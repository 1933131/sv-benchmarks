extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 91 "include/linux/types.h"
typedef unsigned int uint;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 555 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 103
struct compat_timespec;
#line 104 "include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 104 "include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 104
struct pollfd;
#line 104 "include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 104 "include/linux/bug.h"
union __anonunion____missing_field_name_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};
#line 104 "include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_19 __annonCompField8 ;
};
#line 328 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_29 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField12 ;
   struct __anonstruct____missing_field_name_30 __annonCompField13 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_31 __annonCompField15 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 33 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField17 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField18 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_46 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_47 kgid_t;
#line 139 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct vm_area_struct;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 177
struct rw_semaphore;
#line 178 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 172 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 296 "include/linux/rcupdate.h"
struct notifier_block;
#line 1121 "include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 242 "include/linux/timer.h"
struct hrtimer;
#line 243
enum hrtimer_restart;
#line 244 "include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 837 "include/uapi/linux/sysctl.h"
struct ctl_table;
#line 838
struct nsproxy;
#line 839
struct ctl_table_root;
#line 840
struct ctl_table_header;
#line 841
struct ctl_dir;
#line 37 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 57 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 96 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 117 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 122 "include/linux/sysctl.h"
struct __anonstruct____missing_field_name_50 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 122 "include/linux/sysctl.h"
union __anonunion____missing_field_name_49 {
   struct __anonstruct____missing_field_name_50 __annonCompField19 ;
   struct callback_head rcu ;
};
#line 122
struct ctl_table_set;
#line 122 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_49 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 143 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 149 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 154 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 19 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField33 ;
   struct __anonstruct____missing_field_name_149 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_152 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_156 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_154 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_151 {
   union __anonunion____missing_field_name_152 __annonCompField37 ;
   union __anonunion____missing_field_name_153 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_157 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_158 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_159 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32
struct kmem_cache;
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_160 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct __anonstruct____missing_field_name_151 __annonCompField42 ;
   union __anonunion____missing_field_name_157 __annonCompField45 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
union __anonunion____missing_field_name_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 53 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_166 __annonCompField47 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_172 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_172 __annonCompField49 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_180 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_181 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_197 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_199 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_199 __annonCompField52 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_198 __annonCompField53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion____missing_field_name_201 __annonCompField54 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 72 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1161
struct uts_namespace;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769
struct ftrace_ret_stack;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
struct wiphy;
#line 122
struct wireless_dev;
#line 136
struct usb_interface;
#line 56 "include/linux/prefetch.h"
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203
struct of_device_id;
#line 203
struct acpi_device_id;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 1273 "include/linux/device.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion____missing_field_name_217 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_217 __annonCompField58 ;
   unsigned long nr_segs ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 66
struct bdi_writeback;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 1182 "include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38
struct kiocb;
#line 38 "include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_219 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_219 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_220 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_220 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_221 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_221 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_222 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_222 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_223 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_223 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_224 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_224 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_225 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_225 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_226 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_226 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_227 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_228 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_227 ifr_ifrn ;
   union __anonunion_ifr_ifru_228 ifr_ifru ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_233 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_232 {
   struct __anonstruct____missing_field_name_233 __annonCompField59 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_232 __annonCompField60 ;
};
#line 50 "include/linux/lockref.h"
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_235 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion____missing_field_name_234 {
   struct __anonstruct____missing_field_name_235 __annonCompField61 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_234 __annonCompField62 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_236 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_236 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_240 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_239 {
   struct __anonstruct____missing_field_name_240 __annonCompField63 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_239 __annonCompField64 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 428 "include/linux/radix-tree.h"
struct semaphore {
   raw_spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 47
struct block_device;
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 60 "include/uapi/linux/fs.h"
struct export_operations;
#line 62
struct poll_table_struct;
#line 63
struct kstatfs;
#line 64
struct swap_info_struct;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_244 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_244 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_245 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_245 __annonCompField66 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_248 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_249 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_250 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_248 __annonCompField67 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_249 __annonCompField68 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_250 __annonCompField69 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_251 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_251 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 946
struct net;
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_253 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_252 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_253 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_252 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 18 "./arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 45 "./arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 123 "include/linux/random.h"
enum ldv_23609 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
#line 53 "include/uapi/linux/net.h"
typedef enum ldv_23609 socket_state;
#line 70 "include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
#line 93 "include/linux/net.h"
struct proto_ops;
#line 93 "include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
#line 119 "include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   int (*set_peek_off)(struct sock * , int  ) ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 161 "./arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 187 "include/net/checksum.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 66 "include/linux/netdev_features.h"
union __anonunion_in6_u_268 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 66 "include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_268 in6_u ;
};
#line 46 "include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 218 "include/net/flow_dissector.h"
struct pipe_buf_operations;
#line 218 "include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 27 "include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
#line 61 "include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
#line 86 "include/linux/splice.h"
struct napi_struct;
#line 87 "include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_273 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_274 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};
#line 172 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned char orig_proto ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion____missing_field_name_273 __annonCompField73 ;
   union __anonunion____missing_field_name_274 __annonCompField74 ;
};
#line 189 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 403 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 404 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_277 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 404 "include/linux/skbuff.h"
union __anonunion____missing_field_name_276 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_277 __annonCompField75 ;
};
#line 404 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion____missing_field_name_276 __annonCompField76 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_280 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_279 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_280 __annonCompField77 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_278 {
   struct __anonstruct____missing_field_name_279 __annonCompField78 ;
   struct rb_node rbnode ;
};
#line 457
struct sec_path;
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_282 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_281 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_282 __annonCompField80 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_283 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_284 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_285 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 457 "include/linux/skbuff.h"
struct sk_buff {
   union __anonunion____missing_field_name_278 __annonCompField79 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_281 __annonCompField81 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_283 __annonCompField82 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_284 __annonCompField83 ;
   union __anonunion____missing_field_name_285 __annonCompField84 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 718
struct dst_entry;
#line 34 "include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 189 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 245 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 267 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 293 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 322 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 339 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 438 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 475 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 503 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 605 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 637 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 679 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 712 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 728 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 748 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 759 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 778 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 828 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 999 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 1007 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1083 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 99 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * , u8 const    ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*get_tunable)(struct net_device * , struct ethtool_tunable  const  * , void * ) ;
   int (*set_tunable)(struct net_device * , struct ethtool_tunable  const  * , void const   * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 146 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118
struct proc_dir_entry;
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 179 "include/net/inet_frag.h"
struct ipv4_devconf;
#line 180
struct fib_rules_ops;
#line 181
struct fib_table;
#line 182 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
#line 24 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 29
struct inet_peer_base;
#line 29
struct xt_table;
#line 29 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 113
struct neighbour;
#line 113 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 72 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};
#line 39 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 39
struct rt6_info;
#line 39
struct rt6_statistics;
#line 39
struct fib6_table;
#line 39 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};
#line 85 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 91 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};
#line 20
struct sctp_mib;
#line 21 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 134 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 79 "include/uapi/linux/netfilter.h"
struct nf_logger;
#line 80 "include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 23 "include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 25 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 30 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 44 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 49 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 54 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 65 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 73
struct ip_conntrack_stat;
#line 73
struct nf_ct_event_notifier;
#line 73
struct nf_exp_event_notifier;
#line 73 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 115
struct nft_af_info;
#line 116 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};
#line 465 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 672 "include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 21 "include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 30 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 88
struct mpls_route;
#line 89 "include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
#line 16 "include/net/netns/mpls.h"
struct proc_ns_operations;
#line 17 "include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
#line 11 "include/linux/ns_common.h"
struct net_generic;
#line 12
struct netns_ipvs;
#line 13 "include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 241 "include/net/net_namespace.h"
struct __anonstruct_possible_net_t_302 {
   struct net *net ;
};
#line 241 "include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_302 possible_net_t;
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 650
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
#line 657 "include/linux/mod_devicetable.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
#line 32 "include/linux/of.h"
typedef u32 phandle;
#line 34 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 44 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 338 "include/linux/mii.h"
enum ldv_27839 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
} ;
#line 80 "include/linux/phy.h"
typedef enum ldv_27839 phy_interface_t;
#line 126
enum ldv_27893 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
} ;
#line 133
struct phy_device;
#line 133 "include/linux/phy.h"
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_27893 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};
#line 214
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
#line 229 "include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 323
struct phy_driver;
#line 323 "include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
#line 429 "include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const   *driver_data ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*link_change_notify)(struct phy_device * ) ;
   int (*read_mmd_indirect)(struct phy_device * , int  , int  , int  ) ;
   void (*write_mmd_indirect)(struct phy_device * , int  , int  , int  , u32  ) ;
   int (*module_info)(struct phy_device * , struct ethtool_modinfo * ) ;
   int (*module_eeprom)(struct phy_device * , struct ethtool_eeprom * , u8 * ) ;
   struct device_driver driver ;
};
#line 803 "include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};
#line 25 "include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
} ;
#line 33 "include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};
#line 68 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 84
struct packet_type;
#line 85
struct dsa_switch;
#line 85 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 123
struct dsa_switch_driver;
#line 123 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 194 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   u32 (*get_phy_flags)(struct dsa_switch * , int  ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*adjust_link)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*fixed_link_update)(struct dsa_switch * , int  , struct fixed_phy_status * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
   void (*get_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*suspend)(struct dsa_switch * ) ;
   int (*resume)(struct dsa_switch * ) ;
   int (*port_enable)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*port_disable)(struct dsa_switch * , int  , struct phy_device * ) ;
   int (*set_eee)(struct dsa_switch * , int  , struct phy_device * , struct ethtool_eee * ) ;
   int (*get_eee)(struct dsa_switch * , int  , struct ethtool_eee * ) ;
   int (*get_temp)(struct dsa_switch * , int * ) ;
   int (*get_temp_limit)(struct dsa_switch * , int * ) ;
   int (*set_temp_limit)(struct dsa_switch * , int  ) ;
   int (*get_temp_alarm)(struct dsa_switch * , bool * ) ;
   int (*get_eeprom_len)(struct dsa_switch * ) ;
   int (*get_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_regs_len)(struct dsa_switch * , int  ) ;
   void (*get_regs)(struct dsa_switch * , int  , struct ethtool_regs * , void * ) ;
   int (*port_join_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_leave_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_stp_update)(struct dsa_switch * , int  , u8  ) ;
   int (*fdb_add)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_del)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_getnext)(struct dsa_switch * , int  , unsigned char * , bool * ) ;
};
#line 320 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 87 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
#line 132 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
#line 144 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 164 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 187 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 202 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 236 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_setqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_getqcnstats)(struct net_device * , struct ieee_qcn_stats * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   int (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   int (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 105 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 515 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 1628 "include/linux/security.h"
struct mnt_namespace;
#line 1629
struct ipc_namespace;
#line 1630 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 147 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 106 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 182 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 643 "include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};
#line 16 "include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};
#line 118 "include/uapi/linux/if_bonding.h"
struct netpoll_info;
#line 119
struct wpan_dev;
#line 120
struct mpls_dev;
#line 65 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 110 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 129 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 190
struct neigh_parms;
#line 211 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 216 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 245 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 295 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 340
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 388 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 389 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 537
struct Qdisc;
#line 537 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};
#line 607 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 619 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 631 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 683 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 706 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 719 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 730 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 741 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 757 "include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 770 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_get_vf_stats)(struct net_device * , int  , struct ifla_vf_stats * ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device * , int  , bool  ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  , u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       struct net_device * , int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  , int  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_item_id * ) ;
   int (*ndo_get_phys_port_name)(struct net_device * , char * , size_t  ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff * , struct net_device * ,
                                           netdev_features_t  ) ;
   int (*ndo_set_tx_maxrate)(struct net_device * , int  , u32  ) ;
   int (*ndo_get_iflink)(struct net_device  const  * ) ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_adj_list_315 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_316 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257
struct iw_handler_def;
#line 1257
struct iw_public_data;
#line 1257
struct switchdev_ops;
#line 1257
struct vlan_info;
#line 1257
struct tipc_bearer;
#line 1257
struct in_device;
#line 1257
struct dn_dev;
#line 1257
struct inet6_dev;
#line 1257
struct tcf_proto;
#line 1257
struct cpu_rmap;
#line 1257
struct pcpu_lstats;
#line 1257
struct pcpu_sw_netstats;
#line 1257
struct pcpu_dstats;
#line 1257
struct pcpu_vstats;
#line 1257 "include/linux/netdevice.h"
union __anonunion____missing_field_name_317 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1257
struct garp_port;
#line 1257
struct mrp_port;
#line 1257
struct rtnl_link_ops;
#line 1257 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_315 adj_list ;
   struct __anonstruct_all_adj_list_316 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct switchdev_ops  const  *switchdev_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion____missing_field_name_317 __annonCompField94 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};
#line 1978 "include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   bool (*id_match)(struct packet_type * , struct sock * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
#line 2025 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 470 "include/linux/debugfs.h"
enum nl80211_iftype {
    NL80211_IFTYPE_UNSPECIFIED = 0,
    NL80211_IFTYPE_ADHOC = 1,
    NL80211_IFTYPE_STATION = 2,
    NL80211_IFTYPE_AP = 3,
    NL80211_IFTYPE_AP_VLAN = 4,
    NL80211_IFTYPE_WDS = 5,
    NL80211_IFTYPE_MONITOR = 6,
    NL80211_IFTYPE_MESH_POINT = 7,
    NL80211_IFTYPE_P2P_CLIENT = 8,
    NL80211_IFTYPE_P2P_GO = 9,
    NL80211_IFTYPE_P2P_DEVICE = 10,
    NL80211_IFTYPE_OCB = 11,
    NUM_NL80211_IFTYPES = 12,
    NL80211_IFTYPE_MAX = 11
} ;
#line 2431 "./include/uapi/linux/nl80211.h"
enum nl80211_reg_initiator {
    NL80211_REGDOM_SET_BY_CORE = 0,
    NL80211_REGDOM_SET_BY_USER = 1,
    NL80211_REGDOM_SET_BY_DRIVER = 2,
    NL80211_REGDOM_SET_BY_COUNTRY_IE = 3
} ;
#line 2484
enum nl80211_dfs_regions {
    NL80211_DFS_UNSET = 0,
    NL80211_DFS_FCC = 1,
    NL80211_DFS_ETSI = 2,
    NL80211_DFS_JP = 3
} ;
#line 2491
enum nl80211_user_reg_hint_type {
    NL80211_USER_REG_HINT_USER = 0,
    NL80211_USER_REG_HINT_CELL_BASE = 1,
    NL80211_USER_REG_HINT_INDOOR = 2
} ;
#line 2607
enum nl80211_chan_width {
    NL80211_CHAN_WIDTH_20_NOHT = 0,
    NL80211_CHAN_WIDTH_20 = 1,
    NL80211_CHAN_WIDTH_40 = 2,
    NL80211_CHAN_WIDTH_80 = 3,
    NL80211_CHAN_WIDTH_80P80 = 4,
    NL80211_CHAN_WIDTH_160 = 5,
    NL80211_CHAN_WIDTH_5 = 6,
    NL80211_CHAN_WIDTH_10 = 7
} ;
#line 2618
enum nl80211_bss_scan_width {
    NL80211_BSS_CHAN_WIDTH_20 = 0,
    NL80211_BSS_CHAN_WIDTH_10 = 1,
    NL80211_BSS_CHAN_WIDTH_5 = 2
} ;
#line 2650
enum nl80211_auth_type {
    NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
    NL80211_AUTHTYPE_SHARED_KEY = 1,
    NL80211_AUTHTYPE_FT = 2,
    NL80211_AUTHTYPE_NETWORK_EAP = 3,
    NL80211_AUTHTYPE_SAE = 4,
    __NL80211_AUTHTYPE_NUM = 5,
    NL80211_AUTHTYPE_MAX = 4,
    NL80211_AUTHTYPE_AUTOMATIC = 5
} ;
#line 2668
enum nl80211_mfp {
    NL80211_MFP_NO = 0,
    NL80211_MFP_REQUIRED = 1
} ;
#line 3734 "./include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_seq {
   __u32 start ;
   __u32 offset ;
   __u32 len ;
};
#line 3871 "./include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token {
   __u32 offset ;
   __u32 len ;
   __u8 token_stream[] ;
};
#line 3883 "./include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token_feature {
   __u32 min_len ;
   __u32 max_len ;
   __u32 bufsize ;
};
#line 4131
enum nl80211_dfs_state {
    NL80211_DFS_USABLE = 0,
    NL80211_DFS_UNAVAILABLE = 1,
    NL80211_DFS_AVAILABLE = 2
} ;
#line 4153 "./include/uapi/linux/nl80211.h"
struct nl80211_vendor_cmd_info {
   __u32 vendor_id ;
   __u32 subcmd ;
};
#line 1204 "include/linux/ieee80211.h"
struct ieee80211_mcs_info {
   u8 rx_mask[10U] ;
   __le16 rx_highest ;
   u8 tx_params ;
   u8 reserved[3U] ;
};
#line 1229 "include/linux/ieee80211.h"
struct ieee80211_ht_cap {
   __le16 cap_info ;
   u8 ampdu_params_info ;
   struct ieee80211_mcs_info mcs ;
   __le16 extended_ht_cap_info ;
   __le32 tx_BF_cap_info ;
   u8 antenna_selection_info ;
};
#line 1297 "include/linux/ieee80211.h"
struct ieee80211_ht_operation {
   u8 primary_chan ;
   u8 ht_param ;
   __le16 operation_mode ;
   __le16 stbc_param ;
   u8 basic_set[16U] ;
};
#line 1354 "include/linux/ieee80211.h"
struct ieee80211_vht_mcs_info {
   __le16 rx_mcs_map ;
   __le16 rx_highest ;
   __le16 tx_mcs_map ;
   __le16 tx_highest ;
};
#line 1435 "include/linux/ieee80211.h"
struct ieee80211_vht_cap {
   __le32 vht_cap_info ;
   struct ieee80211_vht_mcs_info supp_mcs ;
};
#line 2547
enum environment_cap {
    ENVIRON_ANY = 0,
    ENVIRON_INDOOR = 1,
    ENVIRON_OUTDOOR = 2
} ;
#line 2553 "include/linux/ieee80211.h"
struct regulatory_request {
   struct callback_head callback_head ;
   int wiphy_idx ;
   enum nl80211_reg_initiator initiator ;
   enum nl80211_user_reg_hint_type user_reg_hint_type ;
   char alpha2[2U] ;
   enum nl80211_dfs_regions dfs_region ;
   bool intersect ;
   bool processed ;
   enum environment_cap country_ie_env ;
   struct list_head list ;
};
#line 99 "include/net/regulatory.h"
struct ieee80211_freq_range {
   u32 start_freq_khz ;
   u32 end_freq_khz ;
   u32 max_bandwidth_khz ;
};
#line 185 "include/net/regulatory.h"
struct ieee80211_power_rule {
   u32 max_antenna_gain ;
   u32 max_eirp ;
};
#line 190 "include/net/regulatory.h"
struct ieee80211_reg_rule {
   struct ieee80211_freq_range freq_range ;
   struct ieee80211_power_rule power_rule ;
   u32 flags ;
   u32 dfs_cac_ms ;
};
#line 197 "include/net/regulatory.h"
struct ieee80211_regdomain {
   struct callback_head callback_head ;
   u32 n_reg_rules ;
   char alpha2[3U] ;
   enum nl80211_dfs_regions dfs_region ;
   struct ieee80211_reg_rule reg_rules[] ;
};
#line 205
enum ieee80211_band {
    IEEE80211_BAND_2GHZ = 0,
    IEEE80211_BAND_5GHZ = 1,
    IEEE80211_BAND_60GHZ = 2,
    IEEE80211_NUM_BANDS = 3
} ;
#line 227 "include/net/regulatory.h"
struct ieee80211_channel {
   enum ieee80211_band band ;
   u16 center_freq ;
   u16 hw_value ;
   u32 flags ;
   int max_antenna_gain ;
   int max_power ;
   int max_reg_power ;
   bool beacon_found ;
   u32 orig_flags ;
   int orig_mag ;
   int orig_mpwr ;
   enum nl80211_dfs_state dfs_state ;
   unsigned long dfs_state_entered ;
   unsigned int dfs_cac_ms ;
};
#line 207 "include/net/cfg80211.h"
struct ieee80211_rate {
   u32 flags ;
   u16 bitrate ;
   u16 hw_value ;
   u16 hw_value_short ;
};
#line 269 "include/net/cfg80211.h"
struct ieee80211_sta_ht_cap {
   u16 cap ;
   bool ht_supported ;
   u8 ampdu_factor ;
   u8 ampdu_density ;
   struct ieee80211_mcs_info mcs ;
};
#line 289 "include/net/cfg80211.h"
struct ieee80211_sta_vht_cap {
   bool vht_supported ;
   u32 cap ;
   struct ieee80211_vht_mcs_info vht_mcs ;
};
#line 305 "include/net/cfg80211.h"
struct ieee80211_supported_band {
   struct ieee80211_channel *channels ;
   struct ieee80211_rate *bitrates ;
   enum ieee80211_band band ;
   int n_channels ;
   int n_bitrates ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
};
#line 387 "include/net/cfg80211.h"
struct cfg80211_chan_def {
   struct ieee80211_channel *chan ;
   enum nl80211_chan_width width ;
   u32 center_freq1 ;
   u32 center_freq2 ;
};
#line 608 "include/net/cfg80211.h"
struct cfg80211_crypto_settings {
   u32 wpa_versions ;
   u32 cipher_group ;
   int n_ciphers_pairwise ;
   u32 ciphers_pairwise[5U] ;
   int n_akm_suites ;
   u32 akm_suites[2U] ;
   bool control_port ;
   __be16 control_port_ethertype ;
   bool control_port_no_encrypt ;
};
#line 671 "include/net/cfg80211.h"
struct mac_address {
   u8 addr[6U] ;
};
#line 1395 "include/net/cfg80211.h"
struct cfg80211_ssid {
   u8 ssid[32U] ;
   u8 ssid_len ;
};
#line 1491 "include/net/cfg80211.h"
struct cfg80211_match_set {
   struct cfg80211_ssid ssid ;
   s32 rssi_thold ;
};
#line 1499 "include/net/cfg80211.h"
struct cfg80211_sched_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u32 interval ;
   u8 const   *ie ;
   size_t ie_len ;
   u32 flags ;
   struct cfg80211_match_set *match_sets ;
   int n_match_sets ;
   s32 min_rssi_thold ;
   u32 delay ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   struct net_device *dev ;
   unsigned long scan_start ;
   struct callback_head callback_head ;
   u32 owner_nlportid ;
   struct ieee80211_channel *channels[0U] ;
};
#line 1561
enum cfg80211_signal_type {
    CFG80211_SIGNAL_TYPE_NONE = 0,
    CFG80211_SIGNAL_TYPE_MBM = 1,
    CFG80211_SIGNAL_TYPE_UNSPEC = 2
} ;
#line 1766 "include/net/cfg80211.h"
struct cfg80211_ibss_params {
   u8 const   *ssid ;
   u8 const   *bssid ;
   struct cfg80211_chan_def chandef ;
   u8 const   *ie ;
   u8 ssid_len ;
   u8 ie_len ;
   u16 beacon_interval ;
   u32 basic_rates ;
   bool channel_fixed ;
   bool privacy ;
   bool control_port ;
   bool userspace_handles_dfs ;
   int mcast_rate[3U] ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
};
#line 1814 "include/net/cfg80211.h"
struct cfg80211_connect_params {
   struct ieee80211_channel *channel ;
   struct ieee80211_channel *channel_hint ;
   u8 const   *bssid ;
   u8 const   *bssid_hint ;
   u8 const   *ssid ;
   size_t ssid_len ;
   enum nl80211_auth_type auth_type ;
   u8 const   *ie ;
   size_t ie_len ;
   bool privacy ;
   enum nl80211_mfp mfp ;
   struct cfg80211_crypto_settings crypto ;
   u8 const   *key ;
   u8 key_len ;
   u8 key_idx ;
   u32 flags ;
   int bg_scan_period ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
};
#line 1916 "include/net/cfg80211.h"
struct cfg80211_pkt_pattern {
   u8 const   *mask ;
   u8 const   *pattern ;
   int pattern_len ;
   int pkt_offset ;
};
#line 1933 "include/net/cfg80211.h"
struct cfg80211_wowlan_tcp {
   struct socket *sock ;
   __be32 src ;
   __be32 dst ;
   u16 src_port ;
   u16 dst_port ;
   u8 dst_mac[6U] ;
   int payload_len ;
   u8 const   *payload ;
   struct nl80211_wowlan_tcp_data_seq payload_seq ;
   u32 data_interval ;
   u32 wake_len ;
   u8 const   *wake_data ;
   u8 const   *wake_mask ;
   u32 tokens_size ;
   struct nl80211_wowlan_tcp_data_token payload_tok ;
};
#line 1968 "include/net/cfg80211.h"
struct cfg80211_wowlan {
   bool any ;
   bool disconnect ;
   bool magic_pkt ;
   bool gtk_rekey_failure ;
   bool eap_identity_req ;
   bool four_way_handshake ;
   bool rfkill_release ;
   struct cfg80211_pkt_pattern *patterns ;
   struct cfg80211_wowlan_tcp *tcp ;
   int n_patterns ;
   struct cfg80211_sched_scan_request *nd_config ;
};
#line 2736 "include/net/cfg80211.h"
struct ieee80211_iface_limit {
   u16 max ;
   u16 types ;
};
#line 2797 "include/net/cfg80211.h"
struct ieee80211_iface_combination {
   struct ieee80211_iface_limit  const  *limits ;
   u32 num_different_channels ;
   u16 max_interfaces ;
   u8 n_limits ;
   bool beacon_int_infra_match ;
   u8 radar_detect_widths ;
   u8 radar_detect_regions ;
};
#line 2869 "include/net/cfg80211.h"
struct ieee80211_txrx_stypes {
   u16 tx ;
   u16 rx ;
};
#line 2885 "include/net/cfg80211.h"
struct wiphy_wowlan_tcp_support {
   struct nl80211_wowlan_tcp_data_token_feature  const  *tok ;
   u32 data_payload_max ;
   u32 data_interval_max ;
   u32 wake_payload_max ;
   bool seq ;
};
#line 2910 "include/net/cfg80211.h"
struct wiphy_wowlan_support {
   u32 flags ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
   int max_nd_match_sets ;
   struct wiphy_wowlan_tcp_support  const  *tcp ;
};
#line 2935 "include/net/cfg80211.h"
struct wiphy_coalesce_support {
   int n_rules ;
   int max_delay ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
};
#line 2960 "include/net/cfg80211.h"
struct wiphy_vendor_command {
   struct nl80211_vendor_cmd_info info ;
   u32 flags ;
   int (*doit)(struct wiphy * , struct wireless_dev * , void const   * , int  ) ;
};
#line 2981 "include/net/cfg80211.h"
struct wiphy {
   u8 perm_addr[6U] ;
   u8 addr_mask[6U] ;
   struct mac_address *addresses ;
   struct ieee80211_txrx_stypes  const  *mgmt_stypes ;
   struct ieee80211_iface_combination  const  *iface_combinations ;
   int n_iface_combinations ;
   u16 software_iftypes ;
   u16 n_addresses ;
   u16 interface_modes ;
   u16 max_acl_mac_addrs ;
   u32 flags ;
   u32 regulatory_flags ;
   u32 features ;
   u8 ext_features[1U] ;
   u32 ap_sme_capa ;
   enum cfg80211_signal_type signal_type ;
   int bss_priv_size ;
   u8 max_scan_ssids ;
   u8 max_sched_scan_ssids ;
   u8 max_match_sets ;
   u16 max_scan_ie_len ;
   u16 max_sched_scan_ie_len ;
   int n_cipher_suites ;
   u32 const   *cipher_suites ;
   u8 retry_short ;
   u8 retry_long ;
   u32 frag_threshold ;
   u32 rts_threshold ;
   u8 coverage_class ;
   char fw_version[32U] ;
   u32 hw_version ;
   struct wiphy_wowlan_support  const  *wowlan ;
   struct cfg80211_wowlan *wowlan_config ;
   u16 max_remain_on_channel_duration ;
   u8 max_num_pmkids ;
   u32 available_antennas_tx ;
   u32 available_antennas_rx ;
   u32 probe_resp_offload ;
   u8 const   *extended_capabilities ;
   u8 const   *extended_capabilities_mask ;
   u8 extended_capabilities_len ;
   void const   *privid ;
   struct ieee80211_supported_band *bands[3U] ;
   void (*reg_notifier)(struct wiphy * , struct regulatory_request * ) ;
   struct ieee80211_regdomain  const  *regd ;
   struct device dev ;
   bool registered ;
   struct dentry *debugfsdir ;
   struct ieee80211_ht_cap  const  *ht_capa_mod_mask ;
   struct ieee80211_vht_cap  const  *vht_capa_mod_mask ;
   possible_net_t _net ;
   struct iw_handler_def  const  *wext ;
   struct wiphy_coalesce_support  const  *coalesce ;
   struct wiphy_vendor_command  const  *vendor_commands ;
   struct nl80211_vendor_cmd_info  const  *vendor_events ;
   int n_vendor_commands ;
   int n_vendor_events ;
   u16 max_ap_assoc_sta ;
   u8 max_num_csa_counters ;
   u8 max_adj_channel_rssi_comp ;
   char priv[0U] ;
};
#line 3369
struct cfg80211_conn;
#line 3370
struct cfg80211_internal_bss;
#line 3371
struct cfg80211_cached_keys;
#line 3372 "include/net/cfg80211.h"
struct __anonstruct_wext_370 {
   struct cfg80211_ibss_params ibss ;
   struct cfg80211_connect_params connect ;
   struct cfg80211_cached_keys *keys ;
   u8 const   *ie ;
   size_t ie_len ;
   u8 bssid[6U] ;
   u8 prev_bssid[6U] ;
   u8 ssid[32U] ;
   s8 default_key ;
   s8 default_mgmt_key ;
   bool prev_bssid_valid ;
};
#line 3372 "include/net/cfg80211.h"
struct wireless_dev {
   struct wiphy *wiphy ;
   enum nl80211_iftype iftype ;
   struct list_head list ;
   struct net_device *netdev ;
   u32 identifier ;
   struct list_head mgmt_registrations ;
   spinlock_t mgmt_registrations_lock ;
   struct mutex mtx ;
   bool use_4addr ;
   bool p2p_started ;
   u8 address[6U] ;
   u8 ssid[32U] ;
   u8 ssid_len ;
   u8 mesh_id_len ;
   u8 mesh_id_up_len ;
   struct cfg80211_conn *conn ;
   struct cfg80211_cached_keys *connect_keys ;
   struct list_head event_list ;
   spinlock_t event_lock ;
   struct cfg80211_internal_bss *current_bss ;
   struct cfg80211_chan_def preset_chandef ;
   struct cfg80211_chan_def chandef ;
   bool ibss_fixed ;
   bool ibss_dfs_possible ;
   bool ps ;
   int ps_timeout ;
   int beacon_interval ;
   u32 ap_unexpected_nlportid ;
   bool cac_started ;
   unsigned long cac_start_time ;
   unsigned int cac_time_ms ;
   u32 owner_nlportid ;
   struct __anonstruct_wext_370 wext ;
};
#line 5215 "include/net/cfg80211.h"
struct rtw_queue {
   struct list_head queue ;
   spinlock_t lock ;
};
#line 107 "drivers/staging/rtl8723au/include/osdep_service.h"
struct wlan_bcn_info {
   u8 encryp_protocol ;
   int group_cipher ;
   int pairwise_cipher ;
   int is_8021x ;
};
#line 68 "drivers/staging/rtl8723au/include/wlan_bssdef.h"
struct wlan_bssid_ex {
   u32 Length ;
   u8 MacAddress[6U] ;
   u16 reserved ;
   struct cfg80211_ssid Ssid ;
   u32 Privacy ;
   long Rssi ;
   u16 beacon_interval ;
   u16 capability ;
   u64 tsf ;
   u32 ATIMWindow ;
   u32 DSConfig ;
   enum nl80211_iftype ifmode ;
   unsigned char SupportedRates[16U] ;
   u8 SignalStrength ;
   u8 SignalQuality ;
   u32 IELength ;
   u8 IEs[768U] ;
};
#line 95 "drivers/staging/rtl8723au/include/wlan_bssdef.h"
struct wlan_network {
   struct list_head list ;
   int network_type ;
   int fixed ;
   unsigned long last_scanned ;
   int join_res ;
   struct wlan_bssid_ex network ;
   struct wlan_bcn_info BcnInfo ;
};
#line 125 "drivers/staging/rtl8723au/include/wlan_bssdef.h"
struct AC_param {
   u8 ACI_AIFSN ;
   u8 CW ;
   __le16 TXOP_limit ;
};
#line 33 "drivers/staging/rtl8723au/include/wifi.h"
struct WMM_para_element {
   unsigned char QoS_info ;
   unsigned char reserved ;
   struct AC_param ac_param[4U] ;
};
#line 39 "drivers/staging/rtl8723au/include/wifi.h"
struct ADDBA_request {
   u8 dialog_token ;
   __le16 BA_para_set ;
   __le16 BA_timeout_value ;
   __le16 BA_starting_seqctrl ;
};
#line 46 "drivers/staging/rtl8723au/include/wifi.h"
struct ht_priv {
   bool ht_option ;
   bool ampdu_enable ;
   u32 tx_amsdu_enable ;
   u32 tx_amdsu_maxlen ;
   u32 rx_ampdu_maxlen ;
   u8 bwmode ;
   u8 ch_offset ;
   u8 sgi ;
   u16 agg_enable_bitmap ;
   u16 candidate_tid_bitmap ;
   struct ieee80211_ht_cap ht_cap ;
};
#line 167 "drivers/staging/rtl8723au/include/ieee80211.h"
struct rtw_ieee80211_channel {
   u16 hw_value ;
   u32 flags ;
};
#line 327
struct registry_priv;
#line 339
struct rtw_adapter;
#line 339 "drivers/staging/rtl8723au/include/ieee80211.h"
struct cmd_obj {
   struct work_struct work ;
   struct rtw_adapter *padapter ;
   u16 cmdcode ;
   int res ;
   u32 cmdsz ;
   u8 *parmbuf ;
   u8 *rsp ;
   u32 rspsz ;
};
#line 43 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct cmd_priv {
   struct workqueue_struct *wq ;
   u32 cmd_issued_cnt ;
   u32 cmd_done_cnt ;
   u32 rsp_cnt ;
   struct rtw_adapter *padapter ;
};
#line 51 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct evt_priv {
   struct workqueue_struct *wq ;
   struct work_struct irq_wk ;
};
#line 58 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct c2h_evt_hdr {
   unsigned char id : 4 ;
   unsigned char plen : 4 ;
   u8 seq ;
   u8 payload[0U] ;
};
#line 74 "drivers/staging/rtl8723au/include/rtw_cmd.h"
union __anonunion_u_371 {
   struct c2h_evt_hdr c2h_evt ;
   u8 buf[16U] ;
};
#line 74 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct evt_work {
   union __anonunion_u_371 u ;
   struct work_struct work ;
   struct rtw_adapter *adapter ;
};
#line 148 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct disconnect_parm {
   u32 deauth_timeout_ms ;
};
#line 169 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct setopmode_parm {
   enum nl80211_iftype mode ;
};
#line 173 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct sitesurvey_parm {
   int scan_mode ;
   u8 ssid_num ;
   u8 ch_num ;
   struct cfg80211_ssid ssid[9U] ;
   struct rtw_ieee80211_channel ch[51U] ;
};
#line 226 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct set_stakey_parm {
   u8 addr[6U] ;
   u8 id ;
   u32 algorithm ;
   u8 key[16U] ;
};
#line 242 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct set_stakey_rsp {
   u8 addr[6U] ;
   u8 keyid ;
   u8 rsvd ;
};
#line 248 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct set_assocsta_parm {
   u8 addr[6U] ;
};
#line 262 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct set_assocsta_rsp {
   u8 cam_id ;
   u8 rsvd[3U] ;
};
#line 454 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct drvextra_cmd_parm {
   int ec_id ;
   int type_size ;
   unsigned char *pbuf ;
};
#line 619 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct addBaReq_parm {
   unsigned int tid ;
   u8 addr[6U] ;
};
#line 733 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct _cmd_callback {
   u32 cmd_code ;
   void (*callback)(struct rtw_adapter * , struct cmd_obj * ) ;
};
#line 109 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct hw_xmit {
   struct rtw_queue *sta_queue ;
   int accnt ;
};
#line 114
struct sta_info;
#line 157 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct submit_ctx {
   u32 timeout_ms ;
   int status ;
   struct completion done ;
};
#line 199
struct urb;
#line 237 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct tx_servq {
   struct list_head tx_pending ;
   struct rtw_queue sta_pending ;
   int qcnt ;
};
#line 243 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct sta_xmit_priv {
   spinlock_t lock ;
   int option ;
   int apsd_setting ;
   struct tx_servq be_q ;
   struct tx_servq bk_q ;
   struct tx_servq vi_q ;
   struct tx_servq vo_q ;
   struct list_head legacy_dz ;
   struct list_head apsd ;
   u16 txseq_tid[16U] ;
};
#line 274 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct xmit_priv {
   spinlock_t lock ;
   struct semaphore xmit_sema ;
   struct semaphore terminate_xmitthread_sema ;
   struct rtw_queue be_pending ;
   struct rtw_queue bk_pending ;
   struct rtw_queue vi_pending ;
   struct rtw_queue vo_pending ;
   struct rtw_queue bm_pending ;
   int free_xmitframe_cnt ;
   struct rtw_queue free_xmit_queue ;
   int free_xframe_ext_cnt ;
   struct rtw_queue free_xframe_ext_queue ;
   uint frag_len ;
   struct rtw_adapter *adapter ;
   u64 tx_bytes ;
   u64 tx_pkts ;
   u64 tx_drop ;
   u64 last_tx_bytes ;
   u64 last_tx_pkts ;
   struct hw_xmit *hwxmits ;
   u8 hwxmit_entry ;
   u8 vcs ;
   u8 nqos_ssn ;
   u8 wmm_para_seq[4U] ;
   struct semaphore tx_retevt ;
   struct tasklet_struct xmit_tasklet ;
   struct rtw_queue free_xmitbuf_queue ;
   struct list_head xmitbuf_list ;
   struct rtw_queue pending_xmitbuf_queue ;
   uint free_xmitbuf_cnt ;
   struct rtw_queue free_xmit_extbuf_queue ;
   struct list_head xmitextbuf_list ;
   uint free_xmit_extbuf_cnt ;
   int ack_tx ;
   struct mutex ack_tx_mutex ;
   struct submit_ctx ack_tx_ops ;
   spinlock_t lock_sctx ;
};
#line 161 "drivers/staging/rtl8723au/include/Hal8723APhyCfg.h"
struct recv_reorder_ctrl {
   struct rtw_adapter *padapter ;
   u8 enable ;
   u16 indicate_seq ;
   u16 wend_b ;
   u8 wsize_b ;
   struct rtw_queue pending_recvframe_queue ;
   struct timer_list reordering_ctrl_timer ;
};
#line 42 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct stainfo_rxcache {
   u16 tid_rxseq[16U] ;
};
#line 71 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct signal_stat {
   u8 update_req ;
   u8 avg_val ;
   u32 total_num ;
   u32 total_val ;
};
#line 161 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct recv_priv {
   spinlock_t lock ;
   struct rtw_queue free_recv_queue ;
   struct rtw_queue recv_pending_queue ;
   struct rtw_queue uc_swdec_pending_queue ;
   int free_recvframe_cnt ;
   struct rtw_adapter *adapter ;
   u32 bIsAnyNonBEPkts ;
   u64 rx_bytes ;
   u64 rx_pkts ;
   u64 rx_drop ;
   u64 last_rx_bytes ;
   uint rx_icv_err ;
   uint rx_largepacket_crcerr ;
   uint rx_smallpacket_crcerr ;
   uint rx_middlepacket_crcerr ;
   u8 rx_pending_cnt ;
   struct urb *int_in_urb ;
   u8 *int_in_buf ;
   struct tasklet_struct irq_prepare_beacon_tasklet ;
   struct tasklet_struct recv_tasklet ;
   struct sk_buff_head free_recv_skb_queue ;
   struct sk_buff_head rx_skb_queue ;
   u8 *precv_buf ;
   s8 rxpwdb ;
   u8 signal_strength ;
   u8 signal_qual ;
   u8 noise ;
   int RxSNRdB[2U] ;
   s8 RxRssi[2U] ;
   int FalseAlmCnt_all ;
   struct timer_list signal_stat_timer ;
   u32 signal_stat_sampling_interval ;
   struct signal_stat signal_qual_data ;
   struct signal_stat signal_strength_data ;
};
#line 217 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct sta_recv_priv {
   spinlock_t lock ;
   int option ;
   struct rtw_queue defrag_q ;
   struct stainfo_rxcache rxcache ;
};
#line 127 "include/net/lib80211.h"
struct __anonstruct__byte__372 {
   u8 TSC0 ;
   u8 TSC1 ;
   u8 TSC2 ;
   u8 TSC3 ;
   u8 TSC4 ;
   u8 TSC5 ;
   u8 TSC6 ;
   u8 TSC7 ;
};
#line 127 "include/net/lib80211.h"
union pn48 {
   u64 val ;
   struct __anonstruct__byte__372 _byte_ ;
};
#line 62 "drivers/staging/rtl8723au/include/rtw_security.h"
union Keytype {
   u8 skey[16U] ;
   u32 lkey[4U] ;
};
#line 85 "drivers/staging/rtl8723au/include/rtw_security.h"
struct rtw_wep_key {
   u8 key[14U] ;
   u16 keylen ;
};
#line 90 "drivers/staging/rtl8723au/include/rtw_security.h"
struct rt_pmkid_list {
   u8 bUsed ;
   u8 Bssid[6U] ;
   u8 PMKID[16U] ;
   u8 SsidBuf[33U] ;
   u8 *ssid_octet ;
   u16 ssid_length ;
};
#line 99 "drivers/staging/rtl8723au/include/rtw_security.h"
struct security_priv {
   u32 dot11AuthAlgrthm ;
   u32 dot11PrivacyAlgrthm ;
   u32 dot11PrivacyKeyIndex ;
   struct rtw_wep_key wep_key[4U] ;
   u32 dot118021XGrpPrivacy ;
   u32 dot118021XGrpKeyid ;
   union Keytype dot118021XGrpKey[4U] ;
   union Keytype dot118021XGrptxmickey[4U] ;
   union Keytype dot118021XGrprxmickey[4U] ;
   union pn48 dot11Grptxpn ;
   union pn48 dot11Grprxpn ;
   unsigned int dot8021xalg ;
   unsigned int wpa_psk ;
   unsigned int wpa_group_cipher ;
   unsigned int wpa2_group_cipher ;
   unsigned int wpa_pairwise_cipher ;
   unsigned int wpa2_pairwise_cipher ;
   u8 wps_ie[256U] ;
   int wps_ie_len ;
   unsigned char binstallGrpkey : 1 ;
   unsigned char busetkipkey : 1 ;
   unsigned char bcheck_grpkey : 1 ;
   unsigned char hw_decrypted : 1 ;
   u32 ndisauthtype ;
   u32 ndisencryptstatus ;
   struct wlan_bssid_ex sec_bss ;
   u8 assoc_info[600U] ;
   u8 szofcapability[256U] ;
   u8 oidassociation[512U] ;
   u8 supplicant_ie[256U] ;
   unsigned long last_mic_err_time ;
   u8 btkip_countermeasure ;
   u8 btkip_wait_report ;
   unsigned long btkip_countermeasure_time ;
   struct rt_pmkid_list PMKIDList[16U] ;
   u8 PMKIDIndex ;
   u8 bWepDefaultKeyIdxSet ;
};
#line 98 "drivers/staging/rtl8723au/include/rtw_pwrctrl.h"
enum rt_rf_power_state {
    rf_on = 0,
    rf_sleep = 1,
    rf_off = 2,
    rf_max = 3
} ;
#line 119 "drivers/staging/rtl8723au/include/rtw_pwrctrl.h"
struct pwrctrl_priv {
   struct semaphore lock ;
   u8 volatile   rpwm ;
   u8 volatile   cpwm ;
   u8 volatile   tog ;
   u8 pwr_mode ;
   u8 smart_ps ;
   u8 bcn_ant_mode ;
   u8 bpower_saving ;
   u8 reg_rfoff ;
   u32 rfoff_reason ;
   u32 cur_ps_level ;
   u32 reg_rfps_level ;
   uint ips_enter23a_cnts ;
   uint ips_leave23a_cnts ;
   u8 ips_mode ;
   u8 ips_mode_req ;
   uint bips_processing ;
   unsigned long ips_deny_time ;
   u8 ps_processing ;
   u8 bLeisurePs ;
   u8 LpsIdleCount ;
   u8 power_mgnt ;
   u8 bFwCurrentInPSMode ;
   unsigned long DelayLPSLastTimeStamp ;
   u8 btcoex_rfon ;
   u8 bInSuspend ;
   u8 bAutoResume ;
   u8 autopm_cnt ;
   u8 bSupportRemoteWakeup ;
   struct timer_list pwr_state_check_timer ;
   int pwr_state_check_interval ;
   u8 pwr_state_check_cnts ;
   enum rt_rf_power_state rf_pwrstate ;
   enum rt_rf_power_state change_rfpwrstate ;
   u8 bkeepfwalive ;
   unsigned long PS_BBRegBackup[4U] ;
};
#line 253 "include/uapi/linux/usb/ch9.h"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
};
#line 275 "include/uapi/linux/usb/ch9.h"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
};
#line 343 "include/uapi/linux/usb/ch9.h"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
};
#line 363 "include/uapi/linux/usb/ch9.h"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
};
#line 613 "include/uapi/linux/usb/ch9.h"
struct usb_ss_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bmAttributes ;
   __le16 wBytesPerInterval ;
};
#line 692 "include/uapi/linux/usb/ch9.h"
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
};
#line 751 "include/uapi/linux/usb/ch9.h"
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
};
#line 801 "include/uapi/linux/usb/ch9.h"
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __le32 bmAttributes ;
};
#line 811 "include/uapi/linux/usb/ch9.h"
struct usb_ss_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wSpeedSupported ;
   __u8 bFunctionalitySupport ;
   __u8 bU1devExitLat ;
   __le16 bU2DevExitLat ;
};
#line 840 "include/uapi/linux/usb/ch9.h"
struct usb_ss_container_id_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bReserved ;
   __u8 ContainerID[16U] ;
};
#line 905
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_WIRELESS = 4,
    USB_SPEED_SUPER = 5
} ;
#line 914
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
#line 282 "include/linux/pm_runtime.h"
struct usb_device;
#line 284
struct wusb_dev;
#line 285
struct ep_device;
#line 286 "include/linux/pm_runtime.h"
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct usb_ss_ep_comp_descriptor ss_ep_comp ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
   int streams ;
};
#line 77 "include/linux/usb.h"
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   int extralen ;
   unsigned char *extra ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
};
#line 92
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
#line 99 "include/linux/usb.h"
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned char sysfs_files_created : 1 ;
   unsigned char ep_devs_created : 1 ;
   unsigned char unregistering : 1 ;
   unsigned char needs_remote_wakeup : 1 ;
   unsigned char needs_altsetting0 : 1 ;
   unsigned char needs_binding : 1 ;
   unsigned char resetting_device : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   atomic_t pm_usage_cnt ;
   struct work_struct reset_ws ;
};
#line 201 "include/linux/usb.h"
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0U] ;
};
#line 256 "include/linux/usb.h"
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16U] ;
   struct usb_interface *interface[32U] ;
   struct usb_interface_cache *intf_cache[32U] ;
   unsigned char *extra ;
   int extralen ;
};
#line 320 "include/linux/usb.h"
struct usb_host_bos {
   struct usb_bos_descriptor *desc ;
   struct usb_ext_cap_descriptor *ext_cap ;
   struct usb_ss_cap_descriptor *ss_cap ;
   struct usb_ss_container_id_descriptor *ss_id ;
};
#line 332 "include/linux/usb.h"
struct usb_devmap {
   unsigned long devicemap[2U] ;
};
#line 344
struct mon_bus;
#line 344 "include/linux/usb.h"
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 uses_pio_for_control ;
   u8 otg_port ;
   unsigned char is_b_host : 1 ;
   unsigned char b_hnp_enable : 1 ;
   unsigned char no_stop_on_short : 1 ;
   unsigned char no_sg_constraint : 1 ;
   unsigned int sg_tablesize ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct usb_bus *hs_companion ;
   struct list_head bus_list ;
   struct mutex usb_address0_mutex ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   unsigned int resuming_ports ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
#line 395
struct usb_tt;
#line 396
enum usb_device_removable {
    USB_DEVICE_REMOVABLE_UNKNOWN = 0,
    USB_DEVICE_REMOVABLE = 1,
    USB_DEVICE_FIXED = 2
} ;
#line 409 "include/linux/usb.h"
struct usb2_lpm_parameters {
   unsigned int besl ;
   int timeout ;
};
#line 430 "include/linux/usb.h"
struct usb3_lpm_parameters {
   unsigned int mel ;
   unsigned int pel ;
   unsigned int sel ;
   int timeout ;
};
#line 469 "include/linux/usb.h"
struct usb_device {
   int devnum ;
   char devpath[16U] ;
   u32 route ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2U] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_bos *bos ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16U] ;
   struct usb_host_endpoint *ep_out[16U] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned char can_submit : 1 ;
   unsigned char persist_enabled : 1 ;
   unsigned char have_langid : 1 ;
   unsigned char authorized : 1 ;
   unsigned char authenticated : 1 ;
   unsigned char wusb : 1 ;
   unsigned char lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_besl_capable : 1 ;
   unsigned char usb2_hw_lpm_enabled : 1 ;
   unsigned char usb2_hw_lpm_allowed : 1 ;
   unsigned char usb3_lpm_enabled : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   int maxchild ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   unsigned long connect_time ;
   unsigned char do_remote_wakeup : 1 ;
   unsigned char reset_resume : 1 ;
   unsigned char port_is_suspended : 1 ;
   struct wusb_dev *wusb_dev ;
   int slot_id ;
   enum usb_device_removable removable ;
   struct usb2_lpm_parameters l1_params ;
   struct usb3_lpm_parameters u1_params ;
   struct usb3_lpm_parameters u2_params ;
   unsigned int lpm_disable_count ;
};
#line 1200 "include/linux/usb.h"
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
#line 1242 "include/linux/usb.h"
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   atomic_t suspend_wakeups ;
   unsigned char poisoned : 1 ;
};
#line 1262 "include/linux/usb.h"
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   unsigned int stream_id ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   struct scatterlist *sg ;
   int num_mapped_sgs ;
   int num_sgs ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0U] ;
};
#line 240 "drivers/staging/rtl8723au/include/rtw_io.h"
struct eeprom_priv {
   u8 mac_addr[6U] ;
   u8 bautoload_fail_flag ;
   u8 bloadfile_fail_flag ;
   u8 bloadmac_fail_flag ;
   u16 channel_plan ;
   u8 EepromOrEfuse ;
   u8 efuse_eeprom_data[512U] ;
};
#line 134 "drivers/staging/rtl8723au/include/rtw_eeprom.h"
struct rtw_wlan_acl_node {
   struct list_head list ;
   u8 addr[6U] ;
   u8 valid ;
};
#line 34 "drivers/staging/rtl8723au/include/sta_info.h"
struct wlan_acl_pool {
   int mode ;
   int num ;
   struct rtw_wlan_acl_node aclnode[16U] ;
   struct rtw_queue acl_node_q ;
};
#line 44 "drivers/staging/rtl8723au/include/sta_info.h"
struct rssi_sta {
   s32 UndecoratedSmoothedPWDB ;
   s32 UndecoratedSmoothedCCK ;
   s32 UndecoratedSmoothedOFDM ;
   u64 PacketMap ;
   u8 ValidBit ;
};
#line 52 "drivers/staging/rtl8723au/include/sta_info.h"
struct stainfo_stats {
   u64 rx_mgnt_pkts ;
   u64 rx_beacon_pkts ;
   u64 rx_probereq_pkts ;
   u64 rx_probersp_pkts ;
   u64 rx_probersp_bm_pkts ;
   u64 rx_probersp_uo_pkts ;
   u64 rx_ctrl_pkts ;
   u64 rx_data_pkts ;
   u64 last_rx_mgnt_pkts ;
   u64 last_rx_beacon_pkts ;
   u64 last_rx_probereq_pkts ;
   u64 last_rx_probersp_pkts ;
   u64 last_rx_probersp_bm_pkts ;
   u64 last_rx_probersp_uo_pkts ;
   u64 last_rx_ctrl_pkts ;
   u64 last_rx_data_pkts ;
   u64 rx_bytes ;
   u64 rx_drops ;
   u64 tx_pkts ;
   u64 tx_bytes ;
   u64 tx_drops ;
};
#line 79 "drivers/staging/rtl8723au/include/sta_info.h"
struct sta_info {
   spinlock_t lock ;
   struct list_head list ;
   struct list_head hash_list ;
   struct rtw_adapter *padapter ;
   struct sta_xmit_priv sta_xmitpriv ;
   struct sta_recv_priv sta_recvpriv ;
   struct rtw_queue sleep_q ;
   unsigned int sleepq_len ;
   uint state ;
   uint aid ;
   uint mac_id ;
   uint qos_option ;
   u8 hwaddr[6U] ;
   uint ieee8021x_blocked ;
   u32 dot118021XPrivacy ;
   union Keytype dot11tkiptxmickey ;
   union Keytype dot11tkiprxmickey ;
   union Keytype dot118021x_UncstKey ;
   union pn48 dot11txpn ;
   union pn48 dot11rxpn ;
   u8 bssrateset[16U] ;
   u32 bssratelen ;
   s32 rssi ;
   s32 signal_quality ;
   u8 cts2self ;
   u8 rtsen ;
   u8 raid ;
   u8 init_rate ;
   u32 ra_mask ;
   u8 wireless_mode ;
   struct stainfo_stats sta_stats ;
   struct timer_list addba_retry_timer ;
   struct recv_reorder_ctrl recvreorder_ctrl[16U] ;
   u16 BA_starting_seqctrl[16U] ;
   struct ht_priv htpriv ;
   struct list_head asoc_list ;
   struct list_head auth_list ;
   unsigned int expire_to ;
   unsigned int auth_seq ;
   unsigned int authalg ;
   unsigned char chg_txt[128U] ;
   u16 capability ;
   int flags ;
   int dot8021xalg ;
   int wpa_psk ;
   int wpa_group_cipher ;
   int wpa2_group_cipher ;
   int wpa_pairwise_cipher ;
   int wpa2_pairwise_cipher ;
   u8 bpairwise_key_installed ;
   u8 wpa_ie[32U] ;
   u8 nonerp_set ;
   u8 no_short_slot_time_set ;
   u8 no_short_preamble_set ;
   u8 no_ht_gf_set ;
   u8 no_ht_set ;
   u8 ht_20mhz_set ;
   unsigned int tx_ra_bitmap ;
   u8 qos_info ;
   u8 max_sp_len ;
   u8 uapsd_bk ;
   u8 uapsd_be ;
   u8 uapsd_vi ;
   u8 uapsd_vo ;
   u8 has_legacy_ac ;
   unsigned int sleepq_ac_len ;
   u8 is_p2p_device ;
   u8 p2p_status_code ;
   u8 keep_alive_trycnt ;
   u8 dev_addr[6U] ;
   u8 dev_cap ;
   u16 config_methods ;
   u8 primary_dev_type[8U] ;
   u8 num_of_secdev_type ;
   u8 secdev_types_list[32U] ;
   u16 dev_name_len ;
   u8 dev_name[32U] ;
   u8 *passoc_req ;
   u32 assoc_req_len ;
   struct rssi_sta rssi_stat ;
   u8 bValid ;
   u8 rssi_level ;
   u8 RSSI_Path[4U] ;
   u8 RSSI_Ave ;
   u8 RXEVM[4U] ;
   u8 RXSNR[4U] ;
   u16 RxMgmtFrameSeqNum ;
};
#line 230 "drivers/staging/rtl8723au/include/sta_info.h"
struct sta_priv {
   spinlock_t sta_hash_lock ;
   struct list_head sta_hash[32U] ;
   int asoc_sta_count ;
   struct rtw_adapter *padapter ;
   struct list_head asoc_list ;
   struct list_head auth_list ;
   spinlock_t asoc_list_lock ;
   spinlock_t auth_list_lock ;
   u8 asoc_list_cnt ;
   u8 auth_list_cnt ;
   unsigned int auth_to ;
   unsigned int assoc_to ;
   unsigned int expire_to ;
   struct sta_info *sta_aid[32U] ;
   u16 sta_dz_bitmap ;
   u16 tim_bitmap ;
   u16 max_num_sta ;
   struct wlan_acl_pool acl_list ;
};
#line 31 "drivers/staging/rtl8723au/include/mlme_osdep.h"
enum rt_scan_type {
    SCAN_PASSIVE = 0,
    SCAN_ACTIVE = 1,
    SCAN_MIX = 2
} ;
#line 43 "drivers/staging/rtl8723au/include/mlme_osdep.h"
struct rt_link_detect {
   u32 NumTxOkInPeriod ;
   u32 NumRxOkInPeriod ;
   u32 NumRxUnicastOkInPeriod ;
   bool bBusyTraffic ;
   bool bTxBusyTraffic ;
   bool bRxBusyTraffic ;
   bool bHigherBusyTraffic ;
   bool bHigherBusyRxTraffic ;
   bool bHigherBusyTxTraffic ;
};
#line 111 "drivers/staging/rtl8723au/include/rtw_mlme.h"
struct mlme_priv {
   spinlock_t lock ;
   int fw_state ;
   u8 bScanInProcess ;
   u8 to_join ;
   u8 to_roaming ;
   struct rtw_adapter *nic_hdl ;
   u8 not_indic_disco ;
   struct rtw_queue scanned_queue ;
   struct cfg80211_ssid assoc_ssid ;
   u8 assoc_bssid[6U] ;
   struct wlan_network cur_network ;
   u32 scan_interval ;
   struct timer_list assoc_timer ;
   uint assoc_by_bssid ;
   uint assoc_by_rssi ;
   struct timer_list scan_to_timer ;
   struct timer_list set_scan_deny_timer ;
   atomic_t set_scan_deny ;
   unsigned int qos_option ;
   int num_sta_no_ht ;
   int num_FortyMHzIntolerant ;
   struct ht_priv htpriv ;
   struct rt_link_detect LinkDetectInfo ;
   struct timer_list dynamic_chk_timer ;
   u8 key_mask ;
   u8 acm_mask ;
   u8 ChannelPlan ;
   enum rt_scan_type scan_mode ;
   u8 *wps_probe_req_ie ;
   u32 wps_probe_req_ie_len ;
   u8 *assoc_req ;
   u32 assoc_req_len ;
   u32 assoc_rsp_len ;
   u8 *assoc_rsp ;
   int num_sta_non_erp ;
   int num_sta_no_short_slot_time ;
   int num_sta_no_short_preamble ;
   int olbc ;
   int num_sta_ht_no_gf ;
   int num_sta_ht_20mhz ;
   int olbc_ht ;
   u16 ht_op_mode ;
   spinlock_t bcn_update_lock ;
   u8 update_bcn ;
};
#line 272 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct ss_res {
   int state ;
   int bss_cnt ;
   int channel_idx ;
   int scan_mode ;
   u8 ssid_num ;
   u8 ch_num ;
   struct cfg80211_ssid ssid[9U] ;
   struct rtw_ieee80211_channel ch[51U] ;
};
#line 283 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct FW_Sta_Info {
   struct sta_info *psta ;
   u32 status ;
   u32 rx_pkt ;
   u32 retry ;
   unsigned char SupportedRates[16U] ;
};
#line 300 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct mlme_ext_info {
   u32 state ;
   u32 reauth_count ;
   u32 reassoc_count ;
   u32 link_count ;
   u32 auth_seq ;
   u32 auth_algo ;
   u32 authModeToggle ;
   u32 enc_algo ;
   u32 key_index ;
   u32 iv ;
   u8 chg_txt[128U] ;
   u16 aid ;
   u16 bcn_interval ;
   u16 capability ;
   u8 assoc_AP_vendor ;
   u8 slotTime ;
   u8 preamble_mode ;
   u8 WMM_enable ;
   u8 ERP_enable ;
   u8 ERP_IE ;
   u8 HT_enable ;
   u8 HT_caps_enable ;
   u8 HT_info_enable ;
   u8 HT_protection ;
   u8 turboMode_cts2self ;
   u8 turboMode_rtsen ;
   u8 SM_PS ;
   u8 ADDBA_retry_count ;
   u8 dialogToken ;
   bool bAcceptAddbaReq ;
   u8 bwmode_updated ;
   u8 hidden_ssid_mode ;
   struct ADDBA_request ADDBA_req ;
   struct WMM_para_element WMM_param ;
   struct ieee80211_ht_cap ht_cap ;
   struct ieee80211_ht_operation HT_info ;
   struct wlan_bssid_ex network ;
   struct FW_Sta_Info FW_sta_info[32U] ;
};
#line 362 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct rt_channel_info {
   u8 ChannelNum ;
   enum rt_scan_type ScanType ;
};
#line 370 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct p2p_reg_class {
   u8 reg_class ;
   u8 channel[20U] ;
   size_t channels ;
};
#line 390 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct p2p_channels {
   struct p2p_reg_class reg_class[10U] ;
   size_t reg_classes ;
};
#line 405 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct mlme_ext_priv {
   struct rtw_adapter *padapter ;
   u8 mlmeext_init ;
   atomic_t event_seq ;
   u16 mgnt_seq ;
   unsigned char cur_channel ;
   unsigned char cur_bwmode ;
   unsigned char cur_ch_offset ;
   unsigned char cur_wireless_mode ;
   unsigned char max_chan_nums ;
   struct rt_channel_info channel_set[38U] ;
   struct p2p_channels channel_list ;
   unsigned char basicrate[13U] ;
   unsigned char datarate[13U] ;
   struct ss_res sitesurvey_res ;
   struct mlme_ext_info mlmext_info ;
   struct timer_list survey_timer ;
   struct timer_list link_timer ;
   u16 chan_scan_time ;
   u8 scan_abort ;
   u8 tx_rate ;
   u32 retry ;
   u64 TSFValue ;
   unsigned char bstart_bss ;
   u8 update_channel_plan_by_ap_done ;
   u8 action_public_dialog_token ;
   u16 action_public_rxseq ;
   u8 active_keep_alive_check ;
};
#line 593 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct cmd_hdl {
   uint parmsize ;
   int (*h2cfuns)(struct rtw_adapter * , u8 const   * ) ;
};
#line 65 "drivers/staging/rtl8723au/include/ioctl_cfg80211.h"
struct registry_priv {
   u8 chip_version ;
   u8 rfintfs ;
   struct cfg80211_ssid ssid ;
   u8 channel ;
   u8 wireless_mode ;
   u8 scan_mode ;
   u8 preamble ;
   u8 vrtl_carrier_sense ;
   u8 vcs_type ;
   u16 rts_thresh ;
   u16 frag_thresh ;
   u8 adhoc_tx_pwr ;
   u8 soft_ap ;
   u8 power_mgnt ;
   u8 ips_mode ;
   u8 smart_ps ;
   u8 long_retry_lmt ;
   u8 short_retry_lmt ;
   u16 busy_thresh ;
   u8 ack_policy ;
   u8 software_encrypt ;
   u8 software_decrypt ;
   u8 acm_method ;
   u8 wmm_enable ;
   u8 uapsd_enable ;
   struct wlan_bssid_ex dev_network ;
   u8 ht_enable ;
   u8 cbw40_enable ;
   u8 ampdu_enable ;
   u8 rx_stbc ;
   u8 ampdu_amsdu ;
   u8 lowrate_two_xmit ;
   u8 rf_config ;
   u8 low_power ;
   u8 wifi_spec ;
   u8 channel_plan ;
   u8 btcoex ;
   u8 bt_iso ;
   u8 bt_sco ;
   u8 bt_ampdu ;
   bool bAcceptAddbaReq ;
   u8 antdiv_cfg ;
   u8 antdiv_type ;
   u8 hwpdn_mode ;
   u8 hwpwrp_detect ;
   u8 hw_wps_pbc ;
   u8 max_roaming_times ;
   u8 enable80211d ;
   u8 ifname[16U] ;
   u8 if2name[16U] ;
   u8 notch_filter ;
   u8 regulatory_tid ;
};
#line 137 "drivers/staging/rtl8723au/include/drv_types.h"
union __anonunion_usb_buf_373 {
   __le32 val32 ;
   __le16 val16 ;
   u8 val8 ;
};
#line 137 "drivers/staging/rtl8723au/include/drv_types.h"
struct dvobj_priv {
   struct rtw_adapter *if1 ;
   struct rtw_adapter *if2 ;
   struct mutex hw_init_mutex ;
   struct mutex h2c_fwcmd_mutex ;
   struct mutex setch_mutex ;
   struct mutex setbw_mutex ;
   unsigned char oper_channel ;
   unsigned char oper_bwmode ;
   unsigned char oper_ch_offset ;
   struct rtw_adapter *padapters[4U] ;
   u8 iface_nums ;
   u8 InterfaceNumber ;
   u8 NumInterfaces ;
   int RtInPipe[2U] ;
   int RtOutPipe[3U] ;
   u8 Queue2Pipe[8U] ;
   u8 nr_endpoint ;
   u8 ishighspeed ;
   u8 RtNumInPipes ;
   u8 RtNumOutPipes ;
   int ep_num[5U] ;
   struct mutex usb_vendor_req_mutex ;
   union __anonunion_usb_buf_373 usb_buf ;
   struct usb_interface *pusbintf ;
   struct usb_device *pusbdev ;
   atomic_t continual_urb_error ;
};
#line 211 "drivers/staging/rtl8723au/include/drv_types.h"
struct rtw_adapter {
   int pid[3U] ;
   int bDongle ;
   u16 chip_type ;
   u16 HardwareType ;
   struct dvobj_priv *dvobj ;
   struct mlme_priv mlmepriv ;
   struct mlme_ext_priv mlmeextpriv ;
   struct cmd_priv cmdpriv ;
   struct evt_priv evtpriv ;
   struct xmit_priv xmitpriv ;
   struct recv_priv recvpriv ;
   struct sta_priv stapriv ;
   struct security_priv securitypriv ;
   struct registry_priv registrypriv ;
   struct pwrctrl_priv pwrctrlpriv ;
   struct eeprom_priv eeprompriv ;
   u32 setband ;
   void *HalData ;
   s32 bDriverStopped ;
   s32 bSurpriseRemoved ;
   s32 bCardDisableWOHSM ;
   u32 IsrContent ;
   u32 ImrContent ;
   u8 EepromAddressSize ;
   u8 hw_init_completed ;
   u8 bDriverIsGoingToUnload ;
   u8 init_adpt_in_progress ;
   u8 bHaltInProgress ;
   struct net_device *pnetdev ;
   int bup ;
   struct net_device_stats stats ;
   struct wireless_dev *rtw_wdev ;
   int net_closed ;
   u8 bFWReady ;
   u8 bReadPortCancel ;
   u8 bWritePortCancel ;
   u8 iface_id ;
};
#line 57 "drivers/staging/rtl8723au/include/rtl8723a_rf.h"
enum rt_media_status;
#line 57
enum rt_media_status;
#line 26 "drivers/staging/rtl8723au/include/odm_RegConfig8723A.h"
enum rt_media_status {
    RT_MEDIA_DISCONNECT = 0,
    RT_MEDIA_CONNECT = 1
} ;
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef bool ldv_func_ret_type;
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef bool ldv_func_ret_type___0;
#line 577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef bool ldv_func_ret_type___1;
#line 596 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 607 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef bool ldv_func_ret_type___3;
#line 618 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef int ldv_func_ret_type___4;
#line 629 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef int ldv_func_ret_type___5;
#line 640 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef int ldv_func_ret_type___6;
#line 651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef int ldv_func_ret_type___7;
#line 662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef int ldv_func_ret_type___8;
#line 673 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef int ldv_func_ret_type___9;
#line 684 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef int ldv_func_ret_type___10;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 247
enum hrtimer_restart;
#line 1428 "include/net/cfg80211.h"
struct cfg80211_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u8 const   *ie ;
   size_t ie_len ;
   u32 flags ;
   u32 rates[3U] ;
   struct wireless_dev *wdev ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   unsigned long scan_start ;
   bool aborted ;
   bool notified ;
   bool no_cck ;
   struct ieee80211_channel *channels[0U] ;
};
#line 192 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct setauth_parm {
   u8 mode ;
   u8 _1x ;
   u8 rsvd[2U] ;
};
#line 206 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct setkey_parm {
   u32 algorithm ;
   u8 keyid ;
   u8 grpkey ;
   u8 set_tx ;
   u8 key[16U] ;
};
#line 114 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct pkt_attrib {
   u16 type ;
   u8 bswenc ;
   u8 dhcp_pkt ;
   u16 ether_type ;
   u16 seqnum ;
   u16 pkt_hdrlen ;
   u16 hdrlen ;
   u32 pktlen ;
   u32 last_txcmdsz ;
   u32 encrypt ;
   u8 nr_frags ;
   u8 iv_len ;
   u8 icv_len ;
   u8 iv[18U] ;
   u8 icv[16U] ;
   u8 priority ;
   u8 ack_policy ;
   u8 mac_id ;
   u8 vcs_mode ;
   u8 dst[6U] ;
   u8 src[6U] ;
   u8 ta[6U] ;
   u8 ra[6U] ;
   u8 key_idx ;
   u8 qos_en ;
   u8 ht_en ;
   u8 raid ;
   u8 bwmode ;
   u8 ch_offset ;
   u8 sgi ;
   u8 ampdu_en ;
   u8 mdata ;
   u8 pctrl ;
   u8 triggered ;
   u8 qsel ;
   u8 eosp ;
   u8 rate ;
   u8 retry_ctrl ;
   struct sta_info *psta ;
};
#line 199 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct xmit_buf {
   struct list_head list ;
   struct list_head list2 ;
   struct rtw_adapter *padapter ;
   u8 *pallocated_buf ;
   u8 *pbuf ;
   void *priv_data ;
   u16 ext_tag ;
   u16 flags ;
   u32 alloc_sz ;
   u32 len ;
   struct submit_ctx *sctx ;
   u32 ff_hwaddr ;
   struct urb *pxmit_urb[8U] ;
   u8 bpending[8U] ;
   int last[8U] ;
};
#line 218 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct xmit_frame {
   struct list_head list ;
   struct pkt_attrib attrib ;
   struct sk_buff *pkt ;
   int frame_tag ;
   struct rtw_adapter *padapter ;
   u8 *buf_addr ;
   struct xmit_buf *pxmitbuf ;
   s8 pkt_offset ;
   u8 ack_report ;
   u8 ext_tag ;
};
#line 315 "drivers/staging/rtl8723au/include/rtw_recv.h"
enum hal_def_variable {
    HAL_DEF_UNDERCORATEDSMOOTHEDPWDB = 0,
    HAL_DEF_IS_SUPPORT_ANT_DIV = 1,
    HAL_DEF_CURRENT_ANTENNA = 2,
    HAL_DEF_DRVINFO_SZ = 3,
    HAL_DEF_MAX_RECVBUF_SZ = 4,
    HAL_DEF_RX_PACKET_OFFSET = 5,
    HAL_DEF_DBG_DUMP_RXPKT = 6,
    HAL_DEF_DBG_DM_FUNC = 7,
    HAL_DEF_RA_DECISION_RATE = 8,
    HAL_DEF_RA_SGI = 9,
    HAL_DEF_PT_PWR_STATUS = 10,
    HW_VAR_MAX_RX_AMPDU_FACTOR = 11,
    HW_DEF_RA_INFO_DUMP = 12,
    HAL_DEF_DBG_DUMP_TXPKT = 13,
    HW_DEF_FA_CNT_DUMP = 14,
    HW_DEF_ODM_DBG_FLAG = 15
} ;
#line 334
enum hal_odm_variable {
    HAL_ODM_STA_INFO = 0,
    HAL_ODM_P2P_STATE = 1,
    HAL_ODM_WIFI_DISPLAY_STATE = 2
} ;
#line 168 "drivers/staging/rtl8723au/include/rtw_debug.h"
struct survey_event {
   struct wlan_bssid_ex *bss ;
};
#line 46 "drivers/staging/rtl8723au/include/rtw_event.h"
struct stassoc_event {
   unsigned char macaddr[6U] ;
   unsigned char rsvd[2U] ;
   int cam_id ;
};
#line 56 "drivers/staging/rtl8723au/include/rtw_event.h"
struct stadel_event {
   unsigned char macaddr[6U] ;
   unsigned char rsvd[2U] ;
   int mac_id ;
};
#line 52 "drivers/staging/rtl8723au/include/rtw_ap.h"
struct rtw_wdev_priv {
   struct wireless_dev *rtw_wdev ;
   struct rtw_adapter *padapter ;
   struct cfg80211_scan_request *scan_request ;
   spinlock_t scan_req_lock ;
   struct net_device *pmon_ndev ;
   char ifname_mon[17U] ;
   u8 p2p_enabled ;
   bool power_mgmt ;
};
#line 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
typedef int ldv_func_ret_type___11;
#line 1007 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
typedef int ldv_func_ret_type___12;
#line 1018 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
typedef int ldv_func_ret_type___13;
#line 36 "include/uapi/linux/types.h"
typedef __u64 __le64;
#line 279 "include/linux/timer.h"
enum hrtimer_restart;
#line 143 "include/linux/ieee80211.h"
struct ieee80211_hdr {
   __le16 frame_control ;
   __le16 duration_id ;
   u8 addr1[6U] ;
   u8 addr2[6U] ;
   u8 addr3[6U] ;
   __le16 seq_ctrl ;
   u8 addr4[6U] ;
};
#line 238 "include/linux/ieee80211.h"
struct ieee80211_qos_hdr {
   __le16 frame_control ;
   __le16 duration_id ;
   u8 addr1[6U] ;
   u8 addr2[6U] ;
   u8 addr3[6U] ;
   __le16 seq_ctrl ;
   __le16 qos_ctrl ;
};
#line 677 "include/linux/ieee80211.h"
struct ieee80211_msrment_ie {
   u8 token ;
   u8 mode ;
   u8 type ;
   u8 request[0U] ;
};
#line 700 "include/linux/ieee80211.h"
struct ieee80211_ext_chansw_ie {
   u8 mode ;
   u8 new_operating_class ;
   u8 new_ch_num ;
   u8 count ;
};
#line 831 "include/linux/ieee80211.h"
struct ieee80211_tpc_report_ie {
   u8 tx_power ;
   u8 link_margin ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_auth_331 {
   __le16 auth_alg ;
   __le16 auth_transaction ;
   __le16 status_code ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_deauth_332 {
   __le16 reason_code ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_assoc_req_333 {
   __le16 capab_info ;
   __le16 listen_interval ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_assoc_resp_334 {
   __le16 capab_info ;
   __le16 status_code ;
   __le16 aid ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_reassoc_resp_335 {
   __le16 capab_info ;
   __le16 status_code ;
   __le16 aid ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_reassoc_req_336 {
   __le16 capab_info ;
   __le16 listen_interval ;
   u8 current_ap[6U] ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_disassoc_337 {
   __le16 reason_code ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_beacon_338 {
   __le64 timestamp ;
   __le16 beacon_int ;
   __le16 capab_info ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_probe_req_339 {
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_probe_resp_340 {
   __le64 timestamp ;
   __le16 beacon_int ;
   __le16 capab_info ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_wme_action_343 {
   u8 action_code ;
   u8 dialog_token ;
   u8 status_code ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_chan_switch_344 {
   u8 action_code ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_ext_chan_switch_345 {
   u8 action_code ;
   struct ieee80211_ext_chansw_ie data ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_measurement_346 {
   u8 action_code ;
   u8 dialog_token ;
   u8 element_id ;
   u8 length ;
   struct ieee80211_msrment_ie msr_elem ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_addba_req_347 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 capab ;
   __le16 timeout ;
   __le16 start_seq_num ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_addba_resp_348 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 status ;
   __le16 capab ;
   __le16 timeout ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_delba_349 {
   u8 action_code ;
   __le16 params ;
   __le16 reason_code ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_self_prot_350 {
   u8 action_code ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_mesh_action_351 {
   u8 action_code ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_sa_query_352 {
   u8 action ;
   u8 trans_id[2U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_ht_smps_353 {
   u8 action ;
   u8 smps_control ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_ht_notify_cw_354 {
   u8 action_code ;
   u8 chanwidth ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_tdls_discover_resp_355 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 capability ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_vht_opmode_notif_356 {
   u8 action_code ;
   u8 operating_mode ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_tpc_report_357 {
   u8 action_code ;
   u8 dialog_token ;
   u8 tpc_elem_id ;
   u8 tpc_elem_length ;
   struct ieee80211_tpc_report_ie tpc ;
};
#line 856 "include/linux/ieee80211.h"
union __anonunion_u_342 {
   struct __anonstruct_wme_action_343 wme_action ;
   struct __anonstruct_chan_switch_344 chan_switch ;
   struct __anonstruct_ext_chan_switch_345 ext_chan_switch ;
   struct __anonstruct_measurement_346 measurement ;
   struct __anonstruct_addba_req_347 addba_req ;
   struct __anonstruct_addba_resp_348 addba_resp ;
   struct __anonstruct_delba_349 delba ;
   struct __anonstruct_self_prot_350 self_prot ;
   struct __anonstruct_mesh_action_351 mesh_action ;
   struct __anonstruct_sa_query_352 sa_query ;
   struct __anonstruct_ht_smps_353 ht_smps ;
   struct __anonstruct_ht_notify_cw_354 ht_notify_cw ;
   struct __anonstruct_tdls_discover_resp_355 tdls_discover_resp ;
   struct __anonstruct_vht_opmode_notif_356 vht_opmode_notif ;
   struct __anonstruct_tpc_report_357 tpc_report ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_action_341 {
   u8 category ;
   union __anonunion_u_342 u ;
};
#line 856 "include/linux/ieee80211.h"
union __anonunion_u_330 {
   struct __anonstruct_auth_331 auth ;
   struct __anonstruct_deauth_332 deauth ;
   struct __anonstruct_assoc_req_333 assoc_req ;
   struct __anonstruct_assoc_resp_334 assoc_resp ;
   struct __anonstruct_reassoc_resp_335 reassoc_resp ;
   struct __anonstruct_reassoc_req_336 reassoc_req ;
   struct __anonstruct_disassoc_337 disassoc ;
   struct __anonstruct_beacon_338 beacon ;
   struct __anonstruct_probe_req_339 probe_req ;
   struct __anonstruct_probe_resp_340 probe_resp ;
   struct __anonstruct_action_341 action ;
};
#line 856 "include/linux/ieee80211.h"
struct ieee80211_mgmt {
   __le16 frame_control ;
   __le16 duration ;
   u8 da[6U] ;
   u8 sa[6U] ;
   u8 bssid[6U] ;
   __le16 seq_ctrl ;
   union __anonunion_u_330 u ;
};
#line 450 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct Tx_Beacon_param {
   struct wlan_bssid_ex network ;
};
#line 624 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct set_ch_parm {
   u8 ch ;
   u8 bw ;
   u8 ch_offset ;
};
#line 631 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct SetChannelPlan_param {
   u8 channel_plan ;
};
#line 636
struct led_8723a;
#line 636 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct LedBlink_param {
   struct led_8723a *pLed ;
};
#line 78 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct phy_info {
   u8 RxPWDBAll ;
   u8 SignalQuality ;
   u8 RxMIMOSignalQuality[2U] ;
   u8 RxMIMOSignalStrength[2U] ;
   s8 RxPower ;
   s8 RecvSignalPower ;
   u8 BTRxRSSIPercentage ;
   u8 SignalStrength ;
   u8 RxPwr[2U] ;
   u8 RxSNR[2U] ;
};
#line 94 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct rx_pkt_attrib {
   u16 pkt_len ;
   u8 physt ;
   u8 drvinfo_sz ;
   u8 shift_sz ;
   u8 hdrlen ;
   u8 amsdu ;
   u8 qos ;
   u8 priority ;
   u8 pw_save ;
   u8 mdata ;
   u16 seq_num ;
   u8 frag_num ;
   u8 mfrag ;
   u8 order ;
   u8 privacy ;
   u8 bdecrypted ;
   u32 encrypt ;
   u8 iv_len ;
   u8 icv_len ;
   u8 crc_err ;
   u8 icv_err ;
   u16 eth_type ;
   u8 dst[6U] ;
   u8 src[6U] ;
   u8 ta[6U] ;
   u8 ra[6U] ;
   u8 bssid[6U] ;
   u8 ack_policy ;
   u8 tcpchk_valid ;
   u8 ip_chkrpt ;
   u8 tcp_chkrpt ;
   u8 key_index ;
   u8 mcs_rate ;
   u8 rxht ;
   u8 sgi ;
   u8 pkt_rpt_type ;
   u32 MacIDValidEntry[2U] ;
   struct phy_info phy_info ;
};
#line 246 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct recv_frame {
   struct list_head list ;
   struct sk_buff *pkt ;
   struct rtw_adapter *adapter ;
   struct rx_pkt_attrib attrib ;
   struct sta_info *psta ;
   struct recv_reorder_ctrl *preorder_ctrl ;
};
#line 27 "drivers/staging/rtl8723au/include/rtw_event.h"
struct surveydone_event {
   unsigned int bss_cnt ;
};
#line 35 "drivers/staging/rtl8723au/include/rtw_event.h"
struct joinbss_event {
   struct wlan_network network ;
};
#line 66 "drivers/staging/rtl8723au/include/rtw_event.h"
struct fwevent {
   u32 parmsize ;
   void (*event_callback)(struct rtw_adapter * , u8 const   * ) ;
};
#line 181 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct rt_channel_plan {
   unsigned char Channel[38U] ;
   unsigned char Len ;
};
#line 204 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct rt_channel_plan_2g {
   unsigned char Channel[14U] ;
   unsigned char Len ;
};
#line 209 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct rt_channel_plan_5g {
   unsigned char Channel[24U] ;
   unsigned char Len ;
};
#line 214 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct rt_channel_plan_map {
   unsigned char Index2G ;
   unsigned char Index5G ;
};
#line 261 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct mlme_handler {
   char *str ;
   int (*func)(struct rtw_adapter * , struct recv_frame * ) ;
};
#line 266 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct action_handler {
   unsigned int num ;
   char *str ;
   int (*func)(struct rtw_adapter * , struct recv_frame * ) ;
};
#line 394
enum hw_mode {
    IEEE80211G = 0,
    IEEE80211A = 1
} ;
#line 399
enum ldv_34415 {
    BW20 = 0,
    BW40PLUS = 1,
    BW40MINUS = 2
} ;
#line 405 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct p2p_oper_class_map {
   enum hw_mode mode ;
   u8 op_class ;
   u8 min_chan ;
   u8 max_chan ;
   u8 inc ;
   enum ldv_34415 bw ;
};
#line 629 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct C2HEvent_Header {
   unsigned short len ;
   unsigned char ID ;
   unsigned char seq ;
   unsigned int rsvd ;
};
#line 881 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
typedef int ldv_func_ret_type___14;
#line 892 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
typedef int ldv_func_ret_type___15;
#line 903 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
typedef int ldv_func_ret_type___16;
#line 914 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
typedef int ldv_func_ret_type___17;
#line 925 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
typedef int ldv_func_ret_type___18;
#line 936 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
typedef int ldv_func_ret_type___19;
#line 947 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
typedef int ldv_func_ret_type___20;
#line 958 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
typedef int ldv_func_ret_type___21;
#line 969 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
typedef int ldv_func_ret_type___22;
#line 980 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
typedef int ldv_func_ret_type___23;
#line 991 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
typedef int ldv_func_ret_type___24;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 243
enum hrtimer_restart;
#line 2893 "include/linux/netdevice.h"
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
} ;
#line 1069 "include/linux/ieee80211.h"
struct ieee80211_pspoll {
   __le16 frame_control ;
   __le16 aid ;
   u8 bssid[6U] ;
   u8 ta[6U] ;
};
#line 231 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct recv_buf {
   struct list_head list ;
   struct rtw_adapter *adapter ;
   struct urb *purb ;
   struct sk_buff *pskb ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 165 "drivers/staging/rtl8723au/include/rtw_security.h"
struct mic_data {
   u32 K0 ;
   u32 K1 ;
   u32 L ;
   u32 R ;
   u32 M ;
   u32 nBytesInM ;
};
#line 273 "drivers/staging/rtl8723au/include/drv_types.h"
struct arc4context {
   u32 x ;
   u32 y ;
   u8 state[256U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 77 "drivers/staging/rtl8723au/include/rtw_rf.h"
enum ht_channel_width {
    HT_CHANNEL_WIDTH_20 = 0,
    HT_CHANNEL_WIDTH_40 = 1,
    HT_CHANNEL_WIDTH_80 = 2,
    HT_CHANNEL_WIDTH_160 = 3,
    HT_CHANNEL_WIDTH_10 = 4
} ;
#line 43 "drivers/staging/rtl8723au/include/xmit_osdep.h"
enum WIRELESS_MODE {
    WIRELESS_MODE_UNKNOWN = 0,
    WIRELESS_MODE_A = 4,
    WIRELESS_MODE_B = 1,
    WIRELESS_MODE_G = 2,
    WIRELESS_MODE_AUTO = 32,
    WIRELESS_MODE_N_24G = 8,
    WIRELESS_MODE_N_5G = 16,
    WIRELESS_MODE_AC = 64
} ;
#line 54 "drivers/staging/rtl8723au/include/xmit_osdep.h"
struct bb_reg_define {
   u32 rfintfs ;
   u32 rfintfi ;
   u32 rfintfo ;
   u32 rfintfe ;
   u32 rf3wireOffset ;
   u32 rfLSSI_Select ;
   u32 rfTxGainStage ;
   u32 rfHSSIPara1 ;
   u32 rfHSSIPara2 ;
   u32 rfSwitchControl ;
   u32 rfAGCControl1 ;
   u32 rfAGCControl2 ;
   u32 rfRxIQImbalance ;
   u32 rfRxAFE ;
   u32 rfTxIQImbalance ;
   u32 rfTxAFE ;
   u32 rfLSSIReadBack ;
   u32 rfLSSIReadBackPi ;
};
#line 113 "drivers/staging/rtl8723au/include/hal_intf.h"
enum hal_ic_type {
    CHIP_8192S = 0,
    CHIP_8188C = 1,
    CHIP_8192C = 2,
    CHIP_8192D = 3,
    CHIP_8723A = 4,
    CHIP_8188E = 5,
    CHIP_8881A = 6,
    CHIP_8812A = 7,
    CHIP_8821A = 8,
    CHIP_8723B = 9,
    CHIP_8192E = 10
} ;
#line 127
enum hal_chip_type {
    TEST_CHIP = 0,
    NORMAL_CHIP = 1,
    FPGA = 2
} ;
#line 133
enum hal_cut_version {
    A_CUT_VERSION = 0,
    B_CUT_VERSION = 1,
    C_CUT_VERSION = 2,
    D_CUT_VERSION = 3,
    E_CUT_VERSION = 4,
    F_CUT_VERSION = 5,
    G_CUT_VERSION = 6
} ;
#line 143
enum hal_vendor {
    CHIP_VENDOR_TSMC = 0,
    CHIP_VENDOR_UMC = 1
} ;
#line 148 "drivers/staging/rtl8723au/include/hal_intf.h"
struct hal_version {
   enum hal_ic_type ICType ;
   enum hal_chip_type ChipType ;
   enum hal_cut_version CUTVersion ;
   enum hal_vendor VendorType ;
   u8 ROMVer ;
};
#line 195 "drivers/staging/rtl8723au/include/rtw_io.h"
enum rt_customer_id {
    RT_CID_DEFAULT = 0,
    RT_CID_8187_ALPHA0 = 1,
    RT_CID_8187_SERCOMM_PS = 2,
    RT_CID_8187_HW_LED = 3,
    RT_CID_8187_NETGEAR = 4,
    RT_CID_WHQL = 5,
    RT_CID_819x_CAMEO = 6,
    RT_CID_819x_RUNTOP = 7,
    RT_CID_819x_Senao = 8,
    RT_CID_TOSHIBA = 9,
    RT_CID_819x_Netcore = 10,
    RT_CID_Nettronix = 11,
    RT_CID_DLINK = 12,
    RT_CID_PRONET = 13,
    RT_CID_COREGA = 14,
    RT_CID_CHINA_MOBILE = 15,
    RT_CID_819x_ALPHA = 16,
    RT_CID_819x_Sitecom = 17,
    RT_CID_CCX = 18,
    RT_CID_819x_Lenovo = 19,
    RT_CID_819x_QMI = 20,
    RT_CID_819x_Edimax_Belkin = 21,
    RT_CID_819x_Sercomm_Belkin = 22,
    RT_CID_819x_CAMEO1 = 23,
    RT_CID_819x_MSI = 24,
    RT_CID_819x_Acer = 25,
    RT_CID_819x_AzWave_ASUS = 26,
    RT_CID_819x_AzWave = 27,
    RT_CID_819x_HP = 28,
    RT_CID_819x_WNC_COREGA = 29,
    RT_CID_819x_Arcadyan_Belkin = 30,
    RT_CID_819x_SAMSUNG = 31,
    RT_CID_819x_CLEVO = 32,
    RT_CID_819x_DELL = 33,
    RT_CID_819x_PRONETS = 34,
    RT_CID_819x_Edimax_ASUS = 35,
    RT_CID_819x_CAMEO_NETGEAR = 36,
    RT_CID_PLANEX = 37,
    RT_CID_CC_C = 38,
    RT_CID_819x_Xavi = 39,
    RT_CID_819x_FUNAI_TV = 40,
    RT_CID_819x_ALPHA_WD = 41
} ;
#line 273 "drivers/staging/rtl8723au/include/drv_types.h"
struct sreset_priv {
   struct mutex silentreset_mutex ;
   u8 silent_reset_inprogress ;
   unsigned long last_tx_time ;
   unsigned long last_tx_complete_time ;
};
#line 28 "drivers/staging/rtl8723au/include/Hal8723UHWImg_CE.h"
struct dig_t {
   u8 Dig_Enable_Flag ;
   u8 Dig_Ext_Port_Stage ;
   int RssiLowThresh ;
   int RssiHighThresh ;
   u32 FALowThresh ;
   u32 FAHighThresh ;
   u8 CurSTAConnectState ;
   u8 PreSTAConnectState ;
   u8 CurMultiSTAConnectState ;
   u8 PreIGValue ;
   u8 CurIGValue ;
   u8 BackupIGValue ;
   s8 BackoffVal ;
   s8 BackoffVal_range_max ;
   s8 BackoffVal_range_min ;
   u8 rx_gain_range_max ;
   u8 rx_gain_range_min ;
   u8 Rssi_val_min ;
   u8 PreCCK_CCAThres ;
   u8 CurCCK_CCAThres ;
   u8 PreCCKPDState ;
   u8 CurCCKPDState ;
   u8 LargeFAHit ;
   u8 ForbiddenIGI ;
   u32 Recover_cnt ;
   u8 DIG_Dynamic_MIN_0 ;
   u8 DIG_Dynamic_MIN_1 ;
   bool bMediaConnect_0 ;
   bool bMediaConnect_1 ;
   u32 RSSI_max ;
};
#line 130 "drivers/staging/rtl8723au/include/odm.h"
struct dynamic_pwr_sav {
   u8 PreCCAState ;
   u8 CurCCAState ;
   u8 PreRFState ;
   u8 CurRFState ;
   int Rssi_val_min ;
   u8 initialize ;
   u32 Reg874 ;
   u32 RegC70 ;
   u32 Reg85C ;
   u32 RegA74 ;
};
#line 143 "drivers/staging/rtl8723au/include/odm.h"
struct false_alarm_stats {
   u32 Cnt_Parity_Fail ;
   u32 Cnt_Rate_Illegal ;
   u32 Cnt_Crc8_fail ;
   u32 Cnt_Mcs_fail ;
   u32 Cnt_Ofdm_fail ;
   u32 Cnt_Cck_fail ;
   u32 Cnt_all ;
   u32 Cnt_Fast_Fsync ;
   u32 Cnt_SB_Search_fail ;
   u32 Cnt_OFDM_CCA ;
   u32 Cnt_CCK_CCA ;
   u32 Cnt_CCA_all ;
   u32 Cnt_BW_USC ;
   u32 Cnt_BW_LSC ;
};
#line 160 "drivers/staging/rtl8723au/include/odm.h"
struct sw_ant_sw {
   u8 try_flag ;
   s32 PreRSSI ;
   u8 CurAntenna ;
   u8 PreAntenna ;
   u8 RSSI_Trying ;
   u8 TestMode ;
   u8 bTriggerAntennaSwitch ;
   u8 SelectAntennaMap ;
   u8 RSSI_target ;
   u8 SWAS_NoLink_State ;
   u32 SWAS_NoLink_BK_Reg860 ;
   bool ANTA_ON ;
   bool ANTB_ON ;
   s32 RSSI_sum_A ;
   s32 RSSI_sum_B ;
   s32 RSSI_cnt_A ;
   s32 RSSI_cnt_B ;
   u64 lastTxOkCnt ;
   u64 lastRxOkCnt ;
   u64 TXByteCnt_A ;
   u64 TXByteCnt_B ;
   u64 RXByteCnt_A ;
   u64 RXByteCnt_B ;
   u8 TrafficLoad ;
};
#line 206 "drivers/staging/rtl8723au/include/odm.h"
struct edca_turbo {
   bool bCurrentTurboEDCA ;
   u32 prv_traffic_idx ;
};
#line 211 "drivers/staging/rtl8723au/include/odm.h"
struct odm_rate_adapt {
   u8 Type ;
   u8 HighRSSIThresh ;
   u8 LowRSSIThresh ;
   u8 RATRState ;
   u32 LastRATR ;
};
#line 219 "drivers/staging/rtl8723au/include/odm.h"
struct odm_phy_dbg_info {
   s8 RxSNRdB[2U] ;
   u64 NumQryPhyStatus ;
   u64 NumQryPhyStatusCCK ;
   u64 NumQryPhyStatusOFDM ;
   s32 RxEVM[2U] ;
};
#line 409 "drivers/staging/rtl8723au/include/odm.h"
struct iqk_matrix_regs_set {
   bool bIQKDone ;
   s32 Value[1U][8U] ;
};
#line 454 "drivers/staging/rtl8723au/include/odm.h"
struct odm_rf_cal_t {
   u32 RegA24 ;
   s32 RegE94 ;
   s32 RegE9C ;
   s32 RegEB4 ;
   s32 RegEBC ;
   u8 TXPowercount ;
   bool bTXPowerTrackingInit ;
   bool bTXPowerTracking ;
   u8 TxPowerTrackControl ;
   u8 TM_Trigger ;
   u8 InternalPA5G[2U] ;
   u8 ThermalMeter[2U] ;
   u8 ThermalValue ;
   u8 ThermalValue_LCK ;
   u8 ThermalValue_IQK ;
   u8 ThermalValue_DPK ;
   u8 ThermalValue_AVG[8U] ;
   u8 ThermalValue_AVG_index ;
   u8 ThermalValue_RxGain ;
   u8 ThermalValue_Crystal ;
   u8 ThermalValue_DPKstore ;
   u8 ThermalValue_DPKtrack ;
   bool TxPowerTrackingInProgress ;
   bool bDPKenable ;
   bool bReloadtxpowerindex ;
   u8 bRfPiEnable ;
   u32 TXPowerTrackingCallbackCnt ;
   u8 bCCKinCH14 ;
   u8 CCK_index ;
   u8 OFDM_index[2U] ;
   bool bDoneTxpower ;
   u8 ThermalValue_HP[8U] ;
   u8 ThermalValue_HP_index ;
   struct iqk_matrix_regs_set IQKMatrixRegSetting[46U] ;
   u8 Delta_IQK ;
   u8 Delta_LCK ;
   u32 RegC04 ;
   u32 Reg874 ;
   u32 RegC08 ;
   u32 RegB68 ;
   u32 RegB6C ;
   u32 Reg870 ;
   u32 Reg860 ;
   u32 Reg864 ;
   bool bIQKInitialized ;
   bool bLCKInProgress ;
   bool bAntennaDetected ;
   u32 ADDA_backup[16U] ;
   u32 IQK_MAC_backup[4U] ;
   u32 IQK_BB_backup_recover[9U] ;
   u32 IQK_BB_backup[9U] ;
   u32 APKoutput[2U][2U] ;
   u8 bAPKdone ;
   u8 bAPKThermalMeterIgnore ;
   u8 bDPdone ;
   u8 bDPPathAOK ;
   u8 bDPPathBOK ;
};
#line 537 "drivers/staging/rtl8723au/include/odm.h"
struct dm_odm_t {
   struct rtw_adapter *Adapter ;
   u64 DebugComponents ;
   u32 DebugLevel ;
   bool bCckHighPower ;
   u8 RFPathRxEnable ;
   u32 SupportAbility ;
   u32 SupportICType ;
   u8 CutVersion ;
   u8 FabVersion ;
   u8 BoardType ;
   u8 ExtLNA ;
   u8 ExtPA ;
   u8 ExtTRSW ;
   bool bInHctTest ;
   bool bWIFITest ;
   bool bDualMacSmartConcurrent ;
   u32 BK_SupportAbility ;
   u8 u8_temp ;
   bool bool_temp ;
   struct rtw_adapter *PADAPTER_temp ;
   bool bWIFI_Direct ;
   bool bWIFI_Display ;
   bool bLinked ;
   u8 RSSI_Min ;
   u8 InterfaceIndex ;
   bool bIsMPChip ;
   bool bOneEntryOnly ;
   bool bBtDisabled ;
   bool bBtHsOperation ;
   u8 btHsDigVal ;
   bool bBtDisableEdcaTurbo ;
   bool bBtBusy ;
   struct sta_info *pODM_StaInfo[32U] ;
   struct odm_phy_dbg_info PhyDbgInfo ;
   struct dig_t DM_DigTable ;
   struct dynamic_pwr_sav DM_PSTable ;
   struct false_alarm_stats FalseAlmCnt ;
   struct false_alarm_stats FlaseAlmCntBuddyAdapter ;
   struct sw_ant_sw DM_SWAT_Table ;
   struct edca_turbo DM_EDCA_Table ;
   u32 WMMEDCA_BE ;
   u8 RSSI_BT ;
   struct odm_rate_adapt RateAdaptive ;
   struct odm_rf_cal_t RFCalibrateInfo ;
};
#line 804
struct hal_data_8723a;
#line 36 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct octet_string {
   u8 *Octet ;
   u16 Length ;
};
#line 86
enum hci_status {
    HCI_STATUS_SUCCESS = 0,
    HCI_STATUS_UNKNOW_HCI_CMD = 1,
    HCI_STATUS_UNKNOW_CONNECT_ID = 2,
    HCI_STATUS_HW_FAIL = 3,
    HCI_STATUS_PAGE_TIMEOUT = 4,
    HCI_STATUS_AUTH_FAIL = 5,
    HCI_STATUS_PIN_OR_KEY_MISSING = 6,
    HCI_STATUS_MEM_CAP_EXCEED = 7,
    HCI_STATUS_CONNECT_TIMEOUT = 8,
    HCI_STATUS_CONNECT_LIMIT = 9,
    HCI_STATUS_SYN_CONNECT_LIMIT = 10,
    HCI_STATUS_ACL_CONNECT_EXISTS = 11,
    HCI_STATUS_CMD_DISALLOW = 12,
    HCI_STATUS_CONNECT_RJT_LIMIT_RESOURCE = 13,
    HCI_STATUS_CONNECT_RJT_SEC_REASON = 14,
    HCI_STATUS_CONNECT_RJT_UNACCEPT_BD_ADDR = 15,
    HCI_STATUS_CONNECT_ACCEPT_TIMEOUT = 16,
    HCI_STATUS_UNSUPPORT_FEATURE_PARA_VALUE = 17,
    HCI_STATUS_INVALID_HCI_CMD_PARA_VALUE = 18,
    HCI_STATUS_REMOTE_USER_TERMINATE_CONNECT = 19,
    HCI_STATUS_REMOTE_DEV_TERMINATE_LOW_RESOURCE = 20,
    HCI_STATUS_REMOTE_DEV_TERMINATE_CONNECT_POWER_OFF = 21,
    HCI_STATUS_CONNECT_TERMINATE_LOCAL_HOST = 22,
    HCI_STATUS_REPEATE_ATTEMPT = 23,
    HCI_STATUS_PAIR_NOT_ALLOW = 24,
    HCI_STATUS_UNKNOW_LMP_PDU = 25,
    HCI_STATUS_UNSUPPORT_REMOTE_LMP_FEATURE = 26,
    HCI_STATUS_SOC_OFFSET_REJECT = 27,
    HCI_STATUS_SOC_INTERVAL_REJECT = 28,
    HCI_STATUS_SOC_AIR_MODE_REJECT = 29,
    HCI_STATUS_INVALID_LMP_PARA = 30,
    HCI_STATUS_UNSPECIFIC_ERROR = 31,
    HCI_STATUS_UNSUPPORT_LMP_PARA_VALUE = 32,
    HCI_STATUS_ROLE_CHANGE_NOT_ALLOW = 33,
    HCI_STATUS_LMP_RESPONSE_TIMEOUT = 34,
    HCI_STATUS_LMP_ERROR_TRANSACTION_COLLISION = 35,
    HCI_STATUS_LMP_PDU_NOT_ALLOW = 36,
    HCI_STATUS_ENCRYPTION_MODE_NOT_ALLOW = 37,
    HCI_STATUS_LINK_KEY_CAN_NOT_CHANGE = 38,
    HCI_STATUS_REQUEST_QOS_NOT_SUPPORT = 39,
    HCI_STATUS_INSTANT_PASSED = 40,
    HCI_STATUS_PAIRING_UNIT_KEY_NOT_SUPPORT = 41,
    HCI_STATUS_DIFFERENT_TRANSACTION_COLLISION = 42,
    HCI_STATUS_RESERVE_1 = 43,
    HCI_STATUS_QOS_UNACCEPT_PARA = 44,
    HCI_STATUS_QOS_REJECT = 45,
    HCI_STATUS_CHNL_CLASSIFICATION_NOT_SUPPORT = 46,
    HCI_STATUS_INSUFFICIENT_SECURITY = 47,
    HCI_STATUS_PARA_OUT_OF_RANGE = 48,
    HCI_STATUS_RESERVE_2 = 49,
    HCI_STATUS_ROLE_SWITCH_PENDING = 50,
    HCI_STATUS_RESERVE_3 = 51,
    HCI_STATUS_RESERVE_SOLT_VIOLATION = 52,
    HCI_STATUS_ROLE_SWITCH_FAIL = 53,
    HCI_STATUS_EXTEND_INQUIRY_RSP_TOO_LARGE = 54,
    HCI_STATUS_SEC_SIMPLE_PAIRING_NOT_SUPPORT = 55,
    HCI_STATUS_HOST_BUSY_PAIRING = 56,
    HCI_STATUS_CONNECT_REJ_NOT_SUIT_CHNL_FOUND = 57,
    HCI_STATUS_CONTROLLER_BUSY = 58
} ;
#line 463
enum amp_btap_type {
    AMP_BTAP_NONE = 0,
    AMP_BTAP_CREATOR = 1,
    AMP_BTAP_JOINER = 2
} ;
#line 517
enum bt_connect_type {
    BT_CONNECT_AUTH_REQ = 0,
    BT_CONNECT_AUTH_RSP = 1,
    BT_CONNECT_ASOC_REQ = 2,
    BT_CONNECT_ASOC_RSP = 3,
    BT_DISCONNECT = 4
} ;
#line 563
enum bt_state_wpa_auth {
    STATE_WPA_AUTH_UNINITIALIZED = 0,
    STATE_WPA_AUTH_WAIT_PACKET_1 = 1,
    STATE_WPA_AUTH_WAIT_PACKET_2 = 2,
    STATE_WPA_AUTH_WAIT_PACKET_3 = 3,
    STATE_WPA_AUTH_WAIT_PACKET_4 = 4,
    STATE_WPA_AUTH_SUCCESSED = 5
} ;
#line 572 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct hci_flow_spec {
   u8 Identifier ;
   u8 ServiceType ;
   u16 MaximumSDUSize ;
   u32 SDUInterArrivalTime ;
   u32 AccessLatency ;
   u32 FlushTimeout ;
};
#line 660 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct hci_log_link_cmd_data {
   u8 BtPhyLinkhandle ;
   u16 BtLogLinkhandle ;
   u8 BtTxFlowSpecID ;
   struct hci_flow_spec Tx_Flow_Spec ;
   struct hci_flow_spec Rx_Flow_Spec ;
   u32 TxPacketCount ;
   u32 BestEffortFlushTimeout ;
   u8 bLLCompleteEventIsSet ;
   u8 bLLCancelCMDIsSetandComplete ;
};
#line 674 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct hci_phy_link_cmd_data {
   u8 BtPhyLinkhandle ;
   u16 LinkSuperversionTimeout ;
   u8 BtAMPKeyLen ;
   u8 BtAMPKeyType ;
   u8 BtAMPKey[32U] ;
};
#line 705 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct amp_assoc_cmd_data {
   u8 BtPhyLinkhandle ;
   u16 LenSoFar ;
   u16 MaxRemoteASSOCLen ;
   u16 AMPAssocRemLen ;
   void *AMPAssocfragment ;
};
#line 718 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct hci_link_info {
   u16 ConnectHandle ;
   u8 IncomingTrafficMode ;
   u8 OutgoingTrafficMode ;
   u8 BTProfile ;
   u8 BTCoreSpec ;
   s8 BT_RSSI ;
   u8 TrafficProfile ;
   u8 linkRole ;
};
#line 729 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct hci_ext_config {
   struct hci_link_info linkInfo[2U] ;
   u8 btOperationCode ;
   u16 CurrentConnectHandle ;
   u8 CurrentIncomingTrafficMode ;
   u8 CurrentOutgoingTrafficMode ;
   s8 MIN_BT_RSSI ;
   u8 NumberOfHandle ;
   u8 NumberOfSCO ;
   u8 CurrentBTStatus ;
   u16 HCIExtensionVer ;
   u8 btProfileCase ;
   u8 btProfileAction ;
   u8 bManualControl ;
   u8 bBTBusy ;
   u8 bBTA2DPBusy ;
   u8 bEnableWifiScanNotify ;
   u8 bHoldForBtOperation ;
   u32 bHoldPeriodCnt ;
};
#line 753 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct hci_acl_packet_data {
   u16 ACLDataPacketLen ;
   u8 SyncDataPacketLen ;
   u16 TotalNumACLDataPackets ;
   u16 TotalSyncNumDataPackets ;
};
#line 760 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct hci_phy_link_bss_info {
   u16 bdCap ;
};
#line 771 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_asoc_entry {
   u8 bUsed ;
   u8 mAssoc ;
   u8 b4waySuccess ;
   u8 Bssid[6U] ;
   struct hci_phy_link_cmd_data PhyLinkCmdData ;
   struct hci_log_link_cmd_data LogLinkCmdData[2U] ;
   struct hci_acl_packet_data ACLPacketsData ;
   struct amp_assoc_cmd_data AmpAsocCmdData ;
   struct octet_string BTSsid ;
   u8 BTSsidBuf[33U] ;
   enum hci_status PhyLinkDisconnectReason ;
   u8 bSendSupervisionPacket ;
   u32 NoRxPktCnt ;
   enum amp_btap_type AMPRole ;
   u8 BtCurrentState ;
   u8 BtNextState ;
   u8 bNeedPhysLinkCompleteEvent ;
   enum hci_status PhysLinkCompleteStatus ;
   u8 BTRemoteMACAddr[6U] ;
   u32 BTCapability ;
   u8 SyncDataPacketLen ;
   u16 TotalSyncNumDataPackets ;
   u16 TotalNumACLDataPackets ;
   u8 ShortRangeMode ;
   u8 PTK[64U] ;
   u8 GTK[32U] ;
   u8 ANonce[32U] ;
   u8 SNonce[32U] ;
   u64 KeyReplayCounter ;
   u8 WPAAuthReplayCount ;
   u8 AESKeyBuf[256U] ;
   u8 PMK[32U] ;
   enum bt_state_wpa_auth BTWPAAuthState ;
   s32 UndecoratedSmoothedPWDB ;
   u8 HwCAMIndex ;
   u8 bPeerQosSta ;
   u32 rxSuvpPktCnt ;
};
#line 833 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_traffic_statistics {
   u8 bTxBusyTraffic ;
   u8 bRxBusyTraffic ;
   u8 bIdle ;
   u32 TxPktCntInPeriod ;
   u32 RxPktCntInPeriod ;
   u64 TxPktLenInPeriod ;
   u64 RxPktLenInPeriod ;
};
#line 843 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_mgnt {
   u8 bBTConnectInProgress ;
   u8 bLogLinkInProgress ;
   u8 bPhyLinkInProgress ;
   u8 bPhyLinkInProgressStartLL ;
   u8 BtCurrentPhyLinkhandle ;
   u16 BtCurrentLogLinkhandle ;
   u8 CurrentConnectEntryNum ;
   u8 DisconnectEntryNum ;
   u8 CurrentBTConnectionCnt ;
   enum bt_connect_type BTCurrentConnectType ;
   enum bt_connect_type BTReceiveConnectPkt ;
   u8 BTAuthCount ;
   u8 BTAsocCount ;
   u8 bStartSendSupervisionPkt ;
   u8 BtOperationOn ;
   u8 BTNeedAMPStatusChg ;
   u8 JoinerNeedSendAuth ;
   struct hci_phy_link_bss_info bssDesc ;
   struct hci_ext_config ExtConfig ;
   u8 bNeedNotifyAMPNoCap ;
   u8 bCreateSpportQos ;
   u8 bSupportProfile ;
   u8 BTChannel ;
   u8 CheckChnlIsSuit ;
   u8 bBtScan ;
   u8 btLogoTest ;
};
#line 872 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_hci_dgb_info {
   u32 hciCmdCnt ;
   u32 hciCmdCntUnknown ;
   u32 hciCmdCntCreatePhyLink ;
   u32 hciCmdCntAcceptPhyLink ;
   u32 hciCmdCntDisconnectPhyLink ;
   u32 hciCmdPhyLinkStatus ;
   u32 hciCmdCntCreateLogLink ;
   u32 hciCmdCntAcceptLogLink ;
   u32 hciCmdCntDisconnectLogLink ;
   u32 hciCmdCntReadLocalAmpAssoc ;
   u32 hciCmdCntWriteRemoteAmpAssoc ;
   u32 hciCmdCntSetAclLinkStatus ;
   u32 hciCmdCntSetScoLinkStatus ;
   u32 hciCmdCntExtensionVersionNotify ;
   u32 hciCmdCntLinkStatusNotify ;
};
#line 890 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_irp_dgb_info {
   u32 irpMJCreate ;
   u32 irpIoControl ;
   u32 irpIoCtrlHciCmd ;
   u32 irpIoCtrlHciEvent ;
   u32 irpIoCtrlHciTxData ;
   u32 irpIoCtrlHciRxData ;
   u32 irpIoCtrlUnknown ;
   u32 irpIoCtrlHciTxData1s ;
};
#line 903 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_packet_dgb_info {
   u32 btPktTxProbReq ;
   u32 btPktRxProbReq ;
   u32 btPktRxProbReqFail ;
   u32 btPktTxProbRsp ;
   u32 btPktRxProbRsp ;
   u32 btPktTxAuth ;
   u32 btPktRxAuth ;
   u32 btPktRxAuthButDrop ;
   u32 btPktTxAssocReq ;
   u32 btPktRxAssocReq ;
   u32 btPktRxAssocReqButDrop ;
   u32 btPktTxAssocRsp ;
   u32 btPktRxAssocRsp ;
   u32 btPktTxDisassoc ;
   u32 btPktRxDisassoc ;
   u32 btPktRxDeauth ;
   u32 btPktTx4way1st ;
   u32 btPktRx4way1st ;
   u32 btPktTx4way2nd ;
   u32 btPktRx4way2nd ;
   u32 btPktTx4way3rd ;
   u32 btPktRx4way3rd ;
   u32 btPktTx4way4th ;
   u32 btPktRx4way4th ;
   u32 btPktTxLinkSuperReq ;
   u32 btPktRxLinkSuperReq ;
   u32 btPktTxLinkSuperRsp ;
   u32 btPktRxLinkSuperRsp ;
   u32 btPktTxData ;
   u32 btPktRxData ;
};
#line 936 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_dgb {
   u8 dbgCtrl ;
   u32 dbgProfile ;
   struct bt_hci_dgb_info dbgHciInfo ;
   struct bt_irp_dgb_info dbgIrpInfo ;
   struct bt_packet_dgb_info dbgBtPkt ;
};
#line 944 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_hci_info {
   u8 BTPalVersion ;
   u16 BTPalCompanyID ;
   u16 BTPalsubversion ;
   u16 BTConnectChnlListLen ;
   u8 BTConnectChnllist[64U] ;
   u16 FailContactCount ;
   u64 BTEventMask ;
   u64 BTEventMaskPage2 ;
   u16 ConnAcceptTimeout ;
   u16 LogicalAcceptTimeout ;
   u16 PageTimeout ;
   u8 LocationDomainAware ;
   u16 LocationDomain ;
   u8 LocationDomainOptions ;
   u8 LocationOptions ;
   u8 FlowControlMode ;
   u16 BtPreChnlListLen ;
   u8 BTPreChnllist[64U] ;
   u16 enFlush_LLH ;
   u16 FLTO_LLH ;
   u8 bInTestMode ;
   u8 bTestIsEnd ;
   u8 bTestNeedReport ;
   u8 TestScenario ;
   u8 TestReportInterval ;
   u8 TestCtrType ;
   u32 TestEventType ;
   u16 TestNumOfFrame ;
   u16 TestNumOfErrFrame ;
   u16 TestNumOfBits ;
   u16 TestNumOfErrBits ;
};
#line 995 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_traffic {
   u8 LastRxUniFragNum ;
   u16 LastRxUniSeqNum ;
   struct bt_traffic_statistics Bt30TrafficStatistics ;
};
#line 1007 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_security {
   struct octet_string RSNIE ;
   u8 RSNIEBuf[256U] ;
   u8 bRegNoEncrypt ;
   u8 bUsedHwEncrypt ;
};
#line 1020 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_30info {
   struct rtw_adapter *padapter ;
   struct bt_asoc_entry BtAsocEntry[2U] ;
   struct bt_mgnt BtMgnt ;
   struct bt_dgb BtDbg ;
   struct bt_hci_info BtHciInfo ;
   struct bt_traffic BtTraffic ;
   struct bt_security BtSec ;
   struct work_struct HCICmdWorkItem ;
   struct timer_list BTHCICmdTimer ;
   struct work_struct BTPsDisableWorkItem ;
   struct work_struct BTConnectWorkItem ;
   struct timer_list BTHCIDiscardAclDataTimer ;
   struct timer_list BTHCIJoinTimeoutTimer ;
   struct timer_list BTTestSendPacketTimer ;
   struct timer_list BTDisconnectPhyLinkTimer ;
   struct timer_list BTBeaconTimer ;
   u8 BTBeaconTmrOn ;
   struct timer_list BTPsDisableTimer ;
   void *pBtChnlList ;
};
#line 1120 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct btdm_8723a_1ant {
   u8 prePsTdma ;
   u8 curPsTdma ;
   u8 psTdmaDuAdjType ;
   u8 bPrePsTdmaOn ;
   u8 bCurPsTdmaOn ;
   u8 preWifiPara ;
   u8 curWifiPara ;
   u8 preCoexWifiCon ;
   u8 curCoexWifiCon ;
   u8 wifiRssiThresh ;
   u32 psTdmaMonitorCnt ;
   u32 psTdmaGlobalCnt ;
   u32 psTdmaMonitorCntForSCO ;
   u8 psTdmaDuAdjTypeForSCO ;
   u8 RSSI_WiFi_Last ;
   u8 RSSI_BT_Last ;
   u8 bWiFiHalt ;
   u8 bRAChanged ;
};
#line 1189 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct btdm_8723a_2ant {
   u8 bPreDecBtPwr ;
   u8 bCurDecBtPwr ;
   u8 preWlanActHi ;
   u8 curWlanActHi ;
   u8 preWlanActLo ;
   u8 curWlanActLo ;
   u8 preFwDacSwingLvl ;
   u8 curFwDacSwingLvl ;
   u8 bPreRfRxLpfShrink ;
   u8 bCurRfRxLpfShrink ;
   u8 bPreLowPenaltyRa ;
   u8 bCurLowPenaltyRa ;
   u8 preBtRetryIndex ;
   u8 curBtRetryIndex ;
   u8 bPreDacSwingOn ;
   u32 preDacSwingLvl ;
   u8 bCurDacSwingOn ;
   u32 curDacSwingLvl ;
   u8 bPreAdcBackOff ;
   u8 bCurAdcBackOff ;
   u8 bPreAgcTableEn ;
   u8 bCurAgcTableEn ;
   u32 preVal0x6c0 ;
   u32 curVal0x6c0 ;
   u32 preVal0x6c8 ;
   u32 curVal0x6c8 ;
   u8 preVal0x6cc ;
   u8 curVal0x6cc ;
   u8 bCurIgnoreWlanAct ;
   u8 bPreIgnoreWlanAct ;
   u8 prePsTdma ;
   u8 curPsTdma ;
   u8 psTdmaDuAdjType ;
   u8 bPrePsTdmaOn ;
   u8 bCurPsTdmaOn ;
   u8 preAlgorithm ;
   u8 curAlgorithm ;
   u8 bResetTdmaAdjust ;
   u8 btStatus ;
};
#line 1249 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_coexist_8723a {
   u32 highPriorityTx ;
   u32 highPriorityRx ;
   u32 lowPriorityTx ;
   u32 lowPriorityRx ;
   u8 btRssi ;
   u8 TotalAntNum ;
   u8 bC2hBtInfoSupport ;
   u8 c2hBtInfo ;
   u8 c2hBtInfoOriginal ;
   u8 prec2hBtInfo ;
   u8 bC2hBtInquiryPage ;
   unsigned long btInqPageStartTime ;
   u8 c2hBtProfile ;
   u8 btRetryCnt ;
   u8 btInfoExt ;
   u8 bC2hBtInfoReqSent ;
   u8 bForceFwBtInfo ;
   u8 bForceA2dpSink ;
   struct btdm_8723a_2ant btdm2Ant ;
   struct btdm_8723a_1ant btdm1Ant ;
};
#line 1372 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_coexist_str {
   u8 BluetoothCoexist ;
   u8 BT_Ant_Num ;
   u8 BT_CoexistType ;
   u8 BT_Ant_isolation ;
   u8 bt_radiosharedtype ;
   u32 Ratio_Tx ;
   u32 Ratio_PRI ;
   u8 bInitlized ;
   u32 BtRfRegOrigin1E ;
   u32 BtRfRegOrigin1F ;
   u8 bBTBusyTraffic ;
   u8 bBTTrafficModeSet ;
   u8 bBTNonTrafficModeSet ;
   struct bt_traffic_statistics BT21TrafficStatistics ;
   u64 CurrentState ;
   u64 PreviousState ;
   u8 preRssiState ;
   u8 preRssiState1 ;
   u8 preRssiStateBeacon ;
   u8 bFWCoexistAllOff ;
   u8 bSWCoexistAllOff ;
   u8 bHWCoexistAllOff ;
   u8 bBalanceOn ;
   u8 bSingleAntOn ;
   u8 bInterruptOn ;
   u8 bMultiNAVOn ;
   u8 PreWLANActH ;
   u8 PreWLANActL ;
   u8 WLANActH ;
   u8 WLANActL ;
   u8 A2DPState ;
   u8 AntennaState ;
   u32 lastBtEdca ;
   u16 last_aggr_num ;
   u8 bEDCAInitialized ;
   u8 exec_cnt ;
   u8 b8723aAgcTableOn ;
   u8 b92DAgcTableOn ;
   struct bt_coexist_8723a halCoex8723 ;
   u8 btActiveZeroCnt ;
   u8 bCurBtDisabled ;
   u8 bPreBtDisabled ;
   u8 bNeedToRoamForBtDisableEnable ;
   u8 fw3aVal[5U] ;
};
#line 1629 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct dm_priv {
   u32 InitODMFlag ;
   int UndecoratedSmoothedPWDB ;
   int UndecoratedSmoothedCCK ;
   int EntryMinUndecoratedSmoothedPWDB ;
   int EntryMaxUndecoratedSmoothedPWDB ;
   int MinUndecoratedPWDBForDM ;
   int LastMinUndecoratedPWDBForDM ;
   s32 UndecoratedSmoothedBeacon ;
   s32 BT_EntryMinUndecoratedSmoothedPWDB ;
   s32 BT_EntryMaxUndecoratedSmoothedPWDB ;
   u8 DynamicTxHighPowerLvl ;
   u8 bTXPowerTracking ;
   u8 TXPowercount ;
   u8 bTXPowerTrackingInit ;
   u8 TxPowerTrackControl ;
   u8 TM_Trigger ;
   u8 ThermalMeter[2U] ;
   u8 ThermalValue ;
   u8 ThermalValue_LCK ;
   u8 ThermalValue_IQK ;
   u8 ThermalValue_DPK ;
   u8 bRfPiEnable ;
   u32 APKoutput[2U][2U] ;
   u8 bAPKdone ;
   u8 bAPKThermalMeterIgnore ;
   u8 bDPdone ;
   u8 bDPPathAOK ;
   u8 bDPPathBOK ;
   u32 RegC04 ;
   u32 Reg874 ;
   u32 RegC08 ;
   u32 RegB68 ;
   u32 RegB6C ;
   u32 Reg870 ;
   u32 Reg860 ;
   u32 Reg864 ;
   u32 ADDA_backup[16U] ;
   u32 IQK_MAC_backup[4U] ;
   u32 IQK_BB_backup_recover[9U] ;
   u32 IQK_BB_backup[9U] ;
   u8 PowerIndex_backup[6U] ;
   u8 bCCKinCH14 ;
   u8 CCK_index ;
   u8 OFDM_index[2U] ;
   u8 bDoneTxpower ;
   u8 CCK_index_HP ;
   u8 OFDM_index_HP[2U] ;
   u8 ThermalValue_HP[8U] ;
   u8 ThermalValue_HP_index ;
   s32 RegE94 ;
   s32 RegE9C ;
   s32 RegEB4 ;
   s32 RegEBC ;
   u32 TXPowerTrackingCallbackCnt ;
   u32 prv_traffic_idx ;
   s32 OFDM_Pkt_Cnt ;
   u8 RSSI_Select ;
   u8 INIDATA_RATE[32U] ;
};
#line 124 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
enum RT_MULTI_FUNC {
    RT_MULTI_FUNC_NONE = 0,
    RT_MULTI_FUNC_WIFI = 1,
    RT_MULTI_FUNC_BT = 2,
    RT_MULTI_FUNC_GPS = 4
} ;
#line 131
enum RT_POLARITY_CTL {
    RT_POLARITY_LOW_ACT = 0,
    RT_POLARITY_HIGH_ACT = 1
} ;
#line 136
enum RT_REGULATOR_MODE {
    RT_SWITCHING_REGULATOR = 0,
    RT_LDO_REGULATOR = 1
} ;
#line 156 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
struct hal_data_8723a {
   struct hal_version VersionID ;
   enum rt_customer_id CustomerID ;
   u16 FirmwareVersion ;
   u16 FirmwareVersionRev ;
   u16 FirmwareSubVersion ;
   u16 FirmwareSignature ;
   u32 ReceiveConfig ;
   enum WIRELESS_MODE CurrentWirelessMode ;
   enum ht_channel_width CurrentChannelBW ;
   u8 CurrentChannel ;
   u8 nCur40MhzPrimeSC ;
   u16 BasicRateSet ;
   u8 rf_type ;
   u8 NumTotalRFPath ;
   u8 BoardType ;
   u8 CrystalCap ;
   u8 EEPROMVersion ;
   u8 EEPROMCustomerID ;
   u8 EEPROMSubCustomerID ;
   u8 EEPROMRegulatory ;
   u8 EEPROMThermalMeter ;
   u8 EEPROMBluetoothCoexist ;
   u8 EEPROMBluetoothType ;
   u8 EEPROMBluetoothAntNum ;
   u8 EEPROMBluetoothAntIsolation ;
   u8 EEPROMBluetoothRadioShared ;
   u8 bTXPowerDataReadFromEEPORM ;
   u8 bAPKThermalMeterIgnore ;
   u8 bIQKInitialized ;
   u8 bAntennaDetected ;
   u8 TxPwrLevelCck[2U][14U] ;
   u8 TxPwrLevelHT40_1S[2U][14U] ;
   u8 TxPwrLevelHT40_2S[2U][14U] ;
   u8 TxPwrHt20Diff[2U][14U] ;
   u8 TxPwrLegacyHtDiff[2U][14U] ;
   u8 PwrGroupHT20[2U][14U] ;
   u8 PwrGroupHT40[2U][14U] ;
   u8 LegacyHTTxPowerDiff ;
   u8 framesync ;
   u32 framesyncC34 ;
   u8 framesyncMonitor ;
   u8 pwrGroupCnt ;
   u32 MCSTxPowerLevelOriginalOffset[7U][16U] ;
   u32 CCKTxPowerLevelOriginalOffset ;
   u32 AntennaTxPath ;
   u32 AntennaRxPath ;
   u8 ExternalPA ;
   u8 bLedOpenDrain ;
   u8 b1x1RecvCombine ;
   u32 AcParam_BE ;
   u8 CurrentCckTxPwrIdx ;
   u8 CurrentOfdm24GTxPwrIdx ;
   struct bb_reg_define PHYRegDef[4U] ;
   bool bRFPathRxEnable[4U] ;
   u32 RfRegChnlVal[2U] ;
   u8 bCckHighPower ;
   bool bRDGEnable ;
   u8 LastHMEBoxNum ;
   u8 RegTxPause ;
   u8 RegFwHwTxQCtrl ;
   u8 RegReg542 ;
   struct dm_priv dmpriv ;
   struct dm_odm_t odmpriv ;
   struct sreset_priv srestpriv ;
   u8 bBTMode ;
   struct bt_30info BtInfo ;
   struct bt_coexist_str bt_coexist ;
   u8 bDumpRxPkt ;
   u8 FwRsvdPageStartOffset ;
   u8 pwrdown ;
   u8 OutEpQueueSel ;
   u8 OutEpNumber ;
   u8 EepromOrEfuse ;
   u16 EfuseUsedBytes ;
   u16 BTEfuseUsedBytes ;
   u32 SysIntrStatus ;
   u32 SysIntrMask ;
   enum RT_MULTI_FUNC MultiFunc ;
   enum RT_POLARITY_CTL PolarityCtl ;
   enum RT_REGULATOR_MODE RegulatorMode ;
   u32 IntArray[2U] ;
   u32 IntrMask[2U] ;
};
#line 251 "include/linux/timer.h"
enum hrtimer_restart;
#line 39 "include/uapi/linux/types.h"
typedef __u16 __sum16;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 116 "include/linux/rtnetlink.h"
struct iphdr {
   unsigned char ihl : 4 ;
   unsigned char version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 278 "drivers/staging/rtl8723au/include/drv_types.h"
struct wlan_pwr_cfg {
   u16 offset ;
   u8 cut_msk ;
   unsigned char fab_msk : 4 ;
   unsigned char interface_msk : 4 ;
   unsigned char base : 4 ;
   unsigned char cmd : 4 ;
   u8 msk ;
   u8 value ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 37 "drivers/staging/rtl8723au/include/xmit_osdep.h"
enum RF_RADIO_PATH {
    RF_PATH_A = 0,
    RF_PATH_B = 1,
    RF_PATH_MAX = 2
} ;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_debug.o.c"
struct va_list;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_debug.o.c"

#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 63 "include/linux/printk.h"
struct va_format {
   char const   *fmt ;
   va_list *va ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 244 "drivers/staging/rtl8723au/include/odm.h"
struct odm_packet_info {
   u8 Rate ;
   u8 StationID ;
   bool bPacketMatchBSSID ;
   bool bPacketToSelf ;
   bool bPacketBeacon ;
};
#line 859 "drivers/staging/rtl8723au/include/odm.h"
struct phy_rx_agc_info {
   unsigned char gain : 7 ;
   unsigned char trsw : 1 ;
};
#line 72 "drivers/staging/rtl8723au/include/odm_HWConfig.h"
struct phy_status_rpt {
   struct phy_rx_agc_info path_agc[2U] ;
   u8 ch_corr[2U] ;
   u8 cck_sig_qual_ofdm_pwdb_all ;
   u8 cck_agc_rpt_ofdm_cfosho_a ;
   u8 cck_rpt_b_ofdm_cfosho_b ;
   u8 rsvd_1 ;
   u8 noise_power_db_msb ;
   u8 path_cfotail[2U] ;
   u8 pcts_mask[2U] ;
   s8 stream_rxevm[2U] ;
   u8 path_rxsnr[2U] ;
   u8 noise_power_db_lsb ;
   u8 rsvd_2[3U] ;
   u8 stream_csi[2U] ;
   u8 stream_target_csi[2U] ;
   s8 sig_evm ;
   u8 rsvd_3 ;
   unsigned char antsel_rx_keep_2 : 1 ;
   unsigned char sgi_en : 1 ;
   unsigned char rxsc : 2 ;
   unsigned char idle_long : 1 ;
   unsigned char r_ant_train_en : 1 ;
   unsigned char ant_sel_b : 1 ;
   unsigned char ant_sel : 1 ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 268 "drivers/staging/rtl8723au/include/odm.h"
enum odm_cmninfo {
    ODM_CMNINFO_MP_TEST_CHIP = 2,
    ODM_CMNINFO_IC_TYPE = 3,
    ODM_CMNINFO_CUT_VER = 4,
    ODM_CMNINFO_FAB_VER = 5,
    ODM_CMNINFO_BOARD_TYPE = 6,
    ODM_CMNINFO_EXT_LNA = 7,
    ODM_CMNINFO_EXT_PA = 8,
    ODM_CMNINFO_EXT_TRSW = 9,
    ODM_CMNINFO_BINHCT_TEST = 10,
    ODM_CMNINFO_BWIFI_TEST = 11,
    ODM_CMNINFO_SMART_CONCURRENT = 12,
    ODM_CMNINFO_MP_MODE = 13,
    ODM_CMNINFO_WIFI_DIRECT = 14,
    ODM_CMNINFO_WIFI_DISPLAY = 15,
    ODM_CMNINFO_LINK = 16,
    ODM_CMNINFO_RSSI_MIN = 17,
    ODM_CMNINFO_DBG_COMP = 18,
    ODM_CMNINFO_DBG_LEVEL = 19,
    ODM_CMNINFO_RA_THRESHOLD_HIGH = 20,
    ODM_CMNINFO_RA_THRESHOLD_LOW = 21,
    ODM_CMNINFO_RF_ANTENNA_TYPE = 22,
    ODM_CMNINFO_BT_DISABLED = 23,
    ODM_CMNINFO_BT_OPERATION = 24,
    ODM_CMNINFO_BT_DIG = 25,
    ODM_CMNINFO_BT_BUSY = 26,
    ODM_CMNINFO_BT_DISABLE_EDCA = 27,
    ODM_CMNINFO_STA_STATUS = 28,
    ODM_CMNINFO_PHY_STATUS = 29,
    ODM_CMNINFO_MAC_STATUS = 30,
    ODM_CMNINFO_MAX = 31
} ;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 60 "drivers/staging/rtl8723au/include/rtl8723a_cmd.h"
struct setpwrmode_parm {
   u8 Mode ;
   u8 SmartPS ;
   u8 AwakeInterval ;
   u8 bAllQueueUAPSD ;
   u8 BcnAntMode ;
};
#line 77 "drivers/staging/rtl8723au/include/rtl8723a_cmd.h"
struct joinbssrpt_parm {
   u8 OpMode ;
};
#line 82 "drivers/staging/rtl8723au/include/rtl8723a_cmd.h"
struct rsvdpage_loc {
   u8 LocProbeRsp ;
   u8 LocPsPoll ;
   u8 LocNullData ;
   u8 LocQosNull ;
   u8 LocBTQosNull ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 816 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct tx_desc {
   __le32 txdw0 ;
   __le32 txdw1 ;
   __le32 txdw2 ;
   __le32 txdw3 ;
   __le32 txdw4 ;
   __le32 txdw5 ;
   __le32 txdw6 ;
   __le32 txdw7 ;
};
#line 116 "drivers/staging/rtl8723au/include/rtw_efuse.h"
struct txpowerinfo {
   u8 CCKIndex[2U][12U] ;
   u8 HT40_1SIndex[2U][12U] ;
   u8 HT40_2SIndexDiff[2U][12U] ;
   u8 HT20IndexDiff[2U][12U] ;
   u8 OFDMIndexDiff[2U][12U] ;
   u8 HT40MaxOffset[2U][12U] ;
   u8 HT20MaxOffset[2U][12U] ;
   u8 TSSI_A[3U] ;
   u8 TSSI_B[3U] ;
   u8 TSSI_A_5G[3U] ;
   u8 TSSI_B_5G[3U] ;
};
#line 169 "drivers/staging/rtl8723au/include/rtl8723a_xmit.h"
struct txrpt_ccx_8723a {
   unsigned char tag1 : 1 ;
   unsigned char rsvd : 4 ;
   unsigned char int_bt : 1 ;
   unsigned char int_tri : 1 ;
   unsigned char int_ccx : 1 ;
   unsigned char mac_id : 5 ;
   unsigned char pkt_drop : 1 ;
   unsigned char pkt_ok : 1 ;
   unsigned char bmc : 1 ;
   unsigned char retry_cnt : 6 ;
   unsigned char lifetime_over : 1 ;
   unsigned char retry_over : 1 ;
   u8 ccx_qtime0 ;
   u8 ccx_qtime1 ;
   u8 final_data_rate ;
   unsigned char sw1 : 4 ;
   unsigned char qsel : 4 ;
   u8 sw0 ;
};
#line 23 "drivers/staging/rtl8723au/include/rtl8723a_sreset.h"
struct rt_8723a_firmware_hdr {
   __le16 Signature ;
   u8 Category ;
   u8 Function ;
   __le16 Version ;
   u8 Subversion ;
   u8 Rsvd1 ;
   u8 Month ;
   u8 Date ;
   u8 Hour ;
   u8 Minute ;
   __le16 RamCodeSize ;
   __le16 Rsvd2 ;
   __le32 SvnIdx ;
   __le32 Rsvd3 ;
   __le32 Rsvd4 ;
   __le32 Rsvd5 ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 142 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct recv_stat {
   __le32 rxdw0 ;
   __le32 rxdw1 ;
   __le32 rxdw2 ;
   __le32 rxdw3 ;
   __le32 rxdw4 ;
   __le32 rxdw5 ;
};
#line 136 "drivers/staging/rtl8723au/include/rtl8723a_dm.h"
struct phy_stat {
   unsigned int phydw0 ;
   unsigned int phydw1 ;
   unsigned int phydw2 ;
   unsigned int phydw3 ;
   unsigned int phydw4 ;
   unsigned int phydw5 ;
   unsigned int phydw6 ;
   unsigned int phydw7 ;
};
#line 406 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
struct rxreport_8723a {
   unsigned short pktlen : 14 ;
   unsigned char crc32 : 1 ;
   unsigned char icverr : 1 ;
   unsigned char drvinfosize : 4 ;
   unsigned char security : 3 ;
   unsigned char qos : 1 ;
   unsigned char shift : 2 ;
   unsigned char physt : 1 ;
   unsigned char swdec : 1 ;
   unsigned char ls : 1 ;
   unsigned char fs : 1 ;
   unsigned char eor : 1 ;
   unsigned char own : 1 ;
   unsigned char macid : 5 ;
   unsigned char tid : 4 ;
   unsigned char hwrsvd : 4 ;
   unsigned char amsdu : 1 ;
   unsigned char paggr : 1 ;
   unsigned char faggr : 1 ;
   unsigned char a1fit : 4 ;
   unsigned char a2fit : 4 ;
   unsigned char pam : 1 ;
   unsigned char pwr : 1 ;
   unsigned char md : 1 ;
   unsigned char mf : 1 ;
   unsigned char type : 2 ;
   unsigned char mc : 1 ;
   unsigned char bc : 1 ;
   unsigned short seq : 12 ;
   unsigned char frag : 4 ;
   unsigned short nextpktlen : 14 ;
   unsigned char nextind : 1 ;
   unsigned char rsvd0831 : 1 ;
   unsigned char rxmcs : 6 ;
   unsigned char rxht : 1 ;
   unsigned char gf : 1 ;
   unsigned char splcp : 1 ;
   unsigned char bw : 1 ;
   unsigned char htc : 1 ;
   unsigned char eosp : 1 ;
   unsigned char bssidfit : 2 ;
   unsigned short rsvd1214 ;
   unsigned char unicastwake : 1 ;
   unsigned char magicwake : 1 ;
   unsigned char pattern0match : 1 ;
   unsigned char pattern1match : 1 ;
   unsigned char pattern2match : 1 ;
   unsigned char pattern3match : 1 ;
   unsigned char pattern4match : 1 ;
   unsigned char pattern5match : 1 ;
   unsigned char pattern6match : 1 ;
   unsigned char pattern7match : 1 ;
   unsigned char pattern8match : 1 ;
   unsigned char pattern9match : 1 ;
   unsigned char patternamatch : 1 ;
   unsigned char patternbmatch : 1 ;
   unsigned char patterncmatch : 1 ;
   unsigned int rsvd1613 : 19 ;
   u32 tsfl ;
   unsigned short bassn : 12 ;
   unsigned char bavld : 1 ;
   unsigned int rsvd2413 : 19 ;
};
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_recv.c"
struct recv_stat_cpu {
   u32 rxdw0 ;
   u32 rxdw1 ;
   u32 rxdw2 ;
   u32 rxdw3 ;
   u32 rxdw4 ;
   u32 rxdw5 ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 345 "drivers/staging/rtl8723au/include/rtw_security.h"
struct reportpwrstate_parm {
   unsigned char mode ;
   unsigned char state ;
   unsigned short rsvd ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
struct station_info;
#line 54
struct cfg80211_pmksa;
#line 76
struct vif_params;
#line 145
struct station_parameters;
#line 37 "include/linux/ip.h"
struct ieee80211_radiotap_header {
   u8 it_version ;
   u8 it_pad ;
   __le16 it_len ;
   __le32 it_present ;
};
#line 500 "include/linux/debugfs.h"
struct nl80211_sta_flag_update {
   __u32 mask ;
   __u32 set ;
};
#line 2524 "./include/uapi/linux/nl80211.h"
enum nl80211_mesh_power_mode {
    NL80211_MESH_POWER_UNKNOWN = 0,
    NL80211_MESH_POWER_ACTIVE = 1,
    NL80211_MESH_POWER_LIGHT_SLEEP = 2,
    NL80211_MESH_POWER_DEEP_SLEEP = 3,
    __NL80211_MESH_POWER_AFTER_LAST = 4,
    NL80211_MESH_POWER_MAX = 3
} ;
#line 2592
enum nl80211_ac {
    NL80211_AC_VO = 0,
    NL80211_AC_VI = 1,
    NL80211_AC_BE = 2,
    NL80211_AC_BK = 3,
    NL80211_NUM_ACS = 4
} ;
#line 3559
enum nl80211_txrate_gi {
    NL80211_TXRATE_DEFAULT_GI = 0,
    NL80211_TXRATE_FORCE_SGI = 1,
    NL80211_TXRATE_FORCE_LGI = 2
} ;
#line 3596
enum nl80211_tx_power_setting {
    NL80211_TX_POWER_AUTOMATIC = 0,
    NL80211_TX_POWER_LIMITED = 1,
    NL80211_TX_POWER_FIXED = 2
} ;
#line 3968
enum nl80211_coalesce_condition {
    NL80211_COALESCE_CONDITION_MATCH = 0,
    NL80211_COALESCE_CONDITION_NO_MATCH = 1
} ;
#line 4021
enum nl80211_hidden_ssid {
    NL80211_HIDDEN_SSID_NOT_IN_USE = 0,
    NL80211_HIDDEN_SSID_ZERO_LEN = 1,
    NL80211_HIDDEN_SSID_ZERO_CONTENTS = 2
} ;
#line 4044
enum nl80211_tdls_operation {
    NL80211_TDLS_DISCOVERY_REQ = 0,
    NL80211_TDLS_SETUP = 1,
    NL80211_TDLS_TEARDOWN = 2,
    NL80211_TDLS_ENABLE_LINK = 3,
    NL80211_TDLS_DISABLE_LINK = 4
} ;
#line 4111
enum nl80211_acl_policy {
    NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED = 0,
    NL80211_ACL_POLICY_DENY_UNLESS_LISTED = 1
} ;
#line 4116
enum nl80211_smps_mode {
    NL80211_SMPS_OFF = 0,
    NL80211_SMPS_STATIC = 1,
    NL80211_SMPS_DYNAMIC = 2,
    __NL80211_SMPS_AFTER_LAST = 3,
    NL80211_SMPS_MAX = 2
} ;
#line 4141
enum nl80211_crit_proto_id {
    NL80211_CRIT_PROTO_UNSPEC = 0,
    NL80211_CRIT_PROTO_DHCP = 1,
    NL80211_CRIT_PROTO_EAPOL = 2,
    NL80211_CRIT_PROTO_APIPA = 3,
    NUM_NL80211_CRIT_PROTO = 4
} ;
#line 332 "include/net/cfg80211.h"
struct vif_params {
   int use_4addr ;
   u8 macaddr[6U] ;
};
#line 366 "include/net/cfg80211.h"
struct key_params {
   u8 const   *key ;
   u8 const   *seq ;
   int key_len ;
   int seq_len ;
   u32 cipher ;
};
#line 561 "include/net/cfg80211.h"
struct survey_info {
   struct ieee80211_channel *channel ;
   u64 time ;
   u64 time_busy ;
   u64 time_ext_busy ;
   u64 time_rx ;
   u64 time_tx ;
   u64 time_scan ;
   u32 filled ;
   s8 noise ;
};
#line 638 "include/net/cfg80211.h"
struct cfg80211_beacon_data {
   u8 const   *head ;
   u8 const   *tail ;
   u8 const   *beacon_ies ;
   u8 const   *proberesp_ies ;
   u8 const   *assocresp_ies ;
   u8 const   *probe_resp ;
   size_t head_len ;
   size_t tail_len ;
   size_t beacon_ies_len ;
   size_t proberesp_ies_len ;
   size_t assocresp_ies_len ;
   size_t probe_resp_len ;
};
#line 675 "include/net/cfg80211.h"
struct cfg80211_acl_data {
   enum nl80211_acl_policy acl_policy ;
   int n_acl_entries ;
   struct mac_address mac_addrs[] ;
};
#line 691 "include/net/cfg80211.h"
struct cfg80211_ap_settings {
   struct cfg80211_chan_def chandef ;
   struct cfg80211_beacon_data beacon ;
   int beacon_interval ;
   int dtim_period ;
   u8 const   *ssid ;
   size_t ssid_len ;
   enum nl80211_hidden_ssid hidden_ssid ;
   struct cfg80211_crypto_settings crypto ;
   bool privacy ;
   enum nl80211_auth_type auth_type ;
   enum nl80211_smps_mode smps_mode ;
   int inactivity_timeout ;
   u8 p2p_ctwindow ;
   bool p2p_opp_ps ;
   struct cfg80211_acl_data  const  *acl ;
};
#line 733 "include/net/cfg80211.h"
struct cfg80211_csa_settings {
   struct cfg80211_chan_def chandef ;
   struct cfg80211_beacon_data beacon_csa ;
   u16 const   *counter_offsets_beacon ;
   u16 const   *counter_offsets_presp ;
   unsigned int n_counter_offsets_beacon ;
   unsigned int n_counter_offsets_presp ;
   struct cfg80211_beacon_data beacon_after ;
   bool radar_required ;
   bool block_tx ;
   u8 count ;
};
#line 768 "include/net/cfg80211.h"
struct station_parameters {
   u8 const   *supported_rates ;
   struct net_device *vlan ;
   u32 sta_flags_mask ;
   u32 sta_flags_set ;
   u32 sta_modify_mask ;
   int listen_interval ;
   u16 aid ;
   u8 supported_rates_len ;
   u8 plink_action ;
   u8 plink_state ;
   struct ieee80211_ht_cap  const  *ht_capa ;
   struct ieee80211_vht_cap  const  *vht_capa ;
   u8 uapsd_queues ;
   u8 max_sp ;
   enum nl80211_mesh_power_mode local_pm ;
   u16 capability ;
   u8 const   *ext_capab ;
   u8 ext_capab_len ;
   u8 const   *supported_channels ;
   u8 supported_channels_len ;
   u8 const   *supported_oper_classes ;
   u8 supported_oper_classes_len ;
   u8 opmode_notif ;
   bool opmode_notif_used ;
};
#line 841 "include/net/cfg80211.h"
struct station_del_parameters {
   u8 const   *mac ;
   u8 subtype ;
   u16 reason_code ;
};
#line 914 "include/net/cfg80211.h"
struct rate_info {
   u8 flags ;
   u8 mcs ;
   u16 legacy ;
   u8 nss ;
   u8 bw ;
};
#line 964 "include/net/cfg80211.h"
struct sta_bss_parameters {
   u8 flags ;
   u8 dtim_period ;
   u16 beacon_interval ;
};
#line 989 "include/net/cfg80211.h"
struct cfg80211_tid_stats {
   u32 filled ;
   u64 rx_msdu ;
   u64 tx_msdu ;
   u64 tx_msdu_retries ;
   u64 tx_msdu_failed ;
};
#line 1007 "include/net/cfg80211.h"
struct station_info {
   u32 filled ;
   u32 connected_time ;
   u32 inactive_time ;
   u64 rx_bytes ;
   u64 tx_bytes ;
   u16 llid ;
   u16 plid ;
   u8 plink_state ;
   s8 signal ;
   s8 signal_avg ;
   u8 chains ;
   s8 chain_signal[4U] ;
   s8 chain_signal_avg[4U] ;
   struct rate_info txrate ;
   struct rate_info rxrate ;
   u32 rx_packets ;
   u32 tx_packets ;
   u32 tx_retries ;
   u32 tx_failed ;
   u32 rx_dropped_misc ;
   struct sta_bss_parameters bss_param ;
   struct nl80211_sta_flag_update sta_flags ;
   int generation ;
   u8 const   *assoc_req_ies ;
   size_t assoc_req_ies_len ;
   u32 beacon_loss_count ;
   s64 t_offset ;
   enum nl80211_mesh_power_mode local_pm ;
   enum nl80211_mesh_power_mode peer_pm ;
   enum nl80211_mesh_power_mode nonpeer_pm ;
   u32 expected_throughput ;
   u64 rx_beacon ;
   u8 rx_beacon_signal_avg ;
   struct cfg80211_tid_stats pertid[17U] ;
};
#line 1136 "include/net/cfg80211.h"
struct mpath_info {
   u32 filled ;
   u32 frame_qlen ;
   u32 sn ;
   u32 metric ;
   u32 exptime ;
   u32 discovery_timeout ;
   u8 discovery_retries ;
   u8 flags ;
   int generation ;
};
#line 1195 "include/net/cfg80211.h"
struct bss_parameters {
   int use_cts_prot ;
   int use_short_preamble ;
   int use_short_slot_time ;
   u8 const   *basic_rates ;
   u8 basic_rates_len ;
   int ap_isolate ;
   int ht_opmode ;
   s8 p2p_ctwindow ;
   s8 p2p_opp_ps ;
};
#line 1226 "include/net/cfg80211.h"
struct mesh_config {
   u16 dot11MeshRetryTimeout ;
   u16 dot11MeshConfirmTimeout ;
   u16 dot11MeshHoldingTimeout ;
   u16 dot11MeshMaxPeerLinks ;
   u8 dot11MeshMaxRetries ;
   u8 dot11MeshTTL ;
   u8 element_ttl ;
   bool auto_open_plinks ;
   u32 dot11MeshNbrOffsetMaxNeighbor ;
   u8 dot11MeshHWMPmaxPREQretries ;
   u32 path_refresh_time ;
   u16 min_discovery_timeout ;
   u32 dot11MeshHWMPactivePathTimeout ;
   u16 dot11MeshHWMPpreqMinInterval ;
   u16 dot11MeshHWMPperrMinInterval ;
   u16 dot11MeshHWMPnetDiameterTraversalTime ;
   u8 dot11MeshHWMPRootMode ;
   u16 dot11MeshHWMPRannInterval ;
   bool dot11MeshGateAnnouncementProtocol ;
   bool dot11MeshForwarding ;
   s32 rssi_threshold ;
   u16 ht_opmode ;
   u32 dot11MeshHWMPactivePathToRootTimeout ;
   u16 dot11MeshHWMProotInterval ;
   u16 dot11MeshHWMPconfirmationInterval ;
   enum nl80211_mesh_power_mode power_mode ;
   u16 dot11MeshAwakeWindowDuration ;
   u32 plink_timeout ;
};
#line 1327 "include/net/cfg80211.h"
struct mesh_setup {
   struct cfg80211_chan_def chandef ;
   u8 const   *mesh_id ;
   u8 mesh_id_len ;
   u8 sync_method ;
   u8 path_sel_proto ;
   u8 path_metric ;
   u8 auth_id ;
   u8 const   *ie ;
   u8 ie_len ;
   bool is_authenticated ;
   bool is_secure ;
   bool user_mpm ;
   u8 dtim_period ;
   u16 beacon_interval ;
   int mcast_rate[3U] ;
   u32 basic_rates ;
};
#line 1367 "include/net/cfg80211.h"
struct ocb_setup {
   struct cfg80211_chan_def chandef ;
};
#line 1377 "include/net/cfg80211.h"
struct ieee80211_txq_params {
   enum nl80211_ac ac ;
   u16 txop ;
   u16 cwmin ;
   u16 cwmax ;
   u8 aifs ;
};
#line 1567 "include/net/cfg80211.h"
struct cfg80211_bss_ies {
   u64 tsf ;
   struct callback_head callback_head ;
   int len ;
   bool from_beacon ;
   u8 data[] ;
};
#line 1590 "include/net/cfg80211.h"
struct cfg80211_bss {
   struct ieee80211_channel *channel ;
   enum nl80211_bss_scan_width scan_width ;
   struct cfg80211_bss_ies  const  *ies ;
   struct cfg80211_bss_ies  const  *beacon_ies ;
   struct cfg80211_bss_ies  const  *proberesp_ies ;
   struct cfg80211_bss *hidden_beacon_bss ;
   s32 signal ;
   u16 beacon_interval ;
   u16 capability ;
   u8 bssid[6U] ;
   u8 priv[0U] ;
};
#line 1648 "include/net/cfg80211.h"
struct cfg80211_auth_request {
   struct cfg80211_bss *bss ;
   u8 const   *ie ;
   size_t ie_len ;
   enum nl80211_auth_type auth_type ;
   u8 const   *key ;
   u8 key_len ;
   u8 key_idx ;
   u8 const   *sae_data ;
   size_t sae_data_len ;
};
#line 1684 "include/net/cfg80211.h"
struct cfg80211_assoc_request {
   struct cfg80211_bss *bss ;
   u8 const   *ie ;
   u8 const   *prev_bssid ;
   size_t ie_len ;
   struct cfg80211_crypto_settings crypto ;
   bool use_mfp ;
   u32 flags ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
};
#line 1724 "include/net/cfg80211.h"
struct cfg80211_deauth_request {
   u8 const   *bssid ;
   u8 const   *ie ;
   size_t ie_len ;
   u16 reason_code ;
   bool local_state_change ;
};
#line 1745 "include/net/cfg80211.h"
struct cfg80211_disassoc_request {
   struct cfg80211_bss *bss ;
   u8 const   *ie ;
   size_t ie_len ;
   u16 reason_code ;
   bool local_state_change ;
};
#line 1882 "include/net/cfg80211.h"
struct __anonstruct_control_369 {
   u32 legacy ;
   u8 ht_mcs[10U] ;
   u16 vht_mcs[8U] ;
   enum nl80211_txrate_gi gi ;
};
#line 1882 "include/net/cfg80211.h"
struct cfg80211_bitrate_mask {
   struct __anonstruct_control_369 control[3U] ;
};
#line 1903 "include/net/cfg80211.h"
struct cfg80211_pmksa {
   u8 const   *bssid ;
   u8 const   *pmkid ;
};
#line 1996 "include/net/cfg80211.h"
struct cfg80211_coalesce_rules {
   int delay ;
   enum nl80211_coalesce_condition condition ;
   struct cfg80211_pkt_pattern *patterns ;
   int n_patterns ;
};
#line 2013 "include/net/cfg80211.h"
struct cfg80211_coalesce {
   struct cfg80211_coalesce_rules *rules ;
   int n_rules ;
};
#line 2086 "include/net/cfg80211.h"
struct cfg80211_gtk_rekey_data {
   u8 const   *kek ;
   u8 const   *kck ;
   u8 const   *replay_ctr ;
};
#line 2096 "include/net/cfg80211.h"
struct cfg80211_update_ft_ies_params {
   u16 md ;
   u8 const   *ie ;
   size_t ie_len ;
};
#line 2111 "include/net/cfg80211.h"
struct cfg80211_mgmt_tx_params {
   struct ieee80211_channel *chan ;
   bool offchan ;
   unsigned int wait ;
   u8 const   *buf ;
   size_t len ;
   bool no_cck ;
   bool dont_wait_for_ack ;
   int n_csa_offsets ;
   u16 const   *csa_offsets ;
};
#line 2138 "include/net/cfg80211.h"
struct cfg80211_dscp_exception {
   u8 dscp ;
   u8 up ;
};
#line 2149 "include/net/cfg80211.h"
struct cfg80211_dscp_range {
   u8 low ;
   u8 high ;
};
#line 2160 "include/net/cfg80211.h"
struct cfg80211_qos_map {
   u8 num_des ;
   struct cfg80211_dscp_exception dscp_exception[21U] ;
   struct cfg80211_dscp_range up[8U] ;
};
#line 2182 "include/net/cfg80211.h"
struct cfg80211_ops {
   int (*suspend)(struct wiphy * , struct cfg80211_wowlan * ) ;
   int (*resume)(struct wiphy * ) ;
   void (*set_wakeup)(struct wiphy * , bool  ) ;
   struct wireless_dev *(*add_virtual_intf)(struct wiphy * , char const   * , unsigned char  ,
                                            enum nl80211_iftype  , u32 * , struct vif_params * ) ;
   int (*del_virtual_intf)(struct wiphy * , struct wireless_dev * ) ;
   int (*change_virtual_intf)(struct wiphy * , struct net_device * , enum nl80211_iftype  ,
                              u32 * , struct vif_params * ) ;
   int (*add_key)(struct wiphy * , struct net_device * , u8  , bool  , u8 const   * ,
                  struct key_params * ) ;
   int (*get_key)(struct wiphy * , struct net_device * , u8  , bool  , u8 const   * ,
                  void * , void (*)(void * , struct key_params * ) ) ;
   int (*del_key)(struct wiphy * , struct net_device * , u8  , bool  , u8 const   * ) ;
   int (*set_default_key)(struct wiphy * , struct net_device * , u8  , bool  , bool  ) ;
   int (*set_default_mgmt_key)(struct wiphy * , struct net_device * , u8  ) ;
   int (*start_ap)(struct wiphy * , struct net_device * , struct cfg80211_ap_settings * ) ;
   int (*change_beacon)(struct wiphy * , struct net_device * , struct cfg80211_beacon_data * ) ;
   int (*stop_ap)(struct wiphy * , struct net_device * ) ;
   int (*add_station)(struct wiphy * , struct net_device * , u8 const   * , struct station_parameters * ) ;
   int (*del_station)(struct wiphy * , struct net_device * , struct station_del_parameters * ) ;
   int (*change_station)(struct wiphy * , struct net_device * , u8 const   * , struct station_parameters * ) ;
   int (*get_station)(struct wiphy * , struct net_device * , u8 const   * , struct station_info * ) ;
   int (*dump_station)(struct wiphy * , struct net_device * , int  , u8 * , struct station_info * ) ;
   int (*add_mpath)(struct wiphy * , struct net_device * , u8 const   * , u8 const   * ) ;
   int (*del_mpath)(struct wiphy * , struct net_device * , u8 const   * ) ;
   int (*change_mpath)(struct wiphy * , struct net_device * , u8 const   * , u8 const   * ) ;
   int (*get_mpath)(struct wiphy * , struct net_device * , u8 * , u8 * , struct mpath_info * ) ;
   int (*dump_mpath)(struct wiphy * , struct net_device * , int  , u8 * , u8 * , struct mpath_info * ) ;
   int (*get_mpp)(struct wiphy * , struct net_device * , u8 * , u8 * , struct mpath_info * ) ;
   int (*dump_mpp)(struct wiphy * , struct net_device * , int  , u8 * , u8 * , struct mpath_info * ) ;
   int (*get_mesh_config)(struct wiphy * , struct net_device * , struct mesh_config * ) ;
   int (*update_mesh_config)(struct wiphy * , struct net_device * , u32  , struct mesh_config  const  * ) ;
   int (*join_mesh)(struct wiphy * , struct net_device * , struct mesh_config  const  * ,
                    struct mesh_setup  const  * ) ;
   int (*leave_mesh)(struct wiphy * , struct net_device * ) ;
   int (*join_ocb)(struct wiphy * , struct net_device * , struct ocb_setup * ) ;
   int (*leave_ocb)(struct wiphy * , struct net_device * ) ;
   int (*change_bss)(struct wiphy * , struct net_device * , struct bss_parameters * ) ;
   int (*set_txq_params)(struct wiphy * , struct net_device * , struct ieee80211_txq_params * ) ;
   int (*libertas_set_mesh_channel)(struct wiphy * , struct net_device * , struct ieee80211_channel * ) ;
   int (*set_monitor_channel)(struct wiphy * , struct cfg80211_chan_def * ) ;
   int (*scan)(struct wiphy * , struct cfg80211_scan_request * ) ;
   int (*auth)(struct wiphy * , struct net_device * , struct cfg80211_auth_request * ) ;
   int (*assoc)(struct wiphy * , struct net_device * , struct cfg80211_assoc_request * ) ;
   int (*deauth)(struct wiphy * , struct net_device * , struct cfg80211_deauth_request * ) ;
   int (*disassoc)(struct wiphy * , struct net_device * , struct cfg80211_disassoc_request * ) ;
   int (*connect)(struct wiphy * , struct net_device * , struct cfg80211_connect_params * ) ;
   int (*disconnect)(struct wiphy * , struct net_device * , u16  ) ;
   int (*join_ibss)(struct wiphy * , struct net_device * , struct cfg80211_ibss_params * ) ;
   int (*leave_ibss)(struct wiphy * , struct net_device * ) ;
   int (*set_mcast_rate)(struct wiphy * , struct net_device * , int * ) ;
   int (*set_wiphy_params)(struct wiphy * , u32  ) ;
   int (*set_tx_power)(struct wiphy * , struct wireless_dev * , enum nl80211_tx_power_setting  ,
                       int  ) ;
   int (*get_tx_power)(struct wiphy * , struct wireless_dev * , int * ) ;
   int (*set_wds_peer)(struct wiphy * , struct net_device * , u8 const   * ) ;
   void (*rfkill_poll)(struct wiphy * ) ;
   int (*testmode_cmd)(struct wiphy * , struct wireless_dev * , void * , int  ) ;
   int (*testmode_dump)(struct wiphy * , struct sk_buff * , struct netlink_callback * ,
                        void * , int  ) ;
   int (*set_bitrate_mask)(struct wiphy * , struct net_device * , u8 const   * , struct cfg80211_bitrate_mask  const  * ) ;
   int (*dump_survey)(struct wiphy * , struct net_device * , int  , struct survey_info * ) ;
   int (*set_pmksa)(struct wiphy * , struct net_device * , struct cfg80211_pmksa * ) ;
   int (*del_pmksa)(struct wiphy * , struct net_device * , struct cfg80211_pmksa * ) ;
   int (*flush_pmksa)(struct wiphy * , struct net_device * ) ;
   int (*remain_on_channel)(struct wiphy * , struct wireless_dev * , struct ieee80211_channel * ,
                            unsigned int  , u64 * ) ;
   int (*cancel_remain_on_channel)(struct wiphy * , struct wireless_dev * , u64  ) ;
   int (*mgmt_tx)(struct wiphy * , struct wireless_dev * , struct cfg80211_mgmt_tx_params * ,
                  u64 * ) ;
   int (*mgmt_tx_cancel_wait)(struct wiphy * , struct wireless_dev * , u64  ) ;
   int (*set_power_mgmt)(struct wiphy * , struct net_device * , bool  , int  ) ;
   int (*set_cqm_rssi_config)(struct wiphy * , struct net_device * , s32  , u32  ) ;
   int (*set_cqm_txe_config)(struct wiphy * , struct net_device * , u32  , u32  ,
                             u32  ) ;
   void (*mgmt_frame_register)(struct wiphy * , struct wireless_dev * , u16  , bool  ) ;
   int (*set_antenna)(struct wiphy * , u32  , u32  ) ;
   int (*get_antenna)(struct wiphy * , u32 * , u32 * ) ;
   int (*sched_scan_start)(struct wiphy * , struct net_device * , struct cfg80211_sched_scan_request * ) ;
   int (*sched_scan_stop)(struct wiphy * , struct net_device * ) ;
   int (*set_rekey_data)(struct wiphy * , struct net_device * , struct cfg80211_gtk_rekey_data * ) ;
   int (*tdls_mgmt)(struct wiphy * , struct net_device * , u8 const   * , u8  , u8  ,
                    u16  , u32  , bool  , u8 const   * , size_t  ) ;
   int (*tdls_oper)(struct wiphy * , struct net_device * , u8 const   * , enum nl80211_tdls_operation  ) ;
   int (*probe_client)(struct wiphy * , struct net_device * , u8 const   * , u64 * ) ;
   int (*set_noack_map)(struct wiphy * , struct net_device * , u16  ) ;
   int (*get_channel)(struct wiphy * , struct wireless_dev * , struct cfg80211_chan_def * ) ;
   int (*start_p2p_device)(struct wiphy * , struct wireless_dev * ) ;
   void (*stop_p2p_device)(struct wiphy * , struct wireless_dev * ) ;
   int (*set_mac_acl)(struct wiphy * , struct net_device * , struct cfg80211_acl_data  const  * ) ;
   int (*start_radar_detection)(struct wiphy * , struct net_device * , struct cfg80211_chan_def * ,
                                u32  ) ;
   int (*update_ft_ies)(struct wiphy * , struct net_device * , struct cfg80211_update_ft_ies_params * ) ;
   int (*crit_proto_start)(struct wiphy * , struct wireless_dev * , enum nl80211_crit_proto_id  ,
                           u16  ) ;
   void (*crit_proto_stop)(struct wiphy * , struct wireless_dev * ) ;
   int (*set_coalesce)(struct wiphy * , struct cfg80211_coalesce * ) ;
   int (*channel_switch)(struct wiphy * , struct net_device * , struct cfg80211_csa_settings * ) ;
   int (*set_qos_map)(struct wiphy * , struct net_device * , struct cfg80211_qos_map * ) ;
   int (*set_ap_chanwidth)(struct wiphy * , struct net_device * , struct cfg80211_chan_def * ) ;
   int (*add_tx_ts)(struct wiphy * , struct net_device * , u8  , u8 const   * , u8  ,
                    u16  ) ;
   int (*del_tx_ts)(struct wiphy * , struct net_device * , u8  , u8 const   * ) ;
   int (*tdls_channel_switch)(struct wiphy * , struct net_device * , u8 const   * ,
                              u8  , struct cfg80211_chan_def * ) ;
   void (*tdls_cancel_channel_switch)(struct wiphy * , struct net_device * , u8 const   * ) ;
};
#line 3981
enum cfg80211_bss_frame_type {
    CFG80211_BSS_FTYPE_UNKNOWN = 0,
    CFG80211_BSS_FTYPE_BEACON = 1,
    CFG80211_BSS_FTYPE_PRESP = 2
} ;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 263
enum hrtimer_restart;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 449 "include/linux/etherdevice.h"
struct iw_param {
   __s32 value ;
   __u8 fixed ;
   __u8 disabled ;
   __u16 flags ;
};
#line 680 "include/uapi/linux/wireless.h"
struct iw_point {
   void *pointer ;
   __u16 length ;
   __u16 flags ;
};
#line 691 "include/uapi/linux/wireless.h"
struct iw_freq {
   __s32 m ;
   __s16 e ;
   __u8 i ;
   __u8 flags ;
};
#line 708 "include/uapi/linux/wireless.h"
struct iw_quality {
   __u8 qual ;
   __u8 level ;
   __u8 noise ;
   __u8 updated ;
};
#line 864 "include/uapi/linux/wireless.h"
struct iw_michaelmicfailure {
   __u32 flags ;
   struct sockaddr src_addr ;
   __u8 tsc[8U] ;
};
#line 897 "include/uapi/linux/wireless.h"
union iwreq_data {
   char name[16U] ;
   struct iw_point essid ;
   struct iw_param nwid ;
   struct iw_freq freq ;
   struct iw_param sens ;
   struct iw_param bitrate ;
   struct iw_param txpower ;
   struct iw_param rts ;
   struct iw_param frag ;
   __u32 mode ;
   struct iw_param retry ;
   struct iw_point encoding ;
   struct iw_param power ;
   struct iw_quality qual ;
   struct sockaddr ap_addr ;
   struct sockaddr addr ;
   struct iw_param param ;
   struct iw_point data ;
};
#line 2661 "./include/uapi/linux/nl80211.h"
enum nl80211_key_type {
    NL80211_KEYTYPE_GROUP = 0,
    NL80211_KEYTYPE_PAIRWISE = 1,
    NL80211_KEYTYPE_PEERKEY = 2,
    NUM_NL80211_KEYTYPES = 3
} ;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 39 "include/linux/mod_devicetable.h"
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 bInterfaceNumber ;
   kernel_ulong_t driver_info ;
};
#line 283 "include/linux/pm_runtime.h"
struct usb_driver;
#line 819 "include/linux/usb.h"
struct usb_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 1007 "include/linux/usb.h"
struct usbdrv_wrap {
   struct device_driver driver ;
   int for_devices ;
};
#line 1017 "include/linux/usb.h"
struct usb_driver {
   char const   *name ;
   int (*probe)(struct usb_interface * , struct usb_device_id  const  * ) ;
   void (*disconnect)(struct usb_interface * ) ;
   int (*unlocked_ioctl)(struct usb_interface * , unsigned int  , void * ) ;
   int (*suspend)(struct usb_interface * , pm_message_t  ) ;
   int (*resume)(struct usb_interface * ) ;
   int (*reset_resume)(struct usb_interface * ) ;
   int (*pre_reset)(struct usb_interface * ) ;
   int (*post_reset)(struct usb_interface * ) ;
   struct usb_device_id  const  *id_table ;
   struct usb_dynids dynids ;
   struct usbdrv_wrap drvwrap ;
   unsigned char no_dynamic_id : 1 ;
   unsigned char supports_autosuspend : 1 ;
   unsigned char disable_hub_initiated_lpm : 1 ;
   unsigned char soft_unbind : 1 ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 291
enum hrtimer_restart;
#line 57 "drivers/staging/rtl8723au/include/rtl8723a_rf.h"
enum rt_media_status;
#line 57
enum rt_media_status;
#line 656 "drivers/staging/rtl8723au/include/odm.h"
enum rt_status {
    RT_STATUS_SUCCESS = 0,
    RT_STATUS_FAILURE = 1,
    RT_STATUS_PENDING = 2,
    RT_STATUS_RESOURCE = 3,
    RT_STATUS_INVALID_CONTEXT = 4,
    RT_STATUS_INVALID_PARAMETER = 5,
    RT_STATUS_NOT_SUPPORT = 6,
    RT_STATUS_OS_API_FAILED = 7
} ;
#line 69 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct chnl_txpower_triple {
   u8 FirstChnl ;
   u8 NumChnls ;
   s8 MaxTxPowerInDbm ;
};
#line 469
enum hci_state_with_cmd {
    STATE_CMD_CREATE_PHY_LINK = 0,
    STATE_CMD_ACCEPT_PHY_LINK = 1,
    STATE_CMD_DISCONNECT_PHY_LINK = 2,
    STATE_CMD_CONNECT_ACCEPT_TIMEOUT = 3,
    STATE_CMD_MAC_START_COMPLETE = 4,
    STATE_CMD_MAC_START_FAILED = 5,
    STATE_CMD_MAC_CONNECT_COMPLETE = 6,
    STATE_CMD_MAC_CONNECT_FAILED = 7,
    STATE_CMD_MAC_DISCONNECT_INDICATE = 8,
    STATE_CMD_MAC_CONNECT_CANCEL_INDICATE = 9,
    STATE_CMD_4WAY_FAILED = 10,
    STATE_CMD_4WAY_SUCCESSED = 11,
    STATE_CMD_ENTER_STATE = 12,
    STATE_CMD_NO_SUCH_CMD = 13
} ;
#line 550
enum bt_traffic_mode_profile {
    BT_PROFILE_NONE = 0,
    BT_PROFILE_A2DP = 1,
    BT_PROFILE_PAN = 2,
    BT_PROFILE_HID = 3,
    BT_PROFILE_SCO = 4
} ;
#line 690 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct amp_assoc_structure {
   u8 TypeID ;
   u16 Length ;
   u8 Data[1U] ;
};
#line 699 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct amp_pref_chnl_regulatory {
   u8 reXId ;
   u8 regulatoryClass ;
   u8 coverageClass ;
};
#line 764 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct packet_irp_hcicmd_data {
   unsigned short OCF : 10 ;
   unsigned char OGF : 6 ;
   u8 Length ;
   u8 Data[20U] ;
};
#line 1052 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct packet_irp_hcievent_data {
   u8 EventCode ;
   u8 Length ;
   u8 Data[20U] ;
};
#line 1058 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct common_triple {
   u8 byte_1st ;
   u8 byte_2nd ;
   u8 byte_3rd ;
};
#line 1108
enum bt_state_1ant {
    BT_INFO_STATE_DISABLED = 0,
    BT_INFO_STATE_NO_CONNECTION = 1,
    BT_INFO_STATE_CONNECT_IDLE = 2,
    BT_INFO_STATE_INQ_OR_PAG = 3,
    BT_INFO_STATE_ACL_ONLY_BUSY = 4,
    BT_INFO_STATE_SCO_ONLY_BUSY = 5,
    BT_INFO_STATE_ACL_SCO_BUSY = 6,
    BT_INFO_STATE_ACL_INQ_OR_PAG = 7,
    BT_INFO_STATE_MAX = 8
} ;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 48
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 75 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 77
  __list_add(new, head->prev, head);
#line 78
  return;
}
}
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *memset(void * , int  , size_t  ) ;
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 30 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
#line 42
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
#line 315 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
#line 317
  _raw_spin_lock_bh(& lock->__annonCompField18.rlock);
#line 318
  return;
}
}
#line 360 "include/linux/spinlock.h"
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
#line 362
  _raw_spin_unlock_bh(& lock->__annonCompField18.rlock);
#line 363
  return;
}
}
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 292
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
#line 354 "include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
#line 361
  tmp___0 = __msecs_to_jiffies(m);
#line 361
  return (tmp___0);
}
}
#line 170 "include/linux/timer.h"
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 173
int ldv_mod_timer_11(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 177
int ldv_mod_timer_12(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 181
int ldv_mod_timer_13(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 185
int ldv_mod_timer_14(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 189
int ldv_mod_timer_15(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 193
int ldv_mod_timer_16(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 229
extern int del_timer_sync(struct timer_list * ) ;
#line 232
int ldv_del_timer_sync_17(struct timer_list *ldv_func_arg1 ) ;
#line 181 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 361
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 429
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 433
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 439
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 443
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 452
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 455
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
#line 464
extern bool cancel_work_sync(struct work_struct * ) ;
#line 467
bool ldv_cancel_work_sync_10(struct work_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_5(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 289
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_work_1_1 ;
#line 40
struct work_struct *ldv_work_struct_2_0 ;
#line 44
struct work_struct *ldv_work_struct_2_2 ;
#line 58
struct work_struct *ldv_work_struct_1_1 ;
#line 62
int ldv_work_1_3 ;
#line 63
struct work_struct *ldv_work_struct_2_1 ;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 82
int ldv_work_1_0 ;
#line 88
int ldv_work_2_1 ;
#line 94
struct work_struct *ldv_work_struct_1_3 ;
#line 107
struct work_struct *ldv_work_struct_2_3 ;
#line 121
struct work_struct *ldv_work_struct_1_0 ;
#line 132
int ldv_work_2_0 ;
#line 140
int ldv_work_1_2 ;
#line 144
struct work_struct *ldv_work_struct_1_2 ;
#line 148
int ldv_work_2_2 ;
#line 151
int ldv_work_2_3 ;
#line 161
void call_and_disable_work_1(struct work_struct *work ) ;
#line 169
void call_and_disable_all_2(int state ) ;
#line 174
void activate_work_1(struct work_struct *work , int state ) ;
#line 183
void disable_work_1(struct work_struct *work ) ;
#line 187
void work_init_1(void) ;
#line 188
void disable_suitable_timer_11(struct timer_list *timer ) ;
#line 197
void invoke_work_2(void) ;
#line 202
void work_init_2(void) ;
#line 209
void call_and_disable_all_1(int state ) ;
#line 211
void activate_work_2(struct work_struct *work , int state ) ;
#line 224
void disable_work_2(struct work_struct *work ) ;
#line 228
void invoke_work_1(void) ;
#line 233
void activate_pending_timer_11(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 246
void call_and_disable_work_2(struct work_struct *work ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 271 "include/linux/etherdevice.h"
__inline static void ether_addr_copy(u8 *dst , u8 const   *src ) 
{ 


  {
#line 274
  *((u32 *)dst) = *((u32 const   *)src);
#line 275
  *((u16 *)dst + 4U) = *((u16 const   *)src + 4U);
#line 276
  return;
}
}
#line 91 "drivers/staging/rtl8723au/include/wlan_bssdef.h"
__inline static uint get_wlan_bssid_ex_sz(struct wlan_bssid_ex *bss ) 
{ 


  {
#line 93
  return (bss->IELength + 103U);
}
}
#line 91 "drivers/staging/rtl8723au/include/rtw_cmd.h"
void rtw_evt_work(struct work_struct *work ) ;
#line 93
int rtw_enqueue_cmd23a(struct cmd_priv *pcmdpriv , struct cmd_obj *cmd_obj ) ;
#line 94
void rtw_free_cmd_obj23a(struct cmd_obj *pcmd ) ;
#line 98
int rtw_init_cmd_priv23a(struct cmd_priv *pcmdpriv ) ;
#line 100
u32 rtw_init_evt_priv23a(struct evt_priv *pevtpriv ) ;
#line 101
void rtw_free_evt_priv23a(struct evt_priv *pevtpriv ) ;
#line 680
int rtw_sitesurvey_cmd23a(struct rtw_adapter *padapter , struct cfg80211_ssid *ssid ,
                          int ssid_num , struct rtw_ieee80211_channel *ch , int ch_num ) ;
#line 681
int rtw_createbss_cmd23a(struct rtw_adapter *padapter ) ;
#line 684
int rtw_setstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 unicast_key ) ;
#line 685
int rtw_clearstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 entry , u8 enqueue ) ;
#line 686
int rtw_joinbss_cmd23a(struct rtw_adapter *padapter , struct wlan_network *pnetwork ) ;
#line 687
int rtw_disassoc_cmd23a(struct rtw_adapter *padapter , u32 deauth_timeout_ms , bool enqueue ) ;
#line 688
int rtw_setopmode_cmd23a(struct rtw_adapter *padapter , enum nl80211_iftype ifmode ) ;
#line 703
int rtw_addbareq_cmd23a(struct rtw_adapter *padapter , u8 tid , u8 *addr ) ;
#line 705
int rtw_dynamic_chk_wk_cmd23a(struct rtw_adapter *padapter ) ;
#line 707
int rtw_lps_ctrl_wk_cmd23a(struct rtw_adapter *padapter , u8 lps_ctrl_type , u8 enqueue ) ;
#line 709
int rtw_ps_cmd23a(struct rtw_adapter *padapter ) ;
#line 712
int rtw_chk_hi_queue_cmd23a(struct rtw_adapter *padapter ) ;
#line 719
int rtw_c2h_wk_cmd23a(struct rtw_adapter *padapter , u8 *c2h_evt ) ;
#line 721
int rtw_drvextra_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 723
void rtw_survey_cmd_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
#line 724
void rtw_disassoc_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
#line 725
void rtw_joinbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
#line 726
void rtw_createbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
#line 727
void rtw_getbbrfreg_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
#line 730
void rtw_setstaKey_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
#line 731
void rtw_setassocsta_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
#line 815
struct _cmd_callback rtw_cmd_callback[63U] ;
#line 137 "drivers/staging/rtl8723au/include/hal_com.h"
void c2h_evt_clear23a(struct rtw_adapter *adapter ) ;
#line 138
s32 c2h_evt_read23a(struct rtw_adapter *adapter , u8 *buf ) ;
#line 180
bool rtl8723a_chk_hi_queue_empty(struct rtw_adapter *padapter ) ;
#line 225 "drivers/staging/rtl8723au/include/rtw_pwrctrl.h"
void rtw_ps_processor23a(struct rtw_adapter *padapter ) ;
#line 230
void LPS_Enter23a(struct rtw_adapter *padapter ) ;
#line 231
void LPS_Leave23a(struct rtw_adapter *padapter ) ;
#line 365 "drivers/staging/rtl8723au/include/sta_info.h"
struct sta_info *rtw_alloc_stainfo23a(struct sta_priv *pstapriv , u8 const   *hwaddr ,
                                      gfp_t gfp ) ;
#line 368
struct sta_info *rtw_get_stainfo23a(struct sta_priv *pstapriv , u8 const   *hwaddr ) ;
#line 370
struct sta_info *rtw_get_bcmc_stainfo23a(struct rtw_adapter *padapter ) ;
#line 210 "drivers/staging/rtl8723au/include/rtw_mlme.h"
void rtw_free_network_queue23a(struct rtw_adapter *padapter ) ;
#line 230 "drivers/staging/rtl8723au/include/rtw_mlme.h"
__inline static bool check_fwstate(struct mlme_priv *pmlmepriv , int state ) 
{ 


  {
#line 232
  if ((pmlmepriv->fw_state & state) != 0) {
#line 233
    return (1);
  } else {

  }
#line 235
  return (0);
}
}
#line 250 "drivers/staging/rtl8723au/include/rtw_mlme.h"
__inline static void set_fwstate(struct mlme_priv *pmlmepriv , int state ) 
{ 


  {
#line 252
  pmlmepriv->fw_state = pmlmepriv->fw_state | state;
#line 254
  if (state == 2048) {
#line 255
    pmlmepriv->bScanInProcess = 1U;
  } else {

  }
#line 256
  return;
}
}
#line 258 "drivers/staging/rtl8723au/include/rtw_mlme.h"
__inline static void _clr_fwstate_(struct mlme_priv *pmlmepriv , int state ) 
{ 


  {
#line 260
  pmlmepriv->fw_state = pmlmepriv->fw_state & ~ state;
#line 262
  if (state == 2048) {
#line 263
    pmlmepriv->bScanInProcess = 0U;
  } else {

  }
#line 264
  return;
}
}
#line 270 "drivers/staging/rtl8723au/include/rtw_mlme.h"
__inline static void clr_fwstate(struct mlme_priv *pmlmepriv , int state ) 
{ 
  bool tmp ;

  {
#line 272
  spin_lock_bh(& pmlmepriv->lock);
#line 273
  tmp = check_fwstate(pmlmepriv, state);
#line 273
  if ((int )tmp) {
#line 274
    pmlmepriv->fw_state = pmlmepriv->fw_state ^ state;
  } else {

  }
#line 275
  spin_unlock_bh(& pmlmepriv->lock);
#line 276
  return;
}
}
#line 289
struct wlan_network *rtw_get_oldest_wlan_network23a(struct rtw_queue *scanned_queue ) ;
#line 294
void rtw_indicate_connect23a(struct rtw_adapter *padapter ) ;
#line 297
int rtw_restruct_sec_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len ) ;
#line 299
int rtw_restruct_wmm_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len , uint initial_out_len ) ;
#line 317
struct wlan_network *rtw_alloc_network(struct mlme_priv *pmlmepriv , gfp_t gfp ) ;
#line 325
bool rtw_restructure_ht_ie23a(struct rtw_adapter *padapter , u8 *in_ie , u8 *out_ie ,
                              uint in_len , uint *pout_len ) ;
#line 164 "drivers/staging/rtl8723au/include/rtw_debug.h"
u32 GlobalDebugLevel23A ;
#line 167
void rt_trace(int comp , int level , char const   *fmt  , ...) ;
#line 475 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
void clear_cam_entry23a(struct rtw_adapter *padapter , u8 entry ) ;
#line 493
unsigned char check_assoc_AP23a(u8 *pframe , uint len ) ;
#line 577
void linked_status_chk23a(struct rtw_adapter *padapter ) ;
#line 608
int NULL_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 609
int join_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 610
int disconnect_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 611
int createbss_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 612
int setopmode_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 613
int sitesurvey_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 614
int setauth_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 615
int setkey_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 616
int set_stakey_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 619
int add_ba_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 621
int mlme_evt_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 622
int h2c_msg_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 623
int tx_beacon_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 624
int set_ch_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 625
int set_chplan_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 626
int led_blink_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 627
int set_csa_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 628
int tdls_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 31 "drivers/staging/rtl8723au/include/rtw_ap.h"
void update_beacon23a(struct rtw_adapter *padapter , u8 ie_id , u8 *oui , u8 tx ) ;
#line 33
void expire_timeout_chk23a(struct rtw_adapter *padapter ) ;
#line 146 "drivers/staging/rtl8723au/include/rtl8723a_cmd.h"
void rtl8723a_set_FwJoinBssReport_cmd(struct rtw_adapter *padapter , u8 mstatus ) ;
#line 23 "drivers/staging/rtl8723au/include/rtl8723a_bt_intf.h"
bool rtl8723a_BT_using_antenna_1(struct rtw_adapter *padapter ) ;
#line 25
bool rtl8723a_BT_coexist(struct rtw_adapter *padapter ) ;
#line 26
void rtl8723a_BT_do_coexist(struct rtw_adapter *padapter ) ;
#line 27
void rtl8723a_BT_wifiscan_notify(struct rtw_adapter *padapter , u8 scanType ) ;
#line 28
void rtl8723a_BT_mediastatus_notify(struct rtw_adapter *padapter , enum rt_media_status mstatus ) ;
#line 30
void rtl8723a_BT_specialpacket_notify(struct rtw_adapter *padapter ) ;
#line 31
void rtl8723a_BT_lps_leave(struct rtw_adapter *padapter ) ;
#line 135 "drivers/staging/rtl8723au/include/rtl8723a_dm.h"
void rtl8723a_HalDmWatchDog(struct rtw_adapter *Adapter ) ;
#line 22 "drivers/staging/rtl8723au/include/rtl8723a_sreset.h"
void rtl8723a_sreset_xmit_status_check(struct rtw_adapter *padapter ) ;
#line 520 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
bool c2h_id_filter_ccx_8723a(u8 id ) ;
#line 521
int c2h_handler_8723a(struct rtw_adapter *padapter , struct c2h_evt_hdr *c2h_evt ) ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
static struct cmd_hdl wlancmds[63U]  = 
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
  {      {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {871U, & join_cmd_hdl23a}, 
        {4U, & disconnect_hdl23a}, 
        {871U, & createbss_hdl23a}, 
        {4U, & setopmode_hdl23a}, 
        {712U, & sitesurvey_cmd_hdl23a}, 
        {4U, & setauth_hdl23a}, 
        {24U, & setkey_hdl23a}, 
        {28U, & set_stakey_hdl23a}, 
        {6U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {6U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {8U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {13U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {4U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {14U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {4U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {128U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {4U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {2U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {4U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {12U, & add_ba_hdl23a}, 
        {3U, & set_ch_hdl23a}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {871U, & tx_beacon_hdl23a}, 
        {0U, & mlme_evt_hdl23a}, 
        {0U, & rtw_drvextra_cmd_hdl23a}, 
        {0U, & h2c_msg_hdl23a}, 
        {1U, & set_chplan_hdl23a}, 
        {8U, & led_blink_hdl23a}, 
        {1U, & set_csa_hdl23a}, 
        {7U, & tdls_hdl23a}};
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
struct _cmd_callback rtw_cmd_callback[63U]  = 
#line 93
  {      {0U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {1U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {2U, & rtw_getbbrfreg_cmdrsp_callback23a}, 
        {3U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {4U, & rtw_getbbrfreg_cmdrsp_callback23a}, 
        {5U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {6U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {7U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {8U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {9U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {10U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {11U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {12U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {13U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {14U, & rtw_joinbss_cmd23a_callback}, 
        {15U, & rtw_disassoc_cmd23a_callback}, 
        {16U, & rtw_createbss_cmd23a_callback}, 
        {17U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {18U, & rtw_survey_cmd_callback23a}, 
        {19U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {20U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {21U, & rtw_setstaKey_cmdrsp_callback23a}, 
        {22U, & rtw_setassocsta_cmdrsp_callback23a}, 
        {23U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {24U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {25U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {26U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {27U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {28U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {29U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {30U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {31U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {32U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {33U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {34U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {35U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {36U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {37U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {38U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {39U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {40U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {41U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {42U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {43U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {44U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {45U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {46U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {47U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {48U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {49U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {50U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {51U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {52U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {53U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {54U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {55U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {56U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {57U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {58U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {59U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {60U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {61U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {62U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}};
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_init_cmd_priv23a(struct cmd_priv *pcmdpriv ) 
{ 
  int res ;
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;

  {
#line 173
  res = 1;
#line 175
  pcmdpriv->cmd_issued_cnt = 0U;
#line 176
  pcmdpriv->cmd_done_cnt = 0U;
#line 177
  pcmdpriv->rsp_cnt = 0U;
#line 179
  __lock_name = "\"rtl8723au_cmd\"";
#line 179
  tmp = __alloc_workqueue_key("rtl8723au_cmd", 0U, 1, & __key, __lock_name);
#line 179
  pcmdpriv->wq = tmp;
#line 180
  if ((unsigned long )pcmdpriv->wq == (unsigned long )((struct workqueue_struct *)0)) {
#line 181
    res = 0;
  } else {

  }
#line 183
  return (res);
}
}
#line 188
static void rtw_irq_work(struct work_struct *work ) ;
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
u32 rtw_init_evt_priv23a(struct evt_priv *pevtpriv ) 
{ 
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;

  {
#line 192
  __lock_name = "\"rtl8723au_evt\"";
#line 192
  tmp = __alloc_workqueue_key("rtl8723au_evt", 0U, 1, & __key, __lock_name);
#line 192
  pevtpriv->wq = tmp;
#line 194
  __init_work(& pevtpriv->irq_wk, 0);
#line 194
  __constr_expr_0.counter = 137438953408L;
#line 194
  pevtpriv->irq_wk.data = __constr_expr_0;
#line 194
  lockdep_init_map(& pevtpriv->irq_wk.lockdep_map, "(&pevtpriv->irq_wk)", & __key___0,
                   0);
#line 194
  INIT_LIST_HEAD(& pevtpriv->irq_wk.entry);
#line 194
  pevtpriv->irq_wk.func = & rtw_irq_work;
#line 196
  return (1U);
}
}
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
void rtw_free_evt_priv23a(struct evt_priv *pevtpriv ) 
{ 


  {
#line 201
  ldv_cancel_work_sync_10(& pevtpriv->irq_wk);
#line 202
  return;
}
}
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
static int rtw_cmd_filter(struct cmd_priv *pcmdpriv , struct cmd_obj *cmd_obj ) 
{ 
  u8 bAllow ;

  {
#line 207
  bAllow = 0U;
#line 209
  if ((unsigned int )cmd_obj->cmdcode == 59U) {
#line 210
    bAllow = 1U;
  } else {

  }
#line 212
  if ((unsigned int )(pcmdpriv->padapter)->hw_init_completed == 0U && (unsigned int )bAllow == 0U) {
#line 213
    return (0);
  } else {

  }
#line 214
  return (1);
}
}
#line 217
static void rtw_cmd_work(struct work_struct *work ) ;
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_enqueue_cmd23a(struct cmd_priv *pcmdpriv , struct cmd_obj *cmd_obj ) 
{ 
  int res ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  bool tmp ;

  {
#line 221
  res = 0;
#line 223
  if ((unsigned long )cmd_obj == (unsigned long )((struct cmd_obj *)0)) {
#line 224
    goto exit;
  } else {

  }
#line 226
  cmd_obj->padapter = pcmdpriv->padapter;
#line 228
  res = rtw_cmd_filter(pcmdpriv, cmd_obj);
#line 229
  if (res == 0) {
#line 230
    rtw_free_cmd_obj23a(cmd_obj);
#line 231
    goto exit;
  } else {

  }
#line 234
  __init_work(& cmd_obj->work, 0);
#line 234
  __constr_expr_0.counter = 137438953408L;
#line 234
  cmd_obj->work.data = __constr_expr_0;
#line 234
  lockdep_init_map(& cmd_obj->work.lockdep_map, "(&cmd_obj->work)", & __key, 0);
#line 234
  INIT_LIST_HEAD(& cmd_obj->work.entry);
#line 234
  cmd_obj->work.func = & rtw_cmd_work;
#line 236
  tmp = queue_work(pcmdpriv->wq, & cmd_obj->work);
#line 236
  res = (int )tmp;
#line 238
  if (res == 0) {
#line 239
    printk("\v%s: Call to queue_work() failed\n", "rtw_enqueue_cmd23a");
#line 240
    res = 0;
  } else {
#line 242
    res = 1;
  }
  exit: ;
#line 245
  return (res);
}
}
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
void rtw_free_cmd_obj23a(struct cmd_obj *pcmd ) 
{ 


  {
#line 251
  if ((unsigned int )pcmd->cmdcode != 14U && (unsigned int )pcmd->cmdcode != 16U) {
#line 254
    kfree((void const   *)pcmd->parmbuf);
  } else {

  }
#line 257
  if ((unsigned long )pcmd->rsp != (unsigned long )((u8 *)0U)) {
#line 258
    if (pcmd->rspsz != 0U) {
#line 260
      kfree((void const   *)pcmd->rsp);
    } else {

    }
  } else {

  }
#line 264
  kfree((void const   *)pcmd);
#line 265
  return;
}
}
#line 267 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
static void rtw_cmd_work(struct work_struct *work ) 
{ 
  int (*cmd_hdl)(struct rtw_adapter * , u8 const   * ) ;
  void (*pcmd_callback)(struct rtw_adapter * , struct cmd_obj * ) ;
  struct cmd_priv *pcmdpriv ;
  struct cmd_obj *pcmd ;
  struct work_struct  const  *__mptr ;
  int tmp ;

  {
#line 272
  __mptr = (struct work_struct  const  *)work;
#line 272
  pcmd = (struct cmd_obj *)__mptr;
#line 274
  pcmdpriv = & (pcmd->padapter)->cmdpriv;
#line 276
  tmp = rtw_cmd_filter(pcmdpriv, pcmd);
#line 276
  if (tmp == 0) {
#line 277
    pcmd->res = 3;
#line 278
    goto post_process;
  } else {

  }
#line 281
  pcmdpriv->cmd_issued_cnt = pcmdpriv->cmd_issued_cnt + 1U;
#line 283
  pcmd->cmdsz = (pcmd->cmdsz + 3U) & 4294967292U;
#line 285
  if ((unsigned int )pcmd->cmdcode <= 62U) {
#line 286
    cmd_hdl = wlancmds[(int )pcmd->cmdcode].h2cfuns;
#line 288
    if ((unsigned long )cmd_hdl != (unsigned long )((int (*)(struct rtw_adapter * ,
                                                             u8 const   * ))0)) {
#line 289
      pcmd->res = (*cmd_hdl)(pcmd->padapter, (u8 const   *)pcmd->parmbuf);
    } else {
#line 291
      pcmd->res = 3;
    }
  } else {
#line 293
    pcmd->res = 4;
  }
  post_process: ;
#line 297
  if ((unsigned int )pcmd->cmdcode <= 62U) {
#line 299
    pcmd_callback = rtw_cmd_callback[(int )pcmd->cmdcode].callback;
#line 300
    if ((unsigned long )pcmd_callback == (unsigned long )((void (*)(struct rtw_adapter * ,
                                                                    struct cmd_obj * ))0)) {
#line 301
      if (GlobalDebugLevel23A > 6U) {
#line 301
        rt_trace(128, 7, "mlme_cmd_hdl(): pcmd_callback = 0x%p, cmdcode = 0x%x\n",
                 pcmd_callback, (int )pcmd->cmdcode);
      } else {

      }
#line 304
      rtw_free_cmd_obj23a(pcmd);
    } else {
#line 308
      (*pcmd_callback)(pcmd->padapter, pcmd);
    }
  } else {
#line 311
    if (GlobalDebugLevel23A > 3U) {
#line 311
      rt_trace(128, 4, "%s: cmdcode = 0x%x callback not defined!\n", "rtw_cmd_work",
               (int )pcmd->cmdcode);
    } else {

    }
#line 314
    rtw_free_cmd_obj23a(pcmd);
  }
#line 316
  return;
}
}
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_sitesurvey_cmd23a(struct rtw_adapter *padapter , struct cfg80211_ssid *ssid ,
                          int ssid_num , struct rtw_ieee80211_channel *ch , int ch_num ) 
{ 
  int res ;
  struct cmd_obj *ph2c ;
  struct sitesurvey_parm *psurveyPara ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int i ;
  int i___0 ;
  unsigned long tmp___2 ;

  {
#line 323
  res = 0;
#line 326
  pcmdpriv = & padapter->cmdpriv;
#line 327
  pmlmepriv = & padapter->mlmepriv;
#line 329
  tmp = check_fwstate(pmlmepriv, 1);
#line 329
  if ((int )tmp) {
#line 330
    rtw_lps_ctrl_wk_cmd23a(padapter, 0, 1);
  } else {

  }
#line 332
  tmp___0 = kzalloc(128UL, 32U);
#line 332
  ph2c = (struct cmd_obj *)tmp___0;
#line 333
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 334
    return (0);
  } else {

  }
#line 336
  tmp___1 = kzalloc(712UL, 32U);
#line 336
  psurveyPara = (struct sitesurvey_parm *)tmp___1;
#line 337
  if ((unsigned long )psurveyPara == (unsigned long )((struct sitesurvey_parm *)0)) {
#line 338
    kfree((void const   *)ph2c);
#line 339
    return (0);
  } else {

  }
#line 342
  rtw_free_network_queue23a(padapter);
#line 344
  if (GlobalDebugLevel23A > 6U) {
#line 344
    rt_trace(128, 7, "%s: flush network queue\n", "rtw_sitesurvey_cmd23a");
  } else {

  }
#line 347
  ph2c->cmdcode = 18U;
#line 347
  ph2c->parmbuf = (u8 *)psurveyPara;
#line 347
  ph2c->cmdsz = 712U;
#line 347
  ph2c->rsp = (u8 *)0U;
#line 347
  ph2c->rspsz = 0U;
#line 351
  psurveyPara->scan_mode = (int )pmlmepriv->scan_mode;
#line 354
  if ((unsigned long )ssid != (unsigned long )((struct cfg80211_ssid *)0)) {
#line 357
    i = 0;
#line 357
    goto ldv_55841;
    ldv_55840: ;
#line 358
    if ((unsigned int )(ssid + (unsigned long )i)->ssid_len != 0U) {
#line 359
      memcpy((void *)(& psurveyPara->ssid) + (unsigned long )i, (void const   *)ssid + (unsigned long )i,
               33UL);
#line 361
      psurveyPara->ssid_num = (u8 )((int )psurveyPara->ssid_num + 1);
    } else {

    }
#line 357
    i = i + 1;
    ldv_55841: ;
#line 357
    if (i < ssid_num && i <= 8) {
#line 359
      goto ldv_55840;
    } else {

    }

  } else {

  }
#line 367
  if ((unsigned long )ch != (unsigned long )((struct rtw_ieee80211_channel *)0)) {
#line 370
    i___0 = 0;
#line 370
    goto ldv_55845;
    ldv_55844: ;
#line 371
    if ((unsigned int )(ch + (unsigned long )i___0)->hw_value != 0U && ((ch + (unsigned long )i___0)->flags & 1U) == 0U) {
#line 373
      memcpy((void *)(& psurveyPara->ch) + (unsigned long )i___0, (void const   *)ch + (unsigned long )i___0,
               8UL);
#line 375
      psurveyPara->ch_num = (u8 )((int )psurveyPara->ch_num + 1);
    } else {

    }
#line 370
    i___0 = i___0 + 1;
    ldv_55845: ;
#line 370
    if (i___0 < ch_num && i___0 <= 50) {
#line 372
      goto ldv_55844;
    } else {

    }

  } else {

  }
#line 380
  set_fwstate(pmlmepriv, 2048);
#line 382
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
#line 384
  if (res == 1) {
#line 385
    tmp___2 = msecs_to_jiffies(8000U);
#line 385
    ldv_mod_timer_11(& pmlmepriv->scan_to_timer, tmp___2 + (unsigned long )jiffies);
#line 388
    pmlmepriv->scan_interval = 30U;
  } else {
#line 390
    _clr_fwstate_(pmlmepriv, 2048);
  }
#line 392
  return (res);
}
}
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
void rtw_getbbrfreg_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 


  {
#line 398
  kfree((void const   *)pcmd->parmbuf);
#line 399
  kfree((void const   *)pcmd);
#line 400
  return;
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_createbss_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *pcmd ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pdev_network ;
  u8 res ;
  void *tmp ;
  int tmp___0 ;

  {
#line 405
  pcmdpriv = & padapter->cmdpriv;
#line 406
  pmlmepriv = & padapter->mlmepriv;
#line 408
  res = 1U;
#line 410
  pdev_network = & padapter->registrypriv.dev_network;
#line 412
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len == 0U) {
#line 413
    if (GlobalDebugLevel23A > 6U) {
#line 413
      rt_trace(128, 7, "createbss for Any SSid:%s\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
    } else {

    }
  } else
#line 417
  if (GlobalDebugLevel23A > 6U) {
#line 417
    rt_trace(128, 7, "createbss for SSid:%s\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
  } else {

  }
#line 422
  tmp = kzalloc(128UL, 32U);
#line 422
  pcmd = (struct cmd_obj *)tmp;
#line 423
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
#line 424
    res = 0U;
#line 425
    goto exit;
  } else {

  }
#line 428
  pcmd->cmdcode = 16U;
#line 429
  pcmd->parmbuf = (u8 *)pdev_network;
#line 430
  pcmd->cmdsz = get_wlan_bssid_ex_sz(pdev_network);
#line 431
  pcmd->rsp = (u8 *)0U;
#line 432
  pcmd->rspsz = 0U;
#line 434
  pdev_network->Length = pcmd->cmdsz;
#line 436
  tmp___0 = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
#line 436
  res = (u8 )tmp___0;
  exit: ;
#line 440
  return ((int )res);
}
}
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_joinbss_cmd23a(struct rtw_adapter *padapter , struct wlan_network *pnetwork ) 
{ 
  int res ;
  struct wlan_bssid_ex *psecnetwork ;
  struct cmd_obj *pcmd ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct registry_priv *pregistrypriv ;
  struct ht_priv *phtpriv ;
  enum nl80211_iftype ifmode ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  uint tmp___2 ;
  int tmp___3 ;
  u32 tmp_len ;
  int tmp___4 ;
  u32 algo ;

  {
#line 446
  res = 1;
#line 449
  pcmdpriv = & padapter->cmdpriv;
#line 450
  pmlmepriv = & padapter->mlmepriv;
#line 451
  psecuritypriv = & padapter->securitypriv;
#line 452
  pregistrypriv = & padapter->registrypriv;
#line 453
  phtpriv = & pmlmepriv->htpriv;
#line 455
  pmlmeext = & padapter->mlmeextpriv;
#line 456
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 458
  ifmode = pnetwork->network.ifmode;
#line 460
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len == 0U) {
#line 461
    if (GlobalDebugLevel23A > 6U) {
#line 461
      rt_trace(128, 7, "+Join cmd: Any SSid\n");
    } else {

    }
  } else
#line 464
  if (GlobalDebugLevel23A > 5U) {
#line 464
    rt_trace(128, 6, "+Join cmd: SSid =[%s]\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
  } else {

  }
#line 469
  tmp = kzalloc(128UL, 32U);
#line 469
  pcmd = (struct cmd_obj *)tmp;
#line 470
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
#line 471
    res = 0;
#line 472
    if (GlobalDebugLevel23A > 3U) {
#line 472
      rt_trace(128, 4, "rtw_joinbss_cmd23a: memory allocate for cmd_obj fail!!!\n");
    } else {

    }
#line 474
    goto exit;
  } else {

  }
#line 478
  tmp___0 = check_fwstate(pmlmepriv, 40);
#line 478
  if (tmp___0) {
#line 478
    tmp___1 = 0;
  } else {
#line 478
    tmp___1 = 1;
  }
#line 478
  if (tmp___1) {
#line 479
    switch ((unsigned int )ifmode) {
    case 1U: 
#line 481
    set_fwstate(pmlmepriv, 32);
#line 482
    goto ldv_55877;
    case 8U: ;
    case 2U: 
#line 485
    set_fwstate(pmlmepriv, 8);
#line 486
    goto ldv_55877;
    default: ;
#line 488
    goto ldv_55877;
    }
    ldv_55877: ;
  } else {

  }
#line 492
  psecnetwork = & psecuritypriv->sec_bss;
#line 493
  if ((unsigned long )psecnetwork == (unsigned long )((struct wlan_bssid_ex *)0)) {
#line 494
    kfree((void const   *)pcmd);
#line 495
    res = 0;
#line 497
    if (GlobalDebugLevel23A > 3U) {
#line 497
      rt_trace(128, 4, "rtw_joinbss_cmd23a :psecnetwork == NULL!!!\n");
    } else {

    }
#line 500
    goto exit;
  } else {

  }
#line 503
  memset((void *)psecnetwork, 0, 871UL);
#line 505
  tmp___2 = get_wlan_bssid_ex_sz(& pnetwork->network);
#line 505
  memcpy((void *)psecnetwork, (void const   *)(& pnetwork->network), (size_t )tmp___2);
#line 508
  psecnetwork->IELength = 0U;
#line 515
  if (pmlmepriv->assoc_by_bssid == 0U) {
#line 516
    ether_addr_copy((u8 *)(& pmlmepriv->assoc_bssid), (u8 const   *)(& pnetwork->network.MacAddress));
  } else {

  }
#line 519
  tmp___3 = rtw_restruct_sec_ie23a(padapter, (u8 *)(& pnetwork->network.IEs), (u8 *)(& psecnetwork->IEs),
                                   pnetwork->network.IELength);
#line 519
  psecnetwork->IELength = (u32 )tmp___3;
#line 524
  pmlmepriv->qos_option = 0U;
#line 526
  if ((unsigned int )pregistrypriv->wmm_enable != 0U) {
#line 529
    tmp___4 = rtw_restruct_wmm_ie23a(padapter, (u8 *)(& pnetwork->network.IEs), (u8 *)(& psecnetwork->IEs),
                                     pnetwork->network.IELength, psecnetwork->IELength);
#line 529
    tmp_len = (u32 )tmp___4;
#line 535
    if (psecnetwork->IELength != tmp_len) {
#line 536
      psecnetwork->IELength = tmp_len;
#line 538
      pmlmepriv->qos_option = 1U;
    } else {
#line 541
      pmlmepriv->qos_option = 0U;
    }
  } else {

  }
#line 545
  phtpriv->ht_option = 0;
#line 546
  if ((unsigned int )pregistrypriv->ht_enable != 0U) {
#line 547
    algo = padapter->securitypriv.dot11PrivacyAlgrthm;
#line 552
    if ((algo != 1027073U && algo != 1027077U) && algo != 1027074U) {
#line 556
      rtw_restructure_ht_ie23a(padapter, (u8 *)(& pnetwork->network.IEs), (u8 *)(& psecnetwork->IEs),
                               pnetwork->network.IELength, & psecnetwork->IELength);
    } else {

    }
  } else {

  }
#line 564
  pmlmeinfo->assoc_AP_vendor = check_assoc_AP23a((u8 *)(& pnetwork->network.IEs),
                                                 pnetwork->network.IELength);
#line 568
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 16U) {
#line 569
    padapter->pwrctrlpriv.smart_ps = 0U;
  } else {
#line 571
    padapter->pwrctrlpriv.smart_ps = padapter->registrypriv.smart_ps;
  }
#line 574
  if (GlobalDebugLevel23A > 3U) {
#line 574
    printk("\016RTL8723AU: %s: smart_ps =%d\n", "rtw_joinbss_cmd23a", (int )padapter->pwrctrlpriv.smart_ps);
  } else {

  }
#line 578
  pcmd->cmdsz = get_wlan_bssid_ex_sz(psecnetwork);
#line 580
  pcmd->cmdcode = 14U;
#line 581
  pcmd->parmbuf = (u8 *)psecnetwork;
#line 582
  pcmd->rsp = (u8 *)0U;
#line 583
  pcmd->rspsz = 0U;
#line 585
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
#line 588
  return (res);
}
}
#line 591 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_disassoc_cmd23a(struct rtw_adapter *padapter , u32 deauth_timeout_ms , bool enqueue ) 
{ 
  struct cmd_obj *cmdobj ;
  struct disconnect_parm *param ;
  struct cmd_priv *cmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 594
  cmdobj = (struct cmd_obj *)0;
#line 595
  param = (struct disconnect_parm *)0;
#line 596
  cmdpriv = & padapter->cmdpriv;
#line 597
  res = 1;
#line 599
  if (GlobalDebugLevel23A > 5U) {
#line 599
    rt_trace(128, 6, "+rtw_disassoc_cmd23a\n");
  } else {

  }
#line 603
  tmp = kzalloc(4UL, 32U);
#line 603
  param = (struct disconnect_parm *)tmp;
#line 604
  if ((unsigned long )param == (unsigned long )((struct disconnect_parm *)0)) {
#line 605
    res = 0;
#line 606
    goto exit;
  } else {

  }
#line 608
  param->deauth_timeout_ms = deauth_timeout_ms;
#line 610
  if ((int )enqueue) {
#line 612
    tmp___0 = kzalloc(128UL, 32U);
#line 612
    cmdobj = (struct cmd_obj *)tmp___0;
#line 613
    if ((unsigned long )cmdobj == (unsigned long )((struct cmd_obj *)0)) {
#line 614
      res = 0;
#line 615
      kfree((void const   *)param);
#line 616
      goto exit;
    } else {

    }
#line 618
    cmdobj->cmdcode = 15U;
#line 618
    cmdobj->parmbuf = (u8 *)param;
#line 618
    cmdobj->cmdsz = 4U;
#line 618
    cmdobj->rsp = (u8 *)0U;
#line 618
    cmdobj->rspsz = 0U;
#line 619
    res = rtw_enqueue_cmd23a(cmdpriv, cmdobj);
  } else {
#line 623
    tmp___1 = disconnect_hdl23a(padapter, (u8 const   *)param);
#line 623
    if (tmp___1 != 0) {
#line 624
      res = 0;
    } else {

    }
#line 625
    kfree((void const   *)param);
  }
  exit: ;
#line 629
  return (res);
}
}
#line 632 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_setopmode_cmd23a(struct rtw_adapter *padapter , enum nl80211_iftype ifmode ) 
{ 
  struct cmd_obj *ph2c ;
  struct setopmode_parm *psetop ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 637
  pcmdpriv = & padapter->cmdpriv;
#line 638
  res = 1;
#line 640
  tmp = kzalloc(128UL, 208U);
#line 640
  ph2c = (struct cmd_obj *)tmp;
#line 641
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 642
    res = 0;
#line 643
    goto exit;
  } else {

  }
#line 645
  tmp___0 = kzalloc(4UL, 208U);
#line 645
  psetop = (struct setopmode_parm *)tmp___0;
#line 647
  if ((unsigned long )psetop == (unsigned long )((struct setopmode_parm *)0)) {
#line 648
    kfree((void const   *)ph2c);
#line 649
    res = 0;
#line 650
    goto exit;
  } else {

  }
#line 653
  ph2c->cmdcode = 17U;
#line 653
  ph2c->parmbuf = (u8 *)psetop;
#line 653
  ph2c->cmdsz = 4U;
#line 653
  ph2c->rsp = (u8 *)0U;
#line 653
  ph2c->rspsz = 0U;
#line 654
  psetop->mode = ifmode;
#line 656
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
#line 658
  return (res);
}
}
#line 661 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_setstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 unicast_key ) 
{ 
  struct cmd_obj *ph2c ;
  struct set_stakey_parm *psetstakey_para ;
  struct cmd_priv *pcmdpriv ;
  struct set_stakey_rsp *psetstakey_rsp ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct sta_info *sta ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  bool tmp___2 ;
  int idx ;

  {
#line 665
  pcmdpriv = & padapter->cmdpriv;
#line 666
  psetstakey_rsp = (struct set_stakey_rsp *)0;
#line 667
  pmlmepriv = & padapter->mlmepriv;
#line 668
  psecuritypriv = & padapter->securitypriv;
#line 669
  sta = (struct sta_info *)psta;
#line 670
  res = 1;
#line 672
  tmp = kzalloc(128UL, 208U);
#line 672
  ph2c = (struct cmd_obj *)tmp;
#line 673
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 674
    res = 0;
#line 675
    goto exit;
  } else {

  }
#line 678
  tmp___0 = kzalloc(28UL, 208U);
#line 678
  psetstakey_para = (struct set_stakey_parm *)tmp___0;
#line 679
  if ((unsigned long )psetstakey_para == (unsigned long )((struct set_stakey_parm *)0)) {
#line 680
    kfree((void const   *)ph2c);
#line 681
    res = 0;
#line 682
    goto exit;
  } else {

  }
#line 685
  tmp___1 = kzalloc(8UL, 208U);
#line 685
  psetstakey_rsp = (struct set_stakey_rsp *)tmp___1;
#line 686
  if ((unsigned long )psetstakey_rsp == (unsigned long )((struct set_stakey_rsp *)0)) {
#line 687
    kfree((void const   *)ph2c);
#line 688
    kfree((void const   *)psetstakey_para);
#line 689
    res = 0;
#line 690
    goto exit;
  } else {

  }
#line 693
  ph2c->cmdcode = 21U;
#line 693
  ph2c->parmbuf = (u8 *)psetstakey_para;
#line 693
  ph2c->cmdsz = 28U;
#line 693
  ph2c->rsp = (u8 *)0U;
#line 693
  ph2c->rspsz = 0U;
#line 694
  ph2c->rsp = (u8 *)psetstakey_rsp;
#line 695
  ph2c->rspsz = 8U;
#line 697
  ether_addr_copy((u8 *)(& psetstakey_para->addr), (u8 const   *)(& sta->hwaddr));
#line 699
  tmp___2 = check_fwstate(pmlmepriv, 8);
#line 699
  if ((int )tmp___2) {
#line 700
    psetstakey_para->algorithm = (u32 )((unsigned char )psecuritypriv->dot11PrivacyAlgrthm);
  } else {
#line 703
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U: 
#line 703
    psetstakey_para->algorithm = psecuritypriv->dot11PrivacyAlgrthm;
#line 703
    goto ldv_55920;
    case 2U: 
#line 703
    psetstakey_para->algorithm = sta->dot118021XPrivacy;
#line 703
    goto ldv_55920;
    }
    ldv_55920: ;
  }
#line 707
  if ((unsigned int )unicast_key == 1U) {
#line 708
    memcpy((void *)(& psetstakey_para->key), (void const   *)(& sta->dot118021x_UncstKey),
             16UL);
  } else {
#line 710
    idx = (int )psecuritypriv->dot118021XGrpKeyid;
#line 712
    memcpy((void *)(& psetstakey_para->key), (void const   *)(& psecuritypriv->dot118021XGrpKey[idx].skey),
             16UL);
  }
#line 717
  padapter->securitypriv.busetkipkey = 1U;
#line 719
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
#line 723
  return (res);
}
}
#line 726 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_clearstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 entry , u8 enqueue ) 
{ 
  struct cmd_obj *ph2c ;
  struct set_stakey_parm *psetstakey_para ;
  struct cmd_priv *pcmdpriv ;
  struct set_stakey_rsp *psetstakey_rsp ;
  struct sta_info *sta ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 731
  pcmdpriv = & padapter->cmdpriv;
#line 732
  psetstakey_rsp = (struct set_stakey_rsp *)0;
#line 733
  sta = (struct sta_info *)psta;
#line 734
  res = 1;
#line 736
  if ((unsigned int )enqueue == 0U) {
#line 737
    clear_cam_entry23a(padapter, (int )entry);
  } else {
#line 739
    tmp = kzalloc(128UL, 208U);
#line 739
    ph2c = (struct cmd_obj *)tmp;
#line 740
    if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 741
      res = 0;
#line 742
      goto exit;
    } else {

    }
#line 745
    tmp___0 = kzalloc(28UL, 208U);
#line 745
    psetstakey_para = (struct set_stakey_parm *)tmp___0;
#line 747
    if ((unsigned long )psetstakey_para == (unsigned long )((struct set_stakey_parm *)0)) {
#line 748
      kfree((void const   *)ph2c);
#line 749
      res = 0;
#line 750
      goto exit;
    } else {

    }
#line 753
    tmp___1 = kzalloc(8UL, 208U);
#line 753
    psetstakey_rsp = (struct set_stakey_rsp *)tmp___1;
#line 755
    if ((unsigned long )psetstakey_rsp == (unsigned long )((struct set_stakey_rsp *)0)) {
#line 756
      kfree((void const   *)ph2c);
#line 757
      kfree((void const   *)psetstakey_para);
#line 758
      res = 0;
#line 759
      goto exit;
    } else {

    }
#line 762
    ph2c->cmdcode = 21U;
#line 762
    ph2c->parmbuf = (u8 *)psetstakey_para;
#line 762
    ph2c->cmdsz = 28U;
#line 762
    ph2c->rsp = (u8 *)0U;
#line 762
    ph2c->rspsz = 0U;
#line 764
    ph2c->rsp = (u8 *)psetstakey_rsp;
#line 765
    ph2c->rspsz = 8U;
#line 767
    ether_addr_copy((u8 *)(& psetstakey_para->addr), (u8 const   *)(& sta->hwaddr));
#line 769
    psetstakey_para->algorithm = 0U;
#line 771
    psetstakey_para->id = entry;
#line 773
    res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  }
  exit: ;
#line 776
  return (res);
}
}
#line 779 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_addbareq_cmd23a(struct rtw_adapter *padapter , u8 tid , u8 *addr ) 
{ 
  struct cmd_priv *pcmdpriv ;
  struct cmd_obj *ph2c ;
  struct addBaReq_parm *paddbareq_parm ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 781
  pcmdpriv = & padapter->cmdpriv;
#line 784
  res = 1;
#line 786
  if ((unsigned int )tid > 15U) {
#line 787
    res = 0;
#line 788
    goto exit;
  } else {

  }
#line 791
  tmp = kzalloc(128UL, 32U);
#line 791
  ph2c = (struct cmd_obj *)tmp;
#line 792
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 793
    res = 0;
#line 794
    goto exit;
  } else {

  }
#line 797
  tmp___0 = kzalloc(12UL, 32U);
#line 797
  paddbareq_parm = (struct addBaReq_parm *)tmp___0;
#line 798
  if ((unsigned long )paddbareq_parm == (unsigned long )((struct addBaReq_parm *)0)) {
#line 799
    kfree((void const   *)ph2c);
#line 800
    res = 0;
#line 801
    goto exit;
  } else {

  }
#line 804
  paddbareq_parm->tid = (unsigned int )tid;
#line 805
  ether_addr_copy((u8 *)(& paddbareq_parm->addr), (u8 const   *)addr);
#line 807
  ph2c->cmdcode = 45U;
#line 807
  ph2c->parmbuf = (u8 *)paddbareq_parm;
#line 807
  ph2c->cmdsz = 12U;
#line 807
  ph2c->rsp = (u8 *)0U;
#line 807
  ph2c->rspsz = 0U;
#line 810
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
#line 812
  return (res);
}
}
#line 815 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_dynamic_chk_wk_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 819
  pcmdpriv = & padapter->cmdpriv;
#line 820
  res = 1;
#line 822
  tmp = kzalloc(128UL, 32U);
#line 822
  ph2c = (struct cmd_obj *)tmp;
#line 823
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 824
    res = 0;
#line 825
    goto exit;
  } else {

  }
#line 828
  tmp___0 = kzalloc(16UL, 32U);
#line 828
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
#line 829
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
#line 830
    kfree((void const   *)ph2c);
#line 831
    res = 0;
#line 832
    goto exit;
  } else {

  }
#line 835
  pdrvextra_cmd_parm->ec_id = 1;
#line 836
  pdrvextra_cmd_parm->type_size = 0;
#line 837
  pdrvextra_cmd_parm->pbuf = (unsigned char *)padapter;
#line 839
  ph2c->cmdcode = 57U;
#line 839
  ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
#line 839
  ph2c->cmdsz = 16U;
#line 839
  ph2c->rsp = (u8 *)0U;
#line 839
  ph2c->rspsz = 0U;
#line 842
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
#line 845
  return (res);
}
}
#line 848 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
static void traffic_status_watchdog(struct rtw_adapter *padapter ) 
{ 
  u8 bEnterPS ;
  u8 bBusyTraffic ;
  u8 bTxBusyTraffic ;
  u8 bRxBusyTraffic ;
  u8 bHigherBusyTraffic ;
  u8 bHigherBusyRxTraffic ;
  u8 bHigherBusyTxTraffic ;
  struct mlme_priv *pmlmepriv ;
  int BusyThreshold ;
  struct rt_link_detect *ldi ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;

  {
#line 851
  bBusyTraffic = 0U;
#line 851
  bTxBusyTraffic = 0U;
#line 851
  bRxBusyTraffic = 0U;
#line 852
  bHigherBusyTraffic = 0U;
#line 852
  bHigherBusyRxTraffic = 0U;
#line 853
  bHigherBusyTxTraffic = 0U;
#line 854
  pmlmepriv = & padapter->mlmepriv;
#line 855
  BusyThreshold = 100;
#line 856
  ldi = & pmlmepriv->LinkDetectInfo;
#line 861
  tmp___4 = check_fwstate(pmlmepriv, 1);
#line 861
  if ((int )tmp___4) {
#line 862
    tmp = rtl8723a_BT_coexist(padapter);
#line 862
    if ((int )tmp) {
#line 863
      BusyThreshold = 50;
    } else
#line 864
    if ((int )ldi->bBusyTraffic) {
#line 865
      BusyThreshold = 75;
    } else {

    }
#line 868
    if (ldi->NumRxOkInPeriod > (u32 )BusyThreshold || ldi->NumTxOkInPeriod > (u32 )BusyThreshold) {
#line 870
      bBusyTraffic = 1U;
#line 872
      if (ldi->NumRxOkInPeriod > ldi->NumTxOkInPeriod) {
#line 873
        bRxBusyTraffic = 1U;
      } else {
#line 875
        bTxBusyTraffic = 1U;
      }
    } else {

    }
#line 879
    if (ldi->NumRxOkInPeriod > 4000U || ldi->NumTxOkInPeriod > 4000U) {
#line 881
      bHigherBusyTraffic = 1U;
#line 883
      if (ldi->NumRxOkInPeriod > ldi->NumTxOkInPeriod) {
#line 884
        bHigherBusyRxTraffic = 1U;
      } else {
#line 886
        bHigherBusyTxTraffic = 1U;
      }
    } else {

    }
#line 889
    tmp___0 = rtl8723a_BT_coexist(padapter);
#line 889
    if (tmp___0) {
#line 889
      tmp___1 = 0;
    } else {
#line 889
      tmp___1 = 1;
    }
#line 889
    if (tmp___1) {
#line 889
      goto _L;
    } else {
#line 889
      tmp___2 = rtl8723a_BT_using_antenna_1(padapter);
#line 889
      if (tmp___2) {
#line 889
        tmp___3 = 0;
      } else {
#line 889
        tmp___3 = 1;
      }
#line 889
      if (tmp___3) {
        _L: /* CIL Label */ 
#line 892
        if (ldi->NumRxUnicastOkInPeriod + ldi->NumTxOkInPeriod > 8U || ldi->NumRxUnicastOkInPeriod > 2U) {
#line 895
          bEnterPS = 0U;
        } else {
#line 897
          bEnterPS = 1U;
        }
#line 900
        if ((unsigned int )bEnterPS != 0U) {
#line 901
          LPS_Enter23a(padapter);
        } else {
#line 903
          LPS_Leave23a(padapter);
        }
      } else {

      }
    }
  } else {
#line 906
    LPS_Leave23a(padapter);
  }
#line 908
  ldi->NumRxOkInPeriod = 0U;
#line 909
  ldi->NumTxOkInPeriod = 0U;
#line 910
  ldi->NumRxUnicastOkInPeriod = 0U;
#line 911
  ldi->bBusyTraffic = (unsigned int )bBusyTraffic != 0U;
#line 912
  ldi->bTxBusyTraffic = (unsigned int )bTxBusyTraffic != 0U;
#line 913
  ldi->bRxBusyTraffic = (unsigned int )bRxBusyTraffic != 0U;
#line 914
  ldi->bHigherBusyTraffic = (unsigned int )bHigherBusyTraffic != 0U;
#line 915
  ldi->bHigherBusyRxTraffic = (unsigned int )bHigherBusyRxTraffic != 0U;
#line 916
  ldi->bHigherBusyTxTraffic = (unsigned int )bHigherBusyTxTraffic != 0U;
#line 917
  return;
}
}
#line 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
static void dynamic_chk_wk_hdl(struct rtw_adapter *padapter , u8 *pbuf , int sz ) 
{ 
  struct mlme_priv *pmlmepriv ;
  bool tmp ;

  {
#line 923
  padapter = (struct rtw_adapter *)pbuf;
#line 924
  pmlmepriv = & padapter->mlmepriv;
#line 927
  tmp = check_fwstate(pmlmepriv, 16);
#line 927
  if ((int )tmp) {
#line 928
    expire_timeout_chk23a(padapter);
  } else {

  }
#line 931
  rtl8723a_sreset_xmit_status_check(padapter);
#line 933
  linked_status_chk23a(padapter);
#line 934
  traffic_status_watchdog(padapter);
#line 936
  rtl8723a_HalDmWatchDog(padapter);
#line 941
  rtl8723a_BT_do_coexist(padapter);
#line 942
  return;
}
}
#line 944 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
static void lps_ctrl_wk_hdl(struct rtw_adapter *padapter , u8 lps_ctrl_type ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  u8 mstatus ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;

  {
#line 946
  pwrpriv = & padapter->pwrctrlpriv;
#line 947
  pmlmepriv = & padapter->mlmepriv;
#line 950
  tmp = check_fwstate(pmlmepriv, 64);
#line 950
  if ((int )tmp) {
#line 952
    return;
  } else {
#line 950
    tmp___0 = check_fwstate(pmlmepriv, 32);
#line 950
    if ((int )tmp___0) {
#line 952
      return;
    } else {

    }
  }
#line 954
  switch ((int )lps_ctrl_type) {
  case 0: 
#line 956
  rtl8723a_BT_wifiscan_notify(padapter, 1);
#line 957
  tmp___2 = rtl8723a_BT_using_antenna_1(padapter);
#line 957
  if (tmp___2) {
#line 957
    tmp___3 = 0;
  } else {
#line 957
    tmp___3 = 1;
  }
#line 957
  if (tmp___3) {
#line 958
    tmp___1 = check_fwstate(pmlmepriv, 1);
#line 958
    if ((int )tmp___1) {
#line 959
      LPS_Leave23a(padapter);
    } else {

    }
  } else {

  }
#line 961
  goto ldv_55981;
  case 1: 
#line 963
  LPS_Leave23a(padapter);
#line 964
  goto ldv_55981;
  case 2: 
#line 966
  mstatus = 1U;
#line 968
  padapter->pwrctrlpriv.LpsIdleCount = 0U;
#line 969
  rtl8723a_set_FwJoinBssReport_cmd(padapter, 1);
#line 970
  rtl8723a_BT_mediastatus_notify(padapter, (enum rt_media_status )mstatus);
#line 971
  goto ldv_55981;
  case 3: 
#line 973
  mstatus = 0U;
#line 974
  rtl8723a_BT_mediastatus_notify(padapter, (enum rt_media_status )mstatus);
#line 975
  tmp___4 = rtl8723a_BT_using_antenna_1(padapter);
#line 975
  if (tmp___4) {
#line 975
    tmp___5 = 0;
  } else {
#line 975
    tmp___5 = 1;
  }
#line 975
  if (tmp___5) {
#line 976
    LPS_Leave23a(padapter);
  } else {

  }
#line 977
  rtl8723a_set_FwJoinBssReport_cmd(padapter, 0);
#line 978
  goto ldv_55981;
  case 4: 
#line 980
  pwrpriv->DelayLPSLastTimeStamp = jiffies;
#line 981
  rtl8723a_BT_specialpacket_notify(padapter);
#line 982
  tmp___6 = rtl8723a_BT_using_antenna_1(padapter);
#line 982
  if (tmp___6) {
#line 982
    tmp___7 = 0;
  } else {
#line 982
    tmp___7 = 1;
  }
#line 982
  if (tmp___7) {
#line 983
    LPS_Leave23a(padapter);
  } else {

  }
#line 984
  goto ldv_55981;
  case 5: 
#line 986
  rtl8723a_BT_lps_leave(padapter);
#line 987
  tmp___8 = rtl8723a_BT_using_antenna_1(padapter);
#line 987
  if (tmp___8) {
#line 987
    tmp___9 = 0;
  } else {
#line 987
    tmp___9 = 1;
  }
#line 987
  if (tmp___9) {
#line 988
    LPS_Leave23a(padapter);
  } else {

  }
#line 989
  goto ldv_55981;
  default: ;
#line 992
  goto ldv_55981;
  }
  ldv_55981: ;
#line 995
  return;
}
}
#line 996 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_lps_ctrl_wk_cmd23a(struct rtw_adapter *padapter , u8 lps_ctrl_type , u8 enqueue ) 
{ 
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1001
  pcmdpriv = & padapter->cmdpriv;
#line 1002
  res = 1;
#line 1004
  if ((unsigned int )enqueue != 0U) {
#line 1005
    tmp = kzalloc(128UL, 32U);
#line 1005
    ph2c = (struct cmd_obj *)tmp;
#line 1006
    if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 1007
      res = 0;
#line 1008
      goto exit;
    } else {

    }
#line 1011
    tmp___0 = kzalloc(16UL, 32U);
#line 1011
    pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
#line 1013
    if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
#line 1014
      kfree((void const   *)ph2c);
#line 1015
      res = 0;
#line 1016
      goto exit;
    } else {

    }
#line 1019
    pdrvextra_cmd_parm->ec_id = 5;
#line 1020
    pdrvextra_cmd_parm->type_size = (int )lps_ctrl_type;
#line 1021
    pdrvextra_cmd_parm->pbuf = (unsigned char *)0U;
#line 1023
    ph2c->cmdcode = 57U;
#line 1023
    ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
#line 1023
    ph2c->cmdsz = 16U;
#line 1023
    ph2c->rsp = (u8 *)0U;
#line 1023
    ph2c->rspsz = 0U;
#line 1026
    res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  } else {
#line 1028
    lps_ctrl_wk_hdl(padapter, (int )lps_ctrl_type);
  }
  exit: ;
#line 1031
  return (res);
}
}
#line 1034 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_ps_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *ppscmd ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1038
  pcmdpriv = & padapter->cmdpriv;
#line 1039
  res = 1;
#line 1041
  tmp = kzalloc(128UL, 32U);
#line 1041
  ppscmd = (struct cmd_obj *)tmp;
#line 1042
  if ((unsigned long )ppscmd == (unsigned long )((struct cmd_obj *)0)) {
#line 1043
    res = 0;
#line 1044
    goto exit;
  } else {

  }
#line 1047
  tmp___0 = kzalloc(16UL, 32U);
#line 1047
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
#line 1049
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
#line 1050
    kfree((void const   *)ppscmd);
#line 1051
    res = 0;
#line 1052
    goto exit;
  } else {

  }
#line 1055
  pdrvextra_cmd_parm->ec_id = 4;
#line 1056
  pdrvextra_cmd_parm->pbuf = (unsigned char *)0U;
#line 1057
  ppscmd->cmdcode = 57U;
#line 1057
  ppscmd->parmbuf = (u8 *)pdrvextra_cmd_parm;
#line 1057
  ppscmd->cmdsz = 16U;
#line 1057
  ppscmd->rsp = (u8 *)0U;
#line 1057
  ppscmd->rspsz = 0U;
#line 1060
  res = rtw_enqueue_cmd23a(pcmdpriv, ppscmd);
  exit: ;
#line 1063
  return (res);
}
}
#line 1068 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
static void rtw_chk_hi_queue_hdl(struct rtw_adapter *padapter ) 
{ 
  int cnt ;
  struct sta_info *psta_bmc ;
  struct sta_priv *pstapriv ;
  bool val ;

  {
#line 1070
  cnt = 0;
#line 1072
  pstapriv = & padapter->stapriv;
#line 1074
  psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
#line 1075
  if ((unsigned long )psta_bmc == (unsigned long )((struct sta_info *)0)) {
#line 1076
    return;
  } else {

  }
#line 1078
  if (psta_bmc->sleepq_len == 0U) {
#line 1081
    val = rtl8723a_chk_hi_queue_empty(padapter);
#line 1083
    goto ldv_56015;
    ldv_56014: 
#line 1084
    msleep(100U);
#line 1086
    cnt = cnt + 1;
#line 1088
    if (cnt > 10) {
#line 1089
      goto ldv_56013;
    } else {

    }
#line 1091
    val = rtl8723a_chk_hi_queue_empty(padapter);
    ldv_56015: ;
#line 1083
    if (! val) {
#line 1085
      goto ldv_56014;
    } else {

    }
    ldv_56013: ;
#line 1094
    if (cnt <= 10) {
#line 1095
      pstapriv->tim_bitmap = (unsigned int )pstapriv->tim_bitmap & 65534U;
#line 1096
      pstapriv->sta_dz_bitmap = (unsigned int )pstapriv->sta_dz_bitmap & 65534U;
#line 1098
      update_beacon23a(padapter, 5, (u8 *)0U, 0);
    } else {
#line 1100
      rtw_chk_hi_queue_cmd23a(padapter);
    }
  } else {

  }
#line 1102
  return;
}
}
#line 1104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_chk_hi_queue_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1108
  pcmdpriv = & padapter->cmdpriv;
#line 1109
  res = 1;
#line 1111
  tmp = kzalloc(128UL, 32U);
#line 1111
  ph2c = (struct cmd_obj *)tmp;
#line 1112
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 1113
    res = 0;
#line 1114
    goto exit;
  } else {

  }
#line 1117
  tmp___0 = kzalloc(16UL, 32U);
#line 1117
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
#line 1119
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
#line 1120
    kfree((void const   *)ph2c);
#line 1121
    res = 0;
#line 1122
    goto exit;
  } else {

  }
#line 1125
  pdrvextra_cmd_parm->ec_id = 9;
#line 1126
  pdrvextra_cmd_parm->type_size = 0;
#line 1127
  pdrvextra_cmd_parm->pbuf = (unsigned char *)0U;
#line 1129
  ph2c->cmdcode = 57U;
#line 1129
  ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
#line 1129
  ph2c->cmdsz = 16U;
#line 1129
  ph2c->rsp = (u8 *)0U;
#line 1129
  ph2c->rspsz = 0U;
#line 1132
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
#line 1135
  return (res);
}
}
#line 1139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_c2h_wk_cmd23a(struct rtw_adapter *padapter , u8 *c2h_evt ) 
{ 
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1143
  pcmdpriv = & padapter->cmdpriv;
#line 1144
  res = 1;
#line 1146
  tmp = kzalloc(128UL, 32U);
#line 1146
  ph2c = (struct cmd_obj *)tmp;
#line 1147
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 1148
    res = 0;
#line 1149
    goto exit;
  } else {

  }
#line 1152
  tmp___0 = kzalloc(16UL, 32U);
#line 1152
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
#line 1154
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
#line 1155
    kfree((void const   *)ph2c);
#line 1156
    res = 0;
#line 1157
    goto exit;
  } else {

  }
#line 1160
  pdrvextra_cmd_parm->ec_id = 10;
#line 1161
  pdrvextra_cmd_parm->type_size = (unsigned long )c2h_evt != (unsigned long )((u8 *)0U) ? 16 : 0;
#line 1162
  pdrvextra_cmd_parm->pbuf = c2h_evt;
#line 1164
  ph2c->cmdcode = 57U;
#line 1164
  ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
#line 1164
  ph2c->cmdsz = 16U;
#line 1164
  ph2c->rsp = (u8 *)0U;
#line 1164
  ph2c->rspsz = 0U;
#line 1167
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
#line 1171
  return (res);
}
}
#line 1174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
static int c2h_evt_hdl(struct rtw_adapter *adapter , struct c2h_evt_hdr *c2h_evt ) 
{ 
  int ret ;
  u8 buf[16U] ;
  s32 tmp ;

  {
#line 1176
  ret = 0;
#line 1179
  if ((unsigned long )c2h_evt == (unsigned long )((struct c2h_evt_hdr *)0)) {
#line 1181
    tmp = c2h_evt_read23a(adapter, (u8 *)(& buf));
#line 1181
    if (tmp == 1) {
#line 1182
      c2h_evt = (struct c2h_evt_hdr *)(& buf);
#line 1184
      ret = c2h_handler_8723a(adapter, c2h_evt);
    } else {

    }
  } else {
#line 1187
    ret = c2h_handler_8723a(adapter, c2h_evt);
  }
#line 1189
  return (ret);
}
}
#line 1192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
static void rtw_irq_work(struct work_struct *work ) 
{ 
  struct evt_priv *evtpriv ;
  struct rtw_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  struct evt_priv  const  *__mptr___0 ;

  {
#line 1197
  __mptr = (struct work_struct  const  *)work;
#line 1197
  evtpriv = (struct evt_priv *)__mptr + 0xfffffffffffffff8UL;
#line 1198
  __mptr___0 = (struct evt_priv  const  *)evtpriv;
#line 1198
  adapter = (struct rtw_adapter *)__mptr___0 + 0xffffffffffffe830UL;
#line 1200
  c2h_evt_clear23a(adapter);
#line 1201
  return;
}
}
#line 1203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
void rtw_evt_work(struct work_struct *work ) 
{ 
  struct evt_work *ework ;
  struct rtw_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  bool tmp ;

  {
#line 1208
  __mptr = (struct work_struct  const  *)work;
#line 1208
  ework = (struct evt_work *)__mptr + 0xfffffffffffffff0UL;
#line 1209
  adapter = ework->adapter;
#line 1211
  c2h_evt_clear23a(adapter);
#line 1213
  if ((unsigned int )*((unsigned char *)ework + 0UL) == 0U && (unsigned int )*((unsigned char *)ework + 0UL) == 0U) {
#line 1214
    kfree((void const   *)ework);
#line 1215
    return;
  } else {

  }
#line 1218
  tmp = c2h_id_filter_ccx_8723a((int )ework->u.c2h_evt.id);
#line 1218
  if ((int )tmp) {
#line 1220
    c2h_handler_8723a(adapter, & ework->u.c2h_evt);
#line 1221
    kfree((void const   *)ework);
  } else {
#line 1228
    rtw_c2h_wk_cmd23a(adapter, (u8 *)(& ework->u.c2h_evt));
  }
#line 1229
  return;
}
}
#line 1232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
int rtw_drvextra_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct drvextra_cmd_parm  const  *pdrvextra_cmd ;

  {
#line 1236
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
#line 1237
    return (4);
  } else {

  }
#line 1239
  pdrvextra_cmd = (struct drvextra_cmd_parm  const  *)pbuf;
#line 1241
  switch (pdrvextra_cmd->ec_id) {
  case 1: 
#line 1243
  dynamic_chk_wk_hdl(padapter, (u8 *)pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
#line 1245
  goto ldv_56061;
  case 4: 
#line 1247
  rtw_ps_processor23a(padapter);
#line 1248
  goto ldv_56061;
  case 5: 
#line 1250
  lps_ctrl_wk_hdl(padapter, (int )((unsigned char )pdrvextra_cmd->type_size));
#line 1251
  goto ldv_56061;
  case 9: 
#line 1254
  rtw_chk_hi_queue_hdl(padapter);
#line 1255
  goto ldv_56061;
  case 10: 
#line 1258
  c2h_evt_hdl(padapter, (struct c2h_evt_hdr *)pdrvextra_cmd->pbuf);
#line 1260
  goto ldv_56061;
  default: ;
#line 1263
  goto ldv_56061;
  }
  ldv_56061: ;
#line 1266
  if ((unsigned long )pdrvextra_cmd->pbuf != (unsigned long )((unsigned char */* const  */)0U) && (int )pdrvextra_cmd->type_size > 0) {
#line 1267
    kfree((void const   *)pdrvextra_cmd->pbuf);
  } else {

  }
#line 1275
  return (0);
}
}
#line 1278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
void rtw_survey_cmd_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct mlme_priv *pmlmepriv ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 1281
  pmlmepriv = & padapter->mlmepriv;
#line 1283
  if (pcmd->res == 3) {
#line 1286
    tmp = msecs_to_jiffies(1U);
#line 1286
    ldv_mod_timer_12(& pmlmepriv->scan_to_timer, tmp + (unsigned long )jiffies);
  } else
#line 1288
  if (pcmd->res != 0) {
#line 1289
    tmp___0 = msecs_to_jiffies(1U);
#line 1289
    ldv_mod_timer_13(& pmlmepriv->scan_to_timer, tmp___0 + (unsigned long )jiffies);
#line 1291
    if (GlobalDebugLevel23A > 3U) {
#line 1291
      rt_trace(128, 4, "********Error: MgntActrtw_set_802_11_bssid23a_LIST_SCAN Fail ************\n");
    } else {

    }
  } else {

  }
#line 1296
  rtw_free_cmd_obj23a(pcmd);
#line 1297
  return;
}
}
#line 1299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
void rtw_disassoc_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct mlme_priv *pmlmepriv ;

  {
#line 1302
  pmlmepriv = & padapter->mlmepriv;
#line 1304
  if (pcmd->res != 0) {
#line 1305
    spin_lock_bh(& pmlmepriv->lock);
#line 1306
    set_fwstate(pmlmepriv, 1);
#line 1307
    spin_unlock_bh(& pmlmepriv->lock);
#line 1308
    if (GlobalDebugLevel23A > 3U) {
#line 1308
      rt_trace(128, 4, "***Error: disconnect_cmd_callback Fail ***\n");
    } else {

    }
#line 1310
    return;
  } else {

  }
#line 1314
  rtw_free_cmd_obj23a(pcmd);
#line 1315
  return;
}
}
#line 1317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
void rtw_joinbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct mlme_priv *pmlmepriv ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 1320
  pmlmepriv = & padapter->mlmepriv;
#line 1322
  if (pcmd->res == 3) {
#line 1325
    tmp = msecs_to_jiffies(1U);
#line 1325
    ldv_mod_timer_14(& pmlmepriv->assoc_timer, tmp + (unsigned long )jiffies);
  } else
#line 1327
  if (pcmd->res != 0) {
#line 1328
    if (GlobalDebugLevel23A > 3U) {
#line 1328
      rt_trace(128, 4, "********Error:rtw_select_and_join_from_scanned_queue Wait Sema  Fail ************\n");
    } else {

    }
#line 1330
    tmp___0 = msecs_to_jiffies(1U);
#line 1330
    ldv_mod_timer_15(& pmlmepriv->assoc_timer, tmp___0 + (unsigned long )jiffies);
  } else {

  }
#line 1334
  rtw_free_cmd_obj23a(pcmd);
#line 1335
  return;
}
}
#line 1337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
void rtw_createbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct sta_info *psta ;
  struct wlan_network *pwlan ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pnetwork ;
  struct wlan_network *tgt_network ;
  unsigned long tmp ;
  uint tmp___0 ;
  bool tmp___1 ;

  {
#line 1342
  pmlmepriv = & padapter->mlmepriv;
#line 1343
  pnetwork = (struct wlan_bssid_ex *)pcmd->parmbuf;
#line 1344
  tgt_network = & pmlmepriv->cur_network;
#line 1346
  if (pcmd->res != 0) {
#line 1347
    if (GlobalDebugLevel23A > 3U) {
#line 1347
      rt_trace(128, 4, "********Error: rtw_createbss_cmd23a_callback  Fail ************\n");
    } else {

    }
#line 1349
    tmp = msecs_to_jiffies(1U);
#line 1349
    ldv_mod_timer_16(& pmlmepriv->assoc_timer, tmp + (unsigned long )jiffies);
  } else {

  }
#line 1353
  ldv_del_timer_sync_17(& pmlmepriv->assoc_timer);
#line 1355
  tmp___1 = check_fwstate(pmlmepriv, 16);
#line 1355
  if ((int )tmp___1) {
#line 1356
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pnetwork->MacAddress));
#line 1358
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1359
      psta = rtw_alloc_stainfo23a(& padapter->stapriv, (u8 const   *)(& pnetwork->MacAddress),
                                  208U);
#line 1362
      if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1363
        if (GlobalDebugLevel23A > 3U) {
#line 1363
          rt_trace(128, 4, "Can\'t alloc sta_info when createbss_cmd_callback\n");
        } else {

        }
#line 1365
        goto createbss_cmd_fail;
      } else {

      }
    } else {

    }
#line 1369
    spin_lock_bh(& pmlmepriv->lock);
#line 1370
    rtw_indicate_connect23a(padapter);
#line 1371
    spin_unlock_bh(& pmlmepriv->lock);
  } else {
#line 1373
    pwlan = rtw_alloc_network(pmlmepriv, 208U);
#line 1374
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 1375
    if ((unsigned long )pwlan == (unsigned long )((struct wlan_network *)0)) {
#line 1376
      pwlan = rtw_get_oldest_wlan_network23a(& pmlmepriv->scanned_queue);
#line 1377
      if ((unsigned long )pwlan == (unsigned long )((struct wlan_network *)0)) {
#line 1378
        if (GlobalDebugLevel23A > 3U) {
#line 1378
          rt_trace(128, 4, "Error:  can\'t get pwlan in rtw23a_joinbss_event_cb\n");
        } else {

        }
#line 1380
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1381
        goto createbss_cmd_fail;
      } else {

      }
#line 1383
      pwlan->last_scanned = jiffies;
    } else {
#line 1385
      list_add_tail(& pwlan->list, & pmlmepriv->scanned_queue.queue);
    }
#line 1389
    pnetwork->Length = get_wlan_bssid_ex_sz(pnetwork);
#line 1390
    memcpy((void *)(& pwlan->network), (void const   *)pnetwork, (size_t )pnetwork->Length);
#line 1398
    tmp___0 = get_wlan_bssid_ex_sz(pnetwork);
#line 1398
    memcpy((void *)(& tgt_network->network), (void const   *)pnetwork, (size_t )tmp___0);
#line 1403
    clr_fwstate(pmlmepriv, 128);
#line 1405
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  }
  createbss_cmd_fail: 
#line 1412
  rtw_free_cmd_obj23a(pcmd);
#line 1413
  return;
}
}
#line 1415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
void rtw_setstaKey_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct sta_priv *pstapriv ;
  struct set_stakey_rsp *psetstakey_rsp ;
  struct sta_info *psta ;

  {
#line 1422
  pstapriv = & padapter->stapriv;
#line 1423
  psetstakey_rsp = (struct set_stakey_rsp *)pcmd->rsp;
#line 1424
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& psetstakey_rsp->addr));
#line 1426
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1427
    if (GlobalDebugLevel23A > 3U) {
#line 1427
      rt_trace(128, 4, "OLD_ERROR: rtw_setstaKey_cmdrsp_callback23a => can\'t get sta_info\n");
    } else {

    }
#line 1429
    goto exit;
  } else {

  }
  exit: 
#line 1434
  rtw_free_cmd_obj23a(pcmd);
#line 1435
  return;
}
}
#line 1437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.c"
void rtw_setassocsta_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct set_assocsta_parm *passocsta_parm ;
  struct set_assocsta_rsp *passocsta_rsp ;
  struct sta_info *psta ;
  uint tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 1440
  pstapriv = & padapter->stapriv;
#line 1441
  pmlmepriv = & padapter->mlmepriv;
#line 1446
  passocsta_parm = (struct set_assocsta_parm *)pcmd->parmbuf;
#line 1447
  passocsta_rsp = (struct set_assocsta_rsp *)pcmd->rsp;
#line 1448
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& passocsta_parm->addr));
#line 1450
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1451
    if (GlobalDebugLevel23A > 3U) {
#line 1451
      rt_trace(128, 4, "OLD_ERROR: setassocsta_cmdrsp_callbac => can\'t get sta_info\n");
    } else {

    }
#line 1453
    goto exit;
  } else {

  }
#line 1456
  tmp = (uint )passocsta_rsp->cam_id;
#line 1456
  psta->mac_id = tmp;
#line 1456
  psta->aid = tmp;
#line 1458
  spin_lock_bh(& pmlmepriv->lock);
#line 1460
  tmp___0 = check_fwstate(pmlmepriv, 65536);
#line 1460
  if ((int )tmp___0) {
#line 1460
    tmp___1 = check_fwstate(pmlmepriv, 128);
#line 1460
    if ((int )tmp___1) {
#line 1462
      _clr_fwstate_(pmlmepriv, 128);
    } else {

    }
  } else {

  }
#line 1464
  set_fwstate(pmlmepriv, 1);
#line 1465
  spin_unlock_bh(& pmlmepriv->lock);
  exit: 
#line 1468
  rtw_free_cmd_obj23a(pcmd);
#line 1469
  return;
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void call_and_disable_work_1(struct work_struct *work ) 
{ 


  {
#line 253
  if ((ldv_work_1_0 == 2 || ldv_work_1_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_0) {
#line 255
    rtw_irq_work(work);
#line 256
    ldv_work_1_0 = 1;
#line 257
    return;
  } else {

  }
#line 259
  if ((ldv_work_1_1 == 2 || ldv_work_1_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_1) {
#line 261
    rtw_irq_work(work);
#line 262
    ldv_work_1_1 = 1;
#line 263
    return;
  } else {

  }
#line 265
  if ((ldv_work_1_2 == 2 || ldv_work_1_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_2) {
#line 267
    rtw_irq_work(work);
#line 268
    ldv_work_1_2 = 1;
#line 269
    return;
  } else {

  }
#line 271
  if ((ldv_work_1_3 == 2 || ldv_work_1_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_3) {
#line 273
    rtw_irq_work(work);
#line 274
    ldv_work_1_3 = 1;
#line 275
    return;
  } else {

  }
#line 277
  return;
}
}
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void call_and_disable_all_2(int state ) 
{ 


  {
#line 282
  if (ldv_work_2_0 == state) {
#line 283
    call_and_disable_work_2(ldv_work_struct_2_0);
  } else {

  }
#line 284
  if (ldv_work_2_1 == state) {
#line 285
    call_and_disable_work_2(ldv_work_struct_2_1);
  } else {

  }
#line 286
  if (ldv_work_2_2 == state) {
#line 287
    call_and_disable_work_2(ldv_work_struct_2_2);
  } else {

  }
#line 288
  if (ldv_work_2_3 == state) {
#line 289
    call_and_disable_work_2(ldv_work_struct_2_3);
  } else {

  }
#line 290
  return;
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void activate_work_1(struct work_struct *work , int state ) 
{ 


  {
#line 294
  if (ldv_work_1_0 == 0) {
#line 295
    ldv_work_struct_1_0 = work;
#line 296
    ldv_work_1_0 = state;
#line 297
    return;
  } else {

  }
#line 300
  if (ldv_work_1_1 == 0) {
#line 301
    ldv_work_struct_1_1 = work;
#line 302
    ldv_work_1_1 = state;
#line 303
    return;
  } else {

  }
#line 306
  if (ldv_work_1_2 == 0) {
#line 307
    ldv_work_struct_1_2 = work;
#line 308
    ldv_work_1_2 = state;
#line 309
    return;
  } else {

  }
#line 312
  if (ldv_work_1_3 == 0) {
#line 313
    ldv_work_struct_1_3 = work;
#line 314
    ldv_work_1_3 = state;
#line 315
    return;
  } else {

  }
#line 317
  return;
}
}
#line 320 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void disable_work_1(struct work_struct *work ) 
{ 


  {
#line 322
  if ((ldv_work_1_0 == 3 || ldv_work_1_0 == 2) && (unsigned long )ldv_work_struct_1_0 == (unsigned long )work) {
#line 324
    ldv_work_1_0 = 1;
  } else {

  }
#line 326
  if ((ldv_work_1_1 == 3 || ldv_work_1_1 == 2) && (unsigned long )ldv_work_struct_1_1 == (unsigned long )work) {
#line 328
    ldv_work_1_1 = 1;
  } else {

  }
#line 330
  if ((ldv_work_1_2 == 3 || ldv_work_1_2 == 2) && (unsigned long )ldv_work_struct_1_2 == (unsigned long )work) {
#line 332
    ldv_work_1_2 = 1;
  } else {

  }
#line 334
  if ((ldv_work_1_3 == 3 || ldv_work_1_3 == 2) && (unsigned long )ldv_work_struct_1_3 == (unsigned long )work) {
#line 336
    ldv_work_1_3 = 1;
  } else {

  }
#line 337
  return;
}
}
#line 341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void work_init_1(void) 
{ 


  {
#line 342
  ldv_work_1_0 = 0;
#line 343
  ldv_work_1_1 = 0;
#line 344
  ldv_work_1_2 = 0;
#line 345
  ldv_work_1_3 = 0;
#line 346
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void invoke_work_2(void) 
{ 
  int tmp ;

  {
#line 351
  tmp = __VERIFIER_nondet_int();
#line 351
  switch (tmp) {
  case 0: ;
#line 353
  if (ldv_work_2_0 == 2 || ldv_work_2_0 == 3) {
#line 354
    ldv_work_2_0 = 4;
#line 355
    rtw_cmd_work(ldv_work_struct_2_0);
#line 356
    ldv_work_2_0 = 1;
  } else {

  }
#line 359
  goto ldv_56134;
  case 1: ;
#line 361
  if (ldv_work_2_1 == 2 || ldv_work_2_1 == 3) {
#line 362
    ldv_work_2_1 = 4;
#line 363
    rtw_cmd_work(ldv_work_struct_2_0);
#line 364
    ldv_work_2_1 = 1;
  } else {

  }
#line 367
  goto ldv_56134;
  case 2: ;
#line 369
  if (ldv_work_2_2 == 2 || ldv_work_2_2 == 3) {
#line 370
    ldv_work_2_2 = 4;
#line 371
    rtw_cmd_work(ldv_work_struct_2_0);
#line 372
    ldv_work_2_2 = 1;
  } else {

  }
#line 375
  goto ldv_56134;
  case 3: ;
#line 377
  if (ldv_work_2_3 == 2 || ldv_work_2_3 == 3) {
#line 378
    ldv_work_2_3 = 4;
#line 379
    rtw_cmd_work(ldv_work_struct_2_0);
#line 380
    ldv_work_2_3 = 1;
  } else {

  }
#line 383
  goto ldv_56134;
  default: 
#line 384
  ldv_stop();
  }
  ldv_56134: ;
#line 386
  return;
}
}
#line 390 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void work_init_2(void) 
{ 


  {
#line 391
  ldv_work_2_0 = 0;
#line 392
  ldv_work_2_1 = 0;
#line 393
  ldv_work_2_2 = 0;
#line 394
  ldv_work_2_3 = 0;
#line 395
  return;
}
}
#line 398 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void call_and_disable_all_1(int state ) 
{ 


  {
#line 400
  if (ldv_work_1_0 == state) {
#line 401
    call_and_disable_work_1(ldv_work_struct_1_0);
  } else {

  }
#line 402
  if (ldv_work_1_1 == state) {
#line 403
    call_and_disable_work_1(ldv_work_struct_1_1);
  } else {

  }
#line 404
  if (ldv_work_1_2 == state) {
#line 405
    call_and_disable_work_1(ldv_work_struct_1_2);
  } else {

  }
#line 406
  if (ldv_work_1_3 == state) {
#line 407
    call_and_disable_work_1(ldv_work_struct_1_3);
  } else {

  }
#line 408
  return;
}
}
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void activate_work_2(struct work_struct *work , int state ) 
{ 


  {
#line 412
  if (ldv_work_2_0 == 0) {
#line 413
    ldv_work_struct_2_0 = work;
#line 414
    ldv_work_2_0 = state;
#line 415
    return;
  } else {

  }
#line 418
  if (ldv_work_2_1 == 0) {
#line 419
    ldv_work_struct_2_1 = work;
#line 420
    ldv_work_2_1 = state;
#line 421
    return;
  } else {

  }
#line 424
  if (ldv_work_2_2 == 0) {
#line 425
    ldv_work_struct_2_2 = work;
#line 426
    ldv_work_2_2 = state;
#line 427
    return;
  } else {

  }
#line 430
  if (ldv_work_2_3 == 0) {
#line 431
    ldv_work_struct_2_3 = work;
#line 432
    ldv_work_2_3 = state;
#line 433
    return;
  } else {

  }
#line 435
  return;
}
}
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void disable_work_2(struct work_struct *work ) 
{ 


  {
#line 440
  if ((ldv_work_2_0 == 3 || ldv_work_2_0 == 2) && (unsigned long )ldv_work_struct_2_0 == (unsigned long )work) {
#line 442
    ldv_work_2_0 = 1;
  } else {

  }
#line 444
  if ((ldv_work_2_1 == 3 || ldv_work_2_1 == 2) && (unsigned long )ldv_work_struct_2_1 == (unsigned long )work) {
#line 446
    ldv_work_2_1 = 1;
  } else {

  }
#line 448
  if ((ldv_work_2_2 == 3 || ldv_work_2_2 == 2) && (unsigned long )ldv_work_struct_2_2 == (unsigned long )work) {
#line 450
    ldv_work_2_2 = 1;
  } else {

  }
#line 452
  if ((ldv_work_2_3 == 3 || ldv_work_2_3 == 2) && (unsigned long )ldv_work_struct_2_3 == (unsigned long )work) {
#line 454
    ldv_work_2_3 = 1;
  } else {

  }
#line 455
  return;
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void invoke_work_1(void) 
{ 
  int tmp ;

  {
#line 461
  tmp = __VERIFIER_nondet_int();
#line 461
  switch (tmp) {
  case 0: ;
#line 463
  if (ldv_work_1_0 == 2 || ldv_work_1_0 == 3) {
#line 464
    ldv_work_1_0 = 4;
#line 465
    rtw_irq_work(ldv_work_struct_1_0);
#line 466
    ldv_work_1_0 = 1;
  } else {

  }
#line 469
  goto ldv_56158;
  case 1: ;
#line 471
  if (ldv_work_1_1 == 2 || ldv_work_1_1 == 3) {
#line 472
    ldv_work_1_1 = 4;
#line 473
    rtw_irq_work(ldv_work_struct_1_0);
#line 474
    ldv_work_1_1 = 1;
  } else {

  }
#line 477
  goto ldv_56158;
  case 2: ;
#line 479
  if (ldv_work_1_2 == 2 || ldv_work_1_2 == 3) {
#line 480
    ldv_work_1_2 = 4;
#line 481
    rtw_irq_work(ldv_work_struct_1_0);
#line 482
    ldv_work_1_2 = 1;
  } else {

  }
#line 485
  goto ldv_56158;
  case 3: ;
#line 487
  if (ldv_work_1_3 == 2 || ldv_work_1_3 == 3) {
#line 488
    ldv_work_1_3 = 4;
#line 489
    rtw_irq_work(ldv_work_struct_1_0);
#line 490
    ldv_work_1_3 = 1;
  } else {

  }
#line 493
  goto ldv_56158;
  default: 
#line 494
  ldv_stop();
  }
  ldv_56158: ;
#line 496
  return;
}
}
#line 500 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void call_and_disable_work_2(struct work_struct *work ) 
{ 


  {
#line 503
  if ((ldv_work_2_0 == 2 || ldv_work_2_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_0) {
#line 505
    rtw_cmd_work(work);
#line 506
    ldv_work_2_0 = 1;
#line 507
    return;
  } else {

  }
#line 509
  if ((ldv_work_2_1 == 2 || ldv_work_2_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_1) {
#line 511
    rtw_cmd_work(work);
#line 512
    ldv_work_2_1 = 1;
#line 513
    return;
  } else {

  }
#line 515
  if ((ldv_work_2_2 == 2 || ldv_work_2_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_2) {
#line 517
    rtw_cmd_work(work);
#line 518
    ldv_work_2_2 = 1;
#line 519
    return;
  } else {

  }
#line 521
  if ((ldv_work_2_3 == 2 || ldv_work_2_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_3) {
#line 523
    rtw_cmd_work(work);
#line 524
    ldv_work_2_3 = 1;
#line 525
    return;
  } else {

  }
#line 527
  return;
}
}
#line 553 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 557
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 557
  ldv_func_res = tmp;
#line 559
  activate_work_2(ldv_func_arg3, 2);
#line 561
  return (ldv_func_res);
}
}
#line 564 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 568
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 568
  ldv_func_res = tmp;
#line 570
  activate_work_2(& ldv_func_arg3->work, 2);
#line 572
  return (ldv_func_res);
}
}
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 579
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 579
  ldv_func_res = tmp;
#line 581
  activate_work_2(ldv_func_arg3, 2);
#line 583
  return (ldv_func_res);
}
}
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 589
  flush_workqueue(ldv_func_arg1);
#line 591
  call_and_disable_all_2(2);
#line 592
  return;
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 598
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 598
  ldv_func_res = tmp;
#line 600
  activate_work_2(& ldv_func_arg3->work, 2);
#line 602
  return (ldv_func_res);
}
}
#line 605 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
bool ldv_cancel_work_sync_10(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 609
  tmp = cancel_work_sync(ldv_func_arg1);
#line 609
  ldv_func_res = tmp;
#line 611
  disable_work_2(ldv_func_arg1);
#line 613
  return (ldv_func_res);
}
}
#line 616 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_mod_timer_11(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 620
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 620
  ldv_func_res = tmp;
#line 622
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 624
  return (ldv_func_res);
}
}
#line 627 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_mod_timer_12(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 631
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 631
  ldv_func_res = tmp;
#line 633
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 635
  return (ldv_func_res);
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_mod_timer_13(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 642
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 642
  ldv_func_res = tmp;
#line 644
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 646
  return (ldv_func_res);
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_mod_timer_14(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 653
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 653
  ldv_func_res = tmp;
#line 655
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 657
  return (ldv_func_res);
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_mod_timer_15(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 664
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 664
  ldv_func_res = tmp;
#line 666
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 668
  return (ldv_func_res);
}
}
#line 671 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_mod_timer_16(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 675
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 675
  ldv_func_res = tmp;
#line 677
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 679
  return (ldv_func_res);
}
}
#line 682 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_del_timer_sync_17(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 686
  tmp = del_timer_sync(ldv_func_arg1);
#line 686
  ldv_func_res = tmp;
#line 688
  disable_suitable_timer_11(ldv_func_arg1);
#line 690
  return (ldv_func_res);
}
}
#line 24 "./arch/x86/include/asm/arch_hweight.h"
__inline static unsigned int __arch_hweight32(unsigned int w ) 
{ 
  unsigned int res ;

  {
#line 26
  res = 0U;
#line 28
  __asm__  ("661:\n\tcall __sw_hweight32\n662:\n.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\n663:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6641f - .\n .word ( 4*32+23)\n .byte 663b-661b\n .byte 6651f-6641f\n .byte 663b-662b\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6641:\n\t.byte 0xf3,0x40,0x0f,0xb8,0xc7\n6651:\n\t.popsection": "=a" (res): "D" (w));
#line 32
  return (res);
}
}
#line 40 "./arch/x86/include/asm/arch_hweight.h"
__inline static unsigned int __arch_hweight8(unsigned int w ) 
{ 
  unsigned int tmp ;

  {
#line 42
  tmp = __arch_hweight32(w & 255U);
#line 42
  return (tmp);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_35(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_37(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_36(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_39(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_38(struct workqueue_struct *ldv_func_arg1 ) ;
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 84 "drivers/staging/rtl8723au/include/rtw_efuse.h"
u16 efuse_GetMaxSize23a(struct rtw_adapter *padapter ) ;
#line 85
int rtw_efuse_access23a(struct rtw_adapter *padapter , u8 bWrite , u16 start_addr ,
                        u16 cnts , u8 *data ) ;
#line 86
int rtw_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts , u8 *data ) ;
#line 88
int rtw_BT_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts ,
                             u8 *data ) ;
#line 91
u16 Efuse_GetCurrentSize23a(struct rtw_adapter *pAdapter , u8 efuseType ) ;
#line 92
u8 Efuse_CalculateWordCnts23a(u8 word_en ) ;
#line 93
void ReadEFuseByte23a(struct rtw_adapter *Adapter , u16 _offset , u8 *pbuf ) ;
#line 94
void EFUSE_GetEfuseDefinition23a(struct rtw_adapter *pAdapter , u8 efuseType , u8 type ,
                                 void *pOut ) ;
#line 95
int efuse_OneByteRead23a(struct rtw_adapter *pAdapter , u16 addr , u8 *data ) ;
#line 96
int efuse_OneByteWrite23a(struct rtw_adapter *pAdapter , u16 addr , u8 data ) ;
#line 102
void efuse_WordEnableDataRead23a(u8 word_en , u8 *sourdata , u8 *targetdata ) ;
#line 105
u8 EFUSE_Read1Byte23a(struct rtw_adapter *Adapter , u16 Address ) ;
#line 106
void EFUSE_ShadowMapUpdate23a(struct rtw_adapter *pAdapter , u8 efuseType ) ;
#line 107
void EFUSE_ShadowRead23a(struct rtw_adapter *pAdapter , u8 Type , u16 Offset , u32 *Value ) ;
#line 531 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
void rtl8723a_readefuse(struct rtw_adapter *padapter , u8 efuseType , u16 _offset ,
                        u16 _size_byte , u8 *pbuf ) ;
#line 533
u16 rtl8723a_EfuseGetCurrentSize_WiFi(struct rtw_adapter *padapter ) ;
#line 534
u16 rtl8723a_EfuseGetCurrentSize_BT(struct rtw_adapter *padapter ) ;
#line 32 "drivers/staging/rtl8723au/include/usb_ops_linux.h"
u8 rtl8723au_read8(struct rtw_adapter *padapter , u16 addr ) ;
#line 33
u16 rtl8723au_read16(struct rtw_adapter *padapter , u16 addr ) ;
#line 34
u32 rtl8723au_read32(struct rtw_adapter *padapter , u16 addr ) ;
#line 35
int rtl8723au_write8(struct rtw_adapter *padapter , u16 addr , u8 val ) ;
#line 36
int rtl8723au_write16(struct rtw_adapter *padapter , u16 addr , u16 val ) ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
static void Efuse_PowerSwitch(struct rtw_adapter *padapter , u8 bWrite , u8 PwrState ) 
{ 
  u8 tempval ;
  u16 tmpV16 ;

  {
#line 58
  if ((unsigned int )PwrState == 1U) {
#line 59
    rtl8723au_write8(padapter, 207, 105);
#line 63
    tmpV16 = rtl8723au_read16(padapter, 0);
#line 64
    if ((int )((short )tmpV16) >= 0) {
#line 65
      tmpV16 = (u16 )((unsigned int )tmpV16 | 32768U);
#line 66
      rtl8723au_write16(padapter, 0, (int )tmpV16);
    } else {

    }
#line 69
    tmpV16 = rtl8723au_read16(padapter, 2);
#line 70
    if (((unsigned long )tmpV16 & 4096UL) == 0UL) {
#line 71
      tmpV16 = (u16 )((unsigned int )tmpV16 | 4096U);
#line 72
      rtl8723au_write16(padapter, 2, (int )tmpV16);
    } else {

    }
#line 77
    tmpV16 = rtl8723au_read16(padapter, 8);
#line 78
    if (((unsigned long )tmpV16 & 32UL) == 0UL || ((unsigned long )tmpV16 & 2UL) == 0UL) {
#line 79
      tmpV16 = (u16 )((unsigned int )tmpV16 | 34U);
#line 80
      rtl8723au_write16(padapter, 8, (int )tmpV16);
    } else {

    }
#line 83
    if ((unsigned int )bWrite == 1U) {
#line 85
      tempval = rtl8723au_read8(padapter, 55);
#line 86
      tempval = (unsigned int )tempval & 15U;
#line 87
      tempval = (u8 )((unsigned int )tempval | 48U);
#line 88
      rtl8723au_write8(padapter, 55, (int )((unsigned int )tempval | 128U));
    } else {

    }
  } else {
#line 92
    rtl8723au_write8(padapter, 207, 0);
#line 94
    if ((unsigned int )bWrite == 1U) {
#line 96
      tempval = rtl8723au_read8(padapter, 55);
#line 97
      rtl8723au_write8(padapter, 55, (int )tempval & 127);
    } else {

    }
  }
#line 100
  return;
}
}
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
u16 Efuse_GetCurrentSize23a(struct rtw_adapter *pAdapter , u8 efuseType ) 
{ 
  u16 ret ;

  {
#line 106
  ret = 0U;
#line 108
  if ((unsigned int )efuseType == 0U) {
#line 109
    ret = rtl8723a_EfuseGetCurrentSize_WiFi(pAdapter);
  } else {
#line 111
    ret = rtl8723a_EfuseGetCurrentSize_BT(pAdapter);
  }
#line 113
  return (ret);
}
}
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
u8 Efuse_CalculateWordCnts23a(u8 word_en ) 
{ 
  unsigned int tmp ;

  {
#line 120
  tmp = __arch_hweight8((unsigned int )(~ ((int )word_en)) & 15U);
#line 120
  return ((u8 )tmp);
}
}
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
void ReadEFuseByte23a(struct rtw_adapter *Adapter , u16 _offset , u8 *pbuf ) 
{ 
  u32 value32 ;
  u8 readbyte ;
  u16 retry ;

  {
#line 142
  rtl8723au_write8(Adapter, 49, (int )((u8 )_offset));
#line 143
  readbyte = rtl8723au_read8(Adapter, 50);
#line 144
  rtl8723au_write8(Adapter, 50, (int )((u8 )(((int )((signed char )((int )_offset >> 8)) & 3) | ((int )((signed char )readbyte) & -4))));
#line 148
  readbyte = rtl8723au_read8(Adapter, 51);
#line 149
  rtl8723au_write8(Adapter, 51, (int )readbyte & 127);
#line 152
  retry = 0U;
#line 153
  value32 = rtl8723au_read32(Adapter, 48);
#line 154
  goto ldv_55768;
  ldv_55767: 
#line 155
  value32 = rtl8723au_read32(Adapter, 48);
#line 156
  retry = (u16 )((int )retry + 1);
  ldv_55768: ;
#line 154
  if ((int )value32 >= 0 && (unsigned int )retry <= 9999U) {
#line 156
    goto ldv_55767;
  } else {

  }
#line 163
  __const_udelay(214750UL);
#line 164
  value32 = rtl8723au_read32(Adapter, 48);
#line 166
  *pbuf = (unsigned char )value32;
#line 167
  return;
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
void EFUSE_GetEfuseDefinition23a(struct rtw_adapter *pAdapter , u8 efuseType , u8 type ,
                                 void *pOut ) 
{ 
  u8 *pu1Tmp ;
  u16 *pu2Tmp ;
  u8 *pMax_section ;

  {
#line 177
  switch ((int )type) {
  case 0: 
#line 179
  pMax_section = (u8 *)pOut;
#line 181
  if ((unsigned int )efuseType == 0U) {
#line 182
    *pMax_section = 32U;
  } else {
#line 184
    *pMax_section = 128U;
  }
#line 185
  goto ldv_55780;
  case 1: 
#line 188
  pu2Tmp = (u16 *)pOut;
#line 190
  if ((unsigned int )efuseType == 0U) {
#line 191
    *pu2Tmp = 512U;
  } else {
#line 193
    *pu2Tmp = 1536U;
  }
#line 194
  goto ldv_55780;
  case 2: 
#line 197
  pu2Tmp = (u16 *)pOut;
#line 199
  if ((unsigned int )efuseType == 0U) {
#line 200
    *pu2Tmp = 497U;
  } else {
#line 203
    *pu2Tmp = 496U;
  }
#line 205
  goto ldv_55780;
  case 3: 
#line 208
  pu2Tmp = (u16 *)pOut;
#line 210
  if ((unsigned int )efuseType == 0U) {
#line 211
    *pu2Tmp = 497U;
  } else {
#line 214
    *pu2Tmp = 1488U;
  }
#line 216
  goto ldv_55780;
  case 4: 
#line 219
  pu2Tmp = (u16 *)pOut;
#line 221
  if ((unsigned int )efuseType == 0U) {
#line 222
    *pu2Tmp = 256U;
  } else {
#line 224
    *pu2Tmp = 1024U;
  }
#line 225
  goto ldv_55780;
  case 5: 
#line 228
  pu1Tmp = (u8 *)pOut;
#line 230
  if ((unsigned int )efuseType == 0U) {
#line 231
    *pu1Tmp = 15U;
  } else {
#line 233
    *pu1Tmp = 16U;
  }
#line 234
  goto ldv_55780;
  case 6: 
#line 237
  pu2Tmp = (u16 *)pOut;
#line 239
  if ((unsigned int )efuseType == 0U) {
#line 240
    *pu2Tmp = 512U;
  } else {
#line 242
    *pu2Tmp = 512U;
  }
#line 243
  goto ldv_55780;
  default: 
#line 246
  pu1Tmp = (u8 *)pOut;
#line 247
  *pu1Tmp = 0U;
#line 248
  goto ldv_55780;
  }
  ldv_55780: ;
#line 251
  return;
}
}
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
u8 EFUSE_Read1Byte23a(struct rtw_adapter *Adapter , u16 Address ) 
{ 
  u8 data ;
  u8 Bytetemp ;
  u8 temp ;
  u32 k ;
  u16 contentLen ;

  {
#line 272
  Bytetemp = 0U;
#line 273
  temp = 0U;
#line 274
  k = 0U;
#line 275
  contentLen = 0U;
#line 277
  EFUSE_GetEfuseDefinition23a(Adapter, 0, 1, (void *)(& contentLen));
#line 281
  if ((int )Address < (int )contentLen) {
#line 283
    temp = (u8 )Address;
#line 284
    rtl8723au_write8(Adapter, 49, (int )temp);
#line 285
    Bytetemp = rtl8723au_read8(Adapter, 50);
#line 287
    temp = (u8 )(((int )((signed char )((int )Address >> 8)) & 3) | ((int )((signed char )Bytetemp) & -4));
#line 288
    rtl8723au_write8(Adapter, 50, (int )temp);
#line 291
    Bytetemp = rtl8723au_read8(Adapter, 51);
#line 292
    temp = (unsigned int )Bytetemp & 127U;
#line 293
    rtl8723au_write8(Adapter, 51, (int )temp);
#line 296
    Bytetemp = rtl8723au_read8(Adapter, 51);
#line 297
    goto ldv_55799;
    ldv_55798: 
#line 298
    Bytetemp = rtl8723au_read8(Adapter, 51);
#line 299
    k = k + 1U;
#line 300
    if (k == 1000U) {
#line 301
      k = 0U;
#line 302
      goto ldv_55797;
    } else {

    }
    ldv_55799: ;
#line 297
    if ((int )((signed char )Bytetemp) >= 0) {
#line 299
      goto ldv_55798;
    } else {

    }
    ldv_55797: 
#line 305
    data = rtl8723au_read8(Adapter, 48);
#line 306
    return (data);
  } else {
#line 308
    return (255U);
  }
}
}
#line 329
void EFUSE_Write1Byte(struct rtw_adapter *Adapter , u16 Address , u8 Value ) ;
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
void EFUSE_Write1Byte(struct rtw_adapter *Adapter , u16 Address , u8 Value ) 
{ 
  u8 Bytetemp ;
  u8 temp ;
  u32 k ;
  u16 contentLen ;

  {
#line 333
  Bytetemp = 0U;
#line 334
  temp = 0U;
#line 335
  k = 0U;
#line 336
  contentLen = 0U;
#line 338
  EFUSE_GetEfuseDefinition23a(Adapter, 0, 1, (void *)(& contentLen));
#line 342
  if ((int )Address < (int )contentLen) {
#line 343
    rtl8723au_write8(Adapter, 48, (int )Value);
#line 346
    temp = (u8 )Address;
#line 347
    rtl8723au_write8(Adapter, 49, (int )temp);
#line 348
    Bytetemp = rtl8723au_read8(Adapter, 50);
#line 351
    temp = (u8 )(((int )((signed char )((int )Address >> 8)) & 3) | ((int )((signed char )Bytetemp) & -4));
#line 352
    rtl8723au_write8(Adapter, 50, (int )temp);
#line 355
    Bytetemp = rtl8723au_read8(Adapter, 51);
#line 356
    temp = (u8 )((unsigned int )Bytetemp | 128U);
#line 357
    rtl8723au_write8(Adapter, 51, (int )temp);
#line 360
    Bytetemp = rtl8723au_read8(Adapter, 51);
#line 361
    goto ldv_55815;
    ldv_55814: 
#line 362
    Bytetemp = rtl8723au_read8(Adapter, 51);
#line 363
    k = k + 1U;
#line 364
    if (k == 100U) {
#line 365
      k = 0U;
#line 366
      goto ldv_55813;
    } else {

    }
    ldv_55815: ;
#line 361
    if ((int )((signed char )Bytetemp) < 0) {
#line 363
      goto ldv_55814;
    } else {

    }
    ldv_55813: ;
  } else {

  }
#line 369
  return;
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
int efuse_OneByteRead23a(struct rtw_adapter *pAdapter , u16 addr , u8 *data ) 
{ 
  u8 tmpidx ;
  int bResult ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 376
  tmpidx = 0U;
#line 381
  rtl8723au_write8(pAdapter, 49, (int )((unsigned char )addr));
#line 382
  tmp = rtl8723au_read8(pAdapter, 50);
#line 382
  rtl8723au_write8(pAdapter, 50, (int )((u8 )(((int )((signed char )((int )addr >> 8)) & 3) | ((int )((signed char )tmp) & -4))));
#line 385
  rtl8723au_write8(pAdapter, 51, 114);
#line 387
  goto ldv_55824;
  ldv_55823: 
#line 388
  tmpidx = (u8 )((int )tmpidx + 1);
  ldv_55824: 
#line 387
  tmp___0 = rtl8723au_read8(pAdapter, 51);
#line 387
  if ((int )((signed char )tmp___0) >= 0 && (unsigned int )tmpidx <= 99U) {
#line 389
    goto ldv_55823;
  } else {

  }

#line 389
  if ((unsigned int )tmpidx <= 99U) {
#line 390
    *data = rtl8723au_read8(pAdapter, 48);
#line 391
    bResult = 1;
  } else {
#line 393
    *data = 255U;
#line 394
    bResult = 0;
  }
#line 396
  return (bResult);
}
}
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
int efuse_OneByteWrite23a(struct rtw_adapter *pAdapter , u16 addr , u8 data ) 
{ 
  u8 tmpidx ;
  int bResult ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 403
  tmpidx = 0U;
#line 410
  rtl8723au_write8(pAdapter, 49, (int )((unsigned char )addr));
#line 411
  tmp = rtl8723au_read8(pAdapter, 50);
#line 411
  rtl8723au_write8(pAdapter, 50, (int )((u8 )(((int )((signed char )tmp) & -4) | ((int )((signed char )((int )addr >> 8)) & 3))));
#line 413
  rtl8723au_write8(pAdapter, 48, (int )data);
#line 415
  rtl8723au_write8(pAdapter, 51, 242);
#line 417
  goto ldv_55834;
  ldv_55833: 
#line 419
  tmpidx = (u8 )((int )tmpidx + 1);
  ldv_55834: 
#line 417
  tmp___0 = rtl8723au_read8(pAdapter, 51);
#line 417
  if ((int )((signed char )tmp___0) < 0 && (unsigned int )tmpidx <= 99U) {
#line 420
    goto ldv_55833;
  } else {

  }

#line 422
  if ((unsigned int )tmpidx <= 99U) {
#line 423
    bResult = 1;
  } else {
#line 425
    bResult = 0;
  }
#line 427
  return (bResult);
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
void efuse_WordEnableDataRead23a(u8 word_en , u8 *sourdata , u8 *targetdata ) 
{ 


  {
#line 452
  if (((unsigned long )word_en & 1UL) == 0UL) {
#line 453
    *targetdata = *sourdata;
#line 454
    *(targetdata + 1UL) = *(sourdata + 1UL);
  } else {

  }
#line 456
  if (((unsigned long )word_en & 2UL) == 0UL) {
#line 457
    *(targetdata + 2UL) = *(sourdata + 2UL);
#line 458
    *(targetdata + 3UL) = *(sourdata + 3UL);
  } else {

  }
#line 460
  if (((unsigned long )word_en & 4UL) == 0UL) {
#line 461
    *(targetdata + 4UL) = *(sourdata + 4UL);
#line 462
    *(targetdata + 5UL) = *(sourdata + 5UL);
  } else {

  }
#line 464
  if (((unsigned long )word_en & 8UL) == 0UL) {
#line 465
    *(targetdata + 6UL) = *(sourdata + 6UL);
#line 466
    *(targetdata + 7UL) = *(sourdata + 7UL);
  } else {

  }
#line 468
  return;
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
static int efuse_read8(struct rtw_adapter *padapter , u16 address , u8 *value ) 
{ 
  int tmp ;

  {
#line 472
  tmp = efuse_OneByteRead23a(padapter, (int )address, value);
#line 472
  return (tmp);
}
}
#line 475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
static int efuse_write8(struct rtw_adapter *padapter , u16 address , u8 *value ) 
{ 
  int tmp ;

  {
#line 477
  tmp = efuse_OneByteWrite23a(padapter, (int )address, (int )*value);
#line 477
  return (tmp);
}
}
#line 483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
int rtw_efuse_access23a(struct rtw_adapter *padapter , u8 bWrite , u16 start_addr ,
                        u16 cnts , u8 *data ) 
{ 
  int i ;
  u16 real_content_len ;
  u16 max_available_size ;
  int res ;
  int (*rw8)(struct rtw_adapter * , u16  , u8 * ) ;
  u8 *tmp ;
  u16 tmp___0 ;

  {
#line 486
  i = 0;
#line 487
  real_content_len = 0U;
#line 487
  max_available_size = 0U;
#line 488
  res = 0;
#line 491
  EFUSE_GetEfuseDefinition23a(padapter, 0, 1, (void *)(& real_content_len));
#line 494
  EFUSE_GetEfuseDefinition23a(padapter, 0, 3, (void *)(& max_available_size));
#line 498
  if ((int )start_addr > (int )real_content_len) {
#line 499
    return (0);
  } else {

  }
#line 501
  if ((unsigned int )bWrite == 1U) {
#line 502
    if ((int )start_addr + (int )cnts > (int )max_available_size) {
#line 503
      return (0);
    } else {

    }
#line 504
    rw8 = & efuse_write8;
  } else {
#line 506
    rw8 = & efuse_read8;
  }
#line 508
  Efuse_PowerSwitch(padapter, (int )bWrite, 1);
#line 511
  i = 0;
#line 511
  goto ldv_55868;
  ldv_55867: ;
#line 512
  if ((int )start_addr >= (int )real_content_len) {
#line 513
    res = 0;
#line 514
    goto ldv_55866;
  } else {

  }
#line 517
  tmp = data;
#line 517
  data = data + 1;
#line 517
  tmp___0 = start_addr;
#line 517
  start_addr = (u16 )((int )start_addr + 1);
#line 517
  res = (*rw8)(padapter, (int )tmp___0, tmp);
#line 518
  if (res == 0) {
#line 519
    goto ldv_55866;
  } else {

  }
#line 511
  i = i + 1;
  ldv_55868: ;
#line 511
  if ((int )cnts > i) {
#line 513
    goto ldv_55867;
  } else {

  }
  ldv_55866: 
#line 522
  Efuse_PowerSwitch(padapter, (int )bWrite, 0);
#line 524
  return (res);
}
}
#line 527 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
u16 efuse_GetMaxSize23a(struct rtw_adapter *padapter ) 
{ 
  u16 max_size ;

  {
#line 530
  EFUSE_GetEfuseDefinition23a(padapter, 0, 3, (void *)(& max_size));
#line 533
  return (max_size);
}
}
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
int rtw_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts , u8 *data ) 
{ 
  u16 mapLen ;

  {
#line 539
  mapLen = 0U;
#line 541
  EFUSE_GetEfuseDefinition23a(padapter, 0, 4, (void *)(& mapLen));
#line 544
  if ((int )addr + (int )cnts > (int )mapLen) {
#line 545
    return (0);
  } else {

  }
#line 547
  Efuse_PowerSwitch(padapter, 0, 1);
#line 549
  rtl8723a_readefuse(padapter, 0, (int )addr, (int )cnts, data);
#line 551
  Efuse_PowerSwitch(padapter, 0, 0);
#line 553
  return (1);
}
}
#line 556 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
int rtw_BT_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts ,
                             u8 *data ) 
{ 
  u16 mapLen ;

  {
#line 559
  mapLen = 0U;
#line 561
  EFUSE_GetEfuseDefinition23a(padapter, 1, 4, (void *)(& mapLen));
#line 564
  if ((int )addr + (int )cnts > (int )mapLen) {
#line 565
    return (0);
  } else {

  }
#line 567
  Efuse_PowerSwitch(padapter, 0, 1);
#line 569
  rtl8723a_readefuse(padapter, 1, (int )addr, (int )cnts, data);
#line 571
  Efuse_PowerSwitch(padapter, 0, 0);
#line 573
  return (1);
}
}
#line 593
void Efuse_ReadAllMap(struct rtw_adapter *pAdapter , u8 efuseType , u8 *Efuse ) ;
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
void Efuse_ReadAllMap(struct rtw_adapter *pAdapter , u8 efuseType , u8 *Efuse ) 
{ 
  u16 mapLen ;

  {
#line 597
  mapLen = 0U;
#line 599
  Efuse_PowerSwitch(pAdapter, 0, 1);
#line 601
  EFUSE_GetEfuseDefinition23a(pAdapter, (int )efuseType, 4, (void *)(& mapLen));
#line 604
  rtl8723a_readefuse(pAdapter, (int )efuseType, 0, (int )mapLen, Efuse);
#line 606
  Efuse_PowerSwitch(pAdapter, 0, 0);
#line 607
  return;
}
}
#line 628 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
static void efuse_ShadowRead1Byte(struct rtw_adapter *pAdapter , u16 Offset , u8 *Value ) 
{ 
  struct eeprom_priv *pEEPROM ;

  {
#line 630
  pEEPROM = & pAdapter->eeprompriv;
#line 632
  *Value = pEEPROM->efuse_eeprom_data[(int )Offset];
#line 633
  return;
}
}
#line 637 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
static void efuse_ShadowRead2Byte(struct rtw_adapter *pAdapter , u16 Offset , u16 *Value ) 
{ 
  struct eeprom_priv *pEEPROM ;

  {
#line 639
  pEEPROM = & pAdapter->eeprompriv;
#line 641
  *Value = (u16 )pEEPROM->efuse_eeprom_data[(int )Offset];
#line 642
  *Value = (u16 )((int )((short )*Value) | (int )((short )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 1] << 8)));
#line 643
  return;
}
}
#line 647 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
static void efuse_ShadowRead4Byte(struct rtw_adapter *pAdapter , u16 Offset , u32 *Value ) 
{ 
  struct eeprom_priv *pEEPROM ;

  {
#line 649
  pEEPROM = & pAdapter->eeprompriv;
#line 651
  *Value = (u32 )pEEPROM->efuse_eeprom_data[(int )Offset];
#line 652
  *Value = *Value | (u32 )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 1] << 8);
#line 653
  *Value = *Value | (u32 )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 2] << 16);
#line 654
  *Value = *Value | (u32 )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 3] << 24);
#line 655
  return;
}
}
#line 673 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
void EFUSE_ShadowMapUpdate23a(struct rtw_adapter *pAdapter , u8 efuseType ) 
{ 
  struct eeprom_priv *pEEPROM ;
  u16 mapLen ;

  {
#line 675
  pEEPROM = & pAdapter->eeprompriv;
#line 676
  mapLen = 0U;
#line 678
  EFUSE_GetEfuseDefinition23a(pAdapter, (int )efuseType, 4, (void *)(& mapLen));
#line 681
  if ((unsigned int )pEEPROM->bautoload_fail_flag == 1U) {
#line 682
    memset((void *)(& pEEPROM->efuse_eeprom_data), 255, (size_t )mapLen);
  } else {
#line 684
    Efuse_ReadAllMap(pAdapter, (int )efuseType, (u8 *)(& pEEPROM->efuse_eeprom_data));
  }
#line 686
  return;
}
}
#line 706 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.c"
void EFUSE_ShadowRead23a(struct rtw_adapter *pAdapter , u8 Type , u16 Offset , u32 *Value ) 
{ 


  {
#line 709
  if ((unsigned int )Type == 1U) {
#line 710
    efuse_ShadowRead1Byte(pAdapter, (int )Offset, (u8 *)Value);
  } else
#line 711
  if ((unsigned int )Type == 2U) {
#line 712
    efuse_ShadowRead2Byte(pAdapter, (int )Offset, (u16 *)Value);
  } else
#line 713
  if ((unsigned int )Type == 4U) {
#line 714
    efuse_ShadowRead4Byte(pAdapter, (int )Offset, Value);
  } else {

  }
#line 715
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
bool ldv_queue_work_on_35(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
bool ldv_queue_delayed_work_on_36(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
bool ldv_queue_work_on_37(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
void ldv_flush_workqueue_38(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
bool ldv_queue_delayed_work_on_39(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 154 "include/uapi/linux/swab.h"
__inline static __u16 __swab16p(__u16 const   *p ) 
{ 
  __u16 tmp ;

  {
#line 159
  tmp = __fswab16((int )*p);
#line 159
  return (tmp);
}
}
#line 63 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u16 __le16_to_cpup(__le16 const   *p ) 
{ 


  {
#line 65
  return ((__u16 )*p);
}
}
#line 87 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u16 __be16_to_cpup(__be16 const   *p ) 
{ 
  __u16 tmp ;

  {
#line 89
  tmp = __swab16p(p);
#line 89
  return (tmp);
}
}
#line 63 "./arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_49(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_50(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_53(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_52(struct workqueue_struct *ldv_func_arg1 ) ;
#line 7 "include/linux/unaligned/access_ok.h"
__inline static u16 get_unaligned_le16(void const   *p ) 
{ 
  __u16 tmp ;

  {
#line 9
  tmp = __le16_to_cpup((__le16 const   *)p);
#line 9
  return (tmp);
}
}
#line 22 "include/linux/unaligned/access_ok.h"
__inline static u16 get_unaligned_be16(void const   *p ) 
{ 
  __u16 tmp ;

  {
#line 24
  tmp = __be16_to_cpup((__be16 const   *)p);
#line 24
  return (tmp);
}
}
#line 3775 "include/net/cfg80211.h"
extern u8 const   *cfg80211_find_ie(u8  , u8 const   * , int  ) ;
#line 3793
extern u8 const   *cfg80211_find_vendor_ie(unsigned int  , u8  , u8 const   * , int  ) ;
#line 60 "drivers/staging/rtl8723au/include/ieee80211.h"
u8 RTW_WPA_OUI23A_TYPE[4U] ;
#line 61
u16 RTW_WPA_VERSION23A ;
#line 62
u8 WPA_AUTH_KEY_MGMT_NONE23A[4U] ;
#line 63
u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U] ;
#line 64
u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U] ;
#line 65
u8 WPA_CIPHER_SUITE_NONE23A[4U] ;
#line 66
u8 WPA_CIPHER_SUITE_WEP4023A[4U] ;
#line 67
u8 WPA_CIPHER_SUITE_TKIP23A[4U] ;
#line 68
u8 WPA_CIPHER_SUITE_WRAP23A[4U] ;
#line 69
u8 WPA_CIPHER_SUITE_CCMP23A[4U] ;
#line 70
u8 WPA_CIPHER_SUITE_WEP10423A[4U] ;
#line 76
u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U] ;
#line 77
u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U] ;
#line 78
u8 RSN_CIPHER_SUITE_NONE23A[4U] ;
#line 79
u8 RSN_CIPHER_SUITE_WEP4023A[4U] ;
#line 80
u8 RSN_CIPHER_SUITE_TKIP23A[4U] ;
#line 81
u8 RSN_CIPHER_SUITE_WRAP23A[4U] ;
#line 82
u8 RSN_CIPHER_SUITE_CCMP23A[4U] ;
#line 83
u8 RSN_CIPHER_SUITE_WEP10423A[4U] ;
#line 308
u8 *rtw_set_ie23a(u8 *pbuf , int index , uint len , u8 const   *source , uint *frlen ) ;
#line 314
u8 *rtw_get_ie23a(u8 *pbuf , int index , int *len , int limit ) ;
#line 315
u8 *rtw_get_ie23a_ex(u8 *in_ie , uint in_len , u8 eid , u8 *oui , u8 oui_len , u8 *ie ,
                     uint *ielen ) ;
#line 316
int rtw_ies_remove_ie23a(u8 *ies , uint *ies_len , uint offset , u8 eid , u8 *oui ,
                         u8 oui_len ) ;
#line 318
void rtw_set_supported_rate23a(u8 *SupportedRates , uint mode ) ;
#line 320
int rtw_parse_wpa_ie23a(u8 const   *wpa_ie , int wpa_ie_len , int *group_cipher ,
                        int *pairwise_cipher , int *is_8021x ) ;
#line 321
int rtw_parse_wpa2_ie23a(u8 const   *rsn_ie , int rsn_ie_len , int *group_cipher ,
                         int *pairwise_cipher , int *is_8021x ) ;
#line 323
u8 const   *rtw_get_wps_attr23a(u8 const   *wps_ie , uint wps_ielen , u16 target_attr_id ,
                                u8 *buf_attr , u32 *len_attr ) ;
#line 324
u8 const   *rtw_get_wps_attr_content23a(u8 const   *wps_ie , uint wps_ielen , u16 target_attr_id ,
                                        u8 *buf_content ) ;
#line 326
uint rtw_get_rateset_len23a(u8 *rateset ) ;
#line 329
int rtw_generate_ie23a(struct registry_priv *pregistrypriv ) ;
#line 332
int rtw_get_bit_value_from_ieee_value23a(u8 val ) ;
#line 334
int rtw_check_network_type23a(unsigned char *rate , int ratelen , int channel ) ;
#line 336
void rtw_get_bcn_info23a(struct wlan_network *pnetwork ) ;
#line 338
u16 rtw_mcs_rate23a(u8 rf_type , u8 bw_40MHz , u8 short_GI_20 , u8 short_GI_40 , struct ieee80211_mcs_info *mcs ) ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 RTW_WPA_OUI23A_TYPE[4U]  = {      0U,      80U,      242U,      1U};
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u16 RTW_WPA_VERSION23A  =    1U;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 WPA_AUTH_KEY_MGMT_NONE23A[4U]  = {      0U,      80U,      242U,      0U};
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U]  = {      0U,      80U,      242U,      1U};
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U]  = {      0U,      80U,      242U,      2U};
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 WPA_CIPHER_SUITE_NONE23A[4U]  = {      0U,      80U,      242U,      0U};
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 WPA_CIPHER_SUITE_WEP4023A[4U]  = {      0U,      80U,      242U,      1U};
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 WPA_CIPHER_SUITE_TKIP23A[4U]  = {      0U,      80U,      242U,      2U};
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 WPA_CIPHER_SUITE_WRAP23A[4U]  = {      0U,      80U,      242U,      3U};
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 WPA_CIPHER_SUITE_CCMP23A[4U]  = {      0U,      80U,      242U,      4U};
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 WPA_CIPHER_SUITE_WEP10423A[4U]  = {      0U,      80U,      242U,      5U};
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U]  = {      0U,      15U,      172U,      1U};
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U]  = {      0U,      15U,      172U,      2U};
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 RSN_CIPHER_SUITE_NONE23A[4U]  = {      0U,      15U,      172U,      0U};
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 RSN_CIPHER_SUITE_WEP4023A[4U]  = {      0U,      15U,      172U,      1U};
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 RSN_CIPHER_SUITE_TKIP23A[4U]  = {      0U,      15U,      172U,      2U};
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 RSN_CIPHER_SUITE_WRAP23A[4U]  = {      0U,      15U,      172U,      3U};
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 RSN_CIPHER_SUITE_CCMP23A[4U]  = {      0U,      15U,      172U,      4U};
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 RSN_CIPHER_SUITE_WEP10423A[4U]  = {      0U,      15U,      172U,      5U};
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
static u8 WIFI_CCKRATES[4U]  = {      130U,      132U,      139U,      150U};
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
static u8 WIFI_OFDMRATES[8U]  = 
#line 55
  {      12U,      18U,      24U,      36U, 
        48U,      72U,      96U,      108U};
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
int rtw_get_bit_value_from_ieee_value23a(u8 val ) 
{ 
  unsigned char dot11_rate_table[13U] ;
  int i ;

  {
#line 68
  dot11_rate_table[0] = 2U;
#line 68
  dot11_rate_table[1] = 4U;
#line 68
  dot11_rate_table[2] = 11U;
#line 68
  dot11_rate_table[3] = 22U;
#line 68
  dot11_rate_table[4] = 12U;
#line 68
  dot11_rate_table[5] = 18U;
#line 68
  dot11_rate_table[6] = 24U;
#line 68
  dot11_rate_table[7] = 36U;
#line 68
  dot11_rate_table[8] = 48U;
#line 68
  dot11_rate_table[9] = 72U;
#line 68
  dot11_rate_table[10] = 96U;
#line 68
  dot11_rate_table[11] = 108U;
#line 68
  dot11_rate_table[12] = 0U;
#line 71
  i = 0;
#line 73
  goto ldv_53201;
  ldv_53200: ;
#line 74
  if ((int )dot11_rate_table[i] == (int )val) {
#line 75
    return ((int )(1UL << i));
  } else {

  }
#line 76
  i = i + 1;
  ldv_53201: ;
#line 73
  if ((unsigned int )dot11_rate_table[i] != 0U) {
#line 75
    goto ldv_53200;
  } else {

  }

#line 78
  return (0);
}
}
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
static bool rtw_is_cckrates_included(u8 *rate ) 
{ 
  u32 i ;

  {
#line 83
  i = 0U;
#line 85
  goto ldv_53208;
  ldv_53207: ;
#line 86
  if (((((int )*(rate + (unsigned long )i) & 127) == 2 || ((int )*(rate + (unsigned long )i) & 127) == 4) || ((int )*(rate + (unsigned long )i) & 127) == 11) || ((int )*(rate + (unsigned long )i) & 127) == 22) {
#line 88
    return (1);
  } else {

  }
#line 89
  i = i + 1U;
  ldv_53208: ;
#line 85
  if ((unsigned int )*(rate + (unsigned long )i) != 0U) {
#line 87
    goto ldv_53207;
  } else {

  }

#line 92
  return (0);
}
}
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
static bool rtw_is_cckratesonly_included(u8 *rate ) 
{ 
  u32 i ;

  {
#line 97
  i = 0U;
#line 99
  goto ldv_53215;
  ldv_53214: ;
#line 100
  if (((((int )*(rate + (unsigned long )i) & 127) != 2 && ((int )*(rate + (unsigned long )i) & 127) != 4) && ((int )*(rate + (unsigned long )i) & 127) != 11) && ((int )*(rate + (unsigned long )i) & 127) != 22) {
#line 102
    return (0);
  } else {

  }
#line 104
  i = i + 1U;
  ldv_53215: ;
#line 99
  if ((unsigned int )*(rate + (unsigned long )i) != 0U) {
#line 101
    goto ldv_53214;
  } else {

  }

#line 107
  return (1);
}
}
#line 110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
int rtw_check_network_type23a(unsigned char *rate , int ratelen , int channel ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 112
  if (channel > 14) {
#line 113
    tmp = rtw_is_cckrates_included(rate);
#line 113
    if ((int )tmp) {
#line 114
      return (0);
    } else {
#line 116
      return (4);
    }
  } else {
#line 118
    tmp___1 = rtw_is_cckratesonly_included(rate);
#line 118
    if ((int )tmp___1) {
#line 119
      return (1);
    } else {
#line 120
      tmp___0 = rtw_is_cckrates_included(rate);
#line 120
      if ((int )tmp___0) {
#line 121
        return (3);
      } else {
#line 123
        return (2);
      }
    }
  }
}
}
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 *rtw_set_ie23a(u8 *pbuf , int index , uint len , u8 const   *source , uint *frlen ) 
{ 


  {
#line 131
  *pbuf = (unsigned char )index;
#line 133
  *(pbuf + 1UL) = (unsigned char )len;
#line 135
  if (len != 0U) {
#line 136
    memcpy((void *)pbuf + 2U, (void const   *)source, (size_t )len);
  } else {

  }
#line 138
  *frlen = (*frlen + len) + 2U;
#line 140
  return (pbuf + ((unsigned long )len + 2UL));
}
}
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 *rtw_get_ie23a(u8 *pbuf , int index , int *len , int limit ) 
{ 
  int tmp ;
  int i ;
  u8 *p ;

  {
#line 179
  if (limit <= 0) {
#line 181
    return ((u8 *)0U);
  } else {

  }
#line 184
  p = pbuf;
#line 185
  i = 0;
#line 186
  *len = 0;
  ldv_53255: ;
#line 188
  if ((int )*p == index) {
#line 189
    *len = (int )*(p + 1UL);
#line 190
    return (p);
  } else {
#line 192
    tmp = (int )*(p + 1UL);
#line 193
    p = p + ((unsigned long )tmp + 2UL);
#line 194
    i = (tmp + 2) + i;
  }
#line 196
  if (i >= limit) {
#line 197
    goto ldv_53254;
  } else {

  }
#line 198
  goto ldv_53255;
  ldv_53254: ;
#line 200
  return ((u8 *)0U);
}
}
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 *rtw_get_ie23a_ex(u8 *in_ie , uint in_len , u8 eid , u8 *oui , u8 oui_len , u8 *ie ,
                     uint *ielen ) 
{ 
  uint cnt ;
  u8 *target_ie ;
  int tmp ;

  {
#line 221
  target_ie = (u8 *)0U;
#line 223
  if ((unsigned long )ielen != (unsigned long )((uint *)0U)) {
#line 224
    *ielen = 0U;
  } else {

  }
#line 226
  if ((unsigned long )in_ie == (unsigned long )((u8 *)0U) || in_len == 0U) {
#line 227
    return (target_ie);
  } else {

  }
#line 229
  cnt = 0U;
#line 231
  goto ldv_53269;
  ldv_53268: ;
#line 232
  if ((int )*(in_ie + (unsigned long )cnt) == (int )eid) {
#line 232
    if ((unsigned long )oui == (unsigned long )((u8 *)0U)) {
#line 232
      goto _L;
    } else {
#line 232
      tmp = memcmp((void const   *)in_ie + (unsigned long )(cnt + 2U), (void const   *)oui,
                   (size_t )oui_len);
#line 232
      if (tmp == 0) {
        _L: /* CIL Label */ 
#line 234
        target_ie = in_ie + (unsigned long )cnt;
#line 236
        if ((unsigned long )ie != (unsigned long )((u8 *)0U)) {
#line 237
          memcpy((void *)ie, (void const   *)in_ie + (unsigned long )cnt, (size_t )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2));
        } else {

        }
#line 239
        if ((unsigned long )ielen != (unsigned long )((uint *)0U)) {
#line 240
          *ielen = (uint )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
        } else {

        }
#line 241
        goto ldv_53267;
      } else {
#line 243
        cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
      }
    }
  } else {
#line 243
    cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
  }
  ldv_53269: ;
#line 231
  if (cnt < in_len) {
#line 233
    goto ldv_53268;
  } else {

  }
  ldv_53267: ;
#line 247
  return (target_ie);
}
}
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
int rtw_ies_remove_ie23a(u8 *ies , uint *ies_len , uint offset , u8 eid , u8 *oui ,
                         u8 oui_len ) 
{ 
  int ret ;
  u8 *target_ie ;
  u32 target_ielen ;
  u8 *start ;
  uint search_len ;
  u8 buf[768U] ;
  unsigned int tmp ;
  u8 *remain_ies ;
  uint remain_len ;

  {
#line 264
  ret = 0;
#line 270
  if (((unsigned long )ies == (unsigned long )((u8 *)0U) || (unsigned long )ies_len == (unsigned long )((uint *)0U)) || *ies_len <= offset) {
#line 271
    goto exit;
  } else {

  }
#line 273
  start = ies + (unsigned long )offset;
#line 274
  search_len = *ies_len - offset;
  ldv_53288: 
#line 277
  target_ie = rtw_get_ie23a_ex(start, search_len, (int )eid, oui, (int )oui_len, (u8 *)0U,
                               & target_ielen);
#line 279
  if ((unsigned long )target_ie != (unsigned long )((u8 *)0U) && target_ielen != 0U) {
#line 280
    buf[0] = 0U;
#line 280
    tmp = 1U;
#line 280
    while (1) {
#line 280
      if (tmp >= 768U) {
#line 280
        break;
      } else {

      }
#line 280
      buf[tmp] = (unsigned char)0;
#line 280
      tmp = tmp + 1U;
    }
#line 281
    remain_ies = target_ie + (unsigned long )target_ielen;
#line 282
    remain_len = ((uint )((long )start) - (uint )((long )remain_ies)) + search_len;
#line 284
    memcpy((void *)(& buf), (void const   *)remain_ies, (size_t )remain_len);
#line 285
    memcpy((void *)target_ie, (void const   *)(& buf), (size_t )remain_len);
#line 286
    *ies_len = *ies_len - target_ielen;
#line 287
    ret = 1;
#line 289
    start = target_ie;
#line 290
    search_len = remain_len;
  } else {
#line 292
    goto ldv_53287;
  }
#line 294
  goto ldv_53288;
  ldv_53287: ;
  exit: ;
#line 296
  return (ret);
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
void rtw_set_supported_rate23a(u8 *SupportedRates , uint mode ) 
{ 


  {
#line 303
  memset((void *)SupportedRates, 0, 16UL);
#line 305
  switch (mode) {
  case 1U: 
#line 307
  memcpy((void *)SupportedRates, (void const   *)(& WIFI_CCKRATES), 4UL);
#line 308
  goto ldv_53294;
  case 2U: ;
  case 4U: ;
  case 16U: ;
  case 20U: 
#line 314
  memcpy((void *)SupportedRates, (void const   *)(& WIFI_OFDMRATES), 8UL);
#line 316
  goto ldv_53294;
  case 3U: ;
  case 10U: ;
  case 8U: ;
  case 11U: 
#line 322
  memcpy((void *)SupportedRates, (void const   *)(& WIFI_CCKRATES), 4UL);
#line 323
  memcpy((void *)SupportedRates + 4U, (void const   *)(& WIFI_OFDMRATES), 8UL);
#line 325
  goto ldv_53294;
  }
  ldv_53294: ;
#line 329
  return;
}
}
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
uint rtw_get_rateset_len23a(u8 *rateset ) 
{ 
  uint i ;

  {
#line 332
  i = 0U;
  ldv_53308: ;
#line 335
  if ((unsigned int )*(rateset + (unsigned long )i) == 0U) {
#line 336
    goto ldv_53307;
  } else {

  }
#line 338
  if (i > 12U) {
#line 339
    goto ldv_53307;
  } else {

  }
#line 341
  i = i + 1U;
#line 342
  goto ldv_53308;
  ldv_53307: ;
#line 344
  return (i);
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
int rtw_generate_ie23a(struct registry_priv *pregistrypriv ) 
{ 
  u8 wireless_mode ;
  int sz ;
  int rateLen ;
  struct wlan_bssid_ex *pdev_network ;
  u8 *ie ;
  u16 cap ;
  uint tmp ;

  {
#line 350
  sz = 0;
#line 351
  pdev_network = & pregistrypriv->dev_network;
#line 352
  ie = (u8 *)(& pdev_network->IEs);
#line 355
  pdev_network->tsf = 0ULL;
#line 357
  cap = 2U;
#line 359
  if ((unsigned int )pregistrypriv->preamble == 3U) {
#line 360
    cap = (u16 )((unsigned int )cap | 32U);
  } else {

  }
#line 362
  if (pdev_network->Privacy != 0U) {
#line 363
    cap = (u16 )((unsigned int )cap | 16U);
  } else {

  }
#line 365
  pdev_network->capability = cap;
#line 368
  ie = rtw_set_ie23a(ie, 0, (uint )pdev_network->Ssid.ssid_len, (u8 const   *)(& pdev_network->Ssid.ssid),
                     (uint *)(& sz));
#line 372
  if ((unsigned int )pregistrypriv->wireless_mode == 31U) {
#line 373
    if (pdev_network->DSConfig > 14U) {
#line 374
      wireless_mode = 20U;
    } else {
#line 376
      wireless_mode = 11U;
    }
  } else {
#line 378
    wireless_mode = pregistrypriv->wireless_mode;
  }
#line 381
  rtw_set_supported_rate23a((u8 *)(& pdev_network->SupportedRates), (uint )wireless_mode);
#line 383
  tmp = rtw_get_rateset_len23a((u8 *)(& pdev_network->SupportedRates));
#line 383
  rateLen = (int )tmp;
#line 385
  if (rateLen > 8) {
#line 386
    ie = rtw_set_ie23a(ie, 1, 8U, (u8 const   *)(& pdev_network->SupportedRates),
                       (uint *)(& sz));
  } else {
#line 390
    ie = rtw_set_ie23a(ie, 1, (uint )rateLen, (u8 const   *)(& pdev_network->SupportedRates),
                       (uint *)(& sz));
  }
#line 395
  ie = rtw_set_ie23a(ie, 3, 1U, (u8 const   *)(& pdev_network->DSConfig), (uint *)(& sz));
#line 400
  ie = rtw_set_ie23a(ie, 6, 2U, (u8 const   *)(& pdev_network->ATIMWindow), (uint *)(& sz));
#line 403
  if (rateLen > 8) {
#line 404
    ie = rtw_set_ie23a(ie, 50, (uint )(rateLen + -8), (u8 const   *)(& pdev_network->SupportedRates) + 8U,
                       (uint *)(& sz));
  } else {

  }
#line 412
  return (sz);
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
static int rtw_get_wpa_cipher_suite(u8 const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 417
  tmp = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_NONE23A), 4UL);
#line 417
  if (tmp == 0) {
#line 418
    return (1);
  } else {

  }
#line 419
  tmp___0 = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_WEP4023A),
                   4UL);
#line 419
  if (tmp___0 == 0) {
#line 420
    return (2);
  } else {

  }
#line 421
  tmp___1 = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_TKIP23A),
                   4UL);
#line 421
  if (tmp___1 == 0) {
#line 422
    return (8);
  } else {

  }
#line 423
  tmp___2 = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_CCMP23A),
                   4UL);
#line 423
  if (tmp___2 == 0) {
#line 424
    return (16);
  } else {

  }
#line 425
  tmp___3 = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_WEP10423A),
                   4UL);
#line 425
  if (tmp___3 == 0) {
#line 426
    return (4);
  } else {

  }
#line 428
  return (0);
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
static int rtw_get_wpa2_cipher_suite(u8 const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 433
  tmp = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_NONE23A), 4UL);
#line 433
  if (tmp == 0) {
#line 434
    return (1);
  } else {

  }
#line 435
  tmp___0 = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_WEP4023A),
                   4UL);
#line 435
  if (tmp___0 == 0) {
#line 436
    return (2);
  } else {

  }
#line 437
  tmp___1 = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_TKIP23A),
                   4UL);
#line 437
  if (tmp___1 == 0) {
#line 438
    return (8);
  } else {

  }
#line 439
  tmp___2 = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_CCMP23A),
                   4UL);
#line 439
  if (tmp___2 == 0) {
#line 440
    return (16);
  } else {

  }
#line 441
  tmp___3 = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_WEP10423A),
                   4UL);
#line 441
  if (tmp___3 == 0) {
#line 442
    return (4);
  } else {

  }
#line 444
  return (0);
}
}
#line 447 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
int rtw_parse_wpa_ie23a(u8 const   *wpa_ie , int wpa_ie_len , int *group_cipher ,
                        int *pairwise_cipher , int *is_8021x ) 
{ 
  int i ;
  int ret ;
  int left ;
  int count ;
  u8 const   *pos ;
  u16 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 449
  ret = 1;
#line 453
  if (wpa_ie_len <= 0) {
#line 455
    return (0);
  } else {

  }
#line 458
  if ((unsigned int )((unsigned char )*(wpa_ie + 1UL)) != (unsigned int )((unsigned char )wpa_ie_len) - 2U) {
#line 459
    return (0);
  } else {

  }
#line 461
  pos = wpa_ie;
#line 463
  pos = pos + 8UL;
#line 464
  left = wpa_ie_len + -8;
#line 467
  if (left > 3) {
#line 469
    *group_cipher = rtw_get_wpa_cipher_suite(pos);
#line 471
    pos = pos + 4UL;
#line 472
    left = left + -4;
  } else
#line 473
  if (left > 0) {
#line 474
    if (GlobalDebugLevel23A > 3U) {
#line 474
      rt_trace(16, 4, "%s: ie length mismatch, %u too much\n", "rtw_parse_wpa_ie23a",
               left);
    } else {

    }
#line 478
    return (0);
  } else {

  }
#line 482
  if (left > 1) {
#line 484
    tmp = get_unaligned_le16((void const   *)pos);
#line 484
    count = (int )tmp;
#line 485
    pos = pos + 2UL;
#line 486
    left = left + -2;
#line 488
    if (count == 0 || count * 4 > left) {
#line 489
      if (GlobalDebugLevel23A > 3U) {
#line 489
        rt_trace(16, 4, "%s: ie count botch (pairwise), count %u left %u\n", "rtw_parse_wpa_ie23a",
                 count, left);
      } else {

      }
#line 492
      return (0);
    } else {

    }
#line 495
    i = 0;
#line 495
    goto ldv_53338;
    ldv_53337: 
#line 496
    tmp___0 = rtw_get_wpa_cipher_suite(pos);
#line 496
    *pairwise_cipher = *pairwise_cipher | tmp___0;
#line 498
    pos = pos + 4UL;
#line 499
    left = left + -4;
#line 495
    i = i + 1;
    ldv_53338: ;
#line 495
    if (i < count) {
#line 497
      goto ldv_53337;
    } else {

    }

  } else
#line 501
  if (left == 1) {
#line 502
    if (GlobalDebugLevel23A > 3U) {
#line 502
      rt_trace(16, 4, "%s: ie too short (for key mgmt)\n", "rtw_parse_wpa_ie23a");
    } else {

    }
#line 504
    return (0);
  } else {

  }
#line 507
  if ((unsigned long )is_8021x != (unsigned long )((int *)0)) {
#line 508
    if (left > 5) {
#line 509
      pos = pos + 2UL;
#line 510
      tmp___1 = memcmp((void const   *)pos, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                       4UL);
#line 510
      if (tmp___1 == 0) {
#line 511
        if (GlobalDebugLevel23A > 6U) {
#line 511
          rt_trace(16, 7, "%s : there has 802.1x auth\n", "rtw_parse_wpa_ie23a");
        } else {

        }
#line 514
        *is_8021x = 1;
      } else {

      }
    } else {

    }
  } else {

  }
#line 519
  return (ret);
}
}
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
int rtw_parse_wpa2_ie23a(u8 const   *rsn_ie , int rsn_ie_len , int *group_cipher ,
                         int *pairwise_cipher , int *is_8021x ) 
{ 
  int i ;
  int ret ;
  int left ;
  int count ;
  u8 const   *pos ;
  u8 SUITE_1X[4U] ;
  u16 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 525
  ret = 1;
#line 528
  SUITE_1X[0] = 0U;
#line 528
  SUITE_1X[1] = 15U;
#line 528
  SUITE_1X[2] = 172U;
#line 528
  SUITE_1X[3] = 1U;
#line 530
  if (rsn_ie_len <= 0) {
#line 532
    return (0);
  } else {

  }
#line 535
  if ((unsigned int )((unsigned char )*rsn_ie) != 48U || (unsigned int )((unsigned char )*(rsn_ie + 1UL)) != (unsigned int )((unsigned char )rsn_ie_len) - 2U) {
#line 536
    return (0);
  } else {

  }
#line 539
  pos = rsn_ie;
#line 540
  pos = pos + 4UL;
#line 541
  left = rsn_ie_len + -4;
#line 544
  if (left > 3) {
#line 545
    *group_cipher = rtw_get_wpa2_cipher_suite(pos);
#line 547
    pos = pos + 4UL;
#line 548
    left = left + -4;
  } else
#line 549
  if (left > 0) {
#line 550
    if (GlobalDebugLevel23A > 3U) {
#line 550
      rt_trace(16, 4, "%s: ie length mismatch, %u too much\n", "rtw_parse_wpa2_ie23a",
               left);
    } else {

    }
#line 553
    return (0);
  } else {

  }
#line 557
  if (left > 1) {
#line 559
    tmp = get_unaligned_le16((void const   *)pos);
#line 559
    count = (int )tmp;
#line 560
    pos = pos + 2UL;
#line 561
    left = left + -2;
#line 563
    if (count == 0 || count * 4 > left) {
#line 564
      if (GlobalDebugLevel23A > 3U) {
#line 564
        rt_trace(16, 4, "%s: ie count botch (pairwise), count %u left %u\n", "rtw_parse_wpa2_ie23a",
                 count, left);
      } else {

      }
#line 567
      return (0);
    } else {

    }
#line 570
    i = 0;
#line 570
    goto ldv_53355;
    ldv_53354: 
#line 571
    tmp___0 = rtw_get_wpa2_cipher_suite(pos);
#line 571
    *pairwise_cipher = *pairwise_cipher | tmp___0;
#line 573
    pos = pos + 4UL;
#line 574
    left = left + -4;
#line 570
    i = i + 1;
    ldv_53355: ;
#line 570
    if (i < count) {
#line 572
      goto ldv_53354;
    } else {

    }

  } else
#line 576
  if (left == 1) {
#line 577
    if (GlobalDebugLevel23A > 3U) {
#line 577
      rt_trace(16, 4, "%s: ie too short (for key mgmt)\n", "rtw_parse_wpa2_ie23a");
    } else {

    }
#line 580
    return (0);
  } else {

  }
#line 583
  if ((unsigned long )is_8021x != (unsigned long )((int *)0)) {
#line 584
    if (left > 5) {
#line 585
      pos = pos + 2UL;
#line 586
      tmp___1 = memcmp((void const   *)pos, (void const   *)(& SUITE_1X), 4UL);
#line 586
      if (tmp___1 == 0) {
#line 587
        if (GlobalDebugLevel23A > 6U) {
#line 587
          rt_trace(16, 7, "%s (): there has 802.1x auth\n", "rtw_parse_wpa2_ie23a");
        } else {

        }
#line 590
        *is_8021x = 1;
      } else {

      }
    } else {

    }
  } else {

  }
#line 595
  return (ret);
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 const   *rtw_get_wps_attr23a(u8 const   *wps_ie , uint wps_ielen , u16 target_attr_id ,
                                u8 *buf_attr , u32 *len_attr ) 
{ 
  u8 const   *attr_ptr ;
  u8 const   *target_attr_ptr ;
  u8 wps_oui[4U] ;
  int tmp ;
  u16 attr_id ;
  u16 tmp___0 ;
  u16 attr_data_len ;
  u16 tmp___1 ;
  u16 attr_len ;

  {
#line 613
  attr_ptr = (u8 const   *)0U;
#line 614
  target_attr_ptr = (u8 const   *)0U;
#line 615
  wps_oui[0] = 0U;
#line 615
  wps_oui[1] = 80U;
#line 615
  wps_oui[2] = 242U;
#line 615
  wps_oui[3] = 4U;
#line 617
  if ((unsigned long )len_attr != (unsigned long )((u32 *)0U)) {
#line 618
    *len_attr = 0U;
  } else {

  }
#line 620
  if ((unsigned int )((unsigned char )*wps_ie) != 221U) {
#line 622
    return (attr_ptr);
  } else {
#line 620
    tmp = memcmp((void const   *)wps_ie + 2U, (void const   *)(& wps_oui), 4UL);
#line 620
    if (tmp != 0) {
#line 622
      return (attr_ptr);
    } else {

    }
  }
#line 626
  attr_ptr = wps_ie + 6UL;
#line 628
  goto ldv_53372;
  ldv_53371: 
#line 630
  tmp___0 = get_unaligned_be16((void const   *)attr_ptr);
#line 630
  attr_id = tmp___0;
#line 631
  tmp___1 = get_unaligned_be16((void const   *)attr_ptr + 2U);
#line 631
  attr_data_len = tmp___1;
#line 632
  attr_len = (unsigned int )attr_data_len + 4U;
#line 635
  if ((int )attr_id == (int )target_attr_id) {
#line 636
    target_attr_ptr = attr_ptr;
#line 638
    if ((unsigned long )buf_attr != (unsigned long )((u8 *)0U)) {
#line 639
      memcpy((void *)buf_attr, (void const   *)attr_ptr, (size_t )attr_len);
    } else {

    }
#line 641
    if ((unsigned long )len_attr != (unsigned long )((u32 *)0U)) {
#line 642
      *len_attr = (u32 )attr_len;
    } else {

    }
#line 644
    goto ldv_53370;
  } else {
#line 646
    attr_ptr = attr_ptr + (unsigned long )attr_len;
  }
  ldv_53372: ;
#line 628
  if ((long )attr_ptr - (long )wps_ie < (long )wps_ielen) {
#line 630
    goto ldv_53371;
  } else {

  }
  ldv_53370: ;
#line 650
  return (target_attr_ptr);
}
}
#line 666 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u8 const   *rtw_get_wps_attr_content23a(u8 const   *wps_ie , uint wps_ielen , u16 target_attr_id ,
                                        u8 *buf_content ) 
{ 
  u8 const   *attr_ptr ;
  u32 attr_len ;

  {
#line 672
  attr_ptr = rtw_get_wps_attr23a(wps_ie, wps_ielen, (int )target_attr_id, (u8 *)0U,
                                 & attr_len);
#line 675
  if ((unsigned long )attr_ptr != (unsigned long )((u8 const   *)0U) && attr_len != 0U) {
#line 676
    if ((unsigned long )buf_content != (unsigned long )((u8 *)0U)) {
#line 677
      memcpy((void *)buf_content, (void const   *)attr_ptr + 4U, (size_t )(attr_len - 4U));
    } else {

    }
#line 679
    return (attr_ptr + 4UL);
  } else {

  }
#line 682
  return ((u8 const   *)0U);
}
}
#line 685 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
static int rtw_get_cipher_info(struct wlan_network *pnetwork ) 
{ 
  u8 const   *pbuf ;
  int group_cipher ;
  int pairwise_cipher ;
  int is8021x ;
  int ret ;
  int r ;
  int plen ;
  char *pie ;

  {
#line 688
  group_cipher = 0;
#line 688
  pairwise_cipher = 0;
#line 688
  is8021x = 0;
#line 689
  ret = 0;
#line 693
  pie = (char *)(& pnetwork->network.IEs);
#line 694
  plen = (int )pnetwork->network.IELength;
#line 696
  pbuf = cfg80211_find_vendor_ie(20722U, 1, (u8 const   *)pie, plen);
#line 699
  if ((unsigned long )pbuf != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(pbuf + 1UL)) != 0U) {
#line 700
    if (GlobalDebugLevel23A > 6U) {
#line 700
      rt_trace(16, 7, "rtw_get_cipher_info: wpa_ielen: %d\n", (int )*(pbuf + 1UL));
    } else {

    }
#line 702
    r = rtw_parse_wpa_ie23a(pbuf, (int )*(pbuf + 1UL) + 2, & group_cipher, & pairwise_cipher,
                            & is8021x);
#line 704
    if (r == 1) {
#line 705
      pnetwork->BcnInfo.pairwise_cipher = pairwise_cipher;
#line 706
      pnetwork->BcnInfo.group_cipher = group_cipher;
#line 707
      pnetwork->BcnInfo.is_8021x = is8021x;
#line 708
      if (GlobalDebugLevel23A > 6U) {
#line 708
        rt_trace(16, 7, "%s: pnetwork->pairwise_cipher: %d, is_8021x is %d\n", "rtw_get_cipher_info",
                 pnetwork->BcnInfo.pairwise_cipher, pnetwork->BcnInfo.is_8021x);
      } else {

      }
#line 712
      ret = 1;
    } else {

    }
  } else {
#line 715
    pbuf = cfg80211_find_ie(48, (u8 const   *)pie, plen);
#line 717
    if ((unsigned long )pbuf != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(pbuf + 1UL)) != 0U) {
#line 718
      if (GlobalDebugLevel23A > 6U) {
#line 718
        rt_trace(16, 7, "get RSN IE\n");
      } else {

      }
#line 720
      r = rtw_parse_wpa2_ie23a(pbuf, (int )*(pbuf + 1UL) + 2, & group_cipher, & pairwise_cipher,
                               & is8021x);
#line 723
      if (r == 1) {
#line 724
        if (GlobalDebugLevel23A > 6U) {
#line 724
          rt_trace(16, 7, "get RSN IE  OK!!!\n");
        } else {

        }
#line 726
        pnetwork->BcnInfo.pairwise_cipher = pairwise_cipher;
#line 728
        pnetwork->BcnInfo.group_cipher = group_cipher;
#line 729
        pnetwork->BcnInfo.is_8021x = is8021x;
#line 730
        if (GlobalDebugLevel23A > 6U) {
#line 730
          rt_trace(16, 7, "%s: pnetwork->pairwise_cipher: %d,pnetwork->group_cipher is %d, is_8021x is %d\n",
                   "rtw_get_cipher_info", pnetwork->BcnInfo.pairwise_cipher, pnetwork->BcnInfo.group_cipher,
                   pnetwork->BcnInfo.is_8021x);
        } else {

        }
#line 736
        ret = 1;
      } else {

      }
    } else {

    }
  }
#line 741
  return (ret);
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
void rtw_get_bcn_info23a(struct wlan_network *pnetwork ) 
{ 
  u8 bencrypt ;
  int pie_len ;
  u8 *pie ;
  u8 const   *p ;
  u8 const   *tmp ;

  {
#line 746
  bencrypt = 0U;
#line 751
  if (((int )pnetwork->network.capability & 16) != 0) {
#line 752
    bencrypt = 1U;
#line 753
    pnetwork->network.Privacy = 1U;
  } else {
#line 755
    pnetwork->BcnInfo.encryp_protocol = 0U;
  }
#line 757
  if (GlobalDebugLevel23A > 6U) {
#line 757
    rt_trace(16, 7, "%s: ssid =%s\n", "rtw_get_bcn_info23a", (u8 *)(& pnetwork->network.Ssid.ssid));
  } else {

  }
#line 760
  pie = (u8 *)(& pnetwork->network.IEs);
#line 761
  pie_len = (int )pnetwork->network.IELength;
#line 763
  p = cfg80211_find_ie(48, (u8 const   *)pie, pie_len);
#line 764
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 765
    pnetwork->BcnInfo.encryp_protocol = 3U;
  } else {
#line 766
    tmp = cfg80211_find_vendor_ie(20722U, 1, (u8 const   *)pie, pie_len);
#line 766
    if ((unsigned long )tmp != (unsigned long )((u8 const   *)0U)) {
#line 769
      pnetwork->BcnInfo.encryp_protocol = 2U;
    } else
#line 771
    if ((unsigned int )bencrypt != 0U) {
#line 772
      pnetwork->BcnInfo.encryp_protocol = 1U;
    } else {

    }
  }
#line 774
  if (GlobalDebugLevel23A > 6U) {
#line 774
    rt_trace(16, 7, "%s: pnetwork->encryp_protocol is %x\n", "rtw_get_bcn_info23a",
             (int )pnetwork->BcnInfo.encryp_protocol);
  } else {

  }
#line 777
  if (GlobalDebugLevel23A > 6U) {
#line 777
    rt_trace(16, 7, "%s: pnetwork->encryp_protocol is %x\n", "rtw_get_bcn_info23a",
             (int )pnetwork->BcnInfo.encryp_protocol);
  } else {

  }
#line 780
  rtw_get_cipher_info(pnetwork);
#line 781
  return;
}
}
#line 786 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.c"
u16 rtw_mcs_rate23a(u8 rf_type , u8 bw_40MHz , u8 short_GI_20 , u8 short_GI_40 , struct ieee80211_mcs_info *mcs ) 
{ 
  u16 max_rate ;

  {
#line 789
  max_rate = 0U;
#line 791
  if ((unsigned int )rf_type == 3U) {
#line 792
    if ((int )((signed char )mcs->rx_mask[0]) < 0) {
#line 793
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1500U : 1350U) : ((unsigned int )short_GI_20 != 0U ? 722U : 650U);
    } else
#line 795
    if (((unsigned long )mcs->rx_mask[0] & 64UL) != 0UL) {
#line 796
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1350U : 1215U) : ((unsigned int )short_GI_20 != 0U ? 650U : 585U);
    } else
#line 798
    if (((unsigned long )mcs->rx_mask[0] & 32UL) != 0UL) {
#line 799
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1200U : 1080U) : ((unsigned int )short_GI_20 != 0U ? 578U : 520U);
    } else
#line 801
    if (((unsigned long )mcs->rx_mask[0] & 16UL) != 0UL) {
#line 802
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 900U : 810U) : ((unsigned int )short_GI_20 != 0U ? 433U : 390U);
    } else
#line 804
    if (((unsigned long )mcs->rx_mask[0] & 8UL) != 0UL) {
#line 805
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 600U : 540U) : ((unsigned int )short_GI_20 != 0U ? 289U : 260U);
    } else
#line 807
    if (((unsigned long )mcs->rx_mask[0] & 4UL) != 0UL) {
#line 808
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 450U : 405U) : ((unsigned int )short_GI_20 != 0U ? 217U : 195U);
    } else
#line 810
    if (((unsigned long )mcs->rx_mask[0] & 2UL) != 0UL) {
#line 811
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 300U : 270U) : ((unsigned int )short_GI_20 != 0U ? 144U : 130U);
    } else
#line 813
    if ((int )mcs->rx_mask[0] & 1) {
#line 814
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 150U : 135U) : ((unsigned int )short_GI_20 != 0U ? 72U : 65U);
    } else {

    }
  } else
#line 817
  if ((unsigned int )mcs->rx_mask[1] != 0U) {
#line 818
    if ((int )((signed char )mcs->rx_mask[1]) < 0) {
#line 819
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 3000U : 2700U) : ((unsigned int )short_GI_20 != 0U ? 1444U : 1300U);
    } else
#line 820
    if (((unsigned long )mcs->rx_mask[1] & 64UL) != 0UL) {
#line 821
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 2700U : 2430U) : ((unsigned int )short_GI_20 != 0U ? 1300U : 1170U);
    } else
#line 822
    if (((unsigned long )mcs->rx_mask[1] & 32UL) != 0UL) {
#line 823
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 2400U : 2160U) : ((unsigned int )short_GI_20 != 0U ? 1156U : 1040U);
    } else
#line 824
    if (((unsigned long )mcs->rx_mask[1] & 16UL) != 0UL) {
#line 825
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1800U : 1620U) : ((unsigned int )short_GI_20 != 0U ? 867U : 780U);
    } else
#line 826
    if (((unsigned long )mcs->rx_mask[1] & 8UL) != 0UL) {
#line 827
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1200U : 1080U) : ((unsigned int )short_GI_20 != 0U ? 578U : 520U);
    } else
#line 828
    if (((unsigned long )mcs->rx_mask[1] & 4UL) != 0UL) {
#line 829
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 900U : 810U) : ((unsigned int )short_GI_20 != 0U ? 433U : 390U);
    } else
#line 830
    if (((unsigned long )mcs->rx_mask[1] & 2UL) != 0UL) {
#line 831
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 600U : 540U) : ((unsigned int )short_GI_20 != 0U ? 289U : 260U);
    } else
#line 832
    if ((int )mcs->rx_mask[1] & 1) {
#line 833
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 300U : 270U) : ((unsigned int )short_GI_20 != 0U ? 144U : 130U);
    } else {

    }
  } else
#line 835
  if ((int )((signed char )mcs->rx_mask[0]) < 0) {
#line 836
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1500U : 1350U) : ((unsigned int )short_GI_20 != 0U ? 722U : 650U);
  } else
#line 837
  if (((unsigned long )mcs->rx_mask[0] & 64UL) != 0UL) {
#line 838
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1350U : 1215U) : ((unsigned int )short_GI_20 != 0U ? 650U : 585U);
  } else
#line 839
  if (((unsigned long )mcs->rx_mask[0] & 32UL) != 0UL) {
#line 840
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1200U : 1080U) : ((unsigned int )short_GI_20 != 0U ? 578U : 520U);
  } else
#line 841
  if (((unsigned long )mcs->rx_mask[0] & 16UL) != 0UL) {
#line 842
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 900U : 810U) : ((unsigned int )short_GI_20 != 0U ? 433U : 390U);
  } else
#line 843
  if (((unsigned long )mcs->rx_mask[0] & 8UL) != 0UL) {
#line 844
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 600U : 540U) : ((unsigned int )short_GI_20 != 0U ? 289U : 260U);
  } else
#line 845
  if (((unsigned long )mcs->rx_mask[0] & 4UL) != 0UL) {
#line 846
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 450U : 405U) : ((unsigned int )short_GI_20 != 0U ? 217U : 195U);
  } else
#line 847
  if (((unsigned long )mcs->rx_mask[0] & 2UL) != 0UL) {
#line 848
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 300U : 270U) : ((unsigned int )short_GI_20 != 0U ? 144U : 130U);
  } else
#line 849
  if ((int )mcs->rx_mask[0] & 1) {
#line 850
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 150U : 135U) : ((unsigned int )short_GI_20 != 0U ? 72U : 65U);
  } else {

  }
#line 853
  return (max_rate);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
bool ldv_queue_work_on_49(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
bool ldv_queue_delayed_work_on_50(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
bool ldv_queue_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
void ldv_flush_workqueue_52(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
bool ldv_queue_delayed_work_on_53(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 112 "include/linux/list.h"
extern void __list_del_entry(struct list_head * ) ;
#line 143 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 145
  __list_del_entry(entry);
#line 146
  INIT_LIST_HEAD(entry);
#line 147
  return;
}
}
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 284 "include/linux/jiffies.h"
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 173 "include/linux/timer.h"
int ldv_mod_timer_69(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 177
int ldv_mod_timer_70(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 181
int ldv_mod_timer_71(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 185
int ldv_mod_timer_73(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 189
int ldv_mod_timer_74(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 193
int ldv_mod_timer_75(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 197
int ldv_mod_timer_76(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 201
int ldv_mod_timer_77(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 232
int ldv_del_timer_sync_68(struct timer_list *ldv_func_arg1 ) ;
#line 236
int ldv_del_timer_sync_72(struct timer_list *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_64(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_67(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_66(struct workqueue_struct *ldv_func_arg1 ) ;
#line 111 "include/linux/pid.h"
extern struct pid *find_vpid(int  ) ;
#line 2450 "include/linux/sched.h"
extern int kill_pid(struct pid * , int  , int  ) ;
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
struct timer_list *ldv_timer_list_7_1 ;
#line 27
int ldv_timer_5_2 ;
#line 30
struct timer_list *ldv_timer_list_5_0 ;
#line 35
int ldv_timer_6_2 ;
#line 37
struct timer_list *ldv_timer_list_5_3 ;
#line 41
int ldv_timer_4_3 ;
#line 43
int ldv_timer_6_0 ;
#line 45
struct timer_list *ldv_timer_list_5_1 ;
#line 52
struct timer_list *ldv_timer_list_6_3 ;
#line 56
struct timer_list *ldv_timer_list_6_2 ;
#line 60
struct timer_list *ldv_timer_list_4_0 ;
#line 61
struct timer_list *ldv_timer_list_7_3 ;
#line 68
struct timer_list *ldv_timer_list_6_0 ;
#line 72
int ldv_timer_7_1 ;
#line 74
struct timer_list *ldv_timer_list_4_3 ;
#line 77
int ldv_timer_5_3 ;
#line 78
struct timer_list *ldv_timer_list_7_0 ;
#line 81
int ldv_timer_4_1 ;
#line 83
struct timer_list *ldv_timer_list_4_1 ;
#line 90
int ldv_timer_7_3 ;
#line 93
int ldv_timer_4_0 ;
#line 95
struct timer_list *ldv_timer_list_5_2 ;
#line 104
int ldv_timer_5_1 ;
#line 105
struct timer_list *ldv_timer_list_7_2 ;
#line 108
struct timer_list *ldv_timer_list_6_1 ;
#line 109
int ldv_timer_7_0 ;
#line 116
int ldv_timer_6_3 ;
#line 120
int ldv_timer_4_2 ;
#line 134
int ldv_timer_5_0 ;
#line 139
int ldv_timer_7_2 ;
#line 141
struct timer_list *ldv_timer_list_4_2 ;
#line 146
int ldv_timer_6_1 ;
#line 158
void activate_suitable_timer_6(struct timer_list *timer , unsigned long data ) ;
#line 163
int reg_timer_7(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 165
void ldv_timer_5(int state , struct timer_list *timer ) ;
#line 166
void choose_timer_5(void) ;
#line 168
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 170
void timer_init_4(void) ;
#line 179
void timer_init_6(void) ;
#line 185
void ldv_timer_7(int state , struct timer_list *timer ) ;
#line 186
void timer_init_5(void) ;
#line 190
void disable_suitable_timer_6(struct timer_list *timer ) ;
#line 191
void disable_suitable_timer_5(struct timer_list *timer ) ;
#line 195
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 196
void activate_suitable_timer_4(struct timer_list *timer , unsigned long data ) ;
#line 203
void disable_suitable_timer_7(struct timer_list *timer ) ;
#line 210
void choose_timer_6(void) ;
#line 212
int reg_timer_6(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 216
void ldv_timer_6(int state , struct timer_list *timer ) ;
#line 217
void timer_init_7(void) ;
#line 219
void choose_timer_4(void) ;
#line 222
void disable_suitable_timer_4(struct timer_list *timer ) ;
#line 225
int reg_timer_4(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 230
int reg_timer_11(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 235
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 236
void choose_timer_7(void) ;
#line 241
int reg_timer_5(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 243
void ldv_timer_4(int state , struct timer_list *timer ) ;
#line 244
void activate_suitable_timer_5(struct timer_list *timer , unsigned long data ) ;
#line 245
void activate_pending_timer_7(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 247
void activate_suitable_timer_7(struct timer_list *timer , unsigned long data ) ;
#line 3047 "include/linux/netdevice.h"
extern void netif_carrier_on(struct net_device * ) ;
#line 93 "include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const   *addr ) 
{ 


  {
#line 96
  return (((unsigned int )*((u32 const   *)addr) | (unsigned int )*((u16 const   *)addr + 4U)) == 0U);
}
}
#line 111 "include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const   *addr ) 
{ 
  u32 a ;

  {
#line 114
  a = *((u32 const   *)addr);
#line 121
  return ((a & 1U) != 0U);
}
}
#line 310 "include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 const   *addr1 , u8 const   *addr2 ) 
{ 
  u32 fold ;

  {
#line 313
  fold = ((unsigned int )*((u32 const   *)addr1) ^ (unsigned int )*((u32 const   *)addr2)) | (unsigned int )((int )((unsigned short )*((u16 const   *)addr1 + 4U)) ^ (int )((unsigned short )*((u16 const   *)addr2 + 4U)));
#line 316
  return (fold == 0U);
}
}
#line 3257 "include/net/cfg80211.h"
__inline static void *wiphy_priv(struct wiphy *wiphy ) 
{ 
  long tmp ;

  {
#line 3259
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
#line 3259
  if (tmp != 0L) {
#line 3259
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3259), "i" (12UL));
    ldv_48232: ;
#line 3259
    goto ldv_48232;
  } else {

  }
#line 3260
  return ((void *)(& wiphy->priv));
}
}
#line 3510 "include/net/cfg80211.h"
__inline static void *wdev_priv(struct wireless_dev *wdev ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
#line 3512
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
#line 3512
  if (tmp != 0L) {
#line 3512
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3512), "i" (12UL));
    ldv_48317: ;
#line 3512
    goto ldv_48317;
  } else {

  }
#line 3513
  tmp___0 = wiphy_priv(wdev->wiphy);
#line 3513
  return (tmp___0);
}
}
#line 55 "drivers/staging/rtl8723au/include/osdep_service.h"
__inline static struct list_head *get_list_head(struct rtw_queue *queue ) 
{ 


  {
#line 57
  return (& queue->queue);
}
}
#line 76
unsigned char MCS_rate_2R23A[16U] ;
#line 79
unsigned char MCS_rate_1R23A[16U] ;
#line 81
void _rtw_init_queue23a(struct rtw_queue *pqueue ) ;
#line 341 "drivers/staging/rtl8723au/include/rtw_xmit.h"
void rtw_update_protection23a(struct rtw_adapter *padapter , u8 *ie , uint ie_len ) ;
#line 26 "drivers/staging/rtl8723au/include/xmit_osdep.h"
void rtw_os_xmit_schedule23a(struct rtw_adapter *padapter ) ;
#line 280 "drivers/staging/rtl8723au/include/rtw_recv.h"
u32 rtw_free_uc_swdec_pending_queue23a(struct rtw_adapter *adapter ) ;
#line 112 "drivers/staging/rtl8723au/include/hal_intf.h"
int GetHalDefVar8192CUsb(struct rtw_adapter *Adapter , enum hal_def_variable eVariable ,
                         void *pValue ) ;
#line 168 "drivers/staging/rtl8723au/include/hal_com.h"
void rtl8723a_set_rxdma_agg_pg_th(struct rtw_adapter *padapter , u8 val ) ;
#line 178
u8 rtl8723a_get_rf_type(struct rtw_adapter *padapter ) ;
#line 366 "drivers/staging/rtl8723au/include/sta_info.h"
int rtw_free_stainfo23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 367
void rtw_free_all_stainfo23a(struct rtw_adapter *padapter ) ;
#line 369
int rtw_init_bcmc_stainfo23a(struct rtw_adapter *padapter ) ;
#line 371
bool rtw_access_ctrl23a(struct rtw_adapter *padapter , u8 *mac_addr ) ;
#line 21 "drivers/staging/rtl8723au/include/mlme_osdep.h"
void rtw_os_indicate_disconnect23a(struct rtw_adapter *adapter ) ;
#line 22
void rtw_reset_securitypriv23a(struct rtw_adapter *adapter ) ;
#line 200 "drivers/staging/rtl8723au/include/rtw_mlme.h"
void rtw_joinbss_event_prehandle23a(struct rtw_adapter *adapter , u8 *pbuf ) ;
#line 201
void rtw_survey_event_cb23a(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
#line 202
void rtw_surveydone_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
#line 203
void rtw23a_joinbss_event_cb(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
#line 204
void rtw_stassoc_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
#line 205
void rtw_stadel_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
#line 208
void rtw23a_join_to_handler(unsigned long data ) ;
#line 211
int rtw_init_mlme_priv23a(struct rtw_adapter *padapter ) ;
#line 213
void rtw_free_mlme_priv23a(struct mlme_priv *pmlmepriv ) ;
#line 215
int rtw_do_join_adhoc(struct rtw_adapter *adapter ) ;
#line 216
int rtw_do_join_network(struct rtw_adapter *adapter , struct wlan_network *candidate ) ;
#line 218
int rtw_select_and_join_from_scanned_queue23a(struct mlme_priv *pmlmepriv ) ;
#line 219
int rtw_set_key23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ,
                   int keyid , u8 set_tx ) ;
#line 221
int rtw_set_auth23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ) ;
#line 238 "drivers/staging/rtl8723au/include/rtw_mlme.h"
__inline static int get_fwstate(struct mlme_priv *pmlmepriv ) 
{ 


  {
#line 240
  return (pmlmepriv->fw_state);
}
}
#line 287
void rtw_generate_random_ibss23a(u8 *pibss ) ;
#line 288
struct wlan_network *rtw_find_network23a(struct rtw_queue *scanned_queue , u8 *addr ) ;
#line 291
void rtw_free_assoc_resources23a(struct rtw_adapter *adapter , int lock_scanned_queue ) ;
#line 293
void rtw_indicate_disconnect23a(struct rtw_adapter *padapter ) ;
#line 295
void rtw_scan_abort23a(struct rtw_adapter *adapter ) ;
#line 301
void rtw_init_registrypriv_dev_network23a(struct rtw_adapter *adapter ) ;
#line 303
void rtw_update_registrypriv_dev_network23a(struct rtw_adapter *adapter ) ;
#line 305
void rtw_scan_timeout_handler23a(unsigned long data ) ;
#line 307
void rtw_dynamic_check_timer_handler(unsigned long data ) ;
#line 309
void rtw_clear_scan_deny(struct rtw_adapter *adapter ) ;
#line 310
void rtw_set_scan_deny_timer_hdl(unsigned long data ) ;
#line 311
void rtw_set_scan_deny(struct rtw_adapter *adapter , u32 ms ) ;
#line 313
void rtw23a_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv ) ;
#line 319
int rtw_if_up23a(struct rtw_adapter *padapter ) ;
#line 321
int rtw_linked_check(struct rtw_adapter *padapter ) ;
#line 323
void rtw_joinbss_reset23a(struct rtw_adapter *padapter ) ;
#line 327
void rtw_update_ht_cap23a(struct rtw_adapter *padapter , u8 *pie , uint ie_len ) ;
#line 329
void rtw_issue_addbareq_cmd23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 332
bool rtw_is_same_ibss23a(struct rtw_adapter *adapter , struct wlan_network *pnetwork ) ;
#line 334
int is_same_network23a(struct wlan_bssid_ex *src , struct wlan_bssid_ex *dst ) ;
#line 336
void rtw23a_roaming(struct rtw_adapter *padapter , struct wlan_network *tgt_network ) ;
#line 338
void rtw_set_roaming(struct rtw_adapter *adapter , u8 to_roaming ) ;
#line 484 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
void update_network23a(struct wlan_bssid_ex *dst , struct wlan_bssid_ex *src , struct rtw_adapter *padapter ,
                       bool update_ie ) ;
#line 519
void update_sta_info23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 573
void mlmeext_joinbss_event_callback23a(struct rtw_adapter *padapter , int join_res ) ;
#line 574
void mlmeext_sta_del_event_callback23a(struct rtw_adapter *padapter ) ;
#line 575
void mlmeext_sta_add_event_callback23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 46 "drivers/staging/rtl8723au/include/rtw_ap.h"
void ap_sta_info_defer_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 50 "drivers/staging/rtl8723au/include/ioctl_cfg80211.h"
void rtw_cfg80211_surveydone_event_callback(struct rtw_adapter *padapter ) ;
#line 52
void rtw_cfg80211_indicate_connect(struct rtw_adapter *padapter ) ;
#line 53
void rtw_cfg80211_indicate_disconnect(struct rtw_adapter *padapter ) ;
#line 54
void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv , bool aborted ) ;
#line 269 "drivers/staging/rtl8723au/include/drv_types.h"
__inline static u8 *myid(struct eeprom_priv *peepriv ) 
{ 


  {
#line 271
  return ((u8 *)(& peepriv->mac_addr));
}
}
#line 527 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
void rtl8723a_SetHalODMVar(struct rtw_adapter *Adapter , enum hal_odm_variable eVariable ,
                           void *pValue1 , bool bSet ) ;
#line 34 "drivers/staging/rtl8723au/include/rtw_sreset.h"
void rtw_sreset_reset(struct rtw_adapter *active_adapter ) ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static struct wlan_network *rtw_select_candidate_from_queue(struct mlme_priv *pmlmepriv ) ;
#line 31
static int rtw_do_join(struct rtw_adapter *padapter ) ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static void rtw_init_mlme_timer(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;

  {
#line 35
  pmlmepriv = & padapter->mlmepriv;
#line 37
  reg_timer_11(& pmlmepriv->assoc_timer, & rtw23a_join_to_handler, (unsigned long )padapter);
#line 40
  reg_timer_11(& pmlmepriv->scan_to_timer, & rtw_scan_timeout_handler23a, (unsigned long )padapter);
#line 43
  reg_timer_11(& pmlmepriv->dynamic_chk_timer, & rtw_dynamic_check_timer_handler,
               (unsigned long )padapter);
#line 46
  reg_timer_11(& pmlmepriv->set_scan_deny_timer, & rtw_set_scan_deny_timer_hdl, (unsigned long )padapter);
#line 47
  return;
}
}
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
int rtw_init_mlme_priv23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct lock_class_key __key ;

  {
#line 52
  pmlmepriv = & padapter->mlmepriv;
#line 54
  pmlmepriv->nic_hdl = padapter;
#line 56
  pmlmepriv->fw_state = 0;
#line 57
  pmlmepriv->cur_network.network.ifmode = 0;
#line 60
  pmlmepriv->scan_mode = 1;
#line 62
  spinlock_check(& pmlmepriv->lock);
#line 62
  __raw_spin_lock_init(& pmlmepriv->lock.__annonCompField18.rlock, "&(&pmlmepriv->lock)->rlock",
                       & __key);
#line 63
  _rtw_init_queue23a(& pmlmepriv->scanned_queue);
#line 65
  memset((void *)(& pmlmepriv->assoc_ssid), 0, 33UL);
#line 67
  rtw_clear_scan_deny(padapter);
#line 69
  rtw_init_mlme_timer(padapter);
#line 70
  return (1);
}
}
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static void rtw_free_mlme_ie_data(u8 **ppie , u32 *plen ) 
{ 


  {
#line 76
  if ((unsigned long )*ppie != (unsigned long )((u8 *)0U)) {
#line 77
    kfree((void const   *)*ppie);
#line 78
    *plen = 0U;
#line 79
    *ppie = (u8 *)0U;
  } else {

  }
#line 81
  return;
}
}
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw23a_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv ) 
{ 


  {
#line 87
  kfree((void const   *)pmlmepriv->assoc_req);
#line 88
  kfree((void const   *)pmlmepriv->assoc_rsp);
#line 89
  rtw_free_mlme_ie_data(& pmlmepriv->wps_probe_req_ie, & pmlmepriv->wps_probe_req_ie_len);
#line 91
  return;
}
}
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_free_mlme_priv23a(struct mlme_priv *pmlmepriv ) 
{ 


  {
#line 96
  if (GlobalDebugLevel23A > 3U) {
#line 96
    rt_trace(16, 4, "rtw_free_mlme_priv23a\n");
  } else {

  }
#line 99
  rtw23a_free_mlme_priv_ie_data(pmlmepriv);
#line 100
  return;
}
}
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
struct wlan_network *rtw_alloc_network(struct mlme_priv *pmlmepriv , gfp_t gfp ) 
{ 
  struct wlan_network *pnetwork ;
  void *tmp ;

  {
#line 106
  tmp = kzalloc(928UL, gfp);
#line 106
  pnetwork = (struct wlan_network *)tmp;
#line 107
  if ((unsigned long )pnetwork != (unsigned long )((struct wlan_network *)0)) {
#line 108
    INIT_LIST_HEAD(& pnetwork->list);
#line 109
    pnetwork->network_type = 0;
#line 110
    pnetwork->fixed = 0;
#line 111
    pnetwork->last_scanned = jiffies;
#line 112
    pnetwork->join_res = 0;
  } else {

  }
#line 115
  return (pnetwork);
}
}
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static void _rtw_free_network23a(struct mlme_priv *pmlmepriv , struct wlan_network *pnetwork ) 
{ 


  {
#line 121
  if ((unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
#line 122
    return;
  } else {

  }
#line 124
  if (pnetwork->fixed == 1) {
#line 125
    return;
  } else {

  }
#line 127
  list_del_init(& pnetwork->list);
#line 129
  kfree((void const   *)pnetwork);
#line 130
  return;
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
struct wlan_network *rtw_find_network23a(struct rtw_queue *scanned_queue , u8 *addr ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct wlan_network *pnetwork ;
  bool tmp ;
  struct list_head  const  *__mptr ;
  bool tmp___0 ;

  {
#line 141
  pnetwork = (struct wlan_network *)0;
#line 143
  tmp = is_zero_ether_addr((u8 const   *)addr);
#line 143
  if ((int )tmp) {
#line 144
    pnetwork = (struct wlan_network *)0;
#line 145
    goto exit;
  } else {

  }
#line 150
  phead = get_list_head(scanned_queue);
#line 151
  plist = phead->next;
#line 153
  goto ldv_55826;
  ldv_55825: 
#line 154
  __mptr = (struct list_head  const  *)plist;
#line 154
  pnetwork = (struct wlan_network *)__mptr;
#line 156
  tmp___0 = ether_addr_equal((u8 const   *)addr, (u8 const   *)(& pnetwork->network.MacAddress));
#line 156
  if ((int )tmp___0) {
#line 157
    goto ldv_55824;
  } else {

  }
#line 159
  plist = plist->next;
  ldv_55826: ;
#line 153
  if ((unsigned long )plist != (unsigned long )phead) {
#line 155
    goto ldv_55825;
  } else {

  }
  ldv_55824: ;
#line 162
  if ((unsigned long )plist == (unsigned long )phead) {
#line 163
    pnetwork = (struct wlan_network *)0;
  } else {

  }
  exit: ;
#line 169
  return (pnetwork);
}
}
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_free_network_queue23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct wlan_network *pnetwork ;
  struct mlme_priv *pmlmepriv ;
  struct rtw_queue *scanned_queue ;
  struct list_head  const  *__mptr ;

  {
#line 176
  pmlmepriv = & padapter->mlmepriv;
#line 177
  scanned_queue = & pmlmepriv->scanned_queue;
#line 179
  spin_lock_bh(& scanned_queue->lock);
#line 181
  phead = get_list_head(scanned_queue);
#line 183
  plist = phead->next;
#line 183
  ptmp = plist->next;
#line 183
  goto ldv_55839;
  ldv_55838: 
#line 184
  __mptr = (struct list_head  const  *)plist;
#line 184
  pnetwork = (struct wlan_network *)__mptr;
#line 186
  _rtw_free_network23a(pmlmepriv, pnetwork);
#line 183
  plist = ptmp;
#line 183
  ptmp = plist->next;
  ldv_55839: ;
#line 183
  if ((unsigned long )plist != (unsigned long )phead) {
#line 185
    goto ldv_55838;
  } else {

  }
#line 189
  spin_unlock_bh(& scanned_queue->lock);
#line 190
  return;
}
}
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
int rtw_if_up23a(struct rtw_adapter *padapter ) 
{ 
  int res ;
  bool tmp ;
  int tmp___0 ;

  {
#line 196
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 196
    goto _L;
  } else {
#line 196
    tmp = check_fwstate(& padapter->mlmepriv, 1);
#line 196
    if (tmp) {
#line 196
      tmp___0 = 0;
    } else {
#line 196
      tmp___0 = 1;
    }
#line 196
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 198
      if (GlobalDebugLevel23A > 6U) {
#line 198
        rt_trace(16, 7, "rtw_if_up23a:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n",
                 padapter->bDriverStopped, padapter->bSurpriseRemoved);
      } else {

      }
#line 201
      res = 0;
    } else {
#line 203
      res = 1;
    }
  }
#line 205
  return (res);
}
}
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_generate_random_ibss23a(u8 *pibss ) 
{ 
  unsigned long curtime ;

  {
#line 210
  curtime = jiffies;
#line 212
  *pibss = 2U;
#line 213
  *(pibss + 1UL) = 17U;
#line 214
  *(pibss + 2UL) = 135U;
#line 215
  *(pibss + 3UL) = (u8 )curtime;
#line 216
  *(pibss + 4UL) = (u8 )(curtime >> 8);
#line 217
  *(pibss + 5UL) = (u8 )(curtime >> 16);
#line 218
  return;
}
}
#line 220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_set_roaming(struct rtw_adapter *adapter , u8 to_roaming ) 
{ 


  {
#line 222
  if ((unsigned int )to_roaming == 0U) {
#line 223
    adapter->mlmepriv.to_join = 0U;
  } else {

  }
#line 224
  adapter->mlmepriv.to_roaming = to_roaming;
#line 225
  return;
}
}
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static void _rtw_roaming(struct rtw_adapter *padapter , struct wlan_network *tgt_network ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  int do_join_r ;

  {
#line 230
  pmlmepriv = & padapter->mlmepriv;
#line 234
  if ((unsigned long )tgt_network != (unsigned long )((struct wlan_network *)0)) {
#line 235
    pnetwork = tgt_network;
  } else {
#line 237
    pnetwork = & pmlmepriv->cur_network;
  }
#line 239
  if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
#line 240
    if (GlobalDebugLevel23A > 3U) {
#line 240
      printk("\016RTL8723AU: roaming from %s(%pM), length:%d\n", (u8 *)(& pnetwork->network.Ssid.ssid),
             (u8 *)(& pnetwork->network.MacAddress), (int )pnetwork->network.Ssid.ssid_len);
    } else {

    }
#line 244
    memcpy((void *)(& pmlmepriv->assoc_ssid), (void const   *)(& pnetwork->network.Ssid),
             33UL);
#line 247
    pmlmepriv->assoc_by_bssid = 0U;
    ldv_55863: 
#line 250
    do_join_r = rtw_do_join(padapter);
#line 251
    if (do_join_r == 1) {
#line 252
      goto ldv_55860;
    } else {
#line 254
      if (GlobalDebugLevel23A > 3U) {
#line 254
        printk("\016RTL8723AU: roaming do_join return %d\n", do_join_r);
      } else {

      }
#line 256
      pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
#line 258
      if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
#line 259
        goto ldv_55861;
      } else {
#line 261
        if (GlobalDebugLevel23A > 3U) {
#line 261
          printk("\016RTL8723AU: %s(%d) -to roaming fail, indicate_disconnect\n",
                 "_rtw_roaming", 263);
        } else {

        }
#line 264
        rtw_indicate_disconnect23a(padapter);
#line 265
        goto ldv_55860;
      }
    }
    ldv_55861: ;
#line 268
    goto ldv_55863;
    ldv_55860: ;
  } else {

  }
#line 271
  return;
}
}
#line 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw23a_roaming(struct rtw_adapter *padapter , struct wlan_network *tgt_network ) 
{ 
  struct mlme_priv *pmlmepriv ;

  {
#line 275
  pmlmepriv = & padapter->mlmepriv;
#line 277
  spin_lock_bh(& pmlmepriv->lock);
#line 278
  _rtw_roaming(padapter, tgt_network);
#line 279
  spin_unlock_bh(& pmlmepriv->lock);
#line 280
  return;
}
}
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static void rtw_free_network_nolock(struct mlme_priv *pmlmepriv , struct wlan_network *pnetwork ) 
{ 


  {
#line 285
  _rtw_free_network23a(pmlmepriv, pnetwork);
#line 286
  return;
}
}
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
bool rtw_is_same_ibss23a(struct rtw_adapter *adapter , struct wlan_network *pnetwork ) 
{ 
  int ret ;
  struct security_priv *psecuritypriv ;

  {
#line 292
  psecuritypriv = & adapter->securitypriv;
#line 294
  if (psecuritypriv->dot11PrivacyAlgrthm != 0U && pnetwork->network.Privacy == 0U) {
#line 296
    ret = 0;
  } else
#line 297
  if (psecuritypriv->dot11PrivacyAlgrthm == 0U && pnetwork->network.Privacy == 1U) {
#line 299
    ret = 0;
  } else {
#line 301
    ret = 1;
  }
#line 303
  return (ret != 0);
}
}
#line 306
__inline int is_same_ess(struct wlan_bssid_ex *a , struct wlan_bssid_ex *b ) ;
#line 307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
__inline int is_same_ess(struct wlan_bssid_ex *a , struct wlan_bssid_ex *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 309
  if ((int )a->Ssid.ssid_len == (int )b->Ssid.ssid_len) {
#line 309
    tmp = memcmp((void const   *)(& a->Ssid.ssid), (void const   *)(& b->Ssid.ssid),
                 (size_t )a->Ssid.ssid_len);
#line 309
    if (tmp == 0) {
#line 309
      tmp___0 = 1;
    } else {
#line 309
      tmp___0 = 0;
    }
  } else {
#line 309
    tmp___0 = 0;
  }
#line 309
  return (tmp___0);
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
int is_same_network23a(struct wlan_bssid_ex *src , struct wlan_bssid_ex *dst ) 
{ 
  u16 s_cap ;
  u16 d_cap ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 317
  s_cap = src->capability;
#line 318
  d_cap = dst->capability;
#line 320
  if ((int )src->Ssid.ssid_len == (int )dst->Ssid.ssid_len) {
#line 320
    tmp = ether_addr_equal((u8 const   *)(& src->MacAddress), (u8 const   *)(& dst->MacAddress));
#line 320
    if ((int )tmp) {
#line 320
      tmp___0 = memcmp((void const   *)(& src->Ssid.ssid), (void const   *)(& dst->Ssid.ssid),
                       (size_t )src->Ssid.ssid_len);
#line 320
      if (tmp___0 == 0) {
#line 320
        if ((((int )s_cap ^ (int )d_cap) & 2) == 0) {
#line 320
          if ((((int )s_cap ^ (int )d_cap) & 1) == 0) {
#line 320
            tmp___1 = 1;
          } else {
#line 320
            tmp___1 = 0;
          }
        } else {
#line 320
          tmp___1 = 0;
        }
      } else {
#line 320
        tmp___1 = 0;
      }
    } else {
#line 320
      tmp___1 = 0;
    }
  } else {
#line 320
    tmp___1 = 0;
  }
#line 320
  return (tmp___1);
}
}
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
struct wlan_network *rtw_get_oldest_wlan_network23a(struct rtw_queue *scanned_queue ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct wlan_network *pwlan ;
  struct wlan_network *oldest ;
  struct list_head  const  *__mptr ;

  {
#line 334
  oldest = (struct wlan_network *)0;
#line 336
  phead = get_list_head(scanned_queue);
#line 338
  plist = phead->next;
#line 338
  goto ldv_55908;
  ldv_55907: 
#line 339
  __mptr = (struct list_head  const  *)plist;
#line 339
  pwlan = (struct wlan_network *)__mptr;
#line 341
  if (pwlan->fixed != 1) {
#line 342
    if ((unsigned long )oldest == (unsigned long )((struct wlan_network *)0) || (long )(pwlan->last_scanned - oldest->last_scanned) < 0L) {
#line 344
      oldest = pwlan;
    } else {

    }
  } else {

  }
#line 338
  plist = plist->next;
  ldv_55908: ;
#line 338
  if ((unsigned long )plist != (unsigned long )phead) {
#line 340
    goto ldv_55907;
  } else {

  }

#line 348
  return (oldest);
}
}
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void update_network23a(struct wlan_bssid_ex *dst , struct wlan_bssid_ex *src , struct rtw_adapter *padapter ,
                       bool update_ie ) 
{ 
  u8 ss_ori ;
  u8 sq_ori ;
  long rssi_ori ;
  u8 ss_smp ;
  u8 sq_smp ;
  long rssi_smp ;
  u8 ss_final ;
  u8 sq_final ;
  long rssi_final ;
  bool tmp ;
  int tmp___0 ;
  uint tmp___1 ;

  {
#line 354
  ss_ori = dst->SignalStrength;
#line 355
  sq_ori = dst->SignalQuality;
#line 356
  rssi_ori = dst->Rssi;
#line 358
  ss_smp = src->SignalStrength;
#line 359
  sq_smp = src->SignalQuality;
#line 360
  rssi_smp = src->Rssi;
#line 366
  if (GlobalDebugLevel23A > 3U) {
#line 366
    printk("\016RTL8723AU: %s %s(%pM, ch%u) ss_ori:%3u, sq_ori:%3u, rssi_ori:%3ld, ss_smp:%3u, sq_smp:%3u, rssi_smp:%3ld\n",
           "update_network23a", (u8 *)(& src->Ssid.ssid), (u8 *)(& src->MacAddress),
           src->DSConfig, (int )ss_ori, (int )sq_ori, rssi_ori, (int )ss_smp, (int )sq_smp,
           rssi_smp);
  } else {

  }
#line 374
  tmp = check_fwstate(& padapter->mlmepriv, 1);
#line 374
  if ((int )tmp) {
#line 374
    tmp___0 = is_same_network23a(& padapter->mlmepriv.cur_network.network, src);
#line 374
    if (tmp___0 != 0) {
#line 377
      ss_final = padapter->recvpriv.signal_strength;
#line 378
      sq_final = padapter->recvpriv.signal_qual;
#line 381
      if ((unsigned int )sq_smp != 101U) {
#line 382
        rssi_final = (src->Rssi + dst->Rssi * 4L) / 5L;
      } else {
#line 384
        rssi_final = rssi_ori;
      }
    } else {
#line 374
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 386
  if ((unsigned int )sq_smp != 101U) {
#line 387
    ss_final = (u8 )(((unsigned int )src->SignalStrength + (unsigned int )dst->SignalStrength * 4U) / 5U);
#line 389
    sq_final = (u8 )(((unsigned int )src->SignalQuality + (unsigned int )dst->SignalQuality * 4U) / 5U);
#line 391
    rssi_final = src->Rssi + (dst->Rssi * 4L) / 5L;
  } else {
#line 395
    ss_final = dst->SignalStrength;
#line 396
    sq_final = dst->SignalQuality;
#line 397
    rssi_final = dst->Rssi;
  }
#line 402
  if ((int )update_ie) {
#line 403
    tmp___1 = get_wlan_bssid_ex_sz(src);
#line 403
    memcpy((void *)dst, (void const   *)src, (size_t )tmp___1);
  } else {

  }
#line 405
  dst->SignalStrength = ss_final;
#line 406
  dst->SignalQuality = sq_final;
#line 407
  dst->Rssi = rssi_final;
#line 409
  if (GlobalDebugLevel23A > 3U) {
#line 409
    printk("\016RTL8723AU: %s %s(%pM), SignalStrength:%u, SignalQuality:%u, RawRSSI:%ld\n",
           "update_network23a", (u8 *)(& dst->Ssid.ssid), (u8 *)(& dst->MacAddress),
           (int )dst->SignalStrength, (int )dst->SignalQuality, dst->Rssi);
  } else {

  }
#line 410
  return;
}
}
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static void update_current_network(struct rtw_adapter *adapter , struct wlan_bssid_ex *pnetwork ) 
{ 
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  int tmp___0 ;

  {
#line 417
  pmlmepriv = & adapter->mlmepriv;
#line 419
  tmp = check_fwstate(pmlmepriv, 1);
#line 419
  if ((int )tmp) {
#line 419
    tmp___0 = is_same_network23a(& pmlmepriv->cur_network.network, pnetwork);
#line 419
    if (tmp___0 != 0) {
#line 421
      update_network23a(& pmlmepriv->cur_network.network, pnetwork, adapter, 1);
#line 424
      rtw_update_protection23a(adapter, (u8 *)(& pmlmepriv->cur_network.network.IEs),
                               pmlmepriv->cur_network.network.IELength);
    } else {

    }
  } else {

  }
#line 428
  return;
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static void rtw_update_scanned_network(struct rtw_adapter *adapter , struct wlan_bssid_ex *target ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  struct wlan_network *oldest ;
  struct rtw_queue *queue ;
  u32 bssid_ex_sz ;
  int found ;
  struct list_head  const  *__mptr ;
  int tmp ;
  bool update_ie ;

  {
#line 439
  pmlmepriv = & adapter->mlmepriv;
#line 440
  pnetwork = (struct wlan_network *)0;
#line 441
  oldest = (struct wlan_network *)0;
#line 442
  queue = & pmlmepriv->scanned_queue;
#line 444
  found = 0;
#line 446
  spin_lock_bh(& queue->lock);
#line 447
  phead = get_list_head(queue);
#line 449
  plist = phead->next;
#line 449
  goto ldv_55953;
  ldv_55952: 
#line 450
  __mptr = (struct list_head  const  *)plist;
#line 450
  pnetwork = (struct wlan_network *)__mptr;
#line 452
  tmp = is_same_network23a(& pnetwork->network, target);
#line 452
  if (tmp != 0) {
#line 453
    found = 1;
#line 454
    goto ldv_55945;
  } else {

  }
#line 456
  if ((unsigned long )oldest == (unsigned long )((struct wlan_network *)0) || (long )(pnetwork->last_scanned - oldest->last_scanned) < 0L) {
#line 458
    oldest = pnetwork;
  } else {

  }
#line 449
  plist = plist->next;
  ldv_55953: ;
#line 449
  if ((unsigned long )plist != (unsigned long )phead) {
#line 451
    goto ldv_55952;
  } else {

  }
  ldv_55945: ;
#line 463
  if (found == 0) {
#line 464
    pnetwork = rtw_alloc_network(pmlmepriv, 32U);
#line 465
    if ((unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
#line 466
      if ((unsigned long )oldest == (unsigned long )((struct wlan_network *)0)) {
#line 467
        if (GlobalDebugLevel23A > 3U) {
#line 467
          rt_trace(16, 4, "something wrong here\n");
        } else {

        }
#line 469
        goto exit;
      } else {

      }
#line 471
      pnetwork = oldest;
    } else {
#line 473
      list_add_tail(& pnetwork->list, & queue->queue);
    }
#line 475
    bssid_ex_sz = get_wlan_bssid_ex_sz(target);
#line 476
    target->Length = bssid_ex_sz;
#line 477
    memcpy((void *)(& pnetwork->network), (void const   *)target, (size_t )bssid_ex_sz);
#line 480
    pnetwork->fixed = 0;
#line 481
    pnetwork->last_scanned = jiffies;
#line 483
    pnetwork->network_type = 0;
#line 484
    pnetwork->join_res = 0;
#line 487
    if ((unsigned int )pnetwork->network.SignalQuality == 101U) {
#line 488
      pnetwork->network.SignalQuality = 0U;
    } else {

    }
  } else {
#line 496
    update_ie = 1;
#line 498
    pnetwork->last_scanned = jiffies;
#line 502
    if (pnetwork->network.IELength > target->IELength && (unsigned int )target->reserved == 1U) {
#line 504
      update_ie = 0;
    } else {

    }
#line 506
    update_network23a(& pnetwork->network, target, adapter, (int )update_ie);
  }
  exit: 
#line 511
  spin_unlock_bh(& queue->lock);
#line 512
  return;
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static void rtw_add_network(struct rtw_adapter *adapter , struct wlan_bssid_ex *pnetwork ) 
{ 


  {
#line 517
  update_current_network(adapter, pnetwork);
#line 518
  rtw_update_scanned_network(adapter, pnetwork);
#line 519
  return;
}
}
#line 527 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static int rtw_is_desired_network(struct rtw_adapter *adapter , struct wlan_network *pnetwork ) 
{ 
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  u32 desired_encmode ;
  u32 privacy ;
  int bselected ;
  u8 const   *tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 530
  psecuritypriv = & adapter->securitypriv;
#line 531
  pmlmepriv = & adapter->mlmepriv;
#line 534
  bselected = 1;
#line 536
  desired_encmode = psecuritypriv->ndisencryptstatus;
#line 537
  privacy = pnetwork->network.Privacy;
#line 539
  tmp___0 = check_fwstate(pmlmepriv, 256);
#line 539
  if ((int )tmp___0) {
#line 540
    tmp = cfg80211_find_vendor_ie(20722U, 1, (u8 const   *)(& pnetwork->network.IEs),
                                  (int )pnetwork->network.IELength);
#line 540
    if ((unsigned long )tmp != (unsigned long )((u8 const   *)0U)) {
#line 544
      return (1);
    } else {
#line 546
      return (0);
    }
  } else {

  }
#line 548
  if ((unsigned int )adapter->registrypriv.wifi_spec == 1U) {
#line 550
    if (desired_encmode == 1U && privacy != 0U) {
#line 552
      bselected = 0;
    } else {

    }
  } else {

  }
#line 555
  if (desired_encmode != 1U && privacy == 0U) {
#line 556
    if (GlobalDebugLevel23A > 3U) {
#line 556
      printk("\016RTL8723AU: desired_encmode: %d, privacy: %d\n", desired_encmode,
             privacy);
    } else {

    }
#line 558
    bselected = 0;
  } else {

  }
#line 561
  tmp___1 = check_fwstate(pmlmepriv, 32);
#line 561
  if ((int )tmp___1) {
#line 562
    if ((unsigned int )pnetwork->network.ifmode != (unsigned int )pmlmepriv->cur_network.network.ifmode) {
#line 564
      bselected = 0;
    } else {

    }
  } else {

  }
#line 567
  return (bselected);
}
}
#line 570 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_survey_event_cb23a(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  u32 len ;
  struct wlan_bssid_ex *pnetwork ;
  struct mlme_priv *pmlmepriv ;
  struct survey_event *survey ;
  struct wlan_network *ibss_wlan ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 574
  pmlmepriv = & adapter->mlmepriv;
#line 575
  survey = (struct survey_event *)pbuf;
#line 577
  pnetwork = survey->bss;
#line 579
  if (GlobalDebugLevel23A > 6U) {
#line 579
    rt_trace(16, 7, "rtw_survey_event_cb23a, ssid=%s\n", (u8 *)(& pnetwork->Ssid.ssid));
  } else {

  }
#line 582
  len = get_wlan_bssid_ex_sz(pnetwork);
#line 583
  if (len > 871U) {
#line 584
    if (GlobalDebugLevel23A > 3U) {
#line 584
      rt_trace(16, 4, "****rtw_survey_event_cb23a: return a wrong bss ***\n");
    } else {

    }
#line 586
    return;
  } else {

  }
#line 589
  spin_lock_bh(& pmlmepriv->lock);
#line 592
  tmp___0 = check_fwstate(pmlmepriv, 64);
#line 592
  if ((int )tmp___0) {
#line 593
    tmp = ether_addr_equal((u8 const   *)(& pmlmepriv->cur_network.network.MacAddress),
                           (u8 const   *)(& pnetwork->MacAddress));
#line 593
    if ((int )tmp) {
#line 597
      pmlmepriv->cur_network.network.beacon_interval = pnetwork->beacon_interval;
#line 599
      pmlmepriv->cur_network.network.capability = pnetwork->capability;
#line 601
      pmlmepriv->cur_network.network.tsf = pnetwork->tsf;
#line 602
      spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 603
      ibss_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& pnetwork->MacAddress));
#line 606
      if ((unsigned long )ibss_wlan != (unsigned long )((struct wlan_network *)0)) {
#line 607
        pmlmepriv->cur_network.network.beacon_interval = ibss_wlan->network.beacon_interval;
#line 609
        pmlmepriv->cur_network.network.capability = ibss_wlan->network.capability;
#line 611
        pmlmepriv->cur_network.network.tsf = ibss_wlan->network.tsf;
#line 613
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 614
        goto exit;
      } else {

      }
#line 616
      spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
    } else {

    }
  } else {

  }
#line 621
  tmp___1 = check_fwstate(pmlmepriv, 128);
#line 621
  if (tmp___1) {
#line 621
    tmp___2 = 0;
  } else {
#line 621
    tmp___2 = 1;
  }
#line 621
  if (tmp___2) {
#line 622
    if ((unsigned int )pnetwork->Ssid.ssid[0] == 0U) {
#line 623
      pnetwork->Ssid.ssid_len = 0U;
    } else {

    }
#line 625
    rtw_add_network(adapter, pnetwork);
  } else {

  }
  exit: 
#line 630
  spin_unlock_bh(& pmlmepriv->lock);
#line 632
  kfree((void const   *)survey->bss);
#line 633
  survey->bss = (struct wlan_bssid_ex *)0;
#line 634
  return;
}
}
#line 637 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_surveydone_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;

  {
#line 639
  pmlmepriv = & adapter->mlmepriv;
#line 640
  pmlmeext = & adapter->mlmeextpriv;
#line 643
  spin_lock_bh(& pmlmepriv->lock);
#line 645
  if ((unsigned long )pmlmepriv->wps_probe_req_ie != (unsigned long )((u8 *)0U)) {
#line 646
    pmlmepriv->wps_probe_req_ie_len = 0U;
#line 647
    kfree((void const   *)pmlmepriv->wps_probe_req_ie);
#line 648
    pmlmepriv->wps_probe_req_ie = (u8 *)0U;
  } else {

  }
#line 651
  if (GlobalDebugLevel23A > 6U) {
#line 651
    tmp = get_fwstate(pmlmepriv);
#line 651
    rt_trace(16, 7, "rtw_surveydone_event_callback23a: fw_state:%x\n", tmp);
  } else {

  }
#line 655
  tmp___1 = check_fwstate(pmlmepriv, 2048);
#line 655
  if ((int )tmp___1) {
#line 656
    ldv_del_timer_sync_68(& pmlmepriv->scan_to_timer);
#line 658
    _clr_fwstate_(pmlmepriv, 2048);
  } else
#line 660
  if (GlobalDebugLevel23A > 3U) {
#line 660
    tmp___0 = get_fwstate(pmlmepriv);
#line 660
    rt_trace(16, 4, "nic status =%x, survey done event comes too late!\n", tmp___0);
  } else {

  }
#line 665
  tmp___2 = msecs_to_jiffies(adapter->recvpriv.signal_stat_sampling_interval);
#line 665
  ldv_mod_timer_69(& adapter->recvpriv.signal_stat_timer, tmp___2 + (unsigned long )jiffies);
#line 667
  if ((unsigned int )pmlmepriv->to_join == 1U) {
#line 668
    set_fwstate(pmlmepriv, 128);
#line 669
    tmp___4 = check_fwstate(pmlmepriv, 32);
#line 669
    if ((int )tmp___4) {
#line 670
      ret = rtw_select_and_join_from_scanned_queue23a(pmlmepriv);
#line 672
      if (ret != 1) {
#line 673
        rtw_do_join_adhoc(adapter);
      } else {

      }
    } else {
#line 675
      pmlmepriv->to_join = 0U;
#line 676
      ret = rtw_select_and_join_from_scanned_queue23a(pmlmepriv);
#line 678
      if (ret != 1) {
#line 679
        if (GlobalDebugLevel23A > 3U) {
#line 679
          printk("\016RTL8723AU: try_to_join, but select scanning queue fail, to_roaming:%d\n",
                 (int )adapter->mlmepriv.to_roaming);
        } else {

        }
#line 682
        if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
#line 683
          pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
#line 683
          if ((unsigned int )pmlmepriv->to_roaming == 0U) {
#line 688
            rtw_set_roaming(adapter, 0);
#line 689
            rtw_free_assoc_resources23a(adapter, 1);
#line 691
            rtw_indicate_disconnect23a(adapter);
          } else {
#line 683
            tmp___3 = rtw_sitesurvey_cmd23a(adapter, & pmlmepriv->assoc_ssid, 1, (struct rtw_ieee80211_channel *)0,
                                            0);
#line 683
            if (tmp___3 != 1) {
#line 688
              rtw_set_roaming(adapter, 0);
#line 689
              rtw_free_assoc_resources23a(adapter, 1);
#line 691
              rtw_indicate_disconnect23a(adapter);
            } else {
#line 694
              pmlmepriv->to_join = 1U;
            }
          }
        } else {

        }
#line 696
        _clr_fwstate_(pmlmepriv, 128);
      } else {

      }
    }
  } else {

  }
#line 701
  spin_unlock_bh(& pmlmepriv->lock);
#line 703
  rtw_os_xmit_schedule23a(adapter);
#line 705
  if (pmlmeext->sitesurvey_res.bss_cnt == 0) {
#line 706
    rtw_sreset_reset(adapter);
  } else {

  }
#line 708
  rtw_cfg80211_surveydone_event_callback(adapter);
#line 709
  return;
}
}
#line 711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static void free_scanqueue(struct mlme_priv *pmlmepriv ) 
{ 
  struct wlan_network *pnetwork ;
  struct rtw_queue *scan_queue ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptemp ;
  struct list_head  const  *__mptr ;

  {
#line 714
  scan_queue = & pmlmepriv->scanned_queue;
#line 717
  if (GlobalDebugLevel23A > 5U) {
#line 717
    rt_trace(16, 6, "+free_scanqueue\n");
  } else {

  }
#line 718
  spin_lock_bh(& scan_queue->lock);
#line 720
  phead = get_list_head(scan_queue);
#line 722
  plist = phead->next;
#line 722
  ptemp = plist->next;
#line 722
  goto ldv_55997;
  ldv_55996: 
#line 723
  __mptr = (struct list_head  const  *)plist;
#line 723
  pnetwork = (struct wlan_network *)__mptr;
#line 724
  pnetwork->fixed = 0;
#line 725
  _rtw_free_network23a(pmlmepriv, pnetwork);
#line 722
  plist = ptemp;
#line 722
  ptemp = plist->next;
  ldv_55997: ;
#line 722
  if ((unsigned long )plist != (unsigned long )phead) {
#line 724
    goto ldv_55996;
  } else {

  }
#line 728
  spin_unlock_bh(& scan_queue->lock);
#line 729
  return;
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_free_assoc_resources23a(struct rtw_adapter *adapter , int lock_scanned_queue ) 
{ 
  struct wlan_network *pwlan ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct wlan_network *tgt_network ;
  struct sta_info *psta ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 738
  pmlmepriv = & adapter->mlmepriv;
#line 739
  pstapriv = & adapter->stapriv;
#line 740
  tgt_network = & pmlmepriv->cur_network;
#line 743
  if (GlobalDebugLevel23A > 5U) {
#line 743
    rt_trace(16, 6, "+rtw_free_assoc_resources23a\n");
  } else {

  }
#line 745
  if (GlobalDebugLevel23A > 6U) {
#line 745
    rt_trace(16, 7, "tgt_network->network.MacAddress=%pM ssid=%s\n", (u8 *)(& tgt_network->network.MacAddress),
             (u8 *)(& tgt_network->network.Ssid.ssid));
  } else {

  }
#line 750
  tmp = check_fwstate(pmlmepriv, 24);
#line 750
  if ((int )tmp) {
#line 751
    psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& tgt_network->network.MacAddress));
#line 754
    spin_lock_bh(& pstapriv->sta_hash_lock);
#line 755
    rtw_free_stainfo23a(adapter, psta);
#line 756
    spin_unlock_bh(& pstapriv->sta_hash_lock);
  } else {

  }
#line 759
  tmp___0 = check_fwstate(pmlmepriv, 112);
#line 759
  if ((int )tmp___0) {
#line 761
    rtw_free_all_stainfo23a(adapter);
#line 763
    psta = rtw_get_bcmc_stainfo23a(adapter);
#line 764
    spin_lock_bh(& pstapriv->sta_hash_lock);
#line 765
    rtw_free_stainfo23a(adapter, psta);
#line 766
    spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 768
    rtw_init_bcmc_stainfo23a(adapter);
  } else {

  }
#line 771
  if (lock_scanned_queue != 0) {
#line 772
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
  } else {

  }
#line 774
  pwlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& tgt_network->network.MacAddress));
#line 776
  if ((unsigned long )pwlan != (unsigned long )((struct wlan_network *)0)) {
#line 777
    pwlan->fixed = 0;
  } else
#line 779
  if (GlobalDebugLevel23A > 3U) {
#line 779
    rt_trace(16, 4, "rtw_free_assoc_resources23a : pwlan== NULL\n");
  } else {

  }
#line 782
  tmp___1 = check_fwstate(pmlmepriv, 64);
#line 782
  if ((int )tmp___1 && adapter->stapriv.asoc_sta_count == 1) {
#line 784
    rtw_free_network_nolock(pmlmepriv, pwlan);
  } else {

  }
#line 786
  if (lock_scanned_queue != 0) {
#line 787
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  } else {

  }
#line 789
  pmlmepriv->key_mask = 0U;
#line 790
  return;
}
}
#line 795 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_indicate_connect23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct pid *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 797
  pmlmepriv = & padapter->mlmepriv;
#line 799
  if (GlobalDebugLevel23A > 3U) {
#line 799
    rt_trace(16, 4, "+rtw_indicate_connect23a\n");
  } else {

  }
#line 802
  pmlmepriv->to_join = 0U;
#line 804
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
#line 804
  if (tmp___0) {
#line 804
    tmp___1 = 0;
  } else {
#line 804
    tmp___1 = 1;
  }
#line 804
  if (tmp___1) {
#line 805
    set_fwstate(pmlmepriv, 1);
#line 807
    rtw_cfg80211_indicate_connect(padapter);
#line 809
    netif_carrier_on(padapter->pnetdev);
#line 811
    if (padapter->pid[2] != 0) {
#line 812
      tmp = find_vpid(padapter->pid[2]);
#line 812
      kill_pid(tmp, 14, 1);
    } else {

    }
  } else {

  }
#line 815
  rtw_set_roaming(padapter, 0);
#line 817
  rtw_set_scan_deny(padapter, 3000U);
#line 819
  if (GlobalDebugLevel23A > 3U) {
#line 819
    tmp___2 = get_fwstate(pmlmepriv);
#line 819
    rt_trace(16, 4, "-rtw_indicate_connect23a: fw_state=0x%08x\n", tmp___2);
  } else {

  }
#line 820
  return;
}
}
#line 827 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_indicate_disconnect23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  unsigned long tmp ;
  bool tmp___0 ;

  {
#line 829
  pmlmepriv = & padapter->mlmepriv;
#line 831
  if (GlobalDebugLevel23A > 3U) {
#line 831
    rt_trace(16, 4, "+rtw_indicate_disconnect23a\n");
  } else {

  }
#line 834
  _clr_fwstate_(pmlmepriv, 384);
#line 838
  if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
#line 839
    _clr_fwstate_(pmlmepriv, 1);
  } else {

  }
#line 841
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
#line 841
  if ((int )tmp___0 || (unsigned int )padapter->mlmepriv.to_roaming == 0U) {
#line 843
    rtw_os_indicate_disconnect23a(padapter);
#line 846
    tmp = msecs_to_jiffies(3000U);
#line 846
    padapter->pwrctrlpriv.ips_deny_time = tmp + (unsigned long )jiffies;
#line 849
    _clr_fwstate_(pmlmepriv, 1);
#line 851
    rtw_clear_scan_deny(padapter);
  } else {

  }
#line 854
  rtw_lps_ctrl_wk_cmd23a(padapter, 3, 1);
#line 855
  return;
}
}
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_scan_abort23a(struct rtw_adapter *adapter ) 
{ 
  unsigned long start ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  bool tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  bool tmp___2 ;

  {
#line 860
  pmlmepriv = & adapter->mlmepriv;
#line 861
  pmlmeext = & adapter->mlmeextpriv;
#line 863
  start = jiffies;
#line 864
  pmlmeext->scan_abort = 1U;
#line 865
  goto ldv_56025;
  ldv_56024: ;
#line 867
  if (adapter->bDriverStopped != 0 || adapter->bSurpriseRemoved != 0) {
#line 868
    goto ldv_56022;
  } else {

  }
#line 870
  if (GlobalDebugLevel23A > 3U) {
#line 870
    printk("\016RTL8723AU: %s(%s): fw_state = _FW_UNDER_SURVEY!\n", "rtw_scan_abort23a",
           (char *)(& (adapter->pnetdev)->name));
  } else {

  }
#line 872
  msleep(20U);
  ldv_56025: 
#line 865
  tmp = check_fwstate(pmlmepriv, 2048);
#line 865
  if ((int )tmp) {
#line 865
    tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 865
    if (tmp___0 <= 200U) {
#line 868
      goto ldv_56024;
    } else {
#line 871
      goto ldv_56022;
    }
  } else {

  }
  ldv_56022: 
#line 875
  tmp___2 = check_fwstate(pmlmepriv, 2048);
#line 875
  if ((int )tmp___2) {
#line 876
    if (adapter->bDriverStopped == 0 && adapter->bSurpriseRemoved == 0) {
#line 877
      if (GlobalDebugLevel23A > 3U) {
#line 877
        printk("\016RTL8723AU: %s(%s): waiting for scan_abort time out!\n", "rtw_scan_abort23a",
               (char *)(& (adapter->pnetdev)->name));
      } else {

      }
    } else {

    }
#line 879
    tmp___1 = wdev_priv(adapter->rtw_wdev);
#line 879
    rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___1, 1);
  } else {

  }
#line 882
  pmlmeext->scan_abort = 0U;
#line 883
  return;
}
}
#line 886 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static struct sta_info *rtw_joinbss_update_stainfo(struct rtw_adapter *padapter ,
                                                   struct wlan_network *pnetwork ) 
{ 
  int i ;
  struct sta_info *bmc_sta ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct sta_priv *pstapriv ;

  {
#line 892
  pstapriv = & padapter->stapriv;
#line 894
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pnetwork->network.MacAddress));
#line 895
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 896
    psta = rtw_alloc_stainfo23a(pstapriv, (u8 const   *)(& pnetwork->network.MacAddress),
                                32U);
  } else {

  }
#line 900
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 901
    if (GlobalDebugLevel23A > 3U) {
#line 901
      printk("\016RTL8723AU: %s\n", "rtw_joinbss_update_stainfo");
    } else {

    }
#line 903
    psta->aid = (uint )pnetwork->join_res;
#line 904
    psta->mac_id = 0U;
#line 907
    rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 1);
#line 910
    if (padapter->securitypriv.dot11AuthAlgrthm == 2U) {
#line 912
      padapter->securitypriv.binstallGrpkey = 0U;
#line 913
      padapter->securitypriv.busetkipkey = 0U;
#line 915
      psta->ieee8021x_blocked = 1U;
#line 916
      psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
#line 919
      memset((void *)(& psta->dot118021x_UncstKey), 0, 16UL);
#line 922
      memset((void *)(& psta->dot11tkiprxmickey), 0, 16UL);
#line 924
      memset((void *)(& psta->dot11tkiptxmickey), 0, 16UL);
#line 927
      memset((void *)(& psta->dot11txpn), 0, 8UL);
#line 928
      memset((void *)(& psta->dot11rxpn), 0, 8UL);
    } else {

    }
#line 935
    if (padapter->securitypriv.wps_ie_len != 0) {
#line 936
      psta->ieee8021x_blocked = 1U;
#line 937
      padapter->securitypriv.wps_ie_len = 0;
    } else {

    }
#line 946
    i = 0;
#line 946
    goto ldv_56037;
    ldv_56036: 
#line 948
    preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
#line 949
    preorder_ctrl->enable = 0U;
#line 950
    preorder_ctrl->indicate_seq = 65535U;
#line 951
    preorder_ctrl->wend_b = 65535U;
#line 953
    preorder_ctrl->wsize_b = 64U;
#line 946
    i = i + 1;
    ldv_56037: ;
#line 946
    if (i <= 15) {
#line 948
      goto ldv_56036;
    } else {

    }
#line 956
    bmc_sta = rtw_get_bcmc_stainfo23a(padapter);
#line 957
    if ((unsigned long )bmc_sta != (unsigned long )((struct sta_info *)0)) {
#line 958
      i = 0;
#line 958
      goto ldv_56040;
      ldv_56039: 
#line 959
      preorder_ctrl = (struct recv_reorder_ctrl *)(& bmc_sta->recvreorder_ctrl) + (unsigned long )i;
#line 960
      preorder_ctrl->enable = 0U;
#line 961
      preorder_ctrl->indicate_seq = 65535U;
#line 962
      preorder_ctrl->wend_b = 65535U;
#line 965
      preorder_ctrl->wsize_b = 64U;
#line 958
      i = i + 1;
      ldv_56040: ;
#line 958
      if (i <= 15) {
#line 960
        goto ldv_56039;
      } else {

      }

    } else {

    }
#line 970
    update_sta_info23a(padapter, psta);
  } else {

  }
#line 974
  return (psta);
}
}
#line 980 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static void rtw_joinbss_update_network23a(struct rtw_adapter *padapter , struct wlan_network *ptarget_wlan ,
                                          struct wlan_network *pnetwork ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 984
  pmlmepriv = & padapter->mlmepriv;
#line 985
  cur_network = & pmlmepriv->cur_network;
#line 987
  if (GlobalDebugLevel23A > 3U) {
#line 987
    printk("\016RTL8723AU: %s\n", "rtw_joinbss_update_network23a");
  } else {

  }
#line 989
  if (GlobalDebugLevel23A > 6U) {
#line 989
    tmp = get_fwstate(pmlmepriv);
#line 989
    rt_trace(16, 7, "fw_state:%x, BSSID:%pM\n", tmp, (u8 *)(& pnetwork->network.MacAddress));
  } else {

  }
#line 995
  memcpy((void *)(& cur_network->network), (void const   *)(& pnetwork->network),
           (size_t )pnetwork->network.Length);
#line 998
  cur_network->network.IELength = ptarget_wlan->network.IELength;
#line 999
  memcpy((void *)(& cur_network->network.IEs), (void const   *)(& ptarget_wlan->network.IEs),
           768UL);
#line 1002
  cur_network->network.capability = ptarget_wlan->network.capability;
#line 1003
  cur_network->network.beacon_interval = ptarget_wlan->network.beacon_interval;
#line 1005
  cur_network->network.tsf = ptarget_wlan->network.tsf;
#line 1007
  tmp___0 = msecs_to_jiffies(padapter->recvpriv.signal_stat_sampling_interval);
#line 1007
  ldv_mod_timer_70(& padapter->recvpriv.signal_stat_timer, tmp___0 + (unsigned long )jiffies);
#line 1008
  padapter->recvpriv.signal_strength = ptarget_wlan->network.SignalStrength;
#line 1010
  padapter->recvpriv.signal_qual = ptarget_wlan->network.SignalQuality;
#line 1015
  if (GlobalDebugLevel23A > 3U) {
#line 1015
    printk("\016RTL8723AU: %s signal_strength:%3u, signal_qual:%3u\n", "rtw_joinbss_update_network23a",
           (int )padapter->recvpriv.signal_strength, (int )padapter->recvpriv.signal_qual);
  } else {

  }
#line 1018
  tmp___1 = msecs_to_jiffies(padapter->recvpriv.signal_stat_sampling_interval);
#line 1018
  ldv_mod_timer_71(& padapter->recvpriv.signal_stat_timer, tmp___1 + (unsigned long )jiffies);
#line 1021
  switch ((unsigned int )pnetwork->network.ifmode) {
  case 8U: ;
  case 2U: ;
#line 1024
  if ((pmlmepriv->fw_state & 256) != 0) {
#line 1025
    pmlmepriv->fw_state = 264;
  } else {
#line 1027
    pmlmepriv->fw_state = 8;
  }
#line 1028
  goto ldv_56052;
  case 1U: 
#line 1030
  pmlmepriv->fw_state = 32;
#line 1031
  goto ldv_56052;
  default: 
#line 1033
  pmlmepriv->fw_state = 0;
#line 1034
  if (GlobalDebugLevel23A > 3U) {
#line 1034
    rt_trace(16, 4, "Invalid network_mode\n");
  } else {

  }
#line 1036
  goto ldv_56052;
  }
  ldv_56052: 
#line 1039
  rtw_update_protection23a(padapter, (u8 *)(& cur_network->network.IEs), cur_network->network.IELength);
#line 1042
  rtw_update_ht_cap23a(padapter, (u8 *)(& cur_network->network.IEs), cur_network->network.IELength);
#line 1044
  return;
}
}
#line 1059 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_joinbss_event_prehandle23a(struct rtw_adapter *adapter , u8 *pbuf ) 
{ 
  struct sta_info *ptarget_sta ;
  struct sta_info *pcur_sta ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  struct wlan_network *cur_network ;
  struct wlan_network *pcur_wlan ;
  struct wlan_network *ptarget_wlan ;
  bool the_same_macaddr ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  unsigned long tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  unsigned long tmp___11 ;

  {
#line 1062
  pstapriv = & adapter->stapriv;
#line 1063
  pmlmepriv = & adapter->mlmepriv;
#line 1064
  pnetwork = (struct wlan_network *)pbuf;
#line 1065
  cur_network = & pmlmepriv->cur_network;
#line 1066
  ptarget_wlan = (struct wlan_network *)0;
#line 1069
  if (GlobalDebugLevel23A > 6U) {
#line 1069
    rt_trace(16, 7, "joinbss event call back received with res=%d\n", pnetwork->join_res);
  } else {

  }
#line 1073
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len == 0U) {
#line 1074
    if (GlobalDebugLevel23A > 3U) {
#line 1074
      rt_trace(16, 4, "@@@@@   joinbss event call back  for Any SSid\n");
    } else {

    }
  } else
#line 1077
  if (GlobalDebugLevel23A > 3U) {
#line 1077
    rt_trace(16, 4, "@@@@@   rtw23a_joinbss_event_cb for SSid:%s\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
  } else {

  }
#line 1082
  tmp = ether_addr_equal((u8 const   *)(& pnetwork->network.MacAddress), (u8 const   *)(& cur_network->network.MacAddress));
#line 1082
  if ((int )tmp) {
#line 1084
    the_same_macaddr = 1;
  } else {
#line 1086
    the_same_macaddr = 0;
  }
#line 1088
  pnetwork->network.Length = get_wlan_bssid_ex_sz(& pnetwork->network);
#line 1089
  if (pnetwork->network.Length > 871U) {
#line 1090
    if (GlobalDebugLevel23A > 3U) {
#line 1090
      rt_trace(16, 4, "***joinbss_evt_callback return a wrong bss ***\n");
    } else {

    }
#line 1092
    return;
  } else {

  }
#line 1095
  spin_lock_bh(& pmlmepriv->lock);
#line 1097
  if (GlobalDebugLevel23A > 6U) {
#line 1097
    rt_trace(16, 7, "rtw23a_joinbss_event_cb !! _enter_critical\n");
  } else {

  }
#line 1100
  if (pnetwork->join_res > 0) {
#line 1101
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 1102
    tmp___7 = check_fwstate(pmlmepriv, 128);
#line 1102
    if ((int )tmp___7) {
#line 1104
      tmp___2 = check_fwstate(pmlmepriv, 1);
#line 1104
      if ((int )tmp___2) {
#line 1105
        if ((int )the_same_macaddr) {
#line 1106
          ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& cur_network->network.MacAddress));
        } else {
#line 1108
          pcur_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& cur_network->network.MacAddress));
#line 1109
          if ((unsigned long )pcur_wlan != (unsigned long )((struct wlan_network *)0)) {
#line 1110
            pcur_wlan->fixed = 0;
          } else {

          }
#line 1112
          pcur_sta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->network.MacAddress));
#line 1113
          if ((unsigned long )pcur_sta != (unsigned long )((struct sta_info *)0)) {
#line 1114
            spin_lock_bh(& pstapriv->sta_hash_lock);
#line 1115
            rtw_free_stainfo23a(adapter, pcur_sta);
#line 1117
            spin_unlock_bh(& pstapriv->sta_hash_lock);
          } else {

          }
#line 1120
          ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& pnetwork->network.MacAddress));
#line 1121
          tmp___0 = check_fwstate(pmlmepriv, 8);
#line 1121
          if ((int )tmp___0) {
#line 1123
            if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
#line 1124
              ptarget_wlan->fixed = 1;
            } else {

            }
          } else {

          }
        }
      } else {
#line 1130
        ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& pnetwork->network.MacAddress));
#line 1133
        tmp___1 = check_fwstate(pmlmepriv, 8);
#line 1133
        if ((int )tmp___1) {
#line 1135
          if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
#line 1136
            ptarget_wlan->fixed = 1;
          } else {

          }
        } else {

        }
      }
#line 1141
      if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
#line 1142
        rtw_joinbss_update_network23a(adapter, ptarget_wlan, pnetwork);
      } else {
#line 1146
        if (GlobalDebugLevel23A > 3U) {
#line 1146
          rt_trace(16, 4, "Can\'t find ptarget_wlan when joinbss_event callback\n");
        } else {

        }
#line 1148
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1149
        goto ignore_joinbss_callback;
      }
#line 1154
      tmp___3 = check_fwstate(pmlmepriv, 8);
#line 1154
      if ((int )tmp___3) {
#line 1155
        ptarget_sta = rtw_joinbss_update_stainfo(adapter, pnetwork);
#line 1157
        if ((unsigned long )ptarget_sta == (unsigned long )((struct sta_info *)0)) {
#line 1158
          if (GlobalDebugLevel23A > 3U) {
#line 1158
            rt_trace(16, 4, "Can\'t update stainfo when joinbss_event callback\n");
          } else {

          }
#line 1161
          spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1162
          goto ignore_joinbss_callback;
        } else {

        }
      } else {

      }
#line 1167
      tmp___5 = check_fwstate(pmlmepriv, 8);
#line 1167
      if ((int )tmp___5) {
#line 1168
        rtw_indicate_connect23a(adapter);
      } else
#line 1172
      if (GlobalDebugLevel23A > 6U) {
#line 1172
        tmp___4 = get_fwstate(pmlmepriv);
#line 1172
        rt_trace(16, 7, "adhoc mode, fw_state:%x\n", tmp___4);
      } else {

      }
#line 1178
      ldv_del_timer_sync_72(& pmlmepriv->assoc_timer);
#line 1180
      if (GlobalDebugLevel23A > 6U) {
#line 1180
        rt_trace(16, 7, "Cancle assoc_timer\n");
      } else {

      }
    } else {
#line 1183
      if (GlobalDebugLevel23A > 3U) {
#line 1183
        tmp___6 = get_fwstate(pmlmepriv);
#line 1183
        rt_trace(16, 4, "rtw23a_joinbss_event_cb err: fw_state:%x\n", tmp___6);
      } else {

      }
#line 1186
      spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1187
      goto ignore_joinbss_callback;
    }
#line 1189
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  } else
#line 1190
  if (pnetwork->join_res == -4) {
#line 1191
    rtw_reset_securitypriv23a(adapter);
#line 1192
    tmp___8 = msecs_to_jiffies(1U);
#line 1192
    ldv_mod_timer_73(& pmlmepriv->assoc_timer, tmp___8 + (unsigned long )jiffies);
#line 1197
    tmp___10 = check_fwstate(pmlmepriv, 128);
#line 1197
    if ((int )tmp___10) {
#line 1198
      if (GlobalDebugLevel23A > 3U) {
#line 1198
        tmp___9 = get_fwstate(pmlmepriv);
#line 1198
        rt_trace(16, 4, "fail! clear _FW_UNDER_LINKING ^^^fw_state=%x\n", tmp___9);
      } else {

      }
#line 1201
      _clr_fwstate_(pmlmepriv, 128);
    } else {

    }
  } else {
#line 1205
    tmp___11 = msecs_to_jiffies(1U);
#line 1205
    ldv_mod_timer_74(& pmlmepriv->assoc_timer, tmp___11 + (unsigned long )jiffies);
#line 1207
    _clr_fwstate_(pmlmepriv, 128);
  }
  ignore_joinbss_callback: 
#line 1212
  spin_unlock_bh(& pmlmepriv->lock);
#line 1213
  return;
}
}
#line 1215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw23a_joinbss_event_cb(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  struct wlan_network *pnetwork ;

  {
#line 1217
  pnetwork = (struct wlan_network *)pbuf;
#line 1219
  mlmeext_joinbss_event_callback23a(adapter, pnetwork->join_res);
#line 1221
  rtw_os_xmit_schedule23a(adapter);
#line 1222
  return;
}
}
#line 1224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_stassoc_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  struct sta_info *psta ;
  struct mlme_priv *pmlmepriv ;
  struct stassoc_event *pstassoc ;
  struct wlan_network *cur_network ;
  struct wlan_network *ptarget_wlan ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
#line 1227
  pmlmepriv = & adapter->mlmepriv;
#line 1228
  pstassoc = (struct stassoc_event *)pbuf;
#line 1229
  cur_network = & pmlmepriv->cur_network;
#line 1232
  tmp = rtw_access_ctrl23a(adapter, (u8 *)(& pstassoc->macaddr));
#line 1232
  if (tmp) {
#line 1232
    tmp___0 = 0;
  } else {
#line 1232
    tmp___0 = 1;
  }
#line 1232
  if (tmp___0) {
#line 1233
    return;
  } else {

  }
#line 1236
  tmp___1 = check_fwstate(pmlmepriv, 16);
#line 1236
  if ((int )tmp___1) {
#line 1237
    psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& pstassoc->macaddr));
#line 1238
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1241
      ap_sta_info_defer_update23a(adapter, psta);
    } else {

    }
#line 1243
    return;
  } else {

  }
#line 1247
  psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& pstassoc->macaddr));
#line 1248
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1250
    if (GlobalDebugLevel23A > 3U) {
#line 1250
      rt_trace(16, 4, "Error: rtw_stassoc_event_callback23a: sta has been in sta_hash_queue\n");
    } else {

    }
#line 1254
    return;
  } else {

  }
#line 1257
  psta = rtw_alloc_stainfo23a(& adapter->stapriv, (u8 const   *)(& pstassoc->macaddr),
                              208U);
#line 1259
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1260
    if (GlobalDebugLevel23A > 3U) {
#line 1260
      rt_trace(16, 4, "Can\'t alloc sta_info when rtw_stassoc_event_callback23a\n");
    } else {

    }
#line 1262
    return;
  } else {

  }
#line 1266
  psta->qos_option = 0U;
#line 1267
  psta->mac_id = (unsigned int )pstassoc->cam_id;
#line 1269
  if (GlobalDebugLevel23A > 3U) {
#line 1269
    printk("\016RTL8723AU: %s\n", "rtw_stassoc_event_callback23a");
  } else {

  }
#line 1271
  rtl8723a_SetHalODMVar(adapter, 0, (void *)psta, 1);
#line 1273
  if (adapter->securitypriv.dot11AuthAlgrthm == 2U) {
#line 1274
    psta->dot118021XPrivacy = adapter->securitypriv.dot11PrivacyAlgrthm;
  } else {

  }
#line 1277
  psta->ieee8021x_blocked = 0U;
#line 1279
  spin_lock_bh(& pmlmepriv->lock);
#line 1281
  tmp___2 = check_fwstate(pmlmepriv, 64);
#line 1281
  if ((int )tmp___2) {
#line 1281
    goto _L;
  } else {
#line 1281
    tmp___3 = check_fwstate(pmlmepriv, 32);
#line 1281
    if ((int )tmp___3) {
      _L: /* CIL Label */ 
#line 1283
      if (adapter->stapriv.asoc_sta_count == 2) {
#line 1284
        spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 1285
        ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& cur_network->network.MacAddress));
#line 1288
        if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
#line 1289
          ptarget_wlan->fixed = 1;
        } else {

        }
#line 1290
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1292
        rtw_indicate_connect23a(adapter);
      } else {

      }
    } else {

    }
  }
#line 1296
  spin_unlock_bh(& pmlmepriv->lock);
#line 1298
  mlmeext_sta_add_event_callback23a(adapter, psta);
#line 1299
  return;
}
}
#line 1301 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_stadel_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  int mac_id ;
  struct sta_info *psta ;
  struct wlan_network *pwlan ;
  struct wlan_bssid_ex *pdev_network ;
  struct mlme_priv *pmlmepriv ;
  struct stadel_event *pstadel ;
  struct sta_priv *pstapriv ;
  struct wlan_network *tgt_network ;
  bool tmp ;
  bool tmp___0 ;
  uint tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
#line 1307
  pmlmepriv = & adapter->mlmepriv;
#line 1308
  pstadel = (struct stadel_event *)pbuf;
#line 1309
  pstapriv = & adapter->stapriv;
#line 1310
  tgt_network = & pmlmepriv->cur_network;
#line 1312
  psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& pstadel->macaddr));
#line 1313
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1314
    mac_id = (int )psta->mac_id;
  } else {
#line 1316
    mac_id = pstadel->mac_id;
  }
#line 1318
  if (GlobalDebugLevel23A > 3U) {
#line 1318
    printk("\016RTL8723AU: %s(mac_id=%d)=%pM\n", "rtw_stadel_event_callback23a", mac_id,
           (unsigned char *)(& pstadel->macaddr));
  } else {

  }
#line 1320
  tmp = check_fwstate(pmlmepriv, 16);
#line 1320
  if ((int )tmp) {
#line 1321
    return;
  } else {

  }
#line 1323
  mlmeext_sta_del_event_callback23a(adapter);
#line 1325
  spin_lock_bh(& pmlmepriv->lock);
#line 1327
  tmp___0 = check_fwstate(pmlmepriv, 8);
#line 1327
  if ((int )tmp___0) {
#line 1328
    if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
#line 1331
      pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
    } else
#line 1332
    if ((unsigned int )adapter->mlmepriv.to_roaming == 0U) {
#line 1333
      rtw_set_roaming(adapter, (int )adapter->registrypriv.max_roaming_times);
    } else {

    }
#line 1334
    if ((unsigned int )*((u16 *)(& pstadel->rsvd)) != 65535U) {
#line 1335
      rtw_set_roaming(adapter, 0);
    } else {

    }
#line 1337
    rtw_free_uc_swdec_pending_queue23a(adapter);
#line 1339
    rtw_free_assoc_resources23a(adapter, 1);
#line 1340
    rtw_indicate_disconnect23a(adapter);
#line 1341
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 1343
    pwlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& tgt_network->network.MacAddress));
#line 1345
    if ((unsigned long )pwlan != (unsigned long )((struct wlan_network *)0)) {
#line 1346
      pwlan->fixed = 0;
#line 1347
      rtw_free_network_nolock(pmlmepriv, pwlan);
    } else {

    }
#line 1349
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1351
    _rtw_roaming(adapter, tgt_network);
  } else {

  }
#line 1354
  tmp___2 = check_fwstate(pmlmepriv, 64);
#line 1354
  if ((int )tmp___2) {
#line 1354
    goto _L;
  } else {
#line 1354
    tmp___3 = check_fwstate(pmlmepriv, 32);
#line 1354
    if ((int )tmp___3) {
      _L: /* CIL Label */ 
#line 1357
      spin_lock_bh(& pstapriv->sta_hash_lock);
#line 1358
      rtw_free_stainfo23a(adapter, psta);
#line 1359
      spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 1362
      if (adapter->stapriv.asoc_sta_count == 1) {
#line 1363
        spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 1367
        pwlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& tgt_network->network.MacAddress));
#line 1369
        if ((unsigned long )pwlan != (unsigned long )((struct wlan_network *)0)) {
#line 1370
          pwlan->fixed = 0;
#line 1371
          rtw_free_network_nolock(pmlmepriv, pwlan);
        } else {

        }
#line 1373
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1375
        pdev_network = & adapter->registrypriv.dev_network;
#line 1377
        tmp___1 = get_wlan_bssid_ex_sz(& tgt_network->network);
#line 1377
        memcpy((void *)pdev_network, (void const   *)(& tgt_network->network), (size_t )tmp___1);
#line 1380
        rtw_do_join_adhoc(adapter);
      } else {

      }
    } else {

    }
  }
#line 1384
  spin_unlock_bh(& pmlmepriv->lock);
#line 1385
  return;
}
}
#line 1391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw23a_join_to_handler(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;
  struct mlme_priv *pmlmepriv ;
  int do_join_r ;
  int tmp ;

  {
#line 1393
  adapter = (struct rtw_adapter *)data;
#line 1394
  pmlmepriv = & adapter->mlmepriv;
#line 1397
  if (GlobalDebugLevel23A > 3U) {
#line 1397
    tmp = get_fwstate(pmlmepriv);
#line 1397
    printk("\016RTL8723AU: %s, fw_state=%x\n", "rtw23a_join_to_handler", tmp);
  } else {

  }
#line 1399
  if (adapter->bDriverStopped != 0 || adapter->bSurpriseRemoved != 0) {
#line 1400
    return;
  } else {

  }
#line 1402
  spin_lock_bh(& pmlmepriv->lock);
#line 1404
  if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
    ldv_56106: 
#line 1407
    pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
#line 1408
    if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
#line 1410
      if (GlobalDebugLevel23A > 3U) {
#line 1410
        printk("\016RTL8723AU: %s try another roaming\n", "rtw23a_join_to_handler");
      } else {

      }
#line 1411
      do_join_r = rtw_do_join(adapter);
#line 1412
      if (do_join_r != 1) {
#line 1413
        if (GlobalDebugLevel23A > 3U) {
#line 1413
          printk("\016RTL8723AU: %s roaming do_join return %d\n", "rtw23a_join_to_handler",
                 do_join_r);
        } else {

        }
#line 1415
        goto ldv_56104;
      } else {

      }
#line 1417
      goto ldv_56105;
    } else {
#line 1419
      if (GlobalDebugLevel23A > 3U) {
#line 1419
        printk("\016RTL8723AU: %s We\'ve try roaming but fail\n", "rtw23a_join_to_handler");
      } else {

      }
#line 1421
      rtw_indicate_disconnect23a(adapter);
#line 1422
      goto ldv_56105;
    }
    ldv_56104: ;
#line 1424
    goto ldv_56106;
    ldv_56105: ;
  } else {
#line 1426
    rtw_indicate_disconnect23a(adapter);
#line 1427
    free_scanqueue(pmlmepriv);
#line 1431
    rtw_cfg80211_indicate_disconnect(adapter);
  }
#line 1434
  spin_unlock_bh(& pmlmepriv->lock);
#line 1435
  return;
}
}
#line 1442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_scan_timeout_handler23a(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;
  struct mlme_priv *pmlmepriv ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1444
  adapter = (struct rtw_adapter *)data;
#line 1445
  pmlmepriv = & adapter->mlmepriv;
#line 1447
  if (GlobalDebugLevel23A > 3U) {
#line 1447
    tmp = get_fwstate(pmlmepriv);
#line 1447
    printk("\016RTL8723AU: %s(%s): fw_state =%x\n", "rtw_scan_timeout_handler23a",
           (char *)(& (adapter->pnetdev)->name), tmp);
  } else {

  }
#line 1450
  spin_lock_bh(& pmlmepriv->lock);
#line 1452
  _clr_fwstate_(pmlmepriv, 2048);
#line 1454
  spin_unlock_bh(& pmlmepriv->lock);
#line 1456
  tmp___0 = wdev_priv(adapter->rtw_wdev);
#line 1456
  rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___0, 1);
#line 1457
  return;
}
}
#line 1459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_dynamic_check_timer_handler(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;
  unsigned long tmp ;

  {
#line 1461
  adapter = (struct rtw_adapter *)data;
#line 1463
  if ((unsigned int )adapter->hw_init_completed == 0U) {
#line 1464
    goto out;
  } else {

  }
#line 1466
  if (adapter->bDriverStopped == 1 || adapter->bSurpriseRemoved == 1) {
#line 1468
    goto out;
  } else {

  }
#line 1470
  if (adapter->net_closed == 1) {
#line 1471
    goto out;
  } else {

  }
#line 1473
  rtw_dynamic_chk_wk_cmd23a(adapter);
  out: 
#line 1476
  tmp = msecs_to_jiffies(2000U);
#line 1476
  ldv_mod_timer_75(& adapter->mlmepriv.dynamic_chk_timer, tmp + (unsigned long )jiffies);
#line 1478
  return;
}
}
#line 1487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_clear_scan_deny(struct rtw_adapter *adapter ) 
{ 
  struct mlme_priv *mlmepriv ;

  {
#line 1489
  mlmepriv = & adapter->mlmepriv;
#line 1491
  atomic_set(& mlmepriv->set_scan_deny, 0);
#line 1492
  return;
}
}
#line 1494 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_set_scan_deny_timer_hdl(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;

  {
#line 1496
  adapter = (struct rtw_adapter *)data;
#line 1498
  rtw_clear_scan_deny(adapter);
#line 1499
  return;
}
}
#line 1501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_set_scan_deny(struct rtw_adapter *adapter , u32 ms ) 
{ 
  struct mlme_priv *mlmepriv ;
  unsigned long tmp ;

  {
#line 1503
  mlmepriv = & adapter->mlmepriv;
#line 1505
  atomic_set(& mlmepriv->set_scan_deny, 1);
#line 1506
  tmp = msecs_to_jiffies(ms);
#line 1506
  ldv_mod_timer_76(& mlmepriv->set_scan_deny_timer, tmp + (unsigned long )jiffies);
#line 1508
  return;
}
}
#line 1523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static int rtw_check_join_candidate(struct mlme_priv *pmlmepriv , struct wlan_network **candidate ,
                                    struct wlan_network *competitor ) 
{ 
  int updated ;
  struct rtw_adapter *adapter ;
  struct mlme_priv  const  *__mptr ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int passed ;
  int tmp___3 ;

  {
#line 1527
  updated = 0;
#line 1530
  __mptr = (struct mlme_priv  const  *)pmlmepriv;
#line 1530
  adapter = (struct rtw_adapter *)__mptr + 0xffffffffffffffe0UL;
#line 1533
  if (pmlmepriv->assoc_by_bssid == 1U) {
#line 1534
    tmp = ether_addr_equal((u8 const   *)(& competitor->network.MacAddress), (u8 const   *)(& pmlmepriv->assoc_bssid));
#line 1534
    if (tmp) {
#line 1534
      tmp___0 = 0;
    } else {
#line 1534
      tmp___0 = 1;
    }
#line 1534
    if (tmp___0) {
#line 1536
      goto exit;
    } else {

    }
  } else {

  }
#line 1540
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len != 0U) {
#line 1541
    if ((int )competitor->network.Ssid.ssid_len != (int )pmlmepriv->assoc_ssid.ssid_len) {
#line 1546
      goto exit;
    } else {
#line 1541
      tmp___1 = memcmp((void const   *)(& competitor->network.Ssid.ssid), (void const   *)(& pmlmepriv->assoc_ssid.ssid),
                       (size_t )pmlmepriv->assoc_ssid.ssid_len);
#line 1541
      if (tmp___1 != 0) {
#line 1546
        goto exit;
      } else {

      }
    }
  } else {

  }
#line 1549
  tmp___2 = rtw_is_desired_network(adapter, competitor);
#line 1549
  if (tmp___2 == 0) {
#line 1550
    goto exit;
  } else {

  }
#line 1552
  if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
#line 1555
    passed = jiffies_to_msecs((unsigned long )jiffies - competitor->last_scanned);
#line 1556
    if (passed > 1999U) {
#line 1559
      goto exit;
    } else {
#line 1556
      tmp___3 = is_same_ess(& competitor->network, & pmlmepriv->cur_network.network);
#line 1556
      if (tmp___3 == 0) {
#line 1559
        goto exit;
      } else {

      }
    }
  } else {

  }
#line 1562
  if ((unsigned long )*candidate == (unsigned long )((struct wlan_network *)0) || (*candidate)->network.Rssi < competitor->network.Rssi) {
#line 1564
    *candidate = competitor;
#line 1565
    updated = 1;
  } else {

  }
#line 1568
  if (updated != 0) {
#line 1569
    if (GlobalDebugLevel23A > 3U) {
#line 1569
      printk("\016RTL8723AU: [by_bssid:%u][assoc_ssid:%s][to_roaming:%u] new candidate: %s(%pM) rssi:%d\n",
             pmlmepriv->assoc_by_bssid, (u8 *)(& pmlmepriv->assoc_ssid.ssid), (int )adapter->mlmepriv.to_roaming,
             (u8 *)(& (*candidate)->network.Ssid.ssid), (u8 *)(& (*candidate)->network.MacAddress),
             (int )(*candidate)->network.Rssi);
    } else {

    }
  } else {

  }
  exit: ;
#line 1579
  return (updated);
}
}
#line 1592 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static int rtw_do_join(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  int ret ;
  bool tmp ;

  {
#line 1594
  pmlmepriv = & padapter->mlmepriv;
#line 1597
  pmlmepriv->cur_network.join_res = -2;
#line 1599
  set_fwstate(pmlmepriv, 128);
#line 1601
  pmlmepriv->to_join = 1U;
#line 1603
  ret = rtw_select_and_join_from_scanned_queue23a(pmlmepriv);
#line 1604
  if (ret == 1) {
#line 1605
    pmlmepriv->to_join = 0U;
  } else {
#line 1607
    tmp = check_fwstate(pmlmepriv, 32);
#line 1607
    if ((int )tmp) {
#line 1609
      ret = rtw_do_join_adhoc(padapter);
#line 1610
      if (ret != 1) {
#line 1611
        goto exit;
      } else {

      }
    } else {
#line 1614
      _clr_fwstate_(pmlmepriv, 128);
#line 1616
      ret = 0;
#line 1617
      pmlmepriv->to_join = 0U;
    }
  }
  exit: ;
#line 1622
  return (ret);
}
}
#line 1626 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static struct wlan_network *rtw_select_candidate_from_queue(struct mlme_priv *pmlmepriv ) 
{ 
  struct wlan_network *pnetwork ;
  struct wlan_network *candidate ;
  struct rtw_queue *queue ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct list_head  const  *__mptr ;

  {
#line 1628
  candidate = (struct wlan_network *)0;
#line 1629
  queue = & pmlmepriv->scanned_queue;
#line 1632
  spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 1633
  phead = get_list_head(queue);
#line 1635
  plist = phead->next;
#line 1635
  ptmp = plist->next;
#line 1635
  goto ldv_56166;
  ldv_56165: 
#line 1636
  __mptr = (struct list_head  const  *)plist;
#line 1636
  pnetwork = (struct wlan_network *)__mptr;
#line 1637
  if ((unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
#line 1638
    if (GlobalDebugLevel23A > 3U) {
#line 1638
      rt_trace(16, 4, "%s: return _FAIL:(pnetwork == NULL)\n", "rtw_select_candidate_from_queue");
    } else {

    }
#line 1641
    goto exit;
  } else {

  }
#line 1644
  rtw_check_join_candidate(pmlmepriv, & candidate, pnetwork);
#line 1635
  plist = ptmp;
#line 1635
  ptmp = plist->next;
  ldv_56166: ;
#line 1635
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1637
    goto ldv_56165;
  } else {

  }

  exit: 
#line 1648
  spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1649
  return (candidate);
}
}
#line 1653 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
int rtw_do_join_adhoc(struct rtw_adapter *adapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pdev_network ;
  u8 *ibss ;
  int ret ;

  {
#line 1655
  pmlmepriv = & adapter->mlmepriv;
#line 1660
  pdev_network = & adapter->registrypriv.dev_network;
#line 1661
  ibss = (u8 *)(& adapter->registrypriv.dev_network.MacAddress);
#line 1663
  _clr_fwstate_(pmlmepriv, 2048);
#line 1665
  if (GlobalDebugLevel23A > 3U) {
#line 1665
    rt_trace(16, 4, "switching to adhoc master\n");
  } else {

  }
#line 1668
  memcpy((void *)(& pdev_network->Ssid), (void const   *)(& pmlmepriv->assoc_ssid),
           33UL);
#line 1671
  rtw_update_registrypriv_dev_network23a(adapter);
#line 1672
  rtw_generate_random_ibss23a(ibss);
#line 1674
  pmlmepriv->fw_state = 64;
#line 1676
  ret = rtw_createbss_cmd23a(adapter);
#line 1677
  if (ret != 1) {
#line 1678
    if (GlobalDebugLevel23A > 3U) {
#line 1678
      rt_trace(16, 4, "Error =>rtw_createbss_cmd23a status FAIL\n");
    } else {

    }
  } else {
#line 1681
    pmlmepriv->to_join = 0U;
  }
#line 1684
  return (ret);
}
}
#line 1687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
int rtw_do_join_network(struct rtw_adapter *adapter , struct wlan_network *candidate ) 
{ 
  int ret ;
  bool tmp ;
  unsigned long tmp___0 ;

  {
#line 1693
  tmp = check_fwstate(& adapter->mlmepriv, 1);
#line 1693
  if ((int )tmp) {
#line 1694
    if (GlobalDebugLevel23A > 3U) {
#line 1694
      printk("\016RTL8723AU: %s: _FW_LINKED while ask_for_joinbss!\n", "rtw_do_join_network");
    } else {

    }
#line 1696
    rtw_disassoc_cmd23a(adapter, 0U, 1);
#line 1697
    rtw_indicate_disconnect23a(adapter);
#line 1698
    rtw_free_assoc_resources23a(adapter, 0);
  } else {

  }
#line 1700
  set_fwstate(& adapter->mlmepriv, 128);
#line 1702
  ret = rtw_joinbss_cmd23a(adapter, candidate);
#line 1704
  if (ret == 1) {
#line 1705
    tmp___0 = msecs_to_jiffies(6500U);
#line 1705
    ldv_mod_timer_77(& adapter->mlmepriv.assoc_timer, tmp___0 + (unsigned long )jiffies);
  } else {

  }
#line 1708
  return (ret);
}
}
#line 1711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
int rtw_select_and_join_from_scanned_queue23a(struct mlme_priv *pmlmepriv ) 
{ 
  struct rtw_adapter *adapter ;
  struct wlan_network *candidate ;
  int ret ;

  {
#line 1714
  candidate = (struct wlan_network *)0;
#line 1717
  adapter = pmlmepriv->nic_hdl;
#line 1719
  candidate = rtw_select_candidate_from_queue(pmlmepriv);
#line 1720
  if ((unsigned long )candidate == (unsigned long )((struct wlan_network *)0)) {
#line 1721
    if (GlobalDebugLevel23A > 3U) {
#line 1721
      printk("\016RTL8723AU: %s: return _FAIL(candidate == NULL)\n", "rtw_select_and_join_from_scanned_queue23a");
    } else {

    }
#line 1722
    ret = 0;
#line 1723
    goto exit;
  } else
#line 1725
  if (GlobalDebugLevel23A > 3U) {
#line 1725
    printk("\016RTL8723AU: %s: candidate: %s(%pM, ch:%u)\n", "rtw_select_and_join_from_scanned_queue23a",
           (u8 *)(& candidate->network.Ssid.ssid), (u8 *)(& candidate->network.MacAddress),
           candidate->network.DSConfig);
  } else {

  }
#line 1732
  ret = rtw_do_join_network(adapter, candidate);
  exit: ;
#line 1735
  return (ret);
}
}
#line 1738 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
int rtw_set_auth23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ) 
{ 
  struct cmd_obj *pcmd ;
  struct setauth_parm *psetauthparm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1743
  pcmdpriv = & adapter->cmdpriv;
#line 1744
  res = 1;
#line 1746
  tmp = kzalloc(128UL, 208U);
#line 1746
  pcmd = (struct cmd_obj *)tmp;
#line 1747
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
#line 1748
    res = 0;
#line 1749
    goto exit;
  } else {

  }
#line 1752
  tmp___0 = kzalloc(4UL, 208U);
#line 1752
  psetauthparm = (struct setauth_parm *)tmp___0;
#line 1753
  if ((unsigned long )psetauthparm == (unsigned long )((struct setauth_parm *)0)) {
#line 1754
    kfree((void const   *)pcmd);
#line 1755
    res = 0;
#line 1756
    goto exit;
  } else {

  }
#line 1759
  psetauthparm->mode = (unsigned char )psecuritypriv->dot11AuthAlgrthm;
#line 1761
  pcmd->cmdcode = 19U;
#line 1762
  pcmd->parmbuf = (u8 *)psetauthparm;
#line 1763
  pcmd->cmdsz = 4U;
#line 1764
  pcmd->rsp = (u8 *)0U;
#line 1765
  pcmd->rspsz = 0U;
#line 1767
  if (GlobalDebugLevel23A > 3U) {
#line 1767
    rt_trace(16, 4, "after enqueue set_auth_cmd, auth_mode=%x\n", psecuritypriv->dot11AuthAlgrthm);
  } else {

  }
#line 1771
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
#line 1775
  return (res);
}
}
#line 1778 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
int rtw_set_key23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ,
                   int keyid , u8 set_tx ) 
{ 
  u8 keylen ;
  struct cmd_obj *pcmd ;
  struct setkey_parm *psetkeyparm ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1784
  pcmdpriv = & adapter->cmdpriv;
#line 1785
  pmlmepriv = & adapter->mlmepriv;
#line 1786
  res = 1;
#line 1788
  if (keyid > 3) {
#line 1789
    res = 0;
#line 1790
    goto exit;
  } else {

  }
#line 1793
  tmp = kzalloc(128UL, 208U);
#line 1793
  pcmd = (struct cmd_obj *)tmp;
#line 1794
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
#line 1795
    res = 0;
#line 1796
    goto exit;
  } else {

  }
#line 1798
  tmp___0 = kzalloc(24UL, 208U);
#line 1798
  psetkeyparm = (struct setkey_parm *)tmp___0;
#line 1799
  if ((unsigned long )psetkeyparm == (unsigned long )((struct setkey_parm *)0)) {
#line 1800
    kfree((void const   *)pcmd);
#line 1801
    res = 0;
#line 1802
    goto exit;
  } else {

  }
#line 1805
  if (psecuritypriv->dot11AuthAlgrthm == 2U) {
#line 1806
    psetkeyparm->algorithm = (u32 )((unsigned char )psecuritypriv->dot118021XGrpPrivacy);
#line 1808
    if (GlobalDebugLevel23A > 3U) {
#line 1808
      rt_trace(16, 4, "rtw_set_key23a: psetkeyparm->algorithm = (unsigned char)psecuritypriv->dot118021XGrpPrivacy =%d\n",
               psetkeyparm->algorithm);
    } else {

    }
  } else {
#line 1812
    psetkeyparm->algorithm = (u32 )((unsigned char )psecuritypriv->dot11PrivacyAlgrthm);
#line 1813
    if (GlobalDebugLevel23A > 3U) {
#line 1813
      rt_trace(16, 4, "rtw_set_key23a: psetkeyparm->algorithm = (u8)psecuritypriv->dot11PrivacyAlgrthm =%d\n",
               psetkeyparm->algorithm);
    } else {

    }
  }
#line 1817
  psetkeyparm->keyid = (u8 )keyid;
#line 1818
  psetkeyparm->set_tx = set_tx;
#line 1819
  if (psetkeyparm->algorithm == 1027073U || psetkeyparm->algorithm == 1027077U) {
#line 1820
    pmlmepriv->key_mask = (int )pmlmepriv->key_mask | (int )((u8 )(1UL << (int )psetkeyparm->keyid));
  } else {

  }
#line 1822
  if (GlobalDebugLevel23A > 3U) {
#line 1822
    printk("\016RTL8723AU: ==> rtw_set_key23a algorithm(%x), keyid(%x), key_mask(%x)\n",
           psetkeyparm->algorithm, (int )psetkeyparm->keyid, (int )pmlmepriv->key_mask);
  } else {

  }
#line 1825
  if (GlobalDebugLevel23A > 3U) {
#line 1825
    rt_trace(16, 4, "rtw_set_key23a: psetkeyparm->algorithm =%d psetkeyparm->keyid = (u8)keyid =%d\n",
             psetkeyparm->algorithm, keyid);
  } else {

  }
#line 1829
  switch (psetkeyparm->algorithm) {
  case 1027073U: 
#line 1831
  keylen = 5U;
#line 1832
  memcpy((void *)(& psetkeyparm->key), (void const   *)(& psecuritypriv->wep_key[keyid].key),
           (size_t )keylen);
#line 1834
  goto ldv_56212;
  case 1027077U: 
#line 1836
  keylen = 13U;
#line 1837
  memcpy((void *)(& psetkeyparm->key), (void const   *)(& psecuritypriv->wep_key[keyid].key),
           (size_t )keylen);
#line 1839
  goto ldv_56212;
  case 1027074U: 
#line 1841
  keylen = 16U;
#line 1842
  memcpy((void *)(& psetkeyparm->key), (void const   *)(& psecuritypriv->dot118021XGrpKey) + (unsigned long )keyid,
           (size_t )keylen);
#line 1844
  psetkeyparm->grpkey = 1U;
#line 1845
  goto ldv_56212;
  case 1027076U: 
#line 1847
  keylen = 16U;
#line 1848
  memcpy((void *)(& psetkeyparm->key), (void const   *)(& psecuritypriv->dot118021XGrpKey) + (unsigned long )keyid,
           (size_t )keylen);
#line 1850
  psetkeyparm->grpkey = 1U;
#line 1851
  goto ldv_56212;
  default: ;
#line 1853
  if (GlobalDebugLevel23A > 3U) {
#line 1853
    rt_trace(16, 4, "rtw_set_key23a:psecuritypriv->dot11PrivacyAlgrthm = %x (must be 1 or 2 or 4 or 5)\n",
             psecuritypriv->dot11PrivacyAlgrthm);
  } else {

  }
#line 1856
  res = 0;
#line 1857
  kfree((void const   *)pcmd);
#line 1858
  kfree((void const   *)psetkeyparm);
#line 1859
  goto exit;
  }
  ldv_56212: 
#line 1862
  pcmd->cmdcode = 20U;
#line 1863
  pcmd->parmbuf = (u8 *)psetkeyparm;
#line 1864
  pcmd->cmdsz = 24U;
#line 1865
  pcmd->rsp = (u8 *)0U;
#line 1866
  pcmd->rspsz = 0U;
#line 1870
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
#line 1874
  return (res);
}
}
#line 1878 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
int rtw_restruct_wmm_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len , uint initial_out_len ) 
{ 
  int ielength ;
  u8 const   *p ;

  {
#line 1884
  ielength = (int )initial_out_len;
#line 1886
  p = cfg80211_find_vendor_ie(20722U, 2, (u8 const   *)in_ie, (int )in_len);
#line 1890
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 1891
    memcpy((void *)out_ie + (unsigned long )initial_out_len, (void const   *)p,
             9UL);
#line 1893
    *(out_ie + (unsigned long )(initial_out_len + 1U)) = 7U;
#line 1894
    *(out_ie + (unsigned long )(initial_out_len + 6U)) = 0U;
#line 1895
    *(out_ie + (unsigned long )(initial_out_len + 8U)) = 0U;
#line 1897
    ielength = ielength + 9;
  } else {

  }
#line 1900
  return (ielength);
}
}
#line 1915 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static int SecIsInPMKIDList(struct rtw_adapter *Adapter , u8 *bssid ) 
{ 
  struct security_priv *psecuritypriv ;
  int i ;
  bool tmp ;

  {
#line 1917
  psecuritypriv = & Adapter->securitypriv;
#line 1918
  i = 0;
  ldv_56233: ;
#line 1921
  if ((unsigned int )psecuritypriv->PMKIDList[i].bUsed != 0U) {
#line 1921
    tmp = ether_addr_equal((u8 const   *)(& psecuritypriv->PMKIDList[i].Bssid), (u8 const   *)bssid);
#line 1921
    if ((int )tmp) {
#line 1923
      goto ldv_56232;
    } else {
#line 1925
      i = i + 1;
    }
  } else {
#line 1925
    i = i + 1;
  }
#line 1928
  if (i <= 15) {
#line 1930
    goto ldv_56233;
  } else {

  }
  ldv_56232: ;
#line 1930
  if (i == 16) {
#line 1931
    i = -1;
  } else {

  }
#line 1937
  return (i);
}
}
#line 1949 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
static int rtw_append_pmkid(struct rtw_adapter *Adapter , int iEntry , u8 *ie , uint ie_len ) 
{ 
  struct security_priv *psecuritypriv ;

  {
#line 1952
  psecuritypriv = & Adapter->securitypriv;
#line 1954
  if ((unsigned int )*(ie + 1UL) <= 20U) {
#line 1957
    *(ie + (unsigned long )ie_len) = 1U;
#line 1958
    ie_len = ie_len + 1U;
#line 1959
    *(ie + (unsigned long )ie_len) = 0U;
#line 1960
    ie_len = ie_len + 1U;
#line 1961
    memcpy((void *)ie + (unsigned long )ie_len, (void const   *)(& psecuritypriv->PMKIDList[iEntry].PMKID),
             16UL);
#line 1964
    ie_len = ie_len + 16U;
#line 1965
    *(ie + 1UL) = (unsigned int )*(ie + 1UL) + 18U;
  } else {

  }
#line 1967
  return ((int )ie_len);
}
}
#line 1970 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
int rtw_restruct_sec_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len ) 
{ 
  u8 authmode ;
  uint ielength ;
  int iEntry ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  uint ndisauthmode ;
  uint ndissecuritytype ;
  bool tmp ;
  int tmp___0 ;

  {
#line 1976
  pmlmepriv = & adapter->mlmepriv;
#line 1977
  psecuritypriv = & adapter->securitypriv;
#line 1978
  ndisauthmode = psecuritypriv->ndisauthtype;
#line 1979
  ndissecuritytype = psecuritypriv->ndisencryptstatus;
#line 1981
  if (GlobalDebugLevel23A > 5U) {
#line 1981
    rt_trace(16, 6, "+rtw_restruct_sec_ie23a: ndisauthmode=%d ndissecuritytype=%d\n",
             ndisauthmode, ndissecuritytype);
  } else {

  }
#line 1985
  ielength = 0U;
#line 1986
  if (ndisauthmode == 3U || ndisauthmode == 4U) {
#line 1988
    authmode = 221U;
  } else {

  }
#line 1989
  if (ndisauthmode == 6U || ndisauthmode == 7U) {
#line 1991
    authmode = 48U;
  } else {

  }
#line 1993
  tmp = check_fwstate(pmlmepriv, 256);
#line 1993
  if ((int )tmp) {
#line 1994
    memcpy((void *)out_ie + (unsigned long )ielength, (void const   *)(& psecuritypriv->wps_ie),
             (size_t )psecuritypriv->wps_ie_len);
#line 1997
    ielength = (uint )psecuritypriv->wps_ie_len + ielength;
  } else
#line 1998
  if ((unsigned int )authmode == 221U || (unsigned int )authmode == 48U) {
#line 2001
    memcpy((void *)out_ie + (unsigned long )ielength, (void const   *)(& psecuritypriv->supplicant_ie),
             (size_t )((int )psecuritypriv->supplicant_ie[1] + 2));
#line 2003
    ielength = ((uint )psecuritypriv->supplicant_ie[1] + ielength) + 2U;
  } else {

  }
#line 2006
  iEntry = SecIsInPMKIDList(adapter, (u8 *)(& pmlmepriv->assoc_bssid));
#line 2007
  if (iEntry < 0) {
#line 2008
    return ((int )ielength);
  } else
#line 2010
  if ((unsigned int )authmode == 48U) {
#line 2011
    tmp___0 = rtw_append_pmkid(adapter, iEntry, out_ie, ielength);
#line 2011
    ielength = (uint )tmp___0;
  } else {

  }
#line 2015
  return ((int )ielength);
}
}
#line 2018 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_init_registrypriv_dev_network23a(struct rtw_adapter *adapter ) 
{ 
  struct registry_priv *pregistrypriv ;
  struct eeprom_priv *peepriv ;
  struct wlan_bssid_ex *pdev_network ;
  u8 *myhwaddr ;
  u8 *tmp ;

  {
#line 2020
  pregistrypriv = & adapter->registrypriv;
#line 2021
  peepriv = & adapter->eeprompriv;
#line 2022
  pdev_network = & pregistrypriv->dev_network;
#line 2023
  tmp = myid(peepriv);
#line 2023
  myhwaddr = tmp;
#line 2025
  ether_addr_copy((u8 *)(& pdev_network->MacAddress), (u8 const   *)myhwaddr);
#line 2027
  memcpy((void *)(& pdev_network->Ssid), (void const   *)(& pregistrypriv->ssid),
           33UL);
#line 2030
  pdev_network->beacon_interval = 100U;
#line 2031
  return;
}
}
#line 2033 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_update_registrypriv_dev_network23a(struct rtw_adapter *adapter ) 
{ 
  int sz ;
  struct registry_priv *pregistrypriv ;
  struct wlan_bssid_ex *pdev_network ;
  struct security_priv *psecuritypriv ;
  struct wlan_network *cur_network ;

  {
#line 2035
  sz = 0;
#line 2036
  pregistrypriv = & adapter->registrypriv;
#line 2037
  pdev_network = & pregistrypriv->dev_network;
#line 2038
  psecuritypriv = & adapter->securitypriv;
#line 2039
  cur_network = & adapter->mlmepriv.cur_network;
#line 2042
  pdev_network->Privacy = psecuritypriv->dot11PrivacyAlgrthm != 0U;
#line 2045
  pdev_network->Rssi = 0L;
#line 2047
  pdev_network->DSConfig = (u32 )pregistrypriv->channel;
#line 2048
  if (GlobalDebugLevel23A > 6U) {
#line 2048
    rt_trace(16, 7, "pregistrypriv->channel =%d, pdev_network->DSConfig = 0x%x\n",
             (int )pregistrypriv->channel, pdev_network->DSConfig);
  } else {

  }
#line 2052
  if ((unsigned int )cur_network->network.ifmode == 1U) {
#line 2053
    pdev_network->ATIMWindow = 0U;
  } else {

  }
#line 2055
  pdev_network->ifmode = cur_network->network.ifmode;
#line 2060
  sz = rtw_generate_ie23a(pregistrypriv);
#line 2062
  pdev_network->IELength = (u32 )sz;
#line 2064
  pdev_network->Length = get_wlan_bssid_ex_sz(pdev_network);
#line 2066
  return;
}
}
#line 2073 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_joinbss_reset23a(struct rtw_adapter *padapter ) 
{ 
  u8 threshold ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;

  {
#line 2076
  pmlmepriv = & padapter->mlmepriv;
#line 2077
  phtpriv = & pmlmepriv->htpriv;
#line 2082
  pmlmepriv->num_FortyMHzIntolerant = 0;
#line 2084
  pmlmepriv->num_sta_no_ht = 0;
#line 2086
  phtpriv->ampdu_enable = 0;
#line 2090
  if ((int )phtpriv->ht_option) {
#line 2091
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
#line 2092
      threshold = 1U;
    } else {
#line 2094
      threshold = 0U;
    }
  } else {
#line 2096
    threshold = 1U;
  }
#line 2098
  rtl8723a_set_rxdma_agg_pg_th(padapter, (int )threshold);
#line 2099
  return;
}
}
#line 2102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
bool rtw_restructure_ht_ie23a(struct rtw_adapter *padapter , u8 *in_ie , u8 *out_ie ,
                              uint in_len , uint *pout_len ) 
{ 
  u32 out_len ;
  int max_rx_ampdu_factor ;
  unsigned char *pframe ;
  u8 const   *p ;
  struct ieee80211_ht_cap ht_capie ;
  u8 WMM_IE[7U] ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  u32 rx_packet_offset ;
  u32 max_recvbuf_sz ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;

  {
#line 2110
  WMM_IE[0] = 0U;
#line 2110
  WMM_IE[1] = 80U;
#line 2110
  WMM_IE[2] = 242U;
#line 2110
  WMM_IE[3] = 2U;
#line 2110
  WMM_IE[4] = 0U;
#line 2110
  WMM_IE[5] = 1U;
#line 2110
  WMM_IE[6] = 0U;
#line 2111
  pmlmepriv = & padapter->mlmepriv;
#line 2112
  phtpriv = & pmlmepriv->htpriv;
#line 2114
  phtpriv->ht_option = 0;
#line 2116
  p = cfg80211_find_ie(45, (u8 const   *)in_ie, (int )in_len);
#line 2118
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 2121
    if (pmlmepriv->qos_option == 0U) {
#line 2122
      out_len = *pout_len;
#line 2123
      tmp = rtw_set_ie23a(out_ie + (unsigned long )out_len, 221, 7U, (u8 const   *)(& WMM_IE),
                          pout_len);
#line 2123
      pframe = tmp;
#line 2128
      pmlmepriv->qos_option = 1U;
    } else {

    }
#line 2131
    out_len = *pout_len;
#line 2133
    memset((void *)(& ht_capie), 0, 26UL);
#line 2135
    ht_capie.cap_info = 4322U;
#line 2139
    GetHalDefVar8192CUsb(padapter, 5, (void *)(& rx_packet_offset));
#line 2141
    GetHalDefVar8192CUsb(padapter, 4, (void *)(& max_recvbuf_sz));
#line 2144
    GetHalDefVar8192CUsb(padapter, 11, (void *)(& max_rx_ampdu_factor));
#line 2146
    ht_capie.ampdu_params_info = (unsigned int )((u8 )max_rx_ampdu_factor) & 3U;
#line 2148
    if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
#line 2150
      ht_capie.ampdu_params_info = (u8 )((unsigned int )ht_capie.ampdu_params_info | 28U);
    } else {
#line 2153
      ht_capie.ampdu_params_info = ht_capie.ampdu_params_info;
    }
#line 2156
    tmp___0 = rtw_set_ie23a(out_ie + (unsigned long )out_len, 45, 26U, (u8 const   *)(& ht_capie),
                            pout_len);
#line 2156
    pframe = tmp___0;
#line 2160
    phtpriv->ht_option = 1;
#line 2162
    p = cfg80211_find_ie(61, (u8 const   *)in_ie, (int )in_len);
#line 2163
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) == 22U) {
#line 2164
      out_len = *pout_len;
#line 2165
      tmp___1 = rtw_set_ie23a(out_ie + (unsigned long )out_len, 61, (uint )*(p + 1UL),
                              p + 2UL, pout_len);
#line 2165
      pframe = tmp___1;
    } else {

    }
  } else {

  }
#line 2171
  return (phtpriv->ht_option);
}
}
#line 2175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_update_ht_cap23a(struct rtw_adapter *padapter , u8 *pie , uint ie_len ) 
{ 
  u8 max_ampdu_sz ;
  u8 const   *p ;
  struct ieee80211_ht_cap *pht_capie ;
  struct ieee80211_ht_operation *pht_addtinfo ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int i ;
  u8 rf_type ;

  {
#line 2181
  pmlmepriv = & padapter->mlmepriv;
#line 2182
  phtpriv = & pmlmepriv->htpriv;
#line 2183
  pregistrypriv = & padapter->registrypriv;
#line 2184
  pmlmeext = & padapter->mlmeextpriv;
#line 2185
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2187
  if (! phtpriv->ht_option) {
#line 2188
    return;
  } else {

  }
#line 2190
  if ((unsigned int )pmlmeinfo->HT_info_enable == 0U || (unsigned int )pmlmeinfo->HT_caps_enable == 0U) {
#line 2191
    return;
  } else {

  }
#line 2193
  if (GlobalDebugLevel23A > 3U) {
#line 2193
    printk("\016RTL8723AU: +rtw_update_ht_cap23a()\n");
  } else {

  }
#line 2196
  if (! phtpriv->ampdu_enable && (unsigned int )pregistrypriv->ampdu_enable == 1U) {
#line 2197
    if ((unsigned int )pregistrypriv->wifi_spec == 1U) {
#line 2198
      phtpriv->ampdu_enable = 0;
    } else {
#line 2200
      phtpriv->ampdu_enable = 1;
    }
  } else
#line 2201
  if ((unsigned int )pregistrypriv->ampdu_enable == 2U) {
#line 2202
    phtpriv->ampdu_enable = 1;
  } else {

  }
#line 2205
  p = cfg80211_find_ie(45, (u8 const   *)pie, (int )ie_len);
#line 2207
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 2208
    pht_capie = (struct ieee80211_ht_cap *)p + 2U;
#line 2209
    max_ampdu_sz = (unsigned int )pht_capie->ampdu_params_info & 3U;
#line 2212
    max_ampdu_sz = (u8 )(1 << ((int )max_ampdu_sz + 3));
#line 2214
    phtpriv->rx_ampdu_maxlen = (u32 )max_ampdu_sz;
  } else {

  }
#line 2217
  p = cfg80211_find_ie(61, (u8 const   *)pie, (int )ie_len);
#line 2218
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 2219
    pht_addtinfo = (struct ieee80211_ht_operation *)p + 2U;
  } else {

  }
#line 2224
  if (((unsigned int )pregistrypriv->cbw40_enable != 0U && ((int )pmlmeinfo->ht_cap.cap_info & 2) != 0) && ((int )pmlmeinfo->HT_info.ht_param & 4) != 0) {
#line 2231
    rf_type = rtl8723a_get_rf_type(padapter);
#line 2234
    i = 0;
#line 2234
    goto ldv_56309;
    ldv_56308: ;
#line 2235
    if ((unsigned int )rf_type == 3U || (unsigned int )rf_type == 0U) {
#line 2236
      pmlmeinfo->ht_cap.mcs.rx_mask[i] = (u8 )((int )pmlmeinfo->ht_cap.mcs.rx_mask[i] & (int )MCS_rate_1R23A[i]);
    } else {
#line 2239
      pmlmeinfo->ht_cap.mcs.rx_mask[i] = (u8 )((int )pmlmeinfo->ht_cap.mcs.rx_mask[i] & (int )MCS_rate_2R23A[i]);
    }
#line 2234
    i = i + 1;
    ldv_56309: ;
#line 2234
    if (i <= 9) {
#line 2236
      goto ldv_56308;
    } else {

    }
#line 2243
    pmlmeext->cur_bwmode = 1U;
#line 2244
    switch ((int )pmlmeinfo->HT_info.ht_param & 3) {
    case 1: 
#line 2247
    pmlmeext->cur_ch_offset = 1U;
#line 2248
    goto ldv_56312;
    case 3: 
#line 2251
    pmlmeext->cur_ch_offset = 2U;
#line 2252
    goto ldv_56312;
    default: 
#line 2255
    pmlmeext->cur_ch_offset = 0U;
#line 2257
    goto ldv_56312;
    }
    ldv_56312: ;
  } else {

  }
#line 2264
  pmlmeinfo->SM_PS = (u8 )(((int )pmlmeinfo->ht_cap.cap_info & 12) >> 2);
#line 2267
  if ((unsigned int )pmlmeinfo->SM_PS == 0U) {
#line 2268
    if (GlobalDebugLevel23A > 3U) {
#line 2268
      printk("\016RTL8723AU: %s(): WLAN_HT_CAP_SM_PS_STATIC\n", "rtw_update_ht_cap23a");
    } else {

    }
  } else {

  }
#line 2273
  pmlmeinfo->HT_protection = (unsigned int )((u8 )pmlmeinfo->HT_info.operation_mode) & 3U;
#line 2275
  return;
}
}
#line 2278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
void rtw_issue_addbareq_cmd23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  u8 issued ;
  int priority ;
  struct sta_info *psta ;
  struct ht_priv *phtpriv ;
  struct pkt_attrib *pattrib ;
  s32 bmcst ;
  bool tmp ;

  {
#line 2285
  pattrib = & pxmitframe->attrib;
#line 2286
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 2286
  bmcst = (s32 )tmp;
#line 2288
  if (bmcst != 0 || padapter->mlmepriv.LinkDetectInfo.NumTxOkInPeriod <= 99U) {
#line 2289
    return;
  } else {

  }
#line 2291
  priority = (int )pattrib->priority;
#line 2293
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 2294
    psta = pattrib->psta;
  } else {
#line 2296
    if (GlobalDebugLevel23A > 3U) {
#line 2296
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_issue_addbareq_cmd23a");
    } else {

    }
#line 2297
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
#line 2300
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 2301
    if (GlobalDebugLevel23A > 3U) {
#line 2301
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_issue_addbareq_cmd23a");
    } else {

    }
#line 2302
    return;
  } else {

  }
#line 2305
  if ((psta->state & 1U) == 0U) {
#line 2306
    if (GlobalDebugLevel23A > 3U) {
#line 2306
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_issue_addbareq_cmd23a",
             psta->state);
    } else {

    }
#line 2308
    return;
  } else {

  }
#line 2311
  phtpriv = & psta->htpriv;
#line 2313
  if ((int )phtpriv->ht_option && (int )phtpriv->ampdu_enable) {
#line 2314
    issued = (unsigned int )((u8 )((int )phtpriv->agg_enable_bitmap >> priority)) & 1U;
#line 2315
    issued = (u8 )(((int )((signed char )((int )phtpriv->candidate_tid_bitmap >> priority)) & 1) | (int )((signed char )issued));
#line 2317
    if ((unsigned int )issued == 0U) {
#line 2318
      if (GlobalDebugLevel23A > 3U) {
#line 2318
        printk("\016RTL8723AU: rtw_issue_addbareq_cmd23a, p =%d\n", priority);
      } else {

      }
#line 2320
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap | (int )((u16 )(1UL << priority));
#line 2321
      rtw_addbareq_cmd23a(padapter, (int )((unsigned char )priority), (u8 *)(& pattrib->ra));
    } else {

    }
  } else {

  }
#line 2325
  return;
}
}
#line 2327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.c"
int rtw_linked_check(struct rtw_adapter *padapter ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 2329
  tmp___0 = check_fwstate(& padapter->mlmepriv, 16);
#line 2329
  if ((int )tmp___0) {
#line 2329
    goto _L;
  } else {
#line 2329
    tmp___1 = check_fwstate(& padapter->mlmepriv, 96);
#line 2329
    if ((int )tmp___1) {
      _L: /* CIL Label */ 
#line 2332
      if (padapter->stapriv.asoc_sta_count > 2) {
#line 2333
        return (1);
      } else {

      }
    } else {
#line 2335
      tmp = check_fwstate(& padapter->mlmepriv, 1);
#line 2335
      if ((int )tmp) {
#line 2336
        return (1);
      } else {

      }
    }
  }
#line 2338
  return (0);
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_suitable_timer_6(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 251
  if (ldv_timer_6_0 == 0 || ldv_timer_6_0 == 2) {
#line 252
    ldv_timer_list_6_0 = timer;
#line 253
    ldv_timer_list_6_0->data = data;
#line 254
    ldv_timer_6_0 = 1;
#line 255
    return;
  } else {

  }
#line 257
  if (ldv_timer_6_1 == 0 || ldv_timer_6_1 == 2) {
#line 258
    ldv_timer_list_6_1 = timer;
#line 259
    ldv_timer_list_6_1->data = data;
#line 260
    ldv_timer_6_1 = 1;
#line 261
    return;
  } else {

  }
#line 263
  if (ldv_timer_6_2 == 0 || ldv_timer_6_2 == 2) {
#line 264
    ldv_timer_list_6_2 = timer;
#line 265
    ldv_timer_list_6_2->data = data;
#line 266
    ldv_timer_6_2 = 1;
#line 267
    return;
  } else {

  }
#line 269
  if (ldv_timer_6_3 == 0 || ldv_timer_6_3 == 2) {
#line 270
    ldv_timer_list_6_3 = timer;
#line 271
    ldv_timer_list_6_3->data = data;
#line 272
    ldv_timer_6_3 = 1;
#line 273
    return;
  } else {

  }
#line 275
  return;
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int reg_timer_7(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 280
  if ((unsigned long )function == (unsigned long )(& rtw_set_scan_deny_timer_hdl)) {
#line 281
    activate_suitable_timer_7(timer, data);
  } else {

  }
#line 282
  return (0);
}
}
#line 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void ldv_timer_5(int state , struct timer_list *timer ) 
{ 


  {
#line 287
  LDV_IN_INTERRUPT = 2;
#line 288
  rtw_scan_timeout_handler23a(timer->data);
#line 289
  LDV_IN_INTERRUPT = 1;
#line 290
  return;
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void choose_timer_5(void) 
{ 
  int tmp ;

  {
#line 294
  tmp = __VERIFIER_nondet_int();
#line 294
  switch (tmp) {
  case 0: ;
#line 296
  if (ldv_timer_5_0 == 1) {
#line 297
    ldv_timer_5_0 = 2;
#line 298
    ldv_timer_5(ldv_timer_5_0, ldv_timer_list_5_0);
  } else {

  }
#line 301
  goto ldv_56348;
  case 1: ;
#line 303
  if (ldv_timer_5_1 == 1) {
#line 304
    ldv_timer_5_1 = 2;
#line 305
    ldv_timer_5(ldv_timer_5_1, ldv_timer_list_5_1);
  } else {

  }
#line 308
  goto ldv_56348;
  case 2: ;
#line 310
  if (ldv_timer_5_2 == 1) {
#line 311
    ldv_timer_5_2 = 2;
#line 312
    ldv_timer_5(ldv_timer_5_2, ldv_timer_list_5_2);
  } else {

  }
#line 315
  goto ldv_56348;
  case 3: ;
#line 317
  if (ldv_timer_5_3 == 1) {
#line 318
    ldv_timer_5_3 = 2;
#line 319
    ldv_timer_5(ldv_timer_5_3, ldv_timer_list_5_3);
  } else {

  }
#line 322
  goto ldv_56348;
  default: 
#line 323
  ldv_stop();
  }
  ldv_56348: ;
#line 325
  return;
}
}
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 330
  if ((unsigned long )ldv_timer_list_4_0 == (unsigned long )timer) {
#line 331
    if (ldv_timer_4_0 == 2 || pending_flag != 0) {
#line 332
      ldv_timer_list_4_0 = timer;
#line 333
      ldv_timer_list_4_0->data = data;
#line 334
      ldv_timer_4_0 = 1;
    } else {

    }
#line 336
    return;
  } else {

  }
#line 339
  if ((unsigned long )ldv_timer_list_4_1 == (unsigned long )timer) {
#line 340
    if (ldv_timer_4_1 == 2 || pending_flag != 0) {
#line 341
      ldv_timer_list_4_1 = timer;
#line 342
      ldv_timer_list_4_1->data = data;
#line 343
      ldv_timer_4_1 = 1;
    } else {

    }
#line 345
    return;
  } else {

  }
#line 348
  if ((unsigned long )ldv_timer_list_4_2 == (unsigned long )timer) {
#line 349
    if (ldv_timer_4_2 == 2 || pending_flag != 0) {
#line 350
      ldv_timer_list_4_2 = timer;
#line 351
      ldv_timer_list_4_2->data = data;
#line 352
      ldv_timer_4_2 = 1;
    } else {

    }
#line 354
    return;
  } else {

  }
#line 357
  if ((unsigned long )ldv_timer_list_4_3 == (unsigned long )timer) {
#line 358
    if (ldv_timer_4_3 == 2 || pending_flag != 0) {
#line 359
      ldv_timer_list_4_3 = timer;
#line 360
      ldv_timer_list_4_3->data = data;
#line 361
      ldv_timer_4_3 = 1;
    } else {

    }
#line 363
    return;
  } else {

  }
#line 365
  activate_suitable_timer_4(timer, data);
#line 366
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void timer_init_4(void) 
{ 


  {
#line 370
  ldv_timer_4_0 = 0;
#line 371
  ldv_timer_4_1 = 0;
#line 372
  ldv_timer_4_2 = 0;
#line 373
  ldv_timer_4_3 = 0;
#line 374
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void timer_init_6(void) 
{ 


  {
#line 378
  ldv_timer_6_0 = 0;
#line 379
  ldv_timer_6_1 = 0;
#line 380
  ldv_timer_6_2 = 0;
#line 381
  ldv_timer_6_3 = 0;
#line 382
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void ldv_timer_7(int state , struct timer_list *timer ) 
{ 


  {
#line 386
  LDV_IN_INTERRUPT = 2;
#line 387
  rtw_set_scan_deny_timer_hdl(timer->data);
#line 388
  LDV_IN_INTERRUPT = 1;
#line 389
  return;
}
}
#line 392 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void timer_init_5(void) 
{ 


  {
#line 393
  ldv_timer_5_0 = 0;
#line 394
  ldv_timer_5_1 = 0;
#line 395
  ldv_timer_5_2 = 0;
#line 396
  ldv_timer_5_3 = 0;
#line 397
  return;
}
}
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void disable_suitable_timer_6(struct timer_list *timer ) 
{ 


  {
#line 401
  if (ldv_timer_6_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_0) {
#line 402
    ldv_timer_6_0 = 0;
#line 403
    return;
  } else {

  }
#line 405
  if (ldv_timer_6_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_1) {
#line 406
    ldv_timer_6_1 = 0;
#line 407
    return;
  } else {

  }
#line 409
  if (ldv_timer_6_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_2) {
#line 410
    ldv_timer_6_2 = 0;
#line 411
    return;
  } else {

  }
#line 413
  if (ldv_timer_6_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_3) {
#line 414
    ldv_timer_6_3 = 0;
#line 415
    return;
  } else {

  }
#line 417
  return;
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void disable_suitable_timer_5(struct timer_list *timer ) 
{ 


  {
#line 422
  if (ldv_timer_5_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_0) {
#line 423
    ldv_timer_5_0 = 0;
#line 424
    return;
  } else {

  }
#line 426
  if (ldv_timer_5_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_1) {
#line 427
    ldv_timer_5_1 = 0;
#line 428
    return;
  } else {

  }
#line 430
  if (ldv_timer_5_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_2) {
#line 431
    ldv_timer_5_2 = 0;
#line 432
    return;
  } else {

  }
#line 434
  if (ldv_timer_5_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_3) {
#line 435
    ldv_timer_5_3 = 0;
#line 436
    return;
  } else {

  }
#line 438
  return;
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 443
  if ((unsigned long )ldv_timer_list_6_0 == (unsigned long )timer) {
#line 444
    if (ldv_timer_6_0 == 2 || pending_flag != 0) {
#line 445
      ldv_timer_list_6_0 = timer;
#line 446
      ldv_timer_list_6_0->data = data;
#line 447
      ldv_timer_6_0 = 1;
    } else {

    }
#line 449
    return;
  } else {

  }
#line 452
  if ((unsigned long )ldv_timer_list_6_1 == (unsigned long )timer) {
#line 453
    if (ldv_timer_6_1 == 2 || pending_flag != 0) {
#line 454
      ldv_timer_list_6_1 = timer;
#line 455
      ldv_timer_list_6_1->data = data;
#line 456
      ldv_timer_6_1 = 1;
    } else {

    }
#line 458
    return;
  } else {

  }
#line 461
  if ((unsigned long )ldv_timer_list_6_2 == (unsigned long )timer) {
#line 462
    if (ldv_timer_6_2 == 2 || pending_flag != 0) {
#line 463
      ldv_timer_list_6_2 = timer;
#line 464
      ldv_timer_list_6_2->data = data;
#line 465
      ldv_timer_6_2 = 1;
    } else {

    }
#line 467
    return;
  } else {

  }
#line 470
  if ((unsigned long )ldv_timer_list_6_3 == (unsigned long )timer) {
#line 471
    if (ldv_timer_6_3 == 2 || pending_flag != 0) {
#line 472
      ldv_timer_list_6_3 = timer;
#line 473
      ldv_timer_list_6_3->data = data;
#line 474
      ldv_timer_6_3 = 1;
    } else {

    }
#line 476
    return;
  } else {

  }
#line 478
  activate_suitable_timer_6(timer, data);
#line 479
  return;
}
}
#line 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_suitable_timer_4(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 483
  if (ldv_timer_4_0 == 0 || ldv_timer_4_0 == 2) {
#line 484
    ldv_timer_list_4_0 = timer;
#line 485
    ldv_timer_list_4_0->data = data;
#line 486
    ldv_timer_4_0 = 1;
#line 487
    return;
  } else {

  }
#line 489
  if (ldv_timer_4_1 == 0 || ldv_timer_4_1 == 2) {
#line 490
    ldv_timer_list_4_1 = timer;
#line 491
    ldv_timer_list_4_1->data = data;
#line 492
    ldv_timer_4_1 = 1;
#line 493
    return;
  } else {

  }
#line 495
  if (ldv_timer_4_2 == 0 || ldv_timer_4_2 == 2) {
#line 496
    ldv_timer_list_4_2 = timer;
#line 497
    ldv_timer_list_4_2->data = data;
#line 498
    ldv_timer_4_2 = 1;
#line 499
    return;
  } else {

  }
#line 501
  if (ldv_timer_4_3 == 0 || ldv_timer_4_3 == 2) {
#line 502
    ldv_timer_list_4_3 = timer;
#line 503
    ldv_timer_list_4_3->data = data;
#line 504
    ldv_timer_4_3 = 1;
#line 505
    return;
  } else {

  }
#line 507
  return;
}
}
#line 511 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void disable_suitable_timer_7(struct timer_list *timer ) 
{ 


  {
#line 512
  if (ldv_timer_7_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_0) {
#line 513
    ldv_timer_7_0 = 0;
#line 514
    return;
  } else {

  }
#line 516
  if (ldv_timer_7_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_1) {
#line 517
    ldv_timer_7_1 = 0;
#line 518
    return;
  } else {

  }
#line 520
  if (ldv_timer_7_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_2) {
#line 521
    ldv_timer_7_2 = 0;
#line 522
    return;
  } else {

  }
#line 524
  if (ldv_timer_7_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_3) {
#line 525
    ldv_timer_7_3 = 0;
#line 526
    return;
  } else {

  }
#line 528
  return;
}
}
#line 532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void choose_timer_6(void) 
{ 
  int tmp ;

  {
#line 533
  tmp = __VERIFIER_nondet_int();
#line 533
  switch (tmp) {
  case 0: ;
#line 535
  if (ldv_timer_6_0 == 1) {
#line 536
    ldv_timer_6_0 = 2;
#line 537
    ldv_timer_6(ldv_timer_6_0, ldv_timer_list_6_0);
  } else {

  }
#line 540
  goto ldv_56393;
  case 1: ;
#line 542
  if (ldv_timer_6_1 == 1) {
#line 543
    ldv_timer_6_1 = 2;
#line 544
    ldv_timer_6(ldv_timer_6_1, ldv_timer_list_6_1);
  } else {

  }
#line 547
  goto ldv_56393;
  case 2: ;
#line 549
  if (ldv_timer_6_2 == 1) {
#line 550
    ldv_timer_6_2 = 2;
#line 551
    ldv_timer_6(ldv_timer_6_2, ldv_timer_list_6_2);
  } else {

  }
#line 554
  goto ldv_56393;
  case 3: ;
#line 556
  if (ldv_timer_6_3 == 1) {
#line 557
    ldv_timer_6_3 = 2;
#line 558
    ldv_timer_6(ldv_timer_6_3, ldv_timer_list_6_3);
  } else {

  }
#line 561
  goto ldv_56393;
  default: 
#line 562
  ldv_stop();
  }
  ldv_56393: ;
#line 564
  return;
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int reg_timer_6(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 569
  if ((unsigned long )function == (unsigned long )(& rtw_dynamic_check_timer_handler)) {
#line 570
    activate_suitable_timer_6(timer, data);
  } else {

  }
#line 571
  return (0);
}
}
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void ldv_timer_6(int state , struct timer_list *timer ) 
{ 


  {
#line 576
  LDV_IN_INTERRUPT = 2;
#line 577
  rtw_dynamic_check_timer_handler(timer->data);
#line 578
  LDV_IN_INTERRUPT = 1;
#line 579
  return;
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void timer_init_7(void) 
{ 


  {
#line 583
  ldv_timer_7_0 = 0;
#line 584
  ldv_timer_7_1 = 0;
#line 585
  ldv_timer_7_2 = 0;
#line 586
  ldv_timer_7_3 = 0;
#line 587
  return;
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void choose_timer_4(void) 
{ 
  int tmp ;

  {
#line 591
  tmp = __VERIFIER_nondet_int();
#line 591
  switch (tmp) {
  case 0: ;
#line 593
  if (ldv_timer_4_0 == 1) {
#line 594
    ldv_timer_4_0 = 2;
#line 595
    ldv_timer_4(ldv_timer_4_0, ldv_timer_list_4_0);
  } else {

  }
#line 598
  goto ldv_56415;
  case 1: ;
#line 600
  if (ldv_timer_4_1 == 1) {
#line 601
    ldv_timer_4_1 = 2;
#line 602
    ldv_timer_4(ldv_timer_4_1, ldv_timer_list_4_1);
  } else {

  }
#line 605
  goto ldv_56415;
  case 2: ;
#line 607
  if (ldv_timer_4_2 == 1) {
#line 608
    ldv_timer_4_2 = 2;
#line 609
    ldv_timer_4(ldv_timer_4_2, ldv_timer_list_4_2);
  } else {

  }
#line 612
  goto ldv_56415;
  case 3: ;
#line 614
  if (ldv_timer_4_3 == 1) {
#line 615
    ldv_timer_4_3 = 2;
#line 616
    ldv_timer_4(ldv_timer_4_3, ldv_timer_list_4_3);
  } else {

  }
#line 619
  goto ldv_56415;
  default: 
#line 620
  ldv_stop();
  }
  ldv_56415: ;
#line 622
  return;
}
}
#line 626 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void disable_suitable_timer_4(struct timer_list *timer ) 
{ 


  {
#line 627
  if (ldv_timer_4_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_0) {
#line 628
    ldv_timer_4_0 = 0;
#line 629
    return;
  } else {

  }
#line 631
  if (ldv_timer_4_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_1) {
#line 632
    ldv_timer_4_1 = 0;
#line 633
    return;
  } else {

  }
#line 635
  if (ldv_timer_4_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_2) {
#line 636
    ldv_timer_4_2 = 0;
#line 637
    return;
  } else {

  }
#line 639
  if (ldv_timer_4_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_3) {
#line 640
    ldv_timer_4_3 = 0;
#line 641
    return;
  } else {

  }
#line 643
  return;
}
}
#line 647 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int reg_timer_4(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 648
  if ((unsigned long )function == (unsigned long )(& rtw23a_join_to_handler)) {
#line 649
    activate_suitable_timer_4(timer, data);
  } else {

  }
#line 650
  return (0);
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 655
  if ((unsigned long )ldv_timer_list_5_0 == (unsigned long )timer) {
#line 656
    if (ldv_timer_5_0 == 2 || pending_flag != 0) {
#line 657
      ldv_timer_list_5_0 = timer;
#line 658
      ldv_timer_list_5_0->data = data;
#line 659
      ldv_timer_5_0 = 1;
    } else {

    }
#line 661
    return;
  } else {

  }
#line 664
  if ((unsigned long )ldv_timer_list_5_1 == (unsigned long )timer) {
#line 665
    if (ldv_timer_5_1 == 2 || pending_flag != 0) {
#line 666
      ldv_timer_list_5_1 = timer;
#line 667
      ldv_timer_list_5_1->data = data;
#line 668
      ldv_timer_5_1 = 1;
    } else {

    }
#line 670
    return;
  } else {

  }
#line 673
  if ((unsigned long )ldv_timer_list_5_2 == (unsigned long )timer) {
#line 674
    if (ldv_timer_5_2 == 2 || pending_flag != 0) {
#line 675
      ldv_timer_list_5_2 = timer;
#line 676
      ldv_timer_list_5_2->data = data;
#line 677
      ldv_timer_5_2 = 1;
    } else {

    }
#line 679
    return;
  } else {

  }
#line 682
  if ((unsigned long )ldv_timer_list_5_3 == (unsigned long )timer) {
#line 683
    if (ldv_timer_5_3 == 2 || pending_flag != 0) {
#line 684
      ldv_timer_list_5_3 = timer;
#line 685
      ldv_timer_list_5_3->data = data;
#line 686
      ldv_timer_5_3 = 1;
    } else {

    }
#line 688
    return;
  } else {

  }
#line 690
  activate_suitable_timer_5(timer, data);
#line 691
  return;
}
}
#line 694 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void choose_timer_7(void) 
{ 
  int tmp ;

  {
#line 695
  tmp = __VERIFIER_nondet_int();
#line 695
  switch (tmp) {
  case 0: ;
#line 697
  if (ldv_timer_7_0 == 1) {
#line 698
    ldv_timer_7_0 = 2;
#line 699
    ldv_timer_7(ldv_timer_7_0, ldv_timer_list_7_0);
  } else {

  }
#line 702
  goto ldv_56438;
  case 1: ;
#line 704
  if (ldv_timer_7_1 == 1) {
#line 705
    ldv_timer_7_1 = 2;
#line 706
    ldv_timer_7(ldv_timer_7_1, ldv_timer_list_7_1);
  } else {

  }
#line 709
  goto ldv_56438;
  case 2: ;
#line 711
  if (ldv_timer_7_2 == 1) {
#line 712
    ldv_timer_7_2 = 2;
#line 713
    ldv_timer_7(ldv_timer_7_2, ldv_timer_list_7_2);
  } else {

  }
#line 716
  goto ldv_56438;
  case 3: ;
#line 718
  if (ldv_timer_7_3 == 1) {
#line 719
    ldv_timer_7_3 = 2;
#line 720
    ldv_timer_7(ldv_timer_7_3, ldv_timer_list_7_3);
  } else {

  }
#line 723
  goto ldv_56438;
  default: 
#line 724
  ldv_stop();
  }
  ldv_56438: ;
#line 726
  return;
}
}
#line 730 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int reg_timer_5(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 731
  if ((unsigned long )function == (unsigned long )(& rtw_scan_timeout_handler23a)) {
#line 732
    activate_suitable_timer_5(timer, data);
  } else {

  }
#line 733
  return (0);
}
}
#line 737 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void ldv_timer_4(int state , struct timer_list *timer ) 
{ 


  {
#line 738
  LDV_IN_INTERRUPT = 2;
#line 739
  rtw23a_join_to_handler(timer->data);
#line 740
  LDV_IN_INTERRUPT = 1;
#line 741
  return;
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_suitable_timer_5(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 745
  if (ldv_timer_5_0 == 0 || ldv_timer_5_0 == 2) {
#line 746
    ldv_timer_list_5_0 = timer;
#line 747
    ldv_timer_list_5_0->data = data;
#line 748
    ldv_timer_5_0 = 1;
#line 749
    return;
  } else {

  }
#line 751
  if (ldv_timer_5_1 == 0 || ldv_timer_5_1 == 2) {
#line 752
    ldv_timer_list_5_1 = timer;
#line 753
    ldv_timer_list_5_1->data = data;
#line 754
    ldv_timer_5_1 = 1;
#line 755
    return;
  } else {

  }
#line 757
  if (ldv_timer_5_2 == 0 || ldv_timer_5_2 == 2) {
#line 758
    ldv_timer_list_5_2 = timer;
#line 759
    ldv_timer_list_5_2->data = data;
#line 760
    ldv_timer_5_2 = 1;
#line 761
    return;
  } else {

  }
#line 763
  if (ldv_timer_5_3 == 0 || ldv_timer_5_3 == 2) {
#line 764
    ldv_timer_list_5_3 = timer;
#line 765
    ldv_timer_list_5_3->data = data;
#line 766
    ldv_timer_5_3 = 1;
#line 767
    return;
  } else {

  }
#line 769
  return;
}
}
#line 773 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_pending_timer_7(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 774
  if ((unsigned long )ldv_timer_list_7_0 == (unsigned long )timer) {
#line 775
    if (ldv_timer_7_0 == 2 || pending_flag != 0) {
#line 776
      ldv_timer_list_7_0 = timer;
#line 777
      ldv_timer_list_7_0->data = data;
#line 778
      ldv_timer_7_0 = 1;
    } else {

    }
#line 780
    return;
  } else {

  }
#line 783
  if ((unsigned long )ldv_timer_list_7_1 == (unsigned long )timer) {
#line 784
    if (ldv_timer_7_1 == 2 || pending_flag != 0) {
#line 785
      ldv_timer_list_7_1 = timer;
#line 786
      ldv_timer_list_7_1->data = data;
#line 787
      ldv_timer_7_1 = 1;
    } else {

    }
#line 789
    return;
  } else {

  }
#line 792
  if ((unsigned long )ldv_timer_list_7_2 == (unsigned long )timer) {
#line 793
    if (ldv_timer_7_2 == 2 || pending_flag != 0) {
#line 794
      ldv_timer_list_7_2 = timer;
#line 795
      ldv_timer_list_7_2->data = data;
#line 796
      ldv_timer_7_2 = 1;
    } else {

    }
#line 798
    return;
  } else {

  }
#line 801
  if ((unsigned long )ldv_timer_list_7_3 == (unsigned long )timer) {
#line 802
    if (ldv_timer_7_3 == 2 || pending_flag != 0) {
#line 803
      ldv_timer_list_7_3 = timer;
#line 804
      ldv_timer_list_7_3->data = data;
#line 805
      ldv_timer_7_3 = 1;
    } else {

    }
#line 807
    return;
  } else {

  }
#line 809
  activate_suitable_timer_7(timer, data);
#line 810
  return;
}
}
#line 813 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_suitable_timer_7(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 814
  if (ldv_timer_7_0 == 0 || ldv_timer_7_0 == 2) {
#line 815
    ldv_timer_list_7_0 = timer;
#line 816
    ldv_timer_list_7_0->data = data;
#line 817
    ldv_timer_7_0 = 1;
#line 818
    return;
  } else {

  }
#line 820
  if (ldv_timer_7_1 == 0 || ldv_timer_7_1 == 2) {
#line 821
    ldv_timer_list_7_1 = timer;
#line 822
    ldv_timer_list_7_1->data = data;
#line 823
    ldv_timer_7_1 = 1;
#line 824
    return;
  } else {

  }
#line 826
  if (ldv_timer_7_2 == 0 || ldv_timer_7_2 == 2) {
#line 827
    ldv_timer_list_7_2 = timer;
#line 828
    ldv_timer_list_7_2->data = data;
#line 829
    ldv_timer_7_2 = 1;
#line 830
    return;
  } else {

  }
#line 832
  if (ldv_timer_7_3 == 0 || ldv_timer_7_3 == 2) {
#line 833
    ldv_timer_list_7_3 = timer;
#line 834
    ldv_timer_list_7_3->data = data;
#line 835
    ldv_timer_7_3 = 1;
#line 836
    return;
  } else {

  }
#line 838
  return;
}
}
#line 865 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
bool ldv_queue_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 869
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 869
  ldv_func_res = tmp;
#line 871
  activate_work_2(ldv_func_arg3, 2);
#line 873
  return (ldv_func_res);
}
}
#line 876 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
bool ldv_queue_delayed_work_on_64(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 880
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 880
  ldv_func_res = tmp;
#line 882
  activate_work_2(& ldv_func_arg3->work, 2);
#line 884
  return (ldv_func_res);
}
}
#line 887 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
bool ldv_queue_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 891
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 891
  ldv_func_res = tmp;
#line 893
  activate_work_2(ldv_func_arg3, 2);
#line 895
  return (ldv_func_res);
}
}
#line 898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void ldv_flush_workqueue_66(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 901
  flush_workqueue(ldv_func_arg1);
#line 903
  call_and_disable_all_2(2);
#line 904
  return;
}
}
#line 906 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
bool ldv_queue_delayed_work_on_67(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 910
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 910
  ldv_func_res = tmp;
#line 912
  activate_work_2(& ldv_func_arg3->work, 2);
#line 914
  return (ldv_func_res);
}
}
#line 917 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_del_timer_sync_68(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 921
  tmp = del_timer_sync(ldv_func_arg1);
#line 921
  ldv_func_res = tmp;
#line 923
  disable_suitable_timer_11(ldv_func_arg1);
#line 925
  return (ldv_func_res);
}
}
#line 928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_69(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 932
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 932
  ldv_func_res = tmp;
#line 934
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 936
  return (ldv_func_res);
}
}
#line 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_70(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 943
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 943
  ldv_func_res = tmp;
#line 945
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 947
  return (ldv_func_res);
}
}
#line 950 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_71(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 954
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 954
  ldv_func_res = tmp;
#line 956
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 958
  return (ldv_func_res);
}
}
#line 961 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_del_timer_sync_72(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 965
  tmp = del_timer_sync(ldv_func_arg1);
#line 965
  ldv_func_res = tmp;
#line 967
  disable_suitable_timer_11(ldv_func_arg1);
#line 969
  return (ldv_func_res);
}
}
#line 972 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_73(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 976
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 976
  ldv_func_res = tmp;
#line 978
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 980
  return (ldv_func_res);
}
}
#line 983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_74(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 987
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 987
  ldv_func_res = tmp;
#line 989
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 991
  return (ldv_func_res);
}
}
#line 994 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_75(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 998
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 998
  ldv_func_res = tmp;
#line 1000
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 1002
  return (ldv_func_res);
}
}
#line 1005 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_76(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
#line 1009
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 1009
  ldv_func_res = tmp;
#line 1011
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 1013
  return (ldv_func_res);
}
}
#line 1016 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_77(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
#line 1020
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 1020
  ldv_func_res = tmp;
#line 1022
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 1024
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 47 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u64 __le64_to_cpup(__le64 const   *p ) 
{ 


  {
#line 49
  return ((__u64 )*p);
}
}
#line 187 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 15 "./arch/x86/include/asm/cmpxchg.h"
extern void __xadd_wrong_size(void) ;
#line 155 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 157
  __ret = i;
#line 157
  switch (4UL) {
  case 1UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  case 2UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  case 4UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  case 8UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  default: 
#line 157
  __xadd_wrong_size();
  }
  ldv_5659: ;
#line 157
  return (__ret + i);
}
}
#line 34 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 45
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 370 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 372
  _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
#line 373
  return;
}
}
#line 138 "include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 174
extern void mutex_unlock(struct mutex * ) ;
#line 173 "include/linux/timer.h"
int ldv_mod_timer_104(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 177
int ldv_mod_timer_105(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 181
int ldv_mod_timer_107(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 185
int ldv_mod_timer_108(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 189
int ldv_mod_timer_109(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 193
int ldv_mod_timer_111(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 197
int ldv_mod_timer_113(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 201
int ldv_mod_timer_115(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 205
int ldv_mod_timer_116(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 209
int ldv_mod_timer_121(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 213
int ldv_mod_timer_122(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 232
int ldv_del_timer_sync_102(struct timer_list *ldv_func_arg1 ) ;
#line 236
int ldv_del_timer_sync_103(struct timer_list *ldv_func_arg1 ) ;
#line 240
int ldv_del_timer_sync_106(struct timer_list *ldv_func_arg1 ) ;
#line 244
int ldv_del_timer_sync_110(struct timer_list *ldv_func_arg1 ) ;
#line 248
int ldv_del_timer_sync_112(struct timer_list *ldv_func_arg1 ) ;
#line 252
int ldv_del_timer_sync_114(struct timer_list *ldv_func_arg1 ) ;
#line 256
int ldv_del_timer_sync_117(struct timer_list *ldv_func_arg1 ) ;
#line 260
int ldv_del_timer_sync_118(struct timer_list *ldv_func_arg1 ) ;
#line 264
int ldv_del_timer_sync_119(struct timer_list *ldv_func_arg1 ) ;
#line 268
int ldv_del_timer_sync_120(struct timer_list *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_97(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_99(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_98(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_101(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_100(struct workqueue_struct *ldv_func_arg1 ) ;
#line 2357 "include/linux/sched.h"
extern void yield(void) ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
struct timer_list *ldv_timer_list_9_3 ;
#line 25
struct timer_list *ldv_timer_list_10_2 ;
#line 26
struct timer_list *ldv_timer_list_8_1 ;
#line 34
int ldv_timer_9_1 ;
#line 36
int ldv_timer_9_0 ;
#line 39
int ldv_timer_9_3 ;
#line 51
struct timer_list *ldv_timer_list_10_0 ;
#line 55
int ldv_timer_8_2 ;
#line 57
struct timer_list *ldv_timer_list_9_2 ;
#line 59
int ldv_timer_9_2 ;
#line 71
struct timer_list *ldv_timer_list_8_3 ;
#line 73
int ldv_timer_10_2 ;
#line 79
struct timer_list *ldv_timer_list_10_1 ;
#line 85
struct timer_list *ldv_timer_list_9_0 ;
#line 86
int ldv_timer_8_3 ;
#line 117
int ldv_timer_8_0 ;
#line 118
int ldv_timer_10_0 ;
#line 125
int ldv_timer_8_1 ;
#line 131
int ldv_timer_10_1 ;
#line 142
struct timer_list *ldv_timer_list_8_0 ;
#line 143
struct timer_list *ldv_timer_list_10_3 ;
#line 150
int ldv_timer_10_3 ;
#line 152
struct timer_list *ldv_timer_list_8_2 ;
#line 154
struct timer_list *ldv_timer_list_9_1 ;
#line 167
void activate_pending_timer_9(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 171
void disable_suitable_timer_8(struct timer_list *timer ) ;
#line 173
void activate_pending_timer_10(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 176
int reg_timer_10(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 182
void ldv_timer_9(int state , struct timer_list *timer ) ;
#line 184
void activate_pending_timer_8(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 189
void timer_init_9(void) ;
#line 194
void ldv_timer_10(int state , struct timer_list *timer ) ;
#line 199
void activate_suitable_timer_9(struct timer_list *timer , unsigned long data ) ;
#line 200
void disable_suitable_timer_10(struct timer_list *timer ) ;
#line 201
void choose_timer_8(void) ;
#line 204
int reg_timer_9(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 205
int reg_timer_8(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 208
void disable_suitable_timer_9(struct timer_list *timer ) ;
#line 215
void activate_suitable_timer_10(struct timer_list *timer , unsigned long data ) ;
#line 221
void choose_timer_9(void) ;
#line 223
void timer_init_10(void) ;
#line 231
void ldv_timer_8(int state , struct timer_list *timer ) ;
#line 237
void timer_init_8(void) ;
#line 239
void activate_suitable_timer_8(struct timer_list *timer , unsigned long data ) ;
#line 240
void choose_timer_10(void) ;
#line 17 "include/linux/unaligned/access_ok.h"
__inline static u64 get_unaligned_le64(void const   *p ) 
{ 
  __u64 tmp ;

  {
#line 19
  tmp = __le64_to_cpup((__le64 const   *)p);
#line 19
  return (tmp);
}
}
#line 37 "include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_le16(u16 val , void *p ) 
{ 


  {
#line 39
  *((__le16 *)p) = val;
#line 40
  return;
}
}
#line 42 "include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_le32(u32 val , void *p ) 
{ 


  {
#line 44
  *((__le32 *)p) = val;
#line 45
  return;
}
}
#line 157 "include/linux/etherdevice.h"
__inline static bool is_broadcast_ether_addr(u8 const   *addr ) 
{ 


  {
#line 159
  return ((unsigned int )(((int )((unsigned short )*((u16 const   *)addr)) & (int )((unsigned short )*((u16 const   *)addr + 2U))) & (int )((unsigned short )*((u16 const   *)addr + 4U))) == 65535U);
}
}
#line 290 "include/linux/ieee80211.h"
__inline static int ieee80211_has_retry(__le16 fc ) 
{ 


  {
#line 292
  return (((int )fc & 2048) != 0);
}
}
#line 335 "include/linux/ieee80211.h"
__inline static int ieee80211_is_mgmt(__le16 fc ) 
{ 


  {
#line 337
  return (((int )fc & 12) == 0);
}
}
#line 393 "include/linux/ieee80211.h"
__inline static int ieee80211_is_assoc_req(__le16 fc ) 
{ 


  {
#line 395
  return (((int )fc & 252) == 0);
}
}
#line 433 "include/linux/ieee80211.h"
__inline static int ieee80211_is_probe_req(__le16 fc ) 
{ 


  {
#line 435
  return (((int )fc & 252) == 64);
}
}
#line 443 "include/linux/ieee80211.h"
__inline static int ieee80211_is_probe_resp(__le16 fc ) 
{ 


  {
#line 445
  return (((int )fc & 252) == 80);
}
}
#line 453 "include/linux/ieee80211.h"
__inline static int ieee80211_is_beacon(__le16 fc ) 
{ 


  {
#line 455
  return (((int )fc & 252) == 128);
}
}
#line 3257 "include/net/cfg80211.h"
__inline static void *wiphy_priv___0(struct wiphy *wiphy ) 
{ 
  long tmp ;

  {
#line 3259
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
#line 3259
  if (tmp != 0L) {
#line 3259
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3259), "i" (12UL));
    ldv_48282: ;
#line 3259
    goto ldv_48282;
  } else {

  }
#line 3260
  return ((void *)(& wiphy->priv));
}
}
#line 3510 "include/net/cfg80211.h"
__inline static void *wdev_priv___0(struct wireless_dev *wdev ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
#line 3512
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
#line 3512
  if (tmp != 0L) {
#line 3512
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3512), "i" (12UL));
    ldv_48367: ;
#line 3512
    goto ldv_48367;
  } else {

  }
#line 3513
  tmp___0 = wiphy_priv___0(wdev->wiphy);
#line 3513
  return (tmp___0);
}
}
#line 3528
extern int ieee80211_channel_to_frequency(int  , enum ieee80211_band  ) ;
#line 4683
extern bool cfg80211_rx_mgmt(struct wireless_dev * , int  , int  , u8 const   * ,
                             size_t  , u32  ) ;
#line 310 "drivers/staging/rtl8723au/include/ieee80211.h"
extern u8 hal_ch_offset_to_secondary_ch_offset23a(u8  ) ;
#line 311
extern u8 *rtw_set_ie23a_ch_switch(u8 * , u32 * , u8  , u8  , u8  ) ;
#line 312
extern u8 *rtw_set_ie23a_secondary_ch_offset(u8 * , u32 * , u8  ) ;
#line 196 "drivers/staging/rtl8723au/include/rtw_xmit.h"
void rtw_sctx_init23a(struct submit_ctx *sctx , int timeout_ms ) ;
#line 197
int rtw_sctx_wait23a(struct submit_ctx *sctx ) ;
#line 332
struct xmit_buf *rtw_alloc_xmitbuf23a_ext(struct xmit_priv *pxmitpriv ) ;
#line 337
s32 rtw_free_xmitbuf23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf ) ;
#line 342
struct xmit_frame *rtw_alloc_xmitframe23a_ext(struct xmit_priv *pxmitpriv ) ;
#line 344
s32 rtw_free_xmitframe23a(struct xmit_priv *pxmitpriv , struct xmit_frame *pxmitframe ) ;
#line 380
int rtw_ack_tx_wait23a(struct xmit_priv *pxmitpriv , u32 timeout_ms ) ;
#line 304 "drivers/staging/rtl8723au/include/rtw_recv.h"
void mgt_dispatcher23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 105 "drivers/staging/rtl8723au/include/hal_intf.h"
void hw_var_set_correct_tsf(struct rtw_adapter *padapter ) ;
#line 106
void hw_var_set_mlme_disconnect(struct rtw_adapter *padapter ) ;
#line 107
void hw_var_set_opmode(struct rtw_adapter *padapter , u8 mode ) ;
#line 109
void hw_var_set_bssid(struct rtw_adapter *padapter , u8 *val ) ;
#line 110
void hw_var_set_mlme_join(struct rtw_adapter *padapter , u8 type ) ;
#line 132 "drivers/staging/rtl8723au/include/hal_com.h"
void HalSetBrateCfg23a(struct rtw_adapter *padapter , u8 *mBratesOS ) ;
#line 143
void rtl8723a_set_media_status(struct rtw_adapter *padapter , u8 status ) ;
#line 145
void rtl8723a_set_bcn_func(struct rtw_adapter *padapter , u8 val ) ;
#line 147
void rtl8723a_mlme_sitesurvey(struct rtw_adapter *padapter , u8 flag ) ;
#line 148
void rtl8723a_on_rcr_am(struct rtw_adapter *padapter ) ;
#line 152
void rtl8723a_set_sec_cfg(struct rtw_adapter *padapter , u8 sec ) ;
#line 155
void rtl8723a_cam_write(struct rtw_adapter *padapter , u8 entry , u16 ctrl , u8 const   *mac ,
                        u8 const   *key ) ;
#line 159
void rtl8723a_bcn_valid(struct rtw_adapter *padapter ) ;
#line 160
bool rtl8723a_get_bcn_valid(struct rtw_adapter *padapter ) ;
#line 161
void rtl8723a_set_beacon_interval(struct rtw_adapter *padapter , u16 interval ) ;
#line 169
void rtl8723a_set_initial_gain(struct rtw_adapter *padapter , u32 rx_gain ) ;
#line 172
void rtl8723a_odm_support_ability_backup(struct rtw_adapter *padapter ) ;
#line 173
void rtl8723a_odm_support_ability_restore(struct rtw_adapter *padapter ) ;
#line 174
void rtl8723a_odm_support_ability_set(struct rtw_adapter *padapter , u32 val ) ;
#line 175
void rtl8723a_odm_support_ability_clr(struct rtw_adapter *padapter , u32 val ) ;
#line 321 "drivers/staging/rtl8723au/include/rtw_security.h"
void rtw_wep_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 92 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
unsigned char WMM_OUI23A[4U] ;
#line 93
unsigned char WPS_OUI23A[4U] ;
#line 94
unsigned char WFD_OUI23A[4U] ;
#line 95
unsigned char P2P_OUI23A[4U] ;
#line 97
unsigned char WMM_INFO_OUI23A[6U] ;
#line 98
unsigned char WMM_PARA_OUI23A[6U] ;
#line 369
int rtw_ch_set_search_ch23a(struct rt_channel_info *ch_set , u32 const   ch ) ;
#line 447
int init_mlme_ext_priv23a(struct rtw_adapter *padapter ) ;
#line 448
int init_hw_mlme_ext23a(struct rtw_adapter *padapter ) ;
#line 449
void free_mlme_ext_priv23a(struct mlme_ext_priv *pmlmeext ) ;
#line 450
void init_mlme_ext_timer23a(struct rtw_adapter *padapter ) ;
#line 451
void init_addba_retry_timer23a(struct sta_info *psta ) ;
#line 452
struct xmit_frame *alloc_mgtxmitframe23a(struct xmit_priv *pxmitpriv ) ;
#line 457
void get_rate_set23a(struct rtw_adapter *padapter , unsigned char *pbssrate , int *bssrate_len ) ;
#line 459
void UpdateBrateTbl23a(struct rtw_adapter *Adapter , u8 *mBratesOS ) ;
#line 460
void Update23aTblForSoftAP(u8 *bssrateset , u32 bssratelen ) ;
#line 462
extern u8 rtw_get_oper_ch23a(struct rtw_adapter * ) ;
#line 469
void set_channel_bwmode23a(struct rtw_adapter *padapter , unsigned char channel ,
                           unsigned char channel_offset , unsigned short bwmode ) ;
#line 471
void SelectChannel23a(struct rtw_adapter *padapter , unsigned char channel ) ;
#line 473
unsigned int decide_wait_for_beacon_timeout23a(unsigned int bcn_interval ) ;
#line 479
int allocate_fw_sta_entry23a(struct rtw_adapter *padapter ) ;
#line 480
void flush_all_cam_entry23a(struct rtw_adapter *padapter ) ;
#line 482
bool IsLegal5GChannel(struct rtw_adapter *Adapter , u8 channel ) ;
#line 487
extern u8 *get_my_bssid23a(struct wlan_bssid_ex * ) ;
#line 489
bool is_client_associated_to_ap23a(struct rtw_adapter *padapter ) ;
#line 490
bool is_client_associated_to_ibss23a(struct rtw_adapter *padapter ) ;
#line 491
bool is_IBSS_empty23a(struct rtw_adapter *padapter ) ;
#line 495
int WMM_param_handler23a(struct rtw_adapter *padapter , u8 const   *p ) ;
#line 496
void WMMOnAssocRsp23a(struct rtw_adapter *padapter ) ;
#line 498
void HT_caps_handler23a(struct rtw_adapter *padapter , u8 const   *p ) ;
#line 499
void HT_info_handler23a(struct rtw_adapter *padapter , u8 const   *p ) ;
#line 500
void HTOnAssocRsp23a(struct rtw_adapter *padapter ) ;
#line 502
void ERP_IE_handler23a(struct rtw_adapter *padapter , u8 const   *p ) ;
#line 503
void VCS_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 505
void update_beacon23a_info(struct rtw_adapter *padapter , struct ieee80211_mgmt *mgmt ,
                           uint pkt_len , struct sta_info *psta ) ;
#line 508
int rtw_check_bcn_info23a(struct rtw_adapter *Adapter , struct ieee80211_mgmt *mgmt ,
                          u32 pkt_len ) ;
#line 510
void update_IOT_info23a(struct rtw_adapter *padapter ) ;
#line 511
void update_capinfo23a(struct rtw_adapter *Adapter , u16 updateCap ) ;
#line 512
void update_wireless_mode23a(struct rtw_adapter *padapter ) ;
#line 513
void update_tx_basic_rate23a(struct rtw_adapter *padapter , u8 wirelessmode ) ;
#line 514
void update_bmc_sta_support_rate23a(struct rtw_adapter *padapter , u32 mac_id ) ;
#line 515
int update_sta_support_rate23a(struct rtw_adapter *padapter , u8 *pvar_ie , uint var_ie_len ,
                               int cam_idx ) ;
#line 523
void Update_RA_Entry23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 524
void set_sta_rate23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 526
int receive_disconnect23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                          unsigned short reason ) ;
#line 530
int support_short_GI23a(struct rtw_adapter *padapter , struct ieee80211_ht_cap *pHT_caps ) ;
#line 532
bool is_ap_in_tkip23a(struct rtw_adapter *padapter ) ;
#line 536
void report_join_res23a(struct rtw_adapter *padapter , int res ) ;
#line 537
void report_survey_event23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 539
void report_surveydone_event23a(struct rtw_adapter *padapter ) ;
#line 540
void report_del_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             unsigned short reason ) ;
#line 542
void report_add_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             int cam_idx ) ;
#line 545
int set_tx_beacon_cmd23a(struct rtw_adapter *padapter ) ;
#line 548
void update_mgnt_tx_rate23a(struct rtw_adapter *padapter , u8 rate ) ;
#line 549
void update_mgntframe_attrib23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) ;
#line 551
void dump_mgntframe23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) ;
#line 553
s32 dump_mgntframe23a_and_wait(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ,
                               int timeout_ms ) ;
#line 555
s32 dump_mgntframe23a_and_wait_ack23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) ;
#line 558
void issue_beacon23a(struct rtw_adapter *padapter , int timeout_ms ) ;
#line 559
int issue_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , unsigned int power_mode ,
                      int try_cnt , int wait_ms ) ;
#line 561
int issue_qos_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , u16 tid ,
                          int try_cnt , int wait_ms ) ;
#line 563
int issue_deauth23a(struct rtw_adapter *padapter , unsigned char *da , unsigned short reason ) ;
#line 565
void issue_action_spct_ch_switch23a(struct rtw_adapter *padapter , u8 *ra , u8 new_ch ,
                                    u8 ch_offset ) ;
#line 567
void issue_action_BA23a(struct rtw_adapter *padapter , unsigned char const   *raddr ,
                        unsigned char action , unsigned short status ) ;
#line 570
int send_delba23a(struct rtw_adapter *padapter , u8 initiator , u8 *addr ) ;
#line 571
int send_beacon23a(struct rtw_adapter *padapter ) ;
#line 590
void process_addba_req23a(struct rtw_adapter *padapter , u8 *paddba_req , u8 *addr ) ;
#line 26 "drivers/staging/rtl8723au/include/rtw_ap.h"
void init_mlme_ap_info23a(struct rtw_adapter *padapter ) ;
#line 42
void associated_clients_update23a(struct rtw_adapter *padapter , u8 updated ) ;
#line 43
void bss_cap_update_on_sta_join23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 45
void sta_info_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 47
u8 ap_free_sta23a(struct rtw_adapter *padapter , struct sta_info *psta , bool active ,
                  u16 reason ) ;
#line 58 "drivers/staging/rtl8723au/include/ioctl_cfg80211.h"
void rtw_cfg80211_indicate_sta_assoc(struct rtw_adapter *padapter , u8 *pmgmt_frame ,
                                     uint frame_len ) ;
#line 217 "drivers/staging/rtl8723au/include/rtl8723a_xmit.h"
int rtl8723au_hal_xmitframe_enqueue(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 221
int rtl8723au_mgnt_xmit(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) ;
#line 526 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
void rtl8723a_SetBeaconRelatedRegisters(struct rtw_adapter *padapter ) ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnAssocReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 28
static int OnAssocRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 29
static int OnProbeReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 30
static int OnProbeRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 31
static int DoReserved23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 32
static int OnBeacon23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 33
static int OnAtim23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 34
static int OnDisassoc23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 35
static int OnAuth23aClient23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 36
static int OnDeAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 37
static int OnAction23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 39
static int on_action_spct23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 40
static int OnAction23a_qos(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 41
static int OnAction23a_dls(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 42
static int OnAction23a_back23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 43
static int on_action_public23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 44
static int OnAction23a_ht(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 45
static int OnAction23a_wmm(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 46
static int OnAction23a_p2p(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 48
static void issue_assocreq(struct rtw_adapter *padapter ) ;
#line 49
__inline static void issue_probereq(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                                    u8 *da ) ;
#line 51
static int issue_probereq_ex(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                             u8 *da , int try_cnt , int wait_ms ) ;
#line 54
static void issue_probersp(struct rtw_adapter *padapter , unsigned char *da ) ;
#line 55
static void issue_auth(struct rtw_adapter *padapter , struct sta_info *psta , unsigned short status ) ;
#line 57
static int issue_deauth_ex(struct rtw_adapter *padapter , u8 *da , unsigned short reason ,
                           int try_cnt , int wait_ms ) ;
#line 59
static void start_clnt_assoc(struct rtw_adapter *padapter ) ;
#line 60
static void start_clnt_auth(struct rtw_adapter *padapter ) ;
#line 61
static void start_clnt_join(struct rtw_adapter *padapter ) ;
#line 62
static void start_create_ibss(struct rtw_adapter *padapter ) ;
#line 63
static struct wlan_bssid_ex *collect_bss_info(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 67
static int OnAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 68
static void issue_assocrsp(struct rtw_adapter *padapter , unsigned short status ,
                           struct sta_info *pstat , u16 pkt_type ) ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static struct mlme_handler mlme_sta_tbl[14U]  = 
#line 72
  {      {(char *)"OnAssocReq23a", & OnAssocReq23a}, 
        {(char *)"OnAssocRsp23a", & OnAssocRsp23a}, 
        {(char *)"OnReAssocReq", & OnAssocReq23a}, 
        {(char *)"OnReAssocRsp", & OnAssocRsp23a}, 
        {(char *)"OnProbeReq23a", & OnProbeReq23a}, 
        {(char *)"OnProbeRsp23a", & OnProbeRsp23a}, 
        {(char *)"DoReserved23a", & DoReserved23a}, 
        {(char *)"DoReserved23a", & DoReserved23a}, 
        {(char *)"OnBeacon23a", & OnBeacon23a}, 
        {(char *)"OnATIM", & OnAtim23a}, 
        {(char *)"OnDisassoc23a", & OnDisassoc23a}, 
        {(char *)"OnAuth23a", & OnAuth23aClient23a}, 
        {(char *)"OnDeAuth23a", & OnDeAuth23a}, 
        {(char *)"OnAction23a", & OnAction23a}};
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static struct action_handler OnAction23a_tbl[9U]  = 
#line 93
  {      {0U, (char *)"ACTION_SPECTRUM_MGMT", & on_action_spct23a}, 
        {1U, (char *)"ACTION_QOS", & OnAction23a_qos}, 
        {2U, (char *)"ACTION_DLS", & OnAction23a_dls}, 
        {3U, (char *)"ACTION_BACK", & OnAction23a_back23a}, 
        {4U, (char *)"ACTION_PUBLIC", & on_action_public23a}, 
        {7U, (char *)"ACTION_HT", & OnAction23a_ht}, 
        {8U, (char *)"ACTION_SA_QUERY", & DoReserved23a}, 
        {17U, (char *)"ACTION_WMM", & OnAction23a_wmm}, 
        {127U, (char *)"ACTION_P2P", & OnAction23a_p2p}};
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static u8 null_addr[6U]  = {      0U,      0U,      0U,      0U, 
        0U,      0U};
#line 110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
unsigned char WMM_OUI23A[4U]  = {      0U,      80U,      242U,      2U};
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
unsigned char WPS_OUI23A[4U]  = {      0U,      80U,      242U,      4U};
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
unsigned char P2P_OUI23A[4U]  = {      80U,      111U,      154U,      9U};
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
unsigned char WFD_OUI23A[4U]  = {      80U,      111U,      154U,      10U};
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
unsigned char WMM_INFO_OUI23A[6U]  = {      0U,      80U,      242U,      2U, 
        0U,      1U};
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
unsigned char WMM_PARA_OUI23A[6U]  = {      0U,      80U,      242U,      2U, 
        1U,      1U};
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static unsigned char REALTEK_96B_IE[6U]  = {      0U,      224U,      76U,      2U, 
        1U,      32U};
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
unsigned char MCS_rate_2R23A[16U]  = 
#line 123
  {      255U,      255U,      0U,      0U, 
        1U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U};
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
unsigned char MCS_rate_1R23A[16U]  = 
#line 126
  {      255U,      0U,      0U,      0U, 
        1U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U};
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static struct rt_channel_plan_2g RTW_ChannelPlan2G[6U]  = {      {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U, 12U, 13U}, 13U}, 
        {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U, 12U, 13U}, 13U}, 
        {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U}, 11U}, 
        {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U, 12U, 13U, 14U}, 14U}, 
        {{10U, 11U, 12U, 13U}, 4U}, 
        {{(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, 0U}};
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static struct rt_channel_plan_5g RTW_ChannelPlan5G[20U]  = 
#line 149
  {      {{(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, 0U}, 
        {{36U,
       40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U, 124U,
       128U, 132U, 136U, 140U}, 19U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 136U, 140U, 149U, 153U, 157U, 161U, 165U}, 24U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 149U, 153U, 157U, 161U, 165U}, 22U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 136U, 140U, 149U, 153U, 157U, 161U, 165U}, 24U}, 
        {{36U, 40U, 44U, 48U, 149U, 153U, 157U, 161U, 165U}, 9U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 149U, 153U, 157U, 161U, 165U}, 13U}, 
        {{36U,
       40U, 44U, 48U, 52U, 56U, 60U, 64U, 149U, 153U, 157U, 161U}, 12U}, 
        {{149U, 153U, 157U, 161U, 165U}, 5U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U}, 8U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 136U,
       140U, 149U, 153U, 157U, 161U, 165U}, 20U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 149U, 153U, 157U, 161U, 165U}, 20U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 136U, 140U}, 19U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U}, 8U}, 
        {{100U, 104U, 108U, 112U, 116U, 120U, 124U, 128U, 132U, 136U, 140U}, 11U}, 
        {{56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 136U, 140U, 149U, 153U, 157U,
       161U, 165U}, 15U}, 
        {{56U, 60U, 64U, 149U, 153U, 157U, 161U, 165U}, 8U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 132U,
       136U, 140U, 149U, 153U, 157U, 161U, 165U}, 21U}, 
        {{36U, 40U, 44U, 48U}, 4U}, 
        {{36U, 40U, 44U, 48U, 149U, 153U, 157U, 161U}, 8U}};
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static struct rt_channel_plan_map RTW_ChannelPlanMap[66U]  = 
#line 204
  {      {2U, 17U}, 
        {2U, 10U}, 
        {1U, 1U}, 
        {1U, 0U}, 
        {1U, 0U}, 
        {3U, 0U}, 
        {3U, 0U}, 
        {1U, 9U}, 
        {3U, 9U}, 
        {3U, 0U}, 
        {0U, 0U}, 
        {2U, 15U}, 
        {1U, 8U}, 
        {2U, 6U}, 
        {2U, 11U}, 
        {2U, 9U}, 
        {1U, 1U}, 
        {2U, 5U}, 
        {1U, 18U}, 
        {0U, 4U}, 
        {2U, 16U}, 
        {0U, 18U}, 
        {0U, 19U}, 
        {3U, 18U}, 
        {5U, 8U}, 
        {2U, 8U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {5U, 4U}, 
        {0U, 0U}, 
        {1U, 0U}, 
        {2U, 0U}, 
        {3U, 0U}, 
        {4U, 0U}, 
        {2U, 4U}, 
        {0U, 1U}, 
        {3U, 12U}, 
        {0U, 11U}, 
        {0U, 5U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 6U}, 
        {0U, 7U}, 
        {0U, 8U}, 
        {0U, 9U}, 
        {2U, 10U}, 
        {0U, 2U}, 
        {0U, 3U}, 
        {3U, 13U}, 
        {3U, 14U}, 
        {2U, 15U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {2U, 16U}, 
        {3U, 0U}};
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static struct rt_channel_plan_map RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE  =    {3U, 2U};
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void dummy_event_callback(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 


  {
#line 280
  return;
}
}
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static struct fwevent wlanevents[25U]  = 
#line 282
  {      {0U, & dummy_event_callback}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, & rtw_survey_event_cb23a}, 
        {4U, & rtw_surveydone_event_callback23a}, 
        {0U, & rtw23a_joinbss_event_cb}, 
        {12U, & rtw_stassoc_event_callback23a}, 
        {12U, & rtw_stadel_event_callback23a}, 
        {0U, & dummy_event_callback}, 
        {0U, & dummy_event_callback}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, & dummy_event_callback}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, & dummy_event_callback}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}};
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void rtw_correct_TSF(struct rtw_adapter *padapter ) 
{ 


  {
#line 314
  hw_var_set_correct_tsf(padapter);
#line 315
  return;
}
}
#line 318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void rtw_update_TSF(struct mlme_ext_priv *pmlmeext , struct ieee80211_mgmt *mgmt ) 
{ 


  {
#line 320
  pmlmeext->TSFValue = get_unaligned_le64((void const   *)(& mgmt->u.beacon.timestamp));
#line 321
  return;
}
}
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int rtw_ch_set_search_ch23a(struct rt_channel_info *ch_set , u32 const   ch ) 
{ 
  int i ;

  {
#line 334
  i = 0;
#line 334
  goto ldv_55968;
  ldv_55967: ;
#line 335
  if ((unsigned int )(ch_set + (unsigned long )i)->ChannelNum == (unsigned int )ch) {
#line 336
    goto ldv_55966;
  } else {

  }
#line 334
  i = i + 1;
  ldv_55968: ;
#line 334
  if ((unsigned int )(ch_set + (unsigned long )i)->ChannelNum != 0U) {
#line 336
    goto ldv_55967;
  } else {

  }
  ldv_55966: ;
#line 339
  if ((int )(ch_set + (unsigned long )i)->ChannelNum <= i) {
#line 340
    return (-1);
  } else {

  }
#line 341
  return (i);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int init_hw_mlme_ext23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
#line 352
  pmlmeext = & padapter->mlmeextpriv;
#line 354
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
#line 356
  return (1);
}
}
#line 359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void init_mlme_ext_priv23a_value(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned char mixed_datarate[13U] ;
  unsigned char mixed_basicrate[13U] ;
  unsigned int tmp ;

  {
#line 361
  pmlmeext = & padapter->mlmeextpriv;
#line 362
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 363
  mixed_datarate[0] = 0U;
#line 363
  mixed_datarate[1] = 1U;
#line 363
  mixed_datarate[2] = 2U;
#line 363
  mixed_datarate[3] = 3U;
#line 363
  mixed_datarate[4] = 4U;
#line 363
  mixed_datarate[5] = 5U;
#line 363
  mixed_datarate[6] = 6U;
#line 363
  mixed_datarate[7] = 7U;
#line 363
  mixed_datarate[8] = 8U;
#line 363
  mixed_datarate[9] = 9U;
#line 363
  mixed_datarate[10] = 10U;
#line 363
  mixed_datarate[11] = 11U;
#line 363
  mixed_datarate[12] = 255U;
#line 367
  mixed_basicrate[0] = 0U;
#line 367
  mixed_basicrate[1] = 1U;
#line 367
  mixed_basicrate[2] = 2U;
#line 367
  mixed_basicrate[3] = 3U;
#line 367
  mixed_basicrate[4] = 4U;
#line 367
  mixed_basicrate[5] = 6U;
#line 367
  mixed_basicrate[6] = 8U;
#line 367
  mixed_basicrate[7] = 255U;
#line 367
  tmp = 8U;
#line 367
  while (1) {
#line 367
    if (tmp >= 13U) {
#line 367
      break;
    } else {

    }
#line 367
    mixed_basicrate[tmp] = (unsigned char)0;
#line 367
    tmp = tmp + 1U;
  }
#line 371
  atomic_set(& pmlmeext->event_seq, 0);
#line 373
  pmlmeext->mgnt_seq = 0U;
#line 375
  pmlmeext->cur_channel = padapter->registrypriv.channel;
#line 376
  pmlmeext->cur_bwmode = 0U;
#line 377
  pmlmeext->cur_ch_offset = 0U;
#line 379
  pmlmeext->retry = 0U;
#line 381
  pmlmeext->cur_wireless_mode = padapter->registrypriv.wireless_mode;
#line 383
  memcpy((void *)(& pmlmeext->datarate), (void const   *)(& mixed_datarate), 13UL);
#line 384
  memcpy((void *)(& pmlmeext->basicrate), (void const   *)(& mixed_basicrate), 13UL);
#line 386
  if ((unsigned int )pmlmeext->cur_channel > 14U) {
#line 387
    pmlmeext->tx_rate = 12U;
  } else {
#line 389
    pmlmeext->tx_rate = 2U;
  }
#line 391
  pmlmeext->sitesurvey_res.state = 0;
#line 392
  pmlmeext->sitesurvey_res.channel_idx = 0;
#line 393
  pmlmeext->sitesurvey_res.bss_cnt = 0;
#line 394
  pmlmeext->scan_abort = 0U;
#line 396
  pmlmeinfo->state = 0U;
#line 397
  pmlmeinfo->reauth_count = 0U;
#line 398
  pmlmeinfo->reassoc_count = 0U;
#line 399
  pmlmeinfo->link_count = 0U;
#line 400
  pmlmeinfo->auth_seq = 0U;
#line 401
  pmlmeinfo->auth_algo = 0U;
#line 402
  pmlmeinfo->key_index = 0U;
#line 403
  pmlmeinfo->iv = 0U;
#line 405
  pmlmeinfo->enc_algo = 0U;
#line 406
  pmlmeinfo->authModeToggle = 0U;
#line 408
  memset((void *)(& pmlmeinfo->chg_txt), 0, 128UL);
#line 410
  pmlmeinfo->slotTime = 9U;
#line 411
  pmlmeinfo->preamble_mode = 2U;
#line 413
  pmlmeinfo->dialogToken = 0U;
#line 415
  pmlmeext->action_public_rxseq = 65535U;
#line 416
  pmlmeext->action_public_dialog_token = 255U;
#line 417
  return;
}
}
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int has_channel(struct rt_channel_info *channel_set , u8 chanset_size , u8 chan ) 
{ 
  int i ;

  {
#line 423
  i = 0;
#line 423
  goto ldv_55987;
  ldv_55986: ;
#line 424
  if ((int )(channel_set + (unsigned long )i)->ChannelNum == (int )chan) {
#line 425
    return (1);
  } else {

  }
#line 423
  i = i + 1;
  ldv_55987: ;
#line 423
  if ((int )chanset_size > i) {
#line 425
    goto ldv_55986;
  } else {

  }

#line 428
  return (0);
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void init_channel_list(struct rtw_adapter *padapter , struct rt_channel_info *channel_set ,
                              u8 chanset_size , struct p2p_channels *channel_list ) 
{ 
  struct p2p_oper_class_map op_class[10U] ;
  int cla ;
  int op ;
  u8 ch ;
  struct p2p_oper_class_map *o ;
  struct p2p_reg_class *reg ;
  int tmp ;

  {
#line 436
  op_class[0].mode = 0;
#line 436
  op_class[0].op_class = 81U;
#line 436
  op_class[0].min_chan = 1U;
#line 436
  op_class[0].max_chan = 13U;
#line 436
  op_class[0].inc = 1U;
#line 436
  op_class[0].bw = 0;
#line 436
  op_class[1].mode = 0;
#line 436
  op_class[1].op_class = 82U;
#line 436
  op_class[1].min_chan = 14U;
#line 436
  op_class[1].max_chan = 14U;
#line 436
  op_class[1].inc = 1U;
#line 436
  op_class[1].bw = 0;
#line 436
  op_class[2].mode = 1;
#line 436
  op_class[2].op_class = 115U;
#line 436
  op_class[2].min_chan = 36U;
#line 436
  op_class[2].max_chan = 48U;
#line 436
  op_class[2].inc = 4U;
#line 436
  op_class[2].bw = 0;
#line 436
  op_class[3].mode = 1;
#line 436
  op_class[3].op_class = 116U;
#line 436
  op_class[3].min_chan = 36U;
#line 436
  op_class[3].max_chan = 44U;
#line 436
  op_class[3].inc = 8U;
#line 436
  op_class[3].bw = 1;
#line 436
  op_class[4].mode = 1;
#line 436
  op_class[4].op_class = 117U;
#line 436
  op_class[4].min_chan = 40U;
#line 436
  op_class[4].max_chan = 48U;
#line 436
  op_class[4].inc = 8U;
#line 436
  op_class[4].bw = 2;
#line 436
  op_class[5].mode = 1;
#line 436
  op_class[5].op_class = 124U;
#line 436
  op_class[5].min_chan = 149U;
#line 436
  op_class[5].max_chan = 161U;
#line 436
  op_class[5].inc = 4U;
#line 436
  op_class[5].bw = 0;
#line 436
  op_class[6].mode = 1;
#line 436
  op_class[6].op_class = 125U;
#line 436
  op_class[6].min_chan = 149U;
#line 436
  op_class[6].max_chan = 169U;
#line 436
  op_class[6].inc = 4U;
#line 436
  op_class[6].bw = 0;
#line 436
  op_class[7].mode = 1;
#line 436
  op_class[7].op_class = 126U;
#line 436
  op_class[7].min_chan = 149U;
#line 436
  op_class[7].max_chan = 157U;
#line 436
  op_class[7].inc = 8U;
#line 436
  op_class[7].bw = 1;
#line 436
  op_class[8].mode = 1;
#line 436
  op_class[8].op_class = 127U;
#line 436
  op_class[8].min_chan = 153U;
#line 436
  op_class[8].max_chan = 161U;
#line 436
  op_class[8].inc = 8U;
#line 436
  op_class[8].bw = 2;
#line 436
  op_class[9].mode = 4294967295L;
#line 436
  op_class[9].op_class = 0U;
#line 436
  op_class[9].min_chan = 0U;
#line 436
  op_class[9].max_chan = 0U;
#line 436
  op_class[9].inc = 0U;
#line 436
  op_class[9].bw = 0;
#line 451
  cla = 0;
#line 453
  op = 0;
#line 453
  goto ldv_56006;
  ldv_56005: 
#line 455
  o = (struct p2p_oper_class_map *)(& op_class) + (unsigned long )op;
#line 456
  reg = (struct p2p_reg_class *)0;
#line 458
  ch = o->min_chan;
#line 458
  goto ldv_56003;
  ldv_56002: 
#line 459
  tmp = has_channel(channel_set, (int )chanset_size, (int )ch);
#line 459
  if (tmp == 0) {
#line 460
    goto ldv_56001;
  } else {

  }
#line 462
  if ((unsigned int )padapter->registrypriv.ht_enable == 0U && (unsigned int )o->inc == 8U) {
#line 464
    goto ldv_56001;
  } else {

  }
#line 466
  if (((unsigned long )padapter->registrypriv.cbw40_enable & 2UL) == 0UL && ((unsigned int )o->bw == 2U || (unsigned int )o->bw == 1U)) {
#line 468
    goto ldv_56001;
  } else {

  }
#line 470
  if ((unsigned long )reg == (unsigned long )((struct p2p_reg_class *)0)) {
#line 471
    reg = (struct p2p_reg_class *)(& channel_list->reg_class) + (unsigned long )cla;
#line 472
    cla = cla + 1;
#line 473
    reg->reg_class = o->op_class;
#line 474
    reg->channels = 0UL;
  } else {

  }
#line 476
  reg->channel[reg->channels] = ch;
#line 477
  reg->channels = reg->channels + 1UL;
  ldv_56001: 
#line 458
  ch = (int )o->inc + (int )ch;
  ldv_56003: ;
#line 458
  if ((int )o->max_chan >= (int )ch) {
#line 460
    goto ldv_56002;
  } else {

  }
#line 453
  op = op + 1;
  ldv_56006: ;
#line 453
  if ((unsigned int )op_class[op].op_class != 0U) {
#line 455
    goto ldv_56005;
  } else {

  }
#line 480
  channel_list->reg_classes = (size_t )cla;
#line 481
  return;
}
}
#line 483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static u8 init_channel_set(struct rtw_adapter *padapter , u8 cplan , struct rt_channel_info *c_set ) 
{ 
  u8 i ;
  u8 ch_size ;
  u8 b5GBand ;
  u8 b2_4GBand ;
  u8 Index2G ;
  u8 Index5G ;

  {
#line 486
  ch_size = 0U;
#line 487
  b5GBand = 0U;
#line 487
  b2_4GBand = 0U;
#line 488
  Index2G = 0U;
#line 488
  Index5G = 0U;
#line 490
  memset((void *)c_set, 0, 304UL);
#line 492
  if ((unsigned int )cplan > 65U && (unsigned int )cplan != 127U) {
#line 494
    if (GlobalDebugLevel23A > 3U) {
#line 494
      printk("\016RTL8723AU: ChannelPlan ID %x error !!!!!\n", (int )cplan);
    } else {

    }
#line 495
    return (ch_size);
  } else {

  }
#line 498
  if (((int )padapter->registrypriv.wireless_mode & 2) != 0) {
#line 499
    b2_4GBand = 1U;
#line 500
    if ((unsigned int )cplan == 127U) {
#line 501
      Index2G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index2G;
    } else {
#line 503
      Index2G = RTW_ChannelPlanMap[(int )cplan].Index2G;
    }
  } else {

  }
#line 506
  if (((int )padapter->registrypriv.wireless_mode & 4) != 0) {
#line 507
    b5GBand = 1U;
#line 508
    if ((unsigned int )cplan == 127U) {
#line 509
      Index5G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index5G;
    } else {
#line 511
      Index5G = RTW_ChannelPlanMap[(int )cplan].Index5G;
    }
  } else {

  }
#line 514
  if ((unsigned int )b2_4GBand != 0U) {
#line 515
    i = 0U;
#line 515
    goto ldv_56020;
    ldv_56019: 
#line 516
    (c_set + (unsigned long )ch_size)->ChannelNum = RTW_ChannelPlan2G[(int )Index2G].Channel[(int )i];
#line 519
    if ((unsigned int )cplan == 9U || (unsigned int )cplan == 65U) {
#line 522
      if ((unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum != 0U && (unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum <= 11U) {
#line 524
        (c_set + (unsigned long )ch_size)->ScanType = 1;
      } else
#line 525
      if ((unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum > 11U && (unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum <= 14U) {
#line 527
        (c_set + (unsigned long )ch_size)->ScanType = 0;
      } else {

      }
    } else
#line 528
    if (((unsigned int )cplan == 10U || (unsigned int )cplan == 19U) || (unsigned int )Index2G == 0U) {
#line 532
      if ((unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum <= 11U) {
#line 533
        (c_set + (unsigned long )ch_size)->ScanType = 1;
      } else {
#line 535
        (c_set + (unsigned long )ch_size)->ScanType = 0;
      }
    } else {
#line 537
      (c_set + (unsigned long )ch_size)->ScanType = 1;
    }
#line 539
    ch_size = (u8 )((int )ch_size + 1);
#line 515
    i = (u8 )((int )i + 1);
    ldv_56020: ;
#line 515
    if ((int )RTW_ChannelPlan2G[(int )Index2G].Len > (int )i) {
#line 517
      goto ldv_56019;
    } else {

    }

  } else {

  }
#line 543
  if ((unsigned int )b5GBand != 0U) {
#line 544
    i = 0U;
#line 544
    goto ldv_56024;
    ldv_56023: ;
#line 545
    if ((unsigned int )RTW_ChannelPlan5G[(int )Index5G].Channel[(int )i] <= 48U || (unsigned int )RTW_ChannelPlan5G[(int )Index5G].Channel[(int )i] > 148U) {
#line 547
      (c_set + (unsigned long )ch_size)->ChannelNum = RTW_ChannelPlan5G[(int )Index5G].Channel[(int )i];
#line 549
      if ((unsigned int )cplan == 19U) {
#line 551
        (c_set + (unsigned long )ch_size)->ScanType = 0;
      } else {
#line 554
        (c_set + (unsigned long )ch_size)->ScanType = 1;
      }
#line 556
      if (GlobalDebugLevel23A > 3U) {
#line 556
        printk("\016RTL8723AU: %s(): channel_set[%d].ChannelNum = %d\n", "init_channel_set",
               (int )ch_size, (int )(c_set + (unsigned long )ch_size)->ChannelNum);
      } else {

      }
#line 559
      ch_size = (u8 )((int )ch_size + 1);
    } else {

    }
#line 544
    i = (u8 )((int )i + 1);
    ldv_56024: ;
#line 544
    if ((int )RTW_ChannelPlan5G[(int )Index5G].Len > (int )i) {
#line 546
      goto ldv_56023;
    } else {

    }

  } else {

  }
#line 564
  return (ch_size);
}
}
#line 567 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int init_mlme_ext_priv23a(struct rtw_adapter *padapter ) 
{ 
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 569
  pregistrypriv = & padapter->registrypriv;
#line 570
  pmlmeext = & padapter->mlmeextpriv;
#line 571
  pmlmepriv = & padapter->mlmepriv;
#line 572
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 574
  pmlmeext->padapter = padapter;
#line 576
  init_mlme_ext_priv23a_value(padapter);
#line 577
  pmlmeinfo->bAcceptAddbaReq = pregistrypriv->bAcceptAddbaReq;
#line 579
  init_mlme_ext_timer23a(padapter);
#line 582
  init_mlme_ap_info23a(padapter);
#line 585
  pmlmeext->max_chan_nums = init_channel_set(padapter, (int )pmlmepriv->ChannelPlan,
                                             (struct rt_channel_info *)(& pmlmeext->channel_set));
#line 588
  init_channel_list(padapter, (struct rt_channel_info *)(& pmlmeext->channel_set),
                    (int )pmlmeext->max_chan_nums, & pmlmeext->channel_list);
#line 591
  pmlmeext->chan_scan_time = 100U;
#line 592
  pmlmeext->mlmeext_init = 1U;
#line 594
  pmlmeext->active_keep_alive_check = 1U;
#line 595
  return (1);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void free_mlme_ext_priv23a(struct mlme_ext_priv *pmlmeext ) 
{ 
  struct rtw_adapter *padapter ;

  {
#line 600
  padapter = pmlmeext->padapter;
#line 602
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 603
    return;
  } else {

  }
#line 605
  if (padapter->bDriverStopped == 1) {
#line 606
    ldv_del_timer_sync_102(& pmlmeext->survey_timer);
#line 607
    ldv_del_timer_sync_103(& pmlmeext->link_timer);
  } else {

  }
#line 609
  return;
}
}
#line 613 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void _mgt_dispatcher23a(struct rtw_adapter *padapter , struct mlme_handler *ptable ,
                               struct recv_frame *precv_frame ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 616
  skb = precv_frame->pkt;
#line 617
  hdr = (struct ieee80211_hdr *)skb->data;
#line 619
  if ((unsigned long )ptable->func != (unsigned long )((int (*)(struct rtw_adapter * ,
                                                                struct recv_frame * ))0)) {
#line 622
    tmp = myid(& padapter->eeprompriv);
#line 622
    tmp___0 = ether_addr_equal((u8 const   *)(& hdr->addr1), (u8 const   *)tmp);
#line 622
    if (tmp___0) {
#line 622
      tmp___1 = 0;
    } else {
#line 622
      tmp___1 = 1;
    }
#line 622
    if (tmp___1) {
#line 622
      tmp___2 = is_broadcast_ether_addr((u8 const   *)(& hdr->addr1));
#line 622
      if (tmp___2) {
#line 622
        tmp___3 = 0;
      } else {
#line 622
        tmp___3 = 1;
      }
#line 622
      if (tmp___3) {
#line 624
        return;
      } else {

      }
    } else {

    }
#line 626
    (*(ptable->func))(padapter, precv_frame);
  } else {

  }
#line 628
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void mgt_dispatcher23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct mlme_handler *ptable ;
  struct mlme_priv *pmlmepriv ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  struct sta_info *psta ;
  u16 stype ;
  int index ;
  int tmp ;
  u8 *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;

  {
#line 635
  pmlmepriv = & padapter->mlmepriv;
#line 637
  skb = precv_frame->pkt;
#line 638
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 643
  tmp = ieee80211_is_mgmt((int )mgmt->frame_control);
#line 643
  if (tmp == 0) {
#line 644
    return;
  } else {

  }
#line 648
  tmp___0 = myid(& padapter->eeprompriv);
#line 648
  tmp___1 = ether_addr_equal((u8 const   *)(& mgmt->da), (u8 const   *)tmp___0);
#line 648
  if (tmp___1) {
#line 648
    tmp___2 = 0;
  } else {
#line 648
    tmp___2 = 1;
  }
#line 648
  if (tmp___2) {
#line 648
    tmp___3 = is_broadcast_ether_addr((u8 const   *)(& mgmt->da));
#line 648
    if (tmp___3) {
#line 648
      tmp___4 = 0;
    } else {
#line 648
      tmp___4 = 1;
    }
#line 648
    if (tmp___4) {
#line 650
      return;
    } else {

    }
  } else {

  }
#line 652
  ptable = (struct mlme_handler *)(& mlme_sta_tbl);
#line 654
  stype = (unsigned int )mgmt->frame_control & 240U;
#line 655
  index = (int )stype >> 4;
#line 657
  if (index > 13) {
#line 658
    if (GlobalDebugLevel23A > 3U) {
#line 658
      rt_trace(16, 4, "Currently we do not support reserved sub-fr-type =%d\n", index);
    } else {

    }
#line 661
    return;
  } else {

  }
#line 663
  ptable = ptable + (unsigned long )index;
#line 665
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& mgmt->sa));
#line 667
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 668
    tmp___5 = ieee80211_has_retry((int )mgmt->frame_control);
#line 668
    if (tmp___5 != 0) {
#line 669
      if ((int )precv_frame->attrib.seq_num == (int )psta->RxMgmtFrameSeqNum) {
#line 672
        if (GlobalDebugLevel23A > 3U) {
#line 672
          printk("\016RTL8723AU: Drop duplicate management frame with seq_num = %d.\n",
                 (int )precv_frame->attrib.seq_num);
        } else {

        }
#line 675
        return;
      } else {

      }
    } else {

    }
#line 678
    psta->RxMgmtFrameSeqNum = precv_frame->attrib.seq_num;
  } else {

  }
#line 682
  switch ((int )stype) {
  case 176: 
#line 684
  tmp___6 = check_fwstate(pmlmepriv, 16);
#line 684
  if ((int )tmp___6) {
#line 685
    ptable->func = & OnAuth23a;
  } else {
#line 687
    ptable->func = & OnAuth23aClient23a;
  }
  case 0: ;
  case 32: 
#line 691
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
#line 692
  goto ldv_56058;
  case 64: 
#line 694
  tmp___7 = check_fwstate(pmlmepriv, 16);
#line 694
  if ((int )tmp___7) {
#line 695
    _mgt_dispatcher23a(padapter, ptable, precv_frame);
  } else {
#line 697
    _mgt_dispatcher23a(padapter, ptable, precv_frame);
  }
#line 698
  goto ldv_56058;
  case 128: 
#line 700
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
#line 701
  goto ldv_56058;
  case 208: 
#line 704
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
#line 705
  goto ldv_56058;
  default: 
#line 707
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
#line 708
  goto ldv_56058;
  }
  ldv_56058: ;
#line 714
  return;
}
}
#line 722 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnProbeReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  u8 const   *ie ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  int len ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;

  {
#line 725
  pmlmepriv = & padapter->mlmepriv;
#line 726
  pmlmeext = & padapter->mlmeextpriv;
#line 727
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 728
  cur = & pmlmeinfo->network;
#line 729
  skb = precv_frame->pkt;
#line 730
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 731
  len = (int )skb->len;
#line 733
  tmp = check_fwstate(pmlmepriv, 8);
#line 733
  if ((int )tmp) {
#line 734
    return (1);
  } else {

  }
#line 736
  tmp___0 = check_fwstate(pmlmepriv, 1);
#line 736
  if (tmp___0) {
#line 736
    tmp___1 = 0;
  } else {
#line 736
    tmp___1 = 1;
  }
#line 736
  if (tmp___1) {
#line 736
    tmp___2 = check_fwstate(pmlmepriv, 80);
#line 736
    if (tmp___2) {
#line 736
      tmp___3 = 0;
    } else {
#line 736
      tmp___3 = 1;
    }
#line 736
    if (tmp___3) {
#line 739
      return (1);
    } else {

    }
  } else {

  }
#line 741
  tmp___4 = ieee80211_is_probe_req((int )mgmt->frame_control);
#line 741
  tmp___5 = ldv__builtin_expect(tmp___4 == 0, 0L);
#line 741
  if (tmp___5 != 0L) {
#line 742
    printk("\f%s: Received non probe request frame\n", "OnProbeReq23a");
#line 744
    return (0);
  } else {

  }
#line 747
  len = (int )((unsigned int )len - 24U);
#line 749
  ie = cfg80211_find_ie(0, (u8 const   *)(& mgmt->u.probe_req.variable), len);
#line 752
  if ((unsigned long )ie == (unsigned long )((u8 const   *)0U)) {
#line 753
    goto out;
  } else {

  }
#line 755
  if ((unsigned int )((unsigned char )*(ie + 1UL)) != 0U) {
#line 755
    tmp___6 = memcmp((void const   *)ie + 2U, (void const   *)(& cur->Ssid.ssid),
                     (size_t )cur->Ssid.ssid_len);
#line 755
    if (tmp___6 != 0) {
#line 757
      return (1);
    } else {
#line 755
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 755
  if ((unsigned int )((unsigned char )*(ie + 1UL)) == 0U && (unsigned int )pmlmeinfo->hidden_ssid_mode != 0U) {
#line 757
    return (1);
  } else {

  }
#line 760
  tmp___7 = check_fwstate(pmlmepriv, 1);
#line 760
  if ((int )tmp___7 && pmlmepriv->cur_network.join_res != 0) {
#line 762
    issue_probersp(padapter, (unsigned char *)(& mgmt->sa));
  } else {

  }
  out: ;
#line 765
  return (1);
}
}
#line 769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnProbeRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
#line 771
  pmlmeext = & padapter->mlmeextpriv;
#line 773
  if (pmlmeext->sitesurvey_res.state == 3) {
#line 774
    report_survey_event23a(padapter, precv_frame);
#line 775
    return (1);
  } else {

  }
#line 778
  return (1);
}
}
#line 782 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnBeacon23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  int cam_idx ;
  struct sta_info *psta ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  int pkt_len ;
  struct wlan_bssid_ex *pbss ;
  int ret ;
  u8 *p ;
  u8 *pie ;
  int pie_len ;
  u32 ielen ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 786
  pmlmeext = & padapter->mlmeextpriv;
#line 787
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 788
  pmlmepriv = & padapter->mlmepriv;
#line 789
  pstapriv = & padapter->stapriv;
#line 790
  skb = precv_frame->pkt;
#line 791
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 792
  pkt_len = (int )skb->len;
#line 794
  ret = 1;
#line 797
  ielen = 0U;
#line 799
  pie = (u8 *)(& mgmt->u.beacon.variable);
#line 800
  pie_len = (int )((unsigned int )pkt_len - 36U);
#line 801
  p = rtw_get_ie23a(pie, 50, (int *)(& ielen), pie_len);
#line 802
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ielen != 0U) {
#line 803
    if ((unsigned int )*(p + (unsigned long )(ielen + 1U)) == 45U && (unsigned int )*(p + (unsigned long )(ielen + 2U)) != 45U) {
#line 808
      if (GlobalDebugLevel23A > 3U) {
#line 808
        printk("\016RTL8723AU: [WIFIDBG] Error in ESR IE is detected in Beacon of BSSID: %pM. Fix the length of ESR IE to avoid failed Beacon parsing.\n",
               (u8 *)(& mgmt->bssid));
      } else {

      }
#line 812
      *(p + 1UL) = (unsigned int )((u8 )ielen) - 1U;
    } else {

    }
  } else {

  }
#line 816
  if (pmlmeext->sitesurvey_res.state == 3) {
#line 817
    report_survey_event23a(padapter, precv_frame);
#line 818
    return (1);
  } else {

  }
#line 821
  tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 821
  tmp___0 = ether_addr_equal((u8 const   *)(& mgmt->bssid), (u8 const   *)tmp);
#line 821
  if (tmp___0) {
#line 821
    tmp___1 = 0;
  } else {
#line 821
    tmp___1 = 1;
  }
#line 821
  if (tmp___1) {
#line 823
    goto out;
  } else {

  }
#line 825
  if ((pmlmeinfo->state & 256U) != 0U) {
#line 828
    pbss = collect_bss_info(padapter, precv_frame);
#line 829
    if ((unsigned long )pbss != (unsigned long )((struct wlan_bssid_ex *)0)) {
#line 830
      update_network23a(& pmlmepriv->cur_network.network, pbss, padapter, 1);
#line 832
      rtw_get_bcn_info23a(& pmlmepriv->cur_network);
#line 833
      kfree((void const   *)pbss);
    } else {

    }
#line 837
    pmlmeinfo->assoc_AP_vendor = check_assoc_AP23a((u8 *)(& mgmt->u.beacon), (uint )pkt_len - 24U);
#line 842
    rtw_update_TSF(pmlmeext, mgmt);
#line 845
    start_clnt_auth(padapter);
#line 847
    return (1);
  } else {

  }
#line 850
  if ((pmlmeinfo->state & 3U) == 3U && (pmlmeinfo->state & 16384U) != 0U) {
#line 852
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
#line 853
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 854
      ret = rtw_check_bcn_info23a(padapter, mgmt, (u32 )pkt_len);
#line 855
      if (ret != 1) {
#line 856
        if (GlobalDebugLevel23A != 0U) {
#line 856
          printk("\016RTL8723AU: ap has changed, disconnect now\n");
        } else {

        }
#line 858
        receive_disconnect23a(padapter, (unsigned char *)(& pmlmeinfo->network.MacAddress),
                              65535);
#line 859
        return (1);
      } else {

      }
#line 864
      if ((((psta->sta_stats.rx_mgnt_pkts + psta->sta_stats.rx_ctrl_pkts) + psta->sta_stats.rx_data_pkts) & 15ULL) == 0ULL) {
#line 866
        update_beacon23a_info(padapter, mgmt, (uint )pkt_len, psta);
      } else {

      }
    } else {

    }
  } else
#line 870
  if ((pmlmeinfo->state & 3U) == 1U) {
#line 871
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
#line 872
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 876
      if ((((psta->sta_stats.rx_mgnt_pkts + psta->sta_stats.rx_ctrl_pkts) + psta->sta_stats.rx_data_pkts) & 15ULL) == 0ULL) {
#line 878
        update_beacon23a_info(padapter, mgmt, (uint )pkt_len, psta);
      } else {

      }
    } else {
#line 883
      cam_idx = allocate_fw_sta_entry23a(padapter);
#line 884
      if (cam_idx == 32) {
#line 885
        goto out;
      } else {

      }
#line 888
      tmp___2 = update_sta_support_rate23a(padapter, pie, (uint )pie_len, cam_idx);
#line 888
      if (tmp___2 == 0) {
#line 890
        pmlmeinfo->FW_sta_info[cam_idx].status = 0U;
#line 891
        goto out;
      } else {

      }
#line 895
      rtw_update_TSF(pmlmeext, mgmt);
#line 898
      report_add_sta_event23a(padapter, (unsigned char *)(& mgmt->sa), cam_idx);
    }
  } else {

  }
  out: ;
#line 905
  return (1);
}
}
#line 910 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct sta_info stat ;
  struct sta_info *pstat ;
  struct sta_priv *pstapriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 *pframe ;
  u8 const   *p ;
  unsigned char *sa ;
  u16 auth_mode ;
  u16 seq ;
  u16 algorithm ;
  int status ;
  int len ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 913
  pstat = (struct sta_info *)0;
#line 914
  pstapriv = & padapter->stapriv;
#line 915
  psecuritypriv = & padapter->securitypriv;
#line 916
  pmlmeext = & padapter->mlmeextpriv;
#line 917
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 918
  skb = precv_frame->pkt;
#line 919
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 924
  len = (int )skb->len;
#line 926
  if ((pmlmeinfo->state & 3U) != 3U) {
#line 927
    return (0);
  } else {

  }
#line 929
  if (GlobalDebugLevel23A > 3U) {
#line 929
    printk("\016RTL8723AU: +OnAuth23a\n");
  } else {

  }
#line 931
  sa = (unsigned char *)(& mgmt->sa);
#line 933
  auth_mode = (u16 )psecuritypriv->dot11AuthAlgrthm;
#line 935
  pframe = (u8 *)(& mgmt->u.auth.variable);
#line 936
  len = (int )(skb->len - 30U);
#line 938
  seq = mgmt->u.auth.auth_transaction;
#line 939
  algorithm = mgmt->u.auth.auth_alg;
#line 941
  if (GlobalDebugLevel23A > 3U) {
#line 941
    printk("\016RTL8723AU: auth alg =%x, seq =%X\n", (int )algorithm, (int )seq);
  } else {

  }
#line 943
  if (((unsigned int )auth_mode == 2U && psecuritypriv->dot11PrivacyAlgrthm != 1027073U) && psecuritypriv->dot11PrivacyAlgrthm != 1027077U) {
#line 946
    auth_mode = 0U;
  } else {

  }
#line 950
  if (((unsigned int )algorithm != 0U && (unsigned int )auth_mode == 0U) || ((unsigned int )algorithm == 0U && (unsigned int )auth_mode == 1U)) {
#line 952
    if (GlobalDebugLevel23A > 3U) {
#line 952
      printk("\016RTL8723AU: auth rejected due to bad alg [alg =%d, auth_mib =%d] %02X%02X%02X%02X%02X%02X\n",
             (int )algorithm, (int )auth_mode, (int )*sa, (int )*(sa + 1UL), (int )*(sa + 2UL),
             (int )*(sa + 3UL), (int )*(sa + 4UL), (int )*(sa + 5UL));
    } else {

    }
#line 957
    status = 13;
#line 959
    goto auth_fail;
  } else {

  }
#line 962
  tmp = rtw_access_ctrl23a(padapter, sa);
#line 962
  if (tmp) {
#line 962
    tmp___0 = 0;
  } else {
#line 962
    tmp___0 = 1;
  }
#line 962
  if (tmp___0) {
#line 963
    status = 17;
#line 964
    goto auth_fail;
  } else {

  }
#line 967
  pstat = rtw_get_stainfo23a(pstapriv, (u8 const   *)sa);
#line 968
  if ((unsigned long )pstat == (unsigned long )((struct sta_info *)0)) {
#line 970
    if (GlobalDebugLevel23A > 3U) {
#line 970
      printk("\016RTL8723AU: going to alloc stainfo for sa =%pM\n", sa);
    } else {

    }
#line 971
    pstat = rtw_alloc_stainfo23a(pstapriv, (u8 const   *)sa, 32U);
#line 972
    if ((unsigned long )pstat == (unsigned long )((struct sta_info *)0)) {
#line 973
      if (GlobalDebugLevel23A > 3U) {
#line 973
        printk("\016RTL8723AU:  Exceed the upper limit of supported clients...\n");
      } else {

      }
#line 975
      status = 17;
#line 976
      goto auth_fail;
    } else {

    }
#line 979
    pstat->state = 256U;
#line 980
    pstat->auth_seq = 0U;
  } else {
#line 985
    spin_lock_bh(& pstapriv->asoc_list_lock);
#line 986
    tmp___1 = list_empty((struct list_head  const  *)(& pstat->asoc_list));
#line 986
    if (tmp___1 == 0) {
#line 987
      list_del_init(& pstat->asoc_list);
#line 988
      pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
    } else {

    }
#line 993
    spin_unlock_bh(& pstapriv->asoc_list_lock);
  }
#line 1000
  spin_lock_bh(& pstapriv->auth_list_lock);
#line 1001
  tmp___2 = list_empty((struct list_head  const  *)(& pstat->auth_list));
#line 1001
  if (tmp___2 != 0) {
#line 1002
    list_add_tail(& pstat->auth_list, & pstapriv->auth_list);
#line 1003
    pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt + 1);
  } else {

  }
#line 1005
  spin_unlock_bh(& pstapriv->auth_list_lock);
#line 1007
  if (pstat->auth_seq == 0U) {
#line 1008
    pstat->expire_to = pstapriv->auth_to;
  } else {

  }
#line 1010
  if (pstat->auth_seq + 1U != (unsigned int )seq) {
#line 1011
    if (GlobalDebugLevel23A > 3U) {
#line 1011
      printk("\016RTL8723AU: (1)auth rejected because out of seq [rx_seq =%d, exp_seq =%d]!\n",
             (int )seq, pstat->auth_seq + 1U);
    } else {

    }
#line 1013
    status = 14;
#line 1014
    goto auth_fail;
  } else {

  }
#line 1017
  if ((unsigned int )algorithm == 0U && ((unsigned int )auth_mode == 0U || (unsigned int )auth_mode == 2U)) {
#line 1018
    if ((unsigned int )seq == 1U) {
#line 1019
      pstat->state = pstat->state & 4294967039U;
#line 1020
      pstat->state = pstat->state | 1024U;
#line 1021
      pstat->expire_to = pstapriv->assoc_to;
#line 1022
      pstat->authalg = (unsigned int )algorithm;
    } else {
#line 1024
      if (GlobalDebugLevel23A > 3U) {
#line 1024
        printk("\016RTL8723AU: (2)auth rejected because out of seq [rx_seq =%d, exp_seq =%d]!\n",
               (int )seq, pstat->auth_seq + 1U);
      } else {

      }
#line 1027
      status = 14;
#line 1028
      goto auth_fail;
    }
  } else
#line 1031
  if ((unsigned int )seq == 1U) {
#line 1033
    pstat->state = pstat->state & 4294967039U;
#line 1034
    pstat->state = pstat->state | 512U;
#line 1035
    pstat->authalg = (unsigned int )algorithm;
#line 1036
    pstat->auth_seq = 2U;
  } else
#line 1037
  if ((unsigned int )seq == 3U) {
#line 1039
    if (GlobalDebugLevel23A > 3U) {
#line 1039
      printk("\016RTL8723AU: checking for challenging txt...\n");
    } else {

    }
#line 1041
    p = cfg80211_find_ie(16, (u8 const   *)pframe, len);
#line 1042
    if ((unsigned long )p == (unsigned long )((u8 const   *)0U) || (unsigned int )((unsigned char )*(p + 1UL)) == 0U) {
#line 1043
      if (GlobalDebugLevel23A > 3U) {
#line 1043
        printk("\016RTL8723AU: auth rejected because challenge failure!(1)\n");
      } else {

      }
#line 1045
      status = 15;
#line 1046
      goto auth_fail;
    } else {

    }
#line 1049
    tmp___3 = memcmp((void const   *)p + 2U, (void const   *)(& pstat->chg_txt), 128UL);
#line 1049
    if (tmp___3 == 0) {
#line 1050
      pstat->state = pstat->state & 4294966783U;
#line 1051
      pstat->state = pstat->state | 1024U;
#line 1053
      pstat->expire_to = pstapriv->assoc_to;
    } else {
#line 1055
      if (GlobalDebugLevel23A > 3U) {
#line 1055
        printk("\016RTL8723AU: auth rejected because challenge failure!\n");
      } else {

      }
#line 1057
      status = 15;
#line 1058
      goto auth_fail;
    }
  } else {
#line 1061
    if (GlobalDebugLevel23A > 3U) {
#line 1061
      printk("\016RTL8723AU: (3)auth rejected because out of seq [rx_seq =%d, exp_seq =%d]!\n",
             (int )seq, pstat->auth_seq + 1U);
    } else {

    }
#line 1064
    status = 14;
#line 1065
    goto auth_fail;
  }
#line 1070
  pstat->auth_seq = (unsigned int )((int )seq + 1);
#line 1072
  issue_auth(padapter, pstat, 0);
#line 1074
  if ((pstat->state & 1024U) != 0U) {
#line 1075
    pstat->auth_seq = 0U;
  } else {

  }
#line 1077
  return (1);
  auth_fail: ;
#line 1081
  if ((unsigned long )pstat != (unsigned long )((struct sta_info *)0)) {
#line 1082
    rtw_free_stainfo23a(padapter, pstat);
  } else {

  }
#line 1084
  pstat = & stat;
#line 1085
  memset((void *)pstat, 0, 5656UL);
#line 1086
  pstat->auth_seq = 2U;
#line 1087
  ether_addr_copy((u8 *)(& pstat->hwaddr), (u8 const   *)sa);
#line 1089
  issue_auth(padapter, pstat, (int )((unsigned short )status));
#line 1091
  return (0);
}
}
#line 1096 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnAuth23aClient23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  unsigned int seq ;
  unsigned int status ;
  unsigned int algthm ;
  unsigned int go2asoc ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 const   *p ;
  u8 *pie ;
  int plen ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 1099
  go2asoc = 0U;
#line 1100
  pmlmeext = & padapter->mlmeextpriv;
#line 1101
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1102
  skb = precv_frame->pkt;
#line 1103
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 1106
  plen = (int )skb->len;
#line 1108
  if (GlobalDebugLevel23A > 3U) {
#line 1108
    printk("\016RTL8723AU: %s\n", "OnAuth23aClient23a");
  } else {

  }
#line 1111
  tmp = myid(& padapter->eeprompriv);
#line 1111
  tmp___0 = ether_addr_equal((u8 const   *)tmp, (u8 const   *)(& mgmt->da));
#line 1111
  if (tmp___0) {
#line 1111
    tmp___1 = 0;
  } else {
#line 1111
    tmp___1 = 1;
  }
#line 1111
  if (tmp___1) {
#line 1112
    return (1);
  } else {

  }
#line 1114
  if ((pmlmeinfo->state & 512U) == 0U) {
#line 1115
    return (1);
  } else {

  }
#line 1117
  pie = (u8 *)(& mgmt->u.auth.variable);
#line 1118
  plen = (int )((unsigned int )plen - 30U);
#line 1120
  algthm = (unsigned int )mgmt->u.auth.auth_alg;
#line 1121
  seq = (unsigned int )mgmt->u.auth.auth_transaction;
#line 1122
  status = (unsigned int )mgmt->u.auth.status_code;
#line 1124
  if (status != 0U) {
#line 1125
    if (GlobalDebugLevel23A > 3U) {
#line 1125
      printk("\016RTL8723AU: clnt auth fail, status: %d\n", status);
    } else {

    }
#line 1127
    if (status == 13U) {
#line 1128
      if (pmlmeinfo->auth_algo == 1U) {
#line 1129
        pmlmeinfo->auth_algo = 0U;
      } else {
#line 1131
        pmlmeinfo->auth_algo = 1U;
      }
    } else {

    }
#line 1135
    tmp___2 = msecs_to_jiffies(1U);
#line 1135
    ldv_mod_timer_104(& pmlmeext->link_timer, tmp___2 + (unsigned long )jiffies);
#line 1136
    goto authclnt_fail;
  } else {

  }
#line 1139
  if (seq == 2U) {
#line 1140
    if (pmlmeinfo->auth_algo == 1U) {
#line 1142
      p = cfg80211_find_ie(16, (u8 const   *)pie, plen);
#line 1144
      if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
#line 1146
        goto authclnt_fail;
      } else {

      }
#line 1149
      memcpy((void *)(& pmlmeinfo->chg_txt), (void const   *)p + 2U, (size_t )*(p + 1UL));
#line 1150
      pmlmeinfo->auth_seq = 3U;
#line 1151
      issue_auth(padapter, (struct sta_info *)0, 0);
#line 1152
      tmp___3 = msecs_to_jiffies(300U);
#line 1152
      ldv_mod_timer_105(& pmlmeext->link_timer, tmp___3 + (unsigned long )jiffies);
#line 1154
      return (1);
    } else {
#line 1157
      go2asoc = 1U;
    }
  } else
#line 1159
  if (seq == 4U) {
#line 1160
    if (pmlmeinfo->auth_algo == 1U) {
#line 1161
      go2asoc = 1U;
    } else {
#line 1163
      goto authclnt_fail;
    }
  } else {
#line 1168
    goto authclnt_fail;
  }
#line 1171
  if (go2asoc != 0U) {
#line 1172
    if (GlobalDebugLevel23A != 0U) {
#line 1172
      printk("\016RTL8723AU: auth success, start assoc\n");
    } else {

    }
#line 1173
    start_clnt_assoc(padapter);
#line 1174
    return (1);
  } else {

  }
  authclnt_fail: ;
#line 1181
  return (0);
}
}
#line 1185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int rtw_validate_vendor_specific_ies(u8 const   *pos , int elen ) 
{ 
  unsigned int oui ;

  {
#line 1192
  if (elen <= 3) {
#line 1193
    if (GlobalDebugLevel23A > 3U) {
#line 1193
      printk("\016RTL8723AU: short vendor specific information element ignored (len =%i)\n",
             elen);
    } else {

    }
#line 1195
    return (-22);
  } else {

  }
#line 1198
  oui = (((unsigned int )*pos << 16) | ((unsigned int )*(pos + 1UL) << 8)) | (unsigned int )*(pos + 2UL);
#line 1199
  switch (oui) {
  case 20722U: ;
#line 1203
  switch ((int )*(pos + 3UL)) {
  case 1: ;
#line 1207
  goto ldv_56147;
  case 2: ;
#line 1209
  if (elen <= 4) {
#line 1210
    if (GlobalDebugLevel23A > 3U) {
#line 1210
      printk("\016RTL8723AU: short WME information element ignored (len =%i)\n", elen);
    } else {

    }
#line 1212
    return (-22);
  } else {

  }
#line 1214
  switch ((int )*(pos + 4UL)) {
  case 0: ;
  case 1: ;
#line 1217
  goto ldv_56151;
  case 2: ;
#line 1219
  goto ldv_56151;
  default: ;
#line 1221
  if (GlobalDebugLevel23A > 3U) {
#line 1221
    printk("\016RTL8723AU: unknown WME information element ignored (subtype =%d len =%i)\n",
           (int )*(pos + 4UL), elen);
  } else {

  }
#line 1224
  return (-22);
  }
  ldv_56151: ;
#line 1226
  goto ldv_56147;
  case 4: ;
#line 1229
  goto ldv_56147;
  default: ;
#line 1231
  if (GlobalDebugLevel23A > 3U) {
#line 1231
    printk("\016RTL8723AU: Unknown Microsoft information element ignored (type =%d len =%i)\n",
           (int )*(pos + 3UL), elen);
  } else {

  }
#line 1234
  return (-22);
  }
  ldv_56147: ;
#line 1236
  goto ldv_56156;
  case 36940U: ;
#line 1239
  switch ((int )*(pos + 3UL)) {
  case 51: ;
#line 1241
  goto ldv_56159;
  default: ;
#line 1243
  if (GlobalDebugLevel23A > 3U) {
#line 1243
    printk("\016RTL8723AU: Unknown Broadcom information element ignored (type =%d len =%i)\n",
           (int )*(pos + 3UL), elen);
  } else {

  }
#line 1245
  return (-22);
  }
  ldv_56159: ;
#line 1247
  goto ldv_56156;
  default: ;
#line 1250
  if (GlobalDebugLevel23A > 3U) {
#line 1250
    printk("\016RTL8723AU: unknown vendor specific information element ignored (vendor OUI %02x:%02x:%02x len =%i)\n",
           (int )*pos, (int )*(pos + 1UL), (int )*(pos + 2UL), elen);
  } else {

  }
#line 1253
  return (-22);
  }
  ldv_56156: ;
#line 1256
  return (0);
}
}
#line 1259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int rtw_validate_frame_ies(u8 const   *start , uint len ) 
{ 
  u8 const   *pos ;
  int left ;
  int unknown ;
  u8 id ;
  u8 elen ;
  u8 const   *tmp ;
  u8 const   *tmp___0 ;
  int tmp___1 ;

  {
#line 1261
  pos = start;
#line 1262
  left = (int )len;
#line 1263
  unknown = 0;
#line 1265
  goto ldv_56194;
  ldv_56193: 
#line 1268
  tmp = pos;
#line 1268
  pos = pos + 1;
#line 1268
  id = *tmp;
#line 1269
  tmp___0 = pos;
#line 1269
  pos = pos + 1;
#line 1269
  elen = *tmp___0;
#line 1270
  left = left + -2;
#line 1272
  if ((int )elen > left) {
#line 1273
    if (GlobalDebugLevel23A > 3U) {
#line 1273
      printk("\016RTL8723AU: %s: IEEE 802.11 failed (id =%d elen =%d left =%i)\n",
             "rtw_validate_frame_ies", (int )id, (int )elen, left);
    } else {

    }
#line 1275
    return (-22);
  } else {

  }
#line 1278
  switch ((int )id) {
  case 0: ;
  case 1: ;
  case 2: ;
  case 3: ;
  case 4: ;
  case 5: ;
  case 6: ;
  case 16: ;
  case 42: ;
  case 50: ;
#line 1289
  goto ldv_56182;
  case 221: 
#line 1291
  tmp___1 = rtw_validate_vendor_specific_ies(pos, (int )elen);
#line 1291
  if (tmp___1 != 0) {
#line 1292
    unknown = unknown + 1;
  } else {

  }
#line 1293
  goto ldv_56182;
  case 48: ;
  case 33: ;
  case 36: ;
  case 54: ;
  case 55: ;
  case 56: ;
  case 45: ;
  case 61: ;
  default: 
#line 1303
  unknown = unknown + 1;
#line 1304
  if (GlobalDebugLevel23A > 3U) {
#line 1304
    printk("\016RTL8723AU: %s IEEE 802.11 ignored unknown element (id =%d elen =%d)\n",
           "rtw_validate_frame_ies", (int )id, (int )elen);
  } else {

  }
#line 1306
  goto ldv_56182;
  }
  ldv_56182: 
#line 1309
  left = left - (int )elen;
#line 1310
  pos = pos + (unsigned long )elen;
  ldv_56194: ;
#line 1265
  if (left > 1) {
#line 1267
    goto ldv_56193;
  } else {

  }

#line 1313
  if (left != 0) {
#line 1314
    return (-22);
  } else {

  }
#line 1316
  return (0);
}
}
#line 1321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnAssocReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  u16 capab_info ;
  u16 listen_interval ;
  struct sta_info *pstat ;
  unsigned char reassoc ;
  int i ;
  int wpa_ie_len ;
  int left ;
  unsigned char supportRate[16U] ;
  int supportRateNum ;
  unsigned short status ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur ;
  struct sta_priv *pstapriv ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 const   *pos ;
  u8 const   *p ;
  u8 const   *wpa_ie ;
  u8 const   *wps_ie ;
  u8 *pframe ;
  uint pkt_len ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int group_cipher ;
  int pairwise_cipher ;
  int copy_len ;
  u8 const   *end ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1330
  status = 0U;
#line 1331
  pmlmepriv = & padapter->mlmepriv;
#line 1332
  psecuritypriv = & padapter->securitypriv;
#line 1333
  pmlmeext = & padapter->mlmeextpriv;
#line 1334
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1335
  cur = & pmlmeinfo->network;
#line 1336
  pstapriv = & padapter->stapriv;
#line 1337
  skb = precv_frame->pkt;
#line 1338
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 1340
  pframe = skb->data;
#line 1341
  pkt_len = skb->len;
#line 1344
  if ((pmlmeinfo->state & 3U) != 3U) {
#line 1345
    return (0);
  } else {

  }
#line 1347
  left = (int )(pkt_len - 24U);
#line 1348
  tmp = ieee80211_is_assoc_req((int )mgmt->frame_control);
#line 1348
  if (tmp != 0) {
#line 1349
    reassoc = 0U;
#line 1350
    pos = (u8 const   *)(& mgmt->u.assoc_req.variable);
#line 1351
    left = (int )((unsigned int )left - 28U);
  } else {
#line 1353
    reassoc = 1U;
#line 1354
    pos = (u8 const   *)(& mgmt->u.reassoc_req.variable);
#line 1355
    left = (int )((unsigned int )left - 34U);
  }
#line 1358
  if (left < 0) {
#line 1359
    if (GlobalDebugLevel23A > 3U) {
#line 1359
      printk("\016RTL8723AU: handle_assoc(reassoc =%d) - too short payload (len =%lu)\n",
             (int )reassoc, (unsigned long )pkt_len);
    } else {

    }
#line 1361
    return (0);
  } else {

  }
#line 1364
  pstat = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
#line 1365
  if ((unsigned long )pstat == (unsigned long )((struct sta_info *)0)) {
#line 1366
    status = 6U;
#line 1367
    goto asoc_class2_error;
  } else {

  }
#line 1372
  capab_info = get_unaligned_le16((void const   *)(& mgmt->u.assoc_req.capab_info));
#line 1373
  listen_interval = get_unaligned_le16((void const   *)(& mgmt->u.assoc_req.listen_interval));
#line 1376
  if (GlobalDebugLevel23A > 3U) {
#line 1376
    printk("\016RTL8723AU: %s\n", "OnAssocReq23a");
  } else {

  }
#line 1379
  if ((pstat->state & 1024U) == 0U) {
#line 1380
    if ((pstat->state & 16384U) == 0U) {
#line 1381
      status = 6U;
#line 1382
      goto asoc_class2_error;
    } else {
#line 1384
      pstat->state = pstat->state & 4294950911U;
#line 1385
      pstat->state = pstat->state | 8192U;
    }
  } else {
#line 1388
    pstat->state = pstat->state & 4294966271U;
#line 1389
    pstat->state = pstat->state | 8192U;
  }
#line 1392
  pstat->capability = capab_info;
#line 1396
  tmp___0 = rtw_validate_frame_ies(pos, (uint )left);
#line 1396
  if (tmp___0 != 0) {
#line 1397
    if (GlobalDebugLevel23A > 3U) {
#line 1397
      printk("\016RTL8723AU: STA %pM sent invalid association request\n", (u8 *)(& pstat->hwaddr));
    } else {

    }
#line 1399
    status = 1U;
#line 1400
    goto OnAssocReq23aFail;
  } else {

  }
#line 1405
  p = cfg80211_find_ie(0, pos, left);
#line 1406
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U) || (unsigned int )((unsigned char )*(p + 1UL)) == 0U) {
#line 1408
    if (GlobalDebugLevel23A > 3U) {
#line 1408
      printk("\016RTL8723AU: STA %pM sent invalid association request lacking an SSID\n",
             (u8 *)(& pstat->hwaddr));
    } else {

    }
#line 1410
    status = 1U;
#line 1411
    goto OnAssocReq23aFail;
  } else {
#line 1414
    tmp___1 = memcmp((void const   *)p + 2U, (void const   *)(& cur->Ssid.ssid), (size_t )cur->Ssid.ssid_len);
#line 1414
    if (tmp___1 != 0) {
#line 1415
      status = 1U;
    } else {

    }
#line 1417
    if ((int )((unsigned char )*(p + 1UL)) != (int )cur->Ssid.ssid_len) {
#line 1418
      status = 1U;
    } else {

    }
  }
#line 1421
  if ((unsigned int )status != 0U) {
#line 1422
    goto OnAssocReq23aFail;
  } else {

  }
#line 1425
  p = cfg80211_find_ie(1, pos, left);
#line 1426
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
#line 1427
    if (GlobalDebugLevel23A > 3U) {
#line 1427
      printk("\016RTL8723AU: Rx a sta assoc-req which supported rate is empty!\n");
    } else {

    }
#line 1433
    status = 1U;
#line 1434
    goto OnAssocReq23aFail;
  } else {
#line 1436
    memcpy((void *)(& supportRate), (void const   *)p + 2U, (size_t )*(p + 1UL));
#line 1437
    supportRateNum = (int )*(p + 1UL);
#line 1439
    p = cfg80211_find_ie(50, pos, left);
#line 1440
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 1441
      if ((unsigned int )supportRateNum <= 16U) {
#line 1442
        memcpy((void *)(& supportRate) + (unsigned long )supportRateNum, (void const   *)p + 2U,
                 (size_t )*(p + 1UL));
#line 1443
        supportRateNum = (int )*(p + 1UL) + supportRateNum;
      } else {

      }
    } else {

    }
  }
#line 1452
  pstat->bssratelen = (u32 )supportRateNum;
#line 1453
  memcpy((void *)(& pstat->bssrateset), (void const   *)(& supportRate), (size_t )supportRateNum);
#line 1454
  Update23aTblForSoftAP((u8 *)(& pstat->bssrateset), pstat->bssratelen);
#line 1457
  pstat->dot8021xalg = 0;
#line 1458
  pstat->wpa_psk = 0;
#line 1459
  pstat->wpa_group_cipher = 0;
#line 1460
  pstat->wpa2_group_cipher = 0;
#line 1461
  pstat->wpa_pairwise_cipher = 0;
#line 1462
  pstat->wpa2_pairwise_cipher = 0;
#line 1463
  memset((void *)(& pstat->wpa_ie), 0, 32UL);
#line 1465
  wpa_ie = cfg80211_find_ie(48, pos, left);
#line 1466
  if ((unsigned long )wpa_ie == (unsigned long )((u8 const   *)0U)) {
#line 1467
    wpa_ie = cfg80211_find_vendor_ie(20722U, 1, pos, left);
  } else {

  }
#line 1470
  if ((unsigned long )wpa_ie != (unsigned long )((u8 const   *)0U)) {
#line 1471
    group_cipher = 0;
#line 1471
    pairwise_cipher = 0;
#line 1473
    wpa_ie_len = (int )*(wpa_ie + 1UL);
#line 1474
    if (((unsigned long )psecuritypriv->wpa_psk & 2UL) != 0UL) {
#line 1475
      r = rtw_parse_wpa2_ie23a(wpa_ie, wpa_ie_len + 2, & group_cipher, & pairwise_cipher,
                               (int *)0);
#line 1478
      if (r == 1) {
#line 1479
        pstat->dot8021xalg = 1;
#line 1480
        pstat->wpa_psk = pstat->wpa_psk | 2;
#line 1482
        pstat->wpa2_group_cipher = (int )(psecuritypriv->wpa2_group_cipher & (unsigned int )group_cipher);
#line 1484
        pstat->wpa2_pairwise_cipher = (int )(psecuritypriv->wpa2_pairwise_cipher & (unsigned int )pairwise_cipher);
      } else {
#line 1487
        status = 40U;
      }
    } else
#line 1488
    if ((int )psecuritypriv->wpa_psk & 1) {
#line 1489
      r = rtw_parse_wpa_ie23a(wpa_ie, wpa_ie_len + 2, & group_cipher, & pairwise_cipher,
                              (int *)0);
#line 1492
      if (r == 1) {
#line 1493
        pstat->dot8021xalg = 1;
#line 1494
        pstat->wpa_psk = pstat->wpa_psk | 1;
#line 1496
        pstat->wpa_group_cipher = (int )(psecuritypriv->wpa_group_cipher & (unsigned int )group_cipher);
#line 1498
        pstat->wpa_pairwise_cipher = (int )(psecuritypriv->wpa_pairwise_cipher & (unsigned int )pairwise_cipher);
      } else {
#line 1501
        status = 40U;
      }
    } else {
#line 1503
      wpa_ie = (u8 const   *)0U;
#line 1504
      wpa_ie_len = 0;
    }
#line 1506
    if ((unsigned long )wpa_ie != (unsigned long )((u8 const   *)0U) && (unsigned int )status == 0U) {
#line 1507
      if (pstat->wpa_group_cipher == 0) {
#line 1508
        status = 41U;
      } else {

      }
#line 1510
      if (pstat->wpa_pairwise_cipher == 0) {
#line 1511
        status = 42U;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1515
  if ((unsigned int )status != 0U) {
#line 1516
    goto OnAssocReq23aFail;
  } else {

  }
#line 1518
  pstat->flags = pstat->flags & -12289;
#line 1520
  wps_ie = cfg80211_find_vendor_ie(20722U, 4, pos, left);
#line 1524
  if ((unsigned long )wpa_ie == (unsigned long )((u8 const   *)0U)) {
#line 1525
    if ((unsigned long )wps_ie != (unsigned long )((u8 const   *)0U)) {
#line 1526
      if (GlobalDebugLevel23A > 3U) {
#line 1526
        printk("\016RTL8723AU: STA included WPS IE in (Re)Association Request - assume WPS is used\n");
      } else {

      }
#line 1528
      pstat->flags = pstat->flags | 4096;
    } else {
#line 1530
      if (GlobalDebugLevel23A > 3U) {
#line 1530
        printk("\016RTL8723AU: STA did not include WPA/RSN IE in (Re)Association Request - possible WPS use\n");
      } else {

      }
#line 1532
      pstat->flags = pstat->flags | 8192;
    }
  } else {
#line 1537
    if (psecuritypriv->wpa_psk == 0U) {
#line 1538
      if (GlobalDebugLevel23A > 3U) {
#line 1538
        printk("\016RTL8723AU: STA %pM: WPA/RSN IE in association request, but AP don\'t support WPA/RSN\n",
               (u8 *)(& pstat->hwaddr));
      } else {

      }
#line 1541
      status = 40U;
#line 1543
      goto OnAssocReq23aFail;
    } else {

    }
#line 1546
    if ((unsigned long )wps_ie != (unsigned long )((u8 const   *)0U)) {
#line 1547
      if (GlobalDebugLevel23A > 3U) {
#line 1547
        printk("\016RTL8723AU: STA included WPS IE in (Re)Association Request - WPS is used\n");
      } else {

      }
#line 1549
      pstat->flags = pstat->flags | 4096;
#line 1550
      copy_len = 0;
    } else {
#line 1552
      copy_len = (int )(32U < (unsigned int )(wpa_ie_len + 2) ? 32U : (unsigned int )(wpa_ie_len + 2));
    }
#line 1556
    if (copy_len > 0) {
#line 1557
      memcpy((void *)(& pstat->wpa_ie), (void const   *)wpa_ie + 0xfffffffffffffffeUL,
               (size_t )copy_len);
    } else {

    }
  }
#line 1561
  pstat->flags = pstat->flags & -513;
#line 1562
  pstat->qos_option = 0U;
#line 1563
  pstat->qos_info = 0U;
#line 1564
  pstat->has_legacy_ac = 1U;
#line 1565
  pstat->uapsd_vo = 0U;
#line 1566
  pstat->uapsd_vi = 0U;
#line 1567
  pstat->uapsd_be = 0U;
#line 1568
  pstat->uapsd_bk = 0U;
#line 1569
  if (pmlmepriv->qos_option != 0U) {
#line 1570
    end = pos + (unsigned long )left;
#line 1572
    p = pos;
    ldv_56233: 
#line 1575
    left = (int )((unsigned int )((long )end) - (unsigned int )((long )p));
#line 1576
    p = cfg80211_find_vendor_ie(20722U, 2, p, left);
#line 1579
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 1580
      pstat->flags = pstat->flags | 512;
#line 1582
      pstat->qos_option = 1U;
#line 1583
      pstat->qos_info = *(p + 8UL);
#line 1585
      pstat->max_sp_len = (unsigned int )((u8 )((int )pstat->qos_info >> 5)) & 3U;
#line 1588
      if (((int )pstat->qos_info & 15) != 15) {
#line 1589
        pstat->has_legacy_ac = 1U;
      } else {
#line 1591
        pstat->has_legacy_ac = 0U;
      }
#line 1593
      if (((int )pstat->qos_info & 15) != 0) {
#line 1594
        if ((int )pstat->qos_info & 1) {
#line 1595
          pstat->uapsd_vo = 3U;
        } else {
#line 1597
          pstat->uapsd_vo = 0U;
        }
#line 1599
        if (((unsigned long )pstat->qos_info & 2UL) != 0UL) {
#line 1600
          pstat->uapsd_vi = 3U;
        } else {
#line 1602
          pstat->uapsd_vi = 0U;
        }
#line 1604
        if (((unsigned long )pstat->qos_info & 4UL) != 0UL) {
#line 1605
          pstat->uapsd_bk = 3U;
        } else {
#line 1607
          pstat->uapsd_bk = 0U;
        }
#line 1609
        if (((unsigned long )pstat->qos_info & 8UL) != 0UL) {
#line 1610
          pstat->uapsd_be = 3U;
        } else {
#line 1612
          pstat->uapsd_be = 0U;
        }
#line 1614
        goto ldv_56232;
      } else {

      }
    } else {
#line 1617
      goto ldv_56232;
    }
#line 1619
    p = p + ((unsigned long )*(p + 1UL) + 2UL);
#line 1620
    goto ldv_56233;
    ldv_56232: ;
  } else {

  }
#line 1624
  memset((void *)(& pstat->htpriv.ht_cap), 0, 26UL);
#line 1625
  p = cfg80211_find_ie(45, pos, left);
#line 1627
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) > 25U) {
#line 1628
    pstat->flags = pstat->flags | 2048;
#line 1630
    pstat->flags = pstat->flags | 512;
#line 1632
    memcpy((void *)(& pstat->htpriv.ht_cap), (void const   *)p + 2U, 26UL);
  } else {
#line 1635
    pstat->flags = pstat->flags & -2049;
  }
#line 1637
  if (! pmlmepriv->htpriv.ht_option && ((unsigned long )pstat->flags & 2048UL) != 0UL) {
#line 1638
    status = 1U;
#line 1639
    goto OnAssocReq23aFail;
  } else {

  }
#line 1642
  if (((unsigned long )pstat->flags & 2048UL) != 0UL && (((unsigned long )pstat->wpa2_pairwise_cipher & 8UL) != 0UL || ((unsigned long )pstat->wpa_pairwise_cipher & 8UL) != 0UL)) {
#line 1645
    if (GlobalDebugLevel23A > 3U) {
#line 1645
      printk("\016RTL8723AU: HT: %pM tried to use TKIP with HT association\n", (u8 *)(& pstat->hwaddr));
    } else {

    }
  } else {

  }
#line 1652
  pstat->flags = (int )((unsigned int )pstat->flags | 2147483648U);
#line 1653
  i = 0;
#line 1653
  goto ldv_56236;
  ldv_56235: ;
#line 1654
  if (((int )pstat->bssrateset[i] & 127) > 22) {
#line 1655
    pstat->flags = pstat->flags & 2147483647;
#line 1656
    goto ldv_56234;
  } else {

  }
#line 1653
  i = i + 1;
  ldv_56236: ;
#line 1653
  if ((u32 )i < pstat->bssratelen) {
#line 1655
    goto ldv_56235;
  } else {

  }
  ldv_56234: ;
#line 1660
  if (((int )pstat->capability & 32) != 0) {
#line 1661
    pstat->flags = pstat->flags | 128;
  } else {
#line 1663
    pstat->flags = pstat->flags & -129;
  }
#line 1665
  if ((unsigned int )status != 0U) {
#line 1666
    goto OnAssocReq23aFail;
  } else {

  }
#line 1675
  if (pstat->aid != 0U) {
#line 1676
    if (GlobalDebugLevel23A > 3U) {
#line 1676
      printk("\016RTL8723AU:   old AID %d\n", pstat->aid);
    } else {

    }
  } else {
#line 1678
    pstat->aid = 1U;
#line 1678
    goto ldv_56239;
    ldv_56238: ;
#line 1679
    if ((unsigned long )pstapriv->sta_aid[pstat->aid - 1U] == (unsigned long )((struct sta_info *)0)) {
#line 1680
      goto ldv_56237;
    } else {

    }
#line 1678
    pstat->aid = pstat->aid + 1U;
    ldv_56239: ;
#line 1678
    if (pstat->aid <= 32U) {
#line 1680
      goto ldv_56238;
    } else {

    }
    ldv_56237: ;
#line 1682
    if (pstat->aid > 32U) {
#line 1683
      pstat->aid = 32U;
    } else {

    }
#line 1684
    if (pstat->aid > (uint )pstapriv->max_num_sta) {
#line 1686
      pstat->aid = 0U;
#line 1688
      if (GlobalDebugLevel23A > 3U) {
#line 1688
        printk("\016RTL8723AU:   no room for more AIDs\n");
      } else {

      }
#line 1690
      status = 17U;
#line 1692
      goto OnAssocReq23aFail;
    } else {
#line 1694
      pstapriv->sta_aid[pstat->aid - 1U] = pstat;
#line 1695
      if (GlobalDebugLevel23A > 3U) {
#line 1695
        printk("\016RTL8723AU: allocate new AID = (%d)\n", pstat->aid);
      } else {

      }
    }
  }
#line 1699
  pstat->state = pstat->state & 4294959103U;
#line 1700
  pstat->state = pstat->state | 16384U;
#line 1702
  spin_lock_bh(& pstapriv->auth_list_lock);
#line 1703
  tmp___2 = list_empty((struct list_head  const  *)(& pstat->auth_list));
#line 1703
  if (tmp___2 == 0) {
#line 1704
    list_del_init(& pstat->auth_list);
#line 1705
    pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt - 1);
  } else {

  }
#line 1707
  spin_unlock_bh(& pstapriv->auth_list_lock);
#line 1709
  spin_lock_bh(& pstapriv->asoc_list_lock);
#line 1710
  tmp___3 = list_empty((struct list_head  const  *)(& pstat->asoc_list));
#line 1710
  if (tmp___3 != 0) {
#line 1711
    pstat->expire_to = pstapriv->expire_to;
#line 1712
    list_add_tail(& pstat->asoc_list, & pstapriv->asoc_list);
#line 1713
    pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt + 1);
  } else {

  }
#line 1715
  spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 1718
  if (((unsigned long )pstat != (unsigned long )((struct sta_info *)0) && (pstat->state & 16384U) != 0U) && (unsigned int )status == 0U) {
#line 1721
    bss_cap_update_on_sta_join23a(padapter, pstat);
#line 1722
    sta_info_update23a(padapter, pstat);
#line 1725
    tmp___4 = ieee80211_is_assoc_req((int )mgmt->frame_control);
#line 1725
    if (tmp___4 != 0) {
#line 1726
      issue_assocrsp(padapter, (int )status, pstat, 16);
    } else {
#line 1729
      issue_assocrsp(padapter, (int )status, pstat, 48);
    }
#line 1733
    if (GlobalDebugLevel23A > 3U) {
#line 1733
      printk("\016RTL8723AU: indicate_sta_join_event to upper layer - hostapd\n");
    } else {

    }
#line 1734
    rtw_cfg80211_indicate_sta_assoc(padapter, pframe, pkt_len);
#line 1737
    report_add_sta_event23a(padapter, (unsigned char *)(& pstat->hwaddr), (int )pstat->aid);
  } else {

  }
#line 1740
  return (1);
  asoc_class2_error: 
#line 1744
  issue_deauth23a(padapter, (unsigned char *)(& mgmt->sa), (int )status);
#line 1745
  return (0);
  OnAssocReq23aFail: 
#line 1749
  pstat->aid = 0U;
#line 1750
  tmp___5 = ieee80211_is_assoc_req((int )mgmt->frame_control);
#line 1750
  if (tmp___5 != 0) {
#line 1751
    issue_assocrsp(padapter, (int )status, pstat, 16);
  } else {
#line 1754
    issue_assocrsp(padapter, (int )status, pstat, 48);
  }
#line 1759
  return (0);
}
}
#line 1763 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnAssocRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *pmgmt ;
  int res ;
  unsigned short status ;
  u8 const   *p ;
  u8 const   *pie ;
  u8 *pframe ;
  int pkt_len ;
  int pielen ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u16 tmp___2 ;
  void *tmp___3 ;

  {
#line 1765
  pmlmepriv = & padapter->mlmepriv;
#line 1766
  pmlmeext = & padapter->mlmeextpriv;
#line 1767
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1768
  skb = precv_frame->pkt;
#line 1769
  pmgmt = (struct ieee80211_mgmt *)skb->data;
#line 1773
  pframe = skb->data;
#line 1774
  pkt_len = (int )skb->len;
#line 1777
  if (GlobalDebugLevel23A > 3U) {
#line 1777
    printk("\016RTL8723AU: %s\n", "OnAssocRsp23a");
  } else {

  }
#line 1780
  tmp = myid(& padapter->eeprompriv);
#line 1780
  tmp___0 = ether_addr_equal((u8 const   *)tmp, (u8 const   *)(& pmgmt->da));
#line 1780
  if (tmp___0) {
#line 1780
    tmp___1 = 0;
  } else {
#line 1780
    tmp___1 = 1;
  }
#line 1780
  if (tmp___1) {
#line 1781
    return (1);
  } else {

  }
#line 1783
  if ((pmlmeinfo->state & 9216U) == 0U) {
#line 1784
    return (1);
  } else {

  }
#line 1786
  if ((pmlmeinfo->state & 16384U) != 0U) {
#line 1787
    return (1);
  } else {

  }
#line 1789
  ldv_del_timer_sync_106(& pmlmeext->link_timer);
#line 1792
  status = pmgmt->u.assoc_resp.status_code;
#line 1793
  if ((unsigned int )status != 0U) {
#line 1794
    if (GlobalDebugLevel23A > 3U) {
#line 1794
      printk("\016RTL8723AU: assoc reject, status code: %d\n", (int )status);
    } else {

    }
#line 1795
    pmlmeinfo->state = 0U;
#line 1796
    res = -4;
#line 1797
    goto report_assoc_result;
  } else {

  }
#line 1801
  pmlmeinfo->capability = pmgmt->u.assoc_resp.capab_info;
#line 1804
  pmlmeinfo->slotTime = ((unsigned long )pmlmeinfo->capability & 1024UL) != 0UL ? 9U : 20U;
#line 1807
  tmp___2 = (unsigned int )pmgmt->u.assoc_resp.aid & 16383U;
#line 1807
  pmlmeinfo->aid = tmp___2;
#line 1807
  res = (int )tmp___2;
#line 1809
  pie = (u8 const   *)pframe + 30U;
#line 1810
  pielen = (int )((unsigned int )pkt_len - 30U);
#line 1813
  p = cfg80211_find_ie(45, (u8 const   *)(& pmgmt->u.assoc_resp.variable), pielen);
#line 1815
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 1816
    HT_caps_handler23a(padapter, p);
  } else {

  }
#line 1818
  p = cfg80211_find_ie(61, (u8 const   *)(& pmgmt->u.assoc_resp.variable), pielen);
#line 1820
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 1821
    HT_info_handler23a(padapter, p);
  } else {

  }
#line 1823
  p = cfg80211_find_ie(42, (u8 const   *)(& pmgmt->u.assoc_resp.variable), pielen);
#line 1825
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 1826
    ERP_IE_handler23a(padapter, p);
  } else {

  }
#line 1828
  pie = (u8 const   *)pframe + 30U;
  ldv_56260: 
#line 1830
  p = cfg80211_find_vendor_ie(20722U, 2, pie, (int )((unsigned int )((long )(pframe + (unsigned long )pkt_len)) - (unsigned int )((long )pie)));
#line 1833
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
#line 1834
    goto ldv_56258;
  } else {

  }
#line 1836
  pie = p + ((unsigned long )*(p + 1UL) + 2UL);
#line 1838
  if ((unsigned int )((unsigned char )*(p + 1UL)) <= 4U) {
#line 1839
    goto ldv_56259;
  } else {

  }
#line 1841
  if ((unsigned int )((unsigned char )*(p + 6UL)) == 1U) {
#line 1842
    goto ldv_56258;
  } else {

  }
  ldv_56259: ;
#line 1843
  goto ldv_56260;
  ldv_56258: ;
#line 1845
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 1846
    WMM_param_handler23a(padapter, p);
  } else {

  }
#line 1848
  pmlmeinfo->state = pmlmeinfo->state & 4294959103U;
#line 1849
  pmlmeinfo->state = pmlmeinfo->state | 16384U;
#line 1852
  UpdateBrateTbl23a(padapter, (u8 *)(& pmlmeinfo->network.SupportedRates));
  report_assoc_result: 
#line 1855
  pmlmepriv->assoc_rsp_len = 0U;
#line 1856
  if (res > 0) {
#line 1857
    kfree((void const   *)pmlmepriv->assoc_rsp);
#line 1858
    tmp___3 = kmalloc((size_t )pkt_len, 32U);
#line 1858
    pmlmepriv->assoc_rsp = (u8 *)tmp___3;
#line 1859
    if ((unsigned long )pmlmepriv->assoc_rsp != (unsigned long )((u8 *)0U)) {
#line 1860
      memcpy((void *)pmlmepriv->assoc_rsp, (void const   *)pframe, (size_t )pkt_len);
#line 1861
      pmlmepriv->assoc_rsp_len = (u32 )pkt_len;
    } else {

    }
  } else {
#line 1864
    kfree((void const   *)pmlmepriv->assoc_rsp);
  }
#line 1866
  report_join_res23a(padapter, res);
#line 1868
  return (1);
}
}
#line 1872 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnDeAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  unsigned short reason ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  u8 updated ;
  int tmp___2 ;
  bool tmp___3 ;

  {
#line 1875
  pmlmepriv = & padapter->mlmepriv;
#line 1876
  pmlmeext = & padapter->mlmeextpriv;
#line 1877
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1878
  skb = precv_frame->pkt;
#line 1879
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 1881
  tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 1881
  tmp___0 = ether_addr_equal((u8 const   *)(& mgmt->bssid), (u8 const   *)tmp);
#line 1881
  if (tmp___0) {
#line 1881
    tmp___1 = 0;
  } else {
#line 1881
    tmp___1 = 1;
  }
#line 1881
  if (tmp___1) {
#line 1883
    return (1);
  } else {

  }
#line 1885
  reason = mgmt->u.deauth.reason_code;
#line 1887
  if (GlobalDebugLevel23A > 3U) {
#line 1887
    printk("\016RTL8723AU: %s Reason code(%d)\n", "OnDeAuth23a", (int )reason);
  } else {

  }
#line 1890
  tmp___3 = check_fwstate(pmlmepriv, 16);
#line 1890
  if ((int )tmp___3) {
#line 1892
    pstapriv = & padapter->stapriv;
#line 1894
    if (GlobalDebugLevel23A != 0U) {
#line 1894
      printk("\016RTL8723AU: ap recv deauth reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->sa));
    } else {

    }
#line 1897
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
#line 1898
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1899
      updated = 0U;
#line 1901
      spin_lock_bh(& pstapriv->asoc_list_lock);
#line 1902
      tmp___2 = list_empty((struct list_head  const  *)(& psta->asoc_list));
#line 1902
      if (tmp___2 == 0) {
#line 1903
        list_del_init(& psta->asoc_list);
#line 1904
        pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
#line 1905
        updated = ap_free_sta23a(padapter, psta, 0, (int )reason);
      } else {

      }
#line 1908
      spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 1910
      associated_clients_update23a(padapter, (int )updated);
    } else {

    }
#line 1913
    return (1);
  } else {
#line 1917
    if (GlobalDebugLevel23A != 0U) {
#line 1917
      printk("\016RTL8723AU: sta recv deauth reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->bssid));
    } else {

    }
#line 1920
    receive_disconnect23a(padapter, (unsigned char *)(& mgmt->bssid), (int )reason);
  }
#line 1922
  pmlmepriv->LinkDetectInfo.bBusyTraffic = 0;
#line 1924
  return (1);
}
}
#line 1928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnDisassoc23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  unsigned short reason ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  u8 updated ;
  int tmp___2 ;
  bool tmp___3 ;

  {
#line 1931
  pmlmepriv = & padapter->mlmepriv;
#line 1932
  pmlmeext = & padapter->mlmeextpriv;
#line 1933
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1934
  skb = precv_frame->pkt;
#line 1935
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 1937
  tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 1937
  tmp___0 = ether_addr_equal((u8 const   *)(& mgmt->bssid), (u8 const   *)tmp);
#line 1937
  if (tmp___0) {
#line 1937
    tmp___1 = 0;
  } else {
#line 1937
    tmp___1 = 1;
  }
#line 1937
  if (tmp___1) {
#line 1939
    return (1);
  } else {

  }
#line 1941
  reason = mgmt->u.disassoc.reason_code;
#line 1943
  if (GlobalDebugLevel23A > 3U) {
#line 1943
    printk("\016RTL8723AU: %s Reason code(%d)\n", "OnDisassoc23a", (int )reason);
  } else {

  }
#line 1946
  tmp___3 = check_fwstate(pmlmepriv, 16);
#line 1946
  if ((int )tmp___3) {
#line 1948
    pstapriv = & padapter->stapriv;
#line 1950
    if (GlobalDebugLevel23A != 0U) {
#line 1950
      printk("\016RTL8723AU: ap recv disassoc reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->sa));
    } else {

    }
#line 1953
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
#line 1954
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1955
      updated = 0U;
#line 1957
      spin_lock_bh(& pstapriv->asoc_list_lock);
#line 1958
      tmp___2 = list_empty((struct list_head  const  *)(& psta->asoc_list));
#line 1958
      if (tmp___2 == 0) {
#line 1959
        list_del_init(& psta->asoc_list);
#line 1960
        pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
#line 1961
        updated = ap_free_sta23a(padapter, psta, 0, (int )reason);
      } else {

      }
#line 1964
      spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 1966
      associated_clients_update23a(padapter, (int )updated);
    } else {

    }
#line 1969
    return (1);
  } else {
#line 1973
    if (GlobalDebugLevel23A != 0U) {
#line 1973
      printk("\016RTL8723AU: ap recv disassoc reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->bssid));
    } else {

    }
#line 1976
    receive_disconnect23a(padapter, (unsigned char *)(& mgmt->bssid), (int )reason);
  }
#line 1978
  pmlmepriv->LinkDetectInfo.bBusyTraffic = 0;
#line 1979
  return (1);
}
}
#line 1983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnAtim23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 1985
  if (GlobalDebugLevel23A > 3U) {
#line 1985
    printk("\016RTL8723AU: %s\n", "OnAtim23a");
  } else {

  }
#line 1986
  return (1);
}
}
#line 1990 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int on_action_spct23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 1992
  return (0);
}
}
#line 1996 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnAction23a_qos(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 1998
  return (1);
}
}
#line 2002 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnAction23a_dls(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 2004
  return (1);
}
}
#line 2007 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnAction23a_back23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  u8 *addr ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  unsigned char category ;
  unsigned char action ;
  unsigned short tid ;
  unsigned short status ;
  unsigned short capab ;
  unsigned short params ;
  unsigned short reason_code ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  struct sta_priv *pstapriv ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 2011
  psta = (struct sta_info *)0;
#line 2014
  reason_code = 0U;
#line 2015
  pmlmeext = & padapter->mlmeextpriv;
#line 2016
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2017
  skb = precv_frame->pkt;
#line 2018
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 2019
  pstapriv = & padapter->stapriv;
#line 2022
  tmp = myid(& padapter->eeprompriv);
#line 2022
  tmp___0 = ether_addr_equal((u8 const   *)tmp, (u8 const   *)(& mgmt->da));
#line 2022
  if (tmp___0) {
#line 2022
    tmp___1 = 0;
  } else {
#line 2022
    tmp___1 = 1;
  }
#line 2022
  if (tmp___1) {
#line 2023
    return (1);
  } else {

  }
#line 2025
  if (GlobalDebugLevel23A > 3U) {
#line 2025
    printk("\016RTL8723AU: %s\n", "OnAction23a_back23a");
  } else {

  }
#line 2027
  if ((pmlmeinfo->state & 3U) != 3U) {
#line 2028
    if ((pmlmeinfo->state & 16384U) == 0U) {
#line 2029
      return (1);
    } else {

    }
  } else {

  }
#line 2031
  addr = (u8 *)(& mgmt->sa);
#line 2032
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)addr);
#line 2034
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 2035
    return (1);
  } else {

  }
#line 2037
  category = mgmt->u.action.category;
#line 2038
  if ((unsigned int )category == 3U) {
#line 2039
    if ((unsigned int )pmlmeinfo->HT_enable == 0U) {
#line 2040
      return (1);
    } else {

    }
#line 2043
    action = mgmt->u.action.u.wme_action.action_code;
#line 2044
    if (GlobalDebugLevel23A > 3U) {
#line 2044
      printk("\016RTL8723AU: %s, action =%d\n", "OnAction23a_back23a", (int )action);
    } else {

    }
#line 2045
    switch ((int )action) {
    case 0: 
#line 2047
    memcpy((void *)(& pmlmeinfo->ADDBA_req), (void const   *)(& mgmt->u.action.u.addba_req.dialog_token),
             7UL);
#line 2050
    process_addba_req23a(padapter, (u8 *)(& pmlmeinfo->ADDBA_req), addr);
#line 2052
    if ((int )pmlmeinfo->bAcceptAddbaReq) {
#line 2053
      issue_action_BA23a(padapter, (unsigned char const   *)addr, 1, 0);
    } else {
#line 2057
      issue_action_BA23a(padapter, (unsigned char const   *)addr, 1, 37);
    }
#line 2060
    goto ldv_56327;
    case 1: 
#line 2062
    status = get_unaligned_le16((void const   *)(& mgmt->u.action.u.addba_resp.status));
#line 2064
    capab = get_unaligned_le16((void const   *)(& mgmt->u.action.u.addba_resp.capab));
#line 2066
    tid = (unsigned short )(((int )capab & 60) >> 2);
#line 2067
    if ((unsigned int )status == 0U) {
#line 2068
      if (GlobalDebugLevel23A > 3U) {
#line 2068
        printk("\016RTL8723AU: agg_enable for TID =%d\n", (int )tid);
      } else {

      }
#line 2069
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap | (int )((u16 )(1UL << (int )tid));
#line 2070
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    } else {
#line 2072
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    }
#line 2073
    goto ldv_56327;
    case 2: 
#line 2076
    params = get_unaligned_le16((void const   *)(& mgmt->u.action.u.delba.params));
#line 2078
    tid = (int )params >> 12;
#line 2080
    if (((int )params & 2048) != 0) {
#line 2081
      preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )tid;
#line 2082
      preorder_ctrl->enable = 0U;
#line 2083
      preorder_ctrl->indicate_seq = 65535U;
    } else {
#line 2085
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
#line 2086
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    }
#line 2088
    reason_code = get_unaligned_le16((void const   *)(& mgmt->u.action.u.delba.reason_code));
#line 2092
    goto ldv_56327;
    default: ;
#line 2094
    goto ldv_56327;
    }
    ldv_56327: ;
  } else {

  }
#line 2097
  return (1);
}
}
#line 2100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int on_action_public23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  u8 *pframe ;
  int freq ;
  int channel ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u8 tmp___2 ;
  bool tmp___3 ;

  {
#line 2103
  skb = precv_frame->pkt;
#line 2104
  hdr = (struct ieee80211_hdr *)skb->data;
#line 2105
  pframe = skb->data;
#line 2109
  tmp = myid(& padapter->eeprompriv);
#line 2109
  tmp___0 = ether_addr_equal((u8 const   *)tmp, (u8 const   *)(& hdr->addr1));
#line 2109
  if (tmp___0) {
#line 2109
    tmp___1 = 0;
  } else {
#line 2109
    tmp___1 = 1;
  }
#line 2109
  if (tmp___1) {
#line 2110
    return (0);
  } else {

  }
#line 2112
  tmp___2 = rtw_get_oper_ch23a(padapter);
#line 2112
  channel = (int )tmp___2;
#line 2114
  if (channel <= 14) {
#line 2115
    freq = ieee80211_channel_to_frequency(channel, 0);
  } else {
#line 2118
    freq = ieee80211_channel_to_frequency(channel, 1);
  }
#line 2121
  tmp___3 = cfg80211_rx_mgmt(padapter->rtw_wdev, freq, 0, (u8 const   *)pframe, (size_t )skb->len,
                             0U);
#line 2121
  if ((int )tmp___3) {
#line 2123
    return (1);
  } else {

  }
#line 2125
  return (0);
}
}
#line 2129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnAction23a_ht(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 2131
  return (1);
}
}
#line 2135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnAction23a_wmm(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 2137
  return (1);
}
}
#line 2141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnAction23a_p2p(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 2143
  return (1);
}
}
#line 2147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int OnAction23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  int i ;
  u8 category ;
  struct action_handler *ptable ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;

  {
#line 2152
  skb = precv_frame->pkt;
#line 2153
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 2155
  category = mgmt->u.action.category;
#line 2157
  i = 0;
#line 2157
  goto ldv_56362;
  ldv_56361: 
#line 2159
  ptable = (struct action_handler *)(& OnAction23a_tbl) + (unsigned long )i;
#line 2161
  if ((unsigned int )category == ptable->num) {
#line 2162
    (*(ptable->func))(padapter, precv_frame);
  } else {

  }
#line 2158
  i = i + 1;
  ldv_56362: ;
#line 2157
  if ((unsigned int )i <= 8U) {
#line 2160
    goto ldv_56361;
  } else {

  }

#line 2165
  return (1);
}
}
#line 2168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int DoReserved23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 2171
  return (1);
}
}
#line 2174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
struct xmit_frame *alloc_mgtxmitframe23a(struct xmit_priv *pxmitpriv ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct xmit_buf *pxmitbuf ;

  {
#line 2179
  pmgntframe = rtw_alloc_xmitframe23a_ext(pxmitpriv);
#line 2181
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 2182
    if (GlobalDebugLevel23A > 3U) {
#line 2182
      printk("\016RTL8723AU: %s(%s): alloc xmitframe fail\n", "alloc_mgtxmitframe23a",
             (char *)(& ((pxmitpriv->adapter)->pnetdev)->name));
    } else {

    }
#line 2184
    goto exit;
  } else {

  }
#line 2187
  pxmitbuf = rtw_alloc_xmitbuf23a_ext(pxmitpriv);
#line 2188
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 2189
    if (GlobalDebugLevel23A > 3U) {
#line 2189
      printk("\016RTL8723AU: %s(%s): alloc xmitbuf fail\n", "alloc_mgtxmitframe23a",
             (char *)(& ((pxmitpriv->adapter)->pnetdev)->name));
    } else {

    }
#line 2191
    rtw_free_xmitframe23a(pxmitpriv, pmgntframe);
#line 2192
    pmgntframe = (struct xmit_frame *)0;
#line 2193
    goto exit;
  } else {

  }
#line 2196
  pmgntframe->frame_tag = 3;
#line 2197
  pmgntframe->pxmitbuf = pxmitbuf;
#line 2198
  pmgntframe->buf_addr = pxmitbuf->pbuf;
#line 2199
  pxmitbuf->priv_data = (void *)pmgntframe;
  exit: ;
#line 2202
  return (pmgntframe);
}
}
#line 2211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void update_mgnt_tx_rate23a(struct rtw_adapter *padapter , u8 rate ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
#line 2213
  pmlmeext = & padapter->mlmeextpriv;
#line 2215
  pmlmeext->tx_rate = rate;
#line 2216
  if (GlobalDebugLevel23A > 3U) {
#line 2216
    printk("\016RTL8723AU: %s(): rate = %x\n", "update_mgnt_tx_rate23a", (int )rate);
  } else {

  }
#line 2217
  return;
}
}
#line 2219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void update_mgntframe_attrib23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
#line 2222
  pmlmeext = & padapter->mlmeextpriv;
#line 2224
  memset((void *)pattrib, 0, 112UL);
#line 2226
  pattrib->hdrlen = 24U;
#line 2227
  pattrib->nr_frags = 1U;
#line 2228
  pattrib->priority = 7U;
#line 2229
  pattrib->mac_id = 0U;
#line 2230
  pattrib->qsel = 18U;
#line 2232
  pattrib->pktlen = 0U;
#line 2234
  if ((int )pmlmeext->cur_wireless_mode & 1) {
#line 2235
    pattrib->raid = 6U;
  } else {
#line 2237
    pattrib->raid = 5U;
  }
#line 2239
  pattrib->encrypt = 0U;
#line 2240
  pattrib->bswenc = 0U;
#line 2242
  pattrib->qos_en = 0U;
#line 2243
  pattrib->ht_en = 0U;
#line 2244
  pattrib->bwmode = 0U;
#line 2245
  pattrib->ch_offset = 0U;
#line 2246
  pattrib->sgi = 0U;
#line 2248
  pattrib->seqnum = pmlmeext->mgnt_seq;
#line 2250
  pattrib->retry_ctrl = 1U;
#line 2251
  return;
}
}
#line 2253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void dump_mgntframe23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) 
{ 


  {
#line 2256
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
#line 2258
    return;
  } else {

  }
#line 2260
  rtl8723au_mgnt_xmit(padapter, pmgntframe);
#line 2261
  return;
}
}
#line 2263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
s32 dump_mgntframe23a_and_wait(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ,
                               int timeout_ms ) 
{ 
  int ret ;
  unsigned long irqL ;
  struct xmit_priv *pxmitpriv ;
  struct xmit_buf *pxmitbuf ;
  struct submit_ctx sctx ;
  raw_spinlock_t *tmp ;

  {
#line 2266
  ret = 0;
#line 2268
  pxmitpriv = & padapter->xmitpriv;
#line 2269
  pxmitbuf = pmgntframe->pxmitbuf;
#line 2272
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
#line 2274
    return (ret);
  } else {

  }
#line 2276
  rtw_sctx_init23a(& sctx, timeout_ms);
#line 2277
  pxmitbuf->sctx = & sctx;
#line 2279
  ret = rtl8723au_mgnt_xmit(padapter, pmgntframe);
#line 2281
  if (ret == 1) {
#line 2282
    ret = rtw_sctx_wait23a(& sctx);
  } else {

  }
#line 2284
  tmp = spinlock_check(& pxmitpriv->lock_sctx);
#line 2284
  irqL = _raw_spin_lock_irqsave(tmp);
#line 2285
  pxmitbuf->sctx = (struct submit_ctx *)0;
#line 2286
  spin_unlock_irqrestore(& pxmitpriv->lock_sctx, irqL);
#line 2288
  return (ret);
}
}
#line 2291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
s32 dump_mgntframe23a_and_wait_ack23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) 
{ 
  int ret ;
  u32 timeout_ms ;
  struct xmit_priv *pxmitpriv ;
  int tmp ;

  {
#line 2294
  ret = 0;
#line 2295
  timeout_ms = 500U;
#line 2296
  pxmitpriv = & padapter->xmitpriv;
#line 2298
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
#line 2300
    return (0);
  } else {

  }
#line 2302
  mutex_lock_nested(& pxmitpriv->ack_tx_mutex, 0U);
#line 2303
  pxmitpriv->ack_tx = 1;
#line 2305
  pmgntframe->ack_report = 1U;
#line 2306
  tmp = rtl8723au_mgnt_xmit(padapter, pmgntframe);
#line 2306
  if (tmp == 1) {
#line 2307
    ret = rtw_ack_tx_wait23a(pxmitpriv, timeout_ms);
  } else {

  }
#line 2309
  pxmitpriv->ack_tx = 0;
#line 2310
  mutex_unlock(& pxmitpriv->ack_tx_mutex);
#line 2312
  return (ret);
}
}
#line 2315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int update_hidden_ssid(u8 *ies , u32 ies_len , u8 hidden_ssid_mode ) 
{ 
  u8 *ssid_ie ;
  int ssid_len_ori ;
  int len_diff ;
  u8 *next_ie ;
  u32 remain_len ;

  {
#line 2319
  len_diff = 0;
#line 2323
  ssid_ie = rtw_get_ie23a(ies, 0, & ssid_len_ori, (int )ies_len);
#line 2328
  if ((unsigned long )ssid_ie != (unsigned long )((u8 *)0U) && ssid_len_ori > 0) {
#line 2329
    switch ((int )hidden_ssid_mode) {
    case 1: 
#line 2331
    next_ie = ssid_ie + ((unsigned long )ssid_len_ori + 2UL);
#line 2332
    remain_len = ((u32 )((long )ies) - (u32 )((long )next_ie)) + ies_len;
#line 2334
    *(ssid_ie + 1UL) = 0U;
#line 2335
    memcpy((void *)ssid_ie + 2U, (void const   *)next_ie, (size_t )remain_len);
#line 2336
    len_diff = len_diff - ssid_len_ori;
#line 2338
    goto ldv_56421;
    case 2: 
#line 2340
    memset((void *)ssid_ie + 2U, 0, (size_t )ssid_len_ori);
#line 2341
    goto ldv_56421;
    default: ;
#line 2343
    goto ldv_56421;
    }
    ldv_56421: ;
  } else {

  }
#line 2347
  return (len_diff);
}
}
#line 2350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void issue_beacon23a(struct rtw_adapter *padapter , int timeout_ms ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_mgmt *mgmt ;
  unsigned int rate_len ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 bc_addr___0[6U] ;
  u8 const   *wps_ie ;
  u8 sr ;
  int len_diff ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *iebuf ;
  int buflen ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 erpinfo ;
  u32 ATIMWindow ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;

  {
#line 2357
  pxmitpriv = & padapter->xmitpriv;
#line 2358
  pmlmepriv = & padapter->mlmepriv;
#line 2359
  pmlmeext = & padapter->mlmeextpriv;
#line 2360
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2361
  cur_network = & pmlmeinfo->network;
#line 2362
  bc_addr___0[0] = 255U;
#line 2362
  bc_addr___0[1] = 255U;
#line 2362
  bc_addr___0[2] = 255U;
#line 2362
  bc_addr___0[3] = 255U;
#line 2362
  bc_addr___0[4] = 255U;
#line 2362
  bc_addr___0[5] = 255U;
#line 2364
  sr = 0U;
#line 2369
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 2370
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 2371
    if (GlobalDebugLevel23A > 3U) {
#line 2371
      printk("\016RTL8723AU: %s, alloc mgnt frame fail\n", "issue_beacon23a");
    } else {

    }
#line 2372
    return;
  } else {

  }
#line 2375
  spin_lock_bh(& pmlmepriv->bcn_update_lock);
#line 2379
  pattrib = & pmgntframe->attrib;
#line 2380
  update_mgntframe_attrib23a(padapter, pattrib);
#line 2381
  pattrib->qsel = 16U;
#line 2383
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 2385
  pframe = pmgntframe->buf_addr + 40U;
#line 2386
  mgmt = (struct ieee80211_mgmt *)pframe;
#line 2388
  mgmt->frame_control = 128U;
#line 2390
  mgmt->seq_ctrl = 0U;
#line 2392
  ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)(& bc_addr___0));
#line 2393
  tmp = myid(& padapter->eeprompriv);
#line 2393
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp);
#line 2394
  tmp___0 = get_my_bssid23a(cur_network);
#line 2394
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___0);
#line 2398
  put_unaligned_le16((int )cur_network->beacon_interval, (void *)(& mgmt->u.beacon.beacon_int));
#line 2401
  put_unaligned_le16((int )cur_network->capability, (void *)(& mgmt->u.beacon.capab_info));
#line 2404
  pframe = (unsigned char *)(& mgmt->u.beacon.variable);
#line 2405
  pattrib->pktlen = 36U;
#line 2407
  if ((pmlmeinfo->state & 3U) == 3U) {
#line 2411
    memcpy((void *)pframe, (void const   *)(& cur_network->IEs), (size_t )cur_network->IELength);
#line 2412
    len_diff = update_hidden_ssid(pframe, cur_network->IELength, (int )pmlmeinfo->hidden_ssid_mode);
#line 2414
    pframe = pframe + (unsigned long )(cur_network->IELength + (u32 )len_diff);
#line 2415
    pattrib->pktlen = pattrib->pktlen + (cur_network->IELength + (u32 )len_diff);
#line 2417
    iebuf = (u8 *)(& mgmt->u.beacon.variable);
#line 2418
    buflen = (int )(pattrib->pktlen - 36U);
#line 2420
    wps_ie = cfg80211_find_vendor_ie(20722U, 4, (u8 const   *)iebuf, buflen);
#line 2424
    if ((unsigned long )wps_ie != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(wps_ie + 1UL)) != 0U) {
#line 2425
      rtw_get_wps_attr_content23a(wps_ie, (uint )*(wps_ie + 1UL), 4161, & sr);
    } else {

    }
#line 2429
    if ((unsigned int )sr != 0U) {
#line 2430
      set_fwstate(pmlmepriv, 256);
    } else {
#line 2432
      _clr_fwstate_(pmlmepriv, 256);
    }
#line 2434
    goto _issue_bcn;
  } else {

  }
#line 2438
  tmp___1 = rtw_set_ie23a(pframe, 0, (uint )cur_network->Ssid.ssid_len, (u8 const   *)(& cur_network->Ssid.ssid),
                          & pattrib->pktlen);
#line 2438
  pframe = tmp___1;
#line 2443
  rate_len = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
#line 2444
  tmp___2 = rtw_set_ie23a(pframe, 1, 8U < rate_len ? 8U : rate_len, (u8 const   *)(& cur_network->SupportedRates),
                          & pattrib->pktlen);
#line 2444
  pframe = tmp___2;
#line 2449
  tmp___3 = rtw_set_ie23a(pframe, 3, 1U, (u8 const   *)(& cur_network->DSConfig),
                          & pattrib->pktlen);
#line 2449
  pframe = tmp___3;
#line 2454
  erpinfo = 0U;
#line 2458
  ATIMWindow = 0U;
#line 2459
  tmp___4 = rtw_set_ie23a(pframe, 6, 2U, (u8 const   *)(& ATIMWindow), & pattrib->pktlen);
#line 2459
  pframe = tmp___4;
#line 2464
  tmp___5 = rtw_set_ie23a(pframe, 42, 1U, (u8 const   *)(& erpinfo), & pattrib->pktlen);
#line 2464
  pframe = tmp___5;
#line 2469
  if (rate_len > 8U) {
#line 2470
    tmp___6 = rtw_set_ie23a(pframe, 50, rate_len - 8U, (u8 const   *)(& cur_network->SupportedRates) + 8U,
                            & pattrib->pktlen);
#line 2470
    pframe = tmp___6;
  } else {

  }
  _issue_bcn: 
#line 2480
  pmlmepriv->update_bcn = 0U;
#line 2482
  spin_unlock_bh(& pmlmepriv->bcn_update_lock);
#line 2485
  if (pattrib->pktlen + 32U > 512U) {
#line 2486
    if (GlobalDebugLevel23A > 3U) {
#line 2486
      printk("\016RTL8723AU: beacon frame too large\n");
    } else {

    }
#line 2487
    return;
  } else {

  }
#line 2490
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 2493
  if (timeout_ms > 0) {
#line 2494
    dump_mgntframe23a_and_wait(padapter, pmgntframe, timeout_ms);
  } else {
#line 2496
    dump_mgntframe23a(padapter, pmgntframe);
  }
#line 2497
  return;
}
}
#line 2499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void issue_probersp(struct rtw_adapter *padapter , unsigned char *da ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_mgmt *mgmt ;
  unsigned char *mac ;
  unsigned char *bssid ;
  struct xmit_priv *pxmitpriv ;
  u8 const   *pwps_ie ;
  u8 *ssid_ie ;
  int ssid_ielen ;
  int ssid_ielen_diff ;
  u8 buf[768U] ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  unsigned int rate_len ;
  u8 *tmp ;
  uint remainder_ielen ;
  u8 *remainder_ie ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 erpinfo ;
  u32 ATIMWindow ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;

  {
#line 2506
  pxmitpriv = & padapter->xmitpriv;
#line 2514
  pmlmeext = & padapter->mlmeextpriv;
#line 2515
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2516
  cur_network = & pmlmeinfo->network;
#line 2521
  if (cur_network->IELength > 768U) {
#line 2522
    return;
  } else {

  }
#line 2524
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 2525
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 2526
    if (GlobalDebugLevel23A > 3U) {
#line 2526
      printk("\016RTL8723AU: %s, alloc mgnt frame fail\n", "issue_probersp");
    } else {

    }
#line 2527
    return;
  } else {

  }
#line 2531
  pattrib = & pmgntframe->attrib;
#line 2532
  update_mgntframe_attrib23a(padapter, pattrib);
#line 2534
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 2536
  pframe = pmgntframe->buf_addr + 40U;
#line 2537
  mgmt = (struct ieee80211_mgmt *)pframe;
#line 2539
  tmp = myid(& padapter->eeprompriv);
#line 2539
  mac = tmp;
#line 2540
  bssid = (unsigned char *)(& cur_network->MacAddress);
#line 2542
  mgmt->frame_control = 80U;
#line 2545
  ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)da);
#line 2546
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)mac);
#line 2547
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)bssid);
#line 2549
  mgmt->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 2550
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 2552
  pattrib->hdrlen = 24U;
#line 2555
  put_unaligned_le16((int )cur_network->beacon_interval, (void *)(& mgmt->u.probe_resp.beacon_int));
#line 2558
  put_unaligned_le16((int )cur_network->capability, (void *)(& mgmt->u.probe_resp.capab_info));
#line 2561
  pframe = (unsigned char *)(& mgmt->u.probe_resp.variable);
#line 2562
  pattrib->pktlen = 36U;
#line 2568
  if ((pmlmeinfo->state & 3U) == 3U) {
#line 2569
    pwps_ie = cfg80211_find_vendor_ie(20722U, 4, (u8 const   *)(& cur_network->IEs),
                                      (int )cur_network->IELength);
#line 2574
    memcpy((void *)pframe, (void const   *)(& cur_network->IEs), (size_t )cur_network->IELength);
#line 2575
    pframe = pframe + (unsigned long )cur_network->IELength;
#line 2576
    pattrib->pktlen = pattrib->pktlen + cur_network->IELength;
#line 2580
    ssid_ie = rtw_get_ie23a((u8 *)(& mgmt->u.probe_resp.variable), 0, & ssid_ielen,
                            (int )((unsigned int )((long )pframe) - (unsigned int )((long )(& mgmt->u.probe_resp.variable))));
#line 2584
    ssid_ielen_diff = (int )cur_network->Ssid.ssid_len - ssid_ielen;
#line 2586
    if ((unsigned long )ssid_ie != (unsigned long )((u8 *)0U) && (unsigned int )cur_network->Ssid.ssid_len != 0U) {
#line 2590
      remainder_ie = ssid_ie + 2UL;
#line 2592
      remainder_ielen = (uint )((long )pframe) - (uint )((long )remainder_ie);
#line 2594
      if (GlobalDebugLevel23A > 4U) {
#line 2594
        printk("\016RTL8723AU: %s(%s): remainder_ielen > MAX_IE_SZ\n", "issue_probersp",
               (char *)(& (padapter->pnetdev)->name));
      } else {

      }
#line 2597
      if (remainder_ielen > 768U) {
#line 2598
        remainder_ielen = 768U;
      } else {

      }
#line 2600
      memcpy((void *)(& buf), (void const   *)remainder_ie, (size_t )remainder_ielen);
#line 2601
      memcpy((void *)remainder_ie + (unsigned long )ssid_ielen_diff, (void const   *)(& buf),
               (size_t )remainder_ielen);
#line 2603
      *(ssid_ie + 1UL) = cur_network->Ssid.ssid_len;
#line 2604
      memcpy((void *)ssid_ie + 2U, (void const   *)(& cur_network->Ssid.ssid), (size_t )cur_network->Ssid.ssid_len);
#line 2607
      pframe = pframe + (unsigned long )ssid_ielen_diff;
#line 2608
      pattrib->pktlen = pattrib->pktlen + (u32 )ssid_ielen_diff;
    } else {

    }
  } else {
#line 2614
    tmp___0 = rtw_set_ie23a(pframe, 0, (uint )cur_network->Ssid.ssid_len, (u8 const   *)(& cur_network->Ssid.ssid),
                            & pattrib->pktlen);
#line 2614
    pframe = tmp___0;
#line 2620
    rate_len = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
#line 2621
    tmp___1 = rtw_set_ie23a(pframe, 1, 8U < rate_len ? 8U : rate_len, (u8 const   *)(& cur_network->SupportedRates),
                            & pattrib->pktlen);
#line 2621
    pframe = tmp___1;
#line 2627
    tmp___2 = rtw_set_ie23a(pframe, 3, 1U, (u8 const   *)(& cur_network->DSConfig),
                            & pattrib->pktlen);
#line 2627
    pframe = tmp___2;
#line 2631
    if ((pmlmeinfo->state & 3U) == 1U) {
#line 2632
      erpinfo = 0U;
#line 2636
      ATIMWindow = 0U;
#line 2637
      tmp___3 = rtw_set_ie23a(pframe, 6, 2U, (u8 const   *)(& ATIMWindow), & pattrib->pktlen);
#line 2637
      pframe = tmp___3;
#line 2642
      tmp___4 = rtw_set_ie23a(pframe, 42, 1U, (u8 const   *)(& erpinfo), & pattrib->pktlen);
#line 2642
      pframe = tmp___4;
    } else {

    }
#line 2647
    if (rate_len > 8U) {
#line 2648
      tmp___5 = rtw_set_ie23a(pframe, 50, rate_len - 8U, (u8 const   *)(& cur_network->SupportedRates) + 8U,
                              & pattrib->pktlen);
#line 2648
      pframe = tmp___5;
    } else {

    }
  }
#line 2656
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 2658
  dump_mgntframe23a(padapter, pmgntframe);
#line 2660
  return;
}
}
#line 2663 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int _issue_probereq(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                           u8 *da , int wait_ack ) 
{ 
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  unsigned char *mac ;
  unsigned char bssrate[13U] ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  int bssrate_len ;
  u8 bc_addr___0[6U] ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;

  {
#line 2666
  ret = 0;
#line 2673
  pxmitpriv = & padapter->xmitpriv;
#line 2674
  pmlmepriv = & padapter->mlmepriv;
#line 2675
  pmlmeext = & padapter->mlmeextpriv;
#line 2676
  bssrate_len = 0;
#line 2677
  bc_addr___0[0] = 255U;
#line 2677
  bc_addr___0[1] = 255U;
#line 2677
  bc_addr___0[2] = 255U;
#line 2677
  bc_addr___0[3] = 255U;
#line 2677
  bc_addr___0[4] = 255U;
#line 2677
  bc_addr___0[5] = 255U;
#line 2679
  if (GlobalDebugLevel23A > 5U) {
#line 2679
    rt_trace(16, 6, "+%s\n", "_issue_probereq");
  } else {

  }
#line 2682
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 2683
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 2684
    goto exit;
  } else {

  }
#line 2687
  pattrib = & pmgntframe->attrib;
#line 2688
  update_mgntframe_attrib23a(padapter, pattrib);
#line 2690
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 2692
  pframe = pmgntframe->buf_addr + 40U;
#line 2693
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 2695
  tmp = myid(& padapter->eeprompriv);
#line 2695
  mac = tmp;
#line 2697
  pwlanhdr->frame_control = 64U;
#line 2700
  if ((unsigned long )da != (unsigned long )((u8 *)0U)) {
#line 2702
    ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)da);
#line 2703
    ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)da);
  } else {
#line 2706
    ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)(& bc_addr___0));
#line 2707
    ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)(& bc_addr___0));
  }
#line 2710
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)mac);
#line 2712
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 2715
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 2717
  pframe = pframe + 24UL;
#line 2718
  pattrib->pktlen = 24U;
#line 2720
  if ((unsigned long )pssid != (unsigned long )((struct cfg80211_ssid *)0)) {
#line 2721
    tmp___0 = rtw_set_ie23a(pframe, 0, (uint )pssid->ssid_len, (u8 const   *)(& pssid->ssid),
                            & pattrib->pktlen);
#line 2721
    pframe = tmp___0;
  } else {
#line 2724
    tmp___1 = rtw_set_ie23a(pframe, 0, 0U, (u8 const   *)0U, & pattrib->pktlen);
#line 2724
    pframe = tmp___1;
  }
#line 2727
  get_rate_set23a(padapter, (unsigned char *)(& bssrate), & bssrate_len);
#line 2729
  if (bssrate_len > 8) {
#line 2730
    tmp___2 = rtw_set_ie23a(pframe, 1, 8U, (u8 const   *)(& bssrate), & pattrib->pktlen);
#line 2730
    pframe = tmp___2;
#line 2732
    tmp___3 = rtw_set_ie23a(pframe, 50, (uint )(bssrate_len + -8), (u8 const   *)(& bssrate) + 8U,
                            & pattrib->pktlen);
#line 2732
    pframe = tmp___3;
  } else {
#line 2736
    tmp___4 = rtw_set_ie23a(pframe, 1, (uint )bssrate_len, (u8 const   *)(& bssrate),
                            & pattrib->pktlen);
#line 2736
    pframe = tmp___4;
  }
#line 2741
  if (pmlmepriv->wps_probe_req_ie_len != 0U && (unsigned long )pmlmepriv->wps_probe_req_ie != (unsigned long )((u8 *)0U)) {
#line 2742
    memcpy((void *)pframe, (void const   *)pmlmepriv->wps_probe_req_ie, (size_t )pmlmepriv->wps_probe_req_ie_len);
#line 2744
    pframe = pframe + (unsigned long )pmlmepriv->wps_probe_req_ie_len;
#line 2745
    pattrib->pktlen = pattrib->pktlen + pmlmepriv->wps_probe_req_ie_len;
  } else {

  }
#line 2748
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 2750
  if (GlobalDebugLevel23A > 5U) {
#line 2750
    rt_trace(16, 6, "issuing probe_req, tx_len =%d\n", pattrib->last_txcmdsz);
  } else {

  }
#line 2753
  if (wait_ack != 0) {
#line 2754
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
#line 2756
    dump_mgntframe23a(padapter, pmgntframe);
#line 2757
    ret = 1;
  }
  exit: ;
#line 2761
  return (ret);
}
}
#line 2764 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
__inline static void issue_probereq(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                                    u8 *da ) 
{ 


  {
#line 2767
  _issue_probereq(padapter, pssid, da, 0);
#line 2768
  return;
}
}
#line 2770 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int issue_probereq_ex(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                             u8 *da , int try_cnt , int wait_ms ) 
{ 
  int ret ;
  int i ;
  unsigned long start ;
  unsigned int tmp ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;
  u8 tmp___2 ;

  {
#line 2775
  i = 0;
#line 2776
  start = jiffies;
  ldv_56509: 
#line 2779
  ret = _issue_probereq(padapter, pssid, da, wait_ms > 0);
#line 2782
  i = i + 1;
#line 2784
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 2785
    goto ldv_56508;
  } else {

  }
#line 2787
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
#line 2788
    msleep((unsigned int )wait_ms);
  } else {

  }
#line 2790
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
#line 2792
    goto ldv_56509;
  } else {

  }
  ldv_56508: ;
#line 2792
  if (ret != 0) {
#line 2793
    ret = 1;
#line 2794
    goto exit;
  } else {

  }
#line 2797
  if (try_cnt != 0 && wait_ms != 0) {
#line 2798
    if ((unsigned long )da != (unsigned long )((u8 *)0U)) {
#line 2799
      if (GlobalDebugLevel23A > 3U) {
#line 2799
        tmp = jiffies_to_msecs((unsigned long )jiffies - start);
#line 2799
        tmp___0 = rtw_get_oper_ch23a(padapter);
#line 2799
        printk("\016RTL8723AU: %s(%s): to %pM, ch:%u%s, %d/%d in %u ms\n", "issue_probereq_ex",
               (char *)(& (padapter->pnetdev)->name), da, (int )tmp___0, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp);
      } else {

      }
    } else
#line 2805
    if (GlobalDebugLevel23A > 3U) {
#line 2805
      tmp___1 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 2805
      tmp___2 = rtw_get_oper_ch23a(padapter);
#line 2805
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_probereq_ex",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___2, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___1);
    } else {

    }
  } else {

  }
  exit: ;
#line 2812
  return (ret);
}
}
#line 2816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void issue_auth(struct rtw_adapter *padapter , struct sta_info *psta , unsigned short status ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_mgmt *mgmt ;
  unsigned int val32 ;
  u16 auth_algo ;
  int use_shared_key ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned short val16 ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  struct ieee80211_mgmt *iv_mgmt ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u32 *piv ;
  u8 *tmp___5 ;

  {
#line 2825
  use_shared_key = 0;
#line 2826
  pxmitpriv = & padapter->xmitpriv;
#line 2827
  pmlmeext = & padapter->mlmeextpriv;
#line 2828
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2830
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 2831
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 2832
    return;
  } else {

  }
#line 2835
  pattrib = & pmgntframe->attrib;
#line 2836
  update_mgntframe_attrib23a(padapter, pattrib);
#line 2838
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 2840
  pframe = pmgntframe->buf_addr + 40U;
#line 2841
  mgmt = (struct ieee80211_mgmt *)pframe;
#line 2843
  mgmt->frame_control = 176U;
#line 2845
  mgmt->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 2846
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 2848
  pattrib->pktlen = 30U;
#line 2850
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 2854
    ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)(& psta->hwaddr));
#line 2855
    tmp = myid(& padapter->eeprompriv);
#line 2855
    ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp);
#line 2856
    tmp___0 = myid(& padapter->eeprompriv);
#line 2856
    ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___0);
#line 2859
    val16 = (unsigned short )psta->authalg;
#line 2861
    if ((unsigned int )status != 0U) {
#line 2862
      val16 = 0U;
    } else {

    }
#line 2864
    if ((unsigned int )val16 != 0U) {
#line 2865
      use_shared_key = 1;
    } else {

    }
#line 2867
    mgmt->u.auth.auth_alg = val16;
#line 2870
    mgmt->u.auth.auth_transaction = (unsigned short )psta->auth_seq;
#line 2874
    mgmt->u.auth.status_code = status;
#line 2876
    pframe = (unsigned char *)(& mgmt->u.auth.variable);
#line 2878
    if ((psta->auth_seq == 2U && (psta->state & 512U) != 0U) && use_shared_key == 1) {
#line 2880
      tmp___1 = rtw_set_ie23a(pframe, 16, 128U, (u8 const   *)(& psta->chg_txt), & pattrib->pktlen);
#line 2880
      pframe = tmp___1;
    } else {

    }
  } else {
#line 2886
    tmp___2 = get_my_bssid23a(& pmlmeinfo->network);
#line 2886
    ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)tmp___2);
#line 2887
    tmp___3 = myid(& padapter->eeprompriv);
#line 2887
    ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp___3);
#line 2888
    tmp___4 = get_my_bssid23a(& pmlmeinfo->network);
#line 2888
    ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___4);
#line 2893
    if (pmlmeinfo->auth_algo == 1U) {
#line 2894
      use_shared_key = 1;
#line 2895
      auth_algo = 1U;
    } else {
#line 2897
      auth_algo = 0U;
    }
#line 2904
    if ((pmlmeinfo->auth_seq == 3U && (pmlmeinfo->state & 512U) != 0U) && use_shared_key == 1) {
#line 2907
      piv = (u32 *)(& mgmt->u.auth);
#line 2909
      iv_mgmt = (struct ieee80211_mgmt *)pframe + 4U;
#line 2912
      val32 = (pmlmeinfo->iv & 1073741823U) | (pmlmeinfo->key_index << 30);
#line 2914
      pmlmeinfo->iv = pmlmeinfo->iv + 1U;
#line 2915
      put_unaligned_le32(val32, (void *)piv);
#line 2917
      pattrib->pktlen = pattrib->pktlen + 4U;
#line 2919
      pattrib->iv_len = 4U;
    } else {
#line 2921
      iv_mgmt = mgmt;
    }
#line 2923
    iv_mgmt->u.auth.auth_alg = auth_algo;
#line 2926
    iv_mgmt->u.auth.auth_transaction = (unsigned short )pmlmeinfo->auth_seq;
#line 2930
    iv_mgmt->u.auth.status_code = status;
#line 2932
    pframe = (unsigned char *)(& iv_mgmt->u.auth.variable);
#line 2935
    if ((pmlmeinfo->auth_seq == 3U && (pmlmeinfo->state & 512U) != 0U) && use_shared_key == 1) {
#line 2938
      tmp___5 = rtw_set_ie23a(pframe, 16, 128U, (u8 const   *)(& pmlmeinfo->chg_txt),
                              & pattrib->pktlen);
#line 2938
      pframe = tmp___5;
#line 2942
      mgmt->frame_control = (__le16 )((unsigned int )mgmt->frame_control | 16384U);
#line 2945
      pattrib->hdrlen = 24U;
#line 2947
      pattrib->encrypt = 1027073U;
#line 2949
      pattrib->icv_len = 4U;
#line 2951
      pattrib->pktlen = pattrib->pktlen + (u32 )pattrib->icv_len;
    } else {

    }
  }
#line 2955
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 2957
  rtw_wep_encrypt23a(padapter, pmgntframe);
#line 2958
  if (GlobalDebugLevel23A > 3U) {
#line 2958
    printk("\016RTL8723AU: %s\n", "issue_auth");
  } else {

  }
#line 2959
  dump_mgntframe23a(padapter, pmgntframe);
#line 2961
  return;
}
}
#line 2965 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void issue_assocrsp(struct rtw_adapter *padapter , unsigned short status ,
                           struct sta_info *pstat , u16 pkt_type ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct ieee80211_mgmt *mgmt ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  u8 const   *p ;
  u8 *ie ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  unsigned char WMM_PARA_IE[6U] ;
  int ie_len ;
  int tmp___4 ;
  u8 *tmp___5 ;

  {
#line 2972
  pxmitpriv = & padapter->xmitpriv;
#line 2973
  pmlmepriv = & padapter->mlmepriv;
#line 2974
  pmlmeext = & padapter->mlmeextpriv;
#line 2975
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2976
  pnetwork = & pmlmeinfo->network;
#line 2978
  ie = (u8 *)(& pnetwork->IEs);
#line 2980
  if (GlobalDebugLevel23A > 3U) {
#line 2980
    printk("\016RTL8723AU: %s\n", "issue_assocrsp");
  } else {

  }
#line 2982
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 2983
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 2984
    return;
  } else {

  }
#line 2987
  pattrib = & pmgntframe->attrib;
#line 2988
  update_mgntframe_attrib23a(padapter, pattrib);
#line 2990
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 2992
  pframe = pmgntframe->buf_addr + 40U;
#line 2993
  mgmt = (struct ieee80211_mgmt *)pframe;
#line 2995
  mgmt->frame_control = pkt_type;
#line 2997
  ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)(& pstat->hwaddr));
#line 2998
  tmp = myid(& padapter->eeprompriv);
#line 2998
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp);
#line 2999
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 2999
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___0);
#line 3001
  mgmt->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 3003
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3005
  pattrib->hdrlen = 24U;
#line 3006
  pattrib->pktlen = 30U;
#line 3009
  mgmt->u.assoc_resp.capab_info = pnetwork->capability;
#line 3010
  mgmt->u.assoc_resp.status_code = status;
#line 3011
  mgmt->u.assoc_resp.aid = (unsigned int )((unsigned short )pstat->aid) | 49152U;
#line 3013
  pframe = (unsigned char *)(& mgmt->u.assoc_resp.variable);
#line 3015
  if (pstat->bssratelen <= 8U) {
#line 3016
    tmp___1 = rtw_set_ie23a(pframe, 1, pstat->bssratelen, (u8 const   *)(& pstat->bssrateset),
                            & pattrib->pktlen);
#line 3016
    pframe = tmp___1;
  } else {
#line 3020
    tmp___2 = rtw_set_ie23a(pframe, 1, 8U, (u8 const   *)(& pstat->bssrateset), & pattrib->pktlen);
#line 3020
    pframe = tmp___2;
#line 3022
    tmp___3 = rtw_set_ie23a(pframe, 50, pstat->bssratelen - 8U, (u8 const   *)(& pstat->bssrateset) + 8U,
                            & pattrib->pktlen);
#line 3022
    pframe = tmp___3;
  }
#line 3027
  if (((unsigned long )pstat->flags & 2048UL) != 0UL && (int )pmlmepriv->htpriv.ht_option) {
#line 3030
    p = cfg80211_find_ie(45, (u8 const   *)ie, (int )pnetwork->IELength);
#line 3032
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 3033
      memcpy((void *)pframe, (void const   *)p, (size_t )((int )*(p + 1UL) + 2));
#line 3034
      pframe = pframe + ((unsigned long )*(p + 1UL) + 2UL);
#line 3035
      pattrib->pktlen = (pattrib->pktlen + (u32 )*(p + 1UL)) + 2U;
    } else {

    }
#line 3040
    p = cfg80211_find_ie(61, (u8 const   *)ie, (int )pnetwork->IELength);
#line 3042
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 3043
      memcpy((void *)pframe, (void const   *)p, (size_t )((int )*(p + 1UL) + 2));
#line 3044
      pframe = pframe + ((unsigned long )*(p + 1UL) + 2UL);
#line 3045
      pattrib->pktlen = (pattrib->pktlen + (u32 )*(p + 1UL)) + 2U;
    } else {

    }
  } else {

  }
#line 3050
  if (((unsigned long )pstat->flags & 512UL) != 0UL && pmlmepriv->qos_option != 0U) {
#line 3051
    WMM_PARA_IE[0] = 0U;
#line 3051
    WMM_PARA_IE[1] = 80U;
#line 3051
    WMM_PARA_IE[2] = 242U;
#line 3051
    WMM_PARA_IE[3] = 2U;
#line 3051
    WMM_PARA_IE[4] = 1U;
#line 3051
    WMM_PARA_IE[5] = 1U;
#line 3053
    ie_len = 0;
#line 3055
    p = (u8 const   *)ie;
    ldv_56552: 
#line 3056
    p = cfg80211_find_ie(221, p, (int )((pnetwork->IELength - (u32 )ie_len) + 4294967294U));
#line 3058
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 3059
      ie_len = (int )*(p + 1UL);
    } else {
#line 3061
      ie_len = 0;
    }
#line 3062
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 3062
      tmp___4 = memcmp((void const   *)p + 2U, (void const   *)(& WMM_PARA_IE), 6UL);
#line 3062
      if (tmp___4 == 0) {
#line 3063
        memcpy((void *)pframe, (void const   *)p, (size_t )(ie_len + 2));
#line 3064
        pframe = pframe + ((unsigned long )ie_len + 2UL);
#line 3065
        pattrib->pktlen = (pattrib->pktlen + (u32 )ie_len) + 2U;
#line 3067
        goto ldv_56551;
      } else {

      }
    } else {

    }
#line 3070
    if ((unsigned long )p == (unsigned long )((u8 const   *)0U) || ie_len == 0) {
#line 3071
      goto ldv_56551;
    } else {

    }
#line 3055
    p = p + ((unsigned long )ie_len + 2UL);
#line 3072
    goto ldv_56552;
    ldv_56551: ;
  } else {

  }
#line 3075
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 1U) {
#line 3076
    tmp___5 = rtw_set_ie23a(pframe, 221, 6U, (u8 const   *)(& REALTEK_96B_IE), & pattrib->pktlen);
#line 3076
    pframe = tmp___5;
  } else {

  }
#line 3080
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3082
  dump_mgntframe23a(padapter, pmgntframe);
#line 3083
  return;
}
}
#line 3086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void issue_assocreq(struct rtw_adapter *padapter ) 
{ 
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  u8 const   *p ;
  struct ieee80211_mgmt *mgmt ;
  unsigned int i ;
  unsigned int j ;
  unsigned int index ;
  unsigned char rf_type ;
  unsigned char bssrate[13U] ;
  unsigned char sta_bssrate[13U] ;
  struct registry_priv *pregpriv ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int bssrate_len ;
  int sta_bssrate_len ;
  int pie_len ;
  u8 *pie ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  unsigned int tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  struct ieee80211_ht_cap *cap ;
  bool tmp___8 ;
  bool tmp___9 ;
  u8 *tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  u8 plen ;
  int tmp___13 ;
  u8 *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  u8 *tmp___18 ;
  void *tmp___19 ;

  {
#line 3088
  ret = 0;
#line 3094
  index = 0U;
#line 3096
  pregpriv = & padapter->registrypriv;
#line 3097
  pxmitpriv = & padapter->xmitpriv;
#line 3098
  pmlmepriv = & padapter->mlmepriv;
#line 3099
  pmlmeext = & padapter->mlmeextpriv;
#line 3100
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3101
  bssrate_len = 0;
#line 3101
  sta_bssrate_len = 0;
#line 3104
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 3105
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 3106
    goto exit;
  } else {

  }
#line 3109
  pattrib = & pmgntframe->attrib;
#line 3110
  update_mgntframe_attrib23a(padapter, pattrib);
#line 3112
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 3114
  pframe = pmgntframe->buf_addr + 40U;
#line 3115
  mgmt = (struct ieee80211_mgmt *)pframe;
#line 3117
  mgmt->frame_control = 0U;
#line 3120
  tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 3120
  ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)tmp);
#line 3121
  tmp___0 = myid(& padapter->eeprompriv);
#line 3121
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp___0);
#line 3122
  tmp___1 = get_my_bssid23a(& pmlmeinfo->network);
#line 3122
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___1);
#line 3124
  mgmt->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 3125
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3128
  put_unaligned_le16((int )pmlmeinfo->network.capability, (void *)(& mgmt->u.assoc_req.capab_info));
#line 3131
  put_unaligned_le16(3, (void *)(& mgmt->u.assoc_req.listen_interval));
#line 3133
  pframe = (unsigned char *)(& mgmt->u.assoc_req.variable);
#line 3134
  pattrib->pktlen = 28U;
#line 3137
  tmp___2 = rtw_set_ie23a(pframe, 0, (uint )pmlmeinfo->network.Ssid.ssid_len, (u8 const   *)(& pmlmeinfo->network.Ssid.ssid),
                          & pattrib->pktlen);
#line 3137
  pframe = tmp___2;
#line 3143
  get_rate_set23a(padapter, (unsigned char *)(& sta_bssrate), & sta_bssrate_len);
#line 3147
  if ((unsigned int )pmlmeext->cur_channel == 14U) {
#line 3148
    sta_bssrate_len = 4;
  } else {

  }
#line 3154
  i = 0U;
#line 3154
  goto ldv_56580;
  ldv_56579: ;
#line 3155
  if ((unsigned int )pmlmeinfo->network.SupportedRates[i] == 0U) {
#line 3156
    goto ldv_56578;
  } else {

  }
#line 3157
  if (GlobalDebugLevel23A > 3U) {
#line 3157
    printk("\016RTL8723AU: network.SupportedRates[%d]=%02X\n", i, (int )pmlmeinfo->network.SupportedRates[i]);
  } else {

  }
#line 3154
  i = i + 1U;
  ldv_56580: ;
#line 3154
  if (i <= 15U) {
#line 3156
    goto ldv_56579;
  } else {

  }
  ldv_56578: 
#line 3161
  i = 0U;
#line 3161
  goto ldv_56587;
  ldv_56586: ;
#line 3162
  if ((unsigned int )pmlmeinfo->network.SupportedRates[i] == 0U) {
#line 3163
    goto ldv_56581;
  } else {

  }
#line 3167
  j = 0U;
#line 3167
  goto ldv_56584;
  ldv_56583: ;
#line 3170
  if (((unsigned int )pmlmeinfo->network.SupportedRates[i] | 128U) == ((unsigned int )sta_bssrate[j] | 128U)) {
#line 3174
    goto ldv_56582;
  } else {

  }
#line 3167
  j = j + 1U;
  ldv_56584: ;
#line 3167
  if ((unsigned int )sta_bssrate_len > j) {
#line 3169
    goto ldv_56583;
  } else {

  }
  ldv_56582: ;
#line 3178
  if ((unsigned int )sta_bssrate_len == j) {
#line 3180
    if (GlobalDebugLevel23A > 3U) {
#line 3180
      printk("\016RTL8723AU: %s(): the rate[%d]=%02X is not supported by STA!\n",
             "issue_assocreq", i, (int )pmlmeinfo->network.SupportedRates[i]);
    } else {

    }
  } else {
#line 3185
    tmp___3 = index;
#line 3185
    index = index + 1U;
#line 3185
    bssrate[tmp___3] = pmlmeinfo->network.SupportedRates[i];
  }
#line 3161
  i = i + 1U;
  ldv_56587: ;
#line 3161
  if (i <= 15U) {
#line 3163
    goto ldv_56586;
  } else {

  }
  ldv_56581: 
#line 3189
  bssrate_len = (int )index;
#line 3190
  if (GlobalDebugLevel23A > 3U) {
#line 3190
    printk("\016RTL8723AU: bssrate_len = %d\n", bssrate_len);
  } else {

  }
#line 3192
  if (bssrate_len == 0) {
#line 3193
    rtw_free_xmitbuf23a(pxmitpriv, pmgntframe->pxmitbuf);
#line 3194
    rtw_free_xmitframe23a(pxmitpriv, pmgntframe);
#line 3195
    goto exit;
  } else {

  }
#line 3198
  if (bssrate_len > 8) {
#line 3199
    tmp___4 = rtw_set_ie23a(pframe, 1, 8U, (u8 const   *)(& bssrate), & pattrib->pktlen);
#line 3199
    pframe = tmp___4;
#line 3201
    tmp___5 = rtw_set_ie23a(pframe, 50, (uint )(bssrate_len + -8), (u8 const   *)(& bssrate) + 8U,
                            & pattrib->pktlen);
#line 3201
    pframe = tmp___5;
  } else {
#line 3205
    tmp___6 = rtw_set_ie23a(pframe, 1, (uint )bssrate_len, (u8 const   *)(& bssrate),
                            & pattrib->pktlen);
#line 3205
    pframe = tmp___6;
  }
#line 3210
  pie = (u8 *)(& pmlmeinfo->network.IEs);
#line 3211
  pie_len = (int )pmlmeinfo->network.IELength;
#line 3213
  p = cfg80211_find_ie(48, (u8 const   *)pie, pie_len);
#line 3214
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 3215
    tmp___7 = rtw_set_ie23a(pframe, 48, (uint )*(p + 1UL), p + 2UL, & pattrib->pktlen);
#line 3215
    pframe = tmp___7;
  } else {

  }
#line 3219
  if ((int )padapter->mlmepriv.htpriv.ht_option) {
#line 3220
    p = cfg80211_find_ie(45, (u8 const   *)pie, pie_len);
#line 3222
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 3222
      tmp___11 = is_ap_in_tkip23a(padapter);
#line 3222
      if (tmp___11) {
#line 3222
        tmp___12 = 0;
      } else {
#line 3222
        tmp___12 = 1;
      }
#line 3222
      if (tmp___12) {
#line 3223
        cap = & pmlmeinfo->ht_cap;
#line 3225
        memcpy((void *)cap, (void const   *)p + 2U, 26UL);
#line 3228
        if ((unsigned int )pregpriv->cbw40_enable == 0U) {
#line 3229
          cap->cap_info = (unsigned int )cap->cap_info & 65469U;
        } else {
#line 3233
          cap->cap_info = (__le16 )((unsigned int )cap->cap_info | 2U);
        }
#line 3238
        cap->cap_info = (__le16 )((unsigned int )cap->cap_info | 12U);
#line 3240
        rf_type = rtl8723a_get_rf_type(padapter);
#line 3242
        switch ((int )rf_type) {
        case 3: ;
#line 3245
        if ((unsigned int )pregpriv->rx_stbc != 0U) {
#line 3246
          cap->cap_info = (__le16 )((unsigned int )cap->cap_info | 256U);
        } else {

        }
#line 3248
        memcpy((void *)(& cap->mcs), (void const   *)(& MCS_rate_1R23A), 16UL);
#line 3249
        goto ldv_56590;
        case 2: ;
        case 0: ;
        default: ;
#line 3255
        if ((((unsigned int )pregpriv->rx_stbc == 3U || (((int )pmlmeext->cur_wireless_mode & 8) != 0 && (unsigned int )pregpriv->rx_stbc == 1U)) || (((int )pmlmeext->cur_wireless_mode & 16) != 0 && (unsigned int )pregpriv->rx_stbc == 2U)) || (unsigned int )pregpriv->wifi_spec == 1U) {
#line 3265
          if (GlobalDebugLevel23A > 3U) {
#line 3265
            printk("\016RTL8723AU: declare supporting RX STBC\n");
          } else {

          }
#line 3268
          cap->cap_info = (__le16 )((unsigned int )cap->cap_info | 512U);
        } else {

        }
#line 3270
        memcpy((void *)(& cap->mcs), (void const   *)(& MCS_rate_2R23A), 16UL);
#line 3271
        goto ldv_56590;
        }
        ldv_56590: 
#line 3274
        tmp___8 = rtl8723a_BT_coexist(padapter);
#line 3274
        if ((int )tmp___8) {
#line 3274
          tmp___9 = rtl8723a_BT_using_antenna_1(padapter);
#line 3274
          if ((int )tmp___9) {
#line 3277
            cap->ampdu_params_info = (unsigned int )cap->ampdu_params_info & 252U;
          } else {

          }
        } else {

        }
#line 3282
        tmp___10 = rtw_set_ie23a(pframe, 45, (uint )*(p + 1UL), (u8 const   *)(& pmlmeinfo->ht_cap),
                                 & pattrib->pktlen);
#line 3282
        pframe = tmp___10;
      } else {

      }
    } else {

    }
  } else {

  }
#line 3289
  i = 0U;
#line 3289
  goto ldv_56599;
  ldv_56598: 
#line 3290
  p = (u8 const   *)(& pmlmeinfo->network.IEs) + (unsigned long )i;
#line 3292
  switch ((int )*p) {
  case 221: 
#line 3294
  tmp___15 = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                    4UL);
#line 3294
  if (tmp___15 == 0) {
#line 3294
    goto _L;
  } else {
#line 3294
    tmp___16 = memcmp((void const   *)p + 2U, (void const   *)(& WMM_OUI23A), 4UL);
#line 3294
    if (tmp___16 == 0) {
#line 3294
      goto _L;
    } else {
#line 3294
      tmp___17 = memcmp((void const   *)p + 2U, (void const   *)(& WPS_OUI23A), 4UL);
#line 3294
      if (tmp___17 == 0) {
        _L: /* CIL Label */ 
#line 3297
        plen = *(p + 1UL);
#line 3299
        if ((unsigned int )padapter->registrypriv.wifi_spec == 0U) {
#line 3304
          tmp___13 = memcmp((void const   *)p + 2U, (void const   *)(& WPS_OUI23A),
                            4UL);
#line 3304
          if (tmp___13 == 0) {
#line 3305
            plen = 14U;
          } else {

          }
        } else {

        }
#line 3307
        tmp___14 = rtw_set_ie23a(pframe, 221, (uint )plen, p + 2UL, & pattrib->pktlen);
#line 3307
        pframe = tmp___14;
      } else {

      }
    }
  }
#line 3312
  goto ldv_56596;
  default: ;
#line 3315
  goto ldv_56596;
  }
  ldv_56596: 
#line 3318
  i = ((unsigned int )*(p + 1UL) + i) + 2U;
  ldv_56599: ;
#line 3289
  if (pmlmeinfo->network.IELength > i) {
#line 3291
    goto ldv_56598;
  } else {

  }

#line 3321
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 1U) {
#line 3322
    tmp___18 = rtw_set_ie23a(pframe, 221, 6U, (u8 const   *)(& REALTEK_96B_IE), & pattrib->pktlen);
#line 3322
    pframe = tmp___18;
  } else {

  }
#line 3325
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3326
  dump_mgntframe23a(padapter, pmgntframe);
#line 3328
  ret = 1;
  exit: 
#line 3331
  pmlmepriv->assoc_req_len = 0U;
#line 3332
  if (ret == 1) {
#line 3333
    kfree((void const   *)pmlmepriv->assoc_req);
#line 3334
    tmp___19 = kmalloc((size_t )pattrib->pktlen, 32U);
#line 3334
    pmlmepriv->assoc_req = (u8 *)tmp___19;
#line 3335
    if ((unsigned long )pmlmepriv->assoc_req != (unsigned long )((u8 *)0U)) {
#line 3336
      memcpy((void *)pmlmepriv->assoc_req, (void const   *)mgmt, (size_t )pattrib->pktlen);
#line 3337
      pmlmepriv->assoc_req_len = pattrib->pktlen;
    } else {

    }
  } else {
#line 3340
    kfree((void const   *)pmlmepriv->assoc_req);
  }
#line 3342
  return;
}
}
#line 3346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int _issue_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , unsigned int power_mode ,
                              int wait_ack ) 
{ 
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  u8 *tmp___0 ;

  {
#line 3349
  ret = 0;
#line 3360
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 3361
    goto exit;
  } else {

  }
#line 3363
  pxmitpriv = & padapter->xmitpriv;
#line 3364
  pmlmeext = & padapter->mlmeextpriv;
#line 3365
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3367
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 3368
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 3369
    goto exit;
  } else {

  }
#line 3372
  pattrib = & pmgntframe->attrib;
#line 3373
  update_mgntframe_attrib23a(padapter, pattrib);
#line 3374
  pattrib->retry_ctrl = 0U;
#line 3376
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 3378
  pframe = pmgntframe->buf_addr + 40U;
#line 3379
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 3381
  pwlanhdr->frame_control = 72U;
#line 3384
  if ((pmlmeinfo->state & 3U) == 3U) {
#line 3385
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
  } else
#line 3386
  if ((pmlmeinfo->state & 3U) == 2U) {
#line 3387
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
  } else {

  }
#line 3389
  if (power_mode != 0U) {
#line 3390
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 4096U);
  } else {

  }
#line 3392
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)da);
#line 3393
  tmp = myid(& padapter->eeprompriv);
#line 3393
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp);
#line 3394
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 3394
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___0);
#line 3396
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 3398
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3400
  pframe = pframe + 24UL;
#line 3401
  pattrib->pktlen = 24U;
#line 3403
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3405
  if (wait_ack != 0) {
#line 3406
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
#line 3408
    dump_mgntframe23a(padapter, pmgntframe);
#line 3409
    ret = 1;
  }
  exit: ;
#line 3413
  return (ret);
}
}
#line 3418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int issue_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , unsigned int power_mode ,
                      int try_cnt , int wait_ms ) 
{ 
  int ret ;
  int i ;
  unsigned long start ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  unsigned int tmp___0 ;
  u8 tmp___1 ;
  unsigned int tmp___2 ;
  u8 tmp___3 ;

  {
#line 3422
  i = 0;
#line 3423
  start = jiffies;
#line 3424
  pmlmeext = & padapter->mlmeextpriv;
#line 3425
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3428
  if ((unsigned long )da == (unsigned long )((unsigned char *)0U)) {
#line 3429
    tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 3429
    da = tmp;
  } else {

  }
  ldv_56629: 
#line 3432
  ret = _issue_nulldata23a(padapter, da, power_mode, wait_ms > 0);
#line 3435
  i = i + 1;
#line 3437
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 3438
    goto ldv_56628;
  } else {

  }
#line 3440
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
#line 3441
    msleep((unsigned int )wait_ms);
  } else {

  }
#line 3443
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
#line 3445
    goto ldv_56629;
  } else {

  }
  ldv_56628: ;
#line 3445
  if (ret != 0) {
#line 3446
    ret = 1;
#line 3447
    goto exit;
  } else {

  }
#line 3450
  if (try_cnt != 0 && wait_ms != 0) {
#line 3451
    if ((unsigned long )da != (unsigned long )((unsigned char *)0U)) {
#line 3452
      if (GlobalDebugLevel23A > 3U) {
#line 3452
        tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 3452
        tmp___1 = rtw_get_oper_ch23a(padapter);
#line 3452
        printk("\016RTL8723AU: %s(%s): to %pM, ch:%u%s, %d/%d in %u ms\n", "issue_nulldata23a",
               (char *)(& (padapter->pnetdev)->name), da, (int )tmp___1, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp___0);
      } else {

      }
    } else
#line 3458
    if (GlobalDebugLevel23A > 3U) {
#line 3458
      tmp___2 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 3458
      tmp___3 = rtw_get_oper_ch23a(padapter);
#line 3458
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_nulldata23a",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___3, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___2);
    } else {

    }
  } else {

  }
  exit: ;
#line 3465
  return (ret);
}
}
#line 3469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int _issue_qos_nulldata23a(struct rtw_adapter *padapter , unsigned char *da ,
                                  u16 tid , int wait_ack ) 
{ 
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_qos_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  u8 *tmp___0 ;

  {
#line 3472
  ret = 0;
#line 3477
  pxmitpriv = & padapter->xmitpriv;
#line 3478
  pmlmeext = & padapter->mlmeextpriv;
#line 3479
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3481
  if (GlobalDebugLevel23A > 3U) {
#line 3481
    printk("\016RTL8723AU: %s\n", "_issue_qos_nulldata23a");
  } else {

  }
#line 3483
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 3484
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 3485
    goto exit;
  } else {

  }
#line 3488
  pattrib = & pmgntframe->attrib;
#line 3489
  update_mgntframe_attrib23a(padapter, pattrib);
#line 3491
  pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 2U;
#line 3492
  pattrib->qos_en = 1U;
#line 3493
  pattrib->eosp = 1U;
#line 3494
  pattrib->ack_policy = 0U;
#line 3495
  pattrib->mdata = 0U;
#line 3497
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 3499
  pframe = pmgntframe->buf_addr + 40U;
#line 3500
  pwlanhdr = (struct ieee80211_qos_hdr *)pframe;
#line 3502
  pwlanhdr->frame_control = 200U;
#line 3505
  if ((pmlmeinfo->state & 3U) == 3U) {
#line 3506
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
  } else
#line 3507
  if ((pmlmeinfo->state & 3U) == 2U) {
#line 3508
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
  } else {

  }
#line 3510
  if ((unsigned int )pattrib->mdata != 0U) {
#line 3511
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 8192U);
  } else {

  }
#line 3513
  pwlanhdr->qos_ctrl = (unsigned int )tid & 15U;
#line 3514
  pwlanhdr->qos_ctrl = (__le16 )((int )((short )pwlanhdr->qos_ctrl) | ((int )((short )((int )pattrib->ack_policy << 5)) & 96));
#line 3516
  if ((unsigned int )pattrib->eosp != 0U) {
#line 3517
    pwlanhdr->qos_ctrl = (__le16 )((unsigned int )pwlanhdr->qos_ctrl | 16U);
  } else {

  }
#line 3519
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)da);
#line 3520
  tmp = myid(& padapter->eeprompriv);
#line 3520
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp);
#line 3521
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 3521
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___0);
#line 3523
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 3525
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3527
  pframe = pframe + 26UL;
#line 3528
  pattrib->pktlen = 26U;
#line 3530
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3532
  if (wait_ack != 0) {
#line 3533
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
#line 3535
    dump_mgntframe23a(padapter, pmgntframe);
#line 3536
    ret = 1;
  }
  exit: ;
#line 3540
  return (ret);
}
}
#line 3545 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int issue_qos_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , u16 tid ,
                          int try_cnt , int wait_ms ) 
{ 
  int ret ;
  int i ;
  unsigned long start ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  unsigned int tmp___0 ;
  u8 tmp___1 ;
  unsigned int tmp___2 ;
  u8 tmp___3 ;

  {
#line 3549
  i = 0;
#line 3550
  start = jiffies;
#line 3551
  pmlmeext = & padapter->mlmeextpriv;
#line 3552
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3555
  if ((unsigned long )da == (unsigned long )((unsigned char *)0U)) {
#line 3556
    tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 3556
    da = tmp;
  } else {

  }
  ldv_56661: 
#line 3559
  ret = _issue_qos_nulldata23a(padapter, da, (int )tid, wait_ms > 0);
#line 3562
  i = i + 1;
#line 3564
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 3565
    goto ldv_56660;
  } else {

  }
#line 3567
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
#line 3568
    msleep((unsigned int )wait_ms);
  } else {

  }
#line 3569
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
#line 3571
    goto ldv_56661;
  } else {

  }
  ldv_56660: ;
#line 3571
  if (ret != 0) {
#line 3572
    ret = 1;
#line 3573
    goto exit;
  } else {

  }
#line 3576
  if (try_cnt != 0 && wait_ms != 0) {
#line 3577
    if ((unsigned long )da != (unsigned long )((unsigned char *)0U)) {
#line 3578
      if (GlobalDebugLevel23A > 3U) {
#line 3578
        tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 3578
        tmp___1 = rtw_get_oper_ch23a(padapter);
#line 3578
        printk("\016RTL8723AU: %s(%s): to %pM, ch:%u%s, %d/%d in %u ms\n", "issue_qos_nulldata23a",
               (char *)(& (padapter->pnetdev)->name), da, (int )tmp___1, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp___0);
      } else {

      }
    } else
#line 3584
    if (GlobalDebugLevel23A > 3U) {
#line 3584
      tmp___2 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 3584
      tmp___3 = rtw_get_oper_ch23a(padapter);
#line 3584
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_qos_nulldata23a",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___3, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___2);
    } else {

    }
  } else {

  }
  exit: ;
#line 3591
  return (ret);
}
}
#line 3594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int _issue_deauth(struct rtw_adapter *padapter , unsigned char *da , unsigned short reason ,
                         u8 wait_ack ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  struct ieee80211_mgmt *mgmt ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int ret ;
  u8 *tmp ;
  u8 *tmp___0 ;

  {
#line 3600
  pxmitpriv = & padapter->xmitpriv;
#line 3601
  pmlmeext = & padapter->mlmeextpriv;
#line 3602
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3603
  ret = 0;
#line 3607
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 3608
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 3609
    goto exit;
  } else {

  }
#line 3612
  pattrib = & pmgntframe->attrib;
#line 3613
  update_mgntframe_attrib23a(padapter, pattrib);
#line 3614
  pattrib->retry_ctrl = 0U;
#line 3616
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 3618
  mgmt = (struct ieee80211_mgmt *)pmgntframe->buf_addr + 40U;
#line 3620
  mgmt->frame_control = 192U;
#line 3623
  ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)da);
#line 3624
  tmp = myid(& padapter->eeprompriv);
#line 3624
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp);
#line 3625
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 3625
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___0);
#line 3627
  mgmt->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 3628
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3630
  pattrib->pktlen = 26U;
#line 3632
  mgmt->u.deauth.reason_code = reason;
#line 3634
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3636
  if ((unsigned int )wait_ack != 0U) {
#line 3637
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
#line 3639
    dump_mgntframe23a(padapter, pmgntframe);
#line 3640
    ret = 1;
  }
  exit: ;
#line 3644
  return (ret);
}
}
#line 3647 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int issue_deauth23a(struct rtw_adapter *padapter , unsigned char *da , unsigned short reason ) 
{ 
  int tmp ;

  {
#line 3650
  if (GlobalDebugLevel23A > 3U) {
#line 3650
    printk("\016RTL8723AU: %s to %pM\n", "issue_deauth23a", da);
  } else {

  }
#line 3651
  tmp = _issue_deauth(padapter, da, (int )reason, 0);
#line 3651
  return (tmp);
}
}
#line 3654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int issue_deauth_ex(struct rtw_adapter *padapter , u8 *da , unsigned short reason ,
                           int try_cnt , int wait_ms ) 
{ 
  int ret ;
  int i ;
  unsigned long start ;
  unsigned int tmp ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;
  u8 tmp___2 ;

  {
#line 3658
  i = 0;
#line 3659
  start = jiffies;
  ldv_56695: 
#line 3662
  ret = _issue_deauth(padapter, da, (int )reason, wait_ms > 0);
#line 3665
  i = i + 1;
#line 3667
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 3668
    goto ldv_56694;
  } else {

  }
#line 3670
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
#line 3671
    msleep((unsigned int )wait_ms);
  } else {

  }
#line 3673
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
#line 3675
    goto ldv_56695;
  } else {

  }
  ldv_56694: ;
#line 3675
  if (ret != 0) {
#line 3676
    ret = 1;
#line 3677
    goto exit;
  } else {

  }
#line 3680
  if (try_cnt != 0 && wait_ms != 0) {
#line 3681
    if ((unsigned long )da != (unsigned long )((u8 *)0U)) {
#line 3682
      if (GlobalDebugLevel23A > 3U) {
#line 3682
        tmp = jiffies_to_msecs((unsigned long )jiffies - start);
#line 3682
        tmp___0 = rtw_get_oper_ch23a(padapter);
#line 3682
        printk("\016RTL8723AU: %s(%s): to %pM, ch:%u%s, %d/%d in %u ms\n", "issue_deauth_ex",
               (char *)(& (padapter->pnetdev)->name), da, (int )tmp___0, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp);
      } else {

      }
    } else
#line 3688
    if (GlobalDebugLevel23A > 3U) {
#line 3688
      tmp___1 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 3688
      tmp___2 = rtw_get_oper_ch23a(padapter);
#line 3688
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_deauth_ex",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___2, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___1);
    } else {

    }
  } else {

  }
  exit: ;
#line 3695
  return (ret);
}
}
#line 3698 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void issue_action_spct_ch_switch23a(struct rtw_adapter *padapter , u8 *ra , u8 new_ch ,
                                    u8 ch_offset ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_mgmt *mgmt ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 tmp___1 ;
  u8 *tmp___2 ;

  {
#line 3705
  pxmitpriv = & padapter->xmitpriv;
#line 3706
  pmlmeext = & padapter->mlmeextpriv;
#line 3708
  if (GlobalDebugLevel23A > 3U) {
#line 3708
    printk("\016RTL8723AU: %s(%s): ra=%pM, ch:%u, offset:%u\n", "issue_action_spct_ch_switch23a",
           (char *)(& (padapter->pnetdev)->name), ra, (int )new_ch, (int )ch_offset);
  } else {

  }
#line 3711
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 3712
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 3713
    return;
  } else {

  }
#line 3716
  pattrib = & pmgntframe->attrib;
#line 3717
  update_mgntframe_attrib23a(padapter, pattrib);
#line 3719
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 3721
  mgmt = (struct ieee80211_mgmt *)pmgntframe->buf_addr + 40U;
#line 3723
  mgmt->frame_control = 208U;
#line 3726
  ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)ra);
#line 3727
  tmp = myid(& padapter->eeprompriv);
#line 3727
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp);
#line 3728
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)ra);
#line 3730
  mgmt->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 3731
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3733
  mgmt->u.action.category = 0U;
#line 3734
  mgmt->u.action.u.chan_switch.action_code = 4U;
#line 3736
  pframe = (unsigned char *)(& mgmt->u.action.u.chan_switch.variable);
#line 3737
  pattrib->pktlen = 26U;
#line 3740
  tmp___0 = rtw_set_ie23a_ch_switch(pframe, & pattrib->pktlen, 0, (int )new_ch, 0);
#line 3740
  pframe = tmp___0;
#line 3742
  tmp___1 = hal_ch_offset_to_secondary_ch_offset23a((int )ch_offset);
#line 3742
  tmp___2 = rtw_set_ie23a_secondary_ch_offset(pframe, & pattrib->pktlen, (int )tmp___1);
#line 3742
  pframe = tmp___2;
#line 3745
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3747
  dump_mgntframe23a(padapter, pmgntframe);
#line 3748
  return;
}
}
#line 3750 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void issue_action_BA23a(struct rtw_adapter *padapter , unsigned char const   *raddr ,
                        unsigned char action , unsigned short status ) 
{ 
  u16 start_seq ;
  u16 BA_para_set ;
  u16 BA_starting_seqctrl ;
  u16 BA_para ;
  int max_rx_ampdu_factor ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  struct ieee80211_mgmt *mgmt ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct registry_priv *pregpriv ;
  u8 tendaAPMac[3U] ;
  u8 *tmp ;
  u8 *tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int idx ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
#line 3762
  pxmitpriv = & padapter->xmitpriv;
#line 3763
  pmlmeext = & padapter->mlmeextpriv;
#line 3764
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3766
  pstapriv = & padapter->stapriv;
#line 3767
  pregpriv = & padapter->registrypriv;
#line 3768
  tendaAPMac[0] = 200U;
#line 3768
  tendaAPMac[1] = 58U;
#line 3768
  tendaAPMac[2] = 53U;
#line 3770
  if (GlobalDebugLevel23A > 3U) {
#line 3770
    printk("\016RTL8723AU: %s, action =%d, status =%d\n", "issue_action_BA23a", (int )action,
           (int )status);
  } else {

  }
#line 3772
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 3773
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 3774
    return;
  } else {

  }
#line 3777
  pattrib = & pmgntframe->attrib;
#line 3778
  update_mgntframe_attrib23a(padapter, pattrib);
#line 3780
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 3782
  mgmt = (struct ieee80211_mgmt *)pmgntframe->buf_addr + 40U;
#line 3784
  mgmt->frame_control = 208U;
#line 3787
  ether_addr_copy((u8 *)(& mgmt->da), raddr);
#line 3788
  tmp = myid(& padapter->eeprompriv);
#line 3788
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp);
#line 3789
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 3789
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___0);
#line 3791
  mgmt->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 3792
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3794
  mgmt->u.action.category = 3U;
#line 3796
  pattrib->pktlen = 25U;
#line 3798
  switch ((int )action) {
  case 0: 
#line 3800
  pattrib->pktlen = pattrib->pktlen + 8U;
#line 3802
  mgmt->u.action.u.addba_req.action_code = action;
  ldv_56734: 
#line 3805
  pmlmeinfo->dialogToken = (u8 )((int )pmlmeinfo->dialogToken + 1);
#line 3806
  if ((unsigned int )pmlmeinfo->dialogToken == 0U) {
#line 3808
    goto ldv_56734;
  } else {

  }
#line 3808
  mgmt->u.action.u.addba_req.dialog_token = pmlmeinfo->dialogToken;
#line 3811
  tmp___1 = rtl8723a_BT_coexist(padapter);
#line 3811
  if ((int )tmp___1) {
#line 3811
    tmp___2 = rtl8723a_BT_using_antenna_1(padapter);
#line 3811
    if ((int )tmp___2) {
#line 3811
      if ((unsigned int )pmlmeinfo->assoc_AP_vendor != 1U) {
#line 3816
        BA_para_set = 0U;
#line 3818
        BA_para_set = (u16 )((unsigned int )BA_para_set | 2U);
#line 3821
        BA_para_set = (u16 )(((int )((short )((int )status << 2)) & 60) | (int )((short )BA_para_set));
#line 3824
        BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
      } else {
#line 3811
        tmp___3 = memcmp((void const   *)raddr, (void const   *)(& tendaAPMac), 3UL);
#line 3811
        if (tmp___3 != 0) {
#line 3816
          BA_para_set = 0U;
#line 3818
          BA_para_set = (u16 )((unsigned int )BA_para_set | 2U);
#line 3821
          BA_para_set = (u16 )(((int )((short )((int )status << 2)) & 60) | (int )((short )BA_para_set));
#line 3824
          BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
        } else {
#line 3828
          BA_para_set = (u16 )((int )((short )(((int )status & 15) << 2)) | 4098);
        }
      }
    } else {
#line 3828
      BA_para_set = (u16 )((int )((short )(((int )status & 15) << 2)) | 4098);
    }
  } else {
#line 3828
    BA_para_set = (u16 )((int )((short )(((int )status & 15) << 2)) | 4098);
  }
#line 3831
  put_unaligned_le16((int )BA_para_set, (void *)(& mgmt->u.action.u.addba_req.capab));
#line 3835
  put_unaligned_le16(5000, (void *)(& mgmt->u.action.u.addba_req.timeout));
#line 3837
  psta = rtw_get_stainfo23a(pstapriv, raddr);
#line 3838
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 3841
    idx = (int )status & 7;
#line 3842
    start_seq = ((unsigned int )psta->sta_xmitpriv.txseq_tid[idx] & 4095U) + 1U;
#line 3845
    if (GlobalDebugLevel23A > 3U) {
#line 3845
      printk("\016RTL8723AU: BA_starting_seqctrl = %d for TID =%d\n", (int )start_seq,
             idx);
    } else {

    }
#line 3848
    psta->BA_starting_seqctrl[idx] = start_seq;
#line 3850
    BA_starting_seqctrl = (int )start_seq << 4U;
  } else {
#line 3852
    BA_starting_seqctrl = 0U;
  }
#line 3854
  put_unaligned_le16((int )BA_starting_seqctrl, (void *)(& mgmt->u.action.u.addba_req.start_seq_num));
#line 3857
  goto ldv_56737;
  case 1: 
#line 3860
  pattrib->pktlen = pattrib->pktlen + 8U;
#line 3862
  mgmt->u.action.u.addba_resp.action_code = action;
#line 3863
  mgmt->u.action.u.addba_resp.dialog_token = pmlmeinfo->ADDBA_req.dialog_token;
#line 3865
  put_unaligned_le16((int )status, (void *)(& mgmt->u.action.u.addba_resp.status));
#line 3868
  GetHalDefVar8192CUsb(padapter, 11, (void *)(& max_rx_ampdu_factor));
#line 3871
  BA_para = (unsigned int )pmlmeinfo->ADDBA_req.BA_para_set & 63U;
#line 3872
  if (max_rx_ampdu_factor == 3) {
#line 3873
    BA_para_set = (u16 )((unsigned int )BA_para | 4096U);
  } else
#line 3874
  if (max_rx_ampdu_factor == 2) {
#line 3875
    BA_para_set = (u16 )((unsigned int )BA_para | 2048U);
  } else
#line 3876
  if (max_rx_ampdu_factor == 1) {
#line 3877
    BA_para_set = (u16 )((unsigned int )BA_para | 1024U);
  } else
#line 3878
  if (max_rx_ampdu_factor == 0) {
#line 3879
    BA_para_set = (u16 )((unsigned int )BA_para | 512U);
  } else {
#line 3881
    BA_para_set = (u16 )((unsigned int )BA_para | 4096U);
  }
#line 3883
  tmp___4 = rtl8723a_BT_coexist(padapter);
#line 3883
  if ((int )tmp___4) {
#line 3883
    tmp___5 = rtl8723a_BT_using_antenna_1(padapter);
#line 3883
    if ((int )tmp___5) {
#line 3883
      if ((unsigned int )pmlmeinfo->assoc_AP_vendor != 1U) {
#line 3888
        BA_para_set = (unsigned int )BA_para_set & 63U;
#line 3889
        BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
      } else {
#line 3883
        tmp___6 = memcmp((void const   *)raddr, (void const   *)(& tendaAPMac), 3UL);
#line 3883
        if (tmp___6 != 0) {
#line 3888
          BA_para_set = (unsigned int )BA_para_set & 63U;
#line 3889
          BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
        } else {

        }
      }
    } else {

    }
  } else {

  }
#line 3893
  if ((unsigned int )pregpriv->ampdu_amsdu == 0U) {
#line 3894
    BA_para_set = (unsigned int )BA_para_set & 65534U;
  } else
#line 3895
  if ((unsigned int )pregpriv->ampdu_amsdu == 1U) {
#line 3896
    BA_para_set = (u16 )((unsigned int )BA_para_set | 1U);
  } else {

  }
#line 3898
  put_unaligned_le16((int )BA_para_set, (void *)(& mgmt->u.action.u.addba_resp.capab));
#line 3901
  mgmt->u.action.u.addba_resp.timeout = pmlmeinfo->ADDBA_req.BA_timeout_value;
#line 3904
  pattrib->pktlen = pattrib->pktlen + 8U;
#line 3905
  goto ldv_56737;
  case 2: 
#line 3907
  pattrib->pktlen = pattrib->pktlen + 5U;
#line 3909
  mgmt->u.action.u.delba.action_code = action;
#line 3910
  BA_para_set = (unsigned int )((u16 )((int )status << 3)) & 255U;
#line 3911
  mgmt->u.action.u.delba.params = BA_para_set;
#line 3912
  mgmt->u.action.u.delba.reason_code = 37U;
#line 3915
  pattrib->pktlen = pattrib->pktlen + 5U;
#line 3916
  goto ldv_56737;
  default: ;
#line 3918
  goto ldv_56737;
  }
  ldv_56737: 
#line 3921
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3923
  dump_mgntframe23a(padapter, pmgntframe);
#line 3924
  return;
}
}
#line 3926 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int send_delba23a(struct rtw_adapter *padapter , u8 initiator , u8 *addr ) 
{ 
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u16 tid ;

  {
#line 3928
  pstapriv = & padapter->stapriv;
#line 3929
  psta = (struct sta_info *)0;
#line 3931
  pmlmeext = & padapter->mlmeextpriv;
#line 3932
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3935
  if ((pmlmeinfo->state & 3U) != 3U) {
#line 3936
    if ((pmlmeinfo->state & 16384U) == 0U) {
#line 3937
      return (1);
    } else {

    }
  } else {

  }
#line 3939
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)addr);
#line 3940
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 3941
    return (1);
  } else {

  }
#line 3943
  if ((unsigned int )initiator == 0U) {
#line 3944
    tid = 0U;
#line 3944
    goto ldv_56752;
    ldv_56751: ;
#line 3945
    if ((unsigned int )psta->recvreorder_ctrl[(int )tid].enable == 1U) {
#line 3946
      if (GlobalDebugLevel23A > 3U) {
#line 3946
        printk("\016RTL8723AU: rx agg disable tid(%d)\n", (int )tid);
      } else {

      }
#line 3947
      issue_action_BA23a(padapter, (unsigned char const   *)addr, 2, (int )((unsigned short )((int )((short )((int )tid << 1)) | (int )((short )initiator))) & 31);
#line 3948
      psta->recvreorder_ctrl[(int )tid].enable = 0U;
#line 3949
      psta->recvreorder_ctrl[(int )tid].indicate_seq = 65535U;
    } else {

    }
#line 3944
    tid = (u16 )((int )tid + 1);
    ldv_56752: ;
#line 3944
    if ((unsigned int )tid <= 15U) {
#line 3946
      goto ldv_56751;
    } else {

    }

  } else
#line 3952
  if ((unsigned int )initiator == 1U) {
#line 3953
    tid = 0U;
#line 3953
    goto ldv_56755;
    ldv_56754: ;
#line 3954
    if ((int )((unsigned long )psta->htpriv.agg_enable_bitmap >> (int )tid) & 1) {
#line 3955
      if (GlobalDebugLevel23A > 3U) {
#line 3955
        printk("\016RTL8723AU: tx agg disable tid(%d)\n", (int )tid);
      } else {

      }
#line 3956
      issue_action_BA23a(padapter, (unsigned char const   *)addr, 2, (int )((unsigned short )((int )((short )((int )tid << 1)) | (int )((short )initiator))) & 31);
#line 3957
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
#line 3958
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    } else {

    }
#line 3953
    tid = (u16 )((int )tid + 1);
    ldv_56755: ;
#line 3953
    if ((unsigned int )tid <= 15U) {
#line 3955
      goto ldv_56754;
    } else {

    }

  } else {

  }
#line 3963
  return (1);
}
}
#line 3966 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int send_beacon23a(struct rtw_adapter *padapter ) 
{ 
  bool bxmitok ;
  int issue ;
  int poll ;
  unsigned long start ;
  unsigned int passing_time ;

  {
#line 3969
  issue = 0;
#line 3970
  poll = 0;
#line 3971
  start = jiffies;
#line 3974
  rtl8723a_bcn_valid(padapter);
  ldv_56767: 
#line 3976
  issue_beacon23a(padapter, 100);
#line 3977
  issue = issue + 1;
  ldv_56765: 
#line 3979
  yield();
#line 3980
  bxmitok = rtl8723a_get_bcn_valid(padapter);
#line 3981
  poll = poll + 1;
#line 3984
  if (((poll % 10 != 0 && ! bxmitok) && padapter->bSurpriseRemoved == 0) && padapter->bDriverStopped == 0) {
#line 3986
    goto ldv_56765;
  } else {

  }

#line 3987
  if (((! bxmitok && issue <= 99) && padapter->bSurpriseRemoved == 0) && padapter->bDriverStopped == 0) {
#line 3989
    goto ldv_56767;
  } else {

  }

#line 3989
  if (padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) {
#line 3990
    return (0);
  } else {

  }
#line 3992
  passing_time = jiffies_to_msecs((unsigned long )jiffies - start);
#line 3994
  if (! bxmitok) {
#line 3995
    if (GlobalDebugLevel23A > 3U) {
#line 3995
      printk("\016RTL8723AU: %s fail! %u ms\n", "send_beacon23a", passing_time);
    } else {

    }
#line 3996
    return (0);
  } else {
#line 3999
    if (passing_time > 100U || issue > 3) {
#line 4000
      if (GlobalDebugLevel23A > 3U) {
#line 4000
        printk("\016RTL8723AU: %s success, issue:%d, poll:%d, %u ms\n", "send_beacon23a",
               issue, poll, passing_time);
      } else {

      }
    } else {

    }
#line 4002
    return (1);
  }
}
}
#line 4012 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
bool IsLegal5GChannel(struct rtw_adapter *Adapter , u8 channel ) 
{ 
  int i ;
  u8 Channel_5G[45U] ;

  {
#line 4015
  i = 0;
#line 4016
  Channel_5G[0] = 36U;
#line 4016
  Channel_5G[1] = 38U;
#line 4016
  Channel_5G[2] = 40U;
#line 4016
  Channel_5G[3] = 42U;
#line 4016
  Channel_5G[4] = 44U;
#line 4016
  Channel_5G[5] = 46U;
#line 4016
  Channel_5G[6] = 48U;
#line 4016
  Channel_5G[7] = 50U;
#line 4016
  Channel_5G[8] = 52U;
#line 4016
  Channel_5G[9] = 54U;
#line 4016
  Channel_5G[10] = 56U;
#line 4016
  Channel_5G[11] = 58U;
#line 4016
  Channel_5G[12] = 60U;
#line 4016
  Channel_5G[13] = 62U;
#line 4016
  Channel_5G[14] = 64U;
#line 4016
  Channel_5G[15] = 100U;
#line 4016
  Channel_5G[16] = 102U;
#line 4016
  Channel_5G[17] = 104U;
#line 4016
  Channel_5G[18] = 106U;
#line 4016
  Channel_5G[19] = 108U;
#line 4016
  Channel_5G[20] = 110U;
#line 4016
  Channel_5G[21] = 112U;
#line 4016
  Channel_5G[22] = 114U;
#line 4016
  Channel_5G[23] = 116U;
#line 4016
  Channel_5G[24] = 118U;
#line 4016
  Channel_5G[25] = 120U;
#line 4016
  Channel_5G[26] = 122U;
#line 4016
  Channel_5G[27] = 124U;
#line 4016
  Channel_5G[28] = 126U;
#line 4016
  Channel_5G[29] = 128U;
#line 4016
  Channel_5G[30] = 130U;
#line 4016
  Channel_5G[31] = 132U;
#line 4016
  Channel_5G[32] = 134U;
#line 4016
  Channel_5G[33] = 136U;
#line 4016
  Channel_5G[34] = 138U;
#line 4016
  Channel_5G[35] = 140U;
#line 4016
  Channel_5G[36] = 149U;
#line 4016
  Channel_5G[37] = 151U;
#line 4016
  Channel_5G[38] = 153U;
#line 4016
  Channel_5G[39] = 155U;
#line 4016
  Channel_5G[40] = 157U;
#line 4016
  Channel_5G[41] = 159U;
#line 4016
  Channel_5G[42] = 161U;
#line 4016
  Channel_5G[43] = 163U;
#line 4016
  Channel_5G[44] = 165U;
#line 4021
  i = 0;
#line 4021
  goto ldv_56777;
  ldv_56776: ;
#line 4022
  if ((int )Channel_5G[i] == (int )channel) {
#line 4023
    return (1);
  } else {

  }
#line 4021
  i = i + 1;
  ldv_56777: ;
#line 4021
  if ((unsigned int )i <= 44U) {
#line 4023
    goto ldv_56776;
  } else {

  }

#line 4024
  return (0);
}
}
#line 4027 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void rtw_site_survey(struct rtw_adapter *padapter ) 
{ 
  unsigned char survey_channel ;
  enum rt_scan_type ScanType ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct rtw_ieee80211_channel *ch ;
  int i ;
  unsigned long tmp ;
  bool tmp___0 ;

  {
#line 4029
  survey_channel = 0U;
#line 4030
  ScanType = 0;
#line 4031
  pmlmeext = & padapter->mlmeextpriv;
#line 4032
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4035
  if (pmlmeext->sitesurvey_res.channel_idx < (int )pmlmeext->sitesurvey_res.ch_num) {
#line 4037
    ch = (struct rtw_ieee80211_channel *)(& pmlmeext->sitesurvey_res.ch) + (unsigned long )pmlmeext->sitesurvey_res.channel_idx;
#line 4038
    survey_channel = (unsigned char )ch->hw_value;
#line 4039
    ScanType = (ch->flags & 2U) == 0U;
  } else {

  }
#line 4043
  if ((unsigned int )survey_channel != 0U) {
#line 4045
    if (pmlmeext->sitesurvey_res.channel_idx == 0) {
#line 4046
      set_channel_bwmode23a(padapter, (int )survey_channel, 0, 0);
    } else {
#line 4050
      SelectChannel23a(padapter, (int )survey_channel);
    }
#line 4052
    if ((unsigned int )ScanType == 1U) {
#line 4056
      i = 0;
#line 4056
      goto ldv_56789;
      ldv_56788: ;
#line 4057
      if ((unsigned int )pmlmeext->sitesurvey_res.ssid[i].ssid_len != 0U) {
#line 4059
        issue_probereq(padapter, (struct cfg80211_ssid *)(& pmlmeext->sitesurvey_res.ssid) + (unsigned long )i,
                       (u8 *)0U);
#line 4061
        issue_probereq(padapter, (struct cfg80211_ssid *)(& pmlmeext->sitesurvey_res.ssid) + (unsigned long )i,
                       (u8 *)0U);
      } else {

      }
#line 4056
      i = i + 1;
      ldv_56789: ;
#line 4056
      if (i <= 8) {
#line 4058
        goto ldv_56788;
      } else {

      }

#line 4065
      if (pmlmeext->sitesurvey_res.scan_mode == 1) {
#line 4067
        issue_probereq(padapter, (struct cfg80211_ssid *)0, (u8 *)0U);
#line 4069
        issue_probereq(padapter, (struct cfg80211_ssid *)0, (u8 *)0U);
      } else {

      }
    } else {

    }
#line 4073
    tmp = msecs_to_jiffies((unsigned int const   )pmlmeext->chan_scan_time);
#line 4073
    ldv_mod_timer_107(& pmlmeext->survey_timer, tmp + (unsigned long )jiffies);
  } else {
#line 4076
    pmlmeext->sitesurvey_res.state = 4;
#line 4080
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                          (int )pmlmeext->cur_bwmode);
#line 4088
    rtl8723a_set_media_status(padapter, (int )((u8 )pmlmeinfo->state) & 3);
#line 4091
    rtl8723a_set_initial_gain(padapter, 255U);
#line 4093
    rtl8723a_odm_support_ability_restore(padapter);
#line 4095
    tmp___0 = is_client_associated_to_ap23a(padapter);
#line 4095
    if ((int )tmp___0) {
#line 4096
      issue_nulldata23a(padapter, (unsigned char *)0U, 0U, 3, 500);
    } else {

    }
#line 4098
    rtl8723a_mlme_sitesurvey(padapter, 0);
#line 4100
    report_surveydone_event23a(padapter);
#line 4102
    pmlmeext->chan_scan_time = 100U;
#line 4103
    pmlmeext->sitesurvey_res.state = 0;
  }
#line 4106
  return;
}
}
#line 4110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static struct wlan_bssid_ex *collect_bss_info(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *bssid ;
  u8 const   *p ;
  u8 *pie ;
  unsigned int length ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct ieee80211_ht_operation *HT_info ;
  u8 tmp___3 ;
  int tmp___4 ;
  struct mlme_priv *pmlmepriv ;
  struct ieee80211_ht_cap *pHT_caps ;
  u8 tmp___5 ;

  {
#line 4113
  skb = precv_frame->pkt;
#line 4114
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 4115
  pregistrypriv = & padapter->registrypriv;
#line 4116
  pmlmeext = & padapter->mlmeextpriv;
#line 4117
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4124
  length = skb->len;
#line 4126
  tmp = kzalloc(871UL, 32U);
#line 4126
  bssid = (struct wlan_bssid_ex *)tmp;
#line 4127
  if ((unsigned long )bssid == (unsigned long )((struct wlan_bssid_ex *)0)) {
#line 4128
    return ((struct wlan_bssid_ex *)0);
  } else {

  }
#line 4130
  tmp___2 = ieee80211_is_beacon((int )mgmt->frame_control);
#line 4130
  if (tmp___2 != 0) {
#line 4131
    length = length - 36U;
#line 4132
    pie = (u8 *)(& mgmt->u.beacon.variable);
#line 4133
    bssid->reserved = 1U;
#line 4134
    bssid->capability = get_unaligned_le16((void const   *)(& mgmt->u.beacon.capab_info));
#line 4136
    bssid->beacon_interval = get_unaligned_le16((void const   *)(& mgmt->u.beacon.beacon_int));
#line 4138
    bssid->tsf = get_unaligned_le64((void const   *)(& mgmt->u.beacon.timestamp));
  } else {
#line 4139
    tmp___1 = ieee80211_is_probe_req((int )mgmt->frame_control);
#line 4139
    if (tmp___1 != 0) {
#line 4140
      length = length - 24U;
#line 4141
      pie = (u8 *)(& mgmt->u.probe_req.variable);
#line 4142
      bssid->reserved = 2U;
#line 4143
      bssid->capability = 0U;
#line 4144
      bssid->beacon_interval = padapter->registrypriv.dev_network.beacon_interval;
#line 4146
      bssid->tsf = 0ULL;
    } else {
#line 4147
      tmp___0 = ieee80211_is_probe_resp((int )mgmt->frame_control);
#line 4147
      if (tmp___0 != 0) {
#line 4148
        length = length - 36U;
#line 4150
        pie = (u8 *)(& mgmt->u.probe_resp.variable);
#line 4151
        bssid->reserved = 3U;
#line 4152
        bssid->capability = get_unaligned_le16((void const   *)(& mgmt->u.probe_resp.capab_info));
#line 4154
        bssid->beacon_interval = get_unaligned_le16((void const   *)(& mgmt->u.probe_resp.beacon_int));
#line 4156
        bssid->tsf = get_unaligned_le64((void const   *)(& mgmt->u.probe_resp.timestamp));
      } else {
#line 4158
        length = length - 36U;
#line 4159
        pie = (u8 *)(& mgmt->u.beacon.variable);
#line 4160
        bssid->reserved = 0U;
#line 4161
        bssid->capability = get_unaligned_le16((void const   *)(& mgmt->u.beacon.capab_info));
#line 4163
        bssid->beacon_interval = padapter->registrypriv.dev_network.beacon_interval;
#line 4165
        bssid->tsf = 0ULL;
      }
    }
  }
#line 4168
  if (length > 768U) {
#line 4170
    kfree((void const   *)bssid);
#line 4171
    return ((struct wlan_bssid_ex *)0);
  } else {

  }
#line 4174
  bssid->Length = length + 103U;
#line 4177
  bssid->IELength = length;
#line 4178
  memcpy((void *)(& bssid->IEs), (void const   *)pie, (size_t )bssid->IELength);
#line 4182
  bssid->Rssi = (long )precv_frame->attrib.phy_info.RecvSignalPower;
#line 4183
  bssid->SignalQuality = precv_frame->attrib.phy_info.SignalQuality;
#line 4185
  bssid->SignalStrength = precv_frame->attrib.phy_info.SignalStrength;
#line 4189
  p = cfg80211_find_ie(0, (u8 const   *)(& bssid->IEs), (int )bssid->IELength);
#line 4191
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
#line 4192
    if (GlobalDebugLevel23A > 3U) {
#line 4192
      printk("\016RTL8723AU: marc: cannot find SSID for survey event\n");
    } else {

    }
#line 4193
    goto fail;
  } else {

  }
#line 4196
  if ((unsigned int )((unsigned char )*(p + 1UL)) > 32U) {
#line 4197
    if (GlobalDebugLevel23A > 3U) {
#line 4197
      printk("\016RTL8723AU: %s()-%d: IE too long (%d) for survey event\n", "collect_bss_info",
             4198, (int )*(p + 1UL));
    } else {

    }
#line 4199
    goto fail;
  } else {

  }
#line 4201
  memcpy((void *)(& bssid->Ssid.ssid), (void const   *)p + 2U, (size_t )*(p + 1UL));
#line 4202
  bssid->Ssid.ssid_len = *(p + 1UL);
#line 4205
  i = 0;
#line 4206
  p = cfg80211_find_ie(1, (u8 const   *)(& bssid->IEs), (int )bssid->IELength);
#line 4207
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 4208
    if ((unsigned int )((unsigned char )*(p + 1UL)) > 16U) {
#line 4209
      if (GlobalDebugLevel23A > 3U) {
#line 4209
        printk("\016RTL8723AU: %s()-%d: IE too long (%d) for survey event\n", "collect_bss_info",
               4210, (int )*(p + 1UL));
      } else {

      }
#line 4211
      goto fail;
    } else {

    }
#line 4213
    memcpy((void *)(& bssid->SupportedRates), (void const   *)p + 2U, (size_t )*(p + 1UL));
#line 4214
    i = (int )*(p + 1UL);
  } else {

  }
#line 4217
  p = cfg80211_find_ie(50, (u8 const   *)(& bssid->IEs), (int )bssid->IELength);
#line 4219
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 4220
    if ((int )*(p + 1UL) > 16 - i) {
#line 4221
      if (GlobalDebugLevel23A > 3U) {
#line 4221
        printk("\016RTL8723AU: %s()-%d: IE too long (%d) for survey event\n", "collect_bss_info",
               4222, (int )*(p + 1UL));
      } else {

      }
#line 4223
      goto fail;
    } else {

    }
#line 4225
    memcpy((void *)(& bssid->SupportedRates) + (unsigned long )i, (void const   *)p + 2U,
             (size_t )*(p + 1UL));
  } else {

  }
#line 4229
  p = cfg80211_find_ie(3, (u8 const   *)(& bssid->IEs), (int )bssid->IELength);
#line 4231
  bssid->DSConfig = 0U;
#line 4233
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 4234
    bssid->DSConfig = (u32 )*(p + 2UL);
  } else {
#line 4237
    p = cfg80211_find_ie(61, (u8 const   *)(& bssid->IEs), (int )bssid->IELength);
#line 4239
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 4240
      HT_info = (struct ieee80211_ht_operation *)p + 2U;
#line 4242
      bssid->DSConfig = (u32 )HT_info->primary_chan;
    } else {
#line 4244
      tmp___3 = rtw_get_oper_ch23a(padapter);
#line 4244
      bssid->DSConfig = (u32 )tmp___3;
    }
  }
#line 4247
  tmp___4 = ieee80211_is_probe_req((int )mgmt->frame_control);
#line 4247
  if (tmp___4 != 0) {
#line 4249
    bssid->ifmode = 2;
#line 4250
    ether_addr_copy((u8 *)(& bssid->MacAddress), (u8 const   *)(& mgmt->sa));
#line 4251
    bssid->Privacy = 1U;
#line 4252
    return (bssid);
  } else {

  }
#line 4255
  if ((int )bssid->capability & 1) {
#line 4256
    bssid->ifmode = 2;
#line 4257
    ether_addr_copy((u8 *)(& bssid->MacAddress), (u8 const   *)(& mgmt->sa));
  } else {
#line 4259
    bssid->ifmode = 1;
#line 4260
    ether_addr_copy((u8 *)(& bssid->MacAddress), (u8 const   *)(& mgmt->bssid));
  }
#line 4263
  if (((int )bssid->capability & 16) != 0) {
#line 4264
    bssid->Privacy = 1U;
  } else {
#line 4266
    bssid->Privacy = 0U;
  }
#line 4268
  bssid->ATIMWindow = 0U;
#line 4271
  if ((unsigned int )pregistrypriv->wifi_spec == 1U && (unsigned int )pmlmeinfo->bwmode_updated == 0U) {
#line 4273
    pmlmepriv = & padapter->mlmepriv;
#line 4275
    p = cfg80211_find_ie(45, (u8 const   *)(& bssid->IEs), (int )bssid->IELength);
#line 4277
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 4280
      pHT_caps = (struct ieee80211_ht_cap *)p + 2U;
#line 4282
      if (((int )pHT_caps->cap_info & 16384) != 0) {
#line 4284
        pmlmepriv->num_FortyMHzIntolerant = pmlmepriv->num_FortyMHzIntolerant + 1;
      } else {

      }
    } else {
#line 4286
      pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht + 1;
    }
  } else {

  }
#line 4291
  tmp___5 = rtw_get_oper_ch23a(padapter);
#line 4291
  if (bssid->DSConfig != (u32 )tmp___5) {
#line 4292
    bssid->SignalQuality = 101U;
  } else {

  }
#line 4294
  return (bssid);
  fail: 
#line 4296
  kfree((void const   *)bssid);
#line 4297
  return ((struct wlan_bssid_ex *)0);
}
}
#line 4300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void start_create_ibss(struct rtw_adapter *padapter ) 
{ 
  unsigned short caps ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  int tmp ;

  {
#line 4303
  pmlmeext = & padapter->mlmeextpriv;
#line 4304
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4305
  pnetwork = & pmlmeinfo->network;
#line 4307
  pmlmeext->cur_channel = (unsigned char )pnetwork->DSConfig;
#line 4308
  pmlmeinfo->bcn_interval = pnetwork->beacon_interval;
#line 4311
  update_wireless_mode23a(padapter);
#line 4314
  caps = pnetwork->capability;
#line 4315
  update_capinfo23a(padapter, (int )caps);
#line 4316
  if (((int )caps & 2) != 0) {
#line 4317
    rtl8723a_set_sec_cfg(padapter, 207);
#line 4321
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, 0, 0);
#line 4323
    rtl8723a_SetBeaconRelatedRegisters(padapter);
#line 4326
    pmlmeinfo->state = 1U;
#line 4327
    rtl8723a_set_media_status(padapter, (int )((u8 )pmlmeinfo->state) & 3);
#line 4330
    tmp = send_beacon23a(padapter);
#line 4330
    if (tmp == 0) {
#line 4331
      if (GlobalDebugLevel23A > 3U) {
#line 4331
        rt_trace(16, 4, "issuing beacon frame fail....\n");
      } else {

      }
#line 4334
      report_join_res23a(padapter, -1);
#line 4335
      pmlmeinfo->state = 0U;
    } else {
#line 4337
      hw_var_set_bssid(padapter, (u8 *)(& padapter->registrypriv.dev_network.MacAddress));
#line 4338
      hw_var_set_mlme_join(padapter, 0);
#line 4340
      report_join_res23a(padapter, 1);
#line 4341
      pmlmeinfo->state = pmlmeinfo->state | 16384U;
    }
  } else {
#line 4344
    if (GlobalDebugLevel23A > 3U) {
#line 4344
      printk("\016RTL8723AU: %s: invalid cap:%x\n", "start_create_ibss", (int )caps);
    } else {

    }
#line 4345
    return;
  }
#line 4347
  return;
}
}
#line 4349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void start_clnt_join(struct rtw_adapter *padapter ) 
{ 
  unsigned short caps ;
  u8 val8 ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  int beacon_timeout ;
  unsigned int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 4353
  pmlmeext = & padapter->mlmeextpriv;
#line 4354
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4355
  pnetwork = & pmlmeinfo->network;
#line 4358
  pmlmeext->cur_channel = (unsigned char )pnetwork->DSConfig;
#line 4359
  pmlmeinfo->bcn_interval = pnetwork->beacon_interval;
#line 4362
  update_wireless_mode23a(padapter);
#line 4365
  caps = pnetwork->capability;
#line 4366
  update_capinfo23a(padapter, (int )caps);
#line 4367
  if ((int )caps & 1) {
#line 4369
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                          (int )pmlmeext->cur_bwmode);
#line 4371
    rtl8723a_set_media_status(padapter, 2);
#line 4373
    val8 = pmlmeinfo->auth_algo == 2U ? 204U : 207U;
#line 4376
    rtl8723a_set_sec_cfg(padapter, (int )val8);
#line 4383
    tmp = decide_wait_for_beacon_timeout23a((unsigned int )pmlmeinfo->bcn_interval);
#line 4383
    beacon_timeout = (int )tmp;
#line 4384
    tmp___0 = msecs_to_jiffies((unsigned int const   )beacon_timeout);
#line 4384
    ldv_mod_timer_108(& pmlmeext->link_timer, tmp___0 + (unsigned long )jiffies);
#line 4385
    tmp___1 = msecs_to_jiffies((unsigned int const   )(beacon_timeout + 2400));
#line 4385
    ldv_mod_timer_109(& padapter->mlmepriv.assoc_timer, tmp___1 + (unsigned long )jiffies);
#line 4387
    pmlmeinfo->state = 258U;
  } else
#line 4388
  if (((int )caps & 2) != 0) {
#line 4389
    rtl8723a_set_media_status(padapter, 1);
#line 4391
    rtl8723a_set_sec_cfg(padapter, 207);
#line 4394
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                          (int )pmlmeext->cur_bwmode);
#line 4396
    rtl8723a_SetBeaconRelatedRegisters(padapter);
#line 4398
    pmlmeinfo->state = 1U;
#line 4400
    report_join_res23a(padapter, 1);
  } else {
#line 4403
    return;
  }
#line 4404
  return;
}
}
#line 4407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void start_clnt_auth(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned long tmp ;

  {
#line 4409
  pmlmeext = & padapter->mlmeextpriv;
#line 4410
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4412
  ldv_del_timer_sync_110(& pmlmeext->link_timer);
#line 4414
  pmlmeinfo->state = pmlmeinfo->state & 4294967039U;
#line 4415
  pmlmeinfo->state = pmlmeinfo->state | 512U;
#line 4417
  pmlmeinfo->auth_seq = 1U;
#line 4418
  pmlmeinfo->reauth_count = 0U;
#line 4419
  pmlmeinfo->reassoc_count = 0U;
#line 4420
  pmlmeinfo->link_count = 0U;
#line 4421
  pmlmeext->retry = 0U;
#line 4429
  issue_deauth23a(padapter, (unsigned char *)(& pmlmeinfo->network.MacAddress), 3);
#line 4432
  if (GlobalDebugLevel23A != 0U) {
#line 4432
    printk("\016RTL8723AU: start auth\n");
  } else {

  }
#line 4433
  issue_auth(padapter, (struct sta_info *)0, 0);
#line 4435
  tmp = msecs_to_jiffies(300U);
#line 4435
  ldv_mod_timer_111(& pmlmeext->link_timer, tmp + (unsigned long )jiffies);
#line 4436
  return;
}
}
#line 4438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void start_clnt_assoc(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned long tmp ;

  {
#line 4440
  pmlmeext = & padapter->mlmeextpriv;
#line 4441
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4443
  ldv_del_timer_sync_112(& pmlmeext->link_timer);
#line 4445
  pmlmeinfo->state = pmlmeinfo->state & 4294966527U;
#line 4446
  pmlmeinfo->state = pmlmeinfo->state | 9216U;
#line 4448
  issue_assocreq(padapter);
#line 4450
  tmp = msecs_to_jiffies(300U);
#line 4450
  ldv_mod_timer_113(& pmlmeext->link_timer, tmp + (unsigned long )jiffies);
#line 4451
  return;
}
}
#line 4453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int receive_disconnect23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                          unsigned short reason ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 4456
  pmlmeext = & padapter->mlmeextpriv;
#line 4457
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4460
  tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 4460
  tmp___0 = ether_addr_equal((u8 const   *)MacAddr, (u8 const   *)tmp);
#line 4460
  if (tmp___0) {
#line 4460
    tmp___1 = 0;
  } else {
#line 4460
    tmp___1 = 1;
  }
#line 4460
  if (tmp___1) {
#line 4461
    return (1);
  } else {

  }
#line 4463
  if (GlobalDebugLevel23A > 3U) {
#line 4463
    printk("\016RTL8723AU: %s\n", "receive_disconnect23a");
  } else {

  }
#line 4465
  if ((pmlmeinfo->state & 3U) == 2U) {
#line 4466
    if ((pmlmeinfo->state & 16384U) != 0U) {
#line 4467
      pmlmeinfo->state = 0U;
#line 4468
      report_del_sta_event23a(padapter, MacAddr, (int )reason);
    } else
#line 4470
    if ((pmlmeinfo->state & 9984U) != 0U) {
#line 4471
      pmlmeinfo->state = 0U;
#line 4472
      report_join_res23a(padapter, -2);
    } else {

    }
  } else {

  }
#line 4476
  return (1);
}
}
#line 4479 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void process_80211d(struct rtw_adapter *padapter , struct wlan_bssid_ex *bssid ) 
{ 
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct rt_channel_info *chplan_new ;
  u8 channel ;
  u8 i ;
  u8 const   *ie ;
  u8 const   *p ;
  struct rt_channel_plan chplan_ap ;
  struct rt_channel_info chplan_sta[38U] ;
  u8 country[4U] ;
  u8 fcn ;
  u8 noc ;
  u8 j ;
  u8 k ;
  u8 const   *tmp ;
  u8 const   *tmp___0 ;
  u8 tmp___1 ;

  {
#line 4488
  pregistrypriv = & padapter->registrypriv;
#line 4489
  pmlmeext = & padapter->mlmeextpriv;
#line 4492
  if ((unsigned int )pregistrypriv->enable80211d != 0U && (unsigned int )pmlmeext->update_channel_plan_by_ap_done == 0U) {
#line 4502
    ie = cfg80211_find_ie(7, (u8 const   *)(& bssid->IEs), (int )bssid->IELength);
#line 4504
    if ((unsigned long )ie == (unsigned long )((u8 const   *)0U) || (unsigned int )((unsigned char )*(ie + 1UL)) <= 5U) {
#line 4505
      return;
    } else {

    }
#line 4507
    p = ie + 2UL;
#line 4508
    ie = ie + (unsigned long )*(ie + 1UL);
#line 4509
    ie = ie + 2UL;
#line 4511
    memcpy((void *)(& country), (void const   *)p, 3UL);
#line 4512
    country[3] = 0U;
#line 4514
    p = p + 3UL;
#line 4515
    if (GlobalDebugLevel23A > 5U) {
#line 4515
      rt_trace(16, 6, "%s: 802.11d country =%s\n", "process_80211d", (u8 *)(& country));
    } else {

    }
#line 4518
    i = 0U;
#line 4519
    goto ldv_56868;
    ldv_56867: 
#line 4520
    tmp = p;
#line 4520
    p = p + 1;
#line 4520
    fcn = *tmp;
#line 4521
    tmp___0 = p;
#line 4521
    p = p + 1;
#line 4521
    noc = *tmp___0;
#line 4522
    p = p + 1;
#line 4524
    j = 0U;
#line 4524
    goto ldv_56865;
    ldv_56864: ;
#line 4525
    if ((unsigned int )fcn <= 14U) {
#line 4526
      channel = (int )fcn + (int )j;
    } else {
#line 4528
      channel = (unsigned int )j * 4U + (unsigned int )fcn;
    }
#line 4530
    tmp___1 = i;
#line 4530
    i = (u8 )((int )i + 1);
#line 4530
    chplan_ap.Channel[(int )tmp___1] = channel;
#line 4524
    j = (u8 )((int )j + 1);
    ldv_56865: ;
#line 4524
    if ((int )j < (int )noc) {
#line 4526
      goto ldv_56864;
    } else {

    }

    ldv_56868: ;
#line 4519
    if ((long )ie - (long )p > 2L) {
#line 4521
      goto ldv_56867;
    } else {

    }
#line 4533
    chplan_ap.Len = i;
#line 4535
    memcpy((void *)(& chplan_sta), (void const   *)(& pmlmeext->channel_set), 304UL);
#line 4536
    memset((void *)(& pmlmeext->channel_set), 0, 304UL);
#line 4537
    chplan_new = (struct rt_channel_info *)(& pmlmeext->channel_set);
#line 4539
    k = 0U;
#line 4539
    j = k;
#line 4539
    i = j;
#line 4540
    if (((int )pregistrypriv->wireless_mode & 2) != 0) {
      ldv_56871: ;
#line 4542
      if (((unsigned int )i == 38U || (unsigned int )chplan_sta[(int )i].ChannelNum == 0U) || (unsigned int )chplan_sta[(int )i].ChannelNum > 14U) {
#line 4545
        goto ldv_56870;
      } else {

      }
#line 4547
      if ((int )chplan_ap.Len == (int )j || (unsigned int )chplan_ap.Channel[(int )j] > 14U) {
#line 4549
        goto ldv_56870;
      } else {

      }
#line 4551
      if ((int )chplan_sta[(int )i].ChannelNum == (int )chplan_ap.Channel[(int )j]) {
#line 4553
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
#line 4555
        (chplan_new + (unsigned long )k)->ScanType = 1;
#line 4556
        i = (u8 )((int )i + 1);
#line 4557
        j = (u8 )((int )j + 1);
#line 4558
        k = (u8 )((int )k + 1);
      } else
#line 4559
      if ((int )chplan_sta[(int )i].ChannelNum < (int )chplan_ap.Channel[(int )j]) {
#line 4561
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
#line 4563
        (chplan_new + (unsigned long )k)->ScanType = 0;
#line 4565
        i = (u8 )((int )i + 1);
#line 4566
        k = (u8 )((int )k + 1);
      } else
#line 4567
      if ((int )chplan_sta[(int )i].ChannelNum > (int )chplan_ap.Channel[(int )j]) {
#line 4569
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
#line 4571
        (chplan_new + (unsigned long )k)->ScanType = 1;
#line 4573
        j = (u8 )((int )j + 1);
#line 4574
        k = (u8 )((int )k + 1);
      } else {

      }
#line 4576
      goto ldv_56871;
      ldv_56870: ;
#line 4579
      goto ldv_56873;
      ldv_56872: 
#line 4582
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
#line 4584
      (chplan_new + (unsigned long )k)->ScanType = 0;
#line 4585
      i = (u8 )((int )i + 1);
#line 4586
      k = (u8 )((int )k + 1);
      ldv_56873: ;
#line 4579
      if (((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) && (unsigned int )chplan_sta[(int )i].ChannelNum <= 14U) {
#line 4583
        goto ldv_56872;
      } else {

      }

#line 4590
      goto ldv_56876;
      ldv_56875: 
#line 4591
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
#line 4592
      (chplan_new + (unsigned long )k)->ScanType = 1;
#line 4593
      j = (u8 )((int )j + 1);
#line 4594
      k = (u8 )((int )k + 1);
      ldv_56876: ;
#line 4590
      if ((int )chplan_ap.Len > (int )j && (unsigned int )chplan_ap.Channel[(int )j] <= 14U) {
#line 4592
        goto ldv_56875;
      } else {

      }

    } else {
#line 4598
      goto ldv_56879;
      ldv_56878: 
#line 4601
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
#line 4603
      (chplan_new + (unsigned long )k)->ScanType = chplan_sta[(int )i].ScanType;
#line 4604
      i = (u8 )((int )i + 1);
#line 4605
      k = (u8 )((int )k + 1);
      ldv_56879: ;
#line 4598
      if (((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) && (unsigned int )chplan_sta[(int )i].ChannelNum <= 14U) {
#line 4602
        goto ldv_56878;
      } else {

      }

#line 4609
      goto ldv_56882;
      ldv_56881: 
#line 4610
      j = (u8 )((int )j + 1);
      ldv_56882: ;
#line 4609
      if ((int )chplan_ap.Len > (int )j && (unsigned int )chplan_ap.Channel[(int )j] <= 14U) {
#line 4611
        goto ldv_56881;
      } else {

      }

    }
#line 4613
    if (((int )pregistrypriv->wireless_mode & 4) != 0) {
      ldv_56885: ;
#line 4615
      if ((unsigned int )i == 38U || (unsigned int )chplan_sta[(int )i].ChannelNum == 0U) {
#line 4617
        goto ldv_56884;
      } else {

      }
#line 4619
      if ((int )chplan_ap.Len == (int )j || (unsigned int )chplan_ap.Channel[(int )j] == 0U) {
#line 4621
        goto ldv_56884;
      } else {

      }
#line 4623
      if ((int )chplan_sta[(int )i].ChannelNum == (int )chplan_ap.Channel[(int )j]) {
#line 4625
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
#line 4627
        (chplan_new + (unsigned long )k)->ScanType = 1;
#line 4628
        i = (u8 )((int )i + 1);
#line 4629
        j = (u8 )((int )j + 1);
#line 4630
        k = (u8 )((int )k + 1);
      } else
#line 4631
      if ((int )chplan_sta[(int )i].ChannelNum < (int )chplan_ap.Channel[(int )j]) {
#line 4633
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
#line 4635
        (chplan_new + (unsigned long )k)->ScanType = 0;
#line 4636
        i = (u8 )((int )i + 1);
#line 4637
        k = (u8 )((int )k + 1);
      } else
#line 4638
      if ((int )chplan_sta[(int )i].ChannelNum > (int )chplan_ap.Channel[(int )j]) {
#line 4640
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
#line 4642
        (chplan_new + (unsigned long )k)->ScanType = 1;
#line 4643
        j = (u8 )((int )j + 1);
#line 4644
        k = (u8 )((int )k + 1);
      } else {

      }
#line 4646
      goto ldv_56885;
      ldv_56884: ;
#line 4649
      goto ldv_56887;
      ldv_56886: 
#line 4651
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
#line 4653
      (chplan_new + (unsigned long )k)->ScanType = 0;
#line 4654
      i = (u8 )((int )i + 1);
#line 4655
      k = (u8 )((int )k + 1);
      ldv_56887: ;
#line 4649
      if ((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) {
#line 4652
        goto ldv_56886;
      } else {

      }

#line 4659
      goto ldv_56890;
      ldv_56889: 
#line 4660
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
#line 4661
      (chplan_new + (unsigned long )k)->ScanType = 1;
#line 4662
      j = (u8 )((int )j + 1);
#line 4663
      k = (u8 )((int )k + 1);
      ldv_56890: ;
#line 4659
      if ((int )chplan_ap.Len > (int )j && (unsigned int )chplan_ap.Channel[(int )j] != 0U) {
#line 4661
        goto ldv_56889;
      } else {

      }

    } else {
#line 4667
      goto ldv_56893;
      ldv_56892: 
#line 4669
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
#line 4671
      (chplan_new + (unsigned long )k)->ScanType = chplan_sta[(int )i].ScanType;
#line 4672
      i = (u8 )((int )i + 1);
#line 4673
      k = (u8 )((int )k + 1);
      ldv_56893: ;
#line 4667
      if ((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) {
#line 4670
        goto ldv_56892;
      } else {

      }

    }
#line 4676
    pmlmeext->update_channel_plan_by_ap_done = 1U;
  } else {

  }
#line 4680
  channel = (u8 )bssid->DSConfig;
#line 4681
  chplan_new = (struct rt_channel_info *)(& pmlmeext->channel_set);
#line 4682
  i = 0U;
#line 4683
  goto ldv_56897;
  ldv_56896: ;
#line 4684
  if ((int )(chplan_new + (unsigned long )i)->ChannelNum == (int )channel) {
#line 4685
    if ((unsigned int )(chplan_new + (unsigned long )i)->ScanType == 0U) {
#line 4688
      if ((unsigned int )channel > 51U && (unsigned int )channel <= 144U) {
#line 4689
        goto ldv_56895;
      } else {

      }
#line 4691
      (chplan_new + (unsigned long )i)->ScanType = 1;
#line 4692
      if (GlobalDebugLevel23A > 5U) {
#line 4692
        rt_trace(16, 6, "%s: change channel %d scan type from passive to active\n",
                 "process_80211d", (int )channel);
      } else {

      }
    } else {

    }
#line 4696
    goto ldv_56895;
  } else {

  }
#line 4698
  i = (u8 )((int )i + 1);
  ldv_56897: ;
#line 4683
  if ((unsigned int )i <= 37U && (unsigned int )(chplan_new + (unsigned long )i)->ChannelNum != 0U) {
#line 4685
    goto ldv_56896;
  } else {

  }
  ldv_56895: ;
#line 4690
  return;
}
}
#line 4708 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void report_survey_event23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct survey_event *psurvey_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 4719
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 4720
    return;
  } else {

  }
#line 4722
  pmlmeext = & padapter->mlmeextpriv;
#line 4723
  pcmdpriv = & padapter->cmdpriv;
#line 4725
  tmp = kzalloc(128UL, 32U);
#line 4725
  pcmd_obj = (struct cmd_obj *)tmp;
#line 4726
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
#line 4727
    return;
  } else {

  }
#line 4729
  cmdsz = 16U;
#line 4730
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
#line 4730
  pevtcmd = (u8 *)tmp___0;
#line 4731
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
#line 4732
    kfree((void const   *)pcmd_obj);
#line 4733
    return;
  } else {

  }
#line 4736
  pcmd_obj->cmdcode = 56U;
#line 4737
  pcmd_obj->cmdsz = cmdsz;
#line 4738
  pcmd_obj->parmbuf = pevtcmd;
#line 4740
  pcmd_obj->rsp = (u8 *)0U;
#line 4741
  pcmd_obj->rspsz = 0U;
#line 4743
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
#line 4744
  pc2h_evt_hdr->len = 8U;
#line 4745
  pc2h_evt_hdr->ID = 8U;
#line 4746
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
#line 4746
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
#line 4748
  psurvey_evt = (struct survey_event *)pevtcmd + 8U;
#line 4750
  psurvey_evt->bss = collect_bss_info(padapter, precv_frame);
#line 4751
  if ((unsigned long )psurvey_evt->bss == (unsigned long )((struct wlan_bssid_ex *)0)) {
#line 4752
    kfree((void const   *)pcmd_obj);
#line 4753
    kfree((void const   *)pevtcmd);
#line 4754
    return;
  } else {

  }
#line 4757
  process_80211d(padapter, psurvey_evt->bss);
#line 4759
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
#line 4761
  pmlmeext->sitesurvey_res.bss_cnt = pmlmeext->sitesurvey_res.bss_cnt + 1;
#line 4763
  return;
}
}
#line 4766 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void report_surveydone_event23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct surveydone_event *psurveydone_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 4773
  pmlmeext = & padapter->mlmeextpriv;
#line 4774
  pcmdpriv = & padapter->cmdpriv;
#line 4776
  tmp = kzalloc(128UL, 32U);
#line 4776
  pcmd_obj = (struct cmd_obj *)tmp;
#line 4777
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
#line 4778
    return;
  } else {

  }
#line 4780
  cmdsz = 12U;
#line 4781
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
#line 4781
  pevtcmd = (u8 *)tmp___0;
#line 4782
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
#line 4783
    kfree((void const   *)pcmd_obj);
#line 4784
    return;
  } else {

  }
#line 4787
  pcmd_obj->cmdcode = 56U;
#line 4788
  pcmd_obj->cmdsz = cmdsz;
#line 4789
  pcmd_obj->parmbuf = pevtcmd;
#line 4791
  pcmd_obj->rsp = (u8 *)0U;
#line 4792
  pcmd_obj->rspsz = 0U;
#line 4794
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
#line 4795
  pc2h_evt_hdr->len = 4U;
#line 4796
  pc2h_evt_hdr->ID = 9U;
#line 4797
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
#line 4797
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
#line 4799
  psurveydone_evt = (struct surveydone_event *)pevtcmd + 8U;
#line 4800
  psurveydone_evt->bss_cnt = (unsigned int )pmlmeext->sitesurvey_res.bss_cnt;
#line 4802
  if (GlobalDebugLevel23A > 3U) {
#line 4802
    printk("\016RTL8723AU: survey done event(%x)\n", psurveydone_evt->bss_cnt);
  } else {

  }
#line 4804
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
#line 4806
  return;
}
}
#line 4809 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void report_join_res23a(struct rtw_adapter *padapter , int res ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct joinbss_event *pjoinbss_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 4816
  pmlmeext = & padapter->mlmeextpriv;
#line 4817
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4818
  pcmdpriv = & padapter->cmdpriv;
#line 4820
  tmp = kzalloc(128UL, 32U);
#line 4820
  pcmd_obj = (struct cmd_obj *)tmp;
#line 4821
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
#line 4822
    return;
  } else {

  }
#line 4824
  cmdsz = 936U;
#line 4825
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
#line 4825
  pevtcmd = (u8 *)tmp___0;
#line 4826
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
#line 4827
    kfree((void const   *)pcmd_obj);
#line 4828
    return;
  } else {

  }
#line 4831
  pcmd_obj->cmdcode = 56U;
#line 4832
  pcmd_obj->cmdsz = cmdsz;
#line 4833
  pcmd_obj->parmbuf = pevtcmd;
#line 4835
  pcmd_obj->rsp = (u8 *)0U;
#line 4836
  pcmd_obj->rspsz = 0U;
#line 4838
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
#line 4839
  pc2h_evt_hdr->len = 928U;
#line 4840
  pc2h_evt_hdr->ID = 10U;
#line 4841
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
#line 4841
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
#line 4843
  pjoinbss_evt = (struct joinbss_event *)pevtcmd + 8U;
#line 4844
  memcpy((void *)(& pjoinbss_evt->network.network), (void const   *)(& pmlmeinfo->network),
           871UL);
#line 4846
  pjoinbss_evt->network.join_res = res;
#line 4848
  if (GlobalDebugLevel23A > 3U) {
#line 4848
    printk("\016RTL8723AU: report_join_res23a(%d)\n", res);
  } else {

  }
#line 4850
  rtw_joinbss_event_prehandle23a(padapter, (u8 *)(& pjoinbss_evt->network));
#line 4852
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
#line 4854
  return;
}
}
#line 4857 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void report_del_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             unsigned short reason ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct sta_info *psta ;
  int mac_id ;
  struct stadel_event *pdel_sta_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 4867
  pmlmeext = & padapter->mlmeextpriv;
#line 4868
  pcmdpriv = & padapter->cmdpriv;
#line 4870
  tmp = kzalloc(128UL, 32U);
#line 4870
  pcmd_obj = (struct cmd_obj *)tmp;
#line 4871
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
#line 4872
    return;
  } else {

  }
#line 4874
  cmdsz = 20U;
#line 4875
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
#line 4875
  pevtcmd = (u8 *)tmp___0;
#line 4876
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
#line 4877
    kfree((void const   *)pcmd_obj);
#line 4878
    return;
  } else {

  }
#line 4881
  pcmd_obj->cmdcode = 56U;
#line 4882
  pcmd_obj->cmdsz = cmdsz;
#line 4883
  pcmd_obj->parmbuf = pevtcmd;
#line 4885
  pcmd_obj->rsp = (u8 *)0U;
#line 4886
  pcmd_obj->rspsz = 0U;
#line 4888
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
#line 4889
  pc2h_evt_hdr->len = 12U;
#line 4890
  pc2h_evt_hdr->ID = 12U;
#line 4891
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
#line 4891
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
#line 4893
  pdel_sta_evt = (struct stadel_event *)pevtcmd + 8U;
#line 4894
  ether_addr_copy((u8 *)(& pdel_sta_evt->macaddr), (u8 const   *)MacAddr);
#line 4895
  memcpy((void *)(& pdel_sta_evt->rsvd), (void const   *)(& reason), 2UL);
#line 4898
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)MacAddr);
#line 4899
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 4900
    mac_id = (int )psta->mac_id;
  } else {
#line 4902
    mac_id = -1;
  }
#line 4904
  pdel_sta_evt->mac_id = mac_id;
#line 4906
  if (GlobalDebugLevel23A > 3U) {
#line 4906
    printk("\016RTL8723AU: report_del_sta_event23a: delete STA, mac_id =%d\n", mac_id);
  } else {

  }
#line 4908
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
#line 4910
  return;
}
}
#line 4913 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void report_add_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             int cam_idx ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct stassoc_event *padd_sta_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 4921
  pmlmeext = & padapter->mlmeextpriv;
#line 4922
  pcmdpriv = & padapter->cmdpriv;
#line 4924
  tmp = kzalloc(128UL, 32U);
#line 4924
  pcmd_obj = (struct cmd_obj *)tmp;
#line 4925
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
#line 4926
    return;
  } else {

  }
#line 4928
  cmdsz = 20U;
#line 4929
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
#line 4929
  pevtcmd = (u8 *)tmp___0;
#line 4930
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
#line 4931
    kfree((void const   *)pcmd_obj);
#line 4932
    return;
  } else {

  }
#line 4935
  pcmd_obj->cmdcode = 56U;
#line 4936
  pcmd_obj->cmdsz = cmdsz;
#line 4937
  pcmd_obj->parmbuf = pevtcmd;
#line 4939
  pcmd_obj->rsp = (u8 *)0U;
#line 4940
  pcmd_obj->rspsz = 0U;
#line 4942
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
#line 4943
  pc2h_evt_hdr->len = 12U;
#line 4944
  pc2h_evt_hdr->ID = 11U;
#line 4945
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
#line 4945
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
#line 4947
  padd_sta_evt = (struct stassoc_event *)pevtcmd + 8U;
#line 4948
  ether_addr_copy((u8 *)(& padd_sta_evt->macaddr), (u8 const   *)MacAddr);
#line 4949
  padd_sta_evt->cam_id = cam_idx;
#line 4951
  if (GlobalDebugLevel23A > 3U) {
#line 4951
    printk("\016RTL8723AU: report_add_sta_event23a: add STA\n");
  } else {

  }
#line 4953
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
#line 4955
  return;
}
}
#line 4965 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void update_sta_info23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int tmp ;

  {
#line 4967
  pmlmepriv = & padapter->mlmepriv;
#line 4968
  pmlmeext = & padapter->mlmeextpriv;
#line 4969
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4972
  VCS_update23a(padapter, psta);
#line 4975
  if ((int )pmlmepriv->htpriv.ht_option) {
#line 4976
    psta->htpriv.ht_option = 1;
#line 4978
    psta->htpriv.ampdu_enable = pmlmepriv->htpriv.ampdu_enable;
#line 4980
    tmp = support_short_GI23a(padapter, & pmlmeinfo->ht_cap);
#line 4980
    if (tmp != 0) {
#line 4981
      psta->htpriv.sgi = 1U;
    } else {

    }
#line 4983
    psta->qos_option = 1U;
  } else {
#line 4986
    psta->htpriv.ht_option = 0;
#line 4988
    psta->htpriv.ampdu_enable = 0;
#line 4990
    psta->htpriv.sgi = 0U;
#line 4991
    psta->qos_option = 0U;
  }
#line 4994
  psta->htpriv.bwmode = pmlmeext->cur_bwmode;
#line 4995
  psta->htpriv.ch_offset = pmlmeext->cur_ch_offset;
#line 4997
  psta->htpriv.agg_enable_bitmap = 0U;
#line 4998
  psta->htpriv.candidate_tid_bitmap = 0U;
#line 5001
  if (pmlmepriv->qos_option != 0U) {
#line 5002
    psta->qos_option = 1U;
  } else {

  }
#line 5004
  psta->state = 1U;
#line 5005
  return;
}
}
#line 5007 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void mlmeext_joinbss_event_callback23a(struct rtw_adapter *padapter , int join_res ) 
{ 
  struct sta_info *psta ;
  struct sta_info *psta_bmc ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_priv *pstapriv ;

  {
#line 5011
  pmlmeext = & padapter->mlmeextpriv;
#line 5012
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5013
  cur_network = & pmlmeinfo->network;
#line 5014
  pstapriv = & padapter->stapriv;
#line 5016
  if (join_res < 0) {
#line 5017
    hw_var_set_mlme_join(padapter, 1);
#line 5018
    hw_var_set_bssid(padapter, (u8 *)(& null_addr));
#line 5021
    update_tx_basic_rate23a(padapter, (int )padapter->registrypriv.wireless_mode);
#line 5024
    goto exit_mlmeext_joinbss_event_callback23a;
  } else {

  }
#line 5027
  if ((pmlmeinfo->state & 3U) == 1U) {
#line 5029
    psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
#line 5030
    if ((unsigned long )psta_bmc != (unsigned long )((struct sta_info *)0)) {
#line 5031
      pmlmeinfo->FW_sta_info[psta_bmc->mac_id].psta = psta_bmc;
#line 5032
      update_bmc_sta_support_rate23a(padapter, psta_bmc->mac_id);
#line 5033
      Update_RA_Entry23a(padapter, psta_bmc);
    } else {

    }
  } else {

  }
#line 5038
  rtl8723a_odm_support_ability_set(padapter, 268435455U);
#line 5041
  update_IOT_info23a(padapter);
#line 5043
  HalSetBrateCfg23a(padapter, (u8 *)(& cur_network->SupportedRates));
#line 5046
  rtl8723a_set_beacon_interval(padapter, (int )pmlmeinfo->bcn_interval);
#line 5049
  update_capinfo23a(padapter, (int )pmlmeinfo->capability);
#line 5052
  WMMOnAssocRsp23a(padapter);
#line 5055
  HTOnAssocRsp23a(padapter);
#line 5058
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
#line 5060
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->MacAddress));
#line 5061
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 5062
    pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
#line 5066
    psta->wireless_mode = pmlmeext->cur_wireless_mode;
#line 5069
    set_sta_rate23a(padapter, psta);
  } else {

  }
#line 5072
  hw_var_set_mlme_join(padapter, 2);
#line 5074
  if ((pmlmeinfo->state & 3U) == 2U) {
#line 5076
    rtw_correct_TSF(padapter);
  } else {

  }
#line 5081
  rtw_lps_ctrl_wk_cmd23a(padapter, 2, 0);
  exit_mlmeext_joinbss_event_callback23a: ;
#line 5084
  if (GlobalDebugLevel23A > 3U) {
#line 5084
    printk("\016RTL8723AU: =>%s\n", "mlmeext_joinbss_event_callback23a");
  } else {

  }
#line 5085
  return;
}
}
#line 5087 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void mlmeext_sta_add_event_callback23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int tmp ;

  {
#line 5090
  pmlmeext = & padapter->mlmeextpriv;
#line 5091
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5093
  if (GlobalDebugLevel23A > 3U) {
#line 5093
    printk("\016RTL8723AU: %s\n", "mlmeext_sta_add_event_callback23a");
  } else {

  }
#line 5095
  if ((pmlmeinfo->state & 3U) == 1U) {
#line 5097
    if ((pmlmeinfo->state & 16384U) != 0U) {

    } else {
#line 5101
      rtw_correct_TSF(padapter);
#line 5104
      tmp = send_beacon23a(padapter);
#line 5104
      if (tmp != 1) {
#line 5105
        pmlmeinfo->FW_sta_info[psta->mac_id].status = 0U;
#line 5107
        pmlmeinfo->state = pmlmeinfo->state ^ 1U;
#line 5109
        return;
      } else {

      }
#line 5112
      pmlmeinfo->state = pmlmeinfo->state | 16384U;
    }
#line 5114
    hw_var_set_mlme_join(padapter, 2);
  } else {

  }
#line 5117
  pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
#line 5120
  Update_RA_Entry23a(padapter, psta);
#line 5123
  update_sta_info23a(padapter, psta);
#line 5124
  return;
}
}
#line 5126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void mlmeext_sta_del_event_callback23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 5128
  pmlmeext = & padapter->mlmeextpriv;
#line 5129
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5131
  tmp = is_client_associated_to_ap23a(padapter);
#line 5131
  if ((int )tmp) {
#line 5131
    goto _L;
  } else {
#line 5131
    tmp___0 = is_IBSS_empty23a(padapter);
#line 5131
    if ((int )tmp___0) {
      _L: /* CIL Label */ 
#line 5135
      hw_var_set_mlme_disconnect(padapter);
#line 5136
      hw_var_set_bssid(padapter, (u8 *)(& null_addr));
#line 5139
      update_tx_basic_rate23a(padapter, (int )padapter->registrypriv.wireless_mode);
#line 5143
      pmlmeext->cur_bwmode = 0U;
#line 5144
      pmlmeext->cur_ch_offset = 0U;
#line 5146
      set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                            (int )pmlmeext->cur_bwmode);
#line 5150
      flush_all_cam_entry23a(padapter);
#line 5152
      pmlmeinfo->state = 0U;
#line 5155
      rtl8723a_set_media_status(padapter, 2);
#line 5157
      ldv_del_timer_sync_114(& pmlmeext->link_timer);
    } else {

    }
  }
#line 5159
  return;
}
}
#line 5161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static u8 chk_ap_is_alive(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 ret ;

  {
#line 5163
  ret = 0U;
#line 5165
  if ((psta->sta_stats.rx_data_pkts == psta->sta_stats.last_rx_data_pkts && psta->sta_stats.rx_beacon_pkts == psta->sta_stats.last_rx_beacon_pkts) && psta->sta_stats.rx_probersp_pkts == psta->sta_stats.last_rx_probersp_pkts) {
#line 5168
    ret = 0U;
  } else {
#line 5170
    ret = 1U;
  }
#line 5172
  psta->sta_stats.last_rx_mgnt_pkts = psta->sta_stats.rx_mgnt_pkts;
#line 5172
  psta->sta_stats.last_rx_beacon_pkts = psta->sta_stats.rx_beacon_pkts;
#line 5172
  psta->sta_stats.last_rx_probereq_pkts = psta->sta_stats.rx_probereq_pkts;
#line 5172
  psta->sta_stats.last_rx_probersp_pkts = psta->sta_stats.rx_probersp_pkts;
#line 5172
  psta->sta_stats.last_rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts;
#line 5172
  psta->sta_stats.last_rx_probersp_uo_pkts = psta->sta_stats.rx_probersp_uo_pkts;
#line 5172
  psta->sta_stats.last_rx_ctrl_pkts = psta->sta_stats.rx_ctrl_pkts;
#line 5172
  psta->sta_stats.last_rx_data_pkts = psta->sta_stats.rx_data_pkts;
#line 5173
  return (ret);
}
}
#line 5176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void linked_status_chk23a(struct rtw_adapter *padapter ) 
{ 
  u32 i ;
  struct sta_info *psta ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sta_priv *pstapriv ;
  int tx_chk ;
  int rx_chk ;
  int rx_chk_limit ;
  bool is_p2p_enable ;
  u8 tmp ;
  u8 backup_oper_channel ;
  u8 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
#line 5180
  pxmitpriv = & padapter->xmitpriv;
#line 5181
  pmlmeext = & padapter->mlmeextpriv;
#line 5182
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5183
  pstapriv = & padapter->stapriv;
#line 5185
  tmp___4 = is_client_associated_to_ap23a(padapter);
#line 5185
  if ((int )tmp___4) {
#line 5188
    tx_chk = 1;
#line 5188
    rx_chk = 1;
#line 5191
    rx_chk_limit = 4;
#line 5193
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pmlmeinfo->network.MacAddress));
#line 5195
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 5196
      is_p2p_enable = 0;
#line 5198
      tmp = chk_ap_is_alive(padapter, psta);
#line 5198
      if ((unsigned int )tmp == 0U) {
#line 5199
        rx_chk = 0;
      } else {

      }
#line 5201
      if (pxmitpriv->last_tx_pkts == pxmitpriv->tx_pkts) {
#line 5202
        tx_chk = 0;
      } else {

      }
#line 5204
      if ((unsigned int )pmlmeext->active_keep_alive_check != 0U && (rx_chk == 0 || tx_chk == 0)) {
#line 5206
        backup_oper_channel = 0U;
#line 5210
        tmp___0 = rtw_get_oper_ch23a(padapter);
#line 5210
        if ((int )tmp___0 != (int )pmlmeext->cur_channel) {
#line 5212
          backup_oper_channel = rtw_get_oper_ch23a(padapter);
#line 5214
          SelectChannel23a(padapter, (int )pmlmeext->cur_channel);
        } else {

        }
#line 5218
        if (rx_chk != 1) {
#line 5219
          issue_probereq_ex(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& psta->hwaddr),
                            3, 1);
        } else {

        }
#line 5221
        if (tx_chk != 1) {
#line 5221
          tmp___1 = pmlmeinfo->link_count;
#line 5221
          pmlmeinfo->link_count = pmlmeinfo->link_count + 1U;
#line 5221
          if (tmp___1 == 15U) {
#line 5221
            goto _L;
          } else {
#line 5221
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 5221
        if (rx_chk != 1) {
          _L: /* CIL Label */ 
#line 5224
          tx_chk = issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr),
                                     0U, 3, 1);
#line 5230
          if (tx_chk == 1 && ! is_p2p_enable) {
#line 5232
            rx_chk = 1;
          } else {

          }
        } else {

        }
#line 5236
        if ((unsigned int )backup_oper_channel != 0U) {
#line 5237
          SelectChannel23a(padapter, (int )backup_oper_channel);
        } else {

        }
      } else {
#line 5240
        if (rx_chk != 1) {
#line 5241
          if (pmlmeext->retry == 0U) {
#line 5242
            issue_probereq(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& pmlmeinfo->network.MacAddress));
#line 5243
            issue_probereq(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& pmlmeinfo->network.MacAddress));
#line 5244
            issue_probereq(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& pmlmeinfo->network.MacAddress));
          } else {

          }
        } else {

        }
#line 5248
        if (tx_chk != 1) {
#line 5248
          tmp___2 = pmlmeinfo->link_count;
#line 5248
          pmlmeinfo->link_count = pmlmeinfo->link_count + 1U;
#line 5248
          if (tmp___2 == 15U) {
#line 5250
            tx_chk = issue_nulldata23a(padapter, (unsigned char *)0U, 0U, 1, 0);
          } else {

          }
        } else {

        }
      }
#line 5255
      if (rx_chk == 0) {
#line 5256
        pmlmeext->retry = pmlmeext->retry + 1U;
#line 5257
        if (pmlmeext->retry > (u32 )rx_chk_limit) {
#line 5258
          if (GlobalDebugLevel23A != 0U) {
#line 5258
            printk("\016RTL8723AU: %s(%s): disconnect or roaming\n", "linked_status_chk23a",
                   (char *)(& (padapter->pnetdev)->name));
          } else {

          }
#line 5262
          receive_disconnect23a(padapter, (unsigned char *)(& pmlmeinfo->network.MacAddress),
                                65535);
#line 5264
          return;
        } else {

        }
      } else {
#line 5267
        pmlmeext->retry = 0U;
      }
#line 5269
      if (tx_chk == 0) {
#line 5270
        pmlmeinfo->link_count = pmlmeinfo->link_count & 15U;
      } else {
#line 5272
        pxmitpriv->last_tx_pkts = pxmitpriv->tx_pkts;
#line 5273
        pmlmeinfo->link_count = 0U;
      }
    } else {

    }
  } else {
#line 5277
    tmp___3 = is_client_associated_to_ibss23a(padapter);
#line 5277
    if ((int )tmp___3) {
#line 5280
      i = 2U;
#line 5280
      goto ldv_57010;
      ldv_57009: ;
#line 5281
      if (pmlmeinfo->FW_sta_info[i].status == 1U) {
#line 5282
        psta = pmlmeinfo->FW_sta_info[i].psta;
#line 5284
        if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 5285
          goto ldv_57008;
        } else {

        }
#line 5287
        if ((u64 )pmlmeinfo->FW_sta_info[i].rx_pkt == (psta->sta_stats.rx_mgnt_pkts + psta->sta_stats.rx_ctrl_pkts) + psta->sta_stats.rx_data_pkts) {
#line 5290
          if (pmlmeinfo->FW_sta_info[i].retry <= 2U) {
#line 5291
            pmlmeinfo->FW_sta_info[i].retry = pmlmeinfo->FW_sta_info[i].retry + 1U;
          } else {
#line 5293
            pmlmeinfo->FW_sta_info[i].retry = 0U;
#line 5294
            pmlmeinfo->FW_sta_info[i].status = 0U;
#line 5295
            report_del_sta_event23a(padapter, (unsigned char *)(& psta->hwaddr), 65535);
          }
        } else {
#line 5300
          pmlmeinfo->FW_sta_info[i].retry = 0U;
#line 5301
          pmlmeinfo->FW_sta_info[i].rx_pkt = ((unsigned int )psta->sta_stats.rx_mgnt_pkts + (unsigned int )psta->sta_stats.rx_ctrl_pkts) + (unsigned int )psta->sta_stats.rx_data_pkts;
        }
      } else {

      }
      ldv_57008: 
#line 5280
      i = i + 1U;
      ldv_57010: ;
#line 5280
      if (i <= 31U) {
#line 5282
        goto ldv_57009;
      } else {

      }

    } else {

    }
  }
#line 5288
  return;
}
}
#line 5309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void survey_timer_hdl(unsigned long data ) 
{ 
  struct rtw_adapter *padapter ;
  struct cmd_obj *ph2c ;
  struct sitesurvey_parm *psurveyPara ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_ext_priv *pmlmeext ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 5311
  padapter = (struct rtw_adapter *)data;
#line 5314
  pcmdpriv = & padapter->cmdpriv;
#line 5315
  pmlmeext = & padapter->mlmeextpriv;
#line 5318
  if (pmlmeext->sitesurvey_res.state > 1) {
#line 5319
    if (pmlmeext->sitesurvey_res.state == 3) {
#line 5320
      pmlmeext->sitesurvey_res.channel_idx = pmlmeext->sitesurvey_res.channel_idx + 1;
    } else {

    }
#line 5322
    if ((unsigned int )pmlmeext->scan_abort == 1U) {
#line 5323
      pmlmeext->sitesurvey_res.channel_idx = (int )pmlmeext->sitesurvey_res.ch_num;
#line 5325
      if (GlobalDebugLevel23A > 3U) {
#line 5325
        printk("\016RTL8723AU: %s idx:%d\n", "survey_timer_hdl", pmlmeext->sitesurvey_res.channel_idx);
      } else {

      }
#line 5328
      pmlmeext->scan_abort = 0U;
    } else {

    }
#line 5331
    tmp = kzalloc(128UL, 32U);
#line 5331
    ph2c = (struct cmd_obj *)tmp;
#line 5332
    if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 5333
      goto exit_survey_timer_hdl;
    } else {

    }
#line 5335
    tmp___0 = kzalloc(712UL, 32U);
#line 5335
    psurveyPara = (struct sitesurvey_parm *)tmp___0;
#line 5337
    if ((unsigned long )psurveyPara == (unsigned long )((struct sitesurvey_parm *)0)) {
#line 5338
      kfree((void const   *)ph2c);
#line 5339
      goto exit_survey_timer_hdl;
    } else {

    }
#line 5342
    ph2c->cmdcode = 18U;
#line 5342
    ph2c->parmbuf = (u8 *)psurveyPara;
#line 5342
    ph2c->cmdsz = 712U;
#line 5342
    ph2c->rsp = (u8 *)0U;
#line 5342
    ph2c->rspsz = 0U;
#line 5344
    rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  } else {

  }
  exit_survey_timer_hdl: ;
#line 5348
  return;
}
}
#line 5351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void link_timer_hdl(unsigned long data ) 
{ 
  struct rtw_adapter *padapter ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 5353
  padapter = (struct rtw_adapter *)data;
#line 5357
  pmlmeext = & padapter->mlmeextpriv;
#line 5358
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5361
  if ((pmlmeinfo->state & 256U) != 0U) {
#line 5362
    if (GlobalDebugLevel23A > 3U) {
#line 5362
      printk("\016RTL8723AU: link_timer_hdl:no beacon while connecting\n");
    } else {

    }
#line 5363
    pmlmeinfo->state = 0U;
#line 5364
    report_join_res23a(padapter, -3);
  } else
#line 5365
  if ((pmlmeinfo->state & 512U) != 0U) {
#line 5367
    pmlmeinfo->reauth_count = pmlmeinfo->reauth_count + 1U;
#line 5367
    if (pmlmeinfo->reauth_count > 4U) {
#line 5370
      pmlmeinfo->state = 0U;
#line 5371
      report_join_res23a(padapter, -1);
#line 5372
      return;
    } else {

    }
#line 5381
    if (GlobalDebugLevel23A > 3U) {
#line 5381
      printk("\016RTL8723AU: link_timer_hdl: auth timeout and try again\n");
    } else {

    }
#line 5382
    pmlmeinfo->auth_seq = 1U;
#line 5383
    issue_auth(padapter, (struct sta_info *)0, 0);
#line 5384
    tmp = msecs_to_jiffies(300U);
#line 5384
    ldv_mod_timer_115(& pmlmeext->link_timer, tmp + (unsigned long )jiffies);
  } else
#line 5385
  if ((pmlmeinfo->state & 8192U) != 0U) {
#line 5387
    pmlmeinfo->reassoc_count = pmlmeinfo->reassoc_count + 1U;
#line 5387
    if (pmlmeinfo->reassoc_count > 4U) {
#line 5388
      pmlmeinfo->state = 0U;
#line 5389
      report_join_res23a(padapter, -2);
#line 5390
      return;
    } else {

    }
#line 5393
    if (GlobalDebugLevel23A > 3U) {
#line 5393
      printk("\016RTL8723AU: link_timer_hdl: assoc timeout and try again\n");
    } else {

    }
#line 5394
    issue_assocreq(padapter);
#line 5395
    tmp___0 = msecs_to_jiffies(300U);
#line 5395
    ldv_mod_timer_116(& pmlmeext->link_timer, tmp___0 + (unsigned long )jiffies);
  } else {

  }
#line 5398
  return;
}
}
#line 5401 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static void addba_timer_hdl(unsigned long data ) 
{ 
  struct sta_info *psta ;
  struct ht_priv *phtpriv ;

  {
#line 5403
  psta = (struct sta_info *)data;
#line 5406
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 5407
    return;
  } else {

  }
#line 5409
  phtpriv = & psta->htpriv;
#line 5411
  if ((int )phtpriv->ht_option && (int )phtpriv->ampdu_enable) {
#line 5412
    if ((unsigned int )phtpriv->candidate_tid_bitmap != 0U) {
#line 5413
      phtpriv->candidate_tid_bitmap = 0U;
    } else {

    }
  } else {

  }
#line 5414
  return;
}
}
#line 5417 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void init_addba_retry_timer23a(struct sta_info *psta ) 
{ 


  {
#line 5419
  reg_timer_11(& psta->addba_retry_timer, & addba_timer_hdl, (unsigned long )psta);
#line 5420
  return;
}
}
#line 5423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
void init_mlme_ext_timer23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
#line 5425
  pmlmeext = & padapter->mlmeextpriv;
#line 5427
  reg_timer_11(& pmlmeext->survey_timer, & survey_timer_hdl, (unsigned long )padapter);
#line 5430
  reg_timer_11(& pmlmeext->link_timer, & link_timer_hdl, (unsigned long )padapter);
#line 5431
  return;
}
}
#line 5434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int NULL_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 


  {
#line 5436
  return (0);
}
}
#line 5439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int setopmode_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  enum nl80211_iftype type ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct setopmode_parm  const  *psetop ;

  {
#line 5442
  pmlmeext = & padapter->mlmeextpriv;
#line 5443
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5444
  psetop = (struct setopmode_parm  const  *)pbuf;
#line 5446
  switch ((unsigned int )psetop->mode) {
  case 9U: ;
  case 3U: 
#line 5449
  pmlmeinfo->state = 3U;
#line 5450
  type = 3;
#line 5451
  goto ldv_57054;
  case 8U: ;
  case 2U: 
#line 5455
  pmlmeinfo->state = pmlmeinfo->state & 4294967292U;
#line 5457
  pmlmeinfo->state = pmlmeinfo->state | 2U;
#line 5458
  type = 2;
#line 5459
  goto ldv_57054;
  case 1U: 
#line 5461
  type = 1;
#line 5462
  goto ldv_57054;
  default: 
#line 5464
  type = 0;
#line 5465
  goto ldv_57054;
  }
  ldv_57054: 
#line 5468
  hw_var_set_opmode(padapter, (int )((u8 )type));
#line 5471
  return (0);
}
}
#line 5474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int createbss_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  struct wlan_bssid_ex  const  *pparm ;

  {
#line 5476
  pmlmeext = & padapter->mlmeextpriv;
#line 5477
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5478
  pnetwork = & pmlmeinfo->network;
#line 5479
  pparm = (struct wlan_bssid_ex  const  *)pbuf;
#line 5482
  if ((unsigned int )pparm->ifmode == 3U || (unsigned int )pparm->ifmode == 9U) {
#line 5485
    if (pmlmeinfo->state == 3U) {
#line 5487
      return (0);
    } else {

    }
  } else {

  }
#line 5493
  if ((unsigned int )pparm->ifmode == 1U) {
#line 5494
    rtw_joinbss_reset23a(padapter);
#line 5496
    pmlmeext->cur_bwmode = 0U;
#line 5497
    pmlmeext->cur_ch_offset = 0U;
#line 5498
    pmlmeinfo->ERP_enable = 0U;
#line 5499
    pmlmeinfo->WMM_enable = 0U;
#line 5500
    pmlmeinfo->HT_enable = 0U;
#line 5501
    pmlmeinfo->HT_caps_enable = 0U;
#line 5502
    pmlmeinfo->HT_info_enable = 0U;
#line 5505
    rtl8723a_odm_support_ability_backup(padapter);
#line 5507
    rtl8723a_odm_support_ability_clr(padapter, 0U);
#line 5511
    ldv_del_timer_sync_117(& pmlmeext->link_timer);
#line 5514
    flush_all_cam_entry23a(padapter);
#line 5516
    if ((unsigned int )pparm->IELength > 768U) {
#line 5517
      return (4);
    } else {

    }
#line 5519
    memcpy((void *)pnetwork, (void const   *)pparm, 871UL);
#line 5521
    start_create_ibss(padapter);
  } else {

  }
#line 5524
  return (0);
}
}
#line 5527 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int join_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct registry_priv *pregpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  struct wlan_bssid_ex  const  *pparm ;
  struct ieee80211_ht_operation *pht_info ;
  u32 i ;
  u8 *p ;
  int tmp ;

  {
#line 5529
  pregpriv = & padapter->registrypriv;
#line 5530
  pmlmeext = & padapter->mlmeextpriv;
#line 5531
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5532
  pnetwork = & pmlmeinfo->network;
#line 5533
  pparm = (struct wlan_bssid_ex  const  *)pbuf;
#line 5541
  if ((pmlmeinfo->state & 16384U) != 0U) {
#line 5542
    if ((pmlmeinfo->state & 2U) != 0U) {
#line 5543
      issue_deauth_ex(padapter, (u8 *)(& pnetwork->MacAddress), 3, 5, 100);
    } else {

    }
#line 5546
    pmlmeinfo->state = 0U;
#line 5549
    flush_all_cam_entry23a(padapter);
#line 5551
    ldv_del_timer_sync_118(& pmlmeext->link_timer);
#line 5554
    rtl8723a_set_media_status(padapter, 2);
#line 5556
    hw_var_set_mlme_disconnect(padapter);
  } else {

  }
#line 5559
  rtw_joinbss_reset23a(padapter);
#line 5561
  pmlmeext->cur_bwmode = 0U;
#line 5562
  pmlmeext->cur_ch_offset = 0U;
#line 5563
  pmlmeinfo->ERP_enable = 0U;
#line 5564
  pmlmeinfo->WMM_enable = 0U;
#line 5565
  pmlmeinfo->HT_enable = 0U;
#line 5566
  pmlmeinfo->HT_caps_enable = 0U;
#line 5567
  pmlmeinfo->HT_info_enable = 0U;
#line 5568
  pmlmeinfo->bwmode_updated = 0U;
#line 5571
  if ((unsigned int )pparm->IELength > 768U) {
#line 5572
    return (4);
  } else {

  }
#line 5574
  memcpy((void *)pnetwork, (void const   *)pbuf, 871UL);
#line 5580
  i = 0U;
#line 5580
  goto ldv_57089;
  ldv_57088: 
#line 5581
  p = (u8 *)(& pnetwork->IEs) + (unsigned long )i;
#line 5583
  switch ((int )*p) {
  case 221: 
#line 5585
  tmp = memcmp((void const   *)p + 2U, (void const   *)(& WMM_OUI23A), 4UL);
#line 5585
  if (tmp == 0) {
#line 5586
    pmlmeinfo->WMM_enable = 1U;
  } else {

  }
#line 5587
  goto ldv_57080;
  case 45: 
#line 5590
  pmlmeinfo->HT_caps_enable = 1U;
#line 5591
  goto ldv_57080;
  case 61: 
#line 5594
  pmlmeinfo->HT_info_enable = 1U;
#line 5598
  pht_info = (struct ieee80211_ht_operation *)p + 2U;
#line 5600
  if ((unsigned int )pregpriv->cbw40_enable != 0U && ((int )pht_info->ht_param & 4) != 0) {
#line 5604
    pmlmeext->cur_bwmode = 1U;
#line 5605
    switch ((int )pht_info->ht_param & 3) {
    case 1: 
#line 5608
    pmlmeext->cur_ch_offset = 1U;
#line 5610
    goto ldv_57084;
    case 3: 
#line 5613
    pmlmeext->cur_ch_offset = 2U;
#line 5615
    goto ldv_57084;
    default: 
#line 5618
    pmlmeext->cur_ch_offset = 0U;
#line 5620
    goto ldv_57084;
    }
    ldv_57084: ;
#line 5623
    if (GlobalDebugLevel23A > 3U) {
#line 5623
      printk("\016RTL8723AU: set ch/bw before connected\n");
    } else {

    }
  } else {

  }
#line 5625
  goto ldv_57080;
  default: ;
#line 5628
  goto ldv_57080;
  }
  ldv_57080: 
#line 5631
  i = ((u32 )*(p + 1UL) + i) + 2U;
  ldv_57089: ;
#line 5580
  if (pnetwork->IELength > i) {
#line 5582
    goto ldv_57088;
  } else {

  }
#line 5634
  hw_var_set_bssid(padapter, (u8 *)(& pmlmeinfo->network.MacAddress));
#line 5635
  hw_var_set_mlme_join(padapter, 0);
#line 5638
  ldv_del_timer_sync_119(& pmlmeext->link_timer);
#line 5640
  start_clnt_join(padapter);
#line 5642
  return (0);
}
}
#line 5645 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int disconnect_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct disconnect_parm  const  *param ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  bool tmp ;

  {
#line 5647
  param = (struct disconnect_parm  const  *)pbuf;
#line 5648
  pmlmeext = & padapter->mlmeextpriv;
#line 5649
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5650
  pnetwork = & pmlmeinfo->network;
#line 5652
  tmp = is_client_associated_to_ap23a(padapter);
#line 5652
  if ((int )tmp) {
#line 5653
    issue_deauth_ex(padapter, (u8 *)(& pnetwork->MacAddress), 3, (int )((unsigned int )param->deauth_timeout_ms / 100U),
                    100);
  } else {

  }
#line 5662
  hw_var_set_mlme_disconnect(padapter);
#line 5663
  hw_var_set_bssid(padapter, (u8 *)(& null_addr));
#line 5666
  update_tx_basic_rate23a(padapter, (int )padapter->registrypriv.wireless_mode);
#line 5668
  if ((pmlmeinfo->state & 3U) == 1U || (pmlmeinfo->state & 3U) == 3U) {
#line 5670
    rtl8723a_set_bcn_func(padapter, 0);
  } else {

  }
#line 5673
  rtl8723a_set_media_status(padapter, 2);
#line 5675
  pmlmeinfo->state = 0U;
#line 5678
  pmlmeext->cur_bwmode = 0U;
#line 5679
  pmlmeext->cur_ch_offset = 0U;
#line 5681
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
#line 5684
  flush_all_cam_entry23a(padapter);
#line 5686
  ldv_del_timer_sync_120(& pmlmeext->link_timer);
#line 5688
  rtw_free_uc_swdec_pending_queue23a(padapter);
#line 5690
  return (0);
}
}
#line 5694 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
static int rtw_scan_ch_decision(struct rtw_adapter *padapter , struct rtw_ieee80211_channel *out ,
                                u32 out_num , struct rtw_ieee80211_channel  const  *in ,
                                u32 in_num ) 
{ 
  int i ;
  int j ;
  int scan_ch_num ;
  int set_idx ;
  struct mlme_ext_priv *pmlmeext ;
  int tmp ;

  {
#line 5699
  scan_ch_num = 0;
#line 5701
  pmlmeext = & padapter->mlmeextpriv;
#line 5704
  memset((void *)out, 0, (unsigned long )out_num * 8UL);
#line 5707
  j = 0;
#line 5708
  i = 0;
#line 5708
  goto ldv_57113;
  ldv_57112: ;
#line 5709
  if ((unsigned int )((unsigned short )(in + (unsigned long )i)->hw_value) != 0U && ((unsigned int )(in + (unsigned long )i)->flags & 1U) == 0U) {
#line 5709
    set_idx = rtw_ch_set_search_ch23a((struct rt_channel_info *)(& pmlmeext->channel_set),
                                      (u32 const   )(in + (unsigned long )i)->hw_value);
#line 5709
    if (set_idx >= 0) {
#line 5713
      memcpy((void *)out + (unsigned long )j, (void const   *)in + (unsigned long )i,
               8UL);
#line 5716
      if ((unsigned int )pmlmeext->channel_set[set_idx].ScanType == 0U) {
#line 5718
        (out + (unsigned long )j)->flags = (out + (unsigned long )j)->flags & 2U;
      } else {

      }
#line 5720
      j = j + 1;
    } else {

    }
  } else {

  }
#line 5722
  if ((u32 )j >= out_num) {
#line 5723
    goto ldv_57111;
  } else {

  }
#line 5708
  i = i + 1;
  ldv_57113: ;
#line 5708
  if ((u32 )i < in_num) {
#line 5710
    goto ldv_57112;
  } else {

  }
  ldv_57111: ;
#line 5727
  if (j == 0) {
#line 5728
    i = 0;
#line 5728
    goto ldv_57115;
    ldv_57114: 
#line 5729
    (out + (unsigned long )i)->hw_value = (u16 )pmlmeext->channel_set[i].ChannelNum;
#line 5731
    if ((unsigned int )pmlmeext->channel_set[i].ScanType == 0U) {
#line 5732
      (out + (unsigned long )i)->flags = (out + (unsigned long )i)->flags & 2U;
    } else {

    }
#line 5734
    j = j + 1;
#line 5728
    i = i + 1;
    ldv_57115: ;
#line 5728
    if ((int )pmlmeext->max_chan_nums > i) {
#line 5730
      goto ldv_57114;
    } else {

    }

  } else {

  }
#line 5738
  if (padapter->setband == 2U) {
#line 5739
    i = 0;
#line 5739
    goto ldv_57118;
    ldv_57117: ;
#line 5740
    if ((unsigned int )(out + (unsigned long )i)->hw_value > 35U) {
#line 5741
      memset((void *)out + (unsigned long )i, 0, 8UL);
    } else {
#line 5744
      scan_ch_num = scan_ch_num + 1;
    }
#line 5739
    i = i + 1;
    ldv_57118: ;
#line 5739
    if (i < j) {
#line 5741
      goto ldv_57117;
    } else {

    }
#line 5746
    j = scan_ch_num;
  } else
#line 5747
  if (padapter->setband == 1U) {
#line 5748
    i = 0;
#line 5748
    goto ldv_57121;
    ldv_57120: ;
#line 5749
    if ((unsigned int )(out + (unsigned long )i)->hw_value > 35U) {
#line 5750
      tmp = scan_ch_num;
#line 5750
      scan_ch_num = scan_ch_num + 1;
#line 5750
      memcpy((void *)out + (unsigned long )tmp, (void const   *)out + (unsigned long )i,
               8UL);
    } else {

    }
#line 5748
    i = i + 1;
    ldv_57121: ;
#line 5748
    if (i < j) {
#line 5750
      goto ldv_57120;
    } else {

    }
#line 5754
    j = scan_ch_num;
  } else {

  }
#line 5758
  return (j);
}
}
#line 5761 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int sitesurvey_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct sitesurvey_parm  const  *pparm ;
  u8 bdelayscan ;
  u32 initialgain ;
  u32 i ;
  int tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  unsigned long tmp___2 ;
  void *tmp___3 ;

  {
#line 5763
  pmlmeext = & padapter->mlmeextpriv;
#line 5764
  pparm = (struct sitesurvey_parm  const  *)pbuf;
#line 5765
  bdelayscan = 0U;
#line 5769
  if (pmlmeext->sitesurvey_res.state == 0) {
#line 5770
    pmlmeext->sitesurvey_res.state = 1;
#line 5771
    pmlmeext->sitesurvey_res.bss_cnt = 0;
#line 5772
    pmlmeext->sitesurvey_res.channel_idx = 0;
#line 5774
    i = 0U;
#line 5774
    goto ldv_57133;
    ldv_57132: ;
#line 5775
    if ((unsigned int )((unsigned char )pparm->ssid[i].ssid_len) != 0U) {
#line 5776
      memcpy((void *)(& pmlmeext->sitesurvey_res.ssid[i].ssid), (void const   *)(& pparm->ssid[i].ssid),
               32UL);
#line 5779
      pmlmeext->sitesurvey_res.ssid[i].ssid_len = pparm->ssid[i].ssid_len;
    } else {
#line 5782
      pmlmeext->sitesurvey_res.ssid[i].ssid_len = 0U;
    }
#line 5774
    i = i + 1U;
    ldv_57133: ;
#line 5774
    if (i <= 8U) {
#line 5776
      goto ldv_57132;
    } else {

    }
#line 5786
    tmp = rtw_scan_ch_decision(padapter, (struct rtw_ieee80211_channel *)(& pmlmeext->sitesurvey_res.ch),
                               51U, (struct rtw_ieee80211_channel  const  *)(& pparm->ch),
                               (u32 )pparm->ch_num);
#line 5786
    pmlmeext->sitesurvey_res.ch_num = (u8 )tmp;
#line 5792
    pmlmeext->sitesurvey_res.scan_mode = pparm->scan_mode;
#line 5795
    tmp___1 = is_client_associated_to_ap23a(padapter);
#line 5795
    if ((int )tmp___1) {
#line 5796
      pmlmeext->sitesurvey_res.state = 2;
#line 5800
      tmp___0 = rtw_get_oper_ch23a(padapter);
#line 5800
      if ((int )tmp___0 != (int )pmlmeext->cur_channel) {
#line 5802
        SelectChannel23a(padapter, (int )pmlmeext->cur_channel);
      } else {

      }
#line 5805
      issue_nulldata23a(padapter, (unsigned char *)0U, 1U, 3, 500);
#line 5807
      bdelayscan = 1U;
    } else {

    }
#line 5810
    if ((unsigned int )bdelayscan != 0U) {
#line 5812
      tmp___2 = msecs_to_jiffies(50U);
#line 5812
      ldv_mod_timer_121(& pmlmeext->survey_timer, tmp___2 + (unsigned long )jiffies);
#line 5813
      return (0);
    } else {

    }
  } else {

  }
#line 5817
  if (pmlmeext->sitesurvey_res.state == 1 || pmlmeext->sitesurvey_res.state == 2) {
#line 5820
    rtl8723a_odm_support_ability_backup(padapter);
#line 5821
    rtl8723a_odm_support_ability_clr(padapter, 0U);
#line 5826
    tmp___3 = wdev_priv___0(padapter->rtw_wdev);
#line 5826
    if ((unsigned int )((struct rtw_wdev_priv *)tmp___3)->p2p_enabled == 1U) {
#line 5827
      initialgain = 48U;
    } else {
#line 5829
      initialgain = 30U;
    }
#line 5831
    rtl8723a_set_initial_gain(padapter, initialgain);
#line 5834
    rtl8723a_set_media_status(padapter, 0);
#line 5836
    rtl8723a_mlme_sitesurvey(padapter, 1);
#line 5838
    pmlmeext->sitesurvey_res.state = 3;
  } else {

  }
#line 5841
  rtw_site_survey(padapter);
#line 5843
  return (0);
}
}
#line 5846 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int setauth_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct setauth_parm  const  *pparm ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 5848
  pparm = (struct setauth_parm  const  *)pbuf;
#line 5849
  pmlmeext = & padapter->mlmeextpriv;
#line 5850
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5852
  if ((unsigned int )((unsigned char )pparm->mode) <= 3U) {
#line 5853
    pmlmeinfo->auth_algo = (u32 )pparm->mode;
  } else {

  }
#line 5855
  return (0);
}
}
#line 5858 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int setkey_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  unsigned short ctrl ;
  struct setkey_parm  const  *pparm ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned char null_sta[6U] ;

  {
#line 5861
  pparm = (struct setkey_parm  const  *)pbuf;
#line 5862
  pmlmeext = & padapter->mlmeextpriv;
#line 5863
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5864
  null_sta[0] = 0U;
#line 5864
  null_sta[1] = 0U;
#line 5864
  null_sta[2] = 0U;
#line 5864
  null_sta[3] = 0U;
#line 5864
  null_sta[4] = 0U;
#line 5864
  null_sta[5] = 0U;
#line 5867
  if ((unsigned int )((unsigned char )pparm->set_tx) != 0U) {
#line 5868
    pmlmeinfo->key_index = (u32 )pparm->keyid;
  } else {

  }
#line 5871
  ctrl = (unsigned int )(((int )((unsigned short )pparm->algorithm) << 2U) | (int )((unsigned short )pparm->keyid)) | 32768U;
#line 5873
  if (GlobalDebugLevel23A != 0U) {
#line 5873
    printk("\016RTL8723AU: set group key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) keyid:%d\n",
           pparm->algorithm, (int )pparm->keyid);
  } else {

  }
#line 5876
  rtl8723a_cam_write(padapter, (int )pparm->keyid, (int )ctrl, (u8 const   *)(& null_sta),
                     (u8 const   *)(& pparm->key));
#line 5879
  rtl8723a_on_rcr_am(padapter);
#line 5881
  return (0);
}
}
#line 5884 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int set_stakey_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  u16 ctrl ;
  u8 cam_id ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct set_stakey_parm  const  *pparm ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;

  {
#line 5886
  ctrl = 0U;
#line 5888
  pmlmeext = & padapter->mlmeextpriv;
#line 5889
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5890
  pparm = (struct set_stakey_parm  const  *)pbuf;
#line 5905
  cam_id = 4U;
#line 5907
  if (GlobalDebugLevel23A != 0U) {
#line 5907
    printk("\016RTL8723AU: set pairwise key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) camid:%d\n",
           pparm->algorithm, (int )cam_id);
  } else {

  }
#line 5910
  if ((pmlmeinfo->state & 3U) == 3U) {
#line 5912
    pstapriv = & padapter->stapriv;
#line 5914
    if ((unsigned int )pparm->algorithm == 0U) {
#line 5915
      clear_cam_entry23a(padapter, (int )pparm->id);
#line 5916
      return (1);
    } else {

    }
#line 5919
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pparm->addr));
#line 5920
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 5921
      ctrl = (unsigned int )((int )((u16 )pparm->algorithm) << 2U) | 32768U;
#line 5923
      if (GlobalDebugLevel23A > 3U) {
#line 5923
        printk("\016RTL8723AU: r871x_set_stakey_hdl23a(): enc_algorithm =%d\n", pparm->algorithm);
      } else {

      }
#line 5926
      if (psta->mac_id == 0U || psta->mac_id > 28U) {
#line 5927
        if (GlobalDebugLevel23A > 3U) {
#line 5927
          printk("\016RTL8723AU: r871x_set_stakey_hdl23a():set_stakey failed, mac_id(aid) =%d\n",
                 psta->mac_id);
        } else {

        }
#line 5930
        return (5);
      } else {

      }
#line 5935
      cam_id = (unsigned int )((u8 )psta->mac_id) + 3U;
#line 5937
      if (GlobalDebugLevel23A > 3U) {
#line 5937
        printk("\016RTL8723AU: Write CAM, mac_addr =%x:%x:%x:%x:%x:%x, cam_entry =%d\n",
               (int )pparm->addr[0], (int )pparm->addr[1], (int )pparm->addr[2], (int )pparm->addr[3],
               (int )pparm->addr[4], (int )pparm->addr[5], (int )cam_id);
      } else {

      }
#line 5943
      rtl8723a_cam_write(padapter, (int )cam_id, (int )ctrl, (u8 const   *)(& pparm->addr),
                         (u8 const   *)(& pparm->key));
#line 5946
      return (1);
    } else {
#line 5948
      if (GlobalDebugLevel23A > 3U) {
#line 5948
        printk("\016RTL8723AU: r871x_set_stakey_hdl23a(): sta has been free\n");
      } else {

      }
#line 5950
      return (5);
    }
  } else {

  }
#line 5956
  if ((unsigned int )pparm->algorithm == 0U) {
#line 5957
    clear_cam_entry23a(padapter, (int )pparm->id);
#line 5958
    return (0);
  } else {

  }
#line 5961
  ctrl = (unsigned int )((int )((u16 )pparm->algorithm) << 2U) | 32768U;
#line 5963
  rtl8723a_cam_write(padapter, (int )cam_id, (int )ctrl, (u8 const   *)(& pparm->addr),
                     (u8 const   *)(& pparm->key));
#line 5965
  pmlmeinfo->enc_algo = pparm->algorithm;
#line 5967
  return (0);
}
}
#line 5970 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int add_ba_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct addBaReq_parm  const  *pparm ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sta_info *psta ;
  unsigned long tmp ;

  {
#line 5972
  pparm = (struct addBaReq_parm  const  *)pbuf;
#line 5973
  pmlmeext = & padapter->mlmeextpriv;
#line 5974
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5977
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pparm->addr));
#line 5979
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 5980
    return (0);
  } else {

  }
#line 5982
  if (((pmlmeinfo->state & 16384U) != 0U && (unsigned int )pmlmeinfo->HT_enable != 0U) || (pmlmeinfo->state & 3U) == 3U) {
#line 5985
    issue_action_BA23a(padapter, (unsigned char const   *)(& pparm->addr), 0, (int )((unsigned short )pparm->tid));
#line 5987
    tmp = msecs_to_jiffies(2000U);
#line 5987
    ldv_mod_timer_122(& psta->addba_retry_timer, tmp + (unsigned long )jiffies);
  } else {
#line 5990
    psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )pparm->tid)));
  }
#line 5992
  return (0);
}
}
#line 5995 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int set_tx_beacon_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *ph2c ;
  struct Tx_Beacon_param *ptxBeacon_parm ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 res ;
  int len_diff ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 5999
  pcmdpriv = & padapter->cmdpriv;
#line 6000
  pmlmeext = & padapter->mlmeextpriv;
#line 6001
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 6002
  res = 1U;
#line 6003
  len_diff = 0;
#line 6005
  tmp = kzalloc(128UL, 32U);
#line 6005
  ph2c = (struct cmd_obj *)tmp;
#line 6006
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 6007
    res = 0U;
#line 6008
    goto exit;
  } else {

  }
#line 6011
  tmp___0 = kzalloc(871UL, 32U);
#line 6011
  ptxBeacon_parm = (struct Tx_Beacon_param *)tmp___0;
#line 6012
  if ((unsigned long )ptxBeacon_parm == (unsigned long )((struct Tx_Beacon_param *)0)) {
#line 6013
    kfree((void const   *)ph2c);
#line 6014
    res = 0U;
#line 6015
    goto exit;
  } else {

  }
#line 6018
  memcpy((void *)(& ptxBeacon_parm->network), (void const   *)(& pmlmeinfo->network),
           871UL);
#line 6021
  len_diff = update_hidden_ssid((u8 *)(& ptxBeacon_parm->network.IEs), ptxBeacon_parm->network.IELength,
                                (int )pmlmeinfo->hidden_ssid_mode);
#line 6024
  ptxBeacon_parm->network.IELength = ptxBeacon_parm->network.IELength + (u32 )len_diff;
#line 6026
  ph2c->cmdcode = 55U;
#line 6026
  ph2c->parmbuf = (u8 *)ptxBeacon_parm;
#line 6026
  ph2c->cmdsz = 871U;
#line 6026
  ph2c->rsp = (u8 *)0U;
#line 6026
  ph2c->rspsz = 0U;
#line 6029
  tmp___1 = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
#line 6029
  res = (u8 )tmp___1;
  exit: ;
#line 6032
  return ((int )res);
}
}
#line 6035 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int mlme_evt_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  u8 evt_code ;
  u8 evt_seq ;
  u16 evt_sz ;
  struct C2HEvent_Header  const  *c2h ;
  void (*event_callback)(struct rtw_adapter * , u8 const   * ) ;

  {
#line 6042
  c2h = (struct C2HEvent_Header  const  *)pbuf;
#line 6043
  evt_sz = c2h->len;
#line 6044
  evt_seq = c2h->seq;
#line 6045
  evt_code = c2h->ID;
#line 6048
  if ((unsigned int )evt_code > 24U) {
#line 6049
    if (GlobalDebugLevel23A > 3U) {
#line 6049
      rt_trace(128, 4, "Event Code(%d) mismatch!\n", (int )evt_code);
    } else {

    }
#line 6051
    goto _abort_event_;
  } else {

  }
#line 6055
  if (wlanevents[(int )evt_code].parmsize != 0U && wlanevents[(int )evt_code].parmsize != (u32 )evt_sz) {
#line 6057
    if (GlobalDebugLevel23A > 3U) {
#line 6057
      rt_trace(128, 4, "Event(%d) Parm Size mismatch (%d vs %d)!\n", (int )evt_code,
               wlanevents[(int )evt_code].parmsize, (int )evt_sz);
    } else {

    }
#line 6060
    goto _abort_event_;
  } else {

  }
#line 6063
  event_callback = wlanevents[(int )evt_code].event_callback;
#line 6064
  (*event_callback)(padapter, pbuf + 8UL);
  _abort_event_: ;
#line 6068
  return (0);
}
}
#line 6071 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int h2c_msg_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 


  {
#line 6073
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
#line 6074
    return (4);
  } else {

  }
#line 6076
  return (0);
}
}
#line 6079 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int tx_beacon_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct sta_info *psta_bmc ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct xmit_priv *pxmitpriv ;
  struct sta_priv *pstapriv ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 6081
  tmp = send_beacon23a(padapter);
#line 6081
  if (tmp == 0) {
#line 6082
    if (GlobalDebugLevel23A > 3U) {
#line 6082
      printk("\016RTL8723AU: issue_beacon23a, fail!\n");
    } else {

    }
#line 6083
    return (4);
  } else {
#line 6090
    pxmitpriv = & padapter->xmitpriv;
#line 6091
    pstapriv = & padapter->stapriv;
#line 6094
    psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
#line 6095
    if ((unsigned long )psta_bmc == (unsigned long )((struct sta_info *)0)) {
#line 6096
      return (0);
    } else {

    }
#line 6098
    if ((int )pstapriv->tim_bitmap & 1 && psta_bmc->sleepq_len != 0U) {
#line 6099
      msleep(10U);
#line 6101
      spin_lock_bh(& pxmitpriv->lock);
#line 6103
      phead = get_list_head(& psta_bmc->sleep_q);
#line 6105
      plist = phead->next;
#line 6105
      ptmp = plist->next;
#line 6105
      goto ldv_57211;
      ldv_57210: 
#line 6106
      __mptr = (struct list_head  const  *)plist;
#line 6106
      pxmitframe = (struct xmit_frame *)__mptr;
#line 6110
      list_del_init(& pxmitframe->list);
#line 6112
      psta_bmc->sleepq_len = psta_bmc->sleepq_len - 1U;
#line 6113
      if (psta_bmc->sleepq_len != 0U) {
#line 6114
        pxmitframe->attrib.mdata = 1U;
      } else {
#line 6116
        pxmitframe->attrib.mdata = 0U;
      }
#line 6118
      pxmitframe->attrib.triggered = 1U;
#line 6120
      pxmitframe->attrib.qsel = 17U;
#line 6122
      rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
#line 6105
      plist = ptmp;
#line 6105
      ptmp = plist->next;
      ldv_57211: ;
#line 6105
      if ((unsigned long )plist != (unsigned long )phead) {
#line 6107
        goto ldv_57210;
      } else {

      }
#line 6127
      spin_unlock_bh(& pxmitpriv->lock);
    } else {

    }
  }
#line 6132
  return (0);
}
}
#line 6135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int set_ch_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct set_ch_parm  const  *set_ch_parm ;
  struct mlme_ext_priv *pmlmeext ;

  {
#line 6138
  pmlmeext = & padapter->mlmeextpriv;
#line 6140
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
#line 6141
    return (4);
  } else {

  }
#line 6143
  set_ch_parm = (struct set_ch_parm  const  *)pbuf;
#line 6145
  if (GlobalDebugLevel23A > 3U) {
#line 6145
    printk("\016RTL8723AU: %s(%s): ch:%u, bw:%u, ch_offset:%u\n", "set_ch_hdl23a",
           (char *)(& (padapter->pnetdev)->name), (int )set_ch_parm->ch, (int )set_ch_parm->bw,
           (int )set_ch_parm->ch_offset);
  } else {

  }
#line 6149
  pmlmeext->cur_channel = set_ch_parm->ch;
#line 6150
  pmlmeext->cur_ch_offset = set_ch_parm->ch_offset;
#line 6151
  pmlmeext->cur_bwmode = set_ch_parm->bw;
#line 6153
  set_channel_bwmode23a(padapter, (int )set_ch_parm->ch, (int )set_ch_parm->ch_offset,
                        (int )set_ch_parm->bw);
#line 6156
  return (0);
}
}
#line 6159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int set_chplan_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct SetChannelPlan_param  const  *setChannelPlan_param ;
  struct mlme_ext_priv *pmlmeext ;

  {
#line 6162
  pmlmeext = & padapter->mlmeextpriv;
#line 6164
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
#line 6165
    return (4);
  } else {

  }
#line 6167
  setChannelPlan_param = (struct SetChannelPlan_param  const  *)pbuf;
#line 6169
  pmlmeext->max_chan_nums = init_channel_set(padapter, (int )setChannelPlan_param->channel_plan,
                                             (struct rt_channel_info *)(& pmlmeext->channel_set));
#line 6172
  init_channel_list(padapter, (struct rt_channel_info *)(& pmlmeext->channel_set),
                    (int )pmlmeext->max_chan_nums, & pmlmeext->channel_list);
#line 6175
  return (0);
}
}
#line 6178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int led_blink_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct LedBlink_param *ledBlink_param ;

  {
#line 6182
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
#line 6183
    return (4);
  } else {

  }
#line 6185
  ledBlink_param = (struct LedBlink_param *)pbuf;
#line 6187
  return (0);
}
}
#line 6190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int set_csa_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 


  {
#line 6192
  return (5);
}
}
#line 6211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.c"
int tdls_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 


  {
#line 6213
  return (5);
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void activate_pending_timer_9(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 251
  if ((unsigned long )ldv_timer_list_9_0 == (unsigned long )timer) {
#line 252
    if (ldv_timer_9_0 == 2 || pending_flag != 0) {
#line 253
      ldv_timer_list_9_0 = timer;
#line 254
      ldv_timer_list_9_0->data = data;
#line 255
      ldv_timer_9_0 = 1;
    } else {

    }
#line 257
    return;
  } else {

  }
#line 260
  if ((unsigned long )ldv_timer_list_9_1 == (unsigned long )timer) {
#line 261
    if (ldv_timer_9_1 == 2 || pending_flag != 0) {
#line 262
      ldv_timer_list_9_1 = timer;
#line 263
      ldv_timer_list_9_1->data = data;
#line 264
      ldv_timer_9_1 = 1;
    } else {

    }
#line 266
    return;
  } else {

  }
#line 269
  if ((unsigned long )ldv_timer_list_9_2 == (unsigned long )timer) {
#line 270
    if (ldv_timer_9_2 == 2 || pending_flag != 0) {
#line 271
      ldv_timer_list_9_2 = timer;
#line 272
      ldv_timer_list_9_2->data = data;
#line 273
      ldv_timer_9_2 = 1;
    } else {

    }
#line 275
    return;
  } else {

  }
#line 278
  if ((unsigned long )ldv_timer_list_9_3 == (unsigned long )timer) {
#line 279
    if (ldv_timer_9_3 == 2 || pending_flag != 0) {
#line 280
      ldv_timer_list_9_3 = timer;
#line 281
      ldv_timer_list_9_3->data = data;
#line 282
      ldv_timer_9_3 = 1;
    } else {

    }
#line 284
    return;
  } else {

  }
#line 286
  activate_suitable_timer_9(timer, data);
#line 287
  return;
}
}
#line 290 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void disable_suitable_timer_8(struct timer_list *timer ) 
{ 


  {
#line 291
  if (ldv_timer_8_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_0) {
#line 292
    ldv_timer_8_0 = 0;
#line 293
    return;
  } else {

  }
#line 295
  if (ldv_timer_8_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_1) {
#line 296
    ldv_timer_8_1 = 0;
#line 297
    return;
  } else {

  }
#line 299
  if (ldv_timer_8_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_2) {
#line 300
    ldv_timer_8_2 = 0;
#line 301
    return;
  } else {

  }
#line 303
  if (ldv_timer_8_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_3) {
#line 304
    ldv_timer_8_3 = 0;
#line 305
    return;
  } else {

  }
#line 307
  return;
}
}
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void activate_pending_timer_10(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 312
  if ((unsigned long )ldv_timer_list_10_0 == (unsigned long )timer) {
#line 313
    if (ldv_timer_10_0 == 2 || pending_flag != 0) {
#line 314
      ldv_timer_list_10_0 = timer;
#line 315
      ldv_timer_list_10_0->data = data;
#line 316
      ldv_timer_10_0 = 1;
    } else {

    }
#line 318
    return;
  } else {

  }
#line 321
  if ((unsigned long )ldv_timer_list_10_1 == (unsigned long )timer) {
#line 322
    if (ldv_timer_10_1 == 2 || pending_flag != 0) {
#line 323
      ldv_timer_list_10_1 = timer;
#line 324
      ldv_timer_list_10_1->data = data;
#line 325
      ldv_timer_10_1 = 1;
    } else {

    }
#line 327
    return;
  } else {

  }
#line 330
  if ((unsigned long )ldv_timer_list_10_2 == (unsigned long )timer) {
#line 331
    if (ldv_timer_10_2 == 2 || pending_flag != 0) {
#line 332
      ldv_timer_list_10_2 = timer;
#line 333
      ldv_timer_list_10_2->data = data;
#line 334
      ldv_timer_10_2 = 1;
    } else {

    }
#line 336
    return;
  } else {

  }
#line 339
  if ((unsigned long )ldv_timer_list_10_3 == (unsigned long )timer) {
#line 340
    if (ldv_timer_10_3 == 2 || pending_flag != 0) {
#line 341
      ldv_timer_list_10_3 = timer;
#line 342
      ldv_timer_list_10_3->data = data;
#line 343
      ldv_timer_10_3 = 1;
    } else {

    }
#line 345
    return;
  } else {

  }
#line 347
  activate_suitable_timer_10(timer, data);
#line 348
  return;
}
}
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int reg_timer_10(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 352
  if ((unsigned long )function == (unsigned long )(& link_timer_hdl)) {
#line 353
    activate_suitable_timer_10(timer, data);
  } else {

  }
#line 354
  return (0);
}
}
#line 358 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void ldv_timer_9(int state , struct timer_list *timer ) 
{ 


  {
#line 359
  LDV_IN_INTERRUPT = 2;
#line 360
  survey_timer_hdl(timer->data);
#line 361
  LDV_IN_INTERRUPT = 1;
#line 362
  return;
}
}
#line 365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void activate_pending_timer_8(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 366
  if ((unsigned long )ldv_timer_list_8_0 == (unsigned long )timer) {
#line 367
    if (ldv_timer_8_0 == 2 || pending_flag != 0) {
#line 368
      ldv_timer_list_8_0 = timer;
#line 369
      ldv_timer_list_8_0->data = data;
#line 370
      ldv_timer_8_0 = 1;
    } else {

    }
#line 372
    return;
  } else {

  }
#line 375
  if ((unsigned long )ldv_timer_list_8_1 == (unsigned long )timer) {
#line 376
    if (ldv_timer_8_1 == 2 || pending_flag != 0) {
#line 377
      ldv_timer_list_8_1 = timer;
#line 378
      ldv_timer_list_8_1->data = data;
#line 379
      ldv_timer_8_1 = 1;
    } else {

    }
#line 381
    return;
  } else {

  }
#line 384
  if ((unsigned long )ldv_timer_list_8_2 == (unsigned long )timer) {
#line 385
    if (ldv_timer_8_2 == 2 || pending_flag != 0) {
#line 386
      ldv_timer_list_8_2 = timer;
#line 387
      ldv_timer_list_8_2->data = data;
#line 388
      ldv_timer_8_2 = 1;
    } else {

    }
#line 390
    return;
  } else {

  }
#line 393
  if ((unsigned long )ldv_timer_list_8_3 == (unsigned long )timer) {
#line 394
    if (ldv_timer_8_3 == 2 || pending_flag != 0) {
#line 395
      ldv_timer_list_8_3 = timer;
#line 396
      ldv_timer_list_8_3->data = data;
#line 397
      ldv_timer_8_3 = 1;
    } else {

    }
#line 399
    return;
  } else {

  }
#line 401
  activate_suitable_timer_8(timer, data);
#line 402
  return;
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void timer_init_9(void) 
{ 


  {
#line 406
  ldv_timer_9_0 = 0;
#line 407
  ldv_timer_9_1 = 0;
#line 408
  ldv_timer_9_2 = 0;
#line 409
  ldv_timer_9_3 = 0;
#line 410
  return;
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void ldv_timer_10(int state , struct timer_list *timer ) 
{ 


  {
#line 414
  LDV_IN_INTERRUPT = 2;
#line 415
  link_timer_hdl(timer->data);
#line 416
  LDV_IN_INTERRUPT = 1;
#line 417
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void activate_suitable_timer_9(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 421
  if (ldv_timer_9_0 == 0 || ldv_timer_9_0 == 2) {
#line 422
    ldv_timer_list_9_0 = timer;
#line 423
    ldv_timer_list_9_0->data = data;
#line 424
    ldv_timer_9_0 = 1;
#line 425
    return;
  } else {

  }
#line 427
  if (ldv_timer_9_1 == 0 || ldv_timer_9_1 == 2) {
#line 428
    ldv_timer_list_9_1 = timer;
#line 429
    ldv_timer_list_9_1->data = data;
#line 430
    ldv_timer_9_1 = 1;
#line 431
    return;
  } else {

  }
#line 433
  if (ldv_timer_9_2 == 0 || ldv_timer_9_2 == 2) {
#line 434
    ldv_timer_list_9_2 = timer;
#line 435
    ldv_timer_list_9_2->data = data;
#line 436
    ldv_timer_9_2 = 1;
#line 437
    return;
  } else {

  }
#line 439
  if (ldv_timer_9_3 == 0 || ldv_timer_9_3 == 2) {
#line 440
    ldv_timer_list_9_3 = timer;
#line 441
    ldv_timer_list_9_3->data = data;
#line 442
    ldv_timer_9_3 = 1;
#line 443
    return;
  } else {

  }
#line 445
  return;
}
}
#line 449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void disable_suitable_timer_10(struct timer_list *timer ) 
{ 


  {
#line 450
  if (ldv_timer_10_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_0) {
#line 451
    ldv_timer_10_0 = 0;
#line 452
    return;
  } else {

  }
#line 454
  if (ldv_timer_10_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_1) {
#line 455
    ldv_timer_10_1 = 0;
#line 456
    return;
  } else {

  }
#line 458
  if (ldv_timer_10_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_2) {
#line 459
    ldv_timer_10_2 = 0;
#line 460
    return;
  } else {

  }
#line 462
  if (ldv_timer_10_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_3) {
#line 463
    ldv_timer_10_3 = 0;
#line 464
    return;
  } else {

  }
#line 466
  return;
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void choose_timer_8(void) 
{ 
  int tmp ;

  {
#line 471
  tmp = __VERIFIER_nondet_int();
#line 471
  switch (tmp) {
  case 0: ;
#line 473
  if (ldv_timer_8_0 == 1) {
#line 474
    ldv_timer_8_0 = 2;
#line 475
    ldv_timer_8(ldv_timer_8_0, ldv_timer_list_8_0);
  } else {

  }
#line 478
  goto ldv_57285;
  case 1: ;
#line 480
  if (ldv_timer_8_1 == 1) {
#line 481
    ldv_timer_8_1 = 2;
#line 482
    ldv_timer_8(ldv_timer_8_1, ldv_timer_list_8_1);
  } else {

  }
#line 485
  goto ldv_57285;
  case 2: ;
#line 487
  if (ldv_timer_8_2 == 1) {
#line 488
    ldv_timer_8_2 = 2;
#line 489
    ldv_timer_8(ldv_timer_8_2, ldv_timer_list_8_2);
  } else {

  }
#line 492
  goto ldv_57285;
  case 3: ;
#line 494
  if (ldv_timer_8_3 == 1) {
#line 495
    ldv_timer_8_3 = 2;
#line 496
    ldv_timer_8(ldv_timer_8_3, ldv_timer_list_8_3);
  } else {

  }
#line 499
  goto ldv_57285;
  default: 
#line 500
  ldv_stop();
  }
  ldv_57285: ;
#line 502
  return;
}
}
#line 506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int reg_timer_9(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 507
  if ((unsigned long )function == (unsigned long )(& survey_timer_hdl)) {
#line 508
    activate_suitable_timer_9(timer, data);
  } else {

  }
#line 509
  return (0);
}
}
#line 513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int reg_timer_8(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 514
  if ((unsigned long )function == (unsigned long )(& addba_timer_hdl)) {
#line 515
    activate_suitable_timer_8(timer, data);
  } else {

  }
#line 516
  return (0);
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void disable_suitable_timer_9(struct timer_list *timer ) 
{ 


  {
#line 521
  if (ldv_timer_9_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_0) {
#line 522
    ldv_timer_9_0 = 0;
#line 523
    return;
  } else {

  }
#line 525
  if (ldv_timer_9_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_1) {
#line 526
    ldv_timer_9_1 = 0;
#line 527
    return;
  } else {

  }
#line 529
  if (ldv_timer_9_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_2) {
#line 530
    ldv_timer_9_2 = 0;
#line 531
    return;
  } else {

  }
#line 533
  if (ldv_timer_9_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_3) {
#line 534
    ldv_timer_9_3 = 0;
#line 535
    return;
  } else {

  }
#line 537
  return;
}
}
#line 541 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void activate_suitable_timer_10(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 542
  if (ldv_timer_10_0 == 0 || ldv_timer_10_0 == 2) {
#line 543
    ldv_timer_list_10_0 = timer;
#line 544
    ldv_timer_list_10_0->data = data;
#line 545
    ldv_timer_10_0 = 1;
#line 546
    return;
  } else {

  }
#line 548
  if (ldv_timer_10_1 == 0 || ldv_timer_10_1 == 2) {
#line 549
    ldv_timer_list_10_1 = timer;
#line 550
    ldv_timer_list_10_1->data = data;
#line 551
    ldv_timer_10_1 = 1;
#line 552
    return;
  } else {

  }
#line 554
  if (ldv_timer_10_2 == 0 || ldv_timer_10_2 == 2) {
#line 555
    ldv_timer_list_10_2 = timer;
#line 556
    ldv_timer_list_10_2->data = data;
#line 557
    ldv_timer_10_2 = 1;
#line 558
    return;
  } else {

  }
#line 560
  if (ldv_timer_10_3 == 0 || ldv_timer_10_3 == 2) {
#line 561
    ldv_timer_list_10_3 = timer;
#line 562
    ldv_timer_list_10_3->data = data;
#line 563
    ldv_timer_10_3 = 1;
#line 564
    return;
  } else {

  }
#line 566
  return;
}
}
#line 570 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void choose_timer_9(void) 
{ 
  int tmp ;

  {
#line 571
  tmp = __VERIFIER_nondet_int();
#line 571
  switch (tmp) {
  case 0: ;
#line 573
  if (ldv_timer_9_0 == 1) {
#line 574
    ldv_timer_9_0 = 2;
#line 575
    ldv_timer_9(ldv_timer_9_0, ldv_timer_list_9_0);
  } else {

  }
#line 578
  goto ldv_57313;
  case 1: ;
#line 580
  if (ldv_timer_9_1 == 1) {
#line 581
    ldv_timer_9_1 = 2;
#line 582
    ldv_timer_9(ldv_timer_9_1, ldv_timer_list_9_1);
  } else {

  }
#line 585
  goto ldv_57313;
  case 2: ;
#line 587
  if (ldv_timer_9_2 == 1) {
#line 588
    ldv_timer_9_2 = 2;
#line 589
    ldv_timer_9(ldv_timer_9_2, ldv_timer_list_9_2);
  } else {

  }
#line 592
  goto ldv_57313;
  case 3: ;
#line 594
  if (ldv_timer_9_3 == 1) {
#line 595
    ldv_timer_9_3 = 2;
#line 596
    ldv_timer_9(ldv_timer_9_3, ldv_timer_list_9_3);
  } else {

  }
#line 599
  goto ldv_57313;
  default: 
#line 600
  ldv_stop();
  }
  ldv_57313: ;
#line 602
  return;
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void timer_init_10(void) 
{ 


  {
#line 607
  ldv_timer_10_0 = 0;
#line 608
  ldv_timer_10_1 = 0;
#line 609
  ldv_timer_10_2 = 0;
#line 610
  ldv_timer_10_3 = 0;
#line 611
  return;
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void ldv_timer_8(int state , struct timer_list *timer ) 
{ 


  {
#line 615
  LDV_IN_INTERRUPT = 2;
#line 616
  addba_timer_hdl(timer->data);
#line 617
  LDV_IN_INTERRUPT = 1;
#line 618
  return;
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void timer_init_8(void) 
{ 


  {
#line 622
  ldv_timer_8_0 = 0;
#line 623
  ldv_timer_8_1 = 0;
#line 624
  ldv_timer_8_2 = 0;
#line 625
  ldv_timer_8_3 = 0;
#line 626
  return;
}
}
#line 629 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void activate_suitable_timer_8(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 630
  if (ldv_timer_8_0 == 0 || ldv_timer_8_0 == 2) {
#line 631
    ldv_timer_list_8_0 = timer;
#line 632
    ldv_timer_list_8_0->data = data;
#line 633
    ldv_timer_8_0 = 1;
#line 634
    return;
  } else {

  }
#line 636
  if (ldv_timer_8_1 == 0 || ldv_timer_8_1 == 2) {
#line 637
    ldv_timer_list_8_1 = timer;
#line 638
    ldv_timer_list_8_1->data = data;
#line 639
    ldv_timer_8_1 = 1;
#line 640
    return;
  } else {

  }
#line 642
  if (ldv_timer_8_2 == 0 || ldv_timer_8_2 == 2) {
#line 643
    ldv_timer_list_8_2 = timer;
#line 644
    ldv_timer_list_8_2->data = data;
#line 645
    ldv_timer_8_2 = 1;
#line 646
    return;
  } else {

  }
#line 648
  if (ldv_timer_8_3 == 0 || ldv_timer_8_3 == 2) {
#line 649
    ldv_timer_list_8_3 = timer;
#line 650
    ldv_timer_list_8_3->data = data;
#line 651
    ldv_timer_8_3 = 1;
#line 652
    return;
  } else {

  }
#line 654
  return;
}
}
#line 658 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void choose_timer_10(void) 
{ 
  int tmp ;

  {
#line 659
  tmp = __VERIFIER_nondet_int();
#line 659
  switch (tmp) {
  case 0: ;
#line 661
  if (ldv_timer_10_0 == 1) {
#line 662
    ldv_timer_10_0 = 2;
#line 663
    ldv_timer_10(ldv_timer_10_0, ldv_timer_list_10_0);
  } else {

  }
#line 666
  goto ldv_57336;
  case 1: ;
#line 668
  if (ldv_timer_10_1 == 1) {
#line 669
    ldv_timer_10_1 = 2;
#line 670
    ldv_timer_10(ldv_timer_10_1, ldv_timer_list_10_1);
  } else {

  }
#line 673
  goto ldv_57336;
  case 2: ;
#line 675
  if (ldv_timer_10_2 == 1) {
#line 676
    ldv_timer_10_2 = 2;
#line 677
    ldv_timer_10(ldv_timer_10_2, ldv_timer_list_10_2);
  } else {

  }
#line 680
  goto ldv_57336;
  case 3: ;
#line 682
  if (ldv_timer_10_3 == 1) {
#line 683
    ldv_timer_10_3 = 2;
#line 684
    ldv_timer_10(ldv_timer_10_3, ldv_timer_list_10_3);
  } else {

  }
#line 687
  goto ldv_57336;
  default: 
#line 688
  ldv_stop();
  }
  ldv_57336: ;
#line 690
  return;
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
bool ldv_queue_work_on_97(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 721
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 721
  ldv_func_res = tmp;
#line 723
  activate_work_2(ldv_func_arg3, 2);
#line 725
  return (ldv_func_res);
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
bool ldv_queue_delayed_work_on_98(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 732
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 732
  ldv_func_res = tmp;
#line 734
  activate_work_2(& ldv_func_arg3->work, 2);
#line 736
  return (ldv_func_res);
}
}
#line 739 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
bool ldv_queue_work_on_99(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 743
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 743
  ldv_func_res = tmp;
#line 745
  activate_work_2(ldv_func_arg3, 2);
#line 747
  return (ldv_func_res);
}
}
#line 750 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void ldv_flush_workqueue_100(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 753
  flush_workqueue(ldv_func_arg1);
#line 755
  call_and_disable_all_2(2);
#line 756
  return;
}
}
#line 758 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
bool ldv_queue_delayed_work_on_101(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 762
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 762
  ldv_func_res = tmp;
#line 764
  activate_work_2(& ldv_func_arg3->work, 2);
#line 766
  return (ldv_func_res);
}
}
#line 769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_102(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 773
  tmp = del_timer_sync(ldv_func_arg1);
#line 773
  ldv_func_res = tmp;
#line 775
  disable_suitable_timer_11(ldv_func_arg1);
#line 777
  return (ldv_func_res);
}
}
#line 780 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_103(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 784
  tmp = del_timer_sync(ldv_func_arg1);
#line 784
  ldv_func_res = tmp;
#line 786
  disable_suitable_timer_11(ldv_func_arg1);
#line 788
  return (ldv_func_res);
}
}
#line 791 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_104(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 795
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 795
  ldv_func_res = tmp;
#line 797
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 799
  return (ldv_func_res);
}
}
#line 802 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_105(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 806
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 806
  ldv_func_res = tmp;
#line 808
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 810
  return (ldv_func_res);
}
}
#line 813 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_106(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 817
  tmp = del_timer_sync(ldv_func_arg1);
#line 817
  ldv_func_res = tmp;
#line 819
  disable_suitable_timer_11(ldv_func_arg1);
#line 821
  return (ldv_func_res);
}
}
#line 824 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_107(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 828
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 828
  ldv_func_res = tmp;
#line 830
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 832
  return (ldv_func_res);
}
}
#line 835 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_108(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 839
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 839
  ldv_func_res = tmp;
#line 841
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 843
  return (ldv_func_res);
}
}
#line 846 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_109(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 850
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 850
  ldv_func_res = tmp;
#line 852
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 854
  return (ldv_func_res);
}
}
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_110(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
#line 861
  tmp = del_timer_sync(ldv_func_arg1);
#line 861
  ldv_func_res = tmp;
#line 863
  disable_suitable_timer_11(ldv_func_arg1);
#line 865
  return (ldv_func_res);
}
}
#line 868 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_111(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
#line 872
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 872
  ldv_func_res = tmp;
#line 874
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 876
  return (ldv_func_res);
}
}
#line 879 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_112(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
#line 883
  tmp = del_timer_sync(ldv_func_arg1);
#line 883
  ldv_func_res = tmp;
#line 885
  disable_suitable_timer_11(ldv_func_arg1);
#line 887
  return (ldv_func_res);
}
}
#line 890 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_113(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;

  {
#line 894
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 894
  ldv_func_res = tmp;
#line 896
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 898
  return (ldv_func_res);
}
}
#line 901 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_114(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;

  {
#line 905
  tmp = del_timer_sync(ldv_func_arg1);
#line 905
  ldv_func_res = tmp;
#line 907
  disable_suitable_timer_11(ldv_func_arg1);
#line 909
  return (ldv_func_res);
}
}
#line 912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_115(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___17 ldv_func_res ;
  int tmp ;

  {
#line 916
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 916
  ldv_func_res = tmp;
#line 918
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 920
  return (ldv_func_res);
}
}
#line 923 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_116(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___18 ldv_func_res ;
  int tmp ;

  {
#line 927
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 927
  ldv_func_res = tmp;
#line 929
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 931
  return (ldv_func_res);
}
}
#line 934 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_117(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___19 ldv_func_res ;
  int tmp ;

  {
#line 938
  tmp = del_timer_sync(ldv_func_arg1);
#line 938
  ldv_func_res = tmp;
#line 940
  disable_suitable_timer_11(ldv_func_arg1);
#line 942
  return (ldv_func_res);
}
}
#line 945 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_118(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___20 ldv_func_res ;
  int tmp ;

  {
#line 949
  tmp = del_timer_sync(ldv_func_arg1);
#line 949
  ldv_func_res = tmp;
#line 951
  disable_suitable_timer_11(ldv_func_arg1);
#line 953
  return (ldv_func_res);
}
}
#line 956 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_119(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___21 ldv_func_res ;
  int tmp ;

  {
#line 960
  tmp = del_timer_sync(ldv_func_arg1);
#line 960
  ldv_func_res = tmp;
#line 962
  disable_suitable_timer_11(ldv_func_arg1);
#line 964
  return (ldv_func_res);
}
}
#line 967 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_120(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___22 ldv_func_res ;
  int tmp ;

  {
#line 971
  tmp = del_timer_sync(ldv_func_arg1);
#line 971
  ldv_func_res = tmp;
#line 973
  disable_suitable_timer_11(ldv_func_arg1);
#line 975
  return (ldv_func_res);
}
}
#line 978 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_121(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___23 ldv_func_res ;
  int tmp ;

  {
#line 982
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 982
  ldv_func_res = tmp;
#line 984
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 986
  return (ldv_func_res);
}
}
#line 989 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_122(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___24 ldv_func_res ;
  int tmp ;

  {
#line 993
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 993
  ldv_func_res = tmp;
#line 995
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 997
  return (ldv_func_res);
}
}
#line 173 "include/linux/timer.h"
int ldv_mod_timer_158(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_153(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_155(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_154(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_157(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_156(struct workqueue_struct *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
int ldv_timer_11_0 ;
#line 46
struct timer_list *ldv_timer_list_11_1 ;
#line 64
int ldv_timer_11_2 ;
#line 98
int ldv_timer_11_1 ;
#line 101
struct timer_list *ldv_timer_list_11_2 ;
#line 111
struct timer_list *ldv_timer_list_11_0 ;
#line 124
int ldv_timer_11_3 ;
#line 147
struct timer_list *ldv_timer_list_11_3 ;
#line 207
void ldv_timer_11(int state , struct timer_list *timer ) ;
#line 213
void choose_timer_11(void) ;
#line 218
void timer_init_11(void) ;
#line 234
void activate_suitable_timer_11(struct timer_list *timer , unsigned long data ) ;
#line 32 "include/linux/semaphore.h"
__inline static void sema_init(struct semaphore *sem , int val ) 
{ 
  struct lock_class_key __key ;
  struct semaphore __constr_expr_0 ;

  {
#line 35
  __constr_expr_0.lock.raw_lock.val.counter = 0;
#line 35
  __constr_expr_0.lock.magic = 3735899821U;
#line 35
  __constr_expr_0.lock.owner_cpu = 4294967295U;
#line 35
  __constr_expr_0.lock.owner = (void *)-1;
#line 35
  __constr_expr_0.lock.dep_map.key = 0;
#line 35
  __constr_expr_0.lock.dep_map.class_cache[0] = 0;
#line 35
  __constr_expr_0.lock.dep_map.class_cache[1] = 0;
#line 35
  __constr_expr_0.lock.dep_map.name = "(*sem).lock";
#line 35
  __constr_expr_0.lock.dep_map.cpu = 0;
#line 35
  __constr_expr_0.lock.dep_map.ip = 0UL;
#line 35
  __constr_expr_0.count = (unsigned int )val;
#line 35
  __constr_expr_0.wait_list.next = & sem->wait_list;
#line 35
  __constr_expr_0.wait_list.prev = & sem->wait_list;
#line 35
  *sem = __constr_expr_0;
#line 36
  lockdep_init_map(& sem->lock.dep_map, "semaphore->lock", & __key, 0);
#line 37
  return;
}
}
#line 39
extern void down(struct semaphore * ) ;
#line 44
extern void up(struct semaphore * ) ;
#line 177 "drivers/staging/rtl8723au/include/hal_com.h"
void rtl8723a_set_rpwm(struct rtw_adapter *padapter , u8 val ) ;
#line 179
bool rtl8723a_get_fwlps_rf_on(struct rtw_adapter *padapter ) ;
#line 215 "drivers/staging/rtl8723au/include/rtw_pwrctrl.h"
void rtw_init_pwrctrl_priv23a(struct rtw_adapter *padapter ) ;
#line 216
void rtw_free_pwrctrl_priv(struct rtw_adapter *adapter ) ;
#line 218
void rtw_set_ps_mode23a(struct rtw_adapter *padapter , u8 ps_mode , u8 smart_ps ,
                        u8 bcn_ant_mode ) ;
#line 220
void rtw_set_rpwm23a(struct rtw_adapter *padapter , u8 pslv ) ;
#line 221
void LeaveAllPowerSaveMode23a(struct rtw_adapter *Adapter ) ;
#line 222
void ips_enter23a(struct rtw_adapter *padapter ) ;
#line 223
int ips_leave23a(struct rtw_adapter *padapter ) ;
#line 229
s32 LPS_RF_ON_check23a(struct rtw_adapter *padapter , u32 delay_ms ) ;
#line 234
int _rtw_pwr_wakeup23a(struct rtw_adapter *padapter , u32 ips_deffer_ms , char const   *caller ) ;
#line 238
int rtw_pm_set_ips23a(struct rtw_adapter *padapter , u8 mode ) ;
#line 239
int rtw_pm_set_lps23a(struct rtw_adapter *padapter , u8 mode ) ;
#line 35 "drivers/staging/rtl8723au/include/osdep_intf.h"
int rtw_ips_pwr_up23a(struct rtw_adapter *padapter ) ;
#line 36
void rtw_ips_pwr_down23a(struct rtw_adapter *padapter ) ;
#line 64 "drivers/staging/rtl8723au/include/ioctl_cfg80211.h"
extern bool rtw_cfg80211_pwr_mgmt(struct rtw_adapter * ) ;
#line 145 "drivers/staging/rtl8723au/include/rtl8723a_cmd.h"
void rtl8723a_set_FwPwrMode_cmd(struct rtw_adapter *padapter , u8 Mode ) ;
#line 32 "drivers/staging/rtl8723au/include/rtl8723a_bt_intf.h"
void rtl8723a_BT_disable_coexist(struct rtw_adapter *padapter ) ;
#line 32 "drivers/staging/rtl8723au/include/rtw_sreset.h"
bool rtw_sreset_inprogress(struct rtw_adapter *padapter ) ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
void ips_enter23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;

  {
#line 28
  pwrpriv = & padapter->pwrctrlpriv;
#line 30
  down(& pwrpriv->lock);
#line 32
  pwrpriv->bips_processing = 1U;
#line 35
  pwrpriv->ips_mode = pwrpriv->ips_mode_req;
#line 37
  pwrpriv->ips_enter23a_cnts = pwrpriv->ips_enter23a_cnts + 1U;
#line 38
  if (GlobalDebugLevel23A > 3U) {
#line 38
    printk("\016RTL8723AU: ==>ips_enter23a cnts:%d\n", pwrpriv->ips_enter23a_cnts);
  } else {

  }
#line 39
  rtl8723a_BT_disable_coexist(padapter);
#line 41
  if ((unsigned int )pwrpriv->change_rfpwrstate == 2U) {
#line 42
    pwrpriv->bpower_saving = 1U;
#line 43
    if (GlobalDebugLevel23A != 0U) {
#line 43
      printk("\016RTL8723AU: nolinked power save enter\n");
    } else {

    }
#line 45
    if ((unsigned int )pwrpriv->ips_mode == 2U) {
#line 46
      pwrpriv->bkeepfwalive = 1U;
    } else {

    }
#line 48
    rtw_ips_pwr_down23a(padapter);
#line 49
    pwrpriv->rf_pwrstate = 2;
  } else {

  }
#line 51
  pwrpriv->bips_processing = 0U;
#line 53
  up(& pwrpriv->lock);
#line 54
  return;
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
int ips_leave23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  int result ;
  int keyid ;
  u32 tmp ;

  {
#line 58
  pwrpriv = & padapter->pwrctrlpriv;
#line 59
  psecuritypriv = & padapter->securitypriv;
#line 60
  pmlmepriv = & padapter->mlmepriv;
#line 61
  result = 1;
#line 64
  down(& pwrpriv->lock);
#line 66
  if ((unsigned int )pwrpriv->rf_pwrstate == 2U && pwrpriv->bips_processing == 0U) {
#line 67
    pwrpriv->bips_processing = 1U;
#line 68
    pwrpriv->change_rfpwrstate = 0;
#line 69
    pwrpriv->ips_leave23a_cnts = pwrpriv->ips_leave23a_cnts + 1U;
#line 70
    if (GlobalDebugLevel23A > 3U) {
#line 70
      printk("\016RTL8723AU: ==>ips_leave23a cnts:%d\n", pwrpriv->ips_leave23a_cnts);
    } else {

    }
#line 73
    result = rtw_ips_pwr_up23a(padapter);
#line 74
    if (result == 1) {
#line 75
      pwrpriv->rf_pwrstate = 0;
    } else {

    }
#line 77
    if (GlobalDebugLevel23A != 0U) {
#line 77
      printk("\016RTL8723AU: nolinked power save leave\n");
    } else {

    }
#line 79
    if (psecuritypriv->dot11PrivacyAlgrthm == 1027073U || psecuritypriv->dot11PrivacyAlgrthm == 1027077U) {
#line 83
      if (GlobalDebugLevel23A > 3U) {
#line 83
        printk("\016RTL8723AU: ==>%s, channel(%d), processing(%x)\n", "ips_leave23a",
               (int )padapter->mlmeextpriv.cur_channel, pwrpriv->bips_processing);
      } else {

      }
#line 86
      set_channel_bwmode23a(padapter, (int )padapter->mlmeextpriv.cur_channel, 0,
                            0);
#line 90
      keyid = 0;
#line 90
      goto ldv_55764;
      ldv_55763: ;
#line 91
      if ((int )((unsigned long )pmlmepriv->key_mask >> keyid) & 1) {
#line 92
        if ((u32 )keyid == psecuritypriv->dot11PrivacyKeyIndex) {
#line 94
          result = rtw_set_key23a(padapter, psecuritypriv, keyid, 1);
        } else {
#line 96
          result = rtw_set_key23a(padapter, psecuritypriv, keyid, 0);
        }
      } else {

      }
#line 90
      keyid = keyid + 1;
      ldv_55764: ;
#line 90
      if (keyid <= 3) {
#line 92
        goto ldv_55763;
      } else {

      }

    } else {

    }
#line 101
    if (GlobalDebugLevel23A > 3U) {
#line 101
      tmp = rtl8723au_read32(padapter, 76);
#line 101
      printk("\016RTL8723AU: ==> ips_leave23a.....LED(0x%08x)...\n", tmp);
    } else {

    }
#line 103
    pwrpriv->bips_processing = 0U;
#line 105
    pwrpriv->bkeepfwalive = 0U;
#line 106
    pwrpriv->bpower_saving = 0U;
  } else {

  }
#line 109
  up(& pwrpriv->lock);
#line 111
  return (result);
}
}
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
static bool rtw_pwr_unassociated_idle(struct rtw_adapter *adapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct xmit_priv *pxmit_priv ;
  bool ret ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
#line 117
  pmlmepriv = & adapter->mlmepriv;
#line 118
  pxmit_priv = & adapter->xmitpriv;
#line 120
  ret = 0;
#line 122
  if ((long )(adapter->pwrctrlpriv.ips_deny_time - (unsigned long )jiffies) >= 0L) {
#line 123
    goto exit;
  } else {

  }
#line 125
  tmp = check_fwstate(pmlmepriv, 2049);
#line 125
  if ((int )tmp) {
#line 129
    goto exit;
  } else {
#line 125
    tmp___0 = check_fwstate(pmlmepriv, 384);
#line 125
    if ((int )tmp___0) {
#line 129
      goto exit;
    } else {
#line 125
      tmp___1 = check_fwstate(pmlmepriv, 16);
#line 125
      if ((int )tmp___1) {
#line 129
        goto exit;
      } else {
#line 125
        tmp___2 = check_fwstate(pmlmepriv, 96);
#line 125
        if ((int )tmp___2) {
#line 129
          goto exit;
        } else {

        }
      }
    }
  }
#line 132
  if (pxmit_priv->free_xmitbuf_cnt != 4U || pxmit_priv->free_xmit_extbuf_cnt != 32U) {
#line 134
    if (GlobalDebugLevel23A != 0U) {
#line 134
      printk("\016RTL8723AU: There are some pkts to transmit\n");
    } else {

    }
#line 136
    if (GlobalDebugLevel23A > 6U) {
#line 136
      printk("\016RTL8723AU: free_xmitbuf_cnt: %d, free_xmit_extbuf_cnt: %d\n", pxmit_priv->free_xmitbuf_cnt,
             pxmit_priv->free_xmit_extbuf_cnt);
    } else {

    }
#line 140
    goto exit;
  } else {

  }
#line 143
  ret = 1;
  exit: ;
#line 146
  return (ret);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
void rtw_ps_processor23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 151
  pwrpriv = & padapter->pwrctrlpriv;
#line 152
  pmlmepriv = & padapter->mlmepriv;
#line 154
  pwrpriv->ps_processing = 1U;
#line 156
  if (pwrpriv->bips_processing == 1U) {
#line 157
    goto exit;
  } else {

  }
#line 159
  if ((unsigned int )pwrpriv->ips_mode_req == 0U) {
#line 160
    goto exit;
  } else {

  }
#line 162
  tmp = rtw_pwr_unassociated_idle(padapter);
#line 162
  if (tmp) {
#line 162
    tmp___0 = 0;
  } else {
#line 162
    tmp___0 = 1;
  }
#line 162
  if (tmp___0) {
#line 163
    goto exit;
  } else {

  }
#line 165
  if ((unsigned int )pwrpriv->rf_pwrstate == 0U && ((unsigned int )pwrpriv->pwr_state_check_cnts & 3U) == 0U) {
#line 167
    if (GlobalDebugLevel23A > 3U) {
#line 167
      tmp___1 = get_fwstate(pmlmepriv);
#line 167
      printk("\016RTL8723AU: ==>%s .fw_state(%x)\n", "rtw_ps_processor23a", tmp___1);
    } else {

    }
#line 169
    pwrpriv->change_rfpwrstate = 2;
#line 170
    ips_enter23a(padapter);
  } else {

  }
  exit: 
#line 173
  tmp___2 = msecs_to_jiffies((unsigned int const   )padapter->pwrctrlpriv.pwr_state_check_interval);
#line 173
  ldv_mod_timer_158(& padapter->pwrctrlpriv.pwr_state_check_timer, tmp___2 + (unsigned long )jiffies);
#line 174
  pwrpriv->ps_processing = 0U;
#line 175
  return;
}
}
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
static void pwr_state_check_handler(unsigned long data ) 
{ 
  struct rtw_adapter *padapter ;

  {
#line 179
  padapter = (struct rtw_adapter *)data;
#line 181
  rtw_ps_cmd23a(padapter);
#line 182
  return;
}
}
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
void rtw_set_rpwm23a(struct rtw_adapter *padapter , u8 pslv ) 
{ 
  u8 rpwm ;
  struct pwrctrl_priv *pwrpriv ;

  {
#line 194
  pwrpriv = & padapter->pwrctrlpriv;
#line 196
  pslv = (unsigned int )pslv & 15U;
#line 198
  if ((unsigned int )pwrpriv->btcoex_rfon != 0U) {
#line 199
    if ((unsigned int )pslv <= 11U) {
#line 200
      pslv = 4U;
    } else {

    }
  } else {

  }
#line 203
  if ((int )((unsigned char )pwrpriv->rpwm) == (int )pslv) {
#line 204
    if (GlobalDebugLevel23A > 3U) {
#line 204
      rt_trace(524288, 4, "%s: Already set rpwm[0x%02X], new = 0x%02X!\n", "rtw_set_rpwm23a",
               (int )pwrpriv->rpwm, (int )pslv);
    } else {

    }
#line 207
    return;
  } else {

  }
#line 210
  if (padapter->bSurpriseRemoved == 1 || (unsigned int )padapter->hw_init_completed == 0U) {
#line 212
    if (GlobalDebugLevel23A > 3U) {
#line 212
      rt_trace(524288, 4, "%s: SurpriseRemoved(%d) hw_init_completed(%d)\n", "rtw_set_rpwm23a",
               padapter->bSurpriseRemoved, (int )padapter->hw_init_completed);
    } else {

    }
#line 217
    pwrpriv->cpwm = 12U;
#line 219
    return;
  } else {

  }
#line 222
  if (padapter->bDriverStopped == 1) {
#line 223
    if (GlobalDebugLevel23A > 3U) {
#line 223
      rt_trace(524288, 4, "%s: change power state(0x%02X) when DriverStopped\n", "rtw_set_rpwm23a",
               (int )pslv);
    } else {

    }
#line 227
    if ((unsigned int )pslv <= 1U) {
#line 228
      if (GlobalDebugLevel23A > 3U) {
#line 228
        rt_trace(524288, 4, "%s: Reject to enter PS_STATE(0x%02X) lower than S2 when DriverStopped!!\n",
                 "rtw_set_rpwm23a", (int )pslv);
      } else {

      }
#line 231
      return;
    } else {

    }
  } else {

  }
#line 235
  rpwm = (u8 )((int )((unsigned char )pwrpriv->tog) | (int )pslv);
#line 236
  if (GlobalDebugLevel23A > 5U) {
#line 236
    rt_trace(524288, 6, "rtw_set_rpwm23a: rpwm = 0x%02x cpwm = 0x%02x\n", (int )rpwm,
             (int )pwrpriv->cpwm);
  } else {

  }
#line 240
  pwrpriv->rpwm = pslv;
#line 242
  rtl8723a_set_rpwm(padapter, (int )rpwm);
#line 244
  pwrpriv->tog = (unsigned int )pwrpriv->tog + 128U;
#line 245
  pwrpriv->cpwm = pslv;
#line 246
  return;
}
}
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
static bool PS_RDY_CHECK(struct rtw_adapter *padapter ) 
{ 
  unsigned long delta_time ;
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
#line 251
  pwrpriv = & padapter->pwrctrlpriv;
#line 252
  pmlmepriv = & padapter->mlmepriv;
#line 254
  delta_time = (unsigned long )jiffies - pwrpriv->DelayLPSLastTimeStamp;
#line 256
  if (delta_time <= 249UL) {
#line 257
    return (0);
  } else {

  }
#line 259
  tmp = check_fwstate(pmlmepriv, 1);
#line 259
  if (tmp) {
#line 259
    tmp___0 = 0;
  } else {
#line 259
    tmp___0 = 1;
  }
#line 259
  if (tmp___0) {
#line 264
    return (0);
  } else {
#line 259
    tmp___1 = check_fwstate(pmlmepriv, 2048);
#line 259
    if ((int )tmp___1) {
#line 264
      return (0);
    } else {
#line 259
      tmp___2 = check_fwstate(pmlmepriv, 16);
#line 259
      if ((int )tmp___2) {
#line 264
        return (0);
      } else {
#line 259
        tmp___3 = check_fwstate(pmlmepriv, 64);
#line 259
        if ((int )tmp___3) {
#line 264
          return (0);
        } else {
#line 259
          tmp___4 = check_fwstate(pmlmepriv, 32);
#line 259
          if ((int )tmp___4) {
#line 264
            return (0);
          } else {

          }
        }
      }
    }
  }
#line 265
  if ((unsigned int )pwrpriv->bInSuspend != 0U) {
#line 266
    return (0);
  } else {

  }
#line 267
  if (padapter->securitypriv.dot11AuthAlgrthm == 2U && (unsigned int )*((unsigned char *)padapter + 10948UL) == 0U) {
#line 269
    if (GlobalDebugLevel23A > 3U) {
#line 269
      printk("\016RTL8723AU: Group handshake still in progress !!!\n");
    } else {

    }
#line 270
    return (0);
  } else {

  }
#line 272
  tmp___5 = rtw_cfg80211_pwr_mgmt(padapter);
#line 272
  if (tmp___5) {
#line 272
    tmp___6 = 0;
  } else {
#line 272
    tmp___6 = 1;
  }
#line 272
  if (tmp___6) {
#line 273
    return (0);
  } else {

  }
#line 275
  return (1);
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
void rtw_set_ps_mode23a(struct rtw_adapter *padapter , u8 ps_mode , u8 smart_ps ,
                        u8 bcn_ant_mode ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 281
  pwrpriv = & padapter->pwrctrlpriv;
#line 283
  if (GlobalDebugLevel23A > 5U) {
#line 283
    rt_trace(524288, 6, "%s: PowerMode =%d Smart_PS =%d\n", "rtw_set_ps_mode23a",
             (int )ps_mode, (int )smart_ps);
  } else {

  }
#line 287
  if ((unsigned int )ps_mode > 10U) {
#line 288
    if (GlobalDebugLevel23A > 3U) {
#line 288
      rt_trace(524288, 4, "ps_mode:%d error\n", (int )ps_mode);
    } else {

    }
#line 290
    return;
  } else {

  }
#line 293
  if ((int )pwrpriv->pwr_mode == (int )ps_mode) {
#line 294
    if ((unsigned int )ps_mode == 0U) {
#line 295
      return;
    } else {

    }
#line 297
    if ((int )pwrpriv->smart_ps == (int )smart_ps && (int )pwrpriv->bcn_ant_mode == (int )bcn_ant_mode) {
#line 299
      return;
    } else {

    }
  } else {

  }
#line 302
  if ((unsigned int )ps_mode == 0U) {
#line 303
    if (GlobalDebugLevel23A > 3U) {
#line 303
      printk("\016RTL8723AU: rtw_set_ps_mode23a: Leave 802.11 power save\n");
    } else {

    }
#line 305
    pwrpriv->pwr_mode = ps_mode;
#line 306
    rtw_set_rpwm23a(padapter, 12);
#line 307
    rtl8723a_set_FwPwrMode_cmd(padapter, (int )ps_mode);
#line 308
    pwrpriv->bFwCurrentInPSMode = 0U;
  } else {
#line 310
    tmp = PS_RDY_CHECK(padapter);
#line 310
    if ((int )tmp) {
#line 310
      goto _L;
    } else {
#line 310
      tmp___0 = rtl8723a_BT_using_antenna_1(padapter);
#line 310
      if ((int )tmp___0) {
        _L: /* CIL Label */ 
#line 312
        if (GlobalDebugLevel23A > 3U) {
#line 312
          printk("\016RTL8723AU: %s: Enter 802.11 power save\n", "rtw_set_ps_mode23a");
        } else {

        }
#line 314
        pwrpriv->bFwCurrentInPSMode = 1U;
#line 315
        pwrpriv->pwr_mode = ps_mode;
#line 316
        pwrpriv->smart_ps = smart_ps;
#line 317
        pwrpriv->bcn_ant_mode = bcn_ant_mode;
#line 318
        rtl8723a_set_FwPwrMode_cmd(padapter, (int )ps_mode);
#line 320
        rtw_set_rpwm23a(padapter, 2);
      } else {

      }
    }
  }
#line 322
  return;
}
}
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
s32 LPS_RF_ON_check23a(struct rtw_adapter *padapter , u32 delay_ms ) 
{ 
  unsigned long start_time ;
  unsigned long end_time ;
  u8 bAwake ;
  s32 err ;
  unsigned long tmp ;
  bool tmp___0 ;

  {
#line 334
  bAwake = 0U;
#line 335
  err = 0;
#line 337
  start_time = jiffies;
#line 338
  tmp = msecs_to_jiffies(delay_ms);
#line 338
  end_time = tmp + start_time;
  ldv_55827: 
#line 341
  tmp___0 = rtl8723a_get_fwlps_rf_on(padapter);
#line 341
  bAwake = (u8 )tmp___0;
#line 342
  if ((unsigned int )bAwake == 1U) {
#line 343
    goto ldv_55819;
  } else {

  }
#line 345
  if (padapter->bSurpriseRemoved == 1) {
#line 346
    err = -2;
#line 347
    if (GlobalDebugLevel23A > 3U) {
#line 347
      printk("\016RTL8723AU: %s: device surprise removed!!\n", "LPS_RF_ON_check23a");
    } else {

    }
#line 348
    goto ldv_55819;
  } else {

  }
#line 351
  if ((long )(end_time - (unsigned long )jiffies) < 0L) {
#line 352
    err = -1;
#line 353
    if (GlobalDebugLevel23A > 3U) {
#line 353
      printk("\016RTL8723AU: %s: Wait for FW LPS leave more than %u ms!\n", "LPS_RF_ON_check23a",
             delay_ms);
    } else {

    }
#line 355
    goto ldv_55819;
  } else {

  }
#line 357
  __const_udelay(429500UL);
#line 358
  goto ldv_55827;
  ldv_55819: ;
#line 360
  return (err);
}
}
#line 365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
void LPS_Enter23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  bool tmp ;
  int tmp___0 ;

  {
#line 367
  pwrpriv = & padapter->pwrctrlpriv;
#line 369
  tmp = PS_RDY_CHECK(padapter);
#line 369
  if (tmp) {
#line 369
    tmp___0 = 0;
  } else {
#line 369
    tmp___0 = 1;
  }
#line 369
  if (tmp___0) {
#line 370
    return;
  } else {

  }
#line 372
  if ((unsigned int )pwrpriv->bLeisurePs != 0U) {
#line 374
    if ((unsigned int )pwrpriv->LpsIdleCount > 1U) {
#line 375
      if ((unsigned int )pwrpriv->pwr_mode == 0U) {
#line 376
        pwrpriv->bpower_saving = 1U;
#line 377
        if (GlobalDebugLevel23A > 3U) {
#line 377
          printk("\016RTL8723AU: %s smart_ps:%d\n", "LPS_Enter23a", (int )pwrpriv->smart_ps);
        } else {

        }
#line 380
        rtw_set_ps_mode23a(padapter, (int )pwrpriv->power_mgnt, (int )pwrpriv->smart_ps,
                           0);
      } else {

      }
    } else {
#line 385
      pwrpriv->LpsIdleCount = (u8 )((int )pwrpriv->LpsIdleCount + 1);
    }
  } else {

  }
#line 386
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
void LPS_Leave23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;

  {
#line 395
  pwrpriv = & padapter->pwrctrlpriv;
#line 397
  if ((unsigned int )pwrpriv->bLeisurePs != 0U) {
#line 398
    if ((unsigned int )pwrpriv->pwr_mode != 0U) {
#line 399
      rtw_set_ps_mode23a(padapter, 0, 0, 0);
#line 401
      if ((unsigned int )pwrpriv->pwr_mode == 0U) {
#line 402
        LPS_RF_ON_check23a(padapter, 100U);
      } else {

      }
    } else {

    }
  } else {

  }
#line 407
  pwrpriv->bpower_saving = 0U;
#line 408
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
void LeaveAllPowerSaveMode23a(struct rtw_adapter *Adapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  u8 enqueue ;
  bool tmp ;

  {
#line 414
  pmlmepriv = & Adapter->mlmepriv;
#line 415
  enqueue = 0U;
#line 418
  tmp = check_fwstate(pmlmepriv, 1);
#line 418
  if ((int )tmp) {
#line 419
    rtw_lps_ctrl_wk_cmd23a(Adapter, 5, (int )enqueue);
  } else {

  }
#line 420
  return;
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
void rtw_init_pwrctrl_priv23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrctrlpriv ;

  {
#line 424
  pwrctrlpriv = & padapter->pwrctrlpriv;
#line 426
  sema_init(& pwrctrlpriv->lock, 1);
#line 427
  pwrctrlpriv->rf_pwrstate = 0;
#line 428
  pwrctrlpriv->ips_enter23a_cnts = 0U;
#line 429
  pwrctrlpriv->ips_leave23a_cnts = 0U;
#line 430
  pwrctrlpriv->bips_processing = 0U;
#line 432
  pwrctrlpriv->ips_mode = padapter->registrypriv.ips_mode;
#line 433
  pwrctrlpriv->ips_mode_req = padapter->registrypriv.ips_mode;
#line 435
  pwrctrlpriv->pwr_state_check_interval = 2000;
#line 436
  pwrctrlpriv->pwr_state_check_cnts = 0U;
#line 437
  pwrctrlpriv->bInSuspend = 0U;
#line 438
  pwrctrlpriv->bkeepfwalive = 0U;
#line 440
  pwrctrlpriv->LpsIdleCount = 0U;
#line 443
  pwrctrlpriv->power_mgnt = padapter->registrypriv.power_mgnt;
#line 444
  pwrctrlpriv->bLeisurePs = (unsigned int )pwrctrlpriv->power_mgnt != 0U;
#line 447
  pwrctrlpriv->bFwCurrentInPSMode = 0U;
#line 449
  pwrctrlpriv->rpwm = 0U;
#line 450
  pwrctrlpriv->cpwm = 12U;
#line 452
  pwrctrlpriv->pwr_mode = 0U;
#line 453
  pwrctrlpriv->smart_ps = padapter->registrypriv.smart_ps;
#line 454
  pwrctrlpriv->bcn_ant_mode = 0U;
#line 456
  pwrctrlpriv->tog = 128U;
#line 458
  pwrctrlpriv->btcoex_rfon = 0U;
#line 460
  reg_timer_11(& pwrctrlpriv->pwr_state_check_timer, & pwr_state_check_handler, (unsigned long )padapter);
#line 461
  return;
}
}
#line 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
void rtw_free_pwrctrl_priv(struct rtw_adapter *adapter ) 
{ 


  {
#line 466
  return;
}
}
#line 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
int _rtw_pwr_wakeup23a(struct rtw_adapter *padapter , u32 ips_deffer_ms , char const   *caller ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  int ret ;
  unsigned long start ;
  unsigned long new_deny_time ;
  unsigned long tmp ;
  unsigned int tmp___0 ;
  bool tmp___1 ;
  unsigned int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  unsigned int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  unsigned long tmp___8 ;

  {
#line 484
  pwrpriv = & padapter->pwrctrlpriv;
#line 485
  pmlmepriv = & padapter->mlmepriv;
#line 486
  ret = 1;
#line 487
  start = jiffies;
#line 490
  tmp = msecs_to_jiffies(ips_deffer_ms);
#line 490
  new_deny_time = tmp + (unsigned long )jiffies;
#line 492
  if ((long )(pwrpriv->ips_deny_time - new_deny_time) < 0L) {
#line 493
    pwrpriv->ips_deny_time = new_deny_time;
  } else {

  }
#line 495
  if ((unsigned int )pwrpriv->ps_processing != 0U) {
#line 496
    if (GlobalDebugLevel23A > 3U) {
#line 496
      printk("\016RTL8723AU: %s wait ps_processing...\n", "_rtw_pwr_wakeup23a");
    } else {

    }
#line 497
    goto ldv_55872;
    ldv_55871: 
#line 499
    msleep(10U);
    ldv_55872: ;
#line 497
    if ((unsigned int )pwrpriv->ps_processing != 0U) {
#line 497
      tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 497
      if (tmp___0 <= 3000U) {
#line 500
        goto ldv_55871;
      } else {
#line 503
        goto ldv_55873;
      }
    } else {

    }
    ldv_55873: ;
#line 500
    if ((unsigned int )pwrpriv->ps_processing != 0U) {
#line 501
      if (GlobalDebugLevel23A > 3U) {
#line 501
        printk("\016RTL8723AU: %s wait ps_processing timeout\n", "_rtw_pwr_wakeup23a");
      } else {

      }
    } else
#line 503
    if (GlobalDebugLevel23A > 3U) {
#line 503
      printk("\016RTL8723AU: %s wait ps_processing done\n", "_rtw_pwr_wakeup23a");
    } else {

    }
  } else {

  }
#line 506
  tmp___4 = rtw_sreset_inprogress(padapter);
#line 506
  if ((int )tmp___4) {
#line 507
    if (GlobalDebugLevel23A > 3U) {
#line 507
      printk("\016RTL8723AU: %s wait sreset_inprogress...\n", "_rtw_pwr_wakeup23a");
    } else {

    }
#line 508
    goto ldv_55875;
    ldv_55874: 
#line 510
    msleep(10U);
    ldv_55875: 
#line 508
    tmp___1 = rtw_sreset_inprogress(padapter);
#line 508
    if ((int )tmp___1) {
#line 508
      tmp___2 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 508
      if (tmp___2 <= 4000U) {
#line 511
        goto ldv_55874;
      } else {
#line 514
        goto ldv_55876;
      }
    } else {

    }
    ldv_55876: 
#line 511
    tmp___3 = rtw_sreset_inprogress(padapter);
#line 511
    if ((int )tmp___3) {
#line 512
      if (GlobalDebugLevel23A > 3U) {
#line 512
        printk("\016RTL8723AU: %s wait sreset_inprogress timeout\n", "_rtw_pwr_wakeup23a");
      } else {

      }
    } else
#line 515
    if (GlobalDebugLevel23A > 3U) {
#line 515
      printk("\016RTL8723AU: %s wait sreset_inprogress done\n", "_rtw_pwr_wakeup23a");
    } else {

    }
  } else {

  }
#line 518
  if ((unsigned int )pwrpriv->bInSuspend != 0U) {
#line 519
    if (GlobalDebugLevel23A > 3U) {
#line 519
      printk("\016RTL8723AU: %s wait bInSuspend...\n", "_rtw_pwr_wakeup23a");
    } else {

    }
#line 520
    goto ldv_55878;
    ldv_55877: 
#line 522
    msleep(10U);
    ldv_55878: ;
#line 520
    if ((unsigned int )pwrpriv->bInSuspend != 0U) {
#line 520
      tmp___5 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 520
      if (tmp___5 <= 3000U) {
#line 523
        goto ldv_55877;
      } else {
#line 526
        goto ldv_55879;
      }
    } else {

    }
    ldv_55879: ;
#line 524
    if ((unsigned int )pwrpriv->bInSuspend != 0U) {
#line 525
      if (GlobalDebugLevel23A > 3U) {
#line 525
        printk("\016RTL8723AU: %s wait bInSuspend timeout\n", "_rtw_pwr_wakeup23a");
      } else {

      }
    } else
#line 527
    if (GlobalDebugLevel23A > 3U) {
#line 527
      printk("\016RTL8723AU: %s wait bInSuspend done\n", "_rtw_pwr_wakeup23a");
    } else {

    }
  } else {

  }
#line 531
  if ((unsigned int )pwrpriv->bInSuspend != 0U) {
#line 532
    ret = 0;
#line 533
    goto exit;
  } else {

  }
#line 537
  tmp___6 = check_fwstate(pmlmepriv, 1);
#line 537
  if ((int )tmp___6) {
#line 538
    ret = 1;
#line 539
    goto exit;
  } else {

  }
#line 542
  if ((unsigned int )pwrpriv->rf_pwrstate == 2U) {
#line 543
    if (GlobalDebugLevel23A > 3U) {
#line 543
      printk("\016RTL8723AU: %s call ips_leave23a....\n", "_rtw_pwr_wakeup23a");
    } else {

    }
#line 544
    tmp___7 = ips_leave23a(padapter);
#line 544
    if (tmp___7 == 0) {
#line 545
      if (GlobalDebugLevel23A > 3U) {
#line 545
        printk("\016RTL8723AU: ======> ips_leave23a fail.............\n");
      } else {

      }
#line 546
      ret = 0;
#line 547
      goto exit;
    } else {

    }
  } else {

  }
#line 552
  if ((padapter->bDriverStopped != 0 || padapter->bup == 0) || (unsigned int )padapter->hw_init_completed == 0U) {
#line 554
    if (GlobalDebugLevel23A > 3U) {
#line 554
      printk("\016RTL8723AU: %s: bDriverStopped =%d, bup =%d, hw_init_completed =%u\n",
             caller, padapter->bDriverStopped, padapter->bup, (int )padapter->hw_init_completed);
    } else {

    }
#line 557
    ret = 0;
#line 558
    goto exit;
  } else {

  }
  exit: 
#line 562
  tmp___8 = msecs_to_jiffies(ips_deffer_ms);
#line 562
  new_deny_time = tmp___8 + (unsigned long )jiffies;
#line 563
  if ((long )(pwrpriv->ips_deny_time - new_deny_time) < 0L) {
#line 564
    pwrpriv->ips_deny_time = new_deny_time;
  } else {

  }
#line 565
  return (ret);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
int rtw_pm_set_lps23a(struct rtw_adapter *padapter , u8 mode ) 
{ 
  int ret ;
  struct pwrctrl_priv *pwrctrlpriv ;

  {
#line 570
  ret = 0;
#line 571
  pwrctrlpriv = & padapter->pwrctrlpriv;
#line 573
  if ((unsigned int )mode <= 10U) {
#line 574
    if ((int )pwrctrlpriv->power_mgnt != (int )mode) {
#line 575
      if ((unsigned int )mode == 0U) {
#line 576
        LeaveAllPowerSaveMode23a(padapter);
      } else {
#line 578
        pwrctrlpriv->LpsIdleCount = 2U;
      }
#line 579
      pwrctrlpriv->power_mgnt = mode;
#line 580
      pwrctrlpriv->bLeisurePs = (unsigned int )pwrctrlpriv->power_mgnt != 0U;
    } else {

    }
  } else {
#line 585
    ret = -22;
  }
#line 587
  return (ret);
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.c"
int rtw_pm_set_ips23a(struct rtw_adapter *padapter , u8 mode ) 
{ 
  struct pwrctrl_priv *pwrctrlpriv ;
  int tmp ;

  {
#line 592
  pwrctrlpriv = & padapter->pwrctrlpriv;
#line 594
  if (((unsigned int )mode != 1U && (unsigned int )mode != 2U) && (unsigned int )mode != 0U) {
#line 595
    return (-22);
  } else {

  }
#line 597
  pwrctrlpriv->ips_mode_req = mode;
#line 598
  if ((unsigned int )mode == 0U) {
#line 599
    if (GlobalDebugLevel23A > 3U) {
#line 599
      printk("\016RTL8723AU: %s %s\n", "rtw_pm_set_ips23a", (char *)"IPS_NONE");
    } else {

    }
#line 600
    if (padapter->bSurpriseRemoved == 0) {
#line 600
      tmp = _rtw_pwr_wakeup23a(padapter, 2000U, "rtw_pm_set_ips23a");
#line 600
      if (tmp == 0) {
#line 602
        return (-14);
      } else {

      }
    } else {

    }
  } else {

  }
#line 605
  return (0);
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void disable_suitable_timer_11(struct timer_list *timer ) 
{ 


  {
#line 251
  if (ldv_timer_11_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_0) {
#line 252
    ldv_timer_11_0 = 0;
#line 253
    return;
  } else {

  }
#line 255
  if (ldv_timer_11_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_1) {
#line 256
    ldv_timer_11_1 = 0;
#line 257
    return;
  } else {

  }
#line 259
  if (ldv_timer_11_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_2) {
#line 260
    ldv_timer_11_2 = 0;
#line 261
    return;
  } else {

  }
#line 263
  if (ldv_timer_11_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_3) {
#line 264
    ldv_timer_11_3 = 0;
#line 265
    return;
  } else {

  }
#line 267
  return;
}
}
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void ldv_timer_11(int state , struct timer_list *timer ) 
{ 


  {
#line 272
  LDV_IN_INTERRUPT = 2;
#line 273
  pwr_state_check_handler(timer->data);
#line 274
  LDV_IN_INTERRUPT = 1;
#line 275
  return;
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void choose_timer_11(void) 
{ 
  int tmp ;

  {
#line 279
  tmp = __VERIFIER_nondet_int();
#line 279
  switch (tmp) {
  case 0: ;
#line 281
  if (ldv_timer_11_0 == 1) {
#line 282
    ldv_timer_11_0 = 2;
#line 283
    ldv_timer_11(ldv_timer_11_0, ldv_timer_list_11_0);
  } else {

  }
#line 286
  goto ldv_55910;
  case 1: ;
#line 288
  if (ldv_timer_11_1 == 1) {
#line 289
    ldv_timer_11_1 = 2;
#line 290
    ldv_timer_11(ldv_timer_11_1, ldv_timer_list_11_1);
  } else {

  }
#line 293
  goto ldv_55910;
  case 2: ;
#line 295
  if (ldv_timer_11_2 == 1) {
#line 296
    ldv_timer_11_2 = 2;
#line 297
    ldv_timer_11(ldv_timer_11_2, ldv_timer_list_11_2);
  } else {

  }
#line 300
  goto ldv_55910;
  case 3: ;
#line 302
  if (ldv_timer_11_3 == 1) {
#line 303
    ldv_timer_11_3 = 2;
#line 304
    ldv_timer_11(ldv_timer_11_3, ldv_timer_list_11_3);
  } else {

  }
#line 307
  goto ldv_55910;
  default: 
#line 308
  ldv_stop();
  }
  ldv_55910: ;
#line 310
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void timer_init_11(void) 
{ 


  {
#line 315
  ldv_timer_11_0 = 0;
#line 316
  ldv_timer_11_1 = 0;
#line 317
  ldv_timer_11_2 = 0;
#line 318
  ldv_timer_11_3 = 0;
#line 319
  return;
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
int reg_timer_11(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 323
  if ((unsigned long )function == (unsigned long )(& pwr_state_check_handler)) {
#line 324
    activate_suitable_timer_11(timer, data);
  } else {

  }
#line 325
  return (0);
}
}
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void activate_pending_timer_11(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 330
  if ((unsigned long )ldv_timer_list_11_0 == (unsigned long )timer) {
#line 331
    if (ldv_timer_11_0 == 2 || pending_flag != 0) {
#line 332
      ldv_timer_list_11_0 = timer;
#line 333
      ldv_timer_list_11_0->data = data;
#line 334
      ldv_timer_11_0 = 1;
    } else {

    }
#line 336
    return;
  } else {

  }
#line 339
  if ((unsigned long )ldv_timer_list_11_1 == (unsigned long )timer) {
#line 340
    if (ldv_timer_11_1 == 2 || pending_flag != 0) {
#line 341
      ldv_timer_list_11_1 = timer;
#line 342
      ldv_timer_list_11_1->data = data;
#line 343
      ldv_timer_11_1 = 1;
    } else {

    }
#line 345
    return;
  } else {

  }
#line 348
  if ((unsigned long )ldv_timer_list_11_2 == (unsigned long )timer) {
#line 349
    if (ldv_timer_11_2 == 2 || pending_flag != 0) {
#line 350
      ldv_timer_list_11_2 = timer;
#line 351
      ldv_timer_list_11_2->data = data;
#line 352
      ldv_timer_11_2 = 1;
    } else {

    }
#line 354
    return;
  } else {

  }
#line 357
  if ((unsigned long )ldv_timer_list_11_3 == (unsigned long )timer) {
#line 358
    if (ldv_timer_11_3 == 2 || pending_flag != 0) {
#line 359
      ldv_timer_list_11_3 = timer;
#line 360
      ldv_timer_list_11_3->data = data;
#line 361
      ldv_timer_11_3 = 1;
    } else {

    }
#line 363
    return;
  } else {

  }
#line 365
  activate_suitable_timer_11(timer, data);
#line 366
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void activate_suitable_timer_11(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 370
  if (ldv_timer_11_0 == 0 || ldv_timer_11_0 == 2) {
#line 371
    ldv_timer_list_11_0 = timer;
#line 372
    ldv_timer_list_11_0->data = data;
#line 373
    ldv_timer_11_0 = 1;
#line 374
    return;
  } else {

  }
#line 376
  if (ldv_timer_11_1 == 0 || ldv_timer_11_1 == 2) {
#line 377
    ldv_timer_list_11_1 = timer;
#line 378
    ldv_timer_list_11_1->data = data;
#line 379
    ldv_timer_11_1 = 1;
#line 380
    return;
  } else {

  }
#line 382
  if (ldv_timer_11_2 == 0 || ldv_timer_11_2 == 2) {
#line 383
    ldv_timer_list_11_2 = timer;
#line 384
    ldv_timer_list_11_2->data = data;
#line 385
    ldv_timer_11_2 = 1;
#line 386
    return;
  } else {

  }
#line 388
  if (ldv_timer_11_3 == 0 || ldv_timer_11_3 == 2) {
#line 389
    ldv_timer_list_11_3 = timer;
#line 390
    ldv_timer_list_11_3->data = data;
#line 391
    ldv_timer_11_3 = 1;
#line 392
    return;
  } else {

  }
#line 394
  return;
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
bool ldv_queue_work_on_153(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 425
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 425
  ldv_func_res = tmp;
#line 427
  activate_work_2(ldv_func_arg3, 2);
#line 429
  return (ldv_func_res);
}
}
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
bool ldv_queue_delayed_work_on_154(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 436
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 436
  ldv_func_res = tmp;
#line 438
  activate_work_2(& ldv_func_arg3->work, 2);
#line 440
  return (ldv_func_res);
}
}
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
bool ldv_queue_work_on_155(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 447
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 447
  ldv_func_res = tmp;
#line 449
  activate_work_2(ldv_func_arg3, 2);
#line 451
  return (ldv_func_res);
}
}
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void ldv_flush_workqueue_156(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 457
  flush_workqueue(ldv_func_arg1);
#line 459
  call_and_disable_all_2(2);
#line 460
  return;
}
}
#line 462 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
bool ldv_queue_delayed_work_on_157(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 466
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 466
  ldv_func_res = tmp;
#line 468
  activate_work_2(& ldv_func_arg3->work, 2);
#line 470
  return (ldv_func_res);
}
}
#line 473 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
int ldv_mod_timer_158(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 477
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 477
  ldv_func_res = tmp;
#line 479
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 481
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 61 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 63
  __list_add(new, head, head->next);
#line 64
  return;
}
}
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField18.rlock);
#line 313
  return;
}
}
#line 355 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 357
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
#line 358
  return;
}
}
#line 173 "include/linux/timer.h"
int ldv_mod_timer_174(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 177
int ldv_mod_timer_175(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 181
int ldv_mod_timer_177(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 185
int ldv_mod_timer_178(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 232
int ldv_del_timer_sync_176(struct timer_list *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_169(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_171(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_170(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_173(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_172(struct workqueue_struct *ldv_func_arg1 ) ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
struct timer_list *ldv_timer_list_12_1 ;
#line 53
int ldv_timer_12_3 ;
#line 97
struct timer_list *ldv_timer_list_12_0 ;
#line 100
int ldv_timer_12_0 ;
#line 102
int ldv_timer_12_2 ;
#line 110
struct timer_list *ldv_timer_list_12_3 ;
#line 119
int ldv_timer_12_1 ;
#line 135
struct timer_list *ldv_timer_list_12_2 ;
#line 160
void timer_init_12(void) ;
#line 162
int reg_timer_12(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 175
void activate_pending_timer_12(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 180
void ldv_timer_12(int state , struct timer_list *timer ) ;
#line 192
void activate_suitable_timer_12(struct timer_list *timer , unsigned long data ) ;
#line 220
void choose_timer_12(void) ;
#line 242
void disable_suitable_timer_12(struct timer_list *timer ) ;
#line 1011 "include/linux/skbuff.h"
__inline static int skb_queue_empty(struct sk_buff_head  const  *list ) 
{ 


  {
#line 1013
  return ((unsigned long )((struct sk_buff  const  *)list->next) == (unsigned long )((struct sk_buff  const  *)list));
}
}
#line 1259 "include/linux/skbuff.h"
__inline static struct sk_buff *skb_peek(struct sk_buff_head  const  *list_ ) 
{ 
  struct sk_buff *skb ;

  {
#line 1261
  skb = list_->next;
#line 1263
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)list_)) {
#line 1264
    skb = (struct sk_buff *)0;
  } else {

  }
#line 1265
  return (skb);
}
}
#line 1331 "include/linux/skbuff.h"
__inline static void __skb_queue_head_init(struct sk_buff_head *list ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1333
  tmp = (struct sk_buff *)list;
#line 1333
  list->next = tmp;
#line 1333
  list->prev = tmp;
#line 1334
  list->qlen = 0U;
#line 1335
  return;
}
}
#line 1520 "include/linux/skbuff.h"
__inline static void __skb_unlink(struct sk_buff *skb , struct sk_buff_head *list ) 
{ 
  struct sk_buff *next ;
  struct sk_buff *prev ;
  struct sk_buff *tmp ;

  {
#line 1524
  list->qlen = list->qlen - 1U;
#line 1525
  next = skb->__annonCompField79.__annonCompField78.next;
#line 1526
  prev = skb->__annonCompField79.__annonCompField78.prev;
#line 1527
  tmp = (struct sk_buff *)0;
#line 1527
  skb->__annonCompField79.__annonCompField78.prev = tmp;
#line 1527
  skb->__annonCompField79.__annonCompField78.next = tmp;
#line 1528
  next->__annonCompField79.__annonCompField78.prev = prev;
#line 1529
  prev->__annonCompField79.__annonCompField78.next = next;
#line 1530
  return;
}
}
#line 1541 "include/linux/skbuff.h"
__inline static struct sk_buff *__skb_dequeue(struct sk_buff_head *list ) 
{ 
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
#line 1543
  tmp = skb_peek((struct sk_buff_head  const  *)list);
#line 1543
  skb = tmp;
#line 1544
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 1545
    __skb_unlink(skb, list);
  } else {

  }
#line 1546
  return (skb);
}
}
#line 1654 "include/linux/skbuff.h"
__inline static unsigned char *skb_tail_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 1656
  return ((unsigned char *)skb->head + (unsigned long )skb->tail);
}
}
#line 1692
extern unsigned char *skb_put(struct sk_buff * , unsigned int  ) ;
#line 1710
extern unsigned char *skb_pull(struct sk_buff * , unsigned int  ) ;
#line 2061
extern void skb_trim(struct sk_buff * , unsigned int  ) ;
#line 2900 "include/linux/netdevice.h"
extern void __dev_kfree_skb_any(struct sk_buff * , enum skb_free_reason  ) ;
#line 2931 "include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb ) 
{ 


  {
#line 2933
  __dev_kfree_skb_any(skb, 1);
#line 2934
  return;
}
}
#line 2941
extern int netif_rx(struct sk_buff * ) ;
#line 33 "include/linux/etherdevice.h"
extern __be16 eth_type_trans(struct sk_buff * , struct net_device * ) ;
#line 253 "include/linux/ieee80211.h"
__inline static int ieee80211_has_tods(__le16 fc ) 
{ 


  {
#line 255
  return (((int )fc & 256) != 0);
}
}
#line 262 "include/linux/ieee80211.h"
__inline static int ieee80211_has_fromds(__le16 fc ) 
{ 


  {
#line 264
  return (((int )fc & 512) != 0);
}
}
#line 271 "include/linux/ieee80211.h"
__inline static int ieee80211_has_a4(__le16 fc ) 
{ 
  __le16 tmp ;

  {
#line 273
  tmp = 768U;
#line 274
  return (((int )fc & (int )tmp) == (int )tmp);
}
}
#line 281 "include/linux/ieee80211.h"
__inline static int ieee80211_has_morefrags(__le16 fc ) 
{ 


  {
#line 283
  return (((int )fc & 1024) != 0);
}
}
#line 299 "include/linux/ieee80211.h"
__inline static int ieee80211_has_pm(__le16 fc ) 
{ 


  {
#line 301
  return (((int )fc & 4096) != 0);
}
}
#line 308 "include/linux/ieee80211.h"
__inline static int ieee80211_has_moredata(__le16 fc ) 
{ 


  {
#line 310
  return (((int )fc & 8192) != 0);
}
}
#line 317 "include/linux/ieee80211.h"
__inline static int ieee80211_has_protected(__le16 fc ) 
{ 


  {
#line 319
  return (((int )fc & 16384) != 0);
}
}
#line 326 "include/linux/ieee80211.h"
__inline static int ieee80211_has_order(__le16 fc ) 
{ 


  {
#line 328
  return ((int )((short )fc) < 0);
}
}
#line 345 "include/linux/ieee80211.h"
__inline static int ieee80211_is_ctl(__le16 fc ) 
{ 


  {
#line 347
  return (((int )fc & 12) == 4);
}
}
#line 355 "include/linux/ieee80211.h"
__inline static int ieee80211_is_data(__le16 fc ) 
{ 


  {
#line 357
  return (((int )fc & 12) == 8);
}
}
#line 365 "include/linux/ieee80211.h"
__inline static int ieee80211_is_data_qos(__le16 fc ) 
{ 


  {
#line 371
  return (((int )fc & 140) == 136);
}
}
#line 533 "include/linux/ieee80211.h"
__inline static int ieee80211_is_pspoll(__le16 fc ) 
{ 


  {
#line 535
  return (((int )fc & 252) == 164);
}
}
#line 593 "include/linux/ieee80211.h"
__inline static int ieee80211_is_nullfunc(__le16 fc ) 
{ 


  {
#line 595
  return (((int )fc & 252) == 72);
}
}
#line 2329 "include/linux/ieee80211.h"
__inline static u8 *ieee80211_get_qos_ctl(struct ieee80211_hdr *hdr ) 
{ 
  int tmp ;

  {
#line 2331
  tmp = ieee80211_has_a4((int )hdr->frame_control);
#line 2331
  if (tmp != 0) {
#line 2332
    return ((u8 *)hdr + 30UL);
  } else {
#line 2334
    return ((u8 *)hdr + 24UL);
  }
}
}
#line 2347 "include/linux/ieee80211.h"
__inline static u8 *ieee80211_get_SA(struct ieee80211_hdr *hdr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2349
  tmp = ieee80211_has_a4((int )hdr->frame_control);
#line 2349
  if (tmp != 0) {
#line 2350
    return ((u8 *)(& hdr->addr4));
  } else {

  }
#line 2351
  tmp___0 = ieee80211_has_fromds((int )hdr->frame_control);
#line 2351
  if (tmp___0 != 0) {
#line 2352
    return ((u8 *)(& hdr->addr3));
  } else {

  }
#line 2353
  return ((u8 *)(& hdr->addr2));
}
}
#line 2366 "include/linux/ieee80211.h"
__inline static u8 *ieee80211_get_DA(struct ieee80211_hdr *hdr ) 
{ 
  int tmp ;

  {
#line 2368
  tmp = ieee80211_has_tods((int )hdr->frame_control);
#line 2368
  if (tmp != 0) {
#line 2369
    return ((u8 *)(& hdr->addr3));
  } else {
#line 2371
    return ((u8 *)(& hdr->addr1));
  }
}
}
#line 3667 "include/net/cfg80211.h"
extern unsigned char const   rfc1042_header[6U] ;
#line 3668
extern unsigned char const   bridge_tunnel_header[6U] ;
#line 3746
extern void ieee80211_amsdu_to_8023s(struct sk_buff * , struct sk_buff_head * , u8 const   * ,
                                     enum nl80211_iftype  , unsigned int const    ,
                                     bool  ) ;
#line 68 "drivers/staging/rtl8723au/include/osdep_service.h"
__inline static u32 CHKBIT(u32 x ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
#line 70
  __ret_warn_on = x > 31U;
#line 70
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 70
  if (tmp != 0L) {
#line 70
    warn_slowpath_null("drivers/staging/rtl8723au/include/osdep_service.h", 70);
  } else {

  }
#line 70
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (x > 31U) {
#line 72
    return (0U);
  } else {

  }
#line 73
  return ((u32 )(1UL << (int )x));
}
}
#line 373 "drivers/staging/rtl8723au/include/rtw_xmit.h"
void stop_sta_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 374
void wakeup_sta_to_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 375
void xmit_delivery_enabled_frames23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 275 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct recv_frame *rtw_alloc_recvframe23a(struct rtw_queue *pfree_recv_queue ) ;
#line 276
int rtw_free_recvframe23a(struct recv_frame *precvframe ) ;
#line 278
int rtw_enqueue_recvframe23a(struct recv_frame *precvframe , struct rtw_queue *queue ) ;
#line 282
int rtw_enqueue_recvbuf23a_to_head(struct recv_buf *precvbuf , struct rtw_queue *queue ) ;
#line 283
int rtw_enqueue_recvbuf23a(struct recv_buf *precvbuf , struct rtw_queue *queue ) ;
#line 284
struct recv_buf *rtw_dequeue_recvbuf23a(struct rtw_queue *queue ) ;
#line 286
void rtw_reordering_ctrl_timeout_handler23a(unsigned long pcontext ) ;
#line 302
void _rtw_init_sta_recv_priv23a(struct sta_recv_priv *psta_recvpriv ) ;
#line 314 "drivers/staging/rtl8723au/include/rtw_security.h"
void rtw_seccalctkipmic23a(u8 *key , u8 *header , u8 *data , u32 data_len , u8 *mic_code ,
                           u8 pri ) ;
#line 323
int rtw_aes_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) ;
#line 325
int rtw_tkip_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) ;
#line 327
void rtw_wep_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) ;
#line 224 "drivers/staging/rtl8723au/include/rtw_mlme.h"
__inline static u8 *get_bssid(struct mlme_priv *pmlmepriv ) 
{ 


  {
#line 227
  return ((u8 *)(& pmlmepriv->cur_network.network.MacAddress));
}
}
#line 21 "drivers/staging/rtl8723au/include/recv_osdep.h"
int _rtw_init_recv_priv23a(struct recv_priv *precvpriv , struct rtw_adapter *padapter ) ;
#line 22
void _rtw_free_recv_priv23a(struct recv_priv *precvpriv ) ;
#line 24
int rtw_recv_entry23a(struct recv_frame *rframe ) ;
#line 25
int rtw_recv_indicatepkt23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 27
void rtw_handle_tkip_mic_err23a(struct rtw_adapter *padapter , u8 bgroup ) ;
#line 59 "drivers/staging/rtl8723au/include/rtl8723a_recv.h"
int rtl8723au_init_recv_priv(struct rtw_adapter *padapter ) ;
#line 60
void rtl8723au_free_recv_priv(struct rtw_adapter *padapter ) ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
void rtw_signal_stat_timer_hdl23a(unsigned long data ) ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
void _rtw_init_sta_recv_priv23a(struct sta_recv_priv *psta_recvpriv ) 
{ 
  struct lock_class_key __key ;

  {
#line 35
  spinlock_check(& psta_recvpriv->lock);
#line 35
  __raw_spin_lock_init(& psta_recvpriv->lock.__annonCompField18.rlock, "&(&psta_recvpriv->lock)->rlock",
                       & __key);
#line 40
  _rtw_init_queue23a(& psta_recvpriv->defrag_q);
#line 41
  return;
}
}
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int _rtw_init_recv_priv23a(struct recv_priv *precvpriv , struct rtw_adapter *padapter ) 
{ 
  struct recv_frame *precvframe ;
  int i ;
  int res ;
  struct lock_class_key __key ;
  void *tmp ;
  unsigned long tmp___0 ;

  {
#line 50
  res = 1;
#line 52
  spinlock_check(& precvpriv->lock);
#line 52
  __raw_spin_lock_init(& precvpriv->lock.__annonCompField18.rlock, "&(&precvpriv->lock)->rlock",
                       & __key);
#line 54
  _rtw_init_queue23a(& precvpriv->free_recv_queue);
#line 55
  _rtw_init_queue23a(& precvpriv->recv_pending_queue);
#line 56
  _rtw_init_queue23a(& precvpriv->uc_swdec_pending_queue);
#line 58
  precvpriv->adapter = padapter;
#line 60
  i = 0;
#line 60
  goto ldv_53464;
  ldv_53463: 
#line 61
  tmp = kzalloc(144UL, 208U);
#line 61
  precvframe = (struct recv_frame *)tmp;
#line 62
  if ((unsigned long )precvframe == (unsigned long )((struct recv_frame *)0)) {
#line 63
    goto ldv_53462;
  } else {

  }
#line 64
  INIT_LIST_HEAD(& precvframe->list);
#line 66
  list_add_tail(& precvframe->list, & precvpriv->free_recv_queue.queue);
#line 69
  precvframe->adapter = padapter;
#line 70
  precvframe = precvframe + 1;
#line 60
  i = i + 1;
  ldv_53464: ;
#line 60
  if (i <= 255) {
#line 62
    goto ldv_53463;
  } else {

  }
  ldv_53462: 
#line 73
  precvpriv->free_recvframe_cnt = i;
#line 74
  precvpriv->rx_pending_cnt = 1U;
#line 76
  res = rtl8723au_init_recv_priv(padapter);
#line 78
  reg_timer_11(& precvpriv->signal_stat_timer, & rtw_signal_stat_timer_hdl23a, (unsigned long )padapter);
#line 81
  precvpriv->signal_stat_sampling_interval = 1000U;
#line 83
  tmp___0 = msecs_to_jiffies(precvpriv->signal_stat_sampling_interval);
#line 83
  ldv_mod_timer_174(& precvpriv->signal_stat_timer, tmp___0 + (unsigned long )jiffies);
#line 85
  return (res);
}
}
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
void _rtw_free_recv_priv23a(struct recv_priv *precvpriv ) 
{ 
  struct rtw_adapter *padapter ;
  struct recv_frame *precvframe ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct list_head  const  *__mptr ;

  {
#line 90
  padapter = precvpriv->adapter;
#line 94
  rtw_free_uc_swdec_pending_queue23a(padapter);
#line 96
  plist = precvpriv->free_recv_queue.queue.next;
#line 96
  ptmp = plist->next;
#line 96
  goto ldv_53475;
  ldv_53474: 
#line 97
  __mptr = (struct list_head  const  *)plist;
#line 97
  precvframe = (struct recv_frame *)__mptr;
#line 98
  list_del_init(& precvframe->list);
#line 99
  kfree((void const   *)precvframe);
#line 96
  plist = ptmp;
#line 96
  ptmp = plist->next;
  ldv_53475: ;
#line 96
  if ((unsigned long )(& precvpriv->free_recv_queue.queue) != (unsigned long )plist) {
#line 98
    goto ldv_53474;
  } else {

  }
#line 102
  rtl8723au_free_recv_priv(padapter);
#line 103
  return;
}
}
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
struct recv_frame *rtw_alloc_recvframe23a(struct rtw_queue *pfree_recv_queue ) 
{ 
  struct recv_frame *pframe ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 112
  spin_lock_bh(& pfree_recv_queue->lock);
#line 114
  tmp = list_empty((struct list_head  const  *)(& pfree_recv_queue->queue));
#line 114
  if (tmp != 0) {
#line 115
    pframe = (struct recv_frame *)0;
  } else {
#line 117
    phead = get_list_head(pfree_recv_queue);
#line 119
    plist = phead->next;
#line 121
    __mptr = (struct list_head  const  *)plist;
#line 121
    pframe = (struct recv_frame *)__mptr;
#line 123
    list_del_init(& pframe->list);
#line 124
    padapter = pframe->adapter;
#line 125
    if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
#line 126
      precvpriv = & padapter->recvpriv;
#line 127
      if ((unsigned long )(& precvpriv->free_recv_queue) == (unsigned long )pfree_recv_queue) {
#line 128
        precvpriv->free_recvframe_cnt = precvpriv->free_recvframe_cnt - 1;
      } else {

      }
    } else {

    }
  }
#line 132
  spin_unlock_bh(& pfree_recv_queue->lock);
#line 134
  return (pframe);
}
}
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int rtw_free_recvframe23a(struct recv_frame *precvframe ) 
{ 
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  struct rtw_queue *pfree_recv_queue ;
  struct list_head *tmp ;

  {
#line 139
  padapter = precvframe->adapter;
#line 140
  precvpriv = & padapter->recvpriv;
#line 143
  if ((unsigned long )precvframe->pkt != (unsigned long )((struct sk_buff *)0)) {
#line 144
    dev_kfree_skb_any(precvframe->pkt);
#line 145
    precvframe->pkt = (struct sk_buff *)0;
  } else {

  }
#line 148
  pfree_recv_queue = & precvpriv->free_recv_queue;
#line 149
  spin_lock_bh(& pfree_recv_queue->lock);
#line 151
  list_del_init(& precvframe->list);
#line 153
  tmp = get_list_head(pfree_recv_queue);
#line 153
  list_add_tail(& precvframe->list, tmp);
#line 155
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
#line 156
    if ((unsigned long )(& precvpriv->free_recv_queue) == (unsigned long )pfree_recv_queue) {
#line 157
      precvpriv->free_recvframe_cnt = precvpriv->free_recvframe_cnt + 1;
    } else {

    }
  } else {

  }
#line 160
  spin_unlock_bh(& pfree_recv_queue->lock);
#line 164
  return (1);
}
}
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int rtw_enqueue_recvframe23a(struct recv_frame *precvframe , struct rtw_queue *queue ) 
{ 
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  struct list_head *tmp ;

  {
#line 169
  padapter = precvframe->adapter;
#line 170
  precvpriv = & padapter->recvpriv;
#line 172
  spin_lock_bh(& queue->lock);
#line 174
  list_del_init(& precvframe->list);
#line 176
  tmp = get_list_head(queue);
#line 176
  list_add_tail(& precvframe->list, tmp);
#line 178
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
#line 179
    if ((unsigned long )(& precvpriv->free_recv_queue) == (unsigned long )queue) {
#line 180
      precvpriv->free_recvframe_cnt = precvpriv->free_recvframe_cnt + 1;
    } else {

    }
  } else {

  }
#line 183
  spin_unlock_bh(& queue->lock);
#line 185
  return (1);
}
}
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
static void rtw_free_recvframe23a_queue(struct rtw_queue *pframequeue ) 
{ 
  struct recv_frame *hdr ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct list_head  const  *__mptr ;

  {
#line 201
  spin_lock(& pframequeue->lock);
#line 203
  phead = get_list_head(pframequeue);
#line 204
  plist = phead->next;
#line 206
  plist = phead->next;
#line 206
  ptmp = plist->next;
#line 206
  goto ldv_53509;
  ldv_53508: 
#line 207
  __mptr = (struct list_head  const  *)plist;
#line 207
  hdr = (struct recv_frame *)__mptr;
#line 208
  rtw_free_recvframe23a(hdr);
#line 206
  plist = ptmp;
#line 206
  ptmp = plist->next;
  ldv_53509: ;
#line 206
  if ((unsigned long )plist != (unsigned long )phead) {
#line 208
    goto ldv_53508;
  } else {

  }
#line 211
  spin_unlock(& pframequeue->lock);
#line 212
  return;
}
}
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
u32 rtw_free_uc_swdec_pending_queue23a(struct rtw_adapter *adapter ) 
{ 
  u32 cnt ;
  struct recv_frame *pending_frame ;

  {
#line 216
  cnt = 0U;
#line 219
  goto ldv_53518;
  ldv_53517: 
#line 220
  rtw_free_recvframe23a(pending_frame);
#line 221
  if (GlobalDebugLevel23A > 3U) {
#line 221
    printk("\016RTL8723AU: %s: dequeue uc_swdec_pending_queue\n", "rtw_free_uc_swdec_pending_queue23a");
  } else {

  }
#line 222
  cnt = cnt + 1U;
  ldv_53518: 
#line 219
  pending_frame = rtw_alloc_recvframe23a(& adapter->recvpriv.uc_swdec_pending_queue);
#line 219
  if ((unsigned long )pending_frame != (unsigned long )((struct recv_frame *)0)) {
#line 221
    goto ldv_53517;
  } else {

  }

#line 225
  return (cnt);
}
}
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int rtw_enqueue_recvbuf23a_to_head(struct recv_buf *precvbuf , struct rtw_queue *queue ) 
{ 
  struct list_head *tmp ;

  {
#line 230
  spin_lock_bh(& queue->lock);
#line 232
  list_del_init(& precvbuf->list);
#line 233
  tmp = get_list_head(queue);
#line 233
  list_add(& precvbuf->list, tmp);
#line 235
  spin_unlock_bh(& queue->lock);
#line 237
  return (1);
}
}
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int rtw_enqueue_recvbuf23a(struct recv_buf *precvbuf , struct rtw_queue *queue ) 
{ 
  unsigned long irqL ;
  raw_spinlock_t *tmp ;
  struct list_head *tmp___0 ;

  {
#line 244
  tmp = spinlock_check(& queue->lock);
#line 244
  irqL = _raw_spin_lock_irqsave(tmp);
#line 246
  list_del_init(& precvbuf->list);
#line 248
  tmp___0 = get_list_head(queue);
#line 248
  list_add_tail(& precvbuf->list, tmp___0);
#line 249
  spin_unlock_irqrestore(& queue->lock, irqL);
#line 250
  return (1);
}
}
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
struct recv_buf *rtw_dequeue_recvbuf23a(struct rtw_queue *queue ) 
{ 
  unsigned long irqL ;
  struct recv_buf *precvbuf ;
  struct list_head *plist ;
  struct list_head *phead ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
#line 259
  tmp = spinlock_check(& queue->lock);
#line 259
  irqL = _raw_spin_lock_irqsave(tmp);
#line 261
  tmp___0 = list_empty((struct list_head  const  *)(& queue->queue));
#line 261
  if (tmp___0 != 0) {
#line 262
    precvbuf = (struct recv_buf *)0;
  } else {
#line 264
    phead = get_list_head(queue);
#line 266
    plist = phead->next;
#line 268
    __mptr = (struct list_head  const  *)plist;
#line 268
    precvbuf = (struct recv_buf *)__mptr;
#line 270
    list_del_init(& precvbuf->list);
  }
#line 273
  spin_unlock_irqrestore(& queue->lock, irqL);
#line 275
  return (precvbuf);
}
}
#line 278
int recvframe_chkmic(struct rtw_adapter *adapter , struct recv_frame *precvframe ) ;
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int recvframe_chkmic(struct rtw_adapter *adapter , struct recv_frame *precvframe ) 
{ 
  int i ;
  int res ;
  u32 datalen ;
  u8 miccode[8U] ;
  u8 bmic_err ;
  u8 brpt_micerror ;
  u8 *pframe ;
  u8 *payload ;
  u8 *pframemic ;
  u8 *mickey ;
  struct sta_info *stainfo ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool tmp ;
  int i___0 ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
#line 283
  res = 1;
#line 286
  bmic_err = 0U;
#line 286
  brpt_micerror = 1U;
#line 291
  prxattrib = & precvframe->attrib;
#line 292
  psecuritypriv = & adapter->securitypriv;
#line 294
  pmlmeext = & adapter->mlmeextpriv;
#line 295
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 298
  stainfo = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& prxattrib->ta));
#line 300
  if (prxattrib->encrypt == 1027074U) {
#line 301
    if (GlobalDebugLevel23A > 6U) {
#line 301
      rt_trace(4, 7, "recvframe_chkmic:prxattrib->encrypt == WLAN_CIPHER_SUITE_TKIP\n");
    } else {

    }
#line 303
    if (GlobalDebugLevel23A > 6U) {
#line 303
      rt_trace(4, 7, "recvframe_chkmic:da = %pM\n", (u8 *)(& prxattrib->ra));
    } else {

    }
#line 307
    if ((unsigned long )stainfo != (unsigned long )((struct sta_info *)0)) {
#line 308
      tmp = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
#line 308
      if ((int )tmp) {
#line 309
        mickey = (u8 *)(& psecuritypriv->dot118021XGrprxmickey[(int )prxattrib->key_index].skey);
#line 311
        if (GlobalDebugLevel23A > 6U) {
#line 311
          rt_trace(4, 7, "recvframe_chkmic: bcmc key\n");
        } else {

        }
#line 314
        if ((unsigned int )*((unsigned char *)psecuritypriv + 580UL) == 0U) {
#line 315
          res = 0;
#line 316
          if (GlobalDebugLevel23A > 3U) {
#line 316
            rt_trace(4, 4, "recvframe_chkmic:didn\'t install group key!\n");
          } else {

          }
#line 319
          if (GlobalDebugLevel23A > 3U) {
#line 319
            printk("\016RTL8723AU: \n recvframe_chkmic:didn\'t install group key!!!!!!\n");
          } else {

          }
#line 321
          goto exit;
        } else {

        }
      } else {
#line 324
        mickey = (u8 *)(& stainfo->dot11tkiprxmickey.skey);
#line 325
        if (GlobalDebugLevel23A > 3U) {
#line 325
          rt_trace(4, 4, "recvframe_chkmic: unicast key\n");
        } else {

        }
      }
#line 330
      datalen = ((((precvframe->pkt)->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len) - (unsigned int )prxattrib->icv_len) - 8U;
#line 332
      pframe = (precvframe->pkt)->data;
#line 333
      payload = pframe + ((unsigned long )prxattrib->hdrlen + (unsigned long )prxattrib->iv_len);
#line 336
      if (GlobalDebugLevel23A > 6U) {
#line 336
        rt_trace(4, 7, "prxattrib->iv_len =%d prxattrib->icv_len =%d\n", (int )prxattrib->iv_len,
                 (int )prxattrib->icv_len);
      } else {

      }
#line 341
      rtw_seccalctkipmic23a(mickey, pframe, payload, datalen, (u8 *)(& miccode), (int )prxattrib->priority);
#line 345
      pframemic = payload + (unsigned long )datalen;
#line 347
      bmic_err = 0U;
#line 349
      i = 0;
#line 349
      goto ldv_53568;
      ldv_53567: ;
#line 350
      if ((int )miccode[i] != (int )*(pframemic + (unsigned long )i)) {
#line 351
        if (GlobalDebugLevel23A > 3U) {
#line 351
          rt_trace(4, 4, "recvframe_chkmic:miccode[%d](%02x) != *(pframemic+%d)(%02x)\n",
                   i, (int )miccode[i], i, (int )*(pframemic + (unsigned long )i));
        } else {

        }
#line 356
        bmic_err = 1U;
      } else {

      }
#line 349
      i = i + 1;
      ldv_53568: ;
#line 349
      if (i <= 7) {
#line 351
        goto ldv_53567;
      } else {

      }

#line 360
      if ((unsigned int )bmic_err == 1U) {
#line 363
        if (GlobalDebugLevel23A > 3U) {
#line 363
          rt_trace(4, 4, "*(pframemic-8)-*(pframemic-1) =0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
                   (int )*(pframemic + 0xfffffffffffffff8UL), (int )*(pframemic + 0xfffffffffffffff9UL),
                   (int )*(pframemic + 0xfffffffffffffffaUL), (int )*(pframemic + 0xfffffffffffffffbUL),
                   (int )*(pframemic + 0xfffffffffffffffcUL), (int )*(pframemic + 0xfffffffffffffffdUL),
                   (int )*(pframemic + 0xfffffffffffffffeUL), (int )*(pframemic + 0xffffffffffffffffUL));
        } else {

        }
#line 369
        if (GlobalDebugLevel23A > 3U) {
#line 369
          rt_trace(4, 4, "*(pframemic-16)-*(pframemic-9) =0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
                   (int )*(pframemic + 0xfffffffffffffff0UL), (int )*(pframemic + 0xfffffffffffffff1UL),
                   (int )*(pframemic + 0xfffffffffffffff2UL), (int )*(pframemic + 0xfffffffffffffff3UL),
                   (int )*(pframemic + 0xfffffffffffffff4UL), (int )*(pframemic + 0xfffffffffffffff5UL),
                   (int )*(pframemic + 0xfffffffffffffff6UL), (int )*(pframemic + 0xfffffffffffffff7UL));
        } else {

        }
#line 376
        if (GlobalDebugLevel23A > 3U) {
#line 376
          rt_trace(4, 4, "====== demp packet (len =%d) ======\n", (precvframe->pkt)->len);
        } else {

        }
#line 379
        i___0 = 0;
#line 379
        goto ldv_53572;
        ldv_53571: ;
#line 380
        if (GlobalDebugLevel23A > 3U) {
#line 380
          rt_trace(4, 4, "0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
                   (int )*((precvframe->pkt)->data + (unsigned long )i___0), (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 1UL)),
                   (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 2UL)),
                   (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 3UL)),
                   (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 4UL)),
                   (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 5UL)),
                   (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 6UL)),
                   (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 7UL)));
        } else {

        }
#line 379
        i___0 = i___0 + 8;
        ldv_53572: ;
#line 379
        if ((unsigned int )i___0 < (precvframe->pkt)->len) {
#line 381
          goto ldv_53571;
        } else {

        }

#line 392
        if (GlobalDebugLevel23A > 3U) {
#line 392
          rt_trace(4, 4, "====== demp packet end [len =%d]======\n", (precvframe->pkt)->len);
        } else {

        }
#line 395
        if (GlobalDebugLevel23A > 3U) {
#line 395
          rt_trace(4, 4, "hrdlen =%d\n", (int )prxattrib->hdrlen);
        } else {

        }
#line 398
        if (GlobalDebugLevel23A > 3U) {
#line 398
          rt_trace(4, 4, "ra = %pM psecuritypriv->binstallGrpkey =%d\n", (u8 *)(& prxattrib->ra),
                   (int )psecuritypriv->binstallGrpkey);
        } else {

        }
#line 407
        tmp___0 = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
#line 407
        if ((int )tmp___0 && (u32 )prxattrib->key_index != pmlmeinfo->key_index) {
#line 410
          brpt_micerror = 0U;
        } else {

        }
#line 412
        if ((unsigned int )prxattrib->bdecrypted == 1U && (unsigned int )brpt_micerror == 1U) {
#line 414
          tmp___1 = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
#line 414
          rtw_handle_tkip_mic_err23a(adapter, (int )tmp___1);
#line 415
          if (GlobalDebugLevel23A > 3U) {
#line 415
            rt_trace(4, 4, "mic error :prxattrib->bdecrypted =%d\n", (int )prxattrib->bdecrypted);
          } else {

          }
#line 418
          if (GlobalDebugLevel23A > 3U) {
#line 418
            printk("\016RTL8723AU:  mic error :prxattrib->bdecrypted =%d\n", (int )prxattrib->bdecrypted);
          } else {

          }
        } else {
#line 422
          if (GlobalDebugLevel23A > 3U) {
#line 422
            rt_trace(4, 4, "mic error :prxattrib->bdecrypted =%d\n", (int )prxattrib->bdecrypted);
          } else {

          }
#line 426
          if (GlobalDebugLevel23A > 3U) {
#line 426
            printk("\016RTL8723AU:  mic error :prxattrib->bdecrypted =%d\n", (int )prxattrib->bdecrypted);
          } else {

          }
        }
#line 431
        res = 0;
      } else
#line 434
      if ((unsigned int )*((unsigned char *)psecuritypriv + 580UL) == 0U) {
#line 434
        tmp___2 = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
#line 434
        if ((int )tmp___2) {
#line 436
          psecuritypriv->bcheck_grpkey = 1U;
#line 437
          if (GlobalDebugLevel23A > 3U) {
#line 437
            rt_trace(4, 4, "psecuritypriv->bcheck_grpkey = true\n");
          } else {

          }
        } else {

        }
      } else {

      }
    } else
#line 443
    if (GlobalDebugLevel23A > 3U) {
#line 443
      rt_trace(4, 4, "recvframe_chkmic: rtw_get_stainfo23a ==NULL!!!\n");
    } else {

    }
#line 447
    skb_trim(precvframe->pkt, (precvframe->pkt)->len - 8U);
  } else {

  }
  exit: ;
#line 454
  return (res);
}
}
#line 458
struct recv_frame *decryptor(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 460 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
struct recv_frame *decryptor(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct recv_frame *return_packet ;
  int res ;
  u8 *iv ;

  {
#line 463
  prxattrib = & precv_frame->attrib;
#line 464
  psecuritypriv = & padapter->securitypriv;
#line 465
  return_packet = precv_frame;
#line 466
  res = 1;
#line 468
  if (GlobalDebugLevel23A > 6U) {
#line 468
    rt_trace(4, 7, "prxstat->decrypted =%x prxattrib->encrypt = 0x%03x\n", (int )prxattrib->bdecrypted,
             prxattrib->encrypt);
  } else {

  }
#line 472
  if (prxattrib->encrypt != 0U) {
#line 473
    iv = (precv_frame->pkt)->data + (unsigned long )prxattrib->hdrlen;
#line 475
    prxattrib->key_index = (u8 )((int )*(iv + 3UL) >> 6);
#line 477
    if ((unsigned int )prxattrib->key_index > 4U) {
#line 478
      if (GlobalDebugLevel23A > 3U) {
#line 478
        printk("\016RTL8723AU: prxattrib->key_index(%d) > WEP_KEYS\n", (int )prxattrib->key_index);
      } else {

      }
#line 481
      switch (prxattrib->encrypt) {
      case 1027073U: ;
      case 1027077U: 
#line 484
      prxattrib->key_index = (u8 )psecuritypriv->dot11PrivacyKeyIndex;
#line 486
      goto ldv_53588;
      case 1027074U: ;
      case 1027076U: ;
      default: 
#line 490
      prxattrib->key_index = (u8 )psecuritypriv->dot118021XGrpKeyid;
#line 492
      goto ldv_53588;
      }
      ldv_53588: ;
    } else {

    }
  } else {

  }
#line 497
  if (prxattrib->encrypt != 0U && (unsigned int )prxattrib->bdecrypted == 0U) {
#line 498
    psecuritypriv->hw_decrypted = 0U;
#line 499
    switch (prxattrib->encrypt) {
    case 1027073U: ;
    case 1027077U: 
#line 502
    rtw_wep_decrypt23a(padapter, precv_frame);
#line 503
    goto ldv_53594;
    case 1027074U: 
#line 505
    res = rtw_tkip_decrypt23a(padapter, precv_frame);
#line 506
    goto ldv_53594;
    case 1027076U: 
#line 508
    res = rtw_aes_decrypt23a(padapter, precv_frame);
#line 509
    goto ldv_53594;
    default: ;
#line 511
    goto ldv_53594;
    }
    ldv_53594: ;
  } else
#line 513
  if (((unsigned int )prxattrib->bdecrypted == 1U && prxattrib->encrypt != 0U) && ((unsigned int )*((unsigned char *)psecuritypriv + 580UL) != 0U || prxattrib->encrypt != 1027074U)) {
#line 516
    psecuritypriv->hw_decrypted = 1U;
  } else {

  }
#line 519
  if (res == 0) {
#line 520
    rtw_free_recvframe23a(return_packet);
#line 521
    return_packet = (struct recv_frame *)0;
  } else {

  }
#line 526
  return (return_packet);
}
}
#line 530 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
static struct recv_frame *portctrl(struct rtw_adapter *adapter , struct recv_frame *precv_frame ) 
{ 
  u8 *psta_addr ;
  u8 *ptr ;
  uint auth_alg ;
  struct recv_frame *pfhdr ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct recv_frame *prtnframe ;
  u16 ether_type ;
  u16 eapol_type ;
  struct rx_pkt_attrib *pattrib ;

  {
#line 540
  eapol_type = 34958U;
#line 543
  pstapriv = & adapter->stapriv;
#line 545
  auth_alg = adapter->securitypriv.dot11AuthAlgrthm;
#line 547
  pfhdr = precv_frame;
#line 548
  pattrib = & pfhdr->attrib;
#line 549
  psta_addr = (u8 *)(& pattrib->ta);
#line 550
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)psta_addr);
#line 552
  if (GlobalDebugLevel23A > 6U) {
#line 552
    rt_trace(4, 7, "########portctrl:adapter->securitypriv.dot11AuthAlgrthm =%d\n",
             adapter->securitypriv.dot11AuthAlgrthm);
  } else {

  }
#line 556
  prtnframe = precv_frame;
#line 558
  if (auth_alg == 2U) {
#line 560
    ptr = (pfhdr->pkt)->data + (unsigned long )pfhdr->attrib.hdrlen;
#line 562
    ether_type = (u16 )((int )((short )((int )*(ptr + 6UL) << 8)) | (int )((short )*(ptr + 7UL)));
#line 564
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0) && psta->ieee8021x_blocked != 0U) {
#line 567
      if (GlobalDebugLevel23A > 6U) {
#line 567
        rt_trace(4, 7, "########portctrl:psta->ieee8021x_blocked ==1\n");
      } else {

      }
#line 570
      if ((int )ether_type != (int )eapol_type) {
#line 572
        rtw_free_recvframe23a(precv_frame);
#line 573
        prtnframe = (struct recv_frame *)0;
      } else {

      }
    } else {

    }
  } else {

  }
#line 578
  return (prtnframe);
}
}
#line 581
int recv_decache(struct recv_frame *precv_frame , u8 bretry , struct stainfo_rxcache *prxcache ) ;
#line 583 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int recv_decache(struct recv_frame *precv_frame , u8 bretry , struct stainfo_rxcache *prxcache ) 
{ 
  int tid ;
  u16 seq_ctrl ;

  {
#line 586
  tid = (int )precv_frame->attrib.priority;
#line 588
  seq_ctrl = (u16 )((int )((short )((int )precv_frame->attrib.seq_num << 4)) | ((int )((short )precv_frame->attrib.frag_num) & 15));
#line 593
  if (tid > 15) {
#line 594
    if (GlobalDebugLevel23A > 5U) {
#line 594
      rt_trace(4, 6, "recv_decache, (tid>15)! seq_ctrl = 0x%x, tid = 0x%x\n", (int )seq_ctrl,
               tid);
    } else {

    }
#line 598
    return (0);
  } else {

  }
#line 602
  if ((int )prxcache->tid_rxseq[tid] == (int )seq_ctrl) {
#line 603
    if (GlobalDebugLevel23A > 5U) {
#line 603
      rt_trace(4, 6, "recv_decache, seq_ctrl = 0x%x, tid = 0x%x, tid_rxseq = 0x%x\n",
               (int )seq_ctrl, tid, (int )prxcache->tid_rxseq[tid]);
    } else {

    }
#line 607
    return (0);
  } else {

  }
#line 611
  prxcache->tid_rxseq[tid] = seq_ctrl;
#line 615
  return (1);
}
}
#line 618
void process23a_pwrbit_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 620 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
void process23a_pwrbit_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  unsigned char pwrbit ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  int tmp ;

  {
#line 625
  skb = precv_frame->pkt;
#line 626
  hdr = (struct ieee80211_hdr *)skb->data;
#line 627
  pattrib = & precv_frame->attrib;
#line 628
  pstapriv = & padapter->stapriv;
#line 629
  psta = (struct sta_info *)0;
#line 631
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->src));
#line 633
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 634
    tmp = ieee80211_has_pm((int )hdr->frame_control);
#line 634
    pwrbit = (unsigned char )tmp;
#line 636
    if ((unsigned int )pwrbit != 0U) {
#line 637
      if ((psta->state & 4U) == 0U) {
#line 638
        stop_sta_xmit23a(padapter, psta);
      } else {

      }
    } else
#line 640
    if ((psta->state & 4U) != 0U) {
#line 641
      wakeup_sta_to_xmit23a(padapter, psta);
    } else {

    }
  } else {

  }
#line 643
  return;
}
}
#line 648
void process_wmmps_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
void process_wmmps_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  u8 wmmps_ac ;

  {
#line 654
  pattrib = & precv_frame->attrib;
#line 655
  pstapriv = & padapter->stapriv;
#line 656
  psta = (struct sta_info *)0;
#line 658
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->src));
#line 660
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 661
    return;
  } else {

  }
#line 664
  if (psta->qos_option == 0U) {
#line 665
    return;
  } else {

  }
#line 667
  if (((int )psta->qos_info & 15) == 0) {
#line 668
    return;
  } else {

  }
#line 670
  if ((psta->state & 4U) != 0U) {
#line 671
    wmmps_ac = 0U;
#line 673
    switch ((int )pattrib->priority) {
    case 1: ;
    case 2: 
#line 676
    wmmps_ac = (unsigned int )psta->uapsd_bk & 2U;
#line 677
    goto ldv_53649;
    case 4: ;
    case 5: 
#line 680
    wmmps_ac = (unsigned int )psta->uapsd_vi & 2U;
#line 681
    goto ldv_53649;
    case 6: ;
    case 7: 
#line 684
    wmmps_ac = (unsigned int )psta->uapsd_vo & 2U;
#line 685
    goto ldv_53649;
    case 0: ;
    case 3: ;
    default: 
#line 689
    wmmps_ac = (unsigned int )psta->uapsd_be & 2U;
#line 690
    goto ldv_53649;
    }
    ldv_53649: ;
#line 693
    if ((unsigned int )wmmps_ac != 0U) {
#line 694
      if (psta->sleepq_ac_len != 0U) {
#line 696
        xmit_delivery_enabled_frames23a(padapter, psta);
      } else {
#line 699
        issue_qos_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), (int )pattrib->priority,
                              0, 0);
      }
    } else {

    }
  } else {

  }
#line 702
  return;
}
}
#line 709 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
static void count_rx_stats(struct rtw_adapter *padapter , struct recv_frame *prframe ,
                           struct sta_info *sta ) 
{ 
  int sz ;
  struct sta_info *psta ;
  struct stainfo_stats *pstats ;
  struct rx_pkt_attrib *pattrib ;
  struct recv_priv *precvpriv ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 713
  psta = (struct sta_info *)0;
#line 714
  pstats = (struct stainfo_stats *)0;
#line 715
  pattrib = & prframe->attrib;
#line 716
  precvpriv = & padapter->recvpriv;
#line 718
  sz = (int )(prframe->pkt)->len;
#line 719
  precvpriv->rx_bytes = precvpriv->rx_bytes + (u64 )sz;
#line 721
  padapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod = padapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod + 1U;
#line 723
  tmp = is_broadcast_ether_addr((u8 const   *)(& pattrib->dst));
#line 723
  if (tmp) {
#line 723
    tmp___0 = 0;
  } else {
#line 723
    tmp___0 = 1;
  }
#line 723
  if (tmp___0) {
#line 723
    tmp___1 = is_multicast_ether_addr((u8 const   *)(& pattrib->dst));
#line 723
    if (tmp___1) {
#line 723
      tmp___2 = 0;
    } else {
#line 723
      tmp___2 = 1;
    }
#line 723
    if (tmp___2) {
#line 725
      padapter->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod = padapter->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod + 1U;
    } else {

    }
  } else {

  }
#line 727
  if ((unsigned long )sta != (unsigned long )((struct sta_info *)0)) {
#line 728
    psta = sta;
  } else {
#line 730
    psta = prframe->psta;
  }
#line 732
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 733
    pstats = & psta->sta_stats;
#line 735
    pstats->rx_data_pkts = pstats->rx_data_pkts + 1ULL;
#line 736
    pstats->rx_bytes = pstats->rx_bytes + (u64 )sz;
  } else {

  }
#line 738
  return;
}
}
#line 740 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
static int sta2sta_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                              struct sta_info **psta ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  int ret ;
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  u8 *mybssid ;
  u8 *tmp ;
  u8 *myhwaddr ;
  u8 *tmp___0 ;
  u8 *sta_addr ;
  int bmcast ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  bool tmp___18 ;
  bool tmp___19 ;

  {
#line 744
  skb = precv_frame->pkt;
#line 745
  hdr = (struct ieee80211_hdr *)skb->data;
#line 746
  ret = 1;
#line 747
  pattrib = & precv_frame->attrib;
#line 748
  pstapriv = & adapter->stapriv;
#line 749
  pmlmepriv = & adapter->mlmepriv;
#line 750
  tmp = get_bssid(pmlmepriv);
#line 750
  mybssid = tmp;
#line 751
  tmp___0 = myid(& adapter->eeprompriv);
#line 751
  myhwaddr = tmp___0;
#line 752
  sta_addr = (u8 *)0U;
#line 753
  tmp___1 = is_multicast_ether_addr((u8 const   *)(& pattrib->dst));
#line 753
  bmcast = (int )tmp___1;
#line 757
  tmp___18 = check_fwstate(pmlmepriv, 32);
#line 757
  if ((int )tmp___18) {
#line 757
    goto _L;
  } else {
#line 757
    tmp___19 = check_fwstate(pmlmepriv, 64);
#line 757
    if ((int )tmp___19) {
      _L: /* CIL Label */ 
#line 761
      tmp___2 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->src));
#line 761
      if ((int )tmp___2) {
#line 762
        if (GlobalDebugLevel23A > 3U) {
#line 762
          rt_trace(4, 4, "SA == myself\n");
        } else {

        }
#line 764
        ret = 0;
#line 765
        goto exit;
      } else {

      }
#line 768
      tmp___3 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->dst));
#line 768
      if (tmp___3) {
#line 768
        tmp___4 = 0;
      } else {
#line 768
        tmp___4 = 1;
      }
#line 768
      if (tmp___4 && bmcast == 0) {
#line 769
        ret = 0;
#line 770
        goto exit;
      } else {

      }
#line 773
      tmp___5 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)"");
#line 773
      if ((int )tmp___5) {
#line 776
        ret = 0;
#line 777
        goto exit;
      } else {
#line 773
        tmp___6 = ether_addr_equal((u8 const   *)mybssid, (u8 const   *)"");
#line 773
        if ((int )tmp___6) {
#line 776
          ret = 0;
#line 777
          goto exit;
        } else {
#line 773
          tmp___7 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)mybssid);
#line 773
          if (tmp___7) {
#line 773
            tmp___8 = 0;
          } else {
#line 773
            tmp___8 = 1;
          }
#line 773
          if (tmp___8) {
#line 776
            ret = 0;
#line 777
            goto exit;
          } else {

          }
        }
      }
#line 780
      sta_addr = (u8 *)(& pattrib->src);
    } else {
#line 781
      tmp___17 = check_fwstate(pmlmepriv, 8);
#line 781
      if ((int )tmp___17) {
#line 784
        tmp___9 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)(& pattrib->src));
#line 784
        if (tmp___9) {
#line 784
          tmp___10 = 0;
        } else {
#line 784
          tmp___10 = 1;
        }
#line 784
        if (tmp___10) {
#line 785
          if (GlobalDebugLevel23A > 3U) {
#line 785
            rt_trace(4, 4, "bssid != TA under STATION_MODE; drop pkt\n");
          } else {

          }
#line 787
          ret = 0;
#line 788
          goto exit;
        } else {

        }
#line 791
        sta_addr = (u8 *)(& pattrib->bssid);
      } else {
#line 793
        tmp___16 = check_fwstate(pmlmepriv, 16);
#line 793
        if ((int )tmp___16) {
#line 794
          if (bmcast != 0) {
#line 796
            tmp___11 = is_multicast_ether_addr((u8 const   *)(& pattrib->bssid));
#line 796
            if (tmp___11) {
#line 796
              tmp___12 = 0;
            } else {
#line 796
              tmp___12 = 1;
            }
#line 796
            if (tmp___12) {
#line 797
              ret = 0;
#line 798
              goto exit;
            } else {

            }
          } else {
#line 803
            tmp___13 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)(& pattrib->dst));
#line 803
            if (tmp___13) {
#line 803
              tmp___14 = 0;
            } else {
#line 803
              tmp___14 = 1;
            }
#line 803
            if (tmp___14) {
#line 804
              ret = 0;
#line 805
              goto exit;
            } else {

            }
#line 808
            sta_addr = (u8 *)(& pattrib->src);
          }
        } else {
#line 810
          tmp___15 = check_fwstate(pmlmepriv, 65536);
#line 810
          if ((int )tmp___15) {
#line 811
            ether_addr_copy((u8 *)(& pattrib->dst), (u8 const   *)(& hdr->addr1));
#line 812
            ether_addr_copy((u8 *)(& pattrib->src), (u8 const   *)(& hdr->addr2));
#line 813
            ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr3));
#line 814
            ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
#line 815
            ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
#line 817
            sta_addr = mybssid;
          } else {
#line 819
            ret = 0;
          }
        }
      }
    }
  }
#line 822
  if (bmcast != 0) {
#line 823
    *psta = rtw_get_bcmc_stainfo23a(adapter);
  } else {
#line 825
    *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)sta_addr);
  }
#line 827
  if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
#line 828
    if (GlobalDebugLevel23A > 3U) {
#line 828
      rt_trace(4, 4, "can\'t get psta under sta2sta_data_frame ; drop pkt\n");
    } else {

    }
#line 830
    ret = 0;
#line 831
    goto exit;
  } else {

  }
  exit: ;
#line 836
  return (ret);
}
}
#line 839
int ap2sta_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta ) ;
#line 842 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int ap2sta_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  struct rx_pkt_attrib *pattrib ;
  int ret ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  u8 *mybssid ;
  u8 *tmp ;
  u8 *myhwaddr ;
  u8 *tmp___0 ;
  int bmcast ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  bool tmp___13 ;
  bool tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;

  {
#line 846
  skb = precv_frame->pkt;
#line 847
  hdr = (struct ieee80211_hdr *)skb->data;
#line 848
  pattrib = & precv_frame->attrib;
#line 849
  ret = 1;
#line 850
  pstapriv = & adapter->stapriv;
#line 851
  pmlmepriv = & adapter->mlmepriv;
#line 852
  tmp = get_bssid(pmlmepriv);
#line 852
  mybssid = tmp;
#line 853
  tmp___0 = myid(& adapter->eeprompriv);
#line 853
  myhwaddr = tmp___0;
#line 854
  tmp___1 = is_multicast_ether_addr((u8 const   *)(& pattrib->dst));
#line 854
  bmcast = (int )tmp___1;
#line 858
  tmp___14 = check_fwstate(pmlmepriv, 8);
#line 858
  if ((int )tmp___14) {
#line 858
    tmp___15 = check_fwstate(pmlmepriv, 1);
#line 858
    if ((int )tmp___15) {
#line 858
      goto _L___2;
    } else {
#line 858
      tmp___16 = check_fwstate(pmlmepriv, 128);
#line 858
      if ((int )tmp___16) {
        _L___2: /* CIL Label */ 
#line 863
        tmp___2 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->src));
#line 863
        if ((int )tmp___2) {
#line 864
          if (GlobalDebugLevel23A > 3U) {
#line 864
            rt_trace(4, 4, "SA == myself\n");
          } else {

          }
#line 866
          ret = 0;
#line 867
          goto exit;
        } else {

        }
#line 871
        tmp___3 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->dst));
#line 871
        if (tmp___3) {
#line 871
          tmp___4 = 0;
        } else {
#line 871
          tmp___4 = 1;
        }
#line 871
        if (tmp___4 && bmcast == 0) {
#line 872
          if (GlobalDebugLevel23A > 6U) {
#line 872
            rt_trace(4, 7, "ap2sta_data_frame:  compare DA failed; DA=%pM\n", (u8 *)(& pattrib->dst));
          } else {

          }
#line 875
          ret = 0;
#line 876
          goto exit;
        } else {

        }
#line 880
        tmp___5 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)"");
#line 880
        if ((int )tmp___5) {
#line 880
          goto _L;
        } else {
#line 880
          tmp___6 = ether_addr_equal((u8 const   *)mybssid, (u8 const   *)"");
#line 880
          if ((int )tmp___6) {
#line 880
            goto _L;
          } else {
#line 880
            tmp___7 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)mybssid);
#line 880
            if (tmp___7) {
#line 880
              tmp___8 = 0;
            } else {
#line 880
              tmp___8 = 1;
            }
#line 880
            if (tmp___8) {
              _L: /* CIL Label */ 
#line 883
              if (GlobalDebugLevel23A > 6U) {
#line 883
                rt_trace(4, 7, "ap2sta_data_frame:  compare BSSID failed; BSSID=%pM\n",
                         (u8 *)(& pattrib->bssid));
              } else {

              }
#line 886
              if (GlobalDebugLevel23A > 6U) {
#line 886
                rt_trace(4, 7, "mybssid=%pM\n", mybssid);
              } else {

              }
#line 889
              if (bmcast == 0) {
#line 890
                if (GlobalDebugLevel23A > 3U) {
#line 890
                  printk("\016RTL8723AU: issue_deauth23a to the nonassociated ap=%pM for the reason(7)\n",
                         (u8 *)(& pattrib->bssid));
                } else {

                }
#line 892
                issue_deauth23a(adapter, (unsigned char *)(& pattrib->bssid), 7);
              } else {

              }
#line 896
              ret = 0;
#line 897
              goto exit;
            } else {

            }
          }
        }
#line 900
        if (bmcast != 0) {
#line 901
          *psta = rtw_get_bcmc_stainfo23a(adapter);
        } else {
#line 904
          *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->bssid));
        }
#line 906
        if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
#line 907
          if (GlobalDebugLevel23A > 3U) {
#line 907
            rt_trace(4, 4, "ap2sta: can\'t get psta under STATION_MODE; drop pkt\n");
          } else {

          }
#line 909
          ret = 0;
#line 910
          goto exit;
        } else {

        }
#line 913
        tmp___9 = ieee80211_is_nullfunc((int )hdr->frame_control);
#line 913
        if (tmp___9 != 0) {
#line 916
          count_rx_stats(adapter, precv_frame, *psta);
#line 917
          ret = 2;
#line 918
          goto exit;
        } else {

        }
      } else {
#line 858
        goto _L___1;
      }
    }
  } else {
    _L___1: /* CIL Label */ 
#line 921
    tmp___12 = check_fwstate(pmlmepriv, 65536);
#line 921
    if ((int )tmp___12) {
#line 921
      tmp___13 = check_fwstate(pmlmepriv, 1);
#line 921
      if ((int )tmp___13) {
#line 923
        ether_addr_copy((u8 *)(& pattrib->dst), (u8 const   *)(& hdr->addr1));
#line 924
        ether_addr_copy((u8 *)(& pattrib->src), (u8 const   *)(& hdr->addr2));
#line 925
        ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr3));
#line 926
        ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
#line 927
        ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
#line 930
        ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)mybssid);
#line 933
        *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->bssid));
#line 934
        if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
#line 935
          if (GlobalDebugLevel23A > 3U) {
#line 935
            rt_trace(4, 4, "can\'t get psta under MP_MODE ; drop pkt\n");
          } else {

          }
#line 937
          ret = 0;
#line 938
          goto exit;
        } else {

        }
      } else {
#line 921
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 940
      tmp___11 = check_fwstate(pmlmepriv, 16);
#line 940
      if ((int )tmp___11) {
#line 942
        ret = 2;
#line 943
        goto exit;
      } else {
#line 945
        tmp___10 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->dst));
#line 945
        if ((int )tmp___10 && bmcast == 0) {
#line 946
          *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->bssid));
#line 947
          if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
#line 948
            if (GlobalDebugLevel23A > 3U) {
#line 948
              printk("\016RTL8723AU: issue_deauth23a to the ap=%pM for the reason(7)\n",
                     (u8 *)(& pattrib->bssid));
            } else {

            }
#line 951
            issue_deauth23a(adapter, (unsigned char *)(& pattrib->bssid), 7);
          } else {

          }
        } else {

        }
#line 956
        ret = 0;
      }
    }
  }
  exit: ;
#line 963
  return (ret);
}
}
#line 966
int sta2ap_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta ) ;
#line 969 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int sta2ap_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  unsigned char *mybssid ;
  u8 *tmp ;
  int ret ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u8 *myhwaddr ;
  u8 *tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;

  {
#line 973
  skb = precv_frame->pkt;
#line 974
  hdr = (struct ieee80211_hdr *)skb->data;
#line 975
  pattrib = & precv_frame->attrib;
#line 976
  pstapriv = & adapter->stapriv;
#line 977
  pmlmepriv = & adapter->mlmepriv;
#line 978
  tmp = get_bssid(pmlmepriv);
#line 978
  mybssid = tmp;
#line 979
  ret = 1;
#line 983
  tmp___7 = check_fwstate(pmlmepriv, 16);
#line 983
  if ((int )tmp___7) {
#line 985
    tmp___0 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)mybssid);
#line 985
    if (tmp___0) {
#line 985
      tmp___1 = 0;
    } else {
#line 985
      tmp___1 = 1;
    }
#line 985
    if (tmp___1) {
#line 986
      ret = 0;
#line 987
      goto exit;
    } else {

    }
#line 990
    *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->src));
#line 991
    if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
#line 992
      if (GlobalDebugLevel23A > 3U) {
#line 992
        rt_trace(4, 4, "can\'t get psta under AP_MODE; drop pkt\n");
      } else {

      }
#line 994
      if (GlobalDebugLevel23A > 3U) {
#line 994
        printk("\016RTL8723AU: issue_deauth23a to sta=%pM for the reason(7)\n", (u8 *)(& pattrib->src));
      } else {

      }
#line 997
      issue_deauth23a(adapter, (unsigned char *)(& pattrib->src), 7);
#line 1000
      ret = 2;
#line 1001
      goto exit;
    } else {

    }
#line 1004
    process23a_pwrbit_data(adapter, precv_frame);
#line 1008
    tmp___2 = ieee80211_is_data_qos((int )hdr->frame_control);
#line 1008
    if (tmp___2 != 0) {
#line 1009
      process_wmmps_data(adapter, precv_frame);
    } else {

    }
#line 1011
    tmp___3 = ieee80211_is_nullfunc((int )hdr->frame_control);
#line 1011
    if (tmp___3 != 0) {
#line 1014
      count_rx_stats(adapter, precv_frame, *psta);
#line 1015
      ret = 2;
#line 1016
      goto exit;
    } else {

    }
  } else {
#line 1019
    tmp___4 = myid(& adapter->eeprompriv);
#line 1019
    myhwaddr = tmp___4;
#line 1021
    tmp___5 = ether_addr_equal((u8 const   *)(& pattrib->ra), (u8 const   *)myhwaddr);
#line 1021
    if (tmp___5) {
#line 1021
      tmp___6 = 0;
    } else {
#line 1021
      tmp___6 = 1;
    }
#line 1021
    if (tmp___6) {
#line 1022
      ret = 2;
#line 1023
      goto exit;
    } else {

    }
#line 1025
    if (GlobalDebugLevel23A > 3U) {
#line 1025
      printk("\016RTL8723AU: issue_deauth23a to sta=%pM for the reason(7)\n", (u8 *)(& pattrib->src));
    } else {

    }
#line 1027
    issue_deauth23a(adapter, (unsigned char *)(& pattrib->src), 7);
#line 1029
    ret = 2;
#line 1030
    goto exit;
  }
  exit: ;
#line 1037
  return (ret);
}
}
#line 1040 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
static int validate_recv_ctrl_frame(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  int tmp ;
  u8 *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  struct ieee80211_pspoll *psp ;
  u16 aid ;
  u8 wmmps_ac ;
  struct sta_info *psta ;
  struct list_head *xmitframe_plist ;
  struct list_head *xmitframe_phead ;
  struct xmit_frame *pxmitframe ;
  struct xmit_priv *pxmitpriv ;
  struct list_head  const  *__mptr ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  int tmp___6 ;
  u32 tmp___7 ;
  int tmp___8 ;

  {
#line 1044
  pattrib = & precv_frame->attrib;
#line 1045
  pstapriv = & padapter->stapriv;
#line 1046
  skb = precv_frame->pkt;
#line 1047
  hdr = (struct ieee80211_hdr *)skb->data;
#line 1049
  tmp = ieee80211_is_ctl((int )hdr->frame_control);
#line 1049
  if (tmp == 0) {
#line 1050
    return (0);
  } else {

  }
#line 1053
  tmp___0 = myid(& padapter->eeprompriv);
#line 1053
  tmp___1 = ether_addr_equal((u8 const   *)(& hdr->addr1), (u8 const   *)tmp___0);
#line 1053
  if (tmp___1) {
#line 1053
    tmp___2 = 0;
  } else {
#line 1053
    tmp___2 = 1;
  }
#line 1053
  if (tmp___2) {
#line 1054
    return (0);
  } else {

  }
#line 1057
  tmp___8 = ieee80211_is_pspoll((int )hdr->frame_control);
#line 1057
  if (tmp___8 != 0) {
#line 1058
    psp = (struct ieee80211_pspoll *)hdr;
#line 1060
    wmmps_ac = 0U;
#line 1061
    psta = (struct sta_info *)0;
#line 1063
    aid = (unsigned int )psp->aid & 16383U;
#line 1064
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& hdr->addr2));
#line 1066
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0) || psta->aid != (uint )aid) {
#line 1067
      return (0);
    } else {

    }
#line 1070
    psta->sta_stats.rx_ctrl_pkts = psta->sta_stats.rx_ctrl_pkts + 1ULL;
#line 1072
    switch ((int )pattrib->priority) {
    case 1: ;
    case 2: 
#line 1075
    wmmps_ac = (unsigned int )psta->uapsd_bk & 1U;
#line 1076
    goto ldv_53734;
    case 4: ;
    case 5: 
#line 1079
    wmmps_ac = (unsigned int )psta->uapsd_vi & 1U;
#line 1080
    goto ldv_53734;
    case 6: ;
    case 7: 
#line 1083
    wmmps_ac = (unsigned int )psta->uapsd_vo & 1U;
#line 1084
    goto ldv_53734;
    case 0: ;
    case 3: ;
    default: 
#line 1088
    wmmps_ac = (unsigned int )psta->uapsd_be & 1U;
#line 1089
    goto ldv_53734;
    }
    ldv_53734: ;
#line 1092
    if ((unsigned int )wmmps_ac != 0U) {
#line 1093
      return (0);
    } else {

    }
#line 1095
    if ((psta->state & 1024U) != 0U) {
#line 1096
      if (GlobalDebugLevel23A > 3U) {
#line 1096
        printk("\016RTL8723AU: %s alive check-rx ps-poll\n", "validate_recv_ctrl_frame");
      } else {

      }
#line 1097
      psta->expire_to = pstapriv->expire_to;
#line 1098
      psta->state = psta->state ^ 1024U;
    } else {

    }
#line 1101
    if ((psta->state & 4U) != 0U) {
#line 1101
      tmp___7 = CHKBIT(psta->aid);
#line 1101
      if (((u32 )pstapriv->sta_dz_bitmap & tmp___7) != 0U) {
#line 1105
        pxmitpriv = & padapter->xmitpriv;
#line 1107
        spin_lock_bh(& pxmitpriv->lock);
#line 1109
        xmitframe_phead = get_list_head(& psta->sleep_q);
#line 1110
        xmitframe_plist = xmitframe_phead->next;
#line 1112
        tmp___6 = list_empty((struct list_head  const  *)xmitframe_phead);
#line 1112
        if (tmp___6 == 0) {
#line 1113
          __mptr = (struct list_head  const  *)xmitframe_plist;
#line 1113
          pxmitframe = (struct xmit_frame *)__mptr;
#line 1117
          xmitframe_plist = xmitframe_plist->next;
#line 1119
          list_del_init(& pxmitframe->list);
#line 1121
          psta->sleepq_len = psta->sleepq_len - 1U;
#line 1123
          if (psta->sleepq_len != 0U) {
#line 1124
            pxmitframe->attrib.mdata = 1U;
          } else {
#line 1126
            pxmitframe->attrib.mdata = 0U;
          }
#line 1128
          pxmitframe->attrib.triggered = 1U;
#line 1132
          rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
#line 1135
          if (psta->sleepq_len == 0U) {
#line 1136
            tmp___3 = CHKBIT(psta->aid);
#line 1136
            pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp___3));
#line 1142
            update_beacon23a(padapter, 5, (u8 *)0U, 0);
          } else {

          }
#line 1147
          spin_unlock_bh(& pxmitpriv->lock);
        } else {
#line 1151
          spin_unlock_bh(& pxmitpriv->lock);
#line 1154
          tmp___5 = CHKBIT(psta->aid);
#line 1154
          if (((u32 )pstapriv->tim_bitmap & tmp___5) != 0U) {
#line 1155
            if (psta->sleepq_len == 0U) {
#line 1156
              if (GlobalDebugLevel23A > 3U) {
#line 1156
                printk("\016RTL8723AU: no buffered packets to xmit\n");
              } else {

              }
#line 1160
              issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), 0U, 0,
                                0);
            } else {
#line 1164
              if (GlobalDebugLevel23A > 3U) {
#line 1164
                printk("\016RTL8723AU: error!psta->sleepq_len =%d\n", psta->sleepq_len);
              } else {

              }
#line 1167
              psta->sleepq_len = 0U;
            }
#line 1170
            tmp___4 = CHKBIT(psta->aid);
#line 1170
            pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp___4));
#line 1174
            update_beacon23a(padapter, 5, (u8 *)0U, 0);
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 1182
  return (0);
}
}
#line 1185
struct recv_frame *recvframe_chk_defrag23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 1187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
static int validate_recv_mgnt_frame(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct sta_info *psta ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1195
  if (GlobalDebugLevel23A > 6U) {
#line 1195
    rt_trace(4, 7, "+validate_recv_mgnt_frame\n");
  } else {

  }
#line 1198
  precv_frame = recvframe_chk_defrag23a(padapter, precv_frame);
#line 1199
  if ((unsigned long )precv_frame == (unsigned long )((struct recv_frame *)0)) {
#line 1200
    if (GlobalDebugLevel23A > 5U) {
#line 1200
      rt_trace(4, 6, "%s: fragment packet\n", "validate_recv_mgnt_frame");
    } else {

    }
#line 1202
    return (1);
  } else {

  }
#line 1205
  skb = precv_frame->pkt;
#line 1206
  hdr = (struct ieee80211_hdr *)skb->data;
#line 1209
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& hdr->addr2));
#line 1210
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1211
    psta->sta_stats.rx_mgnt_pkts = psta->sta_stats.rx_mgnt_pkts + 1ULL;
#line 1213
    tmp___4 = ieee80211_is_beacon((int )hdr->frame_control);
#line 1213
    if (tmp___4 != 0) {
#line 1214
      psta->sta_stats.rx_beacon_pkts = psta->sta_stats.rx_beacon_pkts + 1ULL;
    } else {
#line 1215
      tmp___3 = ieee80211_is_probe_req((int )hdr->frame_control);
#line 1215
      if (tmp___3 != 0) {
#line 1216
        psta->sta_stats.rx_probereq_pkts = psta->sta_stats.rx_probereq_pkts + 1ULL;
      } else {
#line 1217
        tmp___2 = ieee80211_is_probe_resp((int )hdr->frame_control);
#line 1217
        if (tmp___2 != 0) {
#line 1218
          tmp___1 = ether_addr_equal((u8 const   *)(& padapter->eeprompriv.mac_addr),
                                     (u8 const   *)(& hdr->addr1));
#line 1218
          if ((int )tmp___1) {
#line 1220
            psta->sta_stats.rx_probersp_pkts = psta->sta_stats.rx_probersp_pkts + 1ULL;
          } else {
#line 1221
            tmp = is_broadcast_ether_addr((u8 const   *)(& hdr->addr1));
#line 1221
            if ((int )tmp) {
#line 1223
              psta->sta_stats.rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts + 1ULL;
            } else {
#line 1221
              tmp___0 = is_multicast_ether_addr((u8 const   *)(& hdr->addr1));
#line 1221
              if ((int )tmp___0) {
#line 1223
                psta->sta_stats.rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts + 1ULL;
              } else {
#line 1225
                psta->sta_stats.rx_probersp_uo_pkts = psta->sta_stats.rx_probersp_uo_pkts + 1ULL;
              }
            }
          }
        } else {

        }
      }
    }
  } else {

  }
#line 1229
  mgt_dispatcher23a(padapter, precv_frame);
#line 1231
  return (1);
}
}
#line 1234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
static int validate_recv_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ) 
{ 
  u8 bretry ;
  u8 *psa ;
  u8 *pda ;
  struct sta_info *psta ;
  struct rx_pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  int ret ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  int tmp ;
  int tmp___0 ;
  __le16 *qptr ;
  u8 *tmp___1 ;
  u16 qos_ctrl ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
#line 1239
  psta = (struct sta_info *)0;
#line 1240
  pattrib = & precv_frame->attrib;
#line 1241
  psecuritypriv = & adapter->securitypriv;
#line 1242
  ret = 1;
#line 1243
  skb = precv_frame->pkt;
#line 1244
  hdr = (struct ieee80211_hdr *)skb->data;
#line 1248
  tmp = ieee80211_has_retry((int )hdr->frame_control);
#line 1248
  bretry = (u8 )tmp;
#line 1249
  pda = ieee80211_get_DA(hdr);
#line 1250
  psa = ieee80211_get_SA(hdr);
#line 1252
  ether_addr_copy((u8 *)(& pattrib->dst), (u8 const   *)pda);
#line 1253
  ether_addr_copy((u8 *)(& pattrib->src), (u8 const   *)psa);
#line 1255
  switch ((int )hdr->frame_control & 768) {
  case 0: 
#line 1258
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr3));
#line 1259
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)pda);
#line 1260
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)psa);
#line 1261
  ret = sta2sta_data_frame(adapter, precv_frame, & psta);
#line 1262
  goto ldv_53774;
  case 512: 
#line 1265
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr2));
#line 1266
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)pda);
#line 1267
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& hdr->addr2));
#line 1268
  ret = ap2sta_data_frame(adapter, precv_frame, & psta);
#line 1269
  goto ldv_53774;
  case 256: 
#line 1272
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr1));
#line 1273
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& hdr->addr1));
#line 1274
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)psa);
#line 1275
  ret = sta2ap_data_frame(adapter, precv_frame, & psta);
#line 1276
  goto ldv_53774;
  case 768: 
#line 1283
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr1));
#line 1284
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& hdr->addr1));
#line 1285
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& hdr->addr2));
#line 1286
  ret = 0;
#line 1287
  if (GlobalDebugLevel23A > 3U) {
#line 1287
    rt_trace(4, 4, "case 3\n");
  } else {

  }
#line 1288
  goto ldv_53774;
  }
  ldv_53774: ;
#line 1291
  if (ret == 0 || ret == 2) {
#line 1292
    goto exit;
  } else {

  }
#line 1294
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1295
    if (GlobalDebugLevel23A > 3U) {
#line 1295
      rt_trace(4, 4, "after to_fr_ds_chk; psta == NULL\n");
    } else {

    }
#line 1297
    ret = 0;
#line 1298
    goto exit;
  } else {

  }
#line 1303
  precv_frame->psta = psta;
#line 1305
  pattrib->hdrlen = 24U;
#line 1306
  tmp___0 = ieee80211_has_a4((int )hdr->frame_control);
#line 1306
  if (tmp___0 != 0) {
#line 1307
    pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 6U;
  } else {

  }
#line 1310
  if ((unsigned int )pattrib->qos == 1U) {
#line 1311
    tmp___1 = ieee80211_get_qos_ctl(hdr);
#line 1311
    qptr = (__le16 *)tmp___1;
#line 1312
    qos_ctrl = *qptr;
#line 1314
    pattrib->priority = (unsigned int )((u8 )qos_ctrl) & 15U;
#line 1315
    pattrib->ack_policy = (unsigned int )((u8 )((int )qos_ctrl >> 5)) & 3U;
#line 1316
    pattrib->amsdu = (u8 )(((int )qos_ctrl & 128) >> 7);
#line 1318
    pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 2U;
#line 1320
    if ((unsigned int )pattrib->priority != 0U && (unsigned int )pattrib->priority != 3U) {
#line 1321
      adapter->recvpriv.bIsAnyNonBEPkts = 1U;
    } else {

    }
  } else {
#line 1324
    pattrib->priority = 0U;
#line 1325
    pattrib->ack_policy = 0U;
#line 1326
    pattrib->amsdu = 0U;
  }
#line 1329
  if ((unsigned int )pattrib->order != 0U) {
#line 1330
    pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 4U;
  } else {

  }
#line 1333
  precv_frame->preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )pattrib->priority;
#line 1336
  tmp___2 = recv_decache(precv_frame, (int )bretry, & psta->sta_recvpriv.rxcache);
#line 1336
  if (tmp___2 == 0) {
#line 1338
    if (GlobalDebugLevel23A > 3U) {
#line 1338
      rt_trace(4, 4, "decache : drop pkt\n");
    } else {

    }
#line 1340
    ret = 0;
#line 1341
    goto exit;
  } else {

  }
#line 1344
  if ((unsigned int )pattrib->privacy != 0U) {
#line 1345
    if (GlobalDebugLevel23A > 6U) {
#line 1345
      rt_trace(4, 7, "validate_recv_data_frame:pattrib->privacy =%x\n", (int )pattrib->privacy);
    } else {

    }
#line 1348
    if (GlobalDebugLevel23A > 6U) {
#line 1348
      tmp___3 = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 1348
      rt_trace(4, 7, "^^^^^^^^^^^is_multicast_ether_addr(pattrib->ra(0x%02x)) =%d^^^^^^^^^^^^^^^6\n",
               (int )pattrib->ra[0], (int )tmp___3);
    } else {

    }
#line 1353
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U: 
#line 1353
    pattrib->encrypt = psecuritypriv->dot11PrivacyAlgrthm;
#line 1353
    goto ldv_53784;
    case 2U: 
#line 1353
    tmp___4 = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 1353
    if ((int )tmp___4) {
#line 1353
      pattrib->encrypt = psecuritypriv->dot118021XGrpPrivacy;
    } else {
#line 1353
      pattrib->encrypt = psta->dot118021XPrivacy;
    }
#line 1353
    goto ldv_53784;
    }
    ldv_53784: ;
#line 1356
    if (GlobalDebugLevel23A > 6U) {
#line 1356
      rt_trace(4, 7, "pattrib->encrypt =%d\n", pattrib->encrypt);
    } else {

    }
#line 1359
    switch (pattrib->encrypt) {
    case 1027073U: ;
    case 1027077U: 
#line 1362
    pattrib->iv_len = 4U;
#line 1363
    pattrib->icv_len = 4U;
#line 1364
    goto ldv_53788;
    case 1027074U: 
#line 1366
    pattrib->iv_len = 8U;
#line 1367
    pattrib->icv_len = 4U;
#line 1368
    goto ldv_53788;
    case 1027076U: 
#line 1370
    pattrib->iv_len = 8U;
#line 1371
    pattrib->icv_len = 8U;
#line 1372
    goto ldv_53788;
    default: 
#line 1374
    pattrib->iv_len = 0U;
#line 1375
    pattrib->icv_len = 0U;
#line 1376
    goto ldv_53788;
    }
    ldv_53788: ;
  } else {
#line 1379
    pattrib->encrypt = 0U;
#line 1380
    pattrib->iv_len = 0U;
#line 1381
    pattrib->icv_len = 0U;
  }
  exit: ;
#line 1388
  return (ret);
}
}
#line 1391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
static void dump_rx_pkt(struct sk_buff *skb , u16 type , int level ) 
{ 
  int i ;
  u8 *ptr ;

  {
#line 1396
  if ((level == 1 || (level == 2 && (unsigned int )type == 0U)) || (level == 3 && (unsigned int )type == 8U)) {
#line 1400
    ptr = skb->data;
#line 1402
    if (GlobalDebugLevel23A > 3U) {
#line 1402
      printk("\016RTL8723AU: #############################\n");
    } else {

    }
#line 1404
    i = 0;
#line 1404
    goto ldv_53800;
    ldv_53799: ;
#line 1405
    if (GlobalDebugLevel23A > 3U) {
#line 1405
      printk("\016RTL8723AU: %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\n", (int )*(ptr + (unsigned long )i),
             (int )*(ptr + ((unsigned long )i + 1UL)), (int )*(ptr + ((unsigned long )i + 2UL)),
             (int )*(ptr + ((unsigned long )i + 3UL)), (int )*(ptr + ((unsigned long )i + 4UL)),
             (int )*(ptr + ((unsigned long )i + 5UL)), (int )*(ptr + ((unsigned long )i + 6UL)),
             (int )*(ptr + ((unsigned long )i + 7UL)));
    } else {

    }
#line 1404
    i = i + 8;
    ldv_53800: ;
#line 1404
    if (i <= 63) {
#line 1406
      goto ldv_53799;
    } else {

    }

#line 1410
    if (GlobalDebugLevel23A > 3U) {
#line 1410
      printk("\016RTL8723AU: #############################\n");
    } else {

    }
  } else {

  }
#line 1412
  return;
}
}
#line 1414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
static int validate_recv_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ) 
{ 
  u8 type ;
  u8 subtype ;
  int retval ;
  struct rx_pkt_attrib *pattrib ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  u8 ver ;
  u8 bDumpRxPkt ;
  u16 seq_ctrl ;
  u16 fctl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  struct recv_priv *precvpriv ;

  {
#line 1422
  retval = 1;
#line 1423
  pattrib = & precv_frame->attrib;
#line 1424
  skb = precv_frame->pkt;
#line 1425
  hdr = (struct ieee80211_hdr *)skb->data;
#line 1430
  fctl = hdr->frame_control;
#line 1431
  ver = (unsigned int )((u8 )fctl) & 3U;
#line 1432
  type = (unsigned int )((u8 )fctl) & 12U;
#line 1433
  subtype = (unsigned int )((u8 )fctl) & 240U;
#line 1436
  if ((unsigned int )ver != 0U) {
#line 1437
    if (GlobalDebugLevel23A > 3U) {
#line 1437
      rt_trace(4, 4, "validate_recv_data_frame fail! (ver!= 0)\n");
    } else {

    }
#line 1439
    retval = 0;
#line 1440
    goto exit;
  } else {

  }
#line 1443
  seq_ctrl = hdr->seq_ctrl;
#line 1444
  pattrib->frag_num = (unsigned int )((u8 )seq_ctrl) & 15U;
#line 1445
  pattrib->seq_num = (u16 )((int )seq_ctrl >> 4);
#line 1447
  tmp = ieee80211_has_pm((int )hdr->frame_control);
#line 1447
  pattrib->pw_save = (u8 )tmp;
#line 1448
  tmp___0 = ieee80211_has_morefrags((int )hdr->frame_control);
#line 1448
  pattrib->mfrag = (u8 )tmp___0;
#line 1449
  tmp___1 = ieee80211_has_moredata((int )hdr->frame_control);
#line 1449
  pattrib->mdata = (u8 )tmp___1;
#line 1450
  tmp___2 = ieee80211_has_protected((int )hdr->frame_control);
#line 1450
  pattrib->privacy = (u8 )tmp___2;
#line 1451
  tmp___3 = ieee80211_has_order((int )hdr->frame_control);
#line 1451
  pattrib->order = (u8 )tmp___3;
#line 1453
  GetHalDefVar8192CUsb(adapter, 6, (void *)(& bDumpRxPkt));
#line 1455
  tmp___4 = ldv__builtin_expect((unsigned int )bDumpRxPkt == 1U, 0L);
#line 1455
  if (tmp___4 != 0L) {
#line 1456
    dump_rx_pkt(skb, (int )type, (int )bDumpRxPkt);
  } else {

  }
#line 1458
  switch ((int )type) {
  case 0: 
#line 1460
  retval = validate_recv_mgnt_frame(adapter, precv_frame);
#line 1461
  if (retval == 0) {
#line 1462
    if (GlobalDebugLevel23A > 3U) {
#line 1462
      rt_trace(4, 4, "validate_recv_mgnt_frame fail\n");
    } else {

    }
  } else {

  }
#line 1465
  retval = 0;
#line 1466
  goto ldv_53818;
  case 4: 
#line 1468
  retval = validate_recv_ctrl_frame(adapter, precv_frame);
#line 1469
  if (retval == 0) {
#line 1470
    if (GlobalDebugLevel23A > 3U) {
#line 1470
      rt_trace(4, 4, "validate_recv_ctrl_frame fail\n");
    } else {

    }
  } else {

  }
#line 1473
  retval = 0;
#line 1474
  goto ldv_53818;
  case 8: 
#line 1476
  pattrib->qos = (int )((signed char )subtype) < 0;
#line 1477
  retval = validate_recv_data_frame(adapter, precv_frame);
#line 1478
  if (retval == 0) {
#line 1479
    precvpriv = & adapter->recvpriv;
#line 1481
    precvpriv->rx_drop = precvpriv->rx_drop + 1ULL;
  } else {

  }
#line 1483
  goto ldv_53818;
  default: ;
#line 1485
  if (GlobalDebugLevel23A > 3U) {
#line 1485
    rt_trace(4, 4, "validate_recv_data_frame fail! type = 0x%x\n", (int )type);
  } else {

  }
#line 1487
  retval = 0;
#line 1488
  goto ldv_53818;
  }
  ldv_53818: ;
  exit: ;
#line 1492
  return (retval);
}
}
#line 1497 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
static int wlanhdr_to_ethhdr(struct recv_frame *precvframe ) 
{ 
  u16 eth_type ;
  u16 len ;
  u16 hdrlen ;
  u8 bsnaphdr ;
  u8 *psnap ;
  struct rtw_adapter *adapter ;
  struct mlme_priv *pmlmepriv ;
  struct sk_buff *skb ;
  u8 *ptr ;
  struct rx_pkt_attrib *pattrib ;
  bool tmp ;
  bool tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  bool tmp___3 ;
  __u16 tmp___4 ;

  {
#line 1502
  adapter = precvframe->adapter;
#line 1503
  pmlmepriv = & adapter->mlmepriv;
#line 1505
  skb = precvframe->pkt;
#line 1507
  pattrib = & precvframe->attrib;
#line 1511
  ptr = skb->data;
#line 1512
  hdrlen = (u16 )pattrib->hdrlen;
#line 1513
  psnap = ptr + (unsigned long )hdrlen;
#line 1514
  eth_type = (u16 )((int )((short )((int )*(psnap + 6UL) << 8)) | (int )((short )*(psnap + 7UL)));
#line 1517
  tmp = ether_addr_equal((u8 const   *)psnap, (u8 const   *)(& rfc1042_header));
#line 1517
  if (((int )tmp && (unsigned int )eth_type != 33011U) && (unsigned int )eth_type != 33079U) {
#line 1522
    bsnaphdr = 1U;
#line 1523
    hdrlen = (unsigned int )hdrlen + 6U;
  } else {
#line 1517
    tmp___0 = ether_addr_equal((u8 const   *)psnap, (u8 const   *)(& bridge_tunnel_header));
#line 1517
    if ((int )tmp___0) {
#line 1522
      bsnaphdr = 1U;
#line 1523
      hdrlen = (unsigned int )hdrlen + 6U;
    } else {
#line 1526
      bsnaphdr = 0U;
#line 1527
      eth_type = (u16 )((int )((short )((int )*psnap << 8)) | (int )((short )*(psnap + 1UL)));
    }
  }
#line 1530
  len = (int )((u16 )skb->len) - (int )hdrlen;
#line 1532
  if (GlobalDebugLevel23A > 6U) {
#line 1532
    rt_trace(4, 7, "=== pattrib->hdrlen: %x,  pattrib->iv_len:%x ===\n", (int )pattrib->hdrlen,
             (int )pattrib->iv_len);
  } else {

  }
#line 1536
  pattrib->eth_type = eth_type;
#line 1537
  tmp___3 = check_fwstate(pmlmepriv, 65536);
#line 1537
  if ((int )tmp___3) {
#line 1538
    ptr = ptr + (unsigned long )hdrlen;
#line 1539
    *ptr = 135U;
#line 1540
    *(ptr + 1UL) = 18U;
#line 1542
    eth_type = 34578U;
#line 1545
    tmp___1 = skb_pull(skb, (unsigned int )hdrlen - 36U);
#line 1545
    ptr = tmp___1;
#line 1546
    memcpy((void *)ptr, (void const   *)skb->head, 24UL);
#line 1547
    ptr = ptr + 24UL;
  } else {
#line 1549
    tmp___2 = skb_pull(skb, ((unsigned int )hdrlen + ((unsigned int )bsnaphdr != 0U ? 2U : 0U)) - 14U);
#line 1549
    ptr = tmp___2;
  }
#line 1553
  ether_addr_copy(ptr, (u8 const   *)(& pattrib->dst));
#line 1554
  ether_addr_copy(ptr + 6UL, (u8 const   *)(& pattrib->src));
#line 1556
  if ((unsigned int )bsnaphdr == 0U) {
#line 1557
    tmp___4 = __fswab16((int )len);
#line 1557
    len = tmp___4;
#line 1558
    memcpy((void *)ptr + 12U, (void const   *)(& len), 2UL);
  } else {

  }
#line 1562
  return (1);
}
}
#line 1566
struct recv_frame *recvframe_defrag(struct rtw_adapter *adapter , struct rtw_queue *defrag_q ) ;
#line 1568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
struct recv_frame *recvframe_defrag(struct rtw_adapter *adapter , struct rtw_queue *defrag_q ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  u8 *data ;
  u8 wlanhdr_offset ;
  u8 curfragnum ;
  struct recv_frame *pnfhdr ;
  struct recv_frame *prframe ;
  struct recv_frame *pnextrframe ;
  struct rtw_queue *pfree_recv_queue ;
  struct sk_buff *skb ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  unsigned char *tmp ;

  {
#line 1581
  curfragnum = 0U;
#line 1582
  pfree_recv_queue = & adapter->recvpriv.free_recv_queue;
#line 1584
  phead = get_list_head(defrag_q);
#line 1585
  plist = phead->next;
#line 1586
  __mptr = (struct list_head  const  *)plist;
#line 1586
  prframe = (struct recv_frame *)__mptr;
#line 1587
  list_del_init(& prframe->list);
#line 1588
  skb = prframe->pkt;
#line 1590
  if ((int )prframe->attrib.frag_num != (int )curfragnum) {
#line 1593
    rtw_free_recvframe23a(prframe);
#line 1594
    rtw_free_recvframe23a_queue(defrag_q);
#line 1596
    return ((struct recv_frame *)0);
  } else {

  }
#line 1599
  curfragnum = (u8 )((int )curfragnum + 1);
#line 1601
  phead = get_list_head(defrag_q);
#line 1603
  data = (prframe->pkt)->data;
#line 1605
  plist = phead->next;
#line 1605
  ptmp = plist->next;
#line 1605
  goto ldv_53859;
  ldv_53858: 
#line 1606
  __mptr___0 = (struct list_head  const  *)plist;
#line 1606
  pnfhdr = (struct recv_frame *)__mptr___0;
#line 1607
  pnextrframe = pnfhdr;
#line 1610
  if ((int )pnfhdr->attrib.frag_num != (int )curfragnum) {
#line 1614
    rtw_free_recvframe23a(prframe);
#line 1615
    rtw_free_recvframe23a_queue(defrag_q);
#line 1616
    return ((struct recv_frame *)0);
  } else {

  }
#line 1619
  curfragnum = (u8 )((int )curfragnum + 1);
#line 1625
  wlanhdr_offset = (int )pnfhdr->attrib.hdrlen + (int )pnfhdr->attrib.iv_len;
#line 1627
  skb_pull(pnfhdr->pkt, (unsigned int )wlanhdr_offset);
#line 1632
  skb_trim(skb, skb->len - (unsigned int )prframe->attrib.icv_len);
#line 1634
  tmp = skb_tail_pointer((struct sk_buff  const  *)skb);
#line 1634
  memcpy((void *)tmp, (void const   *)(pnfhdr->pkt)->data, (size_t )(pnfhdr->pkt)->len);
#line 1637
  skb_put(skb, (pnfhdr->pkt)->len);
#line 1639
  prframe->attrib.icv_len = pnfhdr->attrib.icv_len;
#line 1605
  plist = ptmp;
#line 1605
  ptmp = plist->next;
  ldv_53859: ;
#line 1605
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1607
    goto ldv_53858;
  } else {

  }
#line 1643
  rtw_free_recvframe23a_queue(defrag_q);
#line 1645
  if (GlobalDebugLevel23A > 6U) {
#line 1645
    rt_trace(4, 7, "Performance defrag!!!!!\n");
  } else {

  }
#line 1650
  return (prframe);
}
}
#line 1654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
struct recv_frame *recvframe_chk_defrag23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  u8 ismfrag ;
  u8 fragnum ;
  u8 *psta_addr ;
  struct recv_frame *pfhdr ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct list_head *phead ;
  struct recv_frame *prtnframe ;
  struct rtw_queue *pfree_recv_queue ;
  struct rtw_queue *pdefrag_q ;
  struct ieee80211_hdr *hdr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1664
  prtnframe = (struct recv_frame *)0;
#line 1669
  pstapriv = & padapter->stapriv;
#line 1671
  pfhdr = precv_frame;
#line 1673
  pfree_recv_queue = & padapter->recvpriv.free_recv_queue;
#line 1676
  ismfrag = pfhdr->attrib.mfrag;
#line 1677
  fragnum = pfhdr->attrib.frag_num;
#line 1679
  psta_addr = (u8 *)(& pfhdr->attrib.ta);
#line 1680
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)psta_addr);
#line 1681
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1682
    hdr = (struct ieee80211_hdr *)(pfhdr->pkt)->data;
#line 1684
    tmp = ieee80211_is_data((int )hdr->frame_control);
#line 1684
    if (tmp == 0) {
#line 1685
      psta = rtw_get_bcmc_stainfo23a(padapter);
#line 1686
      pdefrag_q = & psta->sta_recvpriv.defrag_q;
    } else {
#line 1688
      pdefrag_q = (struct rtw_queue *)0;
    }
  } else {
#line 1690
    pdefrag_q = & psta->sta_recvpriv.defrag_q;
  }
#line 1692
  if ((unsigned int )ismfrag == 0U && (unsigned int )fragnum == 0U) {
#line 1693
    prtnframe = precv_frame;
  } else {

  }
#line 1696
  if ((unsigned int )ismfrag == 1U) {
#line 1699
    if ((unsigned long )pdefrag_q != (unsigned long )((struct rtw_queue *)0)) {
#line 1700
      if ((unsigned int )fragnum == 0U) {
#line 1702
        tmp___0 = list_empty((struct list_head  const  *)(& pdefrag_q->queue));
#line 1702
        if (tmp___0 == 0) {
#line 1704
          rtw_free_recvframe23a_queue(pdefrag_q);
        } else {

        }
      } else {

      }
#line 1712
      phead = get_list_head(pdefrag_q);
#line 1713
      list_add_tail(& pfhdr->list, phead);
#line 1716
      if (GlobalDebugLevel23A > 6U) {
#line 1716
        rt_trace(4, 7, "Enqueuq: ismfrag = %d, fragnum = %d\n", (int )ismfrag, (int )fragnum);
      } else {

      }
#line 1720
      prtnframe = (struct recv_frame *)0;
    } else {
#line 1725
      rtw_free_recvframe23a(precv_frame);
#line 1726
      prtnframe = (struct recv_frame *)0;
#line 1727
      if (GlobalDebugLevel23A > 3U) {
#line 1727
        rt_trace(4, 4, "Free because pdefrag_q == NULL: ismfrag = %d, fragnum = %d\n",
                 (int )ismfrag, (int )fragnum);
      } else {

      }
    }
  } else {

  }
#line 1733
  if ((unsigned int )ismfrag == 0U && (unsigned int )fragnum != 0U) {
#line 1736
    if ((unsigned long )pdefrag_q != (unsigned long )((struct rtw_queue *)0)) {
#line 1738
      phead = get_list_head(pdefrag_q);
#line 1739
      list_add_tail(& pfhdr->list, phead);
#line 1743
      if (GlobalDebugLevel23A > 6U) {
#line 1743
        rt_trace(4, 7, "defrag: ismfrag = %d, fragnum = %d\n", (int )ismfrag, (int )fragnum);
      } else {

      }
#line 1746
      precv_frame = recvframe_defrag(padapter, pdefrag_q);
#line 1747
      prtnframe = precv_frame;
    } else {
#line 1751
      rtw_free_recvframe23a(precv_frame);
#line 1752
      prtnframe = (struct recv_frame *)0;
#line 1753
      if (GlobalDebugLevel23A > 3U) {
#line 1753
        rt_trace(4, 4, "Free because pdefrag_q == NULL: ismfrag = %d, fragnum = %d\n",
                 (int )ismfrag, (int )fragnum);
      } else {

      }
    }
  } else {

  }
#line 1760
  if ((unsigned long )prtnframe != (unsigned long )((struct recv_frame *)0) && (unsigned int )prtnframe->attrib.privacy != 0U) {
#line 1762
    tmp___1 = recvframe_chkmic(padapter, prtnframe);
#line 1762
    if (tmp___1 == 0) {
#line 1763
      if (GlobalDebugLevel23A > 3U) {
#line 1763
        rt_trace(4, 4, "recvframe_chkmic(padapter,  prtnframe) ==_FAIL\n");
      } else {

      }
#line 1765
      rtw_free_recvframe23a(prtnframe);
#line 1766
      prtnframe = (struct recv_frame *)0;
    } else {

    }
  } else {

  }
#line 1772
  return (prtnframe);
}
}
#line 1775
int amsdu_to_msdu(struct rtw_adapter *padapter , struct recv_frame *prframe ) ;
#line 1776 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int amsdu_to_msdu(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct sk_buff *skb ;
  struct sk_buff *sub_skb ;
  struct sk_buff_head skb_list ;
  int tmp ;

  {
#line 1782
  pattrib = & prframe->attrib;
#line 1784
  skb = prframe->pkt;
#line 1785
  skb_pull(skb, (unsigned int )prframe->attrib.hdrlen);
#line 1786
  __skb_queue_head_init(& skb_list);
#line 1788
  ieee80211_amsdu_to_8023s(skb, & skb_list, (u8 const   *)0U, 0, 0U, 0);
#line 1790
  goto ldv_53888;
  ldv_53887: 
#line 1791
  sub_skb = __skb_dequeue(& skb_list);
#line 1793
  sub_skb->protocol = eth_type_trans(sub_skb, padapter->pnetdev);
#line 1794
  sub_skb->dev = padapter->pnetdev;
#line 1796
  sub_skb->ip_summed = 0U;
#line 1798
  netif_rx(sub_skb);
  ldv_53888: 
#line 1790
  tmp = skb_queue_empty((struct sk_buff_head  const  *)(& skb_list));
#line 1790
  if (tmp == 0) {
#line 1792
    goto ldv_53887;
  } else {

  }
#line 1801
  prframe->pkt = (struct sk_buff *)0;
#line 1802
  rtw_free_recvframe23a(prframe);
#line 1803
  return (1);
}
}
#line 1806
int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl , u16 seq_num ) ;
#line 1807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl , u16 seq_num ) 
{ 
  u8 wsize ;
  u16 wend ;

  {
#line 1809
  wsize = preorder_ctrl->wsize_b;
#line 1810
  wend = (unsigned int )((u16 )((unsigned int )((int )preorder_ctrl->indicate_seq + (int )((unsigned short )wsize)) + 65535U)) & 4095U;
#line 1813
  if ((unsigned int )preorder_ctrl->indicate_seq == 65535U) {
#line 1814
    preorder_ctrl->indicate_seq = seq_num;
  } else {

  }
#line 1817
  if ((((int )seq_num - (int )preorder_ctrl->indicate_seq) & 2048) != 0) {
#line 1818
    return (0);
  } else {

  }
#line 1825
  if ((int )preorder_ctrl->indicate_seq == (int )seq_num) {
#line 1826
    preorder_ctrl->indicate_seq = (unsigned int )((u16 )((unsigned int )preorder_ctrl->indicate_seq + 1U)) & 4095U;
  } else
#line 1828
  if ((((int )wend - (int )seq_num) & 2048) != 0) {
#line 1830
    if ((int )seq_num >= (int )wsize + -1) {
#line 1831
      preorder_ctrl->indicate_seq = (unsigned int )((int )seq_num - (int )((u16 )wsize)) + 1U;
    } else {
#line 1833
      preorder_ctrl->indicate_seq = (unsigned int )((int )seq_num - (int )((u16 )wsize)) + 4097U;
    }
  } else {

  }
#line 1835
  return (1);
}
}
#line 1838 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
static int enqueue_reorder_recvframe23a(struct recv_reorder_ctrl *preorder_ctrl ,
                                        struct recv_frame *prframe ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct rtw_queue *ppending_recvframe_queue ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct recv_frame *hdr ;
  struct rx_pkt_attrib *pnextattrib ;
  struct list_head  const  *__mptr ;

  {
#line 1841
  pattrib = & prframe->attrib;
#line 1847
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
#line 1853
  phead = get_list_head(ppending_recvframe_queue);
#line 1855
  plist = phead->next;
#line 1855
  ptmp = plist->next;
#line 1855
  goto ldv_53915;
  ldv_53914: 
#line 1856
  __mptr = (struct list_head  const  *)plist;
#line 1856
  hdr = (struct recv_frame *)__mptr;
#line 1857
  pnextattrib = & hdr->attrib;
#line 1859
  if ((((int )pnextattrib->seq_num - (int )pattrib->seq_num) & 2048) != 0) {
#line 1860
    goto ldv_53912;
  } else
#line 1861
  if ((int )pnextattrib->seq_num == (int )pattrib->seq_num) {
#line 1865
    return (0);
  } else {
#line 1867
    goto ldv_53913;
  }
  ldv_53912: 
#line 1855
  plist = ptmp;
#line 1855
  ptmp = plist->next;
  ldv_53915: ;
#line 1855
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1857
    goto ldv_53914;
  } else {

  }
  ldv_53913: 
#line 1876
  list_del_init(& prframe->list);
#line 1878
  list_add_tail(& prframe->list, plist);
#line 1883
  return (1);
}
}
#line 1886
int recv_indicatepkts_in_order(struct rtw_adapter *padapter , struct recv_reorder_ctrl *preorder_ctrl ,
                               int bforced ) ;
#line 1889 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int recv_indicatepkts_in_order(struct rtw_adapter *padapter , struct recv_reorder_ctrl *preorder_ctrl ,
                               int bforced ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct recv_frame *prframe ;
  struct rx_pkt_attrib *pattrib ;
  int bPktInBuf ;
  struct recv_priv *precvpriv ;
  struct rtw_queue *ppending_recvframe_queue ;
  int tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1898
  bPktInBuf = 0;
#line 1902
  precvpriv = & padapter->recvpriv;
#line 1903
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
#line 1909
  phead = get_list_head(ppending_recvframe_queue);
#line 1910
  plist = phead->next;
#line 1913
  if (bforced != 0) {
#line 1914
    tmp = list_empty((struct list_head  const  *)phead);
#line 1914
    if (tmp != 0) {
#line 1917
      return (1);
    } else {

    }
#line 1920
    __mptr = (struct list_head  const  *)plist;
#line 1920
    prframe = (struct recv_frame *)__mptr;
#line 1921
    pattrib = & prframe->attrib;
#line 1922
    preorder_ctrl->indicate_seq = pattrib->seq_num;
  } else {

  }
#line 1927
  goto ldv_53938;
  ldv_53937: 
#line 1929
  __mptr___0 = (struct list_head  const  *)plist;
#line 1929
  prframe = (struct recv_frame *)__mptr___0;
#line 1930
  pattrib = & prframe->attrib;
#line 1932
  if ((((int )preorder_ctrl->indicate_seq - (int )pattrib->seq_num) & 2048) == 0) {
#line 1933
    if (GlobalDebugLevel23A > 5U) {
#line 1933
      rt_trace(4, 6, "recv_indicatepkts_in_order: indicate =%d seq =%d amsdu =%d\n",
               (int )preorder_ctrl->indicate_seq, (int )pattrib->seq_num, (int )pattrib->amsdu);
    } else {

    }
#line 1938
    plist = plist->next;
#line 1939
    list_del_init(& prframe->list);
#line 1941
    if ((int )preorder_ctrl->indicate_seq == (int )pattrib->seq_num) {
#line 1943
      preorder_ctrl->indicate_seq = (unsigned int )((u16 )((unsigned int )preorder_ctrl->indicate_seq + 1U)) & 4095U;
    } else {

    }
#line 1947
    if ((unsigned int )pattrib->amsdu == 0U) {
#line 1948
      if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
#line 1950
        rtw_recv_indicatepkt23a(padapter, prframe);
      } else {

      }
    } else {
#line 1953
      tmp___0 = amsdu_to_msdu(padapter, prframe);
#line 1953
      if (tmp___0 != 1) {
#line 1955
        rtw_free_recvframe23a(prframe);
      } else {

      }
    }
#line 1959
    bPktInBuf = 0;
  } else {
#line 1962
    bPktInBuf = 1;
#line 1963
    goto ldv_53936;
  }
  ldv_53938: 
#line 1927
  tmp___1 = list_empty((struct list_head  const  *)phead);
#line 1927
  if (tmp___1 == 0) {
#line 1929
    goto ldv_53937;
  } else {

  }
  ldv_53936: ;
#line 1972
  return (bPktInBuf);
}
}
#line 1975
int recv_indicatepkt_reorder(struct rtw_adapter *padapter , struct recv_frame *prframe ) ;
#line 1977 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int recv_indicatepkt_reorder(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  int retval ;
  struct rx_pkt_attrib *pattrib ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct rtw_queue *ppending_recvframe_queue ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
#line 1980
  retval = 1;
#line 1985
  pattrib = & prframe->attrib;
#line 1986
  preorder_ctrl = prframe->preorder_ctrl;
#line 1987
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
#line 1989
  if ((unsigned int )pattrib->amsdu == 0U) {
#line 1991
    wlanhdr_to_ethhdr(prframe);
#line 1993
    if (((unsigned int )pattrib->qos != 1U || (unsigned int )pattrib->eth_type == 2054U) || (unsigned int )pattrib->ack_policy != 0U) {
#line 1995
      if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
#line 1997
        if (GlobalDebugLevel23A > 5U) {
#line 1997
          rt_trace(4, 6, "@@@@  recv_indicatepkt_reorder -recv_func recv_indicatepkt\n");
        } else {

        }
#line 2000
        rtw_recv_indicatepkt23a(padapter, prframe);
#line 2001
        return (1);
      } else {

      }
#line 2004
      return (0);
    } else {

    }
#line 2007
    if ((unsigned int )preorder_ctrl->enable == 0U) {
#line 2009
      preorder_ctrl->indicate_seq = pattrib->seq_num;
#line 2010
      rtw_recv_indicatepkt23a(padapter, prframe);
#line 2012
      preorder_ctrl->indicate_seq = (u16 )(((int )preorder_ctrl->indicate_seq + 1) % 4096);
#line 2014
      return (1);
    } else {

    }
  } else
#line 2018
  if ((unsigned int )preorder_ctrl->enable == 0U) {
#line 2019
    preorder_ctrl->indicate_seq = pattrib->seq_num;
#line 2020
    retval = amsdu_to_msdu(padapter, prframe);
#line 2022
    preorder_ctrl->indicate_seq = (u16 )(((int )preorder_ctrl->indicate_seq + 1) % 4096);
#line 2024
    return (retval);
  } else {

  }
#line 2028
  spin_lock_bh(& ppending_recvframe_queue->lock);
#line 2030
  if (GlobalDebugLevel23A > 5U) {
#line 2030
    rt_trace(4, 6, "recv_indicatepkt_reorder: indicate =%d seq =%d\n", (int )preorder_ctrl->indicate_seq,
             (int )pattrib->seq_num);
  } else {

  }
#line 2035
  tmp = check_indicate_seq(preorder_ctrl, (int )pattrib->seq_num);
#line 2035
  if (tmp == 0) {
#line 2036
    goto _err_exit;
  } else {

  }
#line 2040
  tmp___0 = enqueue_reorder_recvframe23a(preorder_ctrl, prframe);
#line 2040
  if (tmp___0 == 0) {
#line 2041
    goto _err_exit;
  } else {

  }
#line 2057
  tmp___2 = recv_indicatepkts_in_order(padapter, preorder_ctrl, 0);
#line 2057
  if (tmp___2 == 1) {
#line 2058
    tmp___1 = msecs_to_jiffies(50U);
#line 2058
    ldv_mod_timer_175(& preorder_ctrl->reordering_ctrl_timer, tmp___1 + (unsigned long )jiffies);
#line 2060
    spin_unlock_bh(& ppending_recvframe_queue->lock);
  } else {
#line 2062
    spin_unlock_bh(& ppending_recvframe_queue->lock);
#line 2063
    ldv_del_timer_sync_176(& preorder_ctrl->reordering_ctrl_timer);
  }
#line 2065
  return (1);
  _err_exit: 
#line 2069
  spin_unlock_bh(& ppending_recvframe_queue->lock);
#line 2070
  return (0);
}
}
#line 2073 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
void rtw_reordering_ctrl_timeout_handler23a(unsigned long pcontext ) 
{ 
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct rtw_adapter *padapter ;
  struct rtw_queue *ppending_recvframe_queue ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 2079
  preorder_ctrl = (struct recv_reorder_ctrl *)pcontext;
#line 2080
  padapter = preorder_ctrl->padapter;
#line 2081
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
#line 2083
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 2084
    return;
  } else {

  }
#line 2089
  spin_lock_bh(& ppending_recvframe_queue->lock);
#line 2091
  tmp___0 = recv_indicatepkts_in_order(padapter, preorder_ctrl, 1);
#line 2091
  if (tmp___0 == 1) {
#line 2092
    tmp = msecs_to_jiffies(50U);
#line 2092
    ldv_mod_timer_177(& preorder_ctrl->reordering_ctrl_timer, tmp + (unsigned long )jiffies);
  } else {

  }
#line 2096
  spin_unlock_bh(& ppending_recvframe_queue->lock);
#line 2097
  return;
}
}
#line 2099
int process_recv_indicatepkts(struct rtw_adapter *padapter , struct recv_frame *prframe ) ;
#line 2101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int process_recv_indicatepkts(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  int retval ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  int tmp ;

  {
#line 2104
  retval = 1;
#line 2107
  pmlmepriv = & padapter->mlmepriv;
#line 2108
  phtpriv = & pmlmepriv->htpriv;
#line 2110
  if ((int )phtpriv->ht_option) {
#line 2114
    tmp = recv_indicatepkt_reorder(padapter, prframe);
#line 2114
    if (tmp != 1) {
#line 2115
      if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
#line 2117
        retval = 0;
#line 2118
        return (retval);
      } else {

      }
    } else {

    }
  } else {
#line 2122
    retval = wlanhdr_to_ethhdr(prframe);
#line 2123
    if (retval != 1) {
#line 2124
      if (GlobalDebugLevel23A > 3U) {
#line 2124
        rt_trace(4, 4, "wlanhdr_to_ethhdr: drop pkt\n");
      } else {

      }
#line 2126
      return (retval);
    } else {

    }
#line 2129
    if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
#line 2132
      if (GlobalDebugLevel23A > 5U) {
#line 2132
        rt_trace(4, 6, "@@@@ process_recv_indicatepkts- recv_func recv_indicatepkt\n");
      } else {

      }
#line 2134
      rtw_recv_indicatepkt23a(padapter, prframe);
    } else {
#line 2136
      if (GlobalDebugLevel23A > 5U) {
#line 2136
        rt_trace(4, 6, "@@@@ process_recv_indicatepkts- recv_func free_indicatepkt\n");
      } else {

      }
#line 2139
      if (GlobalDebugLevel23A > 5U) {
#line 2139
        rt_trace(4, 6, "recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped,
                 padapter->bSurpriseRemoved);
      } else {

      }
#line 2143
      retval = 0;
#line 2144
      return (retval);
    }
  }
#line 2149
  return (retval);
}
}
#line 2152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
static int recv_func_prehandle(struct rtw_adapter *padapter , struct recv_frame *rframe ) 
{ 
  int ret ;

  {
#line 2155
  ret = 1;
#line 2158
  ret = validate_recv_frame(padapter, rframe);
#line 2159
  if (ret != 1) {
#line 2160
    if (GlobalDebugLevel23A > 6U) {
#line 2160
      rt_trace(4, 7, "recv_func: validate_recv_frame fail! drop pkt\n");
    } else {

    }
#line 2162
    rtw_free_recvframe23a(rframe);
#line 2163
    goto exit;
  } else {

  }
  exit: ;
#line 2167
  return (ret);
}
}
#line 2170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
static int recv_func_posthandle(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  int ret ;
  struct recv_frame *orig_prframe ;
  struct recv_priv *precvpriv ;

  {
#line 2173
  ret = 1;
#line 2174
  orig_prframe = prframe;
#line 2175
  precvpriv = & padapter->recvpriv;
#line 2178
  prframe = decryptor(padapter, prframe);
#line 2179
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0)) {
#line 2180
    if (GlobalDebugLevel23A > 3U) {
#line 2180
      rt_trace(4, 4, "decryptor: drop pkt\n");
    } else {

    }
#line 2182
    ret = 0;
#line 2183
    goto _recv_data_drop;
  } else {

  }
#line 2186
  prframe = recvframe_chk_defrag23a(padapter, prframe);
#line 2187
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0)) {
#line 2188
    if (GlobalDebugLevel23A > 3U) {
#line 2188
      rt_trace(4, 4, "recvframe_chk_defrag23a: drop pkt\n");
    } else {

    }
#line 2190
    goto _recv_data_drop;
  } else {

  }
#line 2196
  if ((unsigned int )prframe->attrib.iv_len != 0U) {
#line 2197
    skb_pull(prframe->pkt, (unsigned int )prframe->attrib.iv_len);
  } else {

  }
#line 2200
  if ((unsigned int )prframe->attrib.icv_len != 0U) {
#line 2201
    skb_trim(prframe->pkt, (prframe->pkt)->len - (unsigned int )prframe->attrib.icv_len);
  } else {

  }
#line 2205
  prframe = portctrl(padapter, prframe);
#line 2206
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0)) {
#line 2207
    if (GlobalDebugLevel23A > 3U) {
#line 2207
      rt_trace(4, 4, "portctrl: drop pkt\n");
    } else {

    }
#line 2209
    ret = 0;
#line 2210
    goto _recv_data_drop;
  } else {

  }
#line 2213
  count_rx_stats(padapter, prframe, (struct sta_info *)0);
#line 2215
  ret = process_recv_indicatepkts(padapter, prframe);
#line 2216
  if (ret != 1) {
#line 2217
    if (GlobalDebugLevel23A > 3U) {
#line 2217
      rt_trace(4, 4, "recv_func: process_recv_indicatepkts fail!\n");
    } else {

    }
#line 2219
    rtw_free_recvframe23a(orig_prframe);
#line 2220
    goto _recv_data_drop;
  } else {

  }
#line 2222
  return (ret);
  _recv_data_drop: 
#line 2225
  precvpriv->rx_drop = precvpriv->rx_drop + 1ULL;
#line 2226
  return (ret);
}
}
#line 2229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
int rtw_recv_entry23a(struct recv_frame *rframe ) 
{ 
  int ret ;
  int r ;
  struct rtw_adapter *padapter ;
  struct rx_pkt_attrib *prxattrib ;
  struct recv_priv *recvpriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *mlmepriv ;
  struct recv_frame *pending_frame ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 2232
  padapter = rframe->adapter;
#line 2233
  prxattrib = & rframe->attrib;
#line 2234
  recvpriv = & padapter->recvpriv;
#line 2235
  psecuritypriv = & padapter->securitypriv;
#line 2236
  mlmepriv = & padapter->mlmepriv;
#line 2239
  tmp = check_fwstate(mlmepriv, 8);
#line 2239
  if ((int )tmp && (unsigned int )*((unsigned char *)psecuritypriv + 580UL) != 0U) {
#line 2243
    goto ldv_53994;
    ldv_53993: 
#line 2244
    r = recv_func_posthandle(padapter, pending_frame);
#line 2245
    if (r == 1) {
#line 2246
      if (GlobalDebugLevel23A > 3U) {
#line 2246
        printk("\016RTL8723AU: %s: dequeue uc_swdec_pending_queue\n", "rtw_recv_entry23a");
      } else {

      }
    } else {

    }
    ldv_53994: 
#line 2243
    pending_frame = rtw_alloc_recvframe23a(& padapter->recvpriv.uc_swdec_pending_queue);
#line 2243
    if ((unsigned long )pending_frame != (unsigned long )((struct recv_frame *)0)) {
#line 2245
      goto ldv_53993;
    } else {

    }

  } else {

  }
#line 2250
  ret = recv_func_prehandle(padapter, rframe);
#line 2252
  if (ret == 1) {
#line 2254
    tmp___0 = check_fwstate(mlmepriv, 8);
#line 2254
    if ((int )tmp___0) {
#line 2254
      tmp___1 = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
#line 2254
      if (tmp___1) {
#line 2254
        tmp___2 = 0;
      } else {
#line 2254
        tmp___2 = 1;
      }
#line 2254
      if (tmp___2) {
#line 2254
        if (prxattrib->encrypt != 0U) {
#line 2254
          if ((unsigned int )prxattrib->bdecrypted == 0U) {
#line 2254
            if (psecuritypriv->dot11PrivacyAlgrthm != 1027073U && psecuritypriv->dot11PrivacyAlgrthm != 1027077U) {
#line 2254
              if ((unsigned int )*((unsigned char *)psecuritypriv + 580UL) == 0U) {
#line 2260
                rtw_enqueue_recvframe23a(rframe, & padapter->recvpriv.uc_swdec_pending_queue);
#line 2261
                if (GlobalDebugLevel23A > 3U) {
#line 2261
                  printk("\016RTL8723AU: %s: no key, enqueue uc_swdec_pending_queue\n",
                         "rtw_recv_entry23a");
                } else {

                }
#line 2262
                goto exit;
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
#line 2265
    ret = recv_func_posthandle(padapter, rframe);
#line 2267
    recvpriv->rx_pkts = recvpriv->rx_pkts + 1ULL;
  } else {

  }
  exit: ;
#line 2271
  return (ret);
}
}
#line 2274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.c"
void rtw_signal_stat_timer_hdl23a(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;
  struct recv_priv *recvpriv ;
  u32 tmp_s ;
  u32 tmp_q ;
  u8 avg_signal_strength ;
  u8 avg_signal_qual ;
  u32 num_signal_strength ;
  u32 num_signal_qual ;
  u8 _alpha ;
  bool tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 2276
  adapter = (struct rtw_adapter *)data;
#line 2277
  recvpriv = & adapter->recvpriv;
#line 2280
  avg_signal_strength = 0U;
#line 2281
  avg_signal_qual = 0U;
#line 2282
  num_signal_strength = 0U;
#line 2283
  num_signal_qual = 0U;
#line 2284
  _alpha = 3U;
#line 2287
  if ((unsigned int )recvpriv->signal_strength_data.update_req == 0U) {
#line 2289
    avg_signal_strength = recvpriv->signal_strength_data.avg_val;
#line 2290
    num_signal_strength = recvpriv->signal_strength_data.total_num;
#line 2293
    recvpriv->signal_strength_data.update_req = 1U;
  } else {

  }
#line 2296
  if ((unsigned int )recvpriv->signal_qual_data.update_req == 0U) {
#line 2298
    avg_signal_qual = recvpriv->signal_qual_data.avg_val;
#line 2299
    num_signal_qual = recvpriv->signal_qual_data.total_num;
#line 2302
    recvpriv->signal_qual_data.update_req = 1U;
  } else {

  }
#line 2306
  tmp = check_fwstate(& adapter->mlmepriv, 2048);
#line 2306
  if (tmp) {
#line 2306
    tmp___0 = 0;
  } else {
#line 2306
    tmp___0 = 1;
  }
#line 2306
  if (tmp___0) {
#line 2307
    tmp_s = (u32 )((int )avg_signal_strength + ((int )_alpha + -1) * (int )recvpriv->signal_strength);
#line 2309
    if (tmp_s % (u32 )_alpha != 0U) {
#line 2310
      tmp_s = tmp_s / (u32 )_alpha + 1U;
    } else {
#line 2312
      tmp_s = tmp_s / (u32 )_alpha;
    }
#line 2313
    if (tmp_s > 100U) {
#line 2314
      tmp_s = 100U;
    } else {

    }
#line 2316
    tmp_q = (u32 )((int )avg_signal_qual + ((int )_alpha + -1) * (int )recvpriv->signal_qual);
#line 2317
    if (tmp_q % (u32 )_alpha != 0U) {
#line 2318
      tmp_q = tmp_q / (u32 )_alpha + 1U;
    } else {
#line 2320
      tmp_q = tmp_q / (u32 )_alpha;
    }
#line 2321
    if (tmp_q > 100U) {
#line 2322
      tmp_q = 100U;
    } else {

    }
#line 2324
    recvpriv->signal_strength = (u8 )tmp_s;
#line 2325
    recvpriv->signal_qual = (u8 )tmp_q;
#line 2327
    if (GlobalDebugLevel23A > 3U) {
#line 2327
      printk("\016RTL8723AU: %s signal_strength:%3u, signal_qual:%3u, num_signal_strength:%u, num_signal_qual:%u\n",
             "rtw_signal_stat_timer_hdl23a", (int )recvpriv->signal_strength, (int )recvpriv->signal_qual,
             num_signal_strength, num_signal_qual);
    } else {

    }
  } else {

  }
#line 2334
  tmp___1 = msecs_to_jiffies(recvpriv->signal_stat_sampling_interval);
#line 2334
  ldv_mod_timer_178(& recvpriv->signal_stat_timer, tmp___1 + (unsigned long )jiffies);
#line 2335
  return;
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void timer_init_12(void) 
{ 


  {
#line 251
  ldv_timer_12_0 = 0;
#line 252
  ldv_timer_12_1 = 0;
#line 253
  ldv_timer_12_2 = 0;
#line 254
  ldv_timer_12_3 = 0;
#line 255
  return;
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int reg_timer_12(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 259
  if ((unsigned long )function == (unsigned long )(& rtw_signal_stat_timer_hdl23a)) {
#line 260
    activate_suitable_timer_12(timer, data);
  } else {

  }
#line 261
  return (0);
}
}
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void activate_pending_timer_12(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 266
  if ((unsigned long )ldv_timer_list_12_0 == (unsigned long )timer) {
#line 267
    if (ldv_timer_12_0 == 2 || pending_flag != 0) {
#line 268
      ldv_timer_list_12_0 = timer;
#line 269
      ldv_timer_list_12_0->data = data;
#line 270
      ldv_timer_12_0 = 1;
    } else {

    }
#line 272
    return;
  } else {

  }
#line 275
  if ((unsigned long )ldv_timer_list_12_1 == (unsigned long )timer) {
#line 276
    if (ldv_timer_12_1 == 2 || pending_flag != 0) {
#line 277
      ldv_timer_list_12_1 = timer;
#line 278
      ldv_timer_list_12_1->data = data;
#line 279
      ldv_timer_12_1 = 1;
    } else {

    }
#line 281
    return;
  } else {

  }
#line 284
  if ((unsigned long )ldv_timer_list_12_2 == (unsigned long )timer) {
#line 285
    if (ldv_timer_12_2 == 2 || pending_flag != 0) {
#line 286
      ldv_timer_list_12_2 = timer;
#line 287
      ldv_timer_list_12_2->data = data;
#line 288
      ldv_timer_12_2 = 1;
    } else {

    }
#line 290
    return;
  } else {

  }
#line 293
  if ((unsigned long )ldv_timer_list_12_3 == (unsigned long )timer) {
#line 294
    if (ldv_timer_12_3 == 2 || pending_flag != 0) {
#line 295
      ldv_timer_list_12_3 = timer;
#line 296
      ldv_timer_list_12_3->data = data;
#line 297
      ldv_timer_12_3 = 1;
    } else {

    }
#line 299
    return;
  } else {

  }
#line 301
  activate_suitable_timer_12(timer, data);
#line 302
  return;
}
}
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void ldv_timer_12(int state , struct timer_list *timer ) 
{ 


  {
#line 306
  LDV_IN_INTERRUPT = 2;
#line 307
  rtw_signal_stat_timer_hdl23a(timer->data);
#line 308
  LDV_IN_INTERRUPT = 1;
#line 309
  return;
}
}
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void activate_suitable_timer_12(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 313
  if (ldv_timer_12_0 == 0 || ldv_timer_12_0 == 2) {
#line 314
    ldv_timer_list_12_0 = timer;
#line 315
    ldv_timer_list_12_0->data = data;
#line 316
    ldv_timer_12_0 = 1;
#line 317
    return;
  } else {

  }
#line 319
  if (ldv_timer_12_1 == 0 || ldv_timer_12_1 == 2) {
#line 320
    ldv_timer_list_12_1 = timer;
#line 321
    ldv_timer_list_12_1->data = data;
#line 322
    ldv_timer_12_1 = 1;
#line 323
    return;
  } else {

  }
#line 325
  if (ldv_timer_12_2 == 0 || ldv_timer_12_2 == 2) {
#line 326
    ldv_timer_list_12_2 = timer;
#line 327
    ldv_timer_list_12_2->data = data;
#line 328
    ldv_timer_12_2 = 1;
#line 329
    return;
  } else {

  }
#line 331
  if (ldv_timer_12_3 == 0 || ldv_timer_12_3 == 2) {
#line 332
    ldv_timer_list_12_3 = timer;
#line 333
    ldv_timer_list_12_3->data = data;
#line 334
    ldv_timer_12_3 = 1;
#line 335
    return;
  } else {

  }
#line 337
  return;
}
}
#line 341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void choose_timer_12(void) 
{ 
  int tmp ;

  {
#line 342
  tmp = __VERIFIER_nondet_int();
#line 342
  switch (tmp) {
  case 0: ;
#line 344
  if (ldv_timer_12_0 == 1) {
#line 345
    ldv_timer_12_0 = 2;
#line 346
    ldv_timer_12(ldv_timer_12_0, ldv_timer_list_12_0);
  } else {

  }
#line 349
  goto ldv_54036;
  case 1: ;
#line 351
  if (ldv_timer_12_1 == 1) {
#line 352
    ldv_timer_12_1 = 2;
#line 353
    ldv_timer_12(ldv_timer_12_1, ldv_timer_list_12_1);
  } else {

  }
#line 356
  goto ldv_54036;
  case 2: ;
#line 358
  if (ldv_timer_12_2 == 1) {
#line 359
    ldv_timer_12_2 = 2;
#line 360
    ldv_timer_12(ldv_timer_12_2, ldv_timer_list_12_2);
  } else {

  }
#line 363
  goto ldv_54036;
  case 3: ;
#line 365
  if (ldv_timer_12_3 == 1) {
#line 366
    ldv_timer_12_3 = 2;
#line 367
    ldv_timer_12(ldv_timer_12_3, ldv_timer_list_12_3);
  } else {

  }
#line 370
  goto ldv_54036;
  default: 
#line 371
  ldv_stop();
  }
  ldv_54036: ;
#line 373
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void disable_suitable_timer_12(struct timer_list *timer ) 
{ 


  {
#line 378
  if (ldv_timer_12_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_12_0) {
#line 379
    ldv_timer_12_0 = 0;
#line 380
    return;
  } else {

  }
#line 382
  if (ldv_timer_12_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_12_1) {
#line 383
    ldv_timer_12_1 = 0;
#line 384
    return;
  } else {

  }
#line 386
  if (ldv_timer_12_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_12_2) {
#line 387
    ldv_timer_12_2 = 0;
#line 388
    return;
  } else {

  }
#line 390
  if (ldv_timer_12_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_12_3) {
#line 391
    ldv_timer_12_3 = 0;
#line 392
    return;
  } else {

  }
#line 394
  return;
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
bool ldv_queue_work_on_169(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 425
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 425
  ldv_func_res = tmp;
#line 427
  activate_work_2(ldv_func_arg3, 2);
#line 429
  return (ldv_func_res);
}
}
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
bool ldv_queue_delayed_work_on_170(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 436
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 436
  ldv_func_res = tmp;
#line 438
  activate_work_2(& ldv_func_arg3->work, 2);
#line 440
  return (ldv_func_res);
}
}
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
bool ldv_queue_work_on_171(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 447
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 447
  ldv_func_res = tmp;
#line 449
  activate_work_2(ldv_func_arg3, 2);
#line 451
  return (ldv_func_res);
}
}
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void ldv_flush_workqueue_172(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 457
  flush_workqueue(ldv_func_arg1);
#line 459
  call_and_disable_all_2(2);
#line 460
  return;
}
}
#line 462 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
bool ldv_queue_delayed_work_on_173(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 466
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 466
  ldv_func_res = tmp;
#line 468
  activate_work_2(& ldv_func_arg3->work, 2);
#line 470
  return (ldv_func_res);
}
}
#line 473 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int ldv_mod_timer_174(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 477
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 477
  ldv_func_res = tmp;
#line 479
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 481
  return (ldv_func_res);
}
}
#line 484 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int ldv_mod_timer_175(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 488
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 488
  ldv_func_res = tmp;
#line 490
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 492
  return (ldv_func_res);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int ldv_del_timer_sync_176(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 499
  tmp = del_timer_sync(ldv_func_arg1);
#line 499
  ldv_func_res = tmp;
#line 501
  disable_suitable_timer_11(ldv_func_arg1);
#line 503
  return (ldv_func_res);
}
}
#line 506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int ldv_mod_timer_177(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 510
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 510
  ldv_func_res = tmp;
#line 512
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 514
  return (ldv_func_res);
}
}
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int ldv_mod_timer_178(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 521
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 521
  ldv_func_res = tmp;
#line 523
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 525
  return (ldv_func_res);
}
}
#line 55 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u32 __le32_to_cpup(__le32 const   *p ) 
{ 


  {
#line 57
  return ((__u32 )*p);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_193(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_195(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_194(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_197(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_196(struct workqueue_struct *ldv_func_arg1 ) ;
#line 12 "include/linux/unaligned/access_ok.h"
__inline static u32 get_unaligned_le32(void const   *p ) 
{ 
  __u32 tmp ;

  {
#line 14
  tmp = __le32_to_cpup((__le32 const   *)p);
#line 14
  return (tmp);
}
}
#line 309 "drivers/staging/rtl8723au/include/rtw_security.h"
void rtw_secmicsetkey23a(struct mic_data *pmicdata , u8 *key ) ;
#line 310
void rtw_secmicappend23abyte23a(struct mic_data *pmicdata , u8 b ) ;
#line 311
void rtw_secmicappend23a(struct mic_data *pmicdata , u8 *src , u32 nbytes ) ;
#line 312
void rtw_secgetmic23a(struct mic_data *pmicdata , u8 *dst ) ;
#line 317
int rtw_aes_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 319
int rtw_tkip_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 329
void rtw_use_tkipkey_handler23a(void *FunctionContext ) ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void arcfour_init(struct arc4context *parc4ctx , u8 *key , u32 key_len ) 
{ 
  u32 t ;
  u32 u ;
  u32 keyindex ;
  u32 stateindex ;
  u8 *state ;
  u32 counter ;

  {
#line 40
  state = (u8 *)(& parc4ctx->state);
#line 41
  parc4ctx->x = 0U;
#line 42
  parc4ctx->y = 0U;
#line 43
  counter = 0U;
#line 43
  goto ldv_53190;
  ldv_53189: 
#line 44
  *(state + (unsigned long )counter) = (unsigned char )counter;
#line 43
  counter = counter + 1U;
  ldv_53190: ;
#line 43
  if (counter <= 255U) {
#line 45
    goto ldv_53189;
  } else {

  }
#line 45
  keyindex = 0U;
#line 46
  stateindex = 0U;
#line 47
  counter = 0U;
#line 47
  goto ldv_53193;
  ldv_53192: 
#line 48
  t = (u32 )*(state + (unsigned long )counter);
#line 49
  stateindex = (((u32 )*(key + (unsigned long )keyindex) + stateindex) + t) & 255U;
#line 50
  u = (u32 )*(state + (unsigned long )stateindex);
#line 51
  *(state + (unsigned long )stateindex) = (unsigned char )t;
#line 52
  *(state + (unsigned long )counter) = (unsigned char )u;
#line 53
  keyindex = keyindex + 1U;
#line 53
  if (keyindex >= key_len) {
#line 54
    keyindex = 0U;
  } else {

  }
#line 47
  counter = counter + 1U;
  ldv_53193: ;
#line 47
  if (counter <= 255U) {
#line 49
    goto ldv_53192;
  } else {

  }

#line 54
  return;
}
}
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static u32 arcfour_byte(struct arc4context *parc4ctx ) 
{ 
  u32 x ;
  u32 y ;
  u32 sx ;
  u32 sy ;
  u8 *state ;

  {
#line 66
  state = (u8 *)(& parc4ctx->state);
#line 67
  x = (parc4ctx->x + 1U) & 255U;
#line 68
  sx = (u32 )*(state + (unsigned long )x);
#line 69
  y = (parc4ctx->y + sx) & 255U;
#line 70
  sy = (u32 )*(state + (unsigned long )y);
#line 71
  parc4ctx->x = x;
#line 72
  parc4ctx->y = y;
#line 73
  *(state + (unsigned long )y) = (unsigned char )sx;
#line 74
  *(state + (unsigned long )x) = (unsigned char )sy;
#line 76
  return ((u32 )*(state + ((unsigned long )(sx + sy) & 255UL)));
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void arcfour_encrypt(struct arc4context *parc4ctx , u8 *dest , u8 *src , u32 len ) 
{ 
  u32 i ;
  u32 tmp ;

  {
#line 84
  i = 0U;
#line 84
  goto ldv_53211;
  ldv_53210: 
#line 85
  tmp = arcfour_byte(parc4ctx);
#line 85
  *(dest + (unsigned long )i) = (u8 )((int )*(src + (unsigned long )i) ^ (int )((unsigned char )tmp));
#line 84
  i = i + 1U;
  ldv_53211: ;
#line 84
  if (i < len) {
#line 86
    goto ldv_53210;
  } else {

  }

#line 91
  return;
}
}
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static int bcrc32initialized  ;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static u32 crc32_table[256U]  ;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static u8 crc32_reverseBit(u8 data ) 
{ 
  u8 retval ;

  {
#line 93
  retval = (u8 )((((((((int )((signed char )((int )data << 7)) | ((int )((signed char )((int )data << 5)) & 64)) | ((int )((signed char )((int )data << 3)) & 32)) | ((int )((signed char )((int )data << 1)) & 16)) | ((int )((signed char )((int )data >> 1)) & 8)) | ((int )((signed char )((int )data >> 3)) & 4)) | ((int )((signed char )((int )data >> 5)) & 2)) | (int )((signed char )((int )data >> 7)));
#line 97
  return (retval);
}
}
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void crc32_init(void) 
{ 
  int i ;
  int j ;
  u32 c ;
  u8 *p ;
  u8 *p1 ;
  u8 k ;

  {
#line 107
  if (bcrc32initialized == 1) {
#line 108
    return;
  } else {

  }
#line 110
  p = (u8 *)(& c);
#line 111
  c = 305397760U;
#line 113
  i = 0;
#line 113
  goto ldv_53232;
  ldv_53231: 
#line 114
  k = crc32_reverseBit((int )((unsigned char )i));
#line 116
  c = (unsigned int )k << 24;
#line 116
  j = 8;
#line 116
  goto ldv_53229;
  ldv_53228: 
#line 117
  c = (int )c < 0 ? (c << 1) ^ 79764919U : c << 1;
#line 116
  j = j - 1;
  ldv_53229: ;
#line 116
  if (j > 0) {
#line 118
    goto ldv_53228;
  } else {

  }
#line 119
  p1 = (u8 *)(& crc32_table) + (unsigned long )i;
#line 121
  *p1 = crc32_reverseBit((int )*(p + 3UL));
#line 122
  *(p1 + 1UL) = crc32_reverseBit((int )*(p + 2UL));
#line 123
  *(p1 + 2UL) = crc32_reverseBit((int )*(p + 1UL));
#line 124
  *(p1 + 3UL) = crc32_reverseBit((int )*p);
#line 113
  i = i + 1;
  ldv_53232: ;
#line 113
  if (i <= 255) {
#line 115
    goto ldv_53231;
  } else {

  }
#line 127
  bcrc32initialized = 1;
#line 128
  return;
}
}
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static u32 getcrc32(u8 *buf , int len ) 
{ 
  u8 *p ;
  u32 crc ;

  {
#line 135
  if (bcrc32initialized == 0) {
#line 136
    crc32_init();
  } else {

  }
#line 138
  crc = 4294967295U;
#line 140
  p = buf;
#line 140
  goto ldv_53241;
  ldv_53240: 
#line 141
  crc = crc32_table[((u32 )*p ^ crc) & 255U] ^ (crc >> 8);
#line 140
  p = p + 1;
#line 140
  len = len - 1;
  ldv_53241: ;
#line 140
  if (len > 0) {
#line 142
    goto ldv_53240;
  } else {

  }

#line 143
  return (~ crc);
}
}
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
void rtw_wep_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  unsigned char crc[4U] ;
  struct arc4context mycontext ;
  int curfragnum ;
  int length ;
  int index ;
  u32 keylength ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 wepkey[16U] ;
  u8 hw_hdr_offset ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;

  {
#line 157
  hw_hdr_offset = 0U;
#line 158
  pattrib = & pxmitframe->attrib;
#line 159
  psecuritypriv = & padapter->securitypriv;
#line 160
  pxmitpriv = & padapter->xmitpriv;
#line 162
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
#line 163
    return;
  } else {

  }
#line 165
  hw_hdr_offset = 40U;
#line 167
  pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
#line 170
  if (pattrib->encrypt != 1027073U && pattrib->encrypt != 1027077U) {
#line 172
    return;
  } else {

  }
#line 174
  index = (int )psecuritypriv->dot11PrivacyKeyIndex;
#line 175
  keylength = (u32 )psecuritypriv->wep_key[index].keylen;
#line 177
  curfragnum = 0;
#line 177
  goto ldv_53262;
  ldv_53261: 
#line 178
  iv = pframe + (unsigned long )pattrib->hdrlen;
#line 179
  memcpy((void *)(& wepkey), (void const   *)iv, 3UL);
#line 180
  memcpy((void *)(& wepkey) + 3U, (void const   *)(& psecuritypriv->wep_key[index].key),
           (size_t )keylength);
#line 182
  payload = pframe + ((unsigned long )pattrib->iv_len + (unsigned long )pattrib->hdrlen);
#line 184
  if (curfragnum + 1 == (int )pattrib->nr_frags) {
#line 186
    length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - (u32 )pattrib->icv_len);
#line 189
    *((u32 *)(& crc)) = getcrc32(payload, length);
#line 191
    arcfour_init(& mycontext, (u8 *)(& wepkey), keylength + 3U);
#line 192
    arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
#line 193
    arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                    4U);
  } else {
#line 195
    length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - (uint )pattrib->icv_len);
#line 197
    *((u32 *)(& crc)) = getcrc32(payload, length);
#line 198
    arcfour_init(& mycontext, (u8 *)(& wepkey), keylength + 3U);
#line 199
    arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
#line 200
    arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                    4U);
#line 202
    pframe = pframe + (unsigned long )pxmitpriv->frag_len;
#line 203
    pframe = (u8 *)(((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL);
  }
#line 177
  curfragnum = curfragnum + 1;
  ldv_53262: ;
#line 177
  if ((int )pattrib->nr_frags > curfragnum) {
#line 179
    goto ldv_53261;
  } else {

  }

#line 184
  return;
}
}
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
void rtw_wep_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) 
{ 
  u32 actual_crc ;
  u32 expected_crc ;
  struct arc4context mycontext ;
  int length ;
  u32 keylength ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 wepkey[16U] ;
  u8 keyindex ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct sk_buff *skb ;

  {
#line 219
  prxattrib = & precvframe->attrib;
#line 220
  psecuritypriv = & padapter->securitypriv;
#line 221
  skb = precvframe->pkt;
#line 223
  pframe = skb->data;
#line 226
  if (prxattrib->encrypt != 1027073U && prxattrib->encrypt != 1027077U) {
#line 228
    return;
  } else {

  }
#line 230
  iv = pframe + (unsigned long )prxattrib->hdrlen;
#line 232
  keyindex = prxattrib->key_index;
#line 233
  keylength = (u32 )psecuritypriv->wep_key[(int )keyindex].keylen;
#line 234
  memcpy((void *)(& wepkey), (void const   *)iv, 3UL);
#line 236
  memcpy((void *)(& wepkey) + 3U, (void const   *)(& psecuritypriv->wep_key[(int )keyindex].key),
           (size_t )keylength);
#line 237
  length = (int )((skb->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len);
#line 239
  payload = pframe + ((unsigned long )prxattrib->iv_len + (unsigned long )prxattrib->hdrlen);
#line 242
  arcfour_init(& mycontext, (u8 *)(& wepkey), keylength + 3U);
#line 243
  arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
#line 246
  actual_crc = getcrc32(payload, length + -4);
#line 247
  expected_crc = get_unaligned_le32((void const   *)(payload + ((unsigned long )length + 0xfffffffffffffffcUL)));
#line 249
  if (actual_crc != expected_crc) {
#line 250
    if (GlobalDebugLevel23A > 3U) {
#line 250
      rt_trace(4096, 4, "%s:icv CRC mismatch: actual: %08x, expected: %08x\n", "rtw_wep_decrypt23a",
               actual_crc, expected_crc);
    } else {

    }
  } else {

  }
#line 251
  return;
}
}
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static u32 secmicgetuint32(u8 *p ) 
{ 
  s32 i ;
  u32 res ;
  u8 *tmp ;

  {
#line 263
  res = 0U;
#line 265
  i = 0;
#line 265
  goto ldv_53288;
  ldv_53287: 
#line 266
  tmp = p;
#line 266
  p = p + 1;
#line 266
  res = ((unsigned int )*tmp << i * 8) | res;
#line 265
  i = i + 1;
  ldv_53288: ;
#line 265
  if (i <= 3) {
#line 267
    goto ldv_53287;
  } else {

  }

#line 268
  return (res);
}
}
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void secmicputuint32(u8 *p , u32 val ) 
{ 
  long i ;
  u8 *tmp ;

  {
#line 276
  i = 0L;
#line 276
  goto ldv_53296;
  ldv_53295: 
#line 277
  tmp = p;
#line 277
  p = p + 1;
#line 277
  *tmp = (unsigned char )val;
#line 278
  val = val >> 8;
#line 276
  i = i + 1L;
  ldv_53296: ;
#line 276
  if (i <= 3L) {
#line 278
    goto ldv_53295;
  } else {

  }

#line 283
  return;
}
}
#line 283 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void secmicclear(struct mic_data *pmicdata ) 
{ 


  {
#line 287
  pmicdata->L = pmicdata->K0;
#line 288
  pmicdata->R = pmicdata->K1;
#line 289
  pmicdata->nBytesInM = 0U;
#line 290
  pmicdata->M = 0U;
#line 291
  return;
}
}
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
void rtw_secmicsetkey23a(struct mic_data *pmicdata , u8 *key ) 
{ 


  {
#line 298
  pmicdata->K0 = secmicgetuint32(key);
#line 299
  pmicdata->K1 = secmicgetuint32(key + 4UL);
#line 301
  secmicclear(pmicdata);
#line 302
  return;
}
}
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
void rtw_secmicappend23abyte23a(struct mic_data *pmicdata , u8 b ) 
{ 


  {
#line 309
  pmicdata->M = pmicdata->M | (u32 )((unsigned long )b << (int )(pmicdata->nBytesInM * 8U));
#line 310
  pmicdata->nBytesInM = pmicdata->nBytesInM + 1U;
#line 312
  if (pmicdata->nBytesInM > 3U) {
#line 313
    pmicdata->L = pmicdata->L ^ pmicdata->M;
#line 314
    pmicdata->R = pmicdata->R ^ ((pmicdata->L >> 15) | (pmicdata->L << (8UL * sizeof(pmicdata->L) - 15UL)));
#line 315
    pmicdata->L = pmicdata->L + pmicdata->R;
#line 316
    pmicdata->R = pmicdata->R ^ (((pmicdata->L & 4278255360U) >> 8) | ((pmicdata->L & 16711935U) << 8));
#line 317
    pmicdata->L = pmicdata->L + pmicdata->R;
#line 318
    pmicdata->R = pmicdata->R ^ ((pmicdata->L >> 29) | (pmicdata->L << (8UL * sizeof(pmicdata->L) - 29UL)));
#line 319
    pmicdata->L = pmicdata->L + pmicdata->R;
#line 320
    pmicdata->R = pmicdata->R ^ ((pmicdata->L >> 2) | (pmicdata->L << (8UL * sizeof(pmicdata->L) - 2UL)));
#line 321
    pmicdata->L = pmicdata->L + pmicdata->R;
#line 323
    pmicdata->M = 0U;
#line 324
    pmicdata->nBytesInM = 0U;
  } else {

  }
#line 326
  return;
}
}
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
void rtw_secmicappend23a(struct mic_data *pmicdata , u8 *src , u32 nbytes ) 
{ 
  u8 *tmp ;

  {
#line 333
  goto ldv_53315;
  ldv_53314: 
#line 334
  tmp = src;
#line 334
  src = src + 1;
#line 334
  rtw_secmicappend23abyte23a(pmicdata, (int )*tmp);
#line 335
  nbytes = nbytes - 1U;
  ldv_53315: ;
#line 333
  if (nbytes != 0U) {
#line 335
    goto ldv_53314;
  } else {

  }

#line 340
  return;
}
}
#line 340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
void rtw_secgetmic23a(struct mic_data *pmicdata , u8 *dst ) 
{ 


  {
#line 344
  rtw_secmicappend23abyte23a(pmicdata, 90);
#line 345
  rtw_secmicappend23abyte23a(pmicdata, 0);
#line 346
  rtw_secmicappend23abyte23a(pmicdata, 0);
#line 347
  rtw_secmicappend23abyte23a(pmicdata, 0);
#line 348
  rtw_secmicappend23abyte23a(pmicdata, 0);
#line 350
  goto ldv_53322;
  ldv_53321: 
#line 351
  rtw_secmicappend23abyte23a(pmicdata, 0);
  ldv_53322: ;
#line 350
  if (pmicdata->nBytesInM != 0U) {
#line 352
    goto ldv_53321;
  } else {

  }
#line 353
  secmicputuint32(dst, pmicdata->L);
#line 354
  secmicputuint32(dst + 4UL, pmicdata->R);
#line 356
  secmicclear(pmicdata);
#line 357
  return;
}
}
#line 360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
void rtw_seccalctkipmic23a(u8 *key , u8 *header , u8 *data , u32 data_len , u8 *mic_code ,
                           u8 pri ) 
{ 
  struct mic_data micdata ;
  u8 priority[4U] ;

  {
#line 365
  priority[0] = 0U;
#line 365
  priority[1] = 0U;
#line 365
  priority[2] = 0U;
#line 365
  priority[3] = 0U;
#line 367
  rtw_secmicsetkey23a(& micdata, key);
#line 368
  priority[0] = pri;
#line 371
  if ((int )*(header + 1UL) & 1) {
#line 372
    rtw_secmicappend23a(& micdata, header + 16UL, 6U);
#line 373
    if (((int )*(header + 1UL) & 2) != 0) {
#line 374
      rtw_secmicappend23a(& micdata, header + 24UL, 6U);
    } else {
#line 376
      rtw_secmicappend23a(& micdata, header + 10UL, 6U);
    }
  } else {
#line 378
    rtw_secmicappend23a(& micdata, header + 4UL, 6U);
#line 379
    if (((int )*(header + 1UL) & 2) != 0) {
#line 380
      rtw_secmicappend23a(& micdata, header + 16UL, 6U);
    } else {
#line 382
      rtw_secmicappend23a(& micdata, header + 10UL, 6U);
    }
  }
#line 385
  rtw_secmicappend23a(& micdata, (u8 *)(& priority), 4U);
#line 387
  rtw_secmicappend23a(& micdata, data, data_len);
#line 389
  rtw_secgetmic23a(& micdata, mic_code);
#line 390
  return;
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static unsigned short const   Sbox1[2U][256U]  = { {        50853U,        63620U,        61081U,        63117U, 
            65293U,        54973U,        57009U,        37204U, 
            24656U,        515U,        52905U,        22141U, 
            59161U,        46434U,        19942U,        60570U, 
            36677U,        8093U,        35136U,        64135U, 
            61205U,        45803U,        36553U,        64267U, 
            16876U,        45927U,        24573U,        17898U, 
            9151U,        21495U,        58518U,        39771U, 
            30146U,        57628U,        15790U,        19562U, 
            27738U,        32321U,        62722U,        33615U, 
            26716U,        20980U,        53556U,        63752U, 
            58003U,        43891U,        25171U,        10815U, 
            2060U,        38226U,        18021U,        40286U, 
            12328U,        14241U,        2575U,        12213U, 
            3593U,        9270U,        7067U,        57149U, 
            52518U,        20073U,        32717U,        60063U, 
            4635U,        7582U,        22644U,        13358U, 
            13869U,        56498U,        46318U,        23547U, 
            42230U,        30285U,        46945U,        32206U, 
            21115U,        56638U,        24177U,        5015U, 
            42741U,        47464U,        0U,        49452U, 
            16480U,        58143U,        31176U,        46829U, 
            54462U,        36166U,        26585U,        29259U, 
            38110U,        39124U,        45288U,        34122U, 
            47979U,        50474U,        20453U,        60694U, 
            34501U,        39639U,        26197U,        4500U, 
            35535U,        59664U,        1030U,        65153U, 
            41200U,        30788U,        9658U,        19427U, 
            41715U,        24062U,        32960U,        1418U, 
            16301U,        8636U,        28744U,        61700U, 
            25567U,        30657U,        44917U,        16995U, 
            8240U,        58650U,        64782U,        49005U, 
            33100U,        6164U,        9781U,        49967U, 
            48865U,        13730U,        35020U,        11833U, 
            37719U,        22002U,        64642U,        31303U, 
            51372U,        47847U,        12843U,        59029U, 
            49312U,        6552U,        40657U,        41855U, 
            17510U,        21630U,        15275U,        2947U, 
            36042U,        50985U,        27603U,        10300U, 
            42873U,        48354U,        5661U,        44406U, 
            56123U,        25686U,        29774U,        5150U, 
            37595U,        3082U,        18540U,        47332U, 
            40797U,        48494U,        17391U,        50342U, 
            14760U,        12708U,        54071U,        62091U, 
            54578U,        35651U,        28249U,        55991U, 
            396U,        45412U,        40146U,        18912U, 
            55476U,        44282U,        62215U,        53029U, 
            51887U,        62606U,        18409U,        4120U, 
            28629U,        61576U,        19055U,        23666U, 
            14372U,        22513U,        29639U,        38737U, 
            52003U,        41340U,        59548U,        15905U, 
            38621U,        25052U,        3462U,        3973U, 
            57488U,        31810U,        29124U,        52394U, 
            37080U,        1541U,        63233U,        7186U, 
            49827U,        27231U,        44793U,        27088U, 
            6033U,        39256U,        14887U,        10169U, 
            55608U,        60179U,        11187U,        8755U, 
            53947U,        43376U,        1929U,        13223U, 
            11702U,        15394U,        5522U,        51488U, 
            34633U,        43775U,        20600U,        42362U, 
            911U,        23032U,        2432U,        6679U, 
            26074U,        55089U,        33990U,        53432U, 
            33475U,        10672U,        23159U,        7697U, 
            31691U,        43260U,        28118U,        11322U}, 
   {        42438U,        34040U,        39406U,        36342U, 
            3583U,        48598U,        45534U,        21649U, 
            20576U,        770U,        43470U,        32086U, 
            6631U,        25269U,        58957U,        39660U, 
            17807U,        40223U,        16521U,        34810U, 
            5615U,        60338U,        51598U,        3067U, 
            60481U,        26547U,        64863U,        59973U, 
            48931U,        63315U,        38628U,        23451U, 
            49781U,        7393U,        44605U,        27212U, 
            23148U,        16766U,        757U,        20355U, 
            23656U,        62545U,        13521U,        2297U, 
            37858U,        29611U,        21346U,        16170U, 
            3080U,        21141U,        25926U,        24221U, 
            10288U,        41271U,        3850U,        46383U, 
            2318U,        13860U,        39707U,        15839U, 
            9933U,        26958U,        52607U,        40938U, 
            6930U,        40477U,        29784U,        11828U, 
            11574U,        45788U,        61108U,        64347U, 
            63140U,        19830U,        25015U,        52861U, 
            31570U,        16093U,        29022U,        38675U, 
            62886U,        26809U,        0U,        11457U, 
            24640U,        8163U,        51321U,        60854U, 
            48852U,        18061U,        55655U,        19314U, 
            56980U,        54424U,        59568U,        19077U, 
            27579U,        10949U,        58703U,        5869U, 
            50566U,        55194U,        21862U,        37905U, 
            53130U,        4329U,        1540U,        33278U, 
            61600U,        17528U,        47653U,        58187U, 
            62370U,        65117U,        49280U,        35333U, 
            44351U,        48161U,        18544U,        1265U, 
            57187U,        49527U,        30127U,        25410U, 
            12320U,        6885U,        3837U,        28095U, 
            19585U,        5144U,        13606U,        12227U, 
            57790U,        41525U,        52360U,        14638U, 
            22419U,        62037U,        33532U,        18298U, 
            44232U,        59322U,        11058U,        38374U, 
            41152U,        38937U,        53662U,        32675U, 
            26180U,        32340U,        43835U,        33547U, 
            51852U,        10695U,        54123U,        15400U, 
            31143U,        58044U,        7446U,        30381U, 
            15323U,        22116U,        20084U,        7700U, 
            56210U,        2572U,        27720U,        58552U, 
            23967U,        28349U,        61251U,        42692U, 
            43065U,        42033U,        14291U,        35826U, 
            13013U,        17291U,        22894U,        47066U, 
            35841U,        25777U,        53916U,        57417U, 
            46296U,        64172U,        2035U,        9679U, 
            45002U,        36596U,        59719U,        6160U, 
            54639U,        35056U,        28490U,        29276U, 
            9272U,        61783U,        51059U,        20887U, 
            9163U,        31905U,        40168U,        8510U, 
            56726U,        56417U,        34317U,        34063U, 
            37088U,        17020U,        50289U,        43724U, 
            55440U,        1286U,        503U,        4636U, 
            41922U,        24426U,        63918U,        53353U, 
            37143U,        22681U,        10042U,        47399U, 
            14553U,        5099U,        45867U,        13090U, 
            48082U,        28841U,        35079U,        42803U, 
            46637U,        8764U,        37397U,        8393U, 
            18823U,        65450U,        30800U,        31397U, 
            36611U,        63577U,        32777U,        5914U, 
            55909U,        12759U,        50820U,        47312U, 
            50050U,        45097U,        30554U,        4382U, 
            52091U,        64680U,        54893U,        14892U}};
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void phase1(u16 *p1k , u8 const   *tk , u8 const   *ta , u32 iv32 ) 
{ 
  int i ;

  {
#line 509
  *p1k = (unsigned short )iv32;
#line 510
  *(p1k + 1UL) = (unsigned short )(iv32 >> 16);
#line 511
  *(p1k + 2UL) = (u16 )((int )((short )*ta) ^ (int )((short )((int )*(ta + 1UL) << 8)));
#line 512
  *(p1k + 3UL) = (u16 )((int )((short )*(ta + 2UL)) ^ (int )((short )((int )*(ta + 3UL) << 8)));
#line 513
  *(p1k + 4UL) = (u16 )((int )((short )*(ta + 4UL)) ^ (int )((short )((int )*(ta + 5UL) << 8)));
#line 517
  i = 0;
#line 517
  goto ldv_53343;
  ldv_53342: 
#line 519
  *p1k = (int )*p1k + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 4UL)) ^ ((int )((signed char )*(tk + (unsigned long )((i & 1) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 4UL) ^ ((int )*(tk + (unsigned long )((i & 1) * 2)) ^ ((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8))) >> 8))])));
#line 520
  *(p1k + 1UL) = (int )*(p1k + 1UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*p1k) ^ ((int )((signed char )*(tk + (unsigned long )(((i & 1) + 2) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )(((i & 1) + 2) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*p1k ^ ((int )*(tk + (unsigned long )(((i & 1) + 2) * 2)) ^ ((int )*(tk + ((unsigned long )(((i & 1) + 2) * 2) + 1UL)) << 8))) >> 8))])));
#line 521
  *(p1k + 2UL) = (int )*(p1k + 2UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 1UL)) ^ ((int )((signed char )*(tk + (unsigned long )(((i & 1) + 4) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )(((i & 1) + 4) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 1UL) ^ ((int )*(tk + (unsigned long )(((i & 1) + 4) * 2)) ^ ((int )*(tk + ((unsigned long )(((i & 1) + 4) * 2) + 1UL)) << 8))) >> 8))])));
#line 522
  *(p1k + 3UL) = (int )*(p1k + 3UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 2UL)) ^ ((int )((signed char )*(tk + (unsigned long )(((i & 1) + 6) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )(((i & 1) + 6) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 2UL) ^ ((int )*(tk + (unsigned long )(((i & 1) + 6) * 2)) ^ ((int )*(tk + ((unsigned long )(((i & 1) + 6) * 2) + 1UL)) << 8))) >> 8))])));
#line 523
  *(p1k + 4UL) = (int )*(p1k + 4UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 3UL)) ^ ((int )((signed char )*(tk + (unsigned long )((i & 1) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 3UL) ^ ((int )*(tk + (unsigned long )((i & 1) * 2)) ^ ((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8))) >> 8))])));
#line 524
  *(p1k + 4UL) = (int )*(p1k + 4UL) + (int )((u16 )i);
#line 517
  i = i + 1;
  ldv_53343: ;
#line 517
  if (i <= 7) {
#line 519
    goto ldv_53342;
  } else {

  }

#line 524
  return;
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void phase2(u8 *rc4key , u8 const   *tk , u16 const   *p1k , u16 iv16 ) 
{ 
  int i ;
  u16 PPK[6U] ;

  {
#line 558
  i = 0;
#line 558
  goto ldv_53354;
  ldv_53353: 
#line 559
  PPK[i] = *(p1k + (unsigned long )i);
#line 558
  i = i + 1;
  ldv_53354: ;
#line 558
  if (i <= 4) {
#line 560
    goto ldv_53353;
  } else {

  }
#line 561
  PPK[5] = (int )((u16 )*(p1k + 4UL)) + (int )iv16;
#line 564
  PPK[0] = (int )PPK[0] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[5]) ^ ((int )((signed char )*tk) ^ (int )((signed char )((int )*(tk + 1UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[5] ^ ((int )*tk ^ ((int )*(tk + 1UL) << 8))) >> 8))])));
#line 565
  PPK[1] = (int )PPK[1] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[0]) ^ ((int )((signed char )*(tk + 2UL)) ^ (int )((signed char )((int )*(tk + 3UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[0] ^ ((int )*(tk + 2UL) ^ ((int )*(tk + 3UL) << 8))) >> 8))])));
#line 566
  PPK[2] = (int )PPK[2] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[1]) ^ ((int )((signed char )*(tk + 4UL)) ^ (int )((signed char )((int )*(tk + 5UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[1] ^ ((int )*(tk + 4UL) ^ ((int )*(tk + 5UL) << 8))) >> 8))])));
#line 567
  PPK[3] = (int )PPK[3] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[2]) ^ ((int )((signed char )*(tk + 6UL)) ^ (int )((signed char )((int )*(tk + 7UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[2] ^ ((int )*(tk + 6UL) ^ ((int )*(tk + 7UL) << 8))) >> 8))])));
#line 568
  PPK[4] = (int )PPK[4] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[3]) ^ ((int )((signed char )*(tk + 8UL)) ^ (int )((signed char )((int )*(tk + 9UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[3] ^ ((int )*(tk + 8UL) ^ ((int )*(tk + 9UL) << 8))) >> 8))])));
#line 569
  PPK[5] = (int )PPK[5] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[4]) ^ ((int )((signed char )*(tk + 10UL)) ^ (int )((signed char )((int )*(tk + 11UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[4] ^ ((int )*(tk + 10UL) ^ ((int )*(tk + 11UL) << 8))) >> 8))])));
#line 572
  PPK[0] = (int )PPK[0] + (int )((u16 )(((int )((short )(((int )PPK[5] ^ ((int )*(tk + 12UL) ^ ((int )*(tk + 13UL) << 8))) >> 1)) & 32767) ^ (int )((short )(((int )PPK[5] ^ ((int )*(tk + 12UL) ^ ((int )*(tk + 13UL) << 8))) << 15))));
#line 573
  PPK[1] = (int )PPK[1] + (int )((u16 )(((int )((short )(((int )PPK[0] ^ ((int )*(tk + 14UL) ^ ((int )*(tk + 15UL) << 8))) >> 1)) & 32767) ^ (int )((short )(((int )PPK[0] ^ ((int )*(tk + 14UL) ^ ((int )*(tk + 15UL) << 8))) << 15))));
#line 574
  PPK[2] = (int )PPK[2] + (int )((u16 )((int )((short )((int )PPK[1] >> 1)) ^ (int )((short )((int )PPK[1] << 15))));
#line 575
  PPK[3] = (int )PPK[3] + (int )((u16 )((int )((short )((int )PPK[2] >> 1)) ^ (int )((short )((int )PPK[2] << 15))));
#line 576
  PPK[4] = (int )PPK[4] + (int )((u16 )((int )((short )((int )PPK[3] >> 1)) ^ (int )((short )((int )PPK[3] << 15))));
#line 577
  PPK[5] = (int )PPK[5] + (int )((u16 )((int )((short )((int )PPK[4] >> 1)) ^ (int )((short )((int )PPK[4] << 15))));
#line 584
  *rc4key = (unsigned char )((int )iv16 >> 8);
#line 585
  *(rc4key + 1UL) = ((unsigned int )((u8 )((int )iv16 >> 8)) & 95U) | 32U;
#line 586
  *(rc4key + 2UL) = (unsigned char )iv16;
#line 587
  *(rc4key + 3UL) = (unsigned char )(((int )PPK[5] ^ ((int )*tk ^ ((int )*(tk + 1UL) << 8))) >> 1);
#line 590
  i = 0;
#line 590
  goto ldv_53357;
  ldv_53356: 
#line 591
  *(rc4key + (unsigned long )((i + 2) * 2)) = (unsigned char )PPK[i];
#line 592
  *(rc4key + (unsigned long )(i * 2 + 5)) = (unsigned char )((int )PPK[i] >> 8);
#line 590
  i = i + 1;
  ldv_53357: ;
#line 590
  if (i <= 5) {
#line 592
    goto ldv_53356;
  } else {

  }

#line 597
  return;
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
int rtw_tkip_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  u16 pnl ;
  u32 pnh ;
  u8 rc4key[16U] ;
  u8 ttkey[16U] ;
  u8 crc[4U] ;
  u8 hw_hdr_offset ;
  struct arc4context mycontext ;
  int curfragnum ;
  int length ;
  u32 prwskeylen ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 *prwskey ;
  union pn48 dot11txpn ;
  struct sta_info *stainfo ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;
  int res ;
  bool tmp ;

  {
#line 606
  hw_hdr_offset = 0U;
#line 613
  pattrib = & pxmitframe->attrib;
#line 614
  psecuritypriv = & padapter->securitypriv;
#line 615
  pxmitpriv = & padapter->xmitpriv;
#line 616
  res = 1;
#line 618
  if (pattrib->encrypt != 1027074U) {
#line 619
    return (0);
  } else {

  }
#line 621
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
#line 622
    return (0);
  } else {

  }
#line 624
  hw_hdr_offset = 40U;
#line 626
  pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
#line 628
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 629
    stainfo = pattrib->psta;
  } else {
#line 631
    if (GlobalDebugLevel23A > 3U) {
#line 631
      printk("\016RTL8723AU: %s, call rtw_get_stainfo()\n", "rtw_tkip_encrypt23a");
    } else {

    }
#line 632
    stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
#line 636
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
#line 637
    if (GlobalDebugLevel23A > 3U) {
#line 637
      rt_trace(4096, 4, "%s: stainfo == NULL!!!\n", "rtw_tkip_encrypt23a");
    } else {

    }
#line 639
    if (GlobalDebugLevel23A > 3U) {
#line 639
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_tkip_encrypt23a");
    } else {

    }
#line 640
    return (0);
  } else {

  }
#line 643
  if (GlobalDebugLevel23A > 3U) {
#line 643
    rt_trace(4096, 4, "%s: stainfo!= NULL!!!\n", "rtw_tkip_encrypt23a");
  } else {

  }
#line 646
  if ((stainfo->state & 1U) == 0U) {
#line 647
    if (GlobalDebugLevel23A > 3U) {
#line 647
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_tkip_encrypt23a",
             stainfo->state);
    } else {

    }
#line 648
    return (0);
  } else {

  }
#line 651
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 651
  if ((int )tmp) {
#line 652
    prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey);
  } else {
#line 654
    prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
  }
#line 656
  prwskeylen = 16U;
#line 659
  curfragnum = 0;
#line 659
  goto ldv_53385;
  ldv_53384: 
#line 660
  iv = pframe + (unsigned long )pattrib->hdrlen;
#line 661
  payload = pframe + ((unsigned long )pattrib->iv_len + (unsigned long )pattrib->hdrlen);
#line 663
  dot11txpn._byte_.TSC0 = *(iv + 2UL);
#line 663
  dot11txpn._byte_.TSC1 = *iv;
#line 663
  dot11txpn._byte_.TSC2 = *(iv + 4UL);
#line 663
  dot11txpn._byte_.TSC3 = *(iv + 5UL);
#line 663
  dot11txpn._byte_.TSC4 = *(iv + 6UL);
#line 663
  dot11txpn._byte_.TSC5 = *(iv + 7UL);
#line 665
  pnl = (unsigned short )dot11txpn.val;
#line 666
  pnh = (unsigned int )(dot11txpn.val >> 16);
#line 668
  phase1((u16 *)(& ttkey), (u8 const   *)prwskey, (u8 const   *)(& pattrib->ta), pnh);
#line 670
  phase2((u8 *)(& rc4key), (u8 const   *)prwskey, (u16 const   *)(& ttkey), (int )pnl);
#line 672
  if (curfragnum + 1 == (int )pattrib->nr_frags) {
#line 673
    length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - (u32 )pattrib->icv_len);
#line 678
    if (GlobalDebugLevel23A > 6U) {
#line 678
      rt_trace(4096, 7, "pattrib->iv_len =%x, pattrib->icv_len =%x\n", (int )pattrib->iv_len,
               (int )pattrib->icv_len);
    } else {

    }
#line 682
    *((u32 *)(& crc)) = getcrc32(payload, length);
#line 684
    arcfour_init(& mycontext, (u8 *)(& rc4key), 16U);
#line 685
    arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
#line 686
    arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                    4U);
  } else {
#line 689
    length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - (uint )pattrib->icv_len);
#line 694
    *((u32 *)(& crc)) = getcrc32(payload, length);
#line 695
    arcfour_init(& mycontext, (u8 *)(& rc4key), 16U);
#line 696
    arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
#line 697
    arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                    4U);
#line 699
    pframe = pframe + (unsigned long )pxmitpriv->frag_len;
#line 700
    pframe = (u8 *)(((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL);
  }
#line 659
  curfragnum = curfragnum + 1;
  ldv_53385: ;
#line 659
  if ((int )pattrib->nr_frags > curfragnum) {
#line 661
    goto ldv_53384;
  } else {

  }

#line 704
  return (res);
}
}
#line 708 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
int rtw_tkip_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) 
{ 
  u16 pnl ;
  u32 pnh ;
  u8 rc4key[16U] ;
  u8 ttkey[16U] ;
  u32 actual_crc ;
  u32 expected_crc ;
  struct arc4context mycontext ;
  int length ;
  u32 prwskeylen ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 *prwskey ;
  union pn48 dot11txpn ;
  struct sta_info *stainfo ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct sk_buff *skb ;
  int res ;
  bool tmp ;

  {
#line 722
  prxattrib = & precvframe->attrib;
#line 723
  psecuritypriv = & padapter->securitypriv;
#line 724
  skb = precvframe->pkt;
#line 725
  res = 1;
#line 727
  if (prxattrib->encrypt != 1027074U) {
#line 728
    return (0);
  } else {

  }
#line 730
  pframe = skb->data;
#line 732
  stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& prxattrib->ta));
#line 734
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
#line 735
    if (GlobalDebugLevel23A > 3U) {
#line 735
      rt_trace(4096, 4, "%s: stainfo == NULL!!!\n", "rtw_tkip_decrypt23a");
    } else {

    }
#line 737
    return (0);
  } else {

  }
#line 741
  tmp = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
#line 741
  if ((int )tmp) {
#line 742
    if ((unsigned int )*((unsigned char *)psecuritypriv + 580UL) == 0U) {
#line 743
      res = 0;
#line 744
      if (GlobalDebugLevel23A > 3U) {
#line 744
        printk("\016RTL8723AU: %s:rx bc/mc packets, but didn\'t install group key!!!!!!!!!!\n",
               "rtw_tkip_decrypt23a");
      } else {

      }
#line 745
      goto exit;
    } else {

    }
#line 747
    prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[(int )prxattrib->key_index].skey);
#line 748
    prwskeylen = 16U;
  } else {
#line 750
    if (GlobalDebugLevel23A > 3U) {
#line 750
      rt_trace(4096, 4, "%s: stainfo!= NULL!!!\n", "rtw_tkip_decrypt23a");
    } else {

    }
#line 752
    prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
#line 753
    prwskeylen = 16U;
  }
#line 756
  iv = pframe + (unsigned long )prxattrib->hdrlen;
#line 757
  payload = pframe + ((unsigned long )prxattrib->iv_len + (unsigned long )prxattrib->hdrlen);
#line 758
  length = (int )((skb->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len);
#line 760
  dot11txpn._byte_.TSC0 = *(iv + 2UL);
#line 760
  dot11txpn._byte_.TSC1 = *iv;
#line 760
  dot11txpn._byte_.TSC2 = *(iv + 4UL);
#line 760
  dot11txpn._byte_.TSC3 = *(iv + 5UL);
#line 760
  dot11txpn._byte_.TSC4 = *(iv + 6UL);
#line 760
  dot11txpn._byte_.TSC5 = *(iv + 7UL);
#line 762
  pnl = (unsigned short )dot11txpn.val;
#line 763
  pnh = (unsigned int )(dot11txpn.val >> 16);
#line 765
  phase1((u16 *)(& ttkey), (u8 const   *)prwskey, (u8 const   *)(& prxattrib->ta),
         pnh);
#line 766
  phase2((u8 *)(& rc4key), (u8 const   *)prwskey, (u16 const   *)(& ttkey), (int )pnl);
#line 769
  arcfour_init(& mycontext, (u8 *)(& rc4key), 16U);
#line 770
  arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
#line 772
  actual_crc = getcrc32(payload, length + -4);
#line 773
  expected_crc = get_unaligned_le32((void const   *)(payload + ((unsigned long )length + 0xfffffffffffffffcUL)));
#line 775
  if (actual_crc != expected_crc) {
#line 776
    if (GlobalDebugLevel23A > 3U) {
#line 776
      rt_trace(4096, 4, "%s:icv CRC mismatch: actual: %08x, expected: %08x\n", "rtw_tkip_decrypt23a",
               actual_crc, expected_crc);
    } else {

    }
#line 780
    res = 0;
  } else {

  }
  exit: ;
#line 784
  return (res);
}
}
#line 794 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static u8 sbox_table[256U]  = 
#line 794
  {      99U,      124U,      119U,      123U, 
        242U,      107U,      111U,      197U, 
        48U,      1U,      103U,      43U, 
        254U,      215U,      171U,      118U, 
        202U,      130U,      201U,      125U, 
        250U,      89U,      71U,      240U, 
        173U,      212U,      162U,      175U, 
        156U,      164U,      114U,      192U, 
        183U,      253U,      147U,      38U, 
        54U,      63U,      247U,      204U, 
        52U,      165U,      229U,      241U, 
        113U,      216U,      49U,      21U, 
        4U,      199U,      35U,      195U, 
        24U,      150U,      5U,      154U, 
        7U,      18U,      128U,      226U, 
        235U,      39U,      178U,      117U, 
        9U,      131U,      44U,      26U, 
        27U,      110U,      90U,      160U, 
        82U,      59U,      214U,      179U, 
        41U,      227U,      47U,      132U, 
        83U,      209U,      0U,      237U, 
        32U,      252U,      177U,      91U, 
        106U,      203U,      190U,      57U, 
        74U,      76U,      88U,      207U, 
        208U,      239U,      170U,      251U, 
        67U,      77U,      51U,      133U, 
        69U,      249U,      2U,      127U, 
        80U,      60U,      159U,      168U, 
        81U,      163U,      64U,      143U, 
        146U,      157U,      56U,      245U, 
        188U,      182U,      218U,      33U, 
        16U,      255U,      243U,      210U, 
        205U,      12U,      19U,      236U, 
        95U,      151U,      68U,      23U, 
        196U,      167U,      126U,      61U, 
        100U,      93U,      25U,      115U, 
        96U,      129U,      79U,      220U, 
        34U,      42U,      144U,      136U, 
        70U,      238U,      184U,      20U, 
        222U,      94U,      11U,      219U, 
        224U,      50U,      58U,      10U, 
        73U,      6U,      36U,      92U, 
        194U,      211U,      172U,      98U, 
        145U,      149U,      228U,      121U, 
        231U,      200U,      55U,      109U, 
        141U,      213U,      78U,      169U, 
        108U,      86U,      244U,      234U, 
        101U,      122U,      174U,      8U, 
        186U,      120U,      37U,      46U, 
        28U,      166U,      180U,      198U, 
        232U,      221U,      116U,      31U, 
        75U,      189U,      139U,      138U, 
        112U,      62U,      181U,      102U, 
        72U,      3U,      246U,      14U, 
        97U,      53U,      87U,      185U, 
        134U,      193U,      29U,      158U, 
        225U,      248U,      152U,      17U, 
        105U,      217U,      142U,      148U, 
        155U,      30U,      135U,      233U, 
        206U,      85U,      40U,      223U, 
        140U,      161U,      137U,      13U, 
        191U,      230U,      66U,      104U, 
        65U,      153U,      45U,      15U, 
        176U,      84U,      187U,      22U};
#line 833
static void construct_mic_header2(u8 *mic_header2 , u8 *mpdu , int a4_exists , int qc_exists ) ;
#line 836 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void xor_128(u8 *a , u8 *b , u8 *out ) 
{ 
  int i ;

  {
#line 840
  i = 0;
#line 840
  goto ldv_53425;
  ldv_53424: 
#line 841
  *(out + (unsigned long )i) = (u8 )((int )*(a + (unsigned long )i) ^ (int )*(b + (unsigned long )i));
#line 840
  i = i + 1;
  ldv_53425: ;
#line 840
  if (i <= 15) {
#line 842
    goto ldv_53424;
  } else {

  }

#line 847
  return;
}
}
#line 844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void xor_32(u8 *a , u8 *b , u8 *out ) 
{ 
  int i ;

  {
#line 848
  i = 0;
#line 848
  goto ldv_53434;
  ldv_53433: 
#line 849
  *(out + (unsigned long )i) = (u8 )((int )*(a + (unsigned long )i) ^ (int )*(b + (unsigned long )i));
#line 848
  i = i + 1;
  ldv_53434: ;
#line 848
  if (i <= 3) {
#line 850
    goto ldv_53433;
  } else {

  }

#line 855
  return;
}
}
#line 852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static u8 sbox(u8 a ) 
{ 


  {
#line 854
  return (sbox_table[(int )a]);
}
}
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void next_key(u8 *key , int round ) 
{ 
  u8 rcon___0 ;
  u8 sbox_key[4U] ;
  u8 rcon_table[12U] ;

  {
#line 861
  rcon_table[0] = 1U;
#line 861
  rcon_table[1] = 2U;
#line 861
  rcon_table[2] = 4U;
#line 861
  rcon_table[3] = 8U;
#line 861
  rcon_table[4] = 16U;
#line 861
  rcon_table[5] = 32U;
#line 861
  rcon_table[6] = 64U;
#line 861
  rcon_table[7] = 128U;
#line 861
  rcon_table[8] = 27U;
#line 861
  rcon_table[9] = 54U;
#line 861
  rcon_table[10] = 54U;
#line 861
  rcon_table[11] = 54U;
#line 866
  sbox_key[0] = sbox((int )*(key + 13UL));
#line 867
  sbox_key[1] = sbox((int )*(key + 14UL));
#line 868
  sbox_key[2] = sbox((int )*(key + 15UL));
#line 869
  sbox_key[3] = sbox((int )*(key + 12UL));
#line 871
  rcon___0 = rcon_table[round];
#line 873
  xor_32(key, (u8 *)(& sbox_key), key);
#line 874
  *key = (u8 )((int )*key ^ (int )rcon___0);
#line 876
  xor_32(key + 4UL, key, key + 4UL);
#line 877
  xor_32(key + 8UL, key + 4UL, key + 8UL);
#line 878
  xor_32(key + 12UL, key + 8UL, key + 12UL);
#line 879
  return;
}
}
#line 882 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void byte_sub(u8 *in , u8 *out ) 
{ 
  int i ;

  {
#line 886
  i = 0;
#line 886
  goto ldv_53452;
  ldv_53451: 
#line 887
  *(out + (unsigned long )i) = sbox((int )*(in + (unsigned long )i));
#line 886
  i = i + 1;
  ldv_53452: ;
#line 886
  if (i <= 15) {
#line 888
    goto ldv_53451;
  } else {

  }

#line 893
  return;
}
}
#line 890 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void shift_row(u8 *in , u8 *out ) 
{ 


  {
#line 893
  *out = *in;
#line 894
  *(out + 1UL) = *(in + 5UL);
#line 895
  *(out + 2UL) = *(in + 10UL);
#line 896
  *(out + 3UL) = *(in + 15UL);
#line 897
  *(out + 4UL) = *(in + 4UL);
#line 898
  *(out + 5UL) = *(in + 9UL);
#line 899
  *(out + 6UL) = *(in + 14UL);
#line 900
  *(out + 7UL) = *(in + 3UL);
#line 901
  *(out + 8UL) = *(in + 8UL);
#line 902
  *(out + 9UL) = *(in + 13UL);
#line 903
  *(out + 10UL) = *(in + 2UL);
#line 904
  *(out + 11UL) = *(in + 7UL);
#line 905
  *(out + 12UL) = *(in + 12UL);
#line 906
  *(out + 13UL) = *(in + 1UL);
#line 907
  *(out + 14UL) = *(in + 6UL);
#line 908
  *(out + 15UL) = *(in + 11UL);
#line 909
  return;
}
}
#line 912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void mix_column(u8 *in , u8 *out ) 
{ 
  int i ;
  u8 add1b[4U] ;
  u8 add1bf7[4U] ;
  u8 rotl[4U] ;
  u8 swap_halfs[4U] ;
  u8 andf7[4U] ;
  u8 rotr___0[4U] ;
  u8 temp[4U] ;
  u8 tempb[4U] ;

  {
#line 924
  i = 0;
#line 924
  goto ldv_53472;
  ldv_53471: ;
#line 925
  if ((int )((signed char )*(in + (unsigned long )i)) < 0) {
#line 926
    add1b[i] = 27U;
  } else {
#line 928
    add1b[i] = 0U;
  }
#line 924
  i = i + 1;
  ldv_53472: ;
#line 924
  if (i <= 3) {
#line 926
    goto ldv_53471;
  } else {

  }
#line 931
  swap_halfs[0] = *(in + 2UL);
#line 932
  swap_halfs[1] = *(in + 3UL);
#line 933
  swap_halfs[2] = *in;
#line 934
  swap_halfs[3] = *(in + 1UL);
#line 936
  rotl[0] = *(in + 3UL);
#line 937
  rotl[1] = *in;
#line 938
  rotl[2] = *(in + 1UL);
#line 939
  rotl[3] = *(in + 2UL);
#line 941
  andf7[0] = (unsigned int )*in & 127U;
#line 942
  andf7[1] = (unsigned int )*(in + 1UL) & 127U;
#line 943
  andf7[2] = (unsigned int )*(in + 2UL) & 127U;
#line 944
  andf7[3] = (unsigned int )*(in + 3UL) & 127U;
#line 946
  i = 3;
#line 946
  goto ldv_53475;
  ldv_53474: 
#line 947
  andf7[i] = (int )andf7[i] << 1U;
#line 948
  if ((int )((signed char )andf7[i + -1]) < 0) {
#line 949
    andf7[i] = (u8 )((unsigned int )andf7[i] | 1U);
  } else {

  }
#line 946
  i = i - 1;
  ldv_53475: ;
#line 946
  if (i > 0) {
#line 948
    goto ldv_53474;
  } else {

  }
#line 951
  andf7[0] = (int )andf7[0] << 1U;
#line 952
  andf7[0] = (unsigned int )andf7[0] & 254U;
#line 954
  xor_32((u8 *)(& add1b), (u8 *)(& andf7), (u8 *)(& add1bf7));
#line 956
  xor_32(in, (u8 *)(& add1bf7), (u8 *)(& rotr___0));
#line 958
  temp[0] = rotr___0[0];
#line 959
  rotr___0[0] = rotr___0[1];
#line 960
  rotr___0[1] = rotr___0[2];
#line 961
  rotr___0[2] = rotr___0[3];
#line 962
  rotr___0[3] = temp[0];
#line 964
  xor_32((u8 *)(& add1bf7), (u8 *)(& rotr___0), (u8 *)(& temp));
#line 965
  xor_32((u8 *)(& swap_halfs), (u8 *)(& rotl), (u8 *)(& tempb));
#line 966
  xor_32((u8 *)(& temp), (u8 *)(& tempb), out);
#line 967
  return;
}
}
#line 970 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void aes128k128d(u8 *key , u8 *data , u8 *ciphertext ) 
{ 
  int round ;
  int i ;
  u8 intermediatea[16U] ;
  u8 intermediateb[16U] ;
  u8 round_key[16U] ;

  {
#line 978
  i = 0;
#line 978
  goto ldv_53488;
  ldv_53487: 
#line 979
  round_key[i] = *(key + (unsigned long )i);
#line 978
  i = i + 1;
  ldv_53488: ;
#line 978
  if (i <= 15) {
#line 980
    goto ldv_53487;
  } else {

  }
#line 981
  round = 0;
#line 981
  goto ldv_53491;
  ldv_53490: ;
#line 982
  if (round == 0) {
#line 983
    xor_128((u8 *)(& round_key), data, ciphertext);
#line 984
    next_key((u8 *)(& round_key), round);
  } else
#line 985
  if (round == 10) {
#line 986
    byte_sub(ciphertext, (u8 *)(& intermediatea));
#line 987
    shift_row((u8 *)(& intermediatea), (u8 *)(& intermediateb));
#line 988
    xor_128((u8 *)(& intermediateb), (u8 *)(& round_key), ciphertext);
  } else {
#line 990
    byte_sub(ciphertext, (u8 *)(& intermediatea));
#line 991
    shift_row((u8 *)(& intermediatea), (u8 *)(& intermediateb));
#line 992
    mix_column((u8 *)(& intermediateb), (u8 *)(& intermediatea));
#line 993
    mix_column((u8 *)(& intermediateb) + 4UL, (u8 *)(& intermediatea) + 4UL);
#line 994
    mix_column((u8 *)(& intermediateb) + 8UL, (u8 *)(& intermediatea) + 8UL);
#line 995
    mix_column((u8 *)(& intermediateb) + 12UL, (u8 *)(& intermediatea) + 12UL);
#line 996
    xor_128((u8 *)(& intermediatea), (u8 *)(& round_key), ciphertext);
#line 997
    next_key((u8 *)(& round_key), round);
  }
#line 981
  round = round + 1;
  ldv_53491: ;
#line 981
  if (round <= 10) {
#line 983
    goto ldv_53490;
  } else {

  }

#line 988
  return;
}
}
#line 1007 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void construct_mic_iv(u8 *mic_iv , int qc_exists , int a4_exists , u8 *mpdu ,
                             uint payload_length , u8 *pn_vector ) 
{ 
  int i ;

  {
#line 1012
  *mic_iv = 89U;
#line 1013
  if (qc_exists != 0 && a4_exists != 0) {
#line 1014
    *(mic_iv + 1UL) = (unsigned int )*(mpdu + 30UL) & 15U;
  } else {

  }
#line 1015
  if (qc_exists != 0 && a4_exists == 0) {
#line 1016
    *(mic_iv + 1UL) = (unsigned int )*(mpdu + 24UL) & 15U;
  } else {

  }
#line 1017
  if (qc_exists == 0) {
#line 1018
    *(mic_iv + 1UL) = 0U;
  } else {

  }
#line 1019
  i = 2;
#line 1019
  goto ldv_53503;
  ldv_53502: 
#line 1020
  *(mic_iv + (unsigned long )i) = *(mpdu + ((unsigned long )i + 8UL));
#line 1019
  i = i + 1;
  ldv_53503: ;
#line 1019
  if (i <= 7) {
#line 1021
    goto ldv_53502;
  } else {

  }
#line 1021
  i = 8;
#line 1021
  goto ldv_53506;
  ldv_53505: 
#line 1022
  *(mic_iv + (unsigned long )i) = *(pn_vector + (unsigned long )(13 - i));
#line 1021
  i = i + 1;
  ldv_53506: ;
#line 1021
  if (i <= 13) {
#line 1023
    goto ldv_53505;
  } else {

  }
#line 1023
  *(mic_iv + 14UL) = (unsigned char )(payload_length / 256U);
#line 1024
  *(mic_iv + 15UL) = (unsigned char )payload_length;
#line 1025
  return;
}
}
#line 1032 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void construct_mic_header1(u8 *mic_header1 , int header_length , u8 *mpdu ) 
{ 


  {
#line 1034
  *mic_header1 = (unsigned char )((header_length + -2) / 256);
#line 1035
  *(mic_header1 + 1UL) = (unsigned char )((header_length + -2) % 256);
#line 1036
  *(mic_header1 + 2UL) = (unsigned int )*mpdu & 207U;
#line 1037
  *(mic_header1 + 3UL) = (unsigned int )*(mpdu + 1UL) & 199U;
#line 1038
  *(mic_header1 + 4UL) = *(mpdu + 4UL);
#line 1039
  *(mic_header1 + 5UL) = *(mpdu + 5UL);
#line 1040
  *(mic_header1 + 6UL) = *(mpdu + 6UL);
#line 1041
  *(mic_header1 + 7UL) = *(mpdu + 7UL);
#line 1042
  *(mic_header1 + 8UL) = *(mpdu + 8UL);
#line 1043
  *(mic_header1 + 9UL) = *(mpdu + 9UL);
#line 1044
  *(mic_header1 + 10UL) = *(mpdu + 10UL);
#line 1045
  *(mic_header1 + 11UL) = *(mpdu + 11UL);
#line 1046
  *(mic_header1 + 12UL) = *(mpdu + 12UL);
#line 1047
  *(mic_header1 + 13UL) = *(mpdu + 13UL);
#line 1048
  *(mic_header1 + 14UL) = *(mpdu + 14UL);
#line 1049
  *(mic_header1 + 15UL) = *(mpdu + 15UL);
#line 1050
  return;
}
}
#line 1058 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void construct_mic_header2(u8 *mic_header2 , u8 *mpdu , int a4_exists , int qc_exists ) 
{ 
  int i ;

  {
#line 1063
  i = 0;
#line 1063
  goto ldv_53521;
  ldv_53520: 
#line 1064
  *(mic_header2 + (unsigned long )i) = 0U;
#line 1063
  i = i + 1;
  ldv_53521: ;
#line 1063
  if (i <= 15) {
#line 1065
    goto ldv_53520;
  } else {

  }
#line 1066
  *mic_header2 = *(mpdu + 16UL);
#line 1067
  *(mic_header2 + 1UL) = *(mpdu + 17UL);
#line 1068
  *(mic_header2 + 2UL) = *(mpdu + 18UL);
#line 1069
  *(mic_header2 + 3UL) = *(mpdu + 19UL);
#line 1070
  *(mic_header2 + 4UL) = *(mpdu + 20UL);
#line 1071
  *(mic_header2 + 5UL) = *(mpdu + 21UL);
#line 1073
  *(mic_header2 + 6UL) = 0U;
#line 1074
  *(mic_header2 + 7UL) = 0U;
#line 1076
  if (qc_exists == 0 && a4_exists != 0) {
#line 1077
    i = 0;
#line 1077
    goto ldv_53524;
    ldv_53523: 
#line 1078
    *(mic_header2 + (unsigned long )(i + 8)) = *(mpdu + (unsigned long )(i + 24));
#line 1077
    i = i + 1;
    ldv_53524: ;
#line 1077
    if (i <= 5) {
#line 1079
      goto ldv_53523;
    } else {

    }

  } else {

  }
#line 1081
  if (qc_exists != 0 && a4_exists == 0) {
#line 1082
    *(mic_header2 + 8UL) = (unsigned int )*(mpdu + 24UL) & 15U;
#line 1083
    *(mic_header2 + 9UL) = 0U;
  } else {

  }
#line 1086
  if (qc_exists != 0 && a4_exists != 0) {
#line 1087
    i = 0;
#line 1087
    goto ldv_53527;
    ldv_53526: 
#line 1088
    *(mic_header2 + (unsigned long )(i + 8)) = *(mpdu + (unsigned long )(i + 24));
#line 1087
    i = i + 1;
    ldv_53527: ;
#line 1087
    if (i <= 5) {
#line 1089
      goto ldv_53526;
    } else {

    }
#line 1090
    *(mic_header2 + 14UL) = (unsigned int )*(mpdu + 30UL) & 15U;
#line 1091
    *(mic_header2 + 15UL) = 0U;
  } else {

  }
#line 1093
  return;
}
}
#line 1101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void construct_ctr_preload(u8 *ctr_preload , int a4_exists , int qc_exists ,
                                  u8 *mpdu , u8 *pn_vector , int c ) 
{ 
  int i ;

  {
#line 1104
  i = 0;
#line 1106
  i = 0;
#line 1106
  goto ldv_53539;
  ldv_53538: 
#line 1107
  *(ctr_preload + (unsigned long )i) = 0U;
#line 1106
  i = i + 1;
  ldv_53539: ;
#line 1106
  if (i <= 15) {
#line 1108
    goto ldv_53538;
  } else {

  }
#line 1109
  i = 0;
#line 1111
  *ctr_preload = 1U;
#line 1112
  if (qc_exists != 0 && a4_exists != 0) {
#line 1113
    *(ctr_preload + 1UL) = (unsigned int )*(mpdu + 30UL) & 15U;
  } else {

  }
#line 1114
  if (qc_exists != 0 && a4_exists == 0) {
#line 1115
    *(ctr_preload + 1UL) = (unsigned int )*(mpdu + 24UL) & 15U;
  } else {

  }
#line 1117
  i = 2;
#line 1117
  goto ldv_53542;
  ldv_53541: 
#line 1118
  *(ctr_preload + (unsigned long )i) = *(mpdu + ((unsigned long )i + 8UL));
#line 1117
  i = i + 1;
  ldv_53542: ;
#line 1117
  if (i <= 7) {
#line 1119
    goto ldv_53541;
  } else {

  }
#line 1119
  i = 8;
#line 1119
  goto ldv_53545;
  ldv_53544: 
#line 1120
  *(ctr_preload + (unsigned long )i) = *(pn_vector + (unsigned long )(13 - i));
#line 1119
  i = i + 1;
  ldv_53545: ;
#line 1119
  if (i <= 13) {
#line 1121
    goto ldv_53544;
  } else {

  }
#line 1121
  *(ctr_preload + 14UL) = (unsigned char )(c / 256);
#line 1122
  *(ctr_preload + 15UL) = (unsigned char )(c % 256);
#line 1123
  return;
}
}
#line 1130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static void bitwise_xor(u8 *ina , u8 *inb___0 , u8 *out ) 
{ 
  int i ;

  {
#line 1134
  i = 0;
#line 1134
  goto ldv_53554;
  ldv_53553: 
#line 1135
  *(out + (unsigned long )i) = (u8 )((int )*(ina + (unsigned long )i) ^ (int )*(inb___0 + (unsigned long )i));
#line 1134
  i = i + 1;
  ldv_53554: ;
#line 1134
  if (i <= 15) {
#line 1136
    goto ldv_53553;
  } else {

  }

#line 1141
  return;
}
}
#line 1138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static int aes_cipher(u8 *key , uint hdrlen , u8 *pframe , uint plen ) 
{ 
  uint qc_exists ;
  uint a4_exists ;
  uint i ;
  uint j ;
  uint payload_remainder ;
  uint num_blocks ;
  uint payload_index ;
  u8 pn_vector[6U] ;
  u8 mic_iv[16U] ;
  u8 mic_header1[16U] ;
  u8 mic_header2[16U] ;
  u8 ctr_preload[16U] ;
  u8 chain_buffer[16U] ;
  u8 aes_out[16U] ;
  u8 padded_buffer[16U] ;
  u8 mic[8U] ;
  struct ieee80211_hdr *hdr ;
  u16 frsubtype ;
  int tmp ;
  uint tmp___0 ;
  uint tmp___1 ;
  uint tmp___2 ;
  uint tmp___3 ;

  {
#line 1152
  hdr = (struct ieee80211_hdr *)pframe;
#line 1153
  frsubtype = (unsigned int )hdr->frame_control & 240U;
#line 1155
  memset((void *)(& mic_iv), 0, 16UL);
#line 1156
  memset((void *)(& mic_header1), 0, 16UL);
#line 1157
  memset((void *)(& mic_header2), 0, 16UL);
#line 1158
  memset((void *)(& ctr_preload), 0, 16UL);
#line 1159
  memset((void *)(& chain_buffer), 0, 16UL);
#line 1160
  memset((void *)(& aes_out), 0, 16UL);
#line 1161
  memset((void *)(& padded_buffer), 0, 16UL);
#line 1163
  if (hdrlen == 24U || hdrlen == 26U) {
#line 1165
    a4_exists = 0U;
  } else {
#line 1167
    a4_exists = 1U;
  }
#line 1169
  tmp = ieee80211_is_data((int )hdr->frame_control);
#line 1169
  if (tmp != 0) {
#line 1170
    if (((unsigned int )frsubtype == 16U || (unsigned int )frsubtype == 32U) || (unsigned int )frsubtype == 48U) {
#line 1173
      qc_exists = 1U;
#line 1174
      if (hdrlen != 26U) {
#line 1175
        hdrlen = hdrlen + 2U;
      } else {

      }
    } else
#line 1176
    if ((((unsigned int )frsubtype == 128U || (unsigned int )frsubtype == 144U) || (unsigned int )frsubtype == 160U) || (unsigned int )frsubtype == 176U) {
#line 1180
      if (hdrlen != 26U) {
#line 1181
        hdrlen = hdrlen + 2U;
      } else {

      }
#line 1182
      qc_exists = 1U;
    } else {
#line 1184
      qc_exists = 0U;
    }
  } else {
#line 1187
    qc_exists = 0U;
  }
#line 1189
  pn_vector[0] = *(pframe + (unsigned long )hdrlen);
#line 1190
  pn_vector[1] = *(pframe + (unsigned long )(hdrlen + 1U));
#line 1191
  pn_vector[2] = *(pframe + (unsigned long )(hdrlen + 4U));
#line 1192
  pn_vector[3] = *(pframe + (unsigned long )(hdrlen + 5U));
#line 1193
  pn_vector[4] = *(pframe + (unsigned long )(hdrlen + 6U));
#line 1194
  pn_vector[5] = *(pframe + (unsigned long )(hdrlen + 7U));
#line 1196
  construct_mic_iv((u8 *)(& mic_iv), (int )qc_exists, (int )a4_exists, pframe, plen,
                   (u8 *)(& pn_vector));
#line 1198
  construct_mic_header1((u8 *)(& mic_header1), (int )hdrlen, pframe);
#line 1199
  construct_mic_header2((u8 *)(& mic_header2), pframe, (int )a4_exists, (int )qc_exists);
#line 1201
  payload_remainder = plen & 15U;
#line 1202
  num_blocks = plen / 16U;
#line 1205
  payload_index = hdrlen + 8U;
#line 1208
  aes128k128d(key, (u8 *)(& mic_iv), (u8 *)(& aes_out));
#line 1209
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header1), (u8 *)(& chain_buffer));
#line 1210
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
#line 1211
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header2), (u8 *)(& chain_buffer));
#line 1212
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
#line 1214
  i = 0U;
#line 1214
  goto ldv_53581;
  ldv_53580: 
#line 1215
  bitwise_xor((u8 *)(& aes_out), pframe + (unsigned long )payload_index, (u8 *)(& chain_buffer));
#line 1217
  payload_index = payload_index + 16U;
#line 1218
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
#line 1214
  i = i + 1U;
  ldv_53581: ;
#line 1214
  if (i < num_blocks) {
#line 1216
    goto ldv_53580;
  } else {

  }

#line 1222
  if (payload_remainder != 0U) {
#line 1223
    j = 0U;
#line 1223
    goto ldv_53584;
    ldv_53583: 
#line 1224
    padded_buffer[j] = 0U;
#line 1223
    j = j + 1U;
    ldv_53584: ;
#line 1223
    if (j <= 15U) {
#line 1225
      goto ldv_53583;
    } else {

    }
#line 1225
    j = 0U;
#line 1225
    goto ldv_53587;
    ldv_53586: 
#line 1226
    tmp___0 = payload_index;
#line 1226
    payload_index = payload_index + 1U;
#line 1226
    padded_buffer[j] = *(pframe + (unsigned long )tmp___0);
#line 1225
    j = j + 1U;
    ldv_53587: ;
#line 1225
    if (j < payload_remainder) {
#line 1227
      goto ldv_53586;
    } else {

    }
#line 1227
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
#line 1228
    aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  } else {

  }
#line 1231
  j = 0U;
#line 1231
  goto ldv_53590;
  ldv_53589: 
#line 1232
  mic[j] = aes_out[j];
#line 1231
  j = j + 1U;
  ldv_53590: ;
#line 1231
  if (j <= 7U) {
#line 1233
    goto ldv_53589;
  } else {

  }
#line 1235
  j = 0U;
#line 1235
  goto ldv_53593;
  ldv_53592: 
#line 1236
  *(pframe + (unsigned long )(payload_index + j)) = mic[j];
#line 1235
  j = j + 1U;
  ldv_53593: ;
#line 1235
  if (j <= 7U) {
#line 1237
    goto ldv_53592;
  } else {

  }
#line 1238
  payload_index = hdrlen + 8U;
#line 1239
  i = 0U;
#line 1239
  goto ldv_53599;
  ldv_53598: 
#line 1240
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, pframe,
                        (u8 *)(& pn_vector), (int )(i + 1U));
#line 1242
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1243
  bitwise_xor((u8 *)(& aes_out), pframe + (unsigned long )payload_index, (u8 *)(& chain_buffer));
#line 1244
  j = 0U;
#line 1244
  goto ldv_53596;
  ldv_53595: 
#line 1245
  tmp___1 = payload_index;
#line 1245
  payload_index = payload_index + 1U;
#line 1245
  *(pframe + (unsigned long )tmp___1) = chain_buffer[j];
#line 1244
  j = j + 1U;
  ldv_53596: ;
#line 1244
  if (j <= 15U) {
#line 1246
    goto ldv_53595;
  } else {

  }
#line 1239
  i = i + 1U;
  ldv_53599: ;
#line 1239
  if (i < num_blocks) {
#line 1241
    goto ldv_53598;
  } else {

  }

#line 1248
  if (payload_remainder != 0U) {
#line 1252
    construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists,
                          pframe, (u8 *)(& pn_vector), (int )(num_blocks + 1U));
#line 1255
    j = 0U;
#line 1255
    goto ldv_53602;
    ldv_53601: 
#line 1256
    padded_buffer[j] = 0U;
#line 1255
    j = j + 1U;
    ldv_53602: ;
#line 1255
    if (j <= 15U) {
#line 1257
      goto ldv_53601;
    } else {

    }
#line 1257
    j = 0U;
#line 1257
    goto ldv_53605;
    ldv_53604: 
#line 1258
    padded_buffer[j] = *(pframe + (unsigned long )(payload_index + j));
#line 1257
    j = j + 1U;
    ldv_53605: ;
#line 1257
    if (j < payload_remainder) {
#line 1259
      goto ldv_53604;
    } else {

    }
#line 1259
    aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1260
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
#line 1261
    j = 0U;
#line 1261
    goto ldv_53608;
    ldv_53607: 
#line 1262
    tmp___2 = payload_index;
#line 1262
    payload_index = payload_index + 1U;
#line 1262
    *(pframe + (unsigned long )tmp___2) = chain_buffer[j];
#line 1261
    j = j + 1U;
    ldv_53608: ;
#line 1261
    if (j < payload_remainder) {
#line 1263
      goto ldv_53607;
    } else {

    }

  } else {

  }
#line 1266
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, pframe,
                        (u8 *)(& pn_vector), 0);
#line 1269
  j = 0U;
#line 1269
  goto ldv_53611;
  ldv_53610: 
#line 1270
  padded_buffer[j] = 0U;
#line 1269
  j = j + 1U;
  ldv_53611: ;
#line 1269
  if (j <= 15U) {
#line 1271
    goto ldv_53610;
  } else {

  }
#line 1271
  j = 0U;
#line 1271
  goto ldv_53614;
  ldv_53613: 
#line 1272
  padded_buffer[j] = *(pframe + (unsigned long )(((j + hdrlen) + plen) + 8U));
#line 1271
  j = j + 1U;
  ldv_53614: ;
#line 1271
  if (j <= 7U) {
#line 1273
    goto ldv_53613;
  } else {

  }
#line 1274
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1275
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
#line 1276
  j = 0U;
#line 1276
  goto ldv_53617;
  ldv_53616: 
#line 1277
  tmp___3 = payload_index;
#line 1277
  payload_index = payload_index + 1U;
#line 1277
  *(pframe + (unsigned long )tmp___3) = chain_buffer[j];
#line 1276
  j = j + 1U;
  ldv_53617: ;
#line 1276
  if (j <= 7U) {
#line 1278
    goto ldv_53616;
  } else {

  }

#line 1279
  return (1);
}
}
#line 1282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
int rtw_aes_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int curfragnum ;
  int length ;
  u32 prwskeylen ;
  u8 *pframe ;
  u8 *prwskey ;
  u8 hw_hdr_offset ;
  struct sta_info *stainfo ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;
  int res ;
  bool tmp ;

  {
#line 1289
  hw_hdr_offset = 0U;
#line 1291
  pattrib = & pxmitframe->attrib;
#line 1292
  psecuritypriv = & padapter->securitypriv;
#line 1293
  pxmitpriv = & padapter->xmitpriv;
#line 1294
  res = 1;
#line 1296
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
#line 1297
    return (0);
  } else {

  }
#line 1299
  hw_hdr_offset = 40U;
#line 1301
  pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
#line 1304
  if (pattrib->encrypt != 1027076U) {
#line 1305
    return (0);
  } else {

  }
#line 1307
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 1308
    stainfo = pattrib->psta;
  } else {
#line 1310
    if (GlobalDebugLevel23A > 3U) {
#line 1310
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_aes_encrypt23a");
    } else {

    }
#line 1311
    stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
#line 1314
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
#line 1315
    if (GlobalDebugLevel23A > 3U) {
#line 1315
      rt_trace(4096, 4, "%s: stainfo == NULL!!!\n", "rtw_aes_encrypt23a");
    } else {

    }
#line 1317
    if (GlobalDebugLevel23A > 3U) {
#line 1317
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_aes_encrypt23a");
    } else {

    }
#line 1318
    res = 0;
#line 1319
    goto out;
  } else {

  }
#line 1321
  if ((stainfo->state & 1U) == 0U) {
#line 1322
    if (GlobalDebugLevel23A > 3U) {
#line 1322
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_aes_encrypt23a",
             stainfo->state);
    } else {

    }
#line 1324
    return (0);
  } else {

  }
#line 1326
  if (GlobalDebugLevel23A > 3U) {
#line 1326
    rt_trace(4096, 4, "%s: stainfo!= NULL!!!\n", "rtw_aes_encrypt23a");
  } else {

  }
#line 1329
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 1329
  if ((int )tmp) {
#line 1330
    prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey);
  } else {
#line 1332
    prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
  }
#line 1334
  prwskeylen = 16U;
#line 1336
  curfragnum = 0;
#line 1336
  goto ldv_53637;
  ldv_53636: ;
#line 1338
  if (curfragnum + 1 == (int )pattrib->nr_frags) {
#line 1339
    length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - (u32 )pattrib->icv_len);
#line 1343
    aes_cipher(prwskey, (uint )pattrib->hdrlen, pframe, (uint )length);
  } else {
#line 1345
    length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - (uint )pattrib->icv_len);
#line 1348
    aes_cipher(prwskey, (uint )pattrib->hdrlen, pframe, (uint )length);
#line 1349
    pframe = pframe + (unsigned long )pxmitpriv->frag_len;
#line 1350
    pframe = (u8 *)(((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL);
  }
#line 1336
  curfragnum = curfragnum + 1;
  ldv_53637: ;
#line 1336
  if ((int )pattrib->nr_frags > curfragnum) {
#line 1338
    goto ldv_53636;
  } else {

  }

  out: ;
#line 1354
  return (res);
}
}
#line 1357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
static int aes_decipher(u8 *key , uint hdrlen , u8 *pframe , uint plen ) 
{ 
  u8 message[2048U] ;
  uint qc_exists ;
  uint a4_exists ;
  uint i ;
  uint j ;
  uint payload_remainder ;
  uint num_blocks ;
  uint payload_index ;
  int res ;
  u8 pn_vector[6U] ;
  u8 mic_iv[16U] ;
  u8 mic_header1[16U] ;
  u8 mic_header2[16U] ;
  u8 ctr_preload[16U] ;
  u8 chain_buffer[16U] ;
  u8 aes_out[16U] ;
  u8 padded_buffer[16U] ;
  u8 mic[8U] ;
  struct ieee80211_hdr *hdr ;
  u16 frsubtype ;
  int tmp ;
  uint tmp___0 ;
  uint tmp___1 ;
  uint tmp___2 ;
  uint tmp___3 ;
  uint tmp___4 ;
  uint tmp___5 ;

  {
#line 1362
  res = 1;
#line 1373
  hdr = (struct ieee80211_hdr *)pframe;
#line 1374
  frsubtype = (unsigned int )hdr->frame_control & 240U;
#line 1376
  memset((void *)(& mic_iv), 0, 16UL);
#line 1377
  memset((void *)(& mic_header1), 0, 16UL);
#line 1378
  memset((void *)(& mic_header2), 0, 16UL);
#line 1379
  memset((void *)(& ctr_preload), 0, 16UL);
#line 1380
  memset((void *)(& chain_buffer), 0, 16UL);
#line 1381
  memset((void *)(& aes_out), 0, 16UL);
#line 1382
  memset((void *)(& padded_buffer), 0, 16UL);
#line 1386
  num_blocks = (plen - 8U) / 16U;
#line 1388
  payload_remainder = (plen - 8U) & 15U;
#line 1390
  pn_vector[0] = *(pframe + (unsigned long )hdrlen);
#line 1391
  pn_vector[1] = *(pframe + (unsigned long )(hdrlen + 1U));
#line 1392
  pn_vector[2] = *(pframe + (unsigned long )(hdrlen + 4U));
#line 1393
  pn_vector[3] = *(pframe + (unsigned long )(hdrlen + 5U));
#line 1394
  pn_vector[4] = *(pframe + (unsigned long )(hdrlen + 6U));
#line 1395
  pn_vector[5] = *(pframe + (unsigned long )(hdrlen + 7U));
#line 1397
  if (hdrlen == 24U || hdrlen == 26U) {
#line 1399
    a4_exists = 0U;
  } else {
#line 1401
    a4_exists = 1U;
  }
#line 1403
  tmp = ieee80211_is_data((int )hdr->frame_control);
#line 1403
  if (tmp != 0) {
#line 1404
    if (((unsigned int )frsubtype == 16U || (unsigned int )frsubtype == 32U) || (unsigned int )frsubtype == 48U) {
#line 1407
      qc_exists = 1U;
#line 1408
      if (hdrlen != 24U) {
#line 1409
        hdrlen = hdrlen + 2U;
      } else {

      }
    } else
#line 1410
    if ((((unsigned int )frsubtype == 128U || (unsigned int )frsubtype == 144U) || (unsigned int )frsubtype == 160U) || (unsigned int )frsubtype == 176U) {
#line 1414
      if (hdrlen != 24U) {
#line 1415
        hdrlen = hdrlen + 2U;
      } else {

      }
#line 1416
      qc_exists = 1U;
    } else {
#line 1418
      qc_exists = 0U;
    }
  } else {
#line 1421
    qc_exists = 0U;
  }
#line 1426
  payload_index = hdrlen + 8U;
#line 1428
  i = 0U;
#line 1428
  goto ldv_53669;
  ldv_53668: 
#line 1429
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, pframe,
                        (u8 *)(& pn_vector), (int )(i + 1U));
#line 1432
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1433
  bitwise_xor((u8 *)(& aes_out), pframe + (unsigned long )payload_index, (u8 *)(& chain_buffer));
#line 1435
  j = 0U;
#line 1435
  goto ldv_53666;
  ldv_53665: 
#line 1436
  tmp___0 = payload_index;
#line 1436
  payload_index = payload_index + 1U;
#line 1436
  *(pframe + (unsigned long )tmp___0) = chain_buffer[j];
#line 1435
  j = j + 1U;
  ldv_53666: ;
#line 1435
  if (j <= 15U) {
#line 1437
    goto ldv_53665;
  } else {

  }
#line 1428
  i = i + 1U;
  ldv_53669: ;
#line 1428
  if (i < num_blocks) {
#line 1430
    goto ldv_53668;
  } else {

  }

#line 1439
  if (payload_remainder != 0U) {
#line 1443
    construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists,
                          pframe, (u8 *)(& pn_vector), (int )(num_blocks + 1U));
#line 1446
    j = 0U;
#line 1446
    goto ldv_53672;
    ldv_53671: 
#line 1447
    padded_buffer[j] = 0U;
#line 1446
    j = j + 1U;
    ldv_53672: ;
#line 1446
    if (j <= 15U) {
#line 1448
      goto ldv_53671;
    } else {

    }
#line 1448
    j = 0U;
#line 1448
    goto ldv_53675;
    ldv_53674: 
#line 1449
    padded_buffer[j] = *(pframe + (unsigned long )(payload_index + j));
#line 1448
    j = j + 1U;
    ldv_53675: ;
#line 1448
    if (j < payload_remainder) {
#line 1450
      goto ldv_53674;
    } else {

    }
#line 1450
    aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1451
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
#line 1452
    j = 0U;
#line 1452
    goto ldv_53678;
    ldv_53677: 
#line 1453
    tmp___1 = payload_index;
#line 1453
    payload_index = payload_index + 1U;
#line 1453
    *(pframe + (unsigned long )tmp___1) = chain_buffer[j];
#line 1452
    j = j + 1U;
    ldv_53678: ;
#line 1452
    if (j < payload_remainder) {
#line 1454
      goto ldv_53677;
    } else {

    }

  } else {

  }
#line 1457
  if ((hdrlen + plen) + 8U <= 2048U) {
#line 1458
    memcpy((void *)(& message), (void const   *)pframe, (size_t )((hdrlen + plen) + 8U));
  } else {

  }
#line 1460
  pn_vector[0] = *(pframe + (unsigned long )hdrlen);
#line 1461
  pn_vector[1] = *(pframe + (unsigned long )(hdrlen + 1U));
#line 1462
  pn_vector[2] = *(pframe + (unsigned long )(hdrlen + 4U));
#line 1463
  pn_vector[3] = *(pframe + (unsigned long )(hdrlen + 5U));
#line 1464
  pn_vector[4] = *(pframe + (unsigned long )(hdrlen + 6U));
#line 1465
  pn_vector[5] = *(pframe + (unsigned long )(hdrlen + 7U));
#line 1467
  construct_mic_iv((u8 *)(& mic_iv), (int )qc_exists, (int )a4_exists, (u8 *)(& message),
                   plen - 8U, (u8 *)(& pn_vector));
#line 1470
  construct_mic_header1((u8 *)(& mic_header1), (int )hdrlen, (u8 *)(& message));
#line 1471
  construct_mic_header2((u8 *)(& mic_header2), (u8 *)(& message), (int )a4_exists,
                        (int )qc_exists);
#line 1473
  payload_remainder = (plen - 8U) & 15U;
#line 1474
  num_blocks = (plen - 8U) / 16U;
#line 1477
  payload_index = hdrlen + 8U;
#line 1480
  aes128k128d(key, (u8 *)(& mic_iv), (u8 *)(& aes_out));
#line 1481
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header1), (u8 *)(& chain_buffer));
#line 1482
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
#line 1483
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header2), (u8 *)(& chain_buffer));
#line 1484
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
#line 1486
  i = 0U;
#line 1486
  goto ldv_53681;
  ldv_53680: 
#line 1487
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& message) + (unsigned long )payload_index,
              (u8 *)(& chain_buffer));
#line 1489
  payload_index = payload_index + 16U;
#line 1490
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
#line 1486
  i = i + 1U;
  ldv_53681: ;
#line 1486
  if (i < num_blocks) {
#line 1488
    goto ldv_53680;
  } else {

  }

#line 1494
  if (payload_remainder != 0U) {
#line 1495
    j = 0U;
#line 1495
    goto ldv_53684;
    ldv_53683: 
#line 1496
    padded_buffer[j] = 0U;
#line 1495
    j = j + 1U;
    ldv_53684: ;
#line 1495
    if (j <= 15U) {
#line 1497
      goto ldv_53683;
    } else {

    }
#line 1497
    j = 0U;
#line 1497
    goto ldv_53687;
    ldv_53686: 
#line 1498
    tmp___2 = payload_index;
#line 1498
    payload_index = payload_index + 1U;
#line 1498
    padded_buffer[j] = message[tmp___2];
#line 1497
    j = j + 1U;
    ldv_53687: ;
#line 1497
    if (j < payload_remainder) {
#line 1499
      goto ldv_53686;
    } else {

    }
#line 1499
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
#line 1500
    aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  } else {

  }
#line 1503
  j = 0U;
#line 1503
  goto ldv_53690;
  ldv_53689: 
#line 1504
  mic[j] = aes_out[j];
#line 1503
  j = j + 1U;
  ldv_53690: ;
#line 1503
  if (j <= 7U) {
#line 1505
    goto ldv_53689;
  } else {

  }
#line 1507
  j = 0U;
#line 1507
  goto ldv_53693;
  ldv_53692: 
#line 1508
  message[payload_index + j] = mic[j];
#line 1507
  j = j + 1U;
  ldv_53693: ;
#line 1507
  if (j <= 7U) {
#line 1509
    goto ldv_53692;
  } else {

  }
#line 1510
  payload_index = hdrlen + 8U;
#line 1511
  i = 0U;
#line 1511
  goto ldv_53699;
  ldv_53698: 
#line 1512
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, (u8 *)(& message),
                        (u8 *)(& pn_vector), (int )(i + 1U));
#line 1514
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1515
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& message) + (unsigned long )payload_index,
              (u8 *)(& chain_buffer));
#line 1516
  j = 0U;
#line 1516
  goto ldv_53696;
  ldv_53695: 
#line 1517
  tmp___3 = payload_index;
#line 1517
  payload_index = payload_index + 1U;
#line 1517
  message[tmp___3] = chain_buffer[j];
#line 1516
  j = j + 1U;
  ldv_53696: ;
#line 1516
  if (j <= 15U) {
#line 1518
    goto ldv_53695;
  } else {

  }
#line 1511
  i = i + 1U;
  ldv_53699: ;
#line 1511
  if (i < num_blocks) {
#line 1513
    goto ldv_53698;
  } else {

  }

#line 1520
  if (payload_remainder != 0U) {
#line 1524
    construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists,
                          (u8 *)(& message), (u8 *)(& pn_vector), (int )(num_blocks + 1U));
#line 1527
    j = 0U;
#line 1527
    goto ldv_53702;
    ldv_53701: 
#line 1528
    padded_buffer[j] = 0U;
#line 1527
    j = j + 1U;
    ldv_53702: ;
#line 1527
    if (j <= 15U) {
#line 1529
      goto ldv_53701;
    } else {

    }
#line 1529
    j = 0U;
#line 1529
    goto ldv_53705;
    ldv_53704: 
#line 1530
    padded_buffer[j] = message[payload_index + j];
#line 1529
    j = j + 1U;
    ldv_53705: ;
#line 1529
    if (j < payload_remainder) {
#line 1531
      goto ldv_53704;
    } else {

    }
#line 1531
    aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1532
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
#line 1533
    j = 0U;
#line 1533
    goto ldv_53708;
    ldv_53707: 
#line 1534
    tmp___4 = payload_index;
#line 1534
    payload_index = payload_index + 1U;
#line 1534
    message[tmp___4] = chain_buffer[j];
#line 1533
    j = j + 1U;
    ldv_53708: ;
#line 1533
    if (j < payload_remainder) {
#line 1535
      goto ldv_53707;
    } else {

    }

  } else {

  }
#line 1538
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, (u8 *)(& message),
                        (u8 *)(& pn_vector), 0);
#line 1541
  j = 0U;
#line 1541
  goto ldv_53711;
  ldv_53710: 
#line 1542
  padded_buffer[j] = 0U;
#line 1541
  j = j + 1U;
  ldv_53711: ;
#line 1541
  if (j <= 15U) {
#line 1543
    goto ldv_53710;
  } else {

  }
#line 1543
  j = 0U;
#line 1543
  goto ldv_53714;
  ldv_53713: 
#line 1544
  padded_buffer[j] = message[(j + hdrlen) + plen];
#line 1543
  j = j + 1U;
  ldv_53714: ;
#line 1543
  if (j <= 7U) {
#line 1545
    goto ldv_53713;
  } else {

  }
#line 1546
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1547
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
#line 1548
  j = 0U;
#line 1548
  goto ldv_53717;
  ldv_53716: 
#line 1549
  tmp___5 = payload_index;
#line 1549
  payload_index = payload_index + 1U;
#line 1549
  message[tmp___5] = chain_buffer[j];
#line 1548
  j = j + 1U;
  ldv_53717: ;
#line 1548
  if (j <= 7U) {
#line 1550
    goto ldv_53716;
  } else {

  }
#line 1552
  i = 0U;
#line 1552
  goto ldv_53721;
  ldv_53720: ;
#line 1553
  if ((int )*(pframe + (unsigned long )((hdrlen + plen) + i)) != (int )message[(hdrlen + plen) + i]) {
#line 1554
    if (GlobalDebugLevel23A > 3U) {
#line 1554
      rt_trace(4096, 4, "%s:mic check error mic[%d]: pframe(%x) != message(%x)\n",
               "aes_decipher", i, (int )*(pframe + (unsigned long )((hdrlen + plen) + i)),
               (int )message[(hdrlen + plen) + i]);
    } else {

    }
#line 1559
    if (GlobalDebugLevel23A > 3U) {
#line 1559
      printk("\016RTL8723AU: %s:mic check error mic[%d]: pframe(%x) != message(%x)\n",
             "aes_decipher", i, (int )*(pframe + (unsigned long )((hdrlen + plen) + i)),
             (int )message[(hdrlen + plen) + i]);
    } else {

    }
#line 1563
    res = 0;
  } else {

  }
#line 1552
  i = i + 1U;
  ldv_53721: ;
#line 1552
  if (i <= 7U) {
#line 1554
    goto ldv_53720;
  } else {

  }

#line 1566
  return (res);
}
}
#line 1569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
int rtw_aes_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) 
{ 
  struct sta_info *stainfo ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct sk_buff *skb ;
  int length ;
  u8 *pframe ;
  u8 *prwskey ;
  int res ;
  bool tmp ;

  {
#line 1573
  prxattrib = & precvframe->attrib;
#line 1574
  psecuritypriv = & padapter->securitypriv;
#line 1575
  skb = precvframe->pkt;
#line 1578
  res = 1;
#line 1580
  pframe = skb->data;
#line 1582
  if (prxattrib->encrypt != 1027076U) {
#line 1583
    return (0);
  } else {

  }
#line 1585
  stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& prxattrib->ta));
#line 1586
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
#line 1587
    if (GlobalDebugLevel23A > 3U) {
#line 1587
      rt_trace(4096, 4, "%s: stainfo == NULL!!!\n", "rtw_aes_decrypt23a");
    } else {

    }
#line 1589
    res = 0;
#line 1590
    goto exit;
  } else {

  }
#line 1593
  if (GlobalDebugLevel23A > 3U) {
#line 1593
    rt_trace(4096, 4, "%s: stainfo!= NULL!!!\n", "rtw_aes_decrypt23a");
  } else {

  }
#line 1596
  tmp = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
#line 1596
  if ((int )tmp) {
#line 1600
    if ((unsigned int )*((unsigned char *)psecuritypriv + 580UL) == 0U) {
#line 1601
      res = 0;
#line 1602
      if (GlobalDebugLevel23A > 3U) {
#line 1602
        printk("\016RTL8723AU: %s:rx bc/mc packets, but didn\'t install group key!!!!!!!!!!\n",
               "rtw_aes_decrypt23a");
      } else {

      }
#line 1604
      goto exit;
    } else {

    }
#line 1606
    prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[(int )prxattrib->key_index].skey);
#line 1607
    if (psecuritypriv->dot118021XGrpKeyid != (u32 )prxattrib->key_index) {
#line 1608
      if (GlobalDebugLevel23A > 3U) {
#line 1608
        printk("\016RTL8723AU: not match packet_index =%d, install_index =%d\n", (int )prxattrib->key_index,
               psecuritypriv->dot118021XGrpKeyid);
      } else {

      }
#line 1611
      res = 0;
#line 1612
      goto exit;
    } else {

    }
  } else {
#line 1615
    prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
  }
#line 1618
  length = (int )((skb->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len);
#line 1620
  res = aes_decipher(prwskey, (uint )prxattrib->hdrlen, pframe, (uint )length);
  exit: ;
#line 1622
  return (res);
}
}
#line 1625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.c"
void rtw_use_tkipkey_handler23a(void *FunctionContext ) 
{ 
  struct rtw_adapter *padapter ;

  {
#line 1627
  padapter = (struct rtw_adapter *)FunctionContext;
#line 1629
  if (GlobalDebugLevel23A > 3U) {
#line 1629
    rt_trace(4096, 4, "^^^%s ^^^\n", "rtw_use_tkipkey_handler23a");
  } else {

  }
#line 1631
  padapter->securitypriv.busetkipkey = 1U;
#line 1632
  if (GlobalDebugLevel23A > 3U) {
#line 1632
    rt_trace(4096, 4, "^^^%s padapter->securitypriv.busetkipkey =%d^^^\n", "rtw_use_tkipkey_handler23a",
             (int )padapter->securitypriv.busetkipkey);
  } else {

  }
#line 1633
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
bool ldv_queue_work_on_193(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
bool ldv_queue_delayed_work_on_194(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
bool ldv_queue_work_on_195(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
void ldv_flush_workqueue_196(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
bool ldv_queue_delayed_work_on_197(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 173 "include/linux/timer.h"
int ldv_mod_timer_212(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_207(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_209(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_208(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_211(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_210(struct workqueue_struct *ldv_func_arg1 ) ;
#line 537 "include/linux/interrupt.h"
extern void __tasklet_hi_schedule(struct tasklet_struct * ) ;
#line 539 "include/linux/interrupt.h"
__inline static void tasklet_hi_schedule(struct tasklet_struct *t ) 
{ 
  int tmp ;

  {
#line 541
  tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& t->state));
#line 541
  if (tmp == 0) {
#line 542
    __tasklet_hi_schedule(t);
  } else {

  }
#line 543
  return;
}
}
#line 579
extern void tasklet_kill(struct tasklet_struct * ) ;
#line 1822 "include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device  const  *dev ,
                                                         unsigned int index ) 
{ 


  {
#line 1825
  return ((struct netdev_queue *)dev->_tx + (unsigned long )index);
}
}
#line 2541
extern void netif_tx_wake_queue(struct netdev_queue * ) ;
#line 2555 "include/linux/netdevice.h"
__inline static void netif_tx_wake_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2559
  i = 0U;
#line 2559
  goto ldv_42827;
  ldv_42826: 
#line 2560
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2560
  txq = tmp;
#line 2561
  netif_tx_wake_queue(txq);
#line 2559
  i = i + 1U;
  ldv_42827: ;
#line 2559
  if (dev->num_tx_queues > i) {
#line 2561
    goto ldv_42826;
  } else {

  }

#line 2566
  return;
}
}
#line 2582
extern void netif_tx_stop_all_queues(struct net_device * ) ;
#line 2584 "include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue  const  *dev_queue ) 
{ 
  int tmp ;

  {
#line 2586
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev_queue->state));
#line 2586
  return (tmp != 0);
}
}
#line 60 "drivers/staging/rtl8723au/include/osdep_service.h"
__inline static int rtw_netif_queue_stopped(struct net_device *pnetdev ) 
{ 
  struct netdev_queue *tmp ;
  bool tmp___0 ;
  struct netdev_queue *tmp___1 ;
  bool tmp___2 ;
  struct netdev_queue *tmp___3 ;
  bool tmp___4 ;
  struct netdev_queue *tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;

  {
#line 62
  tmp = netdev_get_tx_queue((struct net_device  const  *)pnetdev, 0U);
#line 62
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp);
#line 62
  if ((int )tmp___0) {
#line 62
    tmp___1 = netdev_get_tx_queue((struct net_device  const  *)pnetdev, 1U);
#line 62
    tmp___2 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp___1);
#line 62
    if ((int )tmp___2) {
#line 62
      tmp___3 = netdev_get_tx_queue((struct net_device  const  *)pnetdev, 2U);
#line 62
      tmp___4 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp___3);
#line 62
      if ((int )tmp___4) {
#line 62
        tmp___5 = netdev_get_tx_queue((struct net_device  const  *)pnetdev, 3U);
#line 62
        tmp___6 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp___5);
#line 62
        if ((int )tmp___6) {
#line 62
          tmp___7 = 1;
        } else {
#line 62
          tmp___7 = 0;
        }
      } else {
#line 62
        tmp___7 = 0;
      }
    } else {
#line 62
      tmp___7 = 0;
    }
  } else {
#line 62
    tmp___7 = 0;
  }
#line 62
  return (tmp___7);
}
}
#line 26 "drivers/staging/rtl8723au/include/osdep_intf.h"
void rtw_cancel_all_timer23a(struct rtw_adapter *padapter ) ;
#line 37 "drivers/staging/rtl8723au/include/rtw_ap.h"
void rtw_ap_restore_network(struct rtw_adapter *padapter ) ;
#line 30 "drivers/staging/rtl8723au/include/rtw_sreset.h"
void rtw_sreset_init(struct rtw_adapter *padapter ) ;
#line 31
void rtw_sreset_reset_value(struct rtw_adapter *padapter ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.c"
void rtw_sreset_init(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  struct lock_class_key __key ;

  {
#line 21
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 22
  psrtpriv = & pHalData->srestpriv;
#line 24
  __mutex_init(& psrtpriv->silentreset_mutex, "&psrtpriv->silentreset_mutex", & __key);
#line 25
  psrtpriv->silent_reset_inprogress = 0U;
#line 26
  psrtpriv->last_tx_time = 0UL;
#line 27
  psrtpriv->last_tx_complete_time = 0UL;
#line 28
  return;
}
}
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.c"
void rtw_sreset_reset_value(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;

  {
#line 32
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 33
  psrtpriv = & pHalData->srestpriv;
#line 35
  psrtpriv->silent_reset_inprogress = 0U;
#line 36
  psrtpriv->last_tx_time = 0UL;
#line 37
  psrtpriv->last_tx_complete_time = 0UL;
#line 38
  return;
}
}
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.c"
bool rtw_sreset_inprogress(struct rtw_adapter *padapter ) 
{ 
  struct rtw_adapter *primary_adapter ;
  struct hal_data_8723a *pHalData ;

  {
#line 42
  primary_adapter = (padapter->dvobj)->if1;
#line 43
  pHalData = (struct hal_data_8723a *)primary_adapter->HalData;
#line 45
  return ((unsigned int )pHalData->srestpriv.silent_reset_inprogress != 0U);
}
}
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.c"
static void sreset_restore_security_station(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *mlmepriv ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 val8 ;
  u8 *tmp ;

  {
#line 50
  mlmepriv = & padapter->mlmepriv;
#line 51
  pstapriv = & padapter->stapriv;
#line 53
  pmlmeinfo = & padapter->mlmeextpriv.mlmext_info;
#line 56
  if (pmlmeinfo->auth_algo == 2U) {
#line 57
    val8 = 204U;
  } else {
#line 59
    val8 = 207U;
  }
#line 61
  rtl8723a_set_sec_cfg(padapter, (int )val8);
#line 63
  if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027074U || padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
#line 67
    tmp = get_bssid(mlmepriv);
#line 67
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)tmp);
#line 68
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {

    } else {
#line 72
      rtw_setstakey_cmd23a(padapter, (u8 *)psta, 1);
#line 74
      rtw_set_key23a(padapter, & padapter->securitypriv, (int )padapter->securitypriv.dot118021XGrpKeyid,
                     0);
    }
  } else {

  }
#line 77
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.c"
static void sreset_restore_network_station(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *mlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 threshold ;

  {
#line 81
  mlmepriv = & padapter->mlmepriv;
#line 82
  pmlmeext = & padapter->mlmeextpriv;
#line 83
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 86
  rtw_setopmode_cmd23a(padapter, 2);
#line 90
  if ((int )mlmepriv->htpriv.ht_option) {
#line 91
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
#line 92
      threshold = 1U;
    } else {
#line 94
      threshold = 0U;
    }
  } else {
#line 96
    threshold = 1U;
  }
#line 98
  rtl8723a_set_rxdma_agg_pg_th(padapter, (int )threshold);
#line 100
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
#line 103
  hw_var_set_bssid(padapter, (u8 *)(& pmlmeinfo->network.MacAddress));
#line 104
  hw_var_set_mlme_join(padapter, 0);
#line 106
  rtl8723a_set_media_status(padapter, (int )((u8 )pmlmeinfo->state) & 3);
#line 108
  mlmeext_joinbss_event_callback23a(padapter, 1);
#line 110
  rtl8723au_write8(padapter, 1244, (int )padapter->xmitpriv.nqos_ssn);
#line 112
  sreset_restore_security_station(padapter);
#line 113
  return;
}
}
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.c"
static void sreset_restore_network_status(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *mlmepriv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;

  {
#line 117
  mlmepriv = & padapter->mlmepriv;
#line 119
  tmp___5 = check_fwstate(mlmepriv, 8);
#line 119
  if ((int )tmp___5) {
#line 120
    if (GlobalDebugLevel23A > 3U) {
#line 120
      tmp = get_fwstate(mlmepriv);
#line 120
      printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - WIFI_STATION_STATE\n", "sreset_restore_network_status",
             (char *)(& (padapter->pnetdev)->name), tmp);
    } else {

    }
#line 123
    sreset_restore_network_station(padapter);
  } else {
#line 125
    tmp___4 = check_fwstate(mlmepriv, 16);
#line 125
    if ((int )tmp___4) {
#line 126
      if (GlobalDebugLevel23A > 3U) {
#line 126
        tmp___0 = get_fwstate(mlmepriv);
#line 126
        printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - WIFI_AP_STATE\n", "sreset_restore_network_status",
               (char *)(& (padapter->pnetdev)->name), tmp___0);
      } else {

      }
#line 129
      rtw_ap_restore_network(padapter);
    } else {
#line 131
      tmp___3 = check_fwstate(mlmepriv, 32);
#line 131
      if ((int )tmp___3) {
#line 132
        if (GlobalDebugLevel23A > 3U) {
#line 132
          tmp___1 = get_fwstate(mlmepriv);
#line 132
          printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - WIFI_ADHOC_STATE\n", "sreset_restore_network_status",
                 (char *)(& (padapter->pnetdev)->name), tmp___1);
        } else {

        }
      } else
#line 136
      if (GlobalDebugLevel23A > 3U) {
#line 136
        tmp___2 = get_fwstate(mlmepriv);
#line 136
        printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - ???\n", "sreset_restore_network_status",
               (char *)(& (padapter->pnetdev)->name), tmp___2);
      } else {

      }
    }
  }
#line 137
  return;
}
}
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.c"
static void sreset_stop_adapter(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct xmit_priv *pxmitpriv ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 143
  pmlmepriv = & padapter->mlmepriv;
#line 144
  pxmitpriv = & padapter->xmitpriv;
#line 146
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 147
    return;
  } else {

  }
#line 149
  if (GlobalDebugLevel23A > 3U) {
#line 149
    printk("\016RTL8723AU: %s(%s)\n", "sreset_stop_adapter", (char *)(& (padapter->pnetdev)->name));
  } else {

  }
#line 151
  tmp = rtw_netif_queue_stopped(padapter->pnetdev);
#line 151
  if (tmp == 0) {
#line 152
    netif_tx_stop_all_queues(padapter->pnetdev);
  } else {

  }
#line 154
  rtw_cancel_all_timer23a(padapter);
#line 157
  tasklet_kill(& pxmitpriv->xmit_tasklet);
#line 159
  tmp___0 = check_fwstate(pmlmepriv, 2048);
#line 159
  if ((int )tmp___0) {
#line 160
    rtw_scan_abort23a(padapter);
  } else {

  }
#line 162
  tmp___1 = check_fwstate(pmlmepriv, 128);
#line 162
  if ((int )tmp___1) {
#line 163
    rtw23a_join_to_handler((unsigned long )padapter);
  } else {

  }
#line 164
  return;
}
}
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.c"
static void sreset_start_adapter(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct xmit_priv *pxmitpriv ;
  bool tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 168
  pmlmepriv = & padapter->mlmepriv;
#line 169
  pxmitpriv = & padapter->xmitpriv;
#line 171
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 172
    return;
  } else {

  }
#line 174
  if (GlobalDebugLevel23A > 3U) {
#line 174
    printk("\016RTL8723AU: %s(%s)\n", "sreset_start_adapter", (char *)(& (padapter->pnetdev)->name));
  } else {

  }
#line 176
  tmp = check_fwstate(pmlmepriv, 1);
#line 176
  if ((int )tmp) {
#line 177
    sreset_restore_network_status(padapter);
  } else {

  }
#line 180
  tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
#line 182
  tmp___0 = msecs_to_jiffies(2000U);
#line 182
  ldv_mod_timer_212(& padapter->mlmepriv.dynamic_chk_timer, tmp___0 + (unsigned long )jiffies);
#line 185
  tmp___1 = rtw_netif_queue_stopped(padapter->pnetdev);
#line 185
  if (tmp___1 != 0) {
#line 186
    netif_tx_wake_all_queues(padapter->pnetdev);
  } else {

  }
#line 187
  return;
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.c"
void rtw_sreset_reset(struct rtw_adapter *active_adapter ) 
{ 
  struct rtw_adapter *padapter ;
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  struct pwrctrl_priv *pwrpriv ;
  unsigned long start ;
  unsigned int tmp ;

  {
#line 191
  padapter = (active_adapter->dvobj)->if1;
#line 192
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 193
  psrtpriv = & pHalData->srestpriv;
#line 194
  pwrpriv = & padapter->pwrctrlpriv;
#line 195
  start = jiffies;
#line 197
  if (GlobalDebugLevel23A > 3U) {
#line 197
    printk("\016RTL8723AU: %s\n", "rtw_sreset_reset");
  } else {

  }
#line 199
  mutex_lock_nested(& psrtpriv->silentreset_mutex, 0U);
#line 200
  psrtpriv->silent_reset_inprogress = 1U;
#line 201
  pwrpriv->change_rfpwrstate = 2;
#line 203
  sreset_stop_adapter(padapter);
#line 205
  ips_enter23a(padapter);
#line 206
  ips_leave23a(padapter);
#line 208
  sreset_start_adapter(padapter);
#line 209
  psrtpriv->silent_reset_inprogress = 0U;
#line 210
  mutex_unlock(& psrtpriv->silentreset_mutex);
#line 212
  if (GlobalDebugLevel23A > 3U) {
#line 212
    tmp = jiffies_to_msecs((unsigned long )jiffies - start);
#line 212
    printk("\016RTL8723AU: %s done in %d ms\n", "rtw_sreset_reset", tmp);
  } else {

  }
#line 213
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
bool ldv_queue_work_on_207(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
bool ldv_queue_delayed_work_on_208(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
bool ldv_queue_work_on_209(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
void ldv_flush_workqueue_210(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
bool ldv_queue_delayed_work_on_211(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
int ldv_mod_timer_212(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 329
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 329
  ldv_func_res = tmp;
#line 331
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 333
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 232 "include/linux/timer.h"
int ldv_del_timer_sync_228(struct timer_list *ldv_func_arg1 ) ;
#line 236
int ldv_del_timer_sync_229(struct timer_list *ldv_func_arg1 ) ;
#line 240
int ldv_del_timer_sync_230(struct timer_list *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_223(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_225(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_224(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_227(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_226(struct workqueue_struct *ldv_func_arg1 ) ;
#line 346 "drivers/staging/rtl8723au/include/rtw_xmit.h"
void rtw_free_xmitframe_queue23a(struct xmit_priv *pxmitpriv , struct rtw_queue *pframequeue ) ;
#line 358
void _rtw_init_sta_xmit_priv23a(struct sta_xmit_priv *psta_xmitpriv ) ;
#line 345 "drivers/staging/rtl8723au/include/sta_info.h"
__inline static u32 wifi_mac_hash(u8 const   *mac ) 
{ 
  u32 x ;

  {
#line 349
  x = (u32 )*mac;
#line 350
  x = (x << 2) ^ (u32 )*(mac + 1UL);
#line 351
  x = (x << 2) ^ (u32 )*(mac + 2UL);
#line 352
  x = (x << 2) ^ (u32 )*(mac + 3UL);
#line 353
  x = (x << 2) ^ (u32 )*(mac + 4UL);
#line 354
  x = (x << 2) ^ (u32 )*(mac + 5UL);
#line 356
  x = (x >> 8) ^ x;
#line 357
  x = x & 31U;
#line 359
  return (x);
}
}
#line 362
int _rtw_init_sta_priv23a(struct sta_priv *pstapriv ) ;
#line 363
int _rtw_free_sta_priv23a(struct sta_priv *pstapriv ) ;
#line 34 "drivers/staging/rtl8723au/include/recv_osdep.h"
void rtw_init_recv_timer23a(struct recv_reorder_ctrl *preorder_ctrl ) ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.c"
static u8 const   bc_addr[6U]  = {      255U,      255U,      255U,      255U, 
        255U,      255U};
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.c"
static void _rtw_init_stainfo(struct sta_info *psta ) 
{ 
  struct lock_class_key __key ;

  {
#line 29
  memset((void *)psta, 0, 5656UL);
#line 30
  spinlock_check(& psta->lock);
#line 30
  __raw_spin_lock_init(& psta->lock.__annonCompField18.rlock, "&(&psta->lock)->rlock",
                       & __key);
#line 31
  INIT_LIST_HEAD(& psta->list);
#line 32
  INIT_LIST_HEAD(& psta->hash_list);
#line 33
  _rtw_init_queue23a(& psta->sleep_q);
#line 34
  psta->sleepq_len = 0U;
#line 35
  _rtw_init_sta_xmit_priv23a(& psta->sta_xmitpriv);
#line 36
  _rtw_init_sta_recv_priv23a(& psta->sta_recvpriv);
#line 38
  INIT_LIST_HEAD(& psta->asoc_list);
#line 39
  INIT_LIST_HEAD(& psta->auth_list);
#line 40
  psta->expire_to = 0U;
#line 41
  psta->flags = 0;
#line 42
  psta->capability = 0U;
#line 43
  psta->bpairwise_key_installed = 0U;
#line 44
  psta->nonerp_set = 0U;
#line 45
  psta->no_short_slot_time_set = 0U;
#line 46
  psta->no_short_preamble_set = 0U;
#line 47
  psta->no_ht_gf_set = 0U;
#line 48
  psta->no_ht_set = 0U;
#line 49
  psta->ht_20mhz_set = 0U;
#line 50
  psta->keep_alive_trycnt = 0U;
#line 51
  return;
}
}
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.c"
int _rtw_init_sta_priv23a(struct sta_priv *pstapriv ) 
{ 
  int i ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;

  {
#line 58
  spinlock_check(& pstapriv->sta_hash_lock);
#line 58
  __raw_spin_lock_init(& pstapriv->sta_hash_lock.__annonCompField18.rlock, "&(&pstapriv->sta_hash_lock)->rlock",
                       & __key);
#line 59
  pstapriv->asoc_sta_count = 0;
#line 60
  i = 0;
#line 60
  goto ldv_55749;
  ldv_55748: 
#line 61
  INIT_LIST_HEAD((struct list_head *)(& pstapriv->sta_hash) + (unsigned long )i);
#line 60
  i = i + 1;
  ldv_55749: ;
#line 60
  if (i <= 31) {
#line 62
    goto ldv_55748;
  } else {

  }
#line 64
  pstapriv->sta_dz_bitmap = 0U;
#line 65
  pstapriv->tim_bitmap = 0U;
#line 66
  INIT_LIST_HEAD(& pstapriv->asoc_list);
#line 67
  INIT_LIST_HEAD(& pstapriv->auth_list);
#line 68
  spinlock_check(& pstapriv->asoc_list_lock);
#line 68
  __raw_spin_lock_init(& pstapriv->asoc_list_lock.__annonCompField18.rlock, "&(&pstapriv->asoc_list_lock)->rlock",
                       & __key___0);
#line 69
  spinlock_check(& pstapriv->auth_list_lock);
#line 69
  __raw_spin_lock_init(& pstapriv->auth_list_lock.__annonCompField18.rlock, "&(&pstapriv->auth_list_lock)->rlock",
                       & __key___1);
#line 70
  pstapriv->asoc_list_cnt = 0U;
#line 71
  pstapriv->auth_list_cnt = 0U;
#line 72
  pstapriv->auth_to = 3U;
#line 73
  pstapriv->assoc_to = 3U;
#line 78
  pstapriv->expire_to = 3U;
#line 79
  pstapriv->max_num_sta = 32U;
#line 81
  return (1);
}
}
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.c"
int _rtw_free_sta_priv23a(struct sta_priv *pstapriv ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  int index ;
  int i ;
  struct list_head  const  *__mptr ;

  {
#line 91
  if ((unsigned long )pstapriv != (unsigned long )((struct sta_priv *)0)) {
#line 93
    spin_lock_bh(& pstapriv->sta_hash_lock);
#line 94
    index = 0;
#line 94
    goto ldv_55772;
    ldv_55771: 
#line 95
    phead = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
#line 97
    plist = phead->next;
#line 97
    ptmp = plist->next;
#line 97
    goto ldv_55769;
    ldv_55768: 
#line 100
    __mptr = (struct list_head  const  *)plist;
#line 100
    psta = (struct sta_info *)__mptr + 0xffffffffffffffa8UL;
#line 102
    i = 0;
#line 102
    goto ldv_55766;
    ldv_55765: 
#line 103
    preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
#line 104
    ldv_del_timer_sync_228(& preorder_ctrl->reordering_ctrl_timer);
#line 102
    i = i + 1;
    ldv_55766: ;
#line 102
    if (i <= 15) {
#line 104
      goto ldv_55765;
    } else {

    }
#line 97
    plist = ptmp;
#line 97
    ptmp = plist->next;
    ldv_55769: ;
#line 97
    if ((unsigned long )plist != (unsigned long )phead) {
#line 99
      goto ldv_55768;
    } else {

    }
#line 94
    index = index + 1;
    ldv_55772: ;
#line 94
    if (index <= 31) {
#line 96
      goto ldv_55771;
    } else {

    }
#line 108
    spin_unlock_bh(& pstapriv->sta_hash_lock);
  } else {

  }
#line 111
  return (1);
}
}
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.c"
struct sta_info *rtw_alloc_stainfo23a(struct sta_priv *pstapriv , u8 const   *hwaddr ,
                                      gfp_t gfp ) 
{ 
  struct list_head *phash_list ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  s32 index ;
  int i ;
  u16 wRxSeqInitialValue ;
  void *tmp ;
  u32 tmp___0 ;

  {
#line 121
  i = 0;
#line 122
  wRxSeqInitialValue = 65535U;
#line 124
  tmp = kmalloc(5656UL, gfp);
#line 124
  psta = (struct sta_info *)tmp;
#line 125
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 126
    return ((struct sta_info *)0);
  } else {

  }
#line 128
  spin_lock_bh(& pstapriv->sta_hash_lock);
#line 130
  _rtw_init_stainfo(psta);
#line 132
  psta->padapter = pstapriv->padapter;
#line 134
  ether_addr_copy((u8 *)(& psta->hwaddr), hwaddr);
#line 136
  tmp___0 = wifi_mac_hash(hwaddr);
#line 136
  index = (s32 )tmp___0;
#line 138
  if (GlobalDebugLevel23A > 6U) {
#line 138
    rt_trace(64, 7, "rtw_alloc_stainfo23a: index  = %x\n", index);
  } else {

  }
#line 140
  if (index > 31) {
#line 141
    if (GlobalDebugLevel23A > 3U) {
#line 141
      rt_trace(64, 4, "OLD_ERROR => rtw_alloc_stainfo23a: index >= NUM_STA\n");
    } else {

    }
#line 143
    psta = (struct sta_info *)0;
#line 144
    goto exit;
  } else {

  }
#line 146
  phash_list = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
#line 148
  list_add_tail(& psta->hash_list, phash_list);
#line 150
  pstapriv->asoc_sta_count = pstapriv->asoc_sta_count + 1;
#line 158
  i = 0;
#line 158
  goto ldv_55787;
  ldv_55786: 
#line 159
  memcpy((void *)(& psta->sta_recvpriv.rxcache.tid_rxseq) + (unsigned long )i, (void const   *)(& wRxSeqInitialValue),
           2UL);
#line 158
  i = i + 1;
  ldv_55787: ;
#line 158
  if (i <= 15) {
#line 160
    goto ldv_55786;
  } else {

  }

#line 162
  if (GlobalDebugLevel23A > 6U) {
#line 162
    rt_trace(64, 7, "alloc number_%d stainfo  with hwaddr = %pM\n", pstapriv->asoc_sta_count,
             hwaddr);
  } else {

  }
#line 166
  init_addba_retry_timer23a(psta);
#line 169
  i = 0;
#line 169
  goto ldv_55790;
  ldv_55789: 
#line 170
  preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
#line 172
  preorder_ctrl->padapter = pstapriv->padapter;
#line 174
  preorder_ctrl->enable = 0U;
#line 176
  preorder_ctrl->indicate_seq = 65535U;
#line 177
  preorder_ctrl->wend_b = 65535U;
#line 179
  preorder_ctrl->wsize_b = 64U;
#line 181
  _rtw_init_queue23a(& preorder_ctrl->pending_recvframe_queue);
#line 183
  rtw_init_recv_timer23a(preorder_ctrl);
#line 169
  i = i + 1;
  ldv_55790: ;
#line 169
  if (i <= 15) {
#line 171
    goto ldv_55789;
  } else {

  }
#line 186
  psta->rssi_stat.UndecoratedSmoothedPWDB = -1;
#line 187
  psta->rssi_stat.UndecoratedSmoothedCCK = -1;
#line 190
  psta->RxMgmtFrameSeqNum = 65535U;
  exit: 
#line 192
  spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 193
  return (psta);
}
}
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.c"
int rtw_free_stainfo23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct sta_xmit_priv *pstaxmitpriv ;
  struct xmit_priv *pxmitpriv ;
  struct sta_priv *pstapriv ;
  struct hw_xmit *phwxmit ;
  int i ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct recv_frame *prframe ;
  struct rtw_queue *ppending_recvframe_queue ;
  struct list_head  const  *__mptr ;
  int tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
#line 201
  pxmitpriv = & padapter->xmitpriv;
#line 202
  pstapriv = & padapter->stapriv;
#line 206
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 207
    goto exit;
  } else {

  }
#line 209
  spin_lock_bh(& psta->lock);
#line 210
  psta->state = psta->state & 4294967294U;
#line 211
  spin_unlock_bh(& psta->lock);
#line 213
  pstaxmitpriv = & psta->sta_xmitpriv;
#line 215
  spin_lock_bh(& pxmitpriv->lock);
#line 217
  rtw_free_xmitframe_queue23a(pxmitpriv, & psta->sleep_q);
#line 218
  psta->sleepq_len = 0U;
#line 221
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->vo_q.sta_pending);
#line 222
  list_del_init(& pstaxmitpriv->vo_q.tx_pending);
#line 223
  phwxmit = pxmitpriv->hwxmits;
#line 224
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->vo_q.qcnt;
#line 225
  pstaxmitpriv->vo_q.qcnt = 0;
#line 228
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->vi_q.sta_pending);
#line 229
  list_del_init(& pstaxmitpriv->vi_q.tx_pending);
#line 230
  phwxmit = pxmitpriv->hwxmits + 1UL;
#line 231
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->vi_q.qcnt;
#line 232
  pstaxmitpriv->vi_q.qcnt = 0;
#line 235
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->be_q.sta_pending);
#line 236
  list_del_init(& pstaxmitpriv->be_q.tx_pending);
#line 237
  phwxmit = pxmitpriv->hwxmits + 2UL;
#line 238
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->be_q.qcnt;
#line 239
  pstaxmitpriv->be_q.qcnt = 0;
#line 242
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->bk_q.sta_pending);
#line 243
  list_del_init(& pstaxmitpriv->bk_q.tx_pending);
#line 244
  phwxmit = pxmitpriv->hwxmits + 3UL;
#line 245
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->bk_q.qcnt;
#line 246
  pstaxmitpriv->bk_q.qcnt = 0;
#line 248
  spin_unlock_bh(& pxmitpriv->lock);
#line 250
  list_del_init(& psta->hash_list);
#line 251
  if (GlobalDebugLevel23A > 3U) {
#line 251
    rt_trace(64, 4, "free number_%d stainfo  with hwaddr = %pM\n", pstapriv->asoc_sta_count,
             (u8 *)(& psta->hwaddr));
  } else {

  }
#line 254
  pstapriv->asoc_sta_count = pstapriv->asoc_sta_count - 1;
#line 260
  ldv_del_timer_sync_229(& psta->addba_retry_timer);
#line 264
  i = 0;
#line 264
  goto ldv_55813;
  ldv_55812: 
#line 269
  preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
#line 271
  ldv_del_timer_sync_230(& preorder_ctrl->reordering_ctrl_timer);
#line 273
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
#line 276
  spin_lock_bh(& ppending_recvframe_queue->lock);
#line 277
  phead = get_list_head(ppending_recvframe_queue);
#line 278
  plist = phead->next;
#line 280
  goto ldv_55810;
  ldv_55809: 
#line 281
  __mptr = (struct list_head  const  *)plist;
#line 281
  prframe = (struct recv_frame *)__mptr;
#line 282
  plist = plist->next;
#line 283
  list_del_init(& prframe->list);
#line 284
  rtw_free_recvframe23a(prframe);
  ldv_55810: 
#line 280
  tmp = list_empty((struct list_head  const  *)phead);
#line 280
  if (tmp == 0) {
#line 282
    goto ldv_55809;
  } else {

  }
#line 286
  spin_unlock_bh(& ppending_recvframe_queue->lock);
#line 264
  i = i + 1;
  ldv_55813: ;
#line 264
  if (i <= 15) {
#line 266
    goto ldv_55812;
  } else {

  }

#line 288
  if ((psta->state & 16U) == 0U) {
#line 289
    rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 0);
  } else {

  }
#line 291
  spin_lock_bh(& pstapriv->auth_list_lock);
#line 292
  tmp___0 = list_empty((struct list_head  const  *)(& psta->auth_list));
#line 292
  if (tmp___0 == 0) {
#line 293
    list_del_init(& psta->auth_list);
#line 294
    pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt - 1);
  } else {

  }
#line 296
  spin_unlock_bh(& pstapriv->auth_list_lock);
#line 298
  psta->expire_to = 0U;
#line 300
  psta->sleepq_ac_len = 0U;
#line 301
  psta->qos_info = 0U;
#line 303
  psta->max_sp_len = 0U;
#line 304
  psta->uapsd_bk = 0U;
#line 305
  psta->uapsd_be = 0U;
#line 306
  psta->uapsd_vi = 0U;
#line 307
  psta->uapsd_vo = 0U;
#line 309
  psta->has_legacy_ac = 0U;
#line 311
  tmp___1 = CHKBIT(psta->aid);
#line 311
  pstapriv->sta_dz_bitmap = (int )pstapriv->sta_dz_bitmap & ~ ((int )((u16 )tmp___1));
#line 312
  tmp___2 = CHKBIT(psta->aid);
#line 312
  pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp___2));
#line 314
  if (psta->aid != 0U && (unsigned long )pstapriv->sta_aid[psta->aid - 1U] == (unsigned long )psta) {
#line 315
    pstapriv->sta_aid[psta->aid - 1U] = (struct sta_info *)0;
#line 316
    psta->aid = 0U;
  } else {

  }
#line 320
  kfree((void const   *)psta);
  exit: ;
#line 322
  return (1);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.c"
void rtw_free_all_stainfo23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct sta_info *pbcmc_stainfo ;
  struct sta_info *tmp ;
  s32 index ;
  struct list_head  const  *__mptr ;

  {
#line 330
  pstapriv = & padapter->stapriv;
#line 331
  tmp = rtw_get_bcmc_stainfo23a(padapter);
#line 331
  pbcmc_stainfo = tmp;
#line 334
  if (pstapriv->asoc_sta_count == 1) {
#line 335
    return;
  } else {

  }
#line 337
  spin_lock_bh(& pstapriv->sta_hash_lock);
#line 339
  index = 0;
#line 339
  goto ldv_55831;
  ldv_55830: 
#line 340
  phead = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
#line 342
  plist = phead->next;
#line 342
  ptmp = plist->next;
#line 342
  goto ldv_55828;
  ldv_55827: 
#line 343
  __mptr = (struct list_head  const  *)plist;
#line 343
  psta = (struct sta_info *)__mptr + 0xffffffffffffffa8UL;
#line 345
  if ((unsigned long )pbcmc_stainfo != (unsigned long )psta) {
#line 346
    rtw_free_stainfo23a(padapter, psta);
  } else {

  }
#line 342
  plist = ptmp;
#line 342
  ptmp = plist->next;
  ldv_55828: ;
#line 342
  if ((unsigned long )plist != (unsigned long )phead) {
#line 344
    goto ldv_55827;
  } else {

  }
#line 339
  index = index + 1;
  ldv_55831: ;
#line 339
  if (index <= 31) {
#line 341
    goto ldv_55830;
  } else {

  }
#line 349
  spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 350
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.c"
struct sta_info *rtw_get_stainfo23a(struct sta_priv *pstapriv , u8 const   *hwaddr ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct sta_info *psta ;
  u32 index ;
  u8 const   *addr ;
  bool tmp ;
  struct list_head  const  *__mptr ;
  bool tmp___0 ;

  {
#line 356
  psta = (struct sta_info *)0;
#line 360
  if ((unsigned long )hwaddr == (unsigned long )((u8 const   *)0U)) {
#line 361
    return ((struct sta_info *)0);
  } else {

  }
#line 363
  tmp = is_multicast_ether_addr(hwaddr);
#line 363
  if ((int )tmp) {
#line 364
    addr = (u8 const   *)(& bc_addr);
  } else {
#line 366
    addr = hwaddr;
  }
#line 368
  index = wifi_mac_hash(addr);
#line 370
  spin_lock_bh(& pstapriv->sta_hash_lock);
#line 372
  phead = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
#line 374
  plist = phead->next;
#line 374
  goto ldv_55846;
  ldv_55845: 
#line 375
  __mptr = (struct list_head  const  *)plist;
#line 375
  psta = (struct sta_info *)__mptr + 0xffffffffffffffa8UL;
#line 378
  tmp___0 = ether_addr_equal((u8 const   *)(& psta->hwaddr), addr);
#line 378
  if ((int )tmp___0) {
#line 379
    goto ldv_55844;
  } else {

  }
#line 381
  psta = (struct sta_info *)0;
#line 374
  plist = plist->next;
  ldv_55846: ;
#line 374
  if ((unsigned long )plist != (unsigned long )phead) {
#line 376
    goto ldv_55845;
  } else {

  }
  ldv_55844: 
#line 383
  spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 384
  return (psta);
}
}
#line 387 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.c"
int rtw_init_bcmc_stainfo23a(struct rtw_adapter *padapter ) 
{ 
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct tx_servq *ptxservq ;
  int res ;

  {
#line 389
  pstapriv = & padapter->stapriv;
#line 392
  res = 1;
#line 394
  psta = rtw_alloc_stainfo23a(pstapriv, (u8 const   *)(& bc_addr), 208U);
#line 395
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 396
    res = 0;
#line 397
    if (GlobalDebugLevel23A > 3U) {
#line 397
      rt_trace(64, 4, "rtw_alloc_stainfo23a fail\n");
    } else {

    }
#line 399
    return (res);
  } else {

  }
#line 402
  psta->mac_id = 1U;
#line 404
  ptxservq = & psta->sta_xmitpriv.be_q;
#line 405
  return (1);
}
}
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.c"
struct sta_info *rtw_get_bcmc_stainfo23a(struct rtw_adapter *padapter ) 
{ 
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;

  {
#line 411
  pstapriv = & padapter->stapriv;
#line 413
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& bc_addr));
#line 414
  return (psta);
}
}
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.c"
bool rtw_access_ctrl23a(struct rtw_adapter *padapter , u8 *mac_addr ) 
{ 
  bool res ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_wlan_acl_node *paclnode ;
  bool match ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  struct list_head  const  *__mptr ;
  bool tmp ;

  {
#line 419
  res = 1;
#line 423
  match = 0;
#line 424
  pstapriv = & padapter->stapriv;
#line 425
  pacl_list = & pstapriv->acl_list;
#line 426
  pacl_node_q = & pacl_list->acl_node_q;
#line 428
  spin_lock_bh(& pacl_node_q->lock);
#line 429
  phead = get_list_head(pacl_node_q);
#line 431
  plist = phead->next;
#line 431
  goto ldv_55875;
  ldv_55874: 
#line 432
  __mptr = (struct list_head  const  *)plist;
#line 432
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
#line 434
  tmp = ether_addr_equal((u8 const   *)(& paclnode->addr), (u8 const   *)mac_addr);
#line 434
  if ((int )tmp) {
#line 435
    if ((unsigned int )paclnode->valid != 0U) {
#line 436
      match = 1;
#line 437
      goto ldv_55873;
    } else {

    }
  } else {

  }
#line 431
  plist = plist->next;
  ldv_55875: ;
#line 431
  if ((unsigned long )plist != (unsigned long )phead) {
#line 433
    goto ldv_55874;
  } else {

  }
  ldv_55873: 
#line 441
  spin_unlock_bh(& pacl_node_q->lock);
#line 443
  if (pacl_list->mode == 1) {
#line 444
    res = (int )match ? 0 : 1;
  } else
#line 445
  if (pacl_list->mode == 2) {
#line 446
    res = (int )match != 0;
  } else {
#line 448
    res = 1;
  }
#line 450
  return (res);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
bool ldv_queue_work_on_223(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
bool ldv_queue_delayed_work_on_224(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
bool ldv_queue_work_on_225(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
void ldv_flush_workqueue_226(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
bool ldv_queue_delayed_work_on_227(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
int ldv_del_timer_sync_228(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 329
  tmp = del_timer_sync(ldv_func_arg1);
#line 329
  ldv_func_res = tmp;
#line 331
  disable_suitable_timer_11(ldv_func_arg1);
#line 333
  return (ldv_func_res);
}
}
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
int ldv_del_timer_sync_229(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 340
  tmp = del_timer_sync(ldv_func_arg1);
#line 340
  ldv_func_res = tmp;
#line 342
  disable_suitable_timer_11(ldv_func_arg1);
#line 344
  return (ldv_func_res);
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
int ldv_del_timer_sync_230(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 351
  tmp = del_timer_sync(ldv_func_arg1);
#line 351
  ldv_func_res = tmp;
#line 353
  disable_suitable_timer_11(ldv_func_arg1);
#line 355
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/mutex-debug.h"
extern void mutex_destroy(struct mutex * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 95
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long  ) ;
#line 106
extern void complete(struct completion * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_243(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_245(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_244(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_247(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_246(struct workqueue_struct *ldv_func_arg1 ) ;
#line 581 "include/linux/interrupt.h"
extern void tasklet_init(struct tasklet_struct * , void (*)(unsigned long  ) , unsigned long  ) ;
#line 52 "include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_be16(u16 val , void *p ) 
{ 
  __u16 tmp ;

  {
#line 54
  tmp = __fswab16((int )val);
#line 54
  *((__be16 *)p) = tmp;
#line 55
  return;
}
}
#line 198 "drivers/staging/rtl8723au/include/rtw_xmit.h"
void rtw23a_sctx_done_err(struct submit_ctx **sctx , int status ) ;
#line 333
s32 rtw_free_xmitbuf_ext23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf ) ;
#line 336
struct xmit_buf *rtw_alloc_xmitbuf23a(struct xmit_priv *pxmitpriv ) ;
#line 339
void rtw_count_tx_stats23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ,
                           int sz ) ;
#line 347
struct tx_servq *rtw_get_sta_pending23a(struct rtw_adapter *padapter , struct sta_info *psta ,
                                        int up___0 , u8 *ac ) ;
#line 349
s32 rtw_xmitframe_enqueue23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 351
struct xmit_frame *rtw_dequeue_xframe23a(struct xmit_priv *pxmitpriv , struct hw_xmit *phwxmit_i ,
                                         int entry ) ;
#line 353
s32 rtw_xmit23a_classifier(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 355
s32 rtw_xmitframe_coalesce23a(struct rtw_adapter *padapter , struct sk_buff *skb ,
                              struct xmit_frame *pxmitframe ) ;
#line 360
s32 rtw_txframes_pending23a(struct rtw_adapter *padapter ) ;
#line 361
s32 rtw_txframes_sta_ac_pending23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) ;
#line 363
void rtw_init_hwxmits23a(struct hw_xmit *phwxmit , int entry ) ;
#line 364
int _rtw_init_xmit_priv23a(struct xmit_priv *pxmitpriv , struct rtw_adapter *padapter ) ;
#line 366
void _rtw_free_xmit_priv23a(struct xmit_priv *pxmitpriv ) ;
#line 367
void rtw_alloc_hwxmits23a(struct rtw_adapter *padapter ) ;
#line 368
void rtw_free_hwxmits23a(struct rtw_adapter *padapter ) ;
#line 369
int rtw_xmit23a(struct rtw_adapter *padapter , struct sk_buff *skb ) ;
#line 371
int xmitframe_enqueue_for_sleeping_sta23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 378
u8 qos_acm23a(u8 acm_mask , u8 priority ) ;
#line 379
u32 rtw_get_ff_hwaddr23a(struct xmit_frame *pxmitframe ) ;
#line 28 "drivers/staging/rtl8723au/include/xmit_osdep.h"
int rtw_os_xmit_resource_alloc23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ,
                                  u32 alloc_sz ) ;
#line 30
void rtw_os_xmit_resource_free23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ) ;
#line 33
void rtw_os_pkt_complete23a(struct rtw_adapter *padapter , struct sk_buff *pkt ) ;
#line 34
void rtw_os_xmit_complete23a(struct rtw_adapter *padapter , struct xmit_frame *pxframe ) ;
#line 41 "drivers/staging/rtl8723au/include/usb_ops.h"
void rtl8723au_xmit_tasklet(void *priv ) ;
#line 220 "drivers/staging/rtl8723au/include/rtl8723a_xmit.h"
bool rtl8723au_hal_xmit(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
static void _init_txservq(struct tx_servq *ptxservq ) 
{ 


  {
#line 28
  INIT_LIST_HEAD(& ptxservq->tx_pending);
#line 29
  _rtw_init_queue23a(& ptxservq->sta_pending);
#line 30
  ptxservq->qcnt = 0;
#line 31
  return;
}
}
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
void _rtw_init_sta_xmit_priv23a(struct sta_xmit_priv *psta_xmitpriv ) 
{ 
  struct lock_class_key __key ;

  {
#line 37
  spinlock_check(& psta_xmitpriv->lock);
#line 37
  __raw_spin_lock_init(& psta_xmitpriv->lock.__annonCompField18.rlock, "&(&psta_xmitpriv->lock)->rlock",
                       & __key);
#line 42
  _init_txservq(& psta_xmitpriv->be_q);
#line 43
  _init_txservq(& psta_xmitpriv->bk_q);
#line 44
  _init_txservq(& psta_xmitpriv->vi_q);
#line 45
  _init_txservq(& psta_xmitpriv->vo_q);
#line 46
  INIT_LIST_HEAD(& psta_xmitpriv->legacy_dz);
#line 47
  INIT_LIST_HEAD(& psta_xmitpriv->apsd);
#line 48
  return;
}
}
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
int _rtw_init_xmit_priv23a(struct xmit_priv *pxmitpriv , struct rtw_adapter *padapter ) 
{ 
  int i ;
  struct xmit_buf *pxmitbuf ;
  struct xmit_frame *pxframe ;
  int res ;
  u32 max_xmit_extbuf_size ;
  u32 num_xmit_extbuf ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct lock_class_key __key___1 ;

  {
#line 57
  res = 1;
#line 58
  max_xmit_extbuf_size = 1536U;
#line 59
  num_xmit_extbuf = 32U;
#line 61
  spinlock_check(& pxmitpriv->lock);
#line 61
  __raw_spin_lock_init(& pxmitpriv->lock.__annonCompField18.rlock, "&(&pxmitpriv->lock)->rlock",
                       & __key);
#line 62
  spinlock_check(& pxmitpriv->lock_sctx);
#line 62
  __raw_spin_lock_init(& pxmitpriv->lock_sctx.__annonCompField18.rlock, "&(&pxmitpriv->lock_sctx)->rlock",
                       & __key___0);
#line 63
  sema_init(& pxmitpriv->xmit_sema, 0);
#line 64
  sema_init(& pxmitpriv->terminate_xmitthread_sema, 0);
#line 66
  pxmitpriv->adapter = padapter;
#line 68
  _rtw_init_queue23a(& pxmitpriv->be_pending);
#line 69
  _rtw_init_queue23a(& pxmitpriv->bk_pending);
#line 70
  _rtw_init_queue23a(& pxmitpriv->vi_pending);
#line 71
  _rtw_init_queue23a(& pxmitpriv->vo_pending);
#line 72
  _rtw_init_queue23a(& pxmitpriv->bm_pending);
#line 74
  _rtw_init_queue23a(& pxmitpriv->free_xmit_queue);
#line 76
  i = 0;
#line 76
  goto ldv_53388;
  ldv_53387: 
#line 77
  tmp = kzalloc(176UL, 208U);
#line 77
  pxframe = (struct xmit_frame *)tmp;
#line 78
  if ((unsigned long )pxframe == (unsigned long )((struct xmit_frame *)0)) {
#line 79
    goto ldv_53386;
  } else {

  }
#line 80
  INIT_LIST_HEAD(& pxframe->list);
#line 82
  pxframe->padapter = padapter;
#line 83
  pxframe->frame_tag = 0;
#line 85
  list_add_tail(& pxframe->list, & pxmitpriv->free_xmit_queue.queue);
#line 76
  i = i + 1;
  ldv_53388: ;
#line 76
  if (i <= 255) {
#line 78
    goto ldv_53387;
  } else {

  }
  ldv_53386: 
#line 89
  pxmitpriv->free_xmitframe_cnt = i;
#line 91
  pxmitpriv->frag_len = 2346U;
#line 94
  _rtw_init_queue23a(& pxmitpriv->free_xmitbuf_queue);
#line 95
  INIT_LIST_HEAD(& pxmitpriv->xmitbuf_list);
#line 96
  _rtw_init_queue23a(& pxmitpriv->pending_xmitbuf_queue);
#line 98
  i = 0;
#line 98
  goto ldv_53391;
  ldv_53390: 
#line 99
  tmp___0 = kzalloc(200UL, 208U);
#line 99
  pxmitbuf = (struct xmit_buf *)tmp___0;
#line 100
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 101
    goto fail;
  } else {

  }
#line 102
  INIT_LIST_HEAD(& pxmitbuf->list);
#line 103
  INIT_LIST_HEAD(& pxmitbuf->list2);
#line 105
  pxmitbuf->padapter = padapter;
#line 108
  res = rtw_os_xmit_resource_alloc23a(padapter, pxmitbuf, 2560U);
#line 110
  if (res == 0) {
#line 111
    goto fail;
  } else {

  }
#line 114
  list_add_tail(& pxmitbuf->list, & pxmitpriv->free_xmitbuf_queue.queue);
#line 116
  list_add_tail(& pxmitbuf->list2, & pxmitpriv->xmitbuf_list);
#line 98
  i = i + 1;
  ldv_53391: ;
#line 98
  if (i <= 3) {
#line 100
    goto ldv_53390;
  } else {

  }
#line 120
  pxmitpriv->free_xmitbuf_cnt = 4U;
#line 123
  _rtw_init_queue23a(& pxmitpriv->free_xframe_ext_queue);
#line 125
  i = 0;
#line 125
  goto ldv_53395;
  ldv_53394: 
#line 126
  tmp___1 = kzalloc(176UL, 208U);
#line 126
  pxframe = (struct xmit_frame *)tmp___1;
#line 127
  if ((unsigned long )pxframe == (unsigned long )((struct xmit_frame *)0)) {
#line 128
    goto ldv_53393;
  } else {

  }
#line 129
  INIT_LIST_HEAD(& pxframe->list);
#line 131
  pxframe->padapter = padapter;
#line 132
  pxframe->frame_tag = 0;
#line 134
  pxframe->pkt = (struct sk_buff *)0;
#line 136
  pxframe->buf_addr = (u8 *)0U;
#line 137
  pxframe->pxmitbuf = (struct xmit_buf *)0;
#line 139
  pxframe->ext_tag = 1U;
#line 141
  list_add_tail(& pxframe->list, & pxmitpriv->free_xframe_ext_queue.queue);
#line 125
  i = i + 1;
  ldv_53395: ;
#line 125
  if ((u32 )i < num_xmit_extbuf) {
#line 127
    goto ldv_53394;
  } else {

  }
  ldv_53393: 
#line 144
  pxmitpriv->free_xframe_ext_cnt = i;
#line 147
  _rtw_init_queue23a(& pxmitpriv->free_xmit_extbuf_queue);
#line 148
  INIT_LIST_HEAD(& pxmitpriv->xmitextbuf_list);
#line 150
  i = 0;
#line 150
  goto ldv_53398;
  ldv_53397: 
#line 151
  tmp___2 = kzalloc(200UL, 208U);
#line 151
  pxmitbuf = (struct xmit_buf *)tmp___2;
#line 152
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 153
    goto fail;
  } else {

  }
#line 154
  INIT_LIST_HEAD(& pxmitbuf->list);
#line 155
  INIT_LIST_HEAD(& pxmitbuf->list2);
#line 157
  pxmitbuf->padapter = padapter;
#line 160
  res = rtw_os_xmit_resource_alloc23a(padapter, pxmitbuf, max_xmit_extbuf_size + 512U);
#line 162
  if (res == 0) {
#line 163
    goto exit;
  } else {

  }
#line 166
  list_add_tail(& pxmitbuf->list, & pxmitpriv->free_xmit_extbuf_queue.queue);
#line 168
  list_add_tail(& pxmitbuf->list2, & pxmitpriv->xmitextbuf_list);
#line 150
  i = i + 1;
  ldv_53398: ;
#line 150
  if ((u32 )i < num_xmit_extbuf) {
#line 152
    goto ldv_53397;
  } else {

  }
#line 172
  pxmitpriv->free_xmit_extbuf_cnt = num_xmit_extbuf;
#line 174
  rtw_alloc_hwxmits23a(padapter);
#line 175
  rtw_init_hwxmits23a(pxmitpriv->hwxmits, (int )pxmitpriv->hwxmit_entry);
#line 177
  i = 0;
#line 177
  goto ldv_53401;
  ldv_53400: 
#line 178
  pxmitpriv->wmm_para_seq[i] = (u8 )i;
#line 177
  i = i + 1;
  ldv_53401: ;
#line 177
  if (i <= 3) {
#line 179
    goto ldv_53400;
  } else {

  }
#line 180
  sema_init(& pxmitpriv->tx_retevt, 0);
#line 182
  pxmitpriv->ack_tx = 0;
#line 183
  __mutex_init(& pxmitpriv->ack_tx_mutex, "&pxmitpriv->ack_tx_mutex", & __key___1);
#line 184
  rtw_sctx_init23a(& pxmitpriv->ack_tx_ops, 0);
#line 185
  tasklet_init(& padapter->xmitpriv.xmit_tasklet, (void (*)(unsigned long  ))(& rtl8723au_xmit_tasklet),
               (unsigned long )padapter);
  exit: ;
#line 191
  return (res);
  fail: ;
#line 193
  goto exit;
}
}
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
void _rtw_free_xmit_priv23a(struct xmit_priv *pxmitpriv ) 
{ 
  struct rtw_adapter *padapter ;
  struct xmit_frame *pxframe ;
  struct xmit_buf *pxmitbuf ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 198
  padapter = pxmitpriv->adapter;
#line 203
  plist = pxmitpriv->free_xmit_queue.queue.next;
#line 203
  ptmp = plist->next;
#line 203
  goto ldv_53416;
  ldv_53415: 
#line 204
  __mptr = (struct list_head  const  *)plist;
#line 204
  pxframe = (struct xmit_frame *)__mptr;
#line 205
  list_del_init(& pxframe->list);
#line 206
  rtw_os_xmit_complete23a(padapter, pxframe);
#line 207
  kfree((void const   *)pxframe);
#line 203
  plist = ptmp;
#line 203
  ptmp = plist->next;
  ldv_53416: ;
#line 203
  if ((unsigned long )(& pxmitpriv->free_xmit_queue.queue) != (unsigned long )plist) {
#line 205
    goto ldv_53415;
  } else {

  }
#line 210
  plist = pxmitpriv->xmitbuf_list.next;
#line 210
  ptmp = plist->next;
#line 210
  goto ldv_53421;
  ldv_53420: 
#line 211
  __mptr___0 = (struct list_head  const  *)plist;
#line 211
  pxmitbuf = (struct xmit_buf *)__mptr___0 + 0xfffffffffffffff0UL;
#line 212
  list_del_init(& pxmitbuf->list2);
#line 213
  rtw_os_xmit_resource_free23a(padapter, pxmitbuf);
#line 214
  kfree((void const   *)pxmitbuf);
#line 210
  plist = ptmp;
#line 210
  ptmp = plist->next;
  ldv_53421: ;
#line 210
  if ((unsigned long )(& pxmitpriv->xmitbuf_list) != (unsigned long )plist) {
#line 212
    goto ldv_53420;
  } else {

  }
#line 218
  plist = pxmitpriv->free_xframe_ext_queue.queue.next;
#line 218
  ptmp = plist->next;
#line 218
  goto ldv_53426;
  ldv_53425: 
#line 220
  __mptr___1 = (struct list_head  const  *)plist;
#line 220
  pxframe = (struct xmit_frame *)__mptr___1;
#line 221
  list_del_init(& pxframe->list);
#line 222
  rtw_os_xmit_complete23a(padapter, pxframe);
#line 223
  kfree((void const   *)pxframe);
#line 218
  plist = ptmp;
#line 218
  ptmp = plist->next;
  ldv_53426: ;
#line 218
  if ((unsigned long )(& pxmitpriv->free_xframe_ext_queue.queue) != (unsigned long )plist) {
#line 220
    goto ldv_53425;
  } else {

  }
#line 227
  plist = pxmitpriv->xmitextbuf_list.next;
#line 227
  ptmp = plist->next;
#line 227
  goto ldv_53431;
  ldv_53430: 
#line 228
  __mptr___2 = (struct list_head  const  *)plist;
#line 228
  pxmitbuf = (struct xmit_buf *)__mptr___2 + 0xfffffffffffffff0UL;
#line 229
  list_del_init(& pxmitbuf->list2);
#line 230
  rtw_os_xmit_resource_free23a(padapter, pxmitbuf);
#line 231
  kfree((void const   *)pxmitbuf);
#line 227
  plist = ptmp;
#line 227
  ptmp = plist->next;
  ldv_53431: ;
#line 227
  if ((unsigned long )(& pxmitpriv->xmitextbuf_list) != (unsigned long )plist) {
#line 229
    goto ldv_53430;
  } else {

  }
#line 234
  rtw_free_hwxmits23a(padapter);
#line 235
  mutex_destroy(& pxmitpriv->ack_tx_mutex);
#line 236
  return;
}
}
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
static void update_attrib_vcs_info(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  u32 sz ;
  struct pkt_attrib *pattrib ;
  struct sta_info *psta ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 HTOpMode ;

  {
#line 241
  pattrib = & pxmitframe->attrib;
#line 242
  psta = pattrib->psta;
#line 243
  pmlmeext = & padapter->mlmeextpriv;
#line 244
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 246
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 247
    psta = pattrib->psta;
  } else {
#line 249
    if (GlobalDebugLevel23A > 3U) {
#line 249
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "update_attrib_vcs_info");
    } else {

    }
#line 250
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
#line 253
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 254
    if (GlobalDebugLevel23A > 3U) {
#line 254
      printk("\016RTL8723AU: %s, psta == NUL\n", "update_attrib_vcs_info");
    } else {

    }
#line 255
    return;
  } else {

  }
#line 258
  if ((psta->state & 1U) == 0U) {
#line 259
    if (GlobalDebugLevel23A > 3U) {
#line 259
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "update_attrib_vcs_info",
             psta->state);
    } else {

    }
#line 260
    return;
  } else {

  }
#line 263
  if ((unsigned int )pattrib->nr_frags != 1U) {
#line 264
    sz = padapter->xmitpriv.frag_len;
  } else {
#line 266
    sz = pattrib->last_txcmdsz;
  }
#line 272
  if ((unsigned int )pmlmeext->cur_wireless_mode <= 7U || (unsigned int )padapter->registrypriv.wifi_spec != 0U) {
#line 273
    if ((u32 )padapter->registrypriv.rts_thresh < sz) {
#line 274
      pattrib->vcs_mode = 1U;
    } else
#line 276
    if ((unsigned int )psta->rtsen != 0U) {
#line 277
      pattrib->vcs_mode = 1U;
    } else
#line 278
    if ((unsigned int )psta->cts2self != 0U) {
#line 279
      pattrib->vcs_mode = 2U;
    } else {
#line 281
      pattrib->vcs_mode = 0U;
    }
  } else {
    ldv_53445: ;
#line 286
    if (((unsigned int )pmlmeinfo->assoc_AP_vendor == 5U && (unsigned int )pattrib->ampdu_en != 0U) && padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
#line 290
      pattrib->vcs_mode = 2U;
#line 291
      goto ldv_53443;
    } else {

    }
#line 295
    if ((unsigned int )psta->rtsen != 0U || (unsigned int )psta->cts2self != 0U) {
#line 296
      if ((unsigned int )psta->rtsen != 0U) {
#line 297
        pattrib->vcs_mode = 1U;
      } else
#line 298
      if ((unsigned int )psta->cts2self != 0U) {
#line 299
        pattrib->vcs_mode = 2U;
      } else {

      }
#line 301
      goto ldv_53443;
    } else {

    }
#line 305
    if ((unsigned int )pattrib->ht_en != 0U) {
#line 306
      HTOpMode = pmlmeinfo->HT_protection;
#line 308
      if (((unsigned int )pmlmeext->cur_bwmode != 0U && ((unsigned int )HTOpMode == 2U || (unsigned int )HTOpMode == 3U)) || ((unsigned int )pmlmeext->cur_bwmode == 0U && (unsigned int )HTOpMode == 3U)) {
#line 310
        pattrib->vcs_mode = 1U;
#line 311
        goto ldv_53443;
      } else {

      }
    } else {

    }
#line 316
    if ((u32 )padapter->registrypriv.rts_thresh < sz) {
#line 317
      pattrib->vcs_mode = 1U;
#line 318
      goto ldv_53443;
    } else {

    }
#line 324
    if ((unsigned int )pattrib->ampdu_en != 0U) {
#line 325
      pattrib->vcs_mode = 1U;
#line 326
      goto ldv_53443;
    } else {

    }
#line 329
    pattrib->vcs_mode = 0U;
#line 330
    goto ldv_53443;
#line 331
    goto ldv_53445;
    ldv_53443: ;
  }
#line 334
  return;
}
}
#line 335 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
static void update_attrib_phy_info(struct pkt_attrib *pattrib , struct sta_info *psta ) 
{ 


  {
#line 344
  pattrib->mdata = 0U;
#line 345
  pattrib->eosp = 0U;
#line 346
  pattrib->triggered = 0U;
#line 349
  pattrib->qos_en = (u8 )psta->qos_option;
#line 351
  pattrib->raid = psta->raid;
#line 352
  pattrib->ht_en = (u8 )psta->htpriv.ht_option;
#line 353
  pattrib->bwmode = psta->htpriv.bwmode;
#line 354
  pattrib->ch_offset = psta->htpriv.ch_offset;
#line 355
  pattrib->sgi = psta->htpriv.sgi;
#line 356
  pattrib->ampdu_en = 0U;
#line 358
  pattrib->retry_ctrl = 0U;
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
u8 qos_acm23a(u8 acm_mask , u8 priority ) 
{ 
  u8 change_priority ;

  {
#line 363
  change_priority = priority;
#line 365
  switch ((int )priority) {
  case 0: ;
  case 3: ;
#line 368
  if (((unsigned long )acm_mask & 2UL) != 0UL) {
#line 369
    change_priority = 1U;
  } else {

  }
#line 370
  goto ldv_53457;
  case 1: ;
  case 2: ;
#line 373
  goto ldv_53457;
  case 4: ;
  case 5: ;
#line 376
  if (((unsigned long )acm_mask & 4UL) != 0UL) {
#line 377
    change_priority = 0U;
  } else {

  }
#line 378
  goto ldv_53457;
  case 6: ;
  case 7: ;
#line 381
  if (((unsigned long )acm_mask & 8UL) != 0UL) {
#line 382
    change_priority = 5U;
  } else {

  }
#line 383
  goto ldv_53457;
  default: ;
#line 385
  if (GlobalDebugLevel23A > 3U) {
#line 385
    printk("\016RTL8723AU: qos_acm23a(): invalid pattrib->priority: %d!!!\n", (int )priority);
  } else {

  }
#line 387
  change_priority = 0U;
#line 388
  goto ldv_53457;
  }
  ldv_53457: ;
#line 391
  return (change_priority);
}
}
#line 394 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
static void set_qos(struct sk_buff *skb , struct pkt_attrib *pattrib ) 
{ 
  u8 *pframe ;
  struct iphdr *ip_hdr___0 ;
  u8 UserPriority ;

  {
#line 396
  pframe = skb->data;
#line 398
  UserPriority = 0U;
#line 401
  if ((unsigned int )pattrib->ether_type == 2048U) {
#line 402
    ip_hdr___0 = (struct iphdr *)pframe + 14U;
#line 403
    UserPriority = (u8 )((int )ip_hdr___0->tos >> 5);
  } else
#line 404
  if ((unsigned int )pattrib->ether_type == 34958U) {
#line 408
    UserPriority = 7U;
  } else {

  }
#line 411
  pattrib->priority = UserPriority;
#line 412
  pattrib->hdrlen = 26U;
#line 413
  pattrib->type = 136U;
#line 414
  return;
}
}
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
static int update_attrib(struct rtw_adapter *padapter , struct sk_buff *skb , struct pkt_attrib *pattrib ) 
{ 
  struct sta_info *psta ;
  int bmcast ;
  struct sta_priv *pstapriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  int res ;
  struct ethhdr *ehdr ;
  __u16 tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  u8 *pframe ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;

  {
#line 419
  psta = (struct sta_info *)0;
#line 421
  pstapriv = & padapter->stapriv;
#line 422
  psecuritypriv = & padapter->securitypriv;
#line 423
  pmlmepriv = & padapter->mlmepriv;
#line 424
  res = 1;
#line 425
  ehdr = (struct ethhdr *)skb->data;
#line 427
  tmp = __fswab16((int )ehdr->h_proto);
#line 427
  pattrib->ether_type = tmp;
#line 429
  ether_addr_copy((u8 *)(& pattrib->dst), (u8 const   *)(& ehdr->h_dest));
#line 430
  ether_addr_copy((u8 *)(& pattrib->src), (u8 const   *)(& ehdr->h_source));
#line 432
  pattrib->pctrl = 0U;
#line 434
  tmp___4 = check_fwstate(pmlmepriv, 32);
#line 434
  if ((int )tmp___4) {
#line 436
    ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
#line 437
    ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
  } else {
#line 434
    tmp___5 = check_fwstate(pmlmepriv, 64);
#line 434
    if ((int )tmp___5) {
#line 436
      ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
#line 437
      ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
    } else {
#line 438
      tmp___3 = check_fwstate(pmlmepriv, 8);
#line 438
      if ((int )tmp___3) {
#line 439
        tmp___0 = get_bssid(pmlmepriv);
#line 439
        ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)tmp___0);
#line 440
        ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
      } else {
#line 441
        tmp___2 = check_fwstate(pmlmepriv, 16);
#line 441
        if ((int )tmp___2) {
#line 442
          ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
#line 443
          tmp___1 = get_bssid(pmlmepriv);
#line 443
          ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)tmp___1);
        } else {

        }
      }
    }
  }
#line 446
  pattrib->pktlen = skb->len - 14U;
#line 448
  if ((unsigned int )pattrib->ether_type == 2048U) {
#line 452
    pattrib->dhcp_pkt = 0U;
#line 454
    if (pattrib->pktlen > 306U) {
#line 455
      if ((unsigned int )pattrib->ether_type == 2048U) {
#line 456
        pframe = skb->data;
#line 458
        pframe = pframe + 14UL;
#line 460
        if (((unsigned int )*(pframe + 21UL) == 68U && (unsigned int )*(pframe + 23UL) == 67U) || ((unsigned int )*(pframe + 21UL) == 67U && (unsigned int )*(pframe + 23UL) == 68U)) {
#line 464
          if (GlobalDebugLevel23A > 3U) {
#line 464
            rt_trace(1, 4, "======================update_attrib: get DHCP Packet\n");
          } else {

          }
#line 467
          pattrib->dhcp_pkt = 1U;
        } else {

        }
      } else {

      }
    } else {

    }
  } else
#line 471
  if ((unsigned int )pattrib->ether_type == 34958U) {
#line 472
    if (GlobalDebugLevel23A != 0U) {
#line 472
      printk("\016RTL8723AU: send eapol packet\n");
    } else {

    }
  } else {

  }
#line 475
  if ((unsigned int )pattrib->ether_type == 34958U || (unsigned int )pattrib->dhcp_pkt == 1U) {
#line 476
    rtw_set_scan_deny(padapter, 3000U);
  } else {

  }
#line 480
  if (((unsigned int )pattrib->ether_type == 2054U || (unsigned int )pattrib->ether_type == 34958U) || (unsigned int )pattrib->dhcp_pkt == 1U) {
#line 482
    rtw_lps_ctrl_wk_cmd23a(padapter, 4, 1);
  } else {

  }
#line 485
  tmp___6 = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 485
  bmcast = (int )tmp___6;
#line 488
  if (bmcast != 0) {
#line 489
    psta = rtw_get_bcmc_stainfo23a(padapter);
  } else {
#line 491
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->ra));
#line 492
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 493
      if (GlobalDebugLevel23A > 2U) {
#line 493
        rt_trace(1, 3, "update_attrib => get sta_info fail, ra:%pM\n", (u8 *)(& pattrib->ra));
      } else {

      }
#line 496
      res = 0;
#line 497
      goto exit;
    } else {
#line 498
      tmp___7 = check_fwstate(pmlmepriv, 16);
#line 498
      if ((int )tmp___7 && (psta->state & 1U) == 0U) {
#line 500
        res = 0;
#line 501
        goto exit;
      } else {

      }
    }
  }
#line 505
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 506
    pattrib->mac_id = (u8 )psta->mac_id;
#line 508
    pattrib->psta = psta;
  } else {
#line 511
    if (GlobalDebugLevel23A > 2U) {
#line 511
      rt_trace(1, 3, "update_attrib => get sta_info fail, ra:%pM\n", (u8 *)(& pattrib->ra));
    } else {

    }
#line 514
    res = 0;
#line 515
    goto exit;
  }
#line 518
  pattrib->ack_policy = 0U;
#line 522
  pattrib->pkt_hdrlen = 14U;
#line 524
  pattrib->hdrlen = 24U;
#line 525
  pattrib->type = 8U;
#line 526
  pattrib->priority = 0U;
#line 528
  tmp___8 = check_fwstate(pmlmepriv, 112);
#line 528
  if ((int )tmp___8) {
#line 530
    if (psta->qos_option != 0U) {
#line 531
      set_qos(skb, pattrib);
    } else {

    }
  } else
#line 533
  if (pmlmepriv->qos_option != 0U) {
#line 534
    set_qos(skb, pattrib);
#line 536
    if ((unsigned int )pmlmepriv->acm_mask != 0U) {
#line 537
      pattrib->priority = qos_acm23a((int )pmlmepriv->acm_mask, (int )pattrib->priority);
    } else {

    }
  } else {

  }
#line 543
  if (psta->ieee8021x_blocked == 1U) {
#line 544
    if (GlobalDebugLevel23A > 3U) {
#line 544
      rt_trace(1, 4, "psta->ieee8021x_blocked == true\n");
    } else {

    }
#line 547
    pattrib->encrypt = 0U;
#line 549
    if ((unsigned int )pattrib->ether_type != 34958U) {
#line 549
      tmp___9 = check_fwstate(pmlmepriv, 65536);
#line 549
      if (tmp___9) {
#line 549
        tmp___10 = 0;
      } else {
#line 549
        tmp___10 = 1;
      }
#line 549
      if (tmp___10) {
#line 551
        if (GlobalDebugLevel23A > 3U) {
#line 551
          rt_trace(1, 4, "psta->ieee8021x_blocked == true,  pattrib->ether_type(%.4x) != 0x888e\n",
                   (int )pattrib->ether_type);
        } else {

        }
#line 554
        res = 0;
#line 555
        goto exit;
      } else {

      }
    } else {

    }
  } else {
#line 558
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U: 
#line 558
    pattrib->encrypt = psecuritypriv->dot11PrivacyAlgrthm;
#line 558
    goto ldv_53489;
    case 2U: ;
#line 558
    if (bmcast != 0) {
#line 558
      pattrib->encrypt = psecuritypriv->dot118021XGrpPrivacy;
    } else {
#line 558
      pattrib->encrypt = psta->dot118021XPrivacy;
    }
#line 558
    goto ldv_53489;
    }
    ldv_53489: ;
#line 560
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U: 
#line 564
    pattrib->key_idx = (unsigned char )psecuritypriv->dot11PrivacyKeyIndex;
#line 566
    goto ldv_53494;
    case 2U: ;
#line 568
    if (bmcast != 0) {
#line 569
      pattrib->key_idx = (unsigned char )psecuritypriv->dot118021XGrpKeyid;
    } else {
#line 572
      pattrib->key_idx = 0U;
    }
#line 573
    goto ldv_53494;
    default: 
#line 575
    pattrib->key_idx = 0U;
#line 576
    goto ldv_53494;
    }
    ldv_53494: ;
  }
#line 581
  switch (pattrib->encrypt) {
  case 1027073U: ;
  case 1027077U: 
#line 584
  pattrib->iv_len = 4U;
#line 585
  pattrib->icv_len = 4U;
#line 586
  goto ldv_53499;
  case 1027074U: 
#line 589
  pattrib->iv_len = 8U;
#line 590
  pattrib->icv_len = 4U;
#line 592
  if ((unsigned int )*((unsigned char *)padapter + 10948UL) == 0U) {
#line 593
    if (GlobalDebugLevel23A > 3U) {
#line 593
      rt_trace(1, 4, "padapter->securitypriv.busetkipkey(%d) == false drop packet\n",
               (int )padapter->securitypriv.busetkipkey);
    } else {

    }
#line 596
    res = 0;
#line 597
    goto exit;
  } else {

  }
#line 600
  goto ldv_53499;
  case 1027076U: ;
#line 602
  if (GlobalDebugLevel23A > 6U) {
#line 602
    rt_trace(1, 7, "pattrib->encrypt =%d (WLAN_CIPHER_SUITE_CCMP)\n", pattrib->encrypt);
  } else {

  }
#line 605
  pattrib->iv_len = 8U;
#line 606
  pattrib->icv_len = 8U;
#line 607
  goto ldv_53499;
  default: 
#line 610
  pattrib->iv_len = 0U;
#line 611
  pattrib->icv_len = 0U;
#line 612
  goto ldv_53499;
  }
  ldv_53499: ;
#line 615
  if (GlobalDebugLevel23A > 6U) {
#line 615
    rt_trace(1, 7, "update_attrib: encrypt =%d\n", pattrib->encrypt);
  } else {

  }
#line 618
  if (pattrib->encrypt != 0U && (unsigned int )*((unsigned char *)psecuritypriv + 580UL) == 0U) {
#line 619
    pattrib->bswenc = 1U;
#line 620
    if (GlobalDebugLevel23A > 3U) {
#line 620
      rt_trace(1, 4, "update_attrib: encrypt =%d bswenc = true\n", pattrib->encrypt);
    } else {

    }
  } else {
#line 624
    pattrib->bswenc = 0U;
#line 625
    if (GlobalDebugLevel23A > 6U) {
#line 625
      rt_trace(1, 7, "update_attrib: bswenc = false\n");
    } else {

    }
  }
#line 628
  update_attrib_phy_info(pattrib, psta);
  exit: ;
#line 632
  return (res);
}
}
#line 635 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
static int xmitframe_addmic(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  struct mic_data micdata ;
  struct sta_info *stainfo ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;
  int curfragnum ;
  int length ;
  u8 *pframe ;
  u8 *payload ;
  u8 mic[8U] ;
  u8 priority[4U] ;
  u8 hw_hdr_offset ;
  int bmcst ;
  bool tmp ;
  u8 null_key[16U] ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 639
  pattrib = & pxmitframe->attrib;
#line 640
  psecuritypriv = & padapter->securitypriv;
#line 641
  pxmitpriv = & padapter->xmitpriv;
#line 644
  priority[0] = 0U;
#line 644
  priority[1] = 0U;
#line 644
  priority[2] = 0U;
#line 644
  priority[3] = 0U;
#line 645
  hw_hdr_offset = 0U;
#line 646
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 646
  bmcst = (int )tmp;
#line 648
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 649
    stainfo = pattrib->psta;
  } else {
#line 651
    if (GlobalDebugLevel23A > 3U) {
#line 651
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "xmitframe_addmic");
    } else {

    }
#line 652
    stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
#line 655
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
#line 656
    if (GlobalDebugLevel23A > 3U) {
#line 656
      printk("\016RTL8723AU: %s, psta == NUL\n", "xmitframe_addmic");
    } else {

    }
#line 657
    return (0);
  } else {

  }
#line 660
  if ((stainfo->state & 1U) == 0U) {
#line 661
    if (GlobalDebugLevel23A > 3U) {
#line 661
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "xmitframe_addmic",
             stainfo->state);
    } else {

    }
#line 663
    return (0);
  } else {

  }
#line 666
  hw_hdr_offset = 40U;
#line 668
  if (pattrib->encrypt == 1027074U) {
#line 670
    if ((unsigned long )stainfo != (unsigned long )((struct sta_info *)0)) {
#line 671
      null_key[0] = 0U;
#line 671
      null_key[1] = 0U;
#line 671
      null_key[2] = 0U;
#line 671
      null_key[3] = 0U;
#line 671
      null_key[4] = 0U;
#line 671
      null_key[5] = 0U;
#line 671
      null_key[6] = 0U;
#line 671
      null_key[7] = 0U;
#line 671
      null_key[8] = 0U;
#line 671
      null_key[9] = 0U;
#line 671
      null_key[10] = 0U;
#line 671
      null_key[11] = 0U;
#line 671
      null_key[12] = 0U;
#line 671
      null_key[13] = 0U;
#line 671
      null_key[14] = 0U;
#line 671
      null_key[15] = 0U;
#line 676
      pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
#line 678
      if (bmcst != 0) {
#line 679
        tmp___0 = memcmp((void const   *)(& psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey),
                         (void const   *)(& null_key), 16UL);
#line 679
        if (tmp___0 == 0) {
#line 680
          return (0);
        } else {

        }
#line 683
        rtw_secmicsetkey23a(& micdata, (u8 *)(& psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey));
      } else {
#line 685
        tmp___1 = memcmp((void const   *)(& stainfo->dot11tkiptxmickey.skey), (void const   *)(& null_key),
                         16UL);
#line 685
        if (tmp___1 == 0) {
#line 687
          return (0);
        } else {

        }
#line 690
        rtw_secmicsetkey23a(& micdata, (u8 *)(& stainfo->dot11tkiptxmickey.skey));
      }
#line 693
      if ((int )*(pframe + 1UL) & 1) {
#line 695
        rtw_secmicappend23a(& micdata, pframe + 16UL, 6U);
#line 696
        if (((int )*(pframe + 1UL) & 2) != 0) {
#line 697
          rtw_secmicappend23a(& micdata, pframe + 24UL, 6U);
        } else {
#line 700
          rtw_secmicappend23a(& micdata, pframe + 10UL, 6U);
        }
      } else {
#line 704
        rtw_secmicappend23a(& micdata, pframe + 4UL, 6U);
#line 705
        if (((int )*(pframe + 1UL) & 2) != 0) {
#line 706
          rtw_secmicappend23a(& micdata, pframe + 16UL, 6U);
        } else {
#line 709
          rtw_secmicappend23a(& micdata, pframe + 10UL, 6U);
        }
      }
#line 714
      if ((unsigned int )pattrib->qos_en != 0U) {
#line 715
        priority[0] = pxmitframe->attrib.priority;
      } else {

      }
#line 717
      rtw_secmicappend23a(& micdata, (u8 *)(& priority), 4U);
#line 719
      payload = pframe;
#line 721
      curfragnum = 0;
#line 721
      goto ldv_53523;
      ldv_53522: 
#line 723
      payload = (u8 *)(((unsigned long )payload + 3UL) & 0xfffffffffffffffcUL);
#line 724
      if (GlobalDebugLevel23A > 3U) {
#line 724
        rt_trace(1, 4, "=== curfragnum =%d, pframe = 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x,!!!\n",
                 curfragnum, (int )*payload, (int )*(payload + 1UL), (int )*(payload + 2UL),
                 (int )*(payload + 3UL), (int )*(payload + 4UL), (int )*(payload + 5UL),
                 (int )*(payload + 6UL), (int )*(payload + 7UL));
      } else {

      }
#line 731
      payload = payload + ((unsigned long )pattrib->hdrlen + (unsigned long )pattrib->iv_len);
#line 733
      if (GlobalDebugLevel23A > 3U) {
#line 733
        rt_trace(1, 4, "curfragnum =%d pattrib->hdrlen =%d pattrib->iv_len =%d\n",
                 curfragnum, (int )pattrib->hdrlen, (int )pattrib->iv_len);
      } else {

      }
#line 737
      if (curfragnum + 1 == (int )pattrib->nr_frags) {
#line 738
        length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - ((unsigned int )pattrib->bswenc != 0U ? (u32 )pattrib->icv_len : 0U));
#line 743
        rtw_secmicappend23a(& micdata, payload, (u32 )length);
#line 745
        payload = payload + (unsigned long )length;
      } else {
#line 747
        length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - ((unsigned int )pattrib->bswenc != 0U ? (uint )pattrib->icv_len : 0U));
#line 752
        rtw_secmicappend23a(& micdata, payload, (u32 )length);
#line 754
        payload = payload + ((unsigned long )length + (unsigned long )pattrib->icv_len);
#line 756
        if (GlobalDebugLevel23A > 3U) {
#line 756
          rt_trace(1, 4, "curfragnum =%d length =%d pattrib->icv_len =%d\n", curfragnum,
                   length, (int )pattrib->icv_len);
        } else {

        }
      }
#line 722
      curfragnum = curfragnum + 1;
      ldv_53523: ;
#line 721
      if ((int )pattrib->nr_frags > curfragnum) {
#line 723
        goto ldv_53522;
      } else {

      }
#line 763
      rtw_secgetmic23a(& micdata, (u8 *)(& mic));
#line 764
      if (GlobalDebugLevel23A > 3U) {
#line 764
        rt_trace(1, 4, "xmitframe_addmic: before add mic code!!\n");
      } else {

      }
#line 766
      if (GlobalDebugLevel23A > 3U) {
#line 766
        rt_trace(1, 4, "xmitframe_addmic: pattrib->last_txcmdsz =%d!!!\n", pattrib->last_txcmdsz);
      } else {

      }
#line 769
      if (GlobalDebugLevel23A > 3U) {
#line 769
        rt_trace(1, 4, "xmitframe_addmic: mic[0]= 0x%.2x , mic[1]=0x%.2x , mic[2]= 0x%.2x , mic[3]= 0x%.2x\nmic[4]= 0x%.2x , mic[5]= 0x%.2x , mic[6]= 0x%.2x , mic[7]= 0x%.2x !!!!\n",
                 (int )mic[0], (int )mic[1], (int )mic[2], (int )mic[3], (int )mic[4],
                 (int )mic[5], (int )mic[6], (int )mic[7]);
      } else {

      }
#line 776
      memcpy((void *)payload, (void const   *)(& mic), 8UL);
#line 777
      pattrib->last_txcmdsz = pattrib->last_txcmdsz + 8U;
#line 779
      if (GlobalDebugLevel23A > 6U) {
#line 779
        rt_trace(1, 7, "======== last pkt ========\n");
      } else {

      }
#line 781
      payload = payload + (8UL - (unsigned long )pattrib->last_txcmdsz);
#line 782
      curfragnum = 0;
#line 782
      goto ldv_53526;
      ldv_53525: ;
#line 784
      if (GlobalDebugLevel23A > 6U) {
#line 784
        rt_trace(1, 7, "%.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x\n",
                 (int )*(payload + (unsigned long )curfragnum), (int )*(payload + ((unsigned long )curfragnum + 1UL)),
                 (int )*(payload + ((unsigned long )curfragnum + 2UL)), (int )*(payload + ((unsigned long )curfragnum + 3UL)),
                 (int )*(payload + ((unsigned long )curfragnum + 4UL)), (int )*(payload + ((unsigned long )curfragnum + 5UL)),
                 (int )*(payload + ((unsigned long )curfragnum + 6UL)), (int )*(payload + ((unsigned long )curfragnum + 7UL)));
      } else {

      }
#line 783
      curfragnum = curfragnum + 8;
      ldv_53526: ;
#line 782
      if ((u32 )curfragnum < pattrib->last_txcmdsz) {
#line 784
        goto ldv_53525;
      } else {

      }

    } else
#line 796
    if (GlobalDebugLevel23A > 3U) {
#line 796
      rt_trace(1, 4, "xmitframe_addmic: rtw_get_stainfo23a ==NULL!!!\n");
    } else {

    }
  } else {

  }
#line 801
  return (1);
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
static int xmitframe_swencrypt(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  struct pkt_attrib *pattrib ;

  {
#line 807
  pattrib = & pxmitframe->attrib;
#line 810
  if ((unsigned int )pattrib->bswenc != 0U) {
#line 812
    if (GlobalDebugLevel23A > 2U) {
#line 812
      rt_trace(1, 3, "### xmitframe_swencrypt\n");
    } else {

    }
#line 814
    switch (pattrib->encrypt) {
    case 1027073U: ;
    case 1027077U: 
#line 817
    rtw_wep_encrypt23a(padapter, pxmitframe);
#line 818
    goto ldv_53535;
    case 1027074U: 
#line 820
    rtw_tkip_encrypt23a(padapter, pxmitframe);
#line 821
    goto ldv_53535;
    case 1027076U: 
#line 823
    rtw_aes_encrypt23a(padapter, pxmitframe);
#line 824
    goto ldv_53535;
    default: ;
#line 826
    goto ldv_53535;
    }
    ldv_53535: ;
  } else
#line 830
  if (GlobalDebugLevel23A > 5U) {
#line 830
    rt_trace(1, 6, "### xmitframe_hwencrypt\n");
  } else {

  }
#line 834
  return (1);
}
}
#line 837 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
static int rtw_make_wlanhdr(struct rtw_adapter *padapter , u8 *hdr , struct pkt_attrib *pattrib ) 
{ 
  struct ieee80211_hdr *pwlanhdr ;
  struct ieee80211_qos_hdr *qoshdr ;
  struct mlme_priv *pmlmepriv ;
  u8 qos_option ;
  int res ;
  struct sta_info *psta ;
  int bmcst ;
  bool tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  u16 tx_seq ;

  {
#line 840
  pwlanhdr = (struct ieee80211_hdr *)hdr;
#line 842
  pmlmepriv = & padapter->mlmepriv;
#line 843
  qos_option = 0U;
#line 844
  res = 1;
#line 848
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 848
  bmcst = (int )tmp;
#line 850
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 851
    psta = pattrib->psta;
  } else {
#line 853
    if (GlobalDebugLevel23A > 3U) {
#line 853
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_make_wlanhdr");
    } else {

    }
#line 854
    if (bmcst != 0) {
#line 855
      psta = rtw_get_bcmc_stainfo23a(padapter);
    } else {
#line 857
      psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
    }
  }
#line 861
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 862
    if (GlobalDebugLevel23A > 3U) {
#line 862
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_make_wlanhdr");
    } else {

    }
#line 863
    return (0);
  } else {

  }
#line 866
  if ((psta->state & 1U) == 0U) {
#line 867
    if (GlobalDebugLevel23A > 3U) {
#line 867
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_make_wlanhdr",
             psta->state);
    } else {

    }
#line 868
    return (0);
  } else {

  }
#line 871
  memset((void *)hdr, 0, 64UL);
#line 873
  pwlanhdr->frame_control = pattrib->type;
#line 875
  if (((int )pattrib->type & 8) != 0) {
#line 876
    tmp___7 = check_fwstate(pmlmepriv, 8);
#line 876
    if ((int )tmp___7) {
#line 879
      pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
#line 881
      tmp___0 = get_bssid(pmlmepriv);
#line 881
      ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)tmp___0);
#line 882
      ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)(& pattrib->src));
#line 883
      ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)(& pattrib->dst));
#line 885
      if (pmlmepriv->qos_option != 0U) {
#line 886
        qos_option = 1U;
      } else {

      }
    } else {
#line 888
      tmp___6 = check_fwstate(pmlmepriv, 16);
#line 888
      if ((int )tmp___6) {
#line 890
        pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
#line 892
        ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)(& pattrib->dst));
#line 893
        tmp___1 = get_bssid(pmlmepriv);
#line 893
        ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp___1);
#line 894
        ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)(& pattrib->src));
#line 896
        if (psta->qos_option != 0U) {
#line 897
          qos_option = 1U;
        } else {

        }
      } else {
#line 898
        tmp___4 = check_fwstate(pmlmepriv, 32);
#line 898
        if ((int )tmp___4) {
#line 898
          goto _L;
        } else {
#line 898
          tmp___5 = check_fwstate(pmlmepriv, 64);
#line 898
          if ((int )tmp___5) {
            _L: /* CIL Label */ 
#line 900
            ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)(& pattrib->dst));
#line 901
            ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)(& pattrib->src));
#line 902
            tmp___2 = get_bssid(pmlmepriv);
#line 902
            ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___2);
#line 904
            if (psta->qos_option != 0U) {
#line 905
              qos_option = 1U;
            } else {

            }
          } else {
#line 908
            if (GlobalDebugLevel23A > 3U) {
#line 908
              tmp___3 = get_fwstate(pmlmepriv);
#line 908
              rt_trace(1, 4, "fw_state:%x is not allowed to xmit frame\n", tmp___3);
            } else {

            }
#line 911
            res = 0;
#line 912
            goto exit;
          }
        }
      }
    }
#line 914
    if ((unsigned int )pattrib->mdata != 0U) {
#line 915
      pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 8192U);
    } else {

    }
#line 917
    if (pattrib->encrypt != 0U) {
#line 918
      pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 16384U);
    } else {

    }
#line 920
    if ((unsigned int )qos_option != 0U) {
#line 921
      qoshdr = (struct ieee80211_qos_hdr *)hdr;
#line 923
      qoshdr->qos_ctrl = (unsigned int )((unsigned short )pattrib->priority) & 15U;
#line 926
      qoshdr->qos_ctrl = (__le16 )((int )((short )qoshdr->qos_ctrl) | ((int )((short )((int )pattrib->ack_policy << 5)) & 96));
#line 930
      if ((unsigned int )pattrib->eosp != 0U) {
#line 931
        qoshdr->qos_ctrl = (__le16 )((unsigned int )qoshdr->qos_ctrl | 16U);
      } else {

      }
    } else {

    }
#line 937
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 938
      psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] = (u16 )((int )psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] + 1);
#line 939
      psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] = (unsigned int )psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] & 4095U;
#line 940
      pattrib->seqnum = psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority];
#line 942
      pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pattrib->seqnum << 4)) & 65520U;
#line 945
      if ((unsigned int )pattrib->ht_en != 0U && (int )psta->htpriv.ampdu_enable) {
#line 946
        if ((unsigned int )pattrib->priority > 15U) {
#line 947
          printk("\f%s: Invalid pattrib->priority %i\n", "rtw_make_wlanhdr", (int )pattrib->priority);
        } else {

        }
#line 950
        if ((int )((unsigned long )psta->htpriv.agg_enable_bitmap >> (int )pattrib->priority) & 1) {
#line 952
          pattrib->ampdu_en = 1U;
        } else {

        }
      } else {

      }
#line 955
      if ((unsigned int )pattrib->ampdu_en != 0U) {
#line 958
        tx_seq = psta->BA_starting_seqctrl[(int )pattrib->priority & 15];
#line 961
        if ((((int )pattrib->seqnum - (int )tx_seq) & 2048) != 0) {
#line 963
          pattrib->ampdu_en = 0U;
        } else
#line 964
        if ((int )pattrib->seqnum == (int )tx_seq) {
#line 965
          psta->BA_starting_seqctrl[(int )pattrib->priority & 15] = (unsigned int )((u16 )((unsigned int )tx_seq + 1U)) & 4095U;
#line 966
          pattrib->ampdu_en = 1U;
        } else {
#line 969
          psta->BA_starting_seqctrl[(int )pattrib->priority & 15] = (unsigned int )((u16 )((unsigned int )pattrib->seqnum + 1U)) & 4095U;
#line 970
          pattrib->ampdu_en = 1U;
        }
      } else {

      }
    } else {

    }
  } else {

  }
  exit: ;
#line 976
  return (res);
}
}
#line 979 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
s32 rtw_txframes_pending23a(struct rtw_adapter *padapter ) 
{ 
  struct xmit_priv *pxmitpriv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 981
  pxmitpriv = & padapter->xmitpriv;
#line 983
  tmp = list_empty((struct list_head  const  *)(& pxmitpriv->be_pending.queue));
#line 983
  if (tmp == 0) {
#line 983
    tmp___3 = 1;
  } else {
#line 983
    tmp___0 = list_empty((struct list_head  const  *)(& pxmitpriv->bk_pending.queue));
#line 983
    if (tmp___0 == 0) {
#line 983
      tmp___3 = 1;
    } else {
#line 983
      tmp___1 = list_empty((struct list_head  const  *)(& pxmitpriv->vi_pending.queue));
#line 983
      if (tmp___1 == 0) {
#line 983
        tmp___3 = 1;
      } else {
#line 983
        tmp___2 = list_empty((struct list_head  const  *)(& pxmitpriv->vo_pending.queue));
#line 983
        if (tmp___2 == 0) {
#line 983
          tmp___3 = 1;
        } else {
#line 983
          tmp___3 = 0;
        }
      }
    }
  }
#line 983
  return (tmp___3);
}
}
#line 989 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
s32 rtw_txframes_sta_ac_pending23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) 
{ 
  struct sta_info *psta ;
  struct tx_servq *ptxservq ;
  int priority ;

  {
#line 994
  priority = (int )pattrib->priority;
#line 996
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 997
    psta = pattrib->psta;
  } else {
#line 999
    if (GlobalDebugLevel23A > 3U) {
#line 999
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_txframes_sta_ac_pending23a");
    } else {

    }
#line 1000
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
#line 1002
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1003
    if (GlobalDebugLevel23A > 3U) {
#line 1003
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_txframes_sta_ac_pending23a");
    } else {

    }
#line 1004
    return (0);
  } else {

  }
#line 1006
  if ((psta->state & 1U) == 0U) {
#line 1007
    if (GlobalDebugLevel23A > 3U) {
#line 1007
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_txframes_sta_ac_pending23a",
             psta->state);
    } else {

    }
#line 1009
    return (0);
  } else {

  }
#line 1011
  switch (priority) {
  case 1: ;
  case 2: 
#line 1014
  ptxservq = & psta->sta_xmitpriv.bk_q;
#line 1015
  goto ldv_53568;
  case 4: ;
  case 5: 
#line 1018
  ptxservq = & psta->sta_xmitpriv.vi_q;
#line 1019
  goto ldv_53568;
  case 6: ;
  case 7: 
#line 1022
  ptxservq = & psta->sta_xmitpriv.vo_q;
#line 1023
  goto ldv_53568;
  case 0: ;
  case 3: ;
  default: 
#line 1027
  ptxservq = & psta->sta_xmitpriv.be_q;
#line 1028
  goto ldv_53568;
  }
  ldv_53568: ;
#line 1030
  return (ptxservq->qcnt);
}
}
#line 1040 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
static int rtw_put_snap(u8 *data , u16 h_proto ) 
{ 


  {
#line 1042
  if ((unsigned int )h_proto == 33079U || (unsigned int )h_proto == 33011U) {
#line 1043
    ether_addr_copy(data, (u8 const   *)(& bridge_tunnel_header));
  } else {
#line 1045
    ether_addr_copy(data, (u8 const   *)(& rfc1042_header));
  }
#line 1047
  data = data + 6UL;
#line 1048
  put_unaligned_be16((int )h_proto, (void *)data);
#line 1049
  return (8);
}
}
#line 1064 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
s32 rtw_xmitframe_coalesce23a(struct rtw_adapter *padapter , struct sk_buff *skb ,
                              struct xmit_frame *pxmitframe ) 
{ 
  struct sta_info *psta ;
  struct xmit_priv *pxmitpriv ;
  struct pkt_attrib *pattrib ;
  struct ieee80211_hdr *hdr ;
  s32 frg_inx ;
  s32 frg_len ;
  s32 mpdu_len ;
  s32 llc_sz ;
  s32 mem_sz ;
  u8 *pframe ;
  u8 *mem_start ;
  u8 hw_hdr_offset ;
  u8 *pbuf_start ;
  u8 *pdata ;
  int data_len ;
  s32 bmcst ;
  bool tmp ;
  int res ;
  int tmp___0 ;
  s32 __min1 ;
  s32 __min2 ;
  s32 __min1___0 ;
  s32 __min2___0 ;
  int tmp___1 ;

  {
#line 1068
  pxmitpriv = & padapter->xmitpriv;
#line 1069
  pattrib = & pxmitframe->attrib;
#line 1075
  pdata = skb->data;
#line 1076
  data_len = (int )skb->len;
#line 1077
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 1077
  bmcst = (s32 )tmp;
#line 1078
  res = 1;
#line 1080
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 1081
    psta = pattrib->psta;
  } else {
#line 1083
    if (GlobalDebugLevel23A > 3U) {
#line 1083
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_xmitframe_coalesce23a");
    } else {

    }
#line 1084
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
#line 1087
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1088
    if (GlobalDebugLevel23A > 3U) {
#line 1088
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_xmitframe_coalesce23a");
    } else {

    }
#line 1089
    return (0);
  } else {

  }
#line 1092
  if ((psta->state & 1U) == 0U) {
#line 1093
    if (GlobalDebugLevel23A > 3U) {
#line 1093
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_xmitframe_coalesce23a",
             psta->state);
    } else {

    }
#line 1095
    return (0);
  } else {

  }
#line 1098
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
#line 1099
    if (GlobalDebugLevel23A > 3U) {
#line 1099
      printk("\016RTL8723AU: ==> %s buf_addr == NULL\n", "rtw_xmitframe_coalesce23a");
    } else {

    }
#line 1100
    return (0);
  } else {

  }
#line 1103
  pbuf_start = pxmitframe->buf_addr;
#line 1105
  hw_hdr_offset = 40U;
#line 1107
  mem_start = pbuf_start + (unsigned long )hw_hdr_offset;
#line 1109
  tmp___0 = rtw_make_wlanhdr(padapter, mem_start, pattrib);
#line 1109
  if (tmp___0 == 0) {
#line 1110
    if (GlobalDebugLevel23A > 3U) {
#line 1110
      rt_trace(1, 4, "%s: rtw_make_wlanhdr fail; drop pkt\n", "rtw_xmitframe_coalesce23a");
    } else {

    }
#line 1112
    res = 0;
#line 1113
    goto exit;
  } else {

  }
#line 1116
  pdata = pdata + (unsigned long )pattrib->pkt_hdrlen;
#line 1117
  data_len = data_len - (int )pattrib->pkt_hdrlen;
#line 1119
  frg_inx = 0;
#line 1120
  frg_len = (s32 )(pxmitpriv->frag_len - 4U);
  ldv_53616: 
#line 1123
  llc_sz = 0;
#line 1125
  mpdu_len = frg_len;
#line 1127
  pframe = mem_start;
#line 1128
  hdr = (struct ieee80211_hdr *)mem_start;
#line 1130
  pframe = pframe + (unsigned long )pattrib->hdrlen;
#line 1131
  mpdu_len = mpdu_len - (int )pattrib->hdrlen;
#line 1134
  if ((unsigned int )pattrib->iv_len != 0U) {
#line 1135
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1136
      switch (pattrib->encrypt) {
      case 1027073U: ;
      case 1027077U: 
#line 1139
      pattrib->iv[0] = psta->dot11txpn._byte_.TSC0;
#line 1139
      pattrib->iv[1] = psta->dot11txpn._byte_.TSC1;
#line 1139
      pattrib->iv[2] = psta->dot11txpn._byte_.TSC2;
#line 1139
      pattrib->iv[3] = (u8 )((int )pattrib->key_idx << 6);
#line 1139
      psta->dot11txpn.val = psta->dot11txpn.val != 16777215ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
#line 1141
      goto ldv_53606;
      case 1027074U: ;
#line 1143
      if (bmcst != 0) {
#line 1144
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC1;
#line 1144
        pattrib->iv[1] = ((unsigned int )psta->dot11txpn._byte_.TSC1 & 95U) | 32U;
#line 1144
        pattrib->iv[2] = psta->dot11txpn._byte_.TSC0;
#line 1144
        pattrib->iv[3] = (u8 )((int )((signed char )((int )pattrib->key_idx << 6)) | 32);
#line 1144
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
#line 1144
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
#line 1144
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
#line 1144
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
#line 1144
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      } else {
#line 1148
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC1;
#line 1148
        pattrib->iv[1] = ((unsigned int )psta->dot11txpn._byte_.TSC1 & 95U) | 32U;
#line 1148
        pattrib->iv[2] = psta->dot11txpn._byte_.TSC0;
#line 1148
        pattrib->iv[3] = 32U;
#line 1148
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
#line 1148
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
#line 1148
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
#line 1148
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
#line 1148
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      }
#line 1150
      goto ldv_53606;
      case 1027076U: ;
#line 1152
      if (bmcst != 0) {
#line 1153
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC0;
#line 1153
        pattrib->iv[1] = psta->dot11txpn._byte_.TSC1;
#line 1153
        pattrib->iv[2] = 0U;
#line 1153
        pattrib->iv[3] = (u8 )((int )((signed char )((int )pattrib->key_idx << 6)) | 32);
#line 1153
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
#line 1153
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
#line 1153
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
#line 1153
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
#line 1153
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      } else {
#line 1157
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC0;
#line 1157
        pattrib->iv[1] = psta->dot11txpn._byte_.TSC1;
#line 1157
        pattrib->iv[2] = 0U;
#line 1157
        pattrib->iv[3] = 32U;
#line 1157
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
#line 1157
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
#line 1157
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
#line 1157
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
#line 1157
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      }
#line 1159
      goto ldv_53606;
      }
      ldv_53606: ;
    } else {

    }
#line 1163
    memcpy((void *)pframe, (void const   *)(& pattrib->iv), (size_t )pattrib->iv_len);
#line 1165
    if (GlobalDebugLevel23A > 5U) {
#line 1165
      rt_trace(1, 6, "rtw_xmiaframe_coalesce23a: keyid =%d pattrib->iv[3]=%.2x pframe =%.2x %.2x %.2x %.2x\n",
               padapter->securitypriv.dot11PrivacyKeyIndex, (int )pattrib->iv[3],
               (int )*pframe, (int )*(pframe + 1UL), (int )*(pframe + 2UL), (int )*(pframe + 3UL));
    } else {

    }
#line 1170
    pframe = pframe + (unsigned long )pattrib->iv_len;
#line 1171
    mpdu_len = mpdu_len - (int )pattrib->iv_len;
  } else {

  }
#line 1173
  if (frg_inx == 0) {
#line 1174
    llc_sz = rtw_put_snap(pframe, (int )pattrib->ether_type);
#line 1175
    pframe = pframe + (unsigned long )llc_sz;
#line 1176
    mpdu_len = mpdu_len - llc_sz;
  } else {

  }
#line 1179
  if ((unsigned int )pattrib->icv_len != 0U && (unsigned int )pattrib->bswenc != 0U) {
#line 1180
    mpdu_len = mpdu_len - (int )pattrib->icv_len;
  } else {

  }
#line 1182
  if (bmcst != 0) {
#line 1184
    __min1 = data_len;
#line 1184
    __min2 = (s32 )pattrib->pktlen;
#line 1184
    mem_sz = __min1 < __min2 ? __min1 : __min2;
  } else {
#line 1186
    __min1___0 = data_len;
#line 1186
    __min2___0 = mpdu_len;
#line 1186
    mem_sz = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
  }
#line 1188
  memcpy((void *)pframe, (void const   *)pdata, (size_t )mem_sz);
#line 1190
  pframe = pframe + (unsigned long )mem_sz;
#line 1191
  pdata = pdata + (unsigned long )mem_sz;
#line 1192
  data_len = data_len - mem_sz;
#line 1194
  if ((unsigned int )pattrib->icv_len != 0U && (unsigned int )pattrib->bswenc != 0U) {
#line 1195
    memcpy((void *)pframe, (void const   *)(& pattrib->icv), (size_t )pattrib->icv_len);
#line 1196
    pframe = pframe + (unsigned long )pattrib->icv_len;
  } else {

  }
#line 1199
  frg_inx = frg_inx + 1;
#line 1201
  if (bmcst != 0 || data_len <= 0) {
#line 1202
    pattrib->nr_frags = (u8 )frg_inx;
#line 1204
    pattrib->last_txcmdsz = (u32 )(((((int )pattrib->hdrlen + (int )pattrib->iv_len) + ((unsigned int )pattrib->nr_frags == 1U ? llc_sz : 0)) + ((unsigned int )pattrib->bswenc != 0U ? (int )pattrib->icv_len : 0)) + mem_sz);
#line 1210
    hdr->frame_control = (unsigned int )hdr->frame_control & 64511U;
#line 1213
    goto ldv_53615;
  } else
#line 1215
  if (GlobalDebugLevel23A > 3U) {
#line 1215
    rt_trace(1, 4, "%s: There\'re still something in packet!\n", "rtw_xmitframe_coalesce23a");
  } else {

  }
#line 1219
  hdr->frame_control = (__le16 )((unsigned int )hdr->frame_control | 1024U);
#line 1221
  mem_start = (u8 *)((unsigned long )hw_hdr_offset + (((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL));
#line 1222
  memcpy((void *)mem_start, (void const   *)pbuf_start + (unsigned long )hw_hdr_offset,
           (size_t )pattrib->hdrlen);
#line 1223
  goto ldv_53616;
  ldv_53615: 
#line 1225
  tmp___1 = xmitframe_addmic(padapter, pxmitframe);
#line 1225
  if (tmp___1 == 0) {
#line 1226
    if (GlobalDebugLevel23A > 3U) {
#line 1226
      rt_trace(1, 4, "xmitframe_addmic(padapter, pxmitframe) == _FAIL\n");
    } else {

    }
#line 1228
    if (GlobalDebugLevel23A > 3U) {
#line 1228
      printk("\016RTL8723AU: xmitframe_addmic(padapter, pxmitframe) == _FAIL\n");
    } else {

    }
#line 1229
    res = 0;
#line 1230
    goto exit;
  } else {

  }
#line 1233
  xmitframe_swencrypt(padapter, pxmitframe);
#line 1235
  if (bmcst == 0) {
#line 1236
    update_attrib_vcs_info(padapter, pxmitframe);
  } else {
#line 1238
    pattrib->vcs_mode = 0U;
  }
  exit: ;
#line 1241
  return (res);
}
}
#line 1244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
void rtw_update_protection23a(struct rtw_adapter *padapter , u8 *ie , uint ie_len ) 
{ 
  struct xmit_priv *pxmitpriv ;
  struct registry_priv *pregistrypriv ;
  uint protection ;
  u8 const   *p ;

  {
#line 1246
  pxmitpriv = & padapter->xmitpriv;
#line 1247
  pregistrypriv = & padapter->registrypriv;
#line 1251
  switch ((int )pregistrypriv->vrtl_carrier_sense) {
  case 0: 
#line 1253
  pxmitpriv->vcs = 0U;
#line 1254
  goto ldv_53627;
  case 1: ;
#line 1256
  goto ldv_53627;
  case 2: ;
  default: 
#line 1259
  p = cfg80211_find_ie(42, (u8 const   *)ie, (int )ie_len);
#line 1260
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
#line 1261
    pxmitpriv->vcs = 0U;
  } else {
#line 1263
    protection = (uint )*(p + 2UL) & 2U;
#line 1264
    if (protection != 0U) {
#line 1265
      if ((unsigned int )pregistrypriv->vcs_type == 1U) {
#line 1266
        pxmitpriv->vcs = 1U;
      } else {
#line 1268
        pxmitpriv->vcs = 2U;
      }
    } else {
#line 1270
      pxmitpriv->vcs = 0U;
    }
  }
#line 1273
  goto ldv_53627;
  }
  ldv_53627: ;
#line 1276
  return;
}
}
#line 1277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
void rtw_count_tx_stats23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ,
                           int sz ) 
{ 
  struct sta_info *psta ;
  struct stainfo_stats *pstats ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;

  {
#line 1279
  psta = (struct sta_info *)0;
#line 1280
  pstats = (struct stainfo_stats *)0;
#line 1281
  pxmitpriv = & padapter->xmitpriv;
#line 1282
  pmlmepriv = & padapter->mlmepriv;
#line 1284
  if (pxmitframe->frame_tag == 1) {
#line 1285
    pxmitpriv->tx_bytes = pxmitpriv->tx_bytes + (u64 )sz;
#line 1286
    pmlmepriv->LinkDetectInfo.NumTxOkInPeriod = pmlmepriv->LinkDetectInfo.NumTxOkInPeriod + 1U;
#line 1288
    psta = pxmitframe->attrib.psta;
#line 1289
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1290
      pstats = & psta->sta_stats;
#line 1291
      pstats->tx_pkts = pstats->tx_pkts + 1ULL;
#line 1292
      pstats->tx_bytes = pstats->tx_bytes + (u64 )sz;
    } else {

    }
  } else {

  }
#line 1295
  return;
}
}
#line 1297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
struct xmit_buf *rtw_alloc_xmitbuf23a_ext(struct xmit_priv *pxmitpriv ) 
{ 
  unsigned long irqL ;
  struct xmit_buf *pxmitbuf ;
  struct list_head *phead ;
  struct rtw_queue *pfree_queue ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
#line 1300
  pxmitbuf = (struct xmit_buf *)0;
#line 1302
  pfree_queue = & pxmitpriv->free_xmit_extbuf_queue;
#line 1304
  tmp = spinlock_check(& pfree_queue->lock);
#line 1304
  irqL = _raw_spin_lock_irqsave(tmp);
#line 1306
  phead = get_list_head(pfree_queue);
#line 1308
  tmp___0 = list_empty((struct list_head  const  *)phead);
#line 1308
  if (tmp___0 == 0) {
#line 1309
    __mptr = (struct list_head  const  *)phead->next;
#line 1309
    pxmitbuf = (struct xmit_buf *)__mptr;
#line 1311
    list_del_init(& pxmitbuf->list);
#line 1313
    pxmitpriv->free_xmit_extbuf_cnt = pxmitpriv->free_xmit_extbuf_cnt - 1U;
#line 1314
    pxmitbuf->priv_data = (void *)0;
#line 1315
    pxmitbuf->ext_tag = 1U;
#line 1317
    if ((unsigned long )pxmitbuf->sctx != (unsigned long )((struct submit_ctx *)0)) {
#line 1318
      if (GlobalDebugLevel23A > 3U) {
#line 1318
        printk("\016RTL8723AU: %s pxmitbuf->sctx is not NULL\n", "rtw_alloc_xmitbuf23a_ext");
      } else {

      }
#line 1319
      rtw23a_sctx_done_err(& pxmitbuf->sctx, 3);
    } else {

    }
  } else {

  }
#line 1323
  spin_unlock_irqrestore(& pfree_queue->lock, irqL);
#line 1325
  return (pxmitbuf);
}
}
#line 1328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
s32 rtw_free_xmitbuf_ext23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf ) 
{ 
  unsigned long irqL ;
  struct rtw_queue *pfree_queue ;
  raw_spinlock_t *tmp ;
  struct list_head *tmp___0 ;

  {
#line 1332
  pfree_queue = & pxmitpriv->free_xmit_extbuf_queue;
#line 1334
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 1335
    return (0);
  } else {

  }
#line 1337
  tmp = spinlock_check(& pfree_queue->lock);
#line 1337
  irqL = _raw_spin_lock_irqsave(tmp);
#line 1339
  list_del_init(& pxmitbuf->list);
#line 1341
  tmp___0 = get_list_head(pfree_queue);
#line 1341
  list_add_tail(& pxmitbuf->list, tmp___0);
#line 1342
  pxmitpriv->free_xmit_extbuf_cnt = pxmitpriv->free_xmit_extbuf_cnt + 1U;
#line 1344
  spin_unlock_irqrestore(& pfree_queue->lock, irqL);
#line 1346
  return (1);
}
}
#line 1349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
struct xmit_buf *rtw_alloc_xmitbuf23a(struct xmit_priv *pxmitpriv ) 
{ 
  unsigned long irqL ;
  struct xmit_buf *pxmitbuf ;
  struct list_head *phead ;
  struct rtw_queue *pfree_xmitbuf_queue ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
#line 1352
  pxmitbuf = (struct xmit_buf *)0;
#line 1354
  pfree_xmitbuf_queue = & pxmitpriv->free_xmitbuf_queue;
#line 1358
  tmp = spinlock_check(& pfree_xmitbuf_queue->lock);
#line 1358
  irqL = _raw_spin_lock_irqsave(tmp);
#line 1360
  phead = get_list_head(pfree_xmitbuf_queue);
#line 1362
  tmp___0 = list_empty((struct list_head  const  *)phead);
#line 1362
  if (tmp___0 == 0) {
#line 1363
    __mptr = (struct list_head  const  *)phead->next;
#line 1363
    pxmitbuf = (struct xmit_buf *)__mptr;
#line 1365
    list_del_init(& pxmitbuf->list);
#line 1367
    pxmitpriv->free_xmitbuf_cnt = pxmitpriv->free_xmitbuf_cnt - 1U;
#line 1368
    pxmitbuf->priv_data = (void *)0;
#line 1369
    pxmitbuf->ext_tag = 0U;
#line 1370
    pxmitbuf->flags = 0U;
#line 1372
    if ((unsigned long )pxmitbuf->sctx != (unsigned long )((struct submit_ctx *)0)) {
#line 1373
      if (GlobalDebugLevel23A > 3U) {
#line 1373
        printk("\016RTL8723AU: %s pxmitbuf->sctx is not NULL\n", "rtw_alloc_xmitbuf23a");
      } else {

      }
#line 1374
      rtw23a_sctx_done_err(& pxmitbuf->sctx, 3);
    } else {

    }
  } else {

  }
#line 1378
  spin_unlock_irqrestore(& pfree_xmitbuf_queue->lock, irqL);
#line 1380
  return (pxmitbuf);
}
}
#line 1383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
s32 rtw_free_xmitbuf23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf ) 
{ 
  unsigned long irqL ;
  struct rtw_queue *pfree_xmitbuf_queue ;
  raw_spinlock_t *tmp ;
  struct list_head *tmp___0 ;

  {
#line 1386
  pfree_xmitbuf_queue = & pxmitpriv->free_xmitbuf_queue;
#line 1390
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 1391
    return (0);
  } else {

  }
#line 1393
  if ((unsigned long )pxmitbuf->sctx != (unsigned long )((struct submit_ctx *)0)) {
#line 1394
    if (GlobalDebugLevel23A > 3U) {
#line 1394
      printk("\016RTL8723AU: %s pxmitbuf->sctx is not NULL\n", "rtw_free_xmitbuf23a");
    } else {

    }
#line 1395
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 4);
  } else {

  }
#line 1398
  if ((unsigned int )pxmitbuf->ext_tag != 0U) {
#line 1399
    rtw_free_xmitbuf_ext23a(pxmitpriv, pxmitbuf);
  } else {
#line 1401
    tmp = spinlock_check(& pfree_xmitbuf_queue->lock);
#line 1401
    irqL = _raw_spin_lock_irqsave(tmp);
#line 1403
    list_del_init(& pxmitbuf->list);
#line 1405
    tmp___0 = get_list_head(pfree_xmitbuf_queue);
#line 1405
    list_add_tail(& pxmitbuf->list, tmp___0);
#line 1408
    pxmitpriv->free_xmitbuf_cnt = pxmitpriv->free_xmitbuf_cnt + 1U;
#line 1409
    spin_unlock_irqrestore(& pfree_xmitbuf_queue->lock, irqL);
  }
#line 1412
  return (1);
}
}
#line 1415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
static void rtw_init_xmitframe(struct xmit_frame *pxframe ) 
{ 


  {
#line 1417
  if ((unsigned long )pxframe != (unsigned long )((struct xmit_frame *)0)) {
#line 1419
    pxframe->buf_addr = (u8 *)0U;
#line 1420
    pxframe->pxmitbuf = (struct xmit_buf *)0;
#line 1422
    memset((void *)(& pxframe->attrib), 0, 112UL);
#line 1425
    pxframe->frame_tag = 1;
#line 1427
    pxframe->pkt = (struct sk_buff *)0;
#line 1428
    pxframe->pkt_offset = 1;
#line 1430
    pxframe->ack_report = 0U;
  } else {

  }
#line 1432
  return;
}
}
#line 1445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
static struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv ) 
{ 
  struct xmit_frame *pxframe ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_queue *pfree_xmit_queue ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 1447
  pxframe = (struct xmit_frame *)0;
#line 1449
  pfree_xmit_queue = & pxmitpriv->free_xmit_queue;
#line 1451
  spin_lock_bh(& pfree_xmit_queue->lock);
#line 1453
  tmp = list_empty((struct list_head  const  *)(& pfree_xmit_queue->queue));
#line 1453
  if (tmp != 0) {
#line 1454
    if (GlobalDebugLevel23A > 6U) {
#line 1454
      rt_trace(1, 7, "rtw_alloc_xmitframe:%d\n", pxmitpriv->free_xmitframe_cnt);
    } else {

    }
#line 1457
    pxframe = (struct xmit_frame *)0;
  } else {
#line 1459
    phead = get_list_head(pfree_xmit_queue);
#line 1461
    plist = phead->next;
#line 1463
    __mptr = (struct list_head  const  *)plist;
#line 1463
    pxframe = (struct xmit_frame *)__mptr;
#line 1465
    list_del_init(& pxframe->list);
#line 1466
    pxmitpriv->free_xmitframe_cnt = pxmitpriv->free_xmitframe_cnt - 1;
#line 1467
    if (GlobalDebugLevel23A > 6U) {
#line 1467
      rt_trace(1, 7, "rtw_alloc_xmitframe():free_xmitframe_cnt =%d\n", pxmitpriv->free_xmitframe_cnt);
    } else {

    }
  }
#line 1472
  spin_unlock_bh(& pfree_xmit_queue->lock);
#line 1474
  rtw_init_xmitframe(pxframe);
#line 1476
  return (pxframe);
}
}
#line 1479 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
struct xmit_frame *rtw_alloc_xmitframe23a_ext(struct xmit_priv *pxmitpriv ) 
{ 
  struct xmit_frame *pxframe ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_queue *queue ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 1481
  pxframe = (struct xmit_frame *)0;
#line 1483
  queue = & pxmitpriv->free_xframe_ext_queue;
#line 1485
  spin_lock_bh(& queue->lock);
#line 1487
  tmp = list_empty((struct list_head  const  *)(& queue->queue));
#line 1487
  if (tmp != 0) {
#line 1488
    if (GlobalDebugLevel23A > 6U) {
#line 1488
      rt_trace(1, 7, "rtw_alloc_xmitframe23a_ext:%d\n", pxmitpriv->free_xframe_ext_cnt);
    } else {

    }
#line 1491
    pxframe = (struct xmit_frame *)0;
  } else {
#line 1493
    phead = get_list_head(queue);
#line 1494
    plist = phead->next;
#line 1495
    __mptr = (struct list_head  const  *)plist;
#line 1495
    pxframe = (struct xmit_frame *)__mptr;
#line 1497
    list_del_init(& pxframe->list);
#line 1498
    pxmitpriv->free_xframe_ext_cnt = pxmitpriv->free_xframe_ext_cnt - 1;
#line 1499
    if (GlobalDebugLevel23A > 6U) {
#line 1499
      rt_trace(1, 7, "rtw_alloc_xmitframe23a_ext():free_xmitframe_cnt =%d\n", pxmitpriv->free_xframe_ext_cnt);
    } else {

    }
  }
#line 1504
  spin_unlock_bh(& queue->lock);
#line 1506
  rtw_init_xmitframe(pxframe);
#line 1508
  return (pxframe);
}
}
#line 1511 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
s32 rtw_free_xmitframe23a(struct xmit_priv *pxmitpriv , struct xmit_frame *pxmitframe ) 
{ 
  struct rtw_queue *queue ;
  struct rtw_adapter *padapter ;
  struct sk_buff *pndis_pkt ;
  struct list_head *tmp ;

  {
#line 1513
  queue = (struct rtw_queue *)0;
#line 1514
  padapter = pxmitpriv->adapter;
#line 1515
  pndis_pkt = (struct sk_buff *)0;
#line 1517
  if ((unsigned long )pxmitframe == (unsigned long )((struct xmit_frame *)0)) {
#line 1518
    if (GlobalDebugLevel23A > 3U) {
#line 1518
      rt_trace(1, 4, "====== rtw_free_xmitframe23a():pxmitframe == NULL!!!!!!!!!!\n");
    } else {

    }
#line 1520
    goto exit;
  } else {

  }
#line 1523
  if ((unsigned long )pxmitframe->pkt != (unsigned long )((struct sk_buff *)0)) {
#line 1524
    pndis_pkt = pxmitframe->pkt;
#line 1525
    pxmitframe->pkt = (struct sk_buff *)0;
  } else {

  }
#line 1528
  if ((unsigned int )pxmitframe->ext_tag == 0U) {
#line 1529
    queue = & pxmitpriv->free_xmit_queue;
  } else
#line 1530
  if ((unsigned int )pxmitframe->ext_tag == 1U) {
#line 1531
    queue = & pxmitpriv->free_xframe_ext_queue;
  } else {

  }
#line 1533
  if ((unsigned long )queue == (unsigned long )((struct rtw_queue *)0)) {
#line 1534
    goto check_pkt_complete;
  } else {

  }
#line 1535
  spin_lock_bh(& queue->lock);
#line 1537
  list_del_init(& pxmitframe->list);
#line 1538
  tmp = get_list_head(queue);
#line 1538
  list_add_tail(& pxmitframe->list, tmp);
#line 1539
  if ((unsigned int )pxmitframe->ext_tag == 0U) {
#line 1540
    pxmitpriv->free_xmitframe_cnt = pxmitpriv->free_xmitframe_cnt + 1;
#line 1541
    if (GlobalDebugLevel23A > 7U) {
#line 1541
      rt_trace(1, 8, "rtw_free_xmitframe23a():free_xmitframe_cnt =%d\n", pxmitpriv->free_xmitframe_cnt);
    } else {

    }
  } else
#line 1544
  if ((unsigned int )pxmitframe->ext_tag == 1U) {
#line 1545
    pxmitpriv->free_xframe_ext_cnt = pxmitpriv->free_xframe_ext_cnt + 1;
#line 1546
    if (GlobalDebugLevel23A > 7U) {
#line 1546
      rt_trace(1, 8, "rtw_free_xmitframe23a():free_xframe_ext_cnt =%d\n", pxmitpriv->free_xframe_ext_cnt);
    } else {

    }
  } else {

  }
#line 1551
  spin_unlock_bh(& queue->lock);
  check_pkt_complete: ;
#line 1555
  if ((unsigned long )pndis_pkt != (unsigned long )((struct sk_buff *)0)) {
#line 1556
    rtw_os_pkt_complete23a(padapter, pndis_pkt);
  } else {

  }
  exit: ;
#line 1560
  return (1);
}
}
#line 1563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
void rtw_free_xmitframe_queue23a(struct xmit_priv *pxmitpriv , struct rtw_queue *pframequeue ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct list_head  const  *__mptr ;

  {
#line 1569
  spin_lock_bh(& pframequeue->lock);
#line 1571
  phead = get_list_head(pframequeue);
#line 1573
  plist = phead->next;
#line 1573
  ptmp = plist->next;
#line 1573
  goto ldv_53726;
  ldv_53725: 
#line 1574
  __mptr = (struct list_head  const  *)plist;
#line 1574
  pxmitframe = (struct xmit_frame *)__mptr;
#line 1576
  rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
#line 1573
  plist = ptmp;
#line 1573
  ptmp = plist->next;
  ldv_53726: ;
#line 1573
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1575
    goto ldv_53725;
  } else {

  }
#line 1578
  spin_unlock_bh(& pframequeue->lock);
#line 1579
  return;
}
}
#line 1582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
s32 rtw_xmitframe_enqueue23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  s32 tmp ;

  {
#line 1585
  tmp = rtw_xmit23a_classifier(padapter, pxmitframe);
#line 1585
  if (tmp == 0) {
#line 1586
    if (GlobalDebugLevel23A > 3U) {
#line 1586
      rt_trace(1, 4, "rtw_xmitframe_enqueue23a: drop xmit pkt for classifier fail\n");
    } else {

    }
#line 1588
    return (0);
  } else {

  }
#line 1591
  return (1);
}
}
#line 1595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
static struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv , struct hw_xmit *phwxmit ,
                                                struct tx_servq *ptxservq , struct rtw_queue *pframe_queue ) 
{ 
  struct list_head *phead ;
  struct xmit_frame *pxmitframe ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 1599
  pxmitframe = (struct xmit_frame *)0;
#line 1601
  phead = get_list_head(pframe_queue);
#line 1603
  tmp = list_empty((struct list_head  const  *)phead);
#line 1603
  if (tmp == 0) {
#line 1604
    __mptr = (struct list_head  const  *)phead->next;
#line 1604
    pxmitframe = (struct xmit_frame *)__mptr;
#line 1605
    list_del_init(& pxmitframe->list);
#line 1606
    ptxservq->qcnt = ptxservq->qcnt - 1;
  } else {

  }
#line 1608
  return (pxmitframe);
}
}
#line 1612 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
struct xmit_frame *rtw_dequeue_xframe23a(struct xmit_priv *pxmitpriv , struct hw_xmit *phwxmit_i ,
                                         int entry ) 
{ 
  struct list_head *sta_plist ;
  struct list_head *sta_phead ;
  struct list_head *ptmp ;
  struct hw_xmit *phwxmit ;
  struct tx_servq *ptxservq ;
  struct rtw_queue *pframe_queue ;
  struct xmit_frame *pxmitframe ;
  struct rtw_adapter *padapter ;
  struct registry_priv *pregpriv ;
  int i ;
  int inx[4U] ;
  int j ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 1617
  ptxservq = (struct tx_servq *)0;
#line 1618
  pframe_queue = (struct rtw_queue *)0;
#line 1619
  pxmitframe = (struct xmit_frame *)0;
#line 1620
  padapter = pxmitpriv->adapter;
#line 1621
  pregpriv = & padapter->registrypriv;
#line 1624
  inx[0] = 0;
#line 1625
  inx[1] = 1;
#line 1626
  inx[2] = 2;
#line 1627
  inx[3] = 3;
#line 1628
  if ((unsigned int )pregpriv->wifi_spec == 1U) {
#line 1631
    j = 0;
#line 1631
    goto ldv_53760;
    ldv_53759: 
#line 1632
    inx[j] = (int )pxmitpriv->wmm_para_seq[j];
#line 1631
    j = j + 1;
    ldv_53760: ;
#line 1631
    if (j <= 3) {
#line 1633
      goto ldv_53759;
    } else {

    }

  } else {

  }
#line 1635
  spin_lock_bh(& pxmitpriv->lock);
#line 1637
  i = 0;
#line 1637
  goto ldv_53769;
  ldv_53768: 
#line 1638
  phwxmit = phwxmit_i + (unsigned long )inx[i];
#line 1640
  sta_phead = get_list_head(phwxmit->sta_queue);
#line 1642
  sta_plist = sta_phead->next;
#line 1642
  ptmp = sta_plist->next;
#line 1642
  goto ldv_53766;
  ldv_53765: 
#line 1643
  __mptr = (struct list_head  const  *)sta_plist;
#line 1643
  ptxservq = (struct tx_servq *)__mptr;
#line 1646
  pframe_queue = & ptxservq->sta_pending;
#line 1648
  pxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);
#line 1650
  if ((unsigned long )pxmitframe != (unsigned long )((struct xmit_frame *)0)) {
#line 1651
    phwxmit->accnt = phwxmit->accnt - 1;
#line 1656
    tmp = list_empty((struct list_head  const  *)(& pframe_queue->queue));
#line 1656
    if (tmp != 0) {
#line 1657
      list_del_init(& ptxservq->tx_pending);
    } else {

    }
#line 1658
    goto exit;
  } else {

  }
#line 1642
  sta_plist = ptmp;
#line 1642
  ptmp = sta_plist->next;
  ldv_53766: ;
#line 1642
  if ((unsigned long )sta_plist != (unsigned long )sta_phead) {
#line 1644
    goto ldv_53765;
  } else {

  }
#line 1637
  i = i + 1;
  ldv_53769: ;
#line 1637
  if (i < entry) {
#line 1639
    goto ldv_53768;
  } else {

  }

  exit: 
#line 1663
  spin_unlock_bh(& pxmitpriv->lock);
#line 1664
  return (pxmitframe);
}
}
#line 1667 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
struct tx_servq *rtw_get_sta_pending23a(struct rtw_adapter *padapter , struct sta_info *psta ,
                                        int up___0 , u8 *ac ) 
{ 
  struct tx_servq *ptxservq ;

  {
#line 1669
  ptxservq = (struct tx_servq *)0;
#line 1671
  switch (up___0) {
  case 1: ;
  case 2: 
#line 1674
  ptxservq = & psta->sta_xmitpriv.bk_q;
#line 1675
  *ac = 3U;
#line 1676
  if (GlobalDebugLevel23A > 6U) {
#line 1676
    rt_trace(1, 7, "rtw_get_sta_pending23a : BK\n");
  } else {

  }
#line 1678
  goto ldv_53780;
  case 4: ;
  case 5: 
#line 1681
  ptxservq = & psta->sta_xmitpriv.vi_q;
#line 1682
  *ac = 1U;
#line 1683
  if (GlobalDebugLevel23A > 6U) {
#line 1683
    rt_trace(1, 7, "rtw_get_sta_pending23a : VI\n");
  } else {

  }
#line 1685
  goto ldv_53780;
  case 6: ;
  case 7: 
#line 1688
  ptxservq = & psta->sta_xmitpriv.vo_q;
#line 1689
  *ac = 0U;
#line 1690
  if (GlobalDebugLevel23A > 6U) {
#line 1690
    rt_trace(1, 7, "rtw_get_sta_pending23a : VO\n");
  } else {

  }
#line 1692
  goto ldv_53780;
  case 0: ;
  case 3: ;
  default: 
#line 1696
  ptxservq = & psta->sta_xmitpriv.be_q;
#line 1697
  *ac = 2U;
#line 1698
  if (GlobalDebugLevel23A > 6U) {
#line 1698
    rt_trace(1, 7, "rtw_get_sta_pending23a : BE\n");
  } else {

  }
#line 1700
  goto ldv_53780;
  }
  ldv_53780: ;
#line 1702
  return (ptxservq);
}
}
#line 1709 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
s32 rtw_xmit23a_classifier(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  struct sta_info *psta ;
  struct tx_servq *ptxservq ;
  struct pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct hw_xmit *phwxmits ;
  u8 ac_index ;
  int res ;
  struct list_head *tmp ;
  int tmp___0 ;
  struct list_head *tmp___1 ;

  {
#line 1714
  pattrib = & pxmitframe->attrib;
#line 1715
  pstapriv = & padapter->stapriv;
#line 1716
  phwxmits = padapter->xmitpriv.hwxmits;
#line 1718
  res = 1;
#line 1720
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 1721
    psta = pattrib->psta;
  } else {
#line 1723
    if (GlobalDebugLevel23A > 3U) {
#line 1723
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_xmit23a_classifier");
    } else {

    }
#line 1724
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->ra));
  }
#line 1726
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1727
    res = 0;
#line 1728
    if (GlobalDebugLevel23A > 3U) {
#line 1728
      printk("\016RTL8723AU: rtw_xmit23a_classifier: psta == NULL\n");
    } else {

    }
#line 1729
    if (GlobalDebugLevel23A > 3U) {
#line 1729
      rt_trace(1, 4, "rtw_xmit23a_classifier: psta == NULL\n");
    } else {

    }
#line 1731
    goto exit;
  } else {

  }
#line 1733
  if ((psta->state & 1U) == 0U) {
#line 1734
    if (GlobalDebugLevel23A > 3U) {
#line 1734
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_xmit23a_classifier",
             psta->state);
    } else {

    }
#line 1736
    return (0);
  } else {

  }
#line 1738
  ptxservq = rtw_get_sta_pending23a(padapter, psta, (int )pattrib->priority, & ac_index);
#line 1741
  tmp___0 = list_empty((struct list_head  const  *)(& ptxservq->tx_pending));
#line 1741
  if (tmp___0 != 0) {
#line 1742
    tmp = get_list_head((phwxmits + (unsigned long )ac_index)->sta_queue);
#line 1742
    list_add_tail(& ptxservq->tx_pending, tmp);
  } else {

  }
#line 1746
  tmp___1 = get_list_head(& ptxservq->sta_pending);
#line 1746
  list_add_tail(& pxmitframe->list, tmp___1);
#line 1747
  ptxservq->qcnt = ptxservq->qcnt + 1;
#line 1748
  (phwxmits + (unsigned long )ac_index)->accnt = (phwxmits + (unsigned long )ac_index)->accnt + 1;
  exit: ;
#line 1750
  return (res);
}
}
#line 1753 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
void rtw_alloc_hwxmits23a(struct rtw_adapter *padapter ) 
{ 
  struct hw_xmit *hwxmits ;
  struct xmit_priv *pxmitpriv ;
  int size ;
  void *tmp ;

  {
#line 1756
  pxmitpriv = & padapter->xmitpriv;
#line 1759
  pxmitpriv->hwxmit_entry = 4U;
#line 1761
  size = ((int )pxmitpriv->hwxmit_entry + 1) * 16;
#line 1762
  tmp = kzalloc((size_t )size, 208U);
#line 1762
  pxmitpriv->hwxmits = (struct hw_xmit *)tmp;
#line 1764
  hwxmits = pxmitpriv->hwxmits;
#line 1766
  if ((unsigned int )pxmitpriv->hwxmit_entry == 5U) {
#line 1769
    hwxmits->sta_queue = & pxmitpriv->bm_pending;
#line 1773
    (hwxmits + 1UL)->sta_queue = & pxmitpriv->vo_pending;
#line 1777
    (hwxmits + 2UL)->sta_queue = & pxmitpriv->vi_pending;
#line 1781
    (hwxmits + 3UL)->sta_queue = & pxmitpriv->bk_pending;
#line 1785
    (hwxmits + 4UL)->sta_queue = & pxmitpriv->be_pending;
  } else
#line 1787
  if ((unsigned int )pxmitpriv->hwxmit_entry == 4U) {
#line 1791
    hwxmits->sta_queue = & pxmitpriv->vo_pending;
#line 1795
    (hwxmits + 1UL)->sta_queue = & pxmitpriv->vi_pending;
#line 1799
    (hwxmits + 2UL)->sta_queue = & pxmitpriv->be_pending;
#line 1803
    (hwxmits + 3UL)->sta_queue = & pxmitpriv->bk_pending;
  } else {

  }
#line 1808
  return;
}
}
#line 1809 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
void rtw_free_hwxmits23a(struct rtw_adapter *padapter ) 
{ 
  struct hw_xmit *hwxmits ;
  struct xmit_priv *pxmitpriv ;

  {
#line 1812
  pxmitpriv = & padapter->xmitpriv;
#line 1814
  hwxmits = pxmitpriv->hwxmits;
#line 1815
  kfree((void const   *)hwxmits);
#line 1816
  return;
}
}
#line 1818 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
void rtw_init_hwxmits23a(struct hw_xmit *phwxmit , int entry ) 
{ 
  int i ;

  {
#line 1822
  i = 0;
#line 1822
  goto ldv_53818;
  ldv_53817: 
#line 1823
  phwxmit->accnt = 0;
#line 1822
  i = i + 1;
#line 1822
  phwxmit = phwxmit + 1;
  ldv_53818: ;
#line 1822
  if (i < entry) {
#line 1824
    goto ldv_53817;
  } else {

  }

#line 1829
  return;
}
}
#line 1826 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
u32 rtw_get_ff_hwaddr23a(struct xmit_frame *pxmitframe ) 
{ 
  u32 addr ;
  struct pkt_attrib *pattrib ;

  {
#line 1829
  pattrib = & pxmitframe->attrib;
#line 1831
  switch ((int )pattrib->qsel) {
  case 0: ;
  case 3: 
#line 1834
  addr = 2U;
#line 1835
  goto ldv_53827;
  case 1: ;
  case 2: 
#line 1838
  addr = 3U;
#line 1839
  goto ldv_53827;
  case 4: ;
  case 5: 
#line 1842
  addr = 1U;
#line 1843
  goto ldv_53827;
  case 6: ;
  case 7: 
#line 1846
  addr = 0U;
#line 1847
  goto ldv_53827;
  case 16: 
#line 1849
  addr = 4U;
#line 1850
  goto ldv_53827;
  case 17: 
#line 1852
  addr = 6U;
#line 1853
  goto ldv_53827;
  case 18: ;
  default: 
#line 1856
  addr = 5U;
#line 1857
  goto ldv_53827;
  }
  ldv_53827: ;
#line 1860
  return (addr);
}
}
#line 1871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
int rtw_xmit23a(struct rtw_adapter *padapter , struct sk_buff *skb ) 
{ 
  struct xmit_priv *pxmitpriv ;
  struct xmit_frame *pxmitframe ;
  int res ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 1873
  pxmitpriv = & padapter->xmitpriv;
#line 1874
  pxmitframe = (struct xmit_frame *)0;
#line 1877
  pxmitframe = rtw_alloc_xmitframe(pxmitpriv);
#line 1879
  if ((unsigned long )pxmitframe == (unsigned long )((struct xmit_frame *)0)) {
#line 1880
    if (GlobalDebugLevel23A > 3U) {
#line 1880
      rt_trace(2, 4, "rtw_xmit23a: no more pxmitframe\n");
    } else {

    }
#line 1882
    return (-1);
  } else {

  }
#line 1885
  res = update_attrib(padapter, skb, & pxmitframe->attrib);
#line 1887
  if (res == 0) {
#line 1888
    if (GlobalDebugLevel23A > 3U) {
#line 1888
      rt_trace(2, 4, "rtw_xmit23a: update attrib fail\n");
    } else {

    }
#line 1890
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
#line 1891
    return (-1);
  } else {

  }
#line 1893
  pxmitframe->pkt = skb;
#line 1895
  pxmitframe->attrib.qsel = pxmitframe->attrib.priority;
#line 1898
  spin_lock_bh(& pxmitpriv->lock);
#line 1899
  tmp = xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe);
#line 1899
  if (tmp != 0) {
#line 1900
    spin_unlock_bh(& pxmitpriv->lock);
#line 1901
    return (1);
  } else {

  }
#line 1903
  spin_unlock_bh(& pxmitpriv->lock);
#line 1906
  tmp___0 = rtl8723au_hal_xmit(padapter, pxmitframe);
#line 1906
  if (tmp___0) {
#line 1906
    tmp___1 = 0;
  } else {
#line 1906
    tmp___1 = 1;
  }
#line 1906
  if (tmp___1) {
#line 1907
    return (1);
  } else {

  }
#line 1909
  return (0);
}
}
#line 1914 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
int xmitframe_enqueue_for_sleeping_sta23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int ret ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct pkt_attrib *pattrib ;
  struct mlme_priv *pmlmepriv ;
  int bmcst ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  struct list_head *tmp___2 ;
  u8 wmmps_ac ;
  struct list_head *tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;

  {
#line 1916
  ret = 0;
#line 1917
  psta = (struct sta_info *)0;
#line 1918
  pstapriv = & padapter->stapriv;
#line 1919
  pattrib = & pxmitframe->attrib;
#line 1920
  pmlmepriv = & padapter->mlmepriv;
#line 1921
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 1921
  bmcst = (int )tmp;
#line 1923
  tmp___0 = check_fwstate(pmlmepriv, 16);
#line 1923
  if (tmp___0) {
#line 1923
    tmp___1 = 0;
  } else {
#line 1923
    tmp___1 = 1;
  }
#line 1923
  if (tmp___1) {
#line 1924
    return (ret);
  } else {

  }
#line 1926
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 1927
    psta = pattrib->psta;
  } else {
#line 1929
    if (GlobalDebugLevel23A > 3U) {
#line 1929
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "xmitframe_enqueue_for_sleeping_sta23a");
    } else {

    }
#line 1930
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->ra));
  }
#line 1933
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1934
    if (GlobalDebugLevel23A > 3U) {
#line 1934
      printk("\016RTL8723AU: %s, psta == NUL\n", "xmitframe_enqueue_for_sleeping_sta23a");
    } else {

    }
#line 1935
    return (0);
  } else {

  }
#line 1938
  if ((psta->state & 1U) == 0U) {
#line 1939
    if (GlobalDebugLevel23A > 3U) {
#line 1939
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "xmitframe_enqueue_for_sleeping_sta23a",
             psta->state);
    } else {

    }
#line 1941
    return (0);
  } else {

  }
#line 1944
  if ((unsigned int )pattrib->triggered == 1U) {
#line 1945
    if (bmcst != 0) {
#line 1946
      pattrib->qsel = 17U;
    } else {

    }
#line 1947
    return (ret);
  } else {

  }
#line 1950
  if (bmcst != 0) {
#line 1951
    spin_lock_bh(& psta->sleep_q.lock);
#line 1953
    if ((unsigned int )pstapriv->sta_dz_bitmap != 0U) {
#line 1955
      list_del_init(& pxmitframe->list);
#line 1959
      tmp___2 = get_list_head(& psta->sleep_q);
#line 1959
      list_add_tail(& pxmitframe->list, tmp___2);
#line 1961
      psta->sleepq_len = psta->sleepq_len + 1U;
#line 1963
      pstapriv->tim_bitmap = (u16 )((unsigned int )pstapriv->tim_bitmap | 1U);
#line 1964
      pstapriv->sta_dz_bitmap = (u16 )((unsigned int )pstapriv->sta_dz_bitmap | 1U);
#line 1969
      update_beacon23a(padapter, 5, (u8 *)0U, 0);
#line 1973
      ret = 1;
    } else {

    }
#line 1977
    spin_unlock_bh(& psta->sleep_q.lock);
#line 1979
    return (ret);
  } else {

  }
#line 1983
  spin_lock_bh(& psta->sleep_q.lock);
#line 1985
  if ((psta->state & 4U) != 0U) {
#line 1986
    wmmps_ac = 0U;
#line 1988
    tmp___5 = CHKBIT(psta->aid);
#line 1988
    if (((u32 )pstapriv->sta_dz_bitmap & tmp___5) != 0U) {
#line 1989
      list_del_init(& pxmitframe->list);
#line 1993
      tmp___3 = get_list_head(& psta->sleep_q);
#line 1993
      list_add_tail(& pxmitframe->list, tmp___3);
#line 1995
      psta->sleepq_len = psta->sleepq_len + 1U;
#line 1997
      switch ((int )pattrib->priority) {
      case 1: ;
      case 2: 
#line 2000
      wmmps_ac = (unsigned int )psta->uapsd_bk & 1U;
#line 2001
      goto ldv_53859;
      case 4: ;
      case 5: 
#line 2004
      wmmps_ac = (unsigned int )psta->uapsd_vi & 1U;
#line 2005
      goto ldv_53859;
      case 6: ;
      case 7: 
#line 2008
      wmmps_ac = (unsigned int )psta->uapsd_vo & 1U;
#line 2009
      goto ldv_53859;
      case 0: ;
      case 3: ;
      default: 
#line 2013
      wmmps_ac = (unsigned int )psta->uapsd_be & 1U;
#line 2014
      goto ldv_53859;
      }
      ldv_53859: ;
#line 2017
      if ((unsigned int )wmmps_ac != 0U) {
#line 2018
        psta->sleepq_ac_len = psta->sleepq_ac_len + 1U;
      } else {

      }
#line 2020
      if (((unsigned int )psta->has_legacy_ac != 0U && (unsigned int )wmmps_ac == 0U) || ((unsigned int )psta->has_legacy_ac == 0U && (unsigned int )wmmps_ac != 0U)) {
#line 2022
        tmp___4 = CHKBIT(psta->aid);
#line 2022
        pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap | (int )((u16 )tmp___4);
#line 2024
        if (psta->sleepq_len == 1U) {
#line 2026
          update_beacon23a(padapter, 5, (u8 *)0U, 0);
        } else {

        }
      } else {

      }
#line 2038
      ret = 1;
    } else {

    }
  } else {

  }
#line 2044
  spin_unlock_bh(& psta->sleep_q.lock);
#line 2046
  return (ret);
}
}
#line 2050 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
static void dequeue_xmitframes_to_sleeping_queue(struct rtw_adapter *padapter , struct sta_info *psta ,
                                                 struct rtw_queue *pframequeue ) 
{ 
  int ret ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  u8 ac_index ;
  struct tx_servq *ptxservq ;
  struct pkt_attrib *pattrib ;
  struct xmit_frame *pxmitframe ;
  struct hw_xmit *phwxmits ;
  struct list_head  const  *__mptr ;

  {
#line 2060
  phwxmits = padapter->xmitpriv.hwxmits;
#line 2062
  phead = get_list_head(pframequeue);
#line 2064
  plist = phead->next;
#line 2064
  ptmp = plist->next;
#line 2064
  goto ldv_53884;
  ldv_53883: 
#line 2065
  __mptr = (struct list_head  const  *)plist;
#line 2065
  pxmitframe = (struct xmit_frame *)__mptr;
#line 2067
  ret = xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe);
#line 2069
  if (ret == 1) {
#line 2070
    pattrib = & pxmitframe->attrib;
#line 2072
    ptxservq = rtw_get_sta_pending23a(padapter, psta, (int )pattrib->priority, & ac_index);
#line 2074
    ptxservq->qcnt = ptxservq->qcnt - 1;
#line 2075
    (phwxmits + (unsigned long )ac_index)->accnt = (phwxmits + (unsigned long )ac_index)->accnt - 1;
  } else {

  }
#line 2064
  plist = ptmp;
#line 2064
  ptmp = plist->next;
  ldv_53884: ;
#line 2064
  if ((unsigned long )plist != (unsigned long )phead) {
#line 2066
    goto ldv_53883;
  } else {

  }

#line 2071
  return;
}
}
#line 2082 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
void stop_sta_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct sta_info *psta_bmc ;
  struct sta_xmit_priv *pstaxmitpriv ;
  struct sta_priv *pstapriv ;
  struct xmit_priv *pxmitpriv ;
  u32 tmp ;

  {
#line 2086
  pstapriv = & padapter->stapriv;
#line 2087
  pxmitpriv = & padapter->xmitpriv;
#line 2089
  pstaxmitpriv = & psta->sta_xmitpriv;
#line 2092
  psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
#line 2094
  spin_lock_bh(& pxmitpriv->lock);
#line 2096
  psta->state = psta->state | 4U;
#line 2098
  tmp = CHKBIT(psta->aid);
#line 2098
  pstapriv->sta_dz_bitmap = (int )pstapriv->sta_dz_bitmap | (int )((u16 )tmp);
#line 2100
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->vo_q.sta_pending);
#line 2101
  list_del_init(& pstaxmitpriv->vo_q.tx_pending);
#line 2103
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->vi_q.sta_pending);
#line 2104
  list_del_init(& pstaxmitpriv->vi_q.tx_pending);
#line 2106
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->be_q.sta_pending);
#line 2108
  list_del_init(& pstaxmitpriv->be_q.tx_pending);
#line 2110
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->bk_q.sta_pending);
#line 2112
  list_del_init(& pstaxmitpriv->bk_q.tx_pending);
#line 2115
  pstaxmitpriv = & psta_bmc->sta_xmitpriv;
#line 2116
  dequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc, & pstaxmitpriv->be_q.sta_pending);
#line 2118
  list_del_init(& pstaxmitpriv->be_q.tx_pending);
#line 2120
  spin_unlock_bh(& pxmitpriv->lock);
#line 2121
  return;
}
}
#line 2123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
void wakeup_sta_to_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 update_mask ;
  u8 wmmps_ac ;
  struct sta_info *psta_bmc ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct sta_priv *pstapriv ;
  struct xmit_priv *pxmitpriv ;
  struct list_head  const  *__mptr ;
  u32 tmp ;
  u32 tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 2125
  update_mask = 0U;
#line 2125
  wmmps_ac = 0U;
#line 2128
  pxmitframe = (struct xmit_frame *)0;
#line 2129
  pstapriv = & padapter->stapriv;
#line 2130
  pxmitpriv = & padapter->xmitpriv;
#line 2132
  spin_lock_bh(& pxmitpriv->lock);
#line 2134
  phead = get_list_head(& psta->sleep_q);
#line 2136
  plist = phead->next;
#line 2136
  ptmp = plist->next;
#line 2136
  goto ldv_53920;
  ldv_53919: 
#line 2137
  __mptr = (struct list_head  const  *)plist;
#line 2137
  pxmitframe = (struct xmit_frame *)__mptr;
#line 2138
  list_del_init(& pxmitframe->list);
#line 2140
  switch ((int )pxmitframe->attrib.priority) {
  case 1: ;
  case 2: 
#line 2143
  wmmps_ac = (unsigned int )psta->uapsd_bk & 2U;
#line 2144
  goto ldv_53911;
  case 4: ;
  case 5: 
#line 2147
  wmmps_ac = (unsigned int )psta->uapsd_vi & 2U;
#line 2148
  goto ldv_53911;
  case 6: ;
  case 7: 
#line 2151
  wmmps_ac = (unsigned int )psta->uapsd_vo & 2U;
#line 2152
  goto ldv_53911;
  case 0: ;
  case 3: ;
  default: 
#line 2156
  wmmps_ac = (unsigned int )psta->uapsd_be & 2U;
#line 2157
  goto ldv_53911;
  }
  ldv_53911: 
#line 2160
  psta->sleepq_len = psta->sleepq_len - 1U;
#line 2161
  if (psta->sleepq_len != 0U) {
#line 2162
    pxmitframe->attrib.mdata = 1U;
  } else {
#line 2164
    pxmitframe->attrib.mdata = 0U;
  }
#line 2166
  if ((unsigned int )wmmps_ac != 0U) {
#line 2167
    psta->sleepq_ac_len = psta->sleepq_ac_len - 1U;
#line 2168
    if (psta->sleepq_ac_len != 0U) {
#line 2169
      pxmitframe->attrib.mdata = 1U;
#line 2170
      pxmitframe->attrib.eosp = 0U;
    } else {
#line 2172
      pxmitframe->attrib.mdata = 0U;
#line 2173
      pxmitframe->attrib.eosp = 1U;
    }
  } else {

  }
#line 2177
  pxmitframe->attrib.triggered = 1U;
#line 2178
  rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
#line 2136
  plist = ptmp;
#line 2136
  ptmp = plist->next;
  ldv_53920: ;
#line 2136
  if ((unsigned long )plist != (unsigned long )phead) {
#line 2138
    goto ldv_53919;
  } else {

  }

#line 2181
  if (psta->sleepq_len == 0U) {
#line 2182
    tmp = CHKBIT(psta->aid);
#line 2182
    pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp));
#line 2185
    update_mask = 1U;
#line 2187
    if ((psta->state & 4U) != 0U) {
#line 2188
      psta->state = psta->state ^ 4U;
    } else {

    }
#line 2190
    if ((psta->state & 1024U) != 0U) {
#line 2191
      psta->expire_to = pstapriv->expire_to;
#line 2192
      psta->state = psta->state ^ 1024U;
    } else {

    }
#line 2195
    tmp___0 = CHKBIT(psta->aid);
#line 2195
    pstapriv->sta_dz_bitmap = (int )pstapriv->sta_dz_bitmap & ~ ((int )((u16 )tmp___0));
  } else {

  }
#line 2199
  spin_unlock_bh(& pxmitpriv->lock);
#line 2202
  psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
#line 2203
  if ((unsigned long )psta_bmc == (unsigned long )((struct sta_info *)0)) {
#line 2204
    return;
  } else {

  }
#line 2206
  if (((int )pstapriv->sta_dz_bitmap & 65534) == 0) {
#line 2208
    spin_lock_bh(& pxmitpriv->lock);
#line 2210
    phead = get_list_head(& psta_bmc->sleep_q);
#line 2212
    plist = phead->next;
#line 2212
    ptmp = plist->next;
#line 2212
    goto ldv_53925;
    ldv_53924: 
#line 2213
    __mptr___0 = (struct list_head  const  *)plist;
#line 2213
    pxmitframe = (struct xmit_frame *)__mptr___0;
#line 2216
    list_del_init(& pxmitframe->list);
#line 2218
    psta_bmc->sleepq_len = psta_bmc->sleepq_len - 1U;
#line 2219
    if (psta_bmc->sleepq_len != 0U) {
#line 2220
      pxmitframe->attrib.mdata = 1U;
    } else {
#line 2222
      pxmitframe->attrib.mdata = 0U;
    }
#line 2224
    pxmitframe->attrib.triggered = 1U;
#line 2225
    rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
#line 2212
    plist = ptmp;
#line 2212
    ptmp = plist->next;
    ldv_53925: ;
#line 2212
    if ((unsigned long )plist != (unsigned long )phead) {
#line 2214
      goto ldv_53924;
    } else {

    }

#line 2227
    if (psta_bmc->sleepq_len == 0U) {
#line 2228
      pstapriv->tim_bitmap = (unsigned int )pstapriv->tim_bitmap & 65534U;
#line 2229
      pstapriv->sta_dz_bitmap = (unsigned int )pstapriv->sta_dz_bitmap & 65534U;
#line 2233
      update_mask = (u8 )((unsigned int )update_mask | 2U);
    } else {

    }
#line 2237
    spin_unlock_bh(& pxmitpriv->lock);
  } else {

  }
#line 2240
  if ((unsigned int )update_mask != 0U) {
#line 2241
    update_beacon23a(padapter, 5, (u8 *)0U, 0);
  } else {

  }
#line 2242
  return;
}
}
#line 2244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
void xmit_delivery_enabled_frames23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 wmmps_ac ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct sta_priv *pstapriv ;
  struct xmit_priv *pxmitpriv ;
  struct list_head  const  *__mptr ;
  u32 tmp ;

  {
#line 2247
  wmmps_ac = 0U;
#line 2250
  pstapriv = & padapter->stapriv;
#line 2251
  pxmitpriv = & padapter->xmitpriv;
#line 2254
  spin_lock_bh(& pxmitpriv->lock);
#line 2256
  phead = get_list_head(& psta->sleep_q);
#line 2258
  plist = phead->next;
#line 2258
  ptmp = plist->next;
#line 2258
  goto ldv_53952;
  ldv_53951: 
#line 2259
  __mptr = (struct list_head  const  *)plist;
#line 2259
  pxmitframe = (struct xmit_frame *)__mptr;
#line 2261
  switch ((int )pxmitframe->attrib.priority) {
  case 1: ;
  case 2: 
#line 2264
  wmmps_ac = (unsigned int )psta->uapsd_bk & 2U;
#line 2265
  goto ldv_53942;
  case 4: ;
  case 5: 
#line 2268
  wmmps_ac = (unsigned int )psta->uapsd_vi & 2U;
#line 2269
  goto ldv_53942;
  case 6: ;
  case 7: 
#line 2272
  wmmps_ac = (unsigned int )psta->uapsd_vo & 2U;
#line 2273
  goto ldv_53942;
  case 0: ;
  case 3: ;
  default: 
#line 2277
  wmmps_ac = (unsigned int )psta->uapsd_be & 2U;
#line 2278
  goto ldv_53942;
  }
  ldv_53942: ;
#line 2281
  if ((unsigned int )wmmps_ac == 0U) {
#line 2282
    goto ldv_53950;
  } else {

  }
#line 2284
  list_del_init(& pxmitframe->list);
#line 2286
  psta->sleepq_len = psta->sleepq_len - 1U;
#line 2287
  psta->sleepq_ac_len = psta->sleepq_ac_len - 1U;
#line 2289
  if (psta->sleepq_ac_len != 0U) {
#line 2290
    pxmitframe->attrib.mdata = 1U;
#line 2291
    pxmitframe->attrib.eosp = 0U;
  } else {
#line 2293
    pxmitframe->attrib.mdata = 0U;
#line 2294
    pxmitframe->attrib.eosp = 1U;
  }
#line 2297
  pxmitframe->attrib.triggered = 1U;
#line 2299
  rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
#line 2301
  if ((psta->sleepq_ac_len == 0U && (unsigned int )psta->has_legacy_ac == 0U) && (unsigned int )wmmps_ac != 0U) {
#line 2303
    tmp = CHKBIT(psta->aid);
#line 2303
    pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp));
#line 2306
    update_beacon23a(padapter, 5, (u8 *)0U, 0);
  } else {

  }
  ldv_53950: 
#line 2258
  plist = ptmp;
#line 2258
  ptmp = plist->next;
  ldv_53952: ;
#line 2258
  if ((unsigned long )plist != (unsigned long )phead) {
#line 2260
    goto ldv_53951;
  } else {

  }
#line 2309
  spin_unlock_bh(& pxmitpriv->lock);
#line 2310
  return;
}
}
#line 2314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
void rtw_sctx_init23a(struct submit_ctx *sctx , int timeout_ms ) 
{ 


  {
#line 2316
  sctx->timeout_ms = (u32 )timeout_ms;
#line 2317
  init_completion(& sctx->done);
#line 2318
  sctx->status = -1;
#line 2319
  return;
}
}
#line 2321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
int rtw_sctx_wait23a(struct submit_ctx *sctx ) 
{ 
  int ret ;
  unsigned long expire ;
  int status ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 2323
  ret = 0;
#line 2325
  status = 0;
#line 2327
  if (sctx->timeout_ms != 0U) {
#line 2327
    tmp = msecs_to_jiffies(sctx->timeout_ms);
#line 2327
    expire = tmp;
  } else {
#line 2327
    expire = 9223372036854775807UL;
  }
#line 2329
  tmp___0 = wait_for_completion_timeout(& sctx->done, expire);
#line 2329
  if (tmp___0 == 0UL) {
#line 2331
    status = 2;
#line 2332
    if (GlobalDebugLevel23A > 3U) {
#line 2332
      printk("\016RTL8723AU: %s timeout\n", "rtw_sctx_wait23a");
    } else {

    }
  } else {
#line 2334
    status = sctx->status;
  }
#line 2337
  if (status == 0) {
#line 2338
    ret = 1;
  } else {

  }
#line 2340
  return (ret);
}
}
#line 2343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
static bool rtw_sctx_chk_waring_status(int status ) 
{ 


  {
#line 2345
  switch (status) {
  case 1: ;
  case 3: ;
  case 4: ;
  case 9: ;
  case 10: ;
#line 2351
  return (1);
  default: ;
#line 2353
  return (0);
  }
}
}
#line 2357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
void rtw23a_sctx_done_err(struct submit_ctx **sctx , int status ) 
{ 
  bool tmp ;

  {
#line 2359
  if ((unsigned long )*sctx != (unsigned long )((struct submit_ctx *)0)) {
#line 2360
    tmp = rtw_sctx_chk_waring_status(status);
#line 2360
    if ((int )tmp) {
#line 2361
      if (GlobalDebugLevel23A > 3U) {
#line 2361
        printk("\016RTL8723AU: %s status:%d\n", "rtw23a_sctx_done_err", status);
      } else {

      }
    } else {

    }
#line 2362
    (*sctx)->status = status;
#line 2363
    complete(& (*sctx)->done);
#line 2364
    *sctx = (struct submit_ctx *)0;
  } else {

  }
#line 2366
  return;
}
}
#line 2368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.c"
int rtw_ack_tx_wait23a(struct xmit_priv *pxmitpriv , u32 timeout_ms ) 
{ 
  struct submit_ctx *pack_tx_ops ;
  int tmp ;

  {
#line 2370
  pack_tx_ops = & pxmitpriv->ack_tx_ops;
#line 2372
  pack_tx_ops->timeout_ms = timeout_ms;
#line 2373
  pack_tx_ops->status = -1;
#line 2375
  tmp = rtw_sctx_wait23a(pack_tx_ops);
#line 2375
  return (tmp);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
bool ldv_queue_work_on_243(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
bool ldv_queue_delayed_work_on_244(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
bool ldv_queue_work_on_245(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void ldv_flush_workqueue_246(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
bool ldv_queue_delayed_work_on_247(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_257(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_259(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_258(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_261(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_260(struct workqueue_struct *ldv_func_arg1 ) ;
#line 129 "drivers/staging/rtl8723au/include/Hal8723APhyCfg.h"
void PHY_SetBWMode23a8723A(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ,
                           unsigned char Offset ) ;
#line 136
void PHY_SwChnl8723A(struct rtw_adapter *Adapter , u8 channel ) ;
#line 102 "drivers/staging/rtl8723au/include/hal_intf.h"
void rtw_hal_update_ra_mask23a(struct sta_info *psta , u8 rssi_level ) ;
#line 140 "drivers/staging/rtl8723au/include/hal_com.h"
void rtl8723a_set_ampdu_min_space(struct rtw_adapter *padapter , u8 MinSpacingToSet ) ;
#line 141
void rtl8723a_set_ampdu_factor(struct rtw_adapter *padapter , u8 FactorToSet ) ;
#line 142
void rtl8723a_set_acm_ctrl(struct rtw_adapter *padapter , u8 ctrl ) ;
#line 150
void rtl8723a_set_slot_time(struct rtw_adapter *padapter , u8 slottime ) ;
#line 151
void rtl8723a_ack_preamble(struct rtw_adapter *padapter , u8 bShortPreamble ) ;
#line 154
void rtl8723a_cam_invalidate_all(struct rtw_adapter *padapter ) ;
#line 162
void rtl8723a_set_resp_sifs(struct rtw_adapter *padapter , u8 r2t1 , u8 r2t2 , u8 t2t1 ,
                            u8 t2t2 ) ;
#line 164
void rtl8723a_set_ac_param_vo(struct rtw_adapter *padapter , u32 vo ) ;
#line 165
void rtl8723a_set_ac_param_vi(struct rtw_adapter *padapter , u32 vi ) ;
#line 166
void rtl8723a_set_ac_param_be(struct rtw_adapter *padapter , u32 be ) ;
#line 167
void rtl8723a_set_ac_param_bk(struct rtw_adapter *padapter , u32 bk ) ;
#line 454 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
unsigned char networktype_to_raid23a(unsigned char network_type ) ;
#line 455
u8 judge_network_type23a(struct rtw_adapter *padapter , unsigned char *rate , int ratelen ) ;
#line 463
__inline void rtw_set_oper_ch23a(struct rtw_adapter *adapter , u8 ch ) ;
#line 465
__inline void rtw_set_oper_bw23a(struct rtw_adapter *adapter , u8 bw ) ;
#line 467
__inline void rtw_set_oper_ch23aoffset23a(struct rtw_adapter *adapter , u8 offset ) ;
#line 520
unsigned int update_basic_rate23a(unsigned char *ptn , unsigned int ptn_sz ) ;
#line 521
unsigned int update_supported_rate23a(unsigned char *ptn , unsigned int ptn_sz ) ;
#line 522
unsigned int update_MSC_rate23a(struct ieee80211_ht_cap *pHT_caps ) ;
#line 529
unsigned char get_highest_rate_idx23a(u32 mask ) ;
#line 533
bool is_ap_in_wep23a(struct rtw_adapter *padapter ) ;
#line 534
bool should_forbid_n_rate23a(struct rtw_adapter *padapter ) ;
#line 587
int cckrates_included23a(unsigned char *rate , int ratelen ) ;
#line 588
int cckratesonly_included23a(unsigned char *rate , int ratelen ) ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static unsigned char ARTHEROS_OUI1[3U]  = {      0U,      3U,      127U};
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static unsigned char ARTHEROS_OUI2[3U]  = {      0U,      19U,      116U};
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static unsigned char BROADCOM_OUI1[3U]  = {      0U,      16U,      24U};
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static unsigned char BROADCOM_OUI2[3U]  = {      0U,      10U,      247U};
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static unsigned char CISCO_OUI[3U]  = {      0U,      64U,      150U};
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static unsigned char MARVELL_OUI[3U]  = {      0U,      80U,      67U};
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static unsigned char RALINK_OUI[3U]  = {      0U,      12U,      67U};
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static unsigned char REALTEK_OUI[3U]  = {      0U,      224U,      76U};
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static unsigned char AIRGOCAP_OUI[3U]  = {      0U,      10U,      245U};
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static unsigned char EPIGRAM_OUI[3U]  = {      0U,      144U,      76U};
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static unsigned char WPA_TKIP_CIPHER[4U]  = {      0U,      80U,      242U,      2U};
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static unsigned char RSN_TKIP_CIPHER[4U]  = {      0U,      15U,      172U,      2U};
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static u8 rtw_basic_rate_cck[4U]  = {      130U,      132U,      139U,      150U};
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static u8 rtw_basic_rate_ofdm[3U]  = {      140U,      152U,      176U};
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static u8 rtw_basic_rate_mix[7U]  = {      130U,      132U,      139U,      150U, 
        140U,      152U,      176U};
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
int cckrates_included23a(unsigned char *rate , int ratelen ) 
{ 
  int i ;

  {
#line 72
  i = 0;
#line 72
  goto ldv_53201;
  ldv_53200: ;
#line 73
  if (((((int )*(rate + (unsigned long )i) & 127) == 2 || ((int )*(rate + (unsigned long )i) & 127) == 4) || ((int )*(rate + (unsigned long )i) & 127) == 11) || ((int )*(rate + (unsigned long )i) & 127) == 22) {
#line 75
    return (1);
  } else {

  }
#line 72
  i = i + 1;
  ldv_53201: ;
#line 72
  if (i < ratelen) {
#line 74
    goto ldv_53200;
  } else {

  }

#line 78
  return (0);
}
}
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
int cckratesonly_included23a(unsigned char *rate , int ratelen ) 
{ 
  int i ;

  {
#line 85
  i = 0;
#line 85
  goto ldv_53209;
  ldv_53208: ;
#line 86
  if (((((int )*(rate + (unsigned long )i) & 127) != 2 && ((int )*(rate + (unsigned long )i) & 127) != 4) && ((int )*(rate + (unsigned long )i) & 127) != 11) && ((int )*(rate + (unsigned long )i) & 127) != 22) {
#line 88
    return (0);
  } else {

  }
#line 85
  i = i + 1;
  ldv_53209: ;
#line 85
  if (i < ratelen) {
#line 87
    goto ldv_53208;
  } else {

  }

#line 91
  return (1);
}
}
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
unsigned char networktype_to_raid23a(unsigned char network_type ) 
{ 
  unsigned char raid ;

  {
#line 98
  switch ((int )network_type) {
  case 1: 
#line 100
  raid = 6U;
#line 101
  goto ldv_53216;
  case 4: ;
  case 2: 
#line 104
  raid = 5U;
#line 105
  goto ldv_53216;
  case 3: 
#line 107
  raid = 4U;
#line 108
  goto ldv_53216;
  case 8: ;
  case 16: 
#line 111
  raid = 3U;
#line 112
  goto ldv_53216;
  case 20: ;
  case 10: 
#line 115
  raid = 1U;
#line 116
  goto ldv_53216;
  case 11: 
#line 118
  raid = 0U;
#line 119
  goto ldv_53216;
  default: 
#line 121
  raid = 4U;
#line 122
  goto ldv_53216;
  }
  ldv_53216: ;
#line 124
  return (raid);
}
}
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
u8 judge_network_type23a(struct rtw_adapter *padapter , unsigned char *rate , int ratelen ) 
{ 
  u8 network_type ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int tmp ;
  int tmp___0 ;

  {
#line 130
  network_type = 0U;
#line 131
  pmlmeext = & padapter->mlmeextpriv;
#line 132
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 134
  if ((unsigned int )pmlmeext->cur_channel > 14U) {
#line 135
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
#line 136
      network_type = 16U;
    } else {

    }
#line 137
    network_type = (u8 )((unsigned int )network_type | 4U);
  } else {
#line 139
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
#line 140
      network_type = 8U;
    } else {

    }
#line 142
    tmp___0 = cckratesonly_included23a(rate, ratelen);
#line 142
    if (tmp___0 == 1) {
#line 143
      network_type = (u8 )((unsigned int )network_type | 1U);
    } else {
#line 144
      tmp = cckrates_included23a(rate, ratelen);
#line 144
      if (tmp == 1) {
#line 145
        network_type = (u8 )((unsigned int )network_type | 3U);
      } else {
#line 147
        network_type = (u8 )((unsigned int )network_type | 2U);
      }
    }
  }
#line 149
  return (network_type);
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static unsigned char ratetbl_val_2wifirate(unsigned char rate ) 
{ 
  unsigned char val ;

  {
#line 154
  val = 0U;
#line 156
  switch ((int )rate & 127) {
  case 0: 
#line 158
  val = 2U;
#line 159
  goto ldv_53239;
  case 1: 
#line 161
  val = 4U;
#line 162
  goto ldv_53239;
  case 2: 
#line 164
  val = 11U;
#line 165
  goto ldv_53239;
  case 3: 
#line 167
  val = 22U;
#line 168
  goto ldv_53239;
  case 4: 
#line 170
  val = 12U;
#line 171
  goto ldv_53239;
  case 5: 
#line 173
  val = 18U;
#line 174
  goto ldv_53239;
  case 6: 
#line 176
  val = 24U;
#line 177
  goto ldv_53239;
  case 7: 
#line 179
  val = 36U;
#line 180
  goto ldv_53239;
  case 8: 
#line 182
  val = 48U;
#line 183
  goto ldv_53239;
  case 9: 
#line 185
  val = 72U;
#line 186
  goto ldv_53239;
  case 10: 
#line 188
  val = 96U;
#line 189
  goto ldv_53239;
  case 11: 
#line 191
  val = 108U;
#line 192
  goto ldv_53239;
  }
  ldv_53239: ;
#line 194
  return (val);
}
}
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static int is_basicrate(struct rtw_adapter *padapter , unsigned char rate ) 
{ 
  int i ;
  unsigned char val ;
  struct mlme_ext_priv *pmlmeext ;
  unsigned char tmp ;

  {
#line 201
  pmlmeext = & padapter->mlmeextpriv;
#line 203
  i = 0;
#line 203
  goto ldv_53259;
  ldv_53258: 
#line 204
  val = pmlmeext->basicrate[i];
#line 206
  if ((unsigned int )val != 255U && (unsigned int )val != 254U) {
#line 207
    tmp = ratetbl_val_2wifirate((int )val);
#line 207
    if ((int )tmp == (int )rate) {
#line 208
      return (1);
    } else {

    }
  } else {

  }
#line 203
  i = i + 1;
  ldv_53259: ;
#line 203
  if (i <= 12) {
#line 205
    goto ldv_53258;
  } else {

  }

#line 212
  return (0);
}
}
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static unsigned int ratetbl2rateset(struct rtw_adapter *padapter , unsigned char *rateset ) 
{ 
  int i ;
  unsigned char rate ;
  unsigned int len ;
  struct mlme_ext_priv *pmlmeext ;
  int tmp ;

  {
#line 220
  len = 0U;
#line 221
  pmlmeext = & padapter->mlmeextpriv;
#line 223
  i = 0;
#line 223
  goto ldv_53275;
  ldv_53274: 
#line 224
  rate = pmlmeext->datarate[i];
#line 226
  switch ((int )rate) {
  case 255: ;
#line 228
  return (len);
  case 254: ;
#line 230
  goto ldv_53271;
  default: 
#line 232
  rate = ratetbl_val_2wifirate((int )rate);
#line 234
  tmp = is_basicrate(padapter, (int )rate);
#line 234
  if (tmp == 1) {
#line 235
    rate = (unsigned int )rate | 128U;
  } else {

  }
#line 237
  *(rateset + (unsigned long )len) = rate;
#line 238
  len = len + 1U;
#line 239
  goto ldv_53273;
  }
  ldv_53273: ;
  ldv_53271: 
#line 223
  i = i + 1;
  ldv_53275: ;
#line 223
  if (i <= 12) {
#line 225
    goto ldv_53274;
  } else {

  }

#line 242
  return (len);
}
}
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void get_rate_set23a(struct rtw_adapter *padapter , unsigned char *pbssrate , int *bssrate_len ) 
{ 
  unsigned char supportedrates[13U] ;
  unsigned int tmp ;

  {
#line 250
  memset((void *)(& supportedrates), 0, 13UL);
#line 251
  tmp = ratetbl2rateset(padapter, (unsigned char *)(& supportedrates));
#line 251
  *bssrate_len = (int )tmp;
#line 252
  memcpy((void *)pbssrate, (void const   *)(& supportedrates), (size_t )*bssrate_len);
#line 253
  return;
}
}
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void UpdateBrateTbl23a(struct rtw_adapter *Adapter , u8 *mBratesOS ) 
{ 
  u8 i ;
  u8 rate ;

  {
#line 261
  i = 0U;
#line 261
  goto ldv_53299;
  ldv_53298: 
#line 262
  rate = (unsigned int )*(mBratesOS + (unsigned long )i) & 127U;
#line 263
  switch ((int )rate) {
  case 2: ;
  case 4: ;
  case 11: ;
  case 22: ;
  case 12: ;
  case 24: ;
  case 48: 
#line 271
  *(mBratesOS + (unsigned long )i) = (u8 )((unsigned int )*(mBratesOS + (unsigned long )i) | 128U);
#line 272
  goto ldv_53296;
  default: ;
#line 274
  goto ldv_53296;
  }
  ldv_53296: 
#line 261
  i = (u8 )((int )i + 1);
  ldv_53299: ;
#line 261
  if ((unsigned int )i <= 15U) {
#line 263
    goto ldv_53298;
  } else {

  }

#line 268
  return;
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void Update23aTblForSoftAP(u8 *bssrateset , u32 bssratelen ) 
{ 
  u8 i ;
  u8 rate ;

  {
#line 284
  i = 0U;
#line 284
  goto ldv_53313;
  ldv_53312: 
#line 285
  rate = (unsigned int )*(bssrateset + (unsigned long )i) & 127U;
#line 286
  switch ((int )rate) {
  case 2: ;
  case 4: ;
  case 11: ;
  case 22: 
#line 291
  *(bssrateset + (unsigned long )i) = (u8 )((unsigned int )*(bssrateset + (unsigned long )i) | 128U);
#line 292
  goto ldv_53311;
  }
  ldv_53311: 
#line 284
  i = (u8 )((int )i + 1);
  ldv_53313: ;
#line 284
  if ((u32 )i < bssratelen) {
#line 286
    goto ldv_53312;
  } else {

  }

#line 291
  return;
}
}
#line 302 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
__inline void rtw_set_oper_ch23a(struct rtw_adapter *adapter , u8 ch ) 
{ 


  {
#line 304
  (adapter->dvobj)->oper_channel = ch;
#line 305
  return;
}
}
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
__inline void rtw_set_oper_bw23a(struct rtw_adapter *adapter , u8 bw ) 
{ 


  {
#line 314
  (adapter->dvobj)->oper_bwmode = bw;
#line 315
  return;
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
__inline void rtw_set_oper_ch23aoffset23a(struct rtw_adapter *adapter , u8 offset ) 
{ 


  {
#line 324
  (adapter->dvobj)->oper_ch_offset = offset;
#line 325
  return;
}
}
#line 327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void SelectChannel23a(struct rtw_adapter *padapter , unsigned char channel ) 
{ 


  {
#line 329
  mutex_lock_nested(& (padapter->dvobj)->setch_mutex, 0U);
#line 332
  rtw_set_oper_ch23a(padapter, (int )channel);
#line 334
  PHY_SwChnl8723A(padapter, (int )channel);
#line 336
  mutex_unlock(& (padapter->dvobj)->setch_mutex);
#line 337
  return;
}
}
#line 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static void set_bwmode(struct rtw_adapter *padapter , unsigned short bwmode , unsigned char channel_offset ) 
{ 


  {
#line 342
  mutex_lock_nested(& (padapter->dvobj)->setbw_mutex, 0U);
#line 345
  rtw_set_oper_bw23a(padapter, (int )((u8 )bwmode));
#line 346
  rtw_set_oper_ch23aoffset23a(padapter, (int )channel_offset);
#line 348
  PHY_SetBWMode23a8723A(padapter, (enum ht_channel_width )bwmode, (int )channel_offset);
#line 351
  mutex_unlock(& (padapter->dvobj)->setbw_mutex);
#line 352
  return;
}
}
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void set_channel_bwmode23a(struct rtw_adapter *padapter , unsigned char channel ,
                           unsigned char channel_offset , unsigned short bwmode ) 
{ 
  u8 center_ch ;

  {
#line 359
  if ((unsigned int )bwmode == 0U || (unsigned int )channel_offset == 0U) {
#line 362
    center_ch = channel;
  } else
#line 365
  if ((unsigned int )channel_offset == 1U) {
#line 367
    center_ch = (unsigned int )channel + 2U;
  } else {
#line 370
    center_ch = (unsigned int )channel + 254U;
  }
#line 375
  mutex_lock_nested(& (padapter->dvobj)->setch_mutex, 0U);
#line 378
  rtw_set_oper_ch23a(padapter, (int )channel);
#line 379
  rtw_set_oper_bw23a(padapter, (int )((u8 )bwmode));
#line 380
  rtw_set_oper_ch23aoffset23a(padapter, (int )channel_offset);
#line 382
  PHY_SwChnl8723A(padapter, (int )center_ch);
#line 384
  mutex_unlock(& (padapter->dvobj)->setch_mutex);
#line 386
  set_bwmode(padapter, (int )bwmode, (int )channel_offset);
#line 387
  return;
}
}
#line 394 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
bool is_client_associated_to_ap23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 399
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 400
    return (0);
  } else {

  }
#line 402
  pmlmeext = & padapter->mlmeextpriv;
#line 403
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 405
  if ((pmlmeinfo->state & 16384U) != 0U && (pmlmeinfo->state & 3U) == 2U) {
#line 407
    return (1);
  } else {
#line 409
    return (0);
  }
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
bool is_client_associated_to_ibss23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 414
  pmlmeext = & padapter->mlmeextpriv;
#line 415
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 417
  if ((pmlmeinfo->state & 16384U) != 0U && (pmlmeinfo->state & 3U) == 1U) {
#line 419
    return (1);
  } else {
#line 421
    return (0);
  }
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
bool is_IBSS_empty23a(struct rtw_adapter *padapter ) 
{ 
  unsigned int i ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 427
  pmlmeext = & padapter->mlmeextpriv;
#line 428
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 430
  i = 2U;
#line 430
  goto ldv_53372;
  ldv_53371: ;
#line 431
  if (pmlmeinfo->FW_sta_info[i].status == 1U) {
#line 432
    return (0);
  } else {

  }
#line 430
  i = i + 1U;
  ldv_53372: ;
#line 430
  if (i <= 31U) {
#line 432
    goto ldv_53371;
  } else {

  }

#line 435
  return (1);
}
}
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
unsigned int decide_wait_for_beacon_timeout23a(unsigned int bcn_interval ) 
{ 


  {
#line 440
  if (bcn_interval << 2 <= 5999U) {
#line 441
    return (6000U);
  } else
#line 442
  if (bcn_interval << 2 > 20000U) {
#line 443
    return (20000U);
  } else {
#line 445
    return (bcn_interval << 2);
  }
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void clear_cam_entry23a(struct rtw_adapter *padapter , u8 entry ) 
{ 
  unsigned char null_sta[6U] ;
  unsigned char null_key[16U] ;

  {
#line 450
  null_sta[0] = 0U;
#line 450
  null_sta[1] = 0U;
#line 450
  null_sta[2] = 0U;
#line 450
  null_sta[3] = 0U;
#line 450
  null_sta[4] = 0U;
#line 450
  null_sta[5] = 0U;
#line 452
  null_key[0] = 0U;
#line 452
  null_key[1] = 0U;
#line 452
  null_key[2] = 0U;
#line 452
  null_key[3] = 0U;
#line 452
  null_key[4] = 0U;
#line 452
  null_key[5] = 0U;
#line 452
  null_key[6] = 0U;
#line 452
  null_key[7] = 0U;
#line 452
  null_key[8] = 0U;
#line 452
  null_key[9] = 0U;
#line 452
  null_key[10] = 0U;
#line 452
  null_key[11] = 0U;
#line 452
  null_key[12] = 0U;
#line 452
  null_key[13] = 0U;
#line 452
  null_key[14] = 0U;
#line 452
  null_key[15] = 0U;
#line 456
  rtl8723a_cam_write(padapter, (int )entry, 0, (u8 const   *)(& null_sta), (u8 const   *)(& null_key));
#line 457
  return;
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
int allocate_fw_sta_entry23a(struct rtw_adapter *padapter ) 
{ 
  unsigned int mac_id ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 462
  pmlmeext = & padapter->mlmeextpriv;
#line 463
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 465
  mac_id = 2U;
#line 465
  goto ldv_53391;
  ldv_53390: ;
#line 466
  if (pmlmeinfo->FW_sta_info[mac_id].status == 0U) {
#line 467
    pmlmeinfo->FW_sta_info[mac_id].status = 1U;
#line 468
    pmlmeinfo->FW_sta_info[mac_id].retry = 0U;
#line 469
    goto ldv_53389;
  } else {

  }
#line 465
  mac_id = mac_id + 1U;
  ldv_53391: ;
#line 465
  if (mac_id <= 31U) {
#line 467
    goto ldv_53390;
  } else {

  }
  ldv_53389: ;
#line 473
  return ((int )mac_id);
}
}
#line 476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void flush_all_cam_entry23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 478
  pmlmeext = & padapter->mlmeextpriv;
#line 479
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 481
  rtl8723a_cam_invalidate_all(padapter);
#line 483
  memset((void *)(& pmlmeinfo->FW_sta_info), 0, 1280UL);
#line 484
  return;
}
}
#line 486 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
int WMM_param_handler23a(struct rtw_adapter *padapter , u8 const   *p ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 489
  pmlmepriv = & padapter->mlmepriv;
#line 490
  pmlmeext = & padapter->mlmeextpriv;
#line 491
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 493
  if (pmlmepriv->qos_option == 0U) {
#line 494
    pmlmeinfo->WMM_enable = 0U;
#line 495
    return (0);
  } else {

  }
#line 498
  pmlmeinfo->WMM_enable = 1U;
#line 499
  memcpy((void *)(& pmlmeinfo->WMM_param), (void const   *)p + 8U, 18UL);
#line 501
  return (1);
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void WMMOnAssocRsp23a(struct rtw_adapter *padapter ) 
{ 
  u8 ACI ;
  u8 ACM ;
  u8 AIFS ;
  u8 ECWMin ;
  u8 ECWMax ;
  u8 aSifsTime ;
  u8 acm_mask ;
  u16 TXOP ;
  u32 acParm ;
  u32 i ;
  u32 edca[4U] ;
  u32 inx[4U] ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct xmit_priv *pxmitpriv ;
  struct registry_priv *pregpriv ;
  u32 j ;
  u32 change_inx ;
  u32 __tmp ;
  u32 __tmp___0 ;

  {
#line 511
  pmlmeext = & padapter->mlmeextpriv;
#line 512
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 513
  pxmitpriv = & padapter->xmitpriv;
#line 514
  pregpriv = & padapter->registrypriv;
#line 516
  if ((unsigned int )pmlmeinfo->WMM_enable == 0U) {
#line 517
    padapter->mlmepriv.acm_mask = 0U;
#line 518
    return;
  } else {

  }
#line 521
  acm_mask = 0U;
#line 523
  if ((unsigned int )pmlmeext->cur_wireless_mode == 1U) {
#line 524
    aSifsTime = 10U;
  } else {
#line 526
    aSifsTime = 16U;
  }
#line 528
  i = 0U;
#line 528
  goto ldv_53429;
  ldv_53428: 
#line 529
  ACI = (unsigned int )((u8 )((int )pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 5)) & 3U;
#line 530
  ACM = (unsigned int )((u8 )((int )pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 4)) & 1U;
#line 533
  AIFS = ((unsigned int )pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN & 15U) * (unsigned int )pmlmeinfo->slotTime + (unsigned int )aSifsTime;
#line 536
  ECWMin = (unsigned int )pmlmeinfo->WMM_param.ac_param[i].CW & 15U;
#line 537
  ECWMax = (int )pmlmeinfo->WMM_param.ac_param[i].CW >> 4;
#line 538
  TXOP = pmlmeinfo->WMM_param.ac_param[i].TXOP_limit;
#line 540
  acParm = (u32 )((((int )AIFS | ((int )ECWMin << 8)) | ((int )ECWMax << 12)) | ((int )TXOP << 16));
#line 542
  switch ((int )ACI) {
  case 0: 
#line 544
  rtl8723a_set_ac_param_be(padapter, acParm);
#line 545
  acm_mask = ((unsigned int )ACM != 0U ? 2U : 0U) | (unsigned int )acm_mask;
#line 546
  edca[2] = acParm;
#line 547
  goto ldv_53424;
  case 1: 
#line 549
  rtl8723a_set_ac_param_bk(padapter, acParm);
#line 551
  edca[3] = acParm;
#line 552
  goto ldv_53424;
  case 2: 
#line 554
  rtl8723a_set_ac_param_vi(padapter, acParm);
#line 555
  acm_mask = ((unsigned int )ACM != 0U ? 4U : 0U) | (unsigned int )acm_mask;
#line 556
  edca[1] = acParm;
#line 557
  goto ldv_53424;
  case 3: 
#line 559
  rtl8723a_set_ac_param_vo(padapter, acParm);
#line 560
  acm_mask = ((unsigned int )ACM != 0U ? 8U : 0U) | (unsigned int )acm_mask;
#line 561
  edca[0] = acParm;
#line 562
  goto ldv_53424;
  }
  ldv_53424: ;
#line 565
  if (GlobalDebugLevel23A > 3U) {
#line 565
    printk("\016RTL8723AU: WMM(%x): %x, %x\n", (int )ACI, (int )ACM, acParm);
  } else {

  }
#line 528
  i = i + 1U;
  ldv_53429: ;
#line 528
  if (i <= 3U) {
#line 530
    goto ldv_53428;
  } else {

  }

#line 568
  if ((unsigned int )padapter->registrypriv.acm_method == 1U) {
#line 569
    rtl8723a_set_acm_ctrl(padapter, (int )acm_mask);
  } else {
#line 571
    padapter->mlmepriv.acm_mask = acm_mask;
  }
#line 573
  inx[0] = 0U;
#line 573
  inx[1] = 1U;
#line 573
  inx[2] = 2U;
#line 573
  inx[3] = 3U;
#line 575
  if ((unsigned int )pregpriv->wifi_spec == 1U) {
#line 576
    change_inx = 0U;
#line 579
    i = 0U;
#line 579
    goto ldv_53439;
    ldv_53438: 
#line 580
    j = i + 1U;
#line 580
    goto ldv_53436;
    ldv_53435: ;
#line 582
    if ((edca[j] & 65535U) < (edca[i] & 65535U)) {
#line 583
      change_inx = 1U;
    } else
#line 584
    if (((edca[j] ^ edca[i]) & 65535U) == 0U) {
#line 587
      if (edca[j] >> 16 > edca[i] >> 16) {
#line 588
        change_inx = 1U;
      } else {

      }
    } else {

    }
#line 591
    if (change_inx != 0U) {
#line 592
      __tmp = edca[i];
#line 592
      edca[i] = edca[j];
#line 592
      edca[j] = __tmp;
#line 593
      __tmp___0 = inx[i];
#line 593
      inx[i] = inx[j];
#line 593
      inx[j] = __tmp___0;
#line 594
      change_inx = 0U;
    } else {

    }
#line 580
    j = j + 1U;
    ldv_53436: ;
#line 580
    if (j <= 3U) {
#line 582
      goto ldv_53435;
    } else {

    }
#line 579
    i = i + 1U;
    ldv_53439: ;
#line 579
    if (i <= 3U) {
#line 581
      goto ldv_53438;
    } else {

    }

  } else {

  }
#line 600
  i = 0U;
#line 600
  goto ldv_53442;
  ldv_53441: 
#line 601
  pxmitpriv->wmm_para_seq[i] = (u8 )inx[i];
#line 602
  if (GlobalDebugLevel23A > 3U) {
#line 602
    printk("\016RTL8723AU: wmm_para_seq(%d): %d\n", i, (int )pxmitpriv->wmm_para_seq[i]);
  } else {

  }
#line 600
  i = i + 1U;
  ldv_53442: ;
#line 600
  if (i <= 3U) {
#line 602
    goto ldv_53441;
  } else {

  }

#line 607
  return;
}
}
#line 607 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static void bwmode_update_check(struct rtw_adapter *padapter , u8 const   *p ) 
{ 
  struct ieee80211_ht_operation *pHT_info ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct registry_priv *pregistrypriv ;
  struct ht_priv *phtpriv ;
  unsigned char new_bwmode ;
  unsigned char new_ch_offset ;
  struct sta_info *psta ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_priv *pstapriv ;
  struct ht_priv *phtpriv_sta ;

  {
#line 610
  pmlmepriv = & padapter->mlmepriv;
#line 611
  pmlmeext = & padapter->mlmeextpriv;
#line 612
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 613
  pregistrypriv = & padapter->registrypriv;
#line 614
  phtpriv = & pmlmepriv->htpriv;
#line 618
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
#line 619
    return;
  } else {

  }
#line 620
  if (! phtpriv->ht_option) {
#line 621
    return;
  } else {

  }
#line 622
  if ((unsigned int )((unsigned char )*(p + 1UL)) != 22U) {
#line 623
    return;
  } else {

  }
#line 625
  pHT_info = (struct ieee80211_ht_operation *)p + 2U;
#line 627
  if (((int )pHT_info->ht_param & 4) != 0 && (unsigned int )pregistrypriv->cbw40_enable != 0U) {
#line 629
    new_bwmode = 1U;
#line 631
    switch ((int )pHT_info->ht_param & 3) {
    case 1: 
#line 633
    new_ch_offset = 1U;
#line 634
    goto ldv_53457;
    case 3: 
#line 636
    new_ch_offset = 2U;
#line 637
    goto ldv_53457;
    default: 
#line 639
    new_ch_offset = 0U;
#line 640
    goto ldv_53457;
    }
    ldv_53457: ;
  } else {
#line 643
    new_bwmode = 0U;
#line 644
    new_ch_offset = 0U;
  }
#line 647
  if ((int )pmlmeext->cur_bwmode != (int )new_bwmode || (int )pmlmeext->cur_ch_offset != (int )new_ch_offset) {
#line 649
    pmlmeinfo->bwmode_updated = 1U;
#line 651
    pmlmeext->cur_bwmode = new_bwmode;
#line 652
    pmlmeext->cur_ch_offset = new_ch_offset;
#line 655
    HT_info_handler23a(padapter, p);
  } else {
#line 657
    pmlmeinfo->bwmode_updated = 0U;
  }
#line 659
  if ((unsigned int )pmlmeinfo->bwmode_updated != 0U) {
#line 661
    cur_network = & pmlmeinfo->network;
#line 662
    pstapriv = & padapter->stapriv;
#line 668
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->MacAddress));
#line 669
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 670
      phtpriv_sta = & psta->htpriv;
#line 672
      if ((int )phtpriv_sta->ht_option) {
#line 674
        phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
#line 675
        phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
      } else {
#line 678
        phtpriv_sta->bwmode = 0U;
#line 679
        phtpriv_sta->ch_offset = 0U;
      }
    } else {

    }
  } else {

  }
#line 683
  return;
}
}
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void HT_caps_handler23a(struct rtw_adapter *padapter , u8 const   *p ) 
{ 
  unsigned int i ;
  u8 rf_type ;
  u8 max_AMPDU_len ;
  u8 min_MPDU_spacing ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  struct ieee80211_ht_cap *cap ;
  u8 *dstcap ;

  {
#line 691
  pmlmeext = & padapter->mlmeextpriv;
#line 692
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 693
  pmlmepriv = & padapter->mlmepriv;
#line 694
  phtpriv = & pmlmepriv->htpriv;
#line 698
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
#line 699
    return;
  } else {

  }
#line 701
  if (! phtpriv->ht_option) {
#line 702
    return;
  } else {

  }
#line 704
  pmlmeinfo->HT_caps_enable = 1U;
#line 706
  cap = & pmlmeinfo->ht_cap;
#line 707
  dstcap = (u8 *)cap;
#line 708
  i = 0U;
#line 708
  goto ldv_53479;
  ldv_53478: ;
#line 709
  if (i != 2U) {
#line 710
    *(dstcap + (unsigned long )i) = (u8 )((int )*(dstcap + (unsigned long )i) & (int )((unsigned char )*(p + (unsigned long )(i + 2U))));
  } else {
#line 713
    if (((int )cap->ampdu_params_info & 3) > ((int )*(p + (unsigned long )(i + 2U)) & 3)) {
#line 716
      max_AMPDU_len = (unsigned int )((u8 )*(p + (unsigned long )(i + 2U))) & 3U;
    } else {
#line 719
      max_AMPDU_len = (unsigned int )cap->ampdu_params_info & 3U;
    }
#line 722
    if (((int )cap->ampdu_params_info & 28) > ((int )*(p + (unsigned long )(i + 2U)) & 28)) {
#line 725
      min_MPDU_spacing = (unsigned int )cap->ampdu_params_info & 28U;
    } else {
#line 728
      min_MPDU_spacing = (unsigned int )((u8 )*(p + (unsigned long )(i + 2U))) & 28U;
    }
#line 731
    cap->ampdu_params_info = (u8 )((int )max_AMPDU_len | (int )min_MPDU_spacing);
  }
#line 708
  i = i + 1U;
  ldv_53479: ;
#line 708
  if ((unsigned int )*(p + 1UL) > i) {
#line 710
    goto ldv_53478;
  } else {

  }
#line 736
  rf_type = rtl8723a_get_rf_type(padapter);
#line 739
  i = 0U;
#line 739
  goto ldv_53482;
  ldv_53481: ;
#line 740
  if ((unsigned int )rf_type == 3U || (unsigned int )rf_type == 0U) {
#line 741
    cap->mcs.rx_mask[i] = (u8 )((int )cap->mcs.rx_mask[i] & (int )MCS_rate_1R23A[i]);
  } else {
#line 743
    cap->mcs.rx_mask[i] = (u8 )((int )cap->mcs.rx_mask[i] & (int )MCS_rate_2R23A[i]);
  }
#line 739
  i = i + 1U;
  ldv_53482: ;
#line 739
  if (i <= 9U) {
#line 741
    goto ldv_53481;
  } else {

  }

#line 746
  return;
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void HT_info_handler23a(struct rtw_adapter *padapter , u8 const   *p ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;

  {
#line 749
  pmlmeext = & padapter->mlmeextpriv;
#line 750
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 751
  pmlmepriv = & padapter->mlmepriv;
#line 752
  phtpriv = & pmlmepriv->htpriv;
#line 754
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
#line 755
    return;
  } else {

  }
#line 757
  if (! phtpriv->ht_option) {
#line 758
    return;
  } else {

  }
#line 760
  if ((unsigned int )((unsigned char )*(p + 1UL)) != 22U) {
#line 761
    return;
  } else {

  }
#line 763
  pmlmeinfo->HT_info_enable = 1U;
#line 764
  memcpy((void *)(& pmlmeinfo->HT_info), (void const   *)p + 2U, (size_t )*(p + 1UL));
#line 765
  return;
}
}
#line 767 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void HTOnAssocRsp23a(struct rtw_adapter *padapter ) 
{ 
  unsigned char max_AMPDU_len ;
  unsigned char min_MPDU_spacing ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 772
  pmlmeext = & padapter->mlmeextpriv;
#line 773
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 775
  if (GlobalDebugLevel23A > 3U) {
#line 775
    printk("\016RTL8723AU: %s\n", "HTOnAssocRsp23a");
  } else {

  }
#line 777
  if ((unsigned int )pmlmeinfo->HT_info_enable != 0U && (unsigned int )pmlmeinfo->HT_caps_enable != 0U) {
#line 778
    pmlmeinfo->HT_enable = 1U;
  } else {
#line 780
    pmlmeinfo->HT_enable = 0U;
#line 783
    return;
  }
#line 791
  max_AMPDU_len = (unsigned int )pmlmeinfo->ht_cap.ampdu_params_info & 3U;
#line 794
  min_MPDU_spacing = (unsigned char )(((int )pmlmeinfo->ht_cap.ampdu_params_info & 28) >> 2);
#line 798
  rtl8723a_set_ampdu_min_space(padapter, (int )min_MPDU_spacing);
#line 799
  rtl8723a_set_ampdu_factor(padapter, (int )max_AMPDU_len);
#line 800
  return;
}
}
#line 802 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void ERP_IE_handler23a(struct rtw_adapter *padapter , u8 const   *p ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 804
  pmlmeext = & padapter->mlmeextpriv;
#line 805
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 807
  if ((unsigned int )((unsigned char )*(p + 1UL)) > 1U) {
#line 808
    return;
  } else {

  }
#line 810
  pmlmeinfo->ERP_enable = 1U;
#line 811
  memcpy((void *)(& pmlmeinfo->ERP_IE), (void const   *)p + 2U, (size_t )*(p + 1UL));
#line 812
  return;
}
}
#line 814 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void VCS_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct registry_priv *pregpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 816
  pregpriv = & padapter->registrypriv;
#line 817
  pmlmeext = & padapter->mlmeextpriv;
#line 818
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 820
  switch ((int )pregpriv->vrtl_carrier_sense) {
  case 0: 
#line 822
  psta->rtsen = 0U;
#line 823
  psta->cts2self = 0U;
#line 824
  goto ldv_53514;
  case 1: ;
#line 826
  if ((unsigned int )pregpriv->vcs_type == 1U) {
#line 827
    psta->rtsen = 1U;
#line 828
    psta->cts2self = 0U;
  } else {
#line 830
    psta->rtsen = 0U;
#line 831
    psta->cts2self = 1U;
  }
#line 833
  goto ldv_53514;
  case 2: ;
  default: ;
#line 836
  if ((unsigned int )pmlmeinfo->ERP_enable != 0U && ((unsigned long )pmlmeinfo->ERP_IE & 2UL) != 0UL) {
#line 837
    if ((unsigned int )pregpriv->vcs_type == 1U) {
#line 838
      psta->rtsen = 1U;
#line 839
      psta->cts2self = 0U;
    } else {
#line 841
      psta->rtsen = 0U;
#line 842
      psta->cts2self = 1U;
    }
  } else {
#line 845
    psta->rtsen = 0U;
#line 846
    psta->cts2self = 0U;
  }
#line 848
  goto ldv_53514;
  }
  ldv_53514: ;
#line 851
  return;
}
}
#line 852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
int rtw_check_bcn_info23a(struct rtw_adapter *Adapter , struct ieee80211_mgmt *mgmt ,
                          u32 pkt_len ) 
{ 
  struct wlan_network *cur_network ;
  struct ieee80211_ht_operation *pht_info ;
  unsigned short val16 ;
  u8 crypto ;
  u8 bcn_channel ;
  int group_cipher ;
  int pairwise_cipher ;
  int is_8021x ;
  int r ;
  int pie_len ;
  int ssid_len ;
  int privacy ;
  u8 const   *p ;
  u8 const   *ssid ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 855
  cur_network = & Adapter->mlmepriv.cur_network;
#line 859
  group_cipher = 0;
#line 859
  pairwise_cipher = 0;
#line 859
  is_8021x = 0;
#line 863
  tmp = is_client_associated_to_ap23a(Adapter);
#line 863
  if (tmp) {
#line 863
    tmp___0 = 0;
  } else {
#line 863
    tmp___0 = 1;
  }
#line 863
  if (tmp___0) {
#line 864
    return (1);
  } else {

  }
#line 866
  tmp___1 = ieee80211_is_beacon((int )mgmt->frame_control);
#line 866
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 866
  if (tmp___2 != 0L) {
#line 867
    printk("\f%s: received a non beacon frame!\n", "rtw_check_bcn_info23a");
#line 869
    return (0);
  } else {

  }
#line 872
  tmp___3 = ether_addr_equal((u8 const   *)(& cur_network->network.MacAddress), (u8 const   *)(& mgmt->bssid));
#line 872
  if (tmp___3) {
#line 872
    tmp___4 = 0;
  } else {
#line 872
    tmp___4 = 1;
  }
#line 872
  if (tmp___4) {
#line 873
    if (GlobalDebugLevel23A > 3U) {
#line 873
      printk("\016RTL8723AU: %s: linked but recv other bssid bcn %pM %pM\n", "rtw_check_bcn_info23a",
             (u8 *)(& mgmt->bssid), (u8 *)(& cur_network->network.MacAddress));
    } else {

    }
#line 876
    return (0);
  } else {

  }
#line 881
  pie_len = (int )(pkt_len - 36U);
#line 884
  p = cfg80211_find_ie(3, (u8 const   *)(& mgmt->u.beacon.variable), pie_len);
#line 886
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 887
    bcn_channel = *(p + 2UL);
  } else {
#line 891
    p = cfg80211_find_ie(61, (u8 const   *)(& mgmt->u.beacon.variable), pie_len);
#line 894
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 895
      pht_info = (struct ieee80211_ht_operation *)p + 2U;
#line 896
      bcn_channel = pht_info->primary_chan;
    } else {
#line 898
      if (GlobalDebugLevel23A > 3U) {
#line 898
        printk("\016RTL8723AU: Oops: %s we don\'t find channel IE, so don\'t check it\n",
               "rtw_check_bcn_info23a");
      } else {

      }
#line 900
      bcn_channel = Adapter->mlmeextpriv.cur_channel;
    }
  }
#line 903
  if ((int )Adapter->mlmeextpriv.cur_channel != (int )bcn_channel) {
#line 904
    if (GlobalDebugLevel23A > 3U) {
#line 904
      printk("\016RTL8723AU: %s beacon channel:%d cur channel:%d disconnect\n", "rtw_check_bcn_info23a",
             (int )bcn_channel, (int )Adapter->mlmeextpriv.cur_channel);
    } else {

    }
#line 907
    goto _mismatch;
  } else {

  }
#line 911
  p = cfg80211_find_ie(0, (u8 const   *)(& mgmt->u.beacon.variable), pie_len);
#line 912
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 913
    ssid = p + 2UL;
#line 914
    ssid_len = (int )*(p + 1UL);
  } else {
#line 916
    if (GlobalDebugLevel23A > 3U) {
#line 916
      printk("\016RTL8723AU: %s marc: cannot find SSID for survey event\n", "rtw_check_bcn_info23a");
    } else {

    }
#line 918
    ssid = (u8 const   *)0U;
#line 919
    ssid_len = 0;
  }
#line 922
  if (GlobalDebugLevel23A > 6U) {
#line 922
    rt_trace(16, 7, "%s bssid.Ssid.Ssid:%s bssid.Ssid.SsidLength:%d cur_network->network.Ssid.Ssid:%s len:%d\n",
             "rtw_check_bcn_info23a", ssid, ssid_len, (u8 *)(& cur_network->network.Ssid.ssid),
             (int )cur_network->network.Ssid.ssid_len);
  } else {

  }
#line 927
  if ((int )cur_network->network.Ssid.ssid_len != ssid_len || ssid_len > 32) {
#line 927
    goto _L;
  } else
#line 927
  if (ssid_len != 0) {
#line 927
    tmp___5 = memcmp((void const   *)ssid, (void const   *)(& cur_network->network.Ssid.ssid),
                     (size_t )ssid_len);
#line 927
    if (tmp___5 != 0) {
      _L: /* CIL Label */ 
#line 930
      if (GlobalDebugLevel23A > 3U) {
#line 930
        printk("\016RTL8723AU: %s(), SSID is not match return FAIL\n", "rtw_check_bcn_info23a");
      } else {

      }
#line 931
      goto _mismatch;
    } else {

    }
  } else {

  }
#line 935
  val16 = mgmt->u.beacon.capab_info;
#line 937
  if (((int )val16 & 16) != 0) {
#line 938
    privacy = 1;
  } else {
#line 940
    privacy = 0;
  }
#line 942
  if (GlobalDebugLevel23A > 6U) {
#line 942
    rt_trace(16, 7, "%s(): cur_network->network.Privacy is %d, bssid.Privacy is %d\n",
             "rtw_check_bcn_info23a", cur_network->network.Privacy, privacy);
  } else {

  }
#line 945
  if (cur_network->network.Privacy != (u32 )privacy) {
#line 946
    if (GlobalDebugLevel23A > 3U) {
#line 946
      printk("\016RTL8723AU: %s(), privacy is not match return FAIL\n", "rtw_check_bcn_info23a");
    } else {

    }
#line 947
    goto _mismatch;
  } else {

  }
#line 950
  p = cfg80211_find_ie(48, (u8 const   *)(& mgmt->u.beacon.variable), pie_len);
#line 951
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 952
    crypto = 3U;
#line 953
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 954
      r = rtw_parse_wpa2_ie23a(p, (int )*(p + 1UL) + 2, & group_cipher, & pairwise_cipher,
                               & is_8021x);
#line 956
      if (r == 1) {
#line 957
        if (GlobalDebugLevel23A > 6U) {
#line 957
          rt_trace(16, 7, "%s pnetwork->pairwise_cipher: %d, pnetwork->group_cipher: %d, is_802x : %d\n",
                   "rtw_check_bcn_info23a", pairwise_cipher, group_cipher, is_8021x);
        } else {

        }
      } else {

      }
    } else {

    }
  } else {
#line 963
    p = cfg80211_find_vendor_ie(20722U, 1, (u8 const   *)(& mgmt->u.beacon.variable),
                                pie_len);
#line 966
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 967
      crypto = 2U;
#line 968
      r = rtw_parse_wpa_ie23a(p, (int )*(p + 1UL) + 2, & group_cipher, & pairwise_cipher,
                              & is_8021x);
#line 970
      if (r == 1) {
#line 971
        if (GlobalDebugLevel23A > 6U) {
#line 971
          rt_trace(16, 7, "%s pnetwork->pairwise_cipher: %d, group_cipher is %d, is_8021x is %d\n",
                   "rtw_check_bcn_info23a", pairwise_cipher, group_cipher, is_8021x);
        } else {

        }
      } else {

      }
    } else
#line 976
    if (privacy != 0) {
#line 977
      crypto = 1U;
    } else {
#line 979
      crypto = 0U;
    }
  }
#line 983
  if ((int )cur_network->BcnInfo.encryp_protocol != (int )crypto) {
#line 984
    if (GlobalDebugLevel23A > 3U) {
#line 984
      printk("\016RTL8723AU: %s(): encryption mismatch, return FAIL\n", "rtw_check_bcn_info23a");
    } else {

    }
#line 985
    goto _mismatch;
  } else {

  }
#line 988
  if ((unsigned int )crypto == 2U || (unsigned int )crypto == 3U) {
#line 989
    if (GlobalDebugLevel23A > 3U) {
#line 989
      rt_trace(16, 4, "%s cur_network->group_cipher is %d: %d\n", "rtw_check_bcn_info23a",
               cur_network->BcnInfo.group_cipher, group_cipher);
    } else {

    }
#line 992
    if (cur_network->BcnInfo.pairwise_cipher != pairwise_cipher || cur_network->BcnInfo.group_cipher != group_cipher) {
#line 994
      if (GlobalDebugLevel23A > 3U) {
#line 994
        printk("\016RTL8723AU: %s pairwise_cipher(%x:%x) or group_cipher (%x:%x) is not match, return FAIL\n",
               "rtw_check_bcn_info23a", pairwise_cipher, cur_network->BcnInfo.pairwise_cipher,
               group_cipher, cur_network->BcnInfo.group_cipher);
      } else {

      }
#line 1000
      goto _mismatch;
    } else {

    }
#line 1003
    if (cur_network->BcnInfo.is_8021x != is_8021x) {
#line 1004
      if (GlobalDebugLevel23A > 3U) {
#line 1004
        printk("\016RTL8723AU: %s authentication is not match, return FAIL\n", "rtw_check_bcn_info23a");
      } else {

      }
#line 1006
      goto _mismatch;
    } else {

    }
  } else {

  }
#line 1010
  return (1);
  _mismatch: ;
#line 1014
  return (0);
}
}
#line 1017 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void update_beacon23a_info(struct rtw_adapter *padapter , struct ieee80211_mgmt *mgmt ,
                           uint pkt_len , struct sta_info *psta ) 
{ 
  unsigned int len ;
  u8 const   *p ;

  {
#line 1024
  len = pkt_len - 36U;
#line 1026
  p = cfg80211_find_ie(61, (u8 const   *)(& mgmt->u.beacon.variable), (int )len);
#line 1028
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 1029
    bwmode_update_check(padapter, p);
  } else {

  }
#line 1031
  p = cfg80211_find_ie(42, (u8 const   *)(& mgmt->u.beacon.variable), (int )len);
#line 1032
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 1033
    ERP_IE_handler23a(padapter, p);
#line 1034
    VCS_update23a(padapter, psta);
  } else {

  }
#line 1036
  return;
}
}
#line 1038 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
bool is_ap_in_tkip23a(struct rtw_adapter *padapter ) 
{ 
  u32 i ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 const   *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1041
  pmlmeext = & padapter->mlmeextpriv;
#line 1042
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1043
  cur_network = & pmlmeinfo->network;
#line 1046
  if (((int )cur_network->capability & 16) != 0) {
#line 1047
    i = 0U;
#line 1047
    goto ldv_53560;
    ldv_53559: 
#line 1048
    p = (u8 const   *)(& pmlmeinfo->network.IEs) + (unsigned long )i;
#line 1050
    switch ((int )*p) {
    case 221: 
#line 1052
    tmp = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                 4UL);
#line 1052
    if (tmp == 0) {
#line 1052
      tmp___0 = memcmp((void const   *)p + 14U, (void const   *)(& WPA_TKIP_CIPHER),
                       4UL);
#line 1052
      if (tmp___0 == 0) {
#line 1054
        return (1);
      } else {

      }
    } else {

    }
#line 1055
    goto ldv_53556;
    case 48: 
#line 1057
    tmp___1 = memcmp((void const   *)p + 10U, (void const   *)(& RSN_TKIP_CIPHER),
                     4UL);
#line 1057
    if (tmp___1 == 0) {
#line 1058
      return (1);
    } else {

    }
#line 1059
    goto ldv_53556;
    default: ;
#line 1061
    goto ldv_53556;
    }
    ldv_53556: 
#line 1063
    i = ((u32 )*(p + 1UL) + i) + 2U;
    ldv_53560: ;
#line 1047
    if (pmlmeinfo->network.IELength > i) {
#line 1049
      goto ldv_53559;
    } else {

    }

#line 1065
    return (0);
  } else {
#line 1067
    return (0);
  }
}
}
#line 1070 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
bool should_forbid_n_rate23a(struct rtw_adapter *padapter ) 
{ 
  u32 i ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *cur_network ;
  u8 const   *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1073
  pmlmepriv = & padapter->mlmepriv;
#line 1074
  cur_network = & pmlmepriv->cur_network.network;
#line 1077
  if (((int )cur_network->capability & 16) != 0) {
#line 1078
    i = 0U;
#line 1078
    goto ldv_53574;
    ldv_53573: 
#line 1079
    p = (u8 const   *)(& cur_network->IEs) + (unsigned long )i;
#line 1081
    switch ((int )*p) {
    case 221: 
#line 1083
    tmp = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                 4UL);
#line 1083
    if (tmp == 0) {
#line 1083
      tmp___0 = memcmp((void const   *)p + 14U, (void const   *)(& WPA_CIPHER_SUITE_CCMP23A),
                       4UL);
#line 1083
      if (tmp___0 == 0) {
#line 1088
        return (0);
      } else {
#line 1083
        tmp___1 = memcmp((void const   *)p + 18U, (void const   *)(& WPA_CIPHER_SUITE_CCMP23A),
                         4UL);
#line 1083
        if (tmp___1 == 0) {
#line 1088
          return (0);
        } else {

        }
      }
    } else {

    }
#line 1089
    goto ldv_53570;
    case 48: 
#line 1091
    tmp___2 = memcmp((void const   *)p + 10U, (void const   *)(& RSN_CIPHER_SUITE_CCMP23A),
                     4UL);
#line 1091
    if (tmp___2 == 0) {
#line 1095
      return (0);
    } else {
#line 1091
      tmp___3 = memcmp((void const   *)p + 14U, (void const   *)(& RSN_CIPHER_SUITE_CCMP23A),
                       4UL);
#line 1091
      if (tmp___3 == 0) {
#line 1095
        return (0);
      } else {

      }
    }
    default: ;
#line 1097
    goto ldv_53570;
    }
    ldv_53570: 
#line 1100
    i = ((u32 )*(p + 1UL) + i) + 2U;
    ldv_53574: ;
#line 1078
    if (cur_network->IELength > i) {
#line 1080
      goto ldv_53573;
    } else {

    }

#line 1102
    return (1);
  } else {
#line 1104
    return (0);
  }
}
}
#line 1108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
bool is_ap_in_wep23a(struct rtw_adapter *padapter ) 
{ 
  u32 i ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 const   *p ;
  int tmp ;

  {
#line 1111
  pmlmeext = & padapter->mlmeextpriv;
#line 1112
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1113
  cur_network = & pmlmeinfo->network;
#line 1116
  if (((int )cur_network->capability & 16) != 0) {
#line 1117
    i = 0U;
#line 1117
    goto ldv_53589;
    ldv_53588: 
#line 1118
    p = (u8 const   *)(& pmlmeinfo->network.IEs) + (unsigned long )i;
#line 1120
    switch ((int )*p) {
    case 221: 
#line 1122
    tmp = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                 4UL);
#line 1122
    if (tmp == 0) {
#line 1123
      return (0);
    } else {

    }
#line 1124
    goto ldv_53585;
    case 48: ;
#line 1126
    return (0);
    default: ;
#line 1129
    goto ldv_53585;
    }
    ldv_53585: 
#line 1132
    i = ((u32 )*(p + 1UL) + i) + 2U;
    ldv_53589: ;
#line 1117
    if (pmlmeinfo->network.IELength > i) {
#line 1119
      goto ldv_53588;
    } else {

    }

#line 1135
    return (1);
  } else {
#line 1137
    return (0);
  }
}
}
#line 1140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static int wifirate2_ratetbl_inx23a(unsigned char rate ) 
{ 
  int inx ;

  {
#line 1142
  inx = 0;
#line 1144
  rate = (unsigned int )rate & 127U;
#line 1146
  switch ((int )rate) {
  case 108: 
#line 1148
  inx = 11;
#line 1149
  goto ldv_53596;
  case 96: 
#line 1151
  inx = 10;
#line 1152
  goto ldv_53596;
  case 72: 
#line 1154
  inx = 9;
#line 1155
  goto ldv_53596;
  case 48: 
#line 1157
  inx = 8;
#line 1158
  goto ldv_53596;
  case 36: 
#line 1160
  inx = 7;
#line 1161
  goto ldv_53596;
  case 24: 
#line 1163
  inx = 6;
#line 1164
  goto ldv_53596;
  case 18: 
#line 1166
  inx = 5;
#line 1167
  goto ldv_53596;
  case 12: 
#line 1169
  inx = 4;
#line 1170
  goto ldv_53596;
  case 22: 
#line 1172
  inx = 3;
#line 1173
  goto ldv_53596;
  case 11: 
#line 1175
  inx = 2;
#line 1176
  goto ldv_53596;
  case 4: 
#line 1178
  inx = 1;
#line 1179
  goto ldv_53596;
  case 2: 
#line 1181
  inx = 0;
#line 1182
  goto ldv_53596;
  }
  ldv_53596: ;
#line 1184
  return (inx);
}
}
#line 1187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
unsigned int update_basic_rate23a(unsigned char *ptn , unsigned int ptn_sz ) 
{ 
  unsigned int i ;
  unsigned int num_of_rate ;
  unsigned int mask ;
  int tmp ;

  {
#line 1190
  mask = 0U;
#line 1192
  num_of_rate = 13U < ptn_sz ? 13U : ptn_sz;
#line 1194
  i = 0U;
#line 1194
  goto ldv_53616;
  ldv_53615: ;
#line 1195
  if ((int )((signed char )*(ptn + (unsigned long )i)) < 0) {
#line 1196
    tmp = wifirate2_ratetbl_inx23a((int )*(ptn + (unsigned long )i));
#line 1196
    mask = (unsigned int )(1 << tmp) | mask;
  } else {

  }
#line 1194
  i = i + 1U;
  ldv_53616: ;
#line 1194
  if (i < num_of_rate) {
#line 1196
    goto ldv_53615;
  } else {

  }

#line 1198
  return (mask);
}
}
#line 1201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
unsigned int update_supported_rate23a(unsigned char *ptn , unsigned int ptn_sz ) 
{ 
  unsigned int i ;
  unsigned int num_of_rate ;
  unsigned int mask ;
  int tmp ;

  {
#line 1204
  mask = 0U;
#line 1206
  num_of_rate = 13U < ptn_sz ? 13U : ptn_sz;
#line 1208
  i = 0U;
#line 1208
  goto ldv_53626;
  ldv_53625: 
#line 1209
  tmp = wifirate2_ratetbl_inx23a((int )*(ptn + (unsigned long )i));
#line 1209
  mask = (unsigned int )(1 << tmp) | mask;
#line 1208
  i = i + 1U;
  ldv_53626: ;
#line 1208
  if (i < num_of_rate) {
#line 1210
    goto ldv_53625;
  } else {

  }

#line 1210
  return (mask);
}
}
#line 1213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
unsigned int update_MSC_rate23a(struct ieee80211_ht_cap *pHT_caps ) 
{ 
  unsigned int mask ;

  {
#line 1215
  mask = 0U;
#line 1217
  mask = (unsigned int )(((int )pHT_caps->mcs.rx_mask[0] << 12) | ((int )pHT_caps->mcs.rx_mask[1] << 20));
#line 1220
  return (mask);
}
}
#line 1223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
int support_short_GI23a(struct rtw_adapter *padapter , struct ieee80211_ht_cap *pHT_caps ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned char bit_offset ;

  {
#line 1226
  pmlmeext = & padapter->mlmeextpriv;
#line 1227
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1230
  if ((unsigned int )pmlmeinfo->HT_enable == 0U) {
#line 1231
    return (0);
  } else {

  }
#line 1232
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 4U) {
#line 1233
    return (0);
  } else {

  }
#line 1234
  bit_offset = (int )pmlmeext->cur_bwmode & 1 ? 6U : 5U;
#line 1236
  if ((unsigned int )((int )pHT_caps->cap_info & (int )((unsigned short )(1 << (int )bit_offset))) != 0U) {
#line 1237
    return (1);
  } else {
#line 1239
    return (0);
  }
}
}
#line 1242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
unsigned char get_highest_rate_idx23a(u32 mask ) 
{ 
  int i ;
  unsigned char rate_idx ;

  {
#line 1245
  rate_idx = 0U;
#line 1247
  i = 27;
#line 1247
  goto ldv_53646;
  ldv_53645: ;
#line 1248
  if ((int )((unsigned long )mask >> i) & 1) {
#line 1249
    rate_idx = (unsigned char )i;
#line 1250
    goto ldv_53644;
  } else {

  }
#line 1247
  i = i - 1;
  ldv_53646: ;
#line 1247
  if (i >= 0) {
#line 1249
    goto ldv_53645;
  } else {

  }
  ldv_53644: ;
#line 1253
  return (rate_idx);
}
}
#line 1256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void Update_RA_Entry23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 


  {
#line 1258
  rtw_hal_update_ra_mask23a(psta, 0);
#line 1259
  return;
}
}
#line 1261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
static void enable_rate_adaptive(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 


  {
#line 1264
  Update_RA_Entry23a(padapter, psta);
#line 1265
  return;
}
}
#line 1267 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void set_sta_rate23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 


  {
#line 1270
  enable_rate_adaptive(padapter, psta);
#line 1271
  return;
}
}
#line 1274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void update_tx_basic_rate23a(struct rtw_adapter *padapter , u8 wirelessmode ) 
{ 
  unsigned char supported_rates[16U] ;

  {
#line 1278
  memset((void *)(& supported_rates), 0, 16UL);
#line 1280
  if ((unsigned int )wirelessmode == 1U) {
#line 1281
    memcpy((void *)(& supported_rates), (void const   *)(& rtw_basic_rate_cck),
             4UL);
  } else
#line 1282
  if ((int )wirelessmode & 1) {
#line 1283
    memcpy((void *)(& supported_rates), (void const   *)(& rtw_basic_rate_mix),
             7UL);
  } else {
#line 1285
    memcpy((void *)(& supported_rates), (void const   *)(& rtw_basic_rate_ofdm),
             3UL);
  }
#line 1288
  if ((int )wirelessmode & 1) {
#line 1289
    update_mgnt_tx_rate23a(padapter, 2);
  } else {
#line 1291
    update_mgnt_tx_rate23a(padapter, 12);
  }
#line 1293
  HalSetBrateCfg23a(padapter, (u8 *)(& supported_rates));
#line 1294
  return;
}
}
#line 1296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
unsigned char check_assoc_AP23a(u8 *pframe , uint len ) 
{ 
  int i ;
  u8 epigram_vendor_flag ;
  u8 ralink_vendor_flag ;
  u8 const   *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1303
  epigram_vendor_flag = 0U;
#line 1304
  ralink_vendor_flag = 0U;
#line 1306
  i = 0;
#line 1306
  goto ldv_53676;
  ldv_53675: 
#line 1307
  p = (u8 const   *)pframe + (unsigned long )i;
#line 1309
  switch ((int )*p) {
  case 221: 
#line 1311
  tmp___7 = memcmp((void const   *)p + 2U, (void const   *)(& ARTHEROS_OUI1), 3UL);
#line 1311
  if (tmp___7 == 0) {
#line 1311
    goto _L___0;
  } else {
#line 1311
    tmp___8 = memcmp((void const   *)p + 2U, (void const   *)(& ARTHEROS_OUI2), 3UL);
#line 1311
    if (tmp___8 == 0) {
      _L___0: /* CIL Label */ 
#line 1313
      if (GlobalDebugLevel23A > 3U) {
#line 1313
        printk("\016RTL8723AU: link to Artheros AP\n");
      } else {

      }
#line 1314
      return (5U);
    } else {
#line 1315
      tmp___5 = memcmp((void const   *)p + 2U, (void const   *)(& BROADCOM_OUI1),
                       3UL);
#line 1315
      if (tmp___5 == 0) {
#line 1315
        goto _L;
      } else {
#line 1315
        tmp___6 = memcmp((void const   *)p + 2U, (void const   *)(& BROADCOM_OUI2),
                         3UL);
#line 1315
        if (tmp___6 == 0) {
          _L: /* CIL Label */ 
#line 1317
          if (GlobalDebugLevel23A > 3U) {
#line 1317
            printk("\016RTL8723AU: link to Broadcom AP\n");
          } else {

          }
#line 1318
          return (3U);
        } else {
#line 1319
          tmp___4 = memcmp((void const   *)p + 2U, (void const   *)(& MARVELL_OUI),
                           3UL);
#line 1319
          if (tmp___4 == 0) {
#line 1320
            if (GlobalDebugLevel23A > 3U) {
#line 1320
              printk("\016RTL8723AU: link to Marvell AP\n");
            } else {

            }
#line 1321
            return (8U);
          } else {
#line 1322
            tmp___3 = memcmp((void const   *)p + 2U, (void const   *)(& RALINK_OUI),
                             3UL);
#line 1322
            if (tmp___3 == 0) {
#line 1323
              if ((unsigned int )ralink_vendor_flag == 0U) {
#line 1324
                ralink_vendor_flag = 1U;
              } else {
#line 1326
                if (GlobalDebugLevel23A > 3U) {
#line 1326
                  printk("\016RTL8723AU: link to Ralink AP\n");
                } else {

                }
#line 1327
                return (4U);
              }
            } else {
#line 1329
              tmp___2 = memcmp((void const   *)p + 2U, (void const   *)(& CISCO_OUI),
                               3UL);
#line 1329
              if (tmp___2 == 0) {
#line 1330
                if (GlobalDebugLevel23A > 3U) {
#line 1330
                  printk("\016RTL8723AU: link to Cisco AP\n");
                } else {

                }
#line 1331
                return (6U);
              } else {
#line 1332
                tmp___1 = memcmp((void const   *)p + 2U, (void const   *)(& REALTEK_OUI),
                                 3UL);
#line 1332
                if (tmp___1 == 0) {
#line 1333
                  if (GlobalDebugLevel23A > 3U) {
#line 1333
                    printk("\016RTL8723AU: link to Realtek 96B\n");
                  } else {

                  }
#line 1334
                  return (1U);
                } else {
#line 1335
                  tmp___0 = memcmp((void const   *)p + 2U, (void const   *)(& AIRGOCAP_OUI),
                                   3UL);
#line 1335
                  if (tmp___0 == 0) {
#line 1336
                    if (GlobalDebugLevel23A > 3U) {
#line 1336
                      printk("\016RTL8723AU: link to Airgo Cap\n");
                    } else {

                    }
#line 1337
                    return (11U);
                  } else {
#line 1338
                    tmp = memcmp((void const   *)p + 2U, (void const   *)(& EPIGRAM_OUI),
                                 3UL);
#line 1338
                    if (tmp == 0) {
#line 1339
                      epigram_vendor_flag = 1U;
#line 1340
                      if ((unsigned int )ralink_vendor_flag != 0U) {
#line 1341
                        if (GlobalDebugLevel23A > 3U) {
#line 1341
                          printk("\016RTL8723AU: link to Tenda W311R AP\n");
                        } else {

                        }
#line 1342
                        return (16U);
                      } else
#line 1344
                      if (GlobalDebugLevel23A > 3U) {
#line 1344
                        printk("\016RTL8723AU: Capture EPIGRAM_OUI\n");
                      } else {

                      }
                    } else {
#line 1346
                      goto ldv_53673;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  default: ;
#line 1348
  goto ldv_53673;
  }
  ldv_53673: 
#line 1351
  i = ((int )*(p + 1UL) + 2) + i;
  ldv_53676: ;
#line 1306
  if ((uint )i < len) {
#line 1308
    goto ldv_53675;
  } else {

  }

#line 1354
  if ((unsigned int )ralink_vendor_flag != 0U && (unsigned int )epigram_vendor_flag == 0U) {
#line 1355
    if (GlobalDebugLevel23A > 3U) {
#line 1355
      printk("\016RTL8723AU: link to Ralink AP\n");
    } else {

    }
#line 1356
    return (4U);
  } else
#line 1357
  if ((unsigned int )ralink_vendor_flag != 0U && (unsigned int )epigram_vendor_flag != 0U) {
#line 1358
    if (GlobalDebugLevel23A > 3U) {
#line 1358
      printk("\016RTL8723AU: link to Tenda W311R AP\n");
    } else {

    }
#line 1359
    return (16U);
  } else {
#line 1361
    if (GlobalDebugLevel23A > 3U) {
#line 1361
      printk("\016RTL8723AU: link to new AP\n");
    } else {

    }
#line 1362
    return (0U);
  }
}
}
#line 1366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void update_IOT_info23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 1368
  pmlmeext = & padapter->mlmeextpriv;
#line 1369
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1371
  switch ((int )pmlmeinfo->assoc_AP_vendor) {
  case 8: 
#line 1373
  pmlmeinfo->turboMode_cts2self = 1U;
#line 1374
  pmlmeinfo->turboMode_rtsen = 0U;
#line 1375
  goto ldv_53684;
  case 4: 
#line 1377
  pmlmeinfo->turboMode_cts2self = 0U;
#line 1378
  pmlmeinfo->turboMode_rtsen = 1U;
#line 1380
  rtl8723a_odm_support_ability_clr(padapter, 4294967291U);
#line 1382
  goto ldv_53684;
  case 1: 
#line 1387
  rtl8723a_odm_support_ability_clr(padapter, 4294967291U);
#line 1389
  goto ldv_53684;
  default: 
#line 1391
  pmlmeinfo->turboMode_cts2self = 0U;
#line 1392
  pmlmeinfo->turboMode_rtsen = 1U;
#line 1393
  goto ldv_53684;
  }
  ldv_53684: ;
#line 1396
  return;
}
}
#line 1397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void update_capinfo23a(struct rtw_adapter *Adapter , u16 updateCap ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 1399
  pmlmeext = & Adapter->mlmeextpriv;
#line 1400
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1402
  if (((int )updateCap & 32) != 0) {
#line 1404
    if ((unsigned int )pmlmeinfo->preamble_mode != 3U) {
#line 1406
      pmlmeinfo->preamble_mode = 3U;
#line 1407
      rtl8723a_ack_preamble(Adapter, 1);
    } else {

    }
  } else
#line 1410
  if ((unsigned int )pmlmeinfo->preamble_mode != 1U) {
#line 1412
    pmlmeinfo->preamble_mode = 1U;
#line 1413
    rtl8723a_ack_preamble(Adapter, 0);
  } else {

  }
#line 1416
  if (((int )updateCap & 2) != 0) {
#line 1418
    pmlmeinfo->slotTime = 20U;
  } else
#line 1421
  if (((int )pmlmeext->cur_wireless_mode & 10) != 0) {
#line 1423
    if (((int )updateCap & 1024) != 0) {
#line 1424
      if ((unsigned int )pmlmeinfo->slotTime != 9U) {
#line 1425
        pmlmeinfo->slotTime = 9U;
      } else {

      }
    } else
#line 1427
    if ((unsigned int )pmlmeinfo->slotTime != 20U) {
#line 1428
      pmlmeinfo->slotTime = 20U;
    } else {

    }
  } else
#line 1431
  if (((int )pmlmeext->cur_wireless_mode & 20) != 0) {
#line 1433
    pmlmeinfo->slotTime = 9U;
  } else {
#line 1436
    pmlmeinfo->slotTime = 20U;
  }
#line 1439
  rtl8723a_set_slot_time(Adapter, (int )pmlmeinfo->slotTime);
#line 1440
  return;
}
}
#line 1442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void update_wireless_mode23a(struct rtw_adapter *padapter ) 
{ 
  int ratelen ;
  int network_type ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  unsigned char *rate ;
  uint tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1444
  network_type = 0;
#line 1445
  pmlmeext = & padapter->mlmeextpriv;
#line 1446
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1447
  cur_network = & pmlmeinfo->network;
#line 1448
  rate = (unsigned char *)(& cur_network->SupportedRates);
#line 1450
  tmp = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
#line 1450
  ratelen = (int )tmp;
#line 1452
  if ((unsigned int )pmlmeinfo->HT_info_enable != 0U && (unsigned int )pmlmeinfo->HT_caps_enable != 0U) {
#line 1453
    pmlmeinfo->HT_enable = 1U;
  } else {

  }
#line 1455
  if ((unsigned int )pmlmeext->cur_channel > 14U) {
#line 1456
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
#line 1457
      network_type = 16;
    } else {

    }
#line 1458
    network_type = network_type | 4;
  } else {
#line 1460
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
#line 1461
      network_type = 8;
    } else {

    }
#line 1463
    tmp___1 = cckratesonly_included23a(rate, ratelen);
#line 1463
    if (tmp___1 == 1) {
#line 1464
      network_type = network_type | 1;
    } else {
#line 1465
      tmp___0 = cckrates_included23a(rate, ratelen);
#line 1465
      if (tmp___0 == 1) {
#line 1466
        network_type = network_type | 3;
      } else {
#line 1468
        network_type = network_type | 2;
      }
    }
  }
#line 1471
  pmlmeext->cur_wireless_mode = (unsigned char )((int )((signed char )padapter->registrypriv.wireless_mode) & (int )((signed char )network_type));
#line 1476
  rtl8723a_set_resp_sifs(padapter, 8, 8, 10, 10);
#line 1478
  if ((int )pmlmeext->cur_wireless_mode & 1) {
#line 1479
    update_mgnt_tx_rate23a(padapter, 2);
  } else {
#line 1481
    update_mgnt_tx_rate23a(padapter, 12);
  }
#line 1482
  return;
}
}
#line 1484 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void update_bmc_sta_support_rate23a(struct rtw_adapter *padapter , u32 mac_id ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 1486
  pmlmeext = & padapter->mlmeextpriv;
#line 1487
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1489
  if ((int )pmlmeext->cur_wireless_mode & 1) {
#line 1491
    memcpy((void *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates), (void const   *)(& rtw_basic_rate_cck),
             4UL);
  } else {
#line 1494
    memcpy((void *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates), (void const   *)(& rtw_basic_rate_ofdm),
             3UL);
  }
#line 1495
  return;
}
}
#line 1499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
int update_sta_support_rate23a(struct rtw_adapter *padapter , u8 *pvar_ie , uint var_ie_len ,
                               int cam_idx ) 
{ 
  int supportRateNum ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 const   *p ;

  {
#line 1502
  supportRateNum = 0;
#line 1503
  pmlmeext = & padapter->mlmeextpriv;
#line 1504
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1507
  p = cfg80211_find_ie(1, (u8 const   *)pvar_ie, (int )var_ie_len);
#line 1508
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
#line 1509
    return (0);
  } else {

  }
#line 1511
  memcpy((void *)(& pmlmeinfo->FW_sta_info[cam_idx].SupportedRates), (void const   *)p + 2U,
           (size_t )*(p + 1UL));
#line 1512
  supportRateNum = (int )*(p + 1UL);
#line 1514
  p = cfg80211_find_ie(50, (u8 const   *)pvar_ie, (int )var_ie_len);
#line 1515
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 1516
    memcpy((void *)(& pmlmeinfo->FW_sta_info[cam_idx].SupportedRates) + (unsigned long )supportRateNum,
             (void const   *)p + 2U, (size_t )*(p + 1UL));
  } else {

  }
#line 1518
  return (1);
}
}
#line 1521 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.c"
void process_addba_req23a(struct rtw_adapter *padapter , u8 *paddba_req , u8 *addr ) 
{ 
  struct sta_info *psta ;
  u16 tid ;
  u16 start_seq ;
  u16 param ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct sta_priv *pstapriv ;
  struct ADDBA_request *preq ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 1527
  pstapriv = & padapter->stapriv;
#line 1528
  preq = (struct ADDBA_request *)paddba_req;
#line 1529
  pmlmeext = & padapter->mlmeextpriv;
#line 1530
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1532
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)addr);
#line 1534
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1535
    start_seq = (u16 )((int )preq->BA_starting_seqctrl >> 4);
#line 1537
    param = preq->BA_para_set;
#line 1538
    tid = (unsigned int )((u16 )((int )param >> 2)) & 15U;
#line 1540
    preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )tid;
#line 1542
    preorder_ctrl->indicate_seq = 65535U;
#line 1544
    preorder_ctrl->enable = (u8 )pmlmeinfo->bAcceptAddbaReq;
  } else {

  }
#line 1546
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
bool ldv_queue_work_on_257(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
bool ldv_queue_delayed_work_on_258(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
bool ldv_queue_work_on_259(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void ldv_flush_workqueue_260(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
bool ldv_queue_delayed_work_on_261(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_271(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_273(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_272(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_275(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_274(struct workqueue_struct *ldv_func_arg1 ) ;
#line 122 "drivers/staging/rtl8723au/include/hal_com.h"
u8 hal_com_get_channel_plan23a(struct rtw_adapter *padapter , u8 hw_channel_plan ,
                               u8 sw_channel_plan , u8 def_channel_plan , bool AutoLoadFail ) ;
#line 130
u8 MRateToHwRate23a(u8 rate ) ;
#line 135
bool Hal_MappingOutPipe23a(struct rtw_adapter *pAdapter , u8 NumOutPipe ) ;
#line 144
void rtl8723a_set_media_status1(struct rtw_adapter *padapter , u8 status ) ;
#line 146
void rtl8723a_check_bssid(struct rtw_adapter *padapter , u8 val ) ;
#line 149
void rtl8723a_off_rcr_am(struct rtw_adapter *padapter ) ;
#line 153
void rtl8723a_cam_empty_entry(struct rtw_adapter *padapter , u8 ucIndex ) ;
#line 157
void rtl8723a_fifo_cleanup(struct rtw_adapter *padapter ) ;
#line 24 "drivers/staging/rtl8723au/include/rtl8723a_bt_intf.h"
bool rtl8723a_BT_enabled(struct rtw_adapter *padapter ) ;
#line 817 "drivers/staging/rtl8723au/include/odm.h"
void ODM_Write_DIG23a(struct dm_odm_t *pDM_Odm , u8 CurrentIGI ) ;
#line 514 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
void SetBcnCtrlReg23a(struct rtw_adapter *padapter , u8 SetBits , u8 ClearBits ) ;
#line 37 "drivers/staging/rtl8723au/include/usb_ops_linux.h"
int rtl8723au_write32(struct rtw_adapter *padapter , u16 addr , u32 val ) ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
u8 hal_com_get_channel_plan23a(struct rtw_adapter *padapter , u8 hw_channel_plan ,
                               u8 sw_channel_plan , u8 def_channel_plan , bool AutoLoadFail ) 
{ 
  u8 swConfig ;
  u8 chnlPlan ;

  {
#line 38
  swConfig = 1U;
#line 39
  if (! AutoLoadFail) {
#line 40
    if ((unsigned int )sw_channel_plan > 65U && (unsigned int )sw_channel_plan != 127U) {
#line 41
      swConfig = 0U;
    } else {

    }
#line 42
    if ((int )((signed char )hw_channel_plan) < 0) {
#line 43
      swConfig = 0U;
    } else {

    }
  } else {

  }
#line 46
  if ((unsigned int )swConfig == 1U) {
#line 47
    chnlPlan = sw_channel_plan;
  } else {
#line 49
    chnlPlan = (unsigned int )hw_channel_plan & 127U;
  }
#line 51
  if ((unsigned int )chnlPlan > 65U && (unsigned int )chnlPlan != 127U) {
#line 52
    chnlPlan = def_channel_plan;
  } else {

  }
#line 54
  return (chnlPlan);
}
}
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
u8 MRateToHwRate23a(u8 rate ) 
{ 
  u8 ret ;

  {
#line 59
  ret = 0U;
#line 61
  switch ((int )rate) {
  case 2: 
#line 64
  ret = 0U;
#line 65
  goto ldv_55758;
  case 4: 
#line 67
  ret = 1U;
#line 68
  goto ldv_55758;
  case 11: 
#line 70
  ret = 2U;
#line 71
  goto ldv_55758;
  case 22: 
#line 73
  ret = 3U;
#line 74
  goto ldv_55758;
  case 12: 
#line 76
  ret = 4U;
#line 77
  goto ldv_55758;
  case 18: 
#line 79
  ret = 5U;
#line 80
  goto ldv_55758;
  case 24: 
#line 82
  ret = 6U;
#line 83
  goto ldv_55758;
  case 36: 
#line 85
  ret = 7U;
#line 86
  goto ldv_55758;
  case 48: 
#line 88
  ret = 8U;
#line 89
  goto ldv_55758;
  case 72: 
#line 91
  ret = 9U;
#line 92
  goto ldv_55758;
  case 96: 
#line 94
  ret = 10U;
#line 95
  goto ldv_55758;
  case 108: 
#line 97
  ret = 11U;
#line 98
  goto ldv_55758;
  default: ;
#line 111
  goto ldv_55758;
  }
  ldv_55758: ;
#line 113
  return (ret);
}
}
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void HalSetBrateCfg23a(struct rtw_adapter *padapter , u8 *mBratesOS ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 i ;
  u8 is_brate ;
  u8 brate ;
  u16 brate_cfg ;
  u8 rate_index ;
  u8 tmp ;

  {
#line 118
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 120
  brate_cfg = 0U;
#line 123
  i = 0U;
#line 123
  goto ldv_55795;
  ldv_55794: 
#line 124
  is_brate = (unsigned int )*(mBratesOS + (unsigned long )i) & 128U;
#line 125
  brate = (unsigned int )*(mBratesOS + (unsigned long )i) & 127U;
#line 127
  if ((unsigned int )is_brate != 0U) {
#line 128
    switch ((int )brate) {
    case 2: 
#line 130
    brate_cfg = (u16 )((unsigned int )brate_cfg | 1U);
#line 131
    goto ldv_55782;
    case 4: 
#line 133
    brate_cfg = (u16 )((unsigned int )brate_cfg | 2U);
#line 134
    goto ldv_55782;
    case 11: 
#line 136
    brate_cfg = (u16 )((unsigned int )brate_cfg | 4U);
#line 137
    goto ldv_55782;
    case 22: 
#line 139
    brate_cfg = (u16 )((unsigned int )brate_cfg | 8U);
#line 140
    goto ldv_55782;
    case 12: 
#line 142
    brate_cfg = (u16 )((unsigned int )brate_cfg | 16U);
#line 143
    goto ldv_55782;
    case 18: 
#line 145
    brate_cfg = (u16 )((unsigned int )brate_cfg | 32U);
#line 146
    goto ldv_55782;
    case 24: 
#line 148
    brate_cfg = (u16 )((unsigned int )brate_cfg | 64U);
#line 149
    goto ldv_55782;
    case 36: 
#line 151
    brate_cfg = (u16 )((unsigned int )brate_cfg | 128U);
#line 152
    goto ldv_55782;
    case 48: 
#line 154
    brate_cfg = (u16 )((unsigned int )brate_cfg | 256U);
#line 155
    goto ldv_55782;
    case 72: 
#line 157
    brate_cfg = (u16 )((unsigned int )brate_cfg | 512U);
#line 158
    goto ldv_55782;
    case 96: 
#line 160
    brate_cfg = (u16 )((unsigned int )brate_cfg | 1024U);
#line 161
    goto ldv_55782;
    case 108: 
#line 163
    brate_cfg = (u16 )((unsigned int )brate_cfg | 2048U);
#line 164
    goto ldv_55782;
    }
    ldv_55782: ;
  } else {

  }
#line 123
  i = (u8 )((int )i + 1);
  ldv_55795: ;
#line 123
  if ((unsigned int )i <= 15U) {
#line 125
    goto ldv_55794;
  } else {

  }
#line 180
  brate_cfg = ((unsigned int )brate_cfg & 336U) | 13U;
#line 181
  pHalData->BasicRateSet = brate_cfg;
#line 182
  brate_cfg = (u16 )((unsigned int )brate_cfg | 1U);
#line 183
  if (GlobalDebugLevel23A > 3U) {
#line 183
    printk("\016RTL8723AU: HW_VAR_BASIC_RATE: BrateCfg(%#x)\n", (int )brate_cfg);
  } else {

  }
#line 186
  rtl8723au_write8(padapter, 1088, (int )((u8 )brate_cfg));
#line 187
  rtl8723au_write8(padapter, 1089, (int )((u8 )((int )brate_cfg >> 8)));
#line 188
  tmp = rtl8723au_read8(padapter, 1090);
#line 188
  rtl8723au_write8(padapter, 1090, (int )tmp & 240);
#line 191
  rate_index = 0U;
#line 193
  goto ldv_55798;
  ldv_55797: 
#line 194
  brate_cfg = (u16 )((int )brate_cfg >> 1);
#line 195
  rate_index = (u8 )((int )rate_index + 1);
  ldv_55798: ;
#line 193
  if ((unsigned int )brate_cfg > 1U) {
#line 195
    goto ldv_55797;
  } else {

  }
#line 198
  rtl8723au_write8(padapter, 1152, (int )rate_index);
#line 199
  return;
}
}
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
static void _OneOutPipeMapping(struct rtw_adapter *pAdapter ) 
{ 
  struct dvobj_priv *pdvobjpriv ;

  {
#line 203
  pdvobjpriv = pAdapter->dvobj;
#line 205
  pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 206
  pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 207
  pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 208
  pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 210
  pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 211
  pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 212
  pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 213
  pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 214
  return;
}
}
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
static void _TwoOutPipeMapping(struct rtw_adapter *pAdapter , bool bWIFICfg ) 
{ 
  struct dvobj_priv *pdvobjpriv ;

  {
#line 218
  pdvobjpriv = pAdapter->dvobj;
#line 220
  if ((int )bWIFICfg) {
#line 224
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[1];
#line 225
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 226
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[1];
#line 227
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 229
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 230
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 231
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 232
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  } else {
#line 237
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 238
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 239
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[1];
#line 240
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[1];
#line 242
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 243
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 244
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 245
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  }
#line 247
  return;
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
static void _ThreeOutPipeMapping(struct rtw_adapter *pAdapter , bool bWIFICfg ) 
{ 
  struct dvobj_priv *pdvobjpriv ;

  {
#line 251
  pdvobjpriv = pAdapter->dvobj;
#line 253
  if ((int )bWIFICfg) {
#line 257
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 258
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[1];
#line 259
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[2];
#line 260
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[1];
#line 262
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 263
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 264
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 265
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  } else {
#line 270
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 271
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[1];
#line 272
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[2];
#line 273
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[2];
#line 275
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 276
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 277
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 278
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  }
#line 280
  return;
}
}
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
bool Hal_MappingOutPipe23a(struct rtw_adapter *pAdapter , u8 NumOutPipe ) 
{ 
  struct registry_priv *pregistrypriv ;
  bool bWIFICfg ;
  bool result ;

  {
#line 284
  pregistrypriv = & pAdapter->registrypriv;
#line 285
  bWIFICfg = (unsigned int )pregistrypriv->wifi_spec != 0U;
#line 286
  result = 1;
#line 288
  switch ((int )NumOutPipe) {
  case 2: 
#line 290
  _TwoOutPipeMapping(pAdapter, (int )bWIFICfg);
#line 291
  goto ldv_55822;
  case 3: 
#line 293
  _ThreeOutPipeMapping(pAdapter, (int )bWIFICfg);
#line 294
  goto ldv_55822;
  case 1: 
#line 296
  _OneOutPipeMapping(pAdapter);
#line 297
  goto ldv_55822;
  default: 
#line 299
  result = 0;
#line 300
  goto ldv_55822;
  }
  ldv_55822: ;
#line 303
  return (result);
}
}
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void c2h_evt_clear23a(struct rtw_adapter *adapter ) 
{ 


  {
#line 314
  rtl8723au_write8(adapter, 431, 0);
#line 315
  return;
}
}
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
s32 c2h_evt_read23a(struct rtw_adapter *adapter , u8 *buf ) 
{ 
  int ret ;
  struct c2h_evt_hdr *c2h_evt ;
  int i ;
  u8 trigger ;
  int __i ;
  u8 *ptr ;
  int __i___0 ;
  u8 *ptr___0 ;

  {
#line 319
  ret = 0;
#line 324
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
#line 325
    goto exit;
  } else {

  }
#line 327
  trigger = rtl8723au_read8(adapter, 431);
#line 329
  if ((unsigned int )trigger == 0U) {
#line 330
    goto exit;
  } else
#line 331
  if ((unsigned int )trigger != 255U) {
#line 332
    goto clear_evt;
  } else {

  }
#line 334
  c2h_evt = (struct c2h_evt_hdr *)buf;
#line 336
  memset((void *)c2h_evt, 0, 16UL);
#line 338
  *buf = rtl8723au_read8(adapter, 416);
#line 339
  *(buf + 1UL) = rtl8723au_read8(adapter, 417);
#line 341
  if (GlobalDebugLevel23A > 6U) {
#line 341
    ptr = (u8 *)(& c2h_evt);
#line 341
    printk("\016%s", (char *)"RTL8723AU: ");
#line 341
    printk("\016c2h_evt_read23a(): ");
#line 341
    __i = 0;
#line 341
    goto ldv_55842;
    ldv_55841: 
#line 341
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((unsigned int )(__i + 1) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 341
    if (((unsigned int )(__i + 1) & 15U) == 0U) {
#line 341
      printk("\n");
    } else {

    }
#line 341
    __i = __i + 1;
    ldv_55842: ;
#line 341
    if (__i <= 7) {
#line 343
      goto ldv_55841;
    } else {

    }
#line 341
    printk("\n");
  } else {

  }
#line 351
  i = 0;
#line 351
  goto ldv_55846;
  ldv_55845: 
#line 352
  c2h_evt->payload[i] = rtl8723au_read8(adapter, (int )((unsigned int )((u16 )i) + 418U));
#line 351
  i = i + 1;
  ldv_55846: ;
#line 351
  if ((int )c2h_evt->plen > i) {
#line 353
    goto ldv_55845;
  } else {

  }

#line 356
  if (GlobalDebugLevel23A > 6U) {
#line 356
    ptr___0 = (u8 *)(& c2h_evt->payload);
#line 356
    printk("\016%s", (char *)"RTL8723AU: ");
#line 356
    printk("\016c2h_evt_read23a(): Command Content:\n");
#line 356
    __i___0 = 0;
#line 356
    goto ldv_55851;
    ldv_55850: 
#line 356
    printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((unsigned int )(__i___0 + 1) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 356
    if (((unsigned int )(__i___0 + 1) & 15U) == 0U) {
#line 356
      printk("\n");
    } else {

    }
#line 356
    __i___0 = __i___0 + 1;
    ldv_55851: ;
#line 356
    if ((int )c2h_evt->plen > __i___0) {
#line 358
      goto ldv_55850;
    } else {

    }
#line 356
    printk("\n");
  } else {

  }
#line 360
  ret = 1;
  clear_evt: 
#line 368
  c2h_evt_clear23a(adapter);
  exit: ;
#line 370
  return (ret);
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_ampdu_min_space(struct rtw_adapter *padapter , u8 MinSpacingToSet ) 
{ 
  u8 SecMinSpace ;
  u8 tmp ;

  {
#line 378
  if ((unsigned int )MinSpacingToSet <= 7U) {
#line 379
    switch (padapter->securitypriv.dot11PrivacyAlgrthm) {
    case 0U: ;
    case 1027076U: 
#line 382
    SecMinSpace = 0U;
#line 383
    goto ldv_55860;
    case 1027073U: ;
    case 1027077U: ;
    case 1027074U: 
#line 388
    SecMinSpace = 6U;
#line 389
    goto ldv_55860;
    default: 
#line 391
    SecMinSpace = 7U;
#line 392
    goto ldv_55860;
    }
    ldv_55860: ;
#line 395
    if ((int )MinSpacingToSet < (int )SecMinSpace) {
#line 396
      MinSpacingToSet = SecMinSpace;
    } else {

    }
#line 398
    tmp = rtl8723au_read8(padapter, 1116);
#line 398
    MinSpacingToSet = (u8 )(((int )((signed char )tmp) & -8) | (int )((signed char )MinSpacingToSet));
#line 400
    rtl8723au_write8(padapter, 1116, (int )MinSpacingToSet);
  } else {

  }
#line 402
  return;
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_ampdu_factor(struct rtw_adapter *padapter , u8 FactorToSet ) 
{ 
  u8 RegToSet_Normal[4U] ;
  u8 MaxAggNum ;
  u8 *pRegToSet ;
  u8 index ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 407
  RegToSet_Normal[0] = 65U;
#line 407
  RegToSet_Normal[1] = 168U;
#line 407
  RegToSet_Normal[2] = 114U;
#line 407
  RegToSet_Normal[3] = 185U;
#line 410
  index = 0U;
#line 412
  pRegToSet = (u8 *)(& RegToSet_Normal);
#line 414
  tmp = rtl8723a_BT_enabled(padapter);
#line 414
  if ((int )tmp) {
#line 414
    tmp___0 = rtl8723a_BT_using_antenna_1(padapter);
#line 414
    if ((int )tmp___0) {
#line 416
      MaxAggNum = 8U;
    } else {
#line 418
      MaxAggNum = 15U;
    }
  } else {
#line 418
    MaxAggNum = 15U;
  }
#line 420
  if ((unsigned int )FactorToSet <= 3U) {
#line 421
    FactorToSet = (u8 )(1 << ((int )FactorToSet + 2));
#line 422
    if ((int )FactorToSet > (int )MaxAggNum) {
#line 423
      FactorToSet = MaxAggNum;
    } else {

    }
#line 425
    index = 0U;
#line 425
    goto ldv_55874;
    ldv_55873: ;
#line 426
    if (((int )*(pRegToSet + (unsigned long )index) & 240) > (int )FactorToSet << 4) {
#line 427
      *(pRegToSet + (unsigned long )index) = (u8 )(((int )((signed char )*(pRegToSet + (unsigned long )index)) & 15) | (int )((signed char )((int )FactorToSet << 4)));
    } else {

    }
#line 430
    if (((int )*(pRegToSet + (unsigned long )index) & 15) > (int )FactorToSet) {
#line 431
      *(pRegToSet + (unsigned long )index) = (u8 )(((int )((signed char )*(pRegToSet + (unsigned long )index)) & -16) | (int )((signed char )FactorToSet));
    } else {

    }
#line 434
    rtl8723au_write8(padapter, (int )((unsigned int )((u16 )index) + 1112U), (int )*(pRegToSet + (unsigned long )index));
#line 425
    index = (u8 )((int )index + 1);
    ldv_55874: ;
#line 425
    if ((unsigned int )index <= 3U) {
#line 427
      goto ldv_55873;
    } else {

    }

  } else {

  }
#line 433
  return;
}
}
#line 440 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_acm_ctrl(struct rtw_adapter *padapter , u8 ctrl ) 
{ 
  u8 hwctrl ;

  {
#line 442
  hwctrl = 0U;
#line 444
  if ((unsigned int )ctrl != 0U) {
#line 445
    hwctrl = (u8 )((unsigned int )hwctrl | 1U);
#line 447
    if (((unsigned long )ctrl & 2UL) != 0UL) {
#line 448
      hwctrl = (u8 )((unsigned int )hwctrl | 2U);
    } else {

    }
#line 450
    if (((unsigned long )ctrl & 4UL) != 0UL) {
#line 451
      hwctrl = (u8 )((unsigned int )hwctrl | 4U);
    } else {

    }
#line 453
    if (((unsigned long )ctrl & 8UL) != 0UL) {
#line 454
      hwctrl = (u8 )((unsigned int )hwctrl | 8U);
    } else {

    }
  } else {

  }
#line 457
  if (GlobalDebugLevel23A > 3U) {
#line 457
    printk("\016RTL8723AU: [HW_VAR_ACM_CTRL] Write 0x%02X\n", (int )hwctrl);
  } else {

  }
#line 458
  rtl8723au_write8(padapter, 1472, (int )hwctrl);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_media_status(struct rtw_adapter *padapter , u8 status ) 
{ 
  u8 val8 ;
  u8 tmp ;

  {
#line 465
  tmp = rtl8723au_read8(padapter, 258);
#line 465
  val8 = (unsigned int )tmp & 12U;
#line 466
  val8 = (u8 )((int )val8 | (int )status);
#line 467
  rtl8723au_write8(padapter, 258, (int )val8);
#line 468
  return;
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_media_status1(struct rtw_adapter *padapter , u8 status ) 
{ 
  u8 val8 ;
  u8 tmp ;

  {
#line 474
  tmp = rtl8723au_read8(padapter, 258);
#line 474
  val8 = (unsigned int )tmp & 3U;
#line 475
  val8 = (u8 )((int )((signed char )((int )status << 2)) | (int )((signed char )val8));
#line 476
  rtl8723au_write8(padapter, 258, (int )val8);
#line 477
  return;
}
}
#line 479 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_bcn_func(struct rtw_adapter *padapter , u8 val ) 
{ 


  {
#line 481
  if ((unsigned int )val != 0U) {
#line 482
    SetBcnCtrlReg23a(padapter, 12, 0);
  } else {
#line 484
    SetBcnCtrlReg23a(padapter, 0, 12);
  }
#line 485
  return;
}
}
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_check_bssid(struct rtw_adapter *padapter , u8 val ) 
{ 
  u32 val32 ;

  {
#line 491
  val32 = rtl8723au_read32(padapter, 1544);
#line 492
  if ((unsigned int )val != 0U) {
#line 493
    val32 = val32 | 192U;
  } else {
#line 495
    val32 = val32 & 4294967103U;
  }
#line 496
  rtl8723au_write32(padapter, 1544, val32);
#line 497
  return;
}
}
#line 499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_mlme_sitesurvey(struct rtw_adapter *padapter , u8 flag ) 
{ 
  u32 v32 ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u32 v32___0 ;
  bool tmp ;

  {
#line 501
  if ((unsigned int )flag != 0U) {
#line 506
    v32 = rtl8723au_read32(padapter, 1544);
#line 507
    v32 = v32 & 4294967167U;
#line 508
    rtl8723au_write32(padapter, 1544, v32);
#line 510
    rtl8723au_write16(padapter, 1700, 0);
#line 513
    SetBcnCtrlReg23a(padapter, 16, 0);
  } else {
#line 516
    pmlmeext = & padapter->mlmeextpriv;
#line 520
    pmlmeinfo = & pmlmeext->mlmext_info;
#line 522
    tmp = is_client_associated_to_ap23a(padapter);
#line 522
    if (((int )tmp || (pmlmeinfo->state & 3U) == 1U) || (pmlmeinfo->state & 3U) == 3U) {
#line 526
      rtl8723au_write16(padapter, 1700, 65535);
#line 529
      SetBcnCtrlReg23a(padapter, 0, 16);
    } else {

    }
#line 532
    v32___0 = rtl8723au_read32(padapter, 1544);
#line 533
    v32___0 = v32___0 | 128U;
#line 534
    rtl8723au_write32(padapter, 1544, v32___0);
  }
#line 537
  rtl8723a_BT_wifiscan_notify(padapter, (unsigned int )flag != 0U);
#line 538
  return;
}
}
#line 540 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_on_rcr_am(struct rtw_adapter *padapter ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 542
  tmp = rtl8723au_read32(padapter, 1544);
#line 542
  rtl8723au_write32(padapter, 1544, tmp | 4U);
#line 544
  if (GlobalDebugLevel23A > 3U) {
#line 544
    tmp___0 = rtl8723au_read32(padapter, 1544);
#line 544
    printk("\016RTL8723AU: %s, %d, RCR = %x\n", "rtl8723a_on_rcr_am", 545, tmp___0);
  } else {

  }
#line 545
  return;
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_off_rcr_am(struct rtw_adapter *padapter ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 550
  tmp = rtl8723au_read32(padapter, 1544);
#line 550
  rtl8723au_write32(padapter, 1544, tmp & 4294967291U);
#line 552
  if (GlobalDebugLevel23A > 3U) {
#line 552
    tmp___0 = rtl8723au_read32(padapter, 1544);
#line 552
    printk("\016RTL8723AU: %s, %d, RCR = %x\n", "rtl8723a_off_rcr_am", 553, tmp___0);
  } else {

  }
#line 553
  return;
}
}
#line 556 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_slot_time(struct rtw_adapter *padapter , u8 slottime ) 
{ 
  u8 u1bAIFS ;
  u8 aSifsTime ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 559
  pmlmeext = & padapter->mlmeextpriv;
#line 560
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 562
  rtl8723au_write8(padapter, 1307, (int )slottime);
#line 564
  if ((unsigned int )pmlmeinfo->WMM_enable == 0U) {
#line 565
    if ((unsigned int )pmlmeext->cur_wireless_mode == 1U) {
#line 566
      aSifsTime = 10U;
    } else {
#line 568
      aSifsTime = 16U;
    }
#line 570
    u1bAIFS = (unsigned int )pmlmeinfo->slotTime * 2U + (unsigned int )aSifsTime;
#line 573
    rtl8723au_write8(padapter, 1280, (int )u1bAIFS);
#line 574
    rtl8723au_write8(padapter, 1284, (int )u1bAIFS);
#line 575
    rtl8723au_write8(padapter, 1288, (int )u1bAIFS);
#line 576
    rtl8723au_write8(padapter, 1292, (int )u1bAIFS);
  } else {

  }
#line 578
  return;
}
}
#line 580 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_ack_preamble(struct rtw_adapter *padapter , u8 bShortPreamble ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 regTmp ;

  {
#line 582
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 587
  regTmp = (int )pHalData->nCur40MhzPrimeSC << 5U;
#line 589
  if ((unsigned int )bShortPreamble != 0U) {
#line 590
    regTmp = (u8 )((unsigned int )regTmp | 128U);
  } else {

  }
#line 591
  rtl8723au_write8(padapter, 1090, (int )regTmp);
#line 592
  return;
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_sec_cfg(struct rtw_adapter *padapter , u8 sec ) 
{ 


  {
#line 596
  rtl8723au_write8(padapter, 1664, (int )sec);
#line 597
  return;
}
}
#line 599 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_cam_empty_entry(struct rtw_adapter *padapter , u8 ucIndex ) 
{ 
  u8 i ;
  u32 ulCommand ;
  u32 ulContent ;
  u32 ulEncAlgo ;

  {
#line 602
  ulCommand = 0U;
#line 603
  ulContent = 0U;
#line 604
  ulEncAlgo = 4U;
#line 606
  i = 0U;
#line 606
  goto ldv_55943;
  ldv_55942: ;
#line 608
  if ((unsigned int )i == 0U) {
#line 609
    ulContent = (u32 )(((int )ucIndex & 3) | ((int )((unsigned short )ulEncAlgo) << 2)) | ulContent;
  } else {
#line 613
    ulContent = 0U;
  }
#line 616
  ulCommand = (u32 )((int )ucIndex * 8 + (int )i);
#line 617
  ulCommand = ulCommand | 2147549184U;
#line 620
  rtl8723au_write32(padapter, 1652, ulContent);
#line 622
  rtl8723au_write32(padapter, 1648, ulCommand);
#line 606
  i = (u8 )((int )i + 1);
  ldv_55943: ;
#line 606
  if ((unsigned int )i <= 7U) {
#line 608
    goto ldv_55942;
  } else {

  }

#line 613
  return;
}
}
#line 626 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_cam_invalidate_all(struct rtw_adapter *padapter ) 
{ 


  {
#line 628
  rtl8723au_write32(padapter, 1648, 3221225472U);
#line 629
  return;
}
}
#line 631 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_cam_write(struct rtw_adapter *padapter , u8 entry , u16 ctrl , u8 const   *mac ,
                        u8 const   *key ) 
{ 
  u32 cmd ;
  unsigned int i ;
  unsigned int val ;
  unsigned int addr ;
  int j ;

  {
#line 638
  addr = (unsigned int )((int )entry << 3);
#line 640
  j = 5;
#line 640
  goto ldv_55965;
  ldv_55964: ;
#line 641
  switch (j) {
  case 0: 
#line 643
  val = (unsigned int )(((int )ctrl | ((int )*mac << 16)) | ((int )*(mac + 1UL) << 24));
#line 644
  goto ldv_55961;
  case 1: 
#line 646
  val = (unsigned int )((((int )*(mac + 2UL) | ((int )*(mac + 3UL) << 8)) | ((int )*(mac + 4UL) << 16)) | ((int )*(mac + 5UL) << 24));
#line 648
  goto ldv_55961;
  default: 
#line 650
  i = (unsigned int )((j + -2) << 2);
#line 651
  val = (unsigned int )((((int )*(key + (unsigned long )i) | ((int )*(key + (unsigned long )(i + 1U)) << 8)) | ((int )*(key + (unsigned long )(i + 2U)) << 16)) | ((int )*(key + (unsigned long )(i + 3U)) << 24));
#line 653
  goto ldv_55961;
  }
  ldv_55961: 
#line 656
  rtl8723au_write32(padapter, 1652, val);
#line 657
  cmd = (addr + (unsigned int )j) | 2147549184U;
#line 658
  rtl8723au_write32(padapter, 1648, cmd);
#line 640
  j = j - 1;
  ldv_55965: ;
#line 640
  if (j >= 0) {
#line 642
    goto ldv_55964;
  } else {

  }

#line 647
  return;
}
}
#line 664 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_fifo_cleanup(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  u8 trycnt ;
  u32 v32 ;
  u32 tmp ;
  u8 tmp___0 ;
  unsigned long __ms ;
  unsigned long tmp___1 ;

  {
#line 669
  pwrpriv = & padapter->pwrctrlpriv;
#line 670
  trycnt = 100U;
#line 673
  rtl8723au_write8(padapter, 1314, 255);
#line 676
  padapter->xmitpriv.nqos_ssn = rtl8723au_read8(padapter, 1244);
#line 678
  if ((unsigned int )pwrpriv->bkeepfwalive != 1U) {
#line 682
    v32 = rtl8723au_read32(padapter, 644);
#line 683
    v32 = v32 | 262144U;
#line 684
    rtl8723au_write32(padapter, 644, v32);
    ldv_55974: 
#line 686
    tmp = rtl8723au_read32(padapter, 644);
#line 686
    v32 = tmp & 131072U;
#line 688
    if (v32 == 0U) {
#line 689
      goto ldv_55973;
    } else {

    }
#line 690
    tmp___0 = trycnt;
#line 690
    trycnt = (u8 )((int )trycnt - 1);
#line 690
    if ((unsigned int )tmp___0 != 0U) {
#line 692
      goto ldv_55974;
    } else {

    }
    ldv_55973: ;
#line 691
    if ((unsigned int )trycnt == 0U) {
#line 692
      if (GlobalDebugLevel23A > 3U) {
#line 692
        printk("\016RTL8723AU: Stop RX DMA failed......\n");
      } else {

      }
    } else {

    }
#line 695
    rtl8723au_write16(padapter, 532, 0);
#line 696
    rtl8723au_write32(padapter, 512, 2147483648U);
#line 697
    __ms = 10UL;
#line 697
    goto ldv_55977;
    ldv_55976: 
#line 697
    __const_udelay(4295000UL);
    ldv_55977: 
#line 697
    tmp___1 = __ms;
#line 697
    __ms = __ms - 1UL;
#line 697
    if (tmp___1 != 0UL) {
#line 699
      goto ldv_55976;
    } else {

    }

  } else {

  }
#line 707
  return;
}
}
#line 701 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_bcn_valid(struct rtw_adapter *padapter ) 
{ 
  u8 tmp ;

  {
#line 705
  tmp = rtl8723au_read8(padapter, 522);
#line 705
  rtl8723au_write8(padapter, 522, (int )((unsigned int )tmp | 1U));
#line 707
  return;
}
}
#line 709 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
bool rtl8723a_get_bcn_valid(struct rtw_adapter *padapter ) 
{ 
  bool retval ;
  u8 tmp ;

  {
#line 713
  tmp = rtl8723au_read8(padapter, 522);
#line 713
  retval = ((int )tmp & 1) != 0;
#line 715
  return (retval);
}
}
#line 718 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_beacon_interval(struct rtw_adapter *padapter , u16 interval ) 
{ 


  {
#line 720
  rtl8723au_write16(padapter, 1364, (int )interval);
#line 721
  return;
}
}
#line 723 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_resp_sifs(struct rtw_adapter *padapter , u8 r2t1 , u8 r2t2 , u8 t2t1 ,
                            u8 t2t2 ) 
{ 


  {
#line 729
  rtl8723au_write8(padapter, 1596, (int )r2t1);
#line 731
  rtl8723au_write8(padapter, 1597, (int )r2t2);
#line 734
  rtl8723au_write8(padapter, 1598, (int )t2t1);
#line 736
  rtl8723au_write8(padapter, 1599, (int )t2t2);
#line 737
  return;
}
}
#line 739 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_ac_param_vo(struct rtw_adapter *padapter , u32 vo ) 
{ 


  {
#line 741
  rtl8723au_write32(padapter, 1280, vo);
#line 742
  return;
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_ac_param_vi(struct rtw_adapter *padapter , u32 vi ) 
{ 


  {
#line 746
  rtl8723au_write32(padapter, 1284, vi);
#line 747
  return;
}
}
#line 749 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_ac_param_be(struct rtw_adapter *padapter , u32 be ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 751
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 753
  pHalData->AcParam_BE = be;
#line 754
  rtl8723au_write32(padapter, 1288, be);
#line 755
  return;
}
}
#line 757 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_ac_param_bk(struct rtw_adapter *padapter , u32 bk ) 
{ 


  {
#line 759
  rtl8723au_write32(padapter, 1292, bk);
#line 760
  return;
}
}
#line 762 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_rxdma_agg_pg_th(struct rtw_adapter *padapter , u8 val ) 
{ 


  {
#line 764
  rtl8723au_write8(padapter, 640, (int )val);
#line 765
  return;
}
}
#line 767 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_initial_gain(struct rtw_adapter *padapter , u32 rx_gain ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dig_t *pDigTable ;

  {
#line 769
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 770
  pDigTable = & pHalData->odmpriv.DM_DigTable;
#line 772
  if (rx_gain == 255U) {
#line 773
    ODM_Write_DIG23a(& pHalData->odmpriv, (int )pDigTable->BackupIGValue);
  } else {
#line 775
    pDigTable->BackupIGValue = pDigTable->CurIGValue;
#line 776
    ODM_Write_DIG23a(& pHalData->odmpriv, (int )((u8 )rx_gain));
  }
#line 778
  return;
}
}
#line 780 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_odm_support_ability_restore(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 782
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 784
  pHalData->odmpriv.SupportAbility = pHalData->odmpriv.BK_SupportAbility;
#line 785
  return;
}
}
#line 787 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_odm_support_ability_backup(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 789
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 791
  pHalData->odmpriv.BK_SupportAbility = pHalData->odmpriv.SupportAbility;
#line 792
  return;
}
}
#line 794 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_odm_support_ability_set(struct rtw_adapter *padapter , u32 val ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 796
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 798
  if (val == 268435455U) {
#line 799
    pHalData->odmpriv.SupportAbility = pHalData->dmpriv.InitODMFlag;
  } else {
#line 801
    pHalData->odmpriv.SupportAbility = pHalData->odmpriv.SupportAbility | val;
  }
#line 802
  return;
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_odm_support_ability_clr(struct rtw_adapter *padapter , u32 val ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 806
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 808
  pHalData->odmpriv.SupportAbility = pHalData->odmpriv.SupportAbility & val;
#line 809
  return;
}
}
#line 811 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
void rtl8723a_set_rpwm(struct rtw_adapter *padapter , u8 val ) 
{ 


  {
#line 813
  rtl8723au_write8(padapter, 65112, (int )val);
#line 814
  return;
}
}
#line 816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
u8 rtl8723a_get_rf_type(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 818
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 820
  return (pHalData->rf_type);
}
}
#line 823 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
bool rtl8723a_get_fwlps_rf_on(struct rtw_adapter *padapter ) 
{ 
  bool retval ;
  u32 valRCR ;

  {
#line 830
  if (padapter->bSurpriseRemoved == 1 || (unsigned int )padapter->pwrctrlpriv.rf_pwrstate == 2U) {
#line 834
    retval = 1;
  } else {
#line 836
    valRCR = rtl8723au_read32(padapter, 1544);
#line 837
    if ((valRCR & 458752U) != 0U) {
#line 838
      retval = 0;
    } else {
#line 840
      retval = 1;
    }
  }
#line 843
  return (retval);
}
}
#line 846 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.c"
bool rtl8723a_chk_hi_queue_empty(struct rtw_adapter *padapter ) 
{ 
  u32 hgq ;

  {
#line 850
  hgq = rtl8723au_read32(padapter, 1044);
#line 852
  return ((hgq & 65280U) == 0U);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
bool ldv_queue_work_on_271(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
bool ldv_queue_delayed_work_on_272(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
bool ldv_queue_work_on_273(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void ldv_flush_workqueue_274(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
bool ldv_queue_delayed_work_on_275(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_285(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_287(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_286(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_289(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_288(struct workqueue_struct *ldv_func_arg1 ) ;
#line 32 "drivers/staging/rtl8723au/include/rtw_ap.h"
void add_RATid23a(struct rtw_adapter *padapter , struct sta_info *psta , u8 rssi_level ) ;
#line 535 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
void rtl8723a_update_ramask(struct rtw_adapter *padapter , u32 mac_id , u8 rssi_level ) ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_intf.c"
void rtw_hal_update_ra_mask23a(struct sta_info *psta , u8 rssi_level ) 
{ 
  struct rtw_adapter *padapter ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;

  {
#line 29
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 30
    return;
  } else {

  }
#line 32
  padapter = psta->padapter;
#line 34
  pmlmepriv = & padapter->mlmepriv;
#line 36
  tmp = check_fwstate(pmlmepriv, 16);
#line 36
  if ((int )tmp) {
#line 38
    add_RATid23a(padapter, psta, (int )rssi_level);
  } else {
#line 41
    rtl8723a_update_ramask(padapter, psta->mac_id, (int )rssi_level);
  }
#line 42
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
bool ldv_queue_work_on_285(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
bool ldv_queue_delayed_work_on_286(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
bool ldv_queue_work_on_287(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
void ldv_flush_workqueue_288(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
bool ldv_queue_delayed_work_on_289(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_299(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_301(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_300(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_303(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_302(struct workqueue_struct *ldv_func_arg1 ) ;
#line 116 "drivers/staging/rtl8723au/include/Hal8723PwrSeq.h"
struct wlan_pwr_cfg rtl8723AU_power_on_flow[16U] ;
#line 117
struct wlan_pwr_cfg rtl8723AU_radio_off_flow[16U] ;
#line 118
struct wlan_pwr_cfg rtl8723AU_card_disable_flow[31U] ;
#line 119
struct wlan_pwr_cfg rtl8723AU_card_enable_flow[31U] ;
#line 120
struct wlan_pwr_cfg rtl8723AU_suspend_flow[31U] ;
#line 121
struct wlan_pwr_cfg rtl8723AU_resume_flow[31U] ;
#line 122
struct wlan_pwr_cfg rtl8723AU_hwpdn_flow[31U] ;
#line 123
struct wlan_pwr_cfg rtl8723AU_enter_lps_flow[16U] ;
#line 124
struct wlan_pwr_cfg rtl8723AU_leave_lps_flow[16U] ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.c"
struct wlan_pwr_cfg rtl8723AU_power_on_flow[16U]  = 
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.c"
  {      {32U, 255U, 15U, 2U, 0U, 1U, 1U, 1U}, 
        {103U, 255U, 15U, 2U, 0U, 1U, 16U, 0U}, 
        {1U, 255U, 15U, 2U, 0U, 3U, 1U, 1U}, 
        {0U, 255U, 15U, 2U, 0U, 1U, 32U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 4U, 0U}, 
        {6U, 255U, 15U, 15U, 0U, 2U, 2U, 2U}, 
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 1U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 1U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.c"
struct wlan_pwr_cfg rtl8723AU_radio_off_flow[16U]  = {      {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U}, 
        {0U, 255U, 15U, 2U, 0U, 1U, 32U, 32U}, 
        {32U, 255U, 15U, 2U, 0U, 1U, 1U, 0U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.c"
struct wlan_pwr_cfg rtl8723AU_card_disable_flow[31U]  = 
#line 34
  {      {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U}, 
        {0U, 255U, 15U, 2U, 0U, 1U, 32U, 32U}, 
        {32U, 255U, 15U, 2U, 0U, 1U, 1U, 0U}, 
        {5U, 255U, 15U, 2U, 0U, 1U, 24U, 8U}, 
        {74U, 255U, 15U, 2U, 0U, 1U, 1U, 1U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.c"
struct wlan_pwr_cfg rtl8723AU_card_enable_flow[31U]  = 
#line 41
  {      {5U, 255U, 15U, 15U, 0U, 1U, 136U, 0U}, 
        {74U, 255U, 15U, 2U, 0U, 1U, 1U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {32U, 255U, 15U, 2U, 0U, 1U, 1U, 1U}, 
        {103U, 255U, 15U, 2U, 0U, 1U, 16U, 0U}, 
        {1U, 255U, 15U, 2U, 0U, 3U, 1U, 1U}, 
        {0U, 255U, 15U, 2U, 0U, 1U, 32U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 4U, 0U}, 
        {6U, 255U, 15U, 15U, 0U, 2U, 2U, 2U}, 
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 1U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 1U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.c"
struct wlan_pwr_cfg rtl8723AU_suspend_flow[31U]  = 
#line 48
  {      {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U}, 
        {0U, 255U, 15U, 2U, 0U, 1U, 32U, 32U}, 
        {32U, 255U, 15U, 2U, 0U, 1U, 1U, 0U}, 
        {5U, 255U, 15U, 2U, 0U, 1U, 24U, 8U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.c"
struct wlan_pwr_cfg rtl8723AU_resume_flow[31U]  = 
#line 55
  {      {5U, 255U, 15U, 15U, 0U, 1U, 136U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {32U, 255U, 15U, 2U, 0U, 1U, 1U, 1U}, 
        {103U, 255U, 15U, 2U, 0U, 1U, 16U, 0U}, 
        {1U, 255U, 15U, 2U, 0U, 3U, 1U, 1U}, 
        {0U, 255U, 15U, 2U, 0U, 1U, 32U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 4U, 0U}, 
        {6U, 255U, 15U, 15U, 0U, 2U, 2U, 2U}, 
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 1U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 1U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.c"
struct wlan_pwr_cfg rtl8723AU_hwpdn_flow[31U]  = 
#line 62
  {      {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U}, 
        {0U, 255U, 15U, 2U, 0U, 1U, 32U, 32U}, 
        {32U, 255U, 15U, 2U, 0U, 1U, 1U, 0U}, 
        {7U, 255U, 15U, 2U, 0U, 1U, 255U, 32U}, 
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 128U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.c"
struct wlan_pwr_cfg rtl8723AU_enter_lps_flow[16U]  = 
#line 69
  {      {1314U, 255U, 15U, 15U, 0U, 1U, 255U, 255U}, 
        {1528U, 255U, 15U, 15U, 0U, 2U, 255U, 0U}, 
        {1529U, 255U, 15U, 15U, 0U, 2U, 255U, 0U}, 
        {1530U, 255U, 15U, 15U, 0U, 2U, 255U, 0U}, 
        {1531U, 255U, 15U, 15U, 0U, 2U, 255U, 0U}, 
        {2U, 255U, 15U, 15U, 0U, 1U, 1U, 0U}, 
        {2U, 255U, 15U, 15U, 0U, 3U, 0U, 0U}, 
        {2U, 255U, 15U, 15U, 0U, 1U, 2U, 0U}, 
        {256U, 255U, 15U, 15U, 0U, 1U, 255U, 3U}, 
        {257U, 255U, 15U, 15U, 0U, 1U, 2U, 0U}, 
        {1363U, 255U, 15U, 15U, 0U, 1U, 32U, 32U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.c"
struct wlan_pwr_cfg rtl8723AU_leave_lps_flow[16U]  = 
#line 76
  {      {65112U, 255U, 15U, 2U, 0U, 1U, 255U, 132U}, 
        {2U, 255U, 15U, 15U, 0U, 3U, 0U, 1U}, 
        {8U, 255U, 15U, 15U, 0U, 1U, 16U, 0U}, 
        {265U, 255U, 15U, 15U, 0U, 2U, 128U, 0U}, 
        {41U, 255U, 15U, 15U, 0U, 1U, 192U, 0U}, 
        {257U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {256U, 255U, 15U, 15U, 0U, 1U, 255U, 255U}, 
        {2U, 255U, 15U, 15U, 0U, 1U, 3U, 3U}, 
        {1314U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
bool ldv_queue_work_on_299(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
bool ldv_queue_delayed_work_on_300(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
bool ldv_queue_work_on_301(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
void ldv_flush_workqueue_302(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
bool ldv_queue_delayed_work_on_303(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_313(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_315(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_314(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_317(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_316(struct workqueue_struct *ldv_func_arg1 ) ;
#line 25 "drivers/staging/rtl8723au/include/Hal8723UHWImg_CE.h"
u32 Rtl8723UPHY_REG_Array_PG[336U] ;
#line 27
u32 Rtl8723UMACPHY_Array_PG[1U] ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.c"
u32 Rtl8723UPHY_REG_Array_PG[336U]  = 
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.c"
  {      3584U,      4294967295U,      168561676U,      3588U, 
        4294967295U,      33818120U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      168561934U,      3604U, 
        4294967295U,      33818120U,      3608U,      4294967295U, 
        168561934U,      3612U,      4294967295U,      33818120U, 
        2096U,      4294967295U,      168561676U,      2100U, 
        4294967295U,      33818120U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      168561934U,      2120U, 
        4294967295U,      33818120U,      2124U,      4294967295U, 
        168561934U,      2152U,      4294967295U,      33818120U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      67372036U,      3588U, 
        4294967295U,      131588U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      101058054U,      3604U, 
        4294967295U,      132102U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      67372036U,      2100U, 
        4294967295U,      131588U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      101058054U,      2120U, 
        4294967295U,      132102U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      67372036U,      3588U, 
        4294967295U,      131588U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      67372036U,      2100U, 
        4294967295U,      131588U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U};
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.c"
u32 Rtl8723UMACPHY_Array_PG[1U]  = {      0U};
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
bool ldv_queue_work_on_313(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
bool ldv_queue_delayed_work_on_314(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
bool ldv_queue_work_on_315(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
void ldv_flush_workqueue_316(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
bool ldv_queue_delayed_work_on_317(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_327(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_329(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_328(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_331(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_330(struct workqueue_struct *ldv_func_arg1 ) ;
#line 110 "drivers/staging/rtl8723au/include/Hal8723APhyCfg.h"
u32 PHY_QueryBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask ) ;
#line 112
void PHY_SetBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask , u32 Data ) ;
#line 114
u32 PHY_QueryRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                   u32 BitMask ) ;
#line 117
void PHY_SetRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data ) ;
#line 801 "drivers/staging/rtl8723au/include/odm.h"
u32 OFDMSwingTable23A[43U] ;
#line 802
u8 CCKSwingTable_Ch1_Ch1323A[33U][8U] ;
#line 803
u8 CCKSwingTable_Ch1423A[33U][8U] ;
#line 50 "drivers/staging/rtl8723au/include/HalDMOutSrc8723A.h"
void rtl8723a_phy_iq_calibrate(struct rtw_adapter *pAdapter , bool bReCovery ) ;
#line 55
void rtl8723a_phy_lc_calibrate(struct rtw_adapter *pAdapter ) ;
#line 60
void rtl8723a_phy_ap_calibrate(struct rtw_adapter *pAdapter , char delta ) ;
#line 62
void rtl8723a_odm_check_tx_power_tracking(struct rtw_adapter *Adapter ) ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static void odm_TXPowerTrackingCallback_ThermalMeter_92C(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 ThermalValue ;
  u8 delta ;
  u8 delta_LCK ;
  u8 delta_IQK ;
  u8 delta_HP ;
  int ele_A ;
  int ele_D ;
  int TempCCk ;
  int X ;
  int value32 ;
  int Y ;
  int ele_C ;
  s8 OFDM_index[2U] ;
  s8 CCK_index ;
  s8 OFDM_index_old[2U] ;
  unsigned int tmp ;
  s8 CCK_index_old ;
  int i ;
  u8 OFDM_min_index ;
  u8 rf ;
  u8 ThermalValue_HP_count ;
  u32 ThermalValue_HP ;
  s32 index_mapping_HP[15U] ;
  s8 index_HP ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 29
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 30
  pdmpriv = & pHalData->dmpriv;
#line 31
  ThermalValue = 0U;
#line 34
  CCK_index = 0;
#line 34
  OFDM_index_old[0] = 0;
#line 34
  tmp = 1U;
#line 34
  while (1) {
#line 34
    if (tmp >= 2U) {
#line 34
      break;
    } else {

    }
#line 34
    OFDM_index_old[tmp] = (signed char)0;
#line 34
    tmp = tmp + 1U;
  }
#line 35
  CCK_index_old = 0;
#line 36
  i = 0;
#line 37
  OFDM_min_index = 6U;
#line 38
  ThermalValue_HP_count = 0U;
#line 39
  ThermalValue_HP = 0U;
#line 40
  index_mapping_HP[0] = 0;
#line 40
  index_mapping_HP[1] = 1;
#line 40
  index_mapping_HP[2] = 3;
#line 40
  index_mapping_HP[3] = 4;
#line 40
  index_mapping_HP[4] = 6;
#line 40
  index_mapping_HP[5] = 7;
#line 40
  index_mapping_HP[6] = 9;
#line 40
  index_mapping_HP[7] = 10;
#line 40
  index_mapping_HP[8] = 12;
#line 40
  index_mapping_HP[9] = 13;
#line 40
  index_mapping_HP[10] = 15;
#line 40
  index_mapping_HP[11] = 16;
#line 40
  index_mapping_HP[12] = 18;
#line 40
  index_mapping_HP[13] = 19;
#line 40
  index_mapping_HP[14] = 21;
#line 47
  pdmpriv->TXPowerTrackingCallbackCnt = pdmpriv->TXPowerTrackingCallbackCnt + 1U;
#line 48
  pdmpriv->bTXPowerTrackingInit = 1U;
#line 50
  if ((unsigned int )pHalData->CurrentChannel == 14U && (unsigned int )pdmpriv->bCCKinCH14 == 0U) {
#line 51
    pdmpriv->bCCKinCH14 = 1U;
  } else
#line 52
  if ((unsigned int )pHalData->CurrentChannel != 14U && (unsigned int )pdmpriv->bCCKinCH14 != 0U) {
#line 53
    pdmpriv->bCCKinCH14 = 0U;
  } else {

  }
#line 55
  tmp___0 = PHY_QueryRFReg(Adapter, 0, 36U, 31U);
#line 55
  ThermalValue = (unsigned char )tmp___0;
#line 58
  rtl8723a_phy_ap_calibrate(Adapter, (int )((char )((int )ThermalValue - (int )pHalData->EEPROMThermalMeter)));
#line 61
  if ((unsigned int )pHalData->rf_type == 2U) {
#line 62
    rf = 2U;
  } else {
#line 64
    rf = 1U;
  }
#line 66
  if ((unsigned int )ThermalValue != 0U) {
#line 68
    tmp___1 = rtl8723au_read32(Adapter, 3200);
#line 68
    ele_D = (int )tmp___1 & -4194304;
#line 70
    i = 0;
#line 70
    goto ldv_55774;
    ldv_55773: ;
#line 72
    if ((u32 )ele_D == (OFDMSwingTable23A[i] & 4290772992U)) {
#line 73
      OFDM_index_old[0] = (s8 )i;
#line 74
      goto ldv_55772;
    } else {

    }
#line 70
    i = i + 1;
    ldv_55774: ;
#line 70
    if (i <= 36) {
#line 72
      goto ldv_55773;
    } else {

    }
    ldv_55772: ;
#line 79
    if ((unsigned int )pHalData->rf_type == 2U) {
#line 80
      tmp___2 = rtl8723au_read32(Adapter, 3208);
#line 80
      ele_D = (int )tmp___2;
#line 82
      ele_D = ele_D & -4194304;
#line 83
      i = 0;
#line 83
      goto ldv_55777;
      ldv_55776: ;
#line 84
      if ((u32 )ele_D == (OFDMSwingTable23A[i] & 4290772992U)) {
#line 85
        OFDM_index_old[1] = (s8 )i;
#line 86
        goto ldv_55775;
      } else {

      }
#line 83
      i = i + 1;
      ldv_55777: ;
#line 83
      if (i <= 36) {
#line 85
        goto ldv_55776;
      } else {

      }
      ldv_55775: ;
    } else {

    }
#line 92
    tmp___3 = rtl8723au_read32(Adapter, 2596);
#line 92
    TempCCk = (int )tmp___3 & 1061109567;
#line 93
    i = 0;
#line 93
    goto ldv_55780;
    ldv_55779: ;
#line 94
    if ((unsigned int )pdmpriv->bCCKinCH14 != 0U) {
#line 95
      tmp___4 = memcmp((void const   *)(& TempCCk), (void const   *)(& CCKSwingTable_Ch1423A) + ((unsigned long )i + 2UL),
                       4UL);
#line 95
      if (tmp___4 == 0) {
#line 97
        CCK_index_old = (s8 )i;
#line 98
        goto ldv_55778;
      } else {

      }
    } else {
#line 101
      tmp___5 = memcmp((void const   *)(& TempCCk), (void const   *)(& CCKSwingTable_Ch1_Ch1323A) + ((unsigned long )i + 2UL),
                       4UL);
#line 101
      if (tmp___5 == 0) {
#line 103
        CCK_index_old = (s8 )i;
#line 104
        goto ldv_55778;
      } else {

      }
    }
#line 93
    i = i + 1;
    ldv_55780: ;
#line 93
    if (i <= 32) {
#line 95
      goto ldv_55779;
    } else {

    }
    ldv_55778: ;
#line 109
    if ((unsigned int )pdmpriv->ThermalValue == 0U) {
#line 110
      pdmpriv->ThermalValue = pHalData->EEPROMThermalMeter;
#line 111
      pdmpriv->ThermalValue_LCK = ThermalValue;
#line 112
      pdmpriv->ThermalValue_IQK = ThermalValue;
#line 113
      pdmpriv->ThermalValue_DPK = pHalData->EEPROMThermalMeter;
#line 115
      i = 0;
#line 115
      goto ldv_55782;
      ldv_55781: 
#line 116
      pdmpriv->OFDM_index_HP[i] = (u8 )OFDM_index_old[i];
#line 117
      pdmpriv->OFDM_index[i] = (u8 )OFDM_index_old[i];
#line 115
      i = i + 1;
      ldv_55782: ;
#line 115
      if ((int )rf > i) {
#line 117
        goto ldv_55781;
      } else {

      }
#line 119
      pdmpriv->CCK_index_HP = (u8 )CCK_index_old;
#line 120
      pdmpriv->CCK_index = (u8 )CCK_index_old;
    } else {

    }
#line 123
    if ((unsigned int )pHalData->BoardType == 1U) {
#line 124
      pdmpriv->ThermalValue_HP[(int )pdmpriv->ThermalValue_HP_index] = ThermalValue;
#line 125
      pdmpriv->ThermalValue_HP_index = (u8 )((int )pdmpriv->ThermalValue_HP_index + 1);
#line 126
      if ((unsigned int )pdmpriv->ThermalValue_HP_index == 8U) {
#line 127
        pdmpriv->ThermalValue_HP_index = 0U;
      } else {

      }
#line 129
      i = 0;
#line 129
      goto ldv_55785;
      ldv_55784: ;
#line 130
      if ((unsigned int )pdmpriv->ThermalValue_HP[i] != 0U) {
#line 131
        ThermalValue_HP = (u32 )pdmpriv->ThermalValue_HP[i] + ThermalValue_HP;
#line 132
        ThermalValue_HP_count = (u8 )((int )ThermalValue_HP_count + 1);
      } else {

      }
#line 129
      i = i + 1;
      ldv_55785: ;
#line 129
      if (i <= 7) {
#line 131
        goto ldv_55784;
      } else {

      }

#line 136
      if ((unsigned int )ThermalValue_HP_count != 0U) {
#line 137
        ThermalValue = (unsigned char )(ThermalValue_HP / (u32 )ThermalValue_HP_count);
      } else {

      }
    } else {

    }
#line 140
    delta = (int )pdmpriv->ThermalValue < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue : (int )pdmpriv->ThermalValue - (int )ThermalValue;
#line 143
    if ((unsigned int )pHalData->BoardType == 1U) {
#line 144
      if ((unsigned int )pdmpriv->bDoneTxpower != 0U) {
#line 145
        delta_HP = (int )pdmpriv->ThermalValue < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue : (int )pdmpriv->ThermalValue - (int )ThermalValue;
      } else {
#line 149
        delta_HP = (int )pHalData->EEPROMThermalMeter < (int )ThermalValue ? (int )ThermalValue - (int )pHalData->EEPROMThermalMeter : (int )pHalData->EEPROMThermalMeter - (int )ThermalValue;
      }
    } else {
#line 153
      delta_HP = 0U;
    }
#line 155
    delta_LCK = (int )pdmpriv->ThermalValue_LCK < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue_LCK : (int )pdmpriv->ThermalValue_LCK - (int )ThermalValue;
#line 158
    delta_IQK = (int )pdmpriv->ThermalValue_IQK < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue_IQK : (int )pdmpriv->ThermalValue_IQK - (int )ThermalValue;
#line 162
    if ((unsigned int )delta_LCK > 1U) {
#line 163
      pdmpriv->ThermalValue_LCK = ThermalValue;
#line 164
      rtl8723a_phy_lc_calibrate(Adapter);
    } else {

    }
#line 167
    if (((unsigned int )delta != 0U || (unsigned int )delta_HP != 0U) && (unsigned int )pdmpriv->TxPowerTrackControl != 0U) {
#line 168
      if ((unsigned int )pHalData->BoardType == 1U) {
#line 169
        pdmpriv->bDoneTxpower = 1U;
#line 170
        delta_HP = (int )pHalData->EEPROMThermalMeter < (int )ThermalValue ? (int )ThermalValue - (int )pHalData->EEPROMThermalMeter : (int )pHalData->EEPROMThermalMeter - (int )ThermalValue;
#line 174
        if ((unsigned int )delta_HP > 14U) {
#line 175
          index_HP = (s8 )index_mapping_HP[14];
        } else {
#line 177
          index_HP = (s8 )index_mapping_HP[(int )delta_HP];
        }
#line 179
        if ((int )pHalData->EEPROMThermalMeter < (int )ThermalValue) {
#line 181
          i = 0;
#line 181
          goto ldv_55788;
          ldv_55787: 
#line 182
          OFDM_index[i] = (s8 )((int )pdmpriv->OFDM_index_HP[i] - (int )((unsigned char )index_HP));
#line 181
          i = i + 1;
          ldv_55788: ;
#line 181
          if ((int )rf > i) {
#line 183
            goto ldv_55787;
          } else {

          }
#line 183
          CCK_index = (s8 )((int )pdmpriv->CCK_index_HP - (int )((unsigned char )index_HP));
        } else {
#line 185
          i = 0;
#line 185
          goto ldv_55791;
          ldv_55790: 
#line 186
          OFDM_index[i] = (s8 )((int )pdmpriv->OFDM_index_HP[i] + (int )((unsigned char )index_HP));
#line 185
          i = i + 1;
          ldv_55791: ;
#line 185
          if ((int )rf > i) {
#line 187
            goto ldv_55790;
          } else {

          }
#line 187
          CCK_index = (s8 )((int )pdmpriv->CCK_index_HP + (int )((unsigned char )index_HP));
        }
#line 190
        delta_HP = (int )pdmpriv->ThermalValue < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue : (int )pdmpriv->ThermalValue - (int )ThermalValue;
      } else
#line 194
      if ((int )pdmpriv->ThermalValue < (int )ThermalValue) {
#line 195
        i = 0;
#line 195
        goto ldv_55794;
        ldv_55793: 
#line 196
        pdmpriv->OFDM_index[i] = (int )pdmpriv->OFDM_index[i] - (int )delta;
#line 195
        i = i + 1;
        ldv_55794: ;
#line 195
        if ((int )rf > i) {
#line 197
          goto ldv_55793;
        } else {

        }
#line 197
        pdmpriv->CCK_index = (int )pdmpriv->CCK_index - (int )delta;
      } else {
#line 199
        i = 0;
#line 199
        goto ldv_55797;
        ldv_55796: 
#line 200
        pdmpriv->OFDM_index[i] = (int )pdmpriv->OFDM_index[i] + (int )delta;
#line 199
        i = i + 1;
        ldv_55797: ;
#line 199
        if ((int )rf > i) {
#line 201
          goto ldv_55796;
        } else {

        }
#line 201
        pdmpriv->CCK_index = (int )pdmpriv->CCK_index + (int )delta;
      }
#line 206
      if ((unsigned int )pHalData->BoardType != 1U) {
#line 207
        if ((int )pHalData->EEPROMThermalMeter < (int )ThermalValue) {
#line 208
          i = 0;
#line 208
          goto ldv_55800;
          ldv_55799: 
#line 209
          OFDM_index[i] = (s8 )((unsigned int )pdmpriv->OFDM_index[i] + 1U);
#line 208
          i = i + 1;
          ldv_55800: ;
#line 208
          if ((int )rf > i) {
#line 210
            goto ldv_55799;
          } else {

          }
#line 210
          CCK_index = (s8 )((unsigned int )pdmpriv->CCK_index + 1U);
        } else {
#line 212
          i = 0;
#line 212
          goto ldv_55803;
          ldv_55802: 
#line 213
          OFDM_index[i] = (s8 )pdmpriv->OFDM_index[i];
#line 212
          i = i + 1;
          ldv_55803: ;
#line 212
          if ((int )rf > i) {
#line 214
            goto ldv_55802;
          } else {

          }
#line 214
          CCK_index = (s8 )pdmpriv->CCK_index;
        }
      } else {

      }
#line 217
      i = 0;
#line 217
      goto ldv_55806;
      ldv_55805: ;
#line 218
      if ((int )OFDM_index[i] > 36) {
#line 219
        OFDM_index[i] = 36;
      } else
#line 220
      if ((int )OFDM_index[i] < (int )OFDM_min_index) {
#line 221
        OFDM_index[i] = (s8 )OFDM_min_index;
      } else {

      }
#line 217
      i = i + 1;
      ldv_55806: ;
#line 217
      if ((int )rf > i) {
#line 219
        goto ldv_55805;
      } else {

      }

#line 224
      if ((int )CCK_index > 32) {
#line 225
        CCK_index = 32;
      } else
#line 226
      if ((int )CCK_index < 0) {
#line 227
        CCK_index = 0;
      } else {

      }
    } else {

    }
#line 230
    if ((unsigned int )pdmpriv->TxPowerTrackControl != 0U && ((unsigned int )delta != 0U || (unsigned int )delta_HP != 0U)) {
#line 233
      ele_D = (int )(OFDMSwingTable23A[(int )OFDM_index[0]] >> 22);
#line 234
      X = pdmpriv->RegE94;
#line 235
      Y = pdmpriv->RegE9C;
#line 237
      if (X != 0) {
#line 238
        if ((X & 512) != 0) {
#line 239
          X = (int )((unsigned int )X | 4294966272U);
        } else {

        }
#line 240
        ele_A = (X * ele_D >> 8) & 1023;
#line 243
        if ((Y & 512) != 0) {
#line 244
          Y = (int )((unsigned int )Y | 4294966272U);
        } else {

        }
#line 245
        ele_C = (Y * ele_D >> 8) & 1023;
#line 248
        value32 = ((ele_D << 22) | ((ele_C & 63) << 16)) | ele_A;
#line 249
        rtl8723au_write32(Adapter, 3200, (u32 )value32);
#line 253
        value32 = (ele_C & 960) >> 6;
#line 254
        PHY_SetBBReg(Adapter, 3220U, 4026531840U, (u32 )value32);
#line 256
        value32 = (X * ele_D >> 7) & 1;
#line 257
        PHY_SetBBReg(Adapter, 3148U, 2147483648U, (u32 )value32);
#line 260
        value32 = (Y * ele_D >> 7) & 1;
#line 261
        PHY_SetBBReg(Adapter, 3148U, 536870912U, (u32 )value32);
      } else {
#line 264
        rtl8723au_write32(Adapter, 3200, OFDMSwingTable23A[(int )OFDM_index[0]]);
#line 267
        PHY_SetBBReg(Adapter, 3220U, 4026531840U, 0U);
#line 269
        PHY_SetBBReg(Adapter, 3148U, 2684354560U, 0U);
      }
#line 274
      if ((unsigned int )pdmpriv->bCCKinCH14 == 0U) {
#line 275
        rtl8723au_write8(Adapter, 2594, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][0]);
#line 276
        rtl8723au_write8(Adapter, 2595, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][1]);
#line 277
        rtl8723au_write8(Adapter, 2596, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][2]);
#line 278
        rtl8723au_write8(Adapter, 2597, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][3]);
#line 279
        rtl8723au_write8(Adapter, 2598, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][4]);
#line 280
        rtl8723au_write8(Adapter, 2599, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][5]);
#line 281
        rtl8723au_write8(Adapter, 2600, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][6]);
#line 282
        rtl8723au_write8(Adapter, 2601, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][7]);
      } else {
#line 284
        rtl8723au_write8(Adapter, 2594, (int )CCKSwingTable_Ch1423A[(int )CCK_index][0]);
#line 285
        rtl8723au_write8(Adapter, 2595, (int )CCKSwingTable_Ch1423A[(int )CCK_index][1]);
#line 286
        rtl8723au_write8(Adapter, 2596, (int )CCKSwingTable_Ch1423A[(int )CCK_index][2]);
#line 287
        rtl8723au_write8(Adapter, 2597, (int )CCKSwingTable_Ch1423A[(int )CCK_index][3]);
#line 288
        rtl8723au_write8(Adapter, 2598, (int )CCKSwingTable_Ch1423A[(int )CCK_index][4]);
#line 289
        rtl8723au_write8(Adapter, 2599, (int )CCKSwingTable_Ch1423A[(int )CCK_index][5]);
#line 290
        rtl8723au_write8(Adapter, 2600, (int )CCKSwingTable_Ch1423A[(int )CCK_index][6]);
#line 291
        rtl8723au_write8(Adapter, 2601, (int )CCKSwingTable_Ch1423A[(int )CCK_index][7]);
      }
#line 294
      if ((unsigned int )pHalData->rf_type == 2U) {
#line 295
        ele_D = (int )(OFDMSwingTable23A[(int )((unsigned char )OFDM_index[1])] >> 22);
#line 298
        X = pdmpriv->RegEB4;
#line 299
        Y = pdmpriv->RegEBC;
#line 301
        if (X != 0) {
#line 302
          if ((X & 512) != 0) {
#line 303
            X = (int )((unsigned int )X | 4294966272U);
          } else {

          }
#line 304
          ele_A = (X * ele_D >> 8) & 1023;
#line 307
          if ((Y & 512) != 0) {
#line 308
            Y = (int )((unsigned int )Y | 4294966272U);
          } else {

          }
#line 309
          ele_C = (Y * ele_D >> 8) & 1023;
#line 312
          value32 = ((ele_D << 22) | ((ele_C & 63) << 16)) | ele_A;
#line 313
          rtl8723au_write32(Adapter, 3208, (u32 )value32);
#line 315
          value32 = (ele_C & 960) >> 6;
#line 316
          PHY_SetBBReg(Adapter, 3228U, 4026531840U, (u32 )value32);
#line 318
          value32 = (X * ele_D >> 7) & 1;
#line 319
          PHY_SetBBReg(Adapter, 3148U, 134217728U, (u32 )value32);
#line 323
          value32 = (Y * ele_D >> 7) & 1;
#line 324
          PHY_SetBBReg(Adapter, 3148U, 33554432U, (u32 )value32);
        } else {
#line 328
          rtl8723au_write32(Adapter, 3208, OFDMSwingTable23A[(int )OFDM_index[1]]);
#line 331
          PHY_SetBBReg(Adapter, 3228U, 4026531840U, 0U);
#line 334
          PHY_SetBBReg(Adapter, 3148U, 167772160U, 0U);
        }
      } else {

      }
    } else {

    }
#line 341
    if ((unsigned int )delta_IQK > 3U) {
#line 342
      pdmpriv->ThermalValue_IQK = ThermalValue;
#line 343
      rtl8723a_phy_iq_calibrate(Adapter, 0);
    } else {

    }
#line 347
    if ((unsigned int )pdmpriv->TxPowerTrackControl != 0U) {
#line 348
      pdmpriv->ThermalValue = ThermalValue;
    } else {

    }
  } else {

  }
#line 350
  pdmpriv->TXPowercount = 0U;
#line 351
  return;
}
}
#line 359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static void ODM_TXPowerTracking92CDirectCall(struct rtw_adapter *Adapter ) 
{ 


  {
#line 361
  odm_TXPowerTrackingCallback_ThermalMeter_92C(Adapter);
#line 362
  return;
}
}
#line 364 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
void rtl8723a_odm_check_tx_power_tracking(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;

  {
#line 366
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 367
  pdmpriv = & pHalData->dmpriv;
#line 369
  if ((unsigned int )pdmpriv->TM_Trigger == 0U) {
#line 370
    PHY_SetRFReg(Adapter, 0, 36U, 1048575U, 96U);
#line 372
    pdmpriv->TM_Trigger = 1U;
#line 373
    return;
  } else {
#line 375
    ODM_TXPowerTracking92CDirectCall(Adapter);
#line 376
    pdmpriv->TM_Trigger = 0U;
  }
#line 378
  return;
}
}
#line 384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static u8 _PHY_PathA_IQK(struct rtw_adapter *pAdapter , bool configPathB ) 
{ 
  u32 regEAC ;
  u32 regE94 ;
  u32 regE9C ;
  u32 regEA4 ;
  u8 result ;
  struct hal_data_8723a *pHalData ;

  {
#line 387
  result = 0U;
#line 388
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 391
  rtl8723au_write32(pAdapter, 3632, 268471327U);
#line 392
  rtl8723au_write32(pAdapter, 3636, 268471327U);
#line 393
  rtl8723au_write32(pAdapter, 3640, 2182349058U);
#line 395
  rtl8723au_write32(pAdapter, 3644, (int )configPathB ? 672530946U : (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && ((unsigned int )pHalData->VersionID.VendorType == 1U && (unsigned int )pHalData->VersionID.CUTVersion == 1U) ? 672530946U : 672531714U));
#line 399
  if ((int )configPathB) {
#line 400
    rtl8723au_write32(pAdapter, 3664, 268471330U);
#line 401
    rtl8723au_write32(pAdapter, 3668, 268471330U);
#line 402
    rtl8723au_write32(pAdapter, 3672, 2182349058U);
#line 403
    rtl8723au_write32(pAdapter, 3676, 672530946U);
  } else {

  }
#line 407
  rtl8723au_write32(pAdapter, 3660, 1059025U);
#line 410
  rtl8723au_write32(pAdapter, 3656, 4177526784U);
#line 411
  rtl8723au_write32(pAdapter, 3656, 4160749568U);
#line 415
  __const_udelay(4295000UL);
#line 418
  regEAC = rtl8723au_read32(pAdapter, 3756);
#line 419
  regE94 = rtl8723au_read32(pAdapter, 3732);
#line 420
  regE9C = rtl8723au_read32(pAdapter, 3740);
#line 421
  regEA4 = rtl8723au_read32(pAdapter, 3748);
#line 423
  if ((((unsigned long )regEAC & 268435456UL) == 0UL && (regE94 & 67043328U) >> 16 != 322U) && (regE9C & 67043328U) >> 16 != 66U) {
#line 426
    result = (u8 )((unsigned int )result | 1U);
  } else {
#line 428
    return (result);
  }
#line 430
  if ((((unsigned long )regEAC & 134217728UL) == 0UL && (regEA4 & 67043328U) >> 16 != 306U) && (regEAC & 67043328U) >> 16 != 54U) {
#line 433
    result = (u8 )((unsigned int )result | 2U);
  } else
#line 435
  if (GlobalDebugLevel23A > 3U) {
#line 435
    printk("\016RTL8723AU: Path A Rx IQK fail!!\n");
  } else {

  }
#line 436
  return (result);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static u8 _PHY_PathB_IQK(struct rtw_adapter *pAdapter ) 
{ 
  u32 regEAC ;
  u32 regEB4 ;
  u32 regEBC ;
  u32 regEC4 ;
  u32 regECC ;
  u8 result ;

  {
#line 442
  result = 0U;
#line 445
  rtl8723au_write32(pAdapter, 3680, 2U);
#line 446
  rtl8723au_write32(pAdapter, 3680, 0U);
#line 449
  __const_udelay(4295000UL);
#line 452
  regEAC = rtl8723au_read32(pAdapter, 3756);
#line 453
  regEB4 = rtl8723au_read32(pAdapter, 3764);
#line 454
  regEBC = rtl8723au_read32(pAdapter, 3772);
#line 455
  regEC4 = rtl8723au_read32(pAdapter, 3780);
#line 456
  regECC = rtl8723au_read32(pAdapter, 3788);
#line 458
  if (((int )regEAC >= 0 && (regEB4 & 67043328U) >> 16 != 322U) && (regEBC & 67043328U) >> 16 != 66U) {
#line 461
    result = (u8 )((unsigned int )result | 1U);
  } else {
#line 463
    return (result);
  }
#line 465
  if ((((unsigned long )regEAC & 1073741824UL) == 0UL && (regEC4 & 67043328U) >> 16 != 306U) && (regECC & 67043328U) >> 16 != 54U) {
#line 468
    result = (u8 )((unsigned int )result | 2U);
  } else
#line 470
  if (GlobalDebugLevel23A > 3U) {
#line 470
    printk("\016RTL8723AU: Path B Rx IQK fail!!\n");
  } else {

  }
#line 471
  return (result);
}
}
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static void _PHY_PathAFillIQKMatrix(struct rtw_adapter *pAdapter , bool bIQKOK , int (*result)[8U] ,
                                    u8 final_candidate , bool bTxOnly ) 
{ 
  u32 Oldval_0 ;
  u32 X ;
  u32 TX0_A ;
  u32 reg ;
  s32 Y ;
  s32 TX0_C ;

  {
#line 484
  if (GlobalDebugLevel23A > 3U) {
#line 484
    printk("\016RTL8723AU: Path A IQ Calibration %s !\n", (int )bIQKOK ? (char *)"Success" : (char *)"Failed");
  } else {

  }
#line 486
  if ((unsigned int )final_candidate == 255U) {
#line 487
    return;
  } else
#line 488
  if ((int )bIQKOK) {
#line 489
    Oldval_0 = rtl8723au_read32(pAdapter, 3200);
#line 490
    Oldval_0 = Oldval_0 >> 22;
#line 492
    X = (u32 )(*(result + (unsigned long )final_candidate))[0];
#line 493
    if ((X & 512U) != 0U) {
#line 494
      X = X | 4294966272U;
    } else {

    }
#line 495
    TX0_A = X * Oldval_0 >> 8;
#line 496
    PHY_SetBBReg(pAdapter, 3200U, 1023U, TX0_A);
#line 497
    PHY_SetBBReg(pAdapter, 3148U, 2147483648U, (X * Oldval_0 >> 7) & 1U);
#line 500
    Y = (*(result + (unsigned long )final_candidate))[1];
#line 501
    if ((Y & 512) != 0) {
#line 502
      Y = (s32 )((unsigned int )Y | 4294966272U);
    } else {

    }
#line 503
    TX0_C = (s32 )((u32 )Y * Oldval_0 >> 8);
#line 504
    PHY_SetBBReg(pAdapter, 3220U, 4026531840U, (u32 )((TX0_C & 960) >> 6));
#line 506
    PHY_SetBBReg(pAdapter, 3200U, 4128768U, (u32 )TX0_C & 63U);
#line 508
    PHY_SetBBReg(pAdapter, 3148U, 536870912U, ((u32 )Y * Oldval_0 >> 7) & 1U);
#line 511
    if ((int )bTxOnly) {
#line 512
      if (GlobalDebugLevel23A > 3U) {
#line 512
        printk("\016RTL8723AU: _PHY_PathAFillIQKMatrix only Tx OK\n");
      } else {

      }
#line 513
      return;
    } else {

    }
#line 516
    reg = (u32 )(*(result + (unsigned long )final_candidate))[2];
#line 517
    PHY_SetBBReg(pAdapter, 3092U, 1023U, reg);
#line 519
    reg = (u32 )(*(result + (unsigned long )final_candidate))[3] & 63U;
#line 520
    PHY_SetBBReg(pAdapter, 3092U, 64512U, reg);
#line 522
    reg = (u32 )((*(result + (unsigned long )final_candidate))[3] >> 6) & 15U;
#line 523
    PHY_SetBBReg(pAdapter, 3232U, 4026531840U, reg);
  } else {

  }
#line 525
  return;
}
}
#line 527 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static void _PHY_PathBFillIQKMatrix(struct rtw_adapter *pAdapter , bool bIQKOK , int (*result)[8U] ,
                                    u8 final_candidate , bool bTxOnly ) 
{ 
  u32 Oldval_1 ;
  u32 X ;
  u32 TX1_A ;
  u32 reg ;
  s32 Y ;
  s32 TX1_C ;

  {
#line 532
  if (GlobalDebugLevel23A > 3U) {
#line 532
    printk("\016RTL8723AU: Path B IQ Calibration %s !\n", (int )bIQKOK ? (char *)"Success" : (char *)"Failed");
  } else {

  }
#line 534
  if ((unsigned int )final_candidate == 255U) {
#line 535
    return;
  } else
#line 536
  if ((int )bIQKOK) {
#line 537
    Oldval_1 = rtl8723au_read32(pAdapter, 3208);
#line 538
    Oldval_1 = Oldval_1 >> 22;
#line 540
    X = (u32 )(*(result + (unsigned long )final_candidate))[4];
#line 541
    if ((X & 512U) != 0U) {
#line 542
      X = X | 4294966272U;
    } else {

    }
#line 543
    TX1_A = X * Oldval_1 >> 8;
#line 544
    PHY_SetBBReg(pAdapter, 3208U, 1023U, TX1_A);
#line 545
    PHY_SetBBReg(pAdapter, 3148U, 134217728U, (X * Oldval_1 >> 7) & 1U);
#line 548
    Y = (*(result + (unsigned long )final_candidate))[5];
#line 549
    if ((Y & 512) != 0) {
#line 550
      Y = (s32 )((unsigned int )Y | 4294966272U);
    } else {

    }
#line 551
    TX1_C = (s32 )((u32 )Y * Oldval_1 >> 8);
#line 552
    PHY_SetBBReg(pAdapter, 3228U, 4026531840U, (u32 )((TX1_C & 960) >> 6));
#line 554
    PHY_SetBBReg(pAdapter, 3208U, 4128768U, (u32 )TX1_C & 63U);
#line 556
    PHY_SetBBReg(pAdapter, 3148U, 33554432U, ((u32 )Y * Oldval_1 >> 7) & 1U);
#line 559
    if ((int )bTxOnly) {
#line 560
      return;
    } else {

    }
#line 562
    reg = (u32 )(*(result + (unsigned long )final_candidate))[6];
#line 563
    PHY_SetBBReg(pAdapter, 3100U, 1023U, reg);
#line 565
    reg = (u32 )(*(result + (unsigned long )final_candidate))[7] & 63U;
#line 566
    PHY_SetBBReg(pAdapter, 3100U, 64512U, reg);
#line 568
    reg = (u32 )((*(result + (unsigned long )final_candidate))[7] >> 6) & 15U;
#line 569
    PHY_SetBBReg(pAdapter, 3192U, 61440U, reg);
  } else {

  }
#line 571
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static void _PHY_SaveADDARegisters(struct rtw_adapter *pAdapter , u32 *ADDAReg , u32 *ADDABackup ,
                                   u32 RegisterNum ) 
{ 
  u32 i ;

  {
#line 577
  i = 0U;
#line 577
  goto ldv_55869;
  ldv_55868: 
#line 578
  *(ADDABackup + (unsigned long )i) = rtl8723au_read32(pAdapter, (int )((u16 )*(ADDAReg + (unsigned long )i)));
#line 577
  i = i + 1U;
  ldv_55869: ;
#line 577
  if (i < RegisterNum) {
#line 579
    goto ldv_55868;
  } else {

  }

#line 584
  return;
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static void _PHY_SaveMACRegisters(struct rtw_adapter *pAdapter , u32 *MACReg , u32 *MACBackup ) 
{ 
  u32 i ;
  u8 tmp ;

  {
#line 587
  i = 0U;
#line 587
  goto ldv_55878;
  ldv_55877: 
#line 588
  tmp = rtl8723au_read8(pAdapter, (int )((u16 )*(MACReg + (unsigned long )i)));
#line 588
  *(MACBackup + (unsigned long )i) = (u32 )tmp;
#line 587
  i = i + 1U;
  ldv_55878: ;
#line 587
  if (i <= 2U) {
#line 589
    goto ldv_55877;
  } else {

  }
#line 590
  *(MACBackup + (unsigned long )i) = rtl8723au_read32(pAdapter, (int )((u16 )*(MACReg + (unsigned long )i)));
#line 591
  return;
}
}
#line 593 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static void _PHY_ReloadADDARegisters(struct rtw_adapter *pAdapter , u32 *ADDAReg ,
                                     u32 *ADDABackup , u32 RegiesterNum ) 
{ 
  u32 i ;

  {
#line 599
  i = 0U;
#line 599
  goto ldv_55888;
  ldv_55887: 
#line 600
  rtl8723au_write32(pAdapter, (int )((u16 )*(ADDAReg + (unsigned long )i)), *(ADDABackup + (unsigned long )i));
#line 599
  i = i + 1U;
  ldv_55888: ;
#line 599
  if (i < RegiesterNum) {
#line 601
    goto ldv_55887;
  } else {

  }

#line 606
  return;
}
}
#line 604 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static void _PHY_ReloadMACRegisters(struct rtw_adapter *pAdapter , u32 *MACReg , u32 *MACBackup ) 
{ 
  u32 i ;

  {
#line 609
  i = 0U;
#line 609
  goto ldv_55897;
  ldv_55896: 
#line 610
  rtl8723au_write8(pAdapter, (int )((u16 )*(MACReg + (unsigned long )i)), (int )((unsigned char )*(MACBackup + (unsigned long )i)));
#line 609
  i = i + 1U;
  ldv_55897: ;
#line 609
  if (i <= 2U) {
#line 611
    goto ldv_55896;
  } else {

  }
#line 612
  rtl8723au_write32(pAdapter, (int )((u16 )*(MACReg + (unsigned long )i)), *(MACBackup + (unsigned long )i));
#line 613
  return;
}
}
#line 615 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static void _PHY_PathADDAOn(struct rtw_adapter *pAdapter , u32 *ADDAReg , bool isPathAOn ,
                            bool is2T ) 
{ 
  u32 pathOn ;
  u32 i ;

  {
#line 621
  pathOn = (int )isPathAOn ? 81470884U : 186328484U;
#line 622
  if (! is2T) {
#line 623
    pathOn = 198911392U;
#line 624
    rtl8723au_write32(pAdapter, (int )((u16 )*ADDAReg), 186328480U);
  } else {
#line 626
    rtl8723au_write32(pAdapter, (int )((u16 )*ADDAReg), pathOn);
  }
#line 629
  i = 1U;
#line 629
  goto ldv_55908;
  ldv_55907: 
#line 630
  rtl8723au_write32(pAdapter, (int )((u16 )*(ADDAReg + (unsigned long )i)), pathOn);
#line 629
  i = i + 1U;
  ldv_55908: ;
#line 629
  if (i <= 15U) {
#line 631
    goto ldv_55907;
  } else {

  }

#line 636
  return;
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static void _PHY_MACSettingCalibration(struct rtw_adapter *pAdapter , u32 *MACReg ,
                                       u32 *MACBackup ) 
{ 
  u32 i ;

  {
#line 636
  i = 0U;
#line 638
  rtl8723au_write8(pAdapter, (int )((u16 )*(MACReg + (unsigned long )i)), 63);
#line 640
  i = 1U;
#line 640
  goto ldv_55917;
  ldv_55916: 
#line 641
  rtl8723au_write8(pAdapter, (int )((u16 )*(MACReg + (unsigned long )i)), (int )((unsigned char )*(MACBackup + (unsigned long )i)) & 247);
#line 640
  i = i + 1U;
  ldv_55917: ;
#line 640
  if (i <= 2U) {
#line 642
    goto ldv_55916;
  } else {

  }
#line 644
  rtl8723au_write8(pAdapter, (int )((u16 )*(MACReg + (unsigned long )i)), (int )((unsigned char )*(MACBackup + (unsigned long )i)) & 223);
#line 645
  return;
}
}
#line 647 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static void _PHY_PathAStandBy(struct rtw_adapter *pAdapter ) 
{ 


  {
#line 649
  rtl8723au_write32(pAdapter, 3624, 0U);
#line 650
  rtl8723au_write32(pAdapter, 2112, 65536U);
#line 651
  rtl8723au_write32(pAdapter, 3624, 2155872256U);
#line 652
  return;
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static void _PHY_PIModeSwitch(struct rtw_adapter *pAdapter , bool PIMode ) 
{ 
  u32 mode ;

  {
#line 658
  mode = (int )PIMode ? 16777472U : 16777216U;
#line 659
  rtl8723au_write32(pAdapter, 2080, mode);
#line 660
  rtl8723au_write32(pAdapter, 2088, mode);
#line 661
  return;
}
}
#line 666 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static bool _PHY_SimularityCompare(struct rtw_adapter *pAdapter , int (*result)[8U] ,
                                   u8 c1 , u8 c2 ) 
{ 
  u32 i ;
  u32 j ;
  u32 diff ;
  u32 SimularityBitMap ;
  u32 bound ;
  struct hal_data_8723a *pHalData ;
  u8 final_candidate[2U] ;
  bool bResult ;

  {
#line 668
  bound = 0U;
#line 669
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 670
  final_candidate[0] = 255U;
#line 670
  final_candidate[1] = 255U;
#line 671
  bResult = 1;
#line 673
  if ((unsigned int )pHalData->rf_type == 2U) {
#line 674
    bound = 8U;
  } else {
#line 676
    bound = 4U;
  }
#line 678
  SimularityBitMap = 0U;
#line 680
  i = 0U;
#line 680
  goto ldv_55942;
  ldv_55941: 
#line 681
  diff = (u32 )((*(result + (unsigned long )c1))[i] > (*(result + (unsigned long )c2))[i] ? (*(result + (unsigned long )c1))[i] - (*(result + (unsigned long )c2))[i] : (*(result + (unsigned long )c2))[i] - (*(result + (unsigned long )c1))[i]);
#line 682
  if (diff > 5U) {
#line 683
    if ((i == 2U || i == 6U) && SimularityBitMap == 0U) {
#line 684
      if ((*(result + (unsigned long )c1))[i] + (*(result + (unsigned long )c1))[i + 1U] == 0) {
#line 685
        final_candidate[i / 4U] = c2;
      } else
#line 686
      if ((*(result + (unsigned long )c2))[i] + (*(result + (unsigned long )c2))[i + 1U] == 0) {
#line 687
        final_candidate[i / 4U] = c1;
      } else {
#line 689
        SimularityBitMap = (u32 )(1 << (int )i) | SimularityBitMap;
      }
    } else {
#line 691
      SimularityBitMap = (u32 )(1 << (int )i) | SimularityBitMap;
    }
  } else {

  }
#line 680
  i = i + 1U;
  ldv_55942: ;
#line 680
  if (i < bound) {
#line 682
    goto ldv_55941;
  } else {

  }

#line 696
  if (SimularityBitMap == 0U) {
#line 697
    i = 0U;
#line 697
    goto ldv_55948;
    ldv_55947: ;
#line 698
    if ((unsigned int )final_candidate[i] != 255U) {
#line 699
      j = i * 4U;
#line 699
      goto ldv_55945;
      ldv_55944: 
#line 700
      (*(result + 3UL))[j] = (*(result + (unsigned long )final_candidate[i]))[j];
#line 699
      j = j + 1U;
      ldv_55945: ;
#line 699
      if ((i + 1U) * 4U - 2U > j) {
#line 701
        goto ldv_55944;
      } else {

      }
#line 701
      bResult = 0;
    } else {

    }
#line 697
    i = i + 1U;
    ldv_55948: ;
#line 697
    if (bound / 4U > i) {
#line 699
      goto ldv_55947;
    } else {

    }

#line 704
    return (bResult);
  } else
#line 705
  if ((SimularityBitMap & 15U) == 0U) {
#line 707
    i = 0U;
#line 707
    goto ldv_55951;
    ldv_55950: 
#line 708
    (*(result + 3UL))[i] = (*(result + (unsigned long )c1))[i];
#line 707
    i = i + 1U;
    ldv_55951: ;
#line 707
    if (i <= 3U) {
#line 709
      goto ldv_55950;
    } else {

    }

#line 709
    return (0);
  } else
#line 710
  if ((SimularityBitMap & 240U) == 0U && (unsigned int )pHalData->rf_type == 2U) {
#line 712
    i = 4U;
#line 712
    goto ldv_55954;
    ldv_55953: 
#line 713
    (*(result + 3UL))[i] = (*(result + (unsigned long )c1))[i];
#line 712
    i = i + 1U;
    ldv_55954: ;
#line 712
    if (i <= 7U) {
#line 714
      goto ldv_55953;
    } else {

    }

#line 714
    return (0);
  } else {
#line 716
    return (0);
  }
}
}
#line 720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static void _PHY_IQCalibrate(struct rtw_adapter *pAdapter , int (*result)[8U] , u8 t ,
                             bool is2T ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u32 i ;
  u8 PathAOK ;
  u8 PathBOK ;
  u32 ADDA_REG[16U] ;
  u32 IQK_MAC_REG[4U] ;
  u32 IQK_BB_REG_92C[9U] ;
  u32 retryCount ;
  u32 bbvalue ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;

  {
#line 722
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 723
  pdmpriv = & pHalData->dmpriv;
#line 726
  ADDA_REG[0] = 2140U;
#line 726
  ADDA_REG[1] = 3692U;
#line 726
  ADDA_REG[2] = 3696U;
#line 726
  ADDA_REG[3] = 3700U;
#line 726
  ADDA_REG[4] = 3704U;
#line 726
  ADDA_REG[5] = 3708U;
#line 726
  ADDA_REG[6] = 3712U;
#line 726
  ADDA_REG[7] = 3716U;
#line 726
  ADDA_REG[8] = 3720U;
#line 726
  ADDA_REG[9] = 3724U;
#line 726
  ADDA_REG[10] = 3792U;
#line 726
  ADDA_REG[11] = 3796U;
#line 726
  ADDA_REG[12] = 3800U;
#line 726
  ADDA_REG[13] = 3804U;
#line 726
  ADDA_REG[14] = 3808U;
#line 726
  ADDA_REG[15] = 3820U;
#line 737
  IQK_MAC_REG[0] = 1314U;
#line 737
  IQK_MAC_REG[1] = 1360U;
#line 737
  IQK_MAC_REG[2] = 1361U;
#line 737
  IQK_MAC_REG[3] = 64U;
#line 742
  IQK_BB_REG_92C[0] = 3076U;
#line 742
  IQK_BB_REG_92C[1] = 3080U;
#line 742
  IQK_BB_REG_92C[2] = 2164U;
#line 742
  IQK_BB_REG_92C[3] = 2920U;
#line 742
  IQK_BB_REG_92C[4] = 2924U;
#line 742
  IQK_BB_REG_92C[5] = 2160U;
#line 742
  IQK_BB_REG_92C[6] = 2144U;
#line 742
  IQK_BB_REG_92C[7] = 2148U;
#line 742
  IQK_BB_REG_92C[8] = 2048U;
#line 749
  retryCount = 2U;
#line 756
  if ((unsigned int )t == 0U) {
#line 757
    bbvalue = rtl8723au_read32(pAdapter, 2048);
#line 760
    _PHY_SaveADDARegisters(pAdapter, (u32 *)(& ADDA_REG), (u32 *)(& pdmpriv->ADDA_backup),
                           16U);
#line 761
    _PHY_SaveMACRegisters(pAdapter, (u32 *)(& IQK_MAC_REG), (u32 *)(& pdmpriv->IQK_MAC_backup));
#line 762
    _PHY_SaveADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup),
                           9U);
  } else {

  }
#line 764
  _PHY_PathADDAOn(pAdapter, (u32 *)(& ADDA_REG), 1, (int )is2T);
#line 766
  if ((unsigned int )t == 0U) {
#line 767
    tmp = PHY_QueryBBReg(pAdapter, 2080U, 256U);
#line 767
    pdmpriv->bRfPiEnable = (unsigned char )tmp;
  } else {

  }
#line 771
  if ((unsigned int )pdmpriv->bRfPiEnable == 0U) {
#line 773
    _PHY_PIModeSwitch(pAdapter, 1);
  } else {

  }
#line 776
  PHY_SetBBReg(pAdapter, 2048U, 16777216U, 0U);
#line 777
  rtl8723au_write32(pAdapter, 3076, 60839424U);
#line 778
  rtl8723au_write32(pAdapter, 3080, 524516U);
#line 779
  rtl8723au_write32(pAdapter, 2164, 572538880U);
#line 780
  PHY_SetBBReg(pAdapter, 2160U, 1024U, 1U);
#line 781
  PHY_SetBBReg(pAdapter, 2160U, 67108864U, 1U);
#line 782
  PHY_SetBBReg(pAdapter, 2144U, 1024U, 0U);
#line 783
  PHY_SetBBReg(pAdapter, 2148U, 1024U, 0U);
#line 785
  if ((int )is2T) {
#line 786
    rtl8723au_write32(pAdapter, 2112, 65536U);
#line 788
    rtl8723au_write32(pAdapter, 2116, 65536U);
  } else {

  }
#line 793
  _PHY_MACSettingCalibration(pAdapter, (u32 *)(& IQK_MAC_REG), (u32 *)(& pdmpriv->IQK_MAC_backup));
#line 796
  rtl8723au_write32(pAdapter, 2920, 524288U);
#line 798
  if ((int )is2T) {
#line 799
    rtl8723au_write32(pAdapter, 2924, 524288U);
  } else {

  }
#line 802
  rtl8723au_write32(pAdapter, 3624, 2155872256U);
#line 803
  rtl8723au_write32(pAdapter, 3648, 16808960U);
#line 804
  rtl8723au_write32(pAdapter, 3652, 16795648U);
#line 806
  i = 0U;
#line 806
  goto ldv_55974;
  ldv_55973: 
#line 807
  PathAOK = _PHY_PathA_IQK(pAdapter, (int )is2T);
#line 808
  if ((unsigned int )PathAOK == 3U) {
#line 809
    if (GlobalDebugLevel23A > 3U) {
#line 809
      printk("\016RTL8723AU: Path A IQK Success!!\n");
    } else {

    }
#line 810
    tmp___0 = rtl8723au_read32(pAdapter, 3732);
#line 810
    (*(result + (unsigned long )t))[0] = (int )((tmp___0 & 67043328U) >> 16);
#line 811
    tmp___1 = rtl8723au_read32(pAdapter, 3740);
#line 811
    (*(result + (unsigned long )t))[1] = (int )((tmp___1 & 67043328U) >> 16);
#line 812
    tmp___2 = rtl8723au_read32(pAdapter, 3748);
#line 812
    (*(result + (unsigned long )t))[2] = (int )((tmp___2 & 67043328U) >> 16);
#line 813
    tmp___3 = rtl8723au_read32(pAdapter, 3756);
#line 813
    (*(result + (unsigned long )t))[3] = (int )((tmp___3 & 67043328U) >> 16);
#line 814
    goto ldv_55972;
  } else
#line 815
  if (retryCount - 1U == i && (unsigned int )PathAOK == 1U) {
#line 817
    if (GlobalDebugLevel23A > 3U) {
#line 817
      printk("\016RTL8723AU: Path A IQK Only  Tx Success!!\n");
    } else {

    }
#line 819
    tmp___4 = rtl8723au_read32(pAdapter, 3732);
#line 819
    (*(result + (unsigned long )t))[0] = (int )((tmp___4 & 67043328U) >> 16);
#line 820
    tmp___5 = rtl8723au_read32(pAdapter, 3740);
#line 820
    (*(result + (unsigned long )t))[1] = (int )((tmp___5 & 67043328U) >> 16);
  } else {

  }
#line 806
  i = i + 1U;
  ldv_55974: ;
#line 806
  if (i < retryCount) {
#line 808
    goto ldv_55973;
  } else {

  }
  ldv_55972: ;
#line 824
  if ((unsigned int )PathAOK == 0U) {
#line 825
    if (GlobalDebugLevel23A > 3U) {
#line 825
      printk("\016RTL8723AU: Path A IQK failed!!\n");
    } else {

    }
  } else {

  }
#line 828
  if ((int )is2T) {
#line 829
    _PHY_PathAStandBy(pAdapter);
#line 832
    _PHY_PathADDAOn(pAdapter, (u32 *)(& ADDA_REG), 0, (int )is2T);
#line 834
    i = 0U;
#line 834
    goto ldv_55977;
    ldv_55976: 
#line 835
    PathBOK = _PHY_PathB_IQK(pAdapter);
#line 836
    if ((unsigned int )PathBOK == 3U) {
#line 837
      if (GlobalDebugLevel23A > 3U) {
#line 837
        printk("\016RTL8723AU: Path B IQK Success!!\n");
      } else {

      }
#line 838
      tmp___6 = rtl8723au_read32(pAdapter, 3764);
#line 838
      (*(result + (unsigned long )t))[4] = (int )((tmp___6 & 67043328U) >> 16);
#line 839
      tmp___7 = rtl8723au_read32(pAdapter, 3772);
#line 839
      (*(result + (unsigned long )t))[5] = (int )((tmp___7 & 67043328U) >> 16);
#line 840
      tmp___8 = rtl8723au_read32(pAdapter, 3780);
#line 840
      (*(result + (unsigned long )t))[6] = (int )((tmp___8 & 67043328U) >> 16);
#line 841
      tmp___9 = rtl8723au_read32(pAdapter, 3788);
#line 841
      (*(result + (unsigned long )t))[7] = (int )((tmp___9 & 67043328U) >> 16);
#line 842
      goto ldv_55975;
    } else
#line 843
    if (retryCount - 1U == i && (unsigned int )PathBOK == 1U) {
#line 845
      if (GlobalDebugLevel23A > 3U) {
#line 845
        printk("\016RTL8723AU: Path B Only Tx IQK Success!!\n");
      } else {

      }
#line 846
      tmp___10 = rtl8723au_read32(pAdapter, 3764);
#line 846
      (*(result + (unsigned long )t))[4] = (int )((tmp___10 & 67043328U) >> 16);
#line 847
      tmp___11 = rtl8723au_read32(pAdapter, 3772);
#line 847
      (*(result + (unsigned long )t))[5] = (int )((tmp___11 & 67043328U) >> 16);
    } else {

    }
#line 834
    i = i + 1U;
    ldv_55977: ;
#line 834
    if (i < retryCount) {
#line 836
      goto ldv_55976;
    } else {

    }
    ldv_55975: ;
#line 851
    if ((unsigned int )PathBOK == 0U) {
#line 852
      if (GlobalDebugLevel23A > 3U) {
#line 852
        printk("\016RTL8723AU: Path B IQK failed!!\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 857
  rtl8723au_write32(pAdapter, 3624, 0U);
#line 859
  if ((unsigned int )t != 0U) {
#line 860
    if ((unsigned int )pdmpriv->bRfPiEnable == 0U) {
#line 862
      _PHY_PIModeSwitch(pAdapter, 0);
    } else {

    }
#line 866
    _PHY_ReloadADDARegisters(pAdapter, (u32 *)(& ADDA_REG), (u32 *)(& pdmpriv->ADDA_backup),
                             16U);
#line 869
    _PHY_ReloadMACRegisters(pAdapter, (u32 *)(& IQK_MAC_REG), (u32 *)(& pdmpriv->IQK_MAC_backup));
#line 872
    _PHY_ReloadADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup),
                             9U);
#line 875
    rtl8723au_write32(pAdapter, 2112, 208595U);
#line 877
    if ((int )is2T) {
#line 878
      rtl8723au_write32(pAdapter, 2116, 208595U);
    } else {

    }
#line 883
    rtl8723au_write32(pAdapter, 3632, 16813056U);
#line 884
    rtl8723au_write32(pAdapter, 3636, 16813056U);
  } else {

  }
#line 886
  return;
}
}
#line 889 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
static void _PHY_LCCalibrate(struct rtw_adapter *pAdapter , bool is2T ) 
{ 
  u8 tmpReg ;
  u32 RF_Amode ;
  u32 RF_Bmode ;
  u32 LC_Cal ;

  {
#line 892
  RF_Amode = 0U;
#line 892
  RF_Bmode = 0U;
#line 895
  tmpReg = rtl8723au_read8(pAdapter, 3331);
#line 897
  if (((int )tmpReg & 112) != 0) {
#line 900
    rtl8723au_write8(pAdapter, 3331, (int )tmpReg & 143);
  } else {
#line 904
    rtl8723au_write8(pAdapter, 1314, 255);
  }
#line 907
  if (((int )tmpReg & 112) != 0) {
#line 910
    RF_Amode = PHY_QueryRFReg(pAdapter, 0, 0U, 4095U);
#line 913
    if ((int )is2T) {
#line 914
      RF_Bmode = PHY_QueryRFReg(pAdapter, 1, 0U, 4095U);
    } else {

    }
#line 918
    PHY_SetRFReg(pAdapter, 0, 0U, 4095U, (RF_Amode & 589823U) | 65536U);
#line 921
    if ((int )is2T) {
#line 922
      PHY_SetRFReg(pAdapter, 1, 0U, 4095U, (RF_Bmode & 589823U) | 65536U);
    } else {

    }
  } else {

  }
#line 926
  LC_Cal = PHY_QueryRFReg(pAdapter, 0, 24U, 4095U);
#line 929
  PHY_SetRFReg(pAdapter, 0, 24U, 4095U, LC_Cal | 32768U);
#line 931
  msleep(100U);
#line 934
  if (((int )tmpReg & 112) != 0) {
#line 936
    rtl8723au_write8(pAdapter, 3331, (int )tmpReg);
#line 937
    PHY_SetRFReg(pAdapter, 0, 0U, 4095U, RF_Amode);
#line 940
    if ((int )is2T) {
#line 941
      PHY_SetRFReg(pAdapter, 1, 0U, 4095U, RF_Bmode);
    } else {

    }
  } else {
#line 943
    rtl8723au_write8(pAdapter, 1314, 0);
  }
#line 944
  return;
}
}
#line 951 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
void rtl8723a_phy_iq_calibrate(struct rtw_adapter *pAdapter , bool bReCovery ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  s32 result[4U][8U] ;
  u8 i ;
  u8 final_candidate ;
  bool bPathAOK ;
  bool bPathBOK ;
  s32 RegE94 ;
  s32 RegE9C ;
  s32 RegEA4 ;
  s32 RegEAC ;
  s32 RegEB4 ;
  s32 RegEBC ;
  s32 RegEC4 ;
  s32 RegECC ;
  s32 RegTmp ;
  bool is12simular ;
  bool is13simular ;
  bool is23simular ;
  bool bStartContTx ;
  bool bSingleTone ;
  bool bCarrierSuppression ;
  u32 IQK_BB_REG_92C[9U] ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;

  {
#line 953
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 954
  pdmpriv = & pHalData->dmpriv;
#line 959
  RegTmp = 0;
#line 961
  bStartContTx = 0;
#line 961
  bSingleTone = 0;
#line 962
  bCarrierSuppression = 0;
#line 963
  IQK_BB_REG_92C[0] = 3092U;
#line 963
  IQK_BB_REG_92C[1] = 3100U;
#line 963
  IQK_BB_REG_92C[2] = 3148U;
#line 963
  IQK_BB_REG_92C[3] = 3192U;
#line 963
  IQK_BB_REG_92C[4] = 3200U;
#line 963
  IQK_BB_REG_92C[5] = 3208U;
#line 963
  IQK_BB_REG_92C[6] = 3220U;
#line 963
  IQK_BB_REG_92C[7] = 3228U;
#line 963
  IQK_BB_REG_92C[8] = 3232U;
#line 972
  if (((int )bStartContTx || (int )bSingleTone) || (int )bCarrierSuppression) {
#line 973
    return;
  } else {

  }
#line 975
  if ((int )bReCovery) {
#line 976
    _PHY_ReloadADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup_recover),
                             9U);
#line 977
    return;
  } else {

  }
#line 979
  if (GlobalDebugLevel23A > 3U) {
#line 979
    printk("\016RTL8723AU: IQK:Start!!!\n");
  } else {

  }
#line 981
  i = 0U;
#line 981
  goto ldv_56014;
  ldv_56013: 
#line 982
  result[0][(int )i] = 0;
#line 983
  result[1][(int )i] = 0;
#line 984
  result[2][(int )i] = 0;
#line 985
  result[3][(int )i] = 0;
#line 981
  i = (u8 )((int )i + 1);
  ldv_56014: ;
#line 981
  if ((unsigned int )i <= 7U) {
#line 983
    goto ldv_56013;
  } else {

  }
#line 987
  final_candidate = 255U;
#line 988
  bPathAOK = 0;
#line 989
  bPathBOK = 0;
#line 990
  is12simular = 0;
#line 991
  is23simular = 0;
#line 992
  is13simular = 0;
#line 994
  i = 0U;
#line 994
  goto ldv_56021;
  ldv_56020: ;
#line 995
  if ((unsigned int )pHalData->rf_type == 2U) {
#line 996
    _PHY_IQCalibrate(pAdapter, (int (*)[8])(& result), (int )i, 1);
  } else {
#line 998
    _PHY_IQCalibrate(pAdapter, (int (*)[8])(& result), (int )i, 0);
  }
#line 1000
  if ((unsigned int )i == 1U) {
#line 1001
    is12simular = _PHY_SimularityCompare(pAdapter, (int (*)[8])(& result), 0, 1);
#line 1002
    if ((int )is12simular) {
#line 1003
      final_candidate = 0U;
#line 1004
      goto ldv_56016;
    } else {

    }
  } else {

  }
#line 1008
  if ((unsigned int )i == 2U) {
#line 1009
    is13simular = _PHY_SimularityCompare(pAdapter, (int (*)[8])(& result), 0, 2);
#line 1010
    if ((int )is13simular) {
#line 1011
      final_candidate = 0U;
#line 1012
      goto ldv_56016;
    } else {

    }
#line 1015
    is23simular = _PHY_SimularityCompare(pAdapter, (int (*)[8])(& result), 1, 2);
#line 1016
    if ((int )is23simular) {
#line 1017
      final_candidate = 1U;
    } else {
#line 1019
      i = 0U;
#line 1019
      goto ldv_56018;
      ldv_56017: 
#line 1020
      RegTmp = result[3][(int )i] + RegTmp;
#line 1019
      i = (u8 )((int )i + 1);
      ldv_56018: ;
#line 1019
      if ((unsigned int )i <= 7U) {
#line 1021
        goto ldv_56017;
      } else {

      }

#line 1022
      if (RegTmp != 0) {
#line 1023
        final_candidate = 3U;
      } else {
#line 1025
        final_candidate = 255U;
      }
    }
  } else {

  }
#line 994
  i = (u8 )((int )i + 1);
  ldv_56021: ;
#line 994
  if ((unsigned int )i <= 2U) {
#line 996
    goto ldv_56020;
  } else {

  }
  ldv_56016: 
#line 1030
  i = 0U;
#line 1030
  goto ldv_56023;
  ldv_56022: 
#line 1031
  RegE94 = result[(int )i][0];
#line 1032
  RegE9C = result[(int )i][1];
#line 1033
  RegEA4 = result[(int )i][2];
#line 1034
  RegEAC = result[(int )i][3];
#line 1035
  RegEB4 = result[(int )i][4];
#line 1036
  RegEBC = result[(int )i][5];
#line 1037
  RegEC4 = result[(int )i][6];
#line 1038
  RegECC = result[(int )i][7];
#line 1030
  i = (u8 )((int )i + 1);
  ldv_56023: ;
#line 1030
  if ((unsigned int )i <= 3U) {
#line 1032
    goto ldv_56022;
  } else {

  }

#line 1041
  if ((unsigned int )final_candidate != 255U) {
#line 1042
    RegE94 = result[(int )final_candidate][0];
#line 1043
    pdmpriv->RegE94 = RegE94;
#line 1044
    RegE9C = result[(int )final_candidate][1];
#line 1045
    pdmpriv->RegE9C = RegE9C;
#line 1046
    RegEA4 = result[(int )final_candidate][2];
#line 1047
    RegEAC = result[(int )final_candidate][3];
#line 1048
    RegEB4 = result[(int )final_candidate][4];
#line 1049
    pdmpriv->RegEB4 = RegEB4;
#line 1050
    RegEBC = result[(int )final_candidate][5];
#line 1051
    pdmpriv->RegEBC = RegEBC;
#line 1052
    RegEC4 = result[(int )final_candidate][6];
#line 1053
    RegECC = result[(int )final_candidate][7];
#line 1054
    if (GlobalDebugLevel23A > 3U) {
#line 1054
      printk("\016RTL8723AU: IQK: final_candidate is %x\n", (int )final_candidate);
    } else {

    }
#line 1055
    if (GlobalDebugLevel23A > 3U) {
#line 1055
      printk("\016RTL8723AU: IQK: RegE94 =%x RegE9C =%x RegEA4 =%x RegEAC =%x RegEB4 =%x RegEBC =%x RegEC4 =%x RegECC =%x\n ",
             RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC);
    } else {

    }
#line 1057
    bPathBOK = 1;
#line 1057
    bPathAOK = bPathBOK;
  } else {
#line 1059
    tmp___0 = 256;
#line 1059
    pdmpriv->RegEB4 = tmp___0;
#line 1059
    tmp = tmp___0;
#line 1059
    pdmpriv->RegE94 = tmp;
#line 1059
    RegEB4 = tmp;
#line 1059
    RegE94 = RegEB4;
#line 1060
    tmp___2 = 0;
#line 1060
    pdmpriv->RegEBC = tmp___2;
#line 1060
    tmp___1 = tmp___2;
#line 1060
    pdmpriv->RegE9C = tmp___1;
#line 1060
    RegEBC = tmp___1;
#line 1060
    RegE9C = RegEBC;
  }
#line 1063
  if (RegE94 != 0) {
#line 1064
    _PHY_PathAFillIQKMatrix(pAdapter, (int )bPathAOK, (int (*)[8])(& result), (int )final_candidate,
                            RegEA4 == 0);
  } else {

  }
#line 1066
  if ((unsigned int )pHalData->rf_type == 2U) {
#line 1067
    if (RegEB4 != 0) {
#line 1068
      _PHY_PathBFillIQKMatrix(pAdapter, (int )bPathBOK, (int (*)[8])(& result), (int )final_candidate,
                              RegEC4 == 0);
    } else {

    }
  } else {

  }
#line 1072
  _PHY_SaveADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup_recover),
                         9U);
#line 1073
  return;
}
}
#line 1075 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
void rtl8723a_phy_lc_calibrate(struct rtw_adapter *pAdapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct mlme_ext_priv *pmlmeext ;
  bool bStartContTx ;
  bool bSingleTone ;
  bool bCarrierSuppression ;

  {
#line 1077
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 1078
  pmlmeext = & pAdapter->mlmeextpriv;
#line 1079
  bStartContTx = 0;
#line 1079
  bSingleTone = 0;
#line 1079
  bCarrierSuppression = 0;
#line 1082
  if (((int )bStartContTx || (int )bSingleTone) || (int )bCarrierSuppression) {
#line 1083
    return;
  } else {

  }
#line 1085
  if (pmlmeext->sitesurvey_res.state == 3) {
#line 1086
    return;
  } else {

  }
#line 1088
  if ((unsigned int )pHalData->rf_type == 2U) {
#line 1089
    _PHY_LCCalibrate(pAdapter, 1);
  } else {
#line 1091
    _PHY_LCCalibrate(pAdapter, 0);
  }
#line 1092
  return;
}
}
#line 1095 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.c"
void rtl8723a_phy_ap_calibrate(struct rtw_adapter *pAdapter , char delta ) 
{ 


  {
#line 1097
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
bool ldv_queue_work_on_327(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
bool ldv_queue_delayed_work_on_328(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
bool ldv_queue_work_on_329(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
void ldv_flush_workqueue_330(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
bool ldv_queue_delayed_work_on_331(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_341(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_343(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_342(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_345(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_344(struct workqueue_struct *ldv_func_arg1 ) ;
#line 24 "drivers/staging/rtl8723au/include/HalHWImg8723A_RF.h"
void ODM_ReadAndConfig_AGC_TAB_1T_8723A(struct dm_odm_t *pDM_Odm ) ;
#line 30 "drivers/staging/rtl8723au/include/HalHWImg8723A_BB.h"
void ODM_ReadAndConfig_PHY_REG_1T_8723A(struct dm_odm_t *pDM_Odm ) ;
#line 36
void ODM_ReadAndConfig_PHY_REG_MP_8723A(struct dm_odm_t *pDM_Odm ) ;
#line 23 "drivers/staging/rtl8723au/include/odm_RegConfig8723A.h"
void odm_ConfigBB_AGC_8723A(struct dm_odm_t *pDM_Odm , u32 addr , u32 data ) ;
#line 25
void odm_ConfigBB_PHY_8723A(struct dm_odm_t *pDM_Odm , u32 addr , u32 data ) ;
#line 18 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.c"
static bool CheckCondition(u32 const   Condition , u32 const   Hex ) 
{ 
  u32 _board ;
  u32 _interface ;
  u32 _platform ;
  u32 cond ;

  {
#line 20
  _board = (unsigned int )Hex & 255U;
#line 21
  _interface = ((unsigned int )Hex & 65280U) >> 8;
#line 22
  _platform = ((unsigned int )Hex & 16711680U) >> 16;
#line 23
  cond = Condition;
#line 25
  if ((unsigned int )Condition == 3452816845U) {
#line 26
    return (1);
  } else {

  }
#line 28
  cond = (unsigned int )Condition & 255U;
#line 29
  if (_board == cond && cond != 0U) {
#line 30
    return (0);
  } else {

  }
#line 32
  cond = (unsigned int )Condition & 65280U;
#line 33
  cond = cond >> 8;
#line 34
  if ((_interface & cond) == 0U && cond != 7U) {
#line 35
    return (0);
  } else {

  }
#line 37
  cond = (unsigned int )Condition & 16711680U;
#line 38
  cond = cond >> 16;
#line 39
  if ((_platform & cond) == 0U && cond != 15U) {
#line 40
    return (0);
  } else {

  }
#line 41
  return (1);
}
}
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.c"
static u32 Array_AGC_TAB_1T_8723A[320U]  = 
#line 48
  {      3192U,      2063597569U,      3192U,      2063663105U, 
        3192U,      2063728641U,      3192U,      2063794177U, 
        3192U,      2063859713U,      3192U,      2063925249U, 
        3192U,      2047213569U,      3192U,      2030501889U, 
        3192U,      2013790209U,      3192U,      1997078529U, 
        3192U,      1980366849U,      3192U,      1963655169U, 
        3192U,      1946943489U,      3192U,      1930231809U, 
        3192U,      1913520129U,      3192U,      1896808449U, 
        3192U,      1880096769U,      3192U,      1863385089U, 
        3192U,      1846673409U,      3192U,      1829961729U, 
        3192U,      1813250049U,      3192U,      1796538369U, 
        3192U,      1779826689U,      3192U,      1763115009U, 
        3192U,      1746403329U,      3192U,      1729691649U, 
        3192U,      1712979969U,      3192U,      1696268289U, 
        3192U,      1679556609U,      3192U,      1662844929U, 
        3192U,      1646133249U,      3192U,      1629421569U, 
        3192U,      1612709889U,      3192U,      1226899457U, 
        3192U,      1210187777U,      3192U,      1193476097U, 
        3192U,      1176764417U,      3192U,      1160052737U, 
        3192U,      1143341057U,      3192U,      1126629377U, 
        3192U,      1109917697U,      3192U,      1093206017U, 
        3192U,      1076494337U,      3192U,      640352257U, 
        3192U,      623640577U,      3192U,      606928897U, 
        3192U,      590217217U,      3192U,      573505537U, 
        3192U,      556793857U,      3192U,      540082177U, 
        3192U,      103940097U,      3192U,      87228417U, 
        3192U,      70516737U,      3192U,      53805057U, 
        3192U,      37093377U,      3192U,      20381697U, 
        3192U,      3670017U,      3192U,      3735553U, 
        3192U,      3801089U,      3192U,      3866625U, 
        3192U,      3932161U,      3192U,      3997697U, 
        3192U,      4063233U,      3192U,      4128769U, 
        3192U,      2067791873U,      3192U,      2067857409U, 
        3192U,      2067922945U,      3192U,      2067988481U, 
        3192U,      2068054017U,      3192U,      2068119553U, 
        3192U,      2051407873U,      3192U,      2034696193U, 
        3192U,      2017984513U,      3192U,      2001272833U, 
        3192U,      1984561153U,      3192U,      1967849473U, 
        3192U,      1951137793U,      3192U,      1934426113U, 
        3192U,      1917714433U,      3192U,      1901002753U, 
        3192U,      1884291073U,      3192U,      1867579393U, 
        3192U,      1850867713U,      3192U,      1834156033U, 
        3192U,      1817444353U,      3192U,      1800732673U, 
        3192U,      1784020993U,      3192U,      1767309313U, 
        3192U,      1750597633U,      3192U,      1733885953U, 
        3192U,      1717174273U,      3192U,      1700462593U, 
        3192U,      1683750913U,      3192U,      1667039233U, 
        3192U,      1650327553U,      3192U,      1633615873U, 
        3192U,      1616904193U,      3192U,      1231093761U, 
        3192U,      1214382081U,      3192U,      1197670401U, 
        3192U,      1180958721U,      3192U,      1164247041U, 
        3192U,      1147535361U,      3192U,      1130823681U, 
        3192U,      1114112001U,      3192U,      1097400321U, 
        3192U,      1080688641U,      3192U,      644546561U, 
        3192U,      627834881U,      3192U,      611123201U, 
        3192U,      594411521U,      3192U,      577699841U, 
        3192U,      560988161U,      3192U,      544276481U, 
        3192U,      108134401U,      3192U,      91422721U, 
        3192U,      74711041U,      3192U,      57999361U, 
        3192U,      41287681U,      3192U,      24576001U, 
        3192U,      7864321U,      3192U,      7929857U, 
        3192U,      7995393U,      3192U,      8060929U, 
        3192U,      8126465U,      3192U,      8192001U, 
        3192U,      8257537U,      3192U,      8323073U, 
        3192U,      939524126U,      3192U,      939589662U, 
        3192U,      939655198U,      3192U,      939720734U, 
        3192U,      939786270U,      3192U,      939851806U, 
        3192U,      939917342U,      3192U,      939982878U, 
        3192U,      940048414U,      3192U,      1007222814U, 
        3192U,      1040842782U,      3192U,      1074462750U, 
        3192U,      1141637150U,      3192U,      1208811550U, 
        3192U,      1275985950U,      3192U,      1343160350U, 
        3192U,      1376780318U,      3192U,      1443954718U, 
        3192U,      1511129118U,      3192U,      1578303518U, 
        3192U,      1611923486U,      3192U,      1611989022U, 
        3192U,      1612054558U,      3192U,      1645674526U, 
        3192U,      1645740062U,      3192U,      1645805598U, 
        3192U,      1645871134U,      3192U,      1645936670U, 
        3192U,      1646002206U,      3192U,      1646067742U, 
        3192U,      1646133278U,      3192U,      1646198814U};
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.c"
void ODM_ReadAndConfig_AGC_TAB_1T_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 220
  platform = 4U;
#line 221
  board = pDM_Odm->BoardType;
#line 222
  ArrayLen = 320U;
#line 223
  Array = (u32 *)(& Array_AGC_TAB_1T_8723A);
#line 225
  hex = (u32 )board;
#line 226
  hex = hex + 512U;
#line 227
  hex = (u32 )((int )platform << 16) + hex;
#line 228
  hex = hex + 4278190080U;
#line 229
  i = 0U;
#line 229
  goto ldv_55734;
  ldv_55733: 
#line 230
  v1 = *(Array + (unsigned long )i);
#line 231
  v2 = *(Array + (unsigned long )(i + 1U));
#line 234
  if (v1 <= 3452816844U) {
#line 235
    odm_ConfigBB_AGC_8723A(pDM_Odm, v1, v2);
#line 236
    goto ldv_55723;
  } else {
#line 238
    tmp = CheckCondition(*(Array + (unsigned long )i), hex);
#line 238
    if (tmp) {
#line 238
      tmp___0 = 0;
    } else {
#line 238
      tmp___0 = 1;
    }
#line 238
    if (tmp___0) {
#line 240
      i = i + 2U;
#line 240
      v1 = *(Array + (unsigned long )i);
#line 240
      v2 = *(Array + (unsigned long )(i + 1U));
#line 241
      goto ldv_55725;
      ldv_55724: 
#line 244
      i = i + 2U;
#line 244
      v1 = *(Array + (unsigned long )i);
#line 244
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55725: ;
#line 241
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 245
        goto ldv_55724;
      } else {

      }
#line 245
      i = i - 2U;
    } else {
#line 249
      i = i + 2U;
#line 249
      v1 = *(Array + (unsigned long )i);
#line 249
      v2 = *(Array + (unsigned long )(i + 1U));
#line 250
      goto ldv_55728;
      ldv_55727: 
#line 253
      odm_ConfigBB_AGC_8723A(pDM_Odm, v1, v2);
#line 254
      i = i + 2U;
#line 254
      v1 = *(Array + (unsigned long )i);
#line 254
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55728: ;
#line 250
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 254
        goto ldv_55727;
      } else {

      }

#line 256
      goto ldv_55731;
      ldv_55730: 
#line 257
      i = i + 2U;
#line 257
      v1 = *(Array + (unsigned long )i);
#line 257
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55731: ;
#line 256
      if (v2 != 57005U && ArrayLen - 2U > i) {
#line 258
        goto ldv_55730;
      } else {

      }

    }
  }
  ldv_55723: 
#line 229
  i = i + 2U;
  ldv_55734: ;
#line 229
  if (i < ArrayLen) {
#line 231
    goto ldv_55733;
  } else {

  }

#line 236
  return;
}
}
#line 267 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.c"
static u32 Array_PHY_REG_1T_8723A[388U]  = 
#line 267
  {      2048U,      2147745792U,      2052U,      3U, 
        2056U,      64512U,      2060U,      10U, 
        2064U,      268440369U,      2068U,      34356496U, 
        2072U,      35652485U,      2076U,      0U, 
        2080U,      16777472U,      2084U,      3735556U, 
        2088U,      0U,      2092U,      0U, 
        2096U,      0U,      2100U,      0U, 
        2104U,      0U,      2108U,      0U, 
        2112U,      65536U,      2116U,      0U, 
        2120U,      0U,      2124U,      0U, 
        2128U,      0U,      2132U,      0U, 
        2136U,      1452955290U,      2140U,      1779108U, 
        2144U,      1727398160U,      2148U,      102695216U, 
        2152U,      0U,      2156U,      842150400U, 
        2160U,      117442400U,      2164U,      570441728U, 
        2168U,      2056U,      2172U,      0U, 
        2176U,      3221762160U,      2180U,      1237U, 
        2184U,      0U,      2188U,      3435135168U, 
        2192U,      2048U,      2196U,      4294967294U, 
        2200U,      1076895760U,      2204U,      7364688U, 
        2304U,      0U,      2308U,      35U, 
        2312U,      0U,      2316U,      2165444881U, 
        2560U,      13649864U,      2564U,      2164195340U, 
        2568U,      2357428992U,      2572U,      778572303U, 
        2576U,      2499853176U,      2580U,      286539816U, 
        2584U,      8917271U,      2588U,      2299793152U, 
        2592U,      437977088U,      2596U,      151917335U, 
        2600U,      516U,      2604U,      13828096U, 
        2672U,      270515968U,      2676U,      7U, 
        2680U,      2304U,      3072U,      1208425792U, 
        3076U,      60839441U,      3080U,      228U, 
        3084U,      1819044972U,      3088U,      142606336U, 
        3092U,      1073742080U,      3096U,      142606336U, 
        3100U,      1073742080U,      3104U,      0U, 
        3108U,      0U,      3112U,      0U, 
        3116U,      0U,      3120U,      1776921668U, 
        4279173407U,      43981U,      3124U,      1184256719U, 
        3452816845U,      52685U,      3124U,      1184256687U, 
        4279173407U,      57005U,      3128U,      1232689556U, 
        3132U,      177706780U,      3136U,      528236607U, 
        3140U,      65719U,      3144U,      3959554311U, 
        3148U,      8323967U,      3152U,      1767126048U, 
        3156U,      1136394388U,      3160U,      1767126048U, 
        3164U,      1128005780U,      3168U,      0U, 
        4279173407U,      43981U,      3172U,      1897301131U, 
        3452816845U,      52685U,      3172U,      1897038987U, 
        4279173407U,      57005U,      3176U,      1203768319U, 
        3180U,      54U,      3184U,      746520589U, 
        3188U,      25563355U,      3192U,      31U, 
        3196U,      12129810U,      3200U,      1073742080U, 
        3204U,      552992768U,      3208U,      1073742080U, 
        3212U,      538968064U,      3216U,      1185824U, 
        3220U,      0U,      3224U,      1185824U, 
        3228U,      32639U,      3232U,      0U, 
        3236U,      128U,      3240U,      0U, 
        3244U,      0U,      3248U,      0U, 
        3252U,      0U,      3256U,      0U, 
        3260U,      671088640U,      3264U,      0U, 
        3268U,      0U,      3272U,      0U, 
        3276U,      0U,      3280U,      0U, 
        3284U,      0U,      3288U,      1689396263U, 
        3292U,      7760178U,      3296U,      2236962U, 
        3300U,      0U,      3304U,      929317634U, 
        3308U,      798479372U,      3328U,      526144U, 
        3332U,      132097U,      3336U,      36991U, 
        3340U,      536936961U,      3344U,      2690855731U, 
        3348U,      859028547U,      3352U,      2056215403U, 
        3372U,      3432487285U,      3376U,      0U, 
        3380U,      2153807872U,      3384U,      0U, 
        3388U,      160403U,      3392U,      0U, 
        3396U,      0U,      3400U,      0U, 
        3404U,      0U,      3408U,      1681331210U, 
        3412U,      0U,      3416U,      0U, 
        3420U,      805511268U,      3424U,      1179901544U, 
        3428U,      72452668U,      3432U,      8449U, 
        3436U,      706747414U,      3440U,      403846702U, 
        3444U,      841753120U,      3448U,      932900U, 
        3584U,      707406378U,      3588U,      707406378U, 
        3592U,      59779626U,      3600U,      707406378U, 
        3604U,      707406378U,      3608U,      707406378U, 
        3612U,      707406378U,      3624U,      0U, 
        3632U,      268491807U,      3636U,      268471327U, 
        3640U,      34865410U,      3644U,      1746273474U, 
        3648U,      16808960U,      3652U,      16795648U, 
        3656U,      4211081216U,      3660U,      10449U, 
        3664U,      268491807U,      3668U,      268471327U, 
        3672U,      34865410U,      3676U,      672533765U, 
        3680U,      8U,      3688U,      1779108U, 
        3692U,      1662723488U,      3696U,      1662723488U, 
        3700U,      135996832U,      3704U,      135996832U, 
        3708U,      135996832U,      3712U,      135996832U, 
        3716U,      1662723488U,      3720U,      135996832U, 
        3724U,      1662723488U,      3792U,      1662723488U, 
        3796U,      1662723488U,      3800U,      1662723488U, 
        3804U,      1779104U,      3808U,      1779104U, 
        3820U,      1796941216U,      3860U,      3U, 
        3916U,      0U,      3840U,      768U};
#line 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.c"
void ODM_ReadAndConfig_PHY_REG_1T_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 466
  hex = 0U;
#line 467
  i = 0U;
#line 468
  platform = 4U;
#line 469
  board = pDM_Odm->BoardType;
#line 470
  ArrayLen = 388U;
#line 471
  Array = (u32 *)(& Array_PHY_REG_1T_8723A);
#line 473
  hex = (u32 )board + hex;
#line 474
  hex = hex + 512U;
#line 475
  hex = (u32 )((int )platform << 16) + hex;
#line 476
  hex = hex + 4278190080U;
#line 477
  i = 0U;
#line 477
  goto ldv_55759;
  ldv_55758: 
#line 478
  v1 = *(Array + (unsigned long )i);
#line 479
  v2 = *(Array + (unsigned long )(i + 1U));
#line 482
  if (v1 <= 3452816844U) {
#line 483
    odm_ConfigBB_PHY_8723A(pDM_Odm, v1, v2);
#line 484
    goto ldv_55748;
  } else {
#line 486
    tmp = CheckCondition(*(Array + (unsigned long )i), hex);
#line 486
    if (tmp) {
#line 486
      tmp___0 = 0;
    } else {
#line 486
      tmp___0 = 1;
    }
#line 486
    if (tmp___0) {
#line 488
      i = i + 2U;
#line 488
      v1 = *(Array + (unsigned long )i);
#line 488
      v2 = *(Array + (unsigned long )(i + 1U));
#line 489
      goto ldv_55750;
      ldv_55749: 
#line 492
      i = i + 2U;
#line 492
      v1 = *(Array + (unsigned long )i);
#line 492
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55750: ;
#line 489
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 493
        goto ldv_55749;
      } else {

      }
#line 493
      i = i - 2U;
    } else {
#line 497
      i = i + 2U;
#line 497
      v1 = *(Array + (unsigned long )i);
#line 497
      v2 = *(Array + (unsigned long )(i + 1U));
#line 498
      goto ldv_55753;
      ldv_55752: 
#line 501
      odm_ConfigBB_PHY_8723A(pDM_Odm, v1, v2);
#line 502
      i = i + 2U;
#line 502
      v1 = *(Array + (unsigned long )i);
#line 502
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55753: ;
#line 498
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 502
        goto ldv_55752;
      } else {

      }

#line 504
      goto ldv_55756;
      ldv_55755: 
#line 505
      i = i + 2U;
#line 505
      v1 = *(Array + (unsigned long )i);
#line 505
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55756: ;
#line 504
      if (v2 != 57005U && ArrayLen - 2U > i) {
#line 506
        goto ldv_55755;
      } else {

      }

    }
  }
  ldv_55748: 
#line 477
  i = i + 2U;
  ldv_55759: ;
#line 477
  if (i < ArrayLen) {
#line 479
    goto ldv_55758;
  } else {

  }

#line 484
  return;
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.c"
static u32 Array_PHY_REG_MP_8723A[4U]  = {      3120U,      1776921674U,      3132U,      177706776U};
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.c"
void ODM_ReadAndConfig_PHY_REG_MP_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 522
  hex = 0U;
#line 524
  platform = 4U;
#line 525
  board = pDM_Odm->BoardType;
#line 526
  ArrayLen = 4U;
#line 527
  Array = (u32 *)(& Array_PHY_REG_MP_8723A);
#line 529
  hex = (u32 )board + hex;
#line 530
  hex = hex + 512U;
#line 531
  hex = (u32 )((int )platform << 16) + hex;
#line 532
  hex = hex + 4278190080U;
#line 533
  i = 0U;
#line 533
  goto ldv_55784;
  ldv_55783: 
#line 534
  v1 = *(Array + (unsigned long )i);
#line 535
  v2 = *(Array + (unsigned long )(i + 1U));
#line 538
  if (v1 <= 3452816844U) {
#line 539
    odm_ConfigBB_PHY_8723A(pDM_Odm, v1, v2);
#line 540
    goto ldv_55773;
  } else {
#line 542
    tmp = CheckCondition(*(Array + (unsigned long )i), hex);
#line 542
    if (tmp) {
#line 542
      tmp___0 = 0;
    } else {
#line 542
      tmp___0 = 1;
    }
#line 542
    if (tmp___0) {
#line 544
      i = i + 2U;
#line 544
      v1 = *(Array + (unsigned long )i);
#line 544
      v2 = *(Array + (unsigned long )(i + 1U));
#line 545
      goto ldv_55775;
      ldv_55774: 
#line 548
      i = i + 2U;
#line 548
      v1 = *(Array + (unsigned long )i);
#line 548
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55775: ;
#line 545
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 549
        goto ldv_55774;
      } else {

      }
#line 549
      i = i - 2U;
    } else {
#line 553
      i = i + 2U;
#line 553
      v1 = *(Array + (unsigned long )i);
#line 553
      v2 = *(Array + (unsigned long )(i + 1U));
#line 554
      goto ldv_55778;
      ldv_55777: 
#line 557
      odm_ConfigBB_PHY_8723A(pDM_Odm, v1, v2);
#line 558
      i = i + 2U;
#line 558
      v1 = *(Array + (unsigned long )i);
#line 558
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55778: ;
#line 554
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 558
        goto ldv_55777;
      } else {

      }

#line 560
      goto ldv_55781;
      ldv_55780: 
#line 561
      i = i + 2U;
#line 561
      v1 = *(Array + (unsigned long )i);
#line 561
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55781: ;
#line 560
      if (v2 != 57005U && ArrayLen - 2U > i) {
#line 562
        goto ldv_55780;
      } else {

      }

    }
  }
  ldv_55773: 
#line 533
  i = i + 2U;
  ldv_55784: ;
#line 533
  if (i < ArrayLen) {
#line 535
    goto ldv_55783;
  } else {

  }

#line 540
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
bool ldv_queue_work_on_341(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
bool ldv_queue_delayed_work_on_342(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
bool ldv_queue_work_on_343(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
void ldv_flush_workqueue_344(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
bool ldv_queue_delayed_work_on_345(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_355(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_357(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_356(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_359(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_358(struct workqueue_struct *ldv_func_arg1 ) ;
#line 24 "drivers/staging/rtl8723au/include/HalHWImg8723A_MAC.h"
void ODM_ReadAndConfig_MAC_REG_8723A(struct dm_odm_t *pDM_Odm ) ;
#line 21 "drivers/staging/rtl8723au/include/odm_RegConfig8723A.h"
void odm_ConfigMAC_8723A(struct dm_odm_t *pDM_Odm , u32 addr , u8 data ) ;
#line 18 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.c"
static bool CheckCondition___0(u32 const   Condition , u32 const   Hex ) 
{ 
  u32 _board ;
  u32 _interface ;
  u32 _platform ;
  u32 cond ;

  {
#line 20
  _board = (unsigned int )Hex & 255U;
#line 21
  _interface = ((unsigned int )Hex & 65280U) >> 8;
#line 22
  _platform = ((unsigned int )Hex & 16711680U) >> 16;
#line 23
  cond = Condition;
#line 25
  if ((unsigned int )Condition == 3452816845U) {
#line 26
    return (1);
  } else {

  }
#line 28
  cond = (unsigned int )Condition & 255U;
#line 29
  if (_board == cond && cond != 0U) {
#line 30
    return (0);
  } else {

  }
#line 32
  cond = (unsigned int )Condition & 65280U;
#line 33
  cond = cond >> 8;
#line 34
  if ((_interface & cond) == 0U && cond != 7U) {
#line 35
    return (0);
  } else {

  }
#line 37
  cond = (unsigned int )Condition & 16711680U;
#line 38
  cond = cond >> 16;
#line 39
  if ((_platform & cond) == 0U && cond != 15U) {
#line 40
    return (0);
  } else {

  }
#line 41
  return (1);
}
}
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.c"
static u32 Array_MAC_REG_8723A[172U]  = 
#line 48
  {      1056U,      128U,      1059U,      0U, 
        1072U,      0U,      1073U,      0U, 
        1074U,      0U,      1075U,      1U, 
        1076U,      4U,      1077U,      5U, 
        1078U,      6U,      1079U,      7U, 
        1080U,      0U,      1081U,      0U, 
        1082U,      0U,      1083U,      1U, 
        1084U,      4U,      1085U,      5U, 
        1086U,      6U,      1087U,      7U, 
        1088U,      93U,      1089U,      1U, 
        1090U,      0U,      1092U,      21U, 
        1093U,      240U,      1094U,      15U, 
        1095U,      0U,      1112U,      65U, 
        1113U,      168U,      1114U,      114U, 
        1115U,      185U,      1120U,      102U, 
        1121U,      102U,      1122U,      8U, 
        1123U,      3U,      1224U,      255U, 
        1225U,      8U,      1228U,      255U, 
        1229U,      255U,      1230U,      1U, 
        1280U,      38U,      1281U,      162U, 
        1282U,      47U,      1283U,      0U, 
        1284U,      40U,      1285U,      163U, 
        1286U,      94U,      1287U,      0U, 
        1288U,      43U,      1289U,      164U, 
        1290U,      94U,      1291U,      0U, 
        1292U,      79U,      1293U,      164U, 
        1294U,      0U,      1295U,      0U, 
        1298U,      28U,      1300U,      10U, 
        1301U,      16U,      1302U,      10U, 
        1303U,      16U,      1306U,      22U, 
        1316U,      15U,      1317U,      79U, 
        1350U,      64U,      1351U,      0U, 
        1360U,      16U,      1361U,      16U, 
        1369U,      2U,      1370U,      2U, 
        1373U,      255U,      1541U,      48U, 
        1544U,      14U,      1545U,      42U, 
        1618U,      32U,      1596U,      10U, 
        1597U,      10U,      1598U,      14U, 
        1599U,      14U,      1646U,      5U, 
        1792U,      33U,      1793U,      67U, 
        1794U,      101U,      1795U,      135U, 
        1800U,      33U,      1801U,      67U, 
        1802U,      101U,      1803U,      135U};
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.c"
void ODM_ReadAndConfig_MAC_REG_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 144
  hex = 0U;
#line 145
  i = 0U;
#line 146
  platform = 4U;
#line 147
  board = pDM_Odm->BoardType;
#line 148
  ArrayLen = 172U;
#line 149
  Array = (u32 *)(& Array_MAC_REG_8723A);
#line 151
  hex = (u32 )board + hex;
#line 152
  hex = hex + 512U;
#line 153
  hex = (u32 )((int )platform << 16) + hex;
#line 154
  hex = hex + 4278190080U;
#line 155
  i = 0U;
#line 155
  goto ldv_55734;
  ldv_55733: 
#line 156
  v1 = *(Array + (unsigned long )i);
#line 157
  v2 = *(Array + (unsigned long )(i + 1U));
#line 160
  if (v1 <= 3452816844U) {
#line 161
    odm_ConfigMAC_8723A(pDM_Odm, v1, (int )((unsigned char )v2));
#line 162
    goto ldv_55723;
  } else {
#line 164
    tmp = CheckCondition___0(*(Array + (unsigned long )i), hex);
#line 164
    if (tmp) {
#line 164
      tmp___0 = 0;
    } else {
#line 164
      tmp___0 = 1;
    }
#line 164
    if (tmp___0) {
#line 166
      i = i + 2U;
#line 166
      v1 = *(Array + (unsigned long )i);
#line 166
      v2 = *(Array + (unsigned long )(i + 1U));
#line 167
      goto ldv_55725;
      ldv_55724: 
#line 170
      i = i + 2U;
#line 170
      v1 = *(Array + (unsigned long )i);
#line 170
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55725: ;
#line 167
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 171
        goto ldv_55724;
      } else {

      }
#line 171
      i = i - 2U;
    } else {
#line 174
      i = i + 2U;
#line 174
      v1 = *(Array + (unsigned long )i);
#line 174
      v2 = *(Array + (unsigned long )(i + 1U));
#line 175
      goto ldv_55728;
      ldv_55727: 
#line 178
      odm_ConfigMAC_8723A(pDM_Odm, v1, (int )((unsigned char )v2));
#line 179
      i = i + 2U;
#line 179
      v1 = *(Array + (unsigned long )i);
#line 179
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55728: ;
#line 175
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 179
        goto ldv_55727;
      } else {

      }

#line 182
      goto ldv_55731;
      ldv_55730: 
#line 183
      i = i + 2U;
#line 183
      v1 = *(Array + (unsigned long )i);
#line 183
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55731: ;
#line 182
      if (v2 != 57005U && ArrayLen - 2U > i) {
#line 184
        goto ldv_55730;
      } else {

      }

    }
  }
  ldv_55723: 
#line 155
  i = i + 2U;
  ldv_55734: ;
#line 155
  if (i < ArrayLen) {
#line 157
    goto ldv_55733;
  } else {

  }

#line 162
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
bool ldv_queue_work_on_355(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
bool ldv_queue_delayed_work_on_356(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
bool ldv_queue_work_on_357(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
void ldv_flush_workqueue_358(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
bool ldv_queue_delayed_work_on_359(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_369(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_371(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_370(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_373(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_372(struct workqueue_struct *ldv_func_arg1 ) ;
#line 23 "drivers/staging/rtl8723au/include/HalHWImg8723A_RF.h"
void ODM_ReadAndConfig_RadioA_1T_8723A(struct dm_odm_t *pDM_Odm ) ;
#line 18 "drivers/staging/rtl8723au/include/odm_RegConfig8723A.h"
void odm_ConfigRFReg_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data , enum RF_RADIO_PATH RF_PATH ,
                           u32 RegAddr ) ;
#line 18 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.c"
static bool CheckCondition___1(u32 const   Condition , u32 const   Hex ) 
{ 
  u32 _board ;
  u32 _interface ;
  u32 _platform ;
  u32 cond ;

  {
#line 20
  _board = (unsigned int )Hex & 255U;
#line 21
  _interface = ((unsigned int )Hex & 65280U) >> 8;
#line 22
  _platform = ((unsigned int )Hex & 16711680U) >> 16;
#line 23
  cond = Condition;
#line 25
  if ((unsigned int )Condition == 3452816845U) {
#line 26
    return (1);
  } else {

  }
#line 28
  cond = (unsigned int )Condition & 255U;
#line 29
  if (_board == cond && cond != 0U) {
#line 30
    return (0);
  } else {

  }
#line 32
  cond = (unsigned int )Condition & 65280U;
#line 33
  cond = cond >> 8;
#line 34
  if ((_interface & cond) == 0U && cond != 7U) {
#line 35
    return (0);
  } else {

  }
#line 37
  cond = (unsigned int )Condition & 16711680U;
#line 38
  cond = cond >> 16;
#line 39
  if ((_platform & cond) == 0U && cond != 15U) {
#line 40
    return (0);
  } else {

  }
#line 41
  return (1);
}
}
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.c"
static u32 Array_RadioA_1T_8723A[312U]  = 
#line 48
  {      0U,      196953U,      1U,      201348U, 
        2U,      622592U,      4279173407U,      43981U, 
        3U,      101475U,      3452816845U,      52685U, 
        3U,      236643U,      4279173407U,      57005U, 
        4U,      135399U,      9U,      132175U, 
        10U,      107505U,      11U,      83847U, 
        12U,      562942U,      13U,      57388U, 
        14U,      236775U,      15U,      1105U, 
        25U,      0U,      26U,      197461U, 
        27U,      395776U,      28U,      1033080U, 
        29U,      660048U,      30U,      591U, 
        31U,      0U,      32U,      46612U, 
        33U,      442368U,      34U,      0U, 
        35U,      5464U,      36U,      96U, 
        37U,      1155U,      38U,      323584U, 
        39U,      968665U,      40U,      358192U, 
        41U,      18307U,      42U,      1U, 
        43U,      135988U,      42U,      0U, 
        43U,      84U,      42U,      1U, 
        43U,      2056U,      43U,      340787U, 
        44U,      12U,      42U,      2U, 
        43U,      2056U,      43U,      373555U, 
        44U,      13U,      42U,      3U, 
        43U,      2056U,      43U,      406323U, 
        44U,      13U,      42U,      4U, 
        43U,      2056U,      43U,      439091U, 
        44U,      13U,      42U,      5U, 
        43U,      2056U,      43U,      471859U, 
        44U,      13U,      42U,      6U, 
        43U,      1801U,      43U,      373555U, 
        44U,      13U,      42U,      7U, 
        43U,      1801U,      43U,      406323U, 
        44U,      13U,      42U,      8U, 
        43U,      1546U,      43U,      308019U, 
        44U,      13U,      42U,      9U, 
        43U,      1546U,      43U,      340787U, 
        44U,      13U,      42U,      10U, 
        43U,      1546U,      43U,      373555U, 
        44U,      13U,      42U,      11U, 
        43U,      1546U,      43U,      406323U, 
        44U,      13U,      42U,      12U, 
        43U,      1546U,      43U,      439091U, 
        44U,      13U,      42U,      13U, 
        43U,      1546U,      43U,      471859U, 
        44U,      13U,      42U,      14U, 
        43U,      1291U,      43U,      419430U, 
        44U,      26U,      42U,      917504U, 
        16U,      262159U,      17U,      930300U, 
        16U,      393231U,      17U,      1047032U, 
        16U,      131087U,      17U,      132089U, 
        16U,      196623U,      17U,      1045760U, 
        16U,      0U,      17U,      0U, 
        16U,      524303U,      17U,      258304U, 
        16U,      589839U,      17U,      143616U, 
        18U,      204800U,      18U,      462848U, 
        18U,      720896U,      18U,      1032192U, 
        19U,      165811U,      19U,      148663U, 
        19U,      132267U,      19U,      115871U, 
        19U,      99475U,      19U,      82587U, 
        19U,      66201U,      19U,      49820U, 
        19U,      33184U,      19U,      16556U, 
        19U,      32U,      20U,      103500U, 
        20U,      365636U,      20U,      627788U, 
        20U,      889924U,      4279173407U,      43981U, 
        21U,      62500U,      21U,      324644U, 
        21U,      586788U,      21U,      848932U, 
        3452816845U,      52685U,      21U,      62580U, 
        21U,      324727U,      21U,      586837U, 
        21U,      848981U,      4279173407U,      57005U, 
        22U,      825U,      22U,      262969U, 
        22U,      525113U,      4279173407U,      43981U, 
        22U,      787286U,      3452816845U,      52685U, 
        22U,      787302U,      4279173407U,      57005U, 
        0U,      65881U,      24U,      62465U, 
        254U,      0U,      254U,      0U, 
        31U,      3U,      254U,      0U, 
        254U,      0U,      30U,      583U, 
        31U,      0U,      0U,      196953U};
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.c"
void ODM_ReadAndConfig_RadioA_1T_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 214
  hex = 0U;
#line 215
  i = 0U;
#line 216
  platform = 4U;
#line 217
  board = pDM_Odm->BoardType;
#line 218
  ArrayLen = 312U;
#line 219
  Array = (u32 *)(& Array_RadioA_1T_8723A);
#line 221
  hex = (u32 )board + hex;
#line 222
  hex = hex + 512U;
#line 223
  hex = (u32 )((int )platform << 16) + hex;
#line 224
  hex = hex + 4278190080U;
#line 226
  i = 0U;
#line 226
  goto ldv_55734;
  ldv_55733: 
#line 227
  v1 = *(Array + (unsigned long )i);
#line 228
  v2 = *(Array + (unsigned long )(i + 1U));
#line 231
  if (v1 <= 3452816844U) {
#line 232
    odm_ConfigRFReg_8723A(pDM_Odm, v1, v2, 0, v1);
#line 233
    goto ldv_55723;
  } else {
#line 235
    tmp = CheckCondition___1(*(Array + (unsigned long )i), hex);
#line 235
    if (tmp) {
#line 235
      tmp___0 = 0;
    } else {
#line 235
      tmp___0 = 1;
    }
#line 235
    if (tmp___0) {
#line 237
      i = i + 2U;
#line 237
      v1 = *(Array + (unsigned long )i);
#line 237
      v2 = *(Array + (unsigned long )(i + 1U));
#line 238
      goto ldv_55725;
      ldv_55724: 
#line 241
      i = i + 2U;
#line 241
      v1 = *(Array + (unsigned long )i);
#line 241
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55725: ;
#line 238
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 242
        goto ldv_55724;
      } else {

      }
#line 242
      i = i - 2U;
    } else {
#line 245
      i = i + 2U;
#line 245
      v1 = *(Array + (unsigned long )i);
#line 245
      v2 = *(Array + (unsigned long )(i + 1U));
#line 246
      goto ldv_55728;
      ldv_55727: 
#line 249
      odm_ConfigRFReg_8723A(pDM_Odm, v1, v2, 0, v1);
#line 251
      i = i + 2U;
#line 251
      v1 = *(Array + (unsigned long )i);
#line 251
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55728: ;
#line 246
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 250
        goto ldv_55727;
      } else {

      }

#line 254
      goto ldv_55731;
      ldv_55730: 
#line 255
      i = i + 2U;
#line 255
      v1 = *(Array + (unsigned long )i);
#line 255
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55731: ;
#line 254
      if (v2 != 57005U && ArrayLen - 2U > i) {
#line 256
        goto ldv_55730;
      } else {

      }

    }
  }
  ldv_55723: 
#line 226
  i = i + 2U;
  ldv_55734: ;
#line 226
  if (i < ArrayLen) {
#line 228
    goto ldv_55733;
  } else {

  }

#line 233
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
bool ldv_queue_work_on_369(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
bool ldv_queue_delayed_work_on_370(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
bool ldv_queue_work_on_371(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
void ldv_flush_workqueue_372(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
bool ldv_queue_delayed_work_on_373(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_383(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_385(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_384(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_387(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_386(struct workqueue_struct *ldv_func_arg1 ) ;
#line 8 "include/asm-generic/delay.h"
extern void __udelay(unsigned long  ) ;
#line 123 "drivers/staging/rtl8723au/include/HalPwrSeqCmd.h"
u8 HalPwrSeqCmdParsing23a(struct rtw_adapter *padapter , u8 CutVersion , u8 FabVersion ,
                          u8 InterfaceType , struct wlan_pwr_cfg *PwrSeqCmd ) ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.c"
u8 HalPwrSeqCmdParsing23a(struct rtw_adapter *padapter , u8 CutVersion , u8 FabVersion ,
                          u8 InterfaceType , struct wlan_pwr_cfg *PwrSeqCmd ) 
{ 
  struct wlan_pwr_cfg PwrCfgCmd ;
  u8 bPollingBit ;
  u32 AryIdx ;
  u8 value ;
  u32 offset ;
  u32 pollingCount ;
  u32 maxPollingCnt ;
  u32 tmp ;

  {
#line 52
  AryIdx = 0U;
#line 55
  pollingCount = 0U;
#line 56
  maxPollingCnt = 5000U;
  ldv_53256: 
#line 59
  PwrCfgCmd = *(PwrSeqCmd + (unsigned long )AryIdx);
#line 61
  if (GlobalDebugLevel23A > 6U) {
#line 61
    rt_trace(16384, 7, "HalPwrSeqCmdParsing23a: offset(%#x) cut_msk(%#x) fab_msk(%#x) interface_msk(%#x) base(%#x) cmd(%#x) msk(%#x) value(%#x)\n",
             (int )PwrCfgCmd.offset, (int )PwrCfgCmd.cut_msk, (int )PwrCfgCmd.fab_msk,
             (int )PwrCfgCmd.interface_msk, (int )PwrCfgCmd.base, (int )PwrCfgCmd.cmd,
             (int )PwrCfgCmd.msk, (int )PwrCfgCmd.value);
  } else {

  }
#line 74
  if ((((int )PwrCfgCmd.fab_msk & (int )FabVersion) != 0 && (unsigned int )((int )PwrCfgCmd.cut_msk & (int )CutVersion) != 0U) && ((int )PwrCfgCmd.interface_msk & (int )InterfaceType) != 0) {
#line 77
    switch ((int )PwrCfgCmd.cmd) {
    case 0: ;
#line 79
    if (GlobalDebugLevel23A > 6U) {
#line 79
      rt_trace(16384, 7, "HalPwrSeqCmdParsing23a: PWR_CMD_READ\n");
    } else {

    }
#line 81
    goto ldv_53248;
    case 1: ;
#line 84
    if (GlobalDebugLevel23A > 6U) {
#line 84
      rt_trace(16384, 7, "HalPwrSeqCmdParsing23a: PWR_CMD_WRITE\n");
    } else {

    }
#line 86
    offset = (u32 )PwrCfgCmd.offset;
#line 89
    value = rtl8723au_read8(padapter, (int )((u16 )offset));
#line 91
    value = (u8 )(~ ((int )((signed char )PwrCfgCmd.msk)) & (int )((signed char )value));
#line 92
    value = (u8 )(((int )PwrCfgCmd.value & (int )PwrCfgCmd.msk) | (int )value);
#line 96
    rtl8723au_write8(padapter, (int )((u16 )offset), (int )value);
#line 97
    goto ldv_53248;
    case 2: ;
#line 100
    if (GlobalDebugLevel23A > 6U) {
#line 100
      rt_trace(16384, 7, "HalPwrSeqCmdParsing23a: PWR_CMD_POLLING\n");
    } else {

    }
#line 103
    bPollingBit = 0U;
#line 104
    offset = (u32 )PwrCfgCmd.offset;
    ldv_53251: 
#line 106
    value = rtl8723au_read8(padapter, (int )((u16 )offset));
#line 109
    value = (u8 )((int )PwrCfgCmd.msk & (int )value);
#line 110
    if (((int )PwrCfgCmd.value & (int )PwrCfgCmd.msk) == (int )value) {
#line 113
      bPollingBit = 1U;
    } else {
#line 115
      __const_udelay(42950UL);
    }
#line 117
    tmp = pollingCount;
#line 117
    pollingCount = pollingCount + 1U;
#line 117
    if (tmp > maxPollingCnt) {
#line 118
      if (GlobalDebugLevel23A > 3U) {
#line 118
        printk("\016RTL8723AU: Fail to polling Offset[%#x]\n", offset);
      } else {

      }
#line 121
      return (0U);
    } else {

    }
#line 123
    if ((unsigned int )bPollingBit == 0U) {
#line 125
      goto ldv_53251;
    } else {

    }

#line 125
    goto ldv_53248;
    case 3: ;
#line 128
    if (GlobalDebugLevel23A > 6U) {
#line 128
      rt_trace(16384, 7, "HalPwrSeqCmdParsing23a: PWR_CMD_DELAY\n");
    } else {

    }
#line 130
    if ((unsigned int )PwrCfgCmd.value == 0U) {
#line 132
      __udelay((unsigned long )PwrCfgCmd.offset);
    } else {
#line 134
      __udelay((unsigned long )((int )PwrCfgCmd.offset * 1000));
    }
#line 136
    goto ldv_53248;
    case 4: ;
#line 141
    if (GlobalDebugLevel23A > 6U) {
#line 141
      rt_trace(16384, 7, "HalPwrSeqCmdParsing23a: PWR_CMD_END\n");
    } else {

    }
#line 143
    return (1U);
    default: ;
#line 146
    if (GlobalDebugLevel23A > 3U) {
#line 146
      rt_trace(16384, 4, "HalPwrSeqCmdParsing23a: Unknown CMD!!\n");
    } else {

    }
#line 148
    goto ldv_53248;
    }
    ldv_53248: ;
  } else {

  }
#line 152
  AryIdx = AryIdx + 1U;
#line 153
  goto ldv_53256;
#line 155
  return (1U);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
bool ldv_queue_work_on_383(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
bool ldv_queue_delayed_work_on_384(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
bool ldv_queue_work_on_385(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
void ldv_flush_workqueue_386(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
bool ldv_queue_delayed_work_on_387(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_397(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_399(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_398(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_401(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_400(struct workqueue_struct *ldv_func_arg1 ) ;
#line 57 "drivers/staging/rtl8723au/include/odm_interface.h"
void ODM_SetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data ) ;
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.c"
void odm_ConfigRFReg_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data , enum RF_RADIO_PATH RF_PATH ,
                           u32 RegAddr ) 
{ 
  unsigned long __ms ;
  unsigned long tmp ;
  unsigned long __ms___0 ;
  unsigned long tmp___0 ;

  {
#line 28
  if (Addr == 254U) {
#line 29
    msleep(50U);
  } else
#line 30
  if (Addr == 253U) {
#line 31
    if (1) {
#line 31
      __const_udelay(21475000UL);
    } else {
#line 31
      __ms = 5UL;
#line 31
      goto ldv_55753;
      ldv_55752: 
#line 31
      __const_udelay(4295000UL);
      ldv_55753: 
#line 31
      tmp = __ms;
#line 31
      __ms = __ms - 1UL;
#line 31
      if (tmp != 0UL) {
#line 33
        goto ldv_55752;
      } else {

      }

    }
  } else
#line 32
  if (Addr == 252U) {
#line 33
    if (1) {
#line 33
      __const_udelay(4295000UL);
    } else {
#line 33
      __ms___0 = 1UL;
#line 33
      goto ldv_55757;
      ldv_55756: 
#line 33
      __const_udelay(4295000UL);
      ldv_55757: 
#line 33
      tmp___0 = __ms___0;
#line 33
      __ms___0 = __ms___0 - 1UL;
#line 33
      if (tmp___0 != 0UL) {
#line 35
        goto ldv_55756;
      } else {

      }

    }
  } else
#line 34
  if (Addr == 251U) {
#line 35
    __const_udelay(214750UL);
  } else
#line 36
  if (Addr == 250U) {
#line 37
    __const_udelay(21475UL);
  } else
#line 38
  if (Addr == 249U) {
#line 39
    __const_udelay(4295UL);
  } else {
#line 41
    ODM_SetRFReg(pDM_Odm, RF_PATH, RegAddr, 1048575U, Data);
#line 43
    __const_udelay(4295UL);
  }
#line 46
  return;
}
}
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.c"
void odm_ConfigMAC_8723A(struct dm_odm_t *pDM_Odm , u32 addr , u8 data ) 
{ 


  {
#line 49
  rtl8723au_write8(pDM_Odm->Adapter, (int )((u16 )addr), (int )data);
#line 50
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 50
    printk("[ODM-8723A] ");
#line 50
    printk("%s(): ===> %s: [MAC_REG] %08X %08X\n", "odm_ConfigMAC_8723A", "odm_ConfigMAC_8723A",
           addr, (int )data);
  } else {

  }
#line 52
  return;
}
}
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.c"
void odm_ConfigBB_AGC_8723A(struct dm_odm_t *pDM_Odm , u32 addr , u32 data ) 
{ 


  {
#line 56
  rtl8723au_write32(pDM_Odm->Adapter, (int )((u16 )addr), data);
#line 58
  __const_udelay(4295UL);
#line 60
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 60
    printk("[ODM-8723A] ");
#line 60
    printk("%s(): ===> %s: [AGC_TAB] %08X %08X\n", "odm_ConfigBB_AGC_8723A", "odm_ConfigBB_AGC_8723A",
           addr, data);
  } else {

  }
#line 62
  return;
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.c"
void odm_ConfigBB_PHY_8723A(struct dm_odm_t *pDM_Odm , u32 addr , u32 data ) 
{ 
  unsigned long __ms ;
  unsigned long tmp ;
  unsigned long __ms___0 ;
  unsigned long tmp___0 ;

  {
#line 67
  if (addr == 254U) {
#line 68
    msleep(50U);
  } else
#line 69
  if (addr == 253U) {
#line 70
    if (1) {
#line 70
      __const_udelay(21475000UL);
    } else {
#line 70
      __ms = 5UL;
#line 70
      goto ldv_55778;
      ldv_55777: 
#line 70
      __const_udelay(4295000UL);
      ldv_55778: 
#line 70
      tmp = __ms;
#line 70
      __ms = __ms - 1UL;
#line 70
      if (tmp != 0UL) {
#line 72
        goto ldv_55777;
      } else {

      }

    }
  } else
#line 71
  if (addr == 252U) {
#line 72
    if (1) {
#line 72
      __const_udelay(4295000UL);
    } else {
#line 72
      __ms___0 = 1UL;
#line 72
      goto ldv_55782;
      ldv_55781: 
#line 72
      __const_udelay(4295000UL);
      ldv_55782: 
#line 72
      tmp___0 = __ms___0;
#line 72
      __ms___0 = __ms___0 - 1UL;
#line 72
      if (tmp___0 != 0UL) {
#line 74
        goto ldv_55781;
      } else {

      }

    }
  } else
#line 73
  if (addr == 251U) {
#line 74
    __const_udelay(214750UL);
  } else
#line 75
  if (addr == 250U) {
#line 76
    __const_udelay(21475UL);
  } else
#line 77
  if (addr == 249U) {
#line 78
    __const_udelay(4295UL);
  } else
#line 79
  if (addr == 2596U) {
#line 80
    pDM_Odm->RFCalibrateInfo.RegA24 = data;
  } else {

  }
#line 81
  rtl8723au_write32(pDM_Odm->Adapter, (int )((u16 )addr), data);
#line 84
  __const_udelay(4295UL);
#line 86
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 86
    printk("[ODM-8723A] ");
#line 86
    printk("%s(): ===> %s: [PHY_REG] %08X %08X\n", "odm_ConfigBB_PHY_8723A", "odm_ConfigBB_PHY_8723A",
           addr, data);
  } else {

  }
#line 88
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
bool ldv_queue_work_on_397(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
bool ldv_queue_delayed_work_on_398(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
bool ldv_queue_work_on_399(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
void ldv_flush_workqueue_400(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
bool ldv_queue_delayed_work_on_401(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
void ldv__builtin_va_end(__builtin_va_list  ) ;
#line 1
void ldv__builtin_va_start(__builtin_va_list  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_411(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_413(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_412(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_415(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_414(struct workqueue_struct *ldv_func_arg1 ) ;
#line 164 "drivers/staging/rtl8723au/include/rtw_debug.h"
u32 GlobalDebugLevel23A  ;
#line 115 "drivers/staging/rtl8723au/include/odm_debug.h"
void ODM_InitDebugSetting23a(struct dm_odm_t *pDM_Odm ) ;
#line 18 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_debug.c"
void ODM_InitDebugSetting23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 20
  pDM_Odm->DebugLevel = 5U;
#line 21
  pDM_Odm->DebugComponents = 0ULL;
#line 22
  return;
}
}
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_debug.c"
void rt_trace(int comp , int level , char const   *fmt  , ...) 
{ 
  struct va_format vaf ;
  va_list args ;

  {
#line 31
  ldv__builtin_va_start((va_list *)(& args));
#line 33
  vaf.fmt = fmt;
#line 34
  vaf.va = & args;
#line 36
  printk("\016RTL8723AU:  [0x%08x,%d] %pV", comp, level, & vaf);
#line 38
  ldv__builtin_va_end((va_list *)(& args));
#line 39
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
bool ldv_queue_work_on_411(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
bool ldv_queue_delayed_work_on_412(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
bool ldv_queue_work_on_413(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
void ldv_flush_workqueue_414(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
bool ldv_queue_delayed_work_on_415(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_425(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_427(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_426(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_429(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_428(struct workqueue_struct *ldv_func_arg1 ) ;
#line 59 "drivers/staging/rtl8723au/include/odm_interface.h"
u32 ODM_GetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                 u32 BitMask ) ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_interface.c"
void ODM_SetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data ) 
{ 
  struct rtw_adapter *Adapter ;

  {
#line 34
  Adapter = pDM_Odm->Adapter;
#line 36
  PHY_SetRFReg(Adapter, eRFPath, RegAddr, BitMask, Data);
#line 37
  return;
}
}
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_interface.c"
u32 ODM_GetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                 u32 BitMask ) 
{ 
  struct rtw_adapter *Adapter ;
  u32 tmp ;

  {
#line 46
  Adapter = pDM_Odm->Adapter;
#line 48
  tmp = PHY_QueryRFReg(Adapter, eRFPath, RegAddr, BitMask);
#line 48
  return (tmp);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
bool ldv_queue_work_on_425(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
bool ldv_queue_delayed_work_on_426(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
bool ldv_queue_work_on_427(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
void ldv_flush_workqueue_428(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
bool ldv_queue_delayed_work_on_429(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_439(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_441(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_440(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_443(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_442(struct workqueue_struct *ldv_func_arg1 ) ;
#line 145 "drivers/staging/rtl8723au/include/odm_HWConfig.h"
void odm_Init_RSSIForDM23a(struct dm_odm_t *pDM_Odm ) ;
#line 148
void ODM_PhyStatusQuery23a(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                           u8 *pPhyStatus , struct odm_packet_info *pPktinfo ) ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_HWConfig.c"
static u8 odm_QueryRxPwrPercentage(s8 AntPower ) 
{ 


  {
#line 24
  if ((int )AntPower < -99 || (int )AntPower > 19) {
#line 25
    return (0U);
  } else
#line 26
  if ((int )AntPower >= 0) {
#line 27
    return (100U);
  } else {
#line 29
    return ((unsigned int )((u8 )AntPower) + 100U);
  }
}
}
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_HWConfig.c"
static s32 odm_SignalScaleMapping_92CSeries(struct dm_odm_t *pDM_Odm , s32 CurrSig ) 
{ 
  s32 RetSig ;

  {
#line 34
  RetSig = 0;
#line 36
  if (CurrSig > 50 && CurrSig <= 100) {
#line 37
    RetSig = 100;
  } else
#line 38
  if (CurrSig > 40 && CurrSig <= 50) {
#line 39
    RetSig = CurrSig * 2;
  } else
#line 40
  if (CurrSig > 30 && CurrSig <= 40) {
#line 41
    RetSig = CurrSig + 36;
  } else
#line 42
  if (CurrSig > 20 && CurrSig <= 30) {
#line 43
    RetSig = CurrSig + 34;
  } else
#line 44
  if (CurrSig > 9 && CurrSig <= 20) {
#line 45
    RetSig = ((CurrSig + -10) * 2) / 3 + 42;
  } else
#line 46
  if (CurrSig > 4 && CurrSig <= 9) {
#line 47
    RetSig = (CurrSig * 3 + -15) / 2 + 22;
  } else
#line 48
  if (CurrSig > 0 && CurrSig <= 4) {
#line 49
    RetSig = ((CurrSig + -1) * 3) / 2 + 6;
  } else {
#line 51
    RetSig = CurrSig;
  }
#line 53
  return (RetSig);
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_HWConfig.c"
static s32 odm_SignalScaleMapping(struct dm_odm_t *pDM_Odm , s32 CurrSig ) 
{ 
  s32 tmp ;

  {
#line 58
  tmp = odm_SignalScaleMapping_92CSeries(pDM_Odm, CurrSig);
#line 58
  return (tmp);
}
}
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_HWConfig.c"
static u8 odm_EVMdbToPercentage(s8 Value ) 
{ 
  s8 ret_val ;

  {
#line 71
  ret_val = Value;
#line 73
  if ((int )ret_val >= 0) {
#line 74
    ret_val = 0;
  } else {

  }
#line 75
  if ((int )ret_val < -32) {
#line 76
    ret_val = -33;
  } else {

  }
#line 78
  ret_val = (s8 )(- ((int )((unsigned char )ret_val)));
#line 79
  ret_val = (s8 )((unsigned int )((unsigned char )ret_val) * 3U);
#line 81
  if ((int )ret_val == 99) {
#line 82
    ret_val = 100;
  } else {

  }
#line 84
  return ((u8 )ret_val);
}
}
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_HWConfig.c"
static void odm_RxPhyStatus92CSeries_Parsing(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                                             u8 *pPhyStatus , struct odm_packet_info *pPktinfo ) 
{ 
  struct phy_status_rpt *pPhyStaRpt ;
  u8 i ;
  u8 Max_spatial_stream ;
  s8 rx_pwr[4U] ;
  s8 rx_pwr_all ;
  u8 EVM ;
  u8 PWDB_ALL ;
  u8 PWDB_ALL_BT ;
  u8 RSSI ;
  u8 total_rssi ;
  u8 isCCKrate ;
  u8 rf_rx_num ;
  u8 cck_highpwr ;
  u8 report ;
  u8 cck_agc_rpt ;
  u8 SQ ;
  u8 SQ_rpt ;
  s8 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;

  {
#line 92
  pPhyStaRpt = (struct phy_status_rpt *)pPhyStatus;
#line 94
  rx_pwr_all = 0;
#line 95
  PWDB_ALL = 0U;
#line 96
  total_rssi = 0U;
#line 97
  isCCKrate = 0U;
#line 98
  rf_rx_num = 0U;
#line 99
  cck_highpwr = 0U;
#line 101
  isCCKrate = (unsigned int )pPktinfo->Rate <= 3U;
#line 102
  pPhyInfo->RxMIMOSignalQuality[0] = 255U;
#line 103
  pPhyInfo->RxMIMOSignalQuality[1] = 255U;
#line 105
  if ((unsigned int )isCCKrate != 0U) {
#line 109
    pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK = pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK + 1ULL;
#line 113
    cck_highpwr = (u8 )pDM_Odm->bCckHighPower;
#line 115
    cck_agc_rpt = pPhyStaRpt->cck_agc_rpt_ofdm_cfosho_a;
#line 118
    if ((unsigned int )cck_highpwr == 0U) {
#line 119
      report = (int )cck_agc_rpt >> 6;
#line 120
      switch ((int )report) {
      case 3: 
#line 124
      rx_pwr_all = (s8 )(210U - ((unsigned int )cck_agc_rpt & 62U));
#line 125
      goto ldv_55741;
      case 2: 
#line 127
      rx_pwr_all = (s8 )(230U - ((unsigned int )cck_agc_rpt & 62U));
#line 128
      goto ldv_55741;
      case 1: 
#line 130
      rx_pwr_all = (s8 )(244U - ((unsigned int )cck_agc_rpt & 62U));
#line 131
      goto ldv_55741;
      case 0: 
#line 133
      rx_pwr_all = (s8 )(16U - ((unsigned int )cck_agc_rpt & 62U));
#line 134
      goto ldv_55741;
      }
      ldv_55741: ;
    } else {
#line 137
      report = (u8 )(((int )cck_agc_rpt & 96) >> 5);
#line 138
      switch ((int )report) {
      case 3: 
#line 140
      rx_pwr_all = (s8 )(210U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
#line 141
      goto ldv_55746;
      case 2: 
#line 143
      rx_pwr_all = (s8 )(230U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
#line 144
      goto ldv_55746;
      case 1: 
#line 146
      rx_pwr_all = (s8 )(244U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
#line 147
      goto ldv_55746;
      case 0: 
#line 149
      rx_pwr_all = (s8 )(16U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
#line 150
      goto ldv_55746;
      }
      ldv_55746: ;
    }
#line 154
    PWDB_ALL = odm_QueryRxPwrPercentage((int )rx_pwr_all);
#line 157
    if ((unsigned int )pDM_Odm->BoardType == 1U) {
#line 158
      if ((int )((signed char )cck_agc_rpt) >= 0) {
#line 159
        PWDB_ALL = (unsigned int )PWDB_ALL <= 94U ? (unsigned int )PWDB_ALL + 6U : 100U;
      } else
#line 161
      if ((unsigned int )PWDB_ALL > 38U) {
#line 162
        PWDB_ALL = (unsigned int )PWDB_ALL + 240U;
      } else {
#line 164
        PWDB_ALL = (unsigned int )PWDB_ALL <= 16U ? (u8 )((int )PWDB_ALL >> 2) : (unsigned int )PWDB_ALL + 244U;
      }
#line 168
      if ((unsigned int )PWDB_ALL > 25U && (unsigned int )PWDB_ALL <= 60U) {
#line 169
        PWDB_ALL = (unsigned int )PWDB_ALL + 6U;
      } else {

      }
    } else
#line 171
    if ((unsigned int )PWDB_ALL > 99U) {
#line 172
      PWDB_ALL = (unsigned int )PWDB_ALL + 248U;
    } else
#line 173
    if ((unsigned int )PWDB_ALL > 50U && (unsigned int )PWDB_ALL <= 68U) {
#line 174
      PWDB_ALL = (unsigned int )PWDB_ALL + 4U;
    } else {

    }
#line 176
    pPhyInfo->RxPWDBAll = PWDB_ALL;
#line 177
    pPhyInfo->BTRxRSSIPercentage = PWDB_ALL;
#line 178
    pPhyInfo->RecvSignalPower = rx_pwr_all;
#line 180
    if ((int )pPktinfo->bPacketMatchBSSID) {
#line 183
      SQ_rpt = pPhyStaRpt->cck_sig_qual_ofdm_pwdb_all;
#line 185
      if ((unsigned int )SQ_rpt > 64U) {
#line 186
        SQ = 0U;
      } else
#line 187
      if ((unsigned int )SQ_rpt <= 19U) {
#line 188
        SQ = 100U;
      } else {
#line 190
        SQ = (u8 )(((int )SQ_rpt * -100 + 6400) / 44);
      }
#line 192
      pPhyInfo->SignalQuality = SQ;
#line 193
      pPhyInfo->RxMIMOSignalQuality[0] = SQ;
#line 194
      pPhyInfo->RxMIMOSignalQuality[1] = 255U;
    } else {

    }
  } else {
#line 197
    pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM = pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM + 1ULL;
#line 201
    i = 0U;
#line 201
    goto ldv_55753;
    ldv_55752: ;
#line 203
    if ((int )((unsigned long )pDM_Odm->RFPathRxEnable >> (int )i) & 1) {
#line 204
      rf_rx_num = (u8 )((int )rf_rx_num + 1);
    } else {

    }
#line 206
    rx_pwr[(int )i] = (s8 )((unsigned int )((unsigned char )(((int )pPhyStaRpt->path_agc[(int )i].gain & 63) + -55)) * 2U);
#line 208
    pPhyInfo->RxPwr[(int )i] = (u8 )rx_pwr[(int )i];
#line 211
    RSSI = odm_QueryRxPwrPercentage((int )rx_pwr[(int )i]);
#line 212
    total_rssi = (int )total_rssi + (int )RSSI;
#line 215
    if ((unsigned int )pDM_Odm->BoardType == 1U) {
#line 216
      if ((unsigned int )pPhyStaRpt->path_agc[(int )i].trsw == 1U) {
#line 217
        RSSI = (unsigned int )RSSI <= 94U ? (unsigned int )RSSI + 6U : 100U;
      } else {
#line 219
        RSSI = (unsigned int )RSSI <= 16U ? (u8 )((int )RSSI >> 3) : (unsigned int )RSSI + 240U;
      }
#line 221
      if ((unsigned int )RSSI <= 34U && (unsigned int )RSSI > 3U) {
#line 222
        RSSI = (unsigned int )RSSI + 252U;
      } else {

      }
    } else {

    }
#line 225
    pPhyInfo->RxMIMOSignalStrength[(int )i] = RSSI;
#line 228
    tmp = (s8 )((unsigned int )pPhyStaRpt->path_rxsnr[(int )i] / 2U);
#line 228
    pDM_Odm->PhyDbgInfo.RxSNRdB[(int )i] = tmp;
#line 228
    pPhyInfo->RxSNR[(int )i] = (u8 )tmp;
#line 201
    i = (u8 )((int )i + 1);
    ldv_55753: ;
#line 201
    if ((unsigned int )i <= 1U) {
#line 203
      goto ldv_55752;
    } else {

    }
#line 232
    rx_pwr_all = (s8 )((unsigned int )((int )pPhyStaRpt->cck_sig_qual_ofdm_pwdb_all >> 1) + 146U);
#line 234
    PWDB_ALL = odm_QueryRxPwrPercentage((int )rx_pwr_all);
#line 235
    PWDB_ALL_BT = PWDB_ALL;
#line 237
    pPhyInfo->RxPWDBAll = PWDB_ALL;
#line 238
    pPhyInfo->BTRxRSSIPercentage = PWDB_ALL_BT;
#line 239
    pPhyInfo->RxPower = rx_pwr_all;
#line 240
    pPhyInfo->RecvSignalPower = rx_pwr_all;
#line 243
    if ((unsigned int )pPktinfo->Rate > 19U && (unsigned int )pPktinfo->Rate <= 27U) {
#line 244
      Max_spatial_stream = 2U;
    } else {
#line 246
      Max_spatial_stream = 1U;
    }
#line 248
    i = 0U;
#line 248
    goto ldv_55756;
    ldv_55755: 
#line 252
    EVM = odm_EVMdbToPercentage((int )pPhyStaRpt->stream_rxevm[(int )i]);
#line 254
    if ((int )pPktinfo->bPacketMatchBSSID) {
#line 255
      if ((unsigned int )i == 0U) {
#line 257
        pPhyInfo->SignalQuality = EVM;
      } else {

      }
#line 259
      pPhyInfo->RxMIMOSignalQuality[(int )i] = EVM;
    } else {

    }
#line 248
    i = (u8 )((int )i + 1);
    ldv_55756: ;
#line 248
    if ((int )i < (int )Max_spatial_stream) {
#line 250
      goto ldv_55755;
    } else {

    }

  }
#line 265
  if ((unsigned int )isCCKrate != 0U) {
#line 266
    tmp___0 = odm_SignalScaleMapping(pDM_Odm, (s32 )PWDB_ALL);
#line 266
    pPhyInfo->SignalStrength = (unsigned char )tmp___0;
  } else
#line 268
  if ((unsigned int )rf_rx_num != 0U) {
#line 269
    total_rssi = (u8 )((int )total_rssi / (int )rf_rx_num);
#line 269
    tmp___1 = odm_SignalScaleMapping(pDM_Odm, (s32 )total_rssi);
#line 269
    pPhyInfo->SignalStrength = (unsigned char )tmp___1;
  } else {

  }
#line 270
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_HWConfig.c"
void odm_Init_RSSIForDM23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 275
  return;
}
}
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_HWConfig.c"
static void odm_Process_RSSIForDM(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                                  struct odm_packet_info *pPktinfo ) 
{ 
  s32 UndecoratedSmoothedPWDB ;
  s32 UndecoratedSmoothedCCK ;
  s32 UndecoratedSmoothedOFDM ;
  s32 RSSI_Ave ;
  u8 isCCKrate ;
  u8 RSSI_max ;
  u8 RSSI_min ;
  u8 i ;
  u32 OFDM_pkt ;
  u32 Weighting ;
  struct sta_info *pEntry ;

  {
#line 283
  isCCKrate = 0U;
#line 285
  OFDM_pkt = 0U;
#line 286
  Weighting = 0U;
#line 289
  if ((unsigned int )pPktinfo->StationID == 255U) {
#line 290
    return;
  } else {

  }
#line 292
  pEntry = pDM_Odm->pODM_StaInfo[(int )pPktinfo->StationID];
#line 293
  if ((unsigned long )pEntry == (unsigned long )((struct sta_info *)0)) {
#line 294
    return;
  } else {

  }
#line 295
  if (! pPktinfo->bPacketMatchBSSID) {
#line 296
    return;
  } else {

  }
#line 298
  isCCKrate = (unsigned int )pPktinfo->Rate <= 3U;
#line 302
  UndecoratedSmoothedCCK = pEntry->rssi_stat.UndecoratedSmoothedCCK;
#line 303
  UndecoratedSmoothedOFDM = pEntry->rssi_stat.UndecoratedSmoothedOFDM;
#line 304
  UndecoratedSmoothedPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
#line 306
  if ((int )pPktinfo->bPacketToSelf || (int )pPktinfo->bPacketBeacon) {
#line 307
    if ((unsigned int )isCCKrate == 0U) {
#line 308
      if ((unsigned int )pPhyInfo->RxMIMOSignalStrength[1] == 0U) {
#line 309
        RSSI_Ave = (s32 )pPhyInfo->RxMIMOSignalStrength[0];
      } else {
#line 311
        if ((int )pPhyInfo->RxMIMOSignalStrength[0] > (int )pPhyInfo->RxMIMOSignalStrength[1]) {
#line 312
          RSSI_max = pPhyInfo->RxMIMOSignalStrength[0];
#line 313
          RSSI_min = pPhyInfo->RxMIMOSignalStrength[1];
        } else {
#line 315
          RSSI_max = pPhyInfo->RxMIMOSignalStrength[1];
#line 316
          RSSI_min = pPhyInfo->RxMIMOSignalStrength[0];
        }
#line 318
        if ((int )RSSI_max - (int )RSSI_min <= 2) {
#line 319
          RSSI_Ave = (s32 )RSSI_max;
        } else
#line 320
        if ((int )RSSI_max - (int )RSSI_min <= 5) {
#line 321
          RSSI_Ave = (int )RSSI_max + -1;
        } else
#line 322
        if ((int )RSSI_max - (int )RSSI_min <= 9) {
#line 323
          RSSI_Ave = (int )RSSI_max + -2;
        } else {
#line 325
          RSSI_Ave = (int )RSSI_max + -3;
        }
      }
#line 329
      if (UndecoratedSmoothedOFDM <= 0) {
#line 331
        UndecoratedSmoothedOFDM = (s32 )pPhyInfo->RxPWDBAll;
      } else
#line 333
      if ((unsigned int )pPhyInfo->RxPWDBAll > (unsigned int )UndecoratedSmoothedOFDM) {
#line 334
        UndecoratedSmoothedOFDM = (UndecoratedSmoothedOFDM * 19 + RSSI_Ave) / 20;
#line 337
        UndecoratedSmoothedOFDM = UndecoratedSmoothedOFDM + 1;
      } else {
#line 339
        UndecoratedSmoothedOFDM = (UndecoratedSmoothedOFDM * 19 + RSSI_Ave) / 20;
      }
#line 344
      pEntry->rssi_stat.PacketMap = (pEntry->rssi_stat.PacketMap << 1) | 1ULL;
    } else {
#line 347
      RSSI_Ave = (s32 )pPhyInfo->RxPWDBAll;
#line 350
      if (UndecoratedSmoothedCCK <= 0) {
#line 352
        UndecoratedSmoothedCCK = (s32 )pPhyInfo->RxPWDBAll;
      } else
#line 354
      if ((unsigned int )pPhyInfo->RxPWDBAll > (unsigned int )UndecoratedSmoothedCCK) {
#line 355
        UndecoratedSmoothedCCK = (UndecoratedSmoothedCCK * 19 + (int )pPhyInfo->RxPWDBAll) / 20;
#line 358
        UndecoratedSmoothedCCK = UndecoratedSmoothedCCK + 1;
      } else {
#line 360
        UndecoratedSmoothedCCK = (UndecoratedSmoothedCCK * 19 + (int )pPhyInfo->RxPWDBAll) / 20;
      }
#line 365
      pEntry->rssi_stat.PacketMap = pEntry->rssi_stat.PacketMap << 1;
    }
#line 369
    if ((unsigned int )pEntry->rssi_stat.ValidBit > 63U) {
#line 370
      pEntry->rssi_stat.ValidBit = 64U;
    } else {
#line 372
      pEntry->rssi_stat.ValidBit = (u8 )((int )pEntry->rssi_stat.ValidBit + 1);
    }
#line 374
    i = 0U;
#line 374
    goto ldv_55778;
    ldv_55777: 
#line 375
    OFDM_pkt = ((u32 )((unsigned char )(pEntry->rssi_stat.PacketMap >> (int )i)) & 1U) + OFDM_pkt;
#line 374
    i = (u8 )((int )i + 1);
    ldv_55778: ;
#line 374
    if ((int )pEntry->rssi_stat.ValidBit > (int )i) {
#line 376
      goto ldv_55777;
    } else {

    }

#line 378
    if ((unsigned int )pEntry->rssi_stat.ValidBit == 64U) {
#line 379
      Weighting = 64U < OFDM_pkt << 4 ? 64U : OFDM_pkt << 4;
#line 380
      UndecoratedSmoothedPWDB = (s32 )((Weighting * (u32 )UndecoratedSmoothedOFDM + (64U - Weighting) * (u32 )UndecoratedSmoothedCCK) >> 6);
    } else
#line 382
    if ((unsigned int )pEntry->rssi_stat.ValidBit != 0U) {
#line 383
      UndecoratedSmoothedPWDB = (s32 )((OFDM_pkt * (u32 )UndecoratedSmoothedOFDM + ((u32 )pEntry->rssi_stat.ValidBit - OFDM_pkt) * (u32 )UndecoratedSmoothedCCK) / (u32 )pEntry->rssi_stat.ValidBit);
    } else {
#line 385
      UndecoratedSmoothedPWDB = 0;
    }
#line 387
    pEntry->rssi_stat.UndecoratedSmoothedCCK = UndecoratedSmoothedCCK;
#line 388
    pEntry->rssi_stat.UndecoratedSmoothedOFDM = UndecoratedSmoothedOFDM;
#line 389
    pEntry->rssi_stat.UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
  } else {

  }
#line 391
  return;
}
}
#line 393 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_HWConfig.c"
void ODM_PhyStatusQuery23a(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                           u8 *pPhyStatus , struct odm_packet_info *pPktinfo ) 
{ 


  {
#line 396
  odm_RxPhyStatus92CSeries_Parsing(pDM_Odm, pPhyInfo, pPhyStatus, pPktinfo);
#line 399
  odm_Process_RSSIForDM(pDM_Odm, pPhyInfo, pPktinfo);
#line 400
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
bool ldv_queue_work_on_439(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
bool ldv_queue_delayed_work_on_440(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
bool ldv_queue_work_on_441(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
void ldv_flush_workqueue_442(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
bool ldv_queue_delayed_work_on_443(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_453(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_455(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_454(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_457(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_456(struct workqueue_struct *ldv_func_arg1 ) ;
#line 818 "drivers/staging/rtl8723au/include/odm.h"
void ODM_Write_CCK_CCA_Thres23a(struct dm_odm_t *pDM_Odm , u8 CurCCK_CCAThres ) ;
#line 824
void ODM_RF_Saving23a(struct dm_odm_t *pDM_Odm , u8 bForceInNormal ) ;
#line 829
bool ODM_RAStateCheck23a(struct dm_odm_t *pDM_Odm , s32 RSSI , bool bForceUpdate ,
                         u8 *pRATRState ) ;
#line 833
u32 ConvertTo_dB23a(u32 Value ) ;
#line 835
u32 GetPSDData(struct dm_odm_t *pDM_Odm , unsigned int point , u8 initial_gain_psd ) ;
#line 837
void odm_DIG23abyRSSI_LPS(struct dm_odm_t *pDM_Odm ) ;
#line 839
u32 ODM_Get_Rate_Bitmap23a(struct hal_data_8723a *pHalData , u32 macid , u32 ra_mask ,
                           u8 rssi_level ) ;
#line 842
void ODM23a_DMInit(struct dm_odm_t *pDM_Odm ) ;
#line 844
void ODM_DMWatchdog23a(struct rtw_adapter *adapter ) ;
#line 846
void ODM_CmnInfoInit23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo , u32 Value ) ;
#line 848
void ODM_CmnInfoPtrArrayHook23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo ,
                                u16 Index , void *pValue ) ;
#line 850
void ODM_CmnInfoUpdate23a(struct dm_odm_t *pDM_Odm , u32 CmnInfo , u64 Value ) ;
#line 856
void ODM_SingleDualAntennaDefaultSetting(struct dm_odm_t *pDM_Odm ) ;
#line 858
bool ODM_SingleDualAntennaDetection(struct dm_odm_t *pDM_Odm , u8 mode ) ;
#line 33 "drivers/staging/rtl8723au/include/rtl8723a_bt_intf.h"
bool rtl8723a_BT_disable_EDCA_turbo(struct rtw_adapter *padapter ) ;
#line 152 "drivers/staging/rtl8723au/include/rtl8723a_cmd.h"
int rtl8723a_set_rssi_cmd(struct rtw_adapter *padapter , u8 *param ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
static u16 const   dB_Invert_Table[8U][12U]  = 
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
  { {        1U,        1U,        1U,        2U, 
            2U,        2U,        2U,        3U, 
            3U,        3U,        4U,        4U}, 
   {        4U,        5U,        6U,        6U, 
            7U,        8U,        9U,        10U, 
            11U,        13U,        14U,        16U}, 
   {        18U,        20U,        22U,        25U, 
            28U,        32U,        35U,        40U, 
            45U,        50U,        56U,        63U}, 
   {        71U,        79U,        89U,        100U, 
            112U,        126U,        141U,        158U, 
            178U,        200U,        224U,        251U}, 
   {        282U,        316U,        355U,        398U, 
            447U,        501U,        562U,        631U, 
            708U,        794U,        891U,        1000U}, 
   {        1122U,        1259U,        1413U,        1585U, 
            1778U,        1995U,        2239U,        2512U, 
            2818U,        3162U,        3548U,        3981U}, 
   {        4467U,        5012U,        5623U,        6310U, 
            7079U,        7943U,        8913U,        10000U, 
            11220U,        12589U,        14125U,        15849U}, 
   {        17783U,        19953U,        22387U,        25119U, 
            28184U,        31623U,        35481U,        39811U, 
            44668U,        50119U,        56234U,        65535U}};
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
static u32 EDCAParam[17U][3U]  = 
#line 30
  { {        6202411U,        6202411U,        6202411U}, 
   {        42063U,        6202447U,        6177564U}, 
   {        6202411U,        6202411U,        6202411U}, 
   {        6202155U,        6202411U,        6177570U}, 
   {        6202402U,        42063U,        42063U}, 
   {        6202146U,        42544U,        42063U}, 
   {        6177570U,        6177570U,        6177570U}, 
   {        6202447U,        42063U,        6202411U}, 
   {        6202411U,        6202411U,        6202411U}, 
   {        6202411U,        42544U,        6177564U}};
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
u32 OFDMSwingTable23A[43U]  = 
#line 46
  {      2139095550U,      2021655010U,      1908408775U,      1803551150U, 
        1698693525U,      1606418815U,      1514144105U,      1430258005U, 
        1350566210U,      1275068720U,      1203765535U,      1136656655U, 
        1073742080U,      1015021810U,      956301540U,      901775575U, 
        851443915U,      805306560U,      759169205U,      717226155U, 
        679477410U,      637534360U,      603979920U,      570425480U, 
        536871040U,      507510905U,      478150770U,      452984940U, 
        427819110U,      402653280U,      381681755U,      360710230U, 
        339738705U,      318767180U,      301989960U,      285212740U, 
        268435520U,      251658300U,      239075385U,      226492470U, 
        213909555U,      201326640U,      188743725U};
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
u8 CCKSwingTable_Ch1_Ch1323A[33U][8U]  = 
#line 92
  { {        54U,        53U,        46U,        37U, 
            28U,        18U,        9U,        4U}, 
   {        51U,        50U,        43U,        35U, 
            26U,        17U,        8U,        4U}, 
   {        48U,        47U,        41U,        33U, 
            25U,        16U,        8U,        3U}, 
   {        45U,        45U,        39U,        31U, 
            24U,        15U,        8U,        3U}, 
   {        43U,        42U,        37U,        30U, 
            22U,        14U,        7U,        3U}, 
   {        40U,        40U,        34U,        28U, 
            21U,        13U,        7U,        3U}, 
   {        38U,        37U,        33U,        27U, 
            20U,        13U,        6U,        3U}, 
   {        36U,        35U,        31U,        25U, 
            19U,        12U,        6U,        3U}, 
   {        34U,        33U,        29U,        24U, 
            17U,        11U,        6U,        2U}, 
   {        32U,        32U,        27U,        22U, 
            17U,        8U,        5U,        2U}, 
   {        31U,        30U,        26U,        21U, 
            16U,        10U,        5U,        2U}, 
   {        29U,        28U,        24U,        20U, 
            15U,        10U,        5U,        2U}, 
   {        27U,        26U,        23U,        19U, 
            14U,        9U,        4U,        2U}, 
   {        26U,        25U,        22U,        18U, 
            13U,        9U,        4U,        2U}, 
   {        24U,        23U,        21U,        17U, 
            12U,        8U,        4U,        2U}, 
   {        23U,        22U,        19U,        16U, 
            12U,        8U,        4U,        2U}, 
   {        22U,        21U,        18U,        15U, 
            11U,        7U,        4U,        1U}, 
   {        20U,        20U,        17U,        14U, 
            11U,        7U,        3U,        2U}, 
   {        19U,        19U,        16U,        13U, 
            10U,        6U,        3U,        1U}, 
   {        18U,        18U,        15U,        12U, 
            9U,        6U,        3U,        1U}, 
   {        17U,        17U,        15U,        12U, 
            9U,        6U,        3U,        1U}, 
   {        16U,        16U,        14U,        11U, 
            8U,        5U,        3U,        1U}, 
   {        15U,        15U,        13U,        11U, 
            8U,        5U,        3U,        1U}, 
   {        14U,        14U,        12U,        10U, 
            8U,        5U,        2U,        1U}, 
   {        13U,        13U,        12U,        10U, 
            7U,        5U,        2U,        1U}, 
   {        13U,        12U,        11U,        9U, 
            7U,        4U,        2U,        1U}, 
   {        12U,        12U,        10U,        9U, 
            6U,        4U,        2U,        1U}, 
   {        11U,        11U,        10U,        8U, 
            6U,        4U,        2U,        1U}, 
   {        11U,        10U,        9U,        8U, 
            6U,        4U,        2U,        1U}, 
   {        10U,        10U,        9U,        7U, 
            5U,        3U,        2U,        1U}, 
   {        10U,        9U,        8U,        7U, 
            5U,        3U,        2U,        1U}, 
   {        9U,        9U,        8U,        6U, 
            5U,        3U,        1U,        1U}, 
   {        9U,        8U,        7U,        6U, 
            4U,        3U,        1U,        1U}};
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
u8 CCKSwingTable_Ch1423A[33U][8U]  = 
#line 128
  { {        54U,        53U,        46U,        27U, 
            0U,        0U,        0U,        0U}, 
   {        51U,        50U,        43U,        25U, 
            0U,        0U,        0U,        0U}, 
   {        48U,        47U,        41U,        24U, 
            0U,        0U,        0U,        0U}, 
   {        45U,        45U,        23U,        23U, 
            0U,        0U,        0U,        0U}, 
   {        43U,        42U,        37U,        21U, 
            0U,        0U,        0U,        0U}, 
   {        40U,        40U,        36U,        20U, 
            0U,        0U,        0U,        0U}, 
   {        38U,        37U,        33U,        19U, 
            0U,        0U,        0U,        0U}, 
   {        36U,        35U,        31U,        18U, 
            0U,        0U,        0U,        0U}, 
   {        34U,        33U,        29U,        17U, 
            0U,        0U,        0U,        0U}, 
   {        32U,        32U,        27U,        16U, 
            0U,        0U,        0U,        0U}, 
   {        31U,        30U,        26U,        15U, 
            0U,        0U,        0U,        0U}, 
   {        29U,        28U,        24U,        14U, 
            0U,        0U,        0U,        0U}, 
   {        27U,        26U,        23U,        14U, 
            0U,        0U,        0U,        0U}, 
   {        26U,        25U,        22U,        13U, 
            0U,        0U,        0U,        0U}, 
   {        24U,        23U,        21U,        12U, 
            0U,        0U,        0U,        0U}, 
   {        23U,        22U,        19U,        11U, 
            0U,        0U,        0U,        0U}, 
   {        22U,        21U,        18U,        11U, 
            0U,        0U,        0U,        0U}, 
   {        20U,        20U,        17U,        10U, 
            0U,        0U,        0U,        0U}, 
   {        19U,        19U,        16U,        10U, 
            0U,        0U,        0U,        0U}, 
   {        18U,        18U,        15U,        9U, 
            0U,        0U,        0U,        0U}, 
   {        17U,        17U,        15U,        9U, 
            0U,        0U,        0U,        0U}, 
   {        16U,        16U,        14U,        8U, 
            0U,        0U,        0U,        0U}, 
   {        15U,        15U,        13U,        8U, 
            0U,        0U,        0U,        0U}, 
   {        14U,        14U,        12U,        7U, 
            0U,        0U,        0U,        0U}, 
   {        13U,        13U,        12U,        7U, 
            0U,        0U,        0U,        0U}, 
   {        13U,        12U,        11U,        6U, 
            0U,        0U,        0U,        0U}, 
   {        12U,        12U,        10U,        6U, 
            0U,        0U,        0U,        0U}, 
   {        11U,        11U,        10U,        6U, 
            0U,        0U,        0U,        0U}, 
   {        11U,        10U,        9U,        5U, 
            0U,        0U,        0U,        0U}, 
   {        10U,        10U,        9U,        5U, 
            0U,        0U,        0U,        0U}, 
   {        10U,        9U,        8U,        5U, 
            0U,        0U,        0U,        0U}, 
   {        9U,        9U,        8U,        5U, 
            0U,        0U,        0U,        0U}, 
   {        9U,        8U,        7U,        4U, 
            0U,        0U,        0U,        0U}};
#line 167
void odm_CommonInfoSelfInit23a(struct dm_odm_t *pDM_Odm ) ;
#line 169
static void odm_CommonInfoSelfUpdate(struct hal_data_8723a *pHalData ) ;
#line 171
void odm_CmnInfoInit_Debug23a(struct dm_odm_t *pDM_Odm ) ;
#line 173
void odm_CmnInfoUpdate_Debug23a(struct dm_odm_t *pDM_Odm ) ;
#line 176
void odm_FalseAlarmCounterStatistics23a(struct dm_odm_t *pDM_Odm ) ;
#line 178
void odm_DIG23aInit(struct dm_odm_t *pDM_Odm ) ;
#line 180
void odm_DIG23a(struct rtw_adapter *adapter ) ;
#line 182
void odm_CCKPacketDetectionThresh23a(struct dm_odm_t *pDM_Odm ) ;
#line 186
void odm23a_DynBBPSInit(struct dm_odm_t *pDM_Odm ) ;
#line 188
void odm_DynamicBBPowerSaving23a(struct dm_odm_t *pDM_Odm ) ;
#line 192
void odm_DynamicTxPower23aInit(struct dm_odm_t *pDM_Odm ) ;
#line 194
static void odm_RSSIMonitorCheck(struct dm_odm_t *pDM_Odm ) ;
#line 197
static void odm_RefreshRateAdaptiveMask(struct dm_odm_t *pDM_Odm ) ;
#line 199
void odm_RateAdaptiveMaskInit23a(struct dm_odm_t *pDM_Odm ) ;
#line 201
static void odm_TXPowerTrackingInit(struct dm_odm_t *pDM_Odm ) ;
#line 203
static void odm_EdcaTurboCheck23a(struct dm_odm_t *pDM_Odm ) ;
#line 204
static void ODM_EdcaTurboInit23a(struct dm_odm_t *pDM_Odm ) ;
#line 225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void ODM23a_DMInit(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 228
  odm_CommonInfoSelfInit23a(pDM_Odm);
#line 229
  odm_CmnInfoInit_Debug23a(pDM_Odm);
#line 230
  odm_DIG23aInit(pDM_Odm);
#line 231
  odm_RateAdaptiveMaskInit23a(pDM_Odm);
#line 233
  odm23a_DynBBPSInit(pDM_Odm);
#line 234
  odm_DynamicTxPower23aInit(pDM_Odm);
#line 235
  odm_TXPowerTrackingInit(pDM_Odm);
#line 236
  ODM_EdcaTurboInit23a(pDM_Odm);
#line 237
  return;
}
}
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void ODM_DMWatchdog23a(struct rtw_adapter *adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *pDM_Odm ;
  struct pwrctrl_priv *pwrctrlpriv ;

  {
#line 244
  pHalData = (struct hal_data_8723a *)adapter->HalData;
#line 245
  pDM_Odm = & pHalData->odmpriv;
#line 246
  pwrctrlpriv = & adapter->pwrctrlpriv;
#line 249
  odm_CmnInfoUpdate_Debug23a(pDM_Odm);
#line 250
  odm_CommonInfoSelfUpdate(pHalData);
#line 251
  odm_FalseAlarmCounterStatistics23a(pDM_Odm);
#line 252
  odm_RSSIMonitorCheck(pDM_Odm);
#line 257
  if ((unsigned int )(pDM_Odm->Adapter)->pwrctrlpriv.pwr_mode != 0U && (pDM_Odm->SupportICType & 8U) != 0U) {
#line 259
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 259
      printk("[ODM-8723A] ");
#line 259
      printk("%s(): ----Step1: odm_DIG23a is in LPS mode\n", "ODM_DMWatchdog23a");
    } else {

    }
#line 260
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 260
      printk("[ODM-8723A] ");
#line 260
      printk("%s(): ---Step2: 8723AS is in LPS mode\n", "ODM_DMWatchdog23a");
    } else {

    }
#line 261
    odm_DIG23abyRSSI_LPS(pDM_Odm);
  } else {
#line 263
    odm_DIG23a(adapter);
  }
#line 266
  odm_CCKPacketDetectionThresh23a(pDM_Odm);
#line 268
  if ((unsigned int )pwrctrlpriv->bpower_saving != 0U) {
#line 269
    return;
  } else {

  }
#line 271
  odm_RefreshRateAdaptiveMask(pDM_Odm);
#line 273
  odm_DynamicBBPowerSaving23a(pDM_Odm);
#line 275
  odm_EdcaTurboCheck23a(pDM_Odm);
#line 276
  return;
}
}
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void ODM_CmnInfoInit23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo , u32 Value ) 
{ 


  {
#line 291
  switch ((unsigned int )CmnInfo) {
  case 2U: 
#line 294
  pDM_Odm->bIsMPChip = (unsigned int )((unsigned char )Value) != 0U;
#line 295
  goto ldv_55812;
  case 3U: 
#line 297
  pDM_Odm->SupportICType = Value;
#line 298
  goto ldv_55812;
  case 4U: 
#line 300
  pDM_Odm->CutVersion = (unsigned char )Value;
#line 301
  goto ldv_55812;
  case 5U: 
#line 303
  pDM_Odm->FabVersion = (unsigned char )Value;
#line 304
  goto ldv_55812;
  case 6U: 
#line 306
  pDM_Odm->BoardType = (unsigned char )Value;
#line 307
  goto ldv_55812;
  case 7U: 
#line 309
  pDM_Odm->ExtLNA = (unsigned char )Value;
#line 310
  goto ldv_55812;
  case 8U: 
#line 312
  pDM_Odm->ExtPA = (unsigned char )Value;
#line 313
  goto ldv_55812;
  case 9U: 
#line 315
  pDM_Odm->ExtTRSW = (unsigned char )Value;
#line 316
  goto ldv_55812;
  case 10U: 
#line 318
  pDM_Odm->bInHctTest = Value != 0U;
#line 319
  goto ldv_55812;
  case 11U: 
#line 321
  pDM_Odm->bWIFITest = Value != 0U;
#line 322
  goto ldv_55812;
  case 12U: 
#line 324
  pDM_Odm->bDualMacSmartConcurrent = Value != 0U;
#line 325
  goto ldv_55812;
  default: ;
#line 329
  goto ldv_55812;
  }
  ldv_55812: ;
#line 332
  return;
}
}
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void ODM_CmnInfoPtrArrayHook23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo ,
                                u16 Index , void *pValue ) 
{ 


  {
#line 337
  switch ((unsigned int )CmnInfo) {
  case 28U: 
#line 340
  pDM_Odm->pODM_StaInfo[(int )Index] = (struct sta_info *)pValue;
#line 341
  goto ldv_55831;
  default: ;
#line 345
  goto ldv_55831;
  }
  ldv_55831: ;
#line 348
  return;
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void ODM_CmnInfoUpdate23a(struct dm_odm_t *pDM_Odm , u32 CmnInfo , u64 Value ) 
{ 


  {
#line 353
  switch (CmnInfo) {
  case 14U: 
#line 355
  pDM_Odm->bWIFI_Direct = Value != 0ULL;
#line 356
  goto ldv_55839;
  case 15U: 
#line 358
  pDM_Odm->bWIFI_Display = Value != 0ULL;
#line 359
  goto ldv_55839;
  case 16U: 
#line 361
  pDM_Odm->bLinked = Value != 0ULL;
#line 362
  goto ldv_55839;
  case 17U: 
#line 364
  pDM_Odm->RSSI_Min = (unsigned char )Value;
#line 365
  goto ldv_55839;
  case 18U: 
#line 367
  pDM_Odm->DebugComponents = Value;
#line 368
  goto ldv_55839;
  case 19U: 
#line 370
  pDM_Odm->DebugLevel = (unsigned int )Value;
#line 371
  goto ldv_55839;
  case 20U: 
#line 373
  pDM_Odm->RateAdaptive.HighRSSIThresh = (unsigned char )Value;
#line 374
  goto ldv_55839;
  case 21U: 
#line 376
  pDM_Odm->RateAdaptive.LowRSSIThresh = (unsigned char )Value;
#line 377
  goto ldv_55839;
  }
  ldv_55839: ;
#line 381
  return;
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void odm_CommonInfoSelfInit23a(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 val32 ;
  u32 tmp ;

  {
#line 386
  val32 = rtl8723au_read32(pDM_Odm->Adapter, 2084);
#line 387
  if (((unsigned long )val32 & 512UL) != 0UL) {
#line 388
    pDM_Odm->bCckHighPower = 1;
  } else {
#line 390
    pDM_Odm->bCckHighPower = 0;
  }
#line 392
  tmp = rtl8723au_read32(pDM_Odm->Adapter, 3076);
#line 392
  pDM_Odm->RFPathRxEnable = (unsigned int )((u8 )tmp) & 15U;
#line 395
  ODM_InitDebugSetting23a(pDM_Odm);
#line 396
  return;
}
}
#line 398 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
static void odm_CommonInfoSelfUpdate(struct hal_data_8723a *pHalData ) 
{ 
  struct dm_odm_t *pDM_Odm ;
  struct sta_info *pEntry ;
  u8 EntryCnt ;
  u8 i ;

  {
#line 400
  pDM_Odm = & pHalData->odmpriv;
#line 402
  EntryCnt = 0U;
#line 405
  i = 0U;
#line 405
  goto ldv_55859;
  ldv_55858: 
#line 406
  pEntry = pDM_Odm->pODM_StaInfo[(int )i];
#line 407
  if ((unsigned long )pEntry != (unsigned long )((struct sta_info *)0)) {
#line 408
    EntryCnt = (u8 )((int )EntryCnt + 1);
  } else {

  }
#line 405
  i = (u8 )((int )i + 1);
  ldv_55859: ;
#line 405
  if ((unsigned int )i <= 31U) {
#line 407
    goto ldv_55858;
  } else {

  }

#line 410
  if ((unsigned int )EntryCnt == 1U) {
#line 411
    pDM_Odm->bOneEntryOnly = 1;
  } else {
#line 413
    pDM_Odm->bOneEntryOnly = 0;
  }
#line 414
  return;
}
}
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void odm_CmnInfoInit_Debug23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 418
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 418
    printk("[ODM-8723A] ");
#line 418
    printk("%s(): odm_CmnInfoInit_Debug23a ==>\n", "odm_CmnInfoInit_Debug23a");
  } else {

  }
#line 419
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 419
    printk("[ODM-8723A] ");
#line 419
    printk("%s(): SupportAbility = 0x%x\n", "odm_CmnInfoInit_Debug23a", pDM_Odm->SupportAbility);
  } else {

  }
#line 420
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 420
    printk("[ODM-8723A] ");
#line 420
    printk("%s(): SupportICType = 0x%x\n", "odm_CmnInfoInit_Debug23a", pDM_Odm->SupportICType);
  } else {

  }
#line 421
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 421
    printk("[ODM-8723A] ");
#line 421
    printk("%s(): CutVersion =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->CutVersion);
  } else {

  }
#line 422
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 422
    printk("[ODM-8723A] ");
#line 422
    printk("%s(): FabVersion =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->FabVersion);
  } else {

  }
#line 423
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 423
    printk("[ODM-8723A] ");
#line 423
    printk("%s(): BoardType =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->BoardType);
  } else {

  }
#line 424
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 424
    printk("[ODM-8723A] ");
#line 424
    printk("%s(): ExtLNA =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->ExtLNA);
  } else {

  }
#line 425
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 425
    printk("[ODM-8723A] ");
#line 425
    printk("%s(): ExtPA =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->ExtPA);
  } else {

  }
#line 426
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 426
    printk("[ODM-8723A] ");
#line 426
    printk("%s(): ExtTRSW =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->ExtTRSW);
  } else {

  }
#line 427
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 427
    printk("[ODM-8723A] ");
#line 427
    printk("%s(): bInHctTest =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->bInHctTest);
  } else {

  }
#line 428
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 428
    printk("[ODM-8723A] ");
#line 428
    printk("%s(): bWIFITest =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->bWIFITest);
  } else {

  }
#line 429
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 429
    printk("[ODM-8723A] ");
#line 429
    printk("%s(): bDualMacSmartConcurrent =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->bDualMacSmartConcurrent);
  } else {

  }
#line 431
  return;
}
}
#line 433 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void odm_CmnInfoUpdate_Debug23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 435
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 435
    printk("[ODM-8723A] ");
#line 435
    printk("%s(): odm_CmnInfoUpdate_Debug23a ==>\n", "odm_CmnInfoUpdate_Debug23a");
  } else {

  }
#line 436
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 436
    printk("[ODM-8723A] ");
#line 436
    printk("%s(): bWIFI_Direct =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->bWIFI_Direct);
  } else {

  }
#line 437
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 437
    printk("[ODM-8723A] ");
#line 437
    printk("%s(): bWIFI_Display =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->bWIFI_Display);
  } else {

  }
#line 438
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 438
    printk("[ODM-8723A] ");
#line 438
    printk("%s(): bLinked =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->bLinked);
  } else {

  }
#line 439
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 439
    printk("[ODM-8723A] ");
#line 439
    printk("%s(): RSSI_Min =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->RSSI_Min);
  } else {

  }
#line 441
  return;
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void ODM_Write_DIG23a(struct dm_odm_t *pDM_Odm , u8 CurrentIGI ) 
{ 
  struct rtw_adapter *adapter ;
  struct dig_t *pDM_DigTable ;
  u32 val32 ;

  {
#line 444
  adapter = pDM_Odm->Adapter;
#line 445
  pDM_DigTable = & pDM_Odm->DM_DigTable;
#line 448
  if ((int )pDM_DigTable->CurIGValue != (int )CurrentIGI) {
#line 449
    val32 = rtl8723au_read32(adapter, 3152);
#line 450
    val32 = val32 & 4294967168U;
#line 451
    val32 = (u32 )CurrentIGI | val32;
#line 452
    rtl8723au_write32(adapter, 3152, val32);
#line 453
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 453
      printk("[ODM-8723A] ");
#line 453
      printk("%s(): CurrentIGI(0x%02x). \n", "ODM_Write_DIG23a", (int )CurrentIGI);
    } else {

    }
#line 455
    pDM_DigTable->CurIGValue = CurrentIGI;
  } else {

  }
#line 457
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 457
    printk("[ODM-8723A] ");
#line 457
    printk("%s(): ODM_Write_DIG23a():CurrentIGI = 0x%x \n", "ODM_Write_DIG23a", (int )CurrentIGI);
  } else {

  }
#line 459
  return;
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void odm_DIG23abyRSSI_LPS(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *pAdapter ;
  struct false_alarm_stats *pFalseAlmCnt ;
  u8 RSSI_Lower ;
  u8 bFwCurrentInPSMode ;
  u8 CurrentIGI ;

  {
#line 465
  pAdapter = pDM_Odm->Adapter;
#line 466
  pFalseAlmCnt = & pDM_Odm->FalseAlmCnt;
#line 467
  RSSI_Lower = 30U;
#line 468
  bFwCurrentInPSMode = 0U;
#line 469
  CurrentIGI = pDM_Odm->RSSI_Min;
#line 471
  if ((pDM_Odm->SupportICType & 8U) == 0U) {
#line 472
    return;
  } else {

  }
#line 474
  CurrentIGI = (unsigned int )CurrentIGI + 5U;
#line 475
  bFwCurrentInPSMode = pAdapter->pwrctrlpriv.bFwCurrentInPSMode;
#line 478
  if ((unsigned int )bFwCurrentInPSMode != 0U) {
#line 479
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 479
      printk("[ODM-8723A] ");
#line 479
      printk("%s(): ---Neil---odm_DIG23a is in LPS mode\n", "odm_DIG23abyRSSI_LPS");
    } else {

    }
#line 482
    if (pFalseAlmCnt->Cnt_all > 30U) {
#line 483
      CurrentIGI = (unsigned int )CurrentIGI + 2U;
    } else
#line 484
    if (pFalseAlmCnt->Cnt_all > 15U) {
#line 485
      CurrentIGI = (unsigned int )CurrentIGI + 1U;
    } else
#line 486
    if (pFalseAlmCnt->Cnt_all <= 3U) {
#line 487
      CurrentIGI = (unsigned int )CurrentIGI + 255U;
    } else {

    }
  } else {
#line 489
    CurrentIGI = RSSI_Lower;
  }
#line 495
  if ((int )pDM_Odm->RSSI_Min + -10 > 30) {
#line 496
    RSSI_Lower = (unsigned int )pDM_Odm->RSSI_Min + 246U;
  } else {
#line 498
    RSSI_Lower = 30U;
  }
#line 501
  if ((unsigned int )CurrentIGI > 78U) {
#line 502
    CurrentIGI = 78U;
  } else
#line 503
  if ((int )CurrentIGI < (int )RSSI_Lower) {
#line 504
    CurrentIGI = RSSI_Lower;
  } else {

  }
#line 506
  ODM_Write_DIG23a(pDM_Odm, (int )CurrentIGI);
#line 507
  return;
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void odm_DIG23aInit(struct dm_odm_t *pDM_Odm ) 
{ 
  struct dig_t *pDM_DigTable ;
  u32 val32 ;

  {
#line 511
  pDM_DigTable = & pDM_Odm->DM_DigTable;
#line 514
  val32 = rtl8723au_read32(pDM_Odm->Adapter, 3152);
#line 515
  pDM_DigTable->CurIGValue = (unsigned int )((u8 )val32) & 127U;
#line 517
  pDM_DigTable->RssiLowThresh = 35;
#line 518
  pDM_DigTable->RssiHighThresh = 40;
#line 519
  pDM_DigTable->FALowThresh = 400U;
#line 520
  pDM_DigTable->FAHighThresh = 1000U;
#line 521
  if ((unsigned int )pDM_Odm->BoardType == 1U) {
#line 522
    pDM_DigTable->rx_gain_range_max = 78U;
#line 523
    pDM_DigTable->rx_gain_range_min = 30U;
  } else {
#line 525
    pDM_DigTable->rx_gain_range_max = 78U;
#line 526
    pDM_DigTable->rx_gain_range_min = 30U;
  }
#line 528
  pDM_DigTable->BackoffVal = 10;
#line 529
  pDM_DigTable->BackoffVal_range_max = 12;
#line 530
  pDM_DigTable->BackoffVal_range_min = -4;
#line 531
  pDM_DigTable->PreCCK_CCAThres = 255U;
#line 532
  pDM_DigTable->CurCCK_CCAThres = 131U;
#line 533
  pDM_DigTable->ForbiddenIGI = 30U;
#line 534
  pDM_DigTable->LargeFAHit = 0U;
#line 535
  pDM_DigTable->Recover_cnt = 0U;
#line 536
  pDM_DigTable->DIG_Dynamic_MIN_0 = 30U;
#line 537
  pDM_DigTable->DIG_Dynamic_MIN_1 = 30U;
#line 538
  pDM_DigTable->bMediaConnect_0 = 0;
#line 539
  pDM_DigTable->bMediaConnect_1 = 0;
#line 540
  return;
}
}
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void odm_DIG23a(struct rtw_adapter *adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *pDM_Odm ;
  struct dig_t *pDM_DigTable ;
  struct false_alarm_stats *pFalseAlmCnt ;
  u8 DIG_Dynamic_MIN ;
  u8 DIG_MaxOfMin ;
  bool FirstConnect ;
  bool FirstDisConnect ;
  u8 dm_dig_max ;
  u8 dm_dig_min ;
  u8 CurrentIGI ;

  {
#line 544
  pHalData = (struct hal_data_8723a *)adapter->HalData;
#line 545
  pDM_Odm = & pHalData->odmpriv;
#line 546
  pDM_DigTable = & pDM_Odm->DM_DigTable;
#line 547
  pFalseAlmCnt = & pDM_Odm->FalseAlmCnt;
#line 552
  CurrentIGI = pDM_DigTable->CurIGValue;
#line 554
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 554
    printk("[ODM-8723A] ");
#line 554
    printk("%s(): odm_DIG23a() ==>\n", "odm_DIG23a");
  } else {

  }
#line 556
  if ((unsigned int )adapter->mlmepriv.bScanInProcess != 0U) {
#line 557
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 557
      printk("[ODM-8723A] ");
#line 557
      printk("%s(): odm_DIG23a() Return: In Scan Progress \n", "odm_DIG23a");
    } else {

    }
#line 559
    return;
  } else {

  }
#line 562
  DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
#line 563
  FirstConnect = (bool )((int )pDM_Odm->bLinked && ! pDM_DigTable->bMediaConnect_0);
#line 564
  FirstDisConnect = (bool )(! pDM_Odm->bLinked && (int )pDM_DigTable->bMediaConnect_0);
#line 568
  if ((pDM_Odm->SupportICType & 8U) != 0U && ((unsigned int )pDM_Odm->BoardType == 1U || (unsigned int )pDM_Odm->ExtLNA != 0U)) {
#line 570
    dm_dig_max = 70U;
#line 571
    dm_dig_min = 46U;
#line 572
    DIG_MaxOfMin = 66U;
  } else {
#line 574
    dm_dig_max = 78U;
#line 575
    dm_dig_min = 30U;
#line 576
    DIG_MaxOfMin = 50U;
  }
#line 579
  if ((int )pDM_Odm->bLinked) {
#line 581
    if (pDM_Odm->SupportICType == 8U) {
#line 583
      if ((int )pDM_Odm->RSSI_Min + 10 > 78) {
#line 584
        pDM_DigTable->rx_gain_range_max = 78U;
      } else
#line 585
      if ((int )pDM_Odm->RSSI_Min + 10 <= 29) {
#line 586
        pDM_DigTable->rx_gain_range_max = 30U;
      } else {
#line 588
        pDM_DigTable->rx_gain_range_max = (unsigned int )pDM_Odm->RSSI_Min + 10U;
      }
#line 591
      DIG_Dynamic_MIN = 30U;
    } else {
#line 594
      if ((int )pDM_Odm->RSSI_Min + 20 > (int )dm_dig_max) {
#line 595
        pDM_DigTable->rx_gain_range_max = dm_dig_max;
      } else
#line 596
      if ((int )pDM_Odm->RSSI_Min + 20 < (int )dm_dig_min) {
#line 597
        pDM_DigTable->rx_gain_range_max = dm_dig_min;
      } else {
#line 599
        pDM_DigTable->rx_gain_range_max = (unsigned int )pDM_Odm->RSSI_Min + 20U;
      }
#line 602
      if ((int )pDM_Odm->bOneEntryOnly) {
#line 603
        if ((int )pDM_Odm->RSSI_Min < (int )dm_dig_min) {
#line 604
          DIG_Dynamic_MIN = dm_dig_min;
        } else
#line 605
        if ((int )pDM_Odm->RSSI_Min > (int )DIG_MaxOfMin) {
#line 606
          DIG_Dynamic_MIN = DIG_MaxOfMin;
        } else {
#line 608
          DIG_Dynamic_MIN = pDM_Odm->RSSI_Min;
        }
#line 609
        if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 609
          printk("[ODM-8723A] ");
#line 609
          printk("%s(): odm_DIG23a() : bOneEntryOnly = true,  DIG_Dynamic_MIN = 0x%x\n",
                 "odm_DIG23a", (int )DIG_Dynamic_MIN);
        } else {

        }
#line 612
        if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 612
          printk("[ODM-8723A] ");
#line 612
          printk("%s(): odm_DIG23a() : pDM_Odm->RSSI_Min =%d\n", "odm_DIG23a", (int )pDM_Odm->RSSI_Min);
        } else {

        }
      } else {
#line 616
        DIG_Dynamic_MIN = dm_dig_min;
      }
    }
  } else {
#line 620
    pDM_DigTable->rx_gain_range_max = dm_dig_max;
#line 621
    DIG_Dynamic_MIN = dm_dig_min;
#line 622
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 622
      printk("[ODM-8723A] ");
#line 622
      printk("%s(): odm_DIG23a() : No Link\n", "odm_DIG23a");
    } else {

    }
  }
#line 626
  if (pFalseAlmCnt->Cnt_all > 10000U) {
#line 627
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 627
      printk("[ODM-8723A] ");
#line 627
      printk("%s(): dm_DIG(): Abnornally false alarm case. \n", "odm_DIG23a");
    } else {

    }
#line 630
    if ((unsigned int )pDM_DigTable->LargeFAHit != 3U) {
#line 631
      pDM_DigTable->LargeFAHit = (u8 )((int )pDM_DigTable->LargeFAHit + 1);
    } else {

    }
#line 632
    if ((int )pDM_DigTable->ForbiddenIGI < (int )CurrentIGI) {
#line 633
      pDM_DigTable->ForbiddenIGI = CurrentIGI;
#line 634
      pDM_DigTable->LargeFAHit = 1U;
    } else {

    }
#line 637
    if ((unsigned int )pDM_DigTable->LargeFAHit > 2U) {
#line 638
      if ((int )pDM_DigTable->ForbiddenIGI + 1 > (int )pDM_DigTable->rx_gain_range_max) {
#line 639
        pDM_DigTable->rx_gain_range_min = pDM_DigTable->rx_gain_range_max;
      } else {
#line 641
        pDM_DigTable->rx_gain_range_min = (unsigned int )pDM_DigTable->ForbiddenIGI + 1U;
      }
#line 642
      pDM_DigTable->Recover_cnt = 3600U;
    } else {

    }
  } else
#line 646
  if (pDM_DigTable->Recover_cnt != 0U) {
#line 647
    pDM_DigTable->Recover_cnt = pDM_DigTable->Recover_cnt - 1U;
  } else
#line 649
  if ((unsigned int )pDM_DigTable->LargeFAHit <= 2U) {
#line 650
    if ((int )pDM_DigTable->ForbiddenIGI + -1 < (int )DIG_Dynamic_MIN) {
#line 651
      pDM_DigTable->ForbiddenIGI = DIG_Dynamic_MIN;
#line 652
      pDM_DigTable->rx_gain_range_min = DIG_Dynamic_MIN;
#line 653
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 653
        printk("[ODM-8723A] ");
#line 653
        printk("%s(): odm_DIG23a(): Normal Case: At Lower Bound\n", "odm_DIG23a");
      } else {

      }
    } else {
#line 656
      pDM_DigTable->ForbiddenIGI = (u8 )((int )pDM_DigTable->ForbiddenIGI - 1);
#line 657
      pDM_DigTable->rx_gain_range_min = (unsigned int )pDM_DigTable->ForbiddenIGI + 1U;
#line 658
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 658
        printk("[ODM-8723A] ");
#line 658
        printk("%s(): odm_DIG23a(): Normal Case: Approach Lower Bound\n", "odm_DIG23a");
      } else {

      }
    }
  } else {
#line 662
    pDM_DigTable->LargeFAHit = 0U;
  }
#line 666
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 666
    printk("[ODM-8723A] ");
#line 666
    printk("%s(): odm_DIG23a(): pDM_DigTable->LargeFAHit =%d\n", "odm_DIG23a", (int )pDM_DigTable->LargeFAHit);
  } else {

  }
#line 669
  if ((int )pDM_Odm->bLinked) {
#line 670
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 670
      printk("[ODM-8723A] ");
#line 670
      printk("%s(): odm_DIG23a(): DIG AfterLink\n", "odm_DIG23a");
    } else {

    }
#line 671
    if ((int )FirstConnect) {
#line 672
      CurrentIGI = pDM_Odm->RSSI_Min;
#line 673
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 673
        printk("[ODM-8723A] ");
#line 673
        printk("%s(): DIG: First Connect\n", "odm_DIG23a");
      } else {

      }
    } else
#line 675
    if (pFalseAlmCnt->Cnt_all > 1024U) {
#line 676
      CurrentIGI = (unsigned int )CurrentIGI + 4U;
    } else
#line 677
    if (pFalseAlmCnt->Cnt_all > 768U) {
#line 678
      CurrentIGI = (unsigned int )CurrentIGI + 2U;
    } else
#line 679
    if (pFalseAlmCnt->Cnt_all <= 511U) {
#line 680
      CurrentIGI = (unsigned int )CurrentIGI + 254U;
    } else {

    }
  } else {
#line 683
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 683
      printk("[ODM-8723A] ");
#line 683
      printk("%s(): odm_DIG23a(): DIG BeforeLink\n", "odm_DIG23a");
    } else {

    }
#line 684
    if ((int )FirstDisConnect) {
#line 685
      CurrentIGI = pDM_DigTable->rx_gain_range_min;
#line 686
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 686
        printk("[ODM-8723A] ");
#line 686
        printk("%s(): odm_DIG23a(): First DisConnect \n", "odm_DIG23a");
      } else {

      }
    } else {
#line 689
      if (pFalseAlmCnt->Cnt_all > 10000U) {
#line 690
        CurrentIGI = (unsigned int )CurrentIGI + 2U;
      } else
#line 691
      if (pFalseAlmCnt->Cnt_all > 8000U) {
#line 692
        CurrentIGI = (unsigned int )CurrentIGI + 1U;
      } else
#line 693
      if (pFalseAlmCnt->Cnt_all <= 499U) {
#line 694
        CurrentIGI = (unsigned int )CurrentIGI + 255U;
      } else {

      }
#line 695
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 695
        printk("[ODM-8723A] ");
#line 695
        printk("%s(): odm_DIG23a(): England DIG \n", "odm_DIG23a");
      } else {

      }
    }
  }
#line 698
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 698
    printk("[ODM-8723A] ");
#line 698
    printk("%s(): odm_DIG23a(): DIG End Adjust IGI\n", "odm_DIG23a");
  } else {

  }
#line 700
  if ((int )pDM_DigTable->rx_gain_range_max < (int )CurrentIGI) {
#line 701
    CurrentIGI = pDM_DigTable->rx_gain_range_max;
  } else {

  }
#line 702
  if ((int )pDM_DigTable->rx_gain_range_min > (int )CurrentIGI) {
#line 703
    CurrentIGI = pDM_DigTable->rx_gain_range_min;
  } else {

  }
#line 705
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 705
    printk("[ODM-8723A] ");
#line 705
    printk("%s(): odm_DIG23a(): rx_gain_range_max = 0x%x, rx_gain_range_min = 0x%x\n",
           "odm_DIG23a", (int )pDM_DigTable->rx_gain_range_max, (int )pDM_DigTable->rx_gain_range_min);
  } else {

  }
#line 707
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 707
    printk("[ODM-8723A] ");
#line 707
    printk("%s(): odm_DIG23a(): TotalFA =%d\n", "odm_DIG23a", pFalseAlmCnt->Cnt_all);
  } else {

  }
#line 708
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 708
    printk("[ODM-8723A] ");
#line 708
    printk("%s(): odm_DIG23a(): CurIGValue = 0x%x\n", "odm_DIG23a", (int )CurrentIGI);
  } else {

  }
#line 712
  ODM_Write_DIG23a(pDM_Odm, (int )CurrentIGI);
#line 713
  pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
#line 714
  pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
#line 715
  return;
}
}
#line 721 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void odm_FalseAlarmCounterStatistics23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *adapter ;
  struct false_alarm_stats *FalseAlmCnt ;
  u32 ret_value ;
  u32 val32 ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 723
  adapter = pDM_Odm->Adapter;
#line 724
  FalseAlmCnt = & pDM_Odm->FalseAlmCnt;
#line 729
  val32 = rtl8723au_read32(adapter, 3072);
#line 730
  val32 = val32 | 2147483648U;
#line 731
  rtl8723au_write32(adapter, 3072, val32);
#line 733
  val32 = rtl8723au_read32(adapter, 3328);
#line 734
  val32 = val32 | 2147483648U;
#line 735
  rtl8723au_write32(adapter, 3328, val32);
#line 736
  ret_value = rtl8723au_read32(adapter, 3312);
#line 737
  FalseAlmCnt->Cnt_Fast_Fsync = ret_value & 65535U;
#line 738
  FalseAlmCnt->Cnt_SB_Search_fail = ret_value >> 16;
#line 739
  ret_value = rtl8723au_read32(adapter, 3488);
#line 740
  FalseAlmCnt->Cnt_OFDM_CCA = ret_value & 65535U;
#line 741
  FalseAlmCnt->Cnt_Parity_Fail = ret_value >> 16;
#line 742
  ret_value = rtl8723au_read32(adapter, 3492);
#line 743
  FalseAlmCnt->Cnt_Rate_Illegal = ret_value & 65535U;
#line 744
  FalseAlmCnt->Cnt_Crc8_fail = ret_value >> 16;
#line 745
  ret_value = rtl8723au_read32(adapter, 3496);
#line 746
  FalseAlmCnt->Cnt_Mcs_fail = ret_value & 65535U;
#line 748
  FalseAlmCnt->Cnt_Ofdm_fail = ((((FalseAlmCnt->Cnt_Parity_Fail + FalseAlmCnt->Cnt_Rate_Illegal) + FalseAlmCnt->Cnt_Crc8_fail) + FalseAlmCnt->Cnt_Mcs_fail) + FalseAlmCnt->Cnt_Fast_Fsync) + FalseAlmCnt->Cnt_SB_Search_fail;
#line 755
  val32 = rtl8723au_read32(adapter, 2604);
#line 756
  val32 = val32 | 20480U;
#line 757
  rtl8723au_write32(adapter, 2604, val32);
#line 759
  tmp = rtl8723au_read32(adapter, 2652);
#line 759
  ret_value = tmp & 255U;
#line 760
  FalseAlmCnt->Cnt_Cck_fail = ret_value;
#line 761
  tmp___0 = rtl8723au_read32(adapter, 2648);
#line 761
  ret_value = tmp___0 >> 16;
#line 762
  FalseAlmCnt->Cnt_Cck_fail = FalseAlmCnt->Cnt_Cck_fail + (ret_value & 65280U);
#line 764
  ret_value = rtl8723au_read32(adapter, 2656);
#line 765
  FalseAlmCnt->Cnt_CCK_CCA = ((ret_value << 8) & 65535U) | ((ret_value & 65280U) >> 8);
#line 768
  FalseAlmCnt->Cnt_all = (((((FalseAlmCnt->Cnt_Fast_Fsync + FalseAlmCnt->Cnt_SB_Search_fail) + FalseAlmCnt->Cnt_Parity_Fail) + FalseAlmCnt->Cnt_Rate_Illegal) + FalseAlmCnt->Cnt_Crc8_fail) + FalseAlmCnt->Cnt_Mcs_fail) + FalseAlmCnt->Cnt_Cck_fail;
#line 776
  FalseAlmCnt->Cnt_CCA_all = FalseAlmCnt->Cnt_OFDM_CCA + FalseAlmCnt->Cnt_CCK_CCA;
#line 779
  if (pDM_Odm->SupportICType > 7U) {
#line 781
    val32 = rtl8723au_read32(adapter, 3084);
#line 782
    val32 = val32 | 2147483648U;
#line 783
    rtl8723au_write32(adapter, 3084, val32);
#line 784
    val32 = rtl8723au_read32(adapter, 3084);
#line 785
    val32 = val32 & 2147483647U;
#line 786
    rtl8723au_write32(adapter, 3084, val32);
#line 788
    val32 = rtl8723au_read32(adapter, 3328);
#line 789
    val32 = val32 | 134217728U;
#line 790
    rtl8723au_write32(adapter, 3328, val32);
#line 791
    val32 = rtl8723au_read32(adapter, 3328);
#line 792
    val32 = val32 & 4160749567U;
#line 793
    rtl8723au_write32(adapter, 3328, val32);
#line 797
    val32 = rtl8723au_read32(adapter, 3072);
#line 798
    val32 = val32 & 2147483647U;
#line 799
    rtl8723au_write32(adapter, 3072, val32);
#line 802
    val32 = rtl8723au_read32(adapter, 3328);
#line 803
    val32 = val32 & 2147483647U;
#line 804
    rtl8723au_write32(adapter, 3328, val32);
#line 807
    val32 = rtl8723au_read32(adapter, 2604);
#line 808
    val32 = val32 & 4294905855U;
#line 809
    rtl8723au_write32(adapter, 2604, val32);
#line 811
    val32 = rtl8723au_read32(adapter, 2604);
#line 812
    val32 = val32 | 40960U;
#line 813
    rtl8723au_write32(adapter, 2604, val32);
  } else {

  }
#line 816
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 816
    printk("[ODM-8723A] ");
#line 816
    printk("%s(): Enter odm_FalseAlarmCounterStatistics23a\n", "odm_FalseAlarmCounterStatistics23a");
  } else {

  }
#line 818
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 818
    printk("[ODM-8723A] ");
#line 818
    printk("%s(): Cnt_Fast_Fsync =%d, Cnt_SB_Search_fail =%d\n", "odm_FalseAlarmCounterStatistics23a",
           FalseAlmCnt->Cnt_Fast_Fsync, FalseAlmCnt->Cnt_SB_Search_fail);
  } else {

  }
#line 822
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 822
    printk("[ODM-8723A] ");
#line 822
    printk("%s(): Cnt_Parity_Fail =%d, Cnt_Rate_Illegal =%d\n", "odm_FalseAlarmCounterStatistics23a",
           FalseAlmCnt->Cnt_Parity_Fail, FalseAlmCnt->Cnt_Rate_Illegal);
  } else {

  }
#line 826
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 826
    printk("[ODM-8723A] ");
#line 826
    printk("%s(): Cnt_Crc8_fail =%d, Cnt_Mcs_fail =%d\n", "odm_FalseAlarmCounterStatistics23a",
           FalseAlmCnt->Cnt_Crc8_fail, FalseAlmCnt->Cnt_Mcs_fail);
  } else {

  }
#line 830
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 830
    printk("[ODM-8723A] ");
#line 830
    printk("%s(): Cnt_Cck_fail =%d\n", "odm_FalseAlarmCounterStatistics23a", FalseAlmCnt->Cnt_Cck_fail);
  } else {

  }
#line 832
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 832
    printk("[ODM-8723A] ");
#line 832
    printk("%s(): Cnt_Ofdm_fail =%d\n", "odm_FalseAlarmCounterStatistics23a", FalseAlmCnt->Cnt_Ofdm_fail);
  } else {

  }
#line 834
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 834
    printk("[ODM-8723A] ");
#line 834
    printk("%s(): Total False Alarm =%d\n", "odm_FalseAlarmCounterStatistics23a",
           FalseAlmCnt->Cnt_all);
  } else {

  }
#line 836
  return;
}
}
#line 842 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void odm_CCKPacketDetectionThresh23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct false_alarm_stats *FalseAlmCnt ;
  u8 CurCCK_CCAThres ;

  {
#line 844
  FalseAlmCnt = & pDM_Odm->FalseAlmCnt;
#line 847
  if ((unsigned int )pDM_Odm->ExtLNA != 0U) {
#line 848
    return;
  } else {

  }
#line 850
  if ((int )pDM_Odm->bLinked) {
#line 851
    if ((unsigned int )pDM_Odm->RSSI_Min > 25U) {
#line 852
      CurCCK_CCAThres = 205U;
    } else
#line 853
    if ((unsigned int )pDM_Odm->RSSI_Min <= 25U && (unsigned int )pDM_Odm->RSSI_Min > 10U) {
#line 854
      CurCCK_CCAThres = 131U;
    } else
#line 856
    if (FalseAlmCnt->Cnt_Cck_fail > 1000U) {
#line 857
      CurCCK_CCAThres = 131U;
    } else {
#line 859
      CurCCK_CCAThres = 64U;
    }
  } else
#line 862
  if (FalseAlmCnt->Cnt_Cck_fail > 1000U) {
#line 863
    CurCCK_CCAThres = 131U;
  } else {
#line 865
    CurCCK_CCAThres = 64U;
  }
#line 868
  ODM_Write_CCK_CCA_Thres23a(pDM_Odm, (int )CurCCK_CCAThres);
#line 869
  return;
}
}
#line 871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void ODM_Write_CCK_CCA_Thres23a(struct dm_odm_t *pDM_Odm , u8 CurCCK_CCAThres ) 
{ 
  struct dig_t *pDM_DigTable ;

  {
#line 873
  pDM_DigTable = & pDM_Odm->DM_DigTable;
#line 875
  if ((int )pDM_DigTable->CurCCK_CCAThres != (int )CurCCK_CCAThres) {
#line 876
    rtl8723au_write8(pDM_Odm->Adapter, 2570, (int )CurCCK_CCAThres);
  } else {

  }
#line 878
  pDM_DigTable->PreCCK_CCAThres = pDM_DigTable->CurCCK_CCAThres;
#line 879
  pDM_DigTable->CurCCK_CCAThres = CurCCK_CCAThres;
#line 880
  return;
}
}
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void odm23a_DynBBPSInit(struct dm_odm_t *pDM_Odm ) 
{ 
  struct dynamic_pwr_sav *pDM_PSTable ;

  {
#line 887
  pDM_PSTable = & pDM_Odm->DM_PSTable;
#line 889
  pDM_PSTable->PreCCAState = 2U;
#line 890
  pDM_PSTable->CurCCAState = 2U;
#line 891
  pDM_PSTable->PreRFState = 2U;
#line 892
  pDM_PSTable->CurRFState = 2U;
#line 893
  pDM_PSTable->Rssi_val_min = 0;
#line 894
  pDM_PSTable->initialize = 0U;
#line 895
  return;
}
}
#line 897 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void odm_DynamicBBPowerSaving23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 899
  return;
}
}
#line 902 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void ODM_RF_Saving23a(struct dm_odm_t *pDM_Odm , u8 bForceInNormal ) 
{ 
  struct dynamic_pwr_sav *pDM_PSTable ;
  struct rtw_adapter *adapter ;
  u32 val32 ;
  u8 Rssi_Up_bound ;
  u8 Rssi_Low_bound ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
#line 904
  pDM_PSTable = & pDM_Odm->DM_PSTable;
#line 905
  adapter = pDM_Odm->Adapter;
#line 907
  Rssi_Up_bound = 30U;
#line 908
  Rssi_Low_bound = 25U;
#line 909
  if ((unsigned int )pDM_PSTable->initialize == 0U) {
#line 911
    tmp = rtl8723au_read32(adapter, 2164);
#line 911
    pDM_PSTable->Reg874 = tmp & 1884160U;
#line 913
    tmp___0 = rtl8723au_read32(adapter, 3184);
#line 913
    pDM_PSTable->RegC70 = tmp___0 & 8U;
#line 915
    tmp___1 = rtl8723au_read32(adapter, 2140);
#line 915
    pDM_PSTable->Reg85C = tmp___1 & 4278190080U;
#line 917
    tmp___2 = rtl8723au_read32(adapter, 2676);
#line 917
    pDM_PSTable->RegA74 = tmp___2 & 61440U;
#line 918
    pDM_PSTable->initialize = 1U;
  } else {

  }
#line 921
  if ((unsigned int )bForceInNormal == 0U) {
#line 922
    if ((unsigned int )pDM_Odm->RSSI_Min != 255U) {
#line 923
      if ((unsigned int )pDM_PSTable->PreRFState == 1U) {
#line 924
        if ((int )pDM_Odm->RSSI_Min >= (int )Rssi_Up_bound) {
#line 925
          pDM_PSTable->CurRFState = 0U;
        } else {
#line 927
          pDM_PSTable->CurRFState = 1U;
        }
      } else
#line 929
      if ((int )pDM_Odm->RSSI_Min <= (int )Rssi_Low_bound) {
#line 930
        pDM_PSTable->CurRFState = 1U;
      } else {
#line 932
        pDM_PSTable->CurRFState = 0U;
      }
    } else {
#line 935
      pDM_PSTable->CurRFState = 2U;
    }
  } else {
#line 938
    pDM_PSTable->CurRFState = 1U;
  }
#line 941
  if ((int )pDM_PSTable->PreRFState != (int )pDM_PSTable->CurRFState) {
#line 942
    if ((unsigned int )pDM_PSTable->CurRFState == 0U) {
#line 947
      if (pDM_Odm->SupportICType == 8U) {
#line 948
        val32 = rtl8723au_read32(adapter, 2164);
#line 949
        val32 = val32 | 32U;
#line 950
        rtl8723au_write32(adapter, 2164, val32);
      } else {

      }
#line 953
      val32 = rtl8723au_read32(adapter, 2164);
#line 954
      val32 = val32 & 4293656575U;
#line 955
      val32 = val32 | 524288U;
#line 956
      rtl8723au_write32(adapter, 2164, val32);
#line 958
      val32 = rtl8723au_read32(adapter, 3184);
#line 959
      val32 = val32 & 4294967287U;
#line 960
      rtl8723au_write32(adapter, 3184, val32);
#line 962
      val32 = rtl8723au_read32(adapter, 2140);
#line 963
      val32 = val32 & 16777215U;
#line 964
      val32 = val32 | 1660944384U;
#line 965
      rtl8723au_write32(adapter, 2140, val32);
#line 967
      val32 = rtl8723au_read32(adapter, 2164);
#line 968
      val32 = val32 & 4294950911U;
#line 969
      val32 = val32 | 32768U;
#line 970
      rtl8723au_write32(adapter, 2164, val32);
#line 972
      val32 = rtl8723au_read32(adapter, 2676);
#line 973
      val32 = val32 & 4294918143U;
#line 974
      val32 = val32 | 12288U;
#line 975
      rtl8723au_write32(adapter, 2676, val32);
#line 977
      val32 = rtl8723au_read32(adapter, 2072);
#line 978
      val32 = val32 & 4026531839U;
#line 979
      rtl8723au_write32(adapter, 2072, val32);
#line 981
      val32 = rtl8723au_read32(adapter, 2072);
#line 982
      val32 = val32 | 268435456U;
#line 983
      rtl8723au_write32(adapter, 2072, val32);
    } else {
#line 985
      val32 = rtl8723au_read32(adapter, 2164);
#line 986
      val32 = pDM_PSTable->Reg874 | val32;
#line 987
      rtl8723au_write32(adapter, 2164, val32);
#line 989
      val32 = rtl8723au_read32(adapter, 3184);
#line 990
      val32 = pDM_PSTable->RegC70 | val32;
#line 991
      rtl8723au_write32(adapter, 3184, val32);
#line 993
      val32 = rtl8723au_read32(adapter, 2140);
#line 994
      val32 = pDM_PSTable->Reg85C | val32;
#line 995
      rtl8723au_write32(adapter, 2140, val32);
#line 997
      val32 = rtl8723au_read32(adapter, 2676);
#line 998
      val32 = pDM_PSTable->RegA74 | val32;
#line 999
      rtl8723au_write32(adapter, 2676, val32);
#line 1001
      val32 = rtl8723au_read32(adapter, 2072);
#line 1002
      val32 = val32 & 4026531839U;
#line 1003
      rtl8723au_write32(adapter, 2072, val32);
#line 1006
      if (pDM_Odm->SupportICType == 8U) {
#line 1007
        val32 = rtl8723au_read32(adapter, 2164);
#line 1008
        val32 = val32 & 4294967263U;
#line 1009
        rtl8723au_write32(adapter, 2164, val32);
      } else {

      }
    }
#line 1012
    pDM_PSTable->PreRFState = pDM_PSTable->CurRFState;
  } else {

  }
#line 1014
  return;
}
}
#line 1023 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void odm_RateAdaptiveMaskInit23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct odm_rate_adapt *pOdmRA ;

  {
#line 1025
  pOdmRA = & pDM_Odm->RateAdaptive;
#line 1027
  pOdmRA->Type = 1U;
#line 1029
  pOdmRA->RATRState = 0U;
#line 1030
  pOdmRA->HighRSSIThresh = 50U;
#line 1031
  pOdmRA->LowRSSIThresh = 20U;
#line 1032
  return;
}
}
#line 1034 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
u32 ODM_Get_Rate_Bitmap23a(struct hal_data_8723a *pHalData , u32 macid , u32 ra_mask ,
                           u8 rssi_level ) 
{ 
  struct dm_odm_t *pDM_Odm ;
  struct sta_info *pEntry ;
  u32 rate_bitmap ;
  u8 WirelessMode ;

  {
#line 1037
  pDM_Odm = & pHalData->odmpriv;
#line 1039
  rate_bitmap = 268435455U;
#line 1042
  pEntry = pDM_Odm->pODM_StaInfo[macid];
#line 1043
  if ((unsigned long )pEntry == (unsigned long )((struct sta_info *)0)) {
#line 1044
    return (ra_mask);
  } else {

  }
#line 1046
  WirelessMode = pEntry->wireless_mode;
#line 1048
  switch ((int )WirelessMode) {
  case 1: ;
#line 1050
  if ((ra_mask & 12U) != 0U) {
#line 1051
    rate_bitmap = 13U;
  } else {
#line 1053
    rate_bitmap = 15U;
  }
#line 1054
  goto ldv_55955;
  case 6: ;
#line 1056
  if ((unsigned int )rssi_level == 1U) {
#line 1057
    rate_bitmap = 3840U;
  } else {
#line 1059
    rate_bitmap = 4080U;
  }
#line 1060
  goto ldv_55955;
  case 3: ;
#line 1062
  if ((unsigned int )rssi_level == 1U) {
#line 1063
    rate_bitmap = 3840U;
  } else
#line 1064
  if ((unsigned int )rssi_level == 2U) {
#line 1065
    rate_bitmap = 4080U;
  } else {
#line 1067
    rate_bitmap = 4085U;
  }
#line 1068
  goto ldv_55955;
  case 11: ;
  case 15: ;
#line 1071
  if ((unsigned int )pHalData->rf_type == 0U || (unsigned int )pHalData->rf_type == 3U) {
#line 1073
    if ((unsigned int )rssi_level == 1U) {
#line 1074
      rate_bitmap = 983040U;
    } else
#line 1075
    if ((unsigned int )rssi_level == 2U) {
#line 1076
      rate_bitmap = 1044480U;
    } else
#line 1078
    if ((unsigned int )pHalData->CurrentChannelBW == 1U) {
#line 1080
      rate_bitmap = 1044501U;
    } else {
#line 1082
      rate_bitmap = 1044485U;
    }
  } else
#line 1085
  if ((unsigned int )rssi_level == 1U) {
#line 1086
    rate_bitmap = 261029888U;
  } else
#line 1087
  if ((unsigned int )rssi_level == 2U) {
#line 1088
    rate_bitmap = 261091328U;
  } else
#line 1090
  if ((unsigned int )pHalData->CurrentChannelBW == 1U) {
#line 1092
    rate_bitmap = 261091349U;
  } else {
#line 1094
    rate_bitmap = 261091333U;
  }
#line 1097
  goto ldv_55955;
  default: ;
#line 1101
  if ((unsigned int )pHalData->rf_type == 0U) {
#line 1102
    rate_bitmap = 1048575U;
  } else {
#line 1104
    rate_bitmap = 268435455U;
  }
#line 1105
  goto ldv_55955;
  }
  ldv_55955: ;
#line 1108
  if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1108
    printk("[ODM-8723A] ");
#line 1108
    printk("%s():  ==> rssi_level:0x%02x, WirelessMode:0x%02x, rate_bitmap:0x%08x \n",
           "ODM_Get_Rate_Bitmap23a", (int )rssi_level, (int )WirelessMode, rate_bitmap);
  } else {

  }
#line 1112
  return (rate_bitmap);
}
}
#line 1131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
static void odm_RefreshRateAdaptiveMask(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *pAdapter ;
  u32 smoothed ;
  u8 i ;
  struct sta_info *pstat ;
  bool tmp ;

  {
#line 1133
  pAdapter = pDM_Odm->Adapter;
#line 1137
  if (pAdapter->bDriverStopped != 0) {
#line 1138
    if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 4U) {
#line 1138
      printk("[ODM-8723A] ");
#line 1138
      printk("%s(): <---- %s: driver is going to unload\n", "odm_RefreshRateAdaptiveMask",
             "odm_RefreshRateAdaptiveMask");
    } else {

    }
#line 1141
    return;
  } else {

  }
#line 1144
  i = 0U;
#line 1144
  goto ldv_55971;
  ldv_55970: 
#line 1145
  pstat = pDM_Odm->pODM_StaInfo[(int )i];
#line 1146
  if ((unsigned long )pstat != (unsigned long )((struct sta_info *)0)) {
#line 1147
    smoothed = (u32 )pstat->rssi_stat.UndecoratedSmoothedPWDB;
#line 1148
    tmp = ODM_RAStateCheck23a(pDM_Odm, (s32 )smoothed, 0, & pstat->rssi_level);
#line 1148
    if ((int )tmp) {
#line 1150
      if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1150
        printk("[ODM-8723A] ");
#line 1150
        printk("%s(): RSSI:%d, RSSI_LEVEL:%d\n", "odm_RefreshRateAdaptiveMask", smoothed,
               (int )pstat->rssi_level);
      } else {

      }
#line 1155
      rtw_hal_update_ra_mask23a(pstat, (int )pstat->rssi_level);
    } else {

    }
  } else {

  }
#line 1144
  i = (u8 )((int )i + 1);
  ldv_55971: ;
#line 1144
  if ((unsigned int )i <= 31U) {
#line 1146
    goto ldv_55970;
  } else {

  }

#line 1151
  return;
}
}
#line 1164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
bool ODM_RAStateCheck23a(struct dm_odm_t *pDM_Odm , s32 RSSI , bool bForceUpdate ,
                         u8 *pRATRState ) 
{ 
  struct odm_rate_adapt *pRA ;
  u8 GoUpGap ;
  u8 HighRSSIThreshForRA ;
  u8 LowRSSIThreshForRA ;
  u8 RATRState ;

  {
#line 1167
  pRA = & pDM_Odm->RateAdaptive;
#line 1168
  GoUpGap = 5U;
#line 1169
  HighRSSIThreshForRA = pRA->HighRSSIThresh;
#line 1170
  LowRSSIThreshForRA = pRA->LowRSSIThresh;
#line 1176
  switch ((int )*pRATRState) {
  case 0: ;
  case 1: ;
#line 1179
  goto ldv_55986;
  case 2: 
#line 1181
  HighRSSIThreshForRA = (int )HighRSSIThreshForRA + (int )GoUpGap;
#line 1182
  goto ldv_55986;
  case 3: 
#line 1184
  HighRSSIThreshForRA = (int )HighRSSIThreshForRA + (int )GoUpGap;
#line 1185
  LowRSSIThreshForRA = (int )LowRSSIThreshForRA + (int )GoUpGap;
#line 1186
  goto ldv_55986;
  default: 
#line 1188
  printk("Assertion failed! %s at ......\n", (char *)"false");
#line 1188
  printk("      ......%s,%s,line=%d\n", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c",
         "ODM_RAStateCheck23a", 1189);
#line 1188
  printk("%s(): wrong rssi level setting %d !", "ODM_RAStateCheck23a", (int )*pRATRState);
#line 1190
  goto ldv_55986;
  }
  ldv_55986: ;
#line 1194
  if ((int )HighRSSIThreshForRA < RSSI) {
#line 1195
    RATRState = 1U;
  } else
#line 1196
  if ((int )LowRSSIThreshForRA < RSSI) {
#line 1197
    RATRState = 2U;
  } else {
#line 1199
    RATRState = 3U;
  }
#line 1201
  if ((int )*pRATRState != (int )RATRState || (int )bForceUpdate) {
#line 1202
    if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1202
      printk("[ODM-8723A] ");
#line 1202
      printk("%s(): RSSI Level %d -> %d\n", "ODM_RAStateCheck23a", (int )*pRATRState,
             (int )RATRState);
    } else {

    }
#line 1204
    *pRATRState = RATRState;
#line 1205
    return (1);
  } else {

  }
#line 1207
  return (0);
}
}
#line 1214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void odm_DynamicTxPower23aInit(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;

  {
#line 1216
  Adapter = pDM_Odm->Adapter;
#line 1217
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1218
  pdmpriv = & pHalData->dmpriv;
#line 1224
  pdmpriv->DynamicTxHighPowerLvl = 0U;
#line 1225
  return;
}
}
#line 1228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
static void FindMinimumRSSI(struct rtw_adapter *pAdapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct dm_odm_t *pDM_Odm ;

  {
#line 1230
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 1231
  pdmpriv = & pHalData->dmpriv;
#line 1232
  pDM_Odm = & pHalData->odmpriv;
#line 1236
  if (! pDM_Odm->bLinked && pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0) {
#line 1237
    pdmpriv->MinUndecoratedPWDBForDM = 0;
  } else {
#line 1239
    pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
  }
#line 1241
  return;
}
}
#line 1243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
static void odm_RSSIMonitorCheck(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  int i ;
  int MaxDB ;
  int MinDB ;
  u8 sta_cnt ;
  u32 tmpdb ;
  u32 PWDB_rssi[32U] ;
  unsigned int tmp ;
  struct sta_info *psta ;
  u8 tmp___0 ;

  {
#line 1245
  Adapter = pDM_Odm->Adapter;
#line 1246
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1247
  pdmpriv = & pHalData->dmpriv;
#line 1249
  MaxDB = 0;
#line 1249
  MinDB = 255;
#line 1250
  sta_cnt = 0U;
#line 1252
  PWDB_rssi[0] = 0U;
#line 1252
  tmp = 1U;
#line 1252
  while (1) {
#line 1252
    if (tmp >= 32U) {
#line 1252
      break;
    } else {

    }
#line 1252
    PWDB_rssi[tmp] = 0U;
#line 1252
    tmp = tmp + 1U;
  }
#line 1255
  if (! pDM_Odm->bLinked) {
#line 1256
    return;
  } else {

  }
#line 1258
  i = 0;
#line 1258
  goto ldv_56017;
  ldv_56016: 
#line 1259
  psta = pDM_Odm->pODM_StaInfo[i];
#line 1260
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1261
    if (psta->rssi_stat.UndecoratedSmoothedPWDB < MinDB) {
#line 1262
      MinDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
    } else {

    }
#line 1264
    if (psta->rssi_stat.UndecoratedSmoothedPWDB > MaxDB) {
#line 1265
      MaxDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
    } else {

    }
#line 1267
    if (psta->rssi_stat.UndecoratedSmoothedPWDB != -1) {
#line 1268
      tmpdb = (u32 )psta->rssi_stat.UndecoratedSmoothedPWDB;
#line 1269
      tmp___0 = sta_cnt;
#line 1269
      sta_cnt = (u8 )((int )sta_cnt + 1);
#line 1269
      PWDB_rssi[(int )tmp___0] = psta->mac_id | (tmpdb << 16);
    } else {

    }
  } else {

  }
#line 1258
  i = i + 1;
  ldv_56017: ;
#line 1258
  if (i <= 31) {
#line 1260
    goto ldv_56016;
  } else {

  }
#line 1275
  i = 0;
#line 1275
  goto ldv_56020;
  ldv_56019: ;
#line 1276
  if (PWDB_rssi[i] != 0U) {
#line 1277
    rtl8723a_set_rssi_cmd(Adapter, (u8 *)(& PWDB_rssi) + (unsigned long )i);
  } else {

  }
#line 1275
  i = i + 1;
  ldv_56020: ;
#line 1275
  if ((int )sta_cnt > i) {
#line 1277
    goto ldv_56019;
  } else {

  }
#line 1280
  pdmpriv->EntryMaxUndecoratedSmoothedPWDB = MaxDB;
#line 1282
  if (MinDB != 255) {
#line 1283
    pdmpriv->EntryMinUndecoratedSmoothedPWDB = MinDB;
  } else {
#line 1285
    pdmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
  }
#line 1287
  FindMinimumRSSI(Adapter);
#line 1289
  ODM_CmnInfoUpdate23a(& pHalData->odmpriv, 17U, (u64 )pdmpriv->MinUndecoratedPWDBForDM);
#line 1291
  return;
}
}
#line 1298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
static void odm_TXPowerTrackingInit(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;

  {
#line 1300
  Adapter = pDM_Odm->Adapter;
#line 1301
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1302
  pdmpriv = & pHalData->dmpriv;
#line 1304
  pdmpriv->bTXPowerTracking = 1U;
#line 1305
  pdmpriv->TXPowercount = 0U;
#line 1306
  pdmpriv->bTXPowerTrackingInit = 0U;
#line 1307
  pdmpriv->TxPowerTrackControl = 1U;
#line 1308
  if (GlobalDebugLevel23A > 3U) {
#line 1308
    printk("\016RTL8723AU: pdmpriv->TxPowerTrackControl = %d\n", (int )pdmpriv->TxPowerTrackControl);
  } else {

  }
#line 1311
  pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = 1U;
#line 1312
  return;
}
}
#line 1315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
static void ODM_EdcaTurboInit23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
#line 1317
  Adapter = pDM_Odm->Adapter;
#line 1319
  pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = 0;
#line 1320
  Adapter->recvpriv.bIsAnyNonBEPkts = 0U;
#line 1322
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1322
    printk("[ODM-8723A] ");
#line 1322
    tmp = rtl8723au_read32(Adapter, 1280);
#line 1322
    printk("%s(): Orginial VO PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp);
  } else {

  }
#line 1325
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1325
    printk("[ODM-8723A] ");
#line 1325
    tmp___0 = rtl8723au_read32(Adapter, 1284);
#line 1325
    printk("%s(): Orginial VI PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp___0);
  } else {

  }
#line 1328
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1328
    printk("[ODM-8723A] ");
#line 1328
    tmp___1 = rtl8723au_read32(Adapter, 1288);
#line 1328
    printk("%s(): Orginial BE PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp___1);
  } else {

  }
#line 1331
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1331
    printk("[ODM-8723A] ");
#line 1331
    tmp___2 = rtl8723au_read32(Adapter, 1292);
#line 1331
    printk("%s(): Orginial BK PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp___2);
  } else {

  }
#line 1333
  return;
}
}
#line 1336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
static void odm_EdcaTurboCheck23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  struct hal_data_8723a *pHalData ;
  struct xmit_priv *pxmitpriv ;
  struct recv_priv *precvpriv ;
  struct registry_priv *pregpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u32 trafficIndex ;
  u32 edca_param ;
  u64 cur_tx_bytes ;
  u64 cur_rx_bytes ;
  bool tmp ;

  {
#line 1338
  Adapter = pDM_Odm->Adapter;
#line 1339
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1340
  pxmitpriv = & Adapter->xmitpriv;
#line 1341
  precvpriv = & Adapter->recvpriv;
#line 1342
  pregpriv = & Adapter->registrypriv;
#line 1343
  pmlmeext = & Adapter->mlmeextpriv;
#line 1344
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1360
  if ((unsigned int )pregpriv->wifi_spec == 1U) {
#line 1361
    goto dm_CheckEdcaTurbo_EXIT;
  } else {

  }
#line 1363
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor > 16U) {
#line 1364
    goto dm_CheckEdcaTurbo_EXIT;
  } else {

  }
#line 1366
  tmp = rtl8723a_BT_disable_EDCA_turbo(Adapter);
#line 1366
  if ((int )tmp) {
#line 1367
    goto dm_CheckEdcaTurbo_EXIT;
  } else {

  }
#line 1370
  if (precvpriv->bIsAnyNonBEPkts == 0U) {
#line 1371
    cur_tx_bytes = pxmitpriv->tx_bytes - pxmitpriv->last_tx_bytes;
#line 1372
    cur_rx_bytes = precvpriv->rx_bytes - precvpriv->last_rx_bytes;
#line 1375
    if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 4U || (unsigned int )pmlmeinfo->assoc_AP_vendor == 5U) {
#line 1377
      if (cur_rx_bytes << 2 < cur_tx_bytes) {
#line 1379
        trafficIndex = 0U;
      } else {
#line 1381
        trafficIndex = 1U;
      }
    } else
#line 1384
    if (cur_tx_bytes << 2 < cur_rx_bytes) {
#line 1386
      trafficIndex = 1U;
    } else {
#line 1388
      trafficIndex = 0U;
    }
#line 1392
    if (pDM_Odm->DM_EDCA_Table.prv_traffic_idx != trafficIndex || ! pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA) {
#line 1394
      if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 6U && ((int )pmlmeext->cur_wireless_mode & 8) != 0) {
#line 1396
        edca_param = EDCAParam[(int )pmlmeinfo->assoc_AP_vendor][trafficIndex];
      } else {
#line 1398
        edca_param = EDCAParam[0][trafficIndex];
      }
#line 1399
      rtl8723au_write32(Adapter, 1288, edca_param);
#line 1402
      pDM_Odm->DM_EDCA_Table.prv_traffic_idx = trafficIndex;
    } else {

    }
#line 1405
    pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = 1;
  } else
#line 1409
  if ((int )pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA) {
#line 1410
    rtl8723au_write32(Adapter, 1288, pHalData->AcParam_BE);
#line 1412
    pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = 0;
  } else {

  }
  dm_CheckEdcaTurbo_EXIT: 
#line 1418
  precvpriv->bIsAnyNonBEPkts = 0U;
#line 1419
  pxmitpriv->last_tx_bytes = pxmitpriv->tx_bytes;
#line 1420
  precvpriv->last_rx_bytes = precvpriv->rx_bytes;
#line 1421
  return;
}
}
#line 1423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
u32 GetPSDData(struct dm_odm_t *pDM_Odm , unsigned int point , u8 initial_gain_psd ) 
{ 
  struct rtw_adapter *adapter ;
  u32 psd_report ;
  u32 val32 ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 1426
  adapter = pDM_Odm->Adapter;
#line 1430
  val32 = rtl8723au_read32(adapter, 2056);
#line 1431
  val32 = val32 & 4294966272U;
#line 1432
  val32 = (point & 1023U) | val32;
#line 1433
  rtl8723au_write32(adapter, 2056, val32);
#line 1436
  val32 = rtl8723au_read32(adapter, 2056);
#line 1437
  val32 = val32 | 4194304U;
#line 1438
  rtl8723au_write32(adapter, 2056, val32);
#line 1440
  __const_udelay(128850UL);
#line 1441
  val32 = rtl8723au_read32(adapter, 2056);
#line 1442
  val32 = val32 & 4290772991U;
#line 1443
  rtl8723au_write32(adapter, 2056, val32);
#line 1445
  tmp = rtl8723au_read32(adapter, 2228);
#line 1445
  psd_report = tmp & 65535U;
#line 1447
  tmp___0 = ConvertTo_dB23a(psd_report);
#line 1447
  psd_report = (tmp___0 + (u32 )initial_gain_psd) + 4294967268U;
#line 1450
  return (psd_report);
}
}
#line 1453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
u32 ConvertTo_dB23a(u32 Value ) 
{ 
  u8 i ;
  u8 j ;
  u32 dB ;

  {
#line 1459
  Value = Value & 65535U;
#line 1461
  i = 0U;
#line 1461
  goto ldv_56064;
  ldv_56063: ;
#line 1462
  if ((u32 )dB_Invert_Table[(int )i][11] >= Value) {
#line 1463
    goto ldv_56062;
  } else {

  }
#line 1461
  i = (u8 )((int )i + 1);
  ldv_56064: ;
#line 1461
  if ((unsigned int )i <= 7U) {
#line 1463
    goto ldv_56063;
  } else {

  }
  ldv_56062: ;
#line 1466
  if ((unsigned int )i > 7U) {
#line 1467
    return (96U);
  } else {

  }
#line 1469
  j = 0U;
#line 1469
  goto ldv_56067;
  ldv_56066: ;
#line 1470
  if ((u32 )dB_Invert_Table[(int )i][(int )j] >= Value) {
#line 1471
    goto ldv_56065;
  } else {

  }
#line 1469
  j = (u8 )((int )j + 1);
  ldv_56067: ;
#line 1469
  if ((unsigned int )j <= 11U) {
#line 1471
    goto ldv_56066;
  } else {

  }
  ldv_56065: 
#line 1474
  dB = (u32 )(((int )i * 12 + (int )j) + 1);
#line 1476
  return (dB);
}
}
#line 1486 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
void ODM_SingleDualAntennaDefaultSetting(struct dm_odm_t *pDM_Odm ) 
{ 
  struct sw_ant_sw *pDM_SWAT_Table ;

  {
#line 1488
  pDM_SWAT_Table = & pDM_Odm->DM_SWAT_Table;
#line 1490
  pDM_SWAT_Table->ANTA_ON = 1;
#line 1491
  pDM_SWAT_Table->ANTB_ON = 1;
#line 1492
  return;
}
}
#line 1496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
static void odm_PHY_SaveAFERegisters(struct dm_odm_t *pDM_Odm , u32 *AFEReg , u32 *AFEBackup ,
                                     u32 RegisterNum ) 
{ 
  u32 i ;

  {
#line 1501
  i = 0U;
#line 1501
  goto ldv_56080;
  ldv_56079: 
#line 1502
  *(AFEBackup + (unsigned long )i) = rtl8723au_read32(pDM_Odm->Adapter, (int )((u16 )*(AFEReg + (unsigned long )i)));
#line 1501
  i = i + 1U;
  ldv_56080: ;
#line 1501
  if (i < RegisterNum) {
#line 1503
    goto ldv_56079;
  } else {

  }

#line 1508
  return;
}
}
#line 1505 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
static void odm_PHY_ReloadAFERegisters(struct dm_odm_t *pDM_Odm , u32 *AFEReg , u32 *AFEBackup ,
                                       u32 RegiesterNum ) 
{ 
  u32 i ;

  {
#line 1510
  i = 0U;
#line 1510
  goto ldv_56090;
  ldv_56089: 
#line 1511
  rtl8723au_write32(pDM_Odm->Adapter, (int )((u16 )*(AFEReg + (unsigned long )i)),
                    *(AFEBackup + (unsigned long )i));
#line 1510
  i = i + 1U;
  ldv_56090: ;
#line 1510
  if (i < RegiesterNum) {
#line 1512
    goto ldv_56089;
  } else {

  }

#line 1517
  return;
}
}
#line 1518 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c"
bool ODM_SingleDualAntennaDetection(struct dm_odm_t *pDM_Odm , u8 mode ) 
{ 
  struct sw_ant_sw *pDM_SWAT_Table ;
  struct rtw_adapter *adapter ;
  u32 CurrentChannel ;
  u32 RfLoopReg ;
  u8 n ;
  u32 Reg88c ;
  u32 Regc08 ;
  u32 Reg874 ;
  u32 Regc50 ;
  u32 val32 ;
  u8 initial_gain ;
  u32 PSD_report_tmp ;
  u32 AntA_report ;
  u32 AntB_report ;
  u32 AntO_report ;
  bool bResult ;
  u32 AFE_Backup[16U] ;
  u32 AFE_REG_8723A[16U] ;

  {
#line 1520
  pDM_SWAT_Table = & pDM_Odm->DM_SWAT_Table;
#line 1521
  adapter = pDM_Odm->Adapter;
#line 1525
  initial_gain = 90U;
#line 1527
  AntA_report = 0U;
#line 1527
  AntB_report = 0U;
#line 1527
  AntO_report = 0U;
#line 1528
  bResult = 1;
#line 1530
  AFE_REG_8723A[0] = 3696U;
#line 1530
  AFE_REG_8723A[1] = 3700U;
#line 1530
  AFE_REG_8723A[2] = 3704U;
#line 1530
  AFE_REG_8723A[3] = 3708U;
#line 1530
  AFE_REG_8723A[4] = 3712U;
#line 1530
  AFE_REG_8723A[5] = 3716U;
#line 1530
  AFE_REG_8723A[6] = 3720U;
#line 1530
  AFE_REG_8723A[7] = 3724U;
#line 1530
  AFE_REG_8723A[8] = 3792U;
#line 1530
  AFE_REG_8723A[9] = 3796U;
#line 1530
  AFE_REG_8723A[10] = 3800U;
#line 1530
  AFE_REG_8723A[11] = 3804U;
#line 1530
  AFE_REG_8723A[12] = 3808U;
#line 1530
  AFE_REG_8723A[13] = 3820U;
#line 1530
  AFE_REG_8723A[14] = 2140U;
#line 1530
  AFE_REG_8723A[15] = 3692U;
#line 1540
  if ((pDM_Odm->SupportICType & 8U) == 0U) {
#line 1541
    return (bResult);
  } else {

  }
#line 1543
  if ((pDM_Odm->SupportAbility & 64U) == 0U) {
#line 1544
    return (bResult);
  } else {

  }
#line 1547
  CurrentChannel = ODM_GetRFReg(pDM_Odm, 0, 24U, 1048575U);
#line 1549
  RfLoopReg = ODM_GetRFReg(pDM_Odm, 0, 0U, 1048575U);
#line 1551
  val32 = rtl8723au_read32(adapter, 2144);
#line 1552
  val32 = val32 & 4294966527U;
#line 1553
  val32 = val32 | 256U;
#line 1554
  rtl8723au_write32(adapter, 2144, val32);
#line 1558
  __const_udelay(42950UL);
#line 1561
  Reg88c = rtl8723au_read32(adapter, 2188);
#line 1562
  Regc08 = rtl8723au_read32(adapter, 3080);
#line 1563
  Reg874 = rtl8723au_read32(adapter, 2164);
#line 1564
  Regc50 = rtl8723au_read32(adapter, 3152);
#line 1567
  odm_PHY_SaveAFERegisters(pDM_Odm, (u32 *)(& AFE_REG_8723A), (u32 *)(& AFE_Backup),
                           16U);
#line 1570
  val32 = rtl8723au_read32(adapter, 2056);
#line 1571
  val32 = val32 & 4294918143U;
#line 1572
  rtl8723au_write32(adapter, 2056, val32);
#line 1575
  ODM_SetRFReg(pDM_Odm, 0, 24U, 1048575U, 1U);
#line 1578
  rtl8723au_write32(adapter, 3696, 1876632996U);
#line 1579
  rtl8723au_write32(adapter, 3700, 1876632996U);
#line 1580
  rtl8723au_write32(adapter, 3704, 1876632996U);
#line 1581
  rtl8723au_write32(adapter, 3708, 1876632996U);
#line 1582
  rtl8723au_write32(adapter, 3712, 1876632996U);
#line 1583
  rtl8723au_write32(adapter, 3716, 1876632996U);
#line 1584
  rtl8723au_write32(adapter, 3720, 1876632996U);
#line 1585
  rtl8723au_write32(adapter, 3724, 1876632996U);
#line 1586
  rtl8723au_write32(adapter, 3792, 1876632996U);
#line 1587
  rtl8723au_write32(adapter, 3796, 1876632996U);
#line 1588
  rtl8723au_write32(adapter, 3800, 1876632996U);
#line 1589
  rtl8723au_write32(adapter, 3804, 1876632996U);
#line 1590
  rtl8723au_write32(adapter, 3808, 1876632996U);
#line 1591
  rtl8723au_write32(adapter, 3820, 1876632996U);
#line 1592
  rtl8723au_write32(adapter, 2140, 1876632996U);
#line 1593
  rtl8723au_write32(adapter, 3692, 1876632996U);
#line 1596
  rtl8723au_write32(adapter, 2188, 3438280896U);
#line 1599
  rtl8723au_write32(adapter, 3080, 524516U);
#line 1600
  rtl8723au_write32(adapter, 2164, 572555264U);
#line 1603
  rtl8723au_write32(adapter, 3632, 268471324U);
#line 1604
  rtl8723au_write32(adapter, 3648, 16808960U);
#line 1607
  rtl8723au_write32(adapter, 2920, 524288U);
#line 1608
  rtl8723au_write32(adapter, 2920, 257949696U);
#line 1609
  rtl8723au_write32(adapter, 3652, 16795648U);
#line 1610
  rtl8723au_write32(adapter, 3636, 268471327U);
#line 1611
  rtl8723au_write32(adapter, 3640, 2182414344U);
#line 1612
  rtl8723au_write32(adapter, 3644, 672464904U);
#line 1613
  rtl8723au_write32(adapter, 3660, 1059024U);
#line 1616
  ODM_SetRFReg(pDM_Odm, 0, 0U, 1048575U, 327688U);
#line 1619
  rtl8723au_write32(adapter, 3624, 2155872256U);
#line 1620
  rtl8723au_write32(adapter, 3656, 4160749568U);
#line 1621
  __const_udelay(4295000UL);
#line 1622
  PSD_report_tmp = 0U;
#line 1624
  n = 0U;
#line 1624
  goto ldv_56115;
  ldv_56114: 
#line 1625
  PSD_report_tmp = GetPSDData(pDM_Odm, 14U, (int )initial_gain);
#line 1626
  if (PSD_report_tmp > AntA_report) {
#line 1627
    AntA_report = PSD_report_tmp;
  } else {

  }
#line 1624
  n = (u8 )((int )n + 1);
  ldv_56115: ;
#line 1624
  if ((unsigned int )n <= 1U) {
#line 1626
    goto ldv_56114;
  } else {

  }
#line 1630
  PSD_report_tmp = 0U;
#line 1632
  val32 = rtl8723au_read32(adapter, 2144);
#line 1633
  val32 = val32 & 4294966527U;
#line 1634
  val32 = val32 | 512U;
#line 1635
  rtl8723au_write32(adapter, 2144, val32);
#line 1636
  __const_udelay(42950UL);
#line 1638
  n = 0U;
#line 1638
  goto ldv_56118;
  ldv_56117: 
#line 1639
  PSD_report_tmp = GetPSDData(pDM_Odm, 14U, (int )initial_gain);
#line 1640
  if (PSD_report_tmp > AntB_report) {
#line 1641
    AntB_report = PSD_report_tmp;
  } else {

  }
#line 1638
  n = (u8 )((int )n + 1);
  ldv_56118: ;
#line 1638
  if ((unsigned int )n <= 1U) {
#line 1640
    goto ldv_56117;
  } else {

  }
#line 1646
  val32 = rtl8723au_read32(adapter, 2144);
#line 1647
  val32 = val32 & 4294966527U;
#line 1648
  rtl8723au_write32(adapter, 2144, val32);
#line 1649
  __const_udelay(42950UL);
#line 1651
  n = 0U;
#line 1651
  goto ldv_56121;
  ldv_56120: 
#line 1652
  PSD_report_tmp = GetPSDData(pDM_Odm, 14U, (int )initial_gain);
#line 1653
  if (PSD_report_tmp > AntO_report) {
#line 1654
    AntO_report = PSD_report_tmp;
  } else {

  }
#line 1651
  n = (u8 )((int )n + 1);
  ldv_56121: ;
#line 1651
  if ((unsigned int )n <= 1U) {
#line 1653
    goto ldv_56120;
  } else {

  }
#line 1658
  rtl8723au_write32(adapter, 3624, 0U);
#line 1659
  PSD_report_tmp = 0U;
#line 1662
  val32 = rtl8723au_read32(adapter, 2144);
#line 1663
  val32 = val32 & 4294966527U;
#line 1664
  val32 = val32 | 256U;
#line 1665
  rtl8723au_write32(adapter, 2144, val32);
#line 1666
  rtl8723au_write32(adapter, 2188, Reg88c);
#line 1667
  rtl8723au_write32(adapter, 3080, Regc08);
#line 1668
  rtl8723au_write32(adapter, 2164, Reg874);
#line 1669
  val32 = rtl8723au_read32(adapter, 3152);
#line 1670
  val32 = val32 & 4294967168U;
#line 1671
  val32 = val32 | 64U;
#line 1672
  rtl8723au_write32(adapter, 3152, val32);
#line 1674
  rtl8723au_write32(adapter, 3152, Regc50);
#line 1675
  ODM_SetRFReg(pDM_Odm, 0, 24U, 1048575U, CurrentChannel);
#line 1677
  ODM_SetRFReg(pDM_Odm, 0, 0U, 1048575U, RfLoopReg);
#line 1680
  odm_PHY_ReloadAFERegisters(pDM_Odm, (u32 *)(& AFE_REG_8723A), (u32 *)(& AFE_Backup),
                             16U);
#line 1682
  if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1682
    printk("[ODM-8723A] ");
#line 1682
    printk("%s(): psd_report_A[%d]= %d \n", "ODM_SingleDualAntennaDetection", 2416,
           AntA_report);
  } else {

  }
#line 1684
  if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1684
    printk("[ODM-8723A] ");
#line 1684
    printk("%s(): psd_report_B[%d]= %d \n", "ODM_SingleDualAntennaDetection", 2416,
           AntB_report);
  } else {

  }
#line 1686
  if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1686
    printk("[ODM-8723A] ");
#line 1686
    printk("%s(): psd_report_O[%d]= %d \n", "ODM_SingleDualAntennaDetection", 2416,
           AntO_report);
  } else {

  }
#line 1690
  if ((unsigned int )mode == 2U) {
#line 1691
    if (AntA_report > 99U) {
#line 1692
      if (AntA_report + 1U < AntB_report) {
#line 1693
        pDM_SWAT_Table->ANTB_ON = 0;
#line 1694
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1694
          printk("[ODM-8723A] ");
#line 1694
          printk("%s(): ODM_SingleDualAntennaDetection(): Single Antenna A\n", "ODM_SingleDualAntennaDetection");
        } else {

        }
      } else {
#line 1696
        pDM_SWAT_Table->ANTB_ON = 1;
#line 1697
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1697
          printk("[ODM-8723A] ");
#line 1697
          printk("%s(): ODM_SingleDualAntennaDetection(): Dual Antenna is A and B\n",
                 "ODM_SingleDualAntennaDetection");
        } else {

        }
      }
    } else {
#line 1700
      if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1700
        printk("[ODM-8723A] ");
#line 1700
        printk("%s(): ODM_SingleDualAntennaDetection(): Need to check again\n", "ODM_SingleDualAntennaDetection");
      } else {

      }
#line 1701
      pDM_SWAT_Table->ANTB_ON = 0;
#line 1702
      bResult = 0;
    }
  } else
#line 1704
  if ((unsigned int )mode == 0U) {
#line 1706
    if (AntO_report > 99U && AntO_report <= 117U) {
#line 1707
      if (AntO_report + 1U < AntA_report) {
#line 1708
        pDM_SWAT_Table->ANTA_ON = 0;
#line 1709
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1709
          printk("[ODM-8723A] ");
#line 1709
          printk("%s(): Ant A is OFF", "ODM_SingleDualAntennaDetection");
        } else {

        }
      } else {
#line 1712
        pDM_SWAT_Table->ANTA_ON = 1;
#line 1713
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1713
          printk("[ODM-8723A] ");
#line 1713
          printk("%s(): Ant A is ON", "ODM_SingleDualAntennaDetection");
        } else {

        }
      }
#line 1717
      if (AntO_report + 2U < AntB_report) {
#line 1718
        pDM_SWAT_Table->ANTB_ON = 0;
#line 1719
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1719
          printk("[ODM-8723A] ");
#line 1719
          printk("%s(): Ant B is OFF", "ODM_SingleDualAntennaDetection");
        } else {

        }
      } else {
#line 1722
        pDM_SWAT_Table->ANTB_ON = 1;
#line 1723
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1723
          printk("[ODM-8723A] ");
#line 1723
          printk("%s(): Ant B is ON", "ODM_SingleDualAntennaDetection");
        } else {

        }
      }
    } else {

    }
  } else {
#line 1728
    if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1728
      printk("[ODM-8723A] ");
#line 1728
      printk("%s(): ODM_SingleDualAntennaDetection(): Need to check again\n", "ODM_SingleDualAntennaDetection");
    } else {

    }
#line 1731
    pDM_SWAT_Table->ANTA_ON = 1;
#line 1733
    pDM_SWAT_Table->ANTB_ON = 0;
#line 1734
    bResult = 0;
  }
#line 1737
  return (bResult);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
bool ldv_queue_work_on_453(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
bool ldv_queue_delayed_work_on_454(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
bool ldv_queue_work_on_455(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ldv_flush_workqueue_456(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
bool ldv_queue_delayed_work_on_457(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_467(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_469(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_468(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_471(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_470(struct workqueue_struct *ldv_func_arg1 ) ;
#line 47 "include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_le64(u64 val , void *p ) 
{ 


  {
#line 49
  *((__le64 *)p) = val;
#line 50
  return;
}
}
#line 215 "drivers/staging/rtl8723au/include/rtl8723a_xmit.h"
void rtl8723a_fill_fake_txdesc(struct rtw_adapter *padapter , u8 *pDesc , u32 BufferLen ,
                               u8 IsPsPoll , u8 IsBTQosNull ) ;
#line 148 "drivers/staging/rtl8723au/include/rtl8723a_cmd.h"
void rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd(struct rtw_adapter *padapter ) ;
#line 153
int rtl8723a_set_raid_cmd(struct rtw_adapter *padapter , u32 mask , u8 arg ) ;
#line 154
void rtl8723a_add_rateatid(struct rtw_adapter *pAdapter , u32 bitmap , u8 arg , u8 rssi_level ) ;
#line 156
int FillH2CCmd(struct rtw_adapter *padapter , u8 ElementID , u32 CmdLen , u8 *pCmdBuffer ) ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.c"
static u8 _is_fw_read_cmd_down(struct rtw_adapter *padapter , u8 msgbox_num ) 
{ 
  u8 read_down ;
  int retry_cnts ;
  u8 valid ;
  u8 tmp ;
  int tmp___0 ;

  {
#line 31
  read_down = 0U;
#line 32
  retry_cnts = 100;
  ldv_55774: 
#line 36
  tmp = rtl8723au_read8(padapter, 460);
#line 36
  valid = (int )tmp & (int )((u8 )(1UL << (int )msgbox_num));
#line 37
  if ((unsigned int )valid == 0U) {
#line 38
    read_down = 1U;
  } else {

  }
#line 39
  if ((unsigned int )read_down == 0U) {
#line 39
    tmp___0 = retry_cnts;
#line 39
    retry_cnts = retry_cnts - 1;
#line 39
    if (tmp___0 != 0) {
#line 41
      goto ldv_55774;
    } else {
#line 44
      goto ldv_55775;
    }
  } else {

  }
  ldv_55775: ;
#line 41
  return (read_down);
}
}
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.c"
int FillH2CCmd(struct rtw_adapter *padapter , u8 ElementID , u32 CmdLen , u8 *pCmdBuffer ) 
{ 
  u8 bcmd_down ;
  s32 retry_cnts ;
  u8 h2c_box_num ;
  u32 msgbox_addr ;
  u32 msgbox_ex_addr ;
  struct hal_data_8723a *pHalData ;
  u32 h2c_cmd ;
  u16 h2c_cmd_ex ;
  int ret ;
  u8 tmp ;
  s32 tmp___0 ;

  {
#line 53
  bcmd_down = 0U;
#line 54
  retry_cnts = 100;
#line 59
  h2c_cmd = 0U;
#line 60
  h2c_cmd_ex = 0U;
#line 61
  ret = 0;
#line 63
  padapter = (padapter->dvobj)->if1;
#line 64
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 66
  mutex_lock_nested(& (padapter->dvobj)->h2c_fwcmd_mutex, 0U);
#line 68
  if ((unsigned long )pCmdBuffer == (unsigned long )((u8 *)0U)) {
#line 69
    goto exit;
  } else {

  }
#line 70
  if (CmdLen > 5U) {
#line 71
    goto exit;
  } else {

  }
#line 72
  if (padapter->bSurpriseRemoved == 1) {
#line 73
    goto exit;
  } else {

  }
  ldv_55792: 
#line 77
  h2c_box_num = pHalData->LastHMEBoxNum;
#line 79
  tmp = _is_fw_read_cmd_down(padapter, (int )h2c_box_num);
#line 79
  if ((unsigned int )tmp == 0U) {
#line 80
    if (GlobalDebugLevel23A > 3U) {
#line 80
      printk("\016RTL8723AU:  fw read cmd failed...\n");
    } else {

    }
#line 81
    goto exit;
  } else {

  }
#line 84
  if (CmdLen <= 3U) {
#line 85
    memcpy((void *)(& h2c_cmd) + 1U, (void const   *)pCmdBuffer, (size_t )CmdLen);
  } else {
#line 87
    memcpy((void *)(& h2c_cmd_ex), (void const   *)pCmdBuffer, 2UL);
#line 88
    memcpy((void *)(& h2c_cmd) + 1U, (void const   *)pCmdBuffer + 2U, (size_t )(CmdLen - 2U));
#line 89
    *((u8 *)(& h2c_cmd)) = (u8 )((unsigned int )*((u8 *)(& h2c_cmd)) | 128U);
  }
#line 92
  *((u8 *)(& h2c_cmd)) = (u8 )((int )*((u8 *)(& h2c_cmd)) | (int )ElementID);
#line 94
  if (((unsigned long )h2c_cmd & 128UL) != 0UL) {
#line 95
    msgbox_ex_addr = (u32 )(((int )h2c_box_num + 68) * 2);
#line 96
    h2c_cmd_ex = h2c_cmd_ex;
#line 97
    rtl8723au_write16(padapter, (int )((u16 )msgbox_ex_addr), (int )h2c_cmd_ex);
  } else {

  }
#line 99
  msgbox_addr = (u32 )(((int )h2c_box_num + 116) * 4);
#line 100
  h2c_cmd = h2c_cmd;
#line 101
  rtl8723au_write32(padapter, (int )((u16 )msgbox_addr), h2c_cmd);
#line 103
  bcmd_down = 1U;
#line 105
  pHalData->LastHMEBoxNum = (u8 )(((int )h2c_box_num + 1) % 4);
#line 107
  if ((unsigned int )bcmd_down == 0U) {
#line 107
    tmp___0 = retry_cnts;
#line 107
    retry_cnts = retry_cnts - 1;
#line 107
    if (tmp___0 != 0) {
#line 109
      goto ldv_55792;
    } else {
#line 112
      goto ldv_55793;
    }
  } else {

  }
  ldv_55793: 
#line 109
  ret = 1;
  exit: 
#line 112
  mutex_unlock(& (padapter->dvobj)->h2c_fwcmd_mutex);
#line 113
  return (ret);
}
}
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.c"
int rtl8723a_set_rssi_cmd(struct rtw_adapter *padapter , u8 *param ) 
{ 


  {
#line 118
  *((u32 *)param) = *((u32 *)param);
#line 120
  FillH2CCmd(padapter, 5, 3U, param);
#line 122
  return (1);
}
}
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.c"
int rtl8723a_set_raid_cmd(struct rtw_adapter *padapter , u32 mask , u8 arg ) 
{ 
  u8 buf[5U] ;

  {
#line 129
  memset((void *)(& buf), 0, 5UL);
#line 130
  mask = mask;
#line 131
  memcpy((void *)(& buf), (void const   *)(& mask), 4UL);
#line 132
  buf[4] = arg;
#line 134
  FillH2CCmd(padapter, 6, 5U, (u8 *)(& buf));
#line 136
  return (1);
}
}
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.c"
void rtl8723a_add_rateatid(struct rtw_adapter *pAdapter , u32 bitmap , u8 arg , u8 rssi_level ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 macid ;
  u32 raid ;

  {
#line 145
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 146
  macid = (unsigned int )arg & 31U;
#line 147
  raid = bitmap & 4026531840U;
#line 149
  bitmap = bitmap & 268435455U;
#line 150
  if ((unsigned int )rssi_level != 0U) {
#line 151
    bitmap = ODM_Get_Rate_Bitmap23a(pHalData, (u32 )macid, bitmap, (int )rssi_level);
  } else {

  }
#line 154
  bitmap = bitmap | raid;
#line 156
  rtl8723a_set_raid_cmd(pAdapter, bitmap, (int )arg);
#line 157
  return;
}
}
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.c"
void rtl8723a_set_FwPwrMode_cmd(struct rtw_adapter *padapter , u8 Mode ) 
{ 
  struct setpwrmode_parm H2CSetPwrMode ;
  struct pwrctrl_priv *pwrpriv ;
  struct hal_data_8723a *pHalData ;

  {
#line 162
  pwrpriv = & padapter->pwrctrlpriv;
#line 163
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 165
  if (GlobalDebugLevel23A > 3U) {
#line 165
    printk("\016RTL8723AU: %s: Mode =%d SmartPS =%d UAPSD =%d BcnMode = 0x%02x\n",
           "rtl8723a_set_FwPwrMode_cmd", (int )Mode, (int )pwrpriv->smart_ps, (int )padapter->registrypriv.uapsd_enable,
           (int )pwrpriv->bcn_ant_mode);
  } else {

  }
#line 172
  if ((unsigned int )Mode != 0U && (unsigned int )pHalData->rf_type != 2U) {
#line 173
    ODM_RF_Saving23a(& pHalData->odmpriv, 1);
  } else {

  }
#line 175
  H2CSetPwrMode.Mode = Mode;
#line 176
  H2CSetPwrMode.SmartPS = pwrpriv->smart_ps;
#line 177
  H2CSetPwrMode.AwakeInterval = 1U;
#line 178
  H2CSetPwrMode.bAllQueueUAPSD = padapter->registrypriv.uapsd_enable;
#line 179
  H2CSetPwrMode.BcnAntMode = pwrpriv->bcn_ant_mode;
#line 181
  FillH2CCmd(padapter, 1, 5U, (u8 *)(& H2CSetPwrMode));
#line 182
  return;
}
}
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.c"
static void ConstructBeacon(struct rtw_adapter *padapter , u8 *pframe , u32 *pLength ) 
{ 
  struct ieee80211_mgmt *mgmt ;
  u32 rate_len ;
  u32 pktlen ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 bc_addr___0[6U] ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u32 ATIMWindow ;

  {
#line 190
  pmlmeext = & padapter->mlmeextpriv;
#line 191
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 192
  cur_network = & pmlmeinfo->network;
#line 193
  bc_addr___0[0] = 255U;
#line 193
  bc_addr___0[1] = 255U;
#line 193
  bc_addr___0[2] = 255U;
#line 193
  bc_addr___0[3] = 255U;
#line 193
  bc_addr___0[4] = 255U;
#line 193
  bc_addr___0[5] = 255U;
#line 197
  mgmt = (struct ieee80211_mgmt *)pframe;
#line 199
  mgmt->frame_control = 128U;
#line 202
  ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)(& bc_addr___0));
#line 203
  tmp = myid(& padapter->eeprompriv);
#line 203
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp);
#line 204
  tmp___0 = get_my_bssid23a(cur_network);
#line 204
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___0);
#line 207
  mgmt->seq_ctrl = 0U;
#line 211
  put_unaligned_le16((int )cur_network->beacon_interval, (void *)(& mgmt->u.beacon.beacon_int));
#line 214
  put_unaligned_le16((int )cur_network->capability, (void *)(& mgmt->u.beacon.capab_info));
#line 217
  pframe = (u8 *)(& mgmt->u.beacon.variable);
#line 218
  pktlen = 36U;
#line 220
  if ((pmlmeinfo->state & 3U) == 3U) {
#line 222
    pktlen = cur_network->IELength + pktlen;
#line 223
    memcpy((void *)pframe, (void const   *)(& cur_network->IEs), (size_t )pktlen);
#line 225
    goto _ConstructBeacon;
  } else {

  }
#line 231
  pframe = rtw_set_ie23a(pframe, 0, (uint )cur_network->Ssid.ssid_len, (u8 const   *)(& cur_network->Ssid.ssid),
                         & pktlen);
#line 236
  rate_len = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
#line 237
  pframe = rtw_set_ie23a(pframe, 1, 8U < rate_len ? 8U : rate_len, (u8 const   *)(& cur_network->SupportedRates),
                         & pktlen);
#line 241
  pframe = rtw_set_ie23a(pframe, 3, 1U, (u8 const   *)(& cur_network->DSConfig), & pktlen);
#line 244
  if ((pmlmeinfo->state & 3U) == 1U) {
#line 248
    ATIMWindow = 0U;
#line 249
    pframe = rtw_set_ie23a(pframe, 6, 2U, (u8 const   *)(& ATIMWindow), & pktlen);
  } else {

  }
#line 256
  if (rate_len > 8U) {
#line 257
    pframe = rtw_set_ie23a(pframe, 50, rate_len - 8U, (u8 const   *)(& cur_network->SupportedRates) + 8U,
                           & pktlen);
  } else {

  }
  _ConstructBeacon: ;
#line 266
  if (pktlen + 32U > 512U) {
#line 267
    if (GlobalDebugLevel23A > 3U) {
#line 267
      printk("\016RTL8723AU: beacon frame too large\n");
    } else {

    }
#line 268
    return;
  } else {

  }
#line 271
  *pLength = pktlen;
#line 272
  return;
}
}
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.c"
static void ConstructPSPoll(struct rtw_adapter *padapter , u8 *pframe , u32 *pLength ) 
{ 
  struct ieee80211_hdr *pwlanhdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  u8 *tmp___0 ;

  {
#line 281
  pmlmeext = & padapter->mlmeextpriv;
#line 282
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 284
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 287
  pwlanhdr->frame_control = 164U;
#line 289
  pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 4096U);
#line 292
  pwlanhdr->duration_id = (unsigned int )pmlmeinfo->aid | 49152U;
#line 295
  tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 295
  memcpy((void *)(& pwlanhdr->addr1), (void const   *)tmp, 6UL);
#line 298
  tmp___0 = myid(& padapter->eeprompriv);
#line 298
  memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___0, 6UL);
#line 300
  *pLength = 16U;
#line 301
  return;
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.c"
static void ConstructNullFunctionData(struct rtw_adapter *padapter , u8 *pframe ,
                                      u32 *pLength , u8 *StaAddr , u8 bQoS , u8 AC ,
                                      u8 bEosp , u8 bForcePowerSave ) 
{ 
  struct ieee80211_hdr *pwlanhdr ;
  u32 pktlen ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  struct ieee80211_qos_hdr *qoshdr ;

  {
#line 310
  pmlmepriv = & padapter->mlmepriv;
#line 311
  cur_network = & pmlmepriv->cur_network;
#line 312
  pmlmeext = & padapter->mlmeextpriv;
#line 313
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 315
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 317
  pwlanhdr->frame_control = 0U;
#line 318
  pwlanhdr->seq_ctrl = 0U;
#line 320
  if ((unsigned int )bForcePowerSave != 0U) {
#line 321
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 4096U);
  } else {

  }
#line 323
  switch ((unsigned int )cur_network->network.ifmode) {
  case 8U: ;
  case 2U: 
#line 326
  pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
#line 327
  tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 327
  memcpy((void *)(& pwlanhdr->addr1), (void const   *)tmp, 6UL);
#line 329
  tmp___0 = myid(& padapter->eeprompriv);
#line 329
  memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___0, 6UL);
#line 331
  memcpy((void *)(& pwlanhdr->addr3), (void const   *)StaAddr, 6UL);
#line 332
  goto ldv_55861;
  case 9U: ;
  case 3U: 
#line 335
  pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
#line 336
  memcpy((void *)(& pwlanhdr->addr1), (void const   *)StaAddr, 6UL);
#line 337
  tmp___1 = get_my_bssid23a(& pmlmeinfo->network);
#line 337
  memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___1, 6UL);
#line 339
  tmp___2 = myid(& padapter->eeprompriv);
#line 339
  memcpy((void *)(& pwlanhdr->addr3), (void const   *)tmp___2, 6UL);
#line 341
  goto ldv_55861;
  case 1U: ;
  default: 
#line 344
  memcpy((void *)(& pwlanhdr->addr1), (void const   *)StaAddr, 6UL);
#line 345
  tmp___3 = myid(& padapter->eeprompriv);
#line 345
  memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___3, 6UL);
#line 346
  tmp___4 = get_my_bssid23a(& pmlmeinfo->network);
#line 346
  memcpy((void *)(& pwlanhdr->addr3), (void const   *)tmp___4, 6UL);
#line 348
  goto ldv_55861;
  }
  ldv_55861: ;
#line 351
  if ((unsigned int )bQoS == 1U) {
#line 353
    qoshdr = (struct ieee80211_qos_hdr *)pframe;
#line 355
    qoshdr->frame_control = (__le16 )((unsigned int )qoshdr->frame_control | 200U);
#line 359
    qoshdr->qos_ctrl = (unsigned int )((unsigned short )AC) & 15U;
#line 360
    if ((unsigned int )bEosp != 0U) {
#line 361
      qoshdr->qos_ctrl = (__le16 )((unsigned int )qoshdr->qos_ctrl | 16U);
    } else {

    }
#line 363
    pktlen = 26U;
  } else {
#line 365
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 72U);
#line 369
    pktlen = 24U;
  }
#line 372
  *pLength = pktlen;
#line 373
  return;
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.c"
static void ConstructProbeRsp(struct rtw_adapter *padapter , u8 *pframe , u32 *pLength ,
                              u8 *StaAddr , bool bHideSSID ) 
{ 
  struct ieee80211_mgmt *mgmt ;
  u8 *mac ;
  u8 *bssid ;
  u32 pktlen ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;

  {
#line 381
  pmlmeext = & padapter->mlmeextpriv;
#line 382
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 383
  cur_network = & pmlmeinfo->network;
#line 387
  mgmt = (struct ieee80211_mgmt *)pframe;
#line 389
  mac = myid(& padapter->eeprompriv);
#line 390
  bssid = (u8 *)(& cur_network->MacAddress);
#line 392
  mgmt->frame_control = 80U;
#line 395
  mgmt->seq_ctrl = 0U;
#line 397
  memcpy((void *)(& mgmt->da), (void const   *)StaAddr, 6UL);
#line 398
  memcpy((void *)(& mgmt->sa), (void const   *)mac, 6UL);
#line 399
  memcpy((void *)(& mgmt->bssid), (void const   *)bssid, 6UL);
#line 401
  put_unaligned_le64(cur_network->tsf, (void *)(& mgmt->u.probe_resp.timestamp));
#line 403
  put_unaligned_le16((int )cur_network->beacon_interval, (void *)(& mgmt->u.probe_resp.beacon_int));
#line 405
  put_unaligned_le16((int )cur_network->capability, (void *)(& mgmt->u.probe_resp.capab_info));
#line 408
  pktlen = 36U;
#line 410
  if (cur_network->IELength > 768U) {
#line 411
    return;
  } else {

  }
#line 413
  memcpy((void *)(& mgmt->u.probe_resp.variable), (void const   *)(& cur_network->IEs),
           (size_t )cur_network->IELength);
#line 415
  pktlen = cur_network->IELength + pktlen;
#line 417
  *pLength = pktlen;
#line 418
  return;
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.c"
static void SetFwRsvdPagePkt(struct rtw_adapter *padapter , bool bDLFinished ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u32 BeaconLength ;
  u32 ProbeRspLength ;
  u32 PSPollLength ;
  u32 NullDataLength ;
  u32 QosNullLength ;
  u32 BTQosNullLength ;
  u8 *ReservedPagePacket ;
  u8 PageNum ;
  u8 PageNeed ;
  u8 TxDescLen ;
  u16 BufIndex ;
  u32 TotalPacketLen ;
  struct rsvdpage_loc RsvdPageLoc ;
  void *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u32 tmp___4 ;

  {
#line 438
  BeaconLength = 0U;
#line 438
  ProbeRspLength = 0U;
#line 446
  if (GlobalDebugLevel23A > 3U) {
#line 446
    printk("\016RTL8723AU: %s\n", "SetFwRsvdPagePkt");
  } else {

  }
#line 448
  tmp = kzalloc(1000UL, 208U);
#line 448
  ReservedPagePacket = (u8 *)tmp;
#line 449
  if ((unsigned long )ReservedPagePacket == (unsigned long )((u8 *)0U)) {
#line 450
    if (GlobalDebugLevel23A > 3U) {
#line 450
      printk("\016RTL8723AU: %s: alloc ReservedPagePacket fail!\n", "SetFwRsvdPagePkt");
    } else {

    }
#line 451
    return;
  } else {

  }
#line 454
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 455
  pxmitpriv = & padapter->xmitpriv;
#line 456
  pmlmeext = & padapter->mlmeextpriv;
#line 457
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 459
  TxDescLen = 32U;
#line 460
  PageNum = 0U;
#line 463
  BufIndex = 40U;
#line 464
  ConstructBeacon(padapter, ReservedPagePacket + (unsigned long )BufIndex, & BeaconLength);
#line 468
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + BeaconLength) >> 7)) + ((((u32 )TxDescLen + BeaconLength) & 127U) != 0U ? 1U : 0U);
#line 470
  if ((unsigned int )PageNeed == 1U) {
#line 471
    PageNeed = (unsigned int )PageNeed + 1U;
  } else {

  }
#line 472
  PageNum = (int )PageNum + (int )PageNeed;
#line 473
  pHalData->FwRsvdPageStartOffset = PageNum;
#line 475
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
#line 478
  RsvdPageLoc.LocPsPoll = PageNum;
#line 479
  ConstructPSPoll(padapter, ReservedPagePacket + (unsigned long )BufIndex, & PSPollLength);
#line 480
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            PSPollLength, 1, 0);
#line 482
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + PSPollLength) >> 7)) + ((((u32 )TxDescLen + PSPollLength) & 127U) != 0U ? 1U : 0U);
#line 483
  PageNum = (int )PageNum + (int )PageNeed;
#line 485
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
#line 488
  RsvdPageLoc.LocNullData = PageNum;
#line 489
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 489
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & NullDataLength, tmp___0, 0, 0, 0, 0);
#line 493
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            NullDataLength, 0, 0);
#line 497
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + NullDataLength) >> 7)) + ((((u32 )TxDescLen + NullDataLength) & 127U) != 0U ? 1U : 0U);
#line 498
  PageNum = (int )PageNum + (int )PageNeed;
#line 500
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
#line 503
  RsvdPageLoc.LocProbeRsp = PageNum;
#line 504
  tmp___1 = get_my_bssid23a(& pmlmeinfo->network);
#line 504
  ConstructProbeRsp(padapter, ReservedPagePacket + (unsigned long )BufIndex, & ProbeRspLength,
                    tmp___1, 0);
#line 510
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            ProbeRspLength, 0, 0);
#line 512
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + ProbeRspLength) >> 7)) + ((((u32 )TxDescLen + ProbeRspLength) & 127U) != 0U ? 1U : 0U);
#line 513
  PageNum = (int )PageNum + (int )PageNeed;
#line 515
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
#line 518
  RsvdPageLoc.LocQosNull = PageNum;
#line 519
  tmp___2 = get_my_bssid23a(& pmlmeinfo->network);
#line 519
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & QosNullLength, tmp___2, 1, 0, 0, 0);
#line 525
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            QosNullLength, 0, 0);
#line 527
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + QosNullLength) >> 7)) + ((((u32 )TxDescLen + QosNullLength) & 127U) != 0U ? 1U : 0U);
#line 528
  PageNum = (int )PageNum + (int )PageNeed;
#line 530
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
#line 533
  RsvdPageLoc.LocBTQosNull = PageNum;
#line 534
  tmp___3 = get_my_bssid23a(& pmlmeinfo->network);
#line 534
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & BTQosNullLength, tmp___3, 1, 0, 0, 0);
#line 540
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            BTQosNullLength, 0, 1);
#line 542
  TotalPacketLen = (u32 )BufIndex + BTQosNullLength;
#line 544
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 545
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 546
    goto exit;
  } else {

  }
#line 549
  pattrib = & pmgntframe->attrib;
#line 550
  update_mgntframe_attrib23a(padapter, pattrib);
#line 551
  pattrib->qsel = 16U;
#line 552
  tmp___4 = TotalPacketLen - 40U;
#line 552
  pattrib->last_txcmdsz = tmp___4;
#line 552
  pattrib->pktlen = tmp___4;
#line 553
  memcpy((void *)pmgntframe->buf_addr, (void const   *)ReservedPagePacket, (size_t )TotalPacketLen);
#line 555
  rtl8723au_mgnt_xmit(padapter, pmgntframe);
#line 557
  if (GlobalDebugLevel23A > 3U) {
#line 557
    printk("\016RTL8723AU: %s: Set RSVD page location to Fw\n", "SetFwRsvdPagePkt");
  } else {

  }
#line 558
  FillH2CCmd(padapter, 3, 5U, (u8 *)(& RsvdPageLoc));
  exit: 
#line 561
  kfree((void const   *)ReservedPagePacket);
#line 562
  return;
}
}
#line 564 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.c"
void rtl8723a_set_FwJoinBssReport_cmd(struct rtw_adapter *padapter , u8 mstatus ) 
{ 
  struct joinbssrpt_parm JoinBssRptParm ;
  struct hal_data_8723a *pHalData ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool bRecover ;
  u8 v8 ;

  {
#line 567
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 568
  pmlmeext = & padapter->mlmeextpriv;
#line 569
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 571
  if (GlobalDebugLevel23A > 3U) {
#line 571
    printk("\016RTL8723AU: %s mstatus(%x)\n", "rtl8723a_set_FwJoinBssReport_cmd",
           (int )mstatus);
  } else {

  }
#line 573
  if ((unsigned int )mstatus == 1U) {
#line 574
    bRecover = 0;
#line 579
    rtl8723au_write16(padapter, 1704, (int )((unsigned int )pmlmeinfo->aid | 49152U));
#line 588
    v8 = rtl8723au_read8(padapter, 257);
#line 589
    v8 = (u8 )((unsigned int )v8 | 1U);
#line 590
    rtl8723au_write8(padapter, 257, (int )v8);
#line 597
    SetBcnCtrlReg23a(padapter, 16, 8);
#line 600
    if (((unsigned long )pHalData->RegFwHwTxQCtrl & 64UL) != 0UL) {
#line 601
      bRecover = 1;
    } else {

    }
#line 605
    rtl8723au_write8(padapter, 1058, (int )pHalData->RegFwHwTxQCtrl & 191);
#line 607
    pHalData->RegFwHwTxQCtrl = (unsigned int )pHalData->RegFwHwTxQCtrl & 191U;
#line 608
    SetFwRsvdPagePkt(padapter, 0);
#line 611
    SetBcnCtrlReg23a(padapter, 8, 16);
#line 618
    if ((int )bRecover) {
#line 619
      rtl8723au_write8(padapter, 1058, (int )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U));
#line 621
      pHalData->RegFwHwTxQCtrl = (u8 )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U);
    } else {

    }
#line 625
    v8 = rtl8723au_read8(padapter, 257);
#line 626
    v8 = (unsigned int )v8 & 254U;
#line 627
    rtl8723au_write8(padapter, 257, (int )v8);
  } else {

  }
#line 630
  JoinBssRptParm.OpMode = mstatus;
#line 632
  FillH2CCmd(padapter, 2, 1U, (u8 *)(& JoinBssRptParm));
#line 633
  return;
}
}
#line 637 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.c"
static void SetFwRsvdPagePkt_BTCoex(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 fakemac[6U] ;
  u32 NullDataLength ;
  u32 BTQosNullLength ;
  u8 *ReservedPagePacket ;
  u8 PageNum ;
  u8 PageNeed ;
  u8 TxDescLen ;
  u16 BufIndex ;
  u32 TotalPacketLen ;
  struct rsvdpage_loc RsvdPageLoc ;
  void *tmp ;
  u32 tmp___0 ;

  {
#line 645
  fakemac[0] = 0U;
#line 645
  fakemac[1] = 224U;
#line 645
  fakemac[2] = 76U;
#line 645
  fakemac[3] = 0U;
#line 645
  fakemac[4] = 0U;
#line 645
  fakemac[5] = 0U;
#line 653
  if (GlobalDebugLevel23A > 3U) {
#line 653
    printk("\016RTL8723AU: +%s\n", "SetFwRsvdPagePkt_BTCoex");
  } else {

  }
#line 655
  tmp = kzalloc(1024UL, 208U);
#line 655
  ReservedPagePacket = (u8 *)tmp;
#line 656
  if ((unsigned long )ReservedPagePacket == (unsigned long )((u8 *)0U)) {
#line 657
    if (GlobalDebugLevel23A > 3U) {
#line 657
      printk("\016RTL8723AU: %s: alloc ReservedPagePacket fail!\n", "SetFwRsvdPagePkt_BTCoex");
    } else {

    }
#line 658
    return;
  } else {

  }
#line 661
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 662
  pxmitpriv = & padapter->xmitpriv;
#line 663
  pmlmeext = & padapter->mlmeextpriv;
#line 664
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 666
  TxDescLen = 32U;
#line 667
  PageNum = 0U;
#line 670
  BufIndex = 40U;
#line 672
  PageNeed = 3U;
#line 674
  PageNum = (int )PageNum + (int )PageNeed;
#line 675
  pHalData->FwRsvdPageStartOffset = PageNum;
#line 677
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
#line 680
  RsvdPageLoc.LocNullData = PageNum;
#line 681
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & NullDataLength, (u8 *)(& fakemac), 0, 0, 0, 0);
#line 687
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            NullDataLength, 0, 0);
#line 689
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + NullDataLength) >> 7)) + ((((u32 )TxDescLen + NullDataLength) & 127U) != 0U ? 1U : 0U);
#line 690
  PageNum = (int )PageNum + (int )PageNeed;
#line 692
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
#line 695
  RsvdPageLoc.LocBTQosNull = PageNum;
#line 696
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & BTQosNullLength, (u8 *)(& fakemac), 1, 0, 0, 0);
#line 702
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            BTQosNullLength, 0, 1);
#line 704
  TotalPacketLen = (u32 )BufIndex + BTQosNullLength;
#line 706
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 707
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 708
    goto exit;
  } else {

  }
#line 711
  pattrib = & pmgntframe->attrib;
#line 712
  update_mgntframe_attrib23a(padapter, pattrib);
#line 713
  pattrib->qsel = 16U;
#line 714
  tmp___0 = TotalPacketLen - 40U;
#line 714
  pattrib->last_txcmdsz = tmp___0;
#line 714
  pattrib->pktlen = tmp___0;
#line 715
  memcpy((void *)pmgntframe->buf_addr, (void const   *)ReservedPagePacket, (size_t )TotalPacketLen);
#line 717
  rtl8723au_mgnt_xmit(padapter, pmgntframe);
#line 719
  if (GlobalDebugLevel23A > 3U) {
#line 719
    printk("\016RTL8723AU: %s: Set RSVD page location to Fw\n", "SetFwRsvdPagePkt_BTCoex");
  } else {

  }
#line 720
  FillH2CCmd(padapter, 3, 5U, (u8 *)(& RsvdPageLoc));
  exit: 
#line 723
  kfree((void const   *)ReservedPagePacket);
#line 724
  return;
}
}
#line 726 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.c"
void rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 bRecover ;

  {
#line 729
  bRecover = 0U;
#line 731
  if (GlobalDebugLevel23A > 3U) {
#line 731
    printk("\016RTL8723AU: +%s\n", "rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd");
  } else {

  }
#line 733
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 736
  if (((unsigned long )pHalData->RegFwHwTxQCtrl & 64UL) != 0UL) {
#line 737
    bRecover = 1U;
  } else {

  }
#line 740
  pHalData->RegFwHwTxQCtrl = (unsigned int )pHalData->RegFwHwTxQCtrl & 191U;
#line 741
  rtl8723au_write8(padapter, 1058, (int )pHalData->RegFwHwTxQCtrl);
#line 743
  SetFwRsvdPagePkt_BTCoex(padapter);
#line 750
  if ((unsigned int )bRecover != 0U) {
#line 751
    pHalData->RegFwHwTxQCtrl = (u8 )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U);
#line 752
    rtl8723au_write8(padapter, 1058, (int )pHalData->RegFwHwTxQCtrl);
  } else {

  }
#line 755
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
bool ldv_queue_work_on_467(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
bool ldv_queue_delayed_work_on_468(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
bool ldv_queue_work_on_469(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
void ldv_flush_workqueue_470(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
bool ldv_queue_delayed_work_on_471(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_481(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_483(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_482(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_485(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_484(struct workqueue_struct *ldv_func_arg1 ) ;
#line 132 "drivers/staging/rtl8723au/include/rtl8723a_dm.h"
void rtl8723a_init_dm_priv(struct rtw_adapter *Adapter ) ;
#line 134
void rtl8723a_InitHalDm(struct rtw_adapter *Adapter ) ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_dm.c"
static void dm_CheckPbcGPIO(struct rtw_adapter *padapter ) 
{ 
  u8 tmp1byte ;
  u8 bPbcPressed ;
  struct pid *tmp ;

  {
#line 40
  bPbcPressed = 0U;
#line 42
  if ((unsigned int )padapter->registrypriv.hw_wps_pbc == 0U) {
#line 43
    return;
  } else {

  }
#line 45
  tmp1byte = rtl8723au_read8(padapter, 70);
#line 46
  tmp1byte = (u8 )((unsigned int )tmp1byte | 4U);
#line 48
  rtl8723au_write8(padapter, 70, (int )tmp1byte);
#line 50
  tmp1byte = (unsigned int )tmp1byte & 251U;
#line 52
  rtl8723au_write8(padapter, 68, (int )tmp1byte);
#line 54
  tmp1byte = rtl8723au_read8(padapter, 70);
#line 55
  tmp1byte = (unsigned int )tmp1byte & 251U;
#line 57
  rtl8723au_write8(padapter, 70, (int )tmp1byte);
#line 59
  tmp1byte = rtl8723au_read8(padapter, 68);
#line 61
  if ((unsigned int )tmp1byte == 255U) {
#line 62
    return;
  } else {

  }
#line 64
  if (((unsigned long )tmp1byte & 4UL) != 0UL) {
#line 65
    bPbcPressed = 1U;
  } else {

  }
#line 67
  if ((unsigned int )bPbcPressed != 0U) {
#line 70
    if (GlobalDebugLevel23A > 3U) {
#line 70
      printk("\016RTL8723AU: CheckPbcGPIO - PBC is pressed\n");
    } else {

    }
#line 72
    if (padapter->pid[0] == 0) {
#line 76
      return;
    } else {

    }
#line 79
    tmp = find_vpid(padapter->pid[0]);
#line 79
    kill_pid(tmp, 10, 1);
  } else {

  }
#line 81
  return;
}
}
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_dm.c"
void rtl8723a_init_dm_priv(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct dm_odm_t *pDM_Odm ;
  u8 cut_ver ;
  u8 fab_ver ;

  {
#line 88
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 89
  pdmpriv = & pHalData->dmpriv;
#line 90
  pDM_Odm = & pHalData->odmpriv;
#line 93
  memset((void *)pdmpriv, 0, 352UL);
#line 94
  memset((void *)pDM_Odm, 0, 2632UL);
#line 96
  pDM_Odm->Adapter = Adapter;
#line 98
  ODM_CmnInfoInit23a(pDM_Odm, 3, 8U);
#line 100
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 0U) {
#line 101
    fab_ver = 1U;
#line 102
    cut_ver = 1U;
  } else
#line 103
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 1U) {
#line 104
    fab_ver = 1U;
#line 105
    cut_ver = 2U;
  } else {
#line 107
    fab_ver = 0U;
#line 108
    cut_ver = 1U;
  }
#line 110
  ODM_CmnInfoInit23a(pDM_Odm, 5, (u32 )fab_ver);
#line 111
  ODM_CmnInfoInit23a(pDM_Odm, 4, (u32 )cut_ver);
#line 112
  ODM_CmnInfoInit23a(pDM_Odm, 2, (unsigned int )pHalData->VersionID.ChipType == 1U);
#line 114
  ODM_CmnInfoInit23a(pDM_Odm, 6, (u32 )pHalData->BoardType);
#line 116
  if ((unsigned int )pHalData->BoardType == 1U) {
#line 117
    ODM_CmnInfoInit23a(pDM_Odm, 7, 1U);
#line 118
    ODM_CmnInfoInit23a(pDM_Odm, 8, 1U);
  } else {

  }
#line 120
  ODM_CmnInfoInit23a(pDM_Odm, 11, (u32 )Adapter->registrypriv.wifi_spec);
#line 121
  return;
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_dm.c"
static void Update_ODM_ComInfo_8723a(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *pDM_Odm ;
  struct dm_priv *pdmpriv ;
  int i ;

  {
#line 125
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 126
  pDM_Odm = & pHalData->odmpriv;
#line 127
  pdmpriv = & pHalData->dmpriv;
#line 129
  pdmpriv->InitODMFlag = 0U;
#line 131
  rtl8723a_odm_support_ability_set(Adapter, 268435455U);
#line 133
  i = 0;
#line 133
  goto ldv_55765;
  ldv_55764: 
#line 134
  ODM_CmnInfoPtrArrayHook23a(pDM_Odm, 28, (int )((u16 )i), (void *)0);
#line 133
  i = i + 1;
  ldv_55765: ;
#line 133
  if (i <= 31) {
#line 135
    goto ldv_55764;
  } else {

  }

#line 140
  return;
}
}
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_dm.c"
void rtl8723a_InitHalDm(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct dm_odm_t *pDM_Odm ;
  u8 i ;
  u8 tmp ;

  {
#line 139
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 140
  pdmpriv = & pHalData->dmpriv;
#line 141
  pDM_Odm = & pHalData->odmpriv;
#line 144
  Update_ODM_ComInfo_8723a(Adapter);
#line 145
  ODM23a_DMInit(pDM_Odm);
#line 147
  i = 0U;
#line 147
  goto ldv_55775;
  ldv_55774: 
#line 148
  tmp = rtl8723au_read8(Adapter, (int )((unsigned int )((u16 )i) + 1156U));
#line 148
  pdmpriv->INIDATA_RATE[(int )i] = (unsigned int )tmp & 63U;
#line 147
  i = (u8 )((int )i + 1);
  ldv_55775: ;
#line 147
  if ((unsigned int )i <= 31U) {
#line 149
    goto ldv_55774;
  } else {

  }

#line 154
  return;
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_dm.c"
void rtl8723a_HalDmWatchDog(struct rtw_adapter *Adapter ) 
{ 
  bool bFwCurrentInPSMode ;
  bool bFwPSAwake ;
  u8 bLinked ;
  u8 hw_init_completed ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 tmp ;
  u8 i ;
  u8 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 156
  bFwCurrentInPSMode = 0;
#line 157
  bFwPSAwake = 1;
#line 158
  bLinked = 0U;
#line 159
  hw_init_completed = 0U;
#line 160
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 161
  pdmpriv = & pHalData->dmpriv;
#line 163
  hw_init_completed = Adapter->hw_init_completed;
#line 165
  if ((unsigned int )hw_init_completed == 0U) {
#line 166
    goto skip_dm;
  } else {

  }
#line 168
  bFwCurrentInPSMode = (unsigned int )Adapter->pwrctrlpriv.bFwCurrentInPSMode != 0U;
#line 169
  bFwPSAwake = rtl8723a_get_fwlps_rf_on(Adapter);
#line 171
  if (! bFwCurrentInPSMode && (int )bFwPSAwake) {
#line 173
    tmp___1 = check_fwstate(& Adapter->mlmepriv, 8);
#line 173
    if ((int )tmp___1) {
#line 174
      tmp = rtl8723au_read8(Adapter, 1156);
#line 174
      pdmpriv->INIDATA_RATE[0] = (unsigned int )tmp & 63U;
    } else {
#line 177
      i = 1U;
#line 177
      goto ldv_55789;
      ldv_55788: 
#line 178
      tmp___0 = rtl8723au_read8(Adapter, (int )((unsigned int )((u16 )i) + 1156U));
#line 178
      pdmpriv->INIDATA_RATE[(int )i] = (unsigned int )tmp___0 & 63U;
#line 177
      i = (u8 )((int )i + 1);
      ldv_55789: ;
#line 177
      if ((int )i < Adapter->stapriv.asoc_sta_count + 1) {
#line 179
        goto ldv_55788;
      } else {

      }

    }
  } else {

  }
#line 183
  tmp___2 = rtw_linked_check(Adapter);
#line 183
  if (tmp___2 != 0) {
#line 184
    bLinked = 1U;
  } else {

  }
#line 186
  ODM_CmnInfoUpdate23a(& pHalData->odmpriv, 16U, (u64 )bLinked);
#line 187
  ODM_DMWatchdog23a(Adapter);
  skip_dm: 
#line 193
  dm_CheckPbcGPIO(Adapter);
#line 194
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
bool ldv_queue_work_on_481(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
bool ldv_queue_delayed_work_on_482(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
bool ldv_queue_work_on_483(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
void ldv_flush_workqueue_484(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
bool ldv_queue_delayed_work_on_485(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 121 "include/linux/string.h"
extern void *kmemdup(void const   * , size_t  , gfp_t  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_495(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_497(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_496(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_499(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_498(struct workqueue_struct *ldv_func_arg1 ) ;
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 51
extern void release_firmware(struct firmware  const  * ) ;
#line 108 "drivers/staging/rtl8723au/include/hal_intf.h"
void hw_var_set_macaddr(struct rtw_adapter *padapter , u8 *val ) ;
#line 194 "drivers/staging/rtl8723au/include/drv_types.h"
__inline static struct device *dvobj_to_dev(struct dvobj_priv *dvobj ) 
{ 


  {
#line 197
  return (& (dvobj->pusbintf)->dev);
}
}
#line 36 "drivers/staging/rtl8723au/include/rtl8723a_bt_intf.h"
void rtl8723a_BT_wifiassociate_notify(struct rtw_adapter *padapter , u8 action ) ;
#line 37
void rtl8723a_BT_init_hal_vars(struct rtw_adapter *padapter ) ;
#line 38
void rtl8723a_fw_c2h_BT_info(struct rtw_adapter *padapter , u8 *tmpBuf , u8 length ) ;
#line 214 "drivers/staging/rtl8723au/include/rtl8723a_xmit.h"
void handle_txrpt_ccx_8723a(struct rtw_adapter *adapter , void *buf ) ;
#line 485 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
s32 rtl8723a_FirmwareDownload(struct rtw_adapter *padapter ) ;
#line 486
void rtl8723a_FirmwareSelfReset(struct rtw_adapter *padapter ) ;
#line 487
void rtl8723a_InitializeFirmwareVars(struct rtw_adapter *padapter ) ;
#line 489
void rtl8723a_InitAntenna_Selection(struct rtw_adapter *padapter ) ;
#line 490
void rtl8723a_DeinitAntenna_Selection(struct rtw_adapter *padapter ) ;
#line 491
void rtl8723a_CheckAntenna_Selection(struct rtw_adapter *padapter ) ;
#line 492
void rtl8723a_init_default_value(struct rtw_adapter *padapter ) ;
#line 494
s32 InitLLTTable23a(struct rtw_adapter *padapter , u32 boundary ) ;
#line 496
s32 CardDisableHWSM(struct rtw_adapter *padapter , u8 resetMCU ) ;
#line 497
s32 CardDisableWithoutHWSM(struct rtw_adapter *padapter ) ;
#line 500
u8 GetEEPROMSize8723A(struct rtw_adapter *padapter ) ;
#line 501
void Hal_InitPGData(struct rtw_adapter *padapter , u8 *PROMContent ) ;
#line 502
void Hal_EfuseParseIDCode(struct rtw_adapter *padapter , u8 *hwinfo ) ;
#line 503
void Hal_EfuseParsetxpowerinfo_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                     bool AutoLoadFail ) ;
#line 504
void Hal_EfuseParseBTCoexistInfo_8723A(struct rtw_adapter *padapter , u8 *hwinfo ,
                                       bool AutoLoadFail ) ;
#line 505
void Hal_EfuseParseEEPROMVer(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
#line 506
void rtl8723a_EfuseParseChnlPlan(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
#line 507
void Hal_EfuseParseCustomerID(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
#line 508
void Hal_EfuseParseAntennaDiversity(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
#line 509
void Hal_EfuseParseRateIndicationOption(struct rtw_adapter *padapter , u8 *hwinfo ,
                                        bool AutoLoadFail ) ;
#line 510
void Hal_EfuseParseXtal_8723A(struct rtw_adapter *pAdapter , u8 *hwinfo , u8 AutoLoadFail ) ;
#line 511
void Hal_EfuseParseThermalMeter_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                      bool AutoloadFail ) ;
#line 515
void rtl8723a_InitBeaconParameters(struct rtw_adapter *padapter ) ;
#line 524
void rtl8723a_read_chip_version(struct rtw_adapter *padapter ) ;
#line 525
void rtl8723a_notch_filter(struct rtw_adapter *adapter , bool enable ) ;
#line 38 "drivers/staging/rtl8723au/include/usb_ops_linux.h"
int rtl8723au_writeN(struct rtw_adapter *padapter , u16 addr , u16 len , u8 *buf ) ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static void _FWDownloadEnable(struct rtw_adapter *padapter , bool enable ) 
{ 
  u8 tmp ;

  {
#line 28
  if ((int )enable) {
#line 30
    tmp = rtl8723au_read8(padapter, 3);
#line 31
    rtl8723au_write8(padapter, 3, (int )((unsigned int )tmp | 4U));
#line 34
    tmp = rtl8723au_read8(padapter, 128);
#line 35
    rtl8723au_write8(padapter, 128, (int )((unsigned int )tmp | 1U));
#line 38
    tmp = rtl8723au_read8(padapter, 130);
#line 39
    rtl8723au_write8(padapter, 130, (int )tmp & 247);
  } else {
#line 42
    tmp = rtl8723au_read8(padapter, 128);
#line 43
    rtl8723au_write8(padapter, 128, (int )tmp & 254);
#line 46
    rtl8723au_write8(padapter, 129, 0);
  }
#line 48
  return;
}
}
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static int _PageWrite(struct rtw_adapter *padapter , u32 page , void *buffer , u32 size ) 
{ 
  u8 value8 ;
  u8 u8Page ;
  u8 tmp ;
  int tmp___0 ;

  {
#line 54
  u8Page = (unsigned int )((unsigned char )page) & 7U;
#line 56
  if (size > 4096U) {
#line 57
    return (0);
  } else {

  }
#line 59
  tmp = rtl8723au_read8(padapter, 130);
#line 59
  value8 = (u8 )(((int )((signed char )tmp) & -8) | (int )((signed char )u8Page));
#line 60
  rtl8723au_write8(padapter, 130, (int )value8);
#line 62
  tmp___0 = rtl8723au_writeN(padapter, 4096, (int )((u16 )size), (u8 *)buffer);
#line 62
  return (tmp___0);
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static int _WriteFW(struct rtw_adapter *padapter , void *buffer , u32 size ) 
{ 
  int ret ;
  u32 pageNums ;
  u32 remainSize ;
  u32 page ;
  u32 offset ;
  u8 *bufferPtr ;

  {
#line 70
  ret = 1;
#line 73
  bufferPtr = (u8 *)buffer;
#line 75
  pageNums = size / 4096U;
#line 78
  remainSize = size & 4095U;
#line 80
  page = 0U;
#line 80
  goto ldv_55799;
  ldv_55798: 
#line 81
  offset = page * 4096U;
#line 82
  ret = _PageWrite(padapter, page, (void *)bufferPtr + (unsigned long )offset, 4096U);
#line 85
  if (ret == 0) {
#line 86
    goto exit;
  } else {

  }
#line 80
  page = page + 1U;
  ldv_55799: ;
#line 80
  if (page < pageNums) {
#line 82
    goto ldv_55798;
  } else {

  }

#line 88
  if (remainSize != 0U) {
#line 89
    offset = pageNums * 4096U;
#line 90
    page = pageNums;
#line 91
    ret = _PageWrite(padapter, page, (void *)bufferPtr + (unsigned long )offset, remainSize);
#line 94
    if (ret == 0) {
#line 95
      goto exit;
    } else {

    }
  } else {

  }
#line 97
  if (GlobalDebugLevel23A > 6U) {
#line 97
    rt_trace(16384, 7, "_WriteFW Done- for Normal chip.\n");
  } else {

  }
  exit: ;
#line 101
  return (ret);
}
}
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static int _FWFreeToGo(struct rtw_adapter *padapter ) 
{ 
  u32 counter ;
  u32 value32 ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 106
  counter = 0U;
  ldv_55807: 
#line 111
  value32 = rtl8723au_read32(padapter, 128);
#line 112
  if (((unsigned long )value32 & 4UL) != 0UL) {
#line 113
    goto ldv_55806;
  } else {

  }
#line 114
  tmp = counter;
#line 114
  counter = counter + 1U;
#line 114
  if (tmp <= 999U) {
#line 116
    goto ldv_55807;
  } else {

  }
  ldv_55806: ;
#line 116
  if (counter > 999U) {
#line 117
    if (GlobalDebugLevel23A > 3U) {
#line 117
      rt_trace(16384, 4, "%s: chksum report fail! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo",
               value32);
    } else {

    }
#line 120
    return (0);
  } else {

  }
#line 122
  if (GlobalDebugLevel23A > 6U) {
#line 122
    rt_trace(16384, 7, "%s: Checksum report OK! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo",
             value32);
  } else {

  }
#line 126
  value32 = rtl8723au_read32(padapter, 128);
#line 127
  value32 = value32 | 2U;
#line 128
  value32 = value32 & 4294967231U;
#line 129
  rtl8723au_write32(padapter, 128, value32);
#line 132
  counter = 0U;
  ldv_55809: 
#line 134
  value32 = rtl8723au_read32(padapter, 128);
#line 135
  if (((unsigned long )value32 & 64UL) != 0UL) {
#line 136
    if (GlobalDebugLevel23A > 6U) {
#line 136
      rt_trace(16384, 7, "%s: Polling FW ready success!! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo",
               value32);
    } else {

    }
#line 139
    return (1);
  } else {

  }
#line 141
  __const_udelay(21475UL);
#line 142
  tmp___0 = counter;
#line 142
  counter = counter + 1U;
#line 142
  if (tmp___0 <= 999U) {
#line 144
    goto ldv_55809;
  } else {

  }

#line 144
  if (GlobalDebugLevel23A > 3U) {
#line 144
    rt_trace(16384, 4, "%s: Polling FW ready fail!! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo",
             value32);
  } else {

  }
#line 147
  return (0);
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void rtl8723a_FirmwareSelfReset(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 u1bTmp ;
  u8 Delay ;

  {
#line 154
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 156
  Delay = 100U;
#line 158
  if (((int )((struct hal_data_8723a *)padapter->HalData)->FirmwareSignature & 65520) != 35008 || ((unsigned int )pHalData->FirmwareVersion > 32U && ((unsigned int )pHalData->FirmwareVersion != 33U || (unsigned int )pHalData->FirmwareSubVersion != 0U))) {
#line 164
    rtl8723au_write8(padapter, 463, 32);
#line 166
    u1bTmp = rtl8723au_read8(padapter, 3);
#line 167
    goto ldv_55819;
    ldv_55818: 
#line 168
    Delay = (u8 )((int )Delay - 1);
#line 169
    if ((unsigned int )Delay == 0U) {
#line 170
      goto ldv_55817;
    } else {

    }
#line 171
    __const_udelay(214750UL);
#line 172
    u1bTmp = rtl8723au_read8(padapter, 3);
    ldv_55819: ;
#line 167
    if (((unsigned long )u1bTmp & 4UL) != 0UL) {
#line 169
      goto ldv_55818;
    } else {

    }
    ldv_55817: ;
#line 174
    if (GlobalDebugLevel23A > 6U) {
#line 174
      rt_trace(16384, 7, "-%s: 8051 reset success (%d)\n", "rtl8723a_FirmwareSelfReset",
               (int )Delay);
    } else {

    }
#line 178
    if ((unsigned int )Delay == 0U) {
#line 180
      u1bTmp = rtl8723au_read8(padapter, 3);
#line 181
      rtl8723au_write8(padapter, 3, (int )u1bTmp & 251);
    } else {

    }
  } else {

  }
#line 184
  return;
}
}
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
s32 rtl8723a_FirmwareDownload(struct rtw_adapter *padapter ) 
{ 
  int rtStatus ;
  u8 writeFW_retry ;
  unsigned long fwdl_start_time ;
  struct hal_data_8723a *pHalData ;
  struct dvobj_priv *dvobj ;
  struct device *device ;
  struct device *tmp ;
  struct rt_8723a_firmware_hdr *pFwHdr ;
  struct firmware  const  *fw ;
  char *fw_name ;
  u8 *firmware_buf ;
  u8 *buf ;
  int fw_size ;
  int log_version ;
  bool tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  u8 tmp___4 ;
  u8 tmp___5 ;
  unsigned int tmp___6 ;
  u8 tmp___7 ;
  unsigned int tmp___8 ;

  {
#line 194
  rtStatus = 1;
#line 195
  writeFW_retry = 0U;
#line 197
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 198
  dvobj = padapter->dvobj;
#line 199
  tmp = dvobj_to_dev(dvobj);
#line 199
  device = tmp;
#line 200
  pFwHdr = (struct rt_8723a_firmware_hdr *)0;
#line 203
  firmware_buf = (u8 *)0U;
#line 208
  if (GlobalDebugLevel23A > 6U) {
#line 208
    rt_trace(16384, 7, "+%s\n", "rtl8723a_FirmwareDownload");
  } else {

  }
#line 210
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 0U) {
#line 211
    fw_name = (char *)"rtlwifi/rtl8723aufw_A.bin";
#line 212
    if (GlobalDebugLevel23A > 6U) {
#line 212
      rt_trace(16384, 7, "rtl8723a_FirmwareDownload: R8723FwImageArray_UMC for RTL8723A A CUT\n");
    } else {

    }
  } else
#line 214
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 1U) {
#line 216
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
#line 217
      fw_name = (char *)"rtlwifi/rtl8723aufw_B_NoBT.bin";
#line 218
      if (GlobalDebugLevel23A > 3U) {
#line 218
        printk("\016RTL8723AU:  Rtl8723_FwUMCBCutImageArrayWithoutBT for RTL8723A B CUT\n");
      } else {

      }
    } else {
#line 221
      tmp___0 = rtl8723a_BT_coexist(padapter);
#line 221
      if ((int )tmp___0) {
#line 222
        fw_name = (char *)"rtlwifi/rtl8723aufw_B.bin";
#line 223
        if (GlobalDebugLevel23A > 3U) {
#line 223
          printk("\016RTL8723AU:  Rtl8723_FwUMCBCutImageArrayWithBT for RTL8723A B CUT\n");
        } else {

        }
      } else {
#line 226
        fw_name = (char *)"rtlwifi/rtl8723aufw_B_NoBT.bin";
#line 227
        if (GlobalDebugLevel23A > 3U) {
#line 227
          printk("\016RTL8723AU:  Rtl8723_FwUMCBCutImageArrayWithout BT for RTL8723A B CUT\n");
        } else {

        }
      }
    }
  } else {
#line 234
    if (GlobalDebugLevel23A > 3U) {
#line 234
      rt_trace(16384, 4, "%s: unknown version!\n", "rtl8723a_FirmwareDownload");
    } else {

    }
#line 236
    rtStatus = 0;
#line 237
    goto Exit;
  }
#line 240
  printk("\016rtl8723au: Loading firmware %s\n", fw_name);
#line 241
  tmp___1 = request_firmware(& fw, (char const   *)fw_name, device);
#line 241
  if (tmp___1 != 0) {
#line 242
    printk("\vrtl8723au: request_firmware load failed\n");
#line 243
    rtStatus = 0;
#line 244
    goto Exit;
  } else {

  }
#line 246
  if ((unsigned long )fw == (unsigned long )((struct firmware  const  *)0)) {
#line 247
    printk("\vrtl8723au: Firmware %s not available\n", fw_name);
#line 248
    rtStatus = 0;
#line 249
    goto Exit;
  } else {

  }
#line 251
  tmp___2 = kmemdup((void const   *)fw->data, fw->size, 208U);
#line 251
  firmware_buf = (u8 *)tmp___2;
#line 252
  if ((unsigned long )firmware_buf == (unsigned long )((u8 *)0U)) {
#line 253
    rtStatus = 0;
#line 254
    goto Exit;
  } else {

  }
#line 256
  buf = firmware_buf;
#line 257
  fw_size = (int )fw->size;
#line 258
  release_firmware(fw);
#line 261
  pFwHdr = (struct rt_8723a_firmware_hdr *)firmware_buf;
#line 263
  pHalData->FirmwareVersion = pFwHdr->Version;
#line 264
  pHalData->FirmwareSubVersion = (u16 )pFwHdr->Subversion;
#line 265
  pHalData->FirmwareSignature = pFwHdr->Signature;
#line 267
  if (GlobalDebugLevel23A > 3U) {
#line 267
    printk("\016RTL8723AU: %s: fw_ver =%d fw_subver =%d sig = 0x%x\n", "rtl8723a_FirmwareDownload",
           (int )pHalData->FirmwareVersion, (int )pHalData->FirmwareSubVersion, (int )pHalData->FirmwareSignature);
  } else {

  }
#line 271
  tmp___3 = log_version;
#line 271
  log_version = log_version + 1;
#line 271
  if (tmp___3 == 0) {
#line 272
    printk("\016%sFirmware Version %d, SubVersion %d, Signature 0x%x\n", (char *)"RTL8723AU: ",
           (int )pHalData->FirmwareVersion, (int )pHalData->FirmwareSubVersion, (int )pHalData->FirmwareSignature);
  } else {

  }
#line 277
  if ((((int )pFwHdr->Signature & 65520) == 37568 || ((int )pFwHdr->Signature & 65520) == 35008) || ((int )pFwHdr->Signature & 65520) == 8960) {
#line 279
    buf = buf + 32UL;
#line 280
    fw_size = fw_size + -32;
  } else {

  }
#line 286
  tmp___4 = rtl8723au_read8(padapter, 128);
#line 286
  if ((int )((signed char )tmp___4) < 0) {
#line 288
    rtl8723a_FirmwareSelfReset(padapter);
#line 289
    rtl8723au_write8(padapter, 128, 0);
  } else {

  }
#line 292
  _FWDownloadEnable(padapter, 1);
#line 293
  fwdl_start_time = jiffies;
  ldv_55840: 
#line 296
  tmp___5 = rtl8723au_read8(padapter, 128);
#line 296
  rtl8723au_write8(padapter, 128, (int )((unsigned int )tmp___5 | 4U));
#line 300
  rtStatus = _WriteFW(padapter, (void *)buf, (u32 )fw_size);
#line 302
  if (rtStatus == 1) {
#line 305
    goto ldv_55839;
  } else {
#line 302
    tmp___6 = jiffies_to_msecs((unsigned long )jiffies - fwdl_start_time);
#line 302
    if (tmp___6 > 500U) {
#line 302
      tmp___7 = writeFW_retry;
#line 302
      writeFW_retry = (u8 )((int )writeFW_retry + 1);
#line 302
      if ((unsigned int )tmp___7 > 2U) {
#line 305
        goto ldv_55839;
      } else {

      }
    } else {

    }
  }
#line 307
  if (GlobalDebugLevel23A > 3U) {
#line 307
    tmp___8 = jiffies_to_msecs((unsigned long )jiffies - fwdl_start_time);
#line 307
    printk("\016RTL8723AU: %s writeFW_retry:%u, time after fwdl_start_time:%ums\n",
           "rtl8723a_FirmwareDownload", (int )writeFW_retry, tmp___8);
  } else {

  }
#line 310
  goto ldv_55840;
  ldv_55839: 
#line 311
  _FWDownloadEnable(padapter, 0);
#line 312
  if (rtStatus != 1) {
#line 313
    if (GlobalDebugLevel23A > 3U) {
#line 313
      printk("\016RTL8723AU: DL Firmware failed!\n");
    } else {

    }
#line 314
    goto Exit;
  } else {

  }
#line 317
  rtStatus = _FWFreeToGo(padapter);
#line 318
  if (rtStatus != 1) {
#line 319
    if (GlobalDebugLevel23A > 3U) {
#line 319
      rt_trace(16384, 4, "DL Firmware failed!\n");
    } else {

    }
#line 321
    goto Exit;
  } else {

  }
#line 323
  if (GlobalDebugLevel23A > 6U) {
#line 323
    rt_trace(16384, 7, "Firmware is ready to run!\n");
  } else {

  }
  Exit: 
#line 327
  kfree((void const   *)firmware_buf);
#line 328
  return (rtStatus);
}
}
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void rtl8723a_InitializeFirmwareVars(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 333
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 336
  padapter->pwrctrlpriv.bFwCurrentInPSMode = 0U;
#line 339
  pHalData->LastHMEBoxNum = 0U;
#line 340
  return;
}
}
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static u8 hal_EfuseSwitchToBank(struct rtw_adapter *padapter , u8 bank ) 
{ 
  u8 bRet ;
  u32 value32 ;

  {
#line 348
  bRet = 0U;
#line 349
  value32 = 0U;
#line 351
  if (GlobalDebugLevel23A > 3U) {
#line 351
    printk("\016RTL8723AU: %s: Efuse switch bank to %d\n", "hal_EfuseSwitchToBank",
           (int )bank);
  } else {

  }
#line 352
  value32 = rtl8723au_read32(padapter, 52);
#line 353
  bRet = 1U;
#line 354
  switch ((int )bank) {
  case 0: 
#line 356
  value32 = value32 & 4294966527U;
#line 358
  goto ldv_55853;
  case 1: 
#line 360
  value32 = (value32 & 4294966527U) | 256U;
#line 362
  goto ldv_55853;
  case 2: 
#line 364
  value32 = (value32 & 4294966527U) | 512U;
#line 366
  goto ldv_55853;
  case 3: 
#line 368
  value32 = value32 | 768U;
#line 370
  goto ldv_55853;
  default: 
#line 372
  value32 = value32 & 4294966527U;
#line 374
  bRet = 0U;
#line 375
  goto ldv_55853;
  }
  ldv_55853: 
#line 377
  rtl8723au_write32(padapter, 52, value32);
#line 379
  return (bRet);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static void hal_ReadEFuse_WiFi(struct rtw_adapter *padapter , u16 _offset , u16 _size_byte ,
                               u8 *pbuf ) 
{ 
  u8 *efuseTbl ;
  u16 eFuse_Addr ;
  u8 offset ;
  u8 wden ;
  u8 efuseHeader ;
  u8 efuseExtHdr ;
  u8 efuseData ;
  u16 i ;
  u16 total ;
  u16 used ;
  struct hal_data_8723a *pHalData ;
  void *tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;
  u16 addr ;
  u16 tmp___2 ;
  u16 tmp___3 ;
  u8 tmp___4 ;

  {
#line 386
  efuseTbl = (u8 *)0U;
#line 387
  eFuse_Addr = 0U;
#line 391
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 395
  if ((int )_offset + (int )_size_byte > 256) {
#line 396
    if (GlobalDebugLevel23A > 3U) {
#line 396
      printk("\016RTL8723AU: %s: Invalid offset(%#x) with read bytes(%#x)!!\n", "hal_ReadEFuse_WiFi",
             (int )_offset, (int )_size_byte);
    } else {

    }
#line 398
    return;
  } else {

  }
#line 401
  tmp = kmalloc(256UL, 208U);
#line 401
  efuseTbl = (u8 *)tmp;
#line 402
  if ((unsigned long )efuseTbl == (unsigned long )((u8 *)0U)) {
#line 403
    if (GlobalDebugLevel23A > 3U) {
#line 403
      printk("\016RTL8723AU: %s: alloc efuseTbl fail!\n", "hal_ReadEFuse_WiFi");
    } else {

    }
#line 404
    return;
  } else {

  }
#line 407
  memset((void *)efuseTbl, 255, 256UL);
#line 410
  hal_EfuseSwitchToBank(padapter, 0);
#line 412
  goto ldv_55877;
  ldv_55882: 
#line 413
  tmp___0 = eFuse_Addr;
#line 413
  eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 413
  ReadEFuseByte23a(padapter, (int )tmp___0, & efuseHeader);
#line 414
  if ((unsigned int )efuseHeader == 255U) {
#line 415
    if (GlobalDebugLevel23A > 3U) {
#line 415
      printk("\016RTL8723AU: %s: data end at address =%#x\n", "hal_ReadEFuse_WiFi",
             (int )eFuse_Addr);
    } else {

    }
#line 417
    goto ldv_55876;
  } else {

  }
#line 421
  if (((int )efuseHeader & 31) == 15) {
#line 422
    offset = (int )efuseHeader >> 5;
#line 424
    tmp___1 = eFuse_Addr;
#line 424
    eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 424
    ReadEFuseByte23a(padapter, (int )tmp___1, & efuseExtHdr);
#line 425
    if (((int )efuseExtHdr & 15) == 15) {
#line 426
      goto ldv_55877;
    } else {

    }
#line 428
    offset = (u8 )((int )((signed char )(((int )efuseExtHdr & 240) >> 1)) | (int )((signed char )offset));
#line 429
    wden = (unsigned int )efuseExtHdr & 15U;
  } else {
#line 431
    offset = (u8 )((int )efuseHeader >> 4);
#line 432
    wden = (unsigned int )efuseHeader & 15U;
  }
#line 435
  if ((unsigned int )offset <= 31U) {
#line 439
    addr = (unsigned int )((u16 )offset) * 8U;
#line 440
    i = 0U;
#line 440
    goto ldv_55880;
    ldv_55879: ;
#line 442
    if ((((int )wden >> (int )i) & 1) == 0) {
#line 443
      tmp___2 = eFuse_Addr;
#line 443
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 443
      ReadEFuseByte23a(padapter, (int )tmp___2, & efuseData);
#line 445
      *(efuseTbl + (unsigned long )addr) = efuseData;
#line 447
      tmp___3 = eFuse_Addr;
#line 447
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 447
      ReadEFuseByte23a(padapter, (int )tmp___3, & efuseData);
#line 449
      *(efuseTbl + ((unsigned long )addr + 1UL)) = efuseData;
    } else {

    }
#line 451
    addr = (unsigned int )addr + 2U;
#line 440
    i = (u16 )((int )i + 1);
    ldv_55880: ;
#line 440
    if ((unsigned int )i <= 3U) {
#line 442
      goto ldv_55879;
    } else {

    }

  } else {
#line 454
    if (GlobalDebugLevel23A > 3U) {
#line 454
      printk("\016RTL8723AU: \v%s: offset(%d) is illegal!!\n", "hal_ReadEFuse_WiFi",
             (int )offset);
    } else {

    }
#line 456
    tmp___4 = Efuse_CalculateWordCnts23a((int )wden);
#line 456
    eFuse_Addr = (unsigned int )((u16 )tmp___4) * 2U + (unsigned int )eFuse_Addr;
  }
  ldv_55877: ;
#line 412
  if ((unsigned int )eFuse_Addr <= 511U) {
#line 414
    goto ldv_55882;
  } else {

  }
  ldv_55876: 
#line 461
  i = 0U;
#line 461
  goto ldv_55884;
  ldv_55883: 
#line 462
  *(pbuf + (unsigned long )i) = *(efuseTbl + (unsigned long )((int )_offset + (int )i));
#line 461
  i = (u16 )((int )i + 1);
  ldv_55884: ;
#line 461
  if ((int )i < (int )_size_byte) {
#line 463
    goto ldv_55883;
  } else {

  }
#line 465
  EFUSE_GetEfuseDefinition23a(padapter, 0, 3, (void *)(& total));
#line 467
  used = (unsigned int )eFuse_Addr + 65535U;
#line 468
  pHalData->EfuseUsedBytes = used;
#line 470
  kfree((void const   *)efuseTbl);
#line 471
  return;
}
}
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static void hal_ReadEFuse_BT(struct rtw_adapter *padapter , u16 _offset , u16 _size_byte ,
                             u8 *pbuf ) 
{ 
  u8 *efuseTbl ;
  u8 bank ;
  u16 eFuse_Addr ;
  u8 efuseHeader ;
  u8 efuseExtHdr ;
  u8 efuseData ;
  u8 offset ;
  u8 wden ;
  u16 i ;
  u16 total ;
  u16 used ;
  struct hal_data_8723a *pHalData ;
  void *tmp ;
  u8 tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  u16 addr ;
  u16 tmp___3 ;
  u16 tmp___4 ;
  u8 tmp___5 ;

  {
#line 483
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 487
  if ((int )_offset + (int )_size_byte > 1024) {
#line 488
    if (GlobalDebugLevel23A > 3U) {
#line 488
      printk("\016RTL8723AU: %s: Invalid offset(%#x) with read bytes(%#x)!!\n", "hal_ReadEFuse_BT",
             (int )_offset, (int )_size_byte);
    } else {

    }
#line 490
    return;
  } else {

  }
#line 493
  tmp = kmalloc(1024UL, 208U);
#line 493
  efuseTbl = (u8 *)tmp;
#line 494
  if ((unsigned long )efuseTbl == (unsigned long )((u8 *)0U)) {
#line 495
    if (GlobalDebugLevel23A > 3U) {
#line 495
      printk("\016RTL8723AU: %s: efuseTbl malloc fail!\n", "hal_ReadEFuse_BT");
    } else {

    }
#line 496
    return;
  } else {

  }
#line 499
  memset((void *)efuseTbl, 255, 1024UL);
#line 501
  EFUSE_GetEfuseDefinition23a(padapter, 1, 2, (void *)(& total));
#line 504
  bank = 1U;
#line 504
  goto ldv_55915;
  ldv_55914: 
#line 505
  tmp___0 = hal_EfuseSwitchToBank(padapter, (int )bank);
#line 505
  if ((unsigned int )tmp___0 == 0U) {
#line 506
    if (GlobalDebugLevel23A > 3U) {
#line 506
      printk("\016RTL8723AU: %s: hal_EfuseSwitchToBank Fail!!\n", "hal_ReadEFuse_BT");
    } else {

    }
#line 508
    goto exit;
  } else {

  }
#line 511
  eFuse_Addr = 0U;
#line 513
  goto ldv_55907;
  ldv_55912: 
#line 514
  tmp___1 = eFuse_Addr;
#line 514
  eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 514
  ReadEFuseByte23a(padapter, (int )tmp___1, & efuseHeader);
#line 515
  if ((unsigned int )efuseHeader == 255U) {
#line 516
    goto ldv_55906;
  } else {

  }
#line 519
  if (((int )efuseHeader & 31) == 15) {
#line 520
    offset = (int )efuseHeader >> 5;
#line 522
    tmp___2 = eFuse_Addr;
#line 522
    eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 522
    ReadEFuseByte23a(padapter, (int )tmp___2, & efuseExtHdr);
#line 524
    if (((int )efuseExtHdr & 15) == 15) {
#line 525
      goto ldv_55907;
    } else {

    }
#line 527
    offset = (u8 )((int )((signed char )(((int )efuseExtHdr & 240) >> 1)) | (int )((signed char )offset));
#line 528
    wden = (unsigned int )efuseExtHdr & 15U;
  } else {
#line 530
    offset = (u8 )((int )efuseHeader >> 4);
#line 531
    wden = (unsigned int )efuseHeader & 15U;
  }
#line 534
  if ((int )((signed char )offset) >= 0) {
#line 539
    addr = (unsigned int )((u16 )offset) * 8U;
#line 540
    i = 0U;
#line 540
    goto ldv_55910;
    ldv_55909: ;
#line 543
    if ((((int )wden >> (int )i) & 1) == 0) {
#line 544
      tmp___3 = eFuse_Addr;
#line 544
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 544
      ReadEFuseByte23a(padapter, (int )tmp___3, & efuseData);
#line 547
      *(efuseTbl + (unsigned long )addr) = efuseData;
#line 549
      tmp___4 = eFuse_Addr;
#line 549
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 549
      ReadEFuseByte23a(padapter, (int )tmp___4, & efuseData);
#line 552
      *(efuseTbl + ((unsigned long )addr + 1UL)) = efuseData;
    } else {

    }
#line 554
    addr = (unsigned int )addr + 2U;
#line 540
    i = (u16 )((int )i + 1);
    ldv_55910: ;
#line 540
    if ((unsigned int )i <= 3U) {
#line 542
      goto ldv_55909;
    } else {

    }

  } else {
#line 557
    if (GlobalDebugLevel23A > 3U) {
#line 557
      printk("\016RTL8723AU: \v%s: offset(%d) is illegal!!\n", "hal_ReadEFuse_BT",
             (int )offset);
    } else {

    }
#line 560
    tmp___5 = Efuse_CalculateWordCnts23a((int )wden);
#line 560
    eFuse_Addr = (unsigned int )((u16 )tmp___5) * 2U + (unsigned int )eFuse_Addr;
  }
  ldv_55907: ;
#line 513
  if ((unsigned int )eFuse_Addr <= 511U) {
#line 515
    goto ldv_55912;
  } else {

  }
  ldv_55906: ;
#line 564
  if ((int )eFuse_Addr + -1 < (int )total) {
#line 565
    if (GlobalDebugLevel23A > 3U) {
#line 565
      printk("\016RTL8723AU: %s: bank(%d) data end at %#x\n", "hal_ReadEFuse_BT",
             (int )bank, (int )eFuse_Addr + -1);
    } else {

    }
#line 567
    goto ldv_55913;
  } else {

  }
#line 504
  bank = (u8 )((int )bank + 1);
  ldv_55915: ;
#line 504
  if ((unsigned int )bank <= 3U) {
#line 506
    goto ldv_55914;
  } else {

  }
  ldv_55913: 
#line 572
  hal_EfuseSwitchToBank(padapter, 0);
#line 575
  i = 0U;
#line 575
  goto ldv_55917;
  ldv_55916: 
#line 576
  *(pbuf + (unsigned long )i) = *(efuseTbl + (unsigned long )((int )_offset + (int )i));
#line 575
  i = (u16 )((int )i + 1);
  ldv_55917: ;
#line 575
  if ((int )i < (int )_size_byte) {
#line 577
    goto ldv_55916;
  } else {

  }
#line 581
  EFUSE_GetEfuseDefinition23a(padapter, 1, 3, (void *)(& total));
#line 583
  used = ((unsigned int )((u16 )((int )bank + -1)) * 512U + (unsigned int )eFuse_Addr) + 65535U;
#line 584
  pHalData->BTEfuseUsedBytes = used;
  exit: 
#line 587
  kfree((void const   *)efuseTbl);
#line 588
  return;
}
}
#line 591 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void rtl8723a_readefuse(struct rtw_adapter *padapter , u8 efuseType , u16 _offset ,
                        u16 _size_byte , u8 *pbuf ) 
{ 


  {
#line 594
  if ((unsigned int )efuseType == 0U) {
#line 595
    hal_ReadEFuse_WiFi(padapter, (int )_offset, (int )_size_byte, pbuf);
  } else {
#line 597
    hal_ReadEFuse_BT(padapter, (int )_offset, (int )_size_byte, pbuf);
  }
#line 598
  return;
}
}
#line 600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
u16 rtl8723a_EfuseGetCurrentSize_WiFi(struct rtw_adapter *padapter ) 
{ 
  u16 efuse_addr ;
  u8 hoffset ;
  u8 hworden ;
  u8 efuse_data ;
  u8 word_cnts ;
  struct hal_data_8723a *pHalData ;
  int tmp ;

  {
#line 602
  efuse_addr = 0U;
#line 603
  hoffset = 0U;
#line 603
  hworden = 0U;
#line 604
  word_cnts = 0U;
#line 605
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 607
  efuse_addr = pHalData->EfuseUsedBytes;
#line 609
  if (GlobalDebugLevel23A > 3U) {
#line 609
    printk("\016RTL8723AU: %s: start_efuse_addr = 0x%X\n", "rtl8723a_EfuseGetCurrentSize_WiFi",
           (int )efuse_addr);
  } else {

  }
#line 612
  hal_EfuseSwitchToBank(padapter, 0);
#line 614
  goto ldv_55937;
  ldv_55938: 
#line 615
  tmp = efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
#line 615
  if (tmp == 0) {
#line 617
    if (GlobalDebugLevel23A > 3U) {
#line 617
      printk("\016RTL8723AU: \v%s: efuse_OneByteRead23a Fail! addr = 0x%X !!\n", "rtl8723a_EfuseGetCurrentSize_WiFi",
             (int )efuse_addr);
    } else {

    }
#line 619
    goto ldv_55936;
  } else {

  }
#line 622
  if ((unsigned int )efuse_data == 255U) {
#line 623
    goto ldv_55936;
  } else {

  }
#line 625
  if (((int )efuse_data & 31) == 15) {
#line 626
    hoffset = (int )efuse_data >> 5;
#line 627
    efuse_addr = (u16 )((int )efuse_addr + 1);
#line 628
    efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
#line 629
    if (((int )efuse_data & 15) == 15) {
#line 630
      goto ldv_55937;
    } else {

    }
#line 632
    hoffset = (u8 )((int )((signed char )(((int )efuse_data & 240) >> 1)) | (int )((signed char )hoffset));
#line 633
    hworden = (unsigned int )efuse_data & 15U;
  } else {
#line 635
    hoffset = (u8 )((int )efuse_data >> 4);
#line 636
    hworden = (unsigned int )efuse_data & 15U;
  }
#line 639
  word_cnts = Efuse_CalculateWordCnts23a((int )hworden);
#line 640
  efuse_addr = ((unsigned int )((u16 )word_cnts) * 2U + (unsigned int )efuse_addr) + 1U;
  ldv_55937: ;
#line 614
  if ((unsigned int )efuse_addr <= 511U) {
#line 616
    goto ldv_55938;
  } else {

  }
  ldv_55936: 
#line 643
  pHalData->EfuseUsedBytes = efuse_addr;
#line 645
  if (GlobalDebugLevel23A > 3U) {
#line 645
    printk("\016RTL8723AU: %s: CurrentSize =%d\n", "rtl8723a_EfuseGetCurrentSize_WiFi",
           (int )efuse_addr);
  } else {

  }
#line 647
  return (efuse_addr);
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
u16 rtl8723a_EfuseGetCurrentSize_BT(struct rtw_adapter *padapter ) 
{ 
  u16 btusedbytes ;
  u16 efuse_addr ;
  u8 bank ;
  u8 startBank ;
  u8 hoffset ;
  u8 hworden ;
  u8 efuse_data ;
  u8 word_cnts ;
  u16 retU2 ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  int tmp___0 ;

  {
#line 655
  hoffset = 0U;
#line 655
  hworden = 0U;
#line 656
  word_cnts = 0U;
#line 657
  retU2 = 0U;
#line 658
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 660
  btusedbytes = pHalData->BTEfuseUsedBytes;
#line 662
  efuse_addr = (unsigned int )btusedbytes & 511U;
#line 663
  startBank = (unsigned int )((unsigned char )((unsigned int )btusedbytes / 512U)) + 1U;
#line 665
  if (GlobalDebugLevel23A > 3U) {
#line 665
    printk("\016RTL8723AU: %s: start from bank =%d addr = 0x%X\n", "rtl8723a_EfuseGetCurrentSize_BT",
           (int )startBank, (int )efuse_addr);
  } else {

  }
#line 668
  EFUSE_GetEfuseDefinition23a(padapter, 1, 2, (void *)(& retU2));
#line 671
  bank = startBank;
#line 671
  goto ldv_55958;
  ldv_55957: 
#line 672
  tmp = hal_EfuseSwitchToBank(padapter, (int )bank);
#line 672
  if ((unsigned int )tmp == 0U) {
#line 673
    if (GlobalDebugLevel23A > 3U) {
#line 673
      printk("\016RTL8723AU: \v%s: switch bank(%d) Fail!!\n", "rtl8723a_EfuseGetCurrentSize_BT",
             (int )bank);
    } else {

    }
#line 675
    bank = 4U;
#line 676
    goto ldv_55953;
  } else {

  }
#line 681
  if ((int )bank != (int )startBank) {
#line 682
    efuse_addr = 0U;
  } else {

  }
#line 684
  goto ldv_55955;
  ldv_55956: 
#line 685
  tmp___0 = efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
#line 685
  if (tmp___0 == 0) {
#line 687
    if (GlobalDebugLevel23A > 3U) {
#line 687
      printk("\016RTL8723AU: \v%s: efuse_OneByteRead23a Fail! addr = 0x%X !!\n", "rtl8723a_EfuseGetCurrentSize_BT",
             (int )efuse_addr);
    } else {

    }
#line 690
    bank = 4U;
#line 691
    goto ldv_55954;
  } else {

  }
#line 694
  if ((unsigned int )efuse_data == 255U) {
#line 695
    goto ldv_55954;
  } else {

  }
#line 697
  if (((int )efuse_data & 31) == 15) {
#line 698
    hoffset = (int )efuse_data >> 5;
#line 699
    efuse_addr = (u16 )((int )efuse_addr + 1);
#line 700
    efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
#line 702
    if (((int )efuse_data & 15) == 15) {
#line 703
      efuse_addr = (u16 )((int )efuse_addr + 1);
#line 704
      goto ldv_55955;
    } else {

    }
#line 707
    hoffset = (u8 )((int )((signed char )(((int )efuse_data & 240) >> 1)) | (int )((signed char )hoffset));
#line 708
    hworden = (unsigned int )efuse_data & 15U;
  } else {
#line 710
    hoffset = (u8 )((int )efuse_data >> 4);
#line 711
    hworden = (unsigned int )efuse_data & 15U;
  }
#line 713
  word_cnts = Efuse_CalculateWordCnts23a((int )hworden);
#line 715
  efuse_addr = ((unsigned int )((u16 )word_cnts) * 2U + (unsigned int )efuse_addr) + 1U;
  ldv_55955: ;
#line 684
  if ((unsigned int )efuse_addr <= 511U) {
#line 686
    goto ldv_55956;
  } else {

  }
  ldv_55954: ;
#line 719
  if ((int )efuse_addr < (int )retU2) {
#line 720
    goto ldv_55953;
  } else {

  }
#line 671
  bank = (u8 )((int )bank + 1);
  ldv_55958: ;
#line 671
  if ((unsigned int )bank <= 3U) {
#line 673
    goto ldv_55957;
  } else {

  }
  ldv_55953: 
#line 723
  retU2 = (unsigned int )((u16 )((int )bank + -1)) * 512U + (unsigned int )efuse_addr;
#line 724
  pHalData->BTEfuseUsedBytes = retU2;
#line 726
  if (GlobalDebugLevel23A > 3U) {
#line 726
    printk("\016RTL8723AU: %s: CurrentSize =%d\n", "rtl8723a_EfuseGetCurrentSize_BT",
           (int )retU2);
  } else {

  }
#line 727
  return (retU2);
}
}
#line 730 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void rtl8723a_read_chip_version(struct rtw_adapter *padapter ) 
{ 
  u32 value32 ;
  struct hal_version ChipVersion ;
  struct hal_data_8723a *pHalData ;

  {
#line 736
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 738
  value32 = rtl8723au_read32(padapter, 240);
#line 739
  ChipVersion.ICType = 4;
#line 740
  ChipVersion.ChipType = ((unsigned long )value32 & 8388608UL) == 0UL;
#line 741
  pHalData->rf_type = 3U;
#line 742
  ChipVersion.VendorType = ((unsigned long )value32 & 524288UL) != 0UL;
#line 744
  ChipVersion.CUTVersion = (enum hal_cut_version )((value32 & 61440U) >> 12);
#line 747
  pHalData->RegulatorMode = ((unsigned long )value32 & 16777216UL) != 0UL;
#line 750
  value32 = rtl8723au_read32(padapter, 244);
#line 752
  ChipVersion.ROMVer = (u8 )(((unsigned long )value32 & 4026531840UL) >> 20);
#line 755
  pHalData->MultiFunc = 0;
#line 756
  value32 = rtl8723au_read32(padapter, 104);
#line 757
  pHalData->MultiFunc = (enum RT_MULTI_FUNC )((unsigned int )pHalData->MultiFunc | (((unsigned long )value32 & 4UL) != 0UL ? 1U : 0U));
#line 759
  pHalData->MultiFunc = (enum RT_MULTI_FUNC )((unsigned int )pHalData->MultiFunc | (((unsigned long )value32 & 262144UL) != 0UL ? 2U : 0U));
#line 760
  pHalData->MultiFunc = (enum RT_MULTI_FUNC )((unsigned int )pHalData->MultiFunc | (((unsigned long )value32 & 4194304UL) != 0UL ? 4U : 0U));
#line 762
  pHalData->PolarityCtl = ((unsigned long )value32 & 2UL) != 0UL;
#line 765
  pHalData->VersionID = ChipVersion;
#line 767
  if (GlobalDebugLevel23A > 3U) {
#line 767
    printk("\016RTL8723AU: RF_Type is %x!!\n", (int )pHalData->rf_type);
  } else {

  }
#line 768
  return;
}
}
#line 781 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void SetBcnCtrlReg23a(struct rtw_adapter *padapter , u8 SetBits , u8 ClearBits ) 
{ 
  u8 val8 ;

  {
#line 785
  val8 = rtl8723au_read8(padapter, 1360);
#line 786
  val8 = (u8 )((int )val8 | (int )SetBits);
#line 787
  val8 = (u8 )(~ ((int )((signed char )ClearBits)) & (int )((signed char )val8));
#line 789
  rtl8723au_write8(padapter, 1360, (int )val8);
#line 790
  return;
}
}
#line 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void rtl8723a_InitBeaconParameters(struct rtw_adapter *padapter ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 794
  rtl8723au_write16(padapter, 1360, 4112);
#line 797
  rtl8723au_write16(padapter, 1344, 25604);
#line 800
  tmp = check_fwstate(& padapter->mlmepriv, 8);
#line 800
  if (tmp) {
#line 800
    tmp___0 = 0;
  } else {
#line 800
    tmp___0 = 1;
  }
#line 800
  if (tmp___0) {
#line 801
    rtl8723au_write8(padapter, 1368, 5);
  } else {

  }
#line 804
  rtl8723au_write8(padapter, 1369, 2);
#line 809
  rtl8723au_write16(padapter, 1296, 26127);
#line 810
  return;
}
}
#line 812 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static void ResumeTxBeacon(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 814
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 820
  if (GlobalDebugLevel23A > 6U) {
#line 820
    rt_trace(32768, 7, "+ResumeTxBeacon\n");
  } else {

  }
#line 822
  pHalData->RegFwHwTxQCtrl = (u8 )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U);
#line 823
  rtl8723au_write8(padapter, 1058, (int )pHalData->RegFwHwTxQCtrl);
#line 825
  rtl8723au_write8(padapter, 1345, 255);
#line 826
  pHalData->RegReg542 = (u8 )((unsigned int )pHalData->RegReg542 | 1U);
#line 827
  rtl8723au_write8(padapter, 1346, (int )pHalData->RegReg542);
#line 828
  return;
}
}
#line 830 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static void StopTxBeacon(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 832
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 838
  if (GlobalDebugLevel23A > 6U) {
#line 838
    rt_trace(32768, 7, "+StopTxBeacon\n");
  } else {

  }
#line 840
  pHalData->RegFwHwTxQCtrl = (unsigned int )pHalData->RegFwHwTxQCtrl & 191U;
#line 841
  rtl8723au_write8(padapter, 1058, (int )pHalData->RegFwHwTxQCtrl);
#line 843
  rtl8723au_write8(padapter, 1345, 100);
#line 844
  pHalData->RegReg542 = (unsigned int )pHalData->RegReg542 & 254U;
#line 845
  rtl8723au_write8(padapter, 1346, (int )pHalData->RegReg542);
#line 846
  return;
}
}
#line 848 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static void _BeaconFunctionEnable(struct rtw_adapter *padapter , u8 Enable , u8 Linked ) 
{ 


  {
#line 851
  SetBcnCtrlReg23a(padapter, 26, 0);
#line 853
  rtl8723au_write8(padapter, 1317, 111);
#line 854
  return;
}
}
#line 856 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void rtl8723a_SetBeaconRelatedRegisters(struct rtw_adapter *padapter ) 
{ 
  u32 value32 ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool tmp ;

  {
#line 859
  pmlmeext = & padapter->mlmeextpriv;
#line 860
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 877
  rtl8723au_write16(padapter, 1370, 2);
#line 882
  rtl8723au_write16(padapter, 1364, (int )pmlmeinfo->bcn_interval);
#line 884
  rtl8723a_InitBeaconParameters(padapter);
#line 886
  rtl8723au_write8(padapter, 1307, 9);
#line 891
  value32 = rtl8723au_read32(padapter, 1540);
#line 892
  value32 = value32 & 4294967294U;
#line 893
  rtl8723au_write32(padapter, 1540, value32);
#line 895
  value32 = value32 | 1U;
#line 896
  rtl8723au_write32(padapter, 1540, value32);
#line 899
  tmp = check_fwstate(& padapter->mlmepriv, 112);
#line 899
  if ((int )tmp) {
#line 901
    rtl8723au_write8(padapter, 1374, 80);
#line 902
    rtl8723au_write8(padapter, 1375, 80);
  } else {

  }
#line 905
  _BeaconFunctionEnable(padapter, 1, 1);
#line 907
  ResumeTxBeacon(padapter);
#line 908
  SetBcnCtrlReg23a(padapter, 2, 0);
#line 909
  return;
}
}
#line 911 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void rtl8723a_SetHalODMVar(struct rtw_adapter *Adapter , enum hal_odm_variable eVariable ,
                           void *pValue1 , bool bSet ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *podmpriv ;
  struct sta_info *psta ;

  {
#line 915
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 916
  podmpriv = & pHalData->odmpriv;
#line 917
  switch ((unsigned int )eVariable) {
  case 0U: 
#line 920
  psta = (struct sta_info *)pValue1;
#line 922
  if ((int )bSet) {
#line 923
    if (GlobalDebugLevel23A > 3U) {
#line 923
      printk("\016RTL8723AU: Set STA_(%d) info\n", psta->mac_id);
    } else {

    }
#line 924
    ODM_CmnInfoPtrArrayHook23a(podmpriv, 28, (int )((u16 )psta->mac_id), (void *)psta);
  } else {
#line 928
    if (GlobalDebugLevel23A > 3U) {
#line 928
      printk("\016RTL8723AU: Clean STA_(%d) info\n", psta->mac_id);
    } else {

    }
#line 929
    ODM_CmnInfoPtrArrayHook23a(podmpriv, 28, (int )((u16 )psta->mac_id), (void *)0);
  }
#line 934
  goto ldv_56003;
  case 1U: 
#line 936
  ODM_CmnInfoUpdate23a(podmpriv, 14U, (u64 )bSet);
#line 937
  goto ldv_56003;
  case 2U: 
#line 939
  ODM_CmnInfoUpdate23a(podmpriv, 15U, (u64 )bSet);
#line 940
  goto ldv_56003;
  default: ;
#line 942
  goto ldv_56003;
  }
  ldv_56003: ;
#line 945
  return;
}
}
#line 946 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void rtl8723a_notch_filter(struct rtw_adapter *adapter , bool enable ) 
{ 
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 948
  if ((int )enable) {
#line 949
    if (GlobalDebugLevel23A > 3U) {
#line 949
      printk("\016RTL8723AU: Enable notch filter\n");
    } else {

    }
#line 950
    tmp = rtl8723au_read8(adapter, 3137);
#line 950
    rtl8723au_write8(adapter, 3137, (int )((unsigned int )tmp | 2U));
  } else {
#line 954
    if (GlobalDebugLevel23A > 3U) {
#line 954
      printk("\016RTL8723AU: Disable notch filter\n");
    } else {

    }
#line 955
    tmp___0 = rtl8723au_read8(adapter, 3137);
#line 955
    rtl8723au_write8(adapter, 3137, (int )tmp___0 & 253);
  }
#line 958
  return;
}
}
#line 961 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
bool c2h_id_filter_ccx_8723a(u8 id ) 
{ 
  bool ret ;

  {
#line 963
  ret = 0;
#line 964
  if ((unsigned int )id == 3U) {
#line 965
    ret = 1;
  } else {

  }
#line 967
  return (ret);
}
}
#line 970 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
int c2h_handler_8723a(struct rtw_adapter *padapter , struct c2h_evt_hdr *c2h_evt ) 
{ 
  int ret ;
  u8 i ;

  {
#line 972
  ret = 1;
#line 973
  i = 0U;
#line 975
  if ((unsigned long )c2h_evt == (unsigned long )((struct c2h_evt_hdr *)0)) {
#line 976
    if (GlobalDebugLevel23A > 3U) {
#line 976
      printk("\016RTL8723AU: %s c2h_evt is NULL\n", "c2h_handler_8723a");
    } else {

    }
#line 977
    ret = 0;
#line 978
    goto exit;
  } else {

  }
#line 981
  switch ((int )c2h_evt->id) {
  case 0: ;
#line 983
  if (GlobalDebugLevel23A > 6U) {
#line 983
    rt_trace(16384, 7, "C2HCommandHandler: %s\n", (u8 *)(& c2h_evt->payload));
  } else {

  }
#line 985
  goto ldv_56024;
  case 3: 
#line 988
  handle_txrpt_ccx_8723a(padapter, (void *)(& c2h_evt->payload));
#line 989
  goto ldv_56024;
  case 6: ;
#line 991
  goto ldv_56024;
  case 10: ;
#line 993
  if (GlobalDebugLevel23A > 6U) {
#line 993
    rt_trace(16384, 7, "[BT], C2H_HW_INFO_EXCH\n");
  } else {

  }
#line 995
  i = 0U;
#line 995
  goto ldv_56029;
  ldv_56028: ;
#line 996
  if (GlobalDebugLevel23A > 6U) {
#line 996
    rt_trace(16384, 7, "[BT], tmpBuf[%d]= 0x%x\n", (int )i, (int )c2h_evt->payload[(int )i]);
  } else {

  }
#line 995
  i = (u8 )((int )i + 1);
  ldv_56029: ;
#line 995
  if ((int )i < (int )c2h_evt->plen) {
#line 997
    goto ldv_56028;
  } else {

  }

#line 1000
  goto ldv_56024;
  case 11: ;
#line 1003
  if (GlobalDebugLevel23A > 6U) {
#line 1003
    rt_trace(16384, 7, "[BT], C2H_H2C_TEST\n");
  } else {

  }
#line 1005
  if (GlobalDebugLevel23A > 6U) {
#line 1005
    rt_trace(16384, 7, "[BT], tmpBuf[0]/[1]/[2]/[3]/[4]= 0x%x/ 0x%x/ 0x%x/ 0x%x/ 0x%x\n",
             (int )c2h_evt->payload[0], (int )c2h_evt->payload[1], (int )c2h_evt->payload[2],
             (int )c2h_evt->payload[3], (int )c2h_evt->payload[4]);
  } else {

  }
#line 1010
  goto ldv_56024;
  case 12: ;
#line 1013
  if (GlobalDebugLevel23A > 3U) {
#line 1013
    printk("\016RTL8723AU: %s ,  Got  C2H_BT_INFO \n", "c2h_handler_8723a");
  } else {

  }
#line 1014
  rtl8723a_fw_c2h_BT_info(padapter, (u8 *)(& c2h_evt->payload), (int )c2h_evt->plen);
#line 1016
  goto ldv_56024;
  default: 
#line 1019
  ret = 0;
#line 1020
  goto ldv_56024;
  }
  ldv_56024: ;
  exit: ;
#line 1024
  return (ret);
}
}
#line 1027 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void handle_txrpt_ccx_8723a(struct rtw_adapter *adapter , void *buf ) 
{ 
  struct txrpt_ccx_8723a *txrpt_ccx ;
  struct submit_ctx *pack_tx_ops ;

  {
#line 1029
  txrpt_ccx = (struct txrpt_ccx_8723a *)buf;
#line 1030
  pack_tx_ops = & adapter->xmitpriv.ack_tx_ops;
#line 1032
  if ((unsigned int )*((unsigned char *)txrpt_ccx + 0UL) != 0U && adapter->xmitpriv.ack_tx != 0) {
#line 1033
    if ((unsigned int )*((unsigned char *)txrpt_ccx + 1UL) != 0U) {
#line 1034
      rtw23a_sctx_done_err(& pack_tx_ops, 0);
    } else {
#line 1037
      rtw23a_sctx_done_err(& pack_tx_ops, 8);
    }
  } else {

  }
#line 1038
  return;
}
}
#line 1042 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void rtl8723a_InitAntenna_Selection(struct rtw_adapter *padapter ) 
{ 
  u8 val ;

  {
#line 1046
  val = rtl8723au_read8(padapter, 78);
#line 1048
  val = (u8 )((unsigned int )val | 128U);
#line 1049
  rtl8723au_write8(padapter, 78, (int )val);
#line 1050
  return;
}
}
#line 1052 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void rtl8723a_CheckAntenna_Selection(struct rtw_adapter *padapter ) 
{ 
  u8 val ;

  {
#line 1056
  val = rtl8723au_read8(padapter, 78);
#line 1058
  if ((int )((signed char )val) >= 0) {
#line 1059
    val = (u8 )((unsigned int )val | 128U);
#line 1060
    rtl8723au_write8(padapter, 78, (int )val);
  } else {

  }
#line 1062
  return;
}
}
#line 1064 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void rtl8723a_DeinitAntenna_Selection(struct rtw_adapter *padapter ) 
{ 
  u8 val ;

  {
#line 1068
  val = rtl8723au_read8(padapter, 78);
#line 1070
  val = (unsigned int )val & 127U;
#line 1071
  rtl8723au_write8(padapter, 78, (int )val);
#line 1072
  return;
}
}
#line 1074 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void rtl8723a_init_default_value(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 i ;

  {
#line 1080
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1081
  pdmpriv = & pHalData->dmpriv;
#line 1084
  pHalData->bIQKInitialized = 0U;
#line 1085
  if ((unsigned int )padapter->pwrctrlpriv.bkeepfwalive == 0U) {
#line 1086
    pHalData->LastHMEBoxNum = 0U;
  } else {

  }
#line 1088
  pHalData->bIQKInitialized = 0U;
#line 1091
  pdmpriv->TM_Trigger = 0U;
#line 1096
  pdmpriv->ThermalValue_HP_index = 0U;
#line 1097
  i = 0U;
#line 1097
  goto ldv_56059;
  ldv_56058: 
#line 1098
  pdmpriv->ThermalValue_HP[(int )i] = 0U;
#line 1097
  i = (u8 )((int )i + 1);
  ldv_56059: ;
#line 1097
  if ((unsigned int )i <= 7U) {
#line 1099
    goto ldv_56058;
  } else {

  }
#line 1101
  pHalData->EfuseUsedBytes = 0U;
#line 1102
  pHalData->BTEfuseUsedBytes = 0U;
#line 1103
  return;
}
}
#line 1105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
u8 GetEEPROMSize8723A(struct rtw_adapter *padapter ) 
{ 
  u8 size ;
  u32 cr ;
  u16 tmp ;

  {
#line 1107
  size = 0U;
#line 1110
  tmp = rtl8723au_read16(padapter, 10);
#line 1110
  cr = (u32 )tmp;
#line 1112
  size = ((unsigned long )cr & 16UL) != 0UL ? 6U : 4U;
#line 1114
  if (GlobalDebugLevel23A > 3U) {
#line 1114
    printk("\016RTL8723AU: EEPROM type is %s\n", (unsigned int )size == 4U ? (char *)"E-FUSE" : (char *)"93C46");
  } else {

  }
#line 1116
  return (size);
}
}
#line 1124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static int _LLTWrite(struct rtw_adapter *padapter , u32 address , u32 data ) 
{ 
  int status ;
  s32 count ;
  u32 value ;
  u16 LLTReg ;
  s32 tmp ;

  {
#line 1126
  status = 1;
#line 1127
  count = 0;
#line 1128
  value = (((address << 8) & 65535U) | (data & 255U)) | 1073741824U;
#line 1130
  LLTReg = 480U;
#line 1132
  rtl8723au_write32(padapter, (int )LLTReg, value);
  ldv_56076: 
#line 1136
  value = rtl8723au_read32(padapter, (int )LLTReg);
#line 1137
  if (value >> 30 == 0U) {
#line 1138
    goto ldv_56075;
  } else {

  }
#line 1140
  if (count > 20) {
#line 1141
    if (GlobalDebugLevel23A > 3U) {
#line 1141
      rt_trace(16384, 4, "Failed to polling write LLT done at address %d!\n", address);
    } else {

    }
#line 1144
    status = 0;
#line 1145
    goto ldv_56075;
  } else {

  }
#line 1147
  tmp = count;
#line 1147
  count = count + 1;
#line 1147
  if (tmp != 0) {
#line 1149
    goto ldv_56076;
  } else {

  }
  ldv_56075: ;
#line 1149
  return (status);
}
}
#line 1152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
s32 InitLLTTable23a(struct rtw_adapter *padapter , u32 boundary ) 
{ 
  int status ;
  u32 i ;
  u32 txpktbuf_bndy ;
  u32 Last_Entry_Of_TxPktBuf ;

  {
#line 1154
  status = 1;
#line 1156
  txpktbuf_bndy = boundary;
#line 1157
  Last_Entry_Of_TxPktBuf = 255U;
#line 1159
  i = 0U;
#line 1159
  goto ldv_56086;
  ldv_56085: 
#line 1160
  status = _LLTWrite(padapter, i, i + 1U);
#line 1161
  if (status != 1) {
#line 1162
    return (status);
  } else {

  }
#line 1159
  i = i + 1U;
  ldv_56086: ;
#line 1159
  if (txpktbuf_bndy - 1U > i) {
#line 1161
    goto ldv_56085;
  } else {

  }
#line 1166
  status = _LLTWrite(padapter, txpktbuf_bndy - 1U, 255U);
#line 1167
  if (status != 1) {
#line 1168
    return (status);
  } else {

  }
#line 1174
  i = txpktbuf_bndy;
#line 1174
  goto ldv_56089;
  ldv_56088: 
#line 1175
  status = _LLTWrite(padapter, i, i + 1U);
#line 1176
  if (status != 1) {
#line 1177
    return (status);
  } else {

  }
#line 1174
  i = i + 1U;
  ldv_56089: ;
#line 1174
  if (i < Last_Entry_Of_TxPktBuf) {
#line 1176
    goto ldv_56088;
  } else {

  }
#line 1181
  status = _LLTWrite(padapter, Last_Entry_Of_TxPktBuf, txpktbuf_bndy);
#line 1182
  if (status != 1) {
#line 1183
    return (status);
  } else {

  }
#line 1185
  return (status);
}
}
#line 1188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static void _DisableGPIO(struct rtw_adapter *padapter ) 
{ 
  u32 value32 ;
  u32 u4bTmp ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 1201
  rtl8723au_write16(padapter, 70, 0);
#line 1202
  tmp = rtl8723au_read32(padapter, 68);
#line 1202
  value32 = tmp & 4294902015U;
#line 1203
  u4bTmp = value32 & 255U;
#line 1204
  value32 = ((u4bTmp << 8) | value32) | 16711680U;
#line 1205
  rtl8723au_write32(padapter, 68, value32);
#line 1216
  rtl8723au_write16(padapter, 98, 0);
#line 1217
  tmp___0 = rtl8723au_read32(padapter, 96);
#line 1217
  value32 = tmp___0 & 4294901791U;
#line 1218
  u4bTmp = value32 & 31U;
#line 1220
  value32 = ((u4bTmp << 8) | value32) | 1900544U;
#line 1221
  rtl8723au_write32(padapter, 96, value32);
#line 1224
  rtl8723au_write16(padapter, 76, 32896);
#line 1225
  return;
}
}
#line 1227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static void _DisableRFAFEAndResetBB8192C(struct rtw_adapter *padapter ) 
{ 
  u8 value8 ;

  {
#line 1238
  rtl8723au_write8(padapter, 1314, 255);
#line 1240
  PHY_SetRFReg(padapter, 0, 0U, 255U, 0U);
#line 1242
  value8 = 64U;
#line 1243
  rtl8723au_write8(padapter, 1536, (int )value8);
#line 1246
  value8 = 22U;
#line 1247
  rtl8723au_write8(padapter, 2, (int )value8);
#line 1250
  value8 = (unsigned int )value8 & 253U;
#line 1251
  rtl8723au_write8(padapter, 2, (int )value8);
#line 1252
  return;
}
}
#line 1257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static void _ResetDigitalProcedure1_92C(struct rtw_adapter *padapter , bool bWithoutHWSM ) 
{ 
  struct hal_data_8723a *pHalData ;
  u16 valu16 ;
  u16 tmp ;
  u8 retry_cnts ;
  u8 val8 ;
  u8 tmp___0 ;
  u16 tmp___1 ;
  unsigned long __ms ;
  unsigned long tmp___2 ;

  {
#line 1260
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1262
  if (((int )((struct hal_data_8723a *)padapter->HalData)->FirmwareSignature & 65520) == 35008 && (unsigned int )pHalData->FirmwareVersion <= 32U) {
#line 1271
    rtl8723au_write8(padapter, 128, 0);
#line 1273
    valu16 = rtl8723au_read16(padapter, 2);
#line 1275
    rtl8723au_write16(padapter, 2, (int )valu16 & 64511);
#line 1278
    tmp = rtl8723au_read16(padapter, 2);
#line 1278
    valu16 = (unsigned int )tmp & 4095U;
#line 1280
    rtl8723au_write16(padapter, 2, (int )((unsigned int )valu16 | 20480U));
#line 1283
    valu16 = rtl8723au_read16(padapter, 2);
#line 1285
    rtl8723au_write16(padapter, 2, (int )((unsigned int )valu16 | 1024U));
  } else {
#line 1288
    retry_cnts = 0U;
#line 1291
    val8 = rtl8723au_read8(padapter, 128);
#line 1298
    if (((unsigned long )val8 & 2UL) != 0UL && (unsigned int )padapter->bFWReady != 0U) {
#line 1303
      rtl8723au_write8(padapter, 304, 32);
#line 1307
      rtl8723au_write8(padapter, 312, 0);
#line 1308
      rtl8723au_write8(padapter, 80, 0);
#line 1311
      rtl8723au_write8(padapter, 463, 32);
#line 1313
      goto ldv_56109;
      ldv_56108: 
#line 1316
      __const_udelay(214750UL);
      ldv_56109: 
#line 1313
      tmp___0 = retry_cnts;
#line 1313
      retry_cnts = (u8 )((int )retry_cnts + 1);
#line 1313
      if ((unsigned int )tmp___0 <= 99U) {
#line 1313
        tmp___1 = rtl8723au_read16(padapter, 2);
#line 1313
        if (((unsigned long )tmp___1 & 1024UL) != 0UL) {
#line 1315
          goto ldv_56108;
        } else {
#line 1318
          goto ldv_56110;
        }
      } else {

      }
      ldv_56110: ;
#line 1319
      if ((unsigned int )retry_cnts > 99U) {
#line 1321
        rtl8723au_write8(padapter, 3, 80);
#line 1323
        __ms = 10UL;
#line 1323
        goto ldv_56113;
        ldv_56112: 
#line 1323
        __const_udelay(4295000UL);
        ldv_56113: 
#line 1323
        tmp___2 = __ms;
#line 1323
        __ms = __ms - 1UL;
#line 1323
        if (tmp___2 != 0UL) {
#line 1325
          goto ldv_56112;
        } else {

        }

      } else {

      }
    } else {

    }
#line 1327
    rtl8723au_write8(padapter, 3, 84);
#line 1328
    rtl8723au_write8(padapter, 128, 0);
  }
#line 1331
  if ((int )bWithoutHWSM) {
#line 1340
    rtl8723au_write16(padapter, 8, 28835);
#line 1341
    rtl8723au_write8(padapter, 40, 128);
#line 1342
    rtl8723au_write16(padapter, 36, 34831);
#line 1343
    rtl8723au_write8(padapter, 0, 249);
  } else {
#line 1346
    rtl8723au_write8(padapter, 31, 0);
  }
#line 1347
  return;
}
}
#line 1350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static void _ResetDigitalProcedure2(struct rtw_adapter *padapter ) 
{ 


  {
#line 1358
  rtl8723au_write16(padapter, 8, 28835);
#line 1360
  rtl8723au_write8(padapter, 1, 130);
#line 1361
  return;
}
}
#line 1363 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static void _DisableAnalog(struct rtw_adapter *padapter , bool bWithoutHWSM ) 
{ 
  struct hal_data_8723a *pHalData ;
  u16 value16 ;
  u8 value8 ;

  {
#line 1365
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1369
  if ((int )bWithoutHWSM) {
#line 1377
    rtl8723au_write8(padapter, 32, 4);
#line 1380
    value8 = rtl8723au_read8(padapter, 33);
#line 1381
    value8 = (unsigned int )value8 & 254U;
#line 1382
    rtl8723au_write8(padapter, 33, (int )value8);
  } else {

  }
#line 1389
  value8 = 35U;
#line 1390
  if (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && ((unsigned int )pHalData->VersionID.VendorType == 1U && (unsigned int )pHalData->VersionID.CUTVersion == 1U)) {
#line 1391
    value8 = (u8 )((unsigned int )value8 | 8U);
  } else {

  }
#line 1393
  rtl8723au_write8(padapter, 17, (int )value8);
#line 1395
  if ((int )bWithoutHWSM) {
#line 1401
    value16 = 18434U;
  } else {
#line 1403
    value16 = 18434U;
  }
#line 1406
  rtl8723au_write16(padapter, 4, (int )value16);
#line 1408
  rtl8723au_write8(padapter, 28, 14);
#line 1409
  return;
}
}
#line 1412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
s32 CardDisableHWSM(struct rtw_adapter *padapter , u8 resetMCU ) 
{ 


  {
#line 1414
  if (padapter->bSurpriseRemoved != 0) {
#line 1415
    return (1);
  } else {

  }
#line 1418
  _DisableRFAFEAndResetBB8192C(padapter);
#line 1421
  _ResetDigitalProcedure1_92C(padapter, 0);
#line 1424
  _DisableGPIO(padapter);
#line 1427
  _DisableAnalog(padapter, 0);
#line 1429
  if (GlobalDebugLevel23A > 6U) {
#line 1429
    rt_trace(32768, 7, "======> Card disable finished.\n");
  } else {

  }
#line 1432
  return (1);
}
}
#line 1436 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
s32 CardDisableWithoutHWSM(struct rtw_adapter *padapter ) 
{ 


  {
#line 1438
  if (padapter->bSurpriseRemoved != 0) {
#line 1439
    return (1);
  } else {

  }
#line 1442
  _DisableRFAFEAndResetBB8192C(padapter);
#line 1445
  _ResetDigitalProcedure1_92C(padapter, 1);
#line 1448
  _DisableGPIO(padapter);
#line 1451
  _ResetDigitalProcedure2(padapter);
#line 1454
  _DisableAnalog(padapter, 1);
#line 1456
  return (1);
}
}
#line 1459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void Hal_InitPGData(struct rtw_adapter *padapter , u8 *PROMContent ) 
{ 
  struct eeprom_priv *pEEPROM ;

  {
#line 1461
  pEEPROM = & padapter->eeprompriv;
#line 1463
  if ((unsigned int )pEEPROM->bautoload_fail_flag == 0U) {
#line 1464
    if ((unsigned int )pEEPROM->EepromOrEfuse == 0U) {
#line 1466
      EFUSE_ShadowMapUpdate23a(padapter, 0);
#line 1467
      memcpy((void *)PROMContent, (void const   *)(& pEEPROM->efuse_eeprom_data),
               256UL);
    } else {

    }
  } else {
#line 1471
    if (GlobalDebugLevel23A > 5U) {
#line 1471
      rt_trace(32768, 6, "AutoLoad Fail reported from CR9346!!\n");
    } else {

    }
#line 1474
    if ((unsigned int )pEEPROM->EepromOrEfuse == 0U) {
#line 1475
      EFUSE_ShadowMapUpdate23a(padapter, 0);
    } else {

    }
#line 1476
    memcpy((void *)PROMContent, (void const   *)(& pEEPROM->efuse_eeprom_data),
             256UL);
  }
#line 1478
  return;
}
}
#line 1481 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void Hal_EfuseParseIDCode(struct rtw_adapter *padapter , u8 *hwinfo ) 
{ 
  struct eeprom_priv *pEEPROM ;
  u16 EEPROMId ;

  {
#line 1483
  pEEPROM = & padapter->eeprompriv;
#line 1488
  EEPROMId = *((__le16 *)hwinfo);
#line 1489
  if ((unsigned int )EEPROMId != 33065U) {
#line 1490
    if (GlobalDebugLevel23A > 3U) {
#line 1490
      printk("\016RTL8723AU: EEPROM ID(%#x) is invalid!!\n", (int )EEPROMId);
    } else {

    }
#line 1491
    pEEPROM->bautoload_fail_flag = 1U;
  } else {
#line 1493
    pEEPROM->bautoload_fail_flag = 0U;
  }
#line 1496
  if (GlobalDebugLevel23A > 6U) {
#line 1496
    rt_trace(16384, 7, "EEPROM ID = 0x%04x\n", (int )EEPROMId);
  } else {

  }
#line 1497
  return;
}
}
#line 1500 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static void Hal_EEValueCheck(u8 EEType , void *pInValue , void *pOutValue ) 
{ 
  u8 *pIn ;
  u8 *pOut ;

  {
#line 1502
  switch ((int )EEType) {
  case 0: 
#line 1506
  pIn = (u8 *)pInValue;
#line 1507
  pOut = (u8 *)pOutValue;
#line 1508
  if ((unsigned int )*pIn <= 63U) {
#line 1509
    *pOut = *pIn;
  } else {
#line 1511
    if (GlobalDebugLevel23A > 3U) {
#line 1511
      rt_trace(32768, 4, "EETYPE_TX_PWR, value =%d is invalid, set to default = 0x%x\n",
               (int )*pIn, 34);
    } else {

    }
#line 1514
    *pOut = 34U;
  }
#line 1517
  goto ldv_56151;
  default: ;
#line 1519
  goto ldv_56151;
  }
  ldv_56151: ;
#line 1522
  return;
}
}
#line 1524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static void Hal_ReadPowerValueFromPROM_8723A(struct txpowerinfo *pwrInfo , u8 *PROMContent ,
                                             bool AutoLoadFail ) 
{ 
  u32 rfPath ;
  u32 eeAddr ;
  u32 group ;
  u32 rfPathMax ;

  {
#line 1527
  rfPathMax = 1U;
#line 1529
  memset((void *)pwrInfo, 0, 180UL);
#line 1531
  if ((int )AutoLoadFail) {
#line 1532
    group = 0U;
#line 1532
    goto ldv_56166;
    ldv_56165: 
#line 1533
    rfPath = 0U;
#line 1533
    goto ldv_56163;
    ldv_56162: 
#line 1534
    pwrInfo->CCKIndex[rfPath][group] = 34U;
#line 1536
    pwrInfo->HT40_1SIndex[rfPath][group] = 34U;
#line 1538
    pwrInfo->HT40_2SIndexDiff[rfPath][group] = 0U;
#line 1540
    pwrInfo->HT20IndexDiff[rfPath][group] = 2U;
#line 1542
    pwrInfo->OFDMIndexDiff[rfPath][group] = 3U;
#line 1544
    pwrInfo->HT40MaxOffset[rfPath][group] = 0U;
#line 1546
    pwrInfo->HT20MaxOffset[rfPath][group] = 0U;
#line 1533
    rfPath = rfPath + 1U;
    ldv_56163: ;
#line 1533
    if (rfPath < rfPathMax) {
#line 1535
      goto ldv_56162;
    } else {

    }
#line 1532
    group = group + 1U;
    ldv_56166: ;
#line 1532
    if (group <= 11U) {
#line 1534
      goto ldv_56165;
    } else {

    }
#line 1550
    pwrInfo->TSSI_A[0] = 0U;
#line 1551
    return;
  } else {

  }
#line 1554
  rfPath = 0U;
#line 1554
  goto ldv_56172;
  ldv_56171: 
#line 1555
  group = 0U;
#line 1555
  goto ldv_56169;
  ldv_56168: 
#line 1556
  eeAddr = (rfPath * 3U + group) + 16U;
#line 1560
  Hal_EEValueCheck(0, (void *)PROMContent + (unsigned long )eeAddr, (void *)(& pwrInfo->CCKIndex) + ((unsigned long )rfPath + (unsigned long )group));
#line 1562
  eeAddr = (rfPath * 3U + group) + 22U;
#line 1566
  Hal_EEValueCheck(0, (void *)PROMContent + (unsigned long )eeAddr, (void *)(& pwrInfo->HT40_1SIndex) + ((unsigned long )rfPath + (unsigned long )group));
#line 1555
  group = group + 1U;
  ldv_56169: ;
#line 1555
  if (group <= 11U) {
#line 1557
    goto ldv_56168;
  } else {

  }
#line 1554
  rfPath = rfPath + 1U;
  ldv_56172: ;
#line 1554
  if (rfPath < rfPathMax) {
#line 1556
    goto ldv_56171;
  } else {

  }
#line 1571
  group = 0U;
#line 1571
  goto ldv_56178;
  ldv_56177: 
#line 1572
  rfPath = 0U;
#line 1572
  goto ldv_56175;
  ldv_56174: 
#line 1573
  pwrInfo->HT40_2SIndexDiff[rfPath][group] = 0U;
#line 1574
  pwrInfo->HT20IndexDiff[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 28U)) >> (int )(rfPath * 4U))) & 15U;
#line 1579
  if (((unsigned long )pwrInfo->HT20IndexDiff[rfPath][group] & 8UL) != 0UL) {
#line 1580
    pwrInfo->HT20IndexDiff[rfPath][group] = (u8 )((unsigned int )pwrInfo->HT20IndexDiff[rfPath][group] | 240U);
  } else {

  }
#line 1582
  pwrInfo->OFDMIndexDiff[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 31U)) >> (int )(rfPath * 4U))) & 15U;
#line 1586
  pwrInfo->HT40MaxOffset[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 34U)) >> (int )(rfPath * 4U))) & 15U;
#line 1590
  pwrInfo->HT20MaxOffset[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 37U)) >> (int )(rfPath * 4U))) & 15U;
#line 1572
  rfPath = rfPath + 1U;
  ldv_56175: ;
#line 1572
  if (rfPath < rfPathMax) {
#line 1574
    goto ldv_56174;
  } else {

  }
#line 1571
  group = group + 1U;
  ldv_56178: ;
#line 1571
  if (group <= 11U) {
#line 1573
    goto ldv_56177;
  } else {

  }
#line 1596
  pwrInfo->TSSI_A[0] = *(PROMContent + 41UL);
#line 1597
  return;
}
}
#line 1599 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static u8 Hal_GetChnlGroup(u8 chnl ) 
{ 
  u8 group ;

  {
#line 1601
  group = 0U;
#line 1603
  if ((unsigned int )chnl <= 2U) {
#line 1604
    group = 0U;
  } else
#line 1605
  if ((unsigned int )chnl <= 8U) {
#line 1606
    group = 1U;
  } else {
#line 1608
    group = 2U;
  }
#line 1610
  return (group);
}
}
#line 1614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void Hal_EfuseParsetxpowerinfo_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                     bool AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct txpowerinfo pwrInfo ;
  u8 rfPath ;
  u8 ch ;
  u8 group ;
  u8 rfPathMax ;
  u8 pwr ;
  u8 diff ;
  struct registry_priv *registry_par ;

  {
#line 1617
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1619
  rfPathMax = 1U;
#line 1622
  Hal_ReadPowerValueFromPROM_8723A(& pwrInfo, PROMContent, (int )AutoLoadFail);
#line 1623
  rfPath = 0U;
#line 1623
  goto ldv_56201;
  ldv_56200: 
#line 1624
  ch = 0U;
#line 1624
  goto ldv_56198;
  ldv_56197: 
#line 1625
  group = Hal_GetChnlGroup((int )ch);
#line 1627
  pHalData->TxPwrLevelCck[(int )rfPath][(int )ch] = pwrInfo.CCKIndex[(int )rfPath][(int )group];
#line 1629
  pHalData->TxPwrLevelHT40_1S[(int )rfPath][(int )ch] = pwrInfo.HT40_1SIndex[(int )rfPath][(int )group];
#line 1632
  pHalData->TxPwrHt20Diff[(int )rfPath][(int )ch] = pwrInfo.HT20IndexDiff[(int )rfPath][(int )group];
#line 1634
  pHalData->TxPwrLegacyHtDiff[(int )rfPath][(int )ch] = pwrInfo.OFDMIndexDiff[(int )rfPath][(int )group];
#line 1636
  pHalData->PwrGroupHT20[(int )rfPath][(int )ch] = pwrInfo.HT20MaxOffset[(int )rfPath][(int )group];
#line 1638
  pHalData->PwrGroupHT40[(int )rfPath][(int )ch] = pwrInfo.HT40MaxOffset[(int )rfPath][(int )group];
#line 1641
  pwr = pwrInfo.HT40_1SIndex[(int )rfPath][(int )group];
#line 1642
  diff = pwrInfo.HT40_2SIndexDiff[(int )rfPath][(int )group];
#line 1644
  pHalData->TxPwrLevelHT40_2S[(int )rfPath][(int )ch] = (int )pwr > (int )diff ? (int )pwr - (int )diff : 0U;
#line 1624
  ch = (u8 )((int )ch + 1);
  ldv_56198: ;
#line 1624
  if ((unsigned int )ch <= 13U) {
#line 1626
    goto ldv_56197;
  } else {

  }
#line 1623
  rfPath = (u8 )((int )rfPath + 1);
  ldv_56201: ;
#line 1623
  if ((int )rfPath < (int )rfPathMax) {
#line 1625
    goto ldv_56200;
  } else {

  }
#line 1648
  rfPath = 0U;
#line 1648
  goto ldv_56207;
  ldv_56206: 
#line 1649
  ch = 0U;
#line 1649
  goto ldv_56204;
  ldv_56203: ;
#line 1650
  if (GlobalDebugLevel23A > 6U) {
#line 1650
    rt_trace(32768, 7, "RF(%u)-Ch(%u) [CCK / HT40_1S / HT40_2S] = [0x%x / 0x%x / 0x%x]\n",
             (int )rfPath, (int )ch, (int )pHalData->TxPwrLevelCck[(int )rfPath][(int )ch],
             (int )pHalData->TxPwrLevelHT40_1S[(int )rfPath][(int )ch], (int )pHalData->TxPwrLevelHT40_2S[(int )rfPath][(int )ch]);
  } else {

  }
#line 1649
  ch = (u8 )((int )ch + 1);
  ldv_56204: ;
#line 1649
  if ((unsigned int )ch <= 13U) {
#line 1651
    goto ldv_56203;
  } else {

  }
#line 1648
  rfPath = (u8 )((int )rfPath + 1);
  ldv_56207: ;
#line 1648
  if ((unsigned int )rfPath <= 1U) {
#line 1650
    goto ldv_56206;
  } else {

  }
#line 1659
  ch = 0U;
#line 1659
  goto ldv_56210;
  ldv_56209: ;
#line 1660
  if (GlobalDebugLevel23A > 6U) {
#line 1660
    rt_trace(32768, 7, "RF-A Ht20 to HT40 Diff[%u] = 0x%x(%d)\n", (int )ch, (int )pHalData->TxPwrHt20Diff[0][(int )ch],
             (int )pHalData->TxPwrHt20Diff[0][(int )ch]);
  } else {

  }
#line 1659
  ch = (u8 )((int )ch + 1);
  ldv_56210: ;
#line 1659
  if ((unsigned int )ch <= 13U) {
#line 1661
    goto ldv_56209;
  } else {

  }
#line 1665
  ch = 0U;
#line 1665
  goto ldv_56213;
  ldv_56212: ;
#line 1666
  if (GlobalDebugLevel23A > 6U) {
#line 1666
    rt_trace(32768, 7, "RF-A Legacy to Ht40 Diff[%u] = 0x%x\n", (int )ch, (int )pHalData->TxPwrLegacyHtDiff[0][(int )ch]);
  } else {

  }
#line 1665
  ch = (u8 )((int )ch + 1);
  ldv_56213: ;
#line 1665
  if ((unsigned int )ch <= 13U) {
#line 1667
    goto ldv_56212;
  } else {

  }
#line 1669
  ch = 0U;
#line 1669
  goto ldv_56216;
  ldv_56215: ;
#line 1670
  if (GlobalDebugLevel23A > 6U) {
#line 1670
    rt_trace(32768, 7, "RF-B Ht20 to HT40 Diff[%u] = 0x%x(%d)\n", (int )ch, (int )pHalData->TxPwrHt20Diff[1][(int )ch],
             (int )pHalData->TxPwrHt20Diff[1][(int )ch]);
  } else {

  }
#line 1669
  ch = (u8 )((int )ch + 1);
  ldv_56216: ;
#line 1669
  if ((unsigned int )ch <= 13U) {
#line 1671
    goto ldv_56215;
  } else {

  }
#line 1675
  ch = 0U;
#line 1675
  goto ldv_56219;
  ldv_56218: ;
#line 1676
  if (GlobalDebugLevel23A > 6U) {
#line 1676
    rt_trace(32768, 7, "RF-B Legacy to HT40 Diff[%u] = 0x%x\n", (int )ch, (int )pHalData->TxPwrLegacyHtDiff[1][(int )ch]);
  } else {

  }
#line 1675
  ch = (u8 )((int )ch + 1);
  ldv_56219: ;
#line 1675
  if ((unsigned int )ch <= 13U) {
#line 1677
    goto ldv_56218;
  } else {

  }

#line 1679
  if (! AutoLoadFail) {
#line 1680
    registry_par = & padapter->registrypriv;
#line 1681
    if ((unsigned int )registry_par->regulatory_tid == 255U) {
#line 1682
      if ((unsigned int )*(PROMContent + 43UL) == 255U) {
#line 1683
        pHalData->EEPROMRegulatory = 0U;
      } else {
#line 1685
        pHalData->EEPROMRegulatory = (unsigned int )*(PROMContent + 43UL) & 7U;
      }
    } else {
#line 1688
      pHalData->EEPROMRegulatory = registry_par->regulatory_tid;
    }
  } else {
#line 1692
    pHalData->EEPROMRegulatory = 0U;
  }
#line 1694
  if (GlobalDebugLevel23A > 6U) {
#line 1694
    rt_trace(32768, 7, "EEPROMRegulatory = 0x%x\n", (int )pHalData->EEPROMRegulatory);
  } else {

  }
#line 1697
  if (! AutoLoadFail) {
#line 1698
    pHalData->bTXPowerDataReadFromEEPORM = 1U;
  } else {

  }
#line 1699
  return;
}
}
#line 1702 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void Hal_EfuseParseBTCoexistInfo_8723A(struct rtw_adapter *padapter , u8 *hwinfo ,
                                       bool AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tempval ;
  u32 tmpu4 ;

  {
#line 1705
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1709
  if (! AutoLoadFail) {
#line 1710
    tmpu4 = rtl8723au_read32(padapter, 104);
#line 1711
    if (((unsigned long )tmpu4 & 262144UL) != 0UL) {
#line 1712
      pHalData->EEPROMBluetoothCoexist = 1U;
    } else {
#line 1714
      pHalData->EEPROMBluetoothCoexist = 0U;
    }
#line 1715
    pHalData->EEPROMBluetoothType = 6U;
#line 1719
    tempval = *(hwinfo + 46UL);
#line 1720
    pHalData->EEPROMBluetoothAntNum = (unsigned int )tempval & 1U;
#line 1721
    pHalData->EEPROMBluetoothAntIsolation = (u8 )(((int )tempval & 16) >> 4);
#line 1722
    pHalData->EEPROMBluetoothRadioShared = (u8 )(((int )tempval & 32) >> 5);
  } else {
#line 1724
    pHalData->EEPROMBluetoothCoexist = 0U;
#line 1725
    pHalData->EEPROMBluetoothType = 6U;
#line 1726
    pHalData->EEPROMBluetoothAntNum = 0U;
#line 1727
    pHalData->EEPROMBluetoothAntIsolation = 0U;
#line 1728
    pHalData->EEPROMBluetoothRadioShared = 0U;
  }
#line 1731
  rtl8723a_BT_init_hal_vars(padapter);
#line 1732
  return;
}
}
#line 1735 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void Hal_EfuseParseEEPROMVer(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1738
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1740
  if (! AutoLoadFail) {
#line 1741
    pHalData->EEPROMVersion = *(hwinfo + 48UL);
  } else {
#line 1743
    pHalData->EEPROMVersion = 1U;
  }
#line 1744
  if (GlobalDebugLevel23A > 6U) {
#line 1744
    rt_trace(32768, 7, "Hal_EfuseParseEEPROMVer(), EEVer = %d\n", (int )pHalData->EEPROMVersion);
  } else {

  }
#line 1745
  return;
}
}
#line 1750 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void rtl8723a_EfuseParseChnlPlan(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) 
{ 


  {
#line 1753
  padapter->mlmepriv.ChannelPlan = hal_com_get_channel_plan23a(padapter, (unsigned long )hwinfo != (unsigned long )((u8 *)0U) ? (int )*(hwinfo + 40UL) : 255,
                                                               (int )padapter->registrypriv.channel_plan,
                                                               10, (int )AutoLoadFail);
#line 1760
  if (GlobalDebugLevel23A > 3U) {
#line 1760
    printk("\016RTL8723AU: mlmepriv.ChannelPlan = 0x%02x\n", (int )padapter->mlmepriv.ChannelPlan);
  } else {

  }
#line 1761
  return;
}
}
#line 1765 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void Hal_EfuseParseCustomerID(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1768
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1770
  if (! AutoLoadFail) {
#line 1771
    pHalData->EEPROMCustomerID = *(hwinfo + 49UL);
#line 1772
    pHalData->EEPROMSubCustomerID = *(hwinfo + 50UL);
  } else {
#line 1775
    pHalData->EEPROMCustomerID = 0U;
#line 1776
    pHalData->EEPROMSubCustomerID = 0U;
  }
#line 1778
  if (GlobalDebugLevel23A > 6U) {
#line 1778
    rt_trace(32768, 7, "EEPROM Customer ID: 0x%2x\n", (int )pHalData->EEPROMCustomerID);
  } else {

  }
#line 1780
  if (GlobalDebugLevel23A > 6U) {
#line 1780
    rt_trace(32768, 7, "EEPROM SubCustomer ID: 0x%02x\n", (int )pHalData->EEPROMSubCustomerID);
  } else {

  }
#line 1781
  return;
}
}
#line 1786 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void Hal_EfuseParseAntennaDiversity(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) 
{ 


  {
#line 1788
  return;
}
}
#line 1792 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void Hal_EfuseParseRateIndicationOption(struct rtw_adapter *padapter , u8 *hwinfo ,
                                        bool AutoLoadFail ) 
{ 


  {
#line 1794
  return;
}
}
#line 1798 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void Hal_EfuseParseXtal_8723A(struct rtw_adapter *pAdapter , u8 *hwinfo , u8 AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1801
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 1803
  if ((unsigned int )AutoLoadFail == 0U) {
#line 1804
    pHalData->CrystalCap = *(hwinfo + 51UL);
#line 1805
    if ((unsigned int )pHalData->CrystalCap == 255U) {
#line 1806
      pHalData->CrystalCap = 32U;
    } else {

    }
  } else {
#line 1808
    pHalData->CrystalCap = 32U;
  }
#line 1810
  if (GlobalDebugLevel23A > 6U) {
#line 1810
    rt_trace(32768, 7, "%s: CrystalCap = 0x%2x\n", "Hal_EfuseParseXtal_8723A", (int )pHalData->CrystalCap);
  } else {

  }
#line 1811
  return;
}
}
#line 1816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void Hal_EfuseParseThermalMeter_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                      bool AutoloadFail ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1819
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1824
  if (! AutoloadFail) {
#line 1825
    pHalData->EEPROMThermalMeter = *(PROMContent + 42UL);
  } else {
#line 1828
    pHalData->EEPROMThermalMeter = 18U;
  }
#line 1830
  if ((unsigned int )pHalData->EEPROMThermalMeter == 255U || (int )AutoloadFail) {
#line 1831
    pHalData->bAPKThermalMeterIgnore = 1U;
#line 1832
    pHalData->EEPROMThermalMeter = 18U;
  } else {

  }
#line 1835
  if (GlobalDebugLevel23A > 3U) {
#line 1835
    printk("\016RTL8723AU: %s: ThermalMeter = 0x%x\n", "Hal_EfuseParseThermalMeter_8723A",
           (int )pHalData->EEPROMThermalMeter);
  } else {

  }
#line 1836
  return;
}
}
#line 1839 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
static void rtl8723a_cal_txdesc_chksum(struct tx_desc *ptxdesc ) 
{ 
  u16 *usPtr ;
  u32 count ;
  u32 index ;
  u16 checksum ;

  {
#line 1841
  usPtr = (u16 *)ptxdesc;
#line 1842
  count = 16U;
#line 1844
  checksum = 0U;
#line 1847
  ptxdesc->txdw7 = ptxdesc->txdw7 & 4294901760U;
#line 1849
  index = 0U;
#line 1849
  goto ldv_56279;
  ldv_56278: 
#line 1850
  checksum = (u16 )((int )*(usPtr + (unsigned long )index) ^ (int )checksum);
#line 1849
  index = index + 1U;
  ldv_56279: ;
#line 1849
  if (index < count) {
#line 1851
    goto ldv_56278;
  } else {

  }
#line 1852
  ptxdesc->txdw7 = ptxdesc->txdw7 | (__le32 )checksum;
#line 1853
  return;
}
}
#line 1863 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void rtl8723a_fill_fake_txdesc(struct rtw_adapter *padapter , u8 *pDesc , u32 BufferLen ,
                               u8 IsPsPoll , u8 IsBTQosNull ) 
{ 
  struct tx_desc *ptxdesc ;

  {
#line 1869
  ptxdesc = (struct tx_desc *)pDesc;
#line 1870
  memset((void *)pDesc, 0, 32UL);
#line 1874
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2348810240U;
#line 1877
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2097152U;
#line 1881
  ptxdesc->txdw0 = ptxdesc->txdw0 | (BufferLen & 65535U);
#line 1885
  ptxdesc->txdw1 = ptxdesc->txdw1 | 4608U;
#line 1889
  if ((unsigned int )IsPsPoll != 0U) {
#line 1890
    ptxdesc->txdw1 = ptxdesc->txdw1 | 1048576U;
  } else {
#line 1893
    ptxdesc->txdw4 = ptxdesc->txdw4 | 128U;
#line 1895
    ptxdesc->txdw3 = ptxdesc->txdw3 | 2147483648U;
  }
#line 1898
  if ((unsigned int )IsBTQosNull == 1U) {
#line 1899
    ptxdesc->txdw2 = ptxdesc->txdw2 | 8388608U;
  } else {

  }
#line 1902
  ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
#line 1908
  rtl8723a_cal_txdesc_chksum(ptxdesc);
#line 1909
  return;
}
}
#line 1911 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void hw_var_set_opmode(struct rtw_adapter *padapter , u8 mode ) 
{ 
  u8 val8 ;

  {
#line 1915
  if ((unsigned int )mode == 2U || (unsigned int )mode == 0U) {
#line 1916
    StopTxBeacon(padapter);
#line 1919
    val8 = 25U;
#line 1920
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
  } else
#line 1921
  if ((unsigned int )mode == 1U) {
#line 1922
    ResumeTxBeacon(padapter);
#line 1924
    val8 = 26U;
#line 1925
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
  } else
#line 1926
  if ((unsigned int )mode == 3U) {
#line 1928
    rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd(padapter);
#line 1930
    ResumeTxBeacon(padapter);
#line 1932
    val8 = 18U;
#line 1933
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
#line 1939
    rtl8723au_write32(padapter, 1544, 1879057038U);
#line 1941
    rtl8723au_write16(padapter, 1700, 65535);
#line 1943
    rtl8723au_write16(padapter, 1698, 1024);
#line 1947
    rtl8723au_write8(padapter, 1369, 2);
#line 1949
    rtl8723au_write8(padapter, 1368, 5);
#line 1951
    rtl8723au_write8(padapter, 1370, 10);
#line 1952
    rtl8723au_write16(padapter, 1296, 0);
#line 1953
    rtl8723au_write16(padapter, 1344, 65284);
#line 1955
    rtl8723au_write16(padapter, 1304, 32767);
#line 1958
    rtl8723au_write8(padapter, 1363, 1);
#line 1963
    val8 = 30U;
#line 1965
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
  } else {

  }
#line 1968
  val8 = rtl8723au_read8(padapter, 258);
#line 1969
  val8 = (u8 )(((int )((signed char )val8) & 12) | (int )((signed char )mode));
#line 1970
  rtl8723au_write8(padapter, 258, (int )val8);
#line 1971
  return;
}
}
#line 1973 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void hw_var_set_macaddr(struct rtw_adapter *padapter , u8 *val ) 
{ 
  u8 idx ;
  u32 reg_macid ;

  {
#line 1975
  idx = 0U;
#line 1978
  reg_macid = 1552U;
#line 1980
  idx = 0U;
#line 1980
  goto ldv_56301;
  ldv_56300: 
#line 1981
  rtl8723au_write8(padapter, (int )((u16 )idx) + (int )((u16 )reg_macid), (int )*(val + (unsigned long )idx));
#line 1980
  idx = (u8 )((int )idx + 1);
  ldv_56301: ;
#line 1980
  if ((unsigned int )idx <= 5U) {
#line 1982
    goto ldv_56300;
  } else {

  }

#line 1987
  return;
}
}
#line 1984 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void hw_var_set_bssid(struct rtw_adapter *padapter , u8 *val ) 
{ 
  u8 idx ;
  u32 reg_bssid ;

  {
#line 1986
  idx = 0U;
#line 1989
  reg_bssid = 1560U;
#line 1991
  idx = 0U;
#line 1991
  goto ldv_56310;
  ldv_56309: 
#line 1992
  rtl8723au_write8(padapter, (int )((u16 )idx) + (int )((u16 )reg_bssid), (int )*(val + (unsigned long )idx));
#line 1991
  idx = (u8 )((int )idx + 1);
  ldv_56310: ;
#line 1991
  if ((unsigned int )idx <= 5U) {
#line 1993
    goto ldv_56309;
  } else {

  }

#line 1998
  return;
}
}
#line 1995 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void hw_var_set_correct_tsf(struct rtw_adapter *padapter ) 
{ 
  u64 tsf ;
  u32 reg_tsftr ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  uint32_t __base ;
  uint32_t __rem ;

  {
#line 1999
  pmlmeext = & padapter->mlmeextpriv;
#line 2000
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2005
  __base = (uint32_t )((int )pmlmeinfo->bcn_interval * 1024);
#line 2005
  __rem = (uint32_t )(pmlmeext->TSFValue % (u64 )__base);
#line 2005
  pmlmeext->TSFValue = pmlmeext->TSFValue / (u64 )__base;
#line 2005
  tsf = (pmlmeext->TSFValue - (u64 )__rem) - 1024ULL;
#line 2008
  if ((pmlmeinfo->state & 3U) == 1U || (pmlmeinfo->state & 3U) == 3U) {
#line 2013
    StopTxBeacon(padapter);
  } else {

  }
#line 2016
  reg_tsftr = 1376U;
#line 2019
  SetBcnCtrlReg23a(padapter, 0, 8);
#line 2021
  rtl8723au_write32(padapter, (int )((u16 )reg_tsftr), (u32 )tsf);
#line 2022
  rtl8723au_write32(padapter, (int )((unsigned int )((u16 )reg_tsftr) + 4U), (u32 )(tsf >> 32));
#line 2025
  SetBcnCtrlReg23a(padapter, 8, 0);
#line 2027
  if ((pmlmeinfo->state & 3U) == 1U || (pmlmeinfo->state & 3U) == 3U) {
#line 2029
    ResumeTxBeacon(padapter);
  } else {

  }
#line 2030
  return;
}
}
#line 2032 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void hw_var_set_mlme_disconnect(struct rtw_adapter *padapter ) 
{ 


  {
#line 2035
  rtl8723au_write16(padapter, 1700, 0);
#line 2038
  rtl8723au_write8(padapter, 1363, 1);
#line 2041
  SetBcnCtrlReg23a(padapter, 16, 0);
#line 2042
  return;
}
}
#line 2044 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.c"
void hw_var_set_mlme_join(struct rtw_adapter *padapter , u8 type ) 
{ 
  u8 RetryLimit ;
  struct hal_data_8723a *pHalData ;
  struct mlme_priv *pmlmepriv ;
  u32 v32 ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 2046
  RetryLimit = 48U;
#line 2048
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 2049
  pmlmepriv = & padapter->mlmepriv;
#line 2051
  if ((unsigned int )type == 0U) {
#line 2057
    rtl8723au_write16(padapter, 1700, 65535);
#line 2059
    v32 = rtl8723au_read32(padapter, 1544);
#line 2060
    v32 = v32 | 192U;
#line 2061
    rtl8723au_write32(padapter, 1544, v32);
#line 2063
    tmp = check_fwstate(pmlmepriv, 8);
#line 2063
    if ((int )tmp) {
#line 2064
      RetryLimit = (unsigned int )pHalData->CustomerID == 18U ? 7U : 48U;
    } else {
#line 2067
      RetryLimit = 7U;
    }
  } else
#line 2068
  if ((unsigned int )type == 1U) {
#line 2071
    rtl8723au_write16(padapter, 1700, 0);
  } else
#line 2072
  if ((unsigned int )type == 2U) {
#line 2074
    SetBcnCtrlReg23a(padapter, 0, 16);
#line 2076
    tmp___0 = check_fwstate(pmlmepriv, 96);
#line 2076
    if ((int )tmp___0) {
#line 2079
      rtl8723au_write8(padapter, 1346, 2);
#line 2080
      RetryLimit = 7U;
    } else {

    }
  } else {

  }
#line 2084
  rtl8723au_write16(padapter, 1066, (int )((u16 )((int )((short )((int )RetryLimit << 8)) | (int )((short )RetryLimit))));
#line 2088
  switch ((int )type) {
  case 0: 
#line 2091
  rtl8723a_BT_wifiassociate_notify(padapter, 1);
#line 2092
  goto ldv_56334;
  case 1: 
#line 2095
  rtl8723a_BT_wifiassociate_notify(padapter, 0);
#line 2096
  goto ldv_56334;
  case 2: ;
#line 2100
  goto ldv_56334;
  }
  ldv_56334: ;
#line 2103
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
bool ldv_queue_work_on_495(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
bool ldv_queue_delayed_work_on_496(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
bool ldv_queue_work_on_497(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void ldv_flush_workqueue_498(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
bool ldv_queue_delayed_work_on_499(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_509(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_511(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_510(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_513(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_512(struct workqueue_struct *ldv_func_arg1 ) ;
#line 124 "drivers/staging/rtl8723au/include/Hal8723APhyCfg.h"
void PHY_SetTxPowerLevel8723A(struct rtw_adapter *Adapter , u8 channel ) ;
#line 159
int PHY_BBConfig8723A(struct rtw_adapter *Adapter ) ;
#line 160
s32 PHY_MACConfig8723A(struct rtw_adapter *Adapter ) ;
#line 47 "drivers/staging/rtl8723au/include/rtl8723a_rf.h"
void rtl8723a_phy_rf6052set_bw(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ) ;
#line 49
void rtl823a_phy_rf6052setccktxpower(struct rtw_adapter *Adapter , u8 *pPowerlevel ) ;
#line 51
void rtl8723a_PHY_RF6052SetOFDMTxPower(struct rtw_adapter *Adapter , u8 *pPowerLevel ,
                                       u8 Channel ) ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
static u32 phy_CalculateBitShift(u32 BitMask ) 
{ 
  u32 i ;

  {
#line 61
  i = 0U;
#line 61
  goto ldv_55750;
  ldv_55749: ;
#line 62
  if ((int )(BitMask >> (int )i) & 1) {
#line 63
    goto ldv_55748;
  } else {

  }
#line 61
  i = i + 1U;
  ldv_55750: ;
#line 61
  if (i <= 31U) {
#line 63
    goto ldv_55749;
  } else {

  }
  ldv_55748: ;
#line 66
  return (i);
}
}
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
u32 PHY_QueryBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask ) 
{ 
  u32 ReturnValue ;
  u32 OriginalValue ;
  u32 BitShift ;

  {
#line 89
  ReturnValue = 0U;
#line 91
  OriginalValue = rtl8723au_read32(Adapter, (int )((u16 )RegAddr));
#line 92
  BitShift = phy_CalculateBitShift(BitMask);
#line 93
  ReturnValue = (OriginalValue & BitMask) >> (int )BitShift;
#line 94
  return (ReturnValue);
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
void PHY_SetBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask , u32 Data ) 
{ 
  u32 OriginalValue ;
  u32 BitShift ;

  {
#line 124
  if (BitMask != 4294967295U) {
#line 125
    OriginalValue = rtl8723au_read32(Adapter, (int )((u16 )RegAddr));
#line 126
    BitShift = phy_CalculateBitShift(BitMask);
#line 127
    Data = (~ BitMask & OriginalValue) | (Data << (int )BitShift);
  } else {

  }
#line 130
  rtl8723au_write32(Adapter, (int )((u16 )RegAddr), Data);
#line 131
  return;
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
static u32 phy_RFSerialRead(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath ,
                            u32 Offset ) 
{ 
  u32 retValue ;
  struct hal_data_8723a *pHalData ;
  struct bb_reg_define *pPhyReg ;
  u32 NewOffset ;
  u32 tmplong ;
  u32 tmplong2 ;
  u8 RfPiEnable ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 163
  retValue = 0U;
#line 164
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 165
  pPhyReg = (struct bb_reg_define *)(& pHalData->PHYRegDef) + (unsigned long )eRFPath;
#line 168
  RfPiEnable = 0U;
#line 172
  Offset = Offset & 63U;
#line 177
  NewOffset = Offset;
#line 190
  tmplong = rtl8723au_read32(Adapter, 2084);
#line 191
  if ((unsigned int )eRFPath == 0U) {
#line 192
    tmplong2 = tmplong;
  } else {
#line 194
    tmplong2 = rtl8723au_read32(Adapter, (int )((u16 )pPhyReg->rfHSSIPara2));
  }
#line 196
  tmplong2 = ((tmplong2 & 2155872255U) | (NewOffset << 23)) | 2147483648U;
#line 199
  rtl8723au_write32(Adapter, 2084, tmplong & 2147483647U);
#line 201
  __const_udelay(42950UL);
#line 203
  rtl8723au_write32(Adapter, (int )((u16 )pPhyReg->rfHSSIPara2), tmplong2);
#line 204
  __const_udelay(429500UL);
#line 206
  rtl8723au_write32(Adapter, 2084, tmplong | 2147483648U);
#line 208
  __const_udelay(42950UL);
#line 210
  if ((unsigned int )eRFPath == 0U) {
#line 211
    tmp = PHY_QueryBBReg(Adapter, 2080U, 256U);
#line 211
    RfPiEnable = (unsigned char )tmp;
  } else
#line 214
  if ((unsigned int )eRFPath == 1U) {
#line 215
    tmp___0 = PHY_QueryBBReg(Adapter, 2088U, 256U);
#line 215
    RfPiEnable = (unsigned char )tmp___0;
  } else {

  }
#line 219
  if ((unsigned int )RfPiEnable != 0U) {
#line 221
    retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBackPi, 1048575U);
  } else {
#line 226
    retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBack, 1048575U);
  }
#line 232
  return (retValue);
}
}
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
static void phy_RFSerialWrite(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath ,
                              u32 Offset , u32 Data ) 
{ 
  u32 DataAndAddr ;
  struct hal_data_8723a *pHalData ;
  struct bb_reg_define *pPhyReg ;
  u32 NewOffset ;

  {
#line 283
  DataAndAddr = 0U;
#line 284
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 285
  pPhyReg = (struct bb_reg_define *)(& pHalData->PHYRegDef) + (unsigned long )eRFPath;
#line 296
  Offset = Offset & 63U;
#line 306
  NewOffset = Offset;
#line 313
  DataAndAddr = ((NewOffset << 20) | (Data & 1048575U)) & 268435455U;
#line 318
  rtl8723au_write32(Adapter, (int )((u16 )pPhyReg->rf3wireOffset), DataAndAddr);
#line 319
  return;
}
}
#line 341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
u32 PHY_QueryRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                   u32 BitMask ) 
{ 
  u32 Original_Value ;
  u32 Readback_Value ;
  u32 BitShift ;

  {
#line 349
  Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
#line 351
  BitShift = phy_CalculateBitShift(BitMask);
#line 352
  Readback_Value = (Original_Value & BitMask) >> (int )BitShift;
#line 354
  return (Readback_Value);
}
}
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
void PHY_SetRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data ) 
{ 
  u32 Original_Value ;
  u32 BitShift ;

  {
#line 386
  if (BitMask != 1048575U) {
#line 387
    Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
#line 388
    BitShift = phy_CalculateBitShift(BitMask);
#line 389
    Data = (~ BitMask & Original_Value) | (Data << (int )BitShift);
  } else {

  }
#line 392
  phy_RFSerialWrite(Adapter, eRFPath, RegAddr, Data);
#line 393
  return;
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
s32 PHY_MACConfig8723A(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 415
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 420
  ODM_ReadAndConfig_MAC_REG_8723A(& pHalData->odmpriv);
#line 423
  rtl8723au_write8(Adapter, 1226, 10);
#line 424
  if ((unsigned int )pHalData->rf_type == 2U && (unsigned int )pHalData->BoardType == 0U) {
#line 426
    rtl8723au_write8(Adapter, 64, 4);
  } else {

  }
#line 428
  return (1);
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
static void phy_InitBBRFRegisterDefinition(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 447
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 451
  pHalData->PHYRegDef[0].rfintfs = 2160U;
#line 453
  pHalData->PHYRegDef[1].rfintfs = 2160U;
#line 457
  pHalData->PHYRegDef[0].rfintfi = 2272U;
#line 459
  pHalData->PHYRegDef[1].rfintfi = 2272U;
#line 463
  pHalData->PHYRegDef[0].rfintfo = 2144U;
#line 465
  pHalData->PHYRegDef[1].rfintfo = 2148U;
#line 469
  pHalData->PHYRegDef[0].rfintfe = 2144U;
#line 471
  pHalData->PHYRegDef[1].rfintfe = 2148U;
#line 474
  pHalData->PHYRegDef[0].rf3wireOffset = 2112U;
#line 475
  pHalData->PHYRegDef[1].rf3wireOffset = 2116U;
#line 479
  pHalData->PHYRegDef[0].rfLSSI_Select = 2168U;
#line 480
  pHalData->PHYRegDef[1].rfLSSI_Select = 2168U;
#line 483
  pHalData->PHYRegDef[0].rfTxGainStage = 2060U;
#line 484
  pHalData->PHYRegDef[1].rfTxGainStage = 2060U;
#line 488
  pHalData->PHYRegDef[0].rfHSSIPara1 = 2080U;
#line 490
  pHalData->PHYRegDef[1].rfHSSIPara1 = 2088U;
#line 494
  pHalData->PHYRegDef[0].rfHSSIPara2 = 2084U;
#line 496
  pHalData->PHYRegDef[1].rfHSSIPara2 = 2092U;
#line 499
  pHalData->PHYRegDef[0].rfSwitchControl = 2136U;
#line 501
  pHalData->PHYRegDef[1].rfSwitchControl = 2136U;
#line 505
  pHalData->PHYRegDef[0].rfAGCControl1 = 3152U;
#line 506
  pHalData->PHYRegDef[1].rfAGCControl1 = 3160U;
#line 509
  pHalData->PHYRegDef[0].rfAGCControl2 = 3156U;
#line 510
  pHalData->PHYRegDef[1].rfAGCControl2 = 3164U;
#line 513
  pHalData->PHYRegDef[0].rfRxIQImbalance = 3092U;
#line 514
  pHalData->PHYRegDef[1].rfRxIQImbalance = 3100U;
#line 517
  pHalData->PHYRegDef[0].rfRxAFE = 3088U;
#line 518
  pHalData->PHYRegDef[1].rfRxAFE = 3096U;
#line 521
  pHalData->PHYRegDef[0].rfTxIQImbalance = 3200U;
#line 522
  pHalData->PHYRegDef[1].rfTxIQImbalance = 3208U;
#line 525
  pHalData->PHYRegDef[0].rfTxAFE = 3204U;
#line 526
  pHalData->PHYRegDef[1].rfTxAFE = 3212U;
#line 529
  pHalData->PHYRegDef[0].rfLSSIReadBack = 2208U;
#line 530
  pHalData->PHYRegDef[1].rfLSSIReadBack = 2212U;
#line 533
  pHalData->PHYRegDef[0].rfLSSIReadBackPi = 2232U;
#line 535
  pHalData->PHYRegDef[1].rfLSSIReadBackPi = 2236U;
#line 536
  return;
}
}
#line 541 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
static void storePwrIndexDiffRateOffset(struct rtw_adapter *Adapter , u32 RegAddr ,
                                        u32 BitMask , u32 Data ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 544
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 546
  if (RegAddr == 3584U) {
#line 547
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][0] = Data;
  } else {

  }
#line 549
  if (RegAddr == 3588U) {
#line 550
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][1] = Data;
  } else {

  }
#line 552
  if (RegAddr == 3592U) {
#line 553
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][6] = Data;
  } else {

  }
#line 555
  if (RegAddr == 2156U && BitMask == 4294967040U) {
#line 556
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][7] = Data;
  } else {

  }
#line 558
  if (RegAddr == 3600U) {
#line 559
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][2] = Data;
  } else {

  }
#line 561
  if (RegAddr == 3604U) {
#line 562
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][3] = Data;
  } else {

  }
#line 564
  if (RegAddr == 3608U) {
#line 565
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][4] = Data;
  } else {

  }
#line 567
  if (RegAddr == 3612U) {
#line 568
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][5] = Data;
  } else {

  }
#line 570
  if (RegAddr == 2096U) {
#line 571
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][8] = Data;
  } else {

  }
#line 573
  if (RegAddr == 2100U) {
#line 574
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][9] = Data;
  } else {

  }
#line 576
  if (RegAddr == 2104U) {
#line 577
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][14] = Data;
  } else {

  }
#line 579
  if (RegAddr == 2156U && BitMask == 255U) {
#line 580
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][15] = Data;
  } else {

  }
#line 582
  if (RegAddr == 2108U) {
#line 583
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][10] = Data;
  } else {

  }
#line 585
  if (RegAddr == 2120U) {
#line 586
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][11] = Data;
  } else {

  }
#line 588
  if (RegAddr == 2124U) {
#line 589
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][12] = Data;
  } else {

  }
#line 591
  if (RegAddr == 2152U) {
#line 592
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][13] = Data;
#line 593
    pHalData->pwrGroupCnt = (u8 )((int )pHalData->pwrGroupCnt + 1);
  } else {

  }
#line 595
  return;
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
static int phy_ConfigBBWithPgHeaderFile(struct rtw_adapter *Adapter ) 
{ 
  int i ;
  u32 *Rtl819XPHY_REGArray_Table_PG ;
  u16 PHY_REGArrayPGLen ;

  {
#line 620
  PHY_REGArrayPGLen = 336U;
#line 621
  Rtl819XPHY_REGArray_Table_PG = (u32 *)(& Rtl8723UPHY_REG_Array_PG);
#line 623
  i = 0;
#line 623
  goto ldv_55829;
  ldv_55828: 
#line 624
  storePwrIndexDiffRateOffset(Adapter, *(Rtl819XPHY_REGArray_Table_PG + (unsigned long )i),
                              *(Rtl819XPHY_REGArray_Table_PG + ((unsigned long )i + 1UL)),
                              *(Rtl819XPHY_REGArray_Table_PG + ((unsigned long )i + 2UL)));
#line 623
  i = i + 3;
  ldv_55829: ;
#line 623
  if ((int )PHY_REGArrayPGLen > i) {
#line 625
    goto ldv_55828;
  } else {

  }

#line 630
  return (1);
}
}
#line 634 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
static void phy_BB8192C_Config_1T(struct rtw_adapter *Adapter ) 
{ 


  {
#line 637
  PHY_SetBBReg(Adapter, 2052U, 3U, 2U);
#line 638
  PHY_SetBBReg(Adapter, 2316U, 3145779U, 2097186U);
#line 642
  PHY_SetBBReg(Adapter, 2564U, 4278190080U, 69U);
#line 643
  PHY_SetBBReg(Adapter, 3076U, 255U, 35U);
#line 645
  PHY_SetBBReg(Adapter, 3184U, 48U, 1U);
#line 647
  PHY_SetBBReg(Adapter, 3700U, 201326592U, 2U);
#line 648
  PHY_SetBBReg(Adapter, 3704U, 201326592U, 2U);
#line 649
  PHY_SetBBReg(Adapter, 3708U, 201326592U, 2U);
#line 650
  PHY_SetBBReg(Adapter, 3712U, 201326592U, 2U);
#line 651
  PHY_SetBBReg(Adapter, 3720U, 201326592U, 2U);
#line 652
  return;
}
}
#line 655 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
static int phy_BB8723a_Config_ParaFile(struct rtw_adapter *Adapter ) 
{ 
  struct eeprom_priv *pEEPROM ;
  struct hal_data_8723a *pHalData ;
  int rtStatus ;

  {
#line 657
  pEEPROM = & Adapter->eeprompriv;
#line 658
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 659
  rtStatus = 1;
#line 665
  ODM_ReadAndConfig_PHY_REG_1T_8723A(& pHalData->odmpriv);
#line 670
  if ((unsigned int )pHalData->rf_type == 0U) {
#line 671
    phy_BB8192C_Config_1T(Adapter);
#line 672
    if (GlobalDebugLevel23A > 3U) {
#line 672
      printk("\016RTL8723AU: phy_BB8723a_Config_ParaFile():Config to 1T!!\n");
    } else {

    }
  } else {

  }
#line 679
  if ((unsigned int )pEEPROM->bautoload_fail_flag == 0U) {
#line 680
    pHalData->pwrGroupCnt = 0U;
#line 682
    rtStatus = phy_ConfigBBWithPgHeaderFile(Adapter);
  } else {

  }
#line 685
  if (rtStatus != 1) {
#line 686
    goto phy_BB8190_Config_ParaFile_Fail;
  } else {

  }
#line 691
  ODM_ReadAndConfig_AGC_TAB_1T_8723A(& pHalData->odmpriv);
  phy_BB8190_Config_ParaFile_Fail: ;
#line 695
  return (rtStatus);
}
}
#line 699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
int PHY_BBConfig8723A(struct rtw_adapter *Adapter ) 
{ 
  int rtStatus ;
  struct hal_data_8723a *pHalData ;
  u8 TmpU1B ;
  u8 CrystalCap ;

  {
#line 701
  rtStatus = 1;
#line 702
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 703
  TmpU1B = 0U;
#line 706
  phy_InitBBRFRegisterDefinition(Adapter);
#line 710
  TmpU1B = rtl8723au_read8(Adapter, 40);
#line 711
  __const_udelay(8590UL);
#line 712
  rtl8723au_write8(Adapter, 40, (int )((unsigned int )TmpU1B | 2U));
#line 713
  __const_udelay(8590UL);
#line 716
  rtl8723au_write8(Adapter, 41, 255);
#line 717
  __const_udelay(8590UL);
#line 720
  TmpU1B = rtl8723au_read8(Adapter, 2);
#line 721
  rtl8723au_write8(Adapter, 2, (int )((unsigned int )TmpU1B | 3U));
#line 725
  TmpU1B = rtl8723au_read8(Adapter, 37);
#line 726
  rtl8723au_write8(Adapter, 37, (int )TmpU1B & 191);
#line 729
  TmpU1B = rtl8723au_read8(Adapter, 38);
#line 730
  rtl8723au_write8(Adapter, 38, (int )TmpU1B & 239);
#line 733
  rtl8723au_write8(Adapter, 31, 7);
#line 738
  rtStatus = phy_BB8723a_Config_ParaFile(Adapter);
#line 741
  if ((unsigned int )pHalData->EEPROMVersion != 0U) {
#line 742
    CrystalCap = (unsigned int )pHalData->CrystalCap & 63U;
#line 743
    PHY_SetBBReg(Adapter, 44U, 16773120U, (u32 )((int )CrystalCap | ((int )CrystalCap << 6)));
  } else {

  }
#line 747
  rtl8723au_write32(Adapter, 32, 22488325U);
#line 748
  return (rtStatus);
}
}
#line 751 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
static void getTxPowerIndex(struct rtw_adapter *Adapter , u8 channel , u8 *cckPowerLevel ,
                            u8 *ofdmPowerLevel ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 index ;

  {
#line 754
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 755
  index = (unsigned int )channel + 255U;
#line 757
  *cckPowerLevel = pHalData->TxPwrLevelCck[0][(int )index];
#line 758
  *(cckPowerLevel + 1UL) = pHalData->TxPwrLevelCck[1][(int )index];
#line 761
  if ((unsigned int )((struct hal_data_8723a *)Adapter->HalData)->rf_type == 0U || (unsigned int )((struct hal_data_8723a *)Adapter->HalData)->rf_type == 3U) {
#line 763
    *ofdmPowerLevel = pHalData->TxPwrLevelHT40_1S[0][(int )index];
#line 765
    *(ofdmPowerLevel + 1UL) = pHalData->TxPwrLevelHT40_1S[1][(int )index];
  } else
#line 767
  if ((unsigned int )((struct hal_data_8723a *)Adapter->HalData)->rf_type == 2U) {
#line 769
    *ofdmPowerLevel = pHalData->TxPwrLevelHT40_2S[0][(int )index];
#line 771
    *(ofdmPowerLevel + 1UL) = pHalData->TxPwrLevelHT40_2S[1][(int )index];
  } else {

  }
#line 774
  return;
}
}
#line 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
static void ccxPowerIndexCheck(struct rtw_adapter *Adapter , u8 channel , u8 *cckPowerLevel ,
                               u8 *ofdmPowerLevel ) 
{ 


  {
#line 778
  return;
}
}
#line 795 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
void PHY_SetTxPowerLevel8723A(struct rtw_adapter *Adapter , u8 channel ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 cckPowerLevel[2U] ;
  u8 ofdmPowerLevel[2U] ;

  {
#line 797
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 800
  if ((unsigned int )pHalData->bTXPowerDataReadFromEEPORM == 0U) {
#line 801
    return;
  } else {

  }
#line 803
  getTxPowerIndex(Adapter, (int )channel, (u8 *)(& cckPowerLevel), (u8 *)(& ofdmPowerLevel));
#line 806
  ccxPowerIndexCheck(Adapter, (int )channel, (u8 *)(& cckPowerLevel), (u8 *)(& ofdmPowerLevel));
#line 809
  rtl823a_phy_rf6052setccktxpower(Adapter, (u8 *)(& cckPowerLevel));
#line 810
  rtl8723a_PHY_RF6052SetOFDMTxPower(Adapter, (u8 *)(& ofdmPowerLevel), (int )channel);
#line 811
  return;
}
}
#line 830 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
static void _PHY_SetBWMode23a92C(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 regBwOpMode ;
  u8 regRRSR_RSC ;

  {
#line 832
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 836
  if (Adapter->bDriverStopped != 0) {
#line 837
    return;
  } else {

  }
#line 843
  regBwOpMode = rtl8723au_read8(Adapter, 1539);
#line 844
  regRRSR_RSC = rtl8723au_read8(Adapter, 1090);
#line 846
  switch ((unsigned int )pHalData->CurrentChannelBW) {
  case 0U: 
#line 848
  regBwOpMode = (u8 )((unsigned int )regBwOpMode | 4U);
#line 849
  rtl8723au_write8(Adapter, 1539, (int )regBwOpMode);
#line 850
  goto ldv_55876;
  case 1U: 
#line 852
  regBwOpMode = (unsigned int )regBwOpMode & 251U;
#line 853
  rtl8723au_write8(Adapter, 1539, (int )regBwOpMode);
#line 854
  regRRSR_RSC = (u8 )(((int )((signed char )regRRSR_RSC) & -112) | (int )((signed char )((int )pHalData->nCur40MhzPrimeSC << 5)));
#line 856
  rtl8723au_write8(Adapter, 1090, (int )regRRSR_RSC);
#line 857
  goto ldv_55876;
  default: ;
#line 860
  goto ldv_55876;
  }
  ldv_55876: ;
#line 866
  switch ((unsigned int )pHalData->CurrentChannelBW) {
  case 0U: 
#line 869
  PHY_SetBBReg(Adapter, 2048U, 1U, 0U);
#line 870
  PHY_SetBBReg(Adapter, 2304U, 1U, 0U);
#line 871
  PHY_SetBBReg(Adapter, 2180U, 1024U, 1U);
#line 873
  goto ldv_55880;
  case 1U: 
#line 877
  PHY_SetBBReg(Adapter, 2048U, 1U, 1U);
#line 878
  PHY_SetBBReg(Adapter, 2304U, 1U, 1U);
#line 882
  PHY_SetBBReg(Adapter, 2560U, 16U, (u32 )((int )pHalData->nCur40MhzPrimeSC >> 1));
#line 884
  PHY_SetBBReg(Adapter, 3328U, 3072U, (u32 )pHalData->nCur40MhzPrimeSC);
#line 886
  PHY_SetBBReg(Adapter, 2180U, 1024U, 0U);
#line 888
  PHY_SetBBReg(Adapter, 2072U, 201326592U, (unsigned int )pHalData->nCur40MhzPrimeSC == 1U ? 2U : 1U);
#line 891
  goto ldv_55880;
  default: ;
#line 894
  goto ldv_55880;
  }
  ldv_55880: 
#line 904
  rtl8723a_phy_rf6052set_bw(Adapter, pHalData->CurrentChannelBW);
#line 905
  return;
}
}
#line 922 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
void PHY_SetBWMode23a8723A(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ,
                           unsigned char Offset ) 
{ 
  struct hal_data_8723a *pHalData ;
  enum ht_channel_width tmpBW ;

  {
#line 925
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 926
  tmpBW = pHalData->CurrentChannelBW;
#line 928
  pHalData->CurrentChannelBW = Bandwidth;
#line 930
  pHalData->nCur40MhzPrimeSC = Offset;
#line 932
  if (Adapter->bDriverStopped == 0 && Adapter->bSurpriseRemoved == 0) {
#line 933
    _PHY_SetBWMode23a92C(Adapter);
  } else {
#line 935
    pHalData->CurrentChannelBW = tmpBW;
  }
#line 936
  return;
}
}
#line 938 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
static void _PHY_SwChnl8723A(struct rtw_adapter *Adapter , u8 channel ) 
{ 
  enum RF_RADIO_PATH eRFPath ;
  u32 param1 ;
  u32 param2 ;
  struct hal_data_8723a *pHalData ;

  {
#line 942
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 945
  PHY_SetTxPowerLevel8723A(Adapter, (int )channel);
#line 949
  param1 = 24U;
#line 950
  param2 = (u32 )channel;
#line 951
  eRFPath = 0;
#line 951
  goto ldv_55899;
  ldv_55898: 
#line 952
  pHalData->RfRegChnlVal[(unsigned int )eRFPath] = (pHalData->RfRegChnlVal[(unsigned int )eRFPath] & 4294966272U) | param2;
#line 954
  PHY_SetRFReg(Adapter, eRFPath, param1, 1048575U, pHalData->RfRegChnlVal[(unsigned int )eRFPath]);
#line 951
  eRFPath = (enum RF_RADIO_PATH )((unsigned int )eRFPath + 1U);
  ldv_55899: ;
#line 951
  if ((unsigned int )pHalData->NumTotalRFPath > (unsigned int )eRFPath) {
#line 953
    goto ldv_55898;
  } else {

  }

#line 958
  return;
}
}
#line 961 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.c"
void PHY_SwChnl8723A(struct rtw_adapter *Adapter , u8 channel ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tmpchannel ;
  bool result ;

  {
#line 963
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 964
  tmpchannel = pHalData->CurrentChannel;
#line 965
  result = 1;
#line 967
  if ((unsigned int )channel == 0U) {
#line 968
    channel = 1U;
  } else {

  }
#line 970
  pHalData->CurrentChannel = channel;
#line 972
  if (Adapter->bDriverStopped == 0 && Adapter->bSurpriseRemoved == 0) {
#line 973
    _PHY_SwChnl8723A(Adapter, (int )channel);
#line 975
    if (! result) {
#line 976
      pHalData->CurrentChannel = tmpchannel;
    } else {

    }
  } else {
#line 978
    pHalData->CurrentChannel = tmpchannel;
  }
#line 979
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
bool ldv_queue_work_on_509(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
bool ldv_queue_delayed_work_on_510(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
bool ldv_queue_work_on_511(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
void ldv_flush_workqueue_512(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
bool ldv_queue_delayed_work_on_513(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_523(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_525(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_524(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_527(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_526(struct workqueue_struct *ldv_func_arg1 ) ;
#line 56 "drivers/staging/rtl8723au/include/rtl8723a_rf.h"
int PHY_RF6052_Config8723A(struct rtw_adapter *Adapter ) ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.c"
void rtl8723a_phy_rf6052set_bw(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 62
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 64
  switch ((unsigned int )Bandwidth) {
  case 0U: 
#line 66
  pHalData->RfRegChnlVal[0] = (pHalData->RfRegChnlVal[0] & 4294964223U) | 1024U;
#line 68
  PHY_SetRFReg(Adapter, 0, 24U, 1048575U, pHalData->RfRegChnlVal[0]);
#line 70
  goto ldv_55750;
  case 1U: 
#line 72
  pHalData->RfRegChnlVal[0] = pHalData->RfRegChnlVal[0] & 4294964223U;
#line 74
  PHY_SetRFReg(Adapter, 0, 24U, 1048575U, pHalData->RfRegChnlVal[0]);
#line 76
  goto ldv_55750;
  default: ;
#line 78
  goto ldv_55750;
  }
  ldv_55750: ;
#line 81
  return;
}
}
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.c"
void rtl823a_phy_rf6052setccktxpower(struct rtw_adapter *Adapter , u8 *pPowerlevel ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct mlme_ext_priv *pmlmeext ;
  u32 TxAGC[2U] ;
  u32 tmpval ;
  bool TurboScanOff ;
  u8 idx1 ;
  u8 idx2 ;
  u8 *ptr ;

  {
#line 102
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 103
  pdmpriv = & pHalData->dmpriv;
#line 104
  pmlmeext = & Adapter->mlmeextpriv;
#line 105
  TxAGC[0] = 0U;
#line 105
  TxAGC[1] = 0U;
#line 105
  tmpval = 0U;
#line 106
  TurboScanOff = 0;
#line 113
  if ((unsigned int )pHalData->EEPROMRegulatory != 0U || (unsigned int )pHalData->ExternalPA != 0U) {
#line 114
    TurboScanOff = 1;
  } else {

  }
#line 116
  if (pmlmeext->sitesurvey_res.state == 3) {
#line 117
    TxAGC[0] = 1061109567U;
#line 118
    TxAGC[1] = 1061109567U;
#line 120
    TurboScanOff = 1;
#line 122
    if ((int )TurboScanOff) {
#line 123
      idx1 = 0U;
#line 123
      goto ldv_55767;
      ldv_55766: 
#line 124
      TxAGC[(int )idx1] = (u32 )((((int )*(pPowerlevel + (unsigned long )idx1) | ((int )*(pPowerlevel + (unsigned long )idx1) << 8)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 16)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 24));
#line 131
      if (TxAGC[(int )idx1] > 32U && (unsigned int )pHalData->ExternalPA != 0U) {
#line 132
        TxAGC[(int )idx1] = 32U;
      } else {

      }
#line 123
      idx1 = (u8 )((int )idx1 + 1);
      ldv_55767: ;
#line 123
      if ((unsigned int )idx1 <= 1U) {
#line 125
        goto ldv_55766;
      } else {

      }

    } else {

    }
  } else
#line 142
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 1U) {
#line 143
    TxAGC[0] = 269488144U;
#line 144
    TxAGC[1] = 269488144U;
  } else
#line 145
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 2U) {
#line 147
    TxAGC[0] = 0U;
#line 148
    TxAGC[1] = 0U;
  } else {
#line 150
    idx1 = 0U;
#line 150
    goto ldv_55770;
    ldv_55769: 
#line 151
    TxAGC[(int )idx1] = (u32 )((((int )*(pPowerlevel + (unsigned long )idx1) | ((int )*(pPowerlevel + (unsigned long )idx1) << 8)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 16)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 24));
#line 150
    idx1 = (u8 )((int )idx1 + 1);
    ldv_55770: ;
#line 150
    if ((unsigned int )idx1 <= 1U) {
#line 152
      goto ldv_55769;
    } else {

    }

#line 157
    if ((unsigned int )pHalData->EEPROMRegulatory == 0U) {
#line 158
      tmpval = pHalData->MCSTxPowerLevelOriginalOffset[0][6] + (pHalData->MCSTxPowerLevelOriginalOffset[0][7] << 8);
#line 160
      TxAGC[0] = TxAGC[0] + tmpval;
#line 162
      tmpval = pHalData->MCSTxPowerLevelOriginalOffset[0][14] + (pHalData->MCSTxPowerLevelOriginalOffset[0][15] << 24);
#line 164
      TxAGC[1] = TxAGC[1] + tmpval;
    } else {

    }
  }
#line 169
  idx1 = 0U;
#line 169
  goto ldv_55776;
  ldv_55775: 
#line 170
  ptr = (u8 *)(& TxAGC) + (unsigned long )idx1;
#line 171
  idx2 = 0U;
#line 171
  goto ldv_55773;
  ldv_55772: ;
#line 172
  if ((unsigned int )*ptr > 63U) {
#line 173
    *ptr = 63U;
  } else {

  }
#line 174
  ptr = ptr + 1;
#line 171
  idx2 = (u8 )((int )idx2 + 1);
  ldv_55773: ;
#line 171
  if ((unsigned int )idx2 <= 3U) {
#line 173
    goto ldv_55772;
  } else {

  }
#line 169
  idx1 = (u8 )((int )idx1 + 1);
  ldv_55776: ;
#line 169
  if ((unsigned int )idx1 <= 1U) {
#line 171
    goto ldv_55775;
  } else {

  }
#line 179
  tmpval = TxAGC[0] & 255U;
#line 180
  PHY_SetBBReg(Adapter, 3592U, 65280U, tmpval);
#line 181
  tmpval = TxAGC[0] >> 8;
#line 182
  PHY_SetBBReg(Adapter, 2156U, 4294967040U, tmpval);
#line 185
  tmpval = TxAGC[1] >> 24;
#line 186
  PHY_SetBBReg(Adapter, 2156U, 255U, tmpval);
#line 187
  tmpval = TxAGC[1] & 16777215U;
#line 188
  PHY_SetBBReg(Adapter, 2104U, 4294967040U, tmpval);
#line 189
  return;
}
}
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.c"
static void getPowerBase(struct rtw_adapter *Adapter , u8 *pPowerLevel , u8 Channel ,
                         u32 *OfdmBase , u32 *MCSBase ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 powerBase0 ;
  u32 powerBase1 ;
  u8 Legacy_pwrdiff ;
  s8 HT20_pwrdiff ;
  u8 i ;
  u8 powerlevel[2U] ;

  {
#line 196
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 198
  Legacy_pwrdiff = 0U;
#line 199
  HT20_pwrdiff = 0;
#line 202
  i = 0U;
#line 202
  goto ldv_55793;
  ldv_55792: 
#line 203
  powerlevel[(int )i] = *(pPowerLevel + (unsigned long )i);
#line 204
  Legacy_pwrdiff = pHalData->TxPwrLegacyHtDiff[(int )i][(int )Channel + -1];
#line 205
  powerBase0 = (u32 )((int )powerlevel[(int )i] + (int )Legacy_pwrdiff);
#line 207
  powerBase0 = (((powerBase0 << 24) | (powerBase0 << 16)) | (powerBase0 << 8)) | powerBase0;
#line 209
  *(OfdmBase + (unsigned long )i) = powerBase0;
#line 202
  i = (u8 )((int )i + 1);
  ldv_55793: ;
#line 202
  if ((unsigned int )i <= 1U) {
#line 204
    goto ldv_55792;
  } else {

  }
#line 212
  i = 0U;
#line 212
  goto ldv_55796;
  ldv_55795: ;
#line 214
  if ((unsigned int )pHalData->CurrentChannelBW == 0U) {
#line 215
    HT20_pwrdiff = (s8 )pHalData->TxPwrHt20Diff[(int )i][(int )Channel + -1];
#line 216
    powerlevel[(int )i] = (int )powerlevel[(int )i] + (int )((u8 )HT20_pwrdiff);
  } else {

  }
#line 218
  powerBase1 = (u32 )powerlevel[(int )i];
#line 219
  powerBase1 = (((powerBase1 << 24) | (powerBase1 << 16)) | (powerBase1 << 8)) | powerBase1;
#line 221
  *(MCSBase + (unsigned long )i) = powerBase1;
#line 212
  i = (u8 )((int )i + 1);
  ldv_55796: ;
#line 212
  if ((unsigned int )i <= 1U) {
#line 214
    goto ldv_55795;
  } else {

  }

#line 219
  return;
}
}
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.c"
static void getTxPowerWriteValByRegulatory(struct rtw_adapter *Adapter , u8 Channel ,
                                           u8 index , u32 *powerBase0 , u32 *powerBase1 ,
                                           u32 *pOutWriteVal ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 i ;
  u8 chnlGroup ;
  u8 pwr_diff_limit[4U] ;
  u32 writeVal ;
  u32 customer_limit ;
  u32 rf ;

  {
#line 230
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 231
  pdmpriv = & pHalData->dmpriv;
#line 232
  chnlGroup = 0U;
#line 236
  rf = 0U;
#line 236
  goto ldv_55824;
  ldv_55823: ;
#line 237
  switch ((int )pHalData->EEPROMRegulatory) {
  case 0: 
#line 241
  chnlGroup = 0U;
#line 242
  writeVal = pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] + ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf));
#line 244
  goto ldv_55815;
  case 1: ;
#line 248
  if ((unsigned int )pHalData->pwrGroupCnt == 1U) {
#line 249
    chnlGroup = 0U;
  } else {

  }
#line 250
  if ((unsigned int )pHalData->pwrGroupCnt > 2U) {
#line 251
    if ((unsigned int )Channel <= 3U) {
#line 252
      chnlGroup = 0U;
    } else
#line 253
    if ((unsigned int )Channel > 3U && (unsigned int )Channel <= 9U) {
#line 254
      chnlGroup = 1U;
    } else
#line 255
    if ((unsigned int )Channel > 9U) {
#line 256
      chnlGroup = 2U;
    } else {

    }
#line 258
    if ((unsigned int )pHalData->CurrentChannelBW == 0U) {
#line 260
      chnlGroup = (u8 )((int )chnlGroup + 1);
    } else {
#line 262
      chnlGroup = (unsigned int )chnlGroup + 4U;
    }
  } else {

  }
#line 264
  writeVal = pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] + ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf));
#line 267
  goto ldv_55815;
  case 2: 
#line 270
  writeVal = (unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf);
#line 272
  goto ldv_55815;
  case 3: 
#line 274
  chnlGroup = 0U;
#line 276
  i = 0U;
#line 276
  goto ldv_55820;
  ldv_55819: 
#line 277
  pwr_diff_limit[(int )i] = (unsigned char )((pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] & (u32 )(127 << (int )i * 8)) >> (int )i * 8);
#line 279
  if ((unsigned int )pHalData->CurrentChannelBW == 1U) {
#line 280
    if ((int )pwr_diff_limit[(int )i] > (int )pHalData->PwrGroupHT40[rf][(int )Channel + -1]) {
#line 281
      pwr_diff_limit[(int )i] = pHalData->PwrGroupHT40[rf][(int )Channel + -1];
    } else {

    }
  } else
#line 283
  if ((int )pwr_diff_limit[(int )i] > (int )pHalData->PwrGroupHT20[rf][(int )Channel + -1]) {
#line 284
    pwr_diff_limit[(int )i] = pHalData->PwrGroupHT20[rf][(int )Channel + -1];
  } else {

  }
#line 276
  i = (u8 )((int )i + 1);
  ldv_55820: ;
#line 276
  if ((unsigned int )i <= 3U) {
#line 278
    goto ldv_55819;
  } else {

  }
#line 287
  customer_limit = (u32 )(((((int )pwr_diff_limit[3] << 24) | ((int )pwr_diff_limit[2] << 16)) | ((int )pwr_diff_limit[1] << 8)) | (int )pwr_diff_limit[0]);
#line 289
  writeVal = ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf)) + customer_limit;
#line 290
  goto ldv_55815;
  default: 
#line 292
  chnlGroup = 0U;
#line 293
  writeVal = pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] + ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf));
#line 295
  goto ldv_55815;
  }
  ldv_55815: ;
#line 305
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 1U) {
#line 306
    writeVal = 336860180U;
  } else
#line 307
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 2U) {
#line 309
    writeVal = 0U;
  } else {

  }
#line 314
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 3U) {
#line 315
    writeVal = writeVal - 101058054U;
  } else
#line 316
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 4U) {
#line 317
    writeVal = writeVal;
  } else {

  }
#line 318
  *(pOutWriteVal + (unsigned long )rf) = writeVal;
#line 236
  rf = rf + 1U;
  ldv_55824: ;
#line 236
  if (rf <= 1U) {
#line 238
    goto ldv_55823;
  } else {

  }

#line 243
  return;
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.c"
static void writeOFDMPowerReg(struct rtw_adapter *Adapter , u8 index , u32 *pValue ) 
{ 
  struct hal_data_8723a *pHalData ;
  u16 RegOffset_A[6U] ;
  u16 RegOffset_B[6U] ;
  u8 i ;
  u8 rf ;
  u8 pwr_val[4U] ;
  u32 writeVal ;
  u16 RegOffset ;

  {
#line 325
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 326
  RegOffset_A[0] = 3584U;
#line 326
  RegOffset_A[1] = 3588U;
#line 326
  RegOffset_A[2] = 3600U;
#line 326
  RegOffset_A[3] = 3604U;
#line 326
  RegOffset_A[4] = 3608U;
#line 326
  RegOffset_A[5] = 3612U;
#line 331
  RegOffset_B[0] = 2096U;
#line 331
  RegOffset_B[1] = 2100U;
#line 331
  RegOffset_B[2] = 2108U;
#line 331
  RegOffset_B[3] = 2120U;
#line 331
  RegOffset_B[4] = 2124U;
#line 331
  RegOffset_B[5] = 2152U;
#line 340
  rf = 0U;
#line 340
  goto ldv_55846;
  ldv_55845: 
#line 341
  writeVal = *(pValue + (unsigned long )rf);
#line 342
  i = 0U;
#line 342
  goto ldv_55840;
  ldv_55839: 
#line 343
  pwr_val[(int )i] = (unsigned char )(((u32 )(127 << (int )i * 8) & writeVal) >> (int )i * 8);
#line 345
  if ((unsigned int )pwr_val[(int )i] > 63U) {
#line 346
    pwr_val[(int )i] = 63U;
  } else {

  }
#line 342
  i = (u8 )((int )i + 1);
  ldv_55840: ;
#line 342
  if ((unsigned int )i <= 3U) {
#line 344
    goto ldv_55839;
  } else {

  }
#line 348
  writeVal = (u32 )(((((int )pwr_val[3] << 24) | ((int )pwr_val[2] << 16)) | ((int )pwr_val[1] << 8)) | (int )pwr_val[0]);
#line 351
  if ((unsigned int )rf == 0U) {
#line 352
    RegOffset = RegOffset_A[(int )index];
  } else {
#line 354
    RegOffset = RegOffset_B[(int )index];
  }
#line 356
  rtl8723au_write32(Adapter, (int )RegOffset, writeVal);
#line 360
  if (((unsigned int )pHalData->rf_type == 2U && ((unsigned int )RegOffset == 3612U || (unsigned int )RegOffset == 2152U)) || ((unsigned int )pHalData->rf_type != 2U && ((unsigned int )RegOffset == 3604U || (unsigned int )RegOffset == 2120U))) {
#line 366
    writeVal = (u32 )pwr_val[3];
#line 367
    if ((unsigned int )RegOffset == 3612U || (unsigned int )RegOffset == 3604U) {
#line 369
      RegOffset = 3216U;
    } else {

    }
#line 370
    if ((unsigned int )RegOffset == 2152U || (unsigned int )RegOffset == 2120U) {
#line 372
      RegOffset = 3224U;
    } else {

    }
#line 373
    i = 0U;
#line 373
    goto ldv_55843;
    ldv_55842: ;
#line 374
    if ((unsigned int )i != 2U) {
#line 375
      writeVal = writeVal > 8U ? writeVal - 8U : 0U;
    } else {
#line 378
      writeVal = writeVal > 6U ? writeVal - 6U : 0U;
    }
#line 380
    rtl8723au_write8(Adapter, (int )((u16 )i) + (int )RegOffset, (int )((unsigned char )writeVal));
#line 373
    i = (u8 )((int )i + 1);
    ldv_55843: ;
#line 373
    if ((unsigned int )i <= 2U) {
#line 375
      goto ldv_55842;
    } else {

    }

  } else {

  }
#line 340
  rf = (u8 )((int )rf + 1);
  ldv_55846: ;
#line 340
  if ((unsigned int )rf <= 1U) {
#line 342
    goto ldv_55845;
  } else {

  }

#line 347
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.c"
void rtl8723a_PHY_RF6052SetOFDMTxPower(struct rtw_adapter *Adapter , u8 *pPowerLevel ,
                                       u8 Channel ) 
{ 
  u32 writeVal[2U] ;
  u32 powerBase0[2U] ;
  u32 powerBase1[2U] ;
  u8 index ;

  {
#line 414
  index = 0U;
#line 416
  getPowerBase(Adapter, pPowerLevel, (int )Channel, (u32 *)(& powerBase0), (u32 *)(& powerBase1));
#line 419
  index = 0U;
#line 419
  goto ldv_55858;
  ldv_55857: 
#line 420
  getTxPowerWriteValByRegulatory(Adapter, (int )Channel, (int )index, (u32 *)(& powerBase0),
                                 (u32 *)(& powerBase1), (u32 *)(& writeVal));
#line 423
  writeOFDMPowerReg(Adapter, (int )index, (u32 *)(& writeVal));
#line 419
  index = (u8 )((int )index + 1);
  ldv_55858: ;
#line 419
  if ((unsigned int )index <= 5U) {
#line 421
    goto ldv_55857;
  } else {

  }

#line 426
  return;
}
}
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.c"
static int phy_RF6052_Config_ParaFile(struct rtw_adapter *Adapter ) 
{ 
  u32 u4RegValue ;
  u8 eRFPath ;
  struct bb_reg_define *pPhyReg ;
  int rtStatus ;
  struct hal_data_8723a *pHalData ;

  {
#line 429
  u4RegValue = 0U;
#line 432
  rtStatus = 1;
#line 433
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 438
  eRFPath = 0U;
#line 438
  goto ldv_55879;
  ldv_55878: 
#line 440
  pPhyReg = (struct bb_reg_define *)(& pHalData->PHYRegDef) + (unsigned long )eRFPath;
#line 443
  switch ((int )eRFPath) {
  case 0: 
#line 445
  u4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs, 16U);
#line 447
  goto ldv_55869;
  case 1: 
#line 449
  u4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs, 1048576U);
#line 451
  goto ldv_55869;
  }
  ldv_55869: 
#line 455
  PHY_SetBBReg(Adapter, pPhyReg->rfintfe, 1048576U, 1U);
#line 456
  __const_udelay(4295UL);
#line 459
  PHY_SetBBReg(Adapter, pPhyReg->rfintfo, 16U, 1U);
#line 460
  __const_udelay(4295UL);
#line 463
  PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, 1024U, 0U);
#line 465
  __const_udelay(4295UL);
#line 467
  PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, 2048U, 0U);
#line 469
  __const_udelay(4295UL);
#line 472
  switch ((int )eRFPath) {
  case 0: 
#line 474
  ODM_ReadAndConfig_RadioA_1T_8723A(& pHalData->odmpriv);
#line 475
  goto ldv_55872;
  case 1: ;
#line 477
  goto ldv_55872;
  }
  ldv_55872: ;
#line 481
  switch ((int )eRFPath) {
  case 0: 
#line 483
  PHY_SetBBReg(Adapter, pPhyReg->rfintfs, 16U, u4RegValue);
#line 485
  goto ldv_55875;
  case 1: 
#line 487
  PHY_SetBBReg(Adapter, pPhyReg->rfintfs, 1048576U, u4RegValue);
#line 489
  goto ldv_55875;
  }
  ldv_55875: ;
#line 492
  if (rtStatus != 1) {
#line 493
    goto phy_RF6052_Config_ParaFile_Fail;
  } else {

  }
#line 438
  eRFPath = (u8 )((int )eRFPath + 1);
  ldv_55879: ;
#line 438
  if ((int )pHalData->NumTotalRFPath > (int )eRFPath) {
#line 440
    goto ldv_55878;
  } else {

  }

  phy_RF6052_Config_ParaFile_Fail: ;
#line 497
  return (rtStatus);
}
}
#line 500 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.c"
int PHY_RF6052_Config8723A(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  int tmp ;

  {
#line 502
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 506
  if ((unsigned int )pHalData->rf_type == 3U) {
#line 507
    pHalData->NumTotalRFPath = 1U;
  } else {
#line 509
    pHalData->NumTotalRFPath = 2U;
  }
#line 512
  tmp = phy_RF6052_Config_ParaFile(Adapter);
#line 512
  return (tmp);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
bool ldv_queue_work_on_523(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
bool ldv_queue_delayed_work_on_524(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
bool ldv_queue_work_on_525(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
void ldv_flush_workqueue_526(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
bool ldv_queue_delayed_work_on_527(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_537(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_539(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_538(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_541(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_540(struct workqueue_struct *ldv_func_arg1 ) ;
#line 61 "drivers/staging/rtl8723au/include/rtl8723a_recv.h"
void rtl8723a_process_phy_info(struct rtw_adapter *padapter , void *prframe ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.c"
static void process_rssi(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct signal_stat *signal_stat ;

  {
#line 24
  pattrib = & prframe->attrib;
#line 25
  signal_stat = & padapter->recvpriv.signal_strength_data;
#line 27
  if ((unsigned int )signal_stat->update_req != 0U) {
#line 28
    signal_stat->total_num = 0U;
#line 29
    signal_stat->total_val = 0U;
#line 30
    signal_stat->update_req = 0U;
  } else {

  }
#line 33
  signal_stat->total_num = signal_stat->total_num + 1U;
#line 34
  signal_stat->total_val = signal_stat->total_val + (u32 )pattrib->phy_info.SignalStrength;
#line 35
  signal_stat->avg_val = (u8 )(signal_stat->total_val / signal_stat->total_num);
#line 36
  return;
}
}
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.c"
static void process_link_qual(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct signal_stat *signal_stat ;

  {
#line 44
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0) || (unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 45
    return;
  } else {

  }
#line 47
  pattrib = & prframe->attrib;
#line 48
  signal_stat = & padapter->recvpriv.signal_qual_data;
#line 50
  if ((unsigned int )signal_stat->update_req != 0U) {
#line 51
    signal_stat->total_num = 0U;
#line 52
    signal_stat->total_val = 0U;
#line 53
    signal_stat->update_req = 0U;
  } else {

  }
#line 56
  signal_stat->total_num = signal_stat->total_num + 1U;
#line 57
  signal_stat->total_val = signal_stat->total_val + (u32 )pattrib->phy_info.SignalQuality;
#line 58
  signal_stat->avg_val = (u8 )(signal_stat->total_val / signal_stat->total_num);
#line 59
  return;
}
}
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.c"
void rtl8723a_process_phy_info(struct rtw_adapter *padapter , void *prframe ) 
{ 
  struct recv_frame *precvframe ;

  {
#line 64
  precvframe = (struct recv_frame *)prframe;
#line 66
  process_rssi(padapter, precvframe);
#line 68
  process_link_qual(padapter, precvframe);
#line 69
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
bool ldv_queue_work_on_537(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
bool ldv_queue_delayed_work_on_538(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
bool ldv_queue_work_on_539(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
void ldv_flush_workqueue_540(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
bool ldv_queue_delayed_work_on_541(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_551(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_553(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_552(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_555(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_554(struct workqueue_struct *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.c"
void rtl8723a_sreset_xmit_status_check(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  unsigned long current_time ;
  struct xmit_priv *pxmitpriv ;
  unsigned int diff_time ;
  u32 txdma_status ;

  {
#line 23
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 24
  psrtpriv = & pHalData->srestpriv;
#line 27
  pxmitpriv = & padapter->xmitpriv;
#line 31
  txdma_status = rtl8723au_read32(padapter, 528);
#line 32
  if (txdma_status != 0U) {
#line 33
    if (GlobalDebugLevel23A > 3U) {
#line 33
      printk("\016RTL8723AU: %s REG_TXDMA_STATUS:0x%08x\n", "rtl8723a_sreset_xmit_status_check",
             txdma_status);
    } else {

    }
#line 34
    rtw_sreset_reset(padapter);
  } else {

  }
#line 37
  current_time = jiffies;
#line 39
  if (pxmitpriv->free_xmitbuf_cnt == 0U || pxmitpriv->free_xmit_extbuf_cnt == 0U) {
#line 41
    diff_time = jiffies_to_msecs((unsigned long )jiffies - psrtpriv->last_tx_time);
#line 43
    if (diff_time > 2000U) {
#line 44
      if (psrtpriv->last_tx_complete_time == 0UL) {
#line 45
        psrtpriv->last_tx_complete_time = current_time;
      } else {
#line 47
        diff_time = jiffies_to_msecs((unsigned long )jiffies - psrtpriv->last_tx_complete_time);
#line 48
        if (diff_time > 4000U) {
#line 49
          if (GlobalDebugLevel23A > 3U) {
#line 49
            printk("\016RTL8723AU: %s tx hang\n", "rtl8723a_sreset_xmit_status_check");
          } else {

          }
#line 50
          rtw_sreset_reset(padapter);
        } else {

        }
      }
    } else {

    }
  } else {

  }
#line 54
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
bool ldv_queue_work_on_551(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
bool ldv_queue_delayed_work_on_552(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
bool ldv_queue_work_on_553(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
void ldv_flush_workqueue_554(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
bool ldv_queue_delayed_work_on_555(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_565(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_567(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_566(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_569(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_568(struct workqueue_struct *ldv_func_arg1 ) ;
#line 1316 "include/linux/skbuff.h"
__inline static __u32 skb_queue_len(struct sk_buff_head  const  *list_ ) 
{ 


  {
#line 1318
  return ((__u32 )list_->qlen);
}
}
#line 1345 "include/linux/skbuff.h"
__inline static void skb_queue_head_init(struct sk_buff_head *list ) 
{ 
  struct lock_class_key __key ;

  {
#line 1347
  spinlock_check(& list->lock);
#line 1347
  __raw_spin_lock_init(& list->lock.__annonCompField18.rlock, "&(&list->lock)->rlock",
                       & __key);
#line 1348
  __skb_queue_head_init(list);
#line 1349
  return;
}
}
#line 1508
extern void skb_queue_tail(struct sk_buff_head * , struct sk_buff * ) ;
#line 1793 "include/linux/skbuff.h"
__inline static void skb_reserve(struct sk_buff *skb , int len ) 
{ 


  {
#line 1795
  skb->data = skb->data + (unsigned long )len;
#line 1796
  skb->tail = skb->tail + (sk_buff_data_t )len;
#line 1797
  return;
}
}
#line 2134
extern void skb_queue_purge(struct sk_buff_head * ) ;
#line 2144
extern struct sk_buff *__netdev_alloc_skb(struct net_device * , unsigned int  , gfp_t  ) ;
#line 1602 "include/linux/usb.h"
extern struct urb *usb_alloc_urb(int  , gfp_t  ) ;
#line 1603
extern void usb_free_urb(struct urb * ) ;
#line 39 "drivers/staging/rtl8723au/include/usb_ops.h"
void rtl8723au_recv_tasklet(void *priv ) ;
#line 62 "drivers/staging/rtl8723au/include/rtl8723a_recv.h"
void update_recvframe_attrib(struct recv_frame *precvframe , struct recv_stat *prxstat ) ;
#line 63
void update_recvframe_phyinfo(struct recv_frame *precvframe , struct phy_stat *pphy_status ) ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_recv.c"
int rtl8723au_init_recv_priv(struct rtw_adapter *padapter ) 
{ 
  struct recv_priv *precvpriv ;
  int i ;
  int size ;
  int res ;
  struct recv_buf *precvbuf ;
  unsigned long tmpaddr ;
  unsigned long alignment ;
  struct sk_buff *pskb ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 28
  precvpriv = & padapter->recvpriv;
#line 29
  res = 1;
#line 35
  tasklet_init(& precvpriv->recv_tasklet, (void (*)(unsigned long  ))(& rtl8723au_recv_tasklet),
               (unsigned long )padapter);
#line 39
  precvpriv->int_in_urb = usb_alloc_urb(0, 208U);
#line 40
  if ((unsigned long )precvpriv->int_in_urb == (unsigned long )((struct urb *)0)) {
#line 41
    if (GlobalDebugLevel23A > 3U) {
#line 41
      printk("\016RTL8723AU: alloc_urb for interrupt in endpoint fail !!!!\n");
    } else {

    }
  } else {

  }
#line 42
  tmp = kzalloc(56UL, 208U);
#line 42
  precvpriv->int_in_buf = (u8 *)tmp;
#line 43
  if ((unsigned long )precvpriv->int_in_buf == (unsigned long )((u8 *)0U)) {
#line 44
    if (GlobalDebugLevel23A > 3U) {
#line 44
      printk("\016RTL8723AU: alloc_mem for interrupt in endpoint fail !!!!\n");
    } else {

    }
  } else {

  }
#line 46
  size = 160;
#line 47
  tmp___0 = kzalloc((size_t )size, 208U);
#line 47
  precvpriv->precv_buf = (u8 *)tmp___0;
#line 48
  if ((unsigned long )precvpriv->precv_buf == (unsigned long )((u8 *)0U)) {
#line 49
    res = 0;
#line 50
    if (GlobalDebugLevel23A > 3U) {
#line 50
      rt_trace(4, 4, "alloc recv_buf fail!\n");
    } else {

    }
#line 52
    goto exit;
  } else {

  }
#line 55
  precvbuf = (struct recv_buf *)precvpriv->precv_buf;
#line 57
  i = 0;
#line 57
  goto ldv_55801;
  ldv_55800: 
#line 58
  INIT_LIST_HEAD(& precvbuf->list);
#line 60
  precvbuf->purb = usb_alloc_urb(0, 208U);
#line 61
  if ((unsigned long )precvbuf->purb == (unsigned long )((struct urb *)0)) {
#line 62
    goto ldv_55799;
  } else {

  }
#line 64
  precvbuf->adapter = padapter;
#line 66
  precvbuf = precvbuf + 1;
#line 57
  i = i + 1;
  ldv_55801: ;
#line 57
  if (i <= 3) {
#line 59
    goto ldv_55800;
  } else {

  }
  ldv_55799: 
#line 69
  skb_queue_head_init(& precvpriv->rx_skb_queue);
#line 70
  skb_queue_head_init(& precvpriv->free_recv_skb_queue);
#line 72
  i = 0;
#line 72
  goto ldv_55803;
  ldv_55802: 
#line 73
  size = 15368;
#line 74
  pskb = __netdev_alloc_skb(padapter->pnetdev, (unsigned int )size, 208U);
#line 76
  if ((unsigned long )pskb != (unsigned long )((struct sk_buff *)0)) {
#line 77
    pskb->dev = padapter->pnetdev;
#line 79
    tmpaddr = (unsigned long )pskb->data;
#line 80
    alignment = tmpaddr & 7UL;
#line 81
    skb_reserve(pskb, (int )(8U - (unsigned int )alignment));
#line 83
    skb_queue_tail(& precvpriv->free_recv_skb_queue, pskb);
  } else {

  }
#line 86
  pskb = (struct sk_buff *)0;
#line 72
  i = i + 1;
  ldv_55803: ;
#line 72
  if (i <= 7) {
#line 74
    goto ldv_55802;
  } else {

  }

  exit: ;
#line 90
  return (res);
}
}
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_recv.c"
void rtl8723au_free_recv_priv(struct rtw_adapter *padapter ) 
{ 
  int i ;
  struct recv_buf *precvbuf ;
  struct recv_priv *precvpriv ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
#line 97
  precvpriv = & padapter->recvpriv;
#line 99
  precvbuf = (struct recv_buf *)precvpriv->precv_buf;
#line 101
  i = 0;
#line 101
  goto ldv_55812;
  ldv_55811: 
#line 102
  usb_free_urb(precvbuf->purb);
#line 104
  if ((unsigned long )precvbuf->pskb != (unsigned long )((struct sk_buff *)0)) {
#line 105
    dev_kfree_skb_any(precvbuf->pskb);
  } else {

  }
#line 107
  precvbuf = precvbuf + 1;
#line 101
  i = i + 1;
  ldv_55812: ;
#line 101
  if (i <= 3) {
#line 103
    goto ldv_55811;
  } else {

  }
#line 110
  kfree((void const   *)precvpriv->precv_buf);
#line 112
  usb_free_urb(precvpriv->int_in_urb);
#line 113
  kfree((void const   *)precvpriv->int_in_buf);
#line 115
  tmp = skb_queue_len((struct sk_buff_head  const  *)(& precvpriv->rx_skb_queue));
#line 115
  if (tmp != 0U) {
#line 116
    if (GlobalDebugLevel23A > 3U) {
#line 116
      printk("\016RTL8723AU: \frx_skb_queue not empty\n");
    } else {

    }
  } else {

  }
#line 118
  skb_queue_purge(& precvpriv->rx_skb_queue);
#line 120
  tmp___1 = skb_queue_len((struct sk_buff_head  const  *)(& precvpriv->free_recv_skb_queue));
#line 120
  if (tmp___1 != 0U) {
#line 121
    if (GlobalDebugLevel23A > 3U) {
#line 121
      tmp___0 = skb_queue_len((struct sk_buff_head  const  *)(& precvpriv->free_recv_skb_queue));
#line 121
      printk("\016RTL8723AU: \ffree_recv_skb_queue not empty, %d\n", tmp___0);
    } else {

    }
  } else {

  }
#line 125
  skb_queue_purge(& precvpriv->free_recv_skb_queue);
#line 126
  return;
}
}
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_recv.c"
void update_recvframe_attrib(struct recv_frame *precvframe , struct recv_stat *prxstat ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct recv_stat_cpu report ;
  struct rxreport_8723a *prxreport ;

  {
#line 144
  report.rxdw0 = prxstat->rxdw0;
#line 145
  report.rxdw1 = prxstat->rxdw1;
#line 146
  report.rxdw2 = prxstat->rxdw2;
#line 147
  report.rxdw3 = prxstat->rxdw3;
#line 148
  report.rxdw4 = prxstat->rxdw4;
#line 149
  report.rxdw5 = prxstat->rxdw5;
#line 151
  prxreport = (struct rxreport_8723a *)(& report);
#line 153
  pattrib = & precvframe->attrib;
#line 154
  memset((void *)pattrib, 0, 96UL);
#line 157
  pattrib->pkt_len = prxreport->pktlen;
#line 158
  pattrib->drvinfo_sz = (int )prxreport->drvinfosize << 3U;
#line 159
  pattrib->physt = prxreport->physt;
#line 161
  pattrib->crc_err = prxreport->crc32;
#line 162
  pattrib->icv_err = prxreport->icverr;
#line 164
  pattrib->bdecrypted = (unsigned int )*((unsigned char *)prxreport + 3UL) == 0U;
#line 165
  pattrib->encrypt = (u32 )prxreport->security;
#line 167
  pattrib->qos = prxreport->qos;
#line 168
  pattrib->priority = prxreport->tid;
#line 170
  pattrib->amsdu = prxreport->amsdu;
#line 172
  pattrib->seq_num = prxreport->seq;
#line 173
  pattrib->frag_num = prxreport->frag;
#line 174
  pattrib->mfrag = prxreport->mf;
#line 175
  pattrib->mdata = prxreport->md;
#line 177
  pattrib->mcs_rate = prxreport->rxmcs;
#line 178
  pattrib->rxht = prxreport->rxht;
#line 179
  return;
}
}
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_recv.c"
void update_recvframe_phyinfo(struct recv_frame *precvframe , struct phy_stat *pphy_status ) 
{ 
  struct rtw_adapter *padapter ;
  struct rx_pkt_attrib *pattrib ;
  struct hal_data_8723a *pHalData ;
  struct phy_info *pPHYInfo ;
  struct odm_packet_info pkt_info ;
  u8 *sa ;
  u8 *da ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  bool matchbssid ;
  u8 *bssid ;
  int tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;

  {
#line 184
  padapter = precvframe->adapter;
#line 185
  pattrib = & precvframe->attrib;
#line 186
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 187
  pPHYInfo = & pattrib->phy_info;
#line 189
  sa = (u8 *)0U;
#line 192
  skb = precvframe->pkt;
#line 193
  hdr = (struct ieee80211_hdr *)skb->data;
#line 194
  matchbssid = 0;
#line 197
  tmp = ieee80211_is_ctl((int )hdr->frame_control);
#line 197
  matchbssid = (bool )((tmp == 0 && (unsigned int )pattrib->icv_err == 0U) && (unsigned int )pattrib->crc_err == 0U);
#line 200
  if ((int )matchbssid) {
#line 201
    switch ((int )hdr->frame_control & 768) {
    case 256: 
#line 205
    bssid = (u8 *)(& hdr->addr1);
#line 206
    goto ldv_55846;
    case 512: 
#line 208
    bssid = (u8 *)(& hdr->addr2);
#line 209
    goto ldv_55846;
    case 0: 
#line 211
    bssid = (u8 *)(& hdr->addr3);
#line 212
    goto ldv_55846;
    default: 
#line 214
    bssid = (u8 *)0U;
#line 215
    matchbssid = 0;
    }
    ldv_55846: ;
#line 218
    if ((unsigned long )bssid != (unsigned long )((u8 *)0U)) {
#line 219
      tmp___0 = get_bssid(& padapter->mlmepriv);
#line 219
      matchbssid = ether_addr_equal((u8 const   *)tmp___0, (u8 const   *)bssid);
    } else {

    }
  } else {

  }
#line 223
  pkt_info.bPacketMatchBSSID = matchbssid;
#line 225
  da = ieee80211_get_DA(hdr);
#line 226
  if ((int )pkt_info.bPacketMatchBSSID) {
#line 226
    tmp___1 = myid(& padapter->eeprompriv);
#line 226
    tmp___2 = memcmp((void const   *)da, (void const   *)tmp___1, 6UL);
#line 226
    if (tmp___2 == 0) {
#line 226
      tmp___3 = 1;
    } else {
#line 226
      tmp___3 = 0;
    }
  } else {
#line 226
    tmp___3 = 0;
  }
#line 226
  pkt_info.bPacketToSelf = (bool )tmp___3;
#line 229
  if ((int )pkt_info.bPacketMatchBSSID) {
#line 229
    tmp___4 = ieee80211_is_beacon((int )hdr->frame_control);
#line 229
    if (tmp___4 != 0) {
#line 229
      tmp___5 = 1;
    } else {
#line 229
      tmp___5 = 0;
    }
  } else {
#line 229
    tmp___5 = 0;
  }
#line 229
  pkt_info.bPacketBeacon = (bool )tmp___5;
#line 232
  pkt_info.StationID = 255U;
#line 233
  if ((int )pkt_info.bPacketBeacon) {
#line 234
    tmp___6 = check_fwstate(& padapter->mlmepriv, 8);
#line 234
    if ((int )tmp___6) {
#line 235
      sa = (u8 *)(& padapter->mlmepriv.cur_network.network.MacAddress);
    } else {

    }
  } else {
#line 238
    sa = ieee80211_get_SA(hdr);
  }
#line 241
  pstapriv = & padapter->stapriv;
#line 242
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)sa);
#line 243
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 244
    pkt_info.StationID = (u8 )psta->mac_id;
  } else {

  }
#line 247
  pkt_info.Rate = pattrib->mcs_rate;
#line 249
  ODM_PhyStatusQuery23a(& pHalData->odmpriv, pPHYInfo, (u8 *)pphy_status, & pkt_info);
#line 251
  precvframe->psta = (struct sta_info *)0;
#line 252
  if ((int )pkt_info.bPacketMatchBSSID) {
#line 252
    tmp___8 = check_fwstate(& padapter->mlmepriv, 16);
#line 252
    if ((int )tmp___8) {
#line 254
      if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 255
        precvframe->psta = psta;
#line 256
        rtl8723a_process_phy_info(padapter, (void *)precvframe);
      } else {

      }
    } else {
#line 252
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 258
  if ((int )pkt_info.bPacketToSelf || (int )pkt_info.bPacketBeacon) {
#line 259
    tmp___7 = check_fwstate(& padapter->mlmepriv, 96);
#line 259
    if ((int )tmp___7) {
#line 262
      if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 263
        precvframe->psta = psta;
      } else {

      }
    } else {

    }
#line 265
    rtl8723a_process_phy_info(padapter, (void *)precvframe);
  } else {

  }
#line 267
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
bool ldv_queue_work_on_565(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
bool ldv_queue_delayed_work_on_566(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
bool ldv_queue_work_on_567(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
void ldv_flush_workqueue_568(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
bool ldv_queue_delayed_work_on_569(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_579(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_581(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_580(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_583(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_582(struct workqueue_struct *ldv_func_arg1 ) ;
#line 27 "drivers/staging/rtl8723au/include/usb_ops_linux.h"
int rtl8723au_write_port(struct rtw_adapter *padapter , u32 addr , u32 cnt , struct xmit_buf *pxmitbuf ) ;
#line 222 "drivers/staging/rtl8723au/include/rtl8723a_xmit.h"
bool rtl8723au_xmitframe_complete(struct rtw_adapter *padapter , struct xmit_priv *pxmitpriv ,
                                  struct xmit_buf *pxmitbuf ) ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.c"
static int urb_zero_packet_chk(struct rtw_adapter *padapter , int sz ) 
{ 
  int blnSetTxDescOffset ;
  struct dvobj_priv *pdvobj ;

  {
#line 27
  pdvobj = padapter->dvobj;
#line 29
  if ((unsigned int )pdvobj->ishighspeed != 0U) {
#line 30
    if (((unsigned int )(sz + 32) & 511U) == 0U) {
#line 31
      blnSetTxDescOffset = 1;
    } else {
#line 33
      blnSetTxDescOffset = 0;
    }
  } else
#line 35
  if (((unsigned int )(sz + 32) & 63U) == 0U) {
#line 36
    blnSetTxDescOffset = 1;
  } else {
#line 38
    blnSetTxDescOffset = 0;
  }
#line 40
  return (blnSetTxDescOffset);
}
}
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.c"
static void rtl8192cu_cal_txdesc_chksum(struct tx_desc *ptxdesc ) 
{ 
  __le16 *usPtr ;
  u32 count ;
  u32 index ;
  u16 checksum ;

  {
#line 45
  usPtr = (__le16 *)ptxdesc;
#line 46
  count = 16U;
#line 48
  checksum = 0U;
#line 51
  ptxdesc->txdw7 = ptxdesc->txdw7 & 4294901760U;
#line 53
  index = 0U;
#line 53
  goto ldv_55777;
  ldv_55776: 
#line 54
  checksum = (u16 )((int )*(usPtr + (unsigned long )index) ^ (int )checksum);
#line 53
  index = index + 1U;
  ldv_55777: ;
#line 53
  if (index < count) {
#line 55
    goto ldv_55776;
  } else {

  }
#line 56
  ptxdesc->txdw7 = ptxdesc->txdw7 | (__le32 )checksum;
#line 57
  return;
}
}
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.c"
static void fill_txdesc_sectype(struct pkt_attrib *pattrib , struct tx_desc *ptxdesc ) 
{ 


  {
#line 61
  if (pattrib->encrypt != 0U && (unsigned int )pattrib->bswenc == 0U) {
#line 62
    switch (pattrib->encrypt) {
    case 1027073U: ;
    case 1027077U: 
#line 66
    ptxdesc->txdw1 = ptxdesc->txdw1 | 4194304U;
#line 67
    goto ldv_55785;
    case 1027074U: 
#line 70
    ptxdesc->txdw1 = ptxdesc->txdw1 | 4194304U;
#line 71
    goto ldv_55785;
    case 1027076U: 
#line 73
    ptxdesc->txdw1 = ptxdesc->txdw1 | 12582912U;
#line 74
    goto ldv_55785;
    case 0U: ;
    default: ;
#line 77
    goto ldv_55785;
    }
    ldv_55785: ;
  } else {

  }
#line 81
  return;
}
}
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.c"
static void fill_txdesc_vcs(struct pkt_attrib *pattrib , __le32 *pdw ) 
{ 


  {
#line 86
  switch ((int )pattrib->vcs_mode) {
  case 1: 
#line 88
  *pdw = *pdw | 4096U;
#line 89
  goto ldv_55795;
  case 2: 
#line 91
  *pdw = *pdw | 2048U;
#line 92
  goto ldv_55795;
  case 0: ;
  default: ;
#line 95
  goto ldv_55795;
  }
  ldv_55795: ;
#line 98
  if ((unsigned int )pattrib->vcs_mode != 0U) {
#line 99
    *pdw = *pdw | 8192U;
#line 102
    if ((unsigned int )pattrib->ht_en != 0U) {
#line 103
      *pdw = *pdw | ((int )pattrib->bwmode & 1 ? 134217728U : 0U);
#line 105
      if ((unsigned int )pattrib->ch_offset == 1U) {
#line 106
        *pdw = *pdw | 268435456U;
      } else
#line 107
      if ((unsigned int )pattrib->ch_offset == 2U) {
#line 108
        *pdw = *pdw | 536870912U;
      } else
#line 109
      if ((unsigned int )pattrib->ch_offset == 0U) {
#line 110
        *pdw = *pdw;
      } else {
#line 112
        *pdw = *pdw | 805306368U;
      }
    } else {

    }
  } else {

  }
#line 115
  return;
}
}
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.c"
static void fill_txdesc_phy(struct pkt_attrib *pattrib , __le32 *pdw ) 
{ 


  {
#line 119
  if ((unsigned int )pattrib->ht_en != 0U) {
#line 120
    *pdw = *pdw | ((int )pattrib->bwmode & 1 ? 33554432U : 0U);
#line 122
    if ((unsigned int )pattrib->ch_offset == 1U) {
#line 123
      *pdw = *pdw | 1048576U;
    } else
#line 124
    if ((unsigned int )pattrib->ch_offset == 2U) {
#line 125
      *pdw = *pdw | 2097152U;
    } else
#line 126
    if ((unsigned int )pattrib->ch_offset == 0U) {
#line 127
      *pdw = *pdw;
    } else {
#line 129
      *pdw = *pdw | 3145728U;
    }
  } else {

  }
#line 131
  return;
}
}
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.c"
static s32 update_txdesc(struct xmit_frame *pxmitframe , u8 *pmem , s32 sz ) 
{ 
  int pull ;
  uint qsel ;
  struct rtw_adapter *padapter ;
  struct pkt_attrib *pattrib ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct tx_desc *ptxdesc ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int bmcst ;
  bool tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;

  {
#line 135
  pull = 0;
#line 137
  padapter = pxmitframe->padapter;
#line 138
  pattrib = & pxmitframe->attrib;
#line 139
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 140
  pdmpriv = & pHalData->dmpriv;
#line 141
  ptxdesc = (struct tx_desc *)pmem;
#line 142
  pmlmeext = & padapter->mlmeextpriv;
#line 143
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 144
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 144
  bmcst = (int )tmp;
#line 146
  tmp___0 = urb_zero_packet_chk(padapter, sz);
#line 146
  if (tmp___0 == 0) {
#line 147
    ptxdesc = (struct tx_desc *)pmem + 8U;
#line 148
    pull = 1;
#line 149
    pxmitframe->pkt_offset = (s8 )((int )pxmitframe->pkt_offset - 1);
  } else {

  }
#line 152
  memset((void *)ptxdesc, 0, 32UL);
#line 154
  if (pxmitframe->frame_tag == 1) {
#line 156
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )pattrib->mac_id & 31U);
#line 158
    qsel = (unsigned int )pattrib->qsel & 31U;
#line 159
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((qsel << 8) & 7936U);
#line 161
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )((int )pattrib->raid << 16) & 983040U);
#line 163
    fill_txdesc_sectype(pattrib, ptxdesc);
#line 165
    if ((unsigned int )pattrib->ampdu_en != 0U) {
#line 166
      ptxdesc->txdw1 = ptxdesc->txdw1 | 32U;
    } else {
#line 168
      ptxdesc->txdw1 = ptxdesc->txdw1 | 64U;
    }
#line 173
    ptxdesc->txdw3 = ptxdesc->txdw3 | (__le32 )((int )pattrib->seqnum << 16);
#line 176
    if ((unsigned int )pattrib->qos_en != 0U) {
#line 177
      ptxdesc->txdw4 = ptxdesc->txdw4 | 64U;
    } else {

    }
#line 179
    if (((unsigned int )pattrib->ether_type != 34958U && (unsigned int )pattrib->ether_type != 2054U) && (unsigned int )pattrib->dhcp_pkt != 1U) {
#line 184
      fill_txdesc_vcs(pattrib, & ptxdesc->txdw4);
#line 185
      fill_txdesc_phy(pattrib, & ptxdesc->txdw4);
#line 187
      ptxdesc->txdw4 = ptxdesc->txdw4 | 8U;
#line 188
      ptxdesc->txdw5 = ptxdesc->txdw5 | 130816U;
#line 191
      ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )pdmpriv->INIDATA_RATE[(int )pattrib->mac_id];
    } else {
#line 197
      ptxdesc->txdw1 = ptxdesc->txdw1 | 64U;
#line 199
      ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
#line 201
      if ((unsigned int )pmlmeinfo->preamble_mode == 3U) {
#line 202
        ptxdesc->txdw4 = ptxdesc->txdw4 | 16777216U;
      } else {

      }
#line 204
      tmp___1 = MRateToHwRate23a((int )pmlmeext->tx_rate);
#line 204
      ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )tmp___1;
    }
  } else
#line 206
  if (pxmitframe->frame_tag == 3) {
#line 208
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )pattrib->mac_id & 31U);
#line 210
    qsel = (unsigned int )pattrib->qsel & 31U;
#line 211
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((qsel << 8) & 7936U);
#line 213
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )((int )pattrib->raid << 16) & 983040U);
#line 217
    if ((unsigned int )pxmitframe->ack_report != 0U) {
#line 218
      ptxdesc->txdw2 = ptxdesc->txdw2 | 524288U;
    } else {

    }
#line 221
    ptxdesc->txdw3 = ptxdesc->txdw3 | (__le32 )((int )pattrib->seqnum << 16);
#line 224
    ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
#line 227
    ptxdesc->txdw5 = ptxdesc->txdw5 | 131072U;
#line 228
    ptxdesc->txdw5 = ptxdesc->txdw5 | 1572864U;
#line 230
    tmp___2 = MRateToHwRate23a((int )pmlmeext->tx_rate);
#line 230
    ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )tmp___2;
  } else
#line 231
  if (pxmitframe->frame_tag == 8) {
#line 232
    if (GlobalDebugLevel23A > 3U) {
#line 232
      printk("\016RTL8723AU: pxmitframe->frame_tag == TXAGG_FRAMETAG\n");
    } else {

    }
  } else {
#line 234
    if (GlobalDebugLevel23A > 3U) {
#line 234
      printk("\016RTL8723AU: pxmitframe->frame_tag = %d\n", pxmitframe->frame_tag);
    } else {

    }
#line 238
    ptxdesc->txdw1 = ptxdesc->txdw1 | 4U;
#line 240
    ptxdesc->txdw1 = ptxdesc->txdw1 | 393216U;
#line 245
    ptxdesc->txdw3 = ptxdesc->txdw3 | (__le32 )((int )pattrib->seqnum << 16);
#line 248
    ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
#line 251
    tmp___3 = MRateToHwRate23a((int )pmlmeext->tx_rate);
#line 251
    ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )tmp___3;
  }
#line 260
  if ((unsigned int )pattrib->qos_en == 0U) {
#line 262
    ptxdesc->txdw4 = ptxdesc->txdw4 | 128U;
#line 264
    ptxdesc->txdw3 = ptxdesc->txdw3 | 2147483648U;
  } else {

  }
#line 268
  ptxdesc->txdw0 = ptxdesc->txdw0 | ((__le32 )sz & 65535U);
#line 269
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2348810240U;
#line 270
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2097152U;
#line 272
  if (bmcst != 0) {
#line 273
    ptxdesc->txdw0 = ptxdesc->txdw0 | 16777216U;
  } else {

  }
#line 275
  if (GlobalDebugLevel23A > 6U) {
#line 275
    rt_trace(1, 7, "offset0-txdesc = 0x%x\n", ptxdesc->txdw0);
  } else {

  }
#line 280
  if ((int )pxmitframe->pkt_offset > 0) {
#line 281
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )((int )pxmitframe->pkt_offset << 26) & 2080374784U);
  } else {

  }
#line 283
  rtl8192cu_cal_txdesc_chksum(ptxdesc);
#line 284
  return (pull);
}
}
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.c"
static int rtw_dump_xframe(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int ret ;
  int inner_ret ;
  int t ;
  int sz ;
  int w_sz ;
  int pull ;
  u8 *mem_addr ;
  u32 ff_hwaddr ;
  struct xmit_buf *pxmitbuf ;
  struct pkt_attrib *pattrib ;
  struct xmit_priv *pxmitpriv ;

  {
#line 290
  ret = 1;
#line 291
  inner_ret = 1;
#line 292
  pull = 0;
#line 295
  pxmitbuf = pxmitframe->pxmitbuf;
#line 296
  pattrib = & pxmitframe->attrib;
#line 297
  pxmitpriv = & padapter->xmitpriv;
#line 299
  if (((pxmitframe->frame_tag == 1 && (unsigned int )pxmitframe->attrib.ether_type != 2054U) && (unsigned int )pxmitframe->attrib.ether_type != 34958U) && (unsigned int )pxmitframe->attrib.dhcp_pkt != 1U) {
#line 303
    rtw_issue_addbareq_cmd23a(padapter, pxmitframe);
  } else {

  }
#line 305
  mem_addr = pxmitframe->buf_addr;
#line 307
  if (GlobalDebugLevel23A > 6U) {
#line 307
    rt_trace(1, 7, "rtw_dump_xframe()\n");
  } else {

  }
#line 309
  t = 0;
#line 309
  goto ldv_55834;
  ldv_55833: ;
#line 310
  if (inner_ret != 1 && ret == 1) {
#line 311
    ret = 0;
  } else {

  }
#line 313
  if ((int )pattrib->nr_frags + -1 != t) {
#line 314
    if (GlobalDebugLevel23A > 3U) {
#line 314
      rt_trace(1, 4, "pattrib->nr_frags =%d\n", (int )pattrib->nr_frags);
    } else {

    }
#line 317
    sz = (int )pxmitpriv->frag_len;
#line 318
    sz = (sz + -4) - (int )pattrib->icv_len;
  } else {
#line 321
    sz = (int )pattrib->last_txcmdsz;
  }
#line 324
  pull = update_txdesc(pxmitframe, mem_addr, sz);
#line 326
  if (pull != 0) {
#line 327
    mem_addr = mem_addr + 8UL;
#line 329
    pxmitframe->buf_addr = mem_addr;
#line 331
    w_sz = sz + 32;
  } else {
#line 333
    w_sz = sz + 40;
  }
#line 336
  ff_hwaddr = rtw_get_ff_hwaddr23a(pxmitframe);
#line 337
  inner_ret = rtl8723au_write_port(padapter, ff_hwaddr, (u32 )w_sz, pxmitbuf);
#line 339
  rtw_count_tx_stats23a(padapter, pxmitframe, sz);
#line 341
  if (GlobalDebugLevel23A > 6U) {
#line 341
    rt_trace(1, 7, "rtw_write_port, w_sz =%d\n", w_sz);
  } else {

  }
#line 344
  mem_addr = mem_addr + (unsigned long )w_sz;
#line 346
  mem_addr = (u8 *)(((unsigned long )mem_addr + 3UL) & 0xfffffffffffffffcUL);
#line 309
  t = t + 1;
  ldv_55834: ;
#line 309
  if ((int )pattrib->nr_frags > t) {
#line 311
    goto ldv_55833;
  } else {

  }
#line 349
  rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
#line 351
  if (ret != 1) {
#line 352
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 1);
  } else {

  }
#line 354
  return (ret);
}
}
#line 357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.c"
bool rtl8723au_xmitframe_complete(struct rtw_adapter *padapter , struct xmit_priv *pxmitpriv ,
                                  struct xmit_buf *pxmitbuf ) 
{ 
  struct hw_xmit *phwxmits ;
  struct xmit_frame *pxmitframe ;
  int hwentry ;
  int res ;
  int xcnt ;

  {
#line 364
  res = 1;
#line 364
  xcnt = 0;
#line 366
  phwxmits = pxmitpriv->hwxmits;
#line 367
  hwentry = (int )pxmitpriv->hwxmit_entry;
#line 369
  if (GlobalDebugLevel23A > 6U) {
#line 369
    rt_trace(1, 7, "xmitframe_complete()\n");
  } else {

  }
#line 371
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 372
    pxmitbuf = rtw_alloc_xmitbuf23a(pxmitpriv);
#line 373
    if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 374
      return (0);
    } else {

    }
  } else {

  }
#line 376
  pxmitframe = rtw_dequeue_xframe23a(pxmitpriv, phwxmits, hwentry);
#line 378
  if ((unsigned long )pxmitframe != (unsigned long )((struct xmit_frame *)0)) {
#line 379
    pxmitframe->pxmitbuf = pxmitbuf;
#line 381
    pxmitframe->buf_addr = pxmitbuf->pbuf;
#line 383
    pxmitbuf->priv_data = (void *)pxmitframe;
#line 385
    if (pxmitframe->frame_tag == 1) {
#line 386
      if ((unsigned int )pxmitframe->attrib.priority <= 15U) {
#line 387
        res = rtw_xmitframe_coalesce23a(padapter, pxmitframe->pkt, pxmitframe);
      } else {

      }
#line 389
      rtw_os_xmit_complete23a(padapter, pxmitframe);
    } else {

    }
#line 392
    if (GlobalDebugLevel23A > 6U) {
#line 392
      rt_trace(1, 7, "xmitframe_complete(): rtw_dump_xframe\n");
    } else {

    }
#line 395
    if (res == 1) {
#line 396
      rtw_dump_xframe(padapter, pxmitframe);
    } else {
#line 398
      rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
#line 399
      rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
    }
#line 401
    xcnt = xcnt + 1;
  } else {
#line 403
    rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
#line 404
    return (0);
  }
#line 406
  return (1);
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.c"
static int xmitframe_direct(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int res ;

  {
#line 414
  res = rtw_xmitframe_coalesce23a(padapter, pxmitframe->pkt, pxmitframe);
#line 415
  if (res == 1) {
#line 416
    rtw_dump_xframe(padapter, pxmitframe);
  } else {

  }
#line 417
  return (res);
}
}
#line 425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.c"
bool rtl8723au_hal_xmit(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int res ;
  struct xmit_buf *pxmitbuf ;
  struct xmit_priv *pxmitpriv ;
  struct pkt_attrib *pattrib ;
  struct mlme_priv *pmlmepriv ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  int tmp ;
  s32 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 429
  pxmitbuf = (struct xmit_buf *)0;
#line 430
  pxmitpriv = & padapter->xmitpriv;
#line 431
  pattrib = & pxmitframe->attrib;
#line 432
  pmlmepriv = & padapter->mlmepriv;
#line 434
  pattrib->qsel = pattrib->priority;
#line 435
  spin_lock_bh(& pxmitpriv->lock);
#line 438
  tmp = xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe);
#line 438
  if (tmp != 0) {
#line 440
    pstapriv = & padapter->stapriv;
#line 442
    spin_unlock_bh(& pxmitpriv->lock);
#line 444
    if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 445
      psta = pattrib->psta;
    } else {
#line 447
      psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->ra));
    }
#line 449
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 450
      if (psta->sleepq_len > 32U) {
#line 451
        wakeup_sta_to_xmit23a(padapter, psta);
      } else {

      }
    } else {

    }
#line 454
    return (0);
  } else {

  }
#line 458
  tmp___0 = rtw_txframes_sta_ac_pending23a(padapter, pattrib);
#line 458
  if (tmp___0 > 0) {
#line 459
    goto enqueue;
  } else {

  }
#line 461
  tmp___1 = check_fwstate(pmlmepriv, 2176);
#line 461
  if ((int )tmp___1) {
#line 462
    goto enqueue;
  } else {

  }
#line 464
  pxmitbuf = rtw_alloc_xmitbuf23a(pxmitpriv);
#line 465
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 466
    goto enqueue;
  } else {

  }
#line 468
  spin_unlock_bh(& pxmitpriv->lock);
#line 470
  pxmitframe->pxmitbuf = pxmitbuf;
#line 471
  pxmitframe->buf_addr = pxmitbuf->pbuf;
#line 472
  pxmitbuf->priv_data = (void *)pxmitframe;
#line 474
  tmp___2 = xmitframe_direct(padapter, pxmitframe);
#line 474
  if (tmp___2 != 1) {
#line 475
    rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
#line 476
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
  } else {

  }
#line 478
  return (1);
  enqueue: 
#line 481
  res = rtw_xmitframe_enqueue23a(padapter, pxmitframe);
#line 482
  spin_unlock_bh(& pxmitpriv->lock);
#line 484
  if (res != 1) {
#line 485
    if (GlobalDebugLevel23A > 3U) {
#line 485
      rt_trace(2, 4, "pre_xmitframe: enqueue xmitframe fail\n");
    } else {

    }
#line 487
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
#line 490
    pxmitpriv->tx_pkts = pxmitpriv->tx_pkts - 1ULL;
#line 491
    pxmitpriv->tx_drop = pxmitpriv->tx_drop + 1ULL;
#line 492
    return (1);
  } else {

  }
#line 494
  return (0);
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.c"
int rtl8723au_mgnt_xmit(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) 
{ 
  int tmp ;

  {
#line 500
  tmp = rtw_dump_xframe(padapter, pmgntframe);
#line 500
  return (tmp);
}
}
#line 503 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.c"
int rtl8723au_hal_xmitframe_enqueue(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  struct xmit_priv *pxmitpriv ;
  int err ;

  {
#line 506
  pxmitpriv = & padapter->xmitpriv;
#line 509
  err = rtw_xmitframe_enqueue23a(padapter, pxmitframe);
#line 510
  if (err != 1) {
#line 511
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
#line 514
    pxmitpriv->tx_pkts = pxmitpriv->tx_pkts - 1ULL;
#line 515
    pxmitpriv->tx_drop = pxmitpriv->tx_drop + 1ULL;
  } else {
#line 517
    tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
  }
#line 519
  return (err);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
bool ldv_queue_work_on_579(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
bool ldv_queue_delayed_work_on_580(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
bool ldv_queue_work_on_581(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
void ldv_flush_workqueue_582(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
bool ldv_queue_delayed_work_on_583(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_593(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_595(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_594(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_597(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_596(struct workqueue_struct *ldv_func_arg1 ) ;
#line 98 "drivers/staging/rtl8723au/include/hal_intf.h"
int rtl8723au_hal_init(struct rtw_adapter *Adapter ) ;
#line 99
int rtl8723au_hal_deinit(struct rtw_adapter *padapter ) ;
#line 227 "drivers/staging/rtl8723au/include/rtw_pwrctrl.h"
enum rt_rf_power_state RfOnOffDetect23a(struct rtw_adapter *pAdapter ) ;
#line 41 "drivers/staging/rtl8723au/include/osdep_intf.h"
int rtl8723au_inirp_init(struct rtw_adapter *Adapter ) ;
#line 42
int rtl8723au_inirp_deinit(struct rtw_adapter *Adapter ) ;
#line 34 "drivers/staging/rtl8723au/include/rtl8723a_bt_intf.h"
void rtl8723a_dual_antenna_detection(struct rtw_adapter *padapter ) ;
#line 35
void rtl8723a_BT_init_hwconfig(struct rtw_adapter *padapter ) ;
#line 34 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
void BT_HaltProcess(struct rtw_adapter *padapter ) ;
#line 523 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
void rtl8723a_read_adapter_info(struct rtw_adapter *Adapter ) ;
#line 24 "drivers/staging/rtl8723au/include/usb_ops_linux.h"
int rtl8723au_read_port(struct rtw_adapter *adapter , u32 cnt , struct recv_buf *precvbuf ) ;
#line 26
void rtl8723au_read_port_cancel(struct rtw_adapter *padapter ) ;
#line 30
int rtl8723au_read_interrupt(struct rtw_adapter *adapter ) ;
#line 66 "drivers/staging/rtl8723au/include/usb_ops.h"
bool rtl8723au_chip_configure(struct rtw_adapter *padapter ) ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void phy_SsPwrSwitch92CU(struct rtw_adapter *Adapter , enum rt_rf_power_state eRFPowerState ) ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _ConfigChipOutEP(struct rtw_adapter *pAdapter , u8 NumOutPipe ) 
{ 
  u8 value8 ;
  struct hal_data_8723a *pHalData ;

  {
#line 35
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 37
  pHalData->OutEpQueueSel = 0U;
#line 38
  pHalData->OutEpNumber = 0U;
#line 41
  value8 = rtl8723au_read8(pAdapter, 65126);
#line 43
  if (((int )value8 & 15) != 0) {
#line 44
    pHalData->OutEpQueueSel = (u8 )((unsigned int )pHalData->OutEpQueueSel | 1U);
#line 45
    pHalData->OutEpNumber = (u8 )((int )pHalData->OutEpNumber + 1);
  } else {

  }
#line 48
  if ((((int )value8 >> 4) & 15) != 0) {
#line 49
    pHalData->OutEpQueueSel = (u8 )((unsigned int )pHalData->OutEpQueueSel | 4U);
#line 50
    pHalData->OutEpNumber = (u8 )((int )pHalData->OutEpNumber + 1);
  } else {

  }
#line 54
  value8 = rtl8723au_read8(pAdapter, 65127);
#line 55
  if (((int )value8 & 15) != 0) {
#line 56
    pHalData->OutEpQueueSel = (u8 )((unsigned int )pHalData->OutEpQueueSel | 2U);
#line 57
    pHalData->OutEpNumber = (u8 )((int )pHalData->OutEpNumber + 1);
  } else {

  }
#line 59
  return;
}
}
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
bool rtl8723au_chip_configure(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dvobj_priv *pdvobjpriv ;
  u8 NumInPipe ;
  u8 NumOutPipe ;
  bool tmp ;

  {
#line 68
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 69
  pdvobjpriv = padapter->dvobj;
#line 70
  NumInPipe = pdvobjpriv->RtNumInPipes;
#line 71
  NumOutPipe = pdvobjpriv->RtNumOutPipes;
#line 73
  _ConfigChipOutEP(padapter, (int )NumOutPipe);
#line 76
  if ((unsigned int )pHalData->OutEpNumber == 1U) {
#line 77
    if ((unsigned int )NumInPipe != 1U) {
#line 78
      return (0);
    } else {

    }
  } else {

  }
#line 81
  tmp = Hal_MappingOutPipe23a(padapter, (int )NumOutPipe);
#line 81
  return (tmp);
}
}
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static int _InitPowerOn(struct rtw_adapter *padapter ) 
{ 
  u16 value16 ;
  u8 value8 ;
  u8 tmp ;

  {
#line 91
  rtl8723au_write8(padapter, 28, 0);
#line 94
  tmp = HalPwrSeqCmdParsing23a(padapter, 255, 15, 2, (struct wlan_pwr_cfg *)(& rtl8723AU_card_enable_flow));
#line 94
  if ((unsigned int )tmp == 0U) {
#line 96
    return (0);
  } else {

  }
#line 99
  value8 = rtl8723au_read8(padapter, 6);
#line 100
  rtl8723au_write8(padapter, 6, (int )((unsigned int )value8 | 8U));
#line 105
  value16 = rtl8723au_read16(padapter, 256);
#line 106
  value16 = (u16 )((unsigned int )value16 | 1791U);
#line 109
  rtl8723au_write16(padapter, 256, (int )value16);
#line 112
  PHY_SetBBReg(padapter, 48U, 1879048192U, 6U);
#line 114
  return (1);
}
}
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitInterrupt(struct rtw_adapter *Adapter ) 
{ 
  u32 value32 ;

  {
#line 123
  value32 = 4294967295U;
#line 124
  rtl8723au_write32(Adapter, 292, value32);
#line 127
  rtl8723au_write32(Adapter, 288, value32);
#line 128
  return;
}
}
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitQueueReservedPage(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct registry_priv *pregistrypriv ;
  u32 numHQ ;
  u32 numLQ ;
  u32 numNQ ;
  u32 numPubQ ;
  u32 value32 ;
  u8 value8 ;
  bool bWiFiConfig ;

  {
#line 132
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 133
  pregistrypriv = & Adapter->registrypriv;
#line 134
  numHQ = 0U;
#line 135
  numLQ = 0U;
#line 136
  numNQ = 0U;
#line 140
  bWiFiConfig = (unsigned int )pregistrypriv->wifi_spec != 0U;
#line 145
  numPubQ = (int )bWiFiConfig ? 176U : 231U;
#line 147
  if ((int )pHalData->OutEpQueueSel & 1) {
#line 148
    numHQ = (int )bWiFiConfig ? 41U : 12U;
  } else {

  }
#line 152
  if (((unsigned long )pHalData->OutEpQueueSel & 2UL) != 0UL) {
#line 153
    numLQ = (int )bWiFiConfig ? 28U : 2U;
  } else {

  }
#line 158
  if (((unsigned long )pHalData->OutEpQueueSel & 4UL) != 0UL) {
#line 159
    numNQ = (int )bWiFiConfig ? 28U : 2U;
  } else {

  }
#line 162
  value8 = (unsigned char )numNQ;
#line 163
  rtl8723au_write8(Adapter, 532, (int )value8);
#line 166
  value32 = (((numHQ & 255U) | ((numLQ << 8) & 65535U)) | ((numPubQ & 255U) << 16)) | 2147483648U;
#line 167
  rtl8723au_write32(Adapter, 512, value32);
#line 168
  return;
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitTxBufferBoundary(struct rtw_adapter *Adapter ) 
{ 
  struct registry_priv *pregistrypriv ;
  u8 txpktbuf_bndy ;

  {
#line 172
  pregistrypriv = & Adapter->registrypriv;
#line 176
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
#line 177
    txpktbuf_bndy = 249U;
  } else {
#line 179
    txpktbuf_bndy = 246U;
  }
#line 181
  rtl8723au_write8(Adapter, 1060, (int )txpktbuf_bndy);
#line 182
  rtl8723au_write8(Adapter, 1061, (int )txpktbuf_bndy);
#line 183
  rtl8723au_write8(Adapter, 1117, (int )txpktbuf_bndy);
#line 184
  rtl8723au_write8(Adapter, 276, (int )txpktbuf_bndy);
#line 185
  rtl8723au_write8(Adapter, 521, (int )txpktbuf_bndy);
#line 186
  return;
}
}
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitPageBoundary(struct rtw_adapter *Adapter ) 
{ 
  u16 rxff_bndy ;

  {
#line 192
  rxff_bndy = 10239U;
#line 194
  rtl8723au_write16(Adapter, 278, (int )rxff_bndy);
#line 195
  return;
}
}
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitNormalChipRegPriority(struct rtw_adapter *Adapter , u16 beQ , u16 bkQ ,
                                       u16 viQ , u16 voQ , u16 mgtQ , u16 hiQ ) 
{ 
  u16 value16 ;
  u16 tmp ;

  {
#line 203
  tmp = rtl8723au_read16(Adapter, 268);
#line 203
  value16 = (unsigned int )tmp & 7U;
#line 205
  value16 = (u16 )(((((((int )((short )(((int )beQ & 3) << 8)) | (int )((short )(((int )bkQ & 3) << 10))) | ((int )((short )((int )viQ << 6)) & 255)) | (int )((short )(((int )voQ & 3) << 4))) | (int )((short )(((int )mgtQ & 3) << 12))) | (int )((short )((int )hiQ << 14))) | (int )((short )value16));
#line 209
  rtl8723au_write16(Adapter, 268, (int )value16);
#line 210
  return;
}
}
#line 212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitNormalChipOneOutEpPriority(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u16 value ;

  {
#line 214
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 215
  value = 0U;
#line 217
  switch ((int )pHalData->OutEpQueueSel) {
  case 1: 
#line 219
  value = 3U;
#line 220
  goto ldv_55852;
  case 2: 
#line 222
  value = 1U;
#line 223
  goto ldv_55852;
  case 4: 
#line 225
  value = 2U;
#line 226
  goto ldv_55852;
  default: ;
#line 229
  goto ldv_55852;
  }
  ldv_55852: 
#line 232
  _InitNormalChipRegPriority(Adapter, (int )value, (int )value, (int )value, (int )value,
                             (int )value, (int )value);
#line 233
  return;
}
}
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitNormalChipTwoOutEpPriority(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct registry_priv *pregistrypriv ;
  u16 beQ ;
  u16 bkQ ;
  u16 viQ ;
  u16 voQ ;
  u16 mgtQ ;
  u16 hiQ ;
  u16 valueHi ;
  u16 valueLow ;

  {
#line 238
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 239
  pregistrypriv = & Adapter->registrypriv;
#line 241
  valueHi = 0U;
#line 242
  valueLow = 0U;
#line 244
  switch ((int )pHalData->OutEpQueueSel) {
  case 3: 
#line 246
  valueHi = 3U;
#line 247
  valueLow = 1U;
#line 248
  goto ldv_55870;
  case 6: 
#line 250
  valueHi = 2U;
#line 251
  valueLow = 1U;
#line 252
  goto ldv_55870;
  case 5: 
#line 254
  valueHi = 3U;
#line 255
  valueLow = 2U;
#line 256
  goto ldv_55870;
  default: ;
#line 259
  goto ldv_55870;
  }
  ldv_55870: ;
#line 262
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
#line 263
    beQ = valueLow;
#line 264
    bkQ = valueLow;
#line 265
    viQ = valueHi;
#line 266
    voQ = valueHi;
#line 267
    mgtQ = valueHi;
#line 268
    hiQ = valueHi;
  } else {
#line 270
    beQ = valueLow;
#line 271
    bkQ = valueHi;
#line 272
    viQ = valueHi;
#line 273
    voQ = valueLow;
#line 274
    mgtQ = valueHi;
#line 275
    hiQ = valueHi;
  }
#line 278
  _InitNormalChipRegPriority(Adapter, (int )beQ, (int )bkQ, (int )viQ, (int )voQ,
                             (int )mgtQ, (int )hiQ);
#line 279
  return;
}
}
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitNormalChipThreeOutEpPriority(struct rtw_adapter *Adapter ) 
{ 
  struct registry_priv *pregistrypriv ;
  u16 beQ ;
  u16 bkQ ;
  u16 viQ ;
  u16 voQ ;
  u16 mgtQ ;
  u16 hiQ ;

  {
#line 283
  pregistrypriv = & Adapter->registrypriv;
#line 286
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
#line 287
    beQ = 1U;
#line 288
    bkQ = 1U;
#line 289
    viQ = 2U;
#line 290
    voQ = 3U;
#line 291
    mgtQ = 3U;
#line 292
    hiQ = 3U;
  } else {
#line 294
    beQ = 1U;
#line 295
    bkQ = 2U;
#line 296
    viQ = 2U;
#line 297
    voQ = 3U;
#line 298
    mgtQ = 3U;
#line 299
    hiQ = 3U;
  }
#line 301
  _InitNormalChipRegPriority(Adapter, (int )beQ, (int )bkQ, (int )viQ, (int )voQ,
                             (int )mgtQ, (int )hiQ);
#line 302
  return;
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitQueuePriority(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 306
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 308
  switch ((int )pHalData->OutEpNumber) {
  case 1: 
#line 310
  _InitNormalChipOneOutEpPriority(Adapter);
#line 311
  goto ldv_55889;
  case 2: 
#line 313
  _InitNormalChipTwoOutEpPriority(Adapter);
#line 314
  goto ldv_55889;
  case 3: 
#line 316
  _InitNormalChipThreeOutEpPriority(Adapter);
#line 317
  goto ldv_55889;
  default: ;
#line 320
  goto ldv_55889;
  }
  ldv_55889: ;
#line 323
  return;
}
}
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitTransferPageSize(struct rtw_adapter *Adapter ) 
{ 
  u8 value8 ;

  {
#line 329
  value8 = 17U;
#line 330
  rtl8723au_write8(Adapter, 260, (int )value8);
#line 331
  return;
}
}
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitDriverInfoSize(struct rtw_adapter *Adapter , u8 drvInfoSize ) 
{ 


  {
#line 335
  rtl8723au_write8(Adapter, 1551, (int )drvInfoSize);
#line 336
  return;
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitWMACSetting(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 340
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 343
  pHalData->ReceiveConfig = 1879072974U;
#line 350
  rtl8723au_write32(Adapter, 1544, pHalData->ReceiveConfig);
#line 353
  rtl8723au_write32(Adapter, 1568, 4294967295U);
#line 354
  rtl8723au_write32(Adapter, 1572, 4294967295U);
#line 355
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitAdaptiveCtrl(struct rtw_adapter *Adapter ) 
{ 
  u16 value16 ;
  u32 value32 ;

  {
#line 383
  value32 = rtl8723au_read32(Adapter, 1088);
#line 384
  value32 = value32 & 4293918720U;
#line 385
  value32 = value32 | 1048561U;
#line 386
  rtl8723au_write32(Adapter, 1088, value32);
#line 392
  value16 = 4112U;
#line 393
  rtl8723au_write16(Adapter, 1064, (int )value16);
#line 396
  value16 = 12336U;
#line 397
  rtl8723au_write16(Adapter, 1066, (int )value16);
#line 398
  return;
}
}
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitRateFallback(struct rtw_adapter *Adapter ) 
{ 


  {
#line 403
  rtl8723au_write32(Adapter, 1072, 0U);
#line 404
  rtl8723au_write32(Adapter, 1076, 268960772U);
#line 405
  rtl8723au_write32(Adapter, 1080, 67305985U);
#line 406
  rtl8723au_write32(Adapter, 1084, 134678021U);
#line 407
  return;
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitEDCA(struct rtw_adapter *Adapter ) 
{ 


  {
#line 412
  rtl8723au_write16(Adapter, 1064, 4106);
#line 413
  rtl8723au_write16(Adapter, 1594, 4106);
#line 416
  rtl8723au_write16(Adapter, 1300, 4106);
#line 419
  rtl8723au_write16(Adapter, 1302, 4106);
#line 422
  rtl8723au_write32(Adapter, 1288, 6202411U);
#line 423
  rtl8723au_write32(Adapter, 1292, 42063U);
#line 424
  rtl8723au_write32(Adapter, 1284, 6202148U);
#line 425
  rtl8723au_write32(Adapter, 1280, 3121702U);
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitRDGSetting(struct rtw_adapter *Adapter ) 
{ 


  {
#line 430
  rtl8723au_write8(Adapter, 1316, 255);
#line 431
  rtl8723au_write16(Adapter, 1348, 512);
#line 432
  rtl8723au_write8(Adapter, 1123, 5);
#line 433
  return;
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitRetryFunction(struct rtw_adapter *Adapter ) 
{ 
  u8 value8 ;

  {
#line 439
  value8 = rtl8723au_read8(Adapter, 1056);
#line 440
  value8 = (u8 )((unsigned int )value8 | 128U);
#line 441
  rtl8723au_write8(Adapter, 1056, (int )value8);
#line 444
  rtl8723au_write8(Adapter, 1600, 64);
#line 445
  return;
}
}
#line 447 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _InitRFType(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 449
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 451
  pHalData->rf_type = 3U;
#line 452
  return;
}
}
#line 455 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _BBTurnOnBlock(struct rtw_adapter *Adapter ) 
{ 


  {
#line 457
  PHY_SetBBReg(Adapter, 2048U, 16777216U, 1U);
#line 458
  PHY_SetBBReg(Adapter, 2048U, 33554432U, 1U);
#line 459
  return;
}
}
#line 462 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _RfPowerSave(struct rtw_adapter *padapter ) 
{ 


  {
#line 464
  return;
}
}
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
enum rt_rf_power_state RfOnOffDetect23a(struct rtw_adapter *pAdapter ) 
{ 
  u8 val8 ;
  enum rt_rf_power_state rfpowerstate ;
  u8 tmp ;

  {
#line 475
  rfpowerstate = 2;
#line 477
  tmp = rtl8723au_read8(pAdapter, 67);
#line 477
  rtl8723au_write8(pAdapter, 67, (int )tmp & 247);
#line 480
  val8 = rtl8723au_read8(pAdapter, 66);
#line 481
  if (GlobalDebugLevel23A > 3U) {
#line 481
    printk("\016RTL8723AU: GPIO_IN =%02x\n", (int )val8);
  } else {

  }
#line 482
  rfpowerstate = ((unsigned long )val8 & 8UL) != 0UL ? 0 : 2;
#line 484
  return (rfpowerstate);
}
}
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
int rtl8723au_hal_init(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct pwrctrl_priv *pwrctrlpriv ;
  struct registry_priv *pregistrypriv ;
  u8 val8 ;
  u32 boundary ;
  int status ;
  bool mac_on ;
  unsigned long init_start_time ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 489
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 490
  pwrctrlpriv = & Adapter->pwrctrlpriv;
#line 491
  pregistrypriv = & Adapter->registrypriv;
#line 492
  val8 = 0U;
#line 494
  status = 1;
#line 497
  init_start_time = jiffies;
#line 499
  Adapter->hw_init_completed = 0U;
#line 501
  if ((unsigned int )Adapter->pwrctrlpriv.bkeepfwalive != 0U) {
#line 502
    phy_SsPwrSwitch92CU(Adapter, 0);
#line 504
    if ((unsigned int )pHalData->bIQKInitialized != 0U) {
#line 505
      rtl8723a_phy_iq_calibrate(Adapter, 1);
    } else {
#line 507
      rtl8723a_phy_iq_calibrate(Adapter, 0);
#line 508
      pHalData->bIQKInitialized = 1U;
    }
#line 510
    rtl8723a_odm_check_tx_power_tracking(Adapter);
#line 511
    rtl8723a_phy_lc_calibrate(Adapter);
#line 513
    goto exit;
  } else {

  }
#line 517
  val8 = rtl8723au_read8(Adapter, 256);
#line 518
  if (GlobalDebugLevel23A > 6U) {
#line 518
    rt_trace(32768, 7, "%s: REG_CR 0x100 = 0x%02x\n", "rtl8723au_hal_init", (int )val8);
  } else {

  }
#line 524
  if ((unsigned int )val8 == 234U) {
#line 525
    mac_on = 0;
  } else {
#line 527
    mac_on = 1;
#line 528
    if (GlobalDebugLevel23A > 6U) {
#line 528
      rt_trace(32768, 7, "%s: MAC has already power on\n", "rtl8723au_hal_init");
    } else {

    }
  }
#line 532
  status = _InitPowerOn(Adapter);
#line 533
  if (status == 0) {
#line 534
    if (GlobalDebugLevel23A > 3U) {
#line 534
      rt_trace(32768, 4, "Failed to init power on!\n");
    } else {

    }
#line 536
    goto exit;
  } else {

  }
#line 539
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
#line 540
    boundary = 249U;
  } else {
#line 543
    boundary = 246U;
  }
#line 546
  if (! mac_on) {
#line 547
    status = InitLLTTable23a(Adapter, boundary);
#line 548
    if (status == 0) {
#line 549
      if (GlobalDebugLevel23A > 3U) {
#line 549
        rt_trace(32768, 4, "Failed to init LLT table\n");
      } else {

      }
#line 551
      goto exit;
    } else {

    }
  } else {

  }
#line 555
  if ((int )pHalData->bRDGEnable) {
#line 556
    _InitRDGSetting(Adapter);
  } else {

  }
#line 558
  status = rtl8723a_FirmwareDownload(Adapter);
#line 559
  if (status != 1) {
#line 560
    Adapter->bFWReady = 0U;
#line 561
    if (GlobalDebugLevel23A > 3U) {
#line 561
      printk("\016RTL8723AU: fw download fail!\n");
    } else {

    }
#line 562
    goto exit;
  } else {
#line 564
    Adapter->bFWReady = 1U;
#line 565
    if (GlobalDebugLevel23A > 3U) {
#line 565
      printk("\016RTL8723AU: fw download ok!\n");
    } else {

    }
  }
#line 568
  rtl8723a_InitializeFirmwareVars(Adapter);
#line 570
  if ((unsigned int )pwrctrlpriv->reg_rfoff == 1U) {
#line 571
    pwrctrlpriv->rf_pwrstate = 2;
  } else {

  }
#line 581
  _InitRFType(Adapter);
#line 585
  pHalData->CurrentChannel = 6U;
#line 587
  status = PHY_MACConfig8723A(Adapter);
#line 588
  if (status == 0) {
#line 589
    if (GlobalDebugLevel23A > 3U) {
#line 589
      printk("\016RTL8723AU: PHY_MACConfig8723A fault !!\n");
    } else {

    }
#line 590
    goto exit;
  } else {

  }
#line 596
  status = PHY_BBConfig8723A(Adapter);
#line 597
  if (status == 0) {
#line 598
    if (GlobalDebugLevel23A > 3U) {
#line 598
      printk("\016RTL8723AU: PHY_BBConfig8723A fault !!\n");
    } else {

    }
#line 599
    goto exit;
  } else {

  }
#line 605
  status = PHY_RF6052_Config8723A(Adapter);
#line 606
  if (status == 0) {
#line 607
    if (GlobalDebugLevel23A > 3U) {
#line 607
      printk("\016RTL8723AU: PHY_RF6052_Config8723A failed!!\n");
    } else {

    }
#line 608
    goto exit;
  } else {

  }
#line 612
  rtl8723au_write32(Adapter, 36, 58818701U);
#line 613
  rtl8723au_write32(Adapter, 40, 4043308931U);
#line 614
  rtl8723au_write32(Adapter, 40, 4043308930U);
#line 615
  rtl8723au_write32(Adapter, 40, 4043308931U);
#line 619
  rtl8723au_write32(Adapter, 2052, 3U);
#line 621
  rtl8723au_write32(Adapter, 2160, 117442400U);
#line 623
  rtl8723au_write32(Adapter, 2144, 1727398416U);
#line 625
  if (GlobalDebugLevel23A > 6U) {
#line 625
    tmp = rtl8723au_read32(Adapter, 2160);
#line 625
    rt_trace(32768, 7, "%s: 0x870 = value 0x%x\n", "rtl8723au_hal_init", tmp);
  } else {

  }
#line 632
  pHalData->RfRegChnlVal[0] = PHY_QueryRFReg(Adapter, 0, 24U, 1048575U);
#line 634
  pHalData->RfRegChnlVal[1] = PHY_QueryRFReg(Adapter, 1, 24U, 1048575U);
#line 637
  if (! mac_on) {
#line 638
    _InitQueueReservedPage(Adapter);
#line 639
    _InitTxBufferBoundary(Adapter);
  } else {

  }
#line 641
  _InitQueuePriority(Adapter);
#line 642
  _InitPageBoundary(Adapter);
#line 643
  _InitTransferPageSize(Adapter);
#line 646
  _InitDriverInfoSize(Adapter, 4);
#line 648
  _InitInterrupt(Adapter);
#line 649
  hw_var_set_macaddr(Adapter, (u8 *)(& Adapter->eeprompriv.mac_addr));
#line 650
  rtl8723a_set_media_status(Adapter, 2);
#line 651
  _InitWMACSetting(Adapter);
#line 652
  _InitAdaptiveCtrl(Adapter);
#line 653
  _InitEDCA(Adapter);
#line 654
  _InitRateFallback(Adapter);
#line 655
  _InitRetryFunction(Adapter);
#line 656
  rtl8723a_InitBeaconParameters(Adapter);
#line 658
  _BBTurnOnBlock(Adapter);
#line 661
  rtl8723a_cam_invalidate_all(Adapter);
#line 664
  PHY_SetTxPowerLevel8723A(Adapter, (int )pHalData->CurrentChannel);
#line 666
  rtl8723a_InitAntenna_Selection(Adapter);
#line 670
  rtl8723au_write8(Adapter, 1059, 255);
#line 676
  rtl8723au_write32(Adapter, 1228, 33685503U);
#line 678
  if ((unsigned int )pregistrypriv->wifi_spec != 0U) {
#line 679
    rtl8723au_write16(Adapter, 1120, 0);
  } else {

  }
#line 682
  _RfPowerSave(Adapter);
#line 688
  if ((unsigned int )pwrctrlpriv->rf_pwrstate == 0U) {
#line 689
    if ((unsigned int )pHalData->bIQKInitialized != 0U) {
#line 690
      rtl8723a_phy_iq_calibrate(Adapter, 1);
    } else {
#line 692
      rtl8723a_phy_iq_calibrate(Adapter, 0);
#line 693
      pHalData->bIQKInitialized = 1U;
    }
#line 696
    rtl8723a_odm_check_tx_power_tracking(Adapter);
#line 698
    rtl8723a_phy_lc_calibrate(Adapter);
#line 700
    rtl8723a_dual_antenna_detection(Adapter);
  } else {

  }
#line 704
  rtl8723au_write8(Adapter, 65088, 224);
#line 705
  rtl8723au_write8(Adapter, 65089, 141);
#line 706
  rtl8723au_write8(Adapter, 65090, 128);
#line 707
  rtl8723au_write32(Adapter, 524, 16581408U);
#line 709
  if (((unsigned int )pHalData->VersionID.ICType != 2U && (unsigned int )pHalData->VersionID.ICType != 1U) || ((unsigned int )pHalData->VersionID.VendorType != 1U || (unsigned int )pHalData->VersionID.CUTVersion != 0U)) {
#line 711
    rtl8723au_write8(Adapter, 65088, 230);
#line 712
    rtl8723au_write8(Adapter, 65089, 148);
#line 713
    rtl8723au_write8(Adapter, 65090, 128);
#line 716
    rtl8723au_write8(Adapter, 65088, 224);
#line 717
    rtl8723au_write8(Adapter, 65089, 25);
#line 718
    rtl8723au_write8(Adapter, 65090, 128);
#line 721
    rtl8723au_write8(Adapter, 65088, 229);
#line 722
    rtl8723au_write8(Adapter, 65089, 145);
#line 723
    rtl8723au_write8(Adapter, 65090, 128);
#line 726
    rtl8723au_write8(Adapter, 65088, 226);
#line 727
    rtl8723au_write8(Adapter, 65089, 129);
#line 728
    rtl8723au_write8(Adapter, 65090, 128);
  } else {

  }
#line 735
  rtl8723a_BT_init_hwconfig(Adapter);
#line 737
  rtl8723a_InitHalDm(Adapter);
#line 739
  val8 = 235U;
#line 741
  rtl8723au_write8(Adapter, 1618, (int )val8);
#line 744
  tmp___0 = rtl8723au_read32(Adapter, 2048);
#line 744
  if ((tmp___0 & 4278190080U) != 2197815296U) {
#line 746
    PHY_SetBBReg(Adapter, 2048U, 16777216U, 1U);
#line 747
    if (GlobalDebugLevel23A > 3U) {
#line 747
      rt_trace(32768, 4, "%s: IQK fail recover\n", "rtl8723au_hal_init");
    } else {

    }
  } else {

  }
#line 752
  tmp___1 = rtl8723au_read32(Adapter, 1056);
#line 752
  rtl8723au_write32(Adapter, 1056, tmp___1 | 4096U);
  exit: ;
#line 756
  if (status == 1) {
#line 757
    Adapter->hw_init_completed = 1U;
#line 759
    if ((unsigned int )Adapter->registrypriv.notch_filter == 1U) {
#line 760
      rtl8723a_notch_filter(Adapter, 1);
    } else {

    }
  } else {

  }
#line 763
  if (GlobalDebugLevel23A > 3U) {
#line 763
    tmp___2 = jiffies_to_msecs((unsigned long )jiffies - init_start_time);
#line 763
    printk("\016RTL8723AU: %s in %dms\n", "rtl8723au_hal_init", tmp___2);
  } else {

  }
#line 765
  return (status);
}
}
#line 768 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void phy_SsPwrSwitch92CU(struct rtw_adapter *Adapter , enum rt_rf_power_state eRFPowerState ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 sps0 ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
#line 771
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 774
  sps0 = rtl8723au_read8(Adapter, 17);
#line 776
  switch ((unsigned int )eRFPowerState) {
  case 0U: 
#line 783
  rtl8723au_write8(Adapter, 17, (int )((unsigned int )sps0 | 9U));
#line 788
  if ((unsigned int )pHalData->rf_type == 2U) {
#line 789
    PHY_SetBBReg(Adapter, 2168U, 3670072U, 1U);
  } else {
#line 792
    PHY_SetBBReg(Adapter, 2168U, 56U, 1U);
  }
#line 794
  PHY_SetBBReg(Adapter, 3076U, 240U, 1U);
#line 795
  PHY_SetBBReg(Adapter, 2048U, 2U, 0U);
#line 798
  if ((unsigned int )pHalData->rf_type == 2U) {
#line 799
    rtl8723au_write32(Adapter, 3696, 1675306400U);
  } else
#line 800
  if ((unsigned int )pHalData->rf_type == 3U) {
#line 801
    rtl8723au_write32(Adapter, 3696, 1662723488U);
  } else {

  }
#line 807
  PHY_SetRFReg(Adapter, 0, 0U, 1048575U, 208277U);
#line 809
  if ((unsigned int )pHalData->rf_type == 2U) {
#line 810
    PHY_SetRFReg(Adapter, 1, 0U, 1048575U, 208277U);
  } else {

  }
#line 813
  goto ldv_55961;
  case 1U: ;
  case 2U: ;
#line 816
  if (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && ((unsigned int )pHalData->VersionID.VendorType == 1U && (unsigned int )pHalData->VersionID.CUTVersion == 1U)) {
#line 817
    sps0 = (unsigned int )sps0 & 254U;
  } else {
#line 819
    sps0 = (unsigned int )sps0 & 246U;
  }
#line 821
  if (GlobalDebugLevel23A > 3U) {
#line 821
    rt_trace(16384, 4, "SS LVL1\n");
  } else {

  }
#line 831
  tmp = rtl8723au_read32(Adapter, 2168);
#line 831
  Adapter->pwrctrlpriv.PS_BBRegBackup[0] = (unsigned long )tmp;
#line 833
  tmp___0 = rtl8723au_read32(Adapter, 3076);
#line 833
  Adapter->pwrctrlpriv.PS_BBRegBackup[1] = (unsigned long )tmp___0;
#line 835
  tmp___1 = rtl8723au_read32(Adapter, 2048);
#line 835
  Adapter->pwrctrlpriv.PS_BBRegBackup[2] = (unsigned long )tmp___1;
#line 837
  if ((unsigned int )pHalData->rf_type == 2U) {
#line 838
    PHY_SetBBReg(Adapter, 2168U, 3670072U, 0U);
  } else
#line 840
  if ((unsigned int )pHalData->rf_type == 3U) {
#line 841
    PHY_SetBBReg(Adapter, 2168U, 56U, 0U);
  } else {

  }
#line 843
  PHY_SetBBReg(Adapter, 3076U, 240U, 0U);
#line 844
  PHY_SetBBReg(Adapter, 2048U, 2U, 1U);
#line 847
  tmp___2 = rtl8723au_read32(Adapter, 3696);
#line 847
  Adapter->pwrctrlpriv.PS_BBRegBackup[3] = (unsigned long )tmp___2;
#line 849
  if ((unsigned int )pHalData->rf_type == 2U) {
#line 850
    rtl8723au_write32(Adapter, 3696, 14362016U);
  } else
#line 851
  if ((unsigned int )pHalData->rf_type == 3U) {
#line 852
    rtl8723au_write32(Adapter, 3696, 1779104U);
  } else {

  }
#line 855
  PHY_SetRFReg(Adapter, 0, 0U, 1048575U, 0U);
#line 856
  if ((unsigned int )pHalData->rf_type == 2U) {
#line 857
    PHY_SetRFReg(Adapter, 1, 0U, 1048575U, 0U);
  } else {

  }
#line 861
  rtl8723au_write8(Adapter, 17, (int )sps0);
#line 862
  goto ldv_55961;
  default: ;
#line 864
  goto ldv_55961;
  }
  ldv_55961: ;
#line 867
  return;
}
}
#line 868 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void CardDisableRTL8723U(struct rtw_adapter *Adapter ) 
{ 
  u8 u1bTmp ;
  u8 tmp ;

  {
#line 872
  if (GlobalDebugLevel23A > 3U) {
#line 872
    printk("\016RTL8723AU: CardDisableRTL8723U\n");
  } else {

  }
#line 875
  HalPwrSeqCmdParsing23a(Adapter, 255, 15, 2, (struct wlan_pwr_cfg *)(& rtl8723AU_enter_lps_flow));
#line 879
  rtl8723au_write8(Adapter, 31, 0);
#line 882
  tmp = rtl8723au_read8(Adapter, 128);
#line 882
  if ((int )((signed char )tmp) < 0 && (unsigned int )Adapter->bFWReady != 0U) {
#line 884
    rtl8723a_FirmwareSelfReset(Adapter);
  } else {

  }
#line 887
  u1bTmp = rtl8723au_read8(Adapter, 3);
#line 888
  rtl8723au_write8(Adapter, 3, (int )u1bTmp & 251);
#line 891
  rtl8723au_write8(Adapter, 128, 0);
#line 895
  HalPwrSeqCmdParsing23a(Adapter, 255, 15, 2, (struct wlan_pwr_cfg *)(& rtl8723AU_card_disable_flow));
#line 900
  u1bTmp = rtl8723au_read8(Adapter, 29);
#line 901
  rtl8723au_write8(Adapter, 29, (int )u1bTmp & 254);
#line 902
  u1bTmp = rtl8723au_read8(Adapter, 29);
#line 903
  rtl8723au_write8(Adapter, 29, (int )((unsigned int )u1bTmp | 1U));
#line 906
  rtl8723au_write8(Adapter, 28, 14);
#line 907
  return;
}
}
#line 909 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
int rtl8723au_hal_deinit(struct rtw_adapter *padapter ) 
{ 


  {
#line 911
  if (GlobalDebugLevel23A > 3U) {
#line 911
    printk("\016RTL8723AU: ==> %s\n", "rtl8723au_hal_deinit");
  } else {

  }
#line 914
  BT_HaltProcess(padapter);
#line 920
  CardDisableRTL8723U(padapter);
#line 922
  padapter->hw_init_completed = 0U;
#line 924
  return (1);
}
}
#line 927 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
int rtl8723au_inirp_init(struct rtw_adapter *Adapter ) 
{ 
  u8 i ;
  struct recv_buf *precvbuf ;
  int status ;
  struct recv_priv *precvpriv ;
  struct hal_data_8723a *pHalData ;
  int tmp ;
  int tmp___0 ;

  {
#line 932
  precvpriv = & Adapter->recvpriv;
#line 933
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 935
  status = 1;
#line 937
  if (GlobalDebugLevel23A > 6U) {
#line 937
    rt_trace(32768, 7, "===> usb_inirp_init\n");
  } else {

  }
#line 940
  precvbuf = (struct recv_buf *)precvpriv->precv_buf;
#line 941
  i = 0U;
#line 941
  goto ldv_55983;
  ldv_55982: 
#line 942
  tmp = rtl8723au_read_port(Adapter, 0U, precvbuf);
#line 942
  if (tmp == 0) {
#line 943
    if (GlobalDebugLevel23A > 3U) {
#line 943
      rt_trace(32768, 4, "usb_rx_init: usb_read_port error\n");
    } else {

    }
#line 945
    status = 0;
#line 946
    goto exit;
  } else {

  }
#line 948
  precvbuf = precvbuf + 1;
#line 941
  i = (u8 )((int )i + 1);
  ldv_55983: ;
#line 941
  if ((unsigned int )i <= 3U) {
#line 943
    goto ldv_55982;
  } else {

  }
#line 950
  tmp___0 = rtl8723au_read_interrupt(Adapter);
#line 950
  if (tmp___0 == 0) {
#line 951
    if (GlobalDebugLevel23A > 3U) {
#line 951
      rt_trace(32768, 4, "%s: usb_read_interrupt error\n", "rtl8723au_inirp_init");
    } else {

    }
#line 953
    status = 0;
  } else {

  }
#line 955
  pHalData->IntrMask[0] = rtl8723au_read32(Adapter, 65080);
#line 956
  if (GlobalDebugLevel23A > 3U) {
#line 956
    printk("\016RTL8723AU: pHalData->IntrMask = 0x%04x\n", pHalData->IntrMask[0]);
  } else {

  }
#line 957
  pHalData->IntrMask[0] = pHalData->IntrMask[0] | 1280U;
#line 958
  rtl8723au_write32(Adapter, 65080, pHalData->IntrMask[0]);
  exit: ;
#line 960
  if (GlobalDebugLevel23A > 6U) {
#line 960
    rt_trace(32768, 7, "<=== usb_inirp_init\n");
  } else {

  }
#line 962
  return (status);
}
}
#line 965 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
int rtl8723au_inirp_deinit(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 967
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 969
  if (GlobalDebugLevel23A > 6U) {
#line 969
    rt_trace(32768, 7, "===> usb_rx_deinit\n");
  } else {

  }
#line 971
  rtl8723au_read_port_cancel(Adapter);
#line 972
  pHalData->IntrMask[0] = rtl8723au_read32(Adapter, 65080);
#line 973
  if (GlobalDebugLevel23A > 3U) {
#line 973
    printk("\016RTL8723AU: %s pHalData->IntrMask = 0x%04x\n", "rtl8723au_inirp_deinit",
           pHalData->IntrMask[0]);
  } else {

  }
#line 975
  pHalData->IntrMask[0] = 0U;
#line 976
  rtl8723au_write32(Adapter, 65080, pHalData->IntrMask[0]);
#line 977
  if (GlobalDebugLevel23A > 6U) {
#line 977
    rt_trace(32768, 7, "<=== usb_rx_deinit\n");
  } else {

  }
#line 979
  return (1);
}
}
#line 982 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _ReadBoardType(struct rtw_adapter *Adapter , u8 *PROMContent , bool AutoloadFail ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 boardType ;

  {
#line 985
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 986
  boardType = 0U;
#line 988
  if ((int )AutoloadFail) {
#line 989
    if ((unsigned int )pHalData->VersionID.ICType == 4U) {
#line 990
      pHalData->rf_type = 3U;
    } else {
#line 992
      pHalData->rf_type = 2U;
    }
#line 993
    pHalData->BoardType = boardType;
#line 994
    return;
  } else {

  }
#line 997
  boardType = *(PROMContent + 121UL);
#line 998
  boardType = (unsigned int )boardType & 224U;
#line 999
  boardType = (u8 )((int )boardType >> 5);
#line 1001
  pHalData->BoardType = boardType;
#line 1002
  if (GlobalDebugLevel23A > 3U) {
#line 1002
    printk("\016RTL8723AU: _ReadBoardType(%x)\n", (int )pHalData->BoardType);
  } else {

  }
#line 1004
  if ((unsigned int )boardType == 1U) {
#line 1005
    pHalData->ExternalPA = 1U;
  } else {

  }
#line 1006
  return;
}
}
#line 1008 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void Hal_EfuseParseMACAddr_8723AU(struct rtw_adapter *padapter , u8 *hwinfo ,
                                         bool AutoLoadFail ) 
{ 
  u16 i ;
  u8 sMacAddr[6U] ;
  struct eeprom_priv *pEEPROM ;

  {
#line 1012
  sMacAddr[0] = 0U;
#line 1012
  sMacAddr[1] = 224U;
#line 1012
  sMacAddr[2] = 76U;
#line 1012
  sMacAddr[3] = 135U;
#line 1012
  sMacAddr[4] = 35U;
#line 1012
  sMacAddr[5] = 0U;
#line 1013
  pEEPROM = & padapter->eeprompriv;
#line 1015
  if ((int )AutoLoadFail) {
#line 1016
    i = 0U;
#line 1016
    goto ldv_56007;
    ldv_56006: 
#line 1017
    pEEPROM->mac_addr[(int )i] = sMacAddr[(int )i];
#line 1016
    i = (u16 )((int )i + 1);
    ldv_56007: ;
#line 1016
    if ((unsigned int )i <= 5U) {
#line 1018
      goto ldv_56006;
    } else {

    }

  } else {
#line 1020
    memcpy((void *)(& pEEPROM->mac_addr), (void const   *)hwinfo + 198U, 6UL);
  }
#line 1024
  if (GlobalDebugLevel23A > 5U) {
#line 1024
    rt_trace(32768, 6, "Hal_EfuseParseMACAddr_8723AU: Permanent Address =%02x:%02x:%02x:%02x:%02x:%02x\n",
             (int )pEEPROM->mac_addr[0], (int )pEEPROM->mac_addr[1], (int )pEEPROM->mac_addr[2],
             (int )pEEPROM->mac_addr[3], (int )pEEPROM->mac_addr[4], (int )pEEPROM->mac_addr[5]);
  } else {

  }
#line 1025
  return;
}
}
#line 1031 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void readAdapterInfo(struct rtw_adapter *padapter ) 
{ 
  struct eeprom_priv *pEEPROM ;
  u8 hwinfo[256U] ;

  {
#line 1033
  pEEPROM = & padapter->eeprompriv;
#line 1037
  Hal_InitPGData(padapter, (u8 *)(& hwinfo));
#line 1038
  Hal_EfuseParseIDCode(padapter, (u8 *)(& hwinfo));
#line 1039
  Hal_EfuseParseEEPROMVer(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1041
  Hal_EfuseParseMACAddr_8723AU(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1043
  Hal_EfuseParsetxpowerinfo_8723A(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1045
  _ReadBoardType(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1046
  Hal_EfuseParseBTCoexistInfo_8723A(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1049
  rtl8723a_EfuseParseChnlPlan(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1051
  Hal_EfuseParseThermalMeter_8723A(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1055
  Hal_EfuseParseAntennaDiversity(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1058
  Hal_EfuseParseEEPROMVer(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1059
  Hal_EfuseParseCustomerID(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1061
  Hal_EfuseParseRateIndicationOption(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1063
  Hal_EfuseParseXtal_8723A(padapter, (u8 *)(& hwinfo), (int )pEEPROM->bautoload_fail_flag);
#line 1069
  if (GlobalDebugLevel23A > 3U) {
#line 1069
    printk("\016RTL8723AU: %s(): REPLACEMENT = %x\n", "readAdapterInfo", padapter->bDongle);
  } else {

  }
#line 1070
  return;
}
}
#line 1072 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void _ReadPROMContent(struct rtw_adapter *Adapter ) 
{ 
  struct eeprom_priv *pEEPROM ;
  u8 eeValue ;

  {
#line 1074
  pEEPROM = & Adapter->eeprompriv;
#line 1077
  eeValue = rtl8723au_read8(Adapter, 10);
#line 1079
  pEEPROM->EepromOrEfuse = ((unsigned long )eeValue & 16UL) != 0UL;
#line 1080
  pEEPROM->bautoload_fail_flag = ((unsigned long )eeValue & 32UL) == 0UL;
#line 1082
  if (GlobalDebugLevel23A > 3U) {
#line 1082
    printk("\016RTL8723AU: Boot from %s, Autoload %s !\n", (unsigned int )pEEPROM->EepromOrEfuse != 0U ? (char *)"EEPROM" : (char *)"EFUSE",
           (unsigned int )pEEPROM->bautoload_fail_flag != 0U ? (char *)"Fail" : (char *)"OK");
  } else {

  }
#line 1086
  readAdapterInfo(Adapter);
#line 1087
  return;
}
}
#line 1098 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
static void hal_EfuseCellSel(struct rtw_adapter *Adapter ) 
{ 
  u32 value32 ;

  {
#line 1102
  value32 = rtl8723au_read32(Adapter, 52);
#line 1103
  value32 = value32 & 4294966527U;
#line 1104
  rtl8723au_write32(Adapter, 52, value32);
#line 1105
  return;
}
}
#line 1107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
void rtl8723a_read_adapter_info(struct rtw_adapter *Adapter ) 
{ 
  unsigned long start ;
  unsigned int tmp ;

  {
#line 1109
  start = jiffies;
#line 1112
  Adapter->EepromAddressSize = GetEEPROMSize8723A(Adapter);
#line 1114
  if (GlobalDebugLevel23A > 3U) {
#line 1114
    printk("\016RTL8723AU: ====> _ReadAdapterInfo8723AU\n");
  } else {

  }
#line 1116
  hal_EfuseCellSel(Adapter);
#line 1118
  _ReadPROMContent(Adapter);
#line 1120
  if (GlobalDebugLevel23A > 3U) {
#line 1120
    tmp = jiffies_to_msecs((unsigned long )jiffies - start);
#line 1120
    printk("\016RTL8723AU: <==== _ReadAdapterInfo8723AU in %d ms\n", tmp);
  } else {

  }
#line 1121
  return;
}
}
#line 1128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
int GetHalDefVar8192CUsb(struct rtw_adapter *Adapter , enum hal_def_variable eVariable ,
                         void *pValue ) 
{ 
  struct hal_data_8723a *pHalData ;
  int bResult ;
  struct dm_odm_t *pDM_Odm ;

  {
#line 1131
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1132
  bResult = 1;
#line 1134
  switch ((unsigned int )eVariable) {
  case 0U: 
#line 1136
  *((int *)pValue) = pHalData->dmpriv.UndecoratedSmoothedPWDB;
#line 1137
  goto ldv_56036;
  case 1U: ;
#line 1139
  goto ldv_56036;
  case 2U: ;
#line 1141
  goto ldv_56036;
  case 3U: 
#line 1143
  *((u32 *)pValue) = 4U;
#line 1144
  goto ldv_56036;
  case 4U: 
#line 1146
  *((u32 *)pValue) = 15360U;
#line 1147
  goto ldv_56036;
  case 5U: 
#line 1149
  *((u32 *)pValue) = 28U;
#line 1150
  goto ldv_56036;
  case 6U: 
#line 1152
  *((u8 *)pValue) = pHalData->bDumpRxPkt;
#line 1153
  goto ldv_56036;
  case 7U: 
#line 1155
  *((u32 *)pValue) = pHalData->odmpriv.SupportAbility;
#line 1156
  goto ldv_56036;
  case 11U: 
#line 1158
  *((u32 *)pValue) = 3U;
#line 1159
  goto ldv_56036;
  case 15U: 
#line 1162
  pDM_Odm = & pHalData->odmpriv;
#line 1163
  printk("pDM_Odm->DebugComponents = 0x%llx\n", pDM_Odm->DebugComponents);
#line 1166
  goto ldv_56036;
  default: 
#line 1168
  bResult = 0;
#line 1169
  goto ldv_56036;
  }
  ldv_56036: ;
#line 1172
  return (bResult);
}
}
#line 1175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.c"
void rtl8723a_update_ramask(struct rtw_adapter *padapter , u32 mac_id , u8 rssi_level ) 
{ 
  struct sta_info *psta ;
  struct FW_Sta_Info *fw_sta ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 init_rate ;
  u8 networkType ;
  u8 raid ;
  u8 arg ;
  u32 mask ;
  u32 rate_bitmap ;
  u8 shortGIrate ;
  int supportRateNum ;
  uint tmp ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  uint tmp___4 ;
  uint tmp___5 ;
  u8 tmp___6 ;
  unsigned char tmp___7 ;

  {
#line 1180
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1181
  pdmpriv = & pHalData->dmpriv;
#line 1182
  pmlmeext = & padapter->mlmeextpriv;
#line 1183
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1184
  cur_network = & pmlmeinfo->network;
#line 1187
  shortGIrate = 0U;
#line 1190
  if (mac_id > 31U) {
#line 1191
    return;
  } else {

  }
#line 1193
  psta = pmlmeinfo->FW_sta_info[mac_id].psta;
#line 1194
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1195
    return;
  } else {

  }
#line 1197
  switch (mac_id) {
  case 0U: 
#line 1199
  tmp = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
#line 1199
  supportRateNum = (int )tmp;
#line 1201
  tmp___0 = judge_network_type23a(padapter, (unsigned char *)(& cur_network->SupportedRates),
                                  supportRateNum);
#line 1201
  networkType = (unsigned int )tmp___0 & 15U;
#line 1205
  raid = networktype_to_raid23a((int )networkType);
#line 1207
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
#line 1209
  if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
#line 1209
    tmp___1 = update_MSC_rate23a(& pmlmeinfo->ht_cap);
#line 1209
    tmp___2 = tmp___1;
  } else {
#line 1209
    tmp___2 = 0U;
  }
#line 1209
  mask = tmp___2 | mask;
#line 1212
  tmp___3 = support_short_GI23a(padapter, & pmlmeinfo->ht_cap);
#line 1212
  if (tmp___3 != 0) {
#line 1213
    shortGIrate = 1U;
  } else {

  }
#line 1214
  goto ldv_56069;
  case 1U: 
#line 1217
  fw_sta = (struct FW_Sta_Info *)(& pmlmeinfo->FW_sta_info) + (unsigned long )mac_id;
#line 1218
  tmp___4 = rtw_get_rateset_len23a((u8 *)(& fw_sta->SupportedRates));
#line 1218
  supportRateNum = (int )tmp___4;
#line 1219
  if ((int )pmlmeext->cur_wireless_mode & 1) {
#line 1220
    networkType = 1U;
  } else {
#line 1222
    networkType = 2U;
  }
#line 1223
  raid = networktype_to_raid23a((int )networkType);
#line 1225
  mask = update_basic_rate23a((unsigned char *)(& cur_network->SupportedRates), (unsigned int )supportRateNum);
#line 1227
  goto ldv_56069;
  default: 
#line 1230
  fw_sta = (struct FW_Sta_Info *)(& pmlmeinfo->FW_sta_info) + (unsigned long )mac_id;
#line 1231
  tmp___5 = rtw_get_rateset_len23a((u8 *)(& fw_sta->SupportedRates));
#line 1231
  supportRateNum = (int )tmp___5;
#line 1232
  tmp___6 = judge_network_type23a(padapter, (unsigned char *)(& fw_sta->SupportedRates),
                                  supportRateNum);
#line 1232
  networkType = (unsigned int )tmp___6 & 15U;
#line 1236
  raid = networktype_to_raid23a((int )networkType);
#line 1238
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
#line 1242
  goto ldv_56069;
  }
  ldv_56069: 
#line 1246
  rate_bitmap = ODM_Get_Rate_Bitmap23a(pHalData, mac_id, mask, (int )rssi_level);
#line 1248
  if (GlobalDebugLevel23A > 3U) {
#line 1248
    printk("\016RTL8723AU: %s => mac_id:%d, networkType:0x%02x, mask:0x%08x\n\t ==> rssi_level:%d, rate_bitmap:0x%08x\n",
           "rtl8723a_update_ramask", mac_id, (int )networkType, mask, (int )rssi_level,
           rate_bitmap);
  } else {

  }
#line 1252
  mask = mask & rate_bitmap;
#line 1253
  mask = (u32 )((int )raid << 28) | mask;
#line 1255
  tmp___7 = get_highest_rate_idx23a(mask);
#line 1255
  init_rate = (unsigned int )tmp___7 & 63U;
#line 1257
  arg = (unsigned int )((u8 )mac_id) & 31U;
#line 1258
  arg = (u8 )((unsigned int )arg | 128U);
#line 1260
  if ((unsigned int )shortGIrate == 1U) {
#line 1261
    arg = (u8 )((unsigned int )arg | 32U);
  } else {

  }
#line 1263
  if (GlobalDebugLevel23A > 3U) {
#line 1263
    printk("\016RTL8723AU: update raid entry, mask = 0x%x, arg = 0x%x\n", mask, (int )arg);
  } else {

  }
#line 1265
  rtl8723a_set_raid_cmd(padapter, mask, (int )arg);
#line 1268
  psta->raid = raid;
#line 1269
  psta->init_rate = init_rate;
#line 1272
  pdmpriv->INIDATA_RATE[mac_id] = init_rate;
#line 1273
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
bool ldv_queue_work_on_593(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
bool ldv_queue_delayed_work_on_594(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
bool ldv_queue_work_on_595(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
void ldv_flush_workqueue_596(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
bool ldv_queue_delayed_work_on_597(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 352 "include/linux/workqueue.h"
extern struct workqueue_struct *system_wq ;
#line 433
bool ldv_queue_work_on_607(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_609(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_608(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_611(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_610(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___0(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_607(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 528 "include/linux/workqueue.h"
__inline static bool schedule_work(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 530
  tmp = queue_work___0(system_wq, work);
#line 530
  return (tmp);
}
}
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
struct work_struct *ldv_work_struct_3_1 ;
#line 48
int ldv_work_3_3 ;
#line 50
struct work_struct *ldv_work_struct_3_3 ;
#line 65
struct work_struct *ldv_work_struct_3_2 ;
#line 103
int ldv_work_3_2 ;
#line 106
int ldv_work_3_0 ;
#line 128
int ldv_work_3_1 ;
#line 137
struct work_struct *ldv_work_struct_3_0 ;
#line 155
void work_init_3(void) ;
#line 172
void activate_work_3(struct work_struct *work , int state ) ;
#line 177
void call_and_disable_work_3(struct work_struct *work ) ;
#line 181
void disable_work_3(struct work_struct *work ) ;
#line 226
void invoke_work_3(void) ;
#line 238
void call_and_disable_all_3(int state ) ;
#line 842 "include/linux/skbuff.h"
extern struct sk_buff *skb_clone(struct sk_buff * , gfp_t  ) ;
#line 1540
extern struct sk_buff *skb_dequeue(struct sk_buff_head * ) ;
#line 1659 "include/linux/skbuff.h"
__inline static void skb_reset_tail_pointer(struct sk_buff *skb ) 
{ 


  {
#line 1661
  skb->tail = (sk_buff_data_t )((long )skb->data) - (sk_buff_data_t )((long )skb->head);
#line 1662
  return;
}
}
#line 2160 "include/linux/skbuff.h"
__inline static struct sk_buff *netdev_alloc_skb(struct net_device *dev , unsigned int length ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2163
  tmp = __netdev_alloc_skb(dev, length, 32U);
#line 2163
  return (tmp);
}
}
#line 529 "include/linux/interrupt.h"
extern void __tasklet_schedule(struct tasklet_struct * ) ;
#line 531 "include/linux/interrupt.h"
__inline static void tasklet_schedule(struct tasklet_struct *t ) 
{ 
  int tmp ;

  {
#line 533
  tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& t->state));
#line 533
  if (tmp == 0) {
#line 534
    __tasklet_schedule(t);
  } else {

  }
#line 535
  return;
}
}
#line 1532 "include/linux/usb.h"
__inline static void usb_fill_bulk_urb(struct urb *urb , struct usb_device *dev ,
                                       unsigned int pipe , void *transfer_buffer ,
                                       int buffer_length , void (*complete_fn)(struct urb * ) ,
                                       void *context ) 
{ 


  {
#line 1540
  urb->dev = dev;
#line 1541
  urb->pipe = pipe;
#line 1542
  urb->transfer_buffer = transfer_buffer;
#line 1543
  urb->transfer_buffer_length = (u32 )buffer_length;
#line 1544
  urb->complete = complete_fn;
#line 1545
  urb->context = context;
#line 1546
  return;
}
}
#line 1573 "include/linux/usb.h"
__inline static void usb_fill_int_urb(struct urb *urb , struct usb_device *dev , unsigned int pipe ,
                                      void *transfer_buffer , int buffer_length ,
                                      void (*complete_fn)(struct urb * ) , void *context ,
                                      int interval ) 
{ 
  int _min1 ;
  int _max1 ;
  int _max2 ;
  int _min2 ;

  {
#line 1582
  urb->dev = dev;
#line 1583
  urb->pipe = pipe;
#line 1584
  urb->transfer_buffer = transfer_buffer;
#line 1585
  urb->transfer_buffer_length = (u32 )buffer_length;
#line 1586
  urb->complete = complete_fn;
#line 1587
  urb->context = context;
#line 1589
  if ((unsigned int )dev->speed == 3U || (unsigned int )dev->speed == 5U) {
#line 1591
    _max1 = interval;
#line 1591
    _max2 = 1;
#line 1591
    _min1 = _max1 > _max2 ? _max1 : _max2;
#line 1591
    _min2 = 16;
#line 1591
    interval = _min1 < _min2 ? _min1 : _min2;
#line 1593
    urb->interval = 1 << (interval + -1);
  } else {
#line 1595
    urb->interval = interval;
  }
#line 1598
  urb->start_frame = -1;
#line 1599
  return;
}
}
#line 1606
extern int usb_submit_urb(struct urb * , gfp_t  ) ;
#line 1677
extern int usb_control_msg(struct usb_device * , unsigned int  , __u8  , __u8  , __u16  ,
                           __u16  , void * , __u16  , int  ) ;
#line 1805 "include/linux/usb.h"
__inline static unsigned int __create_pipe(struct usb_device *dev , unsigned int endpoint ) 
{ 


  {
#line 1808
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
#line 37 "drivers/staging/rtl8723au/include/usb_ops.h"
void rtl8723au_set_hw_type(struct rtw_adapter *padapter ) ;
#line 46 "drivers/staging/rtl8723au/include/usb_ops.h"
__inline static int rtw_inc_and_chk_continual_urb_error(struct dvobj_priv *dvobj ) 
{ 
  int ret ;
  int value ;

  {
#line 48
  ret = 0;
#line 51
  value = atomic_add_return(1, & dvobj->continual_urb_error);
#line 52
  if (value > 4) {
#line 53
    if (GlobalDebugLevel23A > 3U) {
#line 53
      printk("\016RTL8723AU: [dvobj:%p][OLD_ERROR] continual_urb_error:%d > %d\n", dvobj,
             value, 4);
    } else {

    }
#line 55
    ret = 1;
  } else {

  }
#line 57
  return (ret);
}
}
#line 61 "drivers/staging/rtl8723au/include/usb_ops.h"
__inline static void rtw_reset_continual_urb_error(struct dvobj_priv *dvobj ) 
{ 


  {
#line 63
  atomic_set(& dvobj->continual_urb_error, 0);
#line 64
  return;
}
}
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
u8 rtl8723au_read8(struct rtw_adapter *padapter , u16 addr ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  int len ;
  u8 data ;
  unsigned int tmp ;

  {
#line 27
  pdvobjpriv = padapter->dvobj;
#line 28
  udev = pdvobjpriv->pusbdev;
#line 32
  mutex_lock_nested(& pdvobjpriv->usb_vendor_req_mutex, 0U);
#line 33
  tmp = __create_pipe(udev, 0U);
#line 33
  len = usb_control_msg(udev, tmp | 2147483776U, 5, 192, (int )addr, 0, (void *)(& pdvobjpriv->usb_buf.val8),
                        1, 500);
#line 38
  data = pdvobjpriv->usb_buf.val8;
#line 39
  mutex_unlock(& pdvobjpriv->usb_vendor_req_mutex);
#line 41
  return (data);
}
}
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
u16 rtl8723au_read16(struct rtw_adapter *padapter , u16 addr ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  int len ;
  u16 data ;
  unsigned int tmp ;

  {
#line 46
  pdvobjpriv = padapter->dvobj;
#line 47
  udev = pdvobjpriv->pusbdev;
#line 51
  mutex_lock_nested(& pdvobjpriv->usb_vendor_req_mutex, 0U);
#line 52
  tmp = __create_pipe(udev, 0U);
#line 52
  len = usb_control_msg(udev, tmp | 2147483776U, 5, 192, (int )addr, 0, (void *)(& pdvobjpriv->usb_buf.val16),
                        2, 500);
#line 57
  data = pdvobjpriv->usb_buf.val16;
#line 58
  mutex_unlock(& pdvobjpriv->usb_vendor_req_mutex);
#line 60
  return (data);
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
u32 rtl8723au_read32(struct rtw_adapter *padapter , u16 addr ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  int len ;
  u32 data ;
  unsigned int tmp ;

  {
#line 65
  pdvobjpriv = padapter->dvobj;
#line 66
  udev = pdvobjpriv->pusbdev;
#line 70
  mutex_lock_nested(& pdvobjpriv->usb_vendor_req_mutex, 0U);
#line 71
  tmp = __create_pipe(udev, 0U);
#line 71
  len = usb_control_msg(udev, tmp | 2147483776U, 5, 192, (int )addr, 0, (void *)(& pdvobjpriv->usb_buf.val32),
                        4, 500);
#line 76
  data = pdvobjpriv->usb_buf.val32;
#line 77
  mutex_unlock(& pdvobjpriv->usb_vendor_req_mutex);
#line 79
  return (data);
}
}
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
int rtl8723au_write8(struct rtw_adapter *padapter , u16 addr , u8 val ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  int ret ;
  unsigned int tmp ;

  {
#line 84
  pdvobjpriv = padapter->dvobj;
#line 85
  udev = pdvobjpriv->pusbdev;
#line 88
  mutex_lock_nested(& pdvobjpriv->usb_vendor_req_mutex, 0U);
#line 89
  pdvobjpriv->usb_buf.val8 = val;
#line 91
  tmp = __create_pipe(udev, 0U);
#line 91
  ret = usb_control_msg(udev, tmp | 2147483648U, 5, 64, (int )addr, 0, (void *)(& pdvobjpriv->usb_buf.val8),
                        1, 500);
#line 97
  if (ret != 1) {
#line 98
    ret = 0;
  } else {
#line 100
    ret = 1;
  }
#line 102
  mutex_unlock(& pdvobjpriv->usb_vendor_req_mutex);
#line 103
  return (ret);
}
}
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
int rtl8723au_write16(struct rtw_adapter *padapter , u16 addr , u16 val ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  int ret ;
  unsigned int tmp ;

  {
#line 108
  pdvobjpriv = padapter->dvobj;
#line 109
  udev = pdvobjpriv->pusbdev;
#line 112
  mutex_lock_nested(& pdvobjpriv->usb_vendor_req_mutex, 0U);
#line 113
  pdvobjpriv->usb_buf.val16 = val;
#line 115
  tmp = __create_pipe(udev, 0U);
#line 115
  ret = usb_control_msg(udev, tmp | 2147483648U, 5, 64, (int )addr, 0, (void *)(& pdvobjpriv->usb_buf.val16),
                        2, 500);
#line 121
  if (ret != 2) {
#line 122
    ret = 0;
  } else {
#line 124
    ret = 1;
  }
#line 126
  mutex_unlock(& pdvobjpriv->usb_vendor_req_mutex);
#line 127
  return (ret);
}
}
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
int rtl8723au_write32(struct rtw_adapter *padapter , u16 addr , u32 val ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  int ret ;
  unsigned int tmp ;

  {
#line 132
  pdvobjpriv = padapter->dvobj;
#line 133
  udev = pdvobjpriv->pusbdev;
#line 136
  mutex_lock_nested(& pdvobjpriv->usb_vendor_req_mutex, 0U);
#line 137
  pdvobjpriv->usb_buf.val32 = val;
#line 139
  tmp = __create_pipe(udev, 0U);
#line 139
  ret = usb_control_msg(udev, tmp | 2147483648U, 5, 64, (int )addr, 0, (void *)(& pdvobjpriv->usb_buf.val32),
                        4, 500);
#line 145
  if (ret != 4) {
#line 146
    ret = 0;
  } else {
#line 148
    ret = 1;
  }
#line 150
  mutex_unlock(& pdvobjpriv->usb_vendor_req_mutex);
#line 151
  return (ret);
}
}
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
int rtl8723au_writeN(struct rtw_adapter *padapter , u16 addr , u16 len , u8 *buf ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  int ret ;
  unsigned int tmp ;

  {
#line 156
  pdvobjpriv = padapter->dvobj;
#line 157
  udev = pdvobjpriv->pusbdev;
#line 160
  tmp = __create_pipe(udev, 0U);
#line 160
  ret = usb_control_msg(udev, tmp | 2147483648U, 5, 64, (int )addr, 0, (void *)buf,
                        (int )len, 500);
#line 165
  if ((int )len != ret) {
#line 166
    return (0);
  } else {

  }
#line 167
  return (1);
}
}
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
static bool InterruptRecognized8723AU(struct rtw_adapter *Adapter , void *pContent ,
                                      u32 ContentLen ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 *buffer ;
  struct reportpwrstate_parm report ;

  {
#line 195
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 196
  buffer = (u8 *)pContent;
#line 199
  memcpy((void *)(& pHalData->IntArray), (void const   *)buffer + 48U, 4UL);
#line 201
  pHalData->IntArray[0] = pHalData->IntArray[0] & pHalData->IntrMask[0];
#line 204
  memcpy((void *)(& pHalData->IntArray) + 1U, (void const   *)buffer + 52U, 4UL);
#line 206
  pHalData->IntArray[1] = pHalData->IntArray[1] & pHalData->IntrMask[1];
#line 211
  memcpy((void *)(& report.state), (void const   *)buffer + 16U, 1UL);
#line 213
  return ((bool )((pHalData->IntArray[0] & pHalData->IntrMask[0]) != 0U || (pHalData->IntArray[1] & pHalData->IntrMask[1]) != 0U));
}
}
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
static void usb_read_interrupt_complete(struct urb *purb ) 
{ 
  int err ;
  struct rtw_adapter *padapter ;
  struct c2h_evt_hdr *c2h_evt ;
  struct evt_work *c2w ;
  int res ;
  void *tmp ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 220
  padapter = (struct rtw_adapter *)purb->context;
#line 222
  if ((padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) || (unsigned int )padapter->bReadPortCancel != 0U) {
#line 224
    if (GlobalDebugLevel23A > 3U) {
#line 224
      printk("\016RTL8723AU: %s() RX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bReadPortCancel(%d)\n",
             "usb_read_interrupt_complete", padapter->bDriverStopped, padapter->bSurpriseRemoved,
             (int )padapter->bReadPortCancel);
    } else {

    }
#line 229
    return;
  } else {

  }
#line 232
  if (purb->status == 0) {
#line 235
    c2h_evt = (struct c2h_evt_hdr *)purb->transfer_buffer;
#line 237
    if (purb->actual_length > 56U) {
#line 238
      if (GlobalDebugLevel23A > 3U) {
#line 238
        printk("\016RTL8723AU: usb_read_interrupt_complete: purb->actual_length > USB_INTR_CONTENT_LENGTH\n");
      } else {

      }
#line 240
      goto urb_submit;
    } else {

    }
#line 243
    InterruptRecognized8723AU(padapter, purb->transfer_buffer, purb->actual_length);
#line 246
    if ((unsigned int )*((unsigned char *)c2h_evt + 0UL) != 0U || (unsigned int )*((unsigned char *)c2h_evt + 0UL) != 0U) {
#line 247
      tmp___1 = c2h_id_filter_ccx_8723a((int )c2h_evt->id);
#line 247
      if ((int )tmp___1) {
#line 249
        handle_txrpt_ccx_8723a(padapter, (void *)(& c2h_evt->payload));
#line 251
        schedule_work(& padapter->evtpriv.irq_wk);
      } else {
#line 256
        tmp = kmalloc(104UL, 32U);
#line 256
        c2w = (struct evt_work *)tmp;
#line 259
        if ((unsigned long )c2w == (unsigned long )((struct evt_work *)0)) {
#line 260
          printk("\f%s: unable to allocate work buffer\n", "usb_read_interrupt_complete");
#line 263
          goto urb_submit;
        } else {

        }
#line 266
        c2w->adapter = padapter;
#line 267
        __init_work(& c2w->work, 0);
#line 267
        __constr_expr_0.counter = 137438953408L;
#line 267
        c2w->work.data = __constr_expr_0;
#line 267
        lockdep_init_map(& c2w->work.lockdep_map, "(&c2w->work)", & __key, 0);
#line 267
        INIT_LIST_HEAD(& c2w->work.entry);
#line 267
        c2w->work.func = & rtw_evt_work;
#line 268
        memcpy((void *)(& c2w->u.buf), (void const   *)purb->transfer_buffer, 16UL);
#line 270
        tmp___0 = queue_work___0(padapter->evtpriv.wq, & c2w->work);
#line 270
        res = (int )tmp___0;
#line 273
        if (res == 0) {
#line 274
          printk("\v%s: Call to queue_work() failed\n", "usb_read_interrupt_complete");
#line 277
          kfree((void const   *)c2w);
#line 278
          goto urb_submit;
        } else {

        }
      }
    } else {

    }
    urb_submit: 
#line 284
    err = usb_submit_urb(purb, 32U);
#line 285
    if (err != 0 && err != -1) {
#line 286
      if (GlobalDebugLevel23A > 3U) {
#line 286
        printk("\016RTL8723AU: cannot submit interrupt in-token(err = 0x%08x), urb_status = %d\n",
               err, purb->status);
      } else {

      }
    } else {

    }
  } else {
#line 291
    if (GlobalDebugLevel23A > 3U) {
#line 291
      printk("\016RTL8723AU: ###=> usb_read_interrupt_complete => urb status(%d)\n",
             purb->status);
    } else {

    }
#line 294
    switch (purb->status) {
    case -22: ;
    case -32: ;
    case -19: ;
    case -108: ;
#line 299
    if (GlobalDebugLevel23A > 3U) {
#line 299
      rt_trace(16777216, 4, "usb_read_port_complete:bSurpriseRemoved =true\n");
    } else {

    }
    case -2: 
#line 303
    padapter->bDriverStopped = 1;
#line 304
    if (GlobalDebugLevel23A > 3U) {
#line 304
      rt_trace(16777216, 4, "usb_read_port_complete:bDriverStopped =true\n");
    } else {

    }
#line 306
    goto ldv_55868;
    case -71: ;
#line 308
    goto ldv_55868;
    case -115: ;
#line 310
    if (GlobalDebugLevel23A > 3U) {
#line 310
      printk("\016RTL8723AU: OLD_ERROR: URB IS IN PROGRESS!\n");
    } else {

    }
#line 311
    goto ldv_55868;
    default: ;
#line 313
    goto ldv_55868;
    }
    ldv_55868: ;
  }
#line 317
  return;
}
}
#line 318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
int rtl8723au_read_interrupt(struct rtw_adapter *adapter ) 
{ 
  int err ;
  unsigned int pipe ;
  int ret ;
  struct dvobj_priv *pdvobj ;
  struct recv_priv *precvpriv ;
  struct usb_device *pusbd ;
  unsigned int tmp ;

  {
#line 322
  ret = 1;
#line 323
  pdvobj = adapter->dvobj;
#line 324
  precvpriv = & adapter->recvpriv;
#line 325
  pusbd = pdvobj->pusbdev;
#line 328
  tmp = __create_pipe(pusbd, (unsigned int )pdvobj->RtInPipe[1]);
#line 328
  pipe = tmp | 1073741952U;
#line 330
  usb_fill_int_urb(precvpriv->int_in_urb, pusbd, pipe, (void *)precvpriv->int_in_buf,
                   56, & usb_read_interrupt_complete, (void *)adapter, 1);
#line 334
  err = usb_submit_urb(precvpriv->int_in_urb, 32U);
#line 335
  if (err != 0 && err != -1) {
#line 336
    if (GlobalDebugLevel23A > 3U) {
#line 336
      printk("\016RTL8723AU: cannot submit interrupt in-token(err = 0x%08x),urb_status = %d\n",
             err, (precvpriv->int_in_urb)->status);
    } else {

    }
#line 339
    ret = 0;
  } else {

  }
#line 342
  return (ret);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
static int recvbuf2recvframe(struct rtw_adapter *padapter , struct sk_buff *pskb ) 
{ 
  u8 *pbuf ;
  u8 shift_sz ;
  u16 pkt_cnt ;
  u32 pkt_offset ;
  u32 skb_len ;
  u32 alloc_sz ;
  int transfer_len ;
  struct recv_stat *prxstat ;
  struct phy_stat *pphy_info ;
  struct sk_buff *pkt_copy ;
  struct recv_frame *precvframe ;
  struct rx_pkt_attrib *pattrib ;
  struct recv_priv *precvpriv ;
  struct rtw_queue *pfree_recv_queue ;
  int tmp ;

  {
#line 348
  shift_sz = 0U;
#line 357
  precvpriv = & padapter->recvpriv;
#line 358
  pfree_recv_queue = & precvpriv->free_recv_queue;
#line 360
  transfer_len = (int )pskb->len;
#line 361
  pbuf = pskb->data;
#line 363
  prxstat = (struct recv_stat *)pbuf;
#line 364
  pkt_cnt = (unsigned int )((u16 )(prxstat->rxdw2 >> 16)) & 255U;
  ldv_55901: ;
#line 367
  if (GlobalDebugLevel23A > 6U) {
#line 367
    rt_trace(4, 7, "recvbuf2recvframe: rxdesc = offsset 0:0x%08x, 4:0x%08x, 8:0x%08x, C:0x%08x\n",
             prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4);
  } else {

  }
#line 372
  prxstat = (struct recv_stat *)pbuf;
#line 374
  precvframe = rtw_alloc_recvframe23a(pfree_recv_queue);
#line 375
  if ((unsigned long )precvframe == (unsigned long )((struct recv_frame *)0)) {
#line 376
    if (GlobalDebugLevel23A > 3U) {
#line 376
      rt_trace(4, 4, "recvbuf2recvframe: precvframe == NULL\n");
    } else {

    }
#line 378
    if (GlobalDebugLevel23A > 3U) {
#line 378
      printk("\016RTL8723AU: %s()-%d: rtw_alloc_recvframe23a() failed! RX Drop!\n",
             "recvbuf2recvframe", 379);
    } else {

    }
#line 380
    goto _exit_recvbuf2recvframe;
  } else {

  }
#line 383
  INIT_LIST_HEAD(& precvframe->list);
#line 385
  update_recvframe_attrib(precvframe, prxstat);
#line 387
  pattrib = & precvframe->attrib;
#line 389
  if ((unsigned int )pattrib->crc_err != 0U) {
#line 390
    if (GlobalDebugLevel23A > 3U) {
#line 390
      printk("\016RTL8723AU: %s()-%d: RX Warning! rx CRC OLD_ERROR !!\n", "recvbuf2recvframe",
             391);
    } else {

    }
#line 392
    rtw_free_recvframe23a(precvframe);
#line 393
    goto _exit_recvbuf2recvframe;
  } else {

  }
#line 396
  pkt_offset = (u32 )((((int )pattrib->drvinfo_sz + 24) + (int )pattrib->shift_sz) + (int )pattrib->pkt_len);
#line 399
  if ((unsigned int )pattrib->pkt_len == 0U || (u32 )transfer_len < pkt_offset) {
#line 400
    if (GlobalDebugLevel23A > 6U) {
#line 400
      rt_trace(4, 7, "recvbuf2recvframe: pkt_len<= 0\n");
    } else {

    }
#line 402
    if (GlobalDebugLevel23A > 3U) {
#line 402
      printk("\016RTL8723AU: %s()-%d: RX Warning!\n", "recvbuf2recvframe", 403);
    } else {

    }
#line 404
    rtw_free_recvframe23a(precvframe);
#line 405
    goto _exit_recvbuf2recvframe;
  } else {

  }
#line 411
  if ((unsigned int )pattrib->qos != 0U) {
#line 412
    shift_sz = 6U;
  } else {
#line 414
    shift_sz = 0U;
  }
#line 416
  skb_len = (u32 )pattrib->pkt_len;
#line 422
  if ((unsigned int )pattrib->mfrag == 1U && (unsigned int )pattrib->frag_num == 0U) {
#line 424
    if (skb_len <= 1650U) {
#line 425
      alloc_sz = 1664U;
    } else {
#line 427
      alloc_sz = skb_len + 14U;
    }
  } else {
#line 429
    alloc_sz = skb_len;
#line 432
    alloc_sz = alloc_sz + 14U;
  }
#line 435
  pkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);
#line 436
  if ((unsigned long )pkt_copy != (unsigned long )((struct sk_buff *)0)) {
#line 437
    pkt_copy->dev = padapter->pnetdev;
#line 438
    precvframe->pkt = pkt_copy;
#line 440
    skb_reserve(pkt_copy, (int )(8U - ((unsigned int )((long )pkt_copy->data) & 7U)));
#line 444
    skb_reserve(pkt_copy, (int )shift_sz);
#line 445
    memcpy((void *)pkt_copy->data, (void const   *)(pbuf + (((unsigned long )pattrib->shift_sz + (unsigned long )pattrib->drvinfo_sz) + 24UL)),
             (size_t )skb_len);
#line 447
    skb_put(pkt_copy, skb_len);
  } else {
#line 449
    if ((unsigned int )pattrib->mfrag == 1U && (unsigned int )pattrib->frag_num == 0U) {
#line 450
      if (GlobalDebugLevel23A > 3U) {
#line 450
        printk("\016RTL8723AU: recvbuf2recvframe: alloc_skb fail, drop frag frame \n");
      } else {

      }
#line 452
      rtw_free_recvframe23a(precvframe);
#line 453
      goto _exit_recvbuf2recvframe;
    } else {

    }
#line 456
    precvframe->pkt = skb_clone(pskb, 32U);
#line 457
    if ((unsigned long )precvframe->pkt == (unsigned long )((struct sk_buff *)0)) {
#line 458
      if (GlobalDebugLevel23A > 3U) {
#line 458
        printk("\016RTL8723AU: recvbuf2recvframe: skb_clone fail\n");
      } else {

      }
#line 460
      rtw_free_recvframe23a(precvframe);
#line 461
      goto _exit_recvbuf2recvframe;
    } else {

    }
  }
#line 465
  if ((unsigned int )pattrib->physt != 0U) {
#line 466
    pphy_info = (struct phy_stat *)pbuf + 24U;
#line 467
    update_recvframe_phyinfo(precvframe, pphy_info);
  } else {

  }
#line 470
  tmp = rtw_recv_entry23a(precvframe);
#line 470
  if (tmp != 1) {
#line 471
    if (GlobalDebugLevel23A > 3U) {
#line 471
      rt_trace(4, 4, "recvbuf2recvframe: rtw_recv_entry23a(precvframe) != _SUCCESS\n");
    } else {

    }
  } else {

  }
#line 474
  pkt_cnt = (u16 )((int )pkt_cnt - 1);
#line 475
  transfer_len = (int )((u32 )transfer_len - pkt_offset);
#line 476
  pbuf = pbuf + (unsigned long )pkt_offset;
#line 477
  precvframe = (struct recv_frame *)0;
#line 478
  pkt_copy = (struct sk_buff *)0;
#line 480
  if (transfer_len > 0 && (unsigned int )pkt_cnt == 0U) {
#line 481
    pkt_cnt = (unsigned int )((u16 )(prxstat->rxdw2 >> 16)) & 255U;
  } else {

  }
#line 483
  if (transfer_len > 0 && (unsigned int )pkt_cnt != 0U) {
#line 485
    goto ldv_55901;
  } else {

  }

  _exit_recvbuf2recvframe: ;
#line 487
  return (1);
}
}
#line 490 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
void rtl8723au_recv_tasklet(void *priv ) 
{ 
  struct sk_buff *pskb ;
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;

  {
#line 493
  padapter = (struct rtw_adapter *)priv;
#line 494
  precvpriv = & padapter->recvpriv;
#line 496
  goto ldv_55911;
  ldv_55910: ;
#line 497
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 498
    if (GlobalDebugLevel23A > 3U) {
#line 498
      printk("\016RTL8723AU: recv_tasklet => bDriverStopped or bSurpriseRemoved \n");
    } else {

    }
#line 500
    dev_kfree_skb_any(pskb);
#line 501
    goto ldv_55909;
  } else {

  }
#line 504
  recvbuf2recvframe(padapter, pskb);
#line 505
  skb_reset_tail_pointer(pskb);
#line 507
  pskb->len = 0U;
#line 509
  skb_queue_tail(& precvpriv->free_recv_skb_queue, pskb);
  ldv_55911: 
#line 496
  pskb = skb_dequeue(& precvpriv->rx_skb_queue);
#line 496
  if ((unsigned long )pskb != (unsigned long )((struct sk_buff *)0)) {
#line 498
    goto ldv_55910;
  } else {

  }
  ldv_55909: ;
#line 503
  return;
}
}
#line 513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
static void usb_read_port_complete(struct urb *purb ) 
{ 
  struct recv_buf *precvbuf ;
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  __u32 tmp ;
  int tmp___0 ;

  {
#line 515
  precvbuf = (struct recv_buf *)purb->context;
#line 516
  padapter = precvbuf->adapter;
#line 517
  precvpriv = & padapter->recvpriv;
#line 519
  if (GlobalDebugLevel23A > 3U) {
#line 519
    rt_trace(16777216, 4, "usb_read_port_complete!!!\n");
  } else {

  }
#line 522
  precvpriv->rx_pending_cnt = (u8 )((int )precvpriv->rx_pending_cnt - 1);
#line 524
  if ((padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) || (unsigned int )padapter->bReadPortCancel != 0U) {
#line 526
    if (GlobalDebugLevel23A > 3U) {
#line 526
      rt_trace(16777216, 4, "usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n",
               padapter->bDriverStopped, padapter->bSurpriseRemoved);
    } else {

    }
#line 530
    if (GlobalDebugLevel23A > 3U) {
#line 530
      printk("\016RTL8723AU: %s()-%d: RX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bReadPortCancel(%d)\n",
             "usb_read_port_complete", 533, padapter->bDriverStopped, padapter->bSurpriseRemoved,
             (int )padapter->bReadPortCancel);
    } else {

    }
#line 534
    return;
  } else {

  }
#line 537
  if (purb->status == 0) {
#line 538
    if (purb->actual_length > 15360U || purb->actual_length <= 23U) {
#line 540
      if (GlobalDebugLevel23A > 3U) {
#line 540
        rt_trace(16777216, 4, "usb_read_port_complete: (purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE)\n");
      } else {

      }
#line 542
      rtl8723au_read_port(padapter, 0U, precvbuf);
#line 543
      if (GlobalDebugLevel23A > 3U) {
#line 543
        printk("\016RTL8723AU: %s()-%d: RX Warning!\n", "usb_read_port_complete",
               544);
      } else {

      }
    } else {
#line 546
      rtw_reset_continual_urb_error(padapter->dvobj);
#line 549
      skb_put(precvbuf->pskb, purb->actual_length);
#line 550
      skb_queue_tail(& precvpriv->rx_skb_queue, precvbuf->pskb);
#line 553
      tmp = skb_queue_len((struct sk_buff_head  const  *)(& precvpriv->rx_skb_queue));
#line 553
      if (tmp <= 1U) {
#line 554
        tasklet_schedule(& precvpriv->recv_tasklet);
      } else {

      }
#line 556
      precvbuf->pskb = (struct sk_buff *)0;
#line 557
      rtl8723au_read_port(padapter, 0U, precvbuf);
    }
  } else {
#line 560
    if (GlobalDebugLevel23A > 3U) {
#line 560
      rt_trace(16777216, 4, "usb_read_port_complete : purb->status(%d) != 0\n", purb->status);
    } else {

    }
#line 563
    skb_put(precvbuf->pskb, purb->actual_length);
#line 564
    precvbuf->pskb = (struct sk_buff *)0;
#line 566
    if (GlobalDebugLevel23A > 3U) {
#line 566
      printk("\016RTL8723AU: ###=> usb_read_port_complete => urb status(%d)\n", purb->status);
    } else {

    }
#line 569
    tmp___0 = rtw_inc_and_chk_continual_urb_error(padapter->dvobj);
#line 569
    if (tmp___0 != 0) {
#line 571
      padapter->bSurpriseRemoved = 1;
    } else {

    }
#line 574
    switch (purb->status) {
    case -22: ;
    case -32: ;
    case -19: ;
    case -108: ;
#line 579
    if (GlobalDebugLevel23A > 3U) {
#line 579
      rt_trace(16777216, 4, "usb_read_port_complete:bSurpriseRemoved = true\n");
    } else {

    }
    case -2: 
#line 583
    padapter->bDriverStopped = 1;
#line 584
    if (GlobalDebugLevel23A > 3U) {
#line 584
      rt_trace(16777216, 4, "usb_read_port_complete:bDriverStopped = true\n");
    } else {

    }
#line 586
    goto ldv_55924;
    case -71: ;
    case -75: 
#line 589
    rtl8723au_read_port(padapter, 0U, precvbuf);
#line 590
    goto ldv_55924;
    case -115: ;
#line 592
    if (GlobalDebugLevel23A > 3U) {
#line 592
      printk("\016RTL8723AU: OLD_ERROR: URB IS IN PROGRESS!\n");
    } else {

    }
#line 593
    goto ldv_55924;
    default: ;
#line 595
    goto ldv_55924;
    }
    ldv_55924: ;
  }
#line 599
  return;
}
}
#line 600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
int rtl8723au_read_port(struct rtw_adapter *adapter , u32 cnt , struct recv_buf *precvbuf ) 
{ 
  struct urb *purb ;
  struct dvobj_priv *pdvobj ;
  struct recv_priv *precvpriv ;
  struct usb_device *pusbd ;
  int err ;
  unsigned int pipe ;
  unsigned long tmpaddr ;
  unsigned long alignment ;
  int ret ;
  unsigned int tmp ;

  {
#line 604
  pdvobj = adapter->dvobj;
#line 605
  precvpriv = & adapter->recvpriv;
#line 606
  pusbd = pdvobj->pusbdev;
#line 611
  ret = 1;
#line 613
  if (adapter->bDriverStopped != 0 || adapter->bSurpriseRemoved != 0) {
#line 614
    if (GlobalDebugLevel23A > 3U) {
#line 614
      rt_trace(16777216, 4, "usb_read_port:(padapter->bDriverStopped ||padapter->bSurpriseRemoved)!!!\n");
    } else {

    }
#line 616
    return (0);
  } else {

  }
#line 619
  if ((unsigned long )precvbuf == (unsigned long )((struct recv_buf *)0)) {
#line 620
    if (GlobalDebugLevel23A > 3U) {
#line 620
      rt_trace(16777216, 4, "usb_read_port:precvbuf == NULL\n");
    } else {

    }
#line 622
    return (0);
  } else {

  }
#line 625
  if ((unsigned long )precvbuf->pskb == (unsigned long )((struct sk_buff *)0)) {
#line 626
    precvbuf->pskb = skb_dequeue(& precvpriv->free_recv_skb_queue);
  } else {

  }
#line 629
  if ((unsigned long )precvbuf->pskb == (unsigned long )((struct sk_buff *)0)) {
#line 630
    precvbuf->pskb = netdev_alloc_skb(adapter->pnetdev, 15368U);
#line 631
    if ((unsigned long )precvbuf->pskb == (unsigned long )((struct sk_buff *)0)) {
#line 632
      if (GlobalDebugLevel23A > 3U) {
#line 632
        rt_trace(16777216, 4, "init_recvbuf(): alloc_skb fail!\n");
      } else {

      }
#line 634
      return (0);
    } else {

    }
#line 637
    tmpaddr = (unsigned long )(precvbuf->pskb)->data;
#line 638
    alignment = tmpaddr & 7UL;
#line 639
    skb_reserve(precvbuf->pskb, (int )(8U - (unsigned int )alignment));
  } else {

  }
#line 642
  precvpriv->rx_pending_cnt = (u8 )((int )precvpriv->rx_pending_cnt + 1);
#line 644
  purb = precvbuf->purb;
#line 647
  tmp = __create_pipe(pusbd, (unsigned int )pdvobj->RtInPipe[0]);
#line 647
  pipe = tmp | 3221225600U;
#line 649
  usb_fill_bulk_urb(purb, pusbd, pipe, (void *)(precvbuf->pskb)->data, 15360, & usb_read_port_complete,
                    (void *)precvbuf);
#line 653
  err = usb_submit_urb(purb, 32U);
#line 654
  if (err != 0 && err != -1) {
#line 655
    if (GlobalDebugLevel23A > 3U) {
#line 655
      rt_trace(16777216, 4, "cannot submit rx in-token(err = 0x%.8x), URB_STATUS = 0x%.8x\n",
               err, purb->status);
    } else {

    }
#line 658
    if (GlobalDebugLevel23A > 3U) {
#line 658
      printk("\016RTL8723AU: cannot submit rx in-token(err = 0x%08x), urb_status = %d\n",
             err, purb->status);
    } else {

    }
#line 660
    ret = 0;
  } else {

  }
#line 662
  return (ret);
}
}
#line 665 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
void rtl8723au_xmit_tasklet(void *priv ) 
{ 
  int ret ;
  struct rtw_adapter *padapter ;
  struct xmit_priv *pxmitpriv ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 668
  padapter = (struct rtw_adapter *)priv;
#line 669
  pxmitpriv = & padapter->xmitpriv;
#line 671
  tmp = check_fwstate(& padapter->mlmepriv, 2048);
#line 671
  if ((int )tmp) {
#line 672
    return;
  } else {

  }
  ldv_55950: ;
#line 675
  if ((padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) || (unsigned int )padapter->bWritePortCancel != 0U) {
#line 677
    if (GlobalDebugLevel23A > 3U) {
#line 677
      printk("\016RTL8723AU: xmit_tasklet => bDriverStopped or bSurpriseRemoved or bWritePortCancel\n");
    } else {

    }
#line 679
    goto ldv_55949;
  } else {

  }
#line 682
  tmp___0 = rtl8723au_xmitframe_complete(padapter, pxmitpriv, (struct xmit_buf *)0);
#line 682
  ret = (int )tmp___0;
#line 684
  if (ret == 0) {
#line 685
    goto ldv_55949;
  } else {

  }
#line 686
  goto ldv_55950;
  ldv_55949: ;
#line 688
  return;
}
}
#line 689 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.c"
void rtl8723au_set_hw_type(struct rtw_adapter *padapter ) 
{ 


  {
#line 691
  padapter->chip_type = 4U;
#line 692
  padapter->HardwareType = 14U;
#line 693
  if (GlobalDebugLevel23A > 3U) {
#line 693
    printk("\016RTL8723AU: CHIP TYPE: RTL8723A\n");
  } else {

  }
#line 694
  return;
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
void work_init_3(void) 
{ 


  {
#line 251
  ldv_work_3_0 = 0;
#line 252
  ldv_work_3_1 = 0;
#line 253
  ldv_work_3_2 = 0;
#line 254
  ldv_work_3_3 = 0;
#line 255
  return;
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
void activate_work_3(struct work_struct *work , int state ) 
{ 


  {
#line 259
  if (ldv_work_3_0 == 0) {
#line 260
    ldv_work_struct_3_0 = work;
#line 261
    ldv_work_3_0 = state;
#line 262
    return;
  } else {

  }
#line 265
  if (ldv_work_3_1 == 0) {
#line 266
    ldv_work_struct_3_1 = work;
#line 267
    ldv_work_3_1 = state;
#line 268
    return;
  } else {

  }
#line 271
  if (ldv_work_3_2 == 0) {
#line 272
    ldv_work_struct_3_2 = work;
#line 273
    ldv_work_3_2 = state;
#line 274
    return;
  } else {

  }
#line 277
  if (ldv_work_3_3 == 0) {
#line 278
    ldv_work_struct_3_3 = work;
#line 279
    ldv_work_3_3 = state;
#line 280
    return;
  } else {

  }
#line 282
  return;
}
}
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
void call_and_disable_work_3(struct work_struct *work ) 
{ 


  {
#line 288
  if ((ldv_work_3_0 == 2 || ldv_work_3_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_0) {
#line 290
    rtw_evt_work(work);
#line 291
    ldv_work_3_0 = 1;
#line 292
    return;
  } else {

  }
#line 294
  if ((ldv_work_3_1 == 2 || ldv_work_3_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_1) {
#line 296
    rtw_evt_work(work);
#line 297
    ldv_work_3_1 = 1;
#line 298
    return;
  } else {

  }
#line 300
  if ((ldv_work_3_2 == 2 || ldv_work_3_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_2) {
#line 302
    rtw_evt_work(work);
#line 303
    ldv_work_3_2 = 1;
#line 304
    return;
  } else {

  }
#line 306
  if ((ldv_work_3_3 == 2 || ldv_work_3_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_3) {
#line 308
    rtw_evt_work(work);
#line 309
    ldv_work_3_3 = 1;
#line 310
    return;
  } else {

  }
#line 312
  return;
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
void disable_work_3(struct work_struct *work ) 
{ 


  {
#line 317
  if ((ldv_work_3_0 == 3 || ldv_work_3_0 == 2) && (unsigned long )ldv_work_struct_3_0 == (unsigned long )work) {
#line 319
    ldv_work_3_0 = 1;
  } else {

  }
#line 321
  if ((ldv_work_3_1 == 3 || ldv_work_3_1 == 2) && (unsigned long )ldv_work_struct_3_1 == (unsigned long )work) {
#line 323
    ldv_work_3_1 = 1;
  } else {

  }
#line 325
  if ((ldv_work_3_2 == 3 || ldv_work_3_2 == 2) && (unsigned long )ldv_work_struct_3_2 == (unsigned long )work) {
#line 327
    ldv_work_3_2 = 1;
  } else {

  }
#line 329
  if ((ldv_work_3_3 == 3 || ldv_work_3_3 == 2) && (unsigned long )ldv_work_struct_3_3 == (unsigned long )work) {
#line 331
    ldv_work_3_3 = 1;
  } else {

  }
#line 332
  return;
}
}
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
void invoke_work_3(void) 
{ 
  int tmp ;

  {
#line 338
  tmp = __VERIFIER_nondet_int();
#line 338
  switch (tmp) {
  case 0: ;
#line 340
  if (ldv_work_3_0 == 2 || ldv_work_3_0 == 3) {
#line 341
    ldv_work_3_0 = 4;
#line 342
    rtw_evt_work(ldv_work_struct_3_0);
#line 343
    ldv_work_3_0 = 1;
  } else {

  }
#line 346
  goto ldv_55975;
  case 1: ;
#line 348
  if (ldv_work_3_1 == 2 || ldv_work_3_1 == 3) {
#line 349
    ldv_work_3_1 = 4;
#line 350
    rtw_evt_work(ldv_work_struct_3_0);
#line 351
    ldv_work_3_1 = 1;
  } else {

  }
#line 354
  goto ldv_55975;
  case 2: ;
#line 356
  if (ldv_work_3_2 == 2 || ldv_work_3_2 == 3) {
#line 357
    ldv_work_3_2 = 4;
#line 358
    rtw_evt_work(ldv_work_struct_3_0);
#line 359
    ldv_work_3_2 = 1;
  } else {

  }
#line 362
  goto ldv_55975;
  case 3: ;
#line 364
  if (ldv_work_3_3 == 2 || ldv_work_3_3 == 3) {
#line 365
    ldv_work_3_3 = 4;
#line 366
    rtw_evt_work(ldv_work_struct_3_0);
#line 367
    ldv_work_3_3 = 1;
  } else {

  }
#line 370
  goto ldv_55975;
  default: 
#line 371
  ldv_stop();
  }
  ldv_55975: ;
#line 373
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
void call_and_disable_all_3(int state ) 
{ 


  {
#line 379
  if (ldv_work_3_0 == state) {
#line 380
    call_and_disable_work_3(ldv_work_struct_3_0);
  } else {

  }
#line 381
  if (ldv_work_3_1 == state) {
#line 382
    call_and_disable_work_3(ldv_work_struct_3_1);
  } else {

  }
#line 383
  if (ldv_work_3_2 == state) {
#line 384
    call_and_disable_work_3(ldv_work_struct_3_2);
  } else {

  }
#line 385
  if (ldv_work_3_3 == state) {
#line 386
    call_and_disable_work_3(ldv_work_struct_3_3);
  } else {

  }
#line 387
  return;
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
bool ldv_queue_work_on_607(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 417
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 417
  ldv_func_res = tmp;
#line 419
  activate_work_2(ldv_func_arg3, 2);
#line 421
  return (ldv_func_res);
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
bool ldv_queue_delayed_work_on_608(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 428
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 428
  ldv_func_res = tmp;
#line 430
  activate_work_2(& ldv_func_arg3->work, 2);
#line 432
  return (ldv_func_res);
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
bool ldv_queue_work_on_609(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 439
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 439
  ldv_func_res = tmp;
#line 441
  activate_work_2(ldv_func_arg3, 2);
#line 443
  return (ldv_func_res);
}
}
#line 446 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
void ldv_flush_workqueue_610(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 449
  flush_workqueue(ldv_func_arg1);
#line 451
  call_and_disable_all_2(2);
#line 452
  return;
}
}
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
bool ldv_queue_delayed_work_on_611(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 458
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 458
  ldv_func_res = tmp;
#line 460
  activate_work_2(& ldv_func_arg3->work, 2);
#line 462
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 5 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void *ldv_err_ptr(long error ) ;
#line 23 "include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_621(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_623(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_622(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_625(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_624(struct workqueue_struct *ldv_func_arg1 ) ;
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
struct station_info *rtw_cfg80211_ops_group1 ;
#line 38
int ldv_state_variable_17 ;
#line 47
int ref_cnt ;
#line 54
struct cfg80211_pmksa *rtw_cfg80211_ops_group2 ;
#line 67
struct wiphy *rtw_cfg80211_ops_group3 ;
#line 69
int usb_counter ;
#line 76
struct vif_params *rtw_cfg80211_ops_group5 ;
#line 112
struct net_device *rtw_cfg80211_ops_group6 ;
#line 122
struct wireless_dev *rtw_cfg80211_ops_group0 ;
#line 126
struct net_device *rtw_cfg80211_monitor_if_ops_group1 ;
#line 127
int ldv_state_variable_16 ;
#line 145
struct station_parameters *rtw_cfg80211_ops_group4 ;
#line 206
void ldv_net_device_ops_17(void) ;
#line 229
void ldv_initialize_cfg80211_ops_16(void) ;
#line 832 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 835
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 836
    return ((char const   *)dev->init_name);
  } else {

  }
#line 838
  tmp = kobject_name(& dev->kobj);
#line 838
  return (tmp);
}
}
#line 775 "include/linux/skbuff.h"
extern void consume_skb(struct sk_buff * ) ;
#line 1880 "include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device  const  *dev ) 
{ 


  {
#line 1882
  return ((void *)dev + 3008U);
}
}
#line 2193
extern int register_netdevice(struct net_device * ) ;
#line 2194
extern void unregister_netdevice_queue(struct net_device * , struct list_head * ) ;
#line 2196 "include/linux/netdevice.h"
__inline static void unregister_netdevice(struct net_device *dev ) 
{ 


  {
#line 2198
  unregister_netdevice_queue(dev, (struct list_head *)0);
#line 2199
  return;
}
}
#line 2202
extern void free_netdev(struct net_device * ) ;
#line 2205
void ldv_free_netdev_626(struct net_device *dev ) ;
#line 3353
extern void unregister_netdev(struct net_device * ) ;
#line 3356
void ldv_unregister_netdev_627(struct net_device *dev ) ;
#line 49 "include/linux/etherdevice.h"
extern struct net_device *alloc_etherdev_mqs(int  , unsigned int  , unsigned int  ) ;
#line 233 "include/linux/etherdevice.h"
__inline static void eth_broadcast_addr(u8 *addr ) 
{ 


  {
#line 235
  memset((void *)addr, 255, 6UL);
#line 236
  return;
}
}
#line 244 "include/linux/etherdevice.h"
__inline static void eth_zero_addr(u8 *addr ) 
{ 


  {
#line 246
  memset((void *)addr, 0, 6UL);
#line 247
  return;
}
}
#line 325 "include/net/ieee80211_radiotap.h"
__inline static int ieee80211_get_radiotap_len(unsigned char *data ) 
{ 
  struct ieee80211_radiotap_header *hdr ;
  u16 tmp ;

  {
#line 327
  hdr = (struct ieee80211_radiotap_header *)data;
#line 330
  tmp = get_unaligned_le16((void const   *)(& hdr->it_len));
#line 330
  return ((int )tmp);
}
}
#line 503 "include/linux/ieee80211.h"
__inline static int ieee80211_is_action(__le16 fc ) 
{ 


  {
#line 505
  return (((int )fc & 252) == 208);
}
}
#line 3257 "include/net/cfg80211.h"
__inline static void *wiphy_priv___1(struct wiphy *wiphy ) 
{ 
  long tmp ;

  {
#line 3259
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
#line 3259
  if (tmp != 0L) {
#line 3259
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3259), "i" (12UL));
    ldv_48184: ;
#line 3259
    goto ldv_48184;
  } else {

  }
#line 3260
  return ((void *)(& wiphy->priv));
}
}
#line 3281 "include/net/cfg80211.h"
__inline static void set_wiphy_dev(struct wiphy *wiphy , struct device *dev ) 
{ 


  {
#line 3283
  wiphy->dev.parent = dev;
#line 3284
  return;
}
}
#line 3303 "include/net/cfg80211.h"
__inline static char const   *wiphy_name(struct wiphy  const  *wiphy ) 
{ 
  char const   *tmp ;

  {
#line 3305
  tmp = dev_name(& wiphy->dev);
#line 3305
  return (tmp);
}
}
#line 3322
extern struct wiphy *wiphy_new_nm(struct cfg80211_ops  const  * , int  , char const   * ) ;
#line 3337 "include/net/cfg80211.h"
__inline static struct wiphy *wiphy_new(struct cfg80211_ops  const  *ops , int sizeof_priv ) 
{ 
  struct wiphy *tmp ;

  {
#line 3340
  tmp = wiphy_new_nm(ops, sizeof_priv, (char const   *)0);
#line 3340
  return (tmp);
}
}
#line 3350
extern int wiphy_register(struct wiphy * ) ;
#line 3361
extern void wiphy_unregister(struct wiphy * ) ;
#line 3368
extern void wiphy_free(struct wiphy * ) ;
#line 3510 "include/net/cfg80211.h"
__inline static void *wdev_priv___1(struct wireless_dev *wdev ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
#line 3512
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
#line 3512
  if (tmp != 0L) {
#line 3512
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3512), "i" (12UL));
    ldv_48269: ;
#line 3512
    goto ldv_48269;
  } else {

  }
#line 3513
  tmp___0 = wiphy_priv___1(wdev->wiphy);
#line 3513
  return (tmp___0);
}
}
#line 3535
extern int ieee80211_frequency_to_channel(int  ) ;
#line 3544
extern struct ieee80211_channel *__ieee80211_get_channel(struct wiphy * , int  ) ;
#line 3553 "include/net/cfg80211.h"
__inline static struct ieee80211_channel *ieee80211_get_channel(struct wiphy *wiphy ,
                                                                int freq ) 
{ 
  struct ieee80211_channel *tmp ;

  {
#line 3555
  tmp = __ieee80211_get_channel(wiphy, freq);
#line 3555
  return (tmp);
}
}
#line 3917
extern void cfg80211_scan_done(struct cfg80211_scan_request * , bool  ) ;
#line 4020
extern struct cfg80211_bss *cfg80211_inform_bss_width(struct wiphy * , struct ieee80211_channel * ,
                                                      enum nl80211_bss_scan_width  ,
                                                      enum cfg80211_bss_frame_type  ,
                                                      u8 const   * , u64  , u16  ,
                                                      u16  , u8 const   * , size_t  ,
                                                      s32  , gfp_t  ) ;
#line 4029 "include/net/cfg80211.h"
__inline static struct cfg80211_bss *cfg80211_inform_bss(struct wiphy *wiphy , struct ieee80211_channel *rx_channel ,
                                                         enum cfg80211_bss_frame_type ftype ,
                                                         u8 const   *bssid , u64 tsf ,
                                                         u16 capability , u16 beacon_interval ,
                                                         u8 const   *ie , size_t ielen ,
                                                         s32 signal , gfp_t gfp ) 
{ 
  struct cfg80211_bss *tmp ;

  {
#line 4036
  tmp = cfg80211_inform_bss_width(wiphy, rx_channel, 0, ftype, bssid, tsf, (int )capability,
                                  (int )beacon_interval, ie, ielen, signal, gfp);
#line 4036
  return (tmp);
}
}
#line 4075
extern void cfg80211_put_bss(struct wiphy * , struct cfg80211_bss * ) ;
#line 4519
extern void cfg80211_connect_result(struct net_device * , u8 const   * , u8 const   * ,
                                    size_t  , u8 const   * , size_t  , u16  , gfp_t  ) ;
#line 4539
extern void cfg80211_roamed(struct net_device * , struct ieee80211_channel * , u8 const   * ,
                            u8 const   * , size_t  , u8 const   * , size_t  , gfp_t  ) ;
#line 4584
extern void cfg80211_disconnected(struct net_device * , u16  , u8 const   * , size_t  ,
                                  bool  , gfp_t  ) ;
#line 4699
extern void cfg80211_mgmt_tx_status(struct wireless_dev * , u64  , u8 const   * ,
                                    size_t  , bool  , gfp_t  ) ;
#line 24 "drivers/staging/rtl8723au/include/xmit_osdep.h"
int rtw_xmit23a_entry23a(struct sk_buff *skb , struct net_device *pnetdev ) ;
#line 288 "drivers/staging/rtl8723au/include/rtw_recv.h"
__inline static s32 translate_percentage_to_dbm(u32 SignalStrengthIndex ) 
{ 
  s32 SignalPower ;

  {
#line 293
  SignalPower = (int )((SignalStrengthIndex + 1U) >> 1);
#line 294
  SignalPower = SignalPower + -95;
#line 296
  return (SignalPower);
}
}
#line 39 "drivers/staging/rtl8723au/include/osdep_intf.h"
void rtw_ndev_destructor(struct net_device *ndev ) ;
#line 308 "drivers/staging/rtl8723au/include/rtw_mlme.h"
extern bool rtw_is_scan_deny(struct rtw_adapter * ) ;
#line 35 "drivers/staging/rtl8723au/include/rtw_ap.h"
int rtw_check_beacon_data23a(struct rtw_adapter *padapter , struct ieee80211_mgmt *mgmt ,
                             unsigned int len ) ;
#line 48
int rtw_sta_flush23a(struct rtw_adapter *padapter ) ;
#line 50
void start_ap_mode23a(struct rtw_adapter *padapter ) ;
#line 51
void stop_ap_mode23a(struct rtw_adapter *padapter ) ;
#line 44 "drivers/staging/rtl8723au/include/ioctl_cfg80211.h"
int rtw_wdev_alloc(struct rtw_adapter *padapter , struct device *dev ) ;
#line 45
void rtw_wdev_free(struct wireless_dev *wdev ) ;
#line 46
void rtw_wdev_unregister(struct wireless_dev *wdev ) ;
#line 48
void rtw_cfg80211_init_wiphy(struct rtw_adapter *padapter ) ;
#line 60
void rtw_cfg80211_indicate_sta_disassoc(struct rtw_adapter *padapter , unsigned char *da ,
                                        unsigned short reason ) ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static u32 const   rtw_cipher_suites[4U]  = {      1027073U,      1027077U,      1027074U,      1027076U};
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static struct ieee80211_rate rtw_rates[12U]  = 
#line 59
  {      {0U, 10U, 1U, (unsigned short)0}, 
        {0U, 20U, 2U, (unsigned short)0}, 
        {0U, 55U, 4U, (unsigned short)0}, 
        {0U, 110U, 8U, (unsigned short)0}, 
        {0U, 60U, 16U, (unsigned short)0}, 
        {0U, 90U, 32U, (unsigned short)0}, 
        {0U, 120U, 64U, (unsigned short)0}, 
        {0U, 180U, 128U, (unsigned short)0}, 
        {0U, 240U, 256U, (unsigned short)0}, 
        {0U, 360U, 512U, (unsigned short)0}, 
        {0U, 480U, 1024U, (unsigned short)0}, 
        {0U, 540U, 2048U, (unsigned short)0}};
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static struct ieee80211_channel rtw_2ghz_channels[14U]  = 
#line 82
  {      {0, 2412U, 1U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2417U, 2U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2422U, 3U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2427U, 4U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2432U, 5U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2437U, 6U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2442U, 7U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2447U, 8U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2452U, 9U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2457U, 10U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2462U, 11U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2467U, 12U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2472U, 13U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2484U, 14U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}};
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static struct ieee80211_channel rtw_5ghz_a_channels[37U]  = 
#line 99
  {      {1, 5170U, 34U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5180U, 36U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5190U, 38U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5200U, 40U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5210U, 42U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5220U, 44U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5230U, 46U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5240U, 48U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5260U, 52U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5280U, 56U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5300U, 60U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5320U, 64U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5500U, 100U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5520U, 104U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5540U, 108U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5560U, 112U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5580U, 116U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5600U, 120U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5620U, 124U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5640U, 128U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5660U, 132U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5680U, 136U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5700U, 140U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5745U, 149U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5765U, 153U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5785U, 157U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5805U, 161U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5825U, 165U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5920U, 184U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5940U, 188U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5960U, 192U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5980U, 196U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6000U, 200U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6020U, 204U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6040U, 208U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6060U, 212U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6080U, 216U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}};
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static void rtw_2g_channels_init(struct ieee80211_channel *channels ) 
{ 


  {
#line 123
  memcpy((void *)channels, (void const   *)(& rtw_2ghz_channels), 896UL);
#line 124
  return;
}
}
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static void rtw_5g_channels_init(struct ieee80211_channel *channels ) 
{ 


  {
#line 129
  memcpy((void *)channels, (void const   *)(& rtw_5ghz_a_channels), 2368UL);
#line 130
  return;
}
}
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static void rtw_2g_rates_init(struct ieee80211_rate *rates ) 
{ 


  {
#line 135
  memcpy((void *)rates, (void const   *)(& rtw_rates), 144UL);
#line 136
  return;
}
}
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static void rtw_5g_rates_init(struct ieee80211_rate *rates ) 
{ 


  {
#line 141
  memcpy((void *)rates, (void const   *)(& rtw_rates) + 4U, 96UL);
#line 142
  return;
}
}
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static struct ieee80211_supported_band *rtw_spt_band_alloc(enum ieee80211_band band ) 
{ 
  struct ieee80211_supported_band *spt_band ;
  int n_channels ;
  int n_bitrates ;
  void *tmp ;

  {
#line 148
  spt_band = (struct ieee80211_supported_band *)0;
#line 151
  if ((unsigned int )band == 0U) {
#line 152
    n_channels = 14;
#line 153
    n_bitrates = 12;
  } else
#line 154
  if ((unsigned int )band == 1U) {
#line 155
    n_channels = 37;
#line 156
    n_bitrates = 8;
  } else {
#line 158
    goto exit;
  }
#line 160
  tmp = kzalloc(((unsigned long )n_channels * 64UL + (unsigned long )n_bitrates * 12UL) + 72UL,
                208U);
#line 160
  spt_band = (struct ieee80211_supported_band *)tmp;
#line 164
  if ((unsigned long )spt_band == (unsigned long )((struct ieee80211_supported_band *)0)) {
#line 165
    goto exit;
  } else {

  }
#line 167
  spt_band->channels = (struct ieee80211_channel *)spt_band + 72U;
#line 171
  spt_band->bitrates = (struct ieee80211_rate *)spt_band->channels + (unsigned long )n_channels * 64UL;
#line 175
  spt_band->band = band;
#line 176
  spt_band->n_channels = n_channels;
#line 177
  spt_band->n_bitrates = n_bitrates;
#line 179
  if ((unsigned int )band == 0U) {
#line 180
    rtw_2g_channels_init(spt_band->channels);
#line 181
    rtw_2g_rates_init(spt_band->bitrates);
  } else
#line 182
  if ((unsigned int )band == 1U) {
#line 183
    rtw_5g_channels_init(spt_band->channels);
#line 184
    rtw_5g_rates_init(spt_band->bitrates);
  } else {

  }
  exit: ;
#line 190
  return (spt_band);
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static struct ieee80211_txrx_stypes  const  rtw_cfg80211_default_mgmt_stypes[12U]  = 
#line 194
  {      {(unsigned short)0, (unsigned short)0}, 
        {65535U, 8192U}, 
        {65535U, 8208U}, 
        {65535U, 15381U}, 
        {65535U, 15381U}, 
        {(unsigned short)0, (unsigned short)0}, 
        {(unsigned short)0, (unsigned short)0}, 
        {(unsigned short)0, (unsigned short)0}, 
        {65535U, 8208U}, 
        {65535U, 15381U}};
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_inform_bss(struct rtw_adapter *padapter , struct wlan_network *pnetwork ) 
{ 
  int ret ;
  struct ieee80211_channel *notify_channel ;
  struct cfg80211_bss *bss ;
  u16 channel ;
  u32 freq ;
  u8 *notify_ie ;
  size_t notify_ielen ;
  s32 notify_signal ;
  struct wireless_dev *wdev ;
  struct wiphy *wiphy ;
  struct mlme_priv *pmlmepriv ;
  int tmp ;
  int tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;

  {
#line 245
  ret = 0;
#line 253
  wdev = padapter->rtw_wdev;
#line 254
  wiphy = wdev->wiphy;
#line 255
  pmlmepriv = & padapter->mlmepriv;
#line 257
  channel = (u16 )pnetwork->network.DSConfig;
#line 258
  if ((unsigned int )channel <= 14U) {
#line 259
    tmp = ieee80211_channel_to_frequency((int )channel, 0);
#line 259
    freq = (u32 )tmp;
  } else {
#line 262
    tmp___0 = ieee80211_channel_to_frequency((int )channel, 1);
#line 262
    freq = (u32 )tmp___0;
  }
#line 265
  notify_channel = ieee80211_get_channel(wiphy, (int )freq);
#line 267
  notify_ie = (u8 *)(& pnetwork->network.IEs);
#line 268
  notify_ielen = (size_t )pnetwork->network.IELength;
#line 273
  tmp___3 = check_fwstate(pmlmepriv, 1);
#line 273
  if ((int )tmp___3) {
#line 273
    tmp___4 = is_same_network23a(& pmlmepriv->cur_network.network, & pnetwork->network);
#line 273
    if (tmp___4 != 0) {
#line 276
      tmp___1 = translate_percentage_to_dbm((u32 )padapter->recvpriv.signal_strength);
#line 276
      notify_signal = tmp___1 * 100;
    } else {
#line 278
      tmp___2 = translate_percentage_to_dbm((u32 )pnetwork->network.SignalStrength);
#line 278
      notify_signal = tmp___2 * 100;
    }
  } else {
#line 278
    tmp___2 = translate_percentage_to_dbm((u32 )pnetwork->network.SignalStrength);
#line 278
    notify_signal = tmp___2 * 100;
  }
#line 282
  bss = cfg80211_inform_bss(wiphy, notify_channel, 0, (u8 const   *)(& pnetwork->network.MacAddress),
                            pnetwork->network.tsf, (int )pnetwork->network.capability,
                            (int )pnetwork->network.beacon_interval, (u8 const   *)notify_ie,
                            notify_ielen, notify_signal, 32U);
#line 291
  tmp___5 = ldv__builtin_expect((unsigned long )bss == (unsigned long )((struct cfg80211_bss *)0),
                             0L);
#line 291
  if (tmp___5 != 0L) {
#line 292
    if (GlobalDebugLevel23A > 3U) {
#line 292
      printk("\016RTL8723AU: rtw_cfg80211_inform_bss error\n");
    } else {

    }
#line 293
    return (-22);
  } else {

  }
#line 296
  cfg80211_put_bss(wiphy, bss);
#line 298
  return (ret);
}
}
#line 301 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
void rtw_cfg80211_indicate_connect(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  struct wireless_dev *pwdev ;
  bool tmp ;
  struct wiphy *wiphy ;
  struct ieee80211_channel *notify_channel ;
  u32 freq ;
  u16 channel ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 303
  pmlmepriv = & padapter->mlmepriv;
#line 304
  cur_network = & pmlmepriv->cur_network;
#line 305
  pwdev = padapter->rtw_wdev;
#line 307
  if (GlobalDebugLevel23A > 3U) {
#line 307
    printk("\016RTL8723AU: %s(padapter =%p)\n", "rtw_cfg80211_indicate_connect", padapter);
  } else {

  }
#line 309
  if ((unsigned int )pwdev->iftype != 2U && (unsigned int )pwdev->iftype != 8U) {
#line 311
    return;
  } else {

  }
#line 313
  tmp = check_fwstate(pmlmepriv, 16);
#line 313
  if ((int )tmp) {
#line 314
    return;
  } else {

  }
#line 316
  if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
#line 317
    wiphy = pwdev->wiphy;
#line 320
    channel = (u16 )cur_network->network.DSConfig;
#line 322
    if ((unsigned int )channel <= 14U) {
#line 323
      tmp___0 = ieee80211_channel_to_frequency((int )channel, 0);
#line 323
      freq = (u32 )tmp___0;
    } else {
#line 327
      tmp___1 = ieee80211_channel_to_frequency((int )channel, 1);
#line 327
      freq = (u32 )tmp___1;
    }
#line 331
    notify_channel = ieee80211_get_channel(wiphy, (int )freq);
#line 333
    if (GlobalDebugLevel23A > 3U) {
#line 333
      printk("\016RTL8723AU: %s call cfg80211_roamed\n", "rtw_cfg80211_indicate_connect");
    } else {

    }
#line 334
    cfg80211_roamed(padapter->pnetdev, notify_channel, (u8 const   *)(& cur_network->network.MacAddress),
                    (u8 const   *)pmlmepriv->assoc_req + 26U, (unsigned long )pmlmepriv->assoc_req_len - 26UL,
                    (u8 const   *)pmlmepriv->assoc_rsp + 30U, (unsigned long )pmlmepriv->assoc_rsp_len - 30UL,
                    32U);
  } else {
#line 346
    cfg80211_connect_result(padapter->pnetdev, (u8 const   *)(& cur_network->network.MacAddress),
                            (u8 const   *)pmlmepriv->assoc_req + 26U, (unsigned long )pmlmepriv->assoc_req_len - 26UL,
                            (u8 const   *)pmlmepriv->assoc_rsp + 30U, (unsigned long )pmlmepriv->assoc_rsp_len - 30UL,
                            0, 32U);
  }
#line 356
  return;
}
}
#line 360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
void rtw_cfg80211_indicate_disconnect(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wireless_dev *pwdev ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 362
  pmlmepriv = & padapter->mlmepriv;
#line 363
  pwdev = padapter->rtw_wdev;
#line 365
  if (GlobalDebugLevel23A > 3U) {
#line 365
    printk("\016RTL8723AU: %s(padapter =%p)\n", "rtw_cfg80211_indicate_disconnect",
           padapter);
  } else {

  }
#line 367
  if ((unsigned int )pwdev->iftype != 2U && (unsigned int )pwdev->iftype != 8U) {
#line 369
    return;
  } else {

  }
#line 371
  tmp = check_fwstate(pmlmepriv, 16);
#line 371
  if ((int )tmp) {
#line 372
    return;
  } else {

  }
#line 374
  if ((unsigned int )padapter->mlmepriv.not_indic_disco == 0U) {
#line 375
    tmp___0 = check_fwstate(& padapter->mlmepriv, 128);
#line 375
    if ((int )tmp___0) {
#line 376
      cfg80211_connect_result(padapter->pnetdev, (u8 const   *)0U, (u8 const   *)0U,
                              0UL, (u8 const   *)0U, 0UL, 1, 32U);
    } else {
#line 381
      cfg80211_disconnected(padapter->pnetdev, 0, (u8 const   *)0U, 0UL, 0, 32U);
    }
  } else {

  }
#line 382
  return;
}
}
#line 388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int set_pairwise_key(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct cmd_obj *ph2c ;
  struct set_stakey_parm *psetstakey_para ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 392
  pcmdpriv = & padapter->cmdpriv;
#line 393
  res = 1;
#line 395
  tmp = kzalloc(128UL, 208U);
#line 395
  ph2c = (struct cmd_obj *)tmp;
#line 396
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 397
    res = 0;
#line 398
    goto exit;
  } else {

  }
#line 401
  tmp___0 = kzalloc(28UL, 208U);
#line 401
  psetstakey_para = (struct set_stakey_parm *)tmp___0;
#line 402
  if ((unsigned long )psetstakey_para == (unsigned long )((struct set_stakey_parm *)0)) {
#line 403
    kfree((void const   *)ph2c);
#line 404
    res = 0;
#line 405
    goto exit;
  } else {

  }
#line 408
  ph2c->cmdcode = 21U;
#line 408
  ph2c->parmbuf = (u8 *)psetstakey_para;
#line 408
  ph2c->cmdsz = 28U;
#line 408
  ph2c->rsp = (u8 *)0U;
#line 408
  ph2c->rspsz = 0U;
#line 410
  psetstakey_para->algorithm = psta->dot118021XPrivacy;
#line 412
  ether_addr_copy((u8 *)(& psetstakey_para->addr), (u8 const   *)(& psta->hwaddr));
#line 414
  memcpy((void *)(& psetstakey_para->key), (void const   *)(& psta->dot118021x_UncstKey),
           16UL);
#line 416
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
#line 419
  return (res);
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int set_group_key(struct rtw_adapter *padapter , struct key_params *parms ,
                         u32 alg , u8 keyid ) 
{ 
  struct cmd_obj *pcmd ;
  struct setkey_parm *psetkeyparm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 427
  pcmdpriv = & padapter->cmdpriv;
#line 428
  res = 1;
#line 430
  if (GlobalDebugLevel23A > 3U) {
#line 430
    printk("\016RTL8723AU: %s\n", "set_group_key");
  } else {

  }
#line 432
  if ((unsigned int )keyid > 3U) {
#line 433
    res = 0;
#line 434
    goto exit;
  } else {

  }
#line 437
  tmp = kzalloc(128UL, 208U);
#line 437
  pcmd = (struct cmd_obj *)tmp;
#line 438
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
#line 439
    res = 0;
#line 440
    goto exit;
  } else {

  }
#line 442
  tmp___0 = kzalloc(24UL, 208U);
#line 442
  psetkeyparm = (struct setkey_parm *)tmp___0;
#line 443
  if ((unsigned long )psetkeyparm == (unsigned long )((struct setkey_parm *)0)) {
#line 444
    kfree((void const   *)pcmd);
#line 445
    res = 0;
#line 446
    goto exit;
  } else {

  }
#line 449
  psetkeyparm->keyid = keyid;
#line 450
  if (alg == 1027073U || alg == 1027077U) {
#line 451
    padapter->mlmepriv.key_mask = (int )padapter->mlmepriv.key_mask | (int )((u8 )(1UL << (int )psetkeyparm->keyid));
  } else {

  }
#line 453
  psetkeyparm->algorithm = alg;
#line 455
  psetkeyparm->set_tx = 1U;
#line 457
  memcpy((void *)(& psetkeyparm->key), (void const   *)parms->key, (size_t )parms->key_len);
#line 459
  pcmd->cmdcode = 20U;
#line 460
  pcmd->parmbuf = (u8 *)psetkeyparm;
#line 461
  pcmd->cmdsz = 24U;
#line 462
  pcmd->rsp = (u8 *)0U;
#line 463
  pcmd->rspsz = 0U;
#line 465
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
#line 468
  return (res);
}
}
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_ap_set_encryption(struct net_device *dev , u8 key_index ,
                                          int set_tx , u8 const   *sta_addr , struct key_params *keyparms ) 
{ 
  int key_len ;
  struct sta_info *psta ;
  struct sta_info *pbcmc_sta ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;
  struct sta_priv *pstapriv ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 476
  psta = (struct sta_info *)0;
#line 476
  pbcmc_sta = (struct sta_info *)0;
#line 477
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 477
  padapter = (struct rtw_adapter *)tmp;
#line 478
  psecuritypriv = & padapter->securitypriv;
#line 479
  pstapriv = & padapter->stapriv;
#line 481
  if (GlobalDebugLevel23A > 3U) {
#line 481
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_ap_set_encryption");
  } else {

  }
#line 483
  tmp___0 = is_broadcast_ether_addr(sta_addr);
#line 483
  if (tmp___0) {
#line 483
    tmp___1 = 0;
  } else {
#line 483
    tmp___1 = 1;
  }
#line 483
  if (tmp___1) {
#line 484
    psta = rtw_get_stainfo23a(pstapriv, sta_addr);
#line 485
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 487
      if (GlobalDebugLevel23A > 3U) {
#line 487
        printk("\016RTL8723AU: rtw_set_encryption(), sta has already been removed or never been added\n");
      } else {

      }
#line 489
      goto exit;
    } else {

    }
  } else {

  }
#line 493
  key_len = keyparms->key_len;
#line 495
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0) && (keyparms->cipher == 1027073U || keyparms->cipher == 1027077U)) {
#line 497
    if (GlobalDebugLevel23A > 3U) {
#line 497
      printk("\016RTL8723AU: r871x_set_encryption, crypt.alg = WEP\n");
    } else {

    }
#line 499
    if (GlobalDebugLevel23A > 3U) {
#line 499
      printk("\016RTL8723AU: r871x_set_encryption, wep_key_idx =%d, len =%d\n", (int )key_index,
             key_len);
    } else {

    }
#line 502
    if ((unsigned int )psecuritypriv->bWepDefaultKeyIdxSet == 0U) {
#line 506
      psecuritypriv->ndisencryptstatus = 0U;
#line 508
      psecuritypriv->dot11PrivacyAlgrthm = keyparms->cipher;
#line 509
      psecuritypriv->dot118021XGrpPrivacy = keyparms->cipher;
#line 511
      psecuritypriv->dot11PrivacyKeyIndex = (u32 )key_index;
    } else {

    }
#line 514
    memcpy((void *)(& psecuritypriv->wep_key[(int )key_index].key), (void const   *)keyparms->key,
             (size_t )key_len);
#line 517
    psecuritypriv->wep_key[(int )key_index].keylen = (u16 )key_len;
#line 519
    set_group_key(padapter, keyparms, keyparms->cipher, (int )key_index);
#line 521
    goto exit;
  } else {

  }
#line 524
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 525
    if (set_tx == 0) {
#line 526
      if (keyparms->cipher == 1027073U || keyparms->cipher == 1027077U) {
#line 528
        if (GlobalDebugLevel23A > 3U) {
#line 528
          printk("\016RTL8723AU: %s, set group_key, WEP\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
#line 530
        memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )key_index].skey),
                 (void const   *)keyparms->key, (size_t )key_len);
#line 534
        psecuritypriv->dot118021XGrpPrivacy = keyparms->cipher;
      } else
#line 536
      if (keyparms->cipher == 1027074U) {
#line 537
        if (GlobalDebugLevel23A > 3U) {
#line 537
          printk("\016RTL8723AU: %s, set group_key, TKIP\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
#line 540
        psecuritypriv->dot118021XGrpPrivacy = 1027074U;
#line 543
        memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )key_index].skey),
                 (void const   *)keyparms->key, (size_t )(16 < key_len ? 16 : key_len));
#line 549
        memcpy((void *)(& psecuritypriv->dot118021XGrptxmickey[(int )key_index].skey),
                 (void const   *)keyparms->key + 16U, 8UL);
#line 552
        memcpy((void *)(& psecuritypriv->dot118021XGrprxmickey[(int )key_index].skey),
                 (void const   *)keyparms->key + 24U, 8UL);
#line 556
        psecuritypriv->busetkipkey = 1U;
      } else
#line 558
      if (keyparms->cipher == 1027076U) {
#line 559
        if (GlobalDebugLevel23A > 3U) {
#line 559
          printk("\016RTL8723AU: %s, set group_key, CCMP\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
#line 562
        psecuritypriv->dot118021XGrpPrivacy = 1027076U;
#line 565
        memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )key_index].skey),
                 (void const   *)keyparms->key, (size_t )(16 < key_len ? 16 : key_len));
      } else {
#line 570
        if (GlobalDebugLevel23A > 3U) {
#line 570
          printk("\016RTL8723AU: %s, set group_key, none\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
#line 573
        psecuritypriv->dot118021XGrpPrivacy = 0U;
      }
#line 576
      psecuritypriv->dot118021XGrpKeyid = (u32 )key_index;
#line 578
      psecuritypriv->binstallGrpkey = 1U;
#line 580
      psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;
#line 583
      set_group_key(padapter, keyparms, psecuritypriv->dot118021XGrpPrivacy, (int )key_index);
#line 587
      pbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);
#line 588
      if ((unsigned long )pbcmc_sta != (unsigned long )((struct sta_info *)0)) {
#line 589
        pbcmc_sta->ieee8021x_blocked = 0U;
#line 591
        pbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;
      } else {

      }
    } else {

    }
#line 598
    goto exit;
  } else {

  }
#line 601
  if (psecuritypriv->dot11AuthAlgrthm == 2U && (unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 603
    if (set_tx == 1) {
#line 605
      memcpy((void *)(& psta->dot118021x_UncstKey.skey), (void const   *)keyparms->key,
               (size_t )(16 < key_len ? 16 : key_len));
#line 608
      if (keyparms->cipher == 1027073U || keyparms->cipher == 1027077U) {
#line 610
        if (GlobalDebugLevel23A > 3U) {
#line 610
          printk("\016RTL8723AU: %s, set pairwise key, WEP\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
#line 613
        psecuritypriv->dot118021XGrpPrivacy = keyparms->cipher;
      } else
#line 615
      if (keyparms->cipher == 1027074U) {
#line 616
        if (GlobalDebugLevel23A > 3U) {
#line 616
          printk("\016RTL8723AU: %s, set pairwise key, TKIP\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
#line 619
        psta->dot118021XPrivacy = 1027074U;
#line 623
        memcpy((void *)(& psta->dot11tkiptxmickey.skey), (void const   *)keyparms->key + 16U,
                 8UL);
#line 625
        memcpy((void *)(& psta->dot11tkiprxmickey.skey), (void const   *)keyparms->key + 24U,
                 8UL);
#line 628
        psecuritypriv->busetkipkey = 1U;
      } else
#line 630
      if (keyparms->cipher == 1027076U) {
#line 631
        if (GlobalDebugLevel23A > 3U) {
#line 631
          printk("\016RTL8723AU: %s, set pairwise key, CCMP\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
#line 634
        psta->dot118021XPrivacy = 1027076U;
      } else {
#line 637
        if (GlobalDebugLevel23A > 3U) {
#line 637
          printk("\016RTL8723AU: %s, set pairwise key, none\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
#line 640
        psta->dot118021XPrivacy = 0U;
      }
#line 643
      set_pairwise_key(padapter, psta);
#line 645
      psta->ieee8021x_blocked = 0U;
#line 647
      psta->bpairwise_key_installed = 1U;
    } else {
#line 649
      if (keyparms->cipher == 1027073U || keyparms->cipher == 1027077U) {
#line 651
        memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )key_index].skey),
                 (void const   *)keyparms->key, (size_t )key_len);
#line 655
        psecuritypriv->dot118021XGrpPrivacy = keyparms->cipher;
      } else
#line 657
      if (keyparms->cipher == 1027074U) {
#line 658
        psecuritypriv->dot118021XGrpPrivacy = 1027074U;
#line 661
        memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )key_index].skey),
                 (void const   *)keyparms->key, (size_t )(16 < key_len ? 16 : key_len));
#line 667
        memcpy((void *)(& psecuritypriv->dot118021XGrptxmickey[(int )key_index].skey),
                 (void const   *)keyparms->key + 16U, 8UL);
#line 670
        memcpy((void *)(& psecuritypriv->dot118021XGrprxmickey[(int )key_index].skey),
                 (void const   *)keyparms->key + 24U, 8UL);
#line 674
        psecuritypriv->busetkipkey = 1U;
      } else
#line 675
      if (keyparms->cipher == 1027076U) {
#line 676
        psecuritypriv->dot118021XGrpPrivacy = 1027076U;
#line 679
        memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )key_index].skey),
                 (void const   *)keyparms->key, (size_t )(16 < key_len ? 16 : key_len));
      } else {
#line 684
        psecuritypriv->dot118021XGrpPrivacy = 0U;
      }
#line 687
      psecuritypriv->dot118021XGrpKeyid = (u32 )key_index;
#line 689
      psecuritypriv->binstallGrpkey = 1U;
#line 691
      psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;
#line 694
      set_group_key(padapter, keyparms, psecuritypriv->dot118021XGrpPrivacy, (int )key_index);
#line 698
      pbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);
#line 699
      if ((unsigned long )pbcmc_sta != (unsigned long )((struct sta_info *)0)) {
#line 702
        pbcmc_sta->ieee8021x_blocked = 0U;
#line 703
        pbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;
      } else {

      }
    }
  } else {

  }
  exit: ;
#line 711
  return (0);
}
}
#line 715 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_set_encryption(struct net_device *dev , u8 key_index , int set_tx ,
                                       u8 const   *sta_addr , struct key_params *keyparms ) 
{ 
  int ret ;
  int key_len ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct sta_info *psta ;
  struct sta_info *pbcmc_sta ;
  struct sta_priv *pstapriv ;
  u8 *tmp___0 ;
  bool tmp___1 ;

  {
#line 719
  ret = 0;
#line 721
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 721
  padapter = (struct rtw_adapter *)tmp;
#line 722
  pmlmepriv = & padapter->mlmepriv;
#line 723
  psecuritypriv = & padapter->securitypriv;
#line 725
  if (GlobalDebugLevel23A > 3U) {
#line 725
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_set_encryption");
  } else {

  }
#line 727
  key_len = keyparms->key_len;
#line 729
  if (keyparms->cipher == 1027073U || keyparms->cipher == 1027077U) {
#line 731
    if (GlobalDebugLevel23A > 3U) {
#line 731
      rt_trace(33554432, 4, "wpa_set_encryption, crypt.alg = WEP\n");
    } else {

    }
#line 733
    if (GlobalDebugLevel23A > 3U) {
#line 733
      printk("\016RTL8723AU: wpa_set_encryption, crypt.alg = WEP\n");
    } else {

    }
#line 735
    if ((unsigned int )psecuritypriv->bWepDefaultKeyIdxSet == 0U) {
#line 739
      psecuritypriv->ndisencryptstatus = 0U;
#line 741
      psecuritypriv->dot11PrivacyAlgrthm = keyparms->cipher;
#line 742
      psecuritypriv->dot118021XGrpPrivacy = keyparms->cipher;
#line 744
      psecuritypriv->dot11PrivacyKeyIndex = (u32 )key_index;
    } else {

    }
#line 747
    memcpy((void *)(& psecuritypriv->wep_key[(int )key_index].key), (void const   *)keyparms->key,
             (size_t )key_len);
#line 750
    psecuritypriv->wep_key[(int )key_index].keylen = (u16 )key_len;
#line 752
    rtw_set_key23a(padapter, psecuritypriv, (int )key_index, 0);
#line 754
    goto exit;
  } else {

  }
#line 757
  if (padapter->securitypriv.dot11AuthAlgrthm == 2U) {
#line 760
    pstapriv = & padapter->stapriv;
#line 762
    tmp___1 = check_fwstate(pmlmepriv, 65544);
#line 762
    if ((int )tmp___1) {
#line 765
      tmp___0 = get_bssid(pmlmepriv);
#line 765
      psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)tmp___0);
#line 766
      if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 767
        if (GlobalDebugLevel23A > 3U) {
#line 767
          printk("\016RTL8723AU: %s, : Obtain Sta_info fail\n", "rtw_cfg80211_set_encryption");
        } else {

        }
      } else {
#line 772
        if (keyparms->cipher != 1U && keyparms->cipher != 0U) {
#line 774
          psta->ieee8021x_blocked = 0U;
        } else {

        }
#line 776
        if (padapter->securitypriv.ndisencryptstatus == 4U || padapter->securitypriv.ndisencryptstatus == 6U) {
#line 780
          psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
        } else {

        }
#line 785
        if (set_tx == 1) {
#line 787
          if (GlobalDebugLevel23A > 3U) {
#line 787
            printk("\016RTL8723AU: %s, : set_tx == 1\n", "rtw_cfg80211_set_encryption");
          } else {

          }
#line 790
          memcpy((void *)(& psta->dot118021x_UncstKey.skey), (void const   *)keyparms->key,
                   (size_t )(16 < key_len ? 16 : key_len));
#line 794
          if (keyparms->cipher == 1027074U) {
#line 796
            memcpy((void *)(& psta->dot11tkiptxmickey.skey), (void const   *)keyparms->key + 16U,
                     8UL);
#line 799
            memcpy((void *)(& psta->dot11tkiprxmickey.skey), (void const   *)keyparms->key + 24U,
                     8UL);
#line 803
            padapter->securitypriv.busetkipkey = 0U;
          } else {

          }
#line 806
          if (GlobalDebugLevel23A > 3U) {
#line 806
            printk("\016RTL8723AU:  ~~~~set sta key:unicastkey\n");
          } else {

          }
#line 808
          rtw_setstakey_cmd23a(padapter, (u8 *)psta, 1);
        } else {
#line 812
          memcpy((void *)(& padapter->securitypriv.dot118021XGrpKey[(int )key_index].skey),
                   (void const   *)keyparms->key, (size_t )(16 < key_len ? 16 : key_len));
#line 816
          memcpy((void *)(& padapter->securitypriv.dot118021XGrptxmickey[(int )key_index].skey),
                   (void const   *)keyparms->key + 16U, 8UL);
#line 819
          memcpy((void *)(& padapter->securitypriv.dot118021XGrprxmickey[(int )key_index].skey),
                   (void const   *)keyparms->key + 24U, 8UL);
#line 822
          padapter->securitypriv.binstallGrpkey = 1U;
#line 824
          if (GlobalDebugLevel23A > 3U) {
#line 824
            printk("\016RTL8723AU:  ~~~~set sta key:groupkey\n");
          } else {

          }
#line 827
          padapter->securitypriv.dot118021XGrpKeyid = (u32 )key_index;
#line 830
          rtw_set_key23a(padapter, & padapter->securitypriv, (int )key_index, 1);
        }
      }
#line 836
      pbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);
#line 837
      if ((unsigned long )pbcmc_sta != (unsigned long )((struct sta_info *)0)) {
#line 840
        if (keyparms->cipher != 1U && keyparms->cipher != 0U) {
#line 842
          pbcmc_sta->ieee8021x_blocked = 0U;
        } else {

        }
#line 844
        if (padapter->securitypriv.ndisencryptstatus == 4U || padapter->securitypriv.ndisencryptstatus == 6U) {
#line 848
          pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  exit: ;
#line 858
  if (GlobalDebugLevel23A > 3U) {
#line 858
    printk("\016RTL8723AU: %s, ret =%d\n", "rtw_cfg80211_set_encryption", ret);
  } else {

  }
#line 862
  return (ret);
}
}
#line 865 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_add_key(struct wiphy *wiphy , struct net_device *ndev , u8 key_index ,
                                bool pairwise , u8 const   *mac_addr , struct key_params *params ) 
{ 
  int set_tx ;
  int ret ;
  struct wireless_dev *rtw_wdev ;
  void *tmp ;
  struct rtw_adapter *padapter ;
  void *tmp___0 ;
  struct mlme_priv *pmlmepriv ;
  u8 sta_addr[6U] ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
#line 869
  ret = 0;
#line 870
  tmp = wiphy_priv___1(wiphy);
#line 870
  rtw_wdev = ((struct rtw_wdev_priv *)tmp)->rtw_wdev;
#line 871
  tmp___0 = wiphy_priv___1(wiphy);
#line 871
  padapter = ((struct rtw_wdev_priv *)tmp___0)->padapter;
#line 872
  pmlmepriv = & padapter->mlmepriv;
#line 875
  if (GlobalDebugLevel23A > 3U) {
#line 875
    printk("\016RTL8723AU: %s(%s): adding key for %pM\n", "cfg80211_rtw_add_key",
           (char *)(& ndev->name), mac_addr);
  } else {

  }
#line 877
  if (GlobalDebugLevel23A > 3U) {
#line 877
    printk("\016RTL8723AU: cipher = 0x%x\n", params->cipher);
  } else {

  }
#line 878
  if (GlobalDebugLevel23A > 3U) {
#line 878
    printk("\016RTL8723AU: key_len = 0x%x\n", params->key_len);
  } else {

  }
#line 879
  if (GlobalDebugLevel23A > 3U) {
#line 879
    printk("\016RTL8723AU: seq_len = 0x%x\n", params->seq_len);
  } else {

  }
#line 880
  if (GlobalDebugLevel23A > 3U) {
#line 880
    printk("\016RTL8723AU: key_index =%d\n", (int )key_index);
  } else {

  }
#line 881
  if (GlobalDebugLevel23A > 3U) {
#line 881
    printk("\016RTL8723AU: pairwise =%d\n", (int )pairwise);
  } else {

  }
#line 883
  switch (params->cipher) {
  case 1U: ;
  case 1027073U: ;
#line 886
  if (params->key_len != 5) {
#line 887
    ret = -22;
#line 888
    goto exit;
  } else {

  }
  case 1027077U: ;
#line 891
  if (params->key_len != 13) {
#line 892
    ret = -22;
#line 893
    goto exit;
  } else {

  }
  case 1027074U: ;
  case 1027076U: ;
#line 897
  goto ldv_53312;
  default: 
#line 899
  ret = -524;
#line 900
  goto exit;
  }
  ldv_53312: ;
#line 903
  if ((unsigned int )key_index > 3U || params->key_len < 0) {
#line 904
    ret = -22;
#line 905
    goto exit;
  } else {

  }
#line 908
  eth_broadcast_addr((u8 *)(& sta_addr));
#line 910
  if ((unsigned long )mac_addr == (unsigned long )((u8 const   *)0U)) {
#line 911
    set_tx = 0;
  } else {
#line 910
    tmp___1 = is_broadcast_ether_addr(mac_addr);
#line 910
    if ((int )tmp___1) {
#line 911
      set_tx = 0;
    } else {
#line 913
      set_tx = 1;
    }
  }
#line 915
  tmp___3 = check_fwstate(pmlmepriv, 8);
#line 915
  if ((int )tmp___3) {
#line 916
    ret = rtw_cfg80211_set_encryption(ndev, (int )key_index, set_tx, (u8 const   *)(& sta_addr),
                                      params);
  } else {
#line 918
    tmp___2 = check_fwstate(pmlmepriv, 16);
#line 918
    if ((int )tmp___2) {
#line 920
      if ((unsigned long )mac_addr != (unsigned long )((u8 const   *)0U)) {
#line 921
        ether_addr_copy((u8 *)(& sta_addr), mac_addr);
      } else {

      }
#line 923
      ret = rtw_cfg80211_ap_set_encryption(ndev, (int )key_index, set_tx, (u8 const   *)(& sta_addr),
                                           params);
    } else
#line 927
    if (GlobalDebugLevel23A > 3U) {
#line 927
      printk("\016RTL8723AU: error! fw_state = 0x%x, iftype =%d\n", pmlmepriv->fw_state,
             (unsigned int )rtw_wdev->iftype);
    } else {

    }
  }
  exit: ;
#line 933
  return (ret);
}
}
#line 937 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_get_key(struct wiphy *wiphy , struct net_device *ndev , u8 key_index ,
                                bool pairwise , u8 const   *mac_addr , void *cookie ,
                                void (*callback)(void * , struct key_params * ) ) 
{ 


  {
#line 942
  if (GlobalDebugLevel23A > 3U) {
#line 942
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_get_key", (char *)(& ndev->name));
  } else {

  }
#line 943
  return (0);
}
}
#line 946 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_del_key(struct wiphy *wiphy , struct net_device *ndev , u8 key_index ,
                                bool pairwise , u8 const   *mac_addr ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;

  {
#line 950
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 950
  padapter = (struct rtw_adapter *)tmp;
#line 951
  psecuritypriv = & padapter->securitypriv;
#line 953
  if (GlobalDebugLevel23A > 3U) {
#line 953
    printk("\016RTL8723AU: %s(%s): key_index =%d\n", "cfg80211_rtw_del_key", (char *)(& ndev->name),
           (int )key_index);
  } else {

  }
#line 955
  if ((u32 )key_index == psecuritypriv->dot11PrivacyKeyIndex) {
#line 957
    psecuritypriv->bWepDefaultKeyIdxSet = 0U;
  } else {

  }
#line 960
  return (0);
}
}
#line 963 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_set_default_key(struct wiphy *wiphy , struct net_device *ndev ,
                                        u8 key_index , bool unicast , bool multicast ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;

  {
#line 967
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 967
  padapter = (struct rtw_adapter *)tmp;
#line 968
  psecuritypriv = & padapter->securitypriv;
#line 970
  if (GlobalDebugLevel23A > 3U) {
#line 970
    printk("\016RTL8723AU: %s(%s): key_index =%d, unicast =%d, multicast =%d.\n",
           "cfg80211_rtw_set_default_key", (char *)(& ndev->name), (int )key_index,
           (int )unicast, (int )multicast);
  } else {

  }
#line 973
  if ((unsigned int )key_index <= 3U && (psecuritypriv->dot11PrivacyAlgrthm == 1027073U || psecuritypriv->dot11PrivacyAlgrthm == 1027077U)) {
#line 977
    psecuritypriv->ndisencryptstatus = 0U;
#line 979
    psecuritypriv->dot11PrivacyKeyIndex = (u32 )key_index;
#line 981
    psecuritypriv->dot11PrivacyAlgrthm = 1027073U;
#line 982
    psecuritypriv->dot118021XGrpPrivacy = 1027073U;
#line 983
    if ((unsigned int )psecuritypriv->wep_key[(int )key_index].keylen == 13U) {
#line 984
      psecuritypriv->dot11PrivacyAlgrthm = 1027077U;
#line 986
      psecuritypriv->dot118021XGrpPrivacy = 1027077U;
    } else {

    }
#line 992
    psecuritypriv->bWepDefaultKeyIdxSet = 1U;
  } else {

  }
#line 995
  return (0);
}
}
#line 998 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static u16 rtw_get_cur_max_rate(struct rtw_adapter *adapter ) 
{ 
  int i ;
  u8 const   *p ;
  u16 rate ;
  u16 max_rate ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct registry_priv *pregistrypriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pcur_bss ;
  struct ieee80211_ht_cap *pht_capie ;
  u8 rf_type ;
  u8 bw_40MHz ;
  u8 short_GI_20 ;
  u8 short_GI_40 ;
  u16 mcs_rate ;

  {
#line 1000
  i = 0;
#line 1002
  rate = 0U;
#line 1002
  max_rate = 0U;
#line 1003
  pmlmeext = & adapter->mlmeextpriv;
#line 1004
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1005
  pregistrypriv = & adapter->registrypriv;
#line 1006
  pmlmepriv = & adapter->mlmepriv;
#line 1007
  pcur_bss = & pmlmepriv->cur_network.network;
#line 1009
  rf_type = 0U;
#line 1010
  bw_40MHz = 0U;
#line 1010
  short_GI_20 = 0U;
#line 1010
  short_GI_40 = 0U;
#line 1011
  mcs_rate = 0U;
#line 1013
  p = cfg80211_find_ie(45, (u8 const   *)(& pcur_bss->IEs), (int )pcur_bss->IELength);
#line 1015
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 1016
    pht_capie = (struct ieee80211_ht_cap *)p + 2U;
#line 1018
    memcpy((void *)(& mcs_rate), (void const   *)(& pht_capie->mcs), 2UL);
#line 1024
    bw_40MHz = (u8 )((unsigned int )pmlmeext->cur_bwmode != 0U && ((int )pmlmeinfo->HT_info.ht_param & 4) != 0);
#line 1030
    short_GI_20 = ((int )pmlmeinfo->ht_cap.cap_info & 32) != 0;
#line 1032
    short_GI_40 = ((int )pmlmeinfo->ht_cap.cap_info & 64) != 0;
#line 1035
    rf_type = rtl8723a_get_rf_type(adapter);
#line 1036
    max_rate = rtw_mcs_rate23a((int )rf_type, (int )pregistrypriv->cbw40_enable & (int )bw_40MHz,
                               (int )short_GI_20, (int )short_GI_40, & pmlmeinfo->ht_cap.mcs);
  } else {
#line 1041
    goto ldv_53365;
    ldv_53364: 
#line 1043
    rate = (unsigned int )((u16 )pcur_bss->SupportedRates[i]) & 127U;
#line 1044
    if ((int )rate > (int )max_rate) {
#line 1045
      max_rate = rate;
    } else {

    }
#line 1046
    i = i + 1;
    ldv_53365: ;
#line 1041
    if ((unsigned int )pcur_bss->SupportedRates[i] != 0U && (unsigned int )pcur_bss->SupportedRates[i] != 255U) {
#line 1044
      goto ldv_53364;
    } else {

    }
#line 1049
    max_rate = (u16 )(((int )max_rate * 10) / 2);
  }
#line 1052
  return (max_rate);
}
}
#line 1055 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_get_station(struct wiphy *wiphy , struct net_device *ndev ,
                                    u8 const   *mac , struct station_info *sinfo ) 
{ 
  int ret ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct wlan_network *cur_network ;
  bool tmp___0 ;
  int tmp___1 ;
  s32 tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;

  {
#line 1059
  ret = 0;
#line 1060
  tmp = wiphy_priv___1(wiphy);
#line 1060
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 1061
  pmlmepriv = & padapter->mlmepriv;
#line 1062
  psta = (struct sta_info *)0;
#line 1063
  pstapriv = & padapter->stapriv;
#line 1065
  sinfo->filled = 0U;
#line 1067
  if ((unsigned long )mac == (unsigned long )((u8 const   *)0U)) {
#line 1068
    if (GlobalDebugLevel23A > 3U) {
#line 1068
      printk("\016RTL8723AU: %s(%s): mac ==%p\n", "cfg80211_rtw_get_station", (char *)(& ndev->name),
             mac);
    } else {

    }
#line 1069
    ret = -2;
#line 1070
    goto exit;
  } else {

  }
#line 1073
  psta = rtw_get_stainfo23a(pstapriv, mac);
#line 1074
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1075
    if (GlobalDebugLevel23A > 3U) {
#line 1075
      printk("\016RTL8723AU: %s, sta_info is null\n", "cfg80211_rtw_get_station");
    } else {

    }
#line 1076
    ret = -2;
#line 1077
    goto exit;
  } else {

  }
#line 1079
  if (GlobalDebugLevel23A > 3U) {
#line 1079
    printk("\016RTL8723AU: %s(%s): mac=%pM\n", "cfg80211_rtw_get_station", (char *)(& ndev->name),
           mac);
  } else {

  }
#line 1082
  tmp___3 = check_fwstate(pmlmepriv, 8);
#line 1082
  if ((int )tmp___3) {
#line 1082
    tmp___4 = check_fwstate(pmlmepriv, 1);
#line 1082
    if ((int )tmp___4) {
#line 1084
      cur_network = & pmlmepriv->cur_network;
#line 1086
      tmp___0 = ether_addr_equal(mac, (u8 const   *)(& cur_network->network.MacAddress));
#line 1086
      if (tmp___0) {
#line 1086
        tmp___1 = 0;
      } else {
#line 1086
        tmp___1 = 1;
      }
#line 1086
      if (tmp___1) {
#line 1087
        if (GlobalDebugLevel23A > 3U) {
#line 1087
          printk("\016RTL8723AU: %s, mismatch bssid=%pM\n", "cfg80211_rtw_get_station",
                 (u8 *)(& cur_network->network.MacAddress));
        } else {

        }
#line 1089
        ret = -2;
#line 1090
        goto exit;
      } else {

      }
#line 1093
      sinfo->filled = sinfo->filled | 128U;
#line 1094
      tmp___2 = translate_percentage_to_dbm((u32 )padapter->recvpriv.signal_strength);
#line 1094
      sinfo->signal = (s8 )tmp___2;
#line 1097
      sinfo->filled = sinfo->filled | 256U;
#line 1098
      sinfo->txrate.legacy = rtw_get_cur_max_rate(padapter);
#line 1100
      sinfo->filled = sinfo->filled | 512U;
#line 1101
      sinfo->rx_packets = (u32 )psta->sta_stats.rx_data_pkts;
#line 1103
      sinfo->filled = sinfo->filled | 1024U;
#line 1104
      sinfo->tx_packets = (u32 )psta->sta_stats.tx_pkts;
    } else {

    }
  } else {

  }
#line 1108
  tmp___5 = check_fwstate(pmlmepriv, 32);
#line 1108
  if ((int )tmp___5) {
#line 1108
    goto _L;
  } else {
#line 1108
    tmp___6 = check_fwstate(pmlmepriv, 64);
#line 1108
    if ((int )tmp___6) {
#line 1108
      goto _L;
    } else {
#line 1108
      tmp___7 = check_fwstate(pmlmepriv, 16);
#line 1108
      if ((int )tmp___7) {
        _L: /* CIL Label */ 
#line 1108
        tmp___8 = check_fwstate(pmlmepriv, 1);
#line 1108
        if ((int )tmp___8) {
#line 1108
          tmp___9 = 1;
        } else {
#line 1108
          tmp___9 = 0;
        }
      } else {
#line 1108
        tmp___9 = 0;
      }
    }
  }
  exit: ;
#line 1117
  return (ret);
}
}
#line 1120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_infrastructure_mode(struct rtw_adapter *padapter , enum nl80211_iftype ifmode ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  enum nl80211_iftype old_mode ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
#line 1123
  pmlmepriv = & padapter->mlmepriv;
#line 1124
  cur_network = & pmlmepriv->cur_network;
#line 1127
  old_mode = cur_network->network.ifmode;
#line 1129
  if (GlobalDebugLevel23A > 5U) {
#line 1129
    tmp = get_fwstate(pmlmepriv);
#line 1129
    rt_trace(131072, 6, "+%s: old =%d new =%d fw_state = 0x%08x\n", "cfg80211_infrastructure_mode",
             (unsigned int )old_mode, (unsigned int )ifmode, tmp);
  } else {

  }
#line 1133
  if ((unsigned int )old_mode != (unsigned int )ifmode) {
#line 1134
    spin_lock_bh(& pmlmepriv->lock);
#line 1136
    if (GlobalDebugLevel23A > 6U) {
#line 1136
      rt_trace(131072, 7, "change mode!\n");
    } else {

    }
#line 1139
    if ((unsigned int )old_mode == 3U || (unsigned int )old_mode == 9U) {
#line 1142
      cur_network->join_res = -1;
#line 1145
      stop_ap_mode23a(padapter);
    } else {

    }
#line 1149
    tmp___0 = check_fwstate(pmlmepriv, 1);
#line 1149
    if ((int )tmp___0 || (unsigned int )old_mode == 1U) {
#line 1151
      rtw_disassoc_cmd23a(padapter, 0U, 1);
    } else {

    }
#line 1153
    tmp___1 = check_fwstate(pmlmepriv, 1);
#line 1153
    if ((int )tmp___1) {
#line 1155
      rtw_free_assoc_resources23a(padapter, 1);
    } else {
#line 1153
      tmp___2 = check_fwstate(pmlmepriv, 64);
#line 1153
      if ((int )tmp___2) {
#line 1155
        rtw_free_assoc_resources23a(padapter, 1);
      } else {

      }
    }
#line 1157
    if (((unsigned int )old_mode == 2U || (unsigned int )old_mode == 8U) || (unsigned int )old_mode == 1U) {
#line 1160
      tmp___3 = check_fwstate(pmlmepriv, 1);
#line 1160
      if ((int )tmp___3) {
#line 1164
        rtw_indicate_disconnect23a(padapter);
      } else {

      }
    } else {

    }
#line 1168
    cur_network->network.ifmode = ifmode;
#line 1170
    _clr_fwstate_(pmlmepriv, -1);
#line 1172
    switch ((unsigned int )ifmode) {
    case 1U: 
#line 1174
    set_fwstate(pmlmepriv, 32);
#line 1175
    goto ldv_53390;
    case 8U: ;
    case 2U: 
#line 1179
    set_fwstate(pmlmepriv, 8);
#line 1180
    goto ldv_53390;
    case 9U: ;
    case 3U: 
#line 1184
    set_fwstate(pmlmepriv, 16);
#line 1186
    start_ap_mode23a(padapter);
#line 1189
    goto ldv_53390;
    default: ;
#line 1192
    goto ldv_53390;
    }
    ldv_53390: 
#line 1197
    spin_unlock_bh(& pmlmepriv->lock);
  } else {

  }
#line 1200
  return (1);
}
}
#line 1203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_change_iface(struct wiphy *wiphy , struct net_device *ndev ,
                                     enum nl80211_iftype type , u32 *flags , struct vif_params *params ) 
{ 
  enum nl80211_iftype old_type ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_ext_priv *pmlmeext ;
  struct wireless_dev *rtw_wdev ;
  void *tmp___0 ;
  int ret ;
  int tmp___1 ;

  {
#line 1209
  tmp = wiphy_priv___1(wiphy);
#line 1209
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 1210
  pmlmeext = & padapter->mlmeextpriv;
#line 1211
  tmp___0 = wiphy_priv___1(wiphy);
#line 1211
  rtw_wdev = ((struct rtw_wdev_priv *)tmp___0)->rtw_wdev;
#line 1212
  ret = 0;
#line 1214
  if (GlobalDebugLevel23A > 3U) {
#line 1214
    printk("\016RTL8723AU: %s(%s): call netdev_open23a\n", "cfg80211_rtw_change_iface",
           (char *)(& ndev->name));
  } else {

  }
#line 1216
  old_type = rtw_wdev->iftype;
#line 1217
  if (GlobalDebugLevel23A > 3U) {
#line 1217
    printk("\016RTL8723AU: %s(%s): old_iftype =%d, new_iftype =%d\n", "cfg80211_rtw_change_iface",
           (char *)(& ndev->name), (unsigned int )old_type, (unsigned int )type);
  } else {

  }
#line 1220
  if ((unsigned int )old_type != (unsigned int )type) {
#line 1221
    pmlmeext->action_public_rxseq = 65535U;
#line 1222
    pmlmeext->action_public_dialog_token = 255U;
  } else {

  }
#line 1225
  switch ((unsigned int )type) {
  case 1U: ;
  case 8U: ;
  case 2U: ;
  case 9U: ;
  case 3U: ;
  case 0U: ;
#line 1232
  goto ldv_53415;
  default: ;
#line 1234
  return (-95);
  }
  ldv_53415: 
#line 1237
  rtw_wdev->iftype = type;
#line 1239
  tmp___1 = cfg80211_infrastructure_mode(padapter, type);
#line 1239
  if (tmp___1 != 1) {
#line 1240
    rtw_wdev->iftype = old_type;
#line 1241
    ret = -1;
#line 1242
    goto exit;
  } else {

  }
#line 1245
  rtw_setopmode_cmd23a(padapter, type);
  exit: ;
#line 1248
  return (ret);
}
}
#line 1251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv , bool aborted ) 
{ 


  {
#line 1254
  spin_lock_bh(& pwdev_priv->scan_req_lock);
#line 1255
  if ((unsigned long )pwdev_priv->scan_request != (unsigned long )((struct cfg80211_scan_request *)0)) {
#line 1256
    if (GlobalDebugLevel23A > 3U) {
#line 1256
      printk("\016RTL8723AU: %s with scan req\n", "rtw_cfg80211_indicate_scan_done");
    } else {

    }
#line 1258
    if ((unsigned long )(pwdev_priv->scan_request)->wiphy != (unsigned long )(pwdev_priv->rtw_wdev)->wiphy) {
#line 1260
      if (GlobalDebugLevel23A > 3U) {
#line 1260
        printk("\016RTL8723AU: error wiphy compare\n");
      } else {

      }
    } else {
#line 1262
      cfg80211_scan_done(pwdev_priv->scan_request, (int )aborted);
    }
#line 1264
    pwdev_priv->scan_request = (struct cfg80211_scan_request *)0;
  } else
#line 1266
  if (GlobalDebugLevel23A > 3U) {
#line 1266
    printk("\016RTL8723AU: %s without scan req\n", "rtw_cfg80211_indicate_scan_done");
  } else {

  }
#line 1268
  spin_unlock_bh(& pwdev_priv->scan_req_lock);
#line 1269
  return;
}
}
#line 1271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
void rtw_cfg80211_surveydone_event_callback(struct rtw_adapter *padapter ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct mlme_priv *pmlmepriv ;
  struct rtw_queue *queue ;
  struct wlan_network *pnetwork ;
  struct list_head  const  *__mptr ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1274
  pmlmepriv = & padapter->mlmepriv;
#line 1275
  queue = & pmlmepriv->scanned_queue;
#line 1278
  spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 1280
  phead = get_list_head(queue);
#line 1282
  plist = phead->next;
#line 1282
  ptmp = plist->next;
#line 1282
  goto ldv_53435;
  ldv_53434: 
#line 1283
  __mptr = (struct list_head  const  *)plist;
#line 1283
  pnetwork = (struct wlan_network *)__mptr;
#line 1287
  tmp = rtw_ch_set_search_ch23a((struct rt_channel_info *)(& padapter->mlmeextpriv.channel_set),
                                pnetwork->network.DSConfig);
#line 1287
  if (tmp >= 0) {
#line 1290
    rtw_cfg80211_inform_bss(padapter, pnetwork);
  } else {

  }
#line 1282
  plist = ptmp;
#line 1282
  ptmp = plist->next;
  ldv_53435: ;
#line 1282
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1284
    goto ldv_53434;
  } else {

  }
#line 1293
  spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1296
  tmp___0 = wdev_priv___1(padapter->rtw_wdev);
#line 1296
  rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___0, 0);
#line 1297
  return;
}
}
#line 1300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_set_probe_req_wpsp2pie(struct rtw_adapter *padapter , char *buf ,
                                               int len ) 
{ 
  int ret ;
  u8 const   *wps_ie ;
  struct mlme_priv *pmlmepriv ;
  void *tmp ;

  {
#line 1303
  ret = 0;
#line 1305
  pmlmepriv = & padapter->mlmepriv;
#line 1307
  if (GlobalDebugLevel23A > 3U) {
#line 1307
    printk("\016RTL8723AU: %s, ielen =%d\n", "rtw_cfg80211_set_probe_req_wpsp2pie",
           len);
  } else {

  }
#line 1309
  if (len > 0) {
#line 1310
    wps_ie = cfg80211_find_vendor_ie(20722U, 4, (u8 const   *)buf, len);
#line 1313
    if ((unsigned long )wps_ie != (unsigned long )((u8 const   *)0U)) {
#line 1314
      if (GlobalDebugLevel23A > 3U) {
#line 1314
        printk("\016RTL8723AU: probe_req_wps_ielen =%d\n", (int )*(wps_ie + 1UL));
      } else {

      }
#line 1316
      if ((unsigned long )pmlmepriv->wps_probe_req_ie != (unsigned long )((u8 *)0U)) {
#line 1317
        pmlmepriv->wps_probe_req_ie_len = 0U;
#line 1318
        kfree((void const   *)pmlmepriv->wps_probe_req_ie);
#line 1319
        pmlmepriv->wps_probe_req_ie = (u8 *)0U;
      } else {

      }
#line 1322
      tmp = kmemdup((void const   *)wps_ie, (size_t )*(wps_ie + 1UL), 208U);
#line 1322
      pmlmepriv->wps_probe_req_ie = (u8 *)tmp;
#line 1324
      if ((unsigned long )pmlmepriv->wps_probe_req_ie == (unsigned long )((u8 *)0U)) {
#line 1325
        if (GlobalDebugLevel23A > 3U) {
#line 1325
          printk("\016RTL8723AU: %s()-%d: kmalloc() OLD_ERROR!\n", "rtw_cfg80211_set_probe_req_wpsp2pie",
                 1326);
        } else {

        }
#line 1327
        return (-22);
      } else {

      }
#line 1329
      pmlmepriv->wps_probe_req_ie_len = (u32 )*(wps_ie + 1UL);
    } else {

    }
  } else {

  }
#line 1333
  return (ret);
}
}
#line 1336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_scan(struct wiphy *wiphy , struct cfg80211_scan_request *request ) 
{ 
  int i ;
  u8 _status ;
  int ret ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct cfg80211_ssid ssid[9U] ;
  struct rtw_ieee80211_channel ch[51U] ;
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp___0 ;
  struct cfg80211_ssid *ssids ;
  bool need_indicate_scan_done ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1340
  _status = 0U;
#line 1341
  ret = 0;
#line 1342
  tmp = wiphy_priv___1(wiphy);
#line 1342
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 1343
  pmlmepriv = & padapter->mlmepriv;
#line 1346
  tmp___0 = wdev_priv___1(padapter->rtw_wdev);
#line 1346
  pwdev_priv = (struct rtw_wdev_priv *)tmp___0;
#line 1347
  ssids = request->ssids;
#line 1348
  need_indicate_scan_done = 0;
#line 1350
  if (GlobalDebugLevel23A > 3U) {
#line 1350
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_scan", (char *)(& (padapter->pnetdev)->name));
  } else {

  }
#line 1352
  spin_lock_bh(& pwdev_priv->scan_req_lock);
#line 1353
  pwdev_priv->scan_request = request;
#line 1354
  spin_unlock_bh(& pwdev_priv->scan_req_lock);
#line 1356
  tmp___1 = check_fwstate(pmlmepriv, 16);
#line 1356
  if ((int )tmp___1) {
#line 1357
    if (GlobalDebugLevel23A > 3U) {
#line 1357
      printk("\016RTL8723AU: %s under WIFI_AP_STATE\n", "cfg80211_rtw_scan");
    } else {

    }
  } else {

  }
#line 1362
  tmp___2 = _rtw_pwr_wakeup23a(padapter, 2000U, "cfg80211_rtw_scan");
#line 1362
  if (tmp___2 == 0) {
#line 1363
    need_indicate_scan_done = 1;
#line 1364
    goto check_need_indicate_scan_done;
  } else {

  }
#line 1367
  if ((unsigned long )request->ie != (unsigned long )((u8 const   *)0U) && request->ie_len != 0UL) {
#line 1368
    rtw_cfg80211_set_probe_req_wpsp2pie(padapter, (char *)request->ie, (int )request->ie_len);
  } else {

  }
#line 1373
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
#line 1374
    if (GlobalDebugLevel23A > 3U) {
#line 1374
      printk("\016RTL8723AU: %s, bBusyTraffic == true\n", "cfg80211_rtw_scan");
    } else {

    }
#line 1375
    need_indicate_scan_done = 1;
#line 1376
    goto check_need_indicate_scan_done;
  } else {

  }
#line 1378
  tmp___3 = rtw_is_scan_deny(padapter);
#line 1378
  if ((int )tmp___3) {
#line 1379
    if (GlobalDebugLevel23A > 3U) {
#line 1379
      printk("\016RTL8723AU: %s(%s): scan deny\n", "cfg80211_rtw_scan", (char *)(& (padapter->pnetdev)->name));
    } else {

    }
#line 1381
    need_indicate_scan_done = 1;
#line 1382
    goto check_need_indicate_scan_done;
  } else {

  }
#line 1385
  tmp___4 = check_fwstate(pmlmepriv, 2176);
#line 1385
  if ((int )tmp___4) {
#line 1387
    if (GlobalDebugLevel23A > 3U) {
#line 1387
      printk("\016RTL8723AU: %s, fwstate = 0x%x\n", "cfg80211_rtw_scan", pmlmepriv->fw_state);
    } else {

    }
#line 1388
    need_indicate_scan_done = 1;
#line 1389
    goto check_need_indicate_scan_done;
  } else {

  }
#line 1392
  memset((void *)(& ssid), 0, 297UL);
#line 1394
  i = 0;
#line 1394
  goto ldv_53463;
  ldv_53462: ;
#line 1395
  if (GlobalDebugLevel23A > 3U) {
#line 1395
    printk("\016RTL8723AU: ssid =%s, len =%d\n", (u8 *)(& (ssids + (unsigned long )i)->ssid),
           (int )(ssids + (unsigned long )i)->ssid_len);
  } else {

  }
#line 1397
  memcpy((void *)(& ssid[i].ssid), (void const   *)(& (ssids + (unsigned long )i)->ssid),
           (size_t )(ssids + (unsigned long )i)->ssid_len);
#line 1398
  ssid[i].ssid_len = (ssids + (unsigned long )i)->ssid_len;
#line 1394
  i = i + 1;
  ldv_53463: ;
#line 1394
  if (request->n_ssids > i && i <= 8) {
#line 1396
    goto ldv_53462;
  } else {

  }
#line 1402
  memset((void *)(& ch), 0, 408UL);
#line 1405
  if (request->n_channels == 1U) {
#line 1406
    i = 0;
#line 1406
    goto ldv_53466;
    ldv_53465: ;
#line 1408
    if (GlobalDebugLevel23A > 3U) {
#line 1408
      printk("\016RTL8723AU: %s:(%s):hw_value:%u, flags:0x%08x\n", "cfg80211_rtw_scan",
             (char *)(& (padapter->pnetdev)->name), (int )(request->channels[i])->hw_value,
             (request->channels[i])->flags);
    } else {

    }
#line 1411
    ch[i].hw_value = (request->channels[i])->hw_value;
#line 1412
    ch[i].flags = (request->channels[i])->flags;
#line 1407
    i = i + 1;
    ldv_53466: ;
#line 1406
    if ((u32 )i < request->n_channels && i <= 50) {
#line 1409
      goto ldv_53465;
    } else {

    }

  } else {

  }
#line 1416
  spin_lock_bh(& pmlmepriv->lock);
#line 1417
  if (request->n_channels == 1U) {
#line 1418
    memcpy((void *)(& ch) + 1U, (void const   *)(& ch), 8UL);
#line 1419
    memcpy((void *)(& ch) + 2U, (void const   *)(& ch), 8UL);
#line 1420
    tmp___5 = rtw_sitesurvey_cmd23a(padapter, (struct cfg80211_ssid *)(& ssid), 9,
                                    (struct rtw_ieee80211_channel *)(& ch), 3);
#line 1420
    _status = (u8 )tmp___5;
  } else {
#line 1423
    tmp___6 = rtw_sitesurvey_cmd23a(padapter, (struct cfg80211_ssid *)(& ssid), 9,
                                    (struct rtw_ieee80211_channel *)0, 0);
#line 1423
    _status = (u8 )tmp___6;
  }
#line 1426
  spin_unlock_bh(& pmlmepriv->lock);
#line 1428
  if ((unsigned int )_status == 0U) {
#line 1429
    ret = -1;
  } else {

  }
  check_need_indicate_scan_done: ;
#line 1432
  if ((int )need_indicate_scan_done) {
#line 1433
    rtw_cfg80211_surveydone_event_callback(padapter);
  } else {

  }
#line 1434
  return (ret);
}
}
#line 1437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_set_wiphy_params(struct wiphy *wiphy , u32 changed ) 
{ 


  {
#line 1439
  if (GlobalDebugLevel23A > 3U) {
#line 1439
    printk("\016RTL8723AU: %s\n", "cfg80211_rtw_set_wiphy_params");
  } else {

  }
#line 1440
  return (0);
}
}
#line 1443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_join_ibss(struct wiphy *wiphy , struct net_device *ndev ,
                                  struct cfg80211_ibss_params *params ) 
{ 


  {
#line 1446
  if (GlobalDebugLevel23A > 3U) {
#line 1446
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_join_ibss", (char *)(& ndev->name));
  } else {

  }
#line 1447
  return (0);
}
}
#line 1450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_leave_ibss(struct wiphy *wiphy , struct net_device *ndev ) 
{ 


  {
#line 1452
  if (GlobalDebugLevel23A > 3U) {
#line 1452
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_leave_ibss", (char *)(& ndev->name));
  } else {

  }
#line 1453
  return (0);
}
}
#line 1456 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_set_wpa_version(struct security_priv *psecuritypriv , u32 wpa_version ) 
{ 


  {
#line 1459
  if (GlobalDebugLevel23A > 3U) {
#line 1459
    printk("\016RTL8723AU: %s, wpa_version =%d\n", "rtw_cfg80211_set_wpa_version",
           wpa_version);
  } else {

  }
#line 1461
  if (wpa_version == 0U) {
#line 1462
    psecuritypriv->ndisauthtype = 0U;
#line 1463
    return (0);
  } else {

  }
#line 1466
  if ((wpa_version & 3U) != 0U) {
#line 1467
    psecuritypriv->ndisauthtype = 4U;
  } else {

  }
#line 1476
  return (0);
}
}
#line 1479 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_set_auth_type(struct security_priv *psecuritypriv , enum nl80211_auth_type sme_auth_type ) 
{ 


  {
#line 1482
  if (GlobalDebugLevel23A > 3U) {
#line 1482
    printk("\016RTL8723AU: %s, nl80211_auth_type =%d\n", "rtw_cfg80211_set_auth_type",
           (unsigned int )sme_auth_type);
  } else {

  }
#line 1484
  switch ((unsigned int )sme_auth_type) {
  case 5U: 
#line 1486
  psecuritypriv->dot11AuthAlgrthm = 3U;
#line 1488
  goto ldv_53495;
  case 0U: 
#line 1490
  psecuritypriv->dot11AuthAlgrthm = 0U;
#line 1492
  if (psecuritypriv->ndisauthtype > 3U) {
#line 1493
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else {

  }
#line 1495
  goto ldv_53495;
  case 1U: 
#line 1497
  psecuritypriv->dot11AuthAlgrthm = 1U;
#line 1499
  psecuritypriv->ndisencryptstatus = 0U;
#line 1500
  goto ldv_53495;
  default: 
#line 1502
  psecuritypriv->dot11AuthAlgrthm = 0U;
  }
  ldv_53495: ;
#line 1506
  return (0);
}
}
#line 1509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_set_cipher(struct security_priv *psecuritypriv , u32 cipher ,
                                   bool ucast ) 
{ 
  u32 ndisencryptstatus ;
  u32 *profile_cipher ;

  {
#line 1512
  ndisencryptstatus = 1U;
#line 1514
  profile_cipher = (int )ucast ? & psecuritypriv->dot11PrivacyAlgrthm : & psecuritypriv->dot118021XGrpPrivacy;
#line 1517
  if (GlobalDebugLevel23A > 3U) {
#line 1517
    printk("\016RTL8723AU: %s, ucast =%d, cipher = 0x%x\n", "rtw_cfg80211_set_cipher",
           (int )ucast, cipher);
  } else {

  }
#line 1519
  if (cipher == 0U) {
#line 1520
    *profile_cipher = 0U;
#line 1521
    psecuritypriv->ndisencryptstatus = ndisencryptstatus;
#line 1522
    return (0);
  } else {

  }
#line 1525
  switch (cipher) {
  case 1U: 
#line 1527
  *profile_cipher = 0U;
#line 1528
  ndisencryptstatus = 1U;
#line 1529
  goto ldv_53508;
  case 1027073U: 
#line 1531
  *profile_cipher = 1027073U;
#line 1532
  ndisencryptstatus = 0U;
#line 1533
  goto ldv_53508;
  case 1027077U: 
#line 1535
  *profile_cipher = 1027077U;
#line 1536
  ndisencryptstatus = 0U;
#line 1537
  goto ldv_53508;
  case 1027074U: 
#line 1539
  *profile_cipher = 1027074U;
#line 1540
  ndisencryptstatus = 4U;
#line 1541
  goto ldv_53508;
  case 1027076U: 
#line 1543
  *profile_cipher = 1027076U;
#line 1544
  ndisencryptstatus = 6U;
#line 1545
  goto ldv_53508;
  default: ;
#line 1547
  if (GlobalDebugLevel23A > 3U) {
#line 1547
    printk("\016RTL8723AU: Unsupported cipher: 0x%x\n", cipher);
  } else {

  }
#line 1548
  return (-524);
  }
  ldv_53508: ;
#line 1551
  if ((int )ucast) {
#line 1552
    psecuritypriv->ndisencryptstatus = ndisencryptstatus;
  } else {

  }
#line 1554
  return (0);
}
}
#line 1557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_set_key_mgt(struct security_priv *psecuritypriv , u32 key_mgt ) 
{ 


  {
#line 1560
  if (GlobalDebugLevel23A > 3U) {
#line 1560
    printk("\016RTL8723AU: %s, key_mgt = 0x%x\n", "rtw_cfg80211_set_key_mgt", key_mgt);
  } else {

  }
#line 1562
  if (key_mgt == 1027073U) {
#line 1563
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else
#line 1564
  if (key_mgt == 1027074U) {
#line 1565
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else
#line 1567
  if (GlobalDebugLevel23A > 3U) {
#line 1567
    printk("\016RTL8723AU: Invalid key mgt: 0x%x\n", key_mgt);
  } else {

  }
#line 1569
  return (0);
}
}
#line 1572 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_set_wpa_ie(struct rtw_adapter *padapter , u8 const   *pie ,
                                   size_t ielen ) 
{ 
  u8 const   *wps_ie ;
  int group_cipher ;
  int pairwise_cipher ;
  int ret ;
  u8 const   *pwpa ;
  u8 const   *pwpa2 ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 1576
  group_cipher = 0;
#line 1576
  pairwise_cipher = 0;
#line 1577
  ret = 0;
#line 1581
  if ((unsigned long )pie == (unsigned long )((u8 const   *)0U) || ielen == 0UL) {
#line 1584
    _clr_fwstate_(& padapter->mlmepriv, 256);
#line 1585
    goto exit;
  } else {

  }
#line 1587
  if (ielen > 768UL) {
#line 1588
    ret = -22;
#line 1589
    goto exit;
  } else {

  }
#line 1593
  if (GlobalDebugLevel23A > 3U) {
#line 1593
    printk("\016RTL8723AU: set wpa_ie(length:%zu):\n", ielen);
  } else {

  }
#line 1594
  i = 0;
#line 1594
  goto ldv_53533;
  ldv_53532: ;
#line 1595
  if (GlobalDebugLevel23A > 3U) {
#line 1595
    printk("\016RTL8723AU: 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n",
           (int )*(pie + (unsigned long )i), (int )*(pie + ((unsigned long )i + 1UL)),
           (int )*(pie + ((unsigned long )i + 2UL)), (int )*(pie + ((unsigned long )i + 3UL)),
           (int )*(pie + ((unsigned long )i + 4UL)), (int )*(pie + ((unsigned long )i + 5UL)),
           (int )*(pie + ((unsigned long )i + 6UL)), (int )*(pie + ((unsigned long )i + 7UL)));
  } else {

  }
#line 1594
  i = i + 8;
  ldv_53533: ;
#line 1594
  if ((size_t )i < ielen) {
#line 1596
    goto ldv_53532;
  } else {

  }

#line 1599
  if (ielen <= 3UL) {
#line 1600
    if (GlobalDebugLevel23A > 3U) {
#line 1600
      rt_trace(33554432, 4, "Ie len too short %d\n", (int )ielen);
    } else {

    }
#line 1602
    ret = -1;
#line 1603
    goto exit;
  } else {

  }
#line 1606
  pwpa = cfg80211_find_vendor_ie(20722U, 1, pie, (int )ielen);
#line 1609
  if ((unsigned long )pwpa != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(pwpa + 1UL)) != 0U) {
#line 1610
    tmp = rtw_parse_wpa_ie23a(pwpa, (int )*(pwpa + 1UL) + 2, & group_cipher, & pairwise_cipher,
                              (int *)0);
#line 1610
    if (tmp == 1) {
#line 1612
      padapter->securitypriv.dot11AuthAlgrthm = 2U;
#line 1614
      padapter->securitypriv.ndisauthtype = 4U;
#line 1616
      memcpy((void *)(& padapter->securitypriv.supplicant_ie), (void const   *)pwpa,
               (size_t )((int )*(pwpa + 1UL) + 2));
#line 1619
      if (GlobalDebugLevel23A > 3U) {
#line 1619
        printk("\016RTL8723AU: got wpa_ie, wpa_ielen:%u\n", (int )*(pwpa + 1UL));
      } else {

      }
    } else {

    }
  } else {

  }
#line 1623
  pwpa2 = cfg80211_find_ie(48, pie, (int )ielen);
#line 1624
  if ((unsigned long )pwpa2 != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(pwpa2 + 1UL)) != 0U) {
#line 1625
    tmp___0 = rtw_parse_wpa2_ie23a(pwpa2, (int )*(pwpa2 + 1UL) + 2, & group_cipher,
                                   & pairwise_cipher, (int *)0);
#line 1625
    if (tmp___0 == 1) {
#line 1627
      padapter->securitypriv.dot11AuthAlgrthm = 2U;
#line 1629
      padapter->securitypriv.ndisauthtype = 7U;
#line 1631
      memcpy((void *)(& padapter->securitypriv.supplicant_ie), (void const   *)pwpa2,
               (size_t )((int )*(pwpa2 + 1UL) + 2));
#line 1634
      if (GlobalDebugLevel23A > 3U) {
#line 1634
        printk("\016RTL8723AU: got wpa2_ie, wpa2_ielen:%u\n", (int )*(pwpa2 + 1UL));
      } else {

      }
    } else {

    }
  } else {

  }
#line 1638
  if (group_cipher == 0) {
#line 1639
    group_cipher = 1;
  } else {

  }
#line 1641
  if (pairwise_cipher == 0) {
#line 1642
    pairwise_cipher = 1;
  } else {

  }
#line 1645
  switch (group_cipher) {
  case 1: 
#line 1647
  padapter->securitypriv.dot118021XGrpPrivacy = 0U;
#line 1648
  padapter->securitypriv.ndisencryptstatus = 1U;
#line 1650
  goto ldv_53536;
  case 2: 
#line 1652
  padapter->securitypriv.dot118021XGrpPrivacy = 1027073U;
#line 1653
  padapter->securitypriv.ndisencryptstatus = 0U;
#line 1655
  goto ldv_53536;
  case 8: 
#line 1657
  padapter->securitypriv.dot118021XGrpPrivacy = 1027074U;
#line 1658
  padapter->securitypriv.ndisencryptstatus = 4U;
#line 1660
  goto ldv_53536;
  case 16: 
#line 1662
  padapter->securitypriv.dot118021XGrpPrivacy = 1027076U;
#line 1663
  padapter->securitypriv.ndisencryptstatus = 6U;
#line 1665
  goto ldv_53536;
  case 4: 
#line 1667
  padapter->securitypriv.dot118021XGrpPrivacy = 1027077U;
#line 1668
  padapter->securitypriv.ndisencryptstatus = 0U;
#line 1670
  goto ldv_53536;
  }
  ldv_53536: ;
#line 1673
  switch (pairwise_cipher) {
  case 1: 
#line 1675
  padapter->securitypriv.dot11PrivacyAlgrthm = 0U;
#line 1676
  padapter->securitypriv.ndisencryptstatus = 1U;
#line 1678
  goto ldv_53542;
  case 2: 
#line 1680
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027073U;
#line 1681
  padapter->securitypriv.ndisencryptstatus = 0U;
#line 1683
  goto ldv_53542;
  case 8: 
#line 1685
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027074U;
#line 1686
  padapter->securitypriv.ndisencryptstatus = 4U;
#line 1688
  goto ldv_53542;
  case 16: 
#line 1690
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027076U;
#line 1691
  padapter->securitypriv.ndisencryptstatus = 6U;
#line 1693
  goto ldv_53542;
  case 4: 
#line 1695
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027077U;
#line 1696
  padapter->securitypriv.ndisencryptstatus = 0U;
#line 1698
  goto ldv_53542;
  }
  ldv_53542: 
#line 1701
  wps_ie = cfg80211_find_vendor_ie(20722U, 4, pie, (int )ielen);
#line 1704
  if ((unsigned long )wps_ie != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(wps_ie + 1UL)) != 0U) {
#line 1705
    if (GlobalDebugLevel23A > 3U) {
#line 1705
      printk("\016RTL8723AU: got wps_ie, wps_ielen:%u\n", (int )*(wps_ie + 1UL));
    } else {

    }
#line 1706
    padapter->securitypriv.wps_ie_len = (int )*(wps_ie + 1UL);
#line 1707
    memcpy((void *)(& padapter->securitypriv.wps_ie), (void const   *)wps_ie, (size_t )padapter->securitypriv.wps_ie_len);
#line 1709
    set_fwstate(& padapter->mlmepriv, 256);
  } else {
#line 1711
    _clr_fwstate_(& padapter->mlmepriv, 256);
  }
#line 1715
  if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027074U || padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
#line 1721
    rtl8723a_off_rcr_am(padapter);
  } else {

  }
#line 1723
  if (GlobalDebugLevel23A > 6U) {
#line 1723
    rt_trace(33554432, 7, "rtw_set_wpa_ie: pairwise_cipher = 0x%08x padapter->securitypriv.ndisencryptstatus =%d padapter->securitypriv.ndisauthtype =%d\n",
             pairwise_cipher, padapter->securitypriv.ndisencryptstatus, padapter->securitypriv.ndisauthtype);
  } else {

  }
  exit: ;
#line 1730
  if (ret != 0) {
#line 1731
    _clr_fwstate_(& padapter->mlmepriv, 256);
  } else {

  }
#line 1732
  return (ret);
}
}
#line 1735 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_add_wep(struct rtw_adapter *padapter , struct rtw_wep_key *wep ,
                                u8 keyid ) 
{ 
  int res ;
  struct security_priv *psecuritypriv ;

  {
#line 1739
  psecuritypriv = & padapter->securitypriv;
#line 1741
  if ((unsigned int )keyid > 3U) {
#line 1742
    if (GlobalDebugLevel23A > 3U) {
#line 1742
      rt_trace(131072, 4, "%s:keyid>4 =>fail\n", "rtw_cfg80211_add_wep");
    } else {

    }
#line 1744
    res = 0;
#line 1745
    goto exit;
  } else {

  }
#line 1748
  switch ((int )wep->keylen) {
  case 5: 
#line 1750
  psecuritypriv->dot11PrivacyAlgrthm = 1027073U;
#line 1751
  if (GlobalDebugLevel23A > 6U) {
#line 1751
    rt_trace(131072, 7, "%s:wep->KeyLength = 5\n", "rtw_cfg80211_add_wep");
  } else {

  }
#line 1753
  goto ldv_53557;
  case 13: 
#line 1755
  psecuritypriv->dot11PrivacyAlgrthm = 1027077U;
#line 1756
  if (GlobalDebugLevel23A > 6U) {
#line 1756
    rt_trace(131072, 7, "%s:wep->KeyLength = 13\n", "rtw_cfg80211_add_wep");
  } else {

  }
#line 1758
  goto ldv_53557;
  default: 
#line 1760
  psecuritypriv->dot11PrivacyAlgrthm = 0U;
#line 1761
  if (GlobalDebugLevel23A > 6U) {
#line 1761
    rt_trace(131072, 7, "%s:wep->KeyLength!= 5 or 13\n", "rtw_cfg80211_add_wep");
  } else {

  }
#line 1763
  res = 0;
#line 1764
  goto exit;
  }
  ldv_53557: ;
#line 1767
  if (GlobalDebugLevel23A > 6U) {
#line 1767
    rt_trace(131072, 7, "%s:before memcpy, wep->KeyLength = 0x%x keyid =%x\n", "rtw_cfg80211_add_wep",
             (int )wep->keylen, (int )keyid);
  } else {

  }
#line 1771
  memcpy((void *)(& psecuritypriv->wep_key) + (unsigned long )keyid, (void const   *)wep,
           16UL);
#line 1773
  psecuritypriv->dot11PrivacyKeyIndex = (u32 )keyid;
#line 1775
  if (GlobalDebugLevel23A > 6U) {
#line 1775
    rt_trace(131072, 7, "%s:security key material : %x %x %x %x %x %x %x %x %x %x %x %x %x\n",
             "rtw_cfg80211_add_wep", (int )psecuritypriv->wep_key[(int )keyid].key[0],
             (int )psecuritypriv->wep_key[(int )keyid].key[1], (int )psecuritypriv->wep_key[(int )keyid].key[2],
             (int )psecuritypriv->wep_key[(int )keyid].key[3], (int )psecuritypriv->wep_key[(int )keyid].key[4],
             (int )psecuritypriv->wep_key[(int )keyid].key[5], (int )psecuritypriv->wep_key[(int )keyid].key[6],
             (int )psecuritypriv->wep_key[(int )keyid].key[7], (int )psecuritypriv->wep_key[(int )keyid].key[8],
             (int )psecuritypriv->wep_key[(int )keyid].key[9], (int )psecuritypriv->wep_key[(int )keyid].key[10],
             (int )psecuritypriv->wep_key[(int )keyid].key[11], (int )psecuritypriv->wep_key[(int )keyid].key[12]);
  } else {

  }
#line 1792
  res = rtw_set_key23a(padapter, psecuritypriv, (int )keyid, 1);
  exit: ;
#line 1796
  return (res);
}
}
#line 1799 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_set_ssid(struct rtw_adapter *padapter , struct wlan_network *newnetwork ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  int status ;
  u32 cur_time ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;

  {
#line 1802
  pmlmepriv = & padapter->mlmepriv;
#line 1803
  pnetwork = & pmlmepriv->cur_network;
#line 1804
  status = 1;
#line 1805
  cur_time = 0U;
#line 1807
  if (GlobalDebugLevel23A != 0U) {
#line 1807
    tmp = get_fwstate(pmlmepriv);
#line 1807
    printk("\016RTL8723AU: set ssid [%s] fw_state = 0x%08x\n", (u8 *)(& newnetwork->network.Ssid.ssid),
           tmp);
  } else {

  }
#line 1810
  if ((unsigned int )padapter->hw_init_completed == 0U) {
#line 1811
    if (GlobalDebugLevel23A > 3U) {
#line 1811
      rt_trace(131072, 4, "set_ssid: hw_init_completed == false =>exit!!!\n");
    } else {

    }
#line 1813
    status = 0;
#line 1814
    goto exit;
  } else {

  }
#line 1817
  spin_lock_bh(& pmlmepriv->lock);
#line 1819
  if (GlobalDebugLevel23A > 3U) {
#line 1819
    tmp___0 = get_fwstate(pmlmepriv);
#line 1819
    printk("\016RTL8723AU: Set SSID under fw_state = 0x%08x\n", tmp___0);
  } else {

  }
#line 1820
  tmp___1 = check_fwstate(pmlmepriv, 2048);
#line 1820
  if ((int )tmp___1) {
#line 1821
    goto handle_tkip_countermeasure;
  } else {

  }
#line 1823
  tmp___11 = check_fwstate(pmlmepriv, 65);
#line 1823
  if ((int )tmp___11) {
#line 1824
    if (GlobalDebugLevel23A > 6U) {
#line 1824
      rt_trace(131072, 7, "set_ssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n");
    } else {

    }
#line 1827
    if ((int )pmlmepriv->assoc_ssid.ssid_len == (int )newnetwork->network.Ssid.ssid_len) {
#line 1827
      tmp___10 = memcmp((void const   *)(& pmlmepriv->assoc_ssid.ssid), (void const   *)(& newnetwork->network.Ssid.ssid),
                        (size_t )newnetwork->network.Ssid.ssid_len);
#line 1827
      if (tmp___10 == 0) {
#line 1832
        tmp___6 = check_fwstate(pmlmepriv, 8);
#line 1832
        if (tmp___6) {
#line 1832
          tmp___7 = 0;
        } else {
#line 1832
          tmp___7 = 1;
        }
#line 1832
        if (tmp___7) {
#line 1833
          if (GlobalDebugLevel23A > 3U) {
#line 1833
            tmp___2 = get_fwstate(pmlmepriv);
#line 1833
            rt_trace(131072, 4, "New SSID is same SSID, fw_state = 0x%08x\n", tmp___2);
          } else {

          }
#line 1838
          tmp___3 = rtw_is_same_ibss23a(padapter, pnetwork);
#line 1838
          if ((int )tmp___3) {
#line 1844
            goto release_mlme_lock;
          } else {

          }
#line 1852
          rtw_disassoc_cmd23a(padapter, 0U, 1);
#line 1854
          tmp___4 = check_fwstate(pmlmepriv, 1);
#line 1854
          if ((int )tmp___4) {
#line 1855
            rtw_indicate_disconnect23a(padapter);
          } else {

          }
#line 1857
          rtw_free_assoc_resources23a(padapter, 1);
#line 1859
          tmp___5 = check_fwstate(pmlmepriv, 64);
#line 1859
          if ((int )tmp___5) {
#line 1861
            _clr_fwstate_(pmlmepriv, 64);
#line 1863
            set_fwstate(pmlmepriv, 32);
          } else {

          }
        } else {
#line 1867
          rtw_lps_ctrl_wk_cmd23a(padapter, 1, 1);
        }
      } else {
#line 1827
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1871
      if (GlobalDebugLevel23A > 6U) {
#line 1871
        rt_trace(131072, 7, "Set SSID not the same ssid\n");
      } else {

      }
#line 1873
      if (GlobalDebugLevel23A > 6U) {
#line 1873
        rt_trace(131072, 7, "set_ssid =[%s] len = 0x%x\n", (u8 *)(& newnetwork->network.Ssid.ssid),
                 (int )newnetwork->network.Ssid.ssid_len);
      } else {

      }
#line 1877
      if (GlobalDebugLevel23A > 6U) {
#line 1877
        rt_trace(131072, 7, "assoc_ssid =[%s] len = 0x%x\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid),
                 (int )pmlmepriv->assoc_ssid.ssid_len);
      } else {

      }
#line 1882
      rtw_disassoc_cmd23a(padapter, 0U, 1);
#line 1884
      tmp___8 = check_fwstate(pmlmepriv, 1);
#line 1884
      if ((int )tmp___8) {
#line 1885
        rtw_indicate_disconnect23a(padapter);
      } else {

      }
#line 1887
      rtw_free_assoc_resources23a(padapter, 1);
#line 1889
      tmp___9 = check_fwstate(pmlmepriv, 64);
#line 1889
      if ((int )tmp___9) {
#line 1890
        _clr_fwstate_(pmlmepriv, 64);
#line 1891
        set_fwstate(pmlmepriv, 32);
      } else {

      }
    }
  } else {

  }
  handle_tkip_countermeasure: ;
#line 1898
  if ((unsigned int )padapter->securitypriv.btkip_countermeasure == 1U) {
#line 1899
    cur_time = (u32 )jiffies;
#line 1901
    if ((unsigned long )cur_time - padapter->securitypriv.btkip_countermeasure_time > 15000UL) {
#line 1904
      padapter->securitypriv.btkip_countermeasure = 0U;
#line 1905
      padapter->securitypriv.btkip_countermeasure_time = 0UL;
    } else {
#line 1907
      status = 0;
#line 1908
      goto release_mlme_lock;
    }
  } else {

  }
#line 1912
  memcpy((void *)(& pmlmepriv->assoc_ssid), (void const   *)(& newnetwork->network.Ssid),
           33UL);
#line 1915
  pmlmepriv->assoc_by_bssid = 0U;
#line 1917
  pmlmepriv->to_join = 1U;
#line 1919
  tmp___13 = check_fwstate(pmlmepriv, 2048);
#line 1919
  if (tmp___13) {
#line 1919
    tmp___14 = 0;
  } else {
#line 1919
    tmp___14 = 1;
  }
#line 1919
  if (tmp___14) {
#line 1920
    pmlmepriv->cur_network.join_res = -2;
#line 1922
    status = rtw_do_join_network(padapter, newnetwork);
#line 1923
    if (status == 1) {
#line 1924
      pmlmepriv->to_join = 0U;
    } else {
#line 1926
      tmp___12 = check_fwstate(pmlmepriv, 32);
#line 1926
      if ((int )tmp___12) {
#line 1928
        status = rtw_do_join_adhoc(padapter);
#line 1929
        if (status != 1) {
#line 1930
          goto release_mlme_lock;
        } else {

        }
      } else {
#line 1933
        _clr_fwstate_(pmlmepriv, 128);
#line 1934
        status = 0;
#line 1935
        pmlmepriv->to_join = 0U;
      }
    }
  } else {

  }
  release_mlme_lock: 
#line 1940
  spin_unlock_bh(& pmlmepriv->lock);
  exit: ;
#line 1943
  if (GlobalDebugLevel23A > 3U) {
#line 1943
    rt_trace(131072, 4, "-%s: status =%d\n", "rtw_set_ssid", status);
  } else {

  }
#line 1946
  return (status);
}
}
#line 1949 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_connect(struct wiphy *wiphy , struct net_device *ndev , struct cfg80211_connect_params *sme ) 
{ 
  int ret ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct wlan_network *pnetwork ;
  u8 matched ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct rtw_queue *queue ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  struct list_head  const  *__mptr ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct rtw_wep_key wep_key ;
  u8 wep_key_idx ;
  u8 wep_key_len ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 1952
  ret = 0;
#line 1954
  pnetwork = (struct wlan_network *)0;
#line 1957
  matched = 0U;
#line 1958
  tmp = wiphy_priv___1(wiphy);
#line 1958
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 1959
  pmlmepriv = & padapter->mlmepriv;
#line 1960
  psecuritypriv = & padapter->securitypriv;
#line 1961
  queue = & pmlmepriv->scanned_queue;
#line 1963
  if (GlobalDebugLevel23A > 3U) {
#line 1963
    printk("\016RTL8723AU: =>%s(%s)\n", "cfg80211_rtw_connect", (char *)(& ndev->name));
  } else {

  }
#line 1964
  if (GlobalDebugLevel23A > 3U) {
#line 1964
    printk("\016RTL8723AU: privacy =%d, key =%p, key_len =%d, key_idx =%d\n", (int )sme->privacy,
           sme->key, (int )sme->key_len, (int )sme->key_idx);
  } else {

  }
#line 1967
  tmp___0 = _rtw_pwr_wakeup23a(padapter, 2000U, "cfg80211_rtw_connect");
#line 1967
  if (tmp___0 == 0) {
#line 1968
    ret = -1;
#line 1969
    goto exit;
  } else {

  }
#line 1972
  tmp___1 = check_fwstate(pmlmepriv, 16);
#line 1972
  if ((int )tmp___1) {
#line 1973
    ret = -1;
#line 1974
    goto exit;
  } else {

  }
#line 1977
  if (((unsigned long )sme->ssid == (unsigned long )((u8 const   *)0U) || sme->ssid_len == 0UL) || sme->ssid_len > 32UL) {
#line 1979
    ret = -22;
#line 1980
    goto exit;
  } else {

  }
#line 1983
  if (GlobalDebugLevel23A > 3U) {
#line 1983
    printk("\016RTL8723AU: ssid =%s, len =%zu\n", sme->ssid, sme->ssid_len);
  } else {

  }
#line 1985
  if ((unsigned long )sme->bssid != (unsigned long )((u8 const   *)0U)) {
#line 1986
    if (GlobalDebugLevel23A > 3U) {
#line 1986
      printk("\016RTL8723AU: bssid=%pM\n", sme->bssid);
    } else {

    }
  } else {

  }
#line 1988
  tmp___2 = check_fwstate(pmlmepriv, 128);
#line 1988
  if ((int )tmp___2) {
#line 1989
    ret = -16;
#line 1990
    if (GlobalDebugLevel23A > 3U) {
#line 1990
      printk("\016RTL8723AU: %s, fw_state = 0x%x, goto exit\n", "cfg80211_rtw_connect",
             pmlmepriv->fw_state);
    } else {

    }
#line 1992
    goto exit;
  } else {

  }
#line 1994
  tmp___3 = check_fwstate(pmlmepriv, 2048);
#line 1994
  if ((int )tmp___3) {
#line 1995
    rtw_scan_abort23a(padapter);
  } else {

  }
#line 1998
  spin_lock_bh(& queue->lock);
#line 2000
  phead = get_list_head(queue);
#line 2002
  plist = phead->next;
#line 2002
  ptmp = plist->next;
#line 2002
  goto ldv_53594;
  ldv_53593: 
#line 2003
  __mptr = (struct list_head  const  *)plist;
#line 2003
  pnetwork = (struct wlan_network *)__mptr;
#line 2005
  if ((unsigned long )sme->bssid != (unsigned long )((u8 const   *)0U)) {
#line 2006
    tmp___4 = ether_addr_equal((u8 const   *)(& pnetwork->network.MacAddress), sme->bssid);
#line 2006
    if (tmp___4) {
#line 2006
      tmp___5 = 0;
    } else {
#line 2006
      tmp___5 = 1;
    }
#line 2006
    if (tmp___5) {
#line 2008
      goto ldv_53591;
    } else {

    }
  } else {

  }
#line 2011
  if ((unsigned long )sme->ssid != (unsigned long )((u8 const   *)0U) && sme->ssid_len != 0UL) {
#line 2012
    if ((size_t )pnetwork->network.Ssid.ssid_len != sme->ssid_len) {
#line 2015
      goto ldv_53591;
    } else {
#line 2012
      tmp___6 = memcmp((void const   *)(& pnetwork->network.Ssid.ssid), (void const   *)sme->ssid,
                       sme->ssid_len);
#line 2012
      if (tmp___6 != 0) {
#line 2015
        goto ldv_53591;
      } else {

      }
    }
  } else {

  }
#line 2018
  if ((unsigned long )sme->bssid != (unsigned long )((u8 const   *)0U)) {
#line 2019
    tmp___7 = ether_addr_equal((u8 const   *)(& pnetwork->network.MacAddress), sme->bssid);
#line 2019
    if ((int )tmp___7) {
#line 2021
      if (GlobalDebugLevel23A > 3U) {
#line 2021
        printk("\016RTL8723AU: matched by bssid\n");
      } else {

      }
#line 2023
      matched = 1U;
#line 2024
      goto ldv_53592;
    } else {

    }
  } else
#line 2026
  if ((unsigned long )sme->ssid != (unsigned long )((u8 const   *)0U) && sme->ssid_len != 0UL) {
#line 2027
    tmp___8 = memcmp((void const   *)(& pnetwork->network.Ssid.ssid), (void const   *)sme->ssid,
                     sme->ssid_len);
#line 2027
    if (tmp___8 == 0 && (size_t )pnetwork->network.Ssid.ssid_len == sme->ssid_len) {
#line 2030
      if (GlobalDebugLevel23A > 3U) {
#line 2030
        printk("\016RTL8723AU: matched by ssid\n");
      } else {

      }
#line 2032
      matched = 1U;
#line 2033
      goto ldv_53592;
    } else {

    }
  } else {

  }
  ldv_53591: 
#line 2002
  plist = ptmp;
#line 2002
  ptmp = plist->next;
  ldv_53594: ;
#line 2002
  if ((unsigned long )plist != (unsigned long )phead) {
#line 2004
    goto ldv_53593;
  } else {

  }
  ldv_53592: 
#line 2038
  spin_unlock_bh(& queue->lock);
#line 2040
  if ((unsigned int )matched == 0U || (unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
#line 2041
    ret = -2;
#line 2042
    if (GlobalDebugLevel23A > 3U) {
#line 2042
      printk("\016RTL8723AU: connect, matched == false, goto exit\n");
    } else {

    }
#line 2043
    goto exit;
  } else {

  }
#line 2046
  tmp___9 = cfg80211_infrastructure_mode(padapter, pnetwork->network.ifmode);
#line 2046
  if (tmp___9 != 1) {
#line 2048
    ret = -1;
#line 2049
    goto exit;
  } else {

  }
#line 2052
  psecuritypriv->ndisencryptstatus = 1U;
#line 2053
  psecuritypriv->dot11PrivacyAlgrthm = 0U;
#line 2054
  psecuritypriv->dot118021XGrpPrivacy = 0U;
#line 2055
  psecuritypriv->dot11AuthAlgrthm = 0U;
#line 2056
  psecuritypriv->ndisauthtype = 0U;
#line 2058
  ret = rtw_cfg80211_set_wpa_version(psecuritypriv, sme->crypto.wpa_versions);
#line 2060
  if (ret < 0) {
#line 2061
    goto exit;
  } else {

  }
#line 2063
  ret = rtw_cfg80211_set_auth_type(psecuritypriv, sme->auth_type);
#line 2065
  if (ret < 0) {
#line 2066
    goto exit;
  } else {

  }
#line 2068
  if (GlobalDebugLevel23A > 3U) {
#line 2068
    printk("\016RTL8723AU: %s, ie_len =%zu\n", "cfg80211_rtw_connect", sme->ie_len);
  } else {

  }
#line 2070
  ret = rtw_cfg80211_set_wpa_ie(padapter, sme->ie, sme->ie_len);
#line 2071
  if (ret < 0) {
#line 2072
    goto exit;
  } else {

  }
#line 2074
  if (sme->crypto.n_ciphers_pairwise != 0) {
#line 2075
    ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.ciphers_pairwise[0],
                                  1);
#line 2078
    if (ret < 0) {
#line 2079
      goto exit;
    } else {

    }
  } else {

  }
#line 2083
  if ((psecuritypriv->dot11AuthAlgrthm == 1U || psecuritypriv->dot11AuthAlgrthm == 3U) && (unsigned long )sme->key != (unsigned long )((u8 const   *)0U)) {
#line 2088
    if (GlobalDebugLevel23A > 3U) {
#line 2088
      printk("\016RTL8723AU: %s(): Shared/Auto WEP\n", "cfg80211_rtw_connect");
    } else {

    }
#line 2090
    wep_key_idx = sme->key_idx;
#line 2091
    wep_key_len = sme->key_len;
#line 2093
    if (((unsigned int )wep_key_idx > 4U || (unsigned int )wep_key_len == 0U) || (unsigned int )wep_key_len > 13U) {
#line 2095
      ret = -22;
#line 2096
      goto exit;
    } else {

    }
#line 2099
    wep_key_len = (unsigned int )wep_key_len <= 5U ? 5U : 13U;
#line 2101
    memset((void *)(& wep_key), 0, 16UL);
#line 2103
    wep_key.keylen = (u16 )wep_key_len;
#line 2105
    if ((unsigned int )wep_key_len == 13U) {
#line 2106
      padapter->securitypriv.dot11PrivacyAlgrthm = 1027077U;
#line 2108
      padapter->securitypriv.dot118021XGrpPrivacy = 1027077U;
    } else {
#line 2111
      padapter->securitypriv.dot11PrivacyAlgrthm = 1027073U;
#line 2113
      padapter->securitypriv.dot118021XGrpPrivacy = 1027073U;
    }
#line 2117
    memcpy((void *)(& wep_key.key), (void const   *)sme->key, (size_t )wep_key.keylen);
#line 2119
    tmp___10 = rtw_cfg80211_add_wep(padapter, & wep_key, (int )wep_key_idx);
#line 2119
    if (tmp___10 != 1) {
#line 2121
      ret = -95;
    } else {

    }
#line 2123
    if (ret < 0) {
#line 2124
      goto exit;
    } else {

    }
  } else {

  }
#line 2127
  ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.cipher_group, 0);
#line 2129
  if (ret < 0) {
#line 2130
    goto exit;
  } else {

  }
#line 2132
  if (sme->crypto.n_akm_suites != 0) {
#line 2133
    ret = rtw_cfg80211_set_key_mgt(psecuritypriv, sme->crypto.akm_suites[0]);
#line 2135
    if (ret < 0) {
#line 2136
      goto exit;
    } else {

    }
  } else {

  }
#line 2139
  if (psecuritypriv->ndisauthtype > 3U) {
#line 2140
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else {

  }
#line 2142
  tmp___11 = rtw_set_auth23a(padapter, psecuritypriv);
#line 2142
  if (tmp___11 != 1) {
#line 2143
    ret = -16;
#line 2144
    goto exit;
  } else {

  }
#line 2150
  tmp___12 = rtw_set_ssid(padapter, pnetwork);
#line 2150
  if (tmp___12 != 1) {
#line 2151
    ret = -16;
#line 2152
    goto exit;
  } else {

  }
#line 2155
  if (GlobalDebugLevel23A > 3U) {
#line 2155
    printk("\016RTL8723AU: set ssid:dot11AuthAlgrthm =%d, dot11PrivacyAlgrthm =%d, dot118021XGrpPrivacy =%d\n",
           psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm, psecuritypriv->dot118021XGrpPrivacy);
  } else {

  }
  exit: ;
#line 2162
  if (GlobalDebugLevel23A > 3U) {
#line 2162
    printk("\016RTL8723AU: <=%s, ret %d\n", "cfg80211_rtw_connect", ret);
  } else {

  }
#line 2164
  return (ret);
}
}
#line 2167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_disconnect(struct wiphy *wiphy , struct net_device *ndev ,
                                   u16 reason_code ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  bool tmp___0 ;

  {
#line 2170
  tmp = wiphy_priv___1(wiphy);
#line 2170
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2172
  if (GlobalDebugLevel23A > 3U) {
#line 2172
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_disconnect", (char *)(& ndev->name));
  } else {

  }
#line 2174
  rtw_set_roaming(padapter, 0);
#line 2176
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
#line 2176
  if ((int )tmp___0) {
#line 2177
    rtw_scan_abort23a(padapter);
#line 2178
    LeaveAllPowerSaveMode23a(padapter);
#line 2179
    rtw_disassoc_cmd23a(padapter, 500U, 0);
#line 2181
    if (GlobalDebugLevel23A > 3U) {
#line 2181
      printk("\016RTL8723AU: %s...call rtw_indicate_disconnect23a\n", "cfg80211_rtw_disconnect");
    } else {

    }
#line 2183
    padapter->mlmepriv.not_indic_disco = 1U;
#line 2184
    rtw_indicate_disconnect23a(padapter);
#line 2185
    padapter->mlmepriv.not_indic_disco = 0U;
#line 2187
    rtw_free_assoc_resources23a(padapter, 1);
  } else {

  }
#line 2190
  return (0);
}
}
#line 2193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_set_txpower(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                    enum nl80211_tx_power_setting type , int mbm ) 
{ 


  {
#line 2197
  if (GlobalDebugLevel23A > 3U) {
#line 2197
    printk("\016RTL8723AU: %s\n", "cfg80211_rtw_set_txpower");
  } else {

  }
#line 2198
  return (0);
}
}
#line 2201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_get_txpower(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                    int *dbm ) 
{ 


  {
#line 2204
  if (GlobalDebugLevel23A > 3U) {
#line 2204
    printk("\016RTL8723AU: %s\n", "cfg80211_rtw_get_txpower");
  } else {

  }
#line 2205
  *dbm = 12;
#line 2206
  return (0);
}
}
#line 2215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_set_power_mgmt(struct wiphy *wiphy , struct net_device *ndev ,
                                       bool enabled , int timeout ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct rtw_wdev_priv *rtw_wdev_priv ;
  void *tmp___0 ;

  {
#line 2219
  tmp = wiphy_priv___1(wiphy);
#line 2219
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2220
  tmp___0 = wdev_priv___1(padapter->rtw_wdev);
#line 2220
  rtw_wdev_priv = (struct rtw_wdev_priv *)tmp___0;
#line 2222
  if (GlobalDebugLevel23A > 3U) {
#line 2222
    printk("\016RTL8723AU: %s(%s): enabled:%u, timeout:%d\n", "cfg80211_rtw_set_power_mgmt",
           (char *)(& ndev->name), (int )enabled, timeout);
  } else {

  }
#line 2225
  rtw_wdev_priv->power_mgmt = enabled;
#line 2227
  if (! enabled) {
#line 2228
    LPS_Leave23a(padapter);
  } else {

  }
#line 2230
  return (0);
}
}
#line 2233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy , struct net_device *netdev ,
                                  struct cfg80211_pmksa *pmksa ) 
{ 
  u8 index ;
  u8 blInserted ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 2237
  blInserted = 0U;
#line 2238
  tmp = wiphy_priv___1(wiphy);
#line 2238
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2239
  psecuritypriv = & padapter->securitypriv;
#line 2241
  if (GlobalDebugLevel23A > 3U) {
#line 2241
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_set_pmksa", (char *)(& netdev->name));
  } else {

  }
#line 2243
  tmp___0 = is_zero_ether_addr(pmksa->bssid);
#line 2243
  if ((int )tmp___0) {
#line 2244
    return (-22);
  } else {

  }
#line 2246
  blInserted = 0U;
#line 2249
  index = 0U;
#line 2249
  goto ldv_53643;
  ldv_53642: 
#line 2250
  tmp___1 = ether_addr_equal((u8 const   *)(& psecuritypriv->PMKIDList[(int )index].Bssid),
                             pmksa->bssid);
#line 2250
  if ((int )tmp___1) {
#line 2254
    if (GlobalDebugLevel23A > 3U) {
#line 2254
      printk("\016RTL8723AU: %s(%s):  BSSID exists in the PMKList.\n", "cfg80211_rtw_set_pmksa",
             (char *)(& netdev->name));
    } else {

    }
#line 2257
    memcpy((void *)(& psecuritypriv->PMKIDList[(int )index].PMKID), (void const   *)pmksa->pmkid,
             16UL);
#line 2259
    psecuritypriv->PMKIDList[(int )index].bUsed = 1U;
#line 2260
    psecuritypriv->PMKIDIndex = (unsigned int )index + 1U;
#line 2261
    blInserted = 1U;
#line 2262
    goto ldv_53641;
  } else {

  }
#line 2249
  index = (u8 )((int )index + 1);
  ldv_53643: ;
#line 2249
  if ((unsigned int )index <= 15U) {
#line 2251
    goto ldv_53642;
  } else {

  }
  ldv_53641: ;
#line 2266
  if ((unsigned int )blInserted == 0U) {
#line 2268
    if (GlobalDebugLevel23A > 3U) {
#line 2268
      printk("\016RTL8723AU: %s(%s): Use new entry index = %d for this PMKID\n", "cfg80211_rtw_set_pmksa",
             (char *)(& netdev->name), (int )psecuritypriv->PMKIDIndex);
    } else {

    }
#line 2271
    ether_addr_copy((u8 *)(& psecuritypriv->PMKIDList[(int )psecuritypriv->PMKIDIndex].Bssid),
                    pmksa->bssid);
#line 2274
    memcpy((void *)(& psecuritypriv->PMKIDList[(int )psecuritypriv->PMKIDIndex].PMKID),
             (void const   *)pmksa->pmkid, 16UL);
#line 2277
    psecuritypriv->PMKIDList[(int )psecuritypriv->PMKIDIndex].bUsed = 1U;
#line 2279
    psecuritypriv->PMKIDIndex = (u8 )((int )psecuritypriv->PMKIDIndex + 1);
#line 2280
    if ((unsigned int )psecuritypriv->PMKIDIndex == 16U) {
#line 2281
      psecuritypriv->PMKIDIndex = 0U;
    } else {

    }
  } else {

  }
#line 2285
  return (0);
}
}
#line 2288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_del_pmksa(struct wiphy *wiphy , struct net_device *netdev ,
                                  struct cfg80211_pmksa *pmksa ) 
{ 
  u8 index ;
  u8 bMatched ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;
  bool tmp___0 ;

  {
#line 2292
  bMatched = 0U;
#line 2293
  tmp = wiphy_priv___1(wiphy);
#line 2293
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2294
  psecuritypriv = & padapter->securitypriv;
#line 2296
  if (GlobalDebugLevel23A > 3U) {
#line 2296
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_del_pmksa", (char *)(& netdev->name));
  } else {

  }
#line 2298
  index = 0U;
#line 2298
  goto ldv_53656;
  ldv_53655: 
#line 2299
  tmp___0 = ether_addr_equal((u8 const   *)(& psecuritypriv->PMKIDList[(int )index].Bssid),
                             pmksa->bssid);
#line 2299
  if ((int )tmp___0) {
#line 2303
    eth_zero_addr((u8 *)(& psecuritypriv->PMKIDList[(int )index].Bssid));
#line 2304
    memset((void *)(& psecuritypriv->PMKIDList[(int )index].PMKID), 0, 16UL);
#line 2306
    psecuritypriv->PMKIDList[(int )index].bUsed = 0U;
#line 2307
    bMatched = 1U;
#line 2308
    goto ldv_53654;
  } else {

  }
#line 2298
  index = (u8 )((int )index + 1);
  ldv_53656: ;
#line 2298
  if ((unsigned int )index <= 15U) {
#line 2300
    goto ldv_53655;
  } else {

  }
  ldv_53654: ;
#line 2312
  if ((unsigned int )bMatched == 0U) {
#line 2313
    if (GlobalDebugLevel23A > 3U) {
#line 2313
      printk("\016RTL8723AU: %s(%s): do not have matched BSSID\n", "cfg80211_rtw_del_pmksa",
             (char *)(& netdev->name));
    } else {

    }
#line 2315
    return (-22);
  } else {

  }
#line 2318
  return (0);
}
}
#line 2321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_flush_pmksa(struct wiphy *wiphy , struct net_device *netdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;

  {
#line 2324
  tmp = wiphy_priv___1(wiphy);
#line 2324
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2325
  psecuritypriv = & padapter->securitypriv;
#line 2327
  if (GlobalDebugLevel23A > 3U) {
#line 2327
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_flush_pmksa", (char *)(& netdev->name));
  } else {

  }
#line 2329
  memset((void *)(& psecuritypriv->PMKIDList), 0, 1152UL);
#line 2331
  psecuritypriv->PMKIDIndex = 0U;
#line 2333
  return (0);
}
}
#line 2337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
void rtw_cfg80211_indicate_sta_assoc(struct rtw_adapter *padapter , u8 *pmgmt_frame ,
                                     uint frame_len ) 
{ 
  s32 freq ;
  int channel ;
  struct mlme_ext_priv *pmlmeext ;
  struct net_device *ndev ;

  {
#line 2342
  pmlmeext = & padapter->mlmeextpriv;
#line 2343
  ndev = padapter->pnetdev;
#line 2345
  if (GlobalDebugLevel23A > 3U) {
#line 2345
    printk("\016RTL8723AU: %s(padapter =%p,%s)\n", "rtw_cfg80211_indicate_sta_assoc",
           padapter, (char *)(& ndev->name));
  } else {

  }
#line 2365
  channel = (int )pmlmeext->cur_channel;
#line 2366
  if (channel <= 14) {
#line 2367
    freq = ieee80211_channel_to_frequency(channel, 0);
  } else {
#line 2370
    freq = ieee80211_channel_to_frequency(channel, 1);
  }
#line 2373
  cfg80211_rx_mgmt(padapter->rtw_wdev, freq, 0, (u8 const   *)pmgmt_frame, (size_t )frame_len,
                   0U);
#line 2374
  return;
}
}
#line 2378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
void rtw_cfg80211_indicate_sta_disassoc(struct rtw_adapter *padapter , unsigned char *da ,
                                        unsigned short reason ) 
{ 
  s32 freq ;
  int channel ;
  uint frame_len ;
  struct ieee80211_mgmt mgmt ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct net_device *ndev ;
  u8 *tmp ;
  u8 *tmp___0 ;

  {
#line 2386
  pmlmeext = & padapter->mlmeextpriv;
#line 2387
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2388
  ndev = padapter->pnetdev;
#line 2390
  if (GlobalDebugLevel23A > 3U) {
#line 2390
    printk("\016RTL8723AU: %s(padapter =%p,%s)\n", "rtw_cfg80211_indicate_sta_disassoc",
           padapter, (char *)(& ndev->name));
  } else {

  }
#line 2392
  memset((void *)(& mgmt), 0, 36UL);
#line 2397
  channel = (int )pmlmeext->cur_channel;
#line 2398
  if (channel <= 14) {
#line 2399
    freq = ieee80211_channel_to_frequency(channel, 0);
  } else {
#line 2402
    freq = ieee80211_channel_to_frequency(channel, 1);
  }
#line 2405
  mgmt.frame_control = 192U;
#line 2408
  tmp = myid(& padapter->eeprompriv);
#line 2408
  ether_addr_copy((u8 *)(& mgmt.da), (u8 const   *)tmp);
#line 2409
  ether_addr_copy((u8 *)(& mgmt.sa), (u8 const   *)da);
#line 2410
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 2410
  ether_addr_copy((u8 *)(& mgmt.bssid), (u8 const   *)tmp___0);
#line 2412
  mgmt.seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 2413
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 2415
  mgmt.u.disassoc.reason_code = reason;
#line 2417
  frame_len = 26U;
#line 2419
  cfg80211_rx_mgmt(padapter->rtw_wdev, freq, 0, (u8 const   *)(& mgmt), (size_t )frame_len,
                   0U);
#line 2420
  return;
}
}
#line 2424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_monitor_if_open(struct net_device *ndev ) 
{ 


  {
#line 2426
  if (GlobalDebugLevel23A > 3U) {
#line 2426
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_monitor_if_open");
  } else {

  }
#line 2428
  return (0);
}
}
#line 2431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_monitor_if_close(struct net_device *ndev ) 
{ 


  {
#line 2433
  if (GlobalDebugLevel23A > 3U) {
#line 2433
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_monitor_if_close");
  } else {

  }
#line 2435
  return (0);
}
}
#line 2438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb , struct net_device *ndev ) 
{ 
  int ret ;
  int rtap_len ;
  int qos_len ;
  int dot11_hdr_len ;
  int snap_len ;
  unsigned char *pdata ;
  unsigned char src_mac_addr[6U] ;
  unsigned char dst_mac_addr[6U] ;
  struct ieee80211_hdr *dot11_hdr ;
  struct ieee80211_radiotap_header *rtap_hdr ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct ieee80211_mgmt *mgmt ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  u32 len ;
  u8 category ;
  u8 action ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2441
  ret = 0;
#line 2443
  qos_len = 0;
#line 2444
  dot11_hdr_len = 24;
#line 2445
  snap_len = 6;
#line 2451
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2451
  padapter = (struct rtw_adapter *)tmp;
#line 2453
  if (GlobalDebugLevel23A > 3U) {
#line 2453
    printk("\016RTL8723AU: %s(%s)\n", "rtw_cfg80211_monitor_if_xmit_entry", (char *)(& ndev->name));
  } else {

  }
#line 2455
  tmp___0 = ldv__builtin_expect(skb->len <= 7U, 0L);
#line 2455
  if (tmp___0 != 0L) {
#line 2456
    goto fail;
  } else {

  }
#line 2458
  rtap_hdr = (struct ieee80211_radiotap_header *)skb->data;
#line 2459
  tmp___1 = ldv__builtin_expect((unsigned int )rtap_hdr->it_version != 0U, 0L);
#line 2459
  if (tmp___1 != 0L) {
#line 2460
    goto fail;
  } else {

  }
#line 2462
  rtap_len = ieee80211_get_radiotap_len(skb->data);
#line 2463
  tmp___2 = ldv__builtin_expect(skb->len < (unsigned int )rtap_len, 0L);
#line 2463
  if (tmp___2 != 0L) {
#line 2464
    goto fail;
  } else {

  }
#line 2466
  if (rtap_len != 14) {
#line 2467
    if (GlobalDebugLevel23A > 3U) {
#line 2467
      printk("\016RTL8723AU: radiotap len (should be 14): %d\n", rtap_len);
    } else {

    }
#line 2468
    goto fail;
  } else {

  }
#line 2472
  skb_pull(skb, (unsigned int )rtap_len);
#line 2474
  dot11_hdr = (struct ieee80211_hdr *)skb->data;
#line 2476
  tmp___6 = ieee80211_is_data((int )dot11_hdr->frame_control);
#line 2476
  if (tmp___6 != 0) {
#line 2480
    tmp___3 = ieee80211_is_data_qos((int )dot11_hdr->frame_control);
#line 2480
    if (tmp___3 != 0) {
#line 2481
      qos_len = 2;
    } else {

    }
#line 2482
    tmp___4 = ieee80211_has_a4((int )dot11_hdr->frame_control);
#line 2482
    if (tmp___4 != 0) {
#line 2483
      dot11_hdr_len = dot11_hdr_len + 6;
    } else {

    }
#line 2485
    memcpy((void *)(& dst_mac_addr), (void const   *)(& dot11_hdr->addr1), 6UL);
#line 2486
    memcpy((void *)(& src_mac_addr), (void const   *)(& dot11_hdr->addr2), 6UL);
#line 2492
    skb_pull(skb, (unsigned int )(((dot11_hdr_len + qos_len) + snap_len) + -12));
#line 2494
    pdata = skb->data;
#line 2495
    ether_addr_copy(pdata, (u8 const   *)(& dst_mac_addr));
#line 2496
    ether_addr_copy(pdata + 6U, (u8 const   *)(& src_mac_addr));
#line 2498
    if (GlobalDebugLevel23A > 3U) {
#line 2498
      printk("\016RTL8723AU: should be eapol packet\n");
    } else {

    }
#line 2501
    ret = rtw_xmit23a_entry23a(skb, padapter->pnetdev);
#line 2503
    return (ret);
  } else {
#line 2505
    tmp___5 = ieee80211_is_action((int )dot11_hdr->frame_control);
#line 2505
    if (tmp___5 != 0) {
#line 2513
      pxmitpriv = & padapter->xmitpriv;
#line 2514
      pmlmeext = & padapter->mlmeextpriv;
#line 2515
      len = skb->len;
#line 2518
      mgmt = (struct ieee80211_mgmt *)dot11_hdr;
#line 2520
      if (GlobalDebugLevel23A > 3U) {
#line 2520
        printk("\016RTL8723AU: RTW_Tx:da=%pM via %s(%s)\n", (u8 *)(& mgmt->da), "rtw_cfg80211_monitor_if_xmit_entry",
               (char *)(& ndev->name));
      } else {

      }
#line 2522
      category = mgmt->u.action.category;
#line 2523
      action = mgmt->u.action.u.wme_action.action_code;
#line 2524
      if (GlobalDebugLevel23A > 3U) {
#line 2524
        printk("\016RTL8723AU: RTW_Tx:category(%u), action(%u)\n", (int )category,
               (int )action);
      } else {

      }
#line 2528
      pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 2529
      if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 2530
        goto fail;
      } else {

      }
#line 2533
      pattrib = & pmgntframe->attrib;
#line 2534
      update_mgntframe_attrib23a(padapter, pattrib);
#line 2535
      pattrib->retry_ctrl = 0U;
#line 2537
      memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 2539
      pframe = pmgntframe->buf_addr + 40U;
#line 2541
      memcpy((void *)pframe, (void const   *)skb->data, (size_t )len);
#line 2542
      pattrib->pktlen = len;
#line 2545
      pmlmeext->mgnt_seq = (u16 )((int )dot11_hdr->seq_ctrl >> 4);
#line 2546
      pattrib->seqnum = pmlmeext->mgnt_seq;
#line 2547
      pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 2549
      pattrib->last_txcmdsz = pattrib->pktlen;
#line 2551
      dump_mgntframe23a(padapter, pmgntframe);
    } else {

    }
  }
  fail: 
#line 2556
  consume_skb(skb);
#line 2558
  return (0);
}
}
#line 2562 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_monitor_if_set_mac_address(struct net_device *ndev , void *addr ) 
{ 


  {
#line 2564
  if (GlobalDebugLevel23A > 3U) {
#line 2564
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_monitor_if_set_mac_address");
  } else {

  }
#line 2566
  return (0);
}
}
#line 2569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static struct net_device_ops  const  rtw_cfg80211_monitor_if_ops  = 
#line 2569
     {0, 0, & rtw_cfg80211_monitor_if_open, & rtw_cfg80211_monitor_if_close, (netdev_tx_t (*)(struct sk_buff * ,
                                                                                            struct net_device * ))(& rtw_cfg80211_monitor_if_xmit_entry),
    0, 0, 0, & rtw_cfg80211_monitor_if_set_mac_address, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_cfg80211_add_monitor_if(struct rtw_adapter *padapter , char *name ,
                                       unsigned char name_assign_type , struct net_device **ndev ) 
{ 
  int ret ;
  struct net_device *mon_ndev ;
  struct wireless_dev *mon_wdev ;
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp ;
  void *tmp___0 ;
  struct net_device *tmp___1 ;

  {
#line 2580
  ret = 0;
#line 2581
  mon_ndev = (struct net_device *)0;
#line 2582
  mon_wdev = (struct wireless_dev *)0;
#line 2583
  tmp = wdev_priv___1(padapter->rtw_wdev);
#line 2583
  pwdev_priv = (struct rtw_wdev_priv *)tmp;
#line 2585
  if ((unsigned long )name == (unsigned long )((char *)0)) {
#line 2586
    if (GlobalDebugLevel23A > 3U) {
#line 2586
      printk("\016RTL8723AU: %s(%s): without specific name\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name));
    } else {

    }
#line 2588
    ret = -22;
#line 2589
    goto out;
  } else {

  }
#line 2592
  if ((unsigned long )pwdev_priv->pmon_ndev != (unsigned long )((struct net_device *)0)) {
#line 2593
    if (GlobalDebugLevel23A > 3U) {
#line 2593
      printk("\016RTL8723AU: %s(%s): monitor interface exist: %s\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name), (char *)(& (pwdev_priv->pmon_ndev)->name));
    } else {

    }
#line 2595
    ret = -16;
#line 2596
    goto out;
  } else {

  }
#line 2599
  mon_ndev = alloc_etherdev_mqs(16776, 1U, 1U);
#line 2600
  if ((unsigned long )mon_ndev == (unsigned long )((struct net_device *)0)) {
#line 2601
    if (GlobalDebugLevel23A > 3U) {
#line 2601
      printk("\016RTL8723AU: %s(%s): allocate ndev fail\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name));
    } else {

    }
#line 2603
    ret = -12;
#line 2604
    goto out;
  } else {

  }
#line 2607
  mon_ndev->type = 803U;
#line 2608
  strncpy((char *)(& mon_ndev->name), (char const   *)name, 16UL);
#line 2609
  mon_ndev->name[15] = 0;
#line 2610
  mon_ndev->name_assign_type = name_assign_type;
#line 2611
  mon_ndev->destructor = & rtw_ndev_destructor;
#line 2613
  mon_ndev->netdev_ops = & rtw_cfg80211_monitor_if_ops;
#line 2616
  tmp___0 = kzalloc(976UL, 208U);
#line 2616
  mon_wdev = (struct wireless_dev *)tmp___0;
#line 2617
  if ((unsigned long )mon_wdev == (unsigned long )((struct wireless_dev *)0)) {
#line 2618
    if (GlobalDebugLevel23A > 3U) {
#line 2618
      printk("\016RTL8723AU: %s(%s): allocate mon_wdev fail\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name));
    } else {

    }
#line 2620
    ret = -12;
#line 2621
    goto out;
  } else {

  }
#line 2624
  mon_wdev->wiphy = (padapter->rtw_wdev)->wiphy;
#line 2625
  mon_wdev->netdev = mon_ndev;
#line 2626
  mon_wdev->iftype = 6;
#line 2627
  mon_ndev->ieee80211_ptr = mon_wdev;
#line 2629
  ret = register_netdevice(mon_ndev);
#line 2630
  if (ret != 0) {
#line 2631
    goto out;
  } else {

  }
#line 2634
  tmp___1 = mon_ndev;
#line 2634
  pwdev_priv->pmon_ndev = tmp___1;
#line 2634
  *ndev = tmp___1;
#line 2635
  memcpy((void *)(& pwdev_priv->ifname_mon), (void const   *)name, 17UL);
  out: ;
#line 2638
  if (ret != 0) {
#line 2639
    kfree((void const   *)mon_wdev);
#line 2640
    mon_wdev = (struct wireless_dev *)0;
  } else {

  }
#line 2643
  if (ret != 0 && (unsigned long )mon_ndev != (unsigned long )((struct net_device *)0)) {
#line 2644
    ldv_free_netdev_626(mon_ndev);
#line 2645
    mon_ndev = (struct net_device *)0;
#line 2645
    *ndev = mon_ndev;
  } else {

  }
#line 2648
  return (ret);
}
}
#line 2652 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static struct wireless_dev *cfg80211_rtw_add_virtual_intf(struct wiphy *wiphy , char const   *name ,
                                                          unsigned char name_assign_type ,
                                                          enum nl80211_iftype type ,
                                                          u32 *flags , struct vif_params *params ) 
{ 
  int ret ;
  struct net_device *ndev ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  struct wireless_dev *tmp___2 ;

  {
#line 2657
  ret = 0;
#line 2658
  ndev = (struct net_device *)0;
#line 2659
  tmp = wiphy_priv___1(wiphy);
#line 2659
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2661
  if (GlobalDebugLevel23A > 3U) {
#line 2661
    tmp___0 = wiphy_name((struct wiphy  const  *)wiphy);
#line 2661
    printk("\016RTL8723AU: %s(%s): wiphy:%s, name:%s, type:%d\n", "cfg80211_rtw_add_virtual_intf",
           (char *)(& (padapter->pnetdev)->name), tmp___0, name, (unsigned int )type);
  } else {

  }
#line 2664
  switch ((unsigned int )type) {
  case 1U: ;
  case 4U: ;
  case 5U: ;
  case 7U: 
#line 2669
  ret = -19;
#line 2670
  goto ldv_53755;
  case 6U: 
#line 2672
  ret = rtw_cfg80211_add_monitor_if(padapter, (char *)name, (int )name_assign_type,
                                    & ndev);
#line 2675
  goto ldv_53755;
  case 8U: ;
  case 2U: 
#line 2679
  ret = -19;
#line 2680
  goto ldv_53755;
  case 9U: ;
  case 3U: 
#line 2684
  ret = -19;
#line 2685
  goto ldv_53755;
  default: 
#line 2687
  ret = -19;
#line 2688
  if (GlobalDebugLevel23A > 3U) {
#line 2688
    printk("\016RTL8723AU: Unsupported interface type\n");
  } else {

  }
#line 2689
  goto ldv_53755;
  }
  ldv_53755: ;
#line 2692
  if (GlobalDebugLevel23A > 3U) {
#line 2692
    printk("\016RTL8723AU: %s(%s): ndev:%p, ret:%d\n", "cfg80211_rtw_add_virtual_intf",
           (char *)(& (padapter->pnetdev)->name), ndev, ret);
  } else {

  }
#line 2696
  if ((unsigned long )ndev != (unsigned long )((struct net_device *)0)) {
#line 2696
    tmp___2 = ndev->ieee80211_ptr;
  } else {
#line 2696
    tmp___1 = ERR_PTR((long )ret);
#line 2696
    tmp___2 = (struct wireless_dev *)tmp___1;
  }
#line 2696
  return (tmp___2);
}
}
#line 2699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_del_virtual_intf(struct wiphy *wiphy , struct wireless_dev *wdev ) 
{ 
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp ;
  struct net_device *ndev ;

  {
#line 2702
  tmp = wiphy_priv___1(wiphy);
#line 2702
  pwdev_priv = (struct rtw_wdev_priv *)tmp;
#line 2705
  ndev = (unsigned long )wdev != (unsigned long )((struct wireless_dev *)0) ? wdev->netdev : (struct net_device *)0;
#line 2707
  if ((unsigned long )ndev == (unsigned long )((struct net_device *)0)) {
#line 2708
    goto exit;
  } else {

  }
#line 2710
  unregister_netdevice(ndev);
#line 2712
  if ((unsigned long )pwdev_priv->pmon_ndev == (unsigned long )ndev) {
#line 2713
    pwdev_priv->pmon_ndev = (struct net_device *)0;
#line 2714
    pwdev_priv->ifname_mon[0] = 0;
#line 2715
    if (GlobalDebugLevel23A > 3U) {
#line 2715
      printk("\016RTL8723AU: %s(%s): remove monitor interface\n", "cfg80211_rtw_del_virtual_intf",
             (char *)(& ndev->name));
    } else {

    }
  } else {

  }
  exit: ;
#line 2720
  return (0);
}
}
#line 2723 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int rtw_add_beacon(struct rtw_adapter *adapter , u8 const   *head , size_t head_len ,
                          u8 const   *tail , size_t tail_len ) 
{ 
  int ret ;
  u8 *pbuf ;
  uint len ;
  uint ielen ;
  uint wps_ielen ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *bss ;
  struct ieee80211_mgmt  const  *mgmt ;
  struct ieee80211_mgmt *tmpmgmt ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  u8 const   *tmp___2 ;
  int tmp___3 ;

  {
#line 2726
  ret = 0;
#line 2728
  wps_ielen = 0U;
#line 2729
  pmlmepriv = & adapter->mlmepriv;
#line 2730
  bss = & pmlmepriv->cur_network.network;
#line 2731
  mgmt = (struct ieee80211_mgmt  const  *)head;
#line 2735
  if (GlobalDebugLevel23A > 3U) {
#line 2735
    printk("\016RTL8723AU: %s beacon_head_len =%zu, beacon_tail_len =%zu\n", "rtw_add_beacon",
           head_len, tail_len);
  } else {

  }
#line 2738
  tmp = check_fwstate(pmlmepriv, 16);
#line 2738
  if (tmp) {
#line 2738
    tmp___0 = 0;
  } else {
#line 2738
    tmp___0 = 1;
  }
#line 2738
  if (tmp___0) {
#line 2739
    return (-22);
  } else {

  }
#line 2741
  if (head_len <= 35UL) {
#line 2742
    return (-22);
  } else {

  }
#line 2744
  tmp___1 = kzalloc(head_len + tail_len, 208U);
#line 2744
  pbuf = (u8 *)tmp___1;
#line 2745
  if ((unsigned long )pbuf == (unsigned long )((u8 *)0U)) {
#line 2746
    return (-12);
  } else {

  }
#line 2747
  tmpmgmt = (struct ieee80211_mgmt *)pbuf;
#line 2749
  bss->beacon_interval = get_unaligned_le16((void const   *)(& mgmt->u.beacon.beacon_int));
#line 2750
  bss->capability = get_unaligned_le16((void const   *)(& mgmt->u.beacon.capab_info));
#line 2751
  bss->tsf = get_unaligned_le64((void const   *)(& mgmt->u.beacon.timestamp));
#line 2754
  memcpy((void *)pbuf, (void const   *)head, head_len);
#line 2755
  memcpy((void *)(pbuf + head_len), (void const   *)tail, tail_len);
#line 2757
  len = (uint )head_len + (uint )tail_len;
#line 2758
  ielen = len - 36U;
#line 2760
  tmp___2 = cfg80211_find_vendor_ie(20722U, 4, (u8 const   *)(& tmpmgmt->u.beacon.variable),
                                    (int )ielen);
#line 2760
  if ((unsigned long )tmp___2 != (unsigned long )((u8 const   *)0U)) {
#line 2763
    if (GlobalDebugLevel23A > 3U) {
#line 2763
      printk("\016RTL8723AU: add bcn, wps_ielen =%d\n", wps_ielen);
    } else {

    }
  } else {

  }
#line 2766
  rtw_ies_remove_ie23a((u8 *)(& tmpmgmt->u.beacon.variable), & ielen, 0U, 221, (u8 *)(& P2P_OUI23A),
                       4);
#line 2768
  rtw_ies_remove_ie23a((u8 *)(& tmpmgmt->u.beacon.variable), & ielen, 0U, 221, (u8 *)(& WFD_OUI23A),
                       4);
#line 2771
  len = ielen + 36U;
#line 2772
  tmp___3 = rtw_check_beacon_data23a(adapter, tmpmgmt, len);
#line 2772
  if (tmp___3 == 1) {
#line 2773
    ret = 0;
  } else {
#line 2775
    ret = -22;
  }
#line 2778
  kfree((void const   *)pbuf);
#line 2780
  return (ret);
}
}
#line 2783 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_start_ap(struct wiphy *wiphy , struct net_device *ndev , struct cfg80211_ap_settings *settings ) 
{ 
  int ret ;
  struct rtw_adapter *adapter ;
  void *tmp ;
  struct wlan_bssid_ex *pbss_network ;
  struct wlan_bssid_ex *pbss_network_ext ;

  {
#line 2786
  ret = 0;
#line 2787
  tmp = wiphy_priv___1(wiphy);
#line 2787
  adapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2789
  if (GlobalDebugLevel23A > 3U) {
#line 2789
    printk("\016RTL8723AU: %s(%s): hidden_ssid:%d, auth_type:%d\n", "cfg80211_rtw_start_ap",
           (char *)(& ndev->name), (unsigned int )settings->hidden_ssid, (unsigned int )settings->auth_type);
  } else {

  }
#line 2793
  ret = rtw_add_beacon(adapter, settings->beacon.head, settings->beacon.head_len,
                       settings->beacon.tail, settings->beacon.tail_len);
#line 2797
  adapter->mlmeextpriv.mlmext_info.hidden_ssid_mode = (u8 )settings->hidden_ssid;
#line 2800
  if ((unsigned long )settings->ssid != (unsigned long )((u8 const   *)0U) && settings->ssid_len != 0UL) {
#line 2801
    pbss_network = & adapter->mlmepriv.cur_network.network;
#line 2803
    pbss_network_ext = & adapter->mlmeextpriv.mlmext_info.network;
#line 2806
    memcpy((void *)(& pbss_network->Ssid.ssid), (void const   *)settings->ssid,
             settings->ssid_len);
#line 2808
    pbss_network->Ssid.ssid_len = (u8 )settings->ssid_len;
#line 2809
    memcpy((void *)(& pbss_network_ext->Ssid.ssid), (void const   *)settings->ssid,
             settings->ssid_len);
#line 2811
    pbss_network_ext->Ssid.ssid_len = (u8 )settings->ssid_len;
  } else {

  }
#line 2814
  return (ret);
}
}
#line 2817 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_change_beacon(struct wiphy *wiphy , struct net_device *ndev ,
                                      struct cfg80211_beacon_data *info ) 
{ 
  int ret ;
  struct rtw_adapter *adapter ;
  void *tmp ;

  {
#line 2821
  ret = 0;
#line 2822
  tmp = wiphy_priv___1(wiphy);
#line 2822
  adapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2824
  if (GlobalDebugLevel23A > 3U) {
#line 2824
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_change_beacon", (char *)(& ndev->name));
  } else {

  }
#line 2826
  ret = rtw_add_beacon(adapter, info->head, info->head_len, info->tail, info->tail_len);
#line 2829
  return (ret);
}
}
#line 2832 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_stop_ap(struct wiphy *wiphy , struct net_device *ndev ) 
{ 


  {
#line 2834
  if (GlobalDebugLevel23A > 3U) {
#line 2834
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_stop_ap", (char *)(& ndev->name));
  } else {

  }
#line 2835
  return (0);
}
}
#line 2838 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_add_station(struct wiphy *wiphy , struct net_device *ndev ,
                                    u8 const   *mac , struct station_parameters *params ) 
{ 


  {
#line 2842
  if (GlobalDebugLevel23A > 3U) {
#line 2842
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_add_station", (char *)(& ndev->name));
  } else {

  }
#line 2844
  return (0);
}
}
#line 2847 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_del_station(struct wiphy *wiphy , struct net_device *ndev ,
                                    struct station_del_parameters *params ) 
{ 
  u8 const   *mac ;
  int ret ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  u8 updated ;
  struct sta_info *psta ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  struct list_head  const  *__mptr ;
  bool tmp___3 ;

  {
#line 2851
  mac = params->mac;
#line 2852
  ret = 0;
#line 2854
  updated = 0U;
#line 2856
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2856
  padapter = (struct rtw_adapter *)tmp;
#line 2857
  pmlmepriv = & padapter->mlmepriv;
#line 2858
  pstapriv = & padapter->stapriv;
#line 2860
  if (GlobalDebugLevel23A > 3U) {
#line 2860
    printk("\016RTL8723AU: +%s(%s)\n", "cfg80211_rtw_del_station", (char *)(& ndev->name));
  } else {

  }
#line 2862
  tmp___0 = check_fwstate(pmlmepriv, 17);
#line 2862
  if (tmp___0) {
#line 2862
    tmp___1 = 0;
  } else {
#line 2862
    tmp___1 = 1;
  }
#line 2862
  if (tmp___1) {
#line 2863
    if (GlobalDebugLevel23A > 3U) {
#line 2863
      printk("\016RTL8723AU: %s, fw_state != FW_LINKED|WIFI_AP_STATE\n", "cfg80211_rtw_del_station");
    } else {

    }
#line 2865
    return (-22);
  } else {

  }
#line 2868
  if ((unsigned long )mac == (unsigned long )((u8 const   *)0U)) {
#line 2869
    if (GlobalDebugLevel23A > 3U) {
#line 2869
      printk("\016RTL8723AU: flush all sta, and cam_entry\n");
    } else {

    }
#line 2871
    flush_all_cam_entry23a(padapter);
#line 2873
    ret = rtw_sta_flush23a(padapter);
#line 2875
    return (ret);
  } else {

  }
#line 2878
  if (GlobalDebugLevel23A > 3U) {
#line 2878
    printk("\016RTL8723AU: free sta macaddr=%pM\n", mac);
  } else {

  }
#line 2880
  tmp___2 = is_broadcast_ether_addr(mac);
#line 2880
  if ((int )tmp___2) {
#line 2881
    return (-22);
  } else {

  }
#line 2883
  spin_lock_bh(& pstapriv->asoc_list_lock);
#line 2885
  phead = & pstapriv->asoc_list;
#line 2888
  plist = phead->next;
#line 2888
  ptmp = plist->next;
#line 2888
  goto ldv_53837;
  ldv_53836: 
#line 2889
  __mptr = (struct list_head  const  *)plist;
#line 2889
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
#line 2891
  tmp___3 = ether_addr_equal(mac, (u8 const   *)(& psta->hwaddr));
#line 2891
  if ((int )tmp___3) {
#line 2892
    if (psta->dot8021xalg == 1 && (unsigned int )psta->bpairwise_key_installed == 0U) {
#line 2894
      if (GlobalDebugLevel23A > 3U) {
#line 2894
        printk("\016RTL8723AU: %s, sta\'s dot8021xalg = 1 and key_installed = false\n",
               "cfg80211_rtw_del_station");
      } else {

      }
    } else {
#line 2897
      if (GlobalDebugLevel23A > 3U) {
#line 2897
        printk("\016RTL8723AU: free psta =%p, aid =%d\n", psta, psta->aid);
      } else {

      }
#line 2900
      list_del_init(& psta->asoc_list);
#line 2901
      pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
#line 2904
      updated = ap_free_sta23a(padapter, psta, 1, 3);
#line 2909
      psta = (struct sta_info *)0;
#line 2911
      goto ldv_53835;
    }
  } else {

  }
#line 2888
  plist = ptmp;
#line 2888
  ptmp = plist->next;
  ldv_53837: ;
#line 2888
  if ((unsigned long )plist != (unsigned long )phead) {
#line 2890
    goto ldv_53836;
  } else {

  }
  ldv_53835: 
#line 2916
  spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 2918
  associated_clients_update23a(padapter, (int )updated);
#line 2920
  if (GlobalDebugLevel23A > 3U) {
#line 2920
    printk("\016RTL8723AU: -%s(%s)\n", "cfg80211_rtw_del_station", (char *)(& ndev->name));
  } else {

  }
#line 2922
  return (ret);
}
}
#line 2925 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_change_station(struct wiphy *wiphy , struct net_device *ndev ,
                                       u8 const   *mac , struct station_parameters *params ) 
{ 


  {
#line 2929
  if (GlobalDebugLevel23A > 3U) {
#line 2929
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_change_station", (char *)(& ndev->name));
  } else {

  }
#line 2930
  return (0);
}
}
#line 2933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_dump_station(struct wiphy *wiphy , struct net_device *ndev ,
                                     int idx , u8 *mac , struct station_info *sinfo ) 
{ 


  {
#line 2937
  if (GlobalDebugLevel23A > 3U) {
#line 2937
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_dump_station", (char *)(& ndev->name));
  } else {

  }
#line 2941
  return (-2);
}
}
#line 2944 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_change_bss(struct wiphy *wiphy , struct net_device *ndev ,
                                   struct bss_parameters *params ) 
{ 


  {
#line 2947
  if (GlobalDebugLevel23A > 3U) {
#line 2947
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_change_bss", (char *)(& ndev->name));
  } else {

  }
#line 2948
  return (0);
}
}
#line 2952 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int _cfg80211_rtw_mgmt_tx(struct rtw_adapter *padapter , u8 tx_ch , u8 const   *buf ,
                                 size_t len ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  int ret ;
  struct ieee80211_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u8 tmp___2 ;

  {
#line 2958
  ret = 0;
#line 2960
  pxmitpriv = & padapter->xmitpriv;
#line 2961
  pmlmeext = & padapter->mlmeextpriv;
#line 2963
  tmp = _rtw_pwr_wakeup23a(padapter, 2000U, "_cfg80211_rtw_mgmt_tx");
#line 2963
  if (tmp == 0) {
#line 2964
    ret = -14;
#line 2965
    goto exit;
  } else {

  }
#line 2968
  rtw_set_scan_deny(padapter, 1000U);
#line 2970
  rtw_scan_abort23a(padapter);
#line 2972
  tmp___2 = rtw_get_oper_ch23a(padapter);
#line 2972
  if ((int )tmp___2 != (int )tx_ch) {
#line 2973
    tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
#line 2973
    if (tmp___0) {
#line 2973
      tmp___1 = 0;
    } else {
#line 2973
      tmp___1 = 1;
    }
#line 2973
    if (tmp___1) {
#line 2974
      pmlmeext->cur_channel = tx_ch;
    } else {

    }
#line 2975
    set_channel_bwmode23a(padapter, (int )tx_ch, 0, 0);
  } else {

  }
#line 2981
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 2982
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 2984
    ret = 0;
#line 2985
    goto exit;
  } else {

  }
#line 2989
  pattrib = & pmgntframe->attrib;
#line 2990
  update_mgntframe_attrib23a(padapter, pattrib);
#line 2991
  pattrib->retry_ctrl = 0U;
#line 2993
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 2995
  pframe = pmgntframe->buf_addr + 40U;
#line 2997
  memcpy((void *)pframe, (void const   *)buf, len);
#line 2998
  pattrib->pktlen = (u32 )len;
#line 3000
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 3002
  pmlmeext->mgnt_seq = (u16 )((int )pwlanhdr->seq_ctrl >> 4);
#line 3003
  pattrib->seqnum = pmlmeext->mgnt_seq;
#line 3004
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3006
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3008
  ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
#line 3010
  if (ret != 1) {
#line 3011
    if (GlobalDebugLevel23A > 3U) {
#line 3011
      printk("\016RTL8723AU: %s, ack == false\n", "_cfg80211_rtw_mgmt_tx");
    } else {

    }
  } else
#line 3013
  if (GlobalDebugLevel23A > 3U) {
#line 3013
    printk("\016RTL8723AU: %s, ack == true\n", "_cfg80211_rtw_mgmt_tx");
  } else {

  }
  exit: ;
#line 3017
  if (GlobalDebugLevel23A > 3U) {
#line 3017
    printk("\016RTL8723AU: %s, ret =%d\n", "_cfg80211_rtw_mgmt_tx", ret);
  } else {

  }
#line 3019
  return (ret);
}
}
#line 3022 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                struct cfg80211_mgmt_tx_params *params , u64 *cookie ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  int ret ;
  int tx_ret ;
  u32 dump_limit ;
  u32 dump_cnt ;
  bool ack ;
  u8 category ;
  u8 action ;
  unsigned long start ;
  size_t len ;
  struct ieee80211_channel *chan ;
  u8 const   *buf ;
  struct ieee80211_mgmt *hdr ;
  u8 tx_ch ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 3026
  tmp = wiphy_priv___1(wiphy);
#line 3026
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 3028
  ret = 0;
#line 3030
  dump_limit = 8U;
#line 3031
  dump_cnt = 0U;
#line 3032
  ack = 1;
#line 3034
  start = jiffies;
#line 3035
  len = params->len;
#line 3036
  chan = params->chan;
#line 3037
  buf = params->buf;
#line 3038
  hdr = (struct ieee80211_mgmt *)buf;
#line 3039
  tmp___0 = ieee80211_frequency_to_channel((int )chan->center_freq);
#line 3039
  tx_ch = (unsigned char )tmp___0;
#line 3041
  tmp___1 = ieee80211_is_action((int )hdr->frame_control);
#line 3041
  if (tmp___1 == 0) {
#line 3042
    return (-22);
  } else {

  }
#line 3045
  *cookie = (u64 )buf;
#line 3047
  if (GlobalDebugLevel23A > 3U) {
#line 3047
    printk("\016RTL8723AU: %s(%s): len =%zu, ch =%d\n", "cfg80211_rtw_mgmt_tx", (char *)(& (padapter->pnetdev)->name),
           len, (int )tx_ch);
  } else {

  }
#line 3051
  cfg80211_mgmt_tx_status(padapter->rtw_wdev, *cookie, buf, len, (int )ack, 208U);
#line 3054
  if (GlobalDebugLevel23A > 3U) {
#line 3054
    printk("\016RTL8723AU: RTW_Tx:tx_ch =%d, da =%pM\n", (int )tx_ch, (u8 *)(& hdr->da));
  } else {

  }
#line 3055
  category = hdr->u.action.category;
#line 3056
  action = hdr->u.action.u.wme_action.action_code;
#line 3057
  if (GlobalDebugLevel23A > 3U) {
#line 3057
    printk("\016RTL8723AU: RTW_Tx:category(%u), action(%u)\n", (int )category, (int )action);
  } else {

  }
  ldv_53895: 
#line 3060
  dump_cnt = dump_cnt + 1U;
#line 3061
  tx_ret = _cfg80211_rtw_mgmt_tx(padapter, (int )tx_ch, buf, len);
#line 3062
  if (dump_cnt < dump_limit && tx_ret != 1) {
#line 3064
    goto ldv_53895;
  } else {

  }

#line 3064
  if (tx_ret != 1 || dump_cnt > 1U) {
#line 3065
    if (GlobalDebugLevel23A > 3U) {
#line 3065
      tmp___2 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 3065
      printk("\016RTL8723AU: %s(%s): %s (%d/%d) in %d ms\n", "cfg80211_rtw_mgmt_tx",
             (char *)(& (padapter->pnetdev)->name), tx_ret == 1 ? (char *)"OK" : (char *)"FAIL",
             dump_cnt, dump_limit, tmp___2);
    } else {

    }
  } else {

  }
#line 3071
  return (ret);
}
}
#line 3074 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static void cfg80211_rtw_mgmt_frame_register(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                             u16 frame_type , bool reg ) 
{ 


  {
#line 3078
  if ((unsigned int )frame_type != 64U) {
#line 3079
    return;
  } else {

  }
#line 3081
  return;
}
}
#line 3084 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static struct cfg80211_ops rtw_cfg80211_ops  = 
#line 3084
     {0, 0, 0, & cfg80211_rtw_add_virtual_intf, & cfg80211_rtw_del_virtual_intf, & cfg80211_rtw_change_iface,
    & cfg80211_rtw_add_key, & cfg80211_rtw_get_key, & cfg80211_rtw_del_key, & cfg80211_rtw_set_default_key,
    0, & cfg80211_rtw_start_ap, & cfg80211_rtw_change_beacon, & cfg80211_rtw_stop_ap,
    & cfg80211_rtw_add_station, & cfg80211_rtw_del_station, & cfg80211_rtw_change_station,
    & cfg80211_rtw_get_station, & cfg80211_rtw_dump_station, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, & cfg80211_rtw_change_bss, 0, 0, 0, & cfg80211_rtw_scan, 0,
    0, 0, 0, & cfg80211_rtw_connect, & cfg80211_rtw_disconnect, & cfg80211_rtw_join_ibss,
    & cfg80211_rtw_leave_ibss, 0, & cfg80211_rtw_set_wiphy_params, & cfg80211_rtw_set_txpower,
    & cfg80211_rtw_get_txpower, 0, 0, 0, 0, 0, 0, & cfg80211_rtw_set_pmksa, & cfg80211_rtw_del_pmksa,
    & cfg80211_rtw_flush_pmksa, 0, 0, & cfg80211_rtw_mgmt_tx, 0, & cfg80211_rtw_set_power_mgmt,
    0, 0, & cfg80211_rtw_mgmt_frame_register, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 3123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap , enum ieee80211_band band ,
                                       u8 rf_type ) 
{ 


  {
#line 3130
  ht_cap->ht_supported = 1;
#line 3132
  ht_cap->cap = 6242U;
#line 3140
  ht_cap->ampdu_factor = 3U;
#line 3143
  ht_cap->ampdu_density = 7U;
#line 3145
  ht_cap->mcs.tx_params = 1U;
#line 3157
  if ((unsigned int )rf_type == 3U) {
#line 3158
    ht_cap->mcs.rx_mask[0] = 255U;
#line 3159
    ht_cap->mcs.rx_mask[1] = 0U;
#line 3160
    ht_cap->mcs.rx_mask[4] = 1U;
#line 3162
    ht_cap->mcs.rx_highest = 150U;
  } else
#line 3163
  if ((unsigned int )rf_type == 0U || (unsigned int )rf_type == 2U) {
#line 3164
    ht_cap->mcs.rx_mask[0] = 255U;
#line 3165
    ht_cap->mcs.rx_mask[1] = 255U;
#line 3166
    ht_cap->mcs.rx_mask[4] = 1U;
#line 3168
    ht_cap->mcs.rx_highest = 300U;
  } else
#line 3170
  if (GlobalDebugLevel23A > 3U) {
#line 3170
    printk("\016RTL8723AU: %s, error rf_type =%d\n", "rtw_cfg80211_init_ht_capab",
           (int )rf_type);
  } else {

  }
#line 3171
  return;
}
}
#line 3175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
void rtw_cfg80211_init_wiphy(struct rtw_adapter *padapter ) 
{ 
  u8 rf_type ;
  struct ieee80211_supported_band *bands ;
  struct wireless_dev *pwdev ;
  struct wiphy *wiphy ;

  {
#line 3179
  pwdev = padapter->rtw_wdev;
#line 3180
  wiphy = pwdev->wiphy;
#line 3182
  rf_type = rtl8723a_get_rf_type(padapter);
#line 3184
  if (GlobalDebugLevel23A > 3U) {
#line 3184
    printk("\016RTL8723AU: %s:rf_type =%d\n", "rtw_cfg80211_init_wiphy", (int )rf_type);
  } else {

  }
#line 3188
  bands = wiphy->bands[0];
#line 3189
  if ((unsigned long )bands != (unsigned long )((struct ieee80211_supported_band *)0)) {
#line 3190
    rtw_cfg80211_init_ht_capab(& bands->ht_cap, 0, (int )rf_type);
  } else {

  }
#line 3197
  bands = wiphy->bands[1];
#line 3198
  if ((unsigned long )bands != (unsigned long )((struct ieee80211_supported_band *)0)) {
#line 3199
    rtw_cfg80211_init_ht_capab(& bands->ht_cap, 1, (int )rf_type);
  } else {

  }
#line 3200
  return;
}
}
#line 3205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
static void rtw_cfg80211_preinit_wiphy(struct rtw_adapter *padapter , struct wiphy *wiphy ) 
{ 


  {
#line 3208
  wiphy->signal_type = 1;
#line 3210
  wiphy->max_scan_ssids = 9U;
#line 3211
  wiphy->max_scan_ie_len = 2304U;
#line 3212
  wiphy->max_num_pmkids = 4U;
#line 3214
  wiphy->max_remain_on_channel_duration = 65535U;
#line 3217
  wiphy->interface_modes = 78U;
#line 3225
  wiphy->mgmt_stypes = (struct ieee80211_txrx_stypes  const  *)(& rtw_cfg80211_default_mgmt_stypes);
#line 3228
  wiphy->software_iftypes = (u16 )((unsigned int )wiphy->software_iftypes | 64U);
#line 3235
  wiphy->cipher_suites = (u32 const   *)(& rtw_cipher_suites);
#line 3236
  wiphy->n_cipher_suites = 4;
#line 3239
  wiphy->bands[0] = rtw_spt_band_alloc(0);
#line 3242
  wiphy->bands[1] = rtw_spt_band_alloc(1);
#line 3245
  wiphy->flags = wiphy->flags | 2097152U;
#line 3246
  wiphy->flags = wiphy->flags | 1179648U;
#line 3248
  if ((unsigned int )padapter->registrypriv.power_mgnt != 0U) {
#line 3249
    wiphy->flags = wiphy->flags | 16U;
  } else {
#line 3251
    wiphy->flags = wiphy->flags & 4294967279U;
  }
#line 3252
  return;
}
}
#line 3254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
int rtw_wdev_alloc(struct rtw_adapter *padapter , struct device *dev ) 
{ 
  int ret ;
  struct wiphy *wiphy ;
  struct wireless_dev *wdev ;
  struct rtw_wdev_priv *pwdev_priv ;
  struct net_device *pnetdev ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;

  {
#line 3256
  ret = 0;
#line 3260
  pnetdev = padapter->pnetdev;
#line 3262
  if (GlobalDebugLevel23A > 3U) {
#line 3262
    printk("\016RTL8723AU: %s(padapter =%p)\n", "rtw_wdev_alloc", padapter);
  } else {

  }
#line 3265
  wiphy = wiphy_new((struct cfg80211_ops  const  *)(& rtw_cfg80211_ops), 128);
#line 3266
  if ((unsigned long )wiphy == (unsigned long )((struct wiphy *)0)) {
#line 3267
    if (GlobalDebugLevel23A > 3U) {
#line 3267
      printk("\016RTL8723AU: Couldn\'t allocate wiphy device\n");
    } else {

    }
#line 3268
    ret = -12;
#line 3269
    goto exit;
  } else {

  }
#line 3273
  tmp = kzalloc(976UL, 208U);
#line 3273
  wdev = (struct wireless_dev *)tmp;
#line 3274
  if ((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0)) {
#line 3275
    if (GlobalDebugLevel23A > 3U) {
#line 3275
      printk("\016RTL8723AU: Couldn\'t allocate wireless device\n");
    } else {

    }
#line 3276
    ret = -12;
#line 3277
    goto free_wiphy;
  } else {

  }
#line 3280
  set_wiphy_dev(wiphy, dev);
#line 3281
  rtw_cfg80211_preinit_wiphy(padapter, wiphy);
#line 3283
  ret = wiphy_register(wiphy);
#line 3284
  if (ret < 0) {
#line 3285
    if (GlobalDebugLevel23A > 3U) {
#line 3285
      printk("\016RTL8723AU: Couldn\'t register wiphy device\n");
    } else {

    }
#line 3286
    goto free_wdev;
  } else {

  }
#line 3289
  wdev->wiphy = wiphy;
#line 3290
  wdev->netdev = pnetdev;
#line 3293
  wdev->iftype = 6;
#line 3294
  padapter->rtw_wdev = wdev;
#line 3295
  pnetdev->ieee80211_ptr = wdev;
#line 3298
  tmp___0 = wdev_priv___1(wdev);
#line 3298
  pwdev_priv = (struct rtw_wdev_priv *)tmp___0;
#line 3299
  pwdev_priv->rtw_wdev = wdev;
#line 3300
  pwdev_priv->pmon_ndev = (struct net_device *)0;
#line 3301
  pwdev_priv->ifname_mon[0] = 0;
#line 3302
  pwdev_priv->padapter = padapter;
#line 3303
  pwdev_priv->scan_request = (struct cfg80211_scan_request *)0;
#line 3304
  spinlock_check(& pwdev_priv->scan_req_lock);
#line 3304
  __raw_spin_lock_init(& pwdev_priv->scan_req_lock.__annonCompField18.rlock, "&(&pwdev_priv->scan_req_lock)->rlock",
                       & __key);
#line 3306
  pwdev_priv->p2p_enabled = 0U;
#line 3308
  if ((unsigned int )padapter->registrypriv.power_mgnt != 0U) {
#line 3309
    pwdev_priv->power_mgmt = 1;
  } else {
#line 3311
    pwdev_priv->power_mgmt = 0;
  }
#line 3313
  return (ret);
  free_wdev: 
#line 3315
  kfree((void const   *)wdev);
  free_wiphy: 
#line 3317
  wiphy_free(wiphy);
  exit: ;
#line 3319
  return (ret);
}
}
#line 3322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
void rtw_wdev_free(struct wireless_dev *wdev ) 
{ 


  {
#line 3324
  if (GlobalDebugLevel23A > 3U) {
#line 3324
    printk("\016RTL8723AU: %s(wdev =%p)\n", "rtw_wdev_free", wdev);
  } else {

  }
#line 3326
  if ((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0)) {
#line 3327
    return;
  } else {

  }
#line 3329
  kfree((void const   *)(wdev->wiphy)->bands[0]);
#line 3330
  kfree((void const   *)(wdev->wiphy)->bands[1]);
#line 3332
  wiphy_free(wdev->wiphy);
#line 3334
  kfree((void const   *)wdev);
#line 3335
  return;
}
}
#line 3337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.c"
void rtw_wdev_unregister(struct wireless_dev *wdev ) 
{ 
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp ;

  {
#line 3341
  if (GlobalDebugLevel23A > 3U) {
#line 3341
    printk("\016RTL8723AU: %s(wdev =%p)\n", "rtw_wdev_unregister", wdev);
  } else {

  }
#line 3343
  if ((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0)) {
#line 3344
    return;
  } else {

  }
#line 3346
  tmp = wdev_priv___1(wdev);
#line 3346
  pwdev_priv = (struct rtw_wdev_priv *)tmp;
#line 3348
  rtw_cfg80211_indicate_scan_done(pwdev_priv, 1);
#line 3350
  if ((unsigned long )pwdev_priv->pmon_ndev != (unsigned long )((struct net_device *)0)) {
#line 3351
    if (GlobalDebugLevel23A > 3U) {
#line 3351
      printk("\016RTL8723AU: %s, unregister monitor interface\n", "rtw_wdev_unregister");
    } else {

    }
#line 3352
    ldv_unregister_netdev_627(pwdev_priv->pmon_ndev);
  } else {

  }
#line 3355
  wiphy_unregister(wdev->wiphy);
#line 3356
  return;
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
int ldv_retval_0  ;
#line 250
extern int ldv_release_16(void) ;
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
int ldv_retval_1  ;
#line 252
extern int ldv_bind_16(void) ;
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
int ldv_retval_3  ;
#line 254
extern int ldv_ndo_uninit_17(void) ;
#line 255
extern int ldv_ndo_init_17(void) ;
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void ldv_net_device_ops_17(void) 
{ 
  void *tmp ;

  {
#line 259
  tmp = ldv_init_zalloc(3008UL);
#line 259
  rtw_cfg80211_monitor_if_ops_group1 = (struct net_device *)tmp;
#line 260
  return;
}
}
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void ldv_initialize_cfg80211_ops_16(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 264
  tmp = ldv_init_zalloc(976UL);
#line 264
  rtw_cfg80211_ops_group0 = (struct wireless_dev *)tmp;
#line 265
  tmp___0 = ldv_init_zalloc(16UL);
#line 265
  rtw_cfg80211_ops_group2 = (struct cfg80211_pmksa *)tmp___0;
#line 266
  tmp___1 = ldv_init_zalloc(3008UL);
#line 266
  rtw_cfg80211_ops_group6 = (struct net_device *)tmp___1;
#line 267
  tmp___2 = ldv_init_zalloc(1792UL);
#line 267
  rtw_cfg80211_ops_group3 = (struct wiphy *)tmp___2;
#line 268
  tmp___3 = ldv_init_zalloc(120UL);
#line 268
  rtw_cfg80211_ops_group4 = (struct station_parameters *)tmp___3;
#line 269
  tmp___4 = ldv_init_zalloc(12UL);
#line 269
  rtw_cfg80211_ops_group5 = (struct vif_params *)tmp___4;
#line 270
  tmp___5 = ldv_init_zalloc(840UL);
#line 270
  rtw_cfg80211_ops_group1 = (struct station_info *)tmp___5;
#line 271
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void ldv_main_exported_16(void) 
{ 
  int ldvarg19 ;
  u8 *ldvarg22 ;
  void *tmp ;
  char *ldvarg25 ;
  void *tmp___0 ;
  u16 ldvarg17 ;
  u8 ldvarg21 ;
  u8 ldvarg30 ;
  struct cfg80211_ap_settings *ldvarg15 ;
  void *tmp___1 ;
  u8 *ldvarg27 ;
  void *tmp___2 ;
  u32 *ldvarg26 ;
  void *tmp___3 ;
  bool ldvarg45 ;
  u8 *ldvarg9 ;
  void *tmp___4 ;
  struct key_params *ldvarg40 ;
  void *tmp___5 ;
  int *ldvarg10 ;
  void *tmp___6 ;
  struct cfg80211_scan_request *ldvarg36 ;
  void *tmp___7 ;
  int ldvarg13 ;
  u8 *ldvarg8 ;
  void *tmp___8 ;
  struct cfg80211_ibss_params *ldvarg3 ;
  void *tmp___9 ;
  bool ldvarg41 ;
  void (*ldvarg31)(void * , struct key_params * ) ;
  bool ldvarg20 ;
  enum nl80211_iftype ldvarg39 ;
  struct bss_parameters *ldvarg2 ;
  void *tmp___10 ;
  void *ldvarg28 ;
  void *tmp___11 ;
  u8 ldvarg34 ;
  enum nl80211_tx_power_setting ldvarg14 ;
  u16 ldvarg4 ;
  bool ldvarg16 ;
  struct cfg80211_mgmt_tx_params *ldvarg6 ;
  void *tmp___12 ;
  bool ldvarg33 ;
  u64 *ldvarg5 ;
  void *tmp___13 ;
  u32 *ldvarg38 ;
  void *tmp___14 ;
  bool ldvarg35 ;
  unsigned char ldvarg24 ;
  int ldvarg44 ;
  bool ldvarg29 ;
  struct cfg80211_beacon_data *ldvarg37 ;
  void *tmp___15 ;
  struct cfg80211_connect_params *ldvarg12 ;
  void *tmp___16 ;
  u8 ldvarg42 ;
  u8 *ldvarg43 ;
  void *tmp___17 ;
  enum nl80211_iftype ldvarg23 ;
  u32 ldvarg7 ;
  u8 *ldvarg32 ;
  void *tmp___18 ;
  struct station_del_parameters *ldvarg11 ;
  void *tmp___19 ;
  u8 *ldvarg18 ;
  void *tmp___20 ;
  int tmp___21 ;

  {
#line 275
  tmp = ldv_init_zalloc(1UL);
#line 275
  ldvarg22 = (u8 *)tmp;
#line 276
  tmp___0 = ldv_init_zalloc(1UL);
#line 276
  ldvarg25 = (char *)tmp___0;
#line 280
  tmp___1 = ldv_init_zalloc(232UL);
#line 280
  ldvarg15 = (struct cfg80211_ap_settings *)tmp___1;
#line 281
  tmp___2 = ldv_init_zalloc(1UL);
#line 281
  ldvarg27 = (u8 *)tmp___2;
#line 282
  tmp___3 = ldv_init_zalloc(4UL);
#line 282
  ldvarg26 = (u32 *)tmp___3;
#line 284
  tmp___4 = ldv_init_zalloc(1UL);
#line 284
  ldvarg9 = (u8 *)tmp___4;
#line 285
  tmp___5 = ldv_init_zalloc(32UL);
#line 285
  ldvarg40 = (struct key_params *)tmp___5;
#line 286
  tmp___6 = ldv_init_zalloc(4UL);
#line 286
  ldvarg10 = (int *)tmp___6;
#line 287
  tmp___7 = ldv_init_zalloc(104UL);
#line 287
  ldvarg36 = (struct cfg80211_scan_request *)tmp___7;
#line 289
  tmp___8 = ldv_init_zalloc(1UL);
#line 289
  ldvarg8 = (u8 *)tmp___8;
#line 290
  tmp___9 = ldv_init_zalloc(128UL);
#line 290
  ldvarg3 = (struct cfg80211_ibss_params *)tmp___9;
#line 295
  tmp___10 = ldv_init_zalloc(40UL);
#line 295
  ldvarg2 = (struct bss_parameters *)tmp___10;
#line 296
  tmp___11 = ldv_init_zalloc(1UL);
#line 296
  ldvarg28 = tmp___11;
#line 301
  tmp___12 = ldv_init_zalloc(48UL);
#line 301
  ldvarg6 = (struct cfg80211_mgmt_tx_params *)tmp___12;
#line 303
  tmp___13 = ldv_init_zalloc(8UL);
#line 303
  ldvarg5 = (u64 *)tmp___13;
#line 304
  tmp___14 = ldv_init_zalloc(4UL);
#line 304
  ldvarg38 = (u32 *)tmp___14;
#line 309
  tmp___15 = ldv_init_zalloc(96UL);
#line 309
  ldvarg37 = (struct cfg80211_beacon_data *)tmp___15;
#line 310
  tmp___16 = ldv_init_zalloc(232UL);
#line 310
  ldvarg12 = (struct cfg80211_connect_params *)tmp___16;
#line 312
  tmp___17 = ldv_init_zalloc(1UL);
#line 312
  ldvarg43 = (u8 *)tmp___17;
#line 315
  tmp___18 = ldv_init_zalloc(1UL);
#line 315
  ldvarg32 = (u8 *)tmp___18;
#line 316
  tmp___19 = ldv_init_zalloc(16UL);
#line 316
  ldvarg11 = (struct station_del_parameters *)tmp___19;
#line 317
  tmp___20 = ldv_init_zalloc(1UL);
#line 317
  ldvarg18 = (u8 *)tmp___20;
#line 274
  ldv_memset((void *)(& ldvarg19), 0, 4UL);
#line 277
  ldv_memset((void *)(& ldvarg17), 0, 2UL);
#line 278
  ldv_memset((void *)(& ldvarg21), 0, 1UL);
#line 279
  ldv_memset((void *)(& ldvarg30), 0, 1UL);
#line 283
  ldv_memset((void *)(& ldvarg45), 0, 1UL);
#line 288
  ldv_memset((void *)(& ldvarg13), 0, 4UL);
#line 291
  ldv_memset((void *)(& ldvarg41), 0, 1UL);
#line 292
  ldv_memset((void *)(& ldvarg31), 0, 8UL);
#line 293
  ldv_memset((void *)(& ldvarg20), 0, 1UL);
#line 294
  ldv_memset((void *)(& ldvarg39), 0, 4UL);
#line 297
  ldv_memset((void *)(& ldvarg34), 0, 1UL);
#line 298
  ldv_memset((void *)(& ldvarg14), 0, 4UL);
#line 299
  ldv_memset((void *)(& ldvarg4), 0, 2UL);
#line 300
  ldv_memset((void *)(& ldvarg16), 0, 1UL);
#line 302
  ldv_memset((void *)(& ldvarg33), 0, 1UL);
#line 305
  ldv_memset((void *)(& ldvarg35), 0, 1UL);
#line 306
  ldv_memset((void *)(& ldvarg24), 0, 1UL);
#line 307
  ldv_memset((void *)(& ldvarg44), 0, 4UL);
#line 308
  ldv_memset((void *)(& ldvarg29), 0, 1UL);
#line 311
  ldv_memset((void *)(& ldvarg42), 0, 1UL);
#line 313
  ldv_memset((void *)(& ldvarg23), 0, 4UL);
#line 314
  ldv_memset((void *)(& ldvarg7), 0, 4UL);
#line 319
  tmp___21 = __VERIFIER_nondet_int();
#line 319
  switch (tmp___21) {
  case 0: ;
#line 322
  if (ldv_state_variable_16 == 1) {
#line 324
    cfg80211_rtw_set_power_mgmt(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                (int )ldvarg45, ldvarg44);
#line 326
    ldv_state_variable_16 = 1;
  } else {

  }
#line 329
  if (ldv_state_variable_16 == 3) {
#line 331
    cfg80211_rtw_set_power_mgmt(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                (int )ldvarg45, ldvarg44);
#line 333
    ldv_state_variable_16 = 3;
  } else {

  }
#line 336
  if (ldv_state_variable_16 == 2) {
#line 338
    cfg80211_rtw_set_power_mgmt(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                (int )ldvarg45, ldvarg44);
#line 340
    ldv_state_variable_16 = 2;
  } else {

  }
#line 343
  goto ldv_54016;
  case 1: ;
#line 346
  if (ldv_state_variable_16 == 1) {
#line 348
    cfg80211_rtw_add_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg42,
                         (int )ldvarg41, (u8 const   *)ldvarg43, ldvarg40);
#line 350
    ldv_state_variable_16 = 1;
  } else {

  }
#line 353
  if (ldv_state_variable_16 == 3) {
#line 355
    cfg80211_rtw_add_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg42,
                         (int )ldvarg41, (u8 const   *)ldvarg43, ldvarg40);
#line 357
    ldv_state_variable_16 = 3;
  } else {

  }
#line 360
  if (ldv_state_variable_16 == 2) {
#line 362
    cfg80211_rtw_add_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg42,
                         (int )ldvarg41, (u8 const   *)ldvarg43, ldvarg40);
#line 364
    ldv_state_variable_16 = 2;
  } else {

  }
#line 367
  goto ldv_54016;
  case 2: ;
#line 370
  if (ldv_state_variable_16 == 1) {
#line 372
    cfg80211_rtw_change_iface(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg39,
                              ldvarg38, rtw_cfg80211_ops_group5);
#line 374
    ldv_state_variable_16 = 1;
  } else {

  }
#line 377
  if (ldv_state_variable_16 == 3) {
#line 379
    cfg80211_rtw_change_iface(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg39,
                              ldvarg38, rtw_cfg80211_ops_group5);
#line 381
    ldv_state_variable_16 = 3;
  } else {

  }
#line 384
  if (ldv_state_variable_16 == 2) {
#line 386
    cfg80211_rtw_change_iface(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg39,
                              ldvarg38, rtw_cfg80211_ops_group5);
#line 388
    ldv_state_variable_16 = 2;
  } else {

  }
#line 391
  goto ldv_54016;
  case 3: ;
#line 394
  if (ldv_state_variable_16 == 1) {
#line 396
    cfg80211_rtw_change_beacon(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg37);
#line 398
    ldv_state_variable_16 = 1;
  } else {

  }
#line 401
  if (ldv_state_variable_16 == 3) {
#line 403
    cfg80211_rtw_change_beacon(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg37);
#line 405
    ldv_state_variable_16 = 3;
  } else {

  }
#line 408
  if (ldv_state_variable_16 == 2) {
#line 410
    cfg80211_rtw_change_beacon(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg37);
#line 412
    ldv_state_variable_16 = 2;
  } else {

  }
#line 415
  goto ldv_54016;
  case 4: ;
#line 418
  if (ldv_state_variable_16 == 1) {
#line 420
    cfg80211_rtw_scan(rtw_cfg80211_ops_group3, ldvarg36);
#line 422
    ldv_state_variable_16 = 1;
  } else {

  }
#line 425
  if (ldv_state_variable_16 == 3) {
#line 427
    cfg80211_rtw_scan(rtw_cfg80211_ops_group3, ldvarg36);
#line 429
    ldv_state_variable_16 = 3;
  } else {

  }
#line 432
  if (ldv_state_variable_16 == 2) {
#line 434
    cfg80211_rtw_scan(rtw_cfg80211_ops_group3, ldvarg36);
#line 436
    ldv_state_variable_16 = 2;
  } else {

  }
#line 439
  goto ldv_54016;
  case 5: ;
#line 442
  if (ldv_state_variable_16 == 1) {
#line 444
    cfg80211_rtw_set_default_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                 (int )ldvarg34, (int )ldvarg33, (int )ldvarg35);
#line 446
    ldv_state_variable_16 = 1;
  } else {

  }
#line 449
  if (ldv_state_variable_16 == 3) {
#line 451
    cfg80211_rtw_set_default_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                 (int )ldvarg34, (int )ldvarg33, (int )ldvarg35);
#line 453
    ldv_state_variable_16 = 3;
  } else {

  }
#line 456
  if (ldv_state_variable_16 == 2) {
#line 458
    cfg80211_rtw_set_default_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                 (int )ldvarg34, (int )ldvarg33, (int )ldvarg35);
#line 460
    ldv_state_variable_16 = 2;
  } else {

  }
#line 463
  goto ldv_54016;
  case 6: ;
#line 466
  if (ldv_state_variable_16 == 1) {
#line 468
    cfg80211_rtw_get_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg30,
                         (int )ldvarg29, (u8 const   *)ldvarg32, ldvarg28, ldvarg31);
#line 470
    ldv_state_variable_16 = 1;
  } else {

  }
#line 473
  if (ldv_state_variable_16 == 3) {
#line 475
    cfg80211_rtw_get_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg30,
                         (int )ldvarg29, (u8 const   *)ldvarg32, ldvarg28, ldvarg31);
#line 477
    ldv_state_variable_16 = 3;
  } else {

  }
#line 480
  if (ldv_state_variable_16 == 2) {
#line 482
    cfg80211_rtw_get_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg30,
                         (int )ldvarg29, (u8 const   *)ldvarg32, ldvarg28, ldvarg31);
#line 484
    ldv_state_variable_16 = 2;
  } else {

  }
#line 487
  goto ldv_54016;
  case 7: ;
#line 490
  if (ldv_state_variable_16 == 1) {
#line 492
    cfg80211_rtw_del_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group2);
#line 494
    ldv_state_variable_16 = 1;
  } else {

  }
#line 497
  if (ldv_state_variable_16 == 3) {
#line 499
    cfg80211_rtw_del_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group2);
#line 501
    ldv_state_variable_16 = 3;
  } else {

  }
#line 504
  if (ldv_state_variable_16 == 2) {
#line 506
    cfg80211_rtw_del_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group2);
#line 508
    ldv_state_variable_16 = 2;
  } else {

  }
#line 511
  goto ldv_54016;
  case 8: ;
#line 514
  if (ldv_state_variable_16 == 1) {
#line 516
    cfg80211_rtw_del_virtual_intf(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0);
#line 518
    ldv_state_variable_16 = 1;
  } else {

  }
#line 521
  if (ldv_state_variable_16 == 3) {
#line 523
    cfg80211_rtw_del_virtual_intf(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0);
#line 525
    ldv_state_variable_16 = 3;
  } else {

  }
#line 528
  if (ldv_state_variable_16 == 2) {
#line 530
    cfg80211_rtw_del_virtual_intf(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0);
#line 532
    ldv_state_variable_16 = 2;
  } else {

  }
#line 535
  goto ldv_54016;
  case 9: ;
#line 538
  if (ldv_state_variable_16 == 1) {
#line 540
    cfg80211_rtw_add_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg27,
                             rtw_cfg80211_ops_group4);
#line 542
    ldv_state_variable_16 = 1;
  } else {

  }
#line 545
  if (ldv_state_variable_16 == 3) {
#line 547
    cfg80211_rtw_add_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg27,
                             rtw_cfg80211_ops_group4);
#line 549
    ldv_state_variable_16 = 3;
  } else {

  }
#line 552
  if (ldv_state_variable_16 == 2) {
#line 554
    cfg80211_rtw_add_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg27,
                             rtw_cfg80211_ops_group4);
#line 556
    ldv_state_variable_16 = 2;
  } else {

  }
#line 559
  goto ldv_54016;
  case 10: ;
#line 562
  if (ldv_state_variable_16 == 1) {
#line 564
    cfg80211_rtw_add_virtual_intf(rtw_cfg80211_ops_group3, (char const   *)ldvarg25,
                                  (int )ldvarg24, ldvarg23, ldvarg26, rtw_cfg80211_ops_group5);
#line 566
    ldv_state_variable_16 = 1;
  } else {

  }
#line 569
  if (ldv_state_variable_16 == 3) {
#line 571
    cfg80211_rtw_add_virtual_intf(rtw_cfg80211_ops_group3, (char const   *)ldvarg25,
                                  (int )ldvarg24, ldvarg23, ldvarg26, rtw_cfg80211_ops_group5);
#line 573
    ldv_state_variable_16 = 3;
  } else {

  }
#line 576
  if (ldv_state_variable_16 == 2) {
#line 578
    cfg80211_rtw_add_virtual_intf(rtw_cfg80211_ops_group3, (char const   *)ldvarg25,
                                  (int )ldvarg24, ldvarg23, ldvarg26, rtw_cfg80211_ops_group5);
#line 580
    ldv_state_variable_16 = 2;
  } else {

  }
#line 583
  goto ldv_54016;
  case 11: ;
#line 586
  if (ldv_state_variable_16 == 1) {
#line 588
    cfg80211_rtw_del_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg21,
                         (int )ldvarg20, (u8 const   *)ldvarg22);
#line 590
    ldv_state_variable_16 = 1;
  } else {

  }
#line 593
  if (ldv_state_variable_16 == 3) {
#line 595
    cfg80211_rtw_del_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg21,
                         (int )ldvarg20, (u8 const   *)ldvarg22);
#line 597
    ldv_state_variable_16 = 3;
  } else {

  }
#line 600
  if (ldv_state_variable_16 == 2) {
#line 602
    cfg80211_rtw_del_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg21,
                         (int )ldvarg20, (u8 const   *)ldvarg22);
#line 604
    ldv_state_variable_16 = 2;
  } else {

  }
#line 607
  goto ldv_54016;
  case 12: ;
#line 610
  if (ldv_state_variable_16 == 1) {
#line 612
    cfg80211_rtw_dump_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg19,
                              ldvarg18, rtw_cfg80211_ops_group1);
#line 614
    ldv_state_variable_16 = 1;
  } else {

  }
#line 617
  if (ldv_state_variable_16 == 3) {
#line 619
    cfg80211_rtw_dump_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg19,
                              ldvarg18, rtw_cfg80211_ops_group1);
#line 621
    ldv_state_variable_16 = 3;
  } else {

  }
#line 624
  if (ldv_state_variable_16 == 2) {
#line 626
    cfg80211_rtw_dump_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg19,
                              ldvarg18, rtw_cfg80211_ops_group1);
#line 628
    ldv_state_variable_16 = 2;
  } else {

  }
#line 631
  goto ldv_54016;
  case 13: ;
#line 634
  if (ldv_state_variable_16 == 1) {
#line 636
    cfg80211_rtw_mgmt_frame_register(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0,
                                     (int )ldvarg17, (int )ldvarg16);
#line 638
    ldv_state_variable_16 = 1;
  } else {

  }
#line 641
  if (ldv_state_variable_16 == 3) {
#line 643
    cfg80211_rtw_mgmt_frame_register(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0,
                                     (int )ldvarg17, (int )ldvarg16);
#line 645
    ldv_state_variable_16 = 3;
  } else {

  }
#line 648
  if (ldv_state_variable_16 == 2) {
#line 650
    cfg80211_rtw_mgmt_frame_register(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0,
                                     (int )ldvarg17, (int )ldvarg16);
#line 652
    ldv_state_variable_16 = 2;
  } else {

  }
#line 655
  goto ldv_54016;
  case 14: ;
#line 658
  if (ldv_state_variable_16 == 1) {
#line 660
    cfg80211_rtw_start_ap(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg15);
#line 662
    ldv_state_variable_16 = 1;
  } else {

  }
#line 665
  if (ldv_state_variable_16 == 3) {
#line 667
    cfg80211_rtw_start_ap(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg15);
#line 669
    ldv_state_variable_16 = 3;
  } else {

  }
#line 672
  if (ldv_state_variable_16 == 2) {
#line 674
    cfg80211_rtw_start_ap(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg15);
#line 676
    ldv_state_variable_16 = 2;
  } else {

  }
#line 679
  goto ldv_54016;
  case 15: ;
#line 682
  if (ldv_state_variable_16 == 1) {
#line 684
    cfg80211_rtw_set_txpower(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg14,
                             ldvarg13);
#line 686
    ldv_state_variable_16 = 1;
  } else {

  }
#line 689
  if (ldv_state_variable_16 == 3) {
#line 691
    cfg80211_rtw_set_txpower(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg14,
                             ldvarg13);
#line 693
    ldv_state_variable_16 = 3;
  } else {

  }
#line 696
  if (ldv_state_variable_16 == 2) {
#line 698
    cfg80211_rtw_set_txpower(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg14,
                             ldvarg13);
#line 700
    ldv_state_variable_16 = 2;
  } else {

  }
#line 703
  goto ldv_54016;
  case 16: ;
#line 706
  if (ldv_state_variable_16 == 2) {
#line 708
    ldv_retval_3 = cfg80211_rtw_connect(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                        ldvarg12);
#line 710
    if (ldv_retval_3 == 0) {
#line 711
      ldv_state_variable_16 = 3;
    } else {

    }
  } else {

  }
#line 715
  goto ldv_54016;
  case 17: ;
#line 718
  if (ldv_state_variable_16 == 1) {
#line 720
    cfg80211_rtw_flush_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
#line 722
    ldv_state_variable_16 = 1;
  } else {

  }
#line 725
  if (ldv_state_variable_16 == 3) {
#line 727
    cfg80211_rtw_flush_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
#line 729
    ldv_state_variable_16 = 3;
  } else {

  }
#line 732
  if (ldv_state_variable_16 == 2) {
#line 734
    cfg80211_rtw_flush_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
#line 736
    ldv_state_variable_16 = 2;
  } else {

  }
#line 739
  goto ldv_54016;
  case 18: ;
#line 742
  if (ldv_state_variable_16 == 1) {
#line 744
    cfg80211_rtw_del_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg11);
#line 746
    ldv_state_variable_16 = 1;
  } else {

  }
#line 749
  if (ldv_state_variable_16 == 3) {
#line 751
    cfg80211_rtw_del_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg11);
#line 753
    ldv_state_variable_16 = 3;
  } else {

  }
#line 756
  if (ldv_state_variable_16 == 2) {
#line 758
    cfg80211_rtw_del_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg11);
#line 760
    ldv_state_variable_16 = 2;
  } else {

  }
#line 763
  goto ldv_54016;
  case 19: ;
#line 766
  if (ldv_state_variable_16 == 1) {
#line 768
    cfg80211_rtw_get_txpower(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg10);
#line 770
    ldv_state_variable_16 = 1;
  } else {

  }
#line 773
  if (ldv_state_variable_16 == 3) {
#line 775
    cfg80211_rtw_get_txpower(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg10);
#line 777
    ldv_state_variable_16 = 3;
  } else {

  }
#line 780
  if (ldv_state_variable_16 == 2) {
#line 782
    cfg80211_rtw_get_txpower(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg10);
#line 784
    ldv_state_variable_16 = 2;
  } else {

  }
#line 787
  goto ldv_54016;
  case 20: ;
#line 790
  if (ldv_state_variable_16 == 1) {
#line 792
    cfg80211_rtw_leave_ibss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
#line 794
    ldv_state_variable_16 = 1;
  } else {

  }
#line 797
  if (ldv_state_variable_16 == 3) {
#line 799
    cfg80211_rtw_leave_ibss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
#line 801
    ldv_state_variable_16 = 3;
  } else {

  }
#line 804
  if (ldv_state_variable_16 == 2) {
#line 806
    cfg80211_rtw_leave_ibss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
#line 808
    ldv_state_variable_16 = 2;
  } else {

  }
#line 811
  goto ldv_54016;
  case 21: ;
#line 814
  if (ldv_state_variable_16 == 1) {
#line 816
    cfg80211_rtw_get_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg9,
                             rtw_cfg80211_ops_group1);
#line 818
    ldv_state_variable_16 = 1;
  } else {

  }
#line 821
  if (ldv_state_variable_16 == 3) {
#line 823
    cfg80211_rtw_get_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg9,
                             rtw_cfg80211_ops_group1);
#line 825
    ldv_state_variable_16 = 3;
  } else {

  }
#line 828
  if (ldv_state_variable_16 == 2) {
#line 830
    cfg80211_rtw_get_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg9,
                             rtw_cfg80211_ops_group1);
#line 832
    ldv_state_variable_16 = 2;
  } else {

  }
#line 835
  goto ldv_54016;
  case 22: ;
#line 838
  if (ldv_state_variable_16 == 1) {
#line 840
    cfg80211_rtw_change_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                (u8 const   *)ldvarg8, rtw_cfg80211_ops_group4);
#line 842
    ldv_state_variable_16 = 1;
  } else {

  }
#line 845
  if (ldv_state_variable_16 == 3) {
#line 847
    cfg80211_rtw_change_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                (u8 const   *)ldvarg8, rtw_cfg80211_ops_group4);
#line 849
    ldv_state_variable_16 = 3;
  } else {

  }
#line 852
  if (ldv_state_variable_16 == 2) {
#line 854
    cfg80211_rtw_change_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                (u8 const   *)ldvarg8, rtw_cfg80211_ops_group4);
#line 856
    ldv_state_variable_16 = 2;
  } else {

  }
#line 859
  goto ldv_54016;
  case 23: ;
#line 862
  if (ldv_state_variable_16 == 1) {
#line 864
    cfg80211_rtw_set_wiphy_params(rtw_cfg80211_ops_group3, ldvarg7);
#line 866
    ldv_state_variable_16 = 1;
  } else {

  }
#line 869
  if (ldv_state_variable_16 == 3) {
#line 871
    cfg80211_rtw_set_wiphy_params(rtw_cfg80211_ops_group3, ldvarg7);
#line 873
    ldv_state_variable_16 = 3;
  } else {

  }
#line 876
  if (ldv_state_variable_16 == 2) {
#line 878
    cfg80211_rtw_set_wiphy_params(rtw_cfg80211_ops_group3, ldvarg7);
#line 880
    ldv_state_variable_16 = 2;
  } else {

  }
#line 883
  goto ldv_54016;
  case 24: ;
#line 886
  if (ldv_state_variable_16 == 1) {
#line 888
    cfg80211_rtw_mgmt_tx(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg6,
                         ldvarg5);
#line 890
    ldv_state_variable_16 = 1;
  } else {

  }
#line 893
  if (ldv_state_variable_16 == 3) {
#line 895
    cfg80211_rtw_mgmt_tx(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg6,
                         ldvarg5);
#line 897
    ldv_state_variable_16 = 3;
  } else {

  }
#line 900
  if (ldv_state_variable_16 == 2) {
#line 902
    cfg80211_rtw_mgmt_tx(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg6,
                         ldvarg5);
#line 904
    ldv_state_variable_16 = 2;
  } else {

  }
#line 907
  goto ldv_54016;
  case 25: ;
#line 910
  if (ldv_state_variable_16 == 3) {
#line 912
    cfg80211_rtw_disconnect(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg4);
#line 913
    ldv_state_variable_16 = 2;
  } else {

  }
#line 916
  goto ldv_54016;
  case 26: ;
#line 919
  if (ldv_state_variable_16 == 1) {
#line 921
    cfg80211_rtw_set_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group2);
#line 923
    ldv_state_variable_16 = 1;
  } else {

  }
#line 926
  if (ldv_state_variable_16 == 3) {
#line 928
    cfg80211_rtw_set_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group2);
#line 930
    ldv_state_variable_16 = 3;
  } else {

  }
#line 933
  if (ldv_state_variable_16 == 2) {
#line 935
    cfg80211_rtw_set_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group2);
#line 937
    ldv_state_variable_16 = 2;
  } else {

  }
#line 940
  goto ldv_54016;
  case 27: ;
#line 943
  if (ldv_state_variable_16 == 1) {
#line 945
    cfg80211_rtw_join_ibss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg3);
#line 947
    ldv_state_variable_16 = 1;
  } else {

  }
#line 950
  if (ldv_state_variable_16 == 3) {
#line 952
    cfg80211_rtw_join_ibss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg3);
#line 954
    ldv_state_variable_16 = 3;
  } else {

  }
#line 957
  if (ldv_state_variable_16 == 2) {
#line 959
    cfg80211_rtw_join_ibss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg3);
#line 961
    ldv_state_variable_16 = 2;
  } else {

  }
#line 964
  goto ldv_54016;
  case 28: ;
#line 967
  if (ldv_state_variable_16 == 1) {
#line 969
    cfg80211_rtw_change_bss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg2);
#line 971
    ldv_state_variable_16 = 1;
  } else {

  }
#line 974
  if (ldv_state_variable_16 == 3) {
#line 976
    cfg80211_rtw_change_bss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg2);
#line 978
    ldv_state_variable_16 = 3;
  } else {

  }
#line 981
  if (ldv_state_variable_16 == 2) {
#line 983
    cfg80211_rtw_change_bss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg2);
#line 985
    ldv_state_variable_16 = 2;
  } else {

  }
#line 988
  goto ldv_54016;
  case 29: ;
#line 991
  if (ldv_state_variable_16 == 1) {
#line 993
    cfg80211_rtw_stop_ap(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
#line 995
    ldv_state_variable_16 = 1;
  } else {

  }
#line 998
  if (ldv_state_variable_16 == 3) {
#line 1000
    cfg80211_rtw_stop_ap(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
#line 1002
    ldv_state_variable_16 = 3;
  } else {

  }
#line 1005
  if (ldv_state_variable_16 == 2) {
#line 1007
    cfg80211_rtw_stop_ap(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
#line 1009
    ldv_state_variable_16 = 2;
  } else {

  }
#line 1012
  goto ldv_54016;
  case 30: ;
#line 1015
  if (ldv_state_variable_16 == 2) {
#line 1017
    ldv_release_16();
#line 1018
    ldv_state_variable_16 = 1;
#line 1019
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1022
  goto ldv_54016;
  case 31: ;
#line 1025
  if (ldv_state_variable_16 == 1) {
#line 1027
    ldv_bind_16();
#line 1028
    ldv_state_variable_16 = 2;
#line 1029
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1032
  goto ldv_54016;
  default: 
#line 1033
  ldv_stop();
  }
  ldv_54016: ;
#line 1037
  return;
}
}
#line 1039 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void ldv_main_exported_17(void) 
{ 
  void *ldvarg0 ;
  void *tmp ;
  struct sk_buff *ldvarg1 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1040
  tmp = ldv_init_zalloc(1UL);
#line 1040
  ldvarg0 = tmp;
#line 1041
  tmp___0 = ldv_init_zalloc(232UL);
#line 1041
  ldvarg1 = (struct sk_buff *)tmp___0;
#line 1043
  tmp___1 = __VERIFIER_nondet_int();
#line 1043
  switch (tmp___1) {
  case 0: ;
#line 1046
  if (ldv_state_variable_17 == 3) {
#line 1048
    rtw_cfg80211_monitor_if_close(rtw_cfg80211_monitor_if_ops_group1);
#line 1049
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1052
  goto ldv_54055;
  case 1: ;
#line 1055
  if (ldv_state_variable_17 == 2) {
#line 1057
    ldv_retval_1 = rtw_cfg80211_monitor_if_open(rtw_cfg80211_monitor_if_ops_group1);
#line 1058
    if (ldv_retval_1 == 0) {
#line 1059
      ldv_state_variable_17 = 3;
    } else {

    }
  } else {

  }
#line 1063
  goto ldv_54055;
  case 2: ;
#line 1066
  if (ldv_state_variable_17 == 3) {
#line 1068
    rtw_cfg80211_monitor_if_xmit_entry(ldvarg1, rtw_cfg80211_monitor_if_ops_group1);
#line 1070
    ldv_state_variable_17 = 3;
  } else {

  }
#line 1073
  goto ldv_54055;
  case 3: ;
#line 1076
  if (ldv_state_variable_17 == 1) {
#line 1078
    rtw_cfg80211_monitor_if_set_mac_address(rtw_cfg80211_monitor_if_ops_group1, ldvarg0);
#line 1080
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1083
  if (ldv_state_variable_17 == 3) {
#line 1085
    rtw_cfg80211_monitor_if_set_mac_address(rtw_cfg80211_monitor_if_ops_group1, ldvarg0);
#line 1087
    ldv_state_variable_17 = 3;
  } else {

  }
#line 1090
  if (ldv_state_variable_17 == 2) {
#line 1092
    rtw_cfg80211_monitor_if_set_mac_address(rtw_cfg80211_monitor_if_ops_group1, ldvarg0);
#line 1094
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1097
  goto ldv_54055;
  case 4: ;
#line 1100
  if (ldv_state_variable_17 == 1) {
#line 1102
    ldv_retval_0 = ldv_ndo_init_17();
#line 1103
    if (ldv_retval_0 == 0) {
#line 1104
      ldv_state_variable_17 = 2;
#line 1105
      usb_counter = usb_counter + 1;
#line 1106
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1110
  goto ldv_54055;
  case 5: ;
#line 1113
  if (ldv_state_variable_17 == 2) {
#line 1115
    ldv_ndo_uninit_17();
#line 1116
    ldv_state_variable_17 = 1;
#line 1117
    usb_counter = usb_counter - 1;
#line 1118
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1121
  goto ldv_54055;
  default: 
#line 1122
  ldv_stop();
  }
  ldv_54055: ;
#line 1126
  return;
}
}
#line 1127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
#line 1130
  tmp = ldv_err_ptr(error);
#line 1130
  return (tmp);
}
}
#line 1151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
bool ldv_queue_work_on_621(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1155
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1155
  ldv_func_res = tmp;
#line 1157
  activate_work_2(ldv_func_arg3, 2);
#line 1159
  return (ldv_func_res);
}
}
#line 1162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
bool ldv_queue_delayed_work_on_622(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1166
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1166
  ldv_func_res = tmp;
#line 1168
  activate_work_2(& ldv_func_arg3->work, 2);
#line 1170
  return (ldv_func_res);
}
}
#line 1173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
bool ldv_queue_work_on_623(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1177
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1177
  ldv_func_res = tmp;
#line 1179
  activate_work_2(ldv_func_arg3, 2);
#line 1181
  return (ldv_func_res);
}
}
#line 1184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void ldv_flush_workqueue_624(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1187
  flush_workqueue(ldv_func_arg1);
#line 1189
  call_and_disable_all_2(2);
#line 1190
  return;
}
}
#line 1192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
bool ldv_queue_delayed_work_on_625(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1196
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1196
  ldv_func_res = tmp;
#line 1198
  activate_work_2(& ldv_func_arg3->work, 2);
#line 1200
  return (ldv_func_res);
}
}
#line 1203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void ldv_free_netdev_626(struct net_device *dev ) 
{ 


  {
#line 1206
  free_netdev(dev);
#line 1208
  ldv_state_variable_17 = 0;
#line 1209
  return;
}
}
#line 1211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void ldv_unregister_netdev_627(struct net_device *dev ) 
{ 


  {
#line 1214
  unregister_netdev(dev);
#line 1216
  ldv_state_variable_17 = 0;
#line 1217
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_639(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_641(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_640(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_643(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_642(struct workqueue_struct *ldv_func_arg1 ) ;
#line 3049 "include/linux/netdevice.h"
extern void netif_carrier_off(struct net_device * ) ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/mlme_linux.c"
static struct rt_pmkid_list backupPMKIDList[16U]  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/mlme_linux.c"
void rtw_reset_securitypriv23a(struct rtw_adapter *adapter ) 
{ 
  u8 backupPMKIDIndex ;
  u8 backupTKIPCountermeasure ;
  unsigned long backupTKIPcountermeasure_time ;
  struct security_priv *psec_priv ;

  {
#line 26
  backupPMKIDIndex = 0U;
#line 27
  backupTKIPCountermeasure = 0U;
#line 28
  backupTKIPcountermeasure_time = 0UL;
#line 30
  if (adapter->securitypriv.dot11AuthAlgrthm == 2U) {
#line 38
    memcpy((void *)(& backupPMKIDList), (void const   *)(& adapter->securitypriv.PMKIDList),
             1152UL);
#line 40
    backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
#line 41
    backupTKIPCountermeasure = adapter->securitypriv.btkip_countermeasure;
#line 42
    backupTKIPcountermeasure_time = adapter->securitypriv.btkip_countermeasure_time;
#line 44
    memset((void *)(& adapter->securitypriv), 0, 4272UL);
#line 49
    memcpy((void *)(& adapter->securitypriv.PMKIDList), (void const   *)(& backupPMKIDList),
             1152UL);
#line 51
    adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
#line 52
    adapter->securitypriv.btkip_countermeasure = backupTKIPCountermeasure;
#line 53
    adapter->securitypriv.btkip_countermeasure_time = backupTKIPcountermeasure_time;
#line 55
    adapter->securitypriv.ndisauthtype = 0U;
#line 56
    adapter->securitypriv.ndisencryptstatus = 1U;
  } else {
#line 58
    psec_priv = & adapter->securitypriv;
#line 61
    psec_priv->dot11AuthAlgrthm = 0U;
#line 62
    psec_priv->dot11PrivacyAlgrthm = 0U;
#line 63
    psec_priv->dot11PrivacyKeyIndex = 0U;
#line 65
    psec_priv->dot118021XGrpPrivacy = 0U;
#line 66
    psec_priv->dot118021XGrpKeyid = 1U;
#line 68
    psec_priv->ndisauthtype = 0U;
#line 69
    psec_priv->ndisencryptstatus = 1U;
  }
#line 71
  return;
}
}
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/mlme_linux.c"
void rtw_os_indicate_disconnect23a(struct rtw_adapter *adapter ) 
{ 


  {
#line 76
  netif_carrier_off(adapter->pnetdev);
#line 78
  rtw_cfg80211_indicate_disconnect(adapter);
#line 80
  rtw_reset_securitypriv23a(adapter);
#line 81
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
bool ldv_queue_work_on_639(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
bool ldv_queue_delayed_work_on_640(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
bool ldv_queue_work_on_641(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
void ldv_flush_workqueue_642(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
bool ldv_queue_delayed_work_on_643(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 405 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 173 "include/linux/timer.h"
int ldv_mod_timer_658(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 177
int ldv_mod_timer_667(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 181
int ldv_mod_timer_668(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 185
int ldv_mod_timer_669(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 189
int ldv_mod_timer_670(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 232
int ldv_del_timer_sync_659(struct timer_list *ldv_func_arg1 ) ;
#line 236
int ldv_del_timer_sync_660(struct timer_list *ldv_func_arg1 ) ;
#line 240
int ldv_del_timer_sync_661(struct timer_list *ldv_func_arg1 ) ;
#line 244
int ldv_del_timer_sync_662(struct timer_list *ldv_func_arg1 ) ;
#line 248
int ldv_del_timer_sync_663(struct timer_list *ldv_func_arg1 ) ;
#line 252
int ldv_del_timer_sync_664(struct timer_list *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_653(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_655(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_654(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_657(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_656(struct workqueue_struct *ldv_func_arg1 ) ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
struct net_device *rtw_netdev_ops_group1 ;
#line 92
int ldv_state_variable_15 ;
#line 178
void ldv_net_device_ops_15(void) ;
#line 1901 "include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1903
  return ((unsigned char *)skb->head + (unsigned long )skb->network_header);
}
}
#line 2181 "include/linux/netdevice.h"
extern int dev_alloc_name(struct net_device * , char const   * ) ;
#line 2205
void ldv_free_netdev_666(struct net_device *dev ) ;
#line 2209
void ldv_free_netdev_671(struct net_device *dev ) ;
#line 2515 "include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue ) 
{ 


  {
#line 2517
  clear_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2518
  return;
}
}
#line 2531 "include/linux/netdevice.h"
__inline static void netif_tx_start_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2535
  i = 0U;
#line 2535
  goto ldv_42870;
  ldv_42869: 
#line 2536
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2536
  txq = tmp;
#line 2537
  netif_tx_start_queue(txq);
#line 2535
  i = i + 1U;
  ldv_42870: ;
#line 2535
  if (dev->num_tx_queues > i) {
#line 2537
    goto ldv_42869;
  } else {

  }

#line 2542
  return;
}
}
#line 2555 "include/linux/netdevice.h"
__inline static void netif_tx_wake_all_queues___0(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2559
  i = 0U;
#line 2559
  goto ldv_42883;
  ldv_42882: 
#line 2560
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2560
  txq = tmp;
#line 2561
  netif_tx_wake_queue(txq);
#line 2559
  i = i + 1U;
  ldv_42883: ;
#line 2559
  if (dev->num_tx_queues > i) {
#line 2561
    goto ldv_42882;
  } else {

  }

#line 2566
  return;
}
}
#line 3352
extern int register_netdev(struct net_device * ) ;
#line 3355
int ldv_register_netdev_665(struct net_device *dev ) ;
#line 23 "include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 25
  tmp = skb_network_header(skb);
#line 25
  return ((struct iphdr *)tmp);
}
}
#line 36 "drivers/staging/rtl8723au/include/xmit_osdep.h"
int netdev_open23a(struct net_device *pnetdev ) ;
#line 96 "drivers/staging/rtl8723au/include/hal_intf.h"
int pm_netdev_open23a(struct net_device *pnetdev , u8 bnormal ) ;
#line 22 "drivers/staging/rtl8723au/include/osdep_intf.h"
int rtw_init_drv_sw23a(struct rtw_adapter *padapter ) ;
#line 23
int rtw_free_drv_sw23a(struct rtw_adapter *padapter ) ;
#line 24
int rtw_reset_drv_sw23a(struct rtw_adapter *padapter ) ;
#line 28
int rtw_init_netdev23a_name23a(struct net_device *pnetdev , char const   *ifname___0 ) ;
#line 29
struct net_device *rtw_init_netdev23a(struct rtw_adapter *old_padapter ) ;
#line 31
u16 rtw_recv_select_queue23a(struct sk_buff *skb ) ;
#line 33
void rtw_ips_dev_unload23a(struct rtw_adapter *padapter ) ;
#line 38
int rtw_drv_register_netdev(struct rtw_adapter *if1 ) ;
#line 43
void rtl8723a_usb_intf_stop(struct rtw_adapter *padapter ) ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_chip_version  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_rfintfs  =    2;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_debug  =    1;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_channel  =    1;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_wireless_mode  =    11;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_vrtl_carrier_sense  =    2;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_vcs_type  =    1;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_rts_thresh  =    2347;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_frag_thresh  =    2346;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_preamble  =    1;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_scan_mode  =    1;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_adhoc_tx_pwr  =    1;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_soft_ap  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_power_mgnt  =    1;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_ips_mode  =    1;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_smart_ps  =    2;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_long_retry_lmt  =    7;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_short_retry_lmt  =    7;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_busy_thresh  =    40;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_ack_policy  =    0;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_acm_method  ;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_wmm_enable  =    1;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_uapsd_enable  ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_ht_enable  =    1;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_cbw40_enable  =    3;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_ampdu_enable  =    1;
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_rx_stbc  =    1;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_ampdu_amsdu  ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_lowrate_two_xmit  =    1;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_rf_config  =    5;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_low_power  ;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_wifi_spec  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_channel_plan  =    66;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_btcoex_enable  =    1;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_bt_iso  =    2;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_bt_sco  =    3;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_bt_ampdu  =    1;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_AcceptAddbaReq  =    1;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_antdiv_cfg  =    2;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_antdiv_type  ;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_hwpdn_mode  =    2;
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_hwpwrp_detect  ;
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_hw_wps_pbc  =    1;
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_80211d  ;
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_regulatory_id  =    255;
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static char *ifname  =    (char *)"wlan%d";
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static char *if2name  =    (char *)"wlan%d";
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static uint rtw_max_roaming_times  =    2U;
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static uint rtw_notch_filter  ;
#line 173
static int netdev_close(struct net_device *pnetdev ) ;
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static void loadparam(struct rtw_adapter *padapter , struct net_device *pnetdev ) 
{ 
  struct registry_priv *registry_par ;

  {
#line 177
  registry_par = & padapter->registrypriv;
#line 179
  GlobalDebugLevel23A = (u32 )rtw_debug;
#line 180
  registry_par->chip_version = (unsigned char )rtw_chip_version;
#line 181
  registry_par->rfintfs = (unsigned char )rtw_rfintfs;
#line 182
  memcpy((void *)(& registry_par->ssid.ssid), (void const   *)"ANY", 3UL);
#line 183
  registry_par->ssid.ssid_len = 3U;
#line 184
  registry_par->channel = (unsigned char )rtw_channel;
#line 185
  registry_par->wireless_mode = (unsigned char )rtw_wireless_mode;
#line 186
  registry_par->vrtl_carrier_sense = (unsigned char )rtw_vrtl_carrier_sense;
#line 187
  registry_par->vcs_type = (unsigned char )rtw_vcs_type;
#line 188
  registry_par->rts_thresh = (unsigned short )rtw_rts_thresh;
#line 189
  registry_par->frag_thresh = (unsigned short )rtw_frag_thresh;
#line 190
  registry_par->preamble = (unsigned char )rtw_preamble;
#line 191
  registry_par->scan_mode = (unsigned char )rtw_scan_mode;
#line 192
  registry_par->adhoc_tx_pwr = (unsigned char )rtw_adhoc_tx_pwr;
#line 193
  registry_par->soft_ap = (unsigned char )rtw_soft_ap;
#line 194
  registry_par->smart_ps = (unsigned char )rtw_smart_ps;
#line 195
  registry_par->power_mgnt = (unsigned char )rtw_power_mgnt;
#line 196
  registry_par->ips_mode = (unsigned char )rtw_ips_mode;
#line 197
  registry_par->long_retry_lmt = (unsigned char )rtw_long_retry_lmt;
#line 198
  registry_par->short_retry_lmt = (unsigned char )rtw_short_retry_lmt;
#line 199
  registry_par->busy_thresh = (unsigned short )rtw_busy_thresh;
#line 200
  registry_par->ack_policy = (unsigned char )rtw_ack_policy;
#line 201
  registry_par->acm_method = (unsigned char )rtw_acm_method;
#line 203
  registry_par->wmm_enable = (unsigned char )rtw_wmm_enable;
#line 204
  registry_par->uapsd_enable = (unsigned char )rtw_uapsd_enable;
#line 205
  registry_par->ht_enable = (unsigned char )rtw_ht_enable;
#line 206
  registry_par->cbw40_enable = (unsigned char )rtw_cbw40_enable;
#line 207
  registry_par->ampdu_enable = (unsigned char )rtw_ampdu_enable;
#line 208
  registry_par->rx_stbc = (unsigned char )rtw_rx_stbc;
#line 209
  registry_par->ampdu_amsdu = (unsigned char )rtw_ampdu_amsdu;
#line 210
  registry_par->lowrate_two_xmit = (unsigned char )rtw_lowrate_two_xmit;
#line 211
  registry_par->rf_config = (unsigned char )rtw_rf_config;
#line 212
  registry_par->low_power = (unsigned char )rtw_low_power;
#line 213
  registry_par->wifi_spec = (unsigned char )rtw_wifi_spec;
#line 214
  registry_par->channel_plan = (unsigned char )rtw_channel_plan;
#line 216
  registry_par->btcoex = (unsigned char )rtw_btcoex_enable;
#line 217
  registry_par->bt_iso = (unsigned char )rtw_bt_iso;
#line 218
  registry_par->bt_sco = (unsigned char )rtw_bt_sco;
#line 219
  registry_par->bt_ampdu = (unsigned char )rtw_bt_ampdu;
#line 221
  registry_par->bAcceptAddbaReq = (unsigned int )((unsigned char )rtw_AcceptAddbaReq) != 0U;
#line 222
  registry_par->antdiv_cfg = (unsigned char )rtw_antdiv_cfg;
#line 223
  registry_par->antdiv_type = (unsigned char )rtw_antdiv_type;
#line 226
  registry_par->hwpdn_mode = (unsigned char )rtw_hwpdn_mode;
#line 228
  registry_par->hwpwrp_detect = (unsigned char )rtw_hwpwrp_detect;
#line 229
  registry_par->hw_wps_pbc = (unsigned char )rtw_hw_wps_pbc;
#line 230
  registry_par->max_roaming_times = (unsigned char )rtw_max_roaming_times;
#line 231
  registry_par->enable80211d = (unsigned char )rtw_80211d;
#line 232
  snprintf((char *)(& registry_par->ifname), 16UL, "%s", ifname);
#line 233
  snprintf((char *)(& registry_par->if2name), 16UL, "%s", if2name);
#line 234
  registry_par->notch_filter = (unsigned char )rtw_notch_filter;
#line 235
  registry_par->regulatory_tid = (unsigned char )rtw_regulatory_id;
#line 236
  return;
}
}
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_net_set_mac_address(struct net_device *pnetdev , void *p ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct sockaddr *addr ;

  {
#line 240
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 240
  padapter = (struct rtw_adapter *)tmp;
#line 241
  addr = (struct sockaddr *)p;
#line 243
  if (padapter->bup == 0) {
#line 244
    ether_addr_copy((u8 *)(& padapter->eeprompriv.mac_addr), (u8 const   *)(& addr->sa_data));
  } else {

  }
#line 245
  return (0);
}
}
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static struct net_device_stats *rtw_net_get_stats(struct net_device *pnetdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct xmit_priv *pxmitpriv ;
  struct recv_priv *precvpriv ;

  {
#line 250
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 250
  padapter = (struct rtw_adapter *)tmp;
#line 251
  pxmitpriv = & padapter->xmitpriv;
#line 252
  precvpriv = & padapter->recvpriv;
#line 254
  padapter->stats.tx_packets = (unsigned long )pxmitpriv->tx_pkts;
#line 255
  padapter->stats.rx_packets = (unsigned long )precvpriv->rx_pkts;
#line 256
  padapter->stats.tx_dropped = (unsigned long )pxmitpriv->tx_drop;
#line 257
  padapter->stats.rx_dropped = (unsigned long )precvpriv->rx_drop;
#line 258
  padapter->stats.tx_bytes = (unsigned long )pxmitpriv->tx_bytes;
#line 259
  padapter->stats.rx_bytes = (unsigned long )precvpriv->rx_bytes;
#line 261
  return (& padapter->stats);
}
}
#line 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static u16 const   rtw_1d_to_queue[8U]  = 
#line 272
  {      2U,      3U,      3U,      2U, 
        1U,      1U,      0U,      0U};
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static u32 rtw_classify8021d(struct sk_buff *skb ) 
{ 
  u32 dscp ;
  struct iphdr *tmp ;

  {
#line 284
  if (skb->priority > 255U && skb->priority <= 263U) {
#line 285
    return (skb->priority - 256U);
  } else {

  }
#line 286
  switch ((int )skb->protocol) {
  case 8: 
#line 288
  tmp = ip_hdr((struct sk_buff  const  *)skb);
#line 288
  dscp = (u32 )tmp->tos & 252U;
#line 289
  goto ldv_56478;
  default: ;
#line 291
  return (0U);
  }
  ldv_56478: ;
#line 293
  return (dscp >> 5);
}
}
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static u16 rtw_select_queue(struct net_device *dev , struct sk_buff *skb , void *accel_priv ,
                            u16 (*fallback)(struct net_device * , struct sk_buff * ) ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  u8 tmp___0 ;

  {
#line 300
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 300
  padapter = (struct rtw_adapter *)tmp;
#line 301
  pmlmepriv = & padapter->mlmepriv;
#line 303
  skb->priority = rtw_classify8021d(skb);
#line 305
  if ((unsigned int )pmlmepriv->acm_mask != 0U) {
#line 306
    tmp___0 = qos_acm23a((int )pmlmepriv->acm_mask, (int )((u8 )skb->priority));
#line 306
    skb->priority = (__u32 )tmp___0;
  } else {

  }
#line 307
  return ((u16 )rtw_1d_to_queue[skb->priority]);
}
}
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
u16 rtw_recv_select_queue23a(struct sk_buff *skb ) 
{ 
  struct iphdr *piphdr ;
  struct ethhdr *eth ;
  unsigned int dscp ;
  u16 eth_type ;
  u16 tmp ;
  u32 priority ;
  u8 *pdata ;

  {
#line 313
  eth = (struct ethhdr *)skb->data;
#line 315
  tmp = get_unaligned_be16((void const   *)(& eth->h_proto));
#line 315
  eth_type = tmp;
#line 317
  pdata = skb->data;
#line 319
  switch ((int )eth_type) {
  case 2048: 
#line 321
  piphdr = (struct iphdr *)pdata + 14U;
#line 322
  dscp = (unsigned int )piphdr->tos & 252U;
#line 323
  priority = dscp >> 5;
#line 324
  goto ldv_56498;
  default: 
#line 326
  priority = 0U;
  }
  ldv_56498: ;
#line 328
  return ((u16 )rtw_1d_to_queue[priority]);
}
}
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static struct net_device_ops  const  rtw_netdev_ops  = 
#line 331
     {0, 0, & netdev_open23a, & netdev_close, (netdev_tx_t (*)(struct sk_buff * , struct net_device * ))(& rtw_xmit23a_entry23a),
    & rtw_select_queue, 0, 0, & rtw_net_set_mac_address, 0, 0, 0, 0, 0, 0, 0, & rtw_net_get_stats,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
int rtw_init_netdev23a_name23a(struct net_device *pnetdev , char const   *ifname___0 ) 
{ 
  int tmp ;

  {
#line 342
  tmp = dev_alloc_name(pnetdev, ifname___0);
#line 342
  if (tmp < 0) {
#line 343
    if (GlobalDebugLevel23A > 3U) {
#line 343
      rt_trace(2048, 4, "dev_alloc_name, fail!\n");
    } else {

    }
  } else {

  }
#line 346
  netif_carrier_off(pnetdev);
#line 347
  return (0);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static struct device_type  const  wlan_type  =    {"wlan", 0, 0, 0, 0, 0};
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
struct net_device *rtw_init_netdev23a(struct rtw_adapter *old_padapter ) 
{ 
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  void *tmp ;

  {
#line 359
  if (GlobalDebugLevel23A > 6U) {
#line 359
    rt_trace(2048, 7, "+init_net_dev\n");
  } else {

  }
#line 361
  pnetdev = alloc_etherdev_mqs(16776, 4U, 4U);
#line 362
  if ((unsigned long )pnetdev == (unsigned long )((struct net_device *)0)) {
#line 363
    return ((struct net_device *)0);
  } else {

  }
#line 365
  pnetdev->dev.type = & wlan_type;
#line 366
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 366
  padapter = (struct rtw_adapter *)tmp;
#line 367
  padapter->pnetdev = pnetdev;
#line 369
  if (GlobalDebugLevel23A > 3U) {
#line 369
    printk("\016RTL8723AU: register rtw_netdev_ops to netdev_ops\n");
  } else {

  }
#line 370
  pnetdev->netdev_ops = & rtw_netdev_ops;
#line 372
  pnetdev->watchdog_timeo = 750;
#line 374
  loadparam(padapter, pnetdev);
#line 375
  return (pnetdev);
}
}
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int rtw_init_default_value(struct rtw_adapter *padapter ) 
{ 
  struct registry_priv *pregistrypriv ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;

  {
#line 380
  pregistrypriv = & padapter->registrypriv;
#line 381
  pxmitpriv = & padapter->xmitpriv;
#line 382
  pmlmepriv = & padapter->mlmepriv;
#line 383
  psecuritypriv = & padapter->securitypriv;
#line 386
  pxmitpriv->vcs = pregistrypriv->vcs_type;
#line 388
  pxmitpriv->frag_len = (uint )pregistrypriv->frag_thresh;
#line 391
  pmlmepriv->scan_interval = 30U;
#line 392
  pmlmepriv->scan_mode = 1;
#line 395
  pmlmepriv->htpriv.ampdu_enable = 0;
#line 398
  psecuritypriv->binstallGrpkey = 0U;
#line 401
  psecuritypriv->dot11AuthAlgrthm = 0U;
#line 402
  psecuritypriv->dot11PrivacyAlgrthm = 0U;
#line 404
  psecuritypriv->dot11PrivacyKeyIndex = 0U;
#line 406
  psecuritypriv->dot118021XGrpPrivacy = 0U;
#line 407
  psecuritypriv->dot118021XGrpKeyid = 1U;
#line 409
  psecuritypriv->ndisauthtype = 0U;
#line 410
  psecuritypriv->ndisencryptstatus = 1U;
#line 413
  rtw_init_registrypriv_dev_network23a(padapter);
#line 414
  rtw_update_registrypriv_dev_network23a(padapter);
#line 417
  rtl8723a_init_default_value(padapter);
#line 420
  padapter->bReadPortCancel = 0U;
#line 421
  padapter->bWritePortCancel = 0U;
#line 422
  return (1);
}
}
#line 425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
int rtw_reset_drv_sw23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct pwrctrl_priv *pwrctrlpriv ;
  unsigned long tmp ;

  {
#line 427
  pmlmepriv = & padapter->mlmepriv;
#line 428
  pwrctrlpriv = & padapter->pwrctrlpriv;
#line 431
  rtl8723a_init_default_value(padapter);
#line 432
  padapter->bReadPortCancel = 0U;
#line 433
  padapter->bWritePortCancel = 0U;
#line 434
  pmlmepriv->scan_interval = 30U;
#line 436
  padapter->xmitpriv.tx_pkts = 0ULL;
#line 437
  padapter->recvpriv.rx_pkts = 0ULL;
#line 439
  pmlmepriv->LinkDetectInfo.bBusyTraffic = 0;
#line 441
  _clr_fwstate_(pmlmepriv, 2176);
#line 443
  rtw_sreset_reset_value(padapter);
#line 444
  pwrctrlpriv->pwr_state_check_cnts = 0U;
#line 447
  padapter->mlmeextpriv.sitesurvey_res.state = 0;
#line 449
  tmp = msecs_to_jiffies(padapter->recvpriv.signal_stat_sampling_interval);
#line 449
  ldv_mod_timer_658(& padapter->recvpriv.signal_stat_timer, tmp + (unsigned long )jiffies);
#line 450
  return (1);
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
int rtw_init_drv_sw23a(struct rtw_adapter *padapter ) 
{ 
  int ret8 ;
  int tmp ;
  u32 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 455
  ret8 = 1;
#line 457
  if (GlobalDebugLevel23A > 6U) {
#line 457
    rt_trace(2048, 7, "+rtw_init_drv_sw23a\n");
  } else {

  }
#line 459
  tmp = rtw_init_cmd_priv23a(& padapter->cmdpriv);
#line 459
  if (tmp == 0) {
#line 460
    if (GlobalDebugLevel23A > 3U) {
#line 460
      rt_trace(2048, 4, "Can\'t init cmd_priv\n");
    } else {

    }
#line 462
    ret8 = 0;
#line 463
    goto exit;
  } else {

  }
#line 466
  padapter->cmdpriv.padapter = padapter;
#line 468
  tmp___0 = rtw_init_evt_priv23a(& padapter->evtpriv);
#line 468
  if (tmp___0 == 0U) {
#line 469
    if (GlobalDebugLevel23A > 3U) {
#line 469
      rt_trace(2048, 4, "Can\'t init evt_priv\n");
    } else {

    }
#line 471
    ret8 = 0;
#line 472
    goto exit;
  } else {

  }
#line 475
  tmp___1 = rtw_init_mlme_priv23a(padapter);
#line 475
  if (tmp___1 == 0) {
#line 476
    if (GlobalDebugLevel23A > 3U) {
#line 476
      rt_trace(2048, 4, "Can\'t init mlme_priv\n");
    } else {

    }
#line 478
    ret8 = 0;
#line 479
    goto exit;
  } else {

  }
#line 483
  tmp___2 = init_mlme_ext_priv23a(padapter);
#line 483
  if (tmp___2 == 0) {
#line 484
    if (GlobalDebugLevel23A > 3U) {
#line 484
      rt_trace(2048, 4, "Can\'t init mlme_ext_priv\n");
    } else {

    }
#line 486
    ret8 = 0;
#line 487
    goto exit;
  } else {

  }
#line 490
  tmp___3 = _rtw_init_xmit_priv23a(& padapter->xmitpriv, padapter);
#line 490
  if (tmp___3 == 0) {
#line 491
    if (GlobalDebugLevel23A > 3U) {
#line 491
      printk("\016RTL8723AU: Can\'t _rtw_init_xmit_priv23a\n");
    } else {

    }
#line 492
    ret8 = 0;
#line 493
    goto exit;
  } else {

  }
#line 496
  tmp___4 = _rtw_init_recv_priv23a(& padapter->recvpriv, padapter);
#line 496
  if (tmp___4 == 0) {
#line 497
    if (GlobalDebugLevel23A > 3U) {
#line 497
      printk("\016RTL8723AU: Can\'t _rtw_init_recv_priv23a\n");
    } else {

    }
#line 498
    ret8 = 0;
#line 499
    goto exit;
  } else {

  }
#line 502
  tmp___5 = _rtw_init_sta_priv23a(& padapter->stapriv);
#line 502
  if (tmp___5 == 0) {
#line 503
    if (GlobalDebugLevel23A > 3U) {
#line 503
      printk("\016RTL8723AU: Can\'t _rtw_init_sta_priv23a\n");
    } else {

    }
#line 504
    ret8 = 0;
#line 505
    goto exit;
  } else {

  }
#line 508
  padapter->stapriv.padapter = padapter;
#line 509
  padapter->setband = 0U;
#line 510
  rtw_init_bcmc_stainfo23a(padapter);
#line 512
  rtw_init_pwrctrl_priv23a(padapter);
#line 514
  ret8 = rtw_init_default_value(padapter);
#line 516
  rtl8723a_init_dm_priv(padapter);
#line 518
  rtw_sreset_init(padapter);
  exit: ;
#line 522
  if (GlobalDebugLevel23A > 6U) {
#line 522
    rt_trace(2048, 7, "-rtw_init_drv_sw23a\n");
  } else {

  }
#line 523
  return (ret8);
}
}
#line 526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
void rtw_cancel_all_timer23a(struct rtw_adapter *padapter ) 
{ 


  {
#line 528
  if (GlobalDebugLevel23A > 6U) {
#line 528
    rt_trace(2048, 7, "+rtw_cancel_all_timer23a\n");
  } else {

  }
#line 531
  ldv_del_timer_sync_659(& padapter->mlmepriv.assoc_timer);
#line 532
  if (GlobalDebugLevel23A > 6U) {
#line 532
    rt_trace(2048, 7, "%s:cancel association timer complete!\n", "rtw_cancel_all_timer23a");
  } else {

  }
#line 535
  ldv_del_timer_sync_660(& padapter->mlmepriv.scan_to_timer);
#line 536
  if (GlobalDebugLevel23A > 6U) {
#line 536
    rt_trace(2048, 7, "%s:cancel scan_to_timer!\n", "rtw_cancel_all_timer23a");
  } else {

  }
#line 539
  ldv_del_timer_sync_661(& padapter->mlmepriv.dynamic_chk_timer);
#line 540
  if (GlobalDebugLevel23A > 6U) {
#line 540
    rt_trace(2048, 7, "%s:cancel dynamic_chk_timer!\n", "rtw_cancel_all_timer23a");
  } else {

  }
#line 543
  ldv_del_timer_sync_662(& padapter->pwrctrlpriv.pwr_state_check_timer);
#line 545
  ldv_del_timer_sync_663(& padapter->mlmepriv.set_scan_deny_timer);
#line 546
  rtw_clear_scan_deny(padapter);
#line 547
  if (GlobalDebugLevel23A > 6U) {
#line 547
    rt_trace(2048, 7, "%s:cancel set_scan_deny_timer!\n", "rtw_cancel_all_timer23a");
  } else {

  }
#line 550
  ldv_del_timer_sync_664(& padapter->recvpriv.signal_stat_timer);
#line 551
  return;
}
}
#line 553 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
int rtw_free_drv_sw23a(struct rtw_adapter *padapter ) 
{ 


  {
#line 555
  if (GlobalDebugLevel23A > 6U) {
#line 555
    rt_trace(2048, 7, "==>rtw_free_drv_sw23a\n");
  } else {

  }
#line 557
  free_mlme_ext_priv23a(& padapter->mlmeextpriv);
#line 559
  rtw_free_evt_priv23a(& padapter->evtpriv);
#line 561
  rtw_free_mlme_priv23a(& padapter->mlmepriv);
#line 563
  _rtw_free_xmit_priv23a(& padapter->xmitpriv);
#line 566
  _rtw_free_sta_priv23a(& padapter->stapriv);
#line 568
  _rtw_free_recv_priv23a(& padapter->recvpriv);
#line 570
  rtw_free_pwrctrl_priv(padapter);
#line 572
  kfree((void const   *)padapter->HalData);
#line 573
  padapter->HalData = (void *)0;
#line 575
  if (GlobalDebugLevel23A > 6U) {
#line 575
    rt_trace(2048, 7, "-rtw_free_drv_sw23a\n");
  } else {

  }
#line 576
  return (1);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int _rtw_drv_register_netdev(struct rtw_adapter *padapter , char *name ) 
{ 
  struct net_device *pnetdev ;
  int ret ;
  int tmp ;

  {
#line 581
  pnetdev = padapter->pnetdev;
#line 582
  ret = 1;
#line 585
  rtw_init_netdev23a_name23a(pnetdev, (char const   *)name);
#line 587
  ether_addr_copy(pnetdev->dev_addr, (u8 const   *)(& padapter->eeprompriv.mac_addr));
#line 590
  tmp = ldv_register_netdev_665(pnetdev);
#line 590
  if (tmp != 0) {
#line 591
    if (GlobalDebugLevel23A > 3U) {
#line 591
      printk("\016RTL8723AU: %s(%s): Failed!\n", "_rtw_drv_register_netdev", (char *)(& pnetdev->name));
    } else {

    }
#line 592
    ret = 0;
#line 593
    goto error_register_netdev;
  } else {

  }
#line 595
  if (GlobalDebugLevel23A > 3U) {
#line 595
    printk("\016RTL8723AU: %s, MAC Address (if%d) = %pM\n", "_rtw_drv_register_netdev",
           (int )padapter->iface_id + 1, pnetdev->dev_addr);
  } else {

  }
#line 597
  return (ret);
  error_register_netdev: ;
#line 601
  if ((unsigned int )padapter->iface_id != 0U) {
#line 602
    rtw_free_drv_sw23a(padapter);
#line 604
    ldv_free_netdev_666(pnetdev);
  } else {

  }
#line 606
  return (ret);
}
}
#line 609 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
int rtw_drv_register_netdev(struct rtw_adapter *if1 ) 
{ 
  struct dvobj_priv *dvobj ;
  int i ;
  int status ;
  struct rtw_adapter *padapter ;
  char *name ;

  {
#line 611
  dvobj = if1->dvobj;
#line 612
  status = 1;
#line 614
  if ((unsigned int )dvobj->iface_nums > 3U) {
#line 615
    status = 0;
#line 616
    goto exit;
  } else {

  }
#line 619
  i = 0;
#line 619
  goto ldv_56554;
  ldv_56553: 
#line 620
  padapter = dvobj->padapters[i];
#line 622
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
#line 625
    if ((unsigned int )padapter->iface_id == 0U) {
#line 626
      name = (char *)(& if1->registrypriv.ifname);
    } else
#line 627
    if ((unsigned int )padapter->iface_id == 1U) {
#line 628
      name = (char *)(& if1->registrypriv.if2name);
    } else {
#line 630
      name = (char *)"wlan%d";
    }
#line 631
    status = _rtw_drv_register_netdev(padapter, name);
#line 632
    if (status != 1) {
#line 633
      goto ldv_56552;
    } else {

    }
  } else {

  }
#line 619
  i = i + 1;
  ldv_56554: ;
#line 619
  if ((int )dvobj->iface_nums > i) {
#line 621
    goto ldv_56553;
  } else {

  }
  ldv_56552: ;
  exit: ;
#line 638
  return (status);
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
int netdev_open23a(struct net_device *pnetdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct pwrctrl_priv *pwrctrlpriv ;
  int ret ;
  int status ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
#line 643
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 643
  padapter = (struct rtw_adapter *)tmp;
#line 645
  ret = 0;
#line 648
  if (GlobalDebugLevel23A > 6U) {
#line 648
    rt_trace(2048, 7, "+871x_drv - dev_open\n");
  } else {

  }
#line 649
  if (GlobalDebugLevel23A > 3U) {
#line 649
    printk("\016RTL8723AU: +871x_drv - drv_open, bup =%d\n", padapter->bup);
  } else {

  }
#line 651
  mutex_lock_nested(& (padapter->dvobj)->hw_init_mutex, 0U);
#line 653
  pwrctrlpriv = & padapter->pwrctrlpriv;
#line 655
  if (padapter->bup == 0) {
#line 656
    padapter->bDriverStopped = 0;
#line 657
    padapter->bSurpriseRemoved = 0;
#line 658
    padapter->bCardDisableWOHSM = 0;
#line 660
    status = rtl8723au_hal_init(padapter);
#line 661
    if (status == 0) {
#line 662
      if (GlobalDebugLevel23A > 3U) {
#line 662
        rt_trace(2048, 4, "rtl871x_hal_init(): Can\'t init h/w!\n");
      } else {

      }
#line 664
      goto netdev_open23a_error;
    } else {

    }
#line 667
    if (GlobalDebugLevel23A > 3U) {
#line 667
      printk("\016RTL8723AU: MAC Address = %pM\n", pnetdev->dev_addr);
    } else {

    }
#line 669
    tmp___0 = init_hw_mlme_ext23a(padapter);
#line 669
    if (tmp___0 == 0) {
#line 670
      if (GlobalDebugLevel23A > 3U) {
#line 670
        printk("\016RTL8723AU: can\'t init mlme_ext_priv\n");
      } else {

      }
#line 671
      goto netdev_open23a_error;
    } else {

    }
#line 674
    rtl8723au_inirp_init(padapter);
#line 676
    rtw_cfg80211_init_wiphy(padapter);
#line 678
    padapter->bup = 1;
  } else {

  }
#line 680
  padapter->net_closed = 0;
#line 682
  tmp___1 = msecs_to_jiffies(2000U);
#line 682
  ldv_mod_timer_667(& padapter->mlmepriv.dynamic_chk_timer, tmp___1 + (unsigned long )jiffies);
#line 685
  padapter->pwrctrlpriv.bips_processing = 0U;
#line 686
  tmp___2 = msecs_to_jiffies((unsigned int const   )padapter->pwrctrlpriv.pwr_state_check_interval);
#line 686
  ldv_mod_timer_668(& padapter->pwrctrlpriv.pwr_state_check_timer, tmp___2 + (unsigned long )jiffies);
#line 690
  tmp___3 = rtw_netif_queue_stopped(pnetdev);
#line 690
  if (tmp___3 == 0) {
#line 691
    netif_tx_start_all_queues(pnetdev);
  } else {
#line 693
    netif_tx_wake_all_queues___0(pnetdev);
  }
#line 695
  if (GlobalDebugLevel23A > 6U) {
#line 695
    rt_trace(2048, 7, "-871x_drv - dev_open\n");
  } else {

  }
#line 696
  if (GlobalDebugLevel23A > 3U) {
#line 696
    printk("\016RTL8723AU: -871x_drv - drv_open, bup =%d\n", padapter->bup);
  } else {

  }
  exit: 
#line 698
  mutex_unlock(& (padapter->dvobj)->hw_init_mutex);
#line 699
  return (ret);
  netdev_open23a_error: 
#line 702
  padapter->bup = 0;
#line 704
  netif_carrier_off(pnetdev);
#line 705
  netif_tx_stop_all_queues(pnetdev);
#line 707
  if (GlobalDebugLevel23A > 3U) {
#line 707
    rt_trace(2048, 4, "-871x_drv - dev_open, fail!\n");
  } else {

  }
#line 709
  if (GlobalDebugLevel23A > 3U) {
#line 709
    printk("\016RTL8723AU: -871x_drv - drv_open fail, bup =%d\n", padapter->bup);
  } else {

  }
#line 711
  ret = -1;
#line 712
  goto exit;
}
}
#line 715 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int ips_netdrv_open(struct rtw_adapter *padapter ) 
{ 
  int status ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 717
  status = 1;
#line 719
  padapter->net_closed = 0;
#line 720
  if (GlobalDebugLevel23A > 3U) {
#line 720
    printk("\016RTL8723AU: ===> %s.........\n", "ips_netdrv_open");
  } else {

  }
#line 722
  padapter->bDriverStopped = 0;
#line 723
  padapter->bSurpriseRemoved = 0;
#line 724
  padapter->bCardDisableWOHSM = 0;
#line 726
  status = rtl8723au_hal_init(padapter);
#line 727
  if (status == 0) {
#line 728
    if (GlobalDebugLevel23A > 3U) {
#line 728
      rt_trace(2048, 4, "ips_netdrv_open(): Can\'t init h/w!\n");
    } else {

    }
#line 730
    goto netdev_open23a_error;
  } else {

  }
#line 733
  rtl8723au_inirp_init(padapter);
#line 735
  tmp = msecs_to_jiffies((unsigned int const   )padapter->pwrctrlpriv.pwr_state_check_interval);
#line 735
  ldv_mod_timer_669(& padapter->pwrctrlpriv.pwr_state_check_timer, tmp + (unsigned long )jiffies);
#line 736
  tmp___0 = msecs_to_jiffies(5000U);
#line 736
  ldv_mod_timer_670(& padapter->mlmepriv.dynamic_chk_timer, tmp___0 + (unsigned long )jiffies);
#line 739
  return (1);
  netdev_open23a_error: ;
#line 743
  if (GlobalDebugLevel23A > 3U) {
#line 743
    printk("\016RTL8723AU: -ips_netdrv_open - drv_open failure, bup =%d\n", padapter->bup);
  } else {

  }
#line 746
  return (0);
}
}
#line 749 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
int rtw_ips_pwr_up23a(struct rtw_adapter *padapter ) 
{ 
  int result ;
  unsigned long start_time ;
  unsigned int tmp ;

  {
#line 752
  start_time = jiffies;
#line 754
  if (GlobalDebugLevel23A > 3U) {
#line 754
    printk("\016RTL8723AU: ===>  rtw_ips_pwr_up23a..............\n");
  } else {

  }
#line 755
  rtw_reset_drv_sw23a(padapter);
#line 757
  result = ips_netdrv_open(padapter);
#line 759
  if (GlobalDebugLevel23A > 3U) {
#line 759
    tmp = jiffies_to_msecs((unsigned long )jiffies - start_time);
#line 759
    printk("\016RTL8723AU: <===  rtw_ips_pwr_up23a.............. in %dms\n", tmp);
  } else {

  }
#line 761
  return (result);
}
}
#line 764 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
void rtw_ips_pwr_down23a(struct rtw_adapter *padapter ) 
{ 
  unsigned long start_time ;
  unsigned int tmp ;

  {
#line 766
  start_time = jiffies;
#line 768
  if (GlobalDebugLevel23A > 3U) {
#line 768
    printk("\016RTL8723AU: ===> rtw_ips_pwr_down23a...................\n");
  } else {

  }
#line 770
  padapter->bCardDisableWOHSM = 1;
#line 771
  padapter->net_closed = 1;
#line 773
  rtw_ips_dev_unload23a(padapter);
#line 774
  padapter->bCardDisableWOHSM = 0;
#line 775
  if (GlobalDebugLevel23A > 3U) {
#line 775
    tmp = jiffies_to_msecs((unsigned long )jiffies - start_time);
#line 775
    printk("\016RTL8723AU: <=== rtw_ips_pwr_down23a..................... in %dms\n",
           tmp);
  } else {

  }
#line 776
  return;
}
}
#line 779 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
void rtw_ips_dev_unload23a(struct rtw_adapter *padapter ) 
{ 


  {
#line 781
  rtl8723a_fifo_cleanup(padapter);
#line 783
  rtl8723a_usb_intf_stop(padapter);
#line 786
  if (padapter->bSurpriseRemoved == 0) {
#line 787
    rtl8723au_hal_deinit(padapter);
  } else {

  }
#line 788
  return;
}
}
#line 790 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
int pm_netdev_open23a(struct net_device *pnetdev , u8 bnormal ) 
{ 
  int status ;
  void *tmp ;
  int tmp___0 ;

  {
#line 794
  if ((unsigned int )bnormal != 0U) {
#line 795
    status = netdev_open23a(pnetdev);
  } else {
#line 797
    tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 797
    tmp___0 = ips_netdrv_open((struct rtw_adapter *)tmp);
#line 797
    status = tmp___0 == 1 ? 0 : -1;
  }
#line 800
  return (status);
}
}
#line 803 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
static int netdev_close(struct net_device *pnetdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  int tmp___0 ;

  {
#line 805
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 805
  padapter = (struct rtw_adapter *)tmp;
#line 807
  if (GlobalDebugLevel23A > 6U) {
#line 807
    rt_trace(2048, 7, "+871x_drv - drv_close\n");
  } else {

  }
#line 809
  padapter->net_closed = 1;
#line 811
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate == 0U) {
#line 812
    if (GlobalDebugLevel23A > 3U) {
#line 812
      printk("\016RTL8723AU: (2)871x_drv - drv_close, bup =%d, hw_init_completed =%d\n",
             padapter->bup, (int )padapter->hw_init_completed);
    } else {

    }
#line 817
    if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
#line 818
      tmp___0 = rtw_netif_queue_stopped(pnetdev);
#line 818
      if (tmp___0 == 0) {
#line 819
        netif_tx_stop_all_queues(pnetdev);
      } else {

      }
    } else {

    }
#line 823
    LeaveAllPowerSaveMode23a(padapter);
#line 824
    rtw_disassoc_cmd23a(padapter, 500U, 0);
#line 826
    rtw_indicate_disconnect23a(padapter);
#line 828
    rtw_free_assoc_resources23a(padapter, 1);
#line 830
    rtw_free_network_queue23a(padapter);
  } else {

  }
#line 833
  rtw_scan_abort23a(padapter);
#line 835
  if (GlobalDebugLevel23A > 6U) {
#line 835
    rt_trace(2048, 7, "-871x_drv - drv_close\n");
  } else {

  }
#line 836
  if (GlobalDebugLevel23A > 3U) {
#line 836
    printk("\016RTL8723AU: -871x_drv - drv_close, bup =%d\n", padapter->bup);
  } else {

  }
#line 838
  return (0);
}
}
#line 841 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
void rtw_ndev_destructor(struct net_device *ndev ) 
{ 


  {
#line 843
  if (GlobalDebugLevel23A > 3U) {
#line 843
    printk("\016RTL8723AU: %s(%s)\n", "rtw_ndev_destructor", (char *)(& ndev->name));
  } else {

  }
#line 844
  kfree((void const   *)ndev->ieee80211_ptr);
#line 845
  ldv_free_netdev_671(ndev);
#line 846
  return;
}
}
#line 848 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.c"
void _rtw_init_queue23a(struct rtw_queue *pqueue ) 
{ 
  struct lock_class_key __key ;

  {
#line 850
  INIT_LIST_HEAD(& pqueue->queue);
#line 851
  spinlock_check(& pqueue->lock);
#line 851
  __raw_spin_lock_init(& pqueue->lock.__annonCompField18.rlock, "&(&pqueue->lock)->rlock",
                       & __key);
#line 853
  return;
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
extern int ldv_ndo_init_15(void) ;
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_retval_8  ;
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_retval_7  ;
#line 252
extern int ldv_ndo_uninit_15(void) ;
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void ldv_net_device_ops_15(void) 
{ 
  void *tmp ;

  {
#line 256
  tmp = ldv_init_zalloc(3008UL);
#line 256
  rtw_netdev_ops_group1 = (struct net_device *)tmp;
#line 257
  return;
}
}
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void ldv_main_exported_15(void) 
{ 
  void *ldvarg50 ;
  void *tmp ;
  u16 (*ldvarg49)(struct net_device * , struct sk_buff * ) ;
  struct sk_buff *ldvarg52 ;
  void *tmp___0 ;
  struct sk_buff *ldvarg51 ;
  void *tmp___1 ;
  void *ldvarg48 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 261
  tmp = ldv_init_zalloc(1UL);
#line 261
  ldvarg50 = tmp;
#line 263
  tmp___0 = ldv_init_zalloc(232UL);
#line 263
  ldvarg52 = (struct sk_buff *)tmp___0;
#line 264
  tmp___1 = ldv_init_zalloc(232UL);
#line 264
  ldvarg51 = (struct sk_buff *)tmp___1;
#line 265
  tmp___2 = ldv_init_zalloc(1UL);
#line 265
  ldvarg48 = tmp___2;
#line 262
  ldv_memset((void *)(& ldvarg49), 0, 8UL);
#line 267
  tmp___3 = __VERIFIER_nondet_int();
#line 267
  switch (tmp___3) {
  case 0: ;
#line 270
  if (ldv_state_variable_15 == 1) {
#line 272
    rtw_net_get_stats(rtw_netdev_ops_group1);
#line 274
    ldv_state_variable_15 = 1;
  } else {

  }
#line 277
  if (ldv_state_variable_15 == 3) {
#line 279
    rtw_net_get_stats(rtw_netdev_ops_group1);
#line 281
    ldv_state_variable_15 = 3;
  } else {

  }
#line 284
  if (ldv_state_variable_15 == 2) {
#line 286
    rtw_net_get_stats(rtw_netdev_ops_group1);
#line 288
    ldv_state_variable_15 = 2;
  } else {

  }
#line 291
  goto ldv_56621;
  case 1: ;
#line 294
  if (ldv_state_variable_15 == 2) {
#line 296
    ldv_retval_8 = netdev_open23a(rtw_netdev_ops_group1);
#line 297
    if (ldv_retval_8 == 0) {
#line 298
      ldv_state_variable_15 = 3;
    } else {

    }
  } else {

  }
#line 302
  goto ldv_56621;
  case 2: ;
#line 305
  if (ldv_state_variable_15 == 3) {
#line 307
    rtw_xmit23a_entry23a(ldvarg52, rtw_netdev_ops_group1);
#line 309
    ldv_state_variable_15 = 3;
  } else {

  }
#line 312
  goto ldv_56621;
  case 3: ;
#line 315
  if (ldv_state_variable_15 == 3) {
#line 317
    netdev_close(rtw_netdev_ops_group1);
#line 318
    ldv_state_variable_15 = 2;
  } else {

  }
#line 321
  goto ldv_56621;
  case 4: ;
#line 324
  if (ldv_state_variable_15 == 1) {
#line 326
    rtw_select_queue(rtw_netdev_ops_group1, ldvarg51, ldvarg50, ldvarg49);
#line 328
    ldv_state_variable_15 = 1;
  } else {

  }
#line 331
  if (ldv_state_variable_15 == 3) {
#line 333
    rtw_select_queue(rtw_netdev_ops_group1, ldvarg51, ldvarg50, ldvarg49);
#line 335
    ldv_state_variable_15 = 3;
  } else {

  }
#line 338
  if (ldv_state_variable_15 == 2) {
#line 340
    rtw_select_queue(rtw_netdev_ops_group1, ldvarg51, ldvarg50, ldvarg49);
#line 342
    ldv_state_variable_15 = 2;
  } else {

  }
#line 345
  goto ldv_56621;
  case 5: ;
#line 348
  if (ldv_state_variable_15 == 1) {
#line 350
    rtw_net_set_mac_address(rtw_netdev_ops_group1, ldvarg48);
#line 352
    ldv_state_variable_15 = 1;
  } else {

  }
#line 355
  if (ldv_state_variable_15 == 3) {
#line 357
    rtw_net_set_mac_address(rtw_netdev_ops_group1, ldvarg48);
#line 359
    ldv_state_variable_15 = 3;
  } else {

  }
#line 362
  if (ldv_state_variable_15 == 2) {
#line 364
    rtw_net_set_mac_address(rtw_netdev_ops_group1, ldvarg48);
#line 366
    ldv_state_variable_15 = 2;
  } else {

  }
#line 369
  goto ldv_56621;
  case 6: ;
#line 372
  if (ldv_state_variable_15 == 1) {
#line 374
    ldv_retval_7 = ldv_ndo_init_15();
#line 375
    if (ldv_retval_7 == 0) {
#line 376
      ldv_state_variable_15 = 2;
#line 377
      usb_counter = usb_counter + 1;
#line 378
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 382
  goto ldv_56621;
  case 7: ;
#line 385
  if (ldv_state_variable_15 == 2) {
#line 387
    ldv_ndo_uninit_15();
#line 388
    ldv_state_variable_15 = 1;
#line 389
    usb_counter = usb_counter - 1;
#line 390
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 393
  goto ldv_56621;
  default: 
#line 394
  ldv_stop();
  }
  ldv_56621: ;
#line 398
  return;
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
bool ldv_queue_work_on_653(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 427
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 427
  ldv_func_res = tmp;
#line 429
  activate_work_2(ldv_func_arg3, 2);
#line 431
  return (ldv_func_res);
}
}
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
bool ldv_queue_delayed_work_on_654(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 438
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 438
  ldv_func_res = tmp;
#line 440
  activate_work_2(& ldv_func_arg3->work, 2);
#line 442
  return (ldv_func_res);
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
bool ldv_queue_work_on_655(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 449
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 449
  ldv_func_res = tmp;
#line 451
  activate_work_2(ldv_func_arg3, 2);
#line 453
  return (ldv_func_res);
}
}
#line 456 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void ldv_flush_workqueue_656(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 459
  flush_workqueue(ldv_func_arg1);
#line 461
  call_and_disable_all_2(2);
#line 462
  return;
}
}
#line 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
bool ldv_queue_delayed_work_on_657(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 468
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 468
  ldv_func_res = tmp;
#line 470
  activate_work_2(& ldv_func_arg3->work, 2);
#line 472
  return (ldv_func_res);
}
}
#line 475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_mod_timer_658(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 479
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 479
  ldv_func_res = tmp;
#line 481
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 483
  return (ldv_func_res);
}
}
#line 486 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_del_timer_sync_659(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 490
  tmp = del_timer_sync(ldv_func_arg1);
#line 490
  ldv_func_res = tmp;
#line 492
  disable_suitable_timer_11(ldv_func_arg1);
#line 494
  return (ldv_func_res);
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_del_timer_sync_660(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 501
  tmp = del_timer_sync(ldv_func_arg1);
#line 501
  ldv_func_res = tmp;
#line 503
  disable_suitable_timer_11(ldv_func_arg1);
#line 505
  return (ldv_func_res);
}
}
#line 508 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_del_timer_sync_661(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 512
  tmp = del_timer_sync(ldv_func_arg1);
#line 512
  ldv_func_res = tmp;
#line 514
  disable_suitable_timer_11(ldv_func_arg1);
#line 516
  return (ldv_func_res);
}
}
#line 519 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_del_timer_sync_662(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 523
  tmp = del_timer_sync(ldv_func_arg1);
#line 523
  ldv_func_res = tmp;
#line 525
  disable_suitable_timer_11(ldv_func_arg1);
#line 527
  return (ldv_func_res);
}
}
#line 530 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_del_timer_sync_663(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 534
  tmp = del_timer_sync(ldv_func_arg1);
#line 534
  ldv_func_res = tmp;
#line 536
  disable_suitable_timer_11(ldv_func_arg1);
#line 538
  return (ldv_func_res);
}
}
#line 541 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_del_timer_sync_664(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 545
  tmp = del_timer_sync(ldv_func_arg1);
#line 545
  ldv_func_res = tmp;
#line 547
  disable_suitable_timer_11(ldv_func_arg1);
#line 549
  return (ldv_func_res);
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_register_netdev_665(struct net_device *dev ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 556
  tmp = register_netdev(dev);
#line 556
  ldv_func_res = tmp;
#line 558
  ldv_state_variable_17 = 1;
#line 559
  ldv_net_device_ops_17();
#line 562
  return (ldv_func_res);
}
}
#line 565 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void ldv_free_netdev_666(struct net_device *dev ) 
{ 


  {
#line 568
  free_netdev(dev);
#line 570
  ldv_state_variable_17 = 0;
#line 571
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_mod_timer_667(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
#line 577
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 577
  ldv_func_res = tmp;
#line 579
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 581
  return (ldv_func_res);
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_mod_timer_668(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
#line 588
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 588
  ldv_func_res = tmp;
#line 590
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 592
  return (ldv_func_res);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_mod_timer_669(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
#line 599
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 599
  ldv_func_res = tmp;
#line 601
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 603
  return (ldv_func_res);
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_mod_timer_670(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;

  {
#line 610
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 610
  ldv_func_res = tmp;
#line 612
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 614
  return (ldv_func_res);
}
}
#line 617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void ldv_free_netdev_671(struct net_device *dev ) 
{ 


  {
#line 620
  free_netdev(dev);
#line 622
  ldv_state_variable_17 = 0;
#line 623
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_695(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_697(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_696(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_699(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_698(struct workqueue_struct *ldv_func_arg1 ) ;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
struct timer_list *ldv_timer_list_13_3 ;
#line 89
int ldv_timer_13_3 ;
#line 113
struct timer_list *ldv_timer_list_13_1 ;
#line 114
int ldv_timer_13_0 ;
#line 129
int ldv_timer_13_2 ;
#line 133
struct timer_list *ldv_timer_list_13_0 ;
#line 149
struct timer_list *ldv_timer_list_13_2 ;
#line 153
int ldv_timer_13_1 ;
#line 156
void activate_suitable_timer_13(struct timer_list *timer , unsigned long data ) ;
#line 157
void choose_timer_13(void) ;
#line 159
void ldv_timer_13(int state , struct timer_list *timer ) ;
#line 164
void disable_suitable_timer_13(struct timer_list *timer ) ;
#line 193
void timer_init_13(void) ;
#line 198
void activate_pending_timer_13(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 227
int reg_timer_13(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 976 "include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 978
  return ((unsigned char *)skb->head + (unsigned long )skb->end);
}
}
#line 3291 "include/linux/skbuff.h"
__inline static void skb_set_queue_mapping(struct sk_buff *skb , u16 queue_mapping ) 
{ 


  {
#line 3293
  skb->queue_mapping = queue_mapping;
#line 3294
  return;
}
}
#line 4200 "include/net/cfg80211.h"
extern void cfg80211_michael_mic_failure(struct net_device * , u8 const   * , enum nl80211_key_type  ,
                                         int  , u8 const   * , gfp_t  ) ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.c"
void rtw_handle_tkip_mic_err23a(struct rtw_adapter *padapter , u8 bgroup ) 
{ 
  enum nl80211_key_type key_type ;
  union iwreq_data wrqu ;
  struct iw_michaelmicfailure ev ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  unsigned long cur_time ;

  {
#line 29
  key_type = 0;
#line 32
  pmlmepriv = & padapter->mlmepriv;
#line 33
  psecuritypriv = & padapter->securitypriv;
#line 36
  if (psecuritypriv->last_mic_err_time == 0UL) {
#line 37
    psecuritypriv->last_mic_err_time = jiffies;
  } else {
#line 39
    cur_time = jiffies;
#line 41
    if (cur_time - psecuritypriv->last_mic_err_time <= 14999UL) {
#line 42
      psecuritypriv->btkip_countermeasure = 1U;
#line 43
      psecuritypriv->last_mic_err_time = 0UL;
#line 44
      psecuritypriv->btkip_countermeasure_time = cur_time;
    } else {
#line 46
      psecuritypriv->last_mic_err_time = jiffies;
    }
  }
#line 50
  if ((unsigned int )bgroup != 0U) {
#line 51
    key_type = key_type;
  } else {
#line 53
    key_type = (enum nl80211_key_type )((unsigned int )key_type | 1U);
  }
#line 55
  cfg80211_michael_mic_failure(padapter->pnetdev, (u8 const   *)(& pmlmepriv->assoc_bssid),
                               key_type, -1, (u8 const   *)0U, 32U);
#line 59
  memset((void *)(& ev), 0, 28UL);
#line 60
  if ((unsigned int )bgroup != 0U) {
#line 61
    ev.flags = ev.flags | 4U;
  } else {
#line 63
    ev.flags = ev.flags | 8U;
  }
#line 65
  ev.src_addr.sa_family = 1U;
#line 66
  ether_addr_copy((u8 *)(& ev.src_addr.sa_data), (u8 const   *)(& pmlmepriv->assoc_bssid));
#line 68
  memset((void *)(& wrqu), 0, 16UL);
#line 69
  wrqu.data.length = 28U;
#line 70
  return;
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.c"
int rtw_recv_indicatepkt23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct recv_priv *precvpriv ;
  struct sk_buff *skb ;
  struct mlme_priv *pmlmepriv ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  struct sk_buff *pskb2 ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct rx_pkt_attrib *pattrib ;
  int bmcast ;
  bool tmp___1 ;
  struct net_device *pnetdev ;
  u16 tmp___2 ;
  u8 *tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;

  {
#line 77
  pmlmepriv = & padapter->mlmepriv;
#line 79
  precvpriv = & padapter->recvpriv;
#line 81
  skb = precv_frame->pkt;
#line 82
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 83
    if (GlobalDebugLevel23A > 3U) {
#line 83
      rt_trace(8, 4, "rtw_recv_indicatepkt23a():skb == NULL!!!!\n");
    } else {

    }
#line 85
    goto _recv_indicatepkt_drop;
  } else {

  }
#line 88
  if (GlobalDebugLevel23A > 6U) {
#line 88
    rt_trace(8, 7, "rtw_recv_indicatepkt23a():skb != NULL !!!\n");
  } else {

  }
#line 90
  if (GlobalDebugLevel23A > 6U) {
#line 90
    rt_trace(8, 7, "rtw_recv_indicatepkt23a():precv_frame->hdr.rx_data =%p\n", (precv_frame->pkt)->data);
  } else {

  }
#line 93
  if (GlobalDebugLevel23A > 6U) {
#line 93
    tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 93
    tmp___0 = skb_tail_pointer((struct sk_buff  const  *)skb);
#line 93
    rt_trace(8, 7, "skb->head =%p skb->data =%p skb->tail =%p skb->end =%p skb->len =%d\n",
             skb->head, skb->data, tmp___0, tmp, skb->len);
  } else {

  }
#line 98
  tmp___6 = check_fwstate(pmlmepriv, 16);
#line 98
  if ((int )tmp___6) {
#line 99
    pskb2 = (struct sk_buff *)0;
#line 100
    psta = (struct sta_info *)0;
#line 101
    pstapriv = & padapter->stapriv;
#line 102
    pattrib = & precv_frame->attrib;
#line 103
    tmp___1 = is_multicast_ether_addr((u8 const   *)(& pattrib->dst));
#line 103
    bmcast = (int )tmp___1;
#line 107
    tmp___3 = myid(& padapter->eeprompriv);
#line 107
    tmp___4 = ether_addr_equal((u8 const   *)(& pattrib->dst), (u8 const   *)tmp___3);
#line 107
    if (tmp___4) {
#line 107
      tmp___5 = 0;
    } else {
#line 107
      tmp___5 = 1;
    }
#line 107
    if (tmp___5) {
#line 110
      if (bmcast != 0) {
#line 111
        psta = rtw_get_bcmc_stainfo23a(padapter);
#line 112
        pskb2 = skb_clone(skb, 32U);
      } else {
#line 114
        psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->dst));
      }
#line 117
      if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 118
        pnetdev = padapter->pnetdev;
#line 123
        skb->dev = pnetdev;
#line 124
        tmp___2 = rtw_recv_select_queue23a(skb);
#line 124
        skb_set_queue_mapping(skb, (int )tmp___2);
#line 126
        rtw_xmit23a_entry23a(skb, pnetdev);
#line 128
        if (bmcast != 0) {
#line 129
          skb = pskb2;
        } else {
#line 131
          goto _recv_indicatepkt_end;
        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 138
  skb->ip_summed = 0U;
#line 139
  skb->dev = padapter->pnetdev;
#line 140
  skb->protocol = eth_type_trans(skb, padapter->pnetdev);
#line 142
  netif_rx(skb);
  _recv_indicatepkt_end: 
#line 146
  precv_frame->pkt = (struct sk_buff *)0;
#line 148
  rtw_free_recvframe23a(precv_frame);
#line 150
  if (GlobalDebugLevel23A > 6U) {
#line 150
    rt_trace(8, 7, "rtw_recv_indicatepkt23a :after netif_rx!!!!\n");
  } else {

  }
#line 152
  return (1);
  _recv_indicatepkt_drop: 
#line 156
  rtw_free_recvframe23a(precv_frame);
#line 157
  return (0);
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.c"
void rtw_init_recv_timer23a(struct recv_reorder_ctrl *preorder_ctrl ) 
{ 


  {
#line 162
  reg_timer_11(& preorder_ctrl->reordering_ctrl_timer, & rtw_reordering_ctrl_timeout_handler23a,
               (unsigned long )preorder_ctrl);
#line 163
  return;
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void activate_suitable_timer_13(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 251
  if (ldv_timer_13_0 == 0 || ldv_timer_13_0 == 2) {
#line 252
    ldv_timer_list_13_0 = timer;
#line 253
    ldv_timer_list_13_0->data = data;
#line 254
    ldv_timer_13_0 = 1;
#line 255
    return;
  } else {

  }
#line 257
  if (ldv_timer_13_1 == 0 || ldv_timer_13_1 == 2) {
#line 258
    ldv_timer_list_13_1 = timer;
#line 259
    ldv_timer_list_13_1->data = data;
#line 260
    ldv_timer_13_1 = 1;
#line 261
    return;
  } else {

  }
#line 263
  if (ldv_timer_13_2 == 0 || ldv_timer_13_2 == 2) {
#line 264
    ldv_timer_list_13_2 = timer;
#line 265
    ldv_timer_list_13_2->data = data;
#line 266
    ldv_timer_13_2 = 1;
#line 267
    return;
  } else {

  }
#line 269
  if (ldv_timer_13_3 == 0 || ldv_timer_13_3 == 2) {
#line 270
    ldv_timer_list_13_3 = timer;
#line 271
    ldv_timer_list_13_3->data = data;
#line 272
    ldv_timer_13_3 = 1;
#line 273
    return;
  } else {

  }
#line 275
  return;
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void choose_timer_13(void) 
{ 
  int tmp ;

  {
#line 280
  tmp = __VERIFIER_nondet_int();
#line 280
  switch (tmp) {
  case 0: ;
#line 282
  if (ldv_timer_13_0 == 1) {
#line 283
    ldv_timer_13_0 = 2;
#line 284
    ldv_timer_13(ldv_timer_13_0, ldv_timer_list_13_0);
  } else {

  }
#line 287
  goto ldv_53293;
  case 1: ;
#line 289
  if (ldv_timer_13_1 == 1) {
#line 290
    ldv_timer_13_1 = 2;
#line 291
    ldv_timer_13(ldv_timer_13_1, ldv_timer_list_13_1);
  } else {

  }
#line 294
  goto ldv_53293;
  case 2: ;
#line 296
  if (ldv_timer_13_2 == 1) {
#line 297
    ldv_timer_13_2 = 2;
#line 298
    ldv_timer_13(ldv_timer_13_2, ldv_timer_list_13_2);
  } else {

  }
#line 301
  goto ldv_53293;
  case 3: ;
#line 303
  if (ldv_timer_13_3 == 1) {
#line 304
    ldv_timer_13_3 = 2;
#line 305
    ldv_timer_13(ldv_timer_13_3, ldv_timer_list_13_3);
  } else {

  }
#line 308
  goto ldv_53293;
  default: 
#line 309
  ldv_stop();
  }
  ldv_53293: ;
#line 311
  return;
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void ldv_timer_13(int state , struct timer_list *timer ) 
{ 


  {
#line 316
  LDV_IN_INTERRUPT = 2;
#line 317
  rtw_reordering_ctrl_timeout_handler23a(timer->data);
#line 318
  LDV_IN_INTERRUPT = 1;
#line 319
  return;
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void disable_suitable_timer_13(struct timer_list *timer ) 
{ 


  {
#line 323
  if (ldv_timer_13_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_13_0) {
#line 324
    ldv_timer_13_0 = 0;
#line 325
    return;
  } else {

  }
#line 327
  if (ldv_timer_13_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_13_1) {
#line 328
    ldv_timer_13_1 = 0;
#line 329
    return;
  } else {

  }
#line 331
  if (ldv_timer_13_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_13_2) {
#line 332
    ldv_timer_13_2 = 0;
#line 333
    return;
  } else {

  }
#line 335
  if (ldv_timer_13_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_13_3) {
#line 336
    ldv_timer_13_3 = 0;
#line 337
    return;
  } else {

  }
#line 339
  return;
}
}
#line 343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void timer_init_13(void) 
{ 


  {
#line 344
  ldv_timer_13_0 = 0;
#line 345
  ldv_timer_13_1 = 0;
#line 346
  ldv_timer_13_2 = 0;
#line 347
  ldv_timer_13_3 = 0;
#line 348
  return;
}
}
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void activate_pending_timer_13(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 352
  if ((unsigned long )ldv_timer_list_13_0 == (unsigned long )timer) {
#line 353
    if (ldv_timer_13_0 == 2 || pending_flag != 0) {
#line 354
      ldv_timer_list_13_0 = timer;
#line 355
      ldv_timer_list_13_0->data = data;
#line 356
      ldv_timer_13_0 = 1;
    } else {

    }
#line 358
    return;
  } else {

  }
#line 361
  if ((unsigned long )ldv_timer_list_13_1 == (unsigned long )timer) {
#line 362
    if (ldv_timer_13_1 == 2 || pending_flag != 0) {
#line 363
      ldv_timer_list_13_1 = timer;
#line 364
      ldv_timer_list_13_1->data = data;
#line 365
      ldv_timer_13_1 = 1;
    } else {

    }
#line 367
    return;
  } else {

  }
#line 370
  if ((unsigned long )ldv_timer_list_13_2 == (unsigned long )timer) {
#line 371
    if (ldv_timer_13_2 == 2 || pending_flag != 0) {
#line 372
      ldv_timer_list_13_2 = timer;
#line 373
      ldv_timer_list_13_2->data = data;
#line 374
      ldv_timer_13_2 = 1;
    } else {

    }
#line 376
    return;
  } else {

  }
#line 379
  if ((unsigned long )ldv_timer_list_13_3 == (unsigned long )timer) {
#line 380
    if (ldv_timer_13_3 == 2 || pending_flag != 0) {
#line 381
      ldv_timer_list_13_3 = timer;
#line 382
      ldv_timer_list_13_3->data = data;
#line 383
      ldv_timer_13_3 = 1;
    } else {

    }
#line 385
    return;
  } else {

  }
#line 387
  activate_suitable_timer_13(timer, data);
#line 388
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
int reg_timer_13(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 392
  if ((unsigned long )function == (unsigned long )(& rtw_reordering_ctrl_timeout_handler23a)) {
#line 393
    activate_suitable_timer_13(timer, data);
  } else {

  }
#line 394
  return (0);
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
bool ldv_queue_work_on_695(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 425
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 425
  ldv_func_res = tmp;
#line 427
  activate_work_2(ldv_func_arg3, 2);
#line 429
  return (ldv_func_res);
}
}
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
bool ldv_queue_delayed_work_on_696(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 436
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 436
  ldv_func_res = tmp;
#line 438
  activate_work_2(& ldv_func_arg3->work, 2);
#line 440
  return (ldv_func_res);
}
}
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
bool ldv_queue_work_on_697(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 447
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 447
  ldv_func_res = tmp;
#line 449
  activate_work_2(ldv_func_arg3, 2);
#line 451
  return (ldv_func_res);
}
}
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void ldv_flush_workqueue_698(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 457
  flush_workqueue(ldv_func_arg1);
#line 459
  call_and_disable_all_2(2);
#line 460
  return;
}
}
#line 462 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
bool ldv_queue_delayed_work_on_699(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 466
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 466
  ldv_func_res = tmp;
#line 468
  activate_work_2(& ldv_func_arg3->work, 2);
#line 470
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_3129: ;
#line 14
  return (pfo_ret__);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_709(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_711(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_710(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_713(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_712(struct workqueue_struct *ldv_func_arg1 ) ;
#line 459
void ldv_flush_workqueue_714(struct workqueue_struct *ldv_func_arg1 ) ;
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_7_1  ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_11_0  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct work_struct *ldv_work_struct_3_1  ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_0  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_9_3  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_10_2  ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_8_1  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_5_2  ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_work_1_1  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_12  ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_5_0  ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_12_1  ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct station_info *rtw_cfg80211_ops_group1  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_14  ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_9_1  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_6_2  ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_9_0  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_5_3  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_17  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_9_3  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct work_struct *ldv_work_struct_2_0  ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_4_3  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_9  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_6_0  ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct work_struct *ldv_work_struct_2_2  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_5_1  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_11_1  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ref_cnt  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_work_3_3  ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_7  ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct work_struct *ldv_work_struct_3_3  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_10_0  ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_6_3  ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_12_3  ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct cfg80211_pmksa *rtw_cfg80211_ops_group2  ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_8_2  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_6_2  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_9_2  ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct work_struct *ldv_work_struct_1_1  ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_9_2  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_4_0  ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_7_3  ;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_work_1_3  ;
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct work_struct *ldv_work_struct_2_1  ;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_11_2  ;
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct work_struct *ldv_work_struct_3_2  ;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_6  ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct wiphy *rtw_cfg80211_ops_group3  ;
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_6_0  ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int usb_counter  ;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_13_3  ;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_8_3  ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_7_1  ;
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_10_2  ;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_4_3  ;
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct vif_params *rtw_cfg80211_ops_group5  ;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_5_3  ;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_7_0  ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_10_1  ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_3  ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_4_1  ;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_work_1_0  ;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_4_1  ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct net_device *rtw_netdev_ops_group1  ;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_9_0  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_8_3  ;
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_4  ;
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_work_2_1  ;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_13_3  ;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_7_3  ;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_8  ;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_15  ;
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_4_0  ;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct work_struct *ldv_work_struct_1_3  ;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_5_2  ;
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_5  ;
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_12_0  ;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_11_1  ;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_13  ;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_12_0  ;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_11_2  ;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_12_2  ;
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_work_3_2  ;
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_5_1  ;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_7_2  ;
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_work_3_0  ;
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct work_struct *ldv_work_struct_2_3  ;
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_6_1  ;
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_7_0  ;
#line 110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_12_3  ;
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_11_0  ;
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct net_device *rtw_cfg80211_ops_group6  ;
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_13_1  ;
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_13_0  ;
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_1  ;
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_6_3  ;
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_8_0  ;
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_10_0  ;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_12_1  ;
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_4_2  ;
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct work_struct *ldv_work_struct_1_0  ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct wireless_dev *rtw_cfg80211_ops_group0  ;
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_10  ;
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_11_3  ;
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_8_1  ;
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct net_device *rtw_cfg80211_monitor_if_ops_group1  ;
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_16  ;
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_work_3_1  ;
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_13_2  ;
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_2  ;
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_10_1  ;
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_work_2_0  ;
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_13_0  ;
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_5_0  ;
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_12_2  ;
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct usb_interface *rtl8723a_usb_drv_group1  ;
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct work_struct *ldv_work_struct_3_0  ;
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_11  ;
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_7_2  ;
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_work_1_2  ;
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_4_2  ;
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_8_0  ;
#line 144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_10_3  ;
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct work_struct *ldv_work_struct_1_2  ;
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct station_parameters *rtw_cfg80211_ops_group4  ;
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_6_1  ;
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_11_3  ;
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_work_2_2  ;
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_13_2  ;
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_10_3  ;
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_work_2_3  ;
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_8_2  ;
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_13_1  ;
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_9_1  ;
#line 215
void ldv_usb_driver_14(void) ;
#line 86 "include/linux/pm_wakeup.h"
__inline static bool device_may_wakeup(struct device *dev ) 
{ 


  {
#line 88
  return ((bool )((unsigned int )*((unsigned char *)dev + 524UL) != 0U && (unsigned long )dev->power.wakeup != (unsigned long )((struct wakeup_source *)0)));
}
}
#line 103
extern int device_init_wakeup(struct device * , bool  ) ;
#line 863 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 865
  return ((void *)dev->driver_data);
}
}
#line 868 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 870
  dev->driver_data = data;
#line 871
  return;
}
}
#line 23 "include/linux/random.h"
extern void get_random_bytes(void * , int  ) ;
#line 2205 "include/linux/netdevice.h"
void ldv_free_netdev_715(struct net_device *dev ) ;
#line 2209
void ldv_free_netdev_717(struct net_device *dev ) ;
#line 3119
extern void netif_device_attach(struct net_device * ) ;
#line 3356
void ldv_unregister_netdev_716(struct net_device *dev ) ;
#line 218 "include/linux/etherdevice.h"
__inline static void eth_random_addr(u8 *addr ) 
{ 


  {
#line 220
  get_random_bytes((void *)addr, 6);
#line 221
  *addr = (unsigned int )*addr & 254U;
#line 222
  *addr = (u8 )((unsigned int )*addr | 2U);
#line 223
  return;
}
}
#line 3257 "include/net/cfg80211.h"
__inline static void *wiphy_priv___2(struct wiphy *wiphy ) 
{ 
  long tmp ;

  {
#line 3259
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
#line 3259
  if (tmp != 0L) {
#line 3259
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3259), "i" (12UL));
    ldv_48194: ;
#line 3259
    goto ldv_48194;
  } else {

  }
#line 3260
  return ((void *)(& wiphy->priv));
}
}
#line 3510 "include/net/cfg80211.h"
__inline static void *wdev_priv___2(struct wireless_dev *wdev ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
#line 3512
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
#line 3512
  if (tmp != 0L) {
#line 3512
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3512), "i" (12UL));
    ldv_48279: ;
#line 3512
    goto ldv_48279;
  } else {

  }
#line 3513
  tmp___0 = wiphy_priv___2(wdev->wiphy);
#line 3513
  return (tmp___0);
}
}
#line 425 "include/uapi/linux/usb/ch9.h"
__inline static int usb_endpoint_num(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 427
  return ((int )epd->bEndpointAddress & 15);
}
}
#line 448 "include/uapi/linux/usb/ch9.h"
__inline static int usb_endpoint_dir_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 450
  return ((int )((signed char )epd->bEndpointAddress) < 0);
}
}
#line 459 "include/uapi/linux/usb/ch9.h"
__inline static int usb_endpoint_dir_out(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 462
  return ((int )((signed char )epd->bEndpointAddress) >= 0);
}
}
#line 471 "include/uapi/linux/usb/ch9.h"
__inline static int usb_endpoint_xfer_bulk(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 474
  return (((int )epd->bmAttributes & 3) == 2);
}
}
#line 498 "include/uapi/linux/usb/ch9.h"
__inline static int usb_endpoint_xfer_int(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 501
  return (((int )epd->bmAttributes & 3) == 3);
}
}
#line 526 "include/uapi/linux/usb/ch9.h"
__inline static int usb_endpoint_is_bulk_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 529
  tmp = usb_endpoint_xfer_bulk(epd);
#line 529
  if (tmp != 0) {
#line 529
    tmp___0 = usb_endpoint_dir_in(epd);
#line 529
    if (tmp___0 != 0) {
#line 529
      tmp___1 = 1;
    } else {
#line 529
      tmp___1 = 0;
    }
  } else {
#line 529
    tmp___1 = 0;
  }
#line 529
  return (tmp___1);
}
}
#line 539 "include/uapi/linux/usb/ch9.h"
__inline static int usb_endpoint_is_bulk_out(struct usb_endpoint_descriptor  const  *epd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 542
  tmp = usb_endpoint_xfer_bulk(epd);
#line 542
  if (tmp != 0) {
#line 542
    tmp___0 = usb_endpoint_dir_out(epd);
#line 542
    if (tmp___0 != 0) {
#line 542
      tmp___1 = 1;
    } else {
#line 542
      tmp___1 = 0;
    }
  } else {
#line 542
    tmp___1 = 0;
  }
#line 542
  return (tmp___1);
}
}
#line 552 "include/uapi/linux/usb/ch9.h"
__inline static int usb_endpoint_is_int_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 555
  tmp = usb_endpoint_xfer_int(epd);
#line 555
  if (tmp != 0) {
#line 555
    tmp___0 = usb_endpoint_dir_in(epd);
#line 555
    if (tmp___0 != 0) {
#line 555
      tmp___1 = 1;
    } else {
#line 555
      tmp___1 = 0;
    }
  } else {
#line 555
    tmp___1 = 0;
  }
#line 555
  return (tmp___1);
}
}
#line 189 "include/linux/usb.h"
__inline static void *usb_get_intfdata(struct usb_interface *intf ) 
{ 
  void *tmp ;

  {
#line 191
  tmp = dev_get_drvdata((struct device  const  *)(& intf->dev));
#line 191
  return (tmp);
}
}
#line 194 "include/linux/usb.h"
__inline static void usb_set_intfdata(struct usb_interface *intf , void *data ) 
{ 


  {
#line 196
  dev_set_drvdata(& intf->dev, data);
#line 197
  return;
}
}
#line 616 "include/linux/usb.h"
__inline static struct usb_device *interface_to_usbdev(struct usb_interface *intf ) 
{ 
  struct device  const  *__mptr ;

  {
#line 618
  __mptr = (struct device  const  *)intf->dev.parent;
#line 618
  return ((struct usb_device *)__mptr + 0xffffffffffffff70UL);
}
}
#line 621
extern struct usb_device *usb_get_dev(struct usb_device * ) ;
#line 622
extern void usb_put_dev(struct usb_device * ) ;
#line 646
extern int usb_reset_device(struct usb_device * ) ;
#line 665
extern int usb_autopm_get_interface(struct usb_interface * ) ;
#line 666
extern void usb_autopm_put_interface(struct usb_interface * ) ;
#line 1169
extern int usb_register_driver(struct usb_driver * , struct module * , char const   * ) ;
#line 1173
int ldv_usb_register_driver_718(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                char const   *ldv_func_arg3 ) ;
#line 1180
extern void usb_deregister(struct usb_driver * ) ;
#line 1183
void ldv_usb_deregister_719(struct usb_driver *arg ) ;
#line 27 "drivers/staging/rtl8723au/include/rtw_ap.h"
void free_mlme_ap_info23a(struct rtw_adapter *padapter ) ;
#line 29 "drivers/staging/rtl8723au/include/usb_ops_linux.h"
void rtl8723au_write_port_cancel(struct rtw_adapter *padapter ) ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static int rtw_suspend(struct usb_interface *pusb_intf , pm_message_t message ) ;
#line 28
static int rtw_resume(struct usb_interface *pusb_intf ) ;
#line 29
static int rtw_drv_init(struct usb_interface *pusb_intf , struct usb_device_id  const  *pdid ) ;
#line 31
static void rtw_disconnect(struct usb_interface *pusb_intf ) ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static struct usb_device_id rtl8723a_usb_id_tbl[4U]  = {      {899U, 3034U, 34596U, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 255U, 255U, 255U, (unsigned char)0, 0UL}, 
        {899U,
      3034U, 5924U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, 255U, 255U, 255U, (unsigned char)0, 0UL}, 
        {899U, 3034U, 1828U, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 255U, 255U, 255U, (unsigned char)0, 0UL}};
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
struct usb_device_id  const  __mod_usb__rtl8723a_usb_id_tbl_device_table[4U]  ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static struct usb_driver rtl8723a_usb_drv  = 
#line 50
     {"rtl8723au", & rtw_drv_init, & rtw_disconnect, 0, & rtw_suspend, & rtw_resume,
    & rtw_resume, 0, 0, (struct usb_device_id  const  *)(& rtl8723a_usb_id_tbl), {{{{{{0}},
                                                                                     0U,
                                                                                     0U,
                                                                                     0,
                                                                                     {0,
                                                                                      {0,
                                                                                       0},
                                                                                      0,
                                                                                      0,
                                                                                      0UL}}}},
                                                                                  {0,
                                                                                   0}},
    {{0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0}, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0};
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static struct usb_driver *usb_drv  =    & rtl8723a_usb_drv;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static int rtw_init_intf_priv(struct dvobj_priv *dvobj ) 
{ 
  struct lock_class_key __key ;

  {
#line 64
  __mutex_init(& dvobj->usb_vendor_req_mutex, "&dvobj->usb_vendor_req_mutex", & __key);
#line 66
  return (1);
}
}
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static int rtw_deinit_intf_priv(struct dvobj_priv *dvobj ) 
{ 


  {
#line 71
  mutex_destroy(& dvobj->usb_vendor_req_mutex);
#line 73
  return (1);
}
}
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static struct dvobj_priv *usb_dvobj_init(struct usb_interface *usb_intf ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_host_config *phost_conf ;
  struct usb_config_descriptor *pconf_desc ;
  struct usb_host_interface *phost_iface ;
  struct usb_interface_descriptor *piface_desc ;
  struct usb_endpoint_descriptor *pendp_desc ;
  struct usb_device *pusbd ;
  int i ;
  int status ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 85
  status = 0;
#line 87
  tmp = kzalloc(944UL, 208U);
#line 87
  pdvobjpriv = (struct dvobj_priv *)tmp;
#line 88
  if ((unsigned long )pdvobjpriv == (unsigned long )((struct dvobj_priv *)0)) {
#line 89
    goto exit;
  } else {

  }
#line 91
  __mutex_init(& pdvobjpriv->hw_init_mutex, "&pdvobjpriv->hw_init_mutex", & __key);
#line 92
  __mutex_init(& pdvobjpriv->h2c_fwcmd_mutex, "&pdvobjpriv->h2c_fwcmd_mutex", & __key___0);
#line 93
  __mutex_init(& pdvobjpriv->setch_mutex, "&pdvobjpriv->setch_mutex", & __key___1);
#line 94
  __mutex_init(& pdvobjpriv->setbw_mutex, "&pdvobjpriv->setbw_mutex", & __key___2);
#line 96
  pdvobjpriv->pusbintf = usb_intf;
#line 97
  pusbd = interface_to_usbdev(usb_intf);
#line 98
  pdvobjpriv->pusbdev = pusbd;
#line 99
  usb_set_intfdata(usb_intf, (void *)pdvobjpriv);
#line 101
  pdvobjpriv->RtNumInPipes = 0U;
#line 102
  pdvobjpriv->RtNumOutPipes = 0U;
#line 104
  phost_conf = pusbd->actconfig;
#line 105
  pconf_desc = & phost_conf->desc;
#line 107
  phost_iface = usb_intf->altsetting;
#line 108
  piface_desc = & phost_iface->desc;
#line 110
  pdvobjpriv->NumInterfaces = pconf_desc->bNumInterfaces;
#line 111
  pdvobjpriv->InterfaceNumber = piface_desc->bInterfaceNumber;
#line 112
  pdvobjpriv->nr_endpoint = piface_desc->bNumEndpoints;
#line 114
  i = 0;
#line 114
  goto ldv_55855;
  ldv_55854: 
#line 115
  pendp_desc = & (phost_iface->endpoint + (unsigned long )i)->desc;
#line 117
  if (GlobalDebugLevel23A > 3U) {
#line 117
    printk("\016RTL8723AU: \nusb_endpoint_descriptor(%d):\n", i);
  } else {

  }
#line 118
  if (GlobalDebugLevel23A > 3U) {
#line 118
    printk("\016RTL8723AU: bLength =%x\n", (int )pendp_desc->bLength);
  } else {

  }
#line 119
  if (GlobalDebugLevel23A > 3U) {
#line 119
    printk("\016RTL8723AU: bDescriptorType =%x\n", (int )pendp_desc->bDescriptorType);
  } else {

  }
#line 120
  if (GlobalDebugLevel23A > 3U) {
#line 120
    printk("\016RTL8723AU: bEndpointAddress =%x\n", (int )pendp_desc->bEndpointAddress);
  } else {

  }
#line 122
  if (GlobalDebugLevel23A > 3U) {
#line 122
    printk("\016RTL8723AU: wMaxPacketSize =%d\n", (int )pendp_desc->wMaxPacketSize);
  } else {

  }
#line 124
  if (GlobalDebugLevel23A > 3U) {
#line 124
    printk("\016RTL8723AU: bInterval =%x\n", (int )pendp_desc->bInterval);
  } else {

  }
#line 126
  tmp___5 = usb_endpoint_is_bulk_in((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 126
  if (tmp___5 != 0) {
#line 127
    if (GlobalDebugLevel23A > 3U) {
#line 127
      tmp___0 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 127
      printk("\016RTL8723AU: usb_endpoint_is_bulk_in = %x\n", tmp___0);
    } else {

    }
#line 129
    pdvobjpriv->RtInPipe[(int )pdvobjpriv->RtNumInPipes] = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 131
    pdvobjpriv->RtNumInPipes = (u8 )((int )pdvobjpriv->RtNumInPipes + 1);
  } else {
#line 132
    tmp___4 = usb_endpoint_is_int_in((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 132
    if (tmp___4 != 0) {
#line 133
      if (GlobalDebugLevel23A > 3U) {
#line 133
        tmp___1 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 133
        printk("\016RTL8723AU: usb_endpoint_is_int_in = %x, Interval = %x\n", tmp___1,
               (int )pendp_desc->bInterval);
      } else {

      }
#line 136
      pdvobjpriv->RtInPipe[(int )pdvobjpriv->RtNumInPipes] = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 138
      pdvobjpriv->RtNumInPipes = (u8 )((int )pdvobjpriv->RtNumInPipes + 1);
    } else {
#line 139
      tmp___3 = usb_endpoint_is_bulk_out((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 139
      if (tmp___3 != 0) {
#line 140
        if (GlobalDebugLevel23A > 3U) {
#line 140
          tmp___2 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 140
          printk("\016RTL8723AU: usb_endpoint_is_bulk_out = %x\n", tmp___2);
        } else {

        }
#line 142
        pdvobjpriv->RtOutPipe[(int )pdvobjpriv->RtNumOutPipes] = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 144
        pdvobjpriv->RtNumOutPipes = (u8 )((int )pdvobjpriv->RtNumOutPipes + 1);
      } else {

      }
    }
  }
#line 146
  pdvobjpriv->ep_num[i] = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 114
  i = i + 1;
  ldv_55855: ;
#line 114
  if ((int )pdvobjpriv->nr_endpoint > i) {
#line 116
    goto ldv_55854;
  } else {

  }

#line 148
  if (GlobalDebugLevel23A > 3U) {
#line 148
    printk("\016RTL8723AU: nr_endpoint =%d, in_num =%d, out_num =%d\n\n", (int )pdvobjpriv->nr_endpoint,
           (int )pdvobjpriv->RtNumInPipes, (int )pdvobjpriv->RtNumOutPipes);
  } else {

  }
#line 152
  if ((unsigned int )pusbd->speed == 3U) {
#line 153
    pdvobjpriv->ishighspeed = 1U;
#line 154
    if (GlobalDebugLevel23A > 3U) {
#line 154
      printk("\016RTL8723AU: USB_SPEED_HIGH\n");
    } else {

    }
  } else {
#line 156
    pdvobjpriv->ishighspeed = 0U;
#line 157
    if (GlobalDebugLevel23A > 3U) {
#line 157
      printk("\016RTL8723AU: NON USB_SPEED_HIGH\n");
    } else {

    }
  }
#line 160
  tmp___6 = rtw_init_intf_priv(pdvobjpriv);
#line 160
  if (tmp___6 == 0) {
#line 161
    if (GlobalDebugLevel23A > 3U) {
#line 161
      rt_trace(2048, 4, "Can\'t INIT rtw_init_intf_priv\n");
    } else {

    }
#line 163
    goto free_dvobj;
  } else {

  }
#line 166
  rtw_reset_continual_urb_error(pdvobjpriv);
#line 167
  usb_get_dev(pusbd);
#line 168
  status = 1;
  free_dvobj: ;
#line 170
  if (status != 1 && (unsigned long )pdvobjpriv != (unsigned long )((struct dvobj_priv *)0)) {
#line 171
    usb_set_intfdata(usb_intf, (void *)0);
#line 172
    mutex_destroy(& pdvobjpriv->hw_init_mutex);
#line 173
    mutex_destroy(& pdvobjpriv->h2c_fwcmd_mutex);
#line 174
    mutex_destroy(& pdvobjpriv->setch_mutex);
#line 175
    mutex_destroy(& pdvobjpriv->setbw_mutex);
#line 176
    kfree((void const   *)pdvobjpriv);
#line 177
    pdvobjpriv = (struct dvobj_priv *)0;
  } else {

  }
  exit: ;
#line 180
  return (pdvobjpriv);
}
}
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static void usb_dvobj_deinit(struct usb_interface *usb_intf ) 
{ 
  struct dvobj_priv *dvobj ;
  void *tmp ;
  struct usb_device *tmp___0 ;
  struct usb_device *tmp___1 ;
  struct usb_device *tmp___2 ;

  {
#line 185
  tmp = usb_get_intfdata(usb_intf);
#line 185
  dvobj = (struct dvobj_priv *)tmp;
#line 187
  usb_set_intfdata(usb_intf, (void *)0);
#line 188
  if ((unsigned long )dvobj != (unsigned long )((struct dvobj_priv *)0)) {
#line 190
    if (((unsigned int )dvobj->NumInterfaces != 2U && (unsigned int )dvobj->NumInterfaces != 3U) || (unsigned int )dvobj->InterfaceNumber == 1U) {
#line 192
      tmp___1 = interface_to_usbdev(usb_intf);
#line 192
      if ((unsigned int )tmp___1->state != 0U) {
#line 200
        if (GlobalDebugLevel23A > 3U) {
#line 200
          printk("\016RTL8723AU: usb attached..., try to reset usb device\n");
        } else {

        }
#line 201
        tmp___0 = interface_to_usbdev(usb_intf);
#line 201
        usb_reset_device(tmp___0);
      } else {

      }
    } else {

    }
#line 204
    rtw_deinit_intf_priv(dvobj);
#line 205
    mutex_destroy(& dvobj->hw_init_mutex);
#line 206
    mutex_destroy(& dvobj->h2c_fwcmd_mutex);
#line 207
    mutex_destroy(& dvobj->setch_mutex);
#line 208
    mutex_destroy(& dvobj->setbw_mutex);
#line 209
    kfree((void const   *)dvobj);
  } else {

  }
#line 211
  tmp___2 = interface_to_usbdev(usb_intf);
#line 211
  usb_put_dev(tmp___2);
#line 212
  return;
}
}
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
void rtl8723a_usb_intf_stop(struct rtw_adapter *padapter ) 
{ 


  {
#line 216
  if (GlobalDebugLevel23A > 3U) {
#line 216
    rt_trace(1048576, 4, "+usb_intf_stop\n");
  } else {

  }
#line 219
  if (padapter->bSurpriseRemoved == 0) {
#line 223
    if (GlobalDebugLevel23A > 3U) {
#line 223
      rt_trace(1048576, 4, "SurpriseRemoved == false\n");
    } else {

    }
  } else {

  }
#line 228
  rtl8723au_inirp_deinit(padapter);
#line 231
  rtl8723au_write_port_cancel(padapter);
#line 234
  if (GlobalDebugLevel23A > 3U) {
#line 234
    rt_trace(1048576, 4, "-usb_intf_stop\n");
  } else {

  }
#line 235
  return;
}
}
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static void rtw_dev_unload(struct rtw_adapter *padapter ) 
{ 
  struct submit_ctx *pack_tx_ops ;

  {
#line 239
  pack_tx_ops = & padapter->xmitpriv.ack_tx_ops;
#line 241
  if (GlobalDebugLevel23A > 3U) {
#line 241
    rt_trace(1048576, 4, "+rtw_dev_unload\n");
  } else {

  }
#line 243
  if (padapter->bup != 0) {
#line 244
    if (GlobalDebugLevel23A > 3U) {
#line 244
      printk("\016RTL8723AU: ===> rtw_dev_unload\n");
    } else {

    }
#line 246
    padapter->bDriverStopped = 1;
#line 247
    if (padapter->xmitpriv.ack_tx != 0) {
#line 248
      rtw23a_sctx_done_err(& pack_tx_ops, 9);
    } else {

    }
#line 252
    rtl8723a_usb_intf_stop(padapter);
#line 255
    ldv_flush_workqueue_714(padapter->cmdpriv.wq);
#line 258
    if (padapter->bSurpriseRemoved == 0) {
#line 259
      rtl8723au_hal_deinit(padapter);
#line 260
      padapter->bSurpriseRemoved = 1;
    } else {

    }
#line 262
    padapter->bup = 0;
  } else
#line 264
  if (GlobalDebugLevel23A > 3U) {
#line 264
    rt_trace(1048576, 4, "r871x_dev_unload():padapter->bup == false\n");
  } else {

  }
#line 267
  if (GlobalDebugLevel23A > 3U) {
#line 267
    printk("\016RTL8723AU: <=== rtw_dev_unload\n");
  } else {

  }
#line 268
  if (GlobalDebugLevel23A > 3U) {
#line 268
    rt_trace(1048576, 4, "-rtw_dev_unload\n");
  } else {

  }
#line 269
  return;
}
}
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static int rtw_suspend(struct usb_interface *pusb_intf , pm_message_t message ) 
{ 
  struct dvobj_priv *dvobj ;
  void *tmp ;
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  struct mlme_priv *pmlmepriv ;
  struct pwrctrl_priv *pwrpriv ;
  int ret ;
  unsigned long start_time ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  void *tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 273
  tmp = usb_get_intfdata(pusb_intf);
#line 273
  dvobj = (struct dvobj_priv *)tmp;
#line 274
  padapter = dvobj->if1;
#line 275
  pnetdev = padapter->pnetdev;
#line 276
  pmlmepriv = & padapter->mlmepriv;
#line 277
  pwrpriv = & padapter->pwrctrlpriv;
#line 278
  ret = 0;
#line 279
  start_time = jiffies;
#line 281
  if (GlobalDebugLevel23A > 3U) {
#line 281
    tmp___0 = get_current();
#line 281
    tmp___1 = get_current();
#line 281
    printk("\016RTL8723AU: ==> %s (%s:%d)\n", "rtw_suspend", (char *)(& tmp___1->comm),
           tmp___0->pid);
  } else {

  }
#line 283
  if ((padapter->bup == 0 || padapter->bDriverStopped != 0) || padapter->bSurpriseRemoved != 0) {
#line 285
    if (GlobalDebugLevel23A > 3U) {
#line 285
      printk("\016RTL8723AU: padapter->bup =%d bDriverStopped =%d bSurpriseRemoved = %d\n",
             padapter->bup, padapter->bDriverStopped, padapter->bSurpriseRemoved);
    } else {

    }
#line 288
    goto exit;
  } else {

  }
#line 290
  pwrpriv->bInSuspend = 1U;
#line 291
  rtw_cancel_all_timer23a(padapter);
#line 292
  LeaveAllPowerSaveMode23a(padapter);
#line 294
  down(& pwrpriv->lock);
#line 297
  if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
#line 298
    netif_carrier_off(pnetdev);
#line 299
    netif_tx_stop_all_queues(pnetdev);
  } else {

  }
#line 303
  rtw_disassoc_cmd23a(padapter, 0U, 0);
#line 305
  tmp___2 = check_fwstate(pmlmepriv, 8);
#line 305
  if ((int )tmp___2) {
#line 305
    tmp___3 = check_fwstate(pmlmepriv, 1);
#line 305
    if ((int )tmp___3) {
#line 307
      if (GlobalDebugLevel23A > 3U) {
#line 307
        printk("\016RTL8723AU: %s:%d %s(%pM), length:%d assoc_ssid.length:%d\n", "rtw_suspend",
               312, (u8 *)(& pmlmepriv->cur_network.network.Ssid.ssid), (u8 *)(& pmlmepriv->cur_network.network.MacAddress),
               (int )pmlmepriv->cur_network.network.Ssid.ssid_len, (int )pmlmepriv->assoc_ssid.ssid_len);
      } else {

      }
#line 314
      rtw_set_roaming(padapter, 1);
    } else {

    }
  } else {

  }
#line 317
  rtw_indicate_disconnect23a(padapter);
#line 319
  rtw_free_assoc_resources23a(padapter, 1);
#line 321
  rtw_free_network_queue23a(padapter);
#line 323
  rtw_dev_unload(padapter);
#line 324
  up(& pwrpriv->lock);
#line 326
  tmp___5 = check_fwstate(pmlmepriv, 2048);
#line 326
  if ((int )tmp___5) {
#line 327
    tmp___4 = wdev_priv___2(padapter->rtw_wdev);
#line 327
    rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___4, 1);
  } else {

  }
#line 330
  tmp___6 = check_fwstate(pmlmepriv, 128);
#line 330
  if ((int )tmp___6) {
#line 331
    rtw_indicate_disconnect23a(padapter);
  } else {

  }
  exit: ;
#line 334
  if (GlobalDebugLevel23A > 3U) {
#line 334
    tmp___7 = jiffies_to_msecs((unsigned long )jiffies - start_time);
#line 334
    printk("\016RTL8723AU: <===  %s return %d.............. in %dms\n", "rtw_suspend",
           ret, tmp___7);
  } else {

  }
#line 337
  return (ret);
}
}
#line 340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static int rtw_resume(struct usb_interface *pusb_intf ) 
{ 
  struct dvobj_priv *dvobj ;
  void *tmp ;
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  struct pwrctrl_priv *pwrpriv ;
  int ret ;
  unsigned long start_time ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  struct pid *tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 342
  tmp = usb_get_intfdata(pusb_intf);
#line 342
  dvobj = (struct dvobj_priv *)tmp;
#line 343
  padapter = dvobj->if1;
#line 345
  pwrpriv = (struct pwrctrl_priv *)0;
#line 346
  ret = -1;
#line 347
  start_time = jiffies;
#line 349
  if (GlobalDebugLevel23A > 3U) {
#line 349
    tmp___0 = get_current();
#line 349
    tmp___1 = get_current();
#line 349
    printk("\016RTL8723AU: ==> %s (%s:%d)\n", "rtw_resume", (char *)(& tmp___1->comm),
           tmp___0->pid);
  } else {

  }
#line 351
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 352
    goto exit;
  } else {

  }
#line 353
  pnetdev = padapter->pnetdev;
#line 354
  pwrpriv = & padapter->pwrctrlpriv;
#line 356
  down(& pwrpriv->lock);
#line 357
  rtw_reset_drv_sw23a(padapter);
#line 358
  pwrpriv->bkeepfwalive = 0U;
#line 360
  if (GlobalDebugLevel23A > 3U) {
#line 360
    printk("\016RTL8723AU: bkeepfwalive(%x)\n", (int )pwrpriv->bkeepfwalive);
  } else {

  }
#line 361
  tmp___2 = pm_netdev_open23a(pnetdev, 1);
#line 361
  if (tmp___2 != 0) {
#line 362
    up(& pwrpriv->lock);
#line 363
    goto exit;
  } else {

  }
#line 366
  netif_device_attach(pnetdev);
#line 367
  netif_carrier_on(pnetdev);
#line 369
  up(& pwrpriv->lock);
#line 371
  if (padapter->pid[1] != 0) {
#line 372
    if (GlobalDebugLevel23A > 3U) {
#line 372
      printk("\016RTL8723AU: pid[1]:%d\n", padapter->pid[1]);
    } else {

    }
#line 373
    tmp___3 = find_vpid(padapter->pid[1]);
#line 373
    kill_pid(tmp___3, 12, 1);
  } else {

  }
#line 376
  rtw23a_roaming(padapter, (struct wlan_network *)0);
#line 378
  ret = 0;
  exit: ;
#line 380
  if ((unsigned long )pwrpriv != (unsigned long )((struct pwrctrl_priv *)0)) {
#line 381
    pwrpriv->bInSuspend = 0U;
  } else {

  }
#line 382
  if (GlobalDebugLevel23A > 3U) {
#line 382
    tmp___4 = jiffies_to_msecs((unsigned long )jiffies - start_time);
#line 382
    printk("\016RTL8723AU: <===  %s return %d.............. in %dms\n", "rtw_resume",
           ret, tmp___4);
  } else {

  }
#line 385
  return (ret);
}
}
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static struct rtw_adapter *rtw_usb_if1_init(struct dvobj_priv *dvobj , struct usb_interface *pusb_intf ,
                                            struct usb_device_id  const  *pdid ) 
{ 
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  int status ;
  void *tmp ;
  u8 tmp___0 ;
  struct device *tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;

  {
#line 399
  padapter = (struct rtw_adapter *)0;
#line 400
  pnetdev = (struct net_device *)0;
#line 401
  status = 0;
#line 403
  pnetdev = rtw_init_netdev23a(padapter);
#line 404
  if ((unsigned long )pnetdev == (unsigned long )((struct net_device *)0)) {
#line 405
    goto free_adapter;
  } else {

  }
#line 406
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 406
  padapter = (struct rtw_adapter *)tmp;
#line 408
  padapter->dvobj = dvobj;
#line 409
  padapter->bDriverStopped = 1;
#line 410
  dvobj->if1 = padapter;
#line 411
  tmp___0 = dvobj->iface_nums;
#line 411
  dvobj->iface_nums = (u8 )((int )dvobj->iface_nums + 1);
#line 411
  dvobj->padapters[(int )tmp___0] = padapter;
#line 412
  padapter->iface_id = 0U;
#line 414
  rtl8723au_set_hw_type(padapter);
#line 416
  pnetdev->dev.parent = dvobj_to_dev(dvobj);
#line 418
  tmp___1 = dvobj_to_dev(dvobj);
#line 418
  tmp___2 = rtw_wdev_alloc(padapter, tmp___1);
#line 418
  if (tmp___2 != 0) {
#line 419
    goto free_adapter;
  } else {

  }
#line 422
  padapter->HalData = kzalloc(8032UL, 208U);
#line 423
  if ((unsigned long )padapter->HalData == (unsigned long )((void *)0)) {
#line 424
    goto free_wdev;
  } else {

  }
#line 427
  rtl8723a_read_chip_version(padapter);
#line 430
  tmp___3 = rtl8723au_chip_configure(padapter);
#line 430
  if (tmp___3) {
#line 430
    tmp___4 = 0;
  } else {
#line 430
    tmp___4 = 1;
  }
#line 430
  if (tmp___4) {
#line 431
    goto free_hal_data;
  } else {

  }
#line 434
  rtl8723a_read_adapter_info(padapter);
#line 437
  tmp___5 = rtw_init_drv_sw23a(padapter);
#line 437
  if (tmp___5 == 0) {
#line 438
    if (GlobalDebugLevel23A > 3U) {
#line 438
      rt_trace(1048576, 4, "Initialize driver software resource Failed!\n");
    } else {

    }
#line 440
    goto free_hal_data;
  } else {

  }
#line 444
  if ((unsigned int )padapter->pwrctrlpriv.bSupportRemoteWakeup != 0U) {
#line 445
    (dvobj->pusbdev)->do_remote_wakeup = 1U;
#line 446
    pusb_intf->needs_remote_wakeup = 1U;
#line 447
    device_init_wakeup(& pusb_intf->dev, 1);
#line 448
    if (GlobalDebugLevel23A > 3U) {
#line 448
      printk("\016RTL8723AU: \n  padapter->pwrctrlpriv.bSupportRemoteWakeup~~~~~~\n");
    } else {

    }
#line 449
    if (GlobalDebugLevel23A > 3U) {
#line 449
      tmp___6 = device_may_wakeup(& pusb_intf->dev);
#line 449
      printk("\016RTL8723AU: \n  padapter->pwrctrlpriv.bSupportRemoteWakeup~~~[%d]~~~\n",
             (int )tmp___6);
    } else {

    }
  } else {

  }
#line 456
  tmp___7 = usb_autopm_get_interface(pusb_intf);
#line 456
  if (tmp___7 < 0) {
#line 457
    if (GlobalDebugLevel23A > 3U) {
#line 457
      printk("\016RTL8723AU: can\'t get autopm:\n");
    } else {

    }
  } else {

  }
#line 459
  padapter->pwrctrlpriv.autopm_cnt = 1U;
#line 463
  tmp___8 = is_broadcast_ether_addr((u8 const   *)(& padapter->eeprompriv.mac_addr));
#line 463
  if ((int )tmp___8) {
#line 465
    eth_random_addr((u8 *)(& padapter->eeprompriv.mac_addr));
  } else {
#line 463
    tmp___9 = is_zero_ether_addr((u8 const   *)(& padapter->eeprompriv.mac_addr));
#line 463
    if ((int )tmp___9) {
#line 465
      eth_random_addr((u8 *)(& padapter->eeprompriv.mac_addr));
    } else {

    }
  }
#line 467
  if (GlobalDebugLevel23A > 3U) {
#line 467
    printk("\016RTL8723AU: bDriverStopped:%d, bSurpriseRemoved:%d, bup:%d, hw_init_completed:%d\n",
           padapter->bDriverStopped, padapter->bSurpriseRemoved, padapter->bup, (int )padapter->hw_init_completed);
  } else {

  }
#line 471
  status = 1;
  free_hal_data: ;
#line 474
  if (status != 1) {
#line 475
    kfree((void const   *)padapter->HalData);
  } else {

  }
  free_wdev: ;
#line 477
  if (status != 1) {
#line 478
    rtw_wdev_unregister(padapter->rtw_wdev);
#line 479
    rtw_wdev_free(padapter->rtw_wdev);
  } else {

  }
  free_adapter: ;
#line 482
  if (status != 1) {
#line 483
    if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
#line 484
      ldv_free_netdev_715(pnetdev);
    } else {

    }
#line 485
    padapter = (struct rtw_adapter *)0;
  } else {

  }
#line 487
  return (padapter);
}
}
#line 490 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static void rtw_usb_if1_deinit(struct rtw_adapter *if1 ) 
{ 
  struct net_device *pnetdev ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;

  {
#line 492
  pnetdev = if1->pnetdev;
#line 493
  pmlmepriv = & if1->mlmepriv;
#line 495
  tmp = check_fwstate(pmlmepriv, 1);
#line 495
  if ((int )tmp) {
#line 496
    rtw_disassoc_cmd23a(if1, 0U, 0);
  } else {

  }
#line 499
  free_mlme_ap_info23a(if1);
#line 502
  if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
#line 503
    ldv_unregister_netdev_716(pnetdev);
  } else {

  }
#line 505
  rtw_cancel_all_timer23a(if1);
#line 507
  rtw_dev_unload(if1);
#line 509
  if (GlobalDebugLevel23A > 3U) {
#line 509
    printk("\016RTL8723AU: +r871xu_dev_remove, hw_init_completed =%d\n", (int )if1->hw_init_completed);
  } else {

  }
#line 512
  if ((unsigned long )if1->rtw_wdev != (unsigned long )((struct wireless_dev *)0)) {
#line 513
    rtw_wdev_unregister(if1->rtw_wdev);
#line 514
    rtw_wdev_free(if1->rtw_wdev);
  } else {

  }
#line 518
  if ((unsigned int )if1->pwrctrlpriv.autopm_cnt == 1U) {
#line 519
    usb_autopm_put_interface((if1->dvobj)->pusbintf);
#line 520
    if1->pwrctrlpriv.autopm_cnt = (u8 )((int )if1->pwrctrlpriv.autopm_cnt - 1);
  } else {

  }
#line 524
  rtw_free_drv_sw23a(if1);
#line 526
  if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
#line 527
    ldv_free_netdev_717(pnetdev);
  } else {

  }
#line 528
  return;
}
}
#line 530 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static int rtw_drv_init(struct usb_interface *pusb_intf , struct usb_device_id  const  *pdid ) 
{ 
  struct rtw_adapter *if1 ;
  struct dvobj_priv *dvobj ;
  int status ;

  {
#line 533
  if1 = (struct rtw_adapter *)0;
#line 535
  status = 0;
#line 537
  if (GlobalDebugLevel23A > 3U) {
#line 537
    rt_trace(1048576, 4, "+rtw_drv_init\n");
  } else {

  }
#line 540
  dvobj = usb_dvobj_init(pusb_intf);
#line 541
  if ((unsigned long )dvobj == (unsigned long )((struct dvobj_priv *)0)) {
#line 542
    if (GlobalDebugLevel23A > 3U) {
#line 542
      rt_trace(1048576, 4, "initialize device object priv Failed!\n");
    } else {

    }
#line 544
    goto exit;
  } else {

  }
#line 547
  if1 = rtw_usb_if1_init(dvobj, pusb_intf, pdid);
#line 548
  if ((unsigned long )if1 == (unsigned long )((struct rtw_adapter *)0)) {
#line 549
    if (GlobalDebugLevel23A > 3U) {
#line 549
      printk("\016RTL8723AU: rtw_init_primary_adapter Failed!\n");
    } else {

    }
#line 550
    goto free_dvobj;
  } else {

  }
#line 554
  status = rtw_drv_register_netdev(if1);
#line 555
  if (status != 1) {
#line 556
    goto free_if1;
  } else {

  }
#line 557
  if (GlobalDebugLevel23A > 3U) {
#line 557
    rt_trace(1048576, 4, "-871x_drv - drv_init, success!\n");
  } else {

  }
#line 560
  status = 1;
  free_if1: ;
#line 563
  if (status != 1 && (unsigned long )if1 != (unsigned long )((struct rtw_adapter *)0)) {
#line 564
    rtw_usb_if1_deinit(if1);
  } else {

  }
  free_dvobj: ;
#line 566
  if (status != 1) {
#line 567
    usb_dvobj_deinit(pusb_intf);
  } else {

  }
  exit: ;
#line 569
  return (status == 1 ? 0 : -19);
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static void rtw_disconnect(struct usb_interface *pusb_intf ) 
{ 
  struct dvobj_priv *dvobj ;
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  struct mlme_priv *pmlmepriv ;
  void *tmp ;

  {
#line 580
  tmp = usb_get_intfdata(pusb_intf);
#line 580
  dvobj = (struct dvobj_priv *)tmp;
#line 581
  if ((unsigned long )dvobj == (unsigned long )((struct dvobj_priv *)0)) {
#line 582
    return;
  } else {

  }
#line 584
  padapter = dvobj->if1;
#line 585
  pnetdev = padapter->pnetdev;
#line 586
  pmlmepriv = & padapter->mlmepriv;
#line 588
  usb_set_intfdata(pusb_intf, (void *)0);
#line 590
  if (GlobalDebugLevel23A > 3U) {
#line 590
    rt_trace(1048576, 4, "+dev_remove()\n");
  } else {

  }
#line 592
  rtw_pm_set_ips23a(padapter, 0);
#line 593
  rtw_pm_set_lps23a(padapter, 0);
#line 595
  LeaveAllPowerSaveMode23a(padapter);
#line 597
  rtw_usb_if1_deinit(padapter);
#line 599
  usb_dvobj_deinit(pusb_intf);
#line 601
  if (GlobalDebugLevel23A > 3U) {
#line 601
    rt_trace(1048576, 4, "-dev_remove()\n");
  } else {

  }
#line 602
  if (GlobalDebugLevel23A > 3U) {
#line 602
    printk("\016RTL8723AU: -r871xu_dev_remove, done\n");
  } else {

  }
#line 603
  return;
}
}
#line 605 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static int rtw_drv_entry(void) 
{ 
  int tmp ;

  {
#line 607
  if (GlobalDebugLevel23A > 3U) {
#line 607
    rt_trace(1048576, 4, "+rtw_drv_entry\n");
  } else {

  }
#line 608
  tmp = ldv_usb_register_driver_718(usb_drv, & __this_module, "r8723au");
#line 608
  return (tmp);
}
}
#line 611 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.c"
static void rtw_drv_halt(void) 
{ 


  {
#line 613
  if (GlobalDebugLevel23A > 3U) {
#line 613
    rt_trace(1048576, 4, "+rtw_drv_halt\n");
  } else {

  }
#line 614
  if (GlobalDebugLevel23A > 3U) {
#line 614
    printk("\016RTL8723AU: +rtw_drv_halt\n");
  } else {

  }
#line 616
  ldv_usb_deregister_719(usb_drv);
#line 618
  if (GlobalDebugLevel23A > 3U) {
#line 618
    printk("\016RTL8723AU: -rtw_drv_halt\n");
  } else {

  }
#line 619
  return;
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_retval_5  ;
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_retval_4  ;
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_retval_6  ;
#line 253
extern void ldv_initialize(void) ;
#line 254
void ldv_check_final_state(void) ;
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_retval_2  ;
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void ldv_usb_driver_14(void) 
{ 
  void *tmp ;

  {
#line 259
  tmp = ldv_init_zalloc(1560UL);
#line 259
  rtl8723a_usb_drv_group1 = (struct usb_interface *)tmp;
#line 260
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void main(void) 
{ 
  struct usb_device_id *ldvarg47 ;
  void *tmp ;
  pm_message_t ldvarg46 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 276
  tmp = ldv_init_zalloc(32UL);
#line 276
  ldvarg47 = (struct usb_device_id *)tmp;
#line 274
  ldv_initialize();
#line 277
  ldv_memset((void *)(& ldvarg46), 0, 4UL);
#line 280
  timer_init_11();
#line 282
  ldv_state_variable_11 = 1;
#line 284
  timer_init_7();
#line 286
  ldv_state_variable_7 = 1;
#line 287
  ldv_state_variable_17 = 0;
#line 289
  work_init_2();
#line 291
  ldv_state_variable_2 = 1;
#line 293
  work_init_1();
#line 295
  ldv_state_variable_1 = 1;
#line 296
  ref_cnt = 0;
#line 297
  ldv_state_variable_0 = 1;
#line 298
  ldv_state_variable_16 = 0;
#line 300
  timer_init_13();
#line 302
  ldv_state_variable_13 = 1;
#line 304
  timer_init_6();
#line 306
  ldv_state_variable_6 = 1;
#line 308
  work_init_3();
#line 310
  ldv_state_variable_3 = 1;
#line 312
  timer_init_9();
#line 314
  ldv_state_variable_9 = 1;
#line 316
  timer_init_12();
#line 318
  ldv_state_variable_12 = 1;
#line 319
  ldv_state_variable_14 = 0;
#line 320
  ldv_state_variable_15 = 0;
#line 322
  timer_init_8();
#line 324
  ldv_state_variable_8 = 1;
#line 326
  timer_init_4();
#line 328
  ldv_state_variable_4 = 1;
#line 330
  timer_init_10();
#line 332
  ldv_state_variable_10 = 1;
#line 334
  timer_init_5();
#line 336
  ldv_state_variable_5 = 1;
  ldv_56002: 
#line 338
  tmp___0 = __VERIFIER_nondet_int();
#line 338
  switch (tmp___0) {
  case 0: ;
#line 345
  goto ldv_55971;
  case 1: ;
#line 352
  goto ldv_55971;
  case 2: ;
#line 356
  if (ldv_state_variable_17 != 0) {
#line 357
    ldv_main_exported_17();
  } else {

  }
#line 360
  goto ldv_55971;
  case 3: ;
#line 367
  goto ldv_55971;
  case 4: ;
#line 374
  goto ldv_55971;
  case 5: ;
#line 378
  if (ldv_state_variable_0 != 0) {
#line 379
    tmp___1 = __VERIFIER_nondet_int();
#line 379
    switch (tmp___1) {
    case 0: ;
#line 382
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
#line 384
      rtw_drv_halt();
#line 385
      ldv_state_variable_0 = 3;
#line 386
      goto ldv_final;
    } else {

    }
#line 389
    goto ldv_55979;
    case 1: ;
#line 392
    if (ldv_state_variable_0 == 1) {
#line 394
      ldv_retval_2 = rtw_drv_entry();
#line 395
      if (ldv_retval_2 != 0) {
#line 396
        ldv_state_variable_0 = 3;
#line 397
        goto ldv_final;
      } else {

      }
#line 400
      if (ldv_retval_2 == 0) {
#line 401
        ldv_state_variable_0 = 2;
#line 402
        ldv_state_variable_16 = 1;
#line 403
        ldv_initialize_cfg80211_ops_16();
      } else {

      }
    } else {

    }
#line 407
    goto ldv_55979;
    default: 
#line 408
    ldv_stop();
    }
    ldv_55979: ;
  } else {

  }
#line 412
  goto ldv_55971;
  case 6: ;
#line 416
  if (ldv_state_variable_16 != 0) {
#line 417
    ldv_main_exported_16();
  } else {

  }
#line 420
  goto ldv_55971;
  case 7: ;
#line 427
  goto ldv_55971;
  case 8: ;
#line 434
  goto ldv_55971;
  case 9: ;
#line 441
  goto ldv_55971;
  case 10: ;
#line 448
  goto ldv_55971;
  case 11: ;
#line 455
  goto ldv_55971;
  case 12: ;
#line 459
  if (ldv_state_variable_14 != 0) {
#line 460
    tmp___2 = __VERIFIER_nondet_int();
#line 460
    switch (tmp___2) {
    case 0: ;
#line 463
    if (ldv_state_variable_14 == 1) {
#line 465
      ldv_retval_6 = rtw_drv_init(rtl8723a_usb_drv_group1, (struct usb_device_id  const  *)ldvarg47);
#line 466
      if (ldv_retval_6 == 0) {
#line 467
        ldv_state_variable_14 = 2;
#line 468
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 472
    goto ldv_55990;
    case 1: ;
#line 475
    if (ldv_state_variable_14 == 2) {
#line 477
      rtw_suspend(rtl8723a_usb_drv_group1, ldvarg46);
#line 478
      ldv_state_variable_14 = 3;
    } else {

    }
#line 481
    goto ldv_55990;
    case 2: ;
#line 484
    if (ldv_state_variable_14 == 3) {
#line 486
      ldv_retval_5 = rtw_resume(rtl8723a_usb_drv_group1);
#line 487
      if (ldv_retval_5 == 0) {
#line 488
        ldv_state_variable_14 = 2;
      } else {

      }
    } else {

    }
#line 492
    goto ldv_55990;
    case 3: ;
#line 495
    if (ldv_state_variable_14 == 3) {
#line 497
      ldv_retval_4 = rtw_resume(rtl8723a_usb_drv_group1);
#line 498
      if (ldv_retval_4 == 0) {
#line 499
        ldv_state_variable_14 = 2;
      } else {

      }
    } else {

    }
#line 503
    goto ldv_55990;
    case 4: ;
#line 506
    if (ldv_state_variable_14 == 3 && usb_counter == 0) {
#line 508
      rtw_disconnect(rtl8723a_usb_drv_group1);
#line 509
      ldv_state_variable_14 = 1;
#line 510
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 513
    if (ldv_state_variable_14 == 2 && usb_counter == 0) {
#line 515
      rtw_disconnect(rtl8723a_usb_drv_group1);
#line 516
      ldv_state_variable_14 = 1;
#line 517
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 520
    goto ldv_55990;
    default: 
#line 521
    ldv_stop();
    }
    ldv_55990: ;
  } else {

  }
#line 525
  goto ldv_55971;
  case 13: ;
#line 529
  if (ldv_state_variable_15 != 0) {
#line 530
    ldv_main_exported_15();
  } else {

  }
#line 533
  goto ldv_55971;
  case 14: ;
#line 540
  goto ldv_55971;
  case 15: ;
#line 547
  goto ldv_55971;
  case 16: ;
#line 554
  goto ldv_55971;
  case 17: ;
#line 561
  goto ldv_55971;
  default: 
#line 562
  ldv_stop();
  }
  ldv_55971: ;
#line 564
  goto ldv_56002;
  ldv_final: 
#line 566
  ldv_check_final_state();
#line 567
  return;
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
bool ldv_queue_work_on_709(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 598
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 598
  ldv_func_res = tmp;
#line 600
  activate_work_2(ldv_func_arg3, 2);
#line 602
  return (ldv_func_res);
}
}
#line 605 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
bool ldv_queue_delayed_work_on_710(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 609
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 609
  ldv_func_res = tmp;
#line 611
  activate_work_2(& ldv_func_arg3->work, 2);
#line 613
  return (ldv_func_res);
}
}
#line 616 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
bool ldv_queue_work_on_711(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 620
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 620
  ldv_func_res = tmp;
#line 622
  activate_work_2(ldv_func_arg3, 2);
#line 624
  return (ldv_func_res);
}
}
#line 627 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void ldv_flush_workqueue_712(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 630
  flush_workqueue(ldv_func_arg1);
#line 632
  call_and_disable_all_2(2);
#line 633
  return;
}
}
#line 635 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
bool ldv_queue_delayed_work_on_713(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 639
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 639
  ldv_func_res = tmp;
#line 641
  activate_work_2(& ldv_func_arg3->work, 2);
#line 643
  return (ldv_func_res);
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void ldv_flush_workqueue_714(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 649
  flush_workqueue(ldv_func_arg1);
#line 651
  call_and_disable_all_2(2);
#line 652
  return;
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void ldv_free_netdev_715(struct net_device *dev ) 
{ 


  {
#line 657
  free_netdev(dev);
#line 659
  ldv_state_variable_17 = 0;
#line 660
  return;
}
}
#line 662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void ldv_unregister_netdev_716(struct net_device *dev ) 
{ 


  {
#line 665
  unregister_netdev(dev);
#line 667
  ldv_state_variable_17 = 0;
#line 668
  return;
}
}
#line 670 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void ldv_free_netdev_717(struct net_device *dev ) 
{ 


  {
#line 673
  free_netdev(dev);
#line 675
  ldv_state_variable_17 = 0;
#line 676
  return;
}
}
#line 678 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_usb_register_driver_718(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 682
  tmp = usb_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 682
  ldv_func_res = tmp;
#line 684
  ldv_state_variable_14 = 1;
#line 685
  usb_counter = 0;
#line 686
  ldv_usb_driver_14();
#line 689
  return (ldv_func_res);
}
}
#line 692 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void ldv_usb_deregister_719(struct usb_driver *arg ) 
{ 


  {
#line 695
  usb_deregister(arg);
#line 697
  ldv_state_variable_14 = 0;
#line 698
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_735(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_737(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_736(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_739(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_738(struct workqueue_struct *ldv_func_arg1 ) ;
#line 1608 "include/linux/usb.h"
extern void usb_kill_urb(struct urb * ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.c"
void rtl8723au_read_port_cancel(struct rtw_adapter *padapter ) 
{ 
  struct recv_buf *precvbuf ;
  int i ;

  {
#line 26
  precvbuf = (struct recv_buf *)padapter->recvpriv.precv_buf;
#line 28
  if (GlobalDebugLevel23A > 3U) {
#line 28
    printk("\016RTL8723AU: %s\n", "rtl8723au_read_port_cancel");
  } else {

  }
#line 30
  padapter->bReadPortCancel = 1U;
#line 32
  i = 0;
#line 32
  goto ldv_55751;
  ldv_55750: ;
#line 33
  if ((unsigned long )precvbuf->purb != (unsigned long )((struct urb *)0)) {
#line 34
    usb_kill_urb(precvbuf->purb);
  } else {

  }
#line 35
  precvbuf = precvbuf + 1;
#line 32
  i = i + 1;
  ldv_55751: ;
#line 32
  if (i <= 3) {
#line 34
    goto ldv_55750;
  } else {

  }
#line 37
  usb_kill_urb(padapter->recvpriv.int_in_urb);
#line 38
  return;
}
}
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.c"
static void usb_write_port23a_complete(struct urb *purb ) 
{ 
  struct xmit_buf *pxmitbuf ;
  struct rtw_adapter *padapter ;
  struct xmit_priv *pxmitpriv ;
  struct hal_data_8723a *phaldata ;
  unsigned long irqL ;
  raw_spinlock_t *tmp ;

  {
#line 42
  pxmitbuf = (struct xmit_buf *)purb->context;
#line 43
  padapter = pxmitbuf->padapter;
#line 44
  pxmitpriv = & padapter->xmitpriv;
#line 48
  switch ((int )pxmitbuf->flags) {
  case 6: 
#line 51
  rtw_chk_hi_queue_cmd23a(padapter);
#line 53
  goto ldv_55762;
  default: ;
#line 55
  goto ldv_55762;
  }
  ldv_55762: ;
#line 58
  if ((padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) || (unsigned int )padapter->bWritePortCancel != 0U) {
#line 60
    if (GlobalDebugLevel23A > 3U) {
#line 60
      rt_trace(16777216, 4, "usb_write_port23a_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n",
               padapter->bDriverStopped, padapter->bSurpriseRemoved);
    } else {

    }
#line 63
    if (GlobalDebugLevel23A > 3U) {
#line 63
      printk("\016RTL8723AU: %s(): TX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bWritePortCancel(%d) pxmitbuf->ext_tag(%x)\n",
             "usb_write_port23a_complete", padapter->bDriverStopped, padapter->bSurpriseRemoved,
             (int )padapter->bReadPortCancel, (int )pxmitbuf->ext_tag);
    } else {

    }
#line 69
    goto check_completion;
  } else {

  }
#line 72
  if (purb->status != 0) {
#line 73
    if (GlobalDebugLevel23A > 3U) {
#line 73
      rt_trace(16777216, 4, "usb_write_port23a_complete : purb->status(%d) != 0\n",
               purb->status);
    } else {

    }
#line 76
    if (GlobalDebugLevel23A > 3U) {
#line 76
      printk("\016RTL8723AU: ###=> urb_write_port_complete status(%d)\n", purb->status);
    } else {

    }
#line 78
    if (purb->status == -32 || purb->status == -71) {

    } else
#line 79
    if (purb->status == -115) {
#line 80
      if (GlobalDebugLevel23A > 3U) {
#line 80
        rt_trace(16777216, 4, "usb_write_port23a_complete: EINPROGESS\n");
      } else {

      }
#line 82
      goto check_completion;
    } else
#line 83
    if (purb->status == -2) {
#line 84
      if (GlobalDebugLevel23A > 3U) {
#line 84
        printk("\016RTL8723AU: %s: -ENOENT\n", "usb_write_port23a_complete");
      } else {

      }
#line 85
      goto check_completion;
    } else
#line 86
    if (purb->status == -104) {
#line 87
      if (GlobalDebugLevel23A > 3U) {
#line 87
        printk("\016RTL8723AU: %s: -ECONNRESET\n", "usb_write_port23a_complete");
      } else {

      }
#line 88
      goto check_completion;
    } else
#line 89
    if (purb->status == -108) {
#line 90
      if (GlobalDebugLevel23A > 3U) {
#line 90
        rt_trace(16777216, 4, "usb_write_port23a_complete: ESHUTDOWN\n");
      } else {

      }
#line 92
      padapter->bDriverStopped = 1;
#line 93
      if (GlobalDebugLevel23A > 3U) {
#line 93
        rt_trace(16777216, 4, "usb_write_port23a_complete:bDriverStopped = true\n");
      } else {

      }
#line 95
      goto check_completion;
    } else {
#line 97
      padapter->bSurpriseRemoved = 1;
#line 98
      if (GlobalDebugLevel23A > 3U) {
#line 98
        printk("\016RTL8723AU: bSurpriseRemoved = true\n");
      } else {

      }
#line 99
      if (GlobalDebugLevel23A > 3U) {
#line 99
        rt_trace(16777216, 4, "usb_write_port23a_complete:bSurpriseRemoved = true\n");
      } else {

      }
#line 101
      goto check_completion;
    }
  } else {

  }
#line 104
  phaldata = (struct hal_data_8723a *)padapter->HalData;
#line 105
  phaldata->srestpriv.last_tx_complete_time = jiffies;
  check_completion: 
#line 108
  tmp = spinlock_check(& pxmitpriv->lock_sctx);
#line 108
  irqL = _raw_spin_lock_irqsave(tmp);
#line 109
  rtw23a_sctx_done_err(& pxmitbuf->sctx, purb->status != 0 ? 5 : 0);
#line 112
  spin_unlock_irqrestore(& pxmitpriv->lock_sctx, irqL);
#line 114
  rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
#line 116
  tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
#line 117
  return;
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.c"
int rtl8723au_write_port(struct rtw_adapter *padapter , u32 addr , u32 cnt , struct xmit_buf *pxmitbuf ) 
{ 
  struct urb *purb ;
  struct dvobj_priv *pdvobj ;
  struct xmit_priv *pxmitpriv ;
  struct xmit_frame *pxmitframe ;
  struct usb_device *pusbd ;
  unsigned long irqL ;
  unsigned int pipe ;
  unsigned int ep_num ;
  int status ;
  int ret ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;
  struct hal_data_8723a *phaldata ;

  {
#line 122
  purb = (struct urb *)0;
#line 123
  pdvobj = padapter->dvobj;
#line 124
  pxmitpriv = & padapter->xmitpriv;
#line 126
  pusbd = pdvobj->pusbdev;
#line 130
  ret = 0;
#line 132
  if (GlobalDebugLevel23A > 3U) {
#line 132
    rt_trace(16777216, 4, "+usb_write_port23a\n");
  } else {

  }
#line 134
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 135
    if (GlobalDebugLevel23A > 3U) {
#line 135
      rt_trace(16777216, 4, "%s:(padapter->bDriverStopped || padapter->bSurpriseRemoved)!!!\n",
               "rtl8723au_write_port");
    } else {

    }
#line 138
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 7);
#line 139
    goto exit;
  } else {

  }
#line 142
  pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data;
#line 143
  tmp = spinlock_check(& pxmitpriv->lock);
#line 143
  irqL = _raw_spin_lock_irqsave(tmp);
#line 145
  switch (addr) {
  case 0U: 
#line 147
  pxmitbuf->flags = 0U;
#line 148
  goto ldv_55791;
  case 1U: 
#line 150
  pxmitbuf->flags = 1U;
#line 151
  goto ldv_55791;
  case 2U: 
#line 153
  pxmitbuf->flags = 2U;
#line 154
  goto ldv_55791;
  case 3U: 
#line 156
  pxmitbuf->flags = 3U;
#line 157
  goto ldv_55791;
  case 6U: 
#line 159
  pxmitbuf->flags = 6U;
#line 160
  goto ldv_55791;
  default: 
#line 162
  pxmitbuf->flags = 5U;
#line 163
  goto ldv_55791;
  }
  ldv_55791: 
#line 166
  spin_unlock_irqrestore(& pxmitpriv->lock, irqL);
#line 168
  purb = pxmitbuf->pxmit_urb[0];
#line 171
  ep_num = (unsigned int )pdvobj->Queue2Pipe[addr];
#line 172
  tmp___0 = __create_pipe(pusbd, ep_num);
#line 172
  pipe = tmp___0 | 3221225472U;
#line 174
  usb_fill_bulk_urb(purb, pusbd, pipe, (void *)pxmitframe->buf_addr, (int )cnt, & usb_write_port23a_complete,
                    (void *)pxmitbuf);
#line 179
  status = usb_submit_urb(purb, 32U);
#line 180
  if (status == 0) {
#line 181
    phaldata = (struct hal_data_8723a *)padapter->HalData;
#line 182
    phaldata->srestpriv.last_tx_time = jiffies;
  } else {
#line 184
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 5);
#line 186
    if (GlobalDebugLevel23A > 3U) {
#line 186
      printk("\016RTL8723AU: usb_write_port23a, status =%d\n", status);
    } else {

    }
#line 187
    if (GlobalDebugLevel23A > 3U) {
#line 187
      rt_trace(16777216, 4, "usb_write_port23a(): usb_submit_urb, status =%x\n", status);
    } else {

    }
#line 191
    switch (status) {
    case -19: 
#line 193
    padapter->bDriverStopped = 1;
#line 194
    goto ldv_55799;
    default: ;
#line 196
    goto ldv_55799;
    }
    ldv_55799: ;
#line 198
    goto exit;
  }
#line 200
  ret = 1;
#line 201
  if (GlobalDebugLevel23A > 3U) {
#line 201
    rt_trace(16777216, 4, "-usb_write_port23a\n");
  } else {

  }
  exit: ;
#line 204
  if (ret != 1) {
#line 205
    rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
  } else {

  }
#line 207
  return (ret);
}
}
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.c"
void rtl8723au_write_port_cancel(struct rtw_adapter *padapter ) 
{ 
  struct xmit_buf *pxmitbuf ;
  struct list_head *plist ;
  int j ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 216
  if (GlobalDebugLevel23A > 3U) {
#line 216
    printk("\016RTL8723AU: %s\n", "rtl8723au_write_port_cancel");
  } else {

  }
#line 218
  padapter->bWritePortCancel = 1U;
#line 220
  plist = padapter->xmitpriv.xmitbuf_list.next;
#line 220
  goto ldv_55814;
  ldv_55813: 
#line 221
  __mptr = (struct list_head  const  *)plist;
#line 221
  pxmitbuf = (struct xmit_buf *)__mptr + 0xfffffffffffffff0UL;
#line 222
  j = 0;
#line 222
  goto ldv_55811;
  ldv_55810: ;
#line 223
  if ((unsigned long )pxmitbuf->pxmit_urb[j] != (unsigned long )((struct urb *)0)) {
#line 224
    usb_kill_urb(pxmitbuf->pxmit_urb[j]);
  } else {

  }
#line 222
  j = j + 1;
  ldv_55811: ;
#line 222
  if (j <= 7) {
#line 224
    goto ldv_55810;
  } else {

  }
#line 220
  plist = plist->next;
  ldv_55814: ;
#line 220
  if ((unsigned long )(& padapter->xmitpriv.xmitbuf_list) != (unsigned long )plist) {
#line 222
    goto ldv_55813;
  } else {

  }
#line 227
  plist = padapter->xmitpriv.xmitextbuf_list.next;
#line 227
  goto ldv_55822;
  ldv_55821: 
#line 228
  __mptr___0 = (struct list_head  const  *)plist;
#line 228
  pxmitbuf = (struct xmit_buf *)__mptr___0 + 0xfffffffffffffff0UL;
#line 229
  j = 0;
#line 229
  goto ldv_55819;
  ldv_55818: ;
#line 230
  if ((unsigned long )pxmitbuf->pxmit_urb[j] != (unsigned long )((struct urb *)0)) {
#line 231
    usb_kill_urb(pxmitbuf->pxmit_urb[j]);
  } else {

  }
#line 229
  j = j + 1;
  ldv_55819: ;
#line 229
  if (j <= 7) {
#line 231
    goto ldv_55818;
  } else {

  }
#line 227
  plist = plist->next;
  ldv_55822: ;
#line 227
  if ((unsigned long )(& padapter->xmitpriv.xmitextbuf_list) != (unsigned long )plist) {
#line 229
    goto ldv_55821;
  } else {

  }

#line 234
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
bool ldv_queue_work_on_735(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
bool ldv_queue_delayed_work_on_736(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
bool ldv_queue_work_on_737(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
void ldv_flush_workqueue_738(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
bool ldv_queue_delayed_work_on_739(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_749(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_751(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_750(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_753(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_752(struct workqueue_struct *ldv_func_arg1 ) ;
#line 3296 "include/linux/skbuff.h"
__inline static u16 skb_get_queue_mapping(struct sk_buff  const  *skb ) 
{ 


  {
#line 3298
  return ((u16 )skb->queue_mapping);
}
}
#line 2565 "include/linux/netdevice.h"
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue ) 
{ 


  {
#line 2567
  set_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2568
  return;
}
}
#line 2802 "include/linux/netdevice.h"
__inline static void netif_stop_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2804
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2804
  txq = tmp;
#line 2805
  netif_tx_stop_queue(txq);
#line 2806
  return;
}
}
#line 2815 "include/linux/netdevice.h"
__inline static bool __netif_subqueue_stopped(struct net_device  const  *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  bool tmp___0 ;

  {
#line 2818
  tmp = netdev_get_tx_queue(dev, (unsigned int )queue_index);
#line 2818
  txq = tmp;
#line 2820
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)txq);
#line 2820
  return (tmp___0);
}
}
#line 2829
extern void netif_wake_subqueue(struct net_device * , u16  ) ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/xmit_linux.c"
int rtw_os_xmit_resource_alloc23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ,
                                  u32 alloc_sz ) 
{ 
  int i ;
  void *tmp ;

  {
#line 32
  tmp = kzalloc((size_t )alloc_sz, 208U);
#line 32
  pxmitbuf->pallocated_buf = (u8 *)tmp;
#line 33
  if ((unsigned long )pxmitbuf->pallocated_buf == (unsigned long )((u8 *)0U)) {
#line 34
    return (0);
  } else {

  }
#line 36
  pxmitbuf->pbuf = (u8 *)(((unsigned long )pxmitbuf->pallocated_buf + 511UL) & 0xfffffffffffffe00UL);
#line 38
  i = 0;
#line 38
  goto ldv_53181;
  ldv_53180: 
#line 39
  pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, 208U);
#line 40
  if ((unsigned long )pxmitbuf->pxmit_urb[i] == (unsigned long )((struct urb *)0)) {
#line 41
    if (GlobalDebugLevel23A > 3U) {
#line 41
      printk("\016RTL8723AU: pxmitbuf->pxmit_urb[i]==NULL");
    } else {

    }
#line 42
    return (0);
  } else {

  }
#line 38
  i = i + 1;
  ldv_53181: ;
#line 38
  if (i <= 7) {
#line 40
    goto ldv_53180;
  } else {

  }

#line 45
  return (1);
}
}
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/xmit_linux.c"
void rtw_os_xmit_resource_free23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ) 
{ 
  int i ;

  {
#line 53
  i = 0;
#line 53
  goto ldv_53189;
  ldv_53188: 
#line 54
  usb_free_urb(pxmitbuf->pxmit_urb[i]);
#line 53
  i = i + 1;
  ldv_53189: ;
#line 53
  if (i <= 7) {
#line 55
    goto ldv_53188;
  } else {

  }
#line 55
  kfree((void const   *)pxmitbuf->pallocated_buf);
#line 56
  return;
}
}
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/xmit_linux.c"
void rtw_os_pkt_complete23a(struct rtw_adapter *padapter , struct sk_buff *pkt ) 
{ 
  struct xmit_priv *pxmitpriv ;
  u16 queue ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 62
  pxmitpriv = & padapter->xmitpriv;
#line 65
  queue = skb_get_queue_mapping((struct sk_buff  const  *)pkt);
#line 66
  if ((unsigned int )padapter->registrypriv.wifi_spec != 0U) {
#line 67
    tmp = __netif_subqueue_stopped((struct net_device  const  *)padapter->pnetdev,
                                   (int )queue);
#line 67
    if ((int )tmp && (pxmitpriv->hwxmits + (unsigned long )queue)->accnt <= 101) {
#line 69
      netif_wake_subqueue(padapter->pnetdev, (int )queue);
    } else {

    }
  } else {
#line 71
    tmp___0 = __netif_subqueue_stopped((struct net_device  const  *)padapter->pnetdev,
                                       (int )queue);
#line 71
    if ((int )tmp___0) {
#line 72
      netif_wake_subqueue(padapter->pnetdev, (int )queue);
    } else {

    }
  }
#line 74
  dev_kfree_skb_any(pkt);
#line 75
  return;
}
}
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/xmit_linux.c"
void rtw_os_xmit_complete23a(struct rtw_adapter *padapter , struct xmit_frame *pxframe ) 
{ 


  {
#line 80
  if ((unsigned long )pxframe->pkt != (unsigned long )((struct sk_buff *)0)) {
#line 81
    rtw_os_pkt_complete23a(padapter, pxframe->pkt);
  } else {

  }
#line 83
  pxframe->pkt = (struct sk_buff *)0;
#line 84
  return;
}
}
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/xmit_linux.c"
void rtw_os_xmit_schedule23a(struct rtw_adapter *padapter ) 
{ 
  struct xmit_priv *pxmitpriv ;
  s32 tmp ;

  {
#line 90
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 91
    return;
  } else {

  }
#line 92
  pxmitpriv = & padapter->xmitpriv;
#line 94
  spin_lock_bh(& pxmitpriv->lock);
#line 96
  tmp = rtw_txframes_pending23a(padapter);
#line 96
  if (tmp != 0) {
#line 97
    tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
  } else {

  }
#line 98
  spin_unlock_bh(& pxmitpriv->lock);
#line 99
  return;
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/xmit_linux.c"
static void rtw_check_xmit_resource(struct rtw_adapter *padapter , struct sk_buff *pkt ) 
{ 
  struct xmit_priv *pxmitpriv ;
  u16 queue ;
  struct netdev_queue *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 104
  pxmitpriv = & padapter->xmitpriv;
#line 107
  queue = skb_get_queue_mapping((struct sk_buff  const  *)pkt);
#line 108
  if ((unsigned int )padapter->registrypriv.wifi_spec != 0U) {
#line 110
    if ((pxmitpriv->hwxmits + (unsigned long )queue)->accnt > 102) {
#line 111
      netif_stop_subqueue(padapter->pnetdev, (int )queue);
    } else {

    }
  } else
#line 113
  if (pxmitpriv->free_xmitframe_cnt <= 4) {
#line 114
    tmp = netdev_get_tx_queue((struct net_device  const  *)padapter->pnetdev, (unsigned int )queue);
#line 114
    tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp);
#line 114
    if (tmp___0) {
#line 114
      tmp___1 = 0;
    } else {
#line 114
      tmp___1 = 1;
    }
#line 114
    if (tmp___1) {
#line 115
      netif_stop_subqueue(padapter->pnetdev, (int )queue);
    } else {

    }
  } else {

  }
#line 116
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/xmit_linux.c"
int rtw_xmit23a_entry23a(struct sk_buff *skb , struct net_device *pnetdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct xmit_priv *pxmitpriv ;
  int res ;
  int tmp___0 ;

  {
#line 122
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 122
  padapter = (struct rtw_adapter *)tmp;
#line 123
  pxmitpriv = & padapter->xmitpriv;
#line 124
  res = 0;
#line 126
  if (GlobalDebugLevel23A > 6U) {
#line 126
    rt_trace(16, 7, "+xmit_enry\n");
  } else {

  }
#line 128
  tmp___0 = rtw_if_up23a(padapter);
#line 128
  if (tmp___0 == 0) {
#line 129
    if (GlobalDebugLevel23A > 3U) {
#line 129
      rt_trace(2, 4, "rtw_xmit23a_entry23a: rtw_if_up23a fail\n");
    } else {

    }
#line 131
    goto drop_packet;
  } else {

  }
#line 134
  rtw_check_xmit_resource(padapter, skb);
#line 136
  res = rtw_xmit23a(padapter, skb);
#line 137
  if (res < 0) {
#line 138
    goto drop_packet;
  } else {

  }
#line 140
  pxmitpriv->tx_pkts = pxmitpriv->tx_pkts + 1ULL;
#line 141
  if (GlobalDebugLevel23A > 6U) {
#line 141
    rt_trace(2, 7, "rtw_xmit23a_entry23a: tx_pkts=%d\n", (unsigned int )pxmitpriv->tx_pkts);
  } else {

  }
#line 144
  goto exit;
  drop_packet: 
#line 147
  pxmitpriv->tx_drop = pxmitpriv->tx_drop + 1ULL;
#line 148
  dev_kfree_skb_any(skb);
#line 149
  if (GlobalDebugLevel23A > 5U) {
#line 149
    rt_trace(2, 6, "rtw_xmit23a_entry23a: drop, tx_drop=%d\n", (unsigned int )pxmitpriv->tx_drop);
  } else {

  }
  exit: ;
#line 153
  return (0);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
bool ldv_queue_work_on_749(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
bool ldv_queue_delayed_work_on_750(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
bool ldv_queue_work_on_751(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
void ldv_flush_workqueue_752(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
bool ldv_queue_delayed_work_on_753(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 173 "include/linux/timer.h"
int ldv_mod_timer_768(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 177
int ldv_mod_timer_773(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 181
int ldv_mod_timer_775(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 185
int ldv_mod_timer_783(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 232
int ldv_del_timer_sync_769(struct timer_list *ldv_func_arg1 ) ;
#line 236
int ldv_del_timer_sync_770(struct timer_list *ldv_func_arg1 ) ;
#line 240
int ldv_del_timer_sync_771(struct timer_list *ldv_func_arg1 ) ;
#line 244
int ldv_del_timer_sync_772(struct timer_list *ldv_func_arg1 ) ;
#line 248
int ldv_del_timer_sync_774(struct timer_list *ldv_func_arg1 ) ;
#line 252
int ldv_del_timer_sync_776(struct timer_list *ldv_func_arg1 ) ;
#line 256
int ldv_del_timer_sync_777(struct timer_list *ldv_func_arg1 ) ;
#line 260
int ldv_del_timer_sync_778(struct timer_list *ldv_func_arg1 ) ;
#line 264
int ldv_del_timer_sync_779(struct timer_list *ldv_func_arg1 ) ;
#line 268
int ldv_del_timer_sync_780(struct timer_list *ldv_func_arg1 ) ;
#line 272
int ldv_del_timer_sync_781(struct timer_list *ldv_func_arg1 ) ;
#line 276
int ldv_del_timer_sync_782(struct timer_list *ldv_func_arg1 ) ;
#line 280
int ldv_del_timer_sync_784(struct timer_list *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_763(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_765(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_764(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_767(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_766(struct workqueue_struct *ldv_func_arg1 ) ;
#line 32 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
void BT_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) ;
#line 1095
void BTHCI_EventParse(struct rtw_adapter *padapter , void *pEvntData , u32 dataLen ) ;
#line 1098
u8 BTHCI_HsConnectionEstablished(struct rtw_adapter *padapter ) ;
#line 1099
void BTHCI_UpdateBTProfileRTKToMoto(struct rtw_adapter *padapter ) ;
#line 1100
void BTHCI_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) ;
#line 1101
void BTHCI_StateMachine(struct rtw_adapter *padapter , u8 StateToEnter , enum hci_state_with_cmd StateCmd ,
                        u8 EntryNum ) ;
#line 1103
void BTHCI_DisconnectPeer(struct rtw_adapter *padapter , u8 EntryNum ) ;
#line 1104
void BTHCI_EventNumOfCompletedDataBlocks(struct rtw_adapter *padapter ) ;
#line 1105
void BTHCI_EventAMPStatusChange(struct rtw_adapter *padapter , u8 AMP_Status ) ;
#line 1106
void BTHCI_DisconnectAll(struct rtw_adapter *padapter ) ;
#line 1107
enum hci_status BTHCI_HandleHCICMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) ;
#line 1163
void BTDM_1AntSignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) ;
#line 1165
void BTDM_1AntForDhcp(struct rtw_adapter *padapter ) ;
#line 1166
void BTDM_1AntBtCoexist8723A(struct rtw_adapter *padapter ) ;
#line 1248
void BTDM_2AntBtCoexist8723A(struct rtw_adapter *padapter ) ;
#line 1317
void BTDM_SetFwChnlInfo(struct rtw_adapter *padapter , enum rt_media_status mstatus ) ;
#line 1319
u8 BTDM_IsWifiConnectionExist(struct rtw_adapter *padapter ) ;
#line 1320
void BTDM_SetFw3a(struct rtw_adapter *padapter , u8 byte1 , u8 byte2 , u8 byte3 ,
                  u8 byte4 , u8 byte5 ) ;
#line 1322
void BTDM_QueryBtInformation(struct rtw_adapter *padapter ) ;
#line 1323
void BTDM_SetSwRfRxLpfCorner(struct rtw_adapter *padapter , u8 type ) ;
#line 1324
void BTDM_SetSwPenaltyTxRateAdaptive(struct rtw_adapter *padapter , u8 raType ) ;
#line 1325
void BTDM_SetFwDecBtPwr(struct rtw_adapter *padapter , u8 bDecBtPwr ) ;
#line 1326
u8 BTDM_BtProfileSupport(struct rtw_adapter *padapter ) ;
#line 1349
void BTDM_SingleAnt(struct rtw_adapter *padapter , u8 bSingleAntOn , u8 bInterruptOn ,
                    u8 bMultiNAVOn ) ;
#line 1351
void BTDM_CheckBTIdleChange1Ant(struct rtw_adapter *padapter ) ;
#line 1371
void BTDM_DiminishWiFi(struct rtw_adapter *padapter , u8 bDACOn , u8 bInterruptOn ,
                       u8 DACSwingLevel , u8 bNAVOn ) ;
#line 1545
void BTDM_CheckAntSelMode(struct rtw_adapter *padapter ) ;
#line 1546
void BTDM_FwC2hBtRssi(struct rtw_adapter *padapter , u8 *tmpBuf ) ;
#line 1548
void BTDM_DisplayBtCoexInfo(struct rtw_adapter *padapter ) ;
#line 1550
void BTDM_RejectAPAggregatedPacket(struct rtw_adapter *padapter , u8 bReject ) ;
#line 1551
u8 BTDM_IsHT40(struct rtw_adapter *padapter ) ;
#line 1552
u8 BTDM_Legacy(struct rtw_adapter *padapter ) ;
#line 1553
void BTDM_CheckWiFiState(struct rtw_adapter *padapter ) ;
#line 1554
s32 BTDM_GetRxSS(struct rtw_adapter *padapter ) ;
#line 1555
u8 BTDM_CheckCoexBcnRssiState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                              u8 RssiThresh1 ) ;
#line 1557
u8 BTDM_CheckCoexRSSIState1(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                            u8 RssiThresh1 ) ;
#line 1559
u8 BTDM_CheckCoexRSSIState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                           u8 RssiThresh1 ) ;
#line 1561
void BTDM_Balance(struct rtw_adapter *padapter , u8 bBalanceOn , u8 ms0 , u8 ms1 ) ;
#line 1562
void BTDM_AGCTable(struct rtw_adapter *padapter , u8 type ) ;
#line 1563
void BTDM_BBBackOffLevel(struct rtw_adapter *padapter , u8 type ) ;
#line 1564
void BTDM_FWCoexAllOff(struct rtw_adapter *padapter ) ;
#line 1565
void BTDM_SWCoexAllOff(struct rtw_adapter *padapter ) ;
#line 1566
void BTDM_HWCoexAllOff(struct rtw_adapter *padapter ) ;
#line 1567
void BTDM_CoexAllOff(struct rtw_adapter *padapter ) ;
#line 1569
void BTDM_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) ;
#line 1571
void BTDM_UpdateCoexState(struct rtw_adapter *padapter ) ;
#line 1572
u8 BTDM_IsSameCoexistState(struct rtw_adapter *padapter ) ;
#line 1573
void BTDM_PWDBMonitor(struct rtw_adapter *padapter ) ;
#line 1574
u8 BTDM_IsBTBusy(struct rtw_adapter *padapter ) ;
#line 1576
u8 BTDM_IsWifiBusy(struct rtw_adapter *padapter ) ;
#line 1577
u8 BTDM_IsCoexistStateChanged(struct rtw_adapter *padapter ) ;
#line 1578
u8 BTDM_IsWifiUplink(struct rtw_adapter *padapter ) ;
#line 1579
u8 BTDM_IsWifiDownlink(struct rtw_adapter *padapter ) ;
#line 1580
u8 BTDM_IsBTHSMode(struct rtw_adapter *padapter ) ;
#line 1581
u8 BTDM_IsBTUplink(struct rtw_adapter *padapter ) ;
#line 1582
u8 BTDM_IsBTDownlink(struct rtw_adapter *padapter ) ;
#line 1583
void BTDM_AdjustForBtOperation(struct rtw_adapter *padapter ) ;
#line 1584
void BTDM_ForHalt(struct rtw_adapter *padapter ) ;
#line 1585
void BTDM_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) ;
#line 1586
void BTDM_WifiAssociateNotify(struct rtw_adapter *padapter , u8 action ) ;
#line 1590
void BTDM_ResetActionProfileState(struct rtw_adapter *padapter ) ;
#line 1591
void BTDM_SetBtCoexCurrAntNum(struct rtw_adapter *padapter , u8 antNum ) ;
#line 1593
u8 BTDM_IsActionSCO(struct rtw_adapter *padapter ) ;
#line 1594
u8 BTDM_IsActionHID(struct rtw_adapter *padapter ) ;
#line 1595
u8 BTDM_IsActionA2DP(struct rtw_adapter *padapter ) ;
#line 1596
u8 BTDM_IsActionPAN(struct rtw_adapter *padapter ) ;
#line 1597
u8 BTDM_IsActionHIDA2DP(struct rtw_adapter *padapter ) ;
#line 1598
u8 BTDM_IsActionHIDPAN(struct rtw_adapter *padapter ) ;
#line 1599
u8 BTDM_IsActionPANA2DP(struct rtw_adapter *padapter ) ;
#line 1600
u32 BTDM_BtTxRxCounterH(struct rtw_adapter *padapter ) ;
#line 1601
u32 BTDM_BtTxRxCounterL(struct rtw_adapter *padapter ) ;
#line 1609
u8 HALBT_GetPGAntNum(struct rtw_adapter *padapter ) ;
#line 1611
void HALBT_SetKey(struct rtw_adapter *padapter , u8 EntryNum ) ;
#line 1612
void HALBT_RemoveKey(struct rtw_adapter *padapter , u8 EntryNum ) ;
#line 1615
u8 HALBT_BTChipType(struct rtw_adapter *padapter ) ;
#line 1616
void HALBT_SetRtsCtsNoLenLimit(struct rtw_adapter *padapter ) ;
#line 1623
u32 BTCoexDbgLevel ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u32 BTCoexDbgLevel  =    0U;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 BT_Operation(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 104
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 105
  pBtMgnt = & pBTInfo->BtMgnt;
#line 107
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
#line 108
    return (1U);
  } else {
#line 110
    return (0U);
  }
}
}
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 BT_IsLegalChannel(struct rtw_adapter *padapter , u8 channel ) 
{ 
  struct rt_channel_info *pChanneList ;
  u8 channelLen ;
  u8 i ;

  {
#line 115
  pChanneList = (struct rt_channel_info *)0;
#line 118
  pChanneList = (struct rt_channel_info *)(& padapter->mlmeextpriv.channel_set);
#line 119
  channelLen = padapter->mlmeextpriv.max_chan_nums;
#line 121
  i = 0U;
#line 121
  goto ldv_55839;
  ldv_55838: ;
#line 122
  if (BTCoexDbgLevel == 1U) {
#line 122
    printk("Check if chnl(%d) in channel plan contains bt target chnl(%d) for BT connection\n",
           (int )(pChanneList + (unsigned long )i)->ChannelNum, (int )channel);
  } else {

  }
#line 125
  if ((int )(pChanneList + (unsigned long )i)->ChannelNum == (int )channel || (int )channel == (int )(pChanneList + (unsigned long )i)->ChannelNum + 2) {
#line 127
    return (channel);
  } else {

  }
#line 121
  i = (u8 )((int )i + 1);
  ldv_55839: ;
#line 121
  if ((int )i < (int )channelLen) {
#line 123
    goto ldv_55838;
  } else {

  }

#line 129
  return (0U);
}
}
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BT_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) 
{ 


  {
#line 134
  BTDM_SignalCompensation(padapter, rssi_wifi, rssi_bt);
#line 135
  return;
}
}
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void rtl8723a_BT_wifiscan_notify(struct rtw_adapter *padapter , u8 scanType ) 
{ 


  {
#line 139
  BTHCI_WifiScanNotify(padapter, (int )scanType);
#line 140
  BTDM_CheckAntSelMode(padapter);
#line 141
  BTDM_WifiScanNotify(padapter, (int )scanType);
#line 142
  return;
}
}
#line 144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void rtl8723a_BT_wifiassociate_notify(struct rtw_adapter *padapter , u8 action ) 
{ 


  {
#line 149
  if ((unsigned int )action != 0U) {
#line 150
    BTDM_CheckAntSelMode(padapter);
  } else {

  }
#line 152
  BTDM_WifiAssociateNotify(padapter, (int )action);
#line 153
  return;
}
}
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BT_HaltProcess(struct rtw_adapter *padapter ) 
{ 


  {
#line 157
  BTDM_ForHalt(padapter);
#line 158
  return;
}
}
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum rt_status PlatformIndicateBTEvent(struct rtw_adapter *padapter , void *pEvntData ,
                                              u32 dataLen ) 
{ 
  enum rt_status rt_status ;
  u32 __i ;
  u8 *ptr ;

  {
#line 175
  rt_status = 1;
#line 177
  if (BTCoexDbgLevel == 1U) {
#line 177
    printk("BT event start, %d bytes data to Transferred!!\n", dataLen);
  } else {

  }
#line 178
  if (BTCoexDbgLevel == 1U) {
#line 178
    ptr = (u8 *)pEvntData;
#line 178
    printk("To transfer Hex Data :\n");
#line 178
    __i = 0U;
#line 178
    goto ldv_55866;
    ldv_55865: 
#line 178
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 178
    if (((__i + 1U) & 15U) == 0U) {
#line 178
      printk("\n");
    } else {

    }
#line 178
    __i = __i + 1U;
    ldv_55866: ;
#line 178
    if (__i < dataLen) {
#line 180
      goto ldv_55865;
    } else {

    }
#line 178
    printk("\n");
  } else {

  }
#line 181
  BTHCI_EventParse(padapter, pEvntData, dataLen);
#line 183
  printk("\f%s: Linux has no way to report BT event!!\n", "PlatformIndicateBTEvent");
#line 185
  if (BTCoexDbgLevel == 1U) {
#line 185
    printk("BT event end, %s\n", (unsigned int )rt_status == 0U ? (char *)"SUCCESS" : (char *)"FAIL");
  } else {

  }
#line 188
  return (rt_status);
}
}
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 bthci_GetLocalChannel(struct rtw_adapter *padapter ) 
{ 


  {
#line 195
  return (padapter->mlmeextpriv.cur_channel);
}
}
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 bthci_GetCurrentEntryNum(struct rtw_adapter *padapter , u8 PhyHandle ) 
{ 
  struct bt_30info *pBTInfo ;
  u8 i ;

  {
#line 200
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 203
  i = 0U;
#line 203
  goto ldv_55879;
  ldv_55878: ;
#line 204
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed != 0U && (int )pBTInfo->BtAsocEntry[(int )i].PhyLinkCmdData.BtPhyLinkhandle == (int )PhyHandle) {
#line 206
    return (i);
  } else {

  }
#line 203
  i = (u8 )((int )i + 1);
  ldv_55879: ;
#line 203
  if ((unsigned int )i <= 1U) {
#line 205
    goto ldv_55878;
  } else {

  }

#line 209
  return (255U);
}
}
#line 212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_DecideBTChannel(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_hci_info *pBtHciInfo ;
  struct chnl_txpower_triple *pTriple_subband ;
  struct common_triple *pTriple ;
  u8 i ;
  u8 j ;
  u8 localchnl ;
  u8 firstRemoteLegalChnlInTriplet ;
  u8 regulatory_skipLen ;
  u8 subbandTripletCnt ;
  bool tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;

  {
#line 219
  pTriple_subband = (struct chnl_txpower_triple *)0;
#line 221
  firstRemoteLegalChnlInTriplet = 0U;
#line 222
  regulatory_skipLen = 0U;
#line 223
  subbandTripletCnt = 0U;
#line 225
  pmlmepriv = & padapter->mlmepriv;
#line 226
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 227
  pBtMgnt = & pBTInfo->BtMgnt;
#line 228
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 230
  pBtMgnt->CheckChnlIsSuit = 1U;
#line 231
  localchnl = bthci_GetLocalChannel(padapter);
#line 233
  pTriple = (struct common_triple *)(& pBtHciInfo->BTPreChnllist) + 3U;
#line 237
  i = 0U;
#line 237
  goto ldv_55902;
  ldv_55901: ;
#line 242
  if ((unsigned int )pTriple->byte_1st == 201U) {
#line 244
    if (BTCoexDbgLevel == 1U) {
#line 244
      printk("Find Regulatory ID, regulatory class = %d\n", (int )pTriple->byte_2nd);
    } else {

    }
#line 246
    regulatory_skipLen = (unsigned int )regulatory_skipLen + 3U;
#line 247
    pTriple_subband = (struct chnl_txpower_triple *)0;
#line 248
    goto ldv_55897;
  } else {
#line 250
    if (BTCoexDbgLevel == 1U) {
#line 250
      printk("Find Sub-band triplet \n");
    } else {

    }
#line 251
    subbandTripletCnt = (u8 )((int )subbandTripletCnt + 1);
#line 252
    pTriple_subband = (struct chnl_txpower_triple *)pTriple;
#line 257
    j = pTriple_subband->FirstChnl;
#line 257
    goto ldv_55900;
    ldv_55899: ;
#line 258
    if (BTCoexDbgLevel == 1U) {
#line 258
      printk(" Check if chnl(%d) is legal\n", (int )j);
    } else {

    }
#line 259
    tmp___2 = BT_IsLegalChannel(padapter, (int )j);
#line 259
    if ((unsigned int )tmp___2 != 0U) {
#line 261
      firstRemoteLegalChnlInTriplet = j;
#line 262
      if (BTCoexDbgLevel == 1U) {
#line 262
        printk("Find first remote legal channel : %d\n", (int )firstRemoteLegalChnlInTriplet);
      } else {

      }
#line 269
      tmp = check_fwstate(pmlmepriv, 49);
#line 269
      if (tmp) {
#line 269
        tmp___0 = 0;
      } else {
#line 269
        tmp___0 = 1;
      }
#line 269
      if (tmp___0) {
#line 269
        tmp___1 = BTHCI_HsConnectionEstablished(padapter);
#line 269
        if ((unsigned int )tmp___1 == 0U) {
#line 271
          pBtMgnt->BTChannel = firstRemoteLegalChnlInTriplet;
#line 272
          if (BTCoexDbgLevel == 1U) {
#line 272
            printk("Remote legal channel (%d) is selected, Local not connect to any!!\n",
                   (int )pBtMgnt->BTChannel);
          } else {

          }
#line 273
          return;
        } else {
#line 269
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 275
      if ((int )localchnl >= (int )firstRemoteLegalChnlInTriplet && (int )localchnl < (int )pTriple_subband->FirstChnl + (int )pTriple_subband->NumChnls) {
#line 277
        pBtMgnt->BTChannel = localchnl;
#line 278
        if (BTCoexDbgLevel == 1U) {
#line 278
          printk("Local channel (%d) is selected, wifi or BT connection exists\n",
                 (int )pBtMgnt->BTChannel);
        } else {

        }
#line 279
        return;
      } else {

      }
#line 282
      goto ldv_55898;
    } else {

    }
#line 257
    j = (u8 )((int )j + 1);
    ldv_55900: ;
#line 257
    if ((int )j < (int )pTriple_subband->FirstChnl + (int )pTriple_subband->NumChnls) {
#line 259
      goto ldv_55899;
    } else {

    }
    ldv_55898: ;
  }
  ldv_55897: 
#line 237
  i = (unsigned int )i + 3U;
#line 237
  pTriple = pTriple + 1;
  ldv_55902: ;
#line 237
  if ((int )i < (int )pBtHciInfo->BtPreChnlListLen + -3) {
#line 239
    goto ldv_55901;
  } else {

  }

#line 288
  if ((unsigned int )subbandTripletCnt != 0U) {
#line 290
    if (BTCoexDbgLevel == 1U) {
#line 290
      printk("There are %d sub band triplet exists, ", (int )subbandTripletCnt);
    } else {

    }
#line 291
    if ((unsigned int )firstRemoteLegalChnlInTriplet == 0U) {
#line 293
      if (BTCoexDbgLevel == 1U) {
#line 293
        printk("no legal channel is found!!\n");
      } else {

      }
    } else
#line 297
    if (BTCoexDbgLevel == 1U) {
#line 297
      printk("Remote Legal channel is found but not match to local(wifi connection exists)!!\n");
    } else {

    }
#line 300
    pBtMgnt->CheckChnlIsSuit = 0U;
  } else
#line 304
  if (BTCoexDbgLevel == 1U) {
#line 304
    printk("No sub band triplet exists!!\n");
  } else {

  }
#line 306
  pBtMgnt->BTChannel = localchnl;
#line 307
  if (BTCoexDbgLevel == 1U) {
#line 307
    printk("Local channel (%d) is selected!!\n", (int )pBtMgnt->BTChannel);
  } else {

  }
#line 308
  return;
}
}
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 bthci_GetAssocInfo(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 tempBuf[256U] ;
  u8 i ;
  u8 BaseMemoryShift ;
  u16 TotalLen ;
  struct amp_assoc_structure *pAmpAsoc ;
  u32 __i ;
  u8 *ptr ;
  u32 __i___0 ;
  u8 *ptr___0 ;
  u32 __i___1 ;
  u8 *ptr___1 ;
  u32 __i___2 ;
  u8 *ptr___2 ;

  {
#line 317
  i = 0U;
#line 318
  BaseMemoryShift = 0U;
#line 319
  TotalLen = 0U;
#line 322
  if (BTCoexDbgLevel == 1U) {
#line 322
    printk("GetAssocInfo start\n");
  } else {

  }
#line 323
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 324
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 326
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar == 0U) {
#line 327
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen <= 247U) {
#line 328
      TotalLen = pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen;
    } else
#line 329
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen == 248U) {
#line 330
      TotalLen = 248U;
    } else {

    }
  } else
#line 331
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar != 0U) {
#line 332
    TotalLen = pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar;
  } else {

  }
#line 334
  goto ldv_55943;
  ldv_55942: ;
#line 335
  if (BTCoexDbgLevel == 1U) {
#line 335
    printk("GetAssocInfo, TotalLen =%d, BaseMemoryShift =%d\n", (int )TotalLen, (int )BaseMemoryShift);
  } else {

  }
#line 336
  memcpy((void *)(& tempBuf), (void const   *)pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment + (unsigned long )BaseMemoryShift,
           (size_t )((int )TotalLen - (int )BaseMemoryShift));
#line 339
  if (BTCoexDbgLevel == 1U) {
#line 339
    ptr = (u8 *)(& tempBuf);
#line 339
    printk("GetAssocInfo :\n");
#line 339
    __i = 0U;
#line 339
    goto ldv_55918;
    ldv_55917: 
#line 339
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 339
    if (((__i + 1U) & 15U) == 0U) {
#line 339
      printk("\n");
    } else {

    }
#line 339
    __i = __i + 1U;
    ldv_55918: ;
#line 339
    if ((unsigned int )TotalLen - (unsigned int )BaseMemoryShift > __i) {
#line 341
      goto ldv_55917;
    } else {

    }
#line 339
    printk("\n");
  } else {

  }
#line 342
  pAmpAsoc = (struct amp_assoc_structure *)(& tempBuf);
#line 344
  BaseMemoryShift = (unsigned int )((int )((u8 )pAmpAsoc->Length) + (int )BaseMemoryShift) + 3U;
#line 346
  if (BTCoexDbgLevel == 1U) {
#line 346
    printk("TypeID = 0x%x, ", (int )pAmpAsoc->TypeID);
  } else {

  }
#line 347
  if (BTCoexDbgLevel == 1U) {
#line 347
    ptr___0 = (u8 *)(& pAmpAsoc->Data);
#line 347
    printk("Hex Data: \n");
#line 347
    __i___0 = 0U;
#line 347
    goto ldv_55923;
    ldv_55922: 
#line 347
    printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((__i___0 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 347
    if (((__i___0 + 1U) & 15U) == 0U) {
#line 347
      printk("\n");
    } else {

    }
#line 347
    __i___0 = __i___0 + 1U;
    ldv_55923: ;
#line 347
    if ((u32 )pAmpAsoc->Length > __i___0) {
#line 349
      goto ldv_55922;
    } else {

    }
#line 347
    printk("\n");
  } else {

  }
#line 348
  switch ((int )pAmpAsoc->TypeID) {
  case 1: ;
#line 350
  if (BTCoexDbgLevel == 1U) {
#line 350
    printk("==> AMP_MAC_ADDR\n");
  } else {

  }
#line 351
  if ((unsigned int )pAmpAsoc->Length > 6U) {
#line 352
    return (0U);
  } else {

  }
#line 353
  memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].BTRemoteMACAddr), (void const   *)(& pAmpAsoc->Data),
           6UL);
#line 354
  if (BTCoexDbgLevel == 1U) {
#line 354
    ptr___1 = (u8 *)(& pBTInfo->BtAsocEntry[(int )EntryNum].BTRemoteMACAddr);
#line 354
    printk("Remote Mac address \n");
#line 354
    printk(" ");
#line 354
    __i___1 = 0U;
#line 354
    goto ldv_55929;
    ldv_55928: 
#line 354
    printk("%02X%s", (int )*(ptr___1 + (unsigned long )__i___1), __i___1 == 5U ? (char *)"" : (char *)"-");
#line 354
    __i___1 = __i___1 + 1U;
    ldv_55929: ;
#line 354
    if (__i___1 <= 5U) {
#line 356
      goto ldv_55928;
    } else {

    }
#line 354
    printk("\n");
  } else {

  }
#line 355
  goto ldv_55931;
  case 2: ;
#line 357
  if (BTCoexDbgLevel == 1U) {
#line 357
    printk("==> AMP_PREFERRED_CHANNEL_LIST\n");
  } else {

  }
#line 358
  pBtHciInfo->BtPreChnlListLen = pAmpAsoc->Length;
#line 359
  memcpy((void *)(& pBtHciInfo->BTPreChnllist), (void const   *)(& pAmpAsoc->Data),
           (size_t )pBtHciInfo->BtPreChnlListLen);
#line 362
  if (BTCoexDbgLevel == 1U) {
#line 362
    ptr___2 = (u8 *)(& pBtHciInfo->BTPreChnllist);
#line 362
    printk("Preferred channel list : \n");
#line 362
    __i___2 = 0U;
#line 362
    goto ldv_55936;
    ldv_55935: 
#line 362
    printk("%02X%s", (int )*(ptr___2 + (unsigned long )__i___2), ((__i___2 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 362
    if (((__i___2 + 1U) & 15U) == 0U) {
#line 362
      printk("\n");
    } else {

    }
#line 362
    __i___2 = __i___2 + 1U;
    ldv_55936: ;
#line 362
    if ((u32 )pBtHciInfo->BtPreChnlListLen > __i___2) {
#line 364
      goto ldv_55935;
    } else {

    }
#line 362
    printk("\n");
  } else {

  }
#line 363
  bthci_DecideBTChannel(padapter, (int )EntryNum);
#line 364
  goto ldv_55931;
  case 3: ;
#line 366
  if (BTCoexDbgLevel == 1U) {
#line 366
    printk("==> AMP_CONNECTED_CHANNEL\n");
  } else {

  }
#line 367
  pBtHciInfo->BTConnectChnlListLen = pAmpAsoc->Length;
#line 368
  memcpy((void *)(& pBtHciInfo->BTConnectChnllist), (void const   *)(& pAmpAsoc->Data),
           (size_t )pBtHciInfo->BTConnectChnlListLen);
#line 371
  goto ldv_55931;
  case 4: ;
#line 373
  if (BTCoexDbgLevel == 1U) {
#line 373
    printk("==> AMP_80211_PAL_CAP_LIST\n");
  } else {

  }
#line 374
  pBTInfo->BtAsocEntry[(int )EntryNum].BTCapability = *((u32 *)(& pAmpAsoc->Data));
#line 384
  goto ldv_55931;
  case 5: 
#line 386
  pBtHciInfo->BTPalVersion = *((u8 *)(& pAmpAsoc->Data));
#line 387
  pBtHciInfo->BTPalCompanyID = *((u16 *)(& pAmpAsoc->Data) + 1U);
#line 388
  pBtHciInfo->BTPalsubversion = *((u16 *)(& pAmpAsoc->Data) + 3U);
#line 389
  if (BTCoexDbgLevel == 1U) {
#line 389
    printk("==> AMP_80211_PAL_VISION PalVersion  0x%x, PalCompanyID  0x%x, Palsubversion 0x%x\n",
           (int )pBtHciInfo->BTPalVersion, (int )pBtHciInfo->BTPalCompanyID, (int )pBtHciInfo->BTPalsubversion);
  } else {

  }
#line 393
  goto ldv_55931;
  default: ;
#line 395
  if (BTCoexDbgLevel == 1U) {
#line 395
    printk("==> Unsupport TypeID !!\n");
  } else {

  }
#line 396
  goto ldv_55931;
  }
  ldv_55931: 
#line 398
  i = (u8 )((int )i + 1);
  ldv_55943: ;
#line 334
  if ((int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar >= (int )((unsigned short )BaseMemoryShift) || (int )((unsigned short )BaseMemoryShift) < (int )TotalLen) {
#line 336
    goto ldv_55942;
  } else {

  }

#line 400
  if (BTCoexDbgLevel == 1U) {
#line 400
    printk("GetAssocInfo end\n");
  } else {

  }
#line 402
  return (1U);
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 bthci_AddEntry(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 i ;

  {
#line 411
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 412
  pBtMgnt = & pBTInfo->BtMgnt;
#line 414
  i = 0U;
#line 414
  goto ldv_55953;
  ldv_55952: ;
#line 415
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed == 0U) {
#line 416
    pBTInfo->BtAsocEntry[(int )i].bUsed = 1U;
#line 417
    pBtMgnt->CurrentConnectEntryNum = i;
#line 418
    goto ldv_55951;
  } else {

  }
#line 414
  i = (u8 )((int )i + 1);
  ldv_55953: ;
#line 414
  if ((unsigned int )i <= 1U) {
#line 416
    goto ldv_55952;
  } else {

  }
  ldv_55951: ;
#line 422
  if ((unsigned int )i == 2U) {
#line 423
    if (BTCoexDbgLevel == 1U) {
#line 423
      printk("bthci_AddEntry(), Add entry fail!!\n");
    } else {

    }
#line 424
    return (0U);
  } else {

  }
#line 426
  return (1U);
}
}
#line 429 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 bthci_DiscardTxPackets(struct rtw_adapter *padapter , u16 LLH ) 
{ 


  {
#line 431
  return (0U);
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 bthci_CheckLogLinkBehavior(struct rtw_adapter *padapter , struct hci_flow_spec TxFlowSpec ) 
{ 
  u8 ID ;
  u8 ServiceType ;
  u16 MaxSDUSize ;
  u32 SDUInterArrivatime ;
  u8 match ;

  {
#line 440
  ID = TxFlowSpec.Identifier;
#line 441
  ServiceType = TxFlowSpec.ServiceType;
#line 442
  MaxSDUSize = TxFlowSpec.MaximumSDUSize;
#line 443
  SDUInterArrivatime = TxFlowSpec.SDUInterArrivalTime;
#line 444
  match = 0U;
#line 446
  switch ((int )ID) {
  case 1: ;
#line 448
  if ((unsigned int )ServiceType == 1U) {
#line 449
    match = 1U;
#line 450
    if (BTCoexDbgLevel == 1U) {
#line 450
      printk("Logical Link Type =  TX best effort flowspec\n");
    } else {

    }
  } else
#line 451
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 65535U) {
#line 452
    match = 1U;
#line 453
    if (BTCoexDbgLevel == 1U) {
#line 453
      printk("Logical Link Type =  RX guaranteed latency flowspec\n");
    } else {

    }
  } else
#line 454
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 2500U) {
#line 455
    if (BTCoexDbgLevel == 1U) {
#line 455
      printk("Logical Link Type =  RX guaranteed Large latency flowspec\n");
    } else {

    }
  } else {

  }
#line 457
  goto ldv_55968;
  case 2: ;
#line 459
  if ((unsigned int )ServiceType == 1U) {
#line 460
    match = 1U;
#line 461
    if (BTCoexDbgLevel == 1U) {
#line 461
      printk("Logical Link Type =  RX best effort flowspec\n");
    } else {

    }
  } else {

  }
#line 464
  goto ldv_55968;
  case 3: ;
#line 466
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 1492U) {
#line 467
    match = 1U;
#line 468
    if (BTCoexDbgLevel == 1U) {
#line 468
      printk("Logical Link Type =  TX guaranteed latency flowspec\n");
    } else {

    }
  } else
#line 469
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 2500U) {
#line 470
    if (BTCoexDbgLevel == 1U) {
#line 470
      printk("Logical Link Type =  TX guaranteed Large latency flowspec\n");
    } else {

    }
  } else {

  }
#line 472
  goto ldv_55968;
  case 4: ;
#line 474
  if ((unsigned int )ServiceType == 1U) {
#line 475
    if ((SDUInterArrivatime == 4294967295U && (unsigned int )ServiceType == 1U) && (unsigned int )MaxSDUSize == 1492U) {
#line 476
      match = 1U;
#line 477
      if (BTCoexDbgLevel == 1U) {
#line 477
        printk("Logical Link Type =  TX/RX aggregated best effort flowspec\n");
      } else {

      }
    } else {

    }
  } else
#line 479
  if ((unsigned int )ServiceType == 2U) {
#line 480
    if (SDUInterArrivatime == 100U) {
#line 481
      match = 1U;
#line 482
      if (BTCoexDbgLevel == 1U) {
#line 482
        printk("Logical Link Type =  TX/RX guaranteed bandwidth flowspec\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 485
  goto ldv_55968;
  default: ;
#line 487
  if (BTCoexDbgLevel == 1U) {
#line 487
    printk("Logical Link Type =  Unknow Type !!!!!!!!\n");
  } else {

  }
#line 488
  goto ldv_55968;
  }
  ldv_55968: ;
#line 491
  if (BTCoexDbgLevel == 1U) {
#line 491
    printk("ID = 0x%x, ServiceType = 0x%x, MaximumSDUSize = 0x%x, SDUInterArrivalTime = 0x%x, AccessLatency = 0x%x, FlushTimeout = 0x%x\n",
           (int )TxFlowSpec.Identifier, (int )TxFlowSpec.ServiceType, (int )MaxSDUSize,
           SDUInterArrivatime, TxFlowSpec.AccessLatency, TxFlowSpec.FlushTimeout);
  } else {

  }
#line 495
  return (match);
}
}
#line 498 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u16 bthci_AssocMACAddr(struct rtw_adapter *padapter , void *pbuf ) 
{ 
  struct amp_assoc_structure *pAssoStrc ;
  u32 __i ;
  u8 *ptr ;

  {
#line 500
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
#line 501
  pAssoStrc->TypeID = 1U;
#line 502
  pAssoStrc->Length = 6U;
#line 503
  memcpy((void *)(& pAssoStrc->Data), (void const   *)(& padapter->eeprompriv.mac_addr),
           6UL);
#line 504
  if (BTCoexDbgLevel == 1U) {
#line 504
    ptr = (u8 *)pAssoStrc;
#line 504
    printk("AssocMACAddr : \n");
#line 504
    __i = 0U;
#line 504
    goto ldv_55981;
    ldv_55980: 
#line 504
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 504
    if (((__i + 1U) & 15U) == 0U) {
#line 504
      printk("\n");
    } else {

    }
#line 504
    __i = __i + 1U;
    ldv_55981: ;
#line 504
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
#line 506
      goto ldv_55980;
    } else {

    }
#line 504
    printk("\n");
  } else {

  }
#line 507
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
#line 511 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u16 bthci_PALCapabilities(struct rtw_adapter *padapter , void *pbuf ) 
{ 
  struct amp_assoc_structure *pAssoStrc ;
  u32 __i ;
  u8 *ptr ;

  {
#line 516
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
#line 518
  pAssoStrc->TypeID = 4U;
#line 519
  pAssoStrc->Length = 4U;
#line 521
  pAssoStrc->Data[0] = 0U;
#line 522
  pAssoStrc->Data[1] = 0U;
#line 524
  if (BTCoexDbgLevel == 1U) {
#line 524
    ptr = (u8 *)pAssoStrc;
#line 524
    printk("PALCapabilities:\n");
#line 524
    __i = 0U;
#line 524
    goto ldv_55991;
    ldv_55990: 
#line 524
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 524
    if (((__i + 1U) & 15U) == 0U) {
#line 524
      printk("\n");
    } else {

    }
#line 524
    __i = __i + 1U;
    ldv_55991: ;
#line 524
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
#line 526
      goto ldv_55990;
    } else {

    }
#line 524
    printk("\n");
  } else {

  }
#line 525
  if (BTCoexDbgLevel == 1U) {
#line 525
    printk("PALCapabilities \n");
  } else {

  }
#line 527
  if (BTCoexDbgLevel == 1U) {
#line 527
    printk(" TypeID = 0x%x,\n Length = 0x%x,\n Content = 0x0000\n", (int )pAssoStrc->TypeID,
           (int )pAssoStrc->Length);
  } else {

  }
#line 531
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
#line 534 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u16 bthci_AssocPreferredChannelList(struct rtw_adapter *padapter , void *pbuf ,
                                           u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct amp_assoc_structure *pAssoStrc ;
  struct amp_pref_chnl_regulatory *pReg ;
  struct chnl_txpower_triple *pTriple ;
  char ctrString[3U] ;
  u32 len ;
  u8 preferredChnl ;
  bool tmp ;
  u8 tmp___0 ;
  u32 __i ;
  u8 *ptr ;

  {
#line 541
  ctrString[0] = 88;
#line 541
  ctrString[1] = 88;
#line 541
  ctrString[2] = 88;
#line 542
  len = 0U;
#line 545
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 546
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
#line 547
  pReg = (struct amp_pref_chnl_regulatory *)(& pAssoStrc->Data) + 3U;
#line 549
  preferredChnl = bthci_GetLocalChannel(padapter);
#line 550
  pAssoStrc->TypeID = 2U;
#line 553
  memcpy((void *)(& pAssoStrc->Data), (void const   *)(& ctrString), 3UL);
#line 554
  pReg->reXId = 201U;
#line 555
  pReg->regulatoryClass = 254U;
#line 556
  pReg->coverageClass = 0U;
#line 557
  len = len + 6U;
#line 558
  if (BTCoexDbgLevel == 1U) {
#line 558
    printk("PREFERRED_CHNL_LIST\n");
  } else {

  }
#line 559
  if (BTCoexDbgLevel == 1U) {
#line 559
    printk("XXX, 201, 254, 0\n");
  } else {

  }
#line 561
  pTriple = (struct chnl_txpower_triple *)(& pAssoStrc->Data) + (unsigned long )len;
#line 564
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole == 1U) {
#line 564
    goto _L;
  } else {
#line 564
    tmp = check_fwstate(& padapter->mlmepriv, 113);
#line 564
    if ((int )tmp) {
#line 564
      goto _L;
    } else {
#line 564
      tmp___0 = BTHCI_HsConnectionEstablished(padapter);
#line 564
      if ((unsigned int )tmp___0 != 0U) {
        _L: /* CIL Label */ 
#line 569
        pTriple->FirstChnl = preferredChnl;
#line 570
        pTriple->NumChnls = 1U;
#line 571
        pTriple->MaxTxPowerInDbm = 20;
#line 572
        len = len + 3U;
#line 573
        if (BTCoexDbgLevel == 1U) {
#line 573
          printk("First Channel = %d, Channel Num = %d, MaxDbm = %d\n", (int )pTriple->FirstChnl,
                 (int )pTriple->NumChnls, (int )pTriple->MaxTxPowerInDbm);
        } else {

        }
      } else {

      }
    }
  }
#line 579
  pAssoStrc->Length = (unsigned short )len;
#line 580
  if (BTCoexDbgLevel == 1U) {
#line 580
    ptr = (u8 *)pAssoStrc;
#line 580
    printk("AssocPreferredChannelList : \n");
#line 580
    __i = 0U;
#line 580
    goto ldv_56008;
    ldv_56007: 
#line 580
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 580
    if (((__i + 1U) & 15U) == 0U) {
#line 580
      printk("\n");
    } else {

    }
#line 580
    __i = __i + 1U;
    ldv_56008: ;
#line 580
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
#line 582
      goto ldv_56007;
    } else {

    }
#line 580
    printk("\n");
  } else {

  }
#line 582
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
#line 585 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u16 bthci_AssocPALVer(struct rtw_adapter *padapter , void *pbuf ) 
{ 
  struct amp_assoc_structure *pAssoStrc ;
  u8 *pu1Tmp ;
  u16 *pu2Tmp ;
  u32 __i ;
  u8 *ptr ;

  {
#line 587
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
#line 591
  pAssoStrc->TypeID = 5U;
#line 592
  pAssoStrc->Length = 5U;
#line 593
  pu1Tmp = (u8 *)(& pAssoStrc->Data);
#line 594
  *pu1Tmp = 1U;
#line 595
  pu2Tmp = (u16 *)(& pAssoStrc->Data) + 1U;
#line 596
  *pu2Tmp = 93U;
#line 597
  pu2Tmp = (u16 *)(& pAssoStrc->Data) + 3U;
#line 598
  *pu2Tmp = 1U;
#line 600
  if (BTCoexDbgLevel == 1U) {
#line 600
    ptr = (u8 *)pAssoStrc;
#line 600
    printk("AssocPALVer : \n");
#line 600
    __i = 0U;
#line 600
    goto ldv_56020;
    ldv_56019: 
#line 600
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 600
    if (((__i + 1U) & 15U) == 0U) {
#line 600
      printk("\n");
    } else {

    }
#line 600
    __i = __i + 1U;
    ldv_56020: ;
#line 600
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
#line 602
      goto ldv_56019;
    } else {

    }
#line 600
    printk("\n");
  } else {

  }
#line 601
  if (BTCoexDbgLevel == 1U) {
#line 601
    printk("AssocPALVer \n");
  } else {

  }
#line 603
  if (BTCoexDbgLevel == 1U) {
#line 603
    printk(" TypeID = 0x%x,\n Length = 0x%x,\n PAL Version = 0x01,\n PAL vendor = 0x01,\n PAL Sub-version specifier = 0x01\n",
           (int )pAssoStrc->TypeID, (int )pAssoStrc->Length);
  } else {

  }
#line 606
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
#line 609 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 bthci_CheckRfStateBeforeConnect(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  enum rt_rf_power_state RfState ;
  unsigned long tmp ;

  {
#line 614
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 616
  RfState = padapter->pwrctrlpriv.rf_pwrstate;
#line 618
  if ((unsigned int )RfState != 0U) {
#line 619
    tmp = msecs_to_jiffies(50U);
#line 619
    ldv_mod_timer_768(& pBTInfo->BTPsDisableTimer, tmp + (unsigned long )jiffies);
#line 621
    return (0U);
  } else {

  }
#line 623
  return (1U);
}
}
#line 626 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_ResponderStartToScan(struct rtw_adapter *padapter ) 
{ 


  {
#line 628
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 bthci_PhyLinkConnectionInProgress(struct rtw_adapter *padapter , u8 PhyLinkHandle ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 635
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 636
  pBtMgnt = & pBTInfo->BtMgnt;
#line 638
  if ((unsigned int )pBtMgnt->bPhyLinkInProgress != 0U && (int )pBtMgnt->BtCurrentPhyLinkhandle == (int )PhyLinkHandle) {
#line 640
    return (1U);
  } else {

  }
#line 641
  return (0U);
}
}
#line 644 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_ResetFlowSpec(struct rtw_adapter *padapter , u8 EntryNum , u8 index ) 
{ 
  struct bt_30info *pBTinfo ;

  {
#line 648
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 650
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].BtLogLinkhandle = 0U;
#line 651
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].BtPhyLinkhandle = 0U;
#line 652
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].bLLCompleteEventIsSet = 0U;
#line 653
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].bLLCancelCMDIsSetandComplete = 0U;
#line 654
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].BtTxFlowSpecID = 0U;
#line 655
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].TxPacketCount = 0U;
#line 657
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.Identifier = 1U;
#line 658
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.ServiceType = 1U;
#line 659
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.MaximumSDUSize = 65535U;
#line 660
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.SDUInterArrivalTime = 4294967295U;
#line 661
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.AccessLatency = 4294967295U;
#line 662
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.FlushTimeout = 4294967295U;
#line 664
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.Identifier = 1U;
#line 665
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.ServiceType = 1U;
#line 666
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.MaximumSDUSize = 65535U;
#line 667
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.SDUInterArrivalTime = 4294967295U;
#line 668
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.AccessLatency = 4294967295U;
#line 669
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.FlushTimeout = 4294967295U;
#line 670
  return;
}
}
#line 672 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_ResetEntry(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 j ;

  {
#line 678
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 679
  pBtMgnt = & pBTinfo->BtMgnt;
#line 681
  pBTinfo->BtAsocEntry[(int )EntryNum].bUsed = 0U;
#line 682
  pBTinfo->BtAsocEntry[(int )EntryNum].BtCurrentState = 32U;
#line 683
  pBTinfo->BtAsocEntry[(int )EntryNum].BtNextState = 32U;
#line 685
  pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen = 0U;
#line 686
  pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.BtPhyLinkhandle = 0U;
#line 687
  if ((unsigned long )pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment != (unsigned long )((void *)0)) {
#line 688
    memset(pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment,
             0, 1000UL);
  } else {

  }
#line 689
  pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar = 0U;
#line 691
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyType = 0U;
#line 692
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle = 0U;
#line 693
  memset((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey),
           0, (size_t )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen);
#line 695
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen = 0U;
#line 698
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout = 16000U;
#line 700
  pBTinfo->BtAsocEntry[(int )EntryNum].AMPRole = 0;
#line 702
  pBTinfo->BtAsocEntry[(int )EntryNum].mAssoc = 0U;
#line 703
  pBTinfo->BtAsocEntry[(int )EntryNum].b4waySuccess = 0U;
#line 706
  pBTinfo->BtAsocEntry[(int )EntryNum].KeyReplayCounter = 0ULL;
#line 707
  pBTinfo->BtAsocEntry[(int )EntryNum].BTWPAAuthState = 0;
#line 709
  pBTinfo->BtAsocEntry[(int )EntryNum].bSendSupervisionPacket = 0U;
#line 710
  pBTinfo->BtAsocEntry[(int )EntryNum].NoRxPktCnt = 0U;
#line 711
  pBTinfo->BtAsocEntry[(int )EntryNum].ShortRangeMode = 0U;
#line 712
  pBTinfo->BtAsocEntry[(int )EntryNum].rxSuvpPktCnt = 0U;
#line 714
  j = 0U;
#line 714
  goto ldv_56050;
  ldv_56049: 
#line 715
  bthci_ResetFlowSpec(padapter, (int )EntryNum, (int )j);
#line 714
  j = (u8 )((int )j + 1);
  ldv_56050: ;
#line 714
  if ((unsigned int )j <= 1U) {
#line 716
    goto ldv_56049;
  } else {

  }
#line 717
  pBtMgnt->BTAuthCount = 0U;
#line 718
  pBtMgnt->BTAsocCount = 0U;
#line 719
  pBtMgnt->BTCurrentConnectType = 4;
#line 720
  pBtMgnt->BTReceiveConnectPkt = 4;
#line 722
  HALBT_RemoveKey(padapter, (int )EntryNum);
#line 723
  return;
}
}
#line 725 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_RemoveEntryByEntryNum(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 727
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 728
  pBtMgnt = & pBTInfo->BtMgnt;
#line 730
  bthci_ResetEntry(padapter, (int )EntryNum);
#line 732
  if ((unsigned int )pBtMgnt->CurrentBTConnectionCnt != 0U) {
#line 733
    pBtMgnt->CurrentBTConnectionCnt = (u8 )((int )pBtMgnt->CurrentBTConnectionCnt - 1);
  } else {

  }
#line 735
  if (BTCoexDbgLevel == 1U) {
#line 735
    printk("[BT Flag], CurrentBTConnectionCnt = %d!!\n", (int )pBtMgnt->CurrentBTConnectionCnt);
  } else {

  }
#line 738
  if ((unsigned int )pBtMgnt->CurrentBTConnectionCnt != 0U) {
#line 739
    pBtMgnt->BtOperationOn = 1U;
  } else {
#line 741
    pBtMgnt->BtOperationOn = 0U;
#line 742
    if (BTCoexDbgLevel == 1U) {
#line 742
      printk("[BT Flag], Bt Operation OFF!!\n");
    } else {

    }
  }
#line 745
  if ((unsigned int )pBtMgnt->BtOperationOn == 0U) {
#line 746
    ldv_del_timer_sync_769(& pBTInfo->BTHCIDiscardAclDataTimer);
#line 747
    ldv_del_timer_sync_770(& pBTInfo->BTBeaconTimer);
#line 748
    pBtMgnt->bStartSendSupervisionPkt = 0U;
  } else {

  }
#line 750
  return;
}
}
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 bthci_CommandCompleteHeader(u8 *pbuf , u16 OGF , u16 OCF , enum hci_status status ) 
{ 
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 NumHCI_Comm ;

  {
#line 760
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)pbuf;
#line 761
  NumHCI_Comm = 1U;
#line 763
  PPacketIrpEvent->EventCode = 14U;
#line 764
  PPacketIrpEvent->Data[0] = NumHCI_Comm;
#line 765
  PPacketIrpEvent->Data[1] = (unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF));
#line 766
  PPacketIrpEvent->Data[2] = (unsigned char )((((int )OGF << 10) | (int )OCF) >> 8);
#line 768
  if ((unsigned int )OGF == 63U) {
#line 769
    if ((unsigned int )OCF == 64U) {
#line 770
      if (BTCoexDbgLevel == 1U) {
#line 770
        printk("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",
               (int )NumHCI_Comm, (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)),
               (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
               (unsigned int )status, (int )OGF, (int )OCF);
      } else {

      }
    } else
#line 774
    if (BTCoexDbgLevel == 1U) {
#line 774
      printk("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",
             (int )NumHCI_Comm, (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)),
             (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
             (unsigned int )status, (int )OGF, (int )OCF);
    } else {

    }
  } else
#line 779
  if (BTCoexDbgLevel == 1U) {
#line 779
    printk("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",
           (int )NumHCI_Comm, (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)),
           (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
           (unsigned int )status, (int )OGF, (int )OCF);
  } else {

  }
#line 783
  return (3U);
}
}
#line 786 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 bthci_ExtensionEventHeaderRtk(u8 *pbuf , u8 extensionEvent ) 
{ 
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 788
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)pbuf;
#line 789
  PPacketIrpEvent->EventCode = 254U;
#line 790
  PPacketIrpEvent->Data[0] = extensionEvent;
#line 792
  return (1U);
}
}
#line 796 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum rt_status bthci_IndicateEvent(struct rtw_adapter *padapter , void *pEvntData ,
                                          u32 dataLen ) 
{ 
  enum rt_status rt_status ;

  {
#line 804
  rt_status = PlatformIndicateBTEvent(padapter, pEvntData, dataLen);
#line 806
  return (rt_status);
}
}
#line 810 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_EventWriteRemoteAmpAssoc(struct rtw_adapter *padapter , enum hci_status status ,
                                           u8 PLHandle ) 
{ 
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 816
  localBuf[0] = '\000';
#line 816
  tmp = 1U;
#line 816
  while (1) {
#line 816
    if (tmp >= 256U) {
#line 816
      break;
    } else {

    }
#line 816
    localBuf[tmp] = (unsigned char)0;
#line 816
    tmp = tmp + 1U;
  }
#line 818
  len = 0U;
#line 821
  memset((void *)(& localBuf), 0, 256UL);
#line 822
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 824
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 11, status);
#line 824
  len = (int )tmp___0 + (int )len;
#line 828
  if (BTCoexDbgLevel == 1U) {
#line 828
    printk("PhyLinkHandle = 0x%x, status = %d\n", (int )PLHandle, (unsigned int )status);
  } else {

  }
#line 830
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 831
  *pRetPar = (u8 )status;
#line 832
  *(pRetPar + 1UL) = PLHandle;
#line 833
  len = (unsigned int )len + 2U;
#line 834
  PPacketIrpEvent->Length = len;
#line 836
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 837
  return;
}
}
#line 840 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_EventEnhancedFlushComplete(struct rtw_adapter *padapter , u16 LLH ) 
{ 
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 845
  localBuf[0] = '\000';
#line 845
  tmp = 1U;
#line 845
  while (1) {
#line 845
    if (tmp >= 4U) {
#line 845
      break;
    } else {

    }
#line 845
    localBuf[tmp] = (unsigned char)0;
#line 845
    tmp = tmp + 1U;
  }
#line 848
  if (BTCoexDbgLevel == 1U) {
#line 848
    printk("EventEnhancedFlushComplete, LLH = 0x%x\n", (int )LLH);
  } else {

  }
#line 850
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 851
  PPacketIrpEvent->EventCode = 57U;
#line 852
  PPacketIrpEvent->Length = 2U;
#line 854
  PPacketIrpEvent->Data[0] = (unsigned char )LLH;
#line 855
  PPacketIrpEvent->Data[1] = (unsigned char )((int )LLH >> 8);
#line 857
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
#line 858
  return;
}
}
#line 861 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_EventShortRangeModeChangeComplete(struct rtw_adapter *padapter ,
                                                    enum hci_status HciStatus , u8 ShortRangeState ,
                                                    u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 868
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 869
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 870
  localBuf[0] = '\000';
#line 870
  tmp = 1U;
#line 870
  while (1) {
#line 870
    if (tmp >= 5U) {
#line 870
      break;
    } else {

    }
#line 870
    localBuf[tmp] = (unsigned char)0;
#line 870
    tmp = tmp + 1U;
  }
#line 873
  if ((pBtHciInfo->BTEventMaskPage2 & 4096ULL) == 0ULL) {
#line 874
    if (BTCoexDbgLevel == 1U) {
#line 874
      printk("[BT event], Short Range Mode Change Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
#line 876
    return;
  } else {

  }
#line 878
  if (BTCoexDbgLevel == 1U) {
#line 878
    printk("[BT event], Short Range Mode Change Complete, Status = %d\n , PLH = 0x%x\n, Short_Range_Mode_State = 0x%x\n",
           (unsigned int )HciStatus, (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
           (int )ShortRangeState);
  } else {

  }
#line 881
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 882
  PPacketIrpEvent->EventCode = 76U;
#line 883
  PPacketIrpEvent->Length = 3U;
#line 884
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
#line 885
  PPacketIrpEvent->Data[1] = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
#line 886
  PPacketIrpEvent->Data[2] = ShortRangeState;
#line 887
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 5U);
#line 888
  return;
}
}
#line 890 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_EventSendFlowSpecModifyComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                                  u16 logicHandle ) 
{ 
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;

  {
#line 894
  localBuf[0] = '\000';
#line 894
  tmp = 1U;
#line 894
  while (1) {
#line 894
    if (tmp >= 5U) {
#line 894
      break;
    } else {

    }
#line 894
    localBuf[tmp] = (unsigned char)0;
#line 894
    tmp = tmp + 1U;
  }
#line 896
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 897
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 899
  if ((pBtHciInfo->BTEventMaskPage2 & 128ULL) == 0ULL) {
#line 900
    if (BTCoexDbgLevel == 1U) {
#line 900
      printk("[BT event], Flow Spec Modify Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
#line 902
    return;
  } else {

  }
#line 904
  if (BTCoexDbgLevel == 1U) {
#line 904
    printk("[BT event], Flow Spec Modify Complete, status = 0x%x, LLH = 0x%x\n", (unsigned int )HciStatus,
           (int )logicHandle);
  } else {

  }
#line 906
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 907
  PPacketIrpEvent->EventCode = 71U;
#line 908
  PPacketIrpEvent->Length = 3U;
#line 910
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
#line 912
  PPacketIrpEvent->Data[1] = (unsigned char )logicHandle;
#line 913
  PPacketIrpEvent->Data[2] = (unsigned char )((int )logicHandle >> 8);
#line 915
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 5U);
#line 916
  return;
}
}
#line 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_EventExtWifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 len ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 *pu1Temp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  enum rt_status tmp___1 ;

  {
#line 924
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 925
  pBtMgnt = & pBTInfo->BtMgnt;
#line 926
  len = 0U;
#line 927
  localBuf[0] = '\000';
#line 927
  tmp = 1U;
#line 927
  while (1) {
#line 927
    if (tmp >= 7U) {
#line 927
      break;
    } else {

    }
#line 927
    localBuf[tmp] = (unsigned char)0;
#line 927
    tmp = tmp + 1U;
  }
#line 932
  if ((unsigned int )pBtMgnt->BtOperationOn == 0U) {
#line 933
    return;
  } else {

  }
#line 935
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 937
  tmp___0 = bthci_ExtensionEventHeaderRtk((u8 *)(& localBuf), 1);
#line 937
  len = (int )tmp___0 + (int )len;
#line 940
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 941
  pu1Temp = pRetPar;
#line 942
  *pu1Temp = scanType;
#line 943
  len = (unsigned int )len + 1U;
#line 945
  PPacketIrpEvent->Length = len;
#line 947
  tmp___1 = bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 947
  if ((unsigned int )tmp___1 == 0U) {
#line 948
    if (BTCoexDbgLevel == 1U) {
#line 948
      printk("[BT event], Wifi scan notify, scan type = %d\n", (int )scanType);
    } else {

    }
  } else {

  }
#line 949
  return;
}
}
#line 954 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_EventAMPReceiverReport(struct rtw_adapter *padapter , u8 Reason ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[20U] ;
  unsigned int tmp ;
  u32 *pu4Temp ;
  u16 *pu2Temp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 959
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 960
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 962
  if ((unsigned int )pBtHciInfo->bTestNeedReport != 0U) {
#line 963
    localBuf[0] = '\000';
#line 963
    tmp = 1U;
#line 963
    while (1) {
#line 963
      if (tmp >= 20U) {
#line 963
        break;
      } else {

      }
#line 963
      localBuf[tmp] = (unsigned char)0;
#line 963
      tmp = tmp + 1U;
    }
#line 968
    if (BTCoexDbgLevel == 1U) {
#line 968
      printk(" HCI_EVENT_AMP_RECEIVER_REPORT\n");
    } else {

    }
#line 969
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 970
    PPacketIrpEvent->EventCode = 75U;
#line 971
    PPacketIrpEvent->Length = 2U;
#line 973
    PPacketIrpEvent->Data[0] = pBtHciInfo->TestCtrType;
#line 975
    PPacketIrpEvent->Data[1] = Reason;
#line 977
    pu4Temp = (u32 *)(& PPacketIrpEvent->Data) + 2U;
#line 978
    *pu4Temp = pBtHciInfo->TestEventType;
#line 980
    pu2Temp = (u16 *)(& PPacketIrpEvent->Data) + 6U;
#line 981
    *pu2Temp = pBtHciInfo->TestNumOfFrame;
#line 983
    pu2Temp = (u16 *)(& PPacketIrpEvent->Data) + 8U;
#line 984
    *pu2Temp = pBtHciInfo->TestNumOfErrFrame;
#line 986
    pu4Temp = (u32 *)(& PPacketIrpEvent->Data) + 10U;
#line 987
    *pu4Temp = (u32 )pBtHciInfo->TestNumOfBits;
#line 989
    pu4Temp = (u32 *)(& PPacketIrpEvent->Data) + 14U;
#line 990
    *pu4Temp = (u32 )pBtHciInfo->TestNumOfErrBits;
#line 992
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 20U);
  } else {

  }
#line 998
  pBtHciInfo->TestNumOfFrame = 0U;
#line 999
  return;
}
}
#line 1002 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_EventChannelSelected(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[3U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 1007
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1008
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1009
  localBuf[0] = '\000';
#line 1009
  tmp = 1U;
#line 1009
  while (1) {
#line 1009
    if (tmp >= 3U) {
#line 1009
      break;
    } else {

    }
#line 1009
    localBuf[tmp] = (unsigned char)0;
#line 1009
    tmp = tmp + 1U;
  }
#line 1012
  if ((pBtHciInfo->BTEventMaskPage2 & 2ULL) == 0ULL) {
#line 1013
    if (BTCoexDbgLevel == 1U) {
#line 1013
      printk("[BT event], Channel Selected, Ignore to send this event due to event mask page 2\n");
    } else {

    }
#line 1015
    return;
  } else {

  }
#line 1018
  if (BTCoexDbgLevel == 1U) {
#line 1018
    printk("[BT event], Channel Selected, PhyLinkHandle %d\n", (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle);
  } else {

  }
#line 1022
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1023
  PPacketIrpEvent->EventCode = 65U;
#line 1024
  PPacketIrpEvent->Length = 1U;
#line 1025
  PPacketIrpEvent->Data[0] = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
#line 1026
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 3U);
#line 1027
  return;
}
}
#line 1030 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_EventDisconnectPhyLinkComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                                 enum hci_status Reason , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 1037
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1038
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1039
  localBuf[0] = '\000';
#line 1039
  tmp = 1U;
#line 1039
  while (1) {
#line 1039
    if (tmp >= 5U) {
#line 1039
      break;
    } else {

    }
#line 1039
    localBuf[tmp] = (unsigned char)0;
#line 1039
    tmp = tmp + 1U;
  }
#line 1042
  if ((pBtHciInfo->BTEventMaskPage2 & 4ULL) == 0ULL) {
#line 1043
    if (BTCoexDbgLevel == 1U) {
#line 1043
      printk("[BT event], Disconnect Physical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
#line 1045
    return;
  } else {

  }
#line 1047
  if (BTCoexDbgLevel == 1U) {
#line 1047
    printk("[BT event], Disconnect Physical Link Complete, Status = 0x%x, PLH = 0x%x Reason = 0x%x\n",
           (unsigned int )HciStatus, (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
           (unsigned int )Reason);
  } else {

  }
#line 1050
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1051
  PPacketIrpEvent->EventCode = 66U;
#line 1052
  PPacketIrpEvent->Length = 3U;
#line 1053
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
#line 1054
  PPacketIrpEvent->Data[1] = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
#line 1055
  PPacketIrpEvent->Data[2] = (u8 )Reason;
#line 1056
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 5U);
#line 1057
  return;
}
}
#line 1060 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_EventPhysicalLinkComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                            u8 EntryNum , u8 PLHandle ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_hci_info *pBtHciInfo ;
  struct bt_dgb *pBtDbg ;
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 PL_handle ;

  {
#line 1067
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1068
  pBtMgnt = & pBTInfo->BtMgnt;
#line 1069
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1070
  pBtDbg = & pBTInfo->BtDbg;
#line 1071
  localBuf[0] = '\000';
#line 1071
  tmp = 1U;
#line 1071
  while (1) {
#line 1071
    if (tmp >= 4U) {
#line 1071
      break;
    } else {

    }
#line 1071
    localBuf[tmp] = (unsigned char)0;
#line 1071
    tmp = tmp + 1U;
  }
#line 1075
  pBtMgnt->bPhyLinkInProgress = 0U;
#line 1076
  pBtDbg->dbgHciInfo.hciCmdPhyLinkStatus = (u32 )HciStatus;
#line 1077
  if ((pBtHciInfo->BTEventMaskPage2 & 1ULL) == 0ULL) {
#line 1078
    if (BTCoexDbgLevel == 1U) {
#line 1078
      printk("[BT event], Physical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
#line 1080
    return;
  } else {

  }
#line 1083
  if ((unsigned int )EntryNum == 255U) {
#line 1085
    PL_handle = PLHandle;
  } else {
#line 1088
    PL_handle = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
#line 1089
    pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent = 0U;
  }
#line 1092
  if (BTCoexDbgLevel == 1U) {
#line 1092
    printk("[BT event], Physical Link Complete, Status = 0x%x PhyLinkHandle = 0x%x\n",
           (unsigned int )HciStatus, (int )PL_handle);
  } else {

  }
#line 1095
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1096
  PPacketIrpEvent->EventCode = 64U;
#line 1097
  PPacketIrpEvent->Length = 2U;
#line 1099
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
#line 1100
  PPacketIrpEvent->Data[1] = PL_handle;
#line 1101
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
#line 1102
  return;
}
}
#line 1106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_EventCommandStatus(struct rtw_adapter *padapter , u8 OGF , u16 OCF ,
                                     enum hci_status HciStatus ) 
{ 
  u8 localBuf[6U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 Num_Hci_Comm ;

  {
#line 1114
  localBuf[0] = '\000';
#line 1114
  tmp = 1U;
#line 1114
  while (1) {
#line 1114
    if (tmp >= 6U) {
#line 1114
      break;
    } else {

    }
#line 1114
    localBuf[tmp] = (unsigned char)0;
#line 1114
    tmp = tmp + 1U;
  }
#line 1116
  Num_Hci_Comm = 1U;
#line 1117
  if (BTCoexDbgLevel == 1U) {
#line 1117
    printk("[BT event], CommandStatus, Opcode = 0x%02x%02x, OGF = 0x%x,  OCF = 0x%x, Status = 0x%x, Num_HCI_COMM = 0x%x\n",
           (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)), (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
           (int )OGF, (int )OCF, (unsigned int )HciStatus, (int )Num_Hci_Comm);
  } else {

  }
#line 1121
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1122
  PPacketIrpEvent->EventCode = 15U;
#line 1123
  PPacketIrpEvent->Length = 4U;
#line 1124
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
#line 1125
  PPacketIrpEvent->Data[1] = Num_Hci_Comm;
#line 1126
  PPacketIrpEvent->Data[2] = (unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF));
#line 1127
  PPacketIrpEvent->Data[3] = (unsigned char )((((int )OGF << 10) | (int )OCF) >> 8);
#line 1129
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 6U);
#line 1130
  return;
}
}
#line 1134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_EventLogicalLinkComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                           u8 PhyLinkHandle , u16 LogLinkHandle ,
                                           u8 LogLinkIndex , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 1144
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1145
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1146
  localBuf[0] = '\000';
#line 1146
  tmp = 1U;
#line 1146
  while (1) {
#line 1146
    if (tmp >= 7U) {
#line 1146
      break;
    } else {

    }
#line 1146
    localBuf[tmp] = (unsigned char)0;
#line 1146
    tmp = tmp + 1U;
  }
#line 1149
  if ((pBtHciInfo->BTEventMaskPage2 & 32ULL) == 0ULL) {
#line 1150
    if (BTCoexDbgLevel == 1U) {
#line 1150
      printk("[BT event], Logical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
#line 1152
    return;
  } else {

  }
#line 1154
  if (BTCoexDbgLevel == 1U) {
#line 1154
    printk("[BT event], Logical Link Complete, PhyLinkHandle = 0x%x,  LogLinkHandle = 0x%x, Status = 0x%x\n",
           (int )PhyLinkHandle, (int )LogLinkHandle, (unsigned int )HciStatus);
  } else {

  }
#line 1157
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1158
  PPacketIrpEvent->EventCode = 69U;
#line 1159
  PPacketIrpEvent->Length = 5U;
#line 1161
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
#line 1163
  PPacketIrpEvent->Data[1] = (unsigned char )LogLinkHandle;
#line 1164
  PPacketIrpEvent->Data[2] = (unsigned char )((int )LogLinkHandle >> 8);
#line 1166
  PPacketIrpEvent->Data[3] = PhyLinkHandle;
#line 1168
  if ((unsigned int )HciStatus == 0U) {
#line 1169
    PPacketIrpEvent->Data[4] = pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )LogLinkIndex].Tx_Flow_Spec.Identifier;
  } else {
#line 1172
    PPacketIrpEvent->Data[4] = 0U;
  }
#line 1175
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 7U);
#line 1176
  return;
}
}
#line 1179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_EventDisconnectLogicalLinkComplete(struct rtw_adapter *padapter ,
                                                     enum hci_status HciStatus , u16 LogLinkHandle ,
                                                     enum hci_status Reason ) 
{ 
  u8 localBuf[6U] ;
  unsigned int tmp ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 1186
  localBuf[0] = '\000';
#line 1186
  tmp = 1U;
#line 1186
  while (1) {
#line 1186
    if (tmp >= 6U) {
#line 1186
      break;
    } else {

    }
#line 1186
    localBuf[tmp] = (unsigned char)0;
#line 1186
    tmp = tmp + 1U;
  }
#line 1187
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1188
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1191
  if ((pBtHciInfo->BTEventMaskPage2 & 64ULL) == 0ULL) {
#line 1192
    if (BTCoexDbgLevel == 1U) {
#line 1192
      printk("[BT event], Disconnect Logical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
#line 1193
    return;
  } else {

  }
#line 1195
  if (BTCoexDbgLevel == 1U) {
#line 1195
    printk("[BT event], Disconnect Logical Link Complete, Status = 0x%x, LLH = 0x%x Reason = 0x%x\n",
           (unsigned int )HciStatus, (int )LogLinkHandle, (unsigned int )Reason);
  } else {

  }
#line 1197
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1198
  PPacketIrpEvent->EventCode = 70U;
#line 1199
  PPacketIrpEvent->Length = 4U;
#line 1201
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
#line 1203
  PPacketIrpEvent->Data[1] = (unsigned char )LogLinkHandle;
#line 1204
  PPacketIrpEvent->Data[2] = (unsigned char )((int )LogLinkHandle >> 8);
#line 1206
  PPacketIrpEvent->Data[3] = (u8 )Reason;
#line 1208
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 6U);
#line 1209
  return;
}
}
#line 1212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_EventFlushOccurred(struct rtw_adapter *padapter , u16 LogLinkHandle ) 
{ 
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 1217
  localBuf[0] = '\000';
#line 1217
  tmp = 1U;
#line 1217
  while (1) {
#line 1217
    if (tmp >= 4U) {
#line 1217
      break;
    } else {

    }
#line 1217
    localBuf[tmp] = (unsigned char)0;
#line 1217
    tmp = tmp + 1U;
  }
#line 1219
  if (BTCoexDbgLevel == 1U) {
#line 1219
    printk("bthci_EventFlushOccurred(), LLH = 0x%x\n", (int )LogLinkHandle);
  } else {

  }
#line 1221
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1222
  PPacketIrpEvent->EventCode = 17U;
#line 1223
  PPacketIrpEvent->Length = 2U;
#line 1225
  PPacketIrpEvent->Data[0] = (unsigned char )LogLinkHandle;
#line 1226
  PPacketIrpEvent->Data[1] = (unsigned char )((int )LogLinkHandle >> 8);
#line 1228
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
#line 1229
  return;
}
}
#line 1232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_BuildPhysicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ,
                                               u16 OCF ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 EntryNum ;
  u8 PLH ;
  u8 tmp ;
  u32 __i ;
  u8 *ptr ;
  u32 __i___0 ;
  u8 *ptr___0 ;

  {
#line 1238
  status = 0;
#line 1239
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1240
  pBtMgnt = & pBTInfo->BtMgnt;
#line 1244
  bthci_EventCommandStatus(padapter, 1, (int )OCF, 0);
#line 1249
  PLH = *((u8 *)(& pHciCmd->Data));
#line 1252
  tmp = bthci_AddEntry(padapter);
#line 1252
  if ((unsigned int )tmp == 0U) {
#line 1253
    status = 13;
#line 1254
    bthci_EventPhysicalLinkComplete(padapter, status, 255, (int )PLH);
#line 1255
    return (status);
  } else {

  }
#line 1258
  EntryNum = pBtMgnt->CurrentConnectEntryNum;
#line 1259
  pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle = PLH;
#line 1260
  pBtMgnt->BtCurrentPhyLinkhandle = PLH;
#line 1262
  if ((unsigned long )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment == (unsigned long )((void *)0)) {
#line 1263
    if (BTCoexDbgLevel == 1U) {
#line 1263
      printk("Create/Accept PhysicalLink, AMP controller is busy\n");
    } else {

    }
#line 1264
    status = 58;
#line 1265
    bthci_EventPhysicalLinkComplete(padapter, status, 255, (int )PLH);
#line 1266
    return (status);
  } else {

  }
#line 1270
  pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen = *((u8 *)(& pHciCmd->Data) + 1UL);
#line 1271
  pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyType = *((u8 *)(& pHciCmd->Data) + 2UL);
#line 1272
  memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey),
           (void const   *)(& pHciCmd->Data) + 3U, (size_t )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen);
#line 1274
  memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PMK), (void const   *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey),
           32UL);
#line 1275
  if (BTCoexDbgLevel == 1U) {
#line 1275
    printk("BuildPhysicalLink, EntryNum = %d, PLH = 0x%x  KeyLen = 0x%x, KeyType = 0x%x\n",
           (int )EntryNum, (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
           (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen,
           (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyType);
  } else {

  }
#line 1279
  if (BTCoexDbgLevel == 1U) {
#line 1279
    ptr = (u8 *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey);
#line 1279
    printk("BtAMPKey\n");
#line 1279
    __i = 0U;
#line 1279
    goto ldv_56213;
    ldv_56212: 
#line 1279
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 1279
    if (((__i + 1U) & 15U) == 0U) {
#line 1279
      printk("\n");
    } else {

    }
#line 1279
    __i = __i + 1U;
    ldv_56213: ;
#line 1279
    if ((u32 )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen > __i) {
#line 1281
      goto ldv_56212;
    } else {

    }
#line 1279
    printk("\n");
  } else {

  }
#line 1281
  if (BTCoexDbgLevel == 1U) {
#line 1281
    ptr___0 = (u8 *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PMK);
#line 1281
    printk("PMK\n");
#line 1281
    __i___0 = 0U;
#line 1281
    goto ldv_56218;
    ldv_56217: 
#line 1281
    printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((__i___0 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 1281
    if (((__i___0 + 1U) & 15U) == 0U) {
#line 1281
      printk("\n");
    } else {

    }
#line 1281
    __i___0 = __i___0 + 1U;
    ldv_56218: ;
#line 1281
    if (__i___0 <= 31U) {
#line 1283
      goto ldv_56217;
    } else {

    }
#line 1281
    printk("\n");
  } else {

  }
#line 1284
  if ((unsigned int )OCF == 53U) {
#line 1286
    if (BTCoexDbgLevel == 1U) {
#line 1286
      printk("[BT state change] caused by %s, line =%d\n", "bthci_BuildPhysicalLink",
             1286);
    } else {

    }
#line 1286
    BTHCI_StateMachine(padapter, 32, 0, (int )EntryNum);
  } else
#line 1287
  if ((unsigned int )OCF == 54U) {
#line 1288
    if (BTCoexDbgLevel == 1U) {
#line 1288
      printk("[BT state change] caused by %s, line =%d\n", "bthci_BuildPhysicalLink",
             1288);
    } else {

    }
#line 1288
    BTHCI_StateMachine(padapter, 32, 1, (int )EntryNum);
  } else {

  }
#line 1291
  return (status);
}
}
#line 1295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_BuildLogicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ,
                                   u16 OCF ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 PhyLinkHandle ;
  u8 EntryNum ;
  u16 AssignLogHandle ;
  struct hci_flow_spec TxFlowSpec ;
  struct hci_flow_spec RxFlowSpec ;
  u32 MaxSDUSize ;
  u32 ArriveTime ;
  u32 Bandwidth ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 i ;
  u8 find ;
  enum hci_status LogCompEventstatus ;

  {
#line 1301
  status = 0;
#line 1302
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1303
  pBtMgnt = & pBTinfo->BtMgnt;
#line 1305
  AssignLogHandle = 1U;
#line 1311
  PhyLinkHandle = *((u8 *)(& pHciCmd->Data));
#line 1313
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
#line 1315
  memcpy((void *)(& TxFlowSpec), (void const   *)(& pHciCmd->Data) + 1U, 16UL);
#line 1317
  memcpy((void *)(& RxFlowSpec), (void const   *)(& pHciCmd->Data) + 17U, 16UL);
#line 1320
  MaxSDUSize = (u32 )TxFlowSpec.MaximumSDUSize;
#line 1321
  ArriveTime = TxFlowSpec.SDUInterArrivalTime;
#line 1323
  tmp = bthci_CheckLogLinkBehavior(padapter, TxFlowSpec);
#line 1323
  if ((unsigned int )tmp != 0U) {
#line 1323
    tmp___0 = bthci_CheckLogLinkBehavior(padapter, RxFlowSpec);
#line 1323
    if ((unsigned int )tmp___0 != 0U) {
#line 1324
      Bandwidth = 30000U;
    } else {
#line 1323
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1325
  if (MaxSDUSize == 65535U && ArriveTime == 4294967295U) {
#line 1326
    Bandwidth = 30000U;
  } else {
#line 1328
    Bandwidth = (MaxSDUSize * 8000U) / (ArriveTime + 244U);
  }
#line 1330
  if (BTCoexDbgLevel == 1U) {
#line 1330
    printk("BuildLogicalLink, PhyLinkHandle = 0x%x, MaximumSDUSize = 0x%x, SDUInterArrivalTime = 0x%x, Bandwidth = 0x%x\n",
           (int )PhyLinkHandle, MaxSDUSize, ArriveTime, Bandwidth);
  } else {

  }
#line 1334
  if ((unsigned int )EntryNum == 255U) {
#line 1335
    if (BTCoexDbgLevel == 1U) {
#line 1335
      printk("Invalid Physical Link handle = 0x%x, status = HCI_STATUS_UNKNOW_CONNECT_ID, return\n",
             (int )PhyLinkHandle);
    } else {

    }
#line 1336
    status = 2;
#line 1339
    bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
#line 1343
    return;
  } else {

  }
#line 1346
  if ((unsigned int )pBtMgnt->bLogLinkInProgress == 0U) {
#line 1347
    tmp___1 = bthci_PhyLinkConnectionInProgress(padapter, (int )PhyLinkHandle);
#line 1347
    if ((unsigned int )tmp___1 != 0U) {
#line 1348
      if (BTCoexDbgLevel == 1U) {
#line 1348
        printk("Physical link connection in progress, status = HCI_STATUS_CMD_DISALLOW, return\n");
      } else {

      }
#line 1349
      status = 12;
#line 1351
      pBtMgnt->bPhyLinkInProgressStartLL = 1U;
#line 1353
      bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
#line 1358
      return;
    } else {

    }
#line 1361
    if (Bandwidth > 30000U) {
#line 1362
      if (BTCoexDbgLevel == 1U) {
#line 1362
        printk("status = HCI_STATUS_QOS_REJECT, Bandwidth = 0x%x, return\n", Bandwidth);
      } else {

      }
#line 1363
      status = 45;
#line 1366
      bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
    } else {
#line 1371
      if (BTCoexDbgLevel == 1U) {
#line 1371
        printk("status = HCI_STATUS_SUCCESS\n");
      } else {

      }
#line 1372
      status = 0;
#line 1375
      bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
    }
#line 1382
    if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].BtCurrentState != 8U) {
#line 1383
      bthci_EventLogicalLinkComplete(padapter, 12, 0, 0, 0, (int )EntryNum);
    } else {
#line 1386
      find = 0U;
#line 1388
      pBtMgnt->bLogLinkInProgress = 1U;
#line 1391
      i = 0U;
#line 1391
      goto ldv_56242;
      ldv_56241: ;
#line 1392
      if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle == 0U) {
#line 1393
        LogCompEventstatus = 0;
#line 1395
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtPhyLinkhandle = *((u8 *)(& pHciCmd->Data));
#line 1396
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle = AssignLogHandle;
#line 1397
        if (BTCoexDbgLevel == 1U) {
#line 1397
          printk("BuildLogicalLink, EntryNum = %d, physical link handle = 0x%x, logical link handle = 0x%x\n",
                 (int )EntryNum, (int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
                 (int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle);
        } else {

        }
#line 1400
        memcpy((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].Tx_Flow_Spec),
                 (void const   *)(& TxFlowSpec), 16UL);
#line 1402
        memcpy((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].Rx_Flow_Spec),
                 (void const   *)(& RxFlowSpec), 16UL);
#line 1405
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].bLLCompleteEventIsSet = 0U;
#line 1407
        if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].bLLCancelCMDIsSetandComplete != 0U) {
#line 1408
          LogCompEventstatus = 2;
        } else {

        }
#line 1409
        bthci_EventLogicalLinkComplete(padapter, LogCompEventstatus, (int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtPhyLinkhandle,
                                       (int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle,
                                       (int )i, (int )EntryNum);
#line 1414
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].bLLCompleteEventIsSet = 1U;
#line 1416
        find = 1U;
#line 1417
        pBtMgnt->BtCurrentLogLinkhandle = AssignLogHandle;
#line 1418
        AssignLogHandle = (u16 )((int )AssignLogHandle + 1);
#line 1419
        goto ldv_56240;
      } else {

      }
#line 1391
      i = (u8 )((int )i + 1);
      ldv_56242: ;
#line 1391
      if ((unsigned int )i <= 1U) {
#line 1393
        goto ldv_56241;
      } else {

      }
      ldv_56240: ;
#line 1423
      if ((unsigned int )find == 0U) {
#line 1424
        bthci_EventLogicalLinkComplete(padapter, 13, 0, 0, 0, (int )EntryNum);
      } else {

      }
#line 1427
      pBtMgnt->bLogLinkInProgress = 0U;
    }
  } else {
#line 1430
    bthci_EventLogicalLinkComplete(padapter, 58, 0, 0, 0, (int )EntryNum);
  }
#line 1431
  return;
}
}
#line 1437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_StartBeaconAndConnect(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ,
                                        u8 CurrentAssocNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  u32 __i ;
  u8 buffer[64U] ;
  u32 length ;

  {
#line 1444
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1445
  pBtMgnt = & pBTInfo->BtMgnt;
#line 1447
  if (BTCoexDbgLevel == 1U) {
#line 1447
    printk("StartBeaconAndConnect, CurrentAssocNum =%d, AMPRole =%d\n", (int )CurrentAssocNum,
           (unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole);
  } else {

  }
#line 1451
  if ((unsigned int )pBtMgnt->CheckChnlIsSuit == 0U) {
#line 1452
    bthci_EventPhysicalLinkComplete(padapter, 57, (int )CurrentAssocNum, 255);
#line 1453
    bthci_RemoveEntryByEntryNum(padapter, (int )CurrentAssocNum);
#line 1454
    return;
  } else {

  }
#line 1457
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 1U) {
#line 1458
    snprintf((char *)(& pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsidBuf), 32UL,
             "AMP-%02x-%02x-%02x-%02x-%02x-%02x", (int )padapter->eeprompriv.mac_addr[0],
             (int )padapter->eeprompriv.mac_addr[1], (int )padapter->eeprompriv.mac_addr[2],
             (int )padapter->eeprompriv.mac_addr[3], (int )padapter->eeprompriv.mac_addr[4],
             (int )padapter->eeprompriv.mac_addr[5]);
  } else
#line 1465
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 2U) {
#line 1466
    snprintf((char *)(& pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsidBuf), 32UL,
             "AMP-%02x-%02x-%02x-%02x-%02x-%02x", (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[0],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[1],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[2],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[3],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[4],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[5]);
  } else {

  }
#line 1475
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsid.Octet = (u8 *)(& pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsidBuf);
#line 1475
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsid.Length = 21U;
#line 1476
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsid.Length = 21U;
#line 1479
  if ((unsigned int )pBtMgnt->bBTConnectInProgress == 0U) {
#line 1480
    pBtMgnt->bBTConnectInProgress = 1U;
#line 1481
    if (BTCoexDbgLevel == 1U) {
#line 1481
      printk("[BT Flag], BT Connect in progress ON!!\n");
    } else {

    }
#line 1482
    if (BTCoexDbgLevel == 1U) {
#line 1482
      printk("[BT state change] caused by %s, line =%d\n", "bthci_StartBeaconAndConnect",
             1482);
    } else {

    }
#line 1482
    BTHCI_StateMachine(padapter, 1, 4, (int )CurrentAssocNum);
#line 1486
    tmp = bthci_CheckRfStateBeforeConnect(padapter);
#line 1486
    if ((unsigned int )tmp == 0U) {
#line 1487
      return;
    } else {

    }
#line 1489
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 1U) {
#line 1491
      if (BTCoexDbgLevel == 1U) {
#line 1491
        printk("[BT state change] caused by %s, line =%d\n", "bthci_StartBeaconAndConnect",
               1491);
      } else {

      }
#line 1491
      BTHCI_StateMachine(padapter, 2, 6, (int )CurrentAssocNum);
    } else
#line 1492
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 2U) {
#line 1493
      bthci_ResponderStartToScan(padapter);
    } else {

    }
  } else {

  }
#line 1496
  length = (unsigned int )pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Length <= 63U ? (u32 )pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Length : 63U;
#line 1496
  memset((void *)(& buffer), 0, 64UL);
#line 1496
  memcpy((void *)(& buffer), (void const   *)pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Octet,
           (size_t )length);
#line 1496
  __i = 0U;
#line 1496
  goto ldv_56255;
  ldv_56254: ;
#line 1496
  if ((unsigned int )buffer[__i] <= 31U || (unsigned int )buffer[__i] > 126U) {
#line 1496
    buffer[__i] = 63U;
  } else {

  }
#line 1496
  __i = __i + 1U;
  ldv_56255: ;
#line 1496
  if (__i < length) {
#line 1498
    goto ldv_56254;
  } else {

  }
#line 1496
  buffer[length] = 0U;
#line 1496
  printk("StartBeaconAndConnect, SSID:\n");
#line 1496
  printk(": %d, <%s>\n", (int )pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Length,
         (u8 *)(& buffer));
#line 1498
  return;
}
}
#line 1502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_ResetBtMgnt(struct bt_mgnt *pBtMgnt ) 
{ 


  {
#line 1504
  pBtMgnt->BtOperationOn = 0U;
#line 1505
  pBtMgnt->bBTConnectInProgress = 0U;
#line 1506
  pBtMgnt->bLogLinkInProgress = 0U;
#line 1507
  pBtMgnt->bPhyLinkInProgress = 0U;
#line 1508
  pBtMgnt->bPhyLinkInProgressStartLL = 0U;
#line 1509
  pBtMgnt->DisconnectEntryNum = 255U;
#line 1510
  pBtMgnt->bStartSendSupervisionPkt = 0U;
#line 1511
  pBtMgnt->JoinerNeedSendAuth = 0U;
#line 1512
  pBtMgnt->CurrentBTConnectionCnt = 0U;
#line 1513
  pBtMgnt->BTCurrentConnectType = 4;
#line 1514
  pBtMgnt->BTReceiveConnectPkt = 4;
#line 1515
  pBtMgnt->BTAuthCount = 0U;
#line 1516
  pBtMgnt->btLogoTest = 0U;
#line 1517
  return;
}
}
#line 1519 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_ResetBtHciInfo(struct bt_hci_info *pBtHciInfo ) 
{ 


  {
#line 1521
  pBtHciInfo->BTEventMask = 0ULL;
#line 1522
  pBtHciInfo->BTEventMaskPage2 = 0ULL;
#line 1523
  pBtHciInfo->ConnAcceptTimeout = 10000U;
#line 1524
  pBtHciInfo->PageTimeout = 48U;
#line 1525
  pBtHciInfo->LocationDomainAware = 0U;
#line 1526
  pBtHciInfo->LocationDomain = 22616U;
#line 1527
  pBtHciInfo->LocationDomainOptions = 88U;
#line 1528
  pBtHciInfo->LocationOptions = 0U;
#line 1529
  pBtHciInfo->FlowControlMode = 1U;
#line 1531
  pBtHciInfo->enFlush_LLH = 0U;
#line 1532
  pBtHciInfo->FLTO_LLH = 0U;
#line 1535
  pBtHciInfo->bTestIsEnd = 1U;
#line 1536
  pBtHciInfo->bInTestMode = 0U;
#line 1537
  pBtHciInfo->bTestNeedReport = 0U;
#line 1538
  pBtHciInfo->TestScenario = 255U;
#line 1539
  pBtHciInfo->TestReportInterval = 1U;
#line 1540
  pBtHciInfo->TestCtrType = 93U;
#line 1541
  pBtHciInfo->TestEventType = 0U;
#line 1542
  pBtHciInfo->TestNumOfFrame = 0U;
#line 1543
  pBtHciInfo->TestNumOfErrFrame = 0U;
#line 1544
  pBtHciInfo->TestNumOfBits = 0U;
#line 1545
  pBtHciInfo->TestNumOfErrBits = 0U;
#line 1546
  return;
}
}
#line 1548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_ResetBtSec(struct rtw_adapter *padapter , struct bt_security *pBtSec ) 
{ 


  {
#line 1553
  if ((unsigned int )((struct hal_data_8723a *)padapter->HalData)->bBTMode != 0U) {
#line 1554
    pBtSec->bUsedHwEncrypt = 1U;
  } else {
#line 1556
    pBtSec->bUsedHwEncrypt = 0U;
  }
#line 1557
  if (GlobalDebugLevel23A > 6U) {
#line 1557
    rt_trace(4096, 7, "%s: bUsedHwEncrypt =%d\n", "bthci_ResetBtSec", (int )pBtSec->bUsedHwEncrypt);
  } else {

  }
#line 1560
  pBtSec->RSNIE.Octet = (u8 *)(& pBtSec->RSNIEBuf);
#line 1561
  return;
}
}
#line 1563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_ResetBtExtInfo(struct bt_mgnt *pBtMgnt ) 
{ 
  u8 i ;

  {
#line 1567
  i = 0U;
#line 1567
  goto ldv_56273;
  ldv_56272: 
#line 1568
  pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = 0U;
#line 1569
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 0U;
#line 1570
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 0U;
#line 1571
  pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile = 0U;
#line 1572
  pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec = 4U;
#line 1573
  pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI = 0;
#line 1574
  pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile = 0U;
#line 1575
  pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole = 0U;
#line 1567
  i = (u8 )((int )i + 1);
  ldv_56273: ;
#line 1567
  if ((unsigned int )i <= 1U) {
#line 1569
    goto ldv_56272;
  } else {

  }
#line 1578
  pBtMgnt->ExtConfig.CurrentConnectHandle = 0U;
#line 1579
  pBtMgnt->ExtConfig.CurrentIncomingTrafficMode = 0U;
#line 1580
  pBtMgnt->ExtConfig.CurrentOutgoingTrafficMode = 0U;
#line 1581
  pBtMgnt->ExtConfig.MIN_BT_RSSI = 0;
#line 1582
  pBtMgnt->ExtConfig.NumberOfHandle = 0U;
#line 1583
  pBtMgnt->ExtConfig.NumberOfSCO = 0U;
#line 1584
  pBtMgnt->ExtConfig.CurrentBTStatus = 0U;
#line 1585
  pBtMgnt->ExtConfig.HCIExtensionVer = 0U;
#line 1587
  pBtMgnt->ExtConfig.bManualControl = 0U;
#line 1588
  pBtMgnt->ExtConfig.bBTBusy = 0U;
#line 1589
  pBtMgnt->ExtConfig.bBTA2DPBusy = 0U;
#line 1590
  return;
}
}
#line 1592 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReset(struct rtw_adapter *_padapter , u8 bNeedSendEvent ) 
{ 
  enum hci_status status ;
  struct rtw_adapter *padapter ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_hci_info *pBtHciInfo ;
  struct bt_security *pBtSec ;
  struct bt_dgb *pBtDbg ;
  u8 i ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 1594
  status = 0;
#line 1604
  if (BTCoexDbgLevel == 1U) {
#line 1604
    printk("bthci_CmdReset()\n");
  } else {

  }
#line 1606
  padapter = _padapter;
#line 1607
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1608
  pBtMgnt = & pBTInfo->BtMgnt;
#line 1609
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1610
  pBtSec = & pBTInfo->BtSec;
#line 1611
  pBtDbg = & pBTInfo->BtDbg;
#line 1613
  pBTInfo->padapter = padapter;
#line 1615
  i = 0U;
#line 1615
  goto ldv_56288;
  ldv_56287: 
#line 1616
  bthci_ResetEntry(padapter, (int )i);
#line 1615
  i = (u8 )((int )i + 1);
  ldv_56288: ;
#line 1615
  if ((unsigned int )i <= 1U) {
#line 1617
    goto ldv_56287;
  } else {

  }
#line 1618
  bthci_ResetBtMgnt(pBtMgnt);
#line 1619
  bthci_ResetBtHciInfo(pBtHciInfo);
#line 1620
  bthci_ResetBtSec(padapter, pBtSec);
#line 1622
  pBtMgnt->BTChannel = 10U;
#line 1623
  pBtMgnt->CheckChnlIsSuit = 1U;
#line 1625
  pBTInfo->BTBeaconTmrOn = 0U;
#line 1627
  pBtMgnt->bCreateSpportQos = 1U;
#line 1629
  ldv_del_timer_sync_771(& pBTInfo->BTHCIDiscardAclDataTimer);
#line 1630
  ldv_del_timer_sync_772(& pBTInfo->BTBeaconTimer);
#line 1632
  HALBT_SetRtsCtsNoLenLimit(padapter);
#line 1637
  bthci_ResetBtExtInfo(pBtMgnt);
#line 1640
  if ((unsigned int )bNeedSendEvent != 0U) {
#line 1641
    localBuf[0] = '\000';
#line 1641
    tmp = 1U;
#line 1641
    while (1) {
#line 1641
      if (tmp >= 6U) {
#line 1641
        break;
      } else {

      }
#line 1641
      localBuf[tmp] = (unsigned char)0;
#line 1641
      tmp = tmp + 1U;
    }
#line 1643
    len = 0U;
#line 1646
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1648
    tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 3, status);
#line 1648
    len = (int )tmp___0 + (int )len;
#line 1654
    pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 1655
    *pRetPar = (u8 )status;
#line 1656
    len = (unsigned int )len + 1U;
#line 1657
    PPacketIrpEvent->Length = len;
#line 1659
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  } else {

  }
#line 1662
  return (status);
}
}
#line 1666 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdWriteRemoteAMPAssoc(struct rtw_adapter *padapter ,
                                                    struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 CurrentAssocNum ;
  u8 PhyLinkHandle ;
  u32 __i ;
  u8 *ptr ;
  u32 __i___0 ;
  u8 *ptr___0 ;
  u8 tmp ;

  {
#line 1671
  status = 0;
#line 1672
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1673
  pBtDbg = & pBTInfo->BtDbg;
#line 1677
  pBtDbg->dbgHciInfo.hciCmdCntWriteRemoteAmpAssoc = pBtDbg->dbgHciInfo.hciCmdCntWriteRemoteAmpAssoc + 1U;
#line 1678
  PhyLinkHandle = *((u8 *)(& pHciCmd->Data));
#line 1679
  CurrentAssocNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
#line 1681
  if ((unsigned int )CurrentAssocNum == 255U) {
#line 1682
    if (BTCoexDbgLevel == 1U) {
#line 1682
      printk("WriteRemoteAMPAssoc, No such Handle in the Entry\n");
    } else {

    }
#line 1683
    status = 2;
#line 1684
    bthci_EventWriteRemoteAmpAssoc(padapter, status, (int )PhyLinkHandle);
#line 1685
    return (status);
  } else {

  }
#line 1688
  if ((unsigned long )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment == (unsigned long )((void *)0)) {
#line 1689
    if (BTCoexDbgLevel == 1U) {
#line 1689
      printk("WriteRemoteAMPAssoc, AMP controller is busy\n");
    } else {

    }
#line 1690
    status = 58;
#line 1691
    bthci_EventWriteRemoteAmpAssoc(padapter, status, (int )PhyLinkHandle);
#line 1692
    return (status);
  } else {

  }
#line 1695
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.BtPhyLinkhandle = PhyLinkHandle;
#line 1696
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar = *((u16 *)(& pHciCmd->Data) + 1U);
#line 1697
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen = *((u16 *)(& pHciCmd->Data) + 3U);
#line 1699
  if (BTCoexDbgLevel == 1U) {
#line 1699
    printk("WriteRemoteAMPAssoc, LenSoFar = 0x%x, AssocRemLen = 0x%x\n", (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar,
           (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen);
  } else {

  }
#line 1703
  if (BTCoexDbgLevel == 1U) {
#line 1703
    ptr = (u8 *)(& pHciCmd->Data);
#line 1703
    printk("WriteRemoteAMPAssoc fragment \n");
#line 1703
    __i = 0U;
#line 1703
    goto ldv_56306;
    ldv_56305: 
#line 1703
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 1703
    if (((__i + 1U) & 15U) == 0U) {
#line 1703
      printk("\n");
    } else {

    }
#line 1703
    __i = __i + 1U;
    ldv_56306: ;
#line 1703
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen + 5U > __i) {
#line 1705
      goto ldv_56305;
    } else {

    }
#line 1703
    printk("\n");
  } else {

  }
#line 1707
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen > 248U) {
#line 1708
    memcpy(pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment + (unsigned long )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar,
             (void const   *)(& pHciCmd->Data) + 5U, 248UL);
  } else {
#line 1712
    memcpy(pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment + (unsigned long )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar,
             (void const   *)(& pHciCmd->Data) + 5U, (size_t )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen);
#line 1716
    if (BTCoexDbgLevel == 1U) {
#line 1716
      ptr___0 = (u8 *)(& pHciCmd->Data) + 5UL;
#line 1716
      printk("WriteRemoteAMPAssoc :\n");
#line 1716
      __i___0 = 0U;
#line 1716
      goto ldv_56311;
      ldv_56310: 
#line 1716
      printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((__i___0 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 1716
      if (((__i___0 + 1U) & 15U) == 0U) {
#line 1716
        printk("\n");
      } else {

      }
#line 1716
      __i___0 = __i___0 + 1U;
      ldv_56311: ;
#line 1716
      if ((u32 )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen > __i___0) {
#line 1718
        goto ldv_56310;
      } else {

      }
#line 1716
      printk("\n");
    } else {

    }
#line 1719
    tmp = bthci_GetAssocInfo(padapter, (int )CurrentAssocNum);
#line 1719
    if ((unsigned int )tmp == 0U) {
#line 1720
      status = 18;
    } else {

    }
#line 1722
    bthci_EventWriteRemoteAmpAssoc(padapter, status, (int )PhyLinkHandle);
#line 1724
    bthci_StartBeaconAndConnect(padapter, pHciCmd, (int )CurrentAssocNum);
  }
#line 1727
  return (status);
}
}
#line 1731 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadConnectionAcceptTimeout(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 1733
  status = 0;
#line 1735
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1736
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1737
  localBuf[0] = '\000';
#line 1737
  tmp = 1U;
#line 1737
  while (1) {
#line 1737
    if (tmp >= 8U) {
#line 1737
      break;
    } else {

    }
#line 1737
    localBuf[tmp] = (unsigned char)0;
#line 1737
    tmp = tmp + 1U;
  }
#line 1739
  len = 0U;
#line 1743
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1745
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 21, status);
#line 1745
  len = (int )tmp___0 + (int )len;
#line 1751
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 1752
  *pRetPar = (u8 )status;
#line 1753
  pu2Temp = (u16 *)pRetPar + 1U;
#line 1754
  *pu2Temp = pBtHciInfo->ConnAcceptTimeout;
#line 1755
  len = (unsigned int )len + 3U;
#line 1756
  PPacketIrpEvent->Length = len;
#line 1758
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 1760
  return (status);
}
}
#line 1765 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdWriteConnectionAcceptTimeout(struct rtw_adapter *padapter ,
                                                             struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 *pu2Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 1770
  status = 0;
#line 1771
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1772
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1774
  localBuf[0] = '\000';
#line 1774
  tmp = 1U;
#line 1774
  while (1) {
#line 1774
    if (tmp >= 6U) {
#line 1774
      break;
    } else {

    }
#line 1774
    localBuf[tmp] = (unsigned char)0;
#line 1774
    tmp = tmp + 1U;
  }
#line 1776
  len = 0U;
#line 1779
  pu2Temp = (u16 *)(& pHciCmd->Data);
#line 1780
  pBtHciInfo->ConnAcceptTimeout = *pu2Temp;
#line 1781
  if (BTCoexDbgLevel == 1U) {
#line 1781
    printk("ConnAcceptTimeout = 0x%x", (int )pBtHciInfo->ConnAcceptTimeout);
  } else {

  }
#line 1785
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1787
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 22, status);
#line 1787
  len = (int )tmp___0 + (int )len;
#line 1793
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 1794
  *pRetPar = (u8 )status;
#line 1795
  len = (unsigned int )len + 1U;
#line 1796
  PPacketIrpEvent->Length = len;
#line 1798
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 1800
  return (status);
}
}
#line 1804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadPageTimeout(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 1809
  status = 0;
#line 1810
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1811
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1812
  localBuf[0] = '\000';
#line 1812
  tmp = 1U;
#line 1812
  while (1) {
#line 1812
    if (tmp >= 8U) {
#line 1812
      break;
    } else {

    }
#line 1812
    localBuf[tmp] = (unsigned char)0;
#line 1812
    tmp = tmp + 1U;
  }
#line 1814
  len = 0U;
#line 1818
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1820
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 23, status);
#line 1820
  len = (int )tmp___0 + (int )len;
#line 1825
  if (BTCoexDbgLevel == 1U) {
#line 1825
    printk("Read PageTimeout = 0x%x\n", (int )pBtHciInfo->PageTimeout);
  } else {

  }
#line 1827
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 1828
  *pRetPar = (u8 )status;
#line 1829
  pu2Temp = (u16 *)pRetPar + 1U;
#line 1830
  *pu2Temp = pBtHciInfo->PageTimeout;
#line 1831
  len = (unsigned int )len + 3U;
#line 1832
  PPacketIrpEvent->Length = len;
#line 1834
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 1836
  return (status);
}
}
#line 1840 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdWritePageTimeout(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 *pu2Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 1845
  status = 0;
#line 1846
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1847
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1850
  pu2Temp = (u16 *)(& pHciCmd->Data);
#line 1851
  pBtHciInfo->PageTimeout = *pu2Temp;
#line 1852
  if (BTCoexDbgLevel == 1U) {
#line 1852
    printk("Write PageTimeout = 0x%x\n", (int )pBtHciInfo->PageTimeout);
  } else {

  }
#line 1857
  localBuf[0] = '\000';
#line 1857
  tmp = 1U;
#line 1857
  while (1) {
#line 1857
    if (tmp >= 6U) {
#line 1857
      break;
    } else {

    }
#line 1857
    localBuf[tmp] = (unsigned char)0;
#line 1857
    tmp = tmp + 1U;
  }
#line 1859
  len = 0U;
#line 1862
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1864
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 24, status);
#line 1864
  len = (int )tmp___0 + (int )len;
#line 1870
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 1871
  *pRetPar = (u8 )status;
#line 1872
  len = (unsigned int )len + 1U;
#line 1873
  PPacketIrpEvent->Length = len;
#line 1875
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 1878
  return (status);
}
}
#line 1882 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadLinkSupervisionTimeout(struct rtw_adapter *padapter ,
                                                           struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u8 physicalLinkHandle ;
  u8 EntryNum ;
  u8 localBuf[10U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 1887
  status = 0;
#line 1888
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1891
  physicalLinkHandle = *((u8 *)(& pHciCmd->Data));
#line 1893
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )physicalLinkHandle);
#line 1895
  if ((unsigned int )EntryNum == 255U) {
#line 1896
    if (BTCoexDbgLevel == 1U) {
#line 1896
      printk("ReadLinkSupervisionTimeout, No such Handle in the Entry\n");
    } else {

    }
#line 1897
    status = 2;
#line 1898
    return (status);
  } else {

  }
#line 1901
  if ((int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle != (int )physicalLinkHandle) {
#line 1902
    status = 2;
  } else {

  }
#line 1905
  localBuf[0] = '\000';
#line 1905
  tmp = 1U;
#line 1905
  while (1) {
#line 1905
    if (tmp >= 10U) {
#line 1905
      break;
    } else {

    }
#line 1905
    localBuf[tmp] = (unsigned char)0;
#line 1905
    tmp = tmp + 1U;
  }
#line 1907
  len = 0U;
#line 1911
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1913
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 54, status);
#line 1913
  len = (int )tmp___0 + (int )len;
#line 1919
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 1920
  *pRetPar = (u8 )status;
#line 1921
  *(pRetPar + 1UL) = pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
#line 1922
  *(pRetPar + 2UL) = 0U;
#line 1923
  pu2Temp = (u16 *)pRetPar + 3U;
#line 1924
  *pu2Temp = pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout;
#line 1925
  len = (unsigned int )len + 5U;
#line 1926
  PPacketIrpEvent->Length = len;
#line 1928
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 1931
  return (status);
}
}
#line 1935 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdWriteLinkSupervisionTimeout(struct rtw_adapter *padapter ,
                                                            struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u8 physicalLinkHandle ;
  u8 EntryNum ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 1940
  status = 0;
#line 1941
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1944
  physicalLinkHandle = *((u8 *)(& pHciCmd->Data));
#line 1946
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )physicalLinkHandle);
#line 1948
  if ((unsigned int )EntryNum == 255U) {
#line 1949
    if (BTCoexDbgLevel == 1U) {
#line 1949
      printk("WriteLinkSupervisionTimeout, No such Handle in the Entry\n");
    } else {

    }
#line 1950
    status = 2;
  } else
#line 1952
  if ((int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle != (int )physicalLinkHandle) {
#line 1953
    status = 2;
  } else {
#line 1955
    pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout = *((u16 *)(& pHciCmd->Data) + 2U);
#line 1956
    if (BTCoexDbgLevel == 1U) {
#line 1956
      printk("BT Write LinkSuperversionTimeout[%d] = 0x%x\n", (int )EntryNum, (int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout);
    } else {

    }
  }
#line 1962
  localBuf[0] = '\000';
#line 1962
  tmp = 1U;
#line 1962
  while (1) {
#line 1962
    if (tmp >= 8U) {
#line 1962
      break;
    } else {

    }
#line 1962
    localBuf[tmp] = (unsigned char)0;
#line 1962
    tmp = tmp + 1U;
  }
#line 1964
  len = 0U;
#line 1967
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1969
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 55, status);
#line 1969
  len = (int )tmp___0 + (int )len;
#line 1975
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 1976
  *pRetPar = (u8 )status;
#line 1977
  *(pRetPar + 1UL) = pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
#line 1978
  *(pRetPar + 2UL) = 0U;
#line 1979
  len = (unsigned int )len + 3U;
#line 1980
  PPacketIrpEvent->Length = len;
#line 1982
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 1985
  return (status);
}
}
#line 1989 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdEnhancedFlush(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 logicHandle ;
  u8 Packet_Type ;
  u8 tmp ;

  {
#line 1994
  status = 0;
#line 1995
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1996
  pBtHciInfo = & pBTinfo->BtHciInfo;
#line 2000
  logicHandle = *((u16 *)(& pHciCmd->Data));
#line 2001
  Packet_Type = pHciCmd->Data[2];
#line 2003
  if ((unsigned int )Packet_Type != 0U) {
#line 2004
    status = 18;
  } else {
#line 2006
    pBtHciInfo->enFlush_LLH = logicHandle;
  }
#line 2008
  tmp = bthci_DiscardTxPackets(padapter, (int )pBtHciInfo->enFlush_LLH);
#line 2008
  if ((unsigned int )tmp != 0U) {
#line 2009
    bthci_EventFlushOccurred(padapter, (int )pBtHciInfo->enFlush_LLH);
  } else {

  }
#line 2012
  bthci_EventCommandStatus(padapter, 3, 95, status);
#line 2017
  if ((unsigned int )pBtHciInfo->enFlush_LLH != 0U) {
#line 2018
    bthci_EventEnhancedFlushComplete(padapter, (int )pBtHciInfo->enFlush_LLH);
#line 2019
    pBtHciInfo->enFlush_LLH = 0U;
  } else {

  }
#line 2022
  return (status);
}
}
#line 2026 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadLogicalLinkAcceptTimeout(struct rtw_adapter *padapter ,
                                                             struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 2031
  status = 0;
#line 2033
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2034
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2035
  localBuf[0] = '\000';
#line 2035
  tmp = 1U;
#line 2035
  while (1) {
#line 2035
    if (tmp >= 8U) {
#line 2035
      break;
    } else {

    }
#line 2035
    localBuf[tmp] = (unsigned char)0;
#line 2035
    tmp = tmp + 1U;
  }
#line 2037
  len = 0U;
#line 2041
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2043
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 97, status);
#line 2043
  len = (int )tmp___0 + (int )len;
#line 2049
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2050
  *pRetPar = (u8 )status;
#line 2052
  pu2Temp = (u16 *)pRetPar + 1U;
#line 2053
  *pu2Temp = pBtHciInfo->LogicalAcceptTimeout;
#line 2054
  len = (unsigned int )len + 3U;
#line 2055
  PPacketIrpEvent->Length = len;
#line 2057
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2059
  return (status);
}
}
#line 2063 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdWriteLogicalLinkAcceptTimeout(struct rtw_adapter *padapter ,
                                                              struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2068
  status = 0;
#line 2070
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2071
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2072
  localBuf[0] = '\000';
#line 2072
  tmp = 1U;
#line 2072
  while (1) {
#line 2072
    if (tmp >= 6U) {
#line 2072
      break;
    } else {

    }
#line 2072
    localBuf[tmp] = (unsigned char)0;
#line 2072
    tmp = tmp + 1U;
  }
#line 2074
  len = 0U;
#line 2077
  pBtHciInfo->LogicalAcceptTimeout = *((u16 *)(& pHciCmd->Data));
#line 2079
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2081
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 98, status);
#line 2081
  len = (int )tmp___0 + (int )len;
#line 2087
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2088
  *pRetPar = (u8 )status;
#line 2090
  len = (unsigned int )len + 1U;
#line 2091
  PPacketIrpEvent->Length = len;
#line 2093
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2094
  return (status);
}
}
#line 2098 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdSetEventMask(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 *pu8Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2103
  status = 0;
#line 2105
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2106
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2108
  localBuf[0] = '\000';
#line 2108
  tmp = 1U;
#line 2108
  while (1) {
#line 2108
    if (tmp >= 6U) {
#line 2108
      break;
    } else {

    }
#line 2108
    localBuf[tmp] = (unsigned char)0;
#line 2108
    tmp = tmp + 1U;
  }
#line 2110
  len = 0U;
#line 2113
  pu8Temp = (u8 *)(& pHciCmd->Data);
#line 2114
  pBtHciInfo->BTEventMask = (u64 )*pu8Temp;
#line 2115
  if (BTCoexDbgLevel == 1U) {
#line 2115
    printk("BTEventMask = 0x%llx\n", pBtHciInfo->BTEventMask);
  } else {

  }
#line 2119
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2121
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 1, status);
#line 2121
  len = (int )tmp___0 + (int )len;
#line 2127
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2128
  *pRetPar = (u8 )status;
#line 2129
  len = (unsigned int )len + 1U;
#line 2130
  PPacketIrpEvent->Length = len;
#line 2132
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2134
  return (status);
}
}
#line 2139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdSetEventMaskPage2(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 *pu8Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2144
  status = 0;
#line 2145
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2146
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2148
  localBuf[0] = '\000';
#line 2148
  tmp = 1U;
#line 2148
  while (1) {
#line 2148
    if (tmp >= 6U) {
#line 2148
      break;
    } else {

    }
#line 2148
    localBuf[tmp] = (unsigned char)0;
#line 2148
    tmp = tmp + 1U;
  }
#line 2150
  len = 0U;
#line 2153
  pu8Temp = (u8 *)(& pHciCmd->Data);
#line 2154
  pBtHciInfo->BTEventMaskPage2 = (u64 )*pu8Temp;
#line 2155
  if (BTCoexDbgLevel == 1U) {
#line 2155
    printk("BTEventMaskPage2 = 0x%llx\n", pBtHciInfo->BTEventMaskPage2);
  } else {

  }
#line 2159
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2161
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 99, status);
#line 2161
  len = (int )tmp___0 + (int )len;
#line 2167
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2168
  *pRetPar = (u8 )status;
#line 2169
  len = (unsigned int )len + 1U;
#line 2170
  PPacketIrpEvent->Length = len;
#line 2172
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2174
  return (status);
}
}
#line 2178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadLocationData(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[12U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 2183
  status = 0;
#line 2184
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2185
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2186
  localBuf[0] = '\000';
#line 2186
  tmp = 1U;
#line 2186
  while (1) {
#line 2186
    if (tmp >= 12U) {
#line 2186
      break;
    } else {

    }
#line 2186
    localBuf[tmp] = (unsigned char)0;
#line 2186
    tmp = tmp + 1U;
  }
#line 2188
  len = 0U;
#line 2192
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2194
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 100, status);
#line 2194
  len = (int )tmp___0 + (int )len;
#line 2198
  if (BTCoexDbgLevel == 1U) {
#line 2198
    printk("DomainAware = 0x%x\n", (int )pBtHciInfo->LocationDomainAware);
  } else {

  }
#line 2199
  if (BTCoexDbgLevel == 1U) {
#line 2199
    printk("Domain = 0x%x\n", (int )pBtHciInfo->LocationDomain);
  } else {

  }
#line 2200
  if (BTCoexDbgLevel == 1U) {
#line 2200
    printk("DomainOptions = 0x%x\n", (int )pBtHciInfo->LocationDomainOptions);
  } else {

  }
#line 2201
  if (BTCoexDbgLevel == 1U) {
#line 2201
    printk("Options = 0x%x\n", (int )pBtHciInfo->LocationOptions);
  } else {

  }
#line 2204
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2205
  *pRetPar = (u8 )status;
#line 2207
  *(pRetPar + 1UL) = pBtHciInfo->LocationDomainAware;
#line 2208
  pu2Temp = (u16 *)pRetPar + 2U;
#line 2209
  *pu2Temp = pBtHciInfo->LocationDomain;
#line 2210
  *(pRetPar + 4UL) = pBtHciInfo->LocationDomainOptions;
#line 2211
  *(pRetPar + 5UL) = pBtHciInfo->LocationOptions;
#line 2212
  len = (unsigned int )len + 6U;
#line 2213
  PPacketIrpEvent->Length = len;
#line 2215
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2216
  return (status);
}
}
#line 2220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdWriteLocationData(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 *pu2Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2225
  status = 0;
#line 2226
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2227
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2229
  localBuf[0] = '\000';
#line 2229
  tmp = 1U;
#line 2229
  while (1) {
#line 2229
    if (tmp >= 6U) {
#line 2229
      break;
    } else {

    }
#line 2229
    localBuf[tmp] = (unsigned char)0;
#line 2229
    tmp = tmp + 1U;
  }
#line 2231
  len = 0U;
#line 2234
  pBtHciInfo->LocationDomainAware = pHciCmd->Data[0];
#line 2235
  pu2Temp = (u16 *)(& pHciCmd->Data) + 1U;
#line 2236
  pBtHciInfo->LocationDomain = *pu2Temp;
#line 2237
  pBtHciInfo->LocationDomainOptions = pHciCmd->Data[3];
#line 2238
  pBtHciInfo->LocationOptions = pHciCmd->Data[4];
#line 2239
  if (BTCoexDbgLevel == 1U) {
#line 2239
    printk("DomainAware = 0x%x\n", (int )pBtHciInfo->LocationDomainAware);
  } else {

  }
#line 2240
  if (BTCoexDbgLevel == 1U) {
#line 2240
    printk("Domain = 0x%x\n", (int )pBtHciInfo->LocationDomain);
  } else {

  }
#line 2241
  if (BTCoexDbgLevel == 1U) {
#line 2241
    printk("DomainOptions = 0x%x\n", (int )pBtHciInfo->LocationDomainOptions);
  } else {

  }
#line 2242
  if (BTCoexDbgLevel == 1U) {
#line 2242
    printk("Options = 0x%x\n", (int )pBtHciInfo->LocationOptions);
  } else {

  }
#line 2245
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2247
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 101, status);
#line 2247
  len = (int )tmp___0 + (int )len;
#line 2253
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2254
  *pRetPar = (u8 )status;
#line 2255
  len = (unsigned int )len + 1U;
#line 2256
  PPacketIrpEvent->Length = len;
#line 2258
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2260
  return (status);
}
}
#line 2264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadFlowControlMode(struct rtw_adapter *padapter ,
                                                    struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2269
  status = 0;
#line 2270
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2271
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2272
  localBuf[0] = '\000';
#line 2272
  tmp = 1U;
#line 2272
  while (1) {
#line 2272
    if (tmp >= 7U) {
#line 2272
      break;
    } else {

    }
#line 2272
    localBuf[tmp] = (unsigned char)0;
#line 2272
    tmp = tmp + 1U;
  }
#line 2274
  len = 0U;
#line 2277
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2279
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 102, status);
#line 2279
  len = (int )tmp___0 + (int )len;
#line 2285
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2286
  *pRetPar = (u8 )status;
#line 2287
  *(pRetPar + 1UL) = pBtHciInfo->FlowControlMode;
#line 2288
  len = (unsigned int )len + 2U;
#line 2289
  PPacketIrpEvent->Length = len;
#line 2291
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2292
  return (status);
}
}
#line 2296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdWriteFlowControlMode(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2301
  status = 0;
#line 2302
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2303
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2304
  localBuf[0] = '\000';
#line 2304
  tmp = 1U;
#line 2304
  while (1) {
#line 2304
    if (tmp >= 6U) {
#line 2304
      break;
    } else {

    }
#line 2304
    localBuf[tmp] = (unsigned char)0;
#line 2304
    tmp = tmp + 1U;
  }
#line 2306
  len = 0U;
#line 2309
  pBtHciInfo->FlowControlMode = pHciCmd->Data[0];
#line 2312
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2314
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 103, status);
#line 2314
  len = (int )tmp___0 + (int )len;
#line 2320
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2321
  *pRetPar = (u8 )status;
#line 2322
  len = (unsigned int )len + 1U;
#line 2323
  PPacketIrpEvent->Length = len;
#line 2325
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2327
  return (status);
}
}
#line 2331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadBestEffortFlushTimeout(struct rtw_adapter *padapter ,
                                                           struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u16 i ;
  u16 j ;
  u16 logicHandle ;
  u32 BestEffortFlushTimeout ;
  u8 find ;
  u8 localBuf[10U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u32 *pu4Temp ;
  u8 tmp___0 ;

  {
#line 2336
  status = 0;
#line 2337
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2339
  BestEffortFlushTimeout = 4294967295U;
#line 2340
  find = 0U;
#line 2342
  logicHandle = *((u16 *)(& pHciCmd->Data));
#line 2344
  j = 0U;
#line 2344
  goto ldv_56502;
  ldv_56501: 
#line 2345
  i = 0U;
#line 2345
  goto ldv_56500;
  ldv_56499: ;
#line 2346
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
#line 2347
    BestEffortFlushTimeout = pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BestEffortFlushTimeout;
#line 2348
    find = 1U;
#line 2349
    goto ldv_56498;
  } else {

  }
#line 2345
  i = (u16 )((int )i + 1);
  ldv_56500: ;
#line 2345
  if ((unsigned int )i <= 1U) {
#line 2347
    goto ldv_56499;
  } else {

  }
  ldv_56498: 
#line 2344
  j = (u16 )((int )j + 1);
  ldv_56502: ;
#line 2344
  if ((unsigned int )j <= 1U) {
#line 2346
    goto ldv_56501;
  } else {

  }

#line 2354
  if ((unsigned int )find == 0U) {
#line 2355
    status = 2;
  } else {

  }
#line 2358
  localBuf[0] = '\000';
#line 2358
  tmp = 1U;
#line 2358
  while (1) {
#line 2358
    if (tmp >= 10U) {
#line 2358
      break;
    } else {

    }
#line 2358
    localBuf[tmp] = (unsigned char)0;
#line 2358
    tmp = tmp + 1U;
  }
#line 2360
  len = 0U;
#line 2364
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2366
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 105, status);
#line 2366
  len = (int )tmp___0 + (int )len;
#line 2372
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2373
  *pRetPar = (u8 )status;
#line 2374
  pu4Temp = (u32 *)pRetPar + 1U;
#line 2375
  *pu4Temp = BestEffortFlushTimeout;
#line 2376
  len = (unsigned int )len + 5U;
#line 2377
  PPacketIrpEvent->Length = len;
#line 2379
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2381
  return (status);
}
}
#line 2385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdWriteBestEffortFlushTimeout(struct rtw_adapter *padapter ,
                                                            struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u16 i ;
  u16 j ;
  u16 logicHandle ;
  u32 BestEffortFlushTimeout ;
  u8 find ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2390
  status = 0;
#line 2391
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2393
  BestEffortFlushTimeout = 4294967295U;
#line 2394
  find = 0U;
#line 2396
  logicHandle = *((u16 *)(& pHciCmd->Data));
#line 2397
  BestEffortFlushTimeout = *((u32 *)(& pHciCmd->Data) + 1U);
#line 2400
  j = 0U;
#line 2400
  goto ldv_56524;
  ldv_56523: 
#line 2401
  i = 0U;
#line 2401
  goto ldv_56522;
  ldv_56521: ;
#line 2402
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
#line 2403
    pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BestEffortFlushTimeout = BestEffortFlushTimeout;
#line 2404
    find = 1U;
#line 2405
    goto ldv_56520;
  } else {

  }
#line 2401
  i = (u16 )((int )i + 1);
  ldv_56522: ;
#line 2401
  if ((unsigned int )i <= 1U) {
#line 2403
    goto ldv_56521;
  } else {

  }
  ldv_56520: 
#line 2400
  j = (u16 )((int )j + 1);
  ldv_56524: ;
#line 2400
  if ((unsigned int )j <= 1U) {
#line 2402
    goto ldv_56523;
  } else {

  }

#line 2410
  if ((unsigned int )find == 0U) {
#line 2411
    status = 2;
  } else {

  }
#line 2414
  localBuf[0] = '\000';
#line 2414
  tmp = 1U;
#line 2414
  while (1) {
#line 2414
    if (tmp >= 6U) {
#line 2414
      break;
    } else {

    }
#line 2414
    localBuf[tmp] = (unsigned char)0;
#line 2414
    tmp = tmp + 1U;
  }
#line 2416
  len = 0U;
#line 2419
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2421
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 106, status);
#line 2421
  len = (int )tmp___0 + (int )len;
#line 2427
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2428
  *pRetPar = (u8 )status;
#line 2429
  len = (unsigned int )len + 1U;
#line 2430
  PPacketIrpEvent->Length = len;
#line 2432
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2434
  return (status);
}
}
#line 2438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdShortRangeMode(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  u8 PhyLinkHandle ;
  u8 EntryNum ;
  u8 ShortRangeMode ;

  {
#line 2443
  status = 0;
#line 2444
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2447
  PhyLinkHandle = pHciCmd->Data[0];
#line 2448
  ShortRangeMode = pHciCmd->Data[1];
#line 2449
  if (BTCoexDbgLevel == 1U) {
#line 2449
    printk("PLH = 0x%x, Short_Range_Mode = 0x%x\n", (int )PhyLinkHandle, (int )ShortRangeMode);
  } else {

  }
#line 2451
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
#line 2452
  if ((unsigned int )EntryNum != 255U) {
#line 2453
    pBTInfo->BtAsocEntry[(int )EntryNum].ShortRangeMode = ShortRangeMode;
  } else {
#line 2455
    if (BTCoexDbgLevel == 1U) {
#line 2455
      printk("No such PLH(0x%x)\n", (int )PhyLinkHandle);
    } else {

    }
#line 2456
    status = 2;
  }
#line 2459
  bthci_EventCommandStatus(padapter, 3, 107, status);
#line 2464
  bthci_EventShortRangeModeChangeComplete(padapter, status, (int )ShortRangeMode,
                                          (int )EntryNum);
#line 2466
  return (status);
}
}
#line 2469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadLocalSupportedCommands(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 *pSupportedCmds ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2471
  status = 0;
#line 2472
  localBuf[0] = '\000';
#line 2472
  tmp = 1U;
#line 2472
  while (1) {
#line 2472
    if (tmp >= 256U) {
#line 2472
      break;
    } else {

    }
#line 2472
    localBuf[tmp] = (unsigned char)0;
#line 2472
    tmp = tmp + 1U;
  }
#line 2474
  len = 0U;
#line 2478
  memset((void *)(& localBuf), 0, 256UL);
#line 2479
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2481
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 2, status);
#line 2481
  len = (int )tmp___0 + (int )len;
#line 2487
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2488
  *pRetPar = (u8 )status;
#line 2489
  len = (unsigned int )len + 1U;
#line 2490
  pSupportedCmds = pRetPar + 1UL;
#line 2491
  if (BTCoexDbgLevel == 1U) {
#line 2491
    printk("Octet[5]= 0xc0\nBit [6]= Set Event Mask, [7]= Reset\n");
  } else {

  }
#line 2492
  *(pSupportedCmds + 5UL) = 192U;
#line 2493
  if (BTCoexDbgLevel == 1U) {
#line 2493
    printk("Octet[6]= 0x01\nBit [0]= Set Event Filter\n");
  } else {

  }
#line 2494
  *(pSupportedCmds + 6UL) = 1U;
#line 2495
  if (BTCoexDbgLevel == 1U) {
#line 2495
    printk("Octet[7]= 0x0c\nBit [2]= Read Connection Accept Timeout, [3]= Write Connection Accept Timeout\n");
  } else {

  }
#line 2496
  *(pSupportedCmds + 7UL) = 12U;
#line 2497
  if (BTCoexDbgLevel == 1U) {
#line 2497
    printk("Octet[10]= 0x80\nBit [7]= Host Number Of Completed Packets\n");
  } else {

  }
#line 2498
  *(pSupportedCmds + 10UL) = 128U;
#line 2499
  if (BTCoexDbgLevel == 1U) {
#line 2499
    printk("Octet[11]= 0x03\nBit [0]= Read Link Supervision Timeout, [1]= Write Link Supervision Timeout\n");
  } else {

  }
#line 2500
  *(pSupportedCmds + 11UL) = 3U;
#line 2501
  if (BTCoexDbgLevel == 1U) {
#line 2501
    printk("Octet[14]= 0xa8\nBit [3]= Read Local Version Information, [5]= Read Local Supported Features, [7]= Read Buffer Size\n");
  } else {

  }
#line 2502
  *(pSupportedCmds + 14UL) = 168U;
#line 2503
  if (BTCoexDbgLevel == 1U) {
#line 2503
    printk("Octet[15]= 0x1c\nBit [2]= Read Failed Contact Count, [3]= Reset Failed Contact Count, [4]= Get Link Quality\n");
  } else {

  }
#line 2504
  *(pSupportedCmds + 15UL) = 28U;
#line 2506
  if (BTCoexDbgLevel == 1U) {
#line 2506
    printk("Octet[19]= 0x40\nBit [6]= Enhanced Flush\n");
  } else {

  }
#line 2507
  *(pSupportedCmds + 19UL) = 64U;
#line 2508
  if (BTCoexDbgLevel == 1U) {
#line 2508
    printk("Octet[21]= 0xff\nBit [0]= Create Physical Link, [1]= Accept Physical Link, [2]= Disconnect Physical Link, [3]= Create Logical Link\n");
  } else {

  }
#line 2509
  if (BTCoexDbgLevel == 1U) {
#line 2509
    printk("\t[4]= Accept Logical Link, [5]= Disconnect Logical Link, [6]= Logical Link Cancel, [7]= Flow Spec Modify\n");
  } else {

  }
#line 2510
  *(pSupportedCmds + 21UL) = 255U;
#line 2511
  if (BTCoexDbgLevel == 1U) {
#line 2511
    printk("Octet[22]= 0xff\nBit [0]= Read Logical Link Accept Timeout, [1]= Write Logical Link Accept Timeout, [2]= Set Event Mask Page 2, [3]= Read Location Data\n");
  } else {

  }
#line 2512
  if (BTCoexDbgLevel == 1U) {
#line 2512
    printk("\t[4]= Write Location Data, [5]= Read Local AMP Info, [6]= Read Local AMP_ASSOC, [7]= Write Remote AMP_ASSOC\n");
  } else {

  }
#line 2513
  *(pSupportedCmds + 22UL) = 255U;
#line 2514
  if (BTCoexDbgLevel == 1U) {
#line 2514
    printk("Octet[23]= 0x07\nBit [0]= Read Flow Control Mode, [1]= Write Flow Control Mode, [2]= Read Data Block Size\n");
  } else {

  }
#line 2515
  *(pSupportedCmds + 23UL) = 7U;
#line 2516
  if (BTCoexDbgLevel == 1U) {
#line 2516
    printk("Octet[24]= 0x1c\nBit [2]= Read Best Effort Flush Timeout, [3]= Write Best Effort Flush Timeout, [4]= Short Range Mode\n");
  } else {

  }
#line 2517
  *(pSupportedCmds + 24UL) = 28U;
#line 2518
  len = (unsigned int )len + 64U;
#line 2519
  PPacketIrpEvent->Length = len;
#line 2521
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2523
  return (status);
}
}
#line 2526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadLocalSupportedFeatures(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2528
  status = 0;
#line 2529
  localBuf[0] = '\000';
#line 2529
  tmp = 1U;
#line 2529
  while (1) {
#line 2529
    if (tmp >= 256U) {
#line 2529
      break;
    } else {

    }
#line 2529
    localBuf[tmp] = (unsigned char)0;
#line 2529
    tmp = tmp + 1U;
  }
#line 2531
  len = 0U;
#line 2535
  memset((void *)(& localBuf), 0, 256UL);
#line 2536
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2538
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 3, status);
#line 2538
  len = (int )tmp___0 + (int )len;
#line 2544
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2545
  *pRetPar = (u8 )status;
#line 2546
  len = (unsigned int )len + 9U;
#line 2547
  PPacketIrpEvent->Length = len;
#line 2549
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2550
  return (status);
}
}
#line 2553 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadLocalAMPAssoc(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 PhyLinkHandle ;
  u8 EntryNum ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u16 *pRemainLen ;
  u32 totalLen ;
  u16 typeLen ;
  u16 remainLen ;
  u16 ret_index ;
  u8 *pRetPar ;
  u8 tmp___0 ;
  u32 __i ;
  u8 *ptr ;

  {
#line 2556
  status = 0;
#line 2557
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2558
  pBtMgnt = & pBTInfo->BtMgnt;
#line 2559
  pBtDbg = & pBTInfo->BtDbg;
#line 2562
  pBtDbg->dbgHciInfo.hciCmdCntReadLocalAmpAssoc = pBtDbg->dbgHciInfo.hciCmdCntReadLocalAmpAssoc + 1U;
#line 2563
  PhyLinkHandle = *((u8 *)(& pHciCmd->Data));
#line 2564
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
#line 2566
  if ((unsigned int )EntryNum == 255U && (unsigned int )PhyLinkHandle != 0U) {
#line 2567
    if (BTCoexDbgLevel == 1U) {
#line 2567
      printk("ReadLocalAMPAssoc, EntryNum = %d  !!!!!, physical link handle = 0x%x\n",
             (int )EntryNum, (int )PhyLinkHandle);
    } else {

    }
#line 2569
    status = 2;
  } else
#line 2570
  if ((unsigned int )pBtMgnt->bPhyLinkInProgressStartLL != 0U) {
#line 2571
    status = 2;
#line 2572
    pBtMgnt->bPhyLinkInProgressStartLL = 0U;
  } else {
#line 2574
    pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.BtPhyLinkhandle = *((u8 *)(& pHciCmd->Data));
#line 2575
    pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar = *((u16 *)(& pHciCmd->Data) + 1U);
#line 2576
    pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.MaxRemoteASSOCLen = *((u16 *)(& pHciCmd->Data) + 3U);
#line 2577
    if (BTCoexDbgLevel == 1U) {
#line 2577
      printk("ReadLocalAMPAssoc, LenSoFar =%d, MaxRemoteASSOCLen =%d\n", (int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar,
             (int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.MaxRemoteASSOCLen);
    } else {

    }
  }
#line 2582
  if (BTCoexDbgLevel == 1U) {
#line 2582
    printk("ReadLocalAMPAssoc, EntryNum = %d  !!!!!, physical link handle = 0x%x, LengthSoFar = %x  \n",
           (int )EntryNum, (int )PhyLinkHandle, (int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar);
  } else {

  }
#line 2590
  localBuf[0] = '\000';
#line 2590
  tmp = 1U;
#line 2590
  while (1) {
#line 2590
    if (tmp >= 256U) {
#line 2590
      break;
    } else {

    }
#line 2590
    localBuf[tmp] = (unsigned char)0;
#line 2590
    tmp = tmp + 1U;
  }
#line 2592
  totalLen = 0U;
#line 2593
  typeLen = 0U;
#line 2593
  remainLen = 0U;
#line 2593
  ret_index = 0U;
#line 2596
  memset((void *)(& localBuf), 0, 256UL);
#line 2598
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2600
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 10, status);
#line 2600
  totalLen = (u32 )tmp___0 + totalLen;
#line 2604
  if (BTCoexDbgLevel == 1U) {
#line 2604
    printk("ReadLocalAMPAssoc, Remaining_Len =%d  \n", (int )remainLen);
  } else {

  }
#line 2606
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )totalLen;
#line 2607
  *pRetPar = (u8 )status;
#line 2608
  *(pRetPar + 1UL) = *((u8 *)(& pHciCmd->Data));
#line 2609
  pRemainLen = (u16 *)pRetPar + 2U;
#line 2610
  totalLen = totalLen + 4U;
#line 2611
  ret_index = 4U;
#line 2613
  typeLen = bthci_AssocMACAddr(padapter, (void *)pRetPar + (unsigned long )ret_index);
#line 2614
  totalLen = (u32 )typeLen + totalLen;
#line 2615
  remainLen = (int )remainLen + (int )typeLen;
#line 2616
  ret_index = (int )ret_index + (int )typeLen;
#line 2617
  typeLen = bthci_AssocPreferredChannelList(padapter, (void *)pRetPar + (unsigned long )ret_index,
                                            (int )EntryNum);
#line 2618
  totalLen = (u32 )typeLen + totalLen;
#line 2619
  remainLen = (int )remainLen + (int )typeLen;
#line 2620
  ret_index = (int )ret_index + (int )typeLen;
#line 2621
  typeLen = bthci_PALCapabilities(padapter, (void *)pRetPar + (unsigned long )ret_index);
#line 2622
  totalLen = (u32 )typeLen + totalLen;
#line 2623
  remainLen = (int )remainLen + (int )typeLen;
#line 2624
  ret_index = (int )ret_index + (int )typeLen;
#line 2625
  typeLen = bthci_AssocPALVer(padapter, (void *)pRetPar + (unsigned long )ret_index);
#line 2626
  totalLen = (u32 )typeLen + totalLen;
#line 2627
  remainLen = (int )remainLen + (int )typeLen;
#line 2628
  PPacketIrpEvent->Length = (unsigned char )totalLen;
#line 2629
  *pRemainLen = remainLen;
#line 2630
  if (BTCoexDbgLevel == 1U) {
#line 2630
    printk("ReadLocalAMPAssoc, Remaining_Len =%d  \n", (int )remainLen);
  } else {

  }
#line 2631
  if (BTCoexDbgLevel == 1U) {
#line 2631
    ptr = (u8 *)(& PPacketIrpEvent->Data);
#line 2631
    printk("AMP_ASSOC_fragment : \n");
#line 2631
    __i = 0U;
#line 2631
    goto ldv_56577;
    ldv_56576: 
#line 2631
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 2631
    if (((__i + 1U) & 15U) == 0U) {
#line 2631
      printk("\n");
    } else {

    }
#line 2631
    __i = __i + 1U;
    ldv_56577: ;
#line 2631
    if (__i < totalLen) {
#line 2633
      goto ldv_56576;
    } else {

    }
#line 2631
    printk("\n");
  } else {

  }
#line 2633
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, totalLen + 2U);
#line 2636
  return (status);
}
}
#line 2639 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadFailedContactCounter(struct rtw_adapter *padapter ,
                                                         struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 handle ;
  u8 tmp___0 ;

  {
#line 2643
  status = 0;
#line 2644
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2645
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2646
  localBuf[0] = '\000';
#line 2646
  tmp = 1U;
#line 2646
  while (1) {
#line 2646
    if (tmp >= 256U) {
#line 2646
      break;
    } else {

    }
#line 2646
    localBuf[tmp] = (unsigned char)0;
#line 2646
    tmp = tmp + 1U;
  }
#line 2648
  len = 0U;
#line 2652
  handle = *((u16 *)(& pHciCmd->Data));
#line 2654
  memset((void *)(& localBuf), 0, 256UL);
#line 2655
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2657
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 1, status);
#line 2657
  len = (int )tmp___0 + (int )len;
#line 2663
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2664
  *pRetPar = (u8 )status;
#line 2665
  *(pRetPar + 1UL) = (unsigned char )handle;
#line 2666
  *(pRetPar + 2UL) = (unsigned char )((int )handle >> 8);
#line 2667
  *(pRetPar + 3UL) = (unsigned char )pBtHciInfo->FailContactCount;
#line 2668
  *(pRetPar + 4UL) = (unsigned char )((int )pBtHciInfo->FailContactCount >> 8);
#line 2669
  len = (unsigned int )len + 5U;
#line 2670
  PPacketIrpEvent->Length = len;
#line 2672
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2674
  return (status);
}
}
#line 2678 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdResetFailedContactCounter(struct rtw_adapter *padapter ,
                                                          struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 handle ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2683
  status = 0;
#line 2685
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2686
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2688
  localBuf[0] = '\000';
#line 2688
  tmp = 1U;
#line 2688
  while (1) {
#line 2688
    if (tmp >= 256U) {
#line 2688
      break;
    } else {

    }
#line 2688
    localBuf[tmp] = (unsigned char)0;
#line 2688
    tmp = tmp + 1U;
  }
#line 2690
  len = 0U;
#line 2693
  handle = *((u16 *)(& pHciCmd->Data));
#line 2694
  pBtHciInfo->FailContactCount = 0U;
#line 2697
  memset((void *)(& localBuf), 0, 256UL);
#line 2699
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2701
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 2, status);
#line 2701
  len = (int )tmp___0 + (int )len;
#line 2707
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2708
  *pRetPar = (u8 )status;
#line 2709
  *(pRetPar + 1UL) = (unsigned char )handle;
#line 2710
  *(pRetPar + 2UL) = (unsigned char )((int )handle >> 8);
#line 2711
  len = (unsigned int )len + 3U;
#line 2712
  PPacketIrpEvent->Length = len;
#line 2714
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2715
  return (status);
}
}
#line 2722 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadLocalVersionInformation(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 2726
  status = 0;
#line 2728
  localBuf[0] = '\000';
#line 2728
  tmp = 1U;
#line 2728
  while (1) {
#line 2728
    if (tmp >= 256U) {
#line 2728
      break;
    } else {

    }
#line 2728
    localBuf[tmp] = (unsigned char)0;
#line 2728
    tmp = tmp + 1U;
  }
#line 2730
  len = 0U;
#line 2734
  memset((void *)(& localBuf), 0, 256UL);
#line 2735
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2737
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 1, status);
#line 2737
  len = (int )tmp___0 + (int )len;
#line 2743
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2744
  *pRetPar = (u8 )status;
#line 2745
  *(pRetPar + 1UL) = 5U;
#line 2746
  pu2Temp = (u16 *)pRetPar + 2U;
#line 2747
  *pu2Temp = 1U;
#line 2748
  *(pRetPar + 4UL) = 5U;
#line 2749
  pu2Temp = (u16 *)pRetPar + 5U;
#line 2750
  *pu2Temp = 93U;
#line 2751
  pu2Temp = (u16 *)pRetPar + 7U;
#line 2752
  *pu2Temp = 1U;
#line 2753
  len = (unsigned int )len + 9U;
#line 2754
  PPacketIrpEvent->Length = len;
#line 2756
  if (BTCoexDbgLevel == 1U) {
#line 2756
    printk("LOCAL_VERSION_INFORMATION\n");
  } else {

  }
#line 2757
  if (BTCoexDbgLevel == 1U) {
#line 2757
    printk("Status  %x\n", (unsigned int )status);
  } else {

  }
#line 2758
  if (BTCoexDbgLevel == 1U) {
#line 2758
    printk("HCI_Version = 0x05\n");
  } else {

  }
#line 2759
  if (BTCoexDbgLevel == 1U) {
#line 2759
    printk("HCI_Revision = 0x0001\n");
  } else {

  }
#line 2760
  if (BTCoexDbgLevel == 1U) {
#line 2760
    printk("LMP/PAL_Version = 0x05\n");
  } else {

  }
#line 2761
  if (BTCoexDbgLevel == 1U) {
#line 2761
    printk("Manufacturer_Name = 0x0001\n");
  } else {

  }
#line 2762
  if (BTCoexDbgLevel == 1U) {
#line 2762
    printk("LMP/PAL_Subversion = 0x0001\n");
  } else {

  }
#line 2764
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2766
  return (status);
}
}
#line 2770 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadDataBlockSize(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 2772
  status = 0;
#line 2773
  localBuf[0] = '\000';
#line 2773
  tmp = 1U;
#line 2773
  while (1) {
#line 2773
    if (tmp >= 256U) {
#line 2773
      break;
    } else {

    }
#line 2773
    localBuf[tmp] = (unsigned char)0;
#line 2773
    tmp = tmp + 1U;
  }
#line 2775
  len = 0U;
#line 2779
  memset((void *)(& localBuf), 0, 256UL);
#line 2780
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2782
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 10, status);
#line 2782
  len = (int )tmp___0 + (int )len;
#line 2788
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2789
  *pRetPar = 0U;
#line 2790
  pu2Temp = (u16 *)pRetPar + 1U;
#line 2791
  *pu2Temp = 1492U;
#line 2793
  pu2Temp = (u16 *)pRetPar + 3U;
#line 2794
  *pu2Temp = 1492U;
#line 2795
  pu2Temp = (u16 *)pRetPar + 5U;
#line 2796
  *pu2Temp = 256U;
#line 2797
  len = (unsigned int )len + 7U;
#line 2798
  PPacketIrpEvent->Length = len;
#line 2800
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2802
  return (status);
}
}
#line 2806 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadBufferSize(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 2808
  status = 0;
#line 2809
  localBuf[0] = '\000';
#line 2809
  tmp = 1U;
#line 2809
  while (1) {
#line 2809
    if (tmp >= 256U) {
#line 2809
      break;
    } else {

    }
#line 2809
    localBuf[tmp] = (unsigned char)0;
#line 2809
    tmp = tmp + 1U;
  }
#line 2811
  len = 0U;
#line 2815
  memset((void *)(& localBuf), 0, 256UL);
#line 2817
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2819
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 5, status);
#line 2819
  len = (int )tmp___0 + (int )len;
#line 2823
  if (BTCoexDbgLevel == 1U) {
#line 2823
    printk("Synchronous_Data_Packet_Length = 0x%x\n", 255);
  } else {

  }
#line 2824
  if (BTCoexDbgLevel == 1U) {
#line 2824
    printk("Total_Num_ACL_Data_Packets = 0x%x\n", 256);
  } else {

  }
#line 2825
  if (BTCoexDbgLevel == 1U) {
#line 2825
    printk("Total_Num_Synchronous_Data_Packets = 0x%x\n", 256);
  } else {

  }
#line 2827
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2828
  *pRetPar = (u8 )status;
#line 2829
  pu2Temp = (u16 *)pRetPar + 1U;
#line 2830
  *pu2Temp = 1492U;
#line 2832
  *(pRetPar + 3UL) = 255U;
#line 2833
  pu2Temp = (u16 *)pRetPar + 4U;
#line 2834
  *pu2Temp = 256U;
#line 2835
  pu2Temp = (u16 *)pRetPar + 6U;
#line 2836
  *pu2Temp = 256U;
#line 2837
  len = (unsigned int )len + 8U;
#line 2838
  PPacketIrpEvent->Length = len;
#line 2840
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2842
  return (status);
}
}
#line 2845 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadLocalAMPInfo(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  struct pwrctrl_priv *ppwrctrl ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u32 *pu4Temp ;
  u32 TotalBandwidth ;
  u32 MaxBandGUBandwidth ;
  u8 ControlType ;
  u8 AmpStatus ;
  u32 MaxFlushTimeout ;
  u32 BestEffortFlushTimeout ;
  u16 MaxPDUSize ;
  u16 PalCap ;
  u16 AmpAssocLen ;
  u16 MinLatency ;
  u8 tmp___0 ;

  {
#line 2847
  status = 0;
#line 2848
  ppwrctrl = & padapter->pwrctrlpriv;
#line 2849
  localBuf[0] = '\000';
#line 2849
  tmp = 1U;
#line 2849
  while (1) {
#line 2849
    if (tmp >= 256U) {
#line 2849
      break;
    } else {

    }
#line 2849
    localBuf[tmp] = (unsigned char)0;
#line 2849
    tmp = tmp + 1U;
  }
#line 2851
  len = 0U;
#line 2855
  TotalBandwidth = 30000U;
#line 2855
  MaxBandGUBandwidth = 20000U;
#line 2856
  ControlType = 1U;
#line 2856
  AmpStatus = 1U;
#line 2857
  MaxFlushTimeout = 10000U;
#line 2857
  BestEffortFlushTimeout = 5000U;
#line 2858
  MaxPDUSize = 1492U;
#line 2858
  PalCap = 1U;
#line 2858
  AmpAssocLen = 672U;
#line 2858
  MinLatency = 20U;
#line 2860
  if (((unsigned long )ppwrctrl->rfoff_reason & 1073741824UL) != 0UL || (int )ppwrctrl->rfoff_reason < 0) {
#line 2862
    AmpStatus = 2U;
  } else {

  }
#line 2865
  memset((void *)(& localBuf), 0, 256UL);
#line 2867
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2869
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 9, status);
#line 2869
  len = (int )tmp___0 + (int )len;
#line 2875
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2876
  *pRetPar = (u8 )status;
#line 2877
  *(pRetPar + 1UL) = AmpStatus;
#line 2878
  pu4Temp = (u32 *)pRetPar + 2U;
#line 2879
  *pu4Temp = TotalBandwidth;
#line 2880
  pu4Temp = (u32 *)pRetPar + 6U;
#line 2881
  *pu4Temp = MaxBandGUBandwidth;
#line 2882
  pu4Temp = (u32 *)pRetPar + 10U;
#line 2883
  *pu4Temp = (u32 )MinLatency;
#line 2884
  pu4Temp = (u32 *)pRetPar + 14U;
#line 2885
  *pu4Temp = (u32 )MaxPDUSize;
#line 2886
  *(pRetPar + 18UL) = ControlType;
#line 2887
  pu2Temp = (u16 *)pRetPar + 19U;
#line 2888
  *pu2Temp = PalCap;
#line 2889
  pu2Temp = (u16 *)pRetPar + 21U;
#line 2890
  *pu2Temp = AmpAssocLen;
#line 2891
  pu4Temp = (u32 *)pRetPar + 23U;
#line 2892
  *pu4Temp = MaxFlushTimeout;
#line 2893
  pu4Temp = (u32 *)pRetPar + 27U;
#line 2894
  *pu4Temp = BestEffortFlushTimeout;
#line 2895
  len = (unsigned int )len + 31U;
#line 2896
  PPacketIrpEvent->Length = len;
#line 2897
  if (BTCoexDbgLevel == 1U) {
#line 2897
    printk("AmpStatus = 0x%x\n", (int )AmpStatus);
  } else {

  }
#line 2899
  if (BTCoexDbgLevel == 1U) {
#line 2899
    printk("TotalBandwidth = 0x%x, MaxBandGUBandwidth = 0x%x, MinLatency = 0x%x, \n MaxPDUSize = 0x%x, ControlType = 0x%x\n",
           TotalBandwidth, MaxBandGUBandwidth, (int )MinLatency, (int )MaxPDUSize,
           (int )ControlType);
  } else {

  }
#line 2901
  if (BTCoexDbgLevel == 1U) {
#line 2901
    printk("PalCap = 0x%x, AmpAssocLen = 0x%x, MaxFlushTimeout = 0x%x, BestEffortFlushTimeout = 0x%x\n",
           (int )PalCap, (int )AmpAssocLen, MaxFlushTimeout, BestEffortFlushTimeout);
  } else {

  }
#line 2903
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2904
  return (status);
}
}
#line 2908 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdCreatePhysicalLink(struct rtw_adapter *padapter ,
                                                   struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
#line 2914
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2915
  pBtDbg = & pBTInfo->BtDbg;
#line 2917
  pBtDbg->dbgHciInfo.hciCmdCntCreatePhyLink = pBtDbg->dbgHciInfo.hciCmdCntCreatePhyLink + 1U;
#line 2919
  status = bthci_BuildPhysicalLink(padapter, pHciCmd, 53);
#line 2922
  return (status);
}
}
#line 2926 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdReadLinkQuality(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  u16 PLH ;
  u8 EntryNum ;
  u8 LinkQuality ;
  u8 localBuf[11U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2931
  status = 0;
#line 2932
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2934
  LinkQuality = 85U;
#line 2936
  PLH = *((u16 *)(& pHciCmd->Data));
#line 2937
  if (BTCoexDbgLevel == 1U) {
#line 2937
    printk("PLH = 0x%x\n", (int )PLH);
  } else {

  }
#line 2939
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )((unsigned char )PLH));
#line 2940
  if ((unsigned int )EntryNum == 255U) {
#line 2941
    if (BTCoexDbgLevel == 1U) {
#line 2941
      printk("No such PLH(0x%x)\n", (int )PLH);
    } else {

    }
#line 2942
    status = 2;
  } else {

  }
#line 2946
  localBuf[0] = '\000';
#line 2946
  tmp = 1U;
#line 2946
  while (1) {
#line 2946
    if (tmp >= 11U) {
#line 2946
      break;
    } else {

    }
#line 2946
    localBuf[tmp] = (unsigned char)0;
#line 2946
    tmp = tmp + 1U;
  }
#line 2948
  len = 0U;
#line 2951
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2953
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 3, status);
#line 2953
  len = (int )tmp___0 + (int )len;
#line 2958
  if (BTCoexDbgLevel == 1U) {
#line 2958
    printk(" PLH = 0x%x\n Link Quality = 0x%x\n", (int )PLH, (int )LinkQuality);
  } else {

  }
#line 2961
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2962
  *pRetPar = (u8 )status;
#line 2963
  *((u16 *)pRetPar + 1U) = (u16 )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
#line 2964
  *(pRetPar + 3UL) = 85U;
#line 2965
  len = (unsigned int )len + 4U;
#line 2966
  PPacketIrpEvent->Length = len;
#line 2968
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2971
  return (status);
}
}
#line 2975 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdCreateLogicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
#line 2980
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2981
  pBtDbg = & pBTInfo->BtDbg;
#line 2983
  pBtDbg->dbgHciInfo.hciCmdCntCreateLogLink = pBtDbg->dbgHciInfo.hciCmdCntCreateLogLink + 1U;
#line 2985
  bthci_BuildLogicalLink(padapter, pHciCmd, 56);
#line 2988
  return (0);
}
}
#line 2992 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdAcceptLogicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
#line 2997
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2998
  pBtDbg = & pBTInfo->BtDbg;
#line 3000
  pBtDbg->dbgHciInfo.hciCmdCntAcceptLogLink = pBtDbg->dbgHciInfo.hciCmdCntAcceptLogLink + 1U;
#line 3002
  bthci_BuildLogicalLink(padapter, pHciCmd, 57);
#line 3005
  return (0);
}
}
#line 3009 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdDisconnectLogicalLink(struct rtw_adapter *padapter ,
                                                      struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u16 logicHandle ;
  u8 i ;
  u8 j ;
  u8 find ;
  u8 LogLinkCount ;
  unsigned long tmp ;

  {
#line 3014
  status = 0;
#line 3016
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3017
  pBtMgnt = & pBTinfo->BtMgnt;
#line 3018
  pBtDbg = & pBTinfo->BtDbg;
#line 3020
  find = 0U;
#line 3020
  LogLinkCount = 0U;
#line 3022
  pBtDbg->dbgHciInfo.hciCmdCntDisconnectLogLink = pBtDbg->dbgHciInfo.hciCmdCntDisconnectLogLink + 1U;
#line 3024
  logicHandle = *((u16 *)(& pHciCmd->Data));
#line 3025
  if (BTCoexDbgLevel == 1U) {
#line 3025
    printk("DisconnectLogicalLink, logicHandle = 0x%x\n", (int )logicHandle);
  } else {

  }
#line 3028
  j = 0U;
#line 3028
  goto ldv_56700;
  ldv_56699: 
#line 3029
  i = 0U;
#line 3029
  goto ldv_56698;
  ldv_56697: ;
#line 3030
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
#line 3031
    if (BTCoexDbgLevel == 1U) {
#line 3031
      printk("DisconnectLogicalLink, logicHandle is matched  0x%x\n", (int )logicHandle);
    } else {

    }
#line 3032
    bthci_ResetFlowSpec(padapter, (int )j, (int )i);
#line 3033
    find = 1U;
#line 3034
    pBtMgnt->DisconnectEntryNum = j;
#line 3035
    goto ldv_56696;
  } else {

  }
#line 3029
  i = (u8 )((int )i + 1);
  ldv_56698: ;
#line 3029
  if ((unsigned int )i <= 1U) {
#line 3031
    goto ldv_56697;
  } else {

  }
  ldv_56696: 
#line 3028
  j = (u8 )((int )j + 1);
  ldv_56700: ;
#line 3028
  if ((unsigned int )j <= 1U) {
#line 3030
    goto ldv_56699;
  } else {

  }

#line 3040
  if ((unsigned int )find == 0U) {
#line 3041
    status = 2;
  } else {

  }
#line 3044
  i = 0U;
#line 3044
  goto ldv_56703;
  ldv_56702: ;
#line 3045
  if ((unsigned int )pBTinfo->BtAsocEntry[(int )pBtMgnt->DisconnectEntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle != 0U) {
#line 3046
    LogLinkCount = (u8 )((int )LogLinkCount + 1);
  } else {

  }
#line 3044
  i = (u8 )((int )i + 1);
  ldv_56703: ;
#line 3044
  if ((unsigned int )i <= 1U) {
#line 3046
    goto ldv_56702;
  } else {

  }
#line 3050
  bthci_EventCommandStatus(padapter, 1, 58, status);
#line 3057
  if ((unsigned int )status == 0U) {
#line 3058
    bthci_EventDisconnectLogicalLinkComplete(padapter, status, (int )logicHandle,
                                             22);
  } else {

  }
#line 3062
  if ((unsigned int )LogLinkCount == 0U) {
#line 3063
    tmp = msecs_to_jiffies(100U);
#line 3063
    ldv_mod_timer_773(& pBTinfo->BTDisconnectPhyLinkTimer, tmp + (unsigned long )jiffies);
  } else {

  }
#line 3066
  return (status);
}
}
#line 3070 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdLogicalLinkCancel(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 CurrentEntryNum ;
  u8 CurrentLogEntryNum ;
  u8 physicalLinkHandle ;
  u8 TxFlowSpecID ;
  u8 i ;
  u16 CurrentLogicalHandle ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3073
  status = 0;
#line 3074
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3075
  pBtMgnt = & pBTinfo->BtMgnt;
#line 3081
  physicalLinkHandle = *((u8 *)(& pHciCmd->Data));
#line 3082
  TxFlowSpecID = *((u8 *)(& pHciCmd->Data) + 1UL);
#line 3084
  if (BTCoexDbgLevel == 1U) {
#line 3084
    printk("LogicalLinkCancel, physicalLinkHandle = 0x%x, TxFlowSpecID = 0x%x\n",
           (int )physicalLinkHandle, (int )TxFlowSpecID);
  } else {

  }
#line 3087
  CurrentEntryNum = pBtMgnt->CurrentConnectEntryNum;
#line 3088
  CurrentLogicalHandle = pBtMgnt->BtCurrentLogLinkhandle;
#line 3090
  if (BTCoexDbgLevel == 1U) {
#line 3090
    printk("CurrentEntryNum = 0x%x, CurrentLogicalHandle = 0x%x\n", (int )CurrentEntryNum,
           (int )CurrentLogicalHandle);
  } else {

  }
#line 3093
  CurrentLogEntryNum = 255U;
#line 3094
  i = 0U;
#line 3094
  goto ldv_56720;
  ldv_56719: ;
#line 3095
  if ((int )pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )CurrentLogicalHandle && (int )pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )i].BtPhyLinkhandle == (int )physicalLinkHandle) {
#line 3097
    CurrentLogEntryNum = i;
#line 3098
    goto ldv_56718;
  } else {

  }
#line 3094
  i = (u8 )((int )i + 1);
  ldv_56720: ;
#line 3094
  if ((unsigned int )i <= 1U) {
#line 3096
    goto ldv_56719;
  } else {

  }
  ldv_56718: ;
#line 3102
  if ((unsigned int )CurrentLogEntryNum == 255U) {
#line 3103
    if (BTCoexDbgLevel == 1U) {
#line 3103
      printk("LogicalLinkCancel, CurrentLogEntryNum == 0xff !!!!\n");
    } else {

    }
#line 3104
    status = 2;
#line 3105
    return (status);
  } else
#line 3107
  if ((unsigned int )pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].bLLCompleteEventIsSet != 0U) {
#line 3108
    if (BTCoexDbgLevel == 1U) {
#line 3108
      printk("LogicalLinkCancel, LLCompleteEventIsSet!!!!\n");
    } else {

    }
#line 3109
    status = 11;
  } else {

  }
#line 3114
  localBuf[0] = '\000';
#line 3114
  tmp = 1U;
#line 3114
  while (1) {
#line 3114
    if (tmp >= 8U) {
#line 3114
      break;
    } else {

    }
#line 3114
    localBuf[tmp] = (unsigned char)0;
#line 3114
    tmp = tmp + 1U;
  }
#line 3116
  len = 0U;
#line 3119
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3121
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 1, 59, status);
#line 3121
  len = (int )tmp___0 + (int )len;
#line 3127
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3128
  *pRetPar = (u8 )status;
#line 3129
  *(pRetPar + 1UL) = pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].BtPhyLinkhandle;
#line 3130
  *(pRetPar + 2UL) = pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].BtTxFlowSpecID;
#line 3131
  len = (unsigned int )len + 3U;
#line 3132
  PPacketIrpEvent->Length = len;
#line 3134
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3137
  pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].bLLCancelCMDIsSetandComplete = 1U;
#line 3139
  return (status);
}
}
#line 3143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdFlowSpecModify(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u8 i ;
  u8 j ;
  u8 find ;
  u16 logicHandle ;

  {
#line 3146
  status = 0;
#line 3148
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3149
  find = 0U;
#line 3152
  logicHandle = *((u16 *)(& pHciCmd->Data));
#line 3154
  j = 0U;
#line 3154
  goto ldv_56739;
  ldv_56738: 
#line 3155
  i = 0U;
#line 3155
  goto ldv_56737;
  ldv_56736: ;
#line 3156
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
#line 3157
    memcpy((void *)(& pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Tx_Flow_Spec),
             (void const   *)(& pHciCmd->Data) + 2U, 16UL);
#line 3159
    memcpy((void *)(& pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Rx_Flow_Spec),
             (void const   *)(& pHciCmd->Data) + 18U, 16UL);
#line 3162
    bthci_CheckLogLinkBehavior(padapter, pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Tx_Flow_Spec);
#line 3163
    find = 1U;
#line 3164
    goto ldv_56735;
  } else {

  }
#line 3155
  i = (u8 )((int )i + 1);
  ldv_56737: ;
#line 3155
  if ((unsigned int )i <= 1U) {
#line 3157
    goto ldv_56736;
  } else {

  }
  ldv_56735: 
#line 3154
  j = (u8 )((int )j + 1);
  ldv_56739: ;
#line 3154
  if ((unsigned int )j <= 1U) {
#line 3156
    goto ldv_56738;
  } else {

  }

#line 3168
  if (BTCoexDbgLevel == 1U) {
#line 3168
    printk("FlowSpecModify, LLH = 0x%x, \n", (int )logicHandle);
  } else {

  }
#line 3171
  bthci_EventCommandStatus(padapter, 1, 60, 0);
#line 3176
  if ((unsigned int )find == 0U) {
#line 3177
    status = 2;
  } else {

  }
#line 3179
  bthci_EventSendFlowSpecModifyComplete(padapter, status, (int )logicHandle);
#line 3181
  return (status);
}
}
#line 3185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdAcceptPhysicalLink(struct rtw_adapter *padapter ,
                                                   struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
#line 3189
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3190
  pBtDbg = & pBTInfo->BtDbg;
#line 3192
  pBtDbg->dbgHciInfo.hciCmdCntAcceptPhyLink = pBtDbg->dbgHciInfo.hciCmdCntAcceptPhyLink + 1U;
#line 3194
  status = bthci_BuildPhysicalLink(padapter, pHciCmd, 54);
#line 3197
  return (status);
}
}
#line 3201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdDisconnectPhysicalLink(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 PLH ;
  u8 CurrentEntryNum ;
  u8 PhysLinkDisconnectReason ;

  {
#line 3204
  status = 0;
#line 3205
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3206
  pBtDbg = & pBTInfo->BtDbg;
#line 3209
  pBtDbg->dbgHciInfo.hciCmdCntDisconnectPhyLink = pBtDbg->dbgHciInfo.hciCmdCntDisconnectPhyLink + 1U;
#line 3211
  PLH = *((u8 *)(& pHciCmd->Data));
#line 3212
  PhysLinkDisconnectReason = *((u8 *)(& pHciCmd->Data) + 1UL);
#line 3213
  if (BTCoexDbgLevel == 1U) {
#line 3213
    printk("HCI_DISCONNECT_PHYSICAL_LINK  PhyHandle = 0x%x, Reason = 0x%x\n", (int )PLH,
           (int )PhysLinkDisconnectReason);
  } else {

  }
#line 3216
  CurrentEntryNum = bthci_GetCurrentEntryNum(padapter, (int )PLH);
#line 3218
  if ((unsigned int )CurrentEntryNum == 255U) {
#line 3219
    if (BTCoexDbgLevel == 1U) {
#line 3219
      printk("DisconnectPhysicalLink, No such Handle in the Entry\n");
    } else {

    }
#line 3221
    status = 2;
  } else {
#line 3223
    pBTInfo->BtAsocEntry[(int )CurrentEntryNum].PhyLinkDisconnectReason = (enum hci_status )PhysLinkDisconnectReason;
  }
#line 3227
  bthci_EventCommandStatus(padapter, 1, 55, status);
#line 3230
  if ((unsigned int )status != 0U) {
#line 3231
    return (status);
  } else {

  }
#line 3234
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentEntryNum].BtCurrentState == 32U) {
#line 3235
    if (BTCoexDbgLevel == 1U) {
#line 3235
      printk("[BT state change] caused by %s, line =%d\n", "bthci_CmdDisconnectPhysicalLink",
             3235);
    } else {

    }
#line 3235
    BTHCI_StateMachine(padapter, 32, 2, (int )CurrentEntryNum);
  } else {
#line 3237
    if (BTCoexDbgLevel == 1U) {
#line 3237
      printk("[BT state change] caused by %s, line =%d\n", "bthci_CmdDisconnectPhysicalLink",
             3237);
    } else {

    }
#line 3237
    BTHCI_StateMachine(padapter, 16, 2, (int )CurrentEntryNum);
  }
#line 3239
  return (status);
}
}
#line 3243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdSetACLLinkDataFlowMode(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 3246
  status = 0;
#line 3247
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3248
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3249
  localBuf[0] = '\000';
#line 3249
  tmp = 1U;
#line 3249
  while (1) {
#line 3249
    if (tmp >= 8U) {
#line 3249
      break;
    } else {

    }
#line 3249
    localBuf[tmp] = (unsigned char)0;
#line 3249
    tmp = tmp + 1U;
  }
#line 3251
  len = 0U;
#line 3255
  pBtMgnt->ExtConfig.CurrentConnectHandle = *((u16 *)(& pHciCmd->Data));
#line 3256
  pBtMgnt->ExtConfig.CurrentIncomingTrafficMode = (unsigned int )*((u8 *)(& pHciCmd->Data)) + 2U;
#line 3257
  pBtMgnt->ExtConfig.CurrentOutgoingTrafficMode = (unsigned int )*((u8 *)(& pHciCmd->Data)) + 3U;
#line 3258
  if (BTCoexDbgLevel == 1U) {
#line 3258
    printk("Connection Handle = 0x%x, Incoming Traffic mode = 0x%x, Outgoing Traffic mode = 0x%x",
           (int )pBtMgnt->ExtConfig.CurrentConnectHandle, (int )pBtMgnt->ExtConfig.CurrentIncomingTrafficMode,
           (int )pBtMgnt->ExtConfig.CurrentOutgoingTrafficMode);
  } else {

  }
#line 3264
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3266
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 16, status);
#line 3266
  len = (int )tmp___0 + (int )len;
#line 3272
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3273
  *pRetPar = (u8 )status;
#line 3275
  pu2Temp = (u16 *)pRetPar + 1U;
#line 3276
  *pu2Temp = pBtMgnt->ExtConfig.CurrentConnectHandle;
#line 3277
  len = (unsigned int )len + 3U;
#line 3278
  PPacketIrpEvent->Length = len;
#line 3280
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3281
  return (status);
}
}
#line 3285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdSetACLLinkStatus(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 i ;
  u8 *pTriple ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3288
  status = 0;
#line 3289
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3290
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3291
  pBtDbg = & pBTInfo->BtDbg;
#line 3295
  pBtDbg->dbgHciInfo.hciCmdCntSetAclLinkStatus = pBtDbg->dbgHciInfo.hciCmdCntSetAclLinkStatus + 1U;
#line 3296
  if (BTCoexDbgLevel == 1U) {
#line 3296
    ptr = (u8 *)(& pHciCmd->Data);
#line 3296
    printk("SetACLLinkStatus, Hex Data :\n");
#line 3296
    __i = 0U;
#line 3296
    goto ldv_56784;
    ldv_56783: 
#line 3296
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 3296
    if (((__i + 1U) & 15U) == 0U) {
#line 3296
      printk("\n");
    } else {

    }
#line 3296
    __i = __i + 1U;
    ldv_56784: ;
#line 3296
    if ((u32 )pHciCmd->Length > __i) {
#line 3298
      goto ldv_56783;
    } else {

    }
#line 3296
    printk("\n");
  } else {

  }
#line 3300
  pBtMgnt->bSupportProfile = 1U;
#line 3302
  pBtMgnt->ExtConfig.NumberOfHandle = *((u8 *)(& pHciCmd->Data));
#line 3303
  if (BTCoexDbgLevel == 1U) {
#line 3303
    printk("NumberOfHandle = 0x%x\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
  } else {

  }
#line 3305
  pTriple = (u8 *)(& pHciCmd->Data) + 1UL;
#line 3306
  i = 0U;
#line 3306
  goto ldv_56787;
  ldv_56786: 
#line 3307
  pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = *((u16 *)pTriple);
#line 3308
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = *(pTriple + 2UL);
#line 3309
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = *(pTriple + 3UL);
#line 3310
  if (BTCoexDbgLevel == 1U) {
#line 3310
    printk("Connection_Handle = 0x%x, Incoming Traffic mode = 0x%x, Outgoing Traffic Mode = 0x%x\n",
           (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode,
           (int )pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode);
  } else {

  }
#line 3315
  pTriple = pTriple + 4UL;
#line 3306
  i = (u8 )((int )i + 1);
  ldv_56787: ;
#line 3306
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
#line 3308
    goto ldv_56786;
  } else {

  }
#line 3319
  localBuf[0] = '\000';
#line 3319
  tmp = 1U;
#line 3319
  while (1) {
#line 3319
    if (tmp >= 6U) {
#line 3319
      break;
    } else {

    }
#line 3319
    localBuf[tmp] = (unsigned char)0;
#line 3319
    tmp = tmp + 1U;
  }
#line 3321
  len = 0U;
#line 3324
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3326
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 32, status);
#line 3326
  len = (int )tmp___0 + (int )len;
#line 3332
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3333
  *pRetPar = (u8 )status;
#line 3335
  len = (unsigned int )len + 1U;
#line 3336
  PPacketIrpEvent->Length = len;
#line 3338
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3341
  return (status);
}
}
#line 3345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdSetSCOLinkStatus(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3350
  status = 0;
#line 3351
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3352
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3353
  pBtDbg = & pBTInfo->BtDbg;
#line 3355
  pBtDbg->dbgHciInfo.hciCmdCntSetScoLinkStatus = pBtDbg->dbgHciInfo.hciCmdCntSetScoLinkStatus + 1U;
#line 3356
  pBtMgnt->ExtConfig.NumberOfSCO = *((u8 *)(& pHciCmd->Data));
#line 3357
  if (BTCoexDbgLevel == 1U) {
#line 3357
    printk("NumberOfSCO = 0x%x\n", (int )pBtMgnt->ExtConfig.NumberOfSCO);
  } else {

  }
#line 3361
  localBuf[0] = '\000';
#line 3361
  tmp = 1U;
#line 3361
  while (1) {
#line 3361
    if (tmp >= 6U) {
#line 3361
      break;
    } else {

    }
#line 3361
    localBuf[tmp] = (unsigned char)0;
#line 3361
    tmp = tmp + 1U;
  }
#line 3363
  len = 0U;
#line 3366
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3368
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 48, status);
#line 3368
  len = (int )tmp___0 + (int )len;
#line 3374
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3375
  *pRetPar = (u8 )status;
#line 3377
  len = (unsigned int )len + 1U;
#line 3378
  PPacketIrpEvent->Length = len;
#line 3380
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3383
  return (status);
}
}
#line 3387 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdSetRSSIValue(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  s8 min_bt_rssi ;
  u8 i ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3392
  status = 0;
#line 3393
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3394
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3395
  min_bt_rssi = 0;
#line 3397
  i = 0U;
#line 3397
  goto ldv_56815;
  ldv_56814: ;
#line 3398
  if ((int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle == (int )*((u16 *)(& pHciCmd->Data))) {
#line 3399
    pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI = (signed char )pHciCmd->Data[2];
#line 3400
    if (BTCoexDbgLevel == 1U) {
#line 3400
      printk("Connection_Handle = 0x%x, RSSI = %d \n", (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle,
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI);
    } else {

    }
  } else {

  }
#line 3406
  if ((int )pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI <= (int )min_bt_rssi) {
#line 3407
    min_bt_rssi = pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI;
  } else {

  }
#line 3397
  i = (u8 )((int )i + 1);
  ldv_56815: ;
#line 3397
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
#line 3399
    goto ldv_56814;
  } else {

  }
#line 3410
  pBtMgnt->ExtConfig.MIN_BT_RSSI = min_bt_rssi;
#line 3411
  if (BTCoexDbgLevel == 1U) {
#line 3411
    printk("[bt rssi], the min rssi is %d\n", (int )min_bt_rssi);
  } else {

  }
#line 3414
  localBuf[0] = '\000';
#line 3414
  tmp = 1U;
#line 3414
  while (1) {
#line 3414
    if (tmp >= 6U) {
#line 3414
      break;
    } else {

    }
#line 3414
    localBuf[tmp] = (unsigned char)0;
#line 3414
    tmp = tmp + 1U;
  }
#line 3416
  len = 0U;
#line 3419
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3421
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 64, status);
#line 3421
  len = (int )tmp___0 + (int )len;
#line 3427
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3428
  *pRetPar = (u8 )status;
#line 3430
  len = (unsigned int )len + 1U;
#line 3431
  PPacketIrpEvent->Length = len;
#line 3433
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3436
  return (status);
}
}
#line 3440 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdSetCurrentBluetoothStatus(struct rtw_adapter *padapter ,
                                                          struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3445
  status = 0;
#line 3447
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3448
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3450
  pBtMgnt->ExtConfig.CurrentBTStatus = *((u8 *)(& pHciCmd->Data));
#line 3451
  if (BTCoexDbgLevel == 1U) {
#line 3451
    printk("SetCurrentBluetoothStatus, CurrentBTStatus = 0x%x\n", (int )pBtMgnt->ExtConfig.CurrentBTStatus);
  } else {

  }
#line 3455
  localBuf[0] = '\000';
#line 3455
  tmp = 1U;
#line 3455
  while (1) {
#line 3455
    if (tmp >= 6U) {
#line 3455
      break;
    } else {

    }
#line 3455
    localBuf[tmp] = (unsigned char)0;
#line 3455
    tmp = tmp + 1U;
  }
#line 3457
  len = 0U;
#line 3460
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3462
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 65, status);
#line 3462
  len = (int )tmp___0 + (int )len;
#line 3468
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3469
  *pRetPar = (u8 )status;
#line 3470
  len = (unsigned int )len + 1U;
#line 3472
  PPacketIrpEvent->Length = len;
#line 3474
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3477
  return (status);
}
}
#line 3481 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdExtensionVersionNotify(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3486
  status = 0;
#line 3487
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3488
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3489
  pBtDbg = & pBTInfo->BtDbg;
#line 3491
  pBtDbg->dbgHciInfo.hciCmdCntExtensionVersionNotify = pBtDbg->dbgHciInfo.hciCmdCntExtensionVersionNotify + 1U;
#line 3492
  if (BTCoexDbgLevel == 1U) {
#line 3492
    ptr = (u8 *)(& pHciCmd->Data);
#line 3492
    printk("ExtensionVersionNotify, Hex Data :\n");
#line 3492
    __i = 0U;
#line 3492
    goto ldv_56843;
    ldv_56842: 
#line 3492
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 3492
    if (((__i + 1U) & 15U) == 0U) {
#line 3492
      printk("\n");
    } else {

    }
#line 3492
    __i = __i + 1U;
    ldv_56843: ;
#line 3492
    if ((u32 )pHciCmd->Length > __i) {
#line 3494
      goto ldv_56842;
    } else {

    }
#line 3492
    printk("\n");
  } else {

  }
#line 3495
  pBtMgnt->ExtConfig.HCIExtensionVer = *((u16 *)(& pHciCmd->Data));
#line 3496
  if (BTCoexDbgLevel == 1U) {
#line 3496
    printk("HCIExtensionVer = 0x%x\n", (int )pBtMgnt->ExtConfig.HCIExtensionVer);
  } else {

  }
#line 3499
  localBuf[0] = '\000';
#line 3499
  tmp = 1U;
#line 3499
  while (1) {
#line 3499
    if (tmp >= 6U) {
#line 3499
      break;
    } else {

    }
#line 3499
    localBuf[tmp] = (unsigned char)0;
#line 3499
    tmp = tmp + 1U;
  }
#line 3501
  len = 0U;
#line 3504
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3506
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 256, status);
#line 3506
  len = (int )tmp___0 + (int )len;
#line 3512
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3513
  *pRetPar = (u8 )status;
#line 3515
  len = (unsigned int )len + 1U;
#line 3516
  PPacketIrpEvent->Length = len;
#line 3518
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3521
  return (status);
}
}
#line 3525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdLinkStatusNotify(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 i ;
  u8 *pTriple ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3530
  status = 0;
#line 3531
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3532
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3533
  pBtDbg = & pBTInfo->BtDbg;
#line 3537
  pBtDbg->dbgHciInfo.hciCmdCntLinkStatusNotify = pBtDbg->dbgHciInfo.hciCmdCntLinkStatusNotify + 1U;
#line 3538
  if (BTCoexDbgLevel == 1U) {
#line 3538
    ptr = (u8 *)(& pHciCmd->Data);
#line 3538
    printk("LinkStatusNotify, Hex Data :\n");
#line 3538
    __i = 0U;
#line 3538
    goto ldv_56862;
    ldv_56861: 
#line 3538
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 3538
    if (((__i + 1U) & 15U) == 0U) {
#line 3538
      printk("\n");
    } else {

    }
#line 3538
    __i = __i + 1U;
    ldv_56862: ;
#line 3538
    if ((u32 )pHciCmd->Length > __i) {
#line 3540
      goto ldv_56861;
    } else {

    }
#line 3538
    printk("\n");
  } else {

  }
#line 3542
  pBtMgnt->bSupportProfile = 1U;
#line 3544
  pBtMgnt->ExtConfig.NumberOfHandle = *((u8 *)(& pHciCmd->Data));
#line 3545
  if (BTCoexDbgLevel == 1U) {
#line 3545
    printk("NumberOfHandle = 0x%x\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
  } else {

  }
#line 3546
  if (BTCoexDbgLevel == 1U) {
#line 3546
    printk("HCIExtensionVer = %d\n", (int )pBtMgnt->ExtConfig.HCIExtensionVer);
  } else {

  }
#line 3548
  pTriple = (u8 *)(& pHciCmd->Data) + 1UL;
#line 3549
  i = 0U;
#line 3549
  goto ldv_56865;
  ldv_56864: ;
#line 3550
  if ((unsigned int )pBtMgnt->ExtConfig.HCIExtensionVer == 0U) {
#line 3551
    pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = *((u16 *)pTriple);
#line 3552
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile = *(pTriple + 2UL);
#line 3553
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec = *(pTriple + 3UL);
#line 3554
    if (BTCoexDbgLevel == 1U) {
#line 3554
      printk("Connection_Handle = 0x%x, BTProfile =%d, BTSpec =%d\n", (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle,
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec);
    } else {

    }
#line 3559
    pTriple = pTriple + 4UL;
  } else
#line 3560
  if ((unsigned int )pBtMgnt->ExtConfig.HCIExtensionVer != 0U) {
#line 3561
    pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = *((u16 *)pTriple);
#line 3562
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile = *(pTriple + 2UL);
#line 3563
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec = *(pTriple + 3UL);
#line 3564
    pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole = *(pTriple + 4UL);
#line 3565
    if (BTCoexDbgLevel == 1U) {
#line 3565
      printk("Connection_Handle = 0x%x, BTProfile =%d, BTSpec =%d, LinkRole =%d\n",
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile,
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole);
    } else {

    }
#line 3571
    pTriple = pTriple + 5UL;
  } else {

  }
#line 3549
  i = (u8 )((int )i + 1);
  ldv_56865: ;
#line 3549
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
#line 3551
    goto ldv_56864;
  } else {

  }
#line 3575
  BTHCI_UpdateBTProfileRTKToMoto(padapter);
#line 3577
  localBuf[0] = '\000';
#line 3577
  tmp = 1U;
#line 3577
  while (1) {
#line 3577
    if (tmp >= 6U) {
#line 3577
      break;
    } else {

    }
#line 3577
    localBuf[tmp] = (unsigned char)0;
#line 3577
    tmp = tmp + 1U;
  }
#line 3579
  len = 0U;
#line 3582
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3584
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 257, status);
#line 3584
  len = (int )tmp___0 + (int )len;
#line 3590
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3591
  *pRetPar = (u8 )status;
#line 3593
  len = (unsigned int )len + 1U;
#line 3594
  PPacketIrpEvent->Length = len;
#line 3596
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3599
  return (status);
}
}
#line 3603 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdBtOperationNotify(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3608
  status = 0;
#line 3609
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3610
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3612
  if (BTCoexDbgLevel == 1U) {
#line 3612
    ptr = (u8 *)(& pHciCmd->Data);
#line 3612
    printk("Bt Operation notify, Hex Data :\n");
#line 3612
    __i = 0U;
#line 3612
    goto ldv_56881;
    ldv_56880: 
#line 3612
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 3612
    if (((__i + 1U) & 15U) == 0U) {
#line 3612
      printk("\n");
    } else {

    }
#line 3612
    __i = __i + 1U;
    ldv_56881: ;
#line 3612
    if ((u32 )pHciCmd->Length > __i) {
#line 3614
      goto ldv_56880;
    } else {

    }
#line 3612
    printk("\n");
  } else {

  }
#line 3615
  pBtMgnt->ExtConfig.btOperationCode = *((u8 *)(& pHciCmd->Data));
#line 3616
  if (BTCoexDbgLevel == 1U) {
#line 3616
    printk("btOperationCode = 0x%x\n", (int )pBtMgnt->ExtConfig.btOperationCode);
  } else {

  }
#line 3617
  switch ((int )pBtMgnt->ExtConfig.btOperationCode) {
  case 0: ;
#line 3619
  if (BTCoexDbgLevel == 1U) {
#line 3619
    printk("[bt operation] : Operation None!!\n");
  } else {

  }
#line 3620
  goto ldv_56884;
  case 1: ;
#line 3622
  if (BTCoexDbgLevel == 1U) {
#line 3622
    printk("[bt operation] : Inquire start!!\n");
  } else {

  }
#line 3623
  goto ldv_56884;
  case 2: ;
#line 3625
  if (BTCoexDbgLevel == 1U) {
#line 3625
    printk("[bt operation] : Inquire finished!!\n");
  } else {

  }
#line 3626
  goto ldv_56884;
  case 3: ;
#line 3628
  if (BTCoexDbgLevel == 1U) {
#line 3628
    printk("[bt operation] : Paging is started!!\n");
  } else {

  }
#line 3629
  goto ldv_56884;
  case 4: ;
#line 3631
  if (BTCoexDbgLevel == 1U) {
#line 3631
    printk("[bt operation] : Paging complete successfully!!\n");
  } else {

  }
#line 3632
  goto ldv_56884;
  case 5: ;
#line 3634
  if (BTCoexDbgLevel == 1U) {
#line 3634
    printk("[bt operation] : Paging complete unsuccessfully!!\n");
  } else {

  }
#line 3635
  goto ldv_56884;
  case 6: ;
#line 3637
  if (BTCoexDbgLevel == 1U) {
#line 3637
    printk("[bt operation] : Pairing start!!\n");
  } else {

  }
#line 3638
  goto ldv_56884;
  case 7: ;
#line 3640
  if (BTCoexDbgLevel == 1U) {
#line 3640
    printk("[bt operation] : Pairing finished!!\n");
  } else {

  }
#line 3641
  goto ldv_56884;
  case 8: ;
#line 3643
  if (BTCoexDbgLevel == 1U) {
#line 3643
    printk("[bt operation] : BT Device is enabled!!\n");
  } else {

  }
#line 3644
  goto ldv_56884;
  case 9: ;
#line 3646
  if (BTCoexDbgLevel == 1U) {
#line 3646
    printk("[bt operation] : BT Device is disabled!!\n");
  } else {

  }
#line 3647
  goto ldv_56884;
  default: ;
#line 3649
  if (BTCoexDbgLevel == 1U) {
#line 3649
    printk("[bt operation] : Unknown, error!!\n");
  } else {

  }
#line 3650
  goto ldv_56884;
  }
  ldv_56884: 
#line 3652
  BTDM_AdjustForBtOperation(padapter);
#line 3654
  localBuf[0] = '\000';
#line 3654
  tmp = 1U;
#line 3654
  while (1) {
#line 3654
    if (tmp >= 6U) {
#line 3654
      break;
    } else {

    }
#line 3654
    localBuf[tmp] = (unsigned char)0;
#line 3654
    tmp = tmp + 1U;
  }
#line 3656
  len = 0U;
#line 3659
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3661
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 258, status);
#line 3661
  len = (int )tmp___0 + (int )len;
#line 3667
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3668
  *pRetPar = (u8 )status;
#line 3670
  len = (unsigned int )len + 1U;
#line 3671
  PPacketIrpEvent->Length = len;
#line 3673
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3676
  return (status);
}
}
#line 3680 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdEnableWifiScanNotify(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3683
  status = 0;
#line 3684
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3685
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3687
  if (BTCoexDbgLevel == 1U) {
#line 3687
    ptr = (u8 *)(& pHciCmd->Data);
#line 3687
    printk("Enable Wifi scan notify, Hex Data :\n");
#line 3687
    __i = 0U;
#line 3687
    goto ldv_56909;
    ldv_56908: 
#line 3687
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 3687
    if (((__i + 1U) & 15U) == 0U) {
#line 3687
      printk("\n");
    } else {

    }
#line 3687
    __i = __i + 1U;
    ldv_56909: ;
#line 3687
    if ((u32 )pHciCmd->Length > __i) {
#line 3689
      goto ldv_56908;
    } else {

    }
#line 3687
    printk("\n");
  } else {

  }
#line 3690
  pBtMgnt->ExtConfig.bEnableWifiScanNotify = *((u8 *)(& pHciCmd->Data));
#line 3691
  if (BTCoexDbgLevel == 1U) {
#line 3691
    printk("bEnableWifiScanNotify = %d\n", (int )pBtMgnt->ExtConfig.bEnableWifiScanNotify);
  } else {

  }
#line 3694
  localBuf[0] = '\000';
#line 3694
  tmp = 1U;
#line 3694
  while (1) {
#line 3694
    if (tmp >= 6U) {
#line 3694
      break;
    } else {

    }
#line 3694
    localBuf[tmp] = (unsigned char)0;
#line 3694
    tmp = tmp + 1U;
  }
#line 3696
  len = 0U;
#line 3699
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3701
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 259, status);
#line 3701
  len = (int )tmp___0 + (int )len;
#line 3707
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3708
  *pRetPar = (u8 )status;
#line 3710
  len = (unsigned int )len + 1U;
#line 3711
  PPacketIrpEvent->Length = len;
#line 3713
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3716
  return (status);
}
}
#line 3720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdWIFICurrentChannel(struct rtw_adapter *padapter ,
                                                   struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct mlme_ext_priv *pmlmeext ;
  u8 chnl ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3723
  status = 0;
#line 3724
  pmlmeext = & padapter->mlmeextpriv;
#line 3725
  chnl = pmlmeext->cur_channel;
#line 3727
  if ((unsigned int )pmlmeext->cur_bwmode == 1U) {
#line 3728
    if ((unsigned int )pmlmeext->cur_ch_offset == 2U) {
#line 3729
      chnl = (unsigned int )chnl + 2U;
    } else
#line 3730
    if ((unsigned int )pmlmeext->cur_ch_offset == 1U) {
#line 3731
      chnl = (unsigned int )chnl + 254U;
    } else {

    }
  } else {

  }
#line 3734
  if (BTCoexDbgLevel == 1U) {
#line 3734
    printk("Current Channel  = 0x%x\n", (int )chnl);
  } else {

  }
#line 3737
  localBuf[0] = '\000';
#line 3737
  tmp = 1U;
#line 3737
  while (1) {
#line 3737
    if (tmp >= 8U) {
#line 3737
      break;
    } else {

    }
#line 3737
    localBuf[tmp] = (unsigned char)0;
#line 3737
    tmp = tmp + 1U;
  }
#line 3739
  len = 0U;
#line 3742
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3744
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 768, status);
#line 3744
  len = (int )tmp___0 + (int )len;
#line 3750
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3751
  *pRetPar = (u8 )status;
#line 3752
  *(pRetPar + 1UL) = chnl;
#line 3753
  len = (unsigned int )len + 2U;
#line 3754
  PPacketIrpEvent->Length = len;
#line 3756
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3759
  return (status);
}
}
#line 3763 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdWIFICurrentBandwidth(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  enum ht_channel_width bw ;
  u8 CurrentBW ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3766
  status = 0;
#line 3768
  CurrentBW = 0U;
#line 3770
  bw = (enum ht_channel_width )padapter->mlmeextpriv.cur_bwmode;
#line 3772
  if ((unsigned int )bw == 0U) {
#line 3773
    CurrentBW = 0U;
  } else
#line 3774
  if ((unsigned int )bw == 1U) {
#line 3775
    CurrentBW = 1U;
  } else {

  }
#line 3777
  if (BTCoexDbgLevel == 1U) {
#line 3777
    printk("Current BW = 0x%x\n", (int )CurrentBW);
  } else {

  }
#line 3781
  localBuf[0] = '\000';
#line 3781
  tmp = 1U;
#line 3781
  while (1) {
#line 3781
    if (tmp >= 8U) {
#line 3781
      break;
    } else {

    }
#line 3781
    localBuf[tmp] = (unsigned char)0;
#line 3781
    tmp = tmp + 1U;
  }
#line 3783
  len = 0U;
#line 3786
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3788
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 769, status);
#line 3788
  len = (int )tmp___0 + (int )len;
#line 3794
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3795
  *pRetPar = (u8 )status;
#line 3796
  *(pRetPar + 1UL) = CurrentBW;
#line 3797
  len = (unsigned int )len + 2U;
#line 3798
  PPacketIrpEvent->Length = len;
#line 3800
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3803
  return (status);
}
}
#line 3807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdWIFIConnectionStatus(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  u8 connectStatus ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  u8 localBuf[8U] ;
  unsigned int tmp___2 ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___3 ;

  {
#line 3812
  status = 0;
#line 3813
  connectStatus = 0U;
#line 3815
  tmp___1 = check_fwstate(& padapter->mlmepriv, 16);
#line 3815
  if ((int )tmp___1) {
#line 3816
    if (padapter->stapriv.asoc_sta_count > 2) {
#line 3817
      connectStatus = 1U;
    } else {
#line 3819
      connectStatus = 0U;
    }
  } else {
#line 3820
    tmp___0 = check_fwstate(& padapter->mlmepriv, 97);
#line 3820
    if ((int )tmp___0) {
#line 3821
      connectStatus = 1U;
    } else {
#line 3822
      tmp = check_fwstate(& padapter->mlmepriv, 128);
#line 3822
      if ((int )tmp) {
#line 3823
        connectStatus = 2U;
      } else {
#line 3825
        connectStatus = 0U;
      }
    }
  }
#line 3829
  localBuf[0] = '\000';
#line 3829
  tmp___2 = 1U;
#line 3829
  while (1) {
#line 3829
    if (tmp___2 >= 8U) {
#line 3829
      break;
    } else {

    }
#line 3829
    localBuf[tmp___2] = (unsigned char)0;
#line 3829
    tmp___2 = tmp___2 + 1U;
  }
#line 3831
  len = 0U;
#line 3834
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3836
  tmp___3 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 770, status);
#line 3836
  len = (int )tmp___3 + (int )len;
#line 3842
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3843
  *pRetPar = (u8 )status;
#line 3844
  *(pRetPar + 1UL) = connectStatus;
#line 3845
  len = (unsigned int )len + 2U;
#line 3846
  PPacketIrpEvent->Length = len;
#line 3848
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3851
  return (status);
}
}
#line 3855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdEnableDeviceUnderTestMode(struct rtw_adapter *padapter ,
                                                          struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3860
  status = 0;
#line 3861
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3862
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 3864
  pBtHciInfo->bInTestMode = 1U;
#line 3865
  pBtHciInfo->bTestIsEnd = 0U;
#line 3869
  localBuf[0] = '\000';
#line 3869
  tmp = 1U;
#line 3869
  while (1) {
#line 3869
    if (tmp >= 6U) {
#line 3869
      break;
    } else {

    }
#line 3869
    localBuf[tmp] = (unsigned char)0;
#line 3869
    tmp = tmp + 1U;
  }
#line 3871
  len = 0U;
#line 3874
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3876
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 6, 3, status);
#line 3876
  len = (int )tmp___0 + (int )len;
#line 3882
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3883
  *pRetPar = (u8 )status;
#line 3884
  len = (unsigned int )len + 1U;
#line 3885
  PPacketIrpEvent->Length = len;
#line 3887
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3890
  return (status);
}
}
#line 3894 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdAMPTestEnd(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 3897
  status = 0;
#line 3898
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3899
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 3901
  if ((unsigned int )pBtHciInfo->bInTestMode == 0U) {
#line 3902
    if (BTCoexDbgLevel == 1U) {
#line 3902
      printk("Not in Test mode, return status = HCI_STATUS_CMD_DISALLOW\n");
    } else {

    }
#line 3903
    status = 12;
#line 3904
    return (status);
  } else {

  }
#line 3907
  pBtHciInfo->bTestIsEnd = 1U;
#line 3909
  ldv_del_timer_sync_774(& pBTInfo->BTTestSendPacketTimer);
#line 3911
  rtl8723a_check_bssid(padapter, 1);
#line 3915
  localBuf[0] = '\000';
#line 3915
  tmp = 1U;
#line 3915
  while (1) {
#line 3915
    if (tmp >= 4U) {
#line 3915
      break;
    } else {

    }
#line 3915
    localBuf[tmp] = (unsigned char)0;
#line 3915
    tmp = tmp + 1U;
  }
#line 3918
  if (BTCoexDbgLevel == 1U) {
#line 3918
    printk("AMP Test End Event \n");
  } else {

  }
#line 3919
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3920
  PPacketIrpEvent->EventCode = 74U;
#line 3921
  PPacketIrpEvent->Length = 2U;
#line 3923
  PPacketIrpEvent->Data[0] = (u8 )status;
#line 3924
  PPacketIrpEvent->Data[1] = pBtHciInfo->TestScenario;
#line 3926
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
#line 3929
  bthci_EventAMPReceiverReport(padapter, 1);
#line 3931
  return (status);
}
}
#line 3935 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdAMPTestCommand(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 localBuf___0[5U] ;
  unsigned int tmp___0 ;
  struct packet_irp_hcievent_data *PPacketIrpEvent___0 ;
  unsigned long tmp___1 ;

  {
#line 3938
  status = 0;
#line 3939
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3940
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 3942
  if ((unsigned int )pBtHciInfo->bInTestMode == 0U) {
#line 3943
    if (BTCoexDbgLevel == 1U) {
#line 3943
      printk("Not in Test mode, return status = HCI_STATUS_CMD_DISALLOW\n");
    } else {

    }
#line 3944
    status = 12;
#line 3945
    return (status);
  } else {

  }
#line 3948
  pBtHciInfo->TestScenario = *((u8 *)(& pHciCmd->Data));
#line 3950
  if ((unsigned int )pBtHciInfo->TestScenario == 1U) {
#line 3951
    if (BTCoexDbgLevel == 1U) {
#line 3951
      printk("TX Single Test \n");
    } else {

    }
  } else
#line 3952
  if ((unsigned int )pBtHciInfo->TestScenario == 2U) {
#line 3953
    if (BTCoexDbgLevel == 1U) {
#line 3953
      printk("Receive Frame Test \n");
    } else {

    }
  } else
#line 3955
  if (BTCoexDbgLevel == 1U) {
#line 3955
    printk("No Such Test !!!!!!!!!!!!!!!!!! \n");
  } else {

  }
#line 3957
  if ((unsigned int )pBtHciInfo->bTestIsEnd != 0U) {
#line 3958
    localBuf[0] = '\000';
#line 3958
    tmp = 1U;
#line 3958
    while (1) {
#line 3958
      if (tmp >= 5U) {
#line 3958
        break;
      } else {

      }
#line 3958
      localBuf[tmp] = (unsigned char)0;
#line 3958
      tmp = tmp + 1U;
    }
#line 3961
    if (BTCoexDbgLevel == 1U) {
#line 3961
      printk("AMP Test End Event \n");
    } else {

    }
#line 3962
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3963
    PPacketIrpEvent->EventCode = 74U;
#line 3964
    PPacketIrpEvent->Length = 2U;
#line 3966
    PPacketIrpEvent->Data[0] = (u8 )status;
#line 3967
    PPacketIrpEvent->Data[1] = pBtHciInfo->TestScenario;
#line 3969
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
#line 3973
    return (status);
  } else {

  }
#line 3977
  bthci_EventCommandStatus(padapter, 6, 9, status);
#line 3987
  localBuf___0[0] = '\000';
#line 3987
  tmp___0 = 1U;
#line 3987
  while (1) {
#line 3987
    if (tmp___0 >= 5U) {
#line 3987
      break;
    } else {

    }
#line 3987
    localBuf___0[tmp___0] = (unsigned char)0;
#line 3987
    tmp___0 = tmp___0 + 1U;
  }
#line 3990
  if (BTCoexDbgLevel == 1U) {
#line 3990
    printk(" HCI_AMP_Start Test Event \n");
  } else {

  }
#line 3991
  PPacketIrpEvent___0 = (struct packet_irp_hcievent_data *)(& localBuf___0);
#line 3992
  PPacketIrpEvent___0->EventCode = 73U;
#line 3993
  PPacketIrpEvent___0->Length = 2U;
#line 3995
  PPacketIrpEvent___0->Data[0] = (u8 )status;
#line 3996
  PPacketIrpEvent___0->Data[1] = pBtHciInfo->TestScenario;
#line 3998
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent___0, 4U);
#line 4003
  if ((unsigned int )pBtHciInfo->TestScenario == 1U) {
#line 4008
    tmp___1 = msecs_to_jiffies(50U);
#line 4008
    ldv_mod_timer_775(& pBTInfo->BTTestSendPacketTimer, tmp___1 + (unsigned long )jiffies);
#line 4010
    if (BTCoexDbgLevel == 1U) {
#line 4010
      printk("TX Single Test \n");
    } else {

    }
  } else
#line 4011
  if ((unsigned int )pBtHciInfo->TestScenario == 2U) {
#line 4012
    rtl8723a_check_bssid(padapter, 0);
#line 4013
    if (BTCoexDbgLevel == 1U) {
#line 4013
      printk("Receive Frame Test \n");
    } else {

    }
  } else {

  }
#line 4016
  return (status);
}
}
#line 4020 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdEnableAMPReceiverReports(struct rtw_adapter *padapter ,
                                                         struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  u8 localBuf___0[6U] ;
  unsigned int tmp___1 ;
  u8 *pRetPar___0 ;
  u8 len___0 ;
  struct packet_irp_hcievent_data *PPacketIrpEvent___0 ;
  u8 tmp___2 ;

  {
#line 4023
  status = 0;
#line 4024
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4025
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 4027
  if ((unsigned int )pBtHciInfo->bInTestMode == 0U) {
#line 4028
    status = 12;
#line 4031
    localBuf[0] = '\000';
#line 4031
    tmp = 1U;
#line 4031
    while (1) {
#line 4031
      if (tmp >= 6U) {
#line 4031
        break;
      } else {

      }
#line 4031
      localBuf[tmp] = (unsigned char)0;
#line 4031
      tmp = tmp + 1U;
    }
#line 4033
    len = 0U;
#line 4036
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 4038
    tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 6, 7, status);
#line 4038
    len = (int )tmp___0 + (int )len;
#line 4044
    pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 4045
    *pRetPar = (u8 )status;
#line 4046
    len = (unsigned int )len + 1U;
#line 4047
    PPacketIrpEvent->Length = len;
#line 4049
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 4051
    return (status);
  } else {

  }
#line 4054
  pBtHciInfo->bTestNeedReport = *((u8 *)(& pHciCmd->Data));
#line 4055
  pBtHciInfo->TestReportInterval = *((u8 *)(& pHciCmd->Data) + 2UL);
#line 4057
  bthci_EventAMPReceiverReport(padapter, 0);
#line 4061
  localBuf___0[0] = '\000';
#line 4061
  tmp___1 = 1U;
#line 4061
  while (1) {
#line 4061
    if (tmp___1 >= 6U) {
#line 4061
      break;
    } else {

    }
#line 4061
    localBuf___0[tmp___1] = (unsigned char)0;
#line 4061
    tmp___1 = tmp___1 + 1U;
  }
#line 4063
  len___0 = 0U;
#line 4066
  PPacketIrpEvent___0 = (struct packet_irp_hcievent_data *)(& localBuf___0);
#line 4068
  tmp___2 = bthci_CommandCompleteHeader((u8 *)(& localBuf___0), 6, 7, status);
#line 4068
  len___0 = (int )tmp___2 + (int )len___0;
#line 4074
  pRetPar___0 = (u8 *)(& PPacketIrpEvent___0->Data) + (unsigned long )len___0;
#line 4075
  *pRetPar___0 = (u8 )status;
#line 4076
  len___0 = (unsigned int )len___0 + 1U;
#line 4077
  PPacketIrpEvent___0->Length = len___0;
#line 4079
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent___0, (u32 )((int )len___0 + 2));
#line 4082
  return (status);
}
}
#line 4086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_CmdHostBufferSize(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  enum hci_status status ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  u8 tmp___0 ;

  {
#line 4089
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4090
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4092
  status = 0;
#line 4093
  localBuf[0] = '\000';
#line 4093
  tmp = 1U;
#line 4093
  while (1) {
#line 4093
    if (tmp >= 6U) {
#line 4093
      break;
    } else {

    }
#line 4093
    localBuf[tmp] = (unsigned char)0;
#line 4093
    tmp = tmp + 1U;
  }
#line 4095
  len = 0U;
#line 4097
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].ACLPacketsData.ACLDataPacketLen = *((u16 *)(& pHciCmd->Data));
#line 4098
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].SyncDataPacketLen = *((u8 *)(& pHciCmd->Data) + 2UL);
#line 4099
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].TotalNumACLDataPackets = *((u16 *)(& pHciCmd->Data) + 3U);
#line 4100
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].TotalSyncNumDataPackets = *((u16 *)(& pHciCmd->Data) + 5U);
#line 4103
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 4105
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 51, status);
#line 4105
  len = (int )tmp___0 + (int )len;
#line 4111
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 4112
  *pRetPar = (u8 )status;
#line 4113
  len = (unsigned int )len + 1U;
#line 4114
  PPacketIrpEvent->Length = len;
#line 4116
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 4118
  return (status);
}
}
#line 4122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_UnknownCMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
#line 4124
  status = 1;
#line 4125
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4126
  pBtDbg = & pBTInfo->BtDbg;
#line 4128
  pBtDbg->dbgHciInfo.hciCmdCntUnknown = pBtDbg->dbgHciInfo.hciCmdCntUnknown + 1U;
#line 4129
  bthci_EventCommandStatus(padapter, (int )pHciCmd->OGF, (int )pHciCmd->OCF, status);
#line 4134
  return (status);
}
}
#line 4138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_HandleOGFInformationalParameters(struct rtw_adapter *padapter ,
                                                              struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
#line 4141
  status = 0;
#line 4143
  switch ((int )pHciCmd->OCF) {
  case 1: ;
#line 4145
  if (BTCoexDbgLevel == 1U) {
#line 4145
    printk("HCI_READ_LOCAL_VERSION_INFORMATION\n");
  } else {

  }
#line 4146
  status = bthci_CmdReadLocalVersionInformation(padapter);
#line 4147
  goto ldv_57017;
  case 2: ;
#line 4149
  if (BTCoexDbgLevel == 1U) {
#line 4149
    printk("HCI_READ_LOCAL_SUPPORTED_COMMANDS\n");
  } else {

  }
#line 4150
  status = bthci_CmdReadLocalSupportedCommands(padapter);
#line 4151
  goto ldv_57017;
  case 3: ;
#line 4153
  if (BTCoexDbgLevel == 1U) {
#line 4153
    printk("HCI_READ_LOCAL_SUPPORTED_FEATURES\n");
  } else {

  }
#line 4154
  status = bthci_CmdReadLocalSupportedFeatures(padapter);
#line 4155
  goto ldv_57017;
  case 5: ;
#line 4157
  if (BTCoexDbgLevel == 1U) {
#line 4157
    printk("HCI_READ_BUFFER_SIZE\n");
  } else {

  }
#line 4158
  status = bthci_CmdReadBufferSize(padapter);
#line 4159
  goto ldv_57017;
  case 10: ;
#line 4161
  if (BTCoexDbgLevel == 1U) {
#line 4161
    printk("HCI_READ_DATA_BLOCK_SIZE\n");
  } else {

  }
#line 4162
  status = bthci_CmdReadDataBlockSize(padapter);
#line 4163
  goto ldv_57017;
  default: ;
#line 4165
  if (BTCoexDbgLevel == 1U) {
#line 4165
    printk("bthci_HandleOGFInformationalParameters(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {

  }
#line 4166
  if (BTCoexDbgLevel == 1U) {
#line 4166
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
#line 4167
  status = bthci_UnknownCMD(padapter, pHciCmd);
#line 4168
  goto ldv_57017;
  }
  ldv_57017: ;
#line 4170
  return (status);
}
}
#line 4174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_HandleOGFSetEventMaskCMD(struct rtw_adapter *padapter ,
                                                      struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
#line 4177
  status = 0;
#line 4179
  switch ((int )pHciCmd->OCF) {
  case 1: ;
#line 4181
  if (BTCoexDbgLevel == 1U) {
#line 4181
    printk("HCI_SET_EVENT_MASK\n");
  } else {

  }
#line 4182
  status = bthci_CmdSetEventMask(padapter, pHciCmd);
#line 4183
  goto ldv_57029;
  case 3: ;
#line 4185
  if (BTCoexDbgLevel == 1U) {
#line 4185
    printk("HCI_RESET\n");
  } else {

  }
#line 4186
  status = bthci_CmdReset(padapter, 1);
#line 4187
  goto ldv_57029;
  case 21: ;
#line 4189
  if (BTCoexDbgLevel == 1U) {
#line 4189
    printk("HCI_READ_CONNECTION_ACCEPT_TIMEOUT\n");
  } else {

  }
#line 4190
  status = bthci_CmdReadConnectionAcceptTimeout(padapter);
#line 4191
  goto ldv_57029;
  case 5: ;
#line 4193
  if (BTCoexDbgLevel == 1U) {
#line 4193
    printk("HCI_SET_EVENT_FILTER\n");
  } else {

  }
#line 4194
  goto ldv_57029;
  case 22: ;
#line 4196
  if (BTCoexDbgLevel == 1U) {
#line 4196
    printk("HCI_WRITE_CONNECTION_ACCEPT_TIMEOUT\n");
  } else {

  }
#line 4197
  status = bthci_CmdWriteConnectionAcceptTimeout(padapter, pHciCmd);
#line 4198
  goto ldv_57029;
  case 23: ;
#line 4200
  if (BTCoexDbgLevel == 1U) {
#line 4200
    printk("HCI_READ_PAGE_TIMEOUT\n");
  } else {

  }
#line 4201
  status = bthci_CmdReadPageTimeout(padapter, pHciCmd);
#line 4202
  goto ldv_57029;
  case 24: ;
#line 4204
  if (BTCoexDbgLevel == 1U) {
#line 4204
    printk("HCI_WRITE_PAGE_TIMEOUT\n");
  } else {

  }
#line 4205
  status = bthci_CmdWritePageTimeout(padapter, pHciCmd);
#line 4206
  goto ldv_57029;
  case 53: ;
#line 4208
  if (BTCoexDbgLevel == 1U) {
#line 4208
    printk("HCI_HOST_NUMBER_OF_COMPLETED_PACKETS\n");
  } else {

  }
#line 4209
  goto ldv_57029;
  case 54: ;
#line 4211
  if (BTCoexDbgLevel == 1U) {
#line 4211
    printk("HCI_READ_LINK_SUPERVISION_TIMEOUT\n");
  } else {

  }
#line 4212
  status = bthci_CmdReadLinkSupervisionTimeout(padapter, pHciCmd);
#line 4213
  goto ldv_57029;
  case 55: ;
#line 4215
  if (BTCoexDbgLevel == 1U) {
#line 4215
    printk("HCI_WRITE_LINK_SUPERVISION_TIMEOUT\n");
  } else {

  }
#line 4216
  status = bthci_CmdWriteLinkSupervisionTimeout(padapter, pHciCmd);
#line 4217
  goto ldv_57029;
  case 95: ;
#line 4219
  if (BTCoexDbgLevel == 1U) {
#line 4219
    printk("HCI_ENHANCED_FLUSH\n");
  } else {

  }
#line 4220
  status = bthci_CmdEnhancedFlush(padapter, pHciCmd);
#line 4221
  goto ldv_57029;
  case 97: ;
#line 4223
  if (BTCoexDbgLevel == 1U) {
#line 4223
    printk("HCI_READ_LOGICAL_LINK_ACCEPT_TIMEOUT\n");
  } else {

  }
#line 4224
  status = bthci_CmdReadLogicalLinkAcceptTimeout(padapter, pHciCmd);
#line 4225
  goto ldv_57029;
  case 98: ;
#line 4227
  if (BTCoexDbgLevel == 1U) {
#line 4227
    printk("HCI_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT\n");
  } else {

  }
#line 4228
  status = bthci_CmdWriteLogicalLinkAcceptTimeout(padapter, pHciCmd);
#line 4229
  goto ldv_57029;
  case 99: ;
#line 4231
  if (BTCoexDbgLevel == 1U) {
#line 4231
    printk("HCI_SET_EVENT_MASK_PAGE_2\n");
  } else {

  }
#line 4232
  status = bthci_CmdSetEventMaskPage2(padapter, pHciCmd);
#line 4233
  goto ldv_57029;
  case 100: ;
#line 4235
  if (BTCoexDbgLevel == 1U) {
#line 4235
    printk("HCI_READ_LOCATION_DATA\n");
  } else {

  }
#line 4236
  status = bthci_CmdReadLocationData(padapter, pHciCmd);
#line 4237
  goto ldv_57029;
  case 101: ;
#line 4239
  if (BTCoexDbgLevel == 1U) {
#line 4239
    printk("HCI_WRITE_LOCATION_DATA\n");
  } else {

  }
#line 4240
  status = bthci_CmdWriteLocationData(padapter, pHciCmd);
#line 4241
  goto ldv_57029;
  case 102: ;
#line 4243
  if (BTCoexDbgLevel == 1U) {
#line 4243
    printk("HCI_READ_FLOW_CONTROL_MODE\n");
  } else {

  }
#line 4244
  status = bthci_CmdReadFlowControlMode(padapter, pHciCmd);
#line 4245
  goto ldv_57029;
  case 103: ;
#line 4247
  if (BTCoexDbgLevel == 1U) {
#line 4247
    printk("HCI_WRITE_FLOW_CONTROL_MODE\n");
  } else {

  }
#line 4248
  status = bthci_CmdWriteFlowControlMode(padapter, pHciCmd);
#line 4249
  goto ldv_57029;
  case 105: ;
#line 4251
  if (BTCoexDbgLevel == 1U) {
#line 4251
    printk("HCI_READ_BEST_EFFORT_FLUSH_TIMEOUT\n");
  } else {

  }
#line 4252
  status = bthci_CmdReadBestEffortFlushTimeout(padapter, pHciCmd);
#line 4253
  goto ldv_57029;
  case 106: ;
#line 4255
  if (BTCoexDbgLevel == 1U) {
#line 4255
    printk("HCI_WRITE_BEST_EFFORT_FLUSH_TIMEOUT\n");
  } else {

  }
#line 4256
  status = bthci_CmdWriteBestEffortFlushTimeout(padapter, pHciCmd);
#line 4257
  goto ldv_57029;
  case 107: ;
#line 4259
  if (BTCoexDbgLevel == 1U) {
#line 4259
    printk("HCI_SHORT_RANGE_MODE\n");
  } else {

  }
#line 4260
  status = bthci_CmdShortRangeMode(padapter, pHciCmd);
#line 4261
  goto ldv_57029;
  case 51: ;
#line 4263
  if (BTCoexDbgLevel == 1U) {
#line 4263
    printk("HCI_HOST_BUFFER_SIZE\n");
  } else {

  }
#line 4264
  status = bthci_CmdHostBufferSize(padapter, pHciCmd);
#line 4265
  goto ldv_57029;
  default: ;
#line 4267
  if (BTCoexDbgLevel == 1U) {
#line 4267
    printk("bthci_HandleOGFSetEventMaskCMD(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {

  }
#line 4268
  if (BTCoexDbgLevel == 1U) {
#line 4268
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
#line 4269
  status = bthci_UnknownCMD(padapter, pHciCmd);
#line 4270
  goto ldv_57029;
  }
  ldv_57029: ;
#line 4272
  return (status);
}
}
#line 4276 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_HandleOGFStatusParameters(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
#line 4279
  status = 0;
#line 4281
  switch ((int )pHciCmd->OCF) {
  case 1: ;
#line 4283
  if (BTCoexDbgLevel == 1U) {
#line 4283
    printk("HCI_READ_FAILED_CONTACT_COUNTER\n");
  } else {

  }
#line 4284
  status = bthci_CmdReadFailedContactCounter(padapter, pHciCmd);
#line 4285
  goto ldv_57058;
  case 2: ;
#line 4287
  if (BTCoexDbgLevel == 1U) {
#line 4287
    printk("HCI_RESET_FAILED_CONTACT_COUNTER\n");
  } else {

  }
#line 4288
  status = bthci_CmdResetFailedContactCounter(padapter, pHciCmd);
#line 4289
  goto ldv_57058;
  case 3: ;
#line 4291
  if (BTCoexDbgLevel == 1U) {
#line 4291
    printk("HCI_READ_LINK_QUALITY\n");
  } else {

  }
#line 4292
  status = bthci_CmdReadLinkQuality(padapter, pHciCmd);
#line 4293
  goto ldv_57058;
  case 5: ;
#line 4295
  if (BTCoexDbgLevel == 1U) {
#line 4295
    printk("HCI_READ_RSSI\n");
  } else {

  }
#line 4296
  goto ldv_57058;
  case 9: ;
#line 4298
  if (BTCoexDbgLevel == 1U) {
#line 4298
    printk("HCI_READ_LOCAL_AMP_INFO\n");
  } else {

  }
#line 4299
  status = bthci_CmdReadLocalAMPInfo(padapter);
#line 4300
  goto ldv_57058;
  case 10: ;
#line 4302
  if (BTCoexDbgLevel == 1U) {
#line 4302
    printk("HCI_READ_LOCAL_AMP_ASSOC\n");
  } else {

  }
#line 4303
  status = bthci_CmdReadLocalAMPAssoc(padapter, pHciCmd);
#line 4304
  goto ldv_57058;
  case 11: ;
#line 4306
  if (BTCoexDbgLevel == 1U) {
#line 4306
    printk("HCI_WRITE_REMOTE_AMP_ASSOC\n");
  } else {

  }
#line 4307
  status = bthci_CmdWriteRemoteAMPAssoc(padapter, pHciCmd);
#line 4308
  goto ldv_57058;
  default: ;
#line 4310
  if (BTCoexDbgLevel == 1U) {
#line 4310
    printk("bthci_HandleOGFStatusParameters(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {

  }
#line 4311
  if (BTCoexDbgLevel == 1U) {
#line 4311
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
#line 4312
  status = bthci_UnknownCMD(padapter, pHciCmd);
#line 4313
  goto ldv_57058;
  }
  ldv_57058: ;
#line 4315
  return (status);
}
}
#line 4319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_HandleOGFLinkControlCMD(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
#line 4322
  status = 0;
#line 4324
  switch ((int )pHciCmd->OCF) {
  case 53: ;
#line 4326
  if (BTCoexDbgLevel == 1U) {
#line 4326
    printk("HCI_CREATE_PHYSICAL_LINK\n");
  } else {

  }
#line 4327
  status = bthci_CmdCreatePhysicalLink(padapter, pHciCmd);
#line 4328
  goto ldv_57072;
  case 54: ;
#line 4330
  if (BTCoexDbgLevel == 1U) {
#line 4330
    printk("HCI_ACCEPT_PHYSICAL_LINK\n");
  } else {

  }
#line 4331
  status = bthci_CmdAcceptPhysicalLink(padapter, pHciCmd);
#line 4332
  goto ldv_57072;
  case 55: ;
#line 4334
  if (BTCoexDbgLevel == 1U) {
#line 4334
    printk("HCI_DISCONNECT_PHYSICAL_LINK\n");
  } else {

  }
#line 4335
  status = bthci_CmdDisconnectPhysicalLink(padapter, pHciCmd);
#line 4336
  goto ldv_57072;
  case 56: ;
#line 4338
  if (BTCoexDbgLevel == 1U) {
#line 4338
    printk("HCI_CREATE_LOGICAL_LINK\n");
  } else {

  }
#line 4339
  status = bthci_CmdCreateLogicalLink(padapter, pHciCmd);
#line 4340
  goto ldv_57072;
  case 57: ;
#line 4342
  if (BTCoexDbgLevel == 1U) {
#line 4342
    printk("HCI_ACCEPT_LOGICAL_LINK\n");
  } else {

  }
#line 4343
  status = bthci_CmdAcceptLogicalLink(padapter, pHciCmd);
#line 4344
  goto ldv_57072;
  case 58: ;
#line 4346
  if (BTCoexDbgLevel == 1U) {
#line 4346
    printk("HCI_DISCONNECT_LOGICAL_LINK\n");
  } else {

  }
#line 4347
  status = bthci_CmdDisconnectLogicalLink(padapter, pHciCmd);
#line 4348
  goto ldv_57072;
  case 59: ;
#line 4350
  if (BTCoexDbgLevel == 1U) {
#line 4350
    printk("HCI_LOGICAL_LINK_CANCEL\n");
  } else {

  }
#line 4351
  status = bthci_CmdLogicalLinkCancel(padapter, pHciCmd);
#line 4352
  goto ldv_57072;
  case 60: ;
#line 4354
  if (BTCoexDbgLevel == 1U) {
#line 4354
    printk("HCI_FLOW_SPEC_MODIFY\n");
  } else {

  }
#line 4355
  status = bthci_CmdFlowSpecModify(padapter, pHciCmd);
#line 4356
  goto ldv_57072;
  default: ;
#line 4358
  if (BTCoexDbgLevel == 1U) {
#line 4358
    printk("bthci_HandleOGFLinkControlCMD(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {

  }
#line 4359
  if (BTCoexDbgLevel == 1U) {
#line 4359
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
#line 4360
  status = bthci_UnknownCMD(padapter, pHciCmd);
#line 4361
  goto ldv_57072;
  }
  ldv_57072: ;
#line 4363
  return (status);
}
}
#line 4367 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_HandleOGFTestingCMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
#line 4370
  status = 0;
#line 4371
  switch ((int )pHciCmd->OCF) {
  case 3: ;
#line 4373
  if (BTCoexDbgLevel == 1U) {
#line 4373
    printk("HCI_ENABLE_DEVICE_UNDER_TEST_MODE\n");
  } else {

  }
#line 4374
  bthci_CmdEnableDeviceUnderTestMode(padapter, pHciCmd);
#line 4375
  goto ldv_57087;
  case 8: ;
#line 4377
  if (BTCoexDbgLevel == 1U) {
#line 4377
    printk("HCI_AMP_TEST_END\n");
  } else {

  }
#line 4378
  bthci_CmdAMPTestEnd(padapter, pHciCmd);
#line 4379
  goto ldv_57087;
  case 9: ;
#line 4381
  if (BTCoexDbgLevel == 1U) {
#line 4381
    printk("HCI_AMP_TEST_COMMAND\n");
  } else {

  }
#line 4382
  bthci_CmdAMPTestCommand(padapter, pHciCmd);
#line 4383
  goto ldv_57087;
  case 7: ;
#line 4385
  if (BTCoexDbgLevel == 1U) {
#line 4385
    printk("HCI_ENABLE_AMP_RECEIVER_REPORTS\n");
  } else {

  }
#line 4386
  bthci_CmdEnableAMPReceiverReports(padapter, pHciCmd);
#line 4387
  goto ldv_57087;
  default: ;
#line 4389
  if (BTCoexDbgLevel == 1U) {
#line 4389
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
#line 4390
  status = bthci_UnknownCMD(padapter, pHciCmd);
#line 4391
  goto ldv_57087;
  }
  ldv_57087: ;
#line 4393
  return (status);
}
}
#line 4397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static enum hci_status bthci_HandleOGFExtension(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
#line 4400
  status = 0;
#line 4401
  switch ((int )pHciCmd->OCF) {
  case 16: ;
#line 4403
  if (BTCoexDbgLevel == 1U) {
#line 4403
    printk("HCI_SET_ACL_LINK_DATA_FLOW_MODE\n");
  } else {

  }
#line 4404
  status = bthci_CmdSetACLLinkDataFlowMode(padapter, pHciCmd);
#line 4405
  goto ldv_57098;
  case 32: ;
#line 4407
  if (BTCoexDbgLevel == 1U) {
#line 4407
    printk("HCI_SET_ACL_LINK_STATUS\n");
  } else {

  }
#line 4408
  status = bthci_CmdSetACLLinkStatus(padapter, pHciCmd);
#line 4409
  goto ldv_57098;
  case 48: ;
#line 4411
  if (BTCoexDbgLevel == 1U) {
#line 4411
    printk("HCI_SET_SCO_LINK_STATUS\n");
  } else {

  }
#line 4412
  status = bthci_CmdSetSCOLinkStatus(padapter, pHciCmd);
#line 4413
  goto ldv_57098;
  case 64: ;
#line 4415
  if (BTCoexDbgLevel == 1U) {
#line 4415
    printk("HCI_SET_RSSI_VALUE\n");
  } else {

  }
#line 4416
  status = bthci_CmdSetRSSIValue(padapter, pHciCmd);
#line 4417
  goto ldv_57098;
  case 65: ;
#line 4419
  if (BTCoexDbgLevel == 1U) {
#line 4419
    printk("HCI_SET_CURRENT_BLUETOOTH_STATUS\n");
  } else {

  }
#line 4420
  status = bthci_CmdSetCurrentBluetoothStatus(padapter, pHciCmd);
#line 4421
  goto ldv_57098;
  case 256: ;
#line 4425
  if (BTCoexDbgLevel == 1U) {
#line 4425
    printk("HCI_EXTENSION_VERSION_NOTIFY\n");
  } else {

  }
#line 4426
  status = bthci_CmdExtensionVersionNotify(padapter, pHciCmd);
#line 4427
  goto ldv_57098;
  case 257: ;
#line 4429
  if (BTCoexDbgLevel == 1U) {
#line 4429
    printk("HCI_LINK_STATUS_NOTIFY\n");
  } else {

  }
#line 4430
  status = bthci_CmdLinkStatusNotify(padapter, pHciCmd);
#line 4431
  goto ldv_57098;
  case 258: ;
#line 4433
  if (BTCoexDbgLevel == 1U) {
#line 4433
    printk("HCI_BT_OPERATION_NOTIFY\n");
  } else {

  }
#line 4434
  status = bthci_CmdBtOperationNotify(padapter, pHciCmd);
#line 4435
  goto ldv_57098;
  case 259: ;
#line 4437
  if (BTCoexDbgLevel == 1U) {
#line 4437
    printk("HCI_ENABLE_WIFI_SCAN_NOTIFY\n");
  } else {

  }
#line 4438
  status = bthci_CmdEnableWifiScanNotify(padapter, pHciCmd);
#line 4439
  goto ldv_57098;
  case 768: ;
#line 4443
  if (BTCoexDbgLevel == 1U) {
#line 4443
    printk("HCI_WIFI_CURRENT_CHANNEL\n");
  } else {

  }
#line 4444
  status = bthci_CmdWIFICurrentChannel(padapter, pHciCmd);
#line 4445
  goto ldv_57098;
  case 769: ;
#line 4447
  if (BTCoexDbgLevel == 1U) {
#line 4447
    printk("HCI_WIFI_CURRENT_BANDWIDTH\n");
  } else {

  }
#line 4448
  status = bthci_CmdWIFICurrentBandwidth(padapter, pHciCmd);
#line 4449
  goto ldv_57098;
  case 770: ;
#line 4451
  if (BTCoexDbgLevel == 1U) {
#line 4451
    printk("HCI_WIFI_CONNECTION_STATUS\n");
  } else {

  }
#line 4452
  status = bthci_CmdWIFIConnectionStatus(padapter, pHciCmd);
#line 4453
  goto ldv_57098;
  default: ;
#line 4456
  if (BTCoexDbgLevel == 1U) {
#line 4456
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
#line 4457
  status = bthci_UnknownCMD(padapter, pHciCmd);
#line 4458
  goto ldv_57098;
  }
  ldv_57098: ;
#line 4460
  return (status);
}
}
#line 4464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_StateStarting(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 4467
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4468
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4470
  if (BTCoexDbgLevel == 1U) {
#line 4470
    printk("[BT state], [Starting], ");
  } else {

  }
#line 4471
  switch ((unsigned int )StateCmd) {
  case 3U: ;
#line 4473
  if (BTCoexDbgLevel == 1U) {
#line 4473
    printk("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n");
  } else {

  }
#line 4474
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 16;
#line 4475
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
#line 4476
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4477
  goto ldv_57119;
  case 2U: ;
#line 4479
  if (BTCoexDbgLevel == 1U) {
#line 4479
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
#line 4481
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
#line 4486
  ldv_del_timer_sync_776(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4488
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 2;
#line 4490
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4491
  goto ldv_57119;
  case 4U: ;
#line 4493
  if (BTCoexDbgLevel == 1U) {
#line 4493
    printk("STATE_CMD_MAC_START_COMPLETE\n");
  } else {

  }
#line 4494
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole == 1U) {
#line 4495
    bthci_EventChannelSelected(padapter, (int )EntryNum);
  } else {

  }
#line 4496
  goto ldv_57119;
  default: ;
#line 4498
  if (BTCoexDbgLevel == 1U) {
#line 4498
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
#line 4499
  goto ldv_57119;
  }
  ldv_57119: ;
#line 4502
  return;
}
}
#line 4504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_StateConnecting(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                  u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 4507
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4508
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4510
  if (BTCoexDbgLevel == 1U) {
#line 4510
    printk("[BT state], [Connecting], ");
  } else {

  }
#line 4511
  switch ((unsigned int )StateCmd) {
  case 3U: ;
#line 4513
  if (BTCoexDbgLevel == 1U) {
#line 4513
    printk("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n");
  } else {

  }
#line 4514
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 16;
#line 4515
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
#line 4516
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4517
  goto ldv_57131;
  case 6U: ;
#line 4519
  if (BTCoexDbgLevel == 1U) {
#line 4519
    printk("STATE_CMD_MAC_CONNECT_COMPLETE\n");
  } else {

  }
#line 4521
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole == 2U) {
#line 4522
    if (GlobalDebugLevel23A > 6U) {
#line 4522
      rt_trace(4096, 7, "StateConnecting\n");
    } else {

    }
  } else {

  }
#line 4525
  goto ldv_57131;
  case 2U: ;
#line 4527
  if (BTCoexDbgLevel == 1U) {
#line 4527
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
#line 4529
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
#line 4534
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 2;
#line 4536
  ldv_del_timer_sync_777(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4538
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4540
  goto ldv_57131;
  case 9U: ;
#line 4542
  if (BTCoexDbgLevel == 1U) {
#line 4542
    printk("STATE_CMD_MAC_CONNECT_CANCEL_INDICATE\n");
  } else {

  }
#line 4543
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 58;
#line 4546
  pBtMgnt->bNeedNotifyAMPNoCap = 0U;
#line 4547
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4548
  goto ldv_57131;
  default: ;
#line 4550
  if (BTCoexDbgLevel == 1U) {
#line 4550
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
#line 4551
  goto ldv_57131;
  }
  ldv_57131: ;
#line 4554
  return;
}
}
#line 4556 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_StateConnected(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                 u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 i ;
  u16 logicHandle ;

  {
#line 4560
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4561
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4563
  logicHandle = 0U;
#line 4565
  if (BTCoexDbgLevel == 1U) {
#line 4565
    printk("[BT state], [Connected], ");
  } else {

  }
#line 4566
  switch ((unsigned int )StateCmd) {
  case 2U: ;
#line 4568
  if (BTCoexDbgLevel == 1U) {
#line 4568
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
#line 4571
  i = 0U;
#line 4571
  goto ldv_57147;
  ldv_57146: ;
#line 4572
  if ((unsigned int )((struct hci_log_link_cmd_data *)(& pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData))->BtLogLinkhandle != 0U) {
#line 4573
    logicHandle = ((struct hci_log_link_cmd_data *)(& pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData))->BtLogLinkhandle;
#line 4575
    bthci_EventDisconnectLogicalLinkComplete(padapter, 0, (int )logicHandle, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason);
#line 4578
    ((struct hci_log_link_cmd_data *)(& pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData))->BtLogLinkhandle = 0U;
  } else {

  }
#line 4571
  i = (u8 )((int )i + 1);
  ldv_57147: ;
#line 4571
  if ((unsigned int )i <= 1U) {
#line 4573
    goto ldv_57146;
  } else {

  }
#line 4582
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
#line 4587
  ldv_del_timer_sync_778(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4589
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4590
  goto ldv_57149;
  case 8U: ;
#line 4593
  if (BTCoexDbgLevel == 1U) {
#line 4593
    printk("STATE_CMD_MAC_DISCONNECT_INDICATE\n");
  } else {

  }
#line 4595
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, 22, (int )EntryNum);
#line 4600
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4602
  goto ldv_57149;
  case 12U: ;
#line 4604
  if (BTCoexDbgLevel == 1U) {
#line 4604
    printk("STATE_CMD_ENTER_STATE\n");
  } else {

  }
#line 4606
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
#line 4607
    pBtMgnt->bBTConnectInProgress = 0U;
#line 4608
    if (BTCoexDbgLevel == 1U) {
#line 4608
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {

    }
  } else {

  }
#line 4610
  pBTInfo->BtAsocEntry[(int )EntryNum].BtCurrentState = 8U;
#line 4611
  pBTInfo->BtAsocEntry[(int )EntryNum].b4waySuccess = 1U;
#line 4612
  pBtMgnt->bStartSendSupervisionPkt = 1U;
#line 4616
  rtl8723a_update_ramask(padapter, (u32 )(63 - (int )EntryNum), 0);
#line 4619
  HalSetBrateCfg23a(padapter, (u8 *)(& padapter->mlmepriv.cur_network.network.SupportedRates));
#line 4620
  BTDM_SetFwChnlInfo(padapter, 1);
#line 4621
  goto ldv_57149;
  default: ;
#line 4623
  if (BTCoexDbgLevel == 1U) {
#line 4623
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
#line 4624
  goto ldv_57149;
  }
  ldv_57149: ;
#line 4627
  return;
}
}
#line 4629 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_StateAuth(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                            u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 4632
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4633
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4635
  if (BTCoexDbgLevel == 1U) {
#line 4635
    printk("[BT state], [Authenticating], ");
  } else {

  }
#line 4636
  switch ((unsigned int )StateCmd) {
  case 3U: ;
#line 4638
  if (BTCoexDbgLevel == 1U) {
#line 4638
    printk("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n");
  } else {

  }
#line 4639
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 16;
#line 4640
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
#line 4641
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4642
  goto ldv_57161;
  case 2U: ;
#line 4644
  if (BTCoexDbgLevel == 1U) {
#line 4644
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
#line 4645
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
#line 4650
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 2;
#line 4652
  ldv_del_timer_sync_779(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4654
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4655
  goto ldv_57161;
  case 10U: ;
#line 4657
  if (BTCoexDbgLevel == 1U) {
#line 4657
    printk("STATE_CMD_4WAY_FAILED\n");
  } else {

  }
#line 4659
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 5;
#line 4660
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
#line 4662
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4664
  ldv_del_timer_sync_780(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4665
  goto ldv_57161;
  case 11U: ;
#line 4667
  if (BTCoexDbgLevel == 1U) {
#line 4667
    printk("STATE_CMD_4WAY_SUCCESSED\n");
  } else {

  }
#line 4669
  bthci_EventPhysicalLinkComplete(padapter, 0, (int )EntryNum, 255);
#line 4671
  ldv_del_timer_sync_781(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4673
  if (BTCoexDbgLevel == 1U) {
#line 4673
    printk("[BT state change] caused by %s, line =%d\n", "bthci_StateAuth", 4673);
  } else {

  }
#line 4673
  BTHCI_StateMachine(padapter, 8, 12, (int )EntryNum);
#line 4674
  goto ldv_57161;
  default: ;
#line 4676
  if (BTCoexDbgLevel == 1U) {
#line 4676
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
#line 4677
  goto ldv_57161;
  }
  ldv_57161: ;
#line 4680
  return;
}
}
#line 4682 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_StateDisconnecting(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                     u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 4685
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4686
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4688
  if (BTCoexDbgLevel == 1U) {
#line 4688
    printk("[BT state], [Disconnecting], ");
  } else {

  }
#line 4689
  switch ((unsigned int )StateCmd) {
  case 9U: ;
#line 4691
  if (BTCoexDbgLevel == 1U) {
#line 4691
    printk("STATE_CMD_MAC_CONNECT_CANCEL_INDICATE\n");
  } else {

  }
#line 4692
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent != 0U) {
#line 4693
    bthci_EventPhysicalLinkComplete(padapter, pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus,
                                    (int )EntryNum, 255);
  } else {

  }
#line 4698
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
#line 4699
    pBtMgnt->bBTConnectInProgress = 0U;
#line 4700
    if (BTCoexDbgLevel == 1U) {
#line 4700
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {

    }
  } else {

  }
#line 4703
  if (BTCoexDbgLevel == 1U) {
#line 4703
    printk("[BT state change] caused by %s, line =%d\n", "bthci_StateDisconnecting",
           4703);
  } else {

  }
#line 4703
  BTHCI_StateMachine(padapter, 32, 12, (int )EntryNum);
#line 4704
  goto ldv_57176;
  case 2U: ;
#line 4706
  if (BTCoexDbgLevel == 1U) {
#line 4706
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
#line 4708
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
#line 4713
  ldv_del_timer_sync_782(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4715
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4716
  goto ldv_57176;
  default: ;
#line 4718
  if (BTCoexDbgLevel == 1U) {
#line 4718
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
#line 4719
  goto ldv_57176;
  }
  ldv_57176: ;
#line 4722
  return;
}
}
#line 4724 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void bthci_StateDisconnected(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                    u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  struct bt_mgnt *pBtMgnt ;
  unsigned long __ms ;
  unsigned long tmp ;
  bool tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 4728
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4729
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 4730
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4732
  if (BTCoexDbgLevel == 1U) {
#line 4732
    printk("[BT state], [Disconnected], ");
  } else {

  }
#line 4733
  switch ((unsigned int )StateCmd) {
  case 0U: ;
  case 1U: ;
#line 4736
  if ((unsigned int )StateCmd == 0U) {
#line 4737
    if (BTCoexDbgLevel == 1U) {
#line 4737
      printk("STATE_CMD_CREATE_PHY_LINK\n");
    } else {

    }
  } else
#line 4739
  if (BTCoexDbgLevel == 1U) {
#line 4739
    printk("STATE_CMD_ACCEPT_PHY_LINK\n");
  } else {

  }
#line 4741
  if (BTCoexDbgLevel == 1U) {
#line 4741
    printk("[BT PS], Disable IPS and LPS\n");
  } else {

  }
#line 4742
  ips_leave23a(padapter);
#line 4743
  LPS_Leave23a(padapter);
#line 4745
  pBtMgnt->bPhyLinkInProgress = 1U;
#line 4746
  pBtMgnt->BTCurrentConnectType = 4;
#line 4747
  pBtMgnt->CurrentBTConnectionCnt = (u8 )((int )pBtMgnt->CurrentBTConnectionCnt + 1);
#line 4748
  if (BTCoexDbgLevel == 1U) {
#line 4748
    printk("[BT Flag], CurrentBTConnectionCnt = %d\n", (int )pBtMgnt->CurrentBTConnectionCnt);
  } else {

  }
#line 4750
  pBtMgnt->BtOperationOn = 1U;
#line 4751
  if (BTCoexDbgLevel == 1U) {
#line 4751
    printk("[BT Flag], Bt Operation ON!! CurrentConnectEntryNum = %d\n", (int )pBtMgnt->CurrentConnectEntryNum);
  } else {

  }
#line 4754
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
#line 4755
    bthci_EventPhysicalLinkComplete(padapter, 58, 255, (int )pBtMgnt->BtCurrentPhyLinkhandle);
#line 4756
    bthci_RemoveEntryByEntryNum(padapter, (int )EntryNum);
#line 4757
    return;
  } else {

  }
#line 4760
  if ((unsigned int )StateCmd == 0U) {
#line 4761
    pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole = 1;
  } else {
#line 4763
    pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole = 2;
  }
#line 4766
  goto ldv_57194;
  ldv_57193: ;
#line 4767
  if (BTCoexDbgLevel == 1U) {
#line 4767
    printk("Scan/Roaming/Wifi Link is in Progress, wait 200 ms\n");
  } else {

  }
#line 4768
  __ms = 200UL;
#line 4768
  goto ldv_57191;
  ldv_57190: 
#line 4768
  __const_udelay(4295000UL);
  ldv_57191: 
#line 4768
  tmp = __ms;
#line 4768
  __ms = __ms - 1UL;
#line 4768
  if (tmp != 0UL) {
#line 4770
    goto ldv_57190;
  } else {

  }

  ldv_57194: 
#line 4766
  tmp___0 = check_fwstate(& padapter->mlmepriv, 2049);
#line 4766
  if ((int )tmp___0) {
#line 4768
    goto ldv_57193;
  } else {

  }

#line 4771
  if (BTCoexDbgLevel == 1U) {
#line 4771
    printk("Channel is Ready\n");
  } else {

  }
#line 4772
  tmp___1 = msecs_to_jiffies((unsigned int const   )pBtHciInfo->ConnAcceptTimeout);
#line 4772
  ldv_mod_timer_783(& pBTInfo->BTHCIJoinTimeoutTimer, tmp___1 + (unsigned long )jiffies);
#line 4775
  pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent = 1U;
#line 4776
  goto ldv_57196;
  case 2U: ;
#line 4778
  if (BTCoexDbgLevel == 1U) {
#line 4778
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
#line 4780
  ldv_del_timer_sync_784(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4782
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
#line 4787
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent != 0U) {
#line 4788
    bthci_EventPhysicalLinkComplete(padapter, 2, (int )EntryNum, 255);
  } else {

  }
#line 4793
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
#line 4794
    pBtMgnt->bBTConnectInProgress = 0U;
#line 4795
    if (BTCoexDbgLevel == 1U) {
#line 4795
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {

    }
  } else {

  }
#line 4797
  if (BTCoexDbgLevel == 1U) {
#line 4797
    printk("[BT state change] caused by %s, line =%d\n", "bthci_StateDisconnected",
           4797);
  } else {

  }
#line 4797
  BTHCI_StateMachine(padapter, 32, 12, (int )EntryNum);
#line 4798
  bthci_RemoveEntryByEntryNum(padapter, (int )EntryNum);
#line 4799
  goto ldv_57196;
  case 12U: ;
#line 4801
  if (BTCoexDbgLevel == 1U) {
#line 4801
    printk("STATE_CMD_ENTER_STATE\n");
  } else {

  }
#line 4802
  goto ldv_57196;
  default: ;
#line 4804
  if (BTCoexDbgLevel == 1U) {
#line 4804
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
#line 4805
  goto ldv_57196;
  }
  ldv_57196: ;
#line 4808
  return;
}
}
#line 4809 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTHCI_EventParse(struct rtw_adapter *padapter , void *pEvntData , u32 dataLen ) 
{ 


  {
#line 4811
  return;
}
}
#line 4813 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTHCI_HsConnectionEstablished(struct rtw_adapter *padapter ) 
{ 
  u8 bBtConnectionExist ;
  struct bt_30info *pBtinfo ;
  u8 i ;

  {
#line 4815
  bBtConnectionExist = 0U;
#line 4816
  pBtinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4819
  i = 0U;
#line 4819
  goto ldv_57214;
  ldv_57213: ;
#line 4820
  if ((unsigned int )pBtinfo->BtAsocEntry[(int )i].b4waySuccess != 0U) {
#line 4821
    bBtConnectionExist = 1U;
#line 4822
    goto ldv_57212;
  } else {

  }
#line 4819
  i = (u8 )((int )i + 1);
  ldv_57214: ;
#line 4819
  if ((unsigned int )i <= 1U) {
#line 4821
    goto ldv_57213;
  } else {

  }
  ldv_57212: ;
#line 4828
  return (bBtConnectionExist);
}
}
#line 4832 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 BTHCI_CheckProfileExist(struct rtw_adapter *padapter , enum bt_traffic_mode_profile Profile ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 IsPRofile ;
  u8 i ;

  {
#line 4835
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4836
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4837
  IsPRofile = 0U;
#line 4838
  i = 0U;
#line 4840
  i = 0U;
#line 4840
  goto ldv_57225;
  ldv_57224: ;
#line 4841
  if ((unsigned int )pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile == (unsigned int )Profile) {
#line 4842
    IsPRofile = 1U;
#line 4843
    goto ldv_57223;
  } else {

  }
#line 4840
  i = (u8 )((int )i + 1);
  ldv_57225: ;
#line 4840
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
#line 4842
    goto ldv_57224;
  } else {

  }
  ldv_57223: ;
#line 4847
  return (IsPRofile);
}
}
#line 4850 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTHCI_UpdateBTProfileRTKToMoto(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 i ;

  {
#line 4852
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4853
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4854
  i = 0U;
#line 4856
  pBtMgnt->ExtConfig.NumberOfSCO = 0U;
#line 4858
  i = 0U;
#line 4858
  goto ldv_57239;
  ldv_57238: 
#line 4859
  pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile = 0U;
#line 4861
  if ((unsigned int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile == 4U) {
#line 4862
    pBtMgnt->ExtConfig.NumberOfSCO = (u8 )((int )pBtMgnt->ExtConfig.NumberOfSCO + 1);
  } else {

  }
#line 4864
  pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile = pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile;
#line 4865
  switch ((int )pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile) {
  case 4: ;
#line 4867
  goto ldv_57233;
  case 2: 
#line 4869
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 0U;
#line 4870
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 0U;
#line 4871
  goto ldv_57233;
  case 1: 
#line 4873
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 3U;
#line 4874
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 3U;
#line 4875
  goto ldv_57233;
  case 3: 
#line 4877
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 1U;
#line 4878
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 0U;
#line 4879
  goto ldv_57233;
  default: ;
#line 4881
  goto ldv_57233;
  }
  ldv_57233: 
#line 4858
  i = (u8 )((int )i + 1);
  ldv_57239: ;
#line 4858
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
#line 4860
    goto ldv_57238;
  } else {

  }

#line 4885
  if (BTCoexDbgLevel == 1U) {
#line 4885
    printk("[DM][BT], RTK, NumberOfHandle = %d, NumberOfSCO = %d\n", (int )pBtMgnt->ExtConfig.NumberOfHandle,
           (int )pBtMgnt->ExtConfig.NumberOfSCO);
  } else {

  }
#line 4886
  return;
}
}
#line 4889 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTHCI_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 4891
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4892
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4894
  if ((unsigned int )pBtMgnt->ExtConfig.bEnableWifiScanNotify != 0U) {
#line 4895
    bthci_EventExtWifiScanNotify(padapter, (int )scanType);
  } else {

  }
#line 4896
  return;
}
}
#line 4899 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTHCI_StateMachine(struct rtw_adapter *padapter , u8 StateToEnter , enum hci_state_with_cmd StateCmd ,
                        u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 4906
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4907
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4909
  if ((unsigned int )EntryNum == 255U) {
#line 4910
    if (BTCoexDbgLevel == 1U) {
#line 4910
      printk(" StateMachine, error EntryNum = 0x%x \n", (int )EntryNum);
    } else {

    }
#line 4911
    return;
  } else {

  }
#line 4913
  if (BTCoexDbgLevel == 1U) {
#line 4913
    printk(" StateMachine, EntryNum = 0x%x, CurrentState = 0x%x, BtNextState = 0x%x,  StateCmd = 0x%x , StateToEnter = 0x%x\n",
           (int )EntryNum, (int )pBTInfo->BtAsocEntry[(int )EntryNum].BtCurrentState,
           (int )pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState, (unsigned int )StateCmd,
           (int )StateToEnter);
  } else {

  }
#line 4916
  if ((unsigned int )((int )pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState & (int )StateToEnter) != 0U) {
#line 4917
    pBTInfo->BtAsocEntry[(int )EntryNum].BtCurrentState = StateToEnter;
#line 4919
    switch ((int )StateToEnter) {
    case 1: 
#line 4921
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 18U;
#line 4922
    bthci_StateStarting(padapter, StateCmd, (int )EntryNum);
#line 4923
    goto ldv_57256;
    case 2: 
#line 4925
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 22U;
#line 4926
    bthci_StateConnecting(padapter, StateCmd, (int )EntryNum);
#line 4927
    goto ldv_57256;
    case 4: 
#line 4929
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 24U;
#line 4930
    bthci_StateAuth(padapter, StateCmd, (int )EntryNum);
#line 4931
    goto ldv_57256;
    case 8: 
#line 4933
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 24U;
#line 4934
    bthci_StateConnected(padapter, StateCmd, (int )EntryNum);
#line 4935
    goto ldv_57256;
    case 16: 
#line 4937
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 48U;
#line 4938
    bthci_StateDisconnecting(padapter, StateCmd, (int )EntryNum);
#line 4939
    goto ldv_57256;
    case 32: 
#line 4941
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 35U;
#line 4942
    bthci_StateDisconnected(padapter, StateCmd, (int )EntryNum);
#line 4943
    goto ldv_57256;
    default: ;
#line 4945
    if (BTCoexDbgLevel == 1U) {
#line 4945
      printk(" StateMachine, Unknown state to enter!!!\n");
    } else {

    }
#line 4946
    goto ldv_57256;
    }
    ldv_57256: ;
  } else
#line 4949
  if (BTCoexDbgLevel == 1U) {
#line 4949
    printk(" StateMachine, Wrong state to enter\n");
  } else {

  }
#line 4953
  if ((unsigned int )pBtMgnt->bBTConnectInProgress == 0U && (unsigned int )pBtMgnt->BtOperationOn == 0U) {
#line 4954
    if (BTCoexDbgLevel == 1U) {
#line 4954
      printk("[BT PS], ips_enter23a()\n");
    } else {

    }
#line 4955
    ips_enter23a(padapter);
  } else {

  }
#line 4957
  return;
}
}
#line 4959 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTHCI_DisconnectPeer(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 4961
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4962
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4964
  if (BTCoexDbgLevel == 1U) {
#line 4964
    printk(" BTHCI_DisconnectPeer()\n");
  } else {

  }
#line 4966
  if (BTCoexDbgLevel == 1U) {
#line 4966
    printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectPeer", 4966);
  } else {

  }
#line 4966
  BTHCI_StateMachine(padapter, 16, 9, (int )EntryNum);
#line 4972
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
#line 4973
    pBtMgnt->bBTConnectInProgress = 0U;
#line 4974
    if (BTCoexDbgLevel == 1U) {
#line 4974
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {

    }
  } else {

  }
#line 4977
  bthci_RemoveEntryByEntryNum(padapter, (int )EntryNum);
#line 4979
  if ((unsigned int )pBtMgnt->bNeedNotifyAMPNoCap != 0U) {
#line 4980
    if (BTCoexDbgLevel == 1U) {
#line 4980
      printk("[BT AMPStatus], set to invalid in BTHCI_DisconnectPeer()\n");
    } else {

    }
#line 4981
    BTHCI_EventAMPStatusChange(padapter, 2);
  } else {

  }
#line 4983
  return;
}
}
#line 4985 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTHCI_EventNumOfCompletedDataBlocks(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 *pTriple ;
  u8 len ;
  u8 i ;
  u8 j ;
  u8 handleNum ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u16 *pPackets ;
  u16 *pHandle ;
  u16 *pDblocks ;
  u8 sent ;

  {
#line 4988
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4989
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 4990
  localBuf[0] = '\000';
#line 4990
  tmp = 1U;
#line 4990
  while (1) {
#line 4990
    if (tmp >= 256U) {
#line 4990
      break;
    } else {

    }
#line 4990
    localBuf[tmp] = (unsigned char)0;
#line 4990
    tmp = tmp + 1U;
  }
#line 4992
  len = 0U;
#line 4992
  handleNum = 0U;
#line 4995
  sent = 0U;
#line 4997
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 4999
  if ((pBtHciInfo->BTEventMaskPage2 & 256ULL) == 0ULL) {
#line 5000
    if (BTCoexDbgLevel == 1U) {
#line 5000
      printk("[BT event], Num Of Completed DataBlocks, Ignore to send NumOfCompletedDataBlocksEvent due to event mask page 2\n");
    } else {

    }
#line 5001
    return;
  } else {

  }
#line 5005
  pRetPar = (u8 *)(& PPacketIrpEvent->Data);
#line 5006
  pTriple = pRetPar + 3UL;
#line 5007
  j = 0U;
#line 5007
  goto ldv_57292;
  ldv_57291: 
#line 5009
  i = 0U;
#line 5009
  goto ldv_57289;
  ldv_57288: ;
#line 5010
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle != 0U) {
#line 5011
    handleNum = (u8 )((int )handleNum + 1);
#line 5012
    pHandle = (u16 *)pTriple;
#line 5013
    pPackets = (u16 *)pTriple + 2U;
#line 5014
    pDblocks = (u16 *)pTriple + 4U;
#line 5015
    *pHandle = pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle;
#line 5016
    *pPackets = (unsigned short )pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount;
#line 5017
    *pDblocks = (unsigned short )pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount;
#line 5018
    if (pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount != 0U) {
#line 5019
      sent = 1U;
#line 5020
      if (BTCoexDbgLevel == 1U) {
#line 5020
        printk("[BT event], Num Of Completed DataBlocks, Handle = 0x%x, Num_Of_Completed_Packets = 0x%x, Num_Of_Completed_Blocks = 0x%x\n",
               (int )*pHandle, (int )*pPackets, (int )*pDblocks);
      } else {

      }
    } else {

    }
#line 5024
    pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount = 0U;
#line 5025
    len = (unsigned int )len + 6U;
#line 5026
    pTriple = pTriple + (unsigned long )len;
  } else {

  }
#line 5009
  i = (u8 )((int )i + 1);
  ldv_57289: ;
#line 5009
  if ((unsigned int )i <= 1U) {
#line 5011
    goto ldv_57288;
  } else {

  }
#line 5007
  j = (u8 )((int )j + 1);
  ldv_57292: ;
#line 5007
  if ((unsigned int )j <= 1U) {
#line 5009
    goto ldv_57291;
  } else {

  }
#line 5031
  *(pRetPar + 2UL) = handleNum;
#line 5032
  len = (unsigned int )len + 1U;
#line 5033
  pu2Temp = (u16 *)pRetPar;
#line 5034
  *pu2Temp = 256U;
#line 5035
  len = (unsigned int )len + 2U;
#line 5037
  PPacketIrpEvent->EventCode = 72U;
#line 5038
  PPacketIrpEvent->Length = len;
#line 5039
  if ((unsigned int )handleNum != 0U && (unsigned int )sent != 0U) {
#line 5040
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  } else {

  }
#line 5041
  return;
}
}
#line 5043 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTHCI_EventAMPStatusChange(struct rtw_adapter *padapter , u8 AMP_Status ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 len ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  enum rt_status tmp___0 ;

  {
#line 5045
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 5046
  pBtMgnt = & pBTInfo->BtMgnt;
#line 5048
  len = 0U;
#line 5049
  localBuf[0] = '\000';
#line 5049
  tmp = 1U;
#line 5049
  while (1) {
#line 5049
    if (tmp >= 7U) {
#line 5049
      break;
    } else {

    }
#line 5049
    localBuf[tmp] = (unsigned char)0;
#line 5049
    tmp = tmp + 1U;
  }
#line 5052
  if ((unsigned int )AMP_Status == 2U) {
#line 5053
    pBtMgnt->BTNeedAMPStatusChg = 1U;
#line 5054
    pBtMgnt->bNeedNotifyAMPNoCap = 0U;
#line 5056
    BTHCI_DisconnectAll(padapter);
  } else
#line 5057
  if ((unsigned int )AMP_Status == 6U) {
#line 5058
    pBtMgnt->BTNeedAMPStatusChg = 0U;
  } else {

  }
#line 5061
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 5063
  pRetPar = (u8 *)(& PPacketIrpEvent->Data);
#line 5065
  *pRetPar = 0U;
#line 5066
  len = (unsigned int )len + 1U;
#line 5067
  *(pRetPar + 1UL) = AMP_Status;
#line 5068
  len = (unsigned int )len + 1U;
#line 5070
  PPacketIrpEvent->EventCode = 77U;
#line 5071
  PPacketIrpEvent->Length = len;
#line 5072
  tmp___0 = bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 5072
  if ((unsigned int )tmp___0 == 0U) {
#line 5073
    if (BTCoexDbgLevel == 1U) {
#line 5073
      printk("[BT event], AMP Status Change, AMP_Status = %d\n", (int )AMP_Status);
    } else {

    }
  } else {

  }
#line 5074
  return;
}
}
#line 5076 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTHCI_DisconnectAll(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  u8 i ;

  {
#line 5078
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 5081
  if (BTCoexDbgLevel == 1U) {
#line 5081
    printk(" DisconnectALL()\n");
  } else {

  }
#line 5083
  i = 0U;
#line 5083
  goto ldv_57311;
  ldv_57310: ;
#line 5084
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].b4waySuccess != 0U) {
#line 5085
    if (BTCoexDbgLevel == 1U) {
#line 5085
      printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectAll",
             5085);
    } else {

    }
#line 5085
    BTHCI_StateMachine(padapter, 8, 2, (int )i);
  } else
#line 5086
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed != 0U) {
#line 5087
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].BtCurrentState == 2U) {
#line 5088
      if (BTCoexDbgLevel == 1U) {
#line 5088
        printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectAll",
               5088);
      } else {

      }
#line 5088
      BTHCI_StateMachine(padapter, 2, 9, (int )i);
    } else
#line 5089
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].BtCurrentState == 16U) {
#line 5090
      if (BTCoexDbgLevel == 1U) {
#line 5090
        printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectAll",
               5090);
      } else {

      }
#line 5090
      BTHCI_StateMachine(padapter, 16, 9, (int )i);
    } else {

    }
  } else {

  }
#line 5083
  i = (u8 )((int )i + 1);
  ldv_57311: ;
#line 5083
  if ((unsigned int )i <= 1U) {
#line 5085
    goto ldv_57310;
  } else {

  }

#line 5090
  return;
}
}
#line 5097 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
enum hci_status BTHCI_HandleHCICMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u32 __i ;
  u8 *ptr ;

  {
#line 5102
  status = 0;
#line 5103
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 5104
  pBtDbg = & pBTInfo->BtDbg;
#line 5106
  if (BTCoexDbgLevel == 1U) {
#line 5106
    printk("\n");
  } else {

  }
#line 5107
  if (BTCoexDbgLevel == 1U) {
#line 5107
    printk("HCI Command start, OGF = 0x%x, OCF = 0x%x, Length = 0x%x\n", (int )pHciCmd->OGF,
           (int )pHciCmd->OCF, (int )pHciCmd->Length);
  } else {

  }
#line 5109
  if ((unsigned int )pHciCmd->Length != 0U) {
#line 5110
    if (BTCoexDbgLevel == 1U) {
#line 5110
      ptr = (u8 *)(& pHciCmd->Data);
#line 5110
      printk("HCI Command, Hex Data :\n");
#line 5110
      __i = 0U;
#line 5110
      goto ldv_57323;
      ldv_57322: 
#line 5110
      printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 5110
      if (((__i + 1U) & 15U) == 0U) {
#line 5110
        printk("\n");
      } else {

      }
#line 5110
      __i = __i + 1U;
      ldv_57323: ;
#line 5110
      if ((u32 )pHciCmd->Length > __i) {
#line 5112
        goto ldv_57322;
      } else {

      }
#line 5110
      printk("\n");
    } else {

    }
  } else {

  }
#line 5113
  if ((unsigned int )*((unsigned char *)pHciCmd + 1UL) == 252U) {
#line 5114
    if ((unsigned int )*((unsigned short *)pHciCmd + 0UL) == 64U) {
#line 5115
      if (BTCoexDbgLevel == 1U) {
#line 5115
        printk("[BT cmd], ");
      } else {

      }
    } else
#line 5117
    if (BTCoexDbgLevel == 1U) {
#line 5117
      printk("[BT cmd], ");
    } else {

    }
  } else
#line 5119
  if (BTCoexDbgLevel == 1U) {
#line 5119
    printk("[BT cmd], ");
  } else {

  }
#line 5122
  pBtDbg->dbgHciInfo.hciCmdCnt = pBtDbg->dbgHciInfo.hciCmdCnt + 1U;
#line 5124
  switch ((int )pHciCmd->OGF) {
  case 1: 
#line 5126
  status = bthci_HandleOGFLinkControlCMD(padapter, pHciCmd);
#line 5127
  goto ldv_57326;
  case 2: ;
#line 5129
  goto ldv_57326;
  case 3: 
#line 5131
  status = bthci_HandleOGFSetEventMaskCMD(padapter, pHciCmd);
#line 5132
  goto ldv_57326;
  case 4: 
#line 5134
  status = bthci_HandleOGFInformationalParameters(padapter, pHciCmd);
#line 5135
  goto ldv_57326;
  case 5: 
#line 5137
  status = bthci_HandleOGFStatusParameters(padapter, pHciCmd);
#line 5138
  goto ldv_57326;
  case 6: 
#line 5140
  status = bthci_HandleOGFTestingCMD(padapter, pHciCmd);
#line 5141
  goto ldv_57326;
  case 63: 
#line 5143
  status = bthci_HandleOGFExtension(padapter, pHciCmd);
#line 5144
  goto ldv_57326;
  default: ;
#line 5146
  if (BTCoexDbgLevel == 1U) {
#line 5146
    printk("HCI Command(), Unknown OGF = 0x%x\n", (int )pHciCmd->OGF);
  } else {

  }
#line 5147
  if (BTCoexDbgLevel == 1U) {
#line 5147
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
#line 5148
  status = bthci_UnknownCMD(padapter, pHciCmd);
#line 5149
  goto ldv_57326;
  }
  ldv_57326: ;
#line 5151
  if (BTCoexDbgLevel == 1U) {
#line 5151
    printk("HCI Command execution end!!\n");
  } else {

  }
#line 5153
  return (status);
}
}
#line 5158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static char const   * const  BtStateString[9U]  = 
#line 5158
  {      "BT_DISABLED",      "BT_NO_CONNECTION",      "BT_CONNECT_IDLE",      "BT_INQ_OR_PAG", 
        "BT_ACL_ONLY_BUSY",      "BT_SCO_ONLY_BUSY",      "BT_ACL_SCO_BUSY",      "BT_ACL_INQ_OR_PAG", 
        "BT_STATE_NOT_DEFINED"};
#line 5172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_SetFwIgnoreWlanAct(struct rtw_adapter *padapter , u8 bEnable ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[1U] ;

  {
#line 5174
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5175
  H2C_Parameter[0] = 0U;
#line 5177
  if ((unsigned int )bEnable != 0U) {
#line 5178
    if (BTCoexDbgLevel == 1U) {
#line 5178
      printk("[BTCoex], BT Ignore Wlan_Act !!\n");
    } else {

    }
#line 5179
    H2C_Parameter[0] = (u8 )((unsigned int )H2C_Parameter[0] | 1U);
#line 5180
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else
#line 5182
  if (BTCoexDbgLevel == 1U) {
#line 5182
    printk("[BTCoex], BT don\'t ignore Wlan_Act !!\n");
  } else {

  }
#line 5185
  if (BTCoexDbgLevel == 1U) {
#line 5185
    printk("[BTCoex], set FW for BT Ignore Wlan_Act, write 0x25 = 0x%02x\n", (int )H2C_Parameter[0]);
  } else {

  }
#line 5188
  FillH2CCmd(padapter, 37, 1U, (u8 *)(& H2C_Parameter));
#line 5189
  return;
}
}
#line 5191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_NotifyFwScan(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  u8 H2C_Parameter[1U] ;

  {
#line 5193
  H2C_Parameter[0] = 0U;
#line 5195
  if ((unsigned int )scanType == 1U) {
#line 5196
    H2C_Parameter[0] = 1U;
  } else {

  }
#line 5198
  if (BTCoexDbgLevel == 1U) {
#line 5198
    printk("[BTCoex], Notify FW for wifi scan, write 0x3b = 0x%02x\n", (int )H2C_Parameter[0]);
  } else {

  }
#line 5201
  FillH2CCmd(padapter, 59, 1U, (u8 *)(& H2C_Parameter));
#line 5202
  return;
}
}
#line 5204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_1AntSetPSMode(struct rtw_adapter *padapter , u8 enable , u8 smartps ,
                               u8 mode ) 
{ 
  struct pwrctrl_priv *pwrctrl ;

  {
#line 5209
  if (BTCoexDbgLevel == 1U) {
#line 5209
    printk("[BTCoex], Current LPS(%s, %d), smartps =%d\n", (unsigned int )enable == 1U ? (char *)"ON" : (char *)"OFF",
           (int )mode, (int )smartps);
  } else {

  }
#line 5211
  pwrctrl = & padapter->pwrctrlpriv;
#line 5213
  if ((unsigned int )enable == 1U) {
#line 5214
    rtw_set_ps_mode23a(padapter, 1, (int )smartps, (int )mode);
  } else {
#line 5216
    rtw_set_ps_mode23a(padapter, 0, 0, 0);
#line 5217
    LPS_RF_ON_check23a(padapter, 100U);
  }
#line 5219
  return;
}
}
#line 5221 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_1AntTSFSwitch(struct rtw_adapter *padapter , u8 enable ) 
{ 
  u8 oldVal ;
  u8 newVal ;

  {
#line 5225
  oldVal = rtl8723au_read8(padapter, 1360);
#line 5227
  if ((unsigned int )enable != 0U) {
#line 5228
    newVal = (u8 )((unsigned int )oldVal | 8U);
  } else {
#line 5230
    newVal = (unsigned int )oldVal & 247U;
  }
#line 5232
  if ((int )oldVal != (int )newVal) {
#line 5233
    rtl8723au_write8(padapter, 1360, (int )newVal);
  } else {

  }
#line 5234
  return;
}
}
#line 5236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 btdm_Is1AntPsTdmaStateChange(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;

  {
#line 5238
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5239
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
#line 5241
  if ((int )pBtdm8723->bPrePsTdmaOn != (int )pBtdm8723->bCurPsTdmaOn || (int )pBtdm8723->prePsTdma != (int )pBtdm8723->curPsTdma) {
#line 5243
    return (1U);
  } else {
#line 5245
    return (0U);
  }
}
}
#line 5250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_1AntPsTdma(struct rtw_adapter *padapter , u8 bTurnOn , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  u8 tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___6 ;
  u8 tmp___7 ;
  u8 tmp___8 ;
  u8 tmp___9 ;
  u8 tmp___10 ;
  u8 tmp___11 ;
  u8 tmp___12 ;
  u8 tmp___13 ;
  u8 tmp___14 ;
  u8 tmp___15 ;
  u8 tmp___16 ;
  u8 tmp___17 ;
  u8 tmp___18 ;
  u8 tmp___19 ;
  u8 tmp___20 ;

  {
#line 5256
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5257
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
#line 5259
  pBtdm8723->bCurPsTdmaOn = bTurnOn;
#line 5260
  pBtdm8723->curPsTdma = type;
#line 5261
  if ((unsigned int )bTurnOn != 0U) {
#line 5262
    switch ((int )type) {
    case 1: ;
    default: 
#line 5265
    tmp = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5265
    if ((unsigned int )tmp != 0U) {
#line 5267
      BTDM_SetFw3a(padapter, 211, 26, 26, 0, 88);
    } else {

    }
#line 5269
    goto ldv_57373;
    case 2: 
#line 5271
    tmp___0 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5271
    if ((unsigned int )tmp___0 != 0U) {
#line 5273
      BTDM_SetFw3a(padapter, 211, 18, 18, 0, 88);
    } else {

    }
#line 5275
    goto ldv_57373;
    case 3: 
#line 5277
    tmp___1 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5277
    if ((unsigned int )tmp___1 != 0U) {
#line 5279
      BTDM_SetFw3a(padapter, 211, 48, 3, 16, 88);
    } else {

    }
#line 5282
    goto ldv_57373;
    case 4: 
#line 5284
    tmp___2 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5284
    if ((unsigned int )tmp___2 != 0U) {
#line 5286
      BTDM_SetFw3a(padapter, 147, 21, 3, 20, 0);
    } else {

    }
#line 5288
    goto ldv_57373;
    case 5: 
#line 5290
    tmp___3 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5290
    if ((unsigned int )tmp___3 != 0U) {
#line 5292
      BTDM_SetFw3a(padapter, 97, 21, 3, 49, 0);
    } else {

    }
#line 5294
    goto ldv_57373;
    case 9: 
#line 5296
    tmp___4 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5296
    if ((unsigned int )tmp___4 != 0U) {
#line 5298
      BTDM_SetFw3a(padapter, 211, 10, 10, 0, 88);
    } else {

    }
#line 5300
    goto ldv_57373;
    case 10: 
#line 5302
    tmp___5 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5302
    if ((unsigned int )tmp___5 != 0U) {
#line 5303
      BTDM_SetFw3a(padapter, 19, 10, 10, 0, 64);
    } else {

    }
#line 5304
    goto ldv_57373;
    case 11: 
#line 5306
    tmp___6 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5306
    if ((unsigned int )tmp___6 != 0U) {
#line 5308
      BTDM_SetFw3a(padapter, 211, 5, 5, 0, 88);
    } else {

    }
#line 5310
    goto ldv_57373;
    case 12: 
#line 5312
    tmp___7 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5312
    if ((unsigned int )tmp___7 != 0U) {
#line 5314
      BTDM_SetFw3a(padapter, 235, 10, 3, 49, 24);
    } else {

    }
#line 5316
    goto ldv_57373;
    case 20: 
#line 5318
    tmp___8 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5318
    if ((unsigned int )tmp___8 != 0U) {
#line 5319
      BTDM_SetFw3a(padapter, 19, 37, 37, 0, 0);
    } else {

    }
#line 5320
    goto ldv_57373;
    case 27: 
#line 5322
    tmp___9 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5322
    if ((unsigned int )tmp___9 != 0U) {
#line 5323
      BTDM_SetFw3a(padapter, 163, 37, 3, 49, 152);
    } else {

    }
#line 5324
    goto ldv_57373;
    case 28: 
#line 5326
    tmp___10 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5326
    if ((unsigned int )tmp___10 != 0U) {
#line 5327
      BTDM_SetFw3a(padapter, 105, 37, 3, 49, 0);
    } else {

    }
#line 5328
    goto ldv_57373;
    case 29: 
#line 5330
    tmp___11 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5330
    if ((unsigned int )tmp___11 != 0U) {
#line 5331
      BTDM_SetFw3a(padapter, 235, 26, 26, 1, 24);
#line 5332
      rtl8723au_write32(padapter, 1728, 1526356730U);
#line 5333
      rtl8723au_write32(padapter, 1732, 1526356730U);
    } else {

    }
#line 5335
    goto ldv_57373;
    case 30: 
#line 5337
    tmp___12 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5337
    if ((unsigned int )tmp___12 != 0U) {
#line 5338
      BTDM_SetFw3a(padapter, 147, 21, 3, 20, 0);
    } else {

    }
#line 5339
    goto ldv_57373;
    case 31: 
#line 5341
    tmp___13 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5341
    if ((unsigned int )tmp___13 != 0U) {
#line 5342
      BTDM_SetFw3a(padapter, 211, 26, 26, 0, 88);
    } else {

    }
#line 5343
    goto ldv_57373;
    case 32: 
#line 5345
    tmp___14 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5345
    if ((unsigned int )tmp___14 != 0U) {
#line 5346
      BTDM_SetFw3a(padapter, 171, 10, 3, 17, 152);
    } else {

    }
#line 5347
    goto ldv_57373;
    case 33: 
#line 5349
    tmp___15 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5349
    if ((unsigned int )tmp___15 != 0U) {
#line 5350
      BTDM_SetFw3a(padapter, 163, 37, 3, 48, 152);
    } else {

    }
#line 5351
    goto ldv_57373;
    case 34: 
#line 5353
    tmp___16 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5353
    if ((unsigned int )tmp___16 != 0U) {
#line 5354
      BTDM_SetFw3a(padapter, 211, 26, 26, 0, 24);
    } else {

    }
#line 5355
    goto ldv_57373;
    case 35: 
#line 5357
    tmp___17 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5357
    if ((unsigned int )tmp___17 != 0U) {
#line 5358
      BTDM_SetFw3a(padapter, 227, 26, 26, 0, 24);
    } else {

    }
#line 5359
    goto ldv_57373;
    }
    ldv_57373: ;
  } else {
#line 5363
    switch ((int )type) {
    case 8: 
#line 5365
    tmp___18 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5365
    if ((unsigned int )tmp___18 != 0U) {
#line 5367
      BTDM_SetFw3a(padapter, 8, 0, 0, 0, 0);
    } else {

    }
#line 5369
    goto ldv_57393;
    case 0: ;
    default: 
#line 5372
    tmp___19 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5372
    if ((unsigned int )tmp___19 != 0U) {
#line 5374
      BTDM_SetFw3a(padapter, 0, 0, 0, 8, 0);
    } else {

    }
#line 5377
    rtl8723au_write16(padapter, 2144, 528);
#line 5378
    if (BTCoexDbgLevel == 1U) {
#line 5378
      printk("[BTCoex], 0x860 = 0x210, Switch Antenna to BT\n");
    } else {

    }
#line 5379
    goto ldv_57393;
    case 9: 
#line 5381
    tmp___20 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5381
    if ((unsigned int )tmp___20 != 0U) {
#line 5383
      BTDM_SetFw3a(padapter, 0, 0, 0, 8, 0);
    } else {

    }
#line 5386
    rtl8723au_write16(padapter, 2144, 272);
#line 5387
    if (BTCoexDbgLevel == 1U) {
#line 5387
      printk("[BTCoex], 0x860 = 0x110, Switch Antenna to WiFi\n");
    } else {

    }
#line 5388
    goto ldv_57393;
    }
    ldv_57393: ;
  }
#line 5392
  if (BTCoexDbgLevel == 1U) {
#line 5392
    printk("[BTCoex], Current TDMA(%s, %d)\n", (unsigned int )pBtdm8723->bCurPsTdmaOn != 0U ? (char *)"ON" : (char *)"OFF",
           (int )pBtdm8723->curPsTdma);
  } else {

  }
#line 5396
  pBtdm8723->bPrePsTdmaOn = pBtdm8723->bCurPsTdmaOn;
#line 5397
  pBtdm8723->prePsTdma = pBtdm8723->curPsTdma;
#line 5398
  return;
}
}
#line 5401 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void _btdm_1AntSetPSTDMA(struct rtw_adapter *padapter , u8 bPSEn , u8 smartps ,
                                u8 psOption , u8 bTDMAOn , u8 tdmaType ) 
{ 
  struct pwrctrl_priv *pwrctrl ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 psMode ;
  u8 bSwitchPS ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 5410
  tmp = check_fwstate(& padapter->mlmepriv, 8);
#line 5410
  if (tmp) {
#line 5410
    tmp___0 = 0;
  } else {
#line 5410
    tmp___0 = 1;
  }
#line 5410
  if (tmp___0) {
#line 5410
    tmp___1 = get_fwstate(& padapter->mlmepriv);
#line 5410
    if (tmp___1 != 0) {
#line 5412
      btdm_1AntPsTdma(padapter, (int )bTDMAOn, (int )tdmaType);
#line 5413
      return;
    } else {

    }
  } else {

  }
#line 5415
  psOption = (unsigned int )psOption & 254U;
#line 5417
  if (BTCoexDbgLevel == 1U) {
#line 5417
    printk("[BTCoex], Set LPS(%s, %d) TDMA(%s, %d)\n", (unsigned int )bPSEn == 1U ? (char *)"ON" : (char *)"OFF",
           (int )psOption, (unsigned int )bTDMAOn == 1U ? (char *)"ON" : (char *)"OFF",
           (int )tdmaType);
  } else {

  }
#line 5422
  pwrctrl = & padapter->pwrctrlpriv;
#line 5423
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5424
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
#line 5426
  if ((unsigned int )bPSEn != 0U) {
#line 5427
    if ((unsigned int )pBtdm8723->bWiFiHalt != 0U) {
#line 5428
      if (BTCoexDbgLevel == 1U) {
#line 5428
        printk("[BTCoex], Enable PS Fail, WiFi in Halt!!\n");
      } else {

      }
#line 5429
      return;
    } else {

    }
#line 5432
    if ((unsigned int )pwrctrl->bInSuspend != 0U) {
#line 5433
      if (BTCoexDbgLevel == 1U) {
#line 5433
        printk("[BTCoex], Enable PS Fail, WiFi in Suspend!!\n");
      } else {

      }
#line 5434
      return;
    } else {

    }
#line 5437
    if (padapter->bDriverStopped != 0) {
#line 5438
      if (BTCoexDbgLevel == 1U) {
#line 5438
        printk("[BTCoex], Enable PS Fail, WiFi driver stopped!!\n");
      } else {

      }
#line 5439
      return;
    } else {

    }
#line 5442
    if (padapter->bSurpriseRemoved != 0) {
#line 5443
      if (BTCoexDbgLevel == 1U) {
#line 5443
        printk("[BTCoex], Enable PS Fail, WiFi Surprise Removed!!\n");
      } else {

      }
#line 5444
      return;
    } else {

    }
#line 5447
    psMode = 1U;
  } else {
#line 5449
    psMode = 0U;
#line 5450
    psOption = 0U;
  }
#line 5453
  if ((int )pwrctrl->pwr_mode != (int )psMode) {
#line 5454
    bSwitchPS = 1U;
  } else
#line 5455
  if ((unsigned int )psMode != 0U) {
#line 5456
    if ((int )pwrctrl->bcn_ant_mode != (int )psOption) {
#line 5457
      bSwitchPS = 1U;
    } else
#line 5458
    if ((int )pwrctrl->smart_ps != (int )smartps) {
#line 5459
      bSwitchPS = 1U;
    } else {
#line 5461
      bSwitchPS = 0U;
    }
  } else {
#line 5463
    bSwitchPS = 0U;
  }
#line 5466
  if ((unsigned int )bSwitchPS != 0U) {
#line 5468
    if ((unsigned int )pBtdm8723->bCurPsTdmaOn != 0U) {
#line 5469
      if ((unsigned int )bTDMAOn == 0U) {
#line 5470
        btdm_1AntPsTdma(padapter, 0, (int )tdmaType);
      } else {
#line 5472
        tmp___2 = rtl8723a_BT_enabled(padapter);
#line 5472
        if (tmp___2) {
#line 5472
          tmp___3 = 0;
        } else {
#line 5472
          tmp___3 = 1;
        }
#line 5472
        if (((tmp___3 || (unsigned int )pHalData->bt_coexist.halCoex8723.c2hBtInfo == 1U) || (unsigned int )pHalData->bt_coexist.halCoex8723.c2hBtInfo == 2U) || (unsigned int )tdmaType == 29U) {
#line 5476
          btdm_1AntPsTdma(padapter, 0, 9);
        } else {
#line 5478
          btdm_1AntPsTdma(padapter, 0, 0);
        }
      }
    } else {

    }
#line 5483
    btdm_1AntSetPSMode(padapter, (int )bPSEn, (int )smartps, (int )psOption);
  } else {

  }
#line 5486
  btdm_1AntPsTdma(padapter, (int )bTDMAOn, (int )tdmaType);
#line 5487
  return;
}
}
#line 5490 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_1AntSetPSTDMA(struct rtw_adapter *padapter , u8 bPSEn , u8 psOption ,
                               u8 bTDMAOn , u8 tdmaType ) 
{ 


  {
#line 5493
  _btdm_1AntSetPSTDMA(padapter, (int )bPSEn, 0, (int )psOption, (int )bTDMAOn, (int )tdmaType);
#line 5494
  return;
}
}
#line 5496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_1AntWifiParaAdjust(struct rtw_adapter *padapter , u8 bEnable ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;

  {
#line 5498
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5499
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
#line 5501
  if ((unsigned int )bEnable != 0U) {
#line 5502
    pBtdm8723->curWifiPara = 1U;
#line 5503
    if ((int )pBtdm8723->preWifiPara != (int )pBtdm8723->curWifiPara) {
#line 5504
      BTDM_SetSwPenaltyTxRateAdaptive(padapter, 1);
    } else {

    }
  } else {
#line 5506
    pBtdm8723->curWifiPara = 2U;
#line 5507
    if ((int )pBtdm8723->preWifiPara != (int )pBtdm8723->curWifiPara) {
#line 5508
      BTDM_SetSwPenaltyTxRateAdaptive(padapter, 0);
    } else {

    }
  }
#line 5510
  return;
}
}
#line 5513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_1AntPtaParaReload(struct rtw_adapter *padapter ) 
{ 


  {
#line 5516
  rtl8723au_write8(padapter, 1740, 0);
#line 5517
  rtl8723au_write32(padapter, 1736, 65535U);
#line 5518
  rtl8723au_write32(padapter, 1732, 1431655765U);
#line 5521
  rtl8723au_write32(padapter, 2136, 2863311530U);
#line 5522
  if ((unsigned int )((struct hal_data_8723a *)padapter->HalData)->VersionID.ICType == 4U && (unsigned int )((struct hal_data_8723a *)padapter->HalData)->VersionID.CUTVersion == 0U) {
#line 5524
    rtl8723au_write32(padapter, 2160, 0U);
#line 5525
    rtl8723au_write8(padapter, 64, 36);
  } else {
#line 5527
    rtl8723au_write8(padapter, 64, 32);
#line 5529
    rtl8723au_write16(padapter, 2144, 528);
#line 5531
    rtl8723au_write32(padapter, 2160, 768U);
#line 5533
    rtl8723au_write32(padapter, 2164, 578830336U);
  }
#line 5537
  rtl8723au_write8(padapter, 1912, 1);
#line 5540
  btdm_SetFwIgnoreWlanAct(padapter, 0);
#line 5541
  return;
}
}
#line 5549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static s8 btdm_1AntTdmaJudgement(struct rtw_adapter *padapter , u8 retry ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  s8 up___0 ;
  s8 dn ;
  s8 m ;
  s8 n ;
  s8 WaitCount ;
  s8 ret ;

  {
#line 5553
  m = 1;
#line 5553
  n = 3;
#line 5556
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5557
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
#line 5558
  ret = 0;
#line 5560
  if (pBtdm8723->psTdmaMonitorCnt == 0U) {
#line 5561
    up___0 = 0;
#line 5562
    dn = 0;
#line 5563
    m = 1;
#line 5564
    n = 3;
#line 5565
    WaitCount = 0;
  } else {
#line 5567
    WaitCount = (s8 )((int )WaitCount + 1);
  }
#line 5570
  if ((unsigned int )retry == 0U) {
#line 5572
    up___0 = (s8 )((int )up___0 + 1);
#line 5573
    dn = (s8 )((int )dn - 1);
#line 5574
    if ((int )dn < 0) {
#line 5575
      dn = 0;
    } else {

    }
#line 5576
    if ((int )up___0 >= (int )m * 3) {
#line 5578
      ret = 1;
#line 5580
      n = 3;
#line 5581
      up___0 = 0;
#line 5582
      dn = 0;
#line 5583
      WaitCount = 0;
    } else {

    }
  } else
#line 5585
  if ((unsigned int )retry <= 3U) {
#line 5587
    up___0 = (s8 )((int )up___0 - 1);
#line 5588
    dn = (s8 )((int )dn + 1);
#line 5589
    if ((int )up___0 < 0) {
#line 5590
      up___0 = 0;
    } else {

    }
#line 5592
    if ((int )dn == 2) {
#line 5594
      ret = -1;
#line 5597
      if ((int )WaitCount <= 2) {
#line 5598
        m = (s8 )((int )m + 1);
      } else {
#line 5600
        m = 1;
      }
#line 5603
      if ((int )m > 19) {
#line 5604
        m = 20;
      } else {

      }
#line 5605
      up___0 = 0;
#line 5606
      dn = 0;
#line 5607
      WaitCount = 0;
    } else {

    }
  } else {
#line 5612
    ret = -1;
#line 5615
    if ((int )WaitCount == 1) {
#line 5616
      m = (s8 )((int )m + 1);
    } else {
#line 5618
      m = 1;
    }
#line 5619
    if ((int )m > 19) {
#line 5620
      m = 20;
    } else {

    }
#line 5622
    up___0 = 0;
#line 5623
    dn = 0;
#line 5624
    WaitCount = 0;
  }
#line 5626
  return (ret);
}
}
#line 5629 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_1AntTdmaDurationAdjustForACL(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  s32 judge ;
  s8 tmp ;

  {
#line 5631
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5632
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
#line 5634
  if (pBtdm8723->psTdmaGlobalCnt != pBtdm8723->psTdmaMonitorCnt) {
#line 5635
    pBtdm8723->psTdmaMonitorCnt = 0U;
#line 5636
    pBtdm8723->psTdmaGlobalCnt = 0U;
  } else {

  }
#line 5638
  if (pBtdm8723->psTdmaMonitorCnt == 0U) {
#line 5639
    btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 2);
#line 5640
    pBtdm8723->psTdmaDuAdjType = 2U;
  } else {
#line 5645
    if ((((unsigned int )pBtdm8723->curPsTdma != 1U && (unsigned int )pBtdm8723->curPsTdma != 2U) && (unsigned int )pBtdm8723->curPsTdma != 9U) && (unsigned int )pBtdm8723->curPsTdma != 11U) {
#line 5649
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
    } else {
#line 5651
      judge = 0;
#line 5653
      tmp = btdm_1AntTdmaJudgement(padapter, (int )pHalData->bt_coexist.halCoex8723.btRetryCnt);
#line 5653
      judge = (s32 )tmp;
#line 5654
      if (judge == -1) {
#line 5655
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
#line 5657
          if ((unsigned int )pHalData->bt_coexist.halCoex8723.btInfoExt != 0U) {
#line 5658
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {
#line 5660
            pBtdm8723->psTdmaDuAdjType = 2U;
          }
#line 5661
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
        } else
#line 5662
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 5663
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 9);
#line 5664
          pBtdm8723->psTdmaDuAdjType = 9U;
        } else
#line 5665
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 5666
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 11);
#line 5667
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else {

        }
      } else
#line 5669
      if (judge == 1) {
#line 5670
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 5671
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 9);
#line 5672
          pBtdm8723->psTdmaDuAdjType = 9U;
        } else
#line 5673
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 5674
          if ((unsigned int )pHalData->bt_coexist.halCoex8723.btInfoExt != 0U) {
#line 5675
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {
#line 5677
            pBtdm8723->psTdmaDuAdjType = 2U;
          }
#line 5678
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
        } else
#line 5679
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 5680
          if ((unsigned int )pHalData->bt_coexist.halCoex8723.btInfoExt != 0U) {
#line 5681
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {
#line 5683
            pBtdm8723->psTdmaDuAdjType = 1U;
          }
#line 5684
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
        } else {

        }
      } else {

      }
    }
#line 5688
    if (BTCoexDbgLevel == 1U) {
#line 5688
      printk("[BTCoex], ACL current TDMA(%s, %d)\n", (unsigned int )pBtdm8723->bCurPsTdmaOn != 0U ? (char *)"ON" : (char *)"OFF",
             (int )pBtdm8723->curPsTdma);
    } else {

    }
  }
#line 5692
  pBtdm8723->psTdmaMonitorCnt = pBtdm8723->psTdmaMonitorCnt + 1U;
#line 5693
  return;
}
}
#line 5695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_1AntCoexProcessForWifiConnect(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 BtState ;
  u8 tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 5703
  pmlmepriv = & padapter->mlmepriv;
#line 5704
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5705
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 5706
  pBtdm8723 = & pBtCoex->btdm1Ant;
#line 5707
  BtState = pBtCoex->c2hBtInfo;
#line 5709
  if (BTCoexDbgLevel == 1U) {
#line 5709
    tmp = BTDM_IsWifiBusy(padapter);
#line 5709
    printk("[BTCoex], WiFi is %s\n", (unsigned int )tmp != 0U ? (char *)"Busy" : (char *)"IDLE");
  } else {

  }
#line 5711
  if (BTCoexDbgLevel == 1U) {
#line 5711
    printk("[BTCoex], BT is %s\n", BtStateString[(int )BtState]);
  } else {

  }
#line 5714
  padapter->pwrctrlpriv.btcoex_rfon = 0U;
#line 5716
  tmp___0 = BTDM_IsWifiBusy(padapter);
#line 5716
  if ((unsigned int )tmp___0 == 0U) {
#line 5716
    tmp___1 = check_fwstate(& padapter->mlmepriv, 16);
#line 5716
    if (tmp___1) {
#line 5716
      tmp___2 = 0;
    } else {
#line 5716
      tmp___2 = 1;
    }
#line 5716
    if (tmp___2) {
#line 5716
      if ((unsigned int )BtState == 1U || (unsigned int )BtState == 2U) {
#line 5720
        switch ((int )BtState) {
        case 1: 
#line 5722
        _btdm_1AntSetPSTDMA(padapter, 1, 2, 38, 0, 9);
#line 5723
        goto ldv_57453;
        case 2: 
#line 5725
        _btdm_1AntSetPSTDMA(padapter, 1, 2, 38, 0, 0);
#line 5726
        goto ldv_57453;
        }
        ldv_57453: ;
      } else {
#line 5716
        goto _L___0;
      }
    } else {
#line 5716
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 5729
    switch ((int )BtState) {
    case 1: ;
    case 2: 
#line 5733
    btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 5);
#line 5734
    rtl8723au_write32(padapter, 1728, 1515870810U);
#line 5735
    rtl8723au_write32(padapter, 1732, 1515870810U);
#line 5736
    goto ldv_57457;
    case 7: ;
#line 5738
    if (BTCoexDbgLevel == 1U) {
#line 5738
      printk("[BTCoex], BT PROFILE is BT_INFO_STATE_ACL_INQ_OR_PAG\n");
    } else {

    }
    case 3: 
#line 5742
    padapter->pwrctrlpriv.btcoex_rfon = 1U;
#line 5743
    btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 30);
#line 5744
    goto ldv_57457;
    case 5: ;
    case 6: ;
#line 5747
    if ((unsigned int )pBtCoex->bC2hBtInquiryPage == 1U) {
#line 5748
      btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 32);
    } else {
#line 5755
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 8);
#line 5757
      rtl8723au_write32(padapter, 1728, 1515870810U);
#line 5758
      rtl8723au_write32(padapter, 1732, 1515870810U);
    }
#line 5761
    goto ldv_57457;
    case 4: 
#line 5763
    padapter->pwrctrlpriv.btcoex_rfon = 1U;
#line 5764
    if ((unsigned int )pBtCoex->c2hBtProfile == 32U) {
#line 5765
      if (BTCoexDbgLevel == 1U) {
#line 5765
        printk("[BTCoex], BT PROFILE is HID\n");
      } else {

      }
#line 5767
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 31);
    } else
#line 5768
    if ((unsigned int )pBtCoex->c2hBtProfile == 128U) {
#line 5769
      if (BTCoexDbgLevel == 1U) {
#line 5769
        printk("[BTCoex], BT PROFILE is FTP/OPP\n");
      } else {

      }
#line 5771
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 3);
    } else
#line 5772
    if ((unsigned int )pBtCoex->c2hBtProfile == 192U) {
#line 5773
      if (BTCoexDbgLevel == 1U) {
#line 5773
        printk("[BTCoex], BT PROFILE is A2DP_FTP\n");
      } else {

      }
#line 5775
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 11);
    } else {
#line 5777
      if ((unsigned int )pBtCoex->c2hBtProfile == 64U) {
#line 5778
        if (BTCoexDbgLevel == 1U) {
#line 5778
          printk("[BTCoex], BT PROFILE is A2DP\n");
        } else {

        }
      } else
#line 5782
      if (BTCoexDbgLevel == 1U) {
#line 5782
        printk("[BTCoex], BT PROFILE is UNKNOWN(0x%02X)! Use A2DP Profile\n", (int )pBtCoex->c2hBtProfile);
      } else {

      }
#line 5787
      btdm_1AntTdmaDurationAdjustForACL(padapter);
    }
#line 5789
    goto ldv_57457;
    }
    ldv_57457: ;
  }
#line 5793
  pBtdm8723->psTdmaGlobalCnt = pBtdm8723->psTdmaGlobalCnt + 1U;
#line 5794
  return;
}
}
#line 5797 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_1AntUpdateHalRAMask(struct rtw_adapter *padapter , u32 mac_id , u32 filter ) 
{ 
  u8 init_rate ;
  u8 raid ;
  u8 arg ;
  u32 mask ;
  u8 shortGIrate ;
  int supportRateNum ;
  struct sta_info *psta ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  uint tmp ;
  unsigned int tmp___0 ;
  u32 tmp___1 ;
  int tmp___2 ;
  uint tmp___3 ;
  uint tmp___4 ;
  unsigned char tmp___5 ;

  {
#line 5799
  init_rate = 0U;
#line 5802
  shortGIrate = 0U;
#line 5803
  supportRateNum = 0;
#line 5811
  if (BTCoexDbgLevel == 1U) {
#line 5811
    printk("[BTCoex], %s, MACID =%d, filter = 0x%08x!!\n", "btdm_1AntUpdateHalRAMask",
           mac_id, filter);
  } else {

  }
#line 5814
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5815
  pdmpriv = & pHalData->dmpriv;
#line 5816
  pmlmeext = & padapter->mlmeextpriv;
#line 5817
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5818
  cur_network = & pmlmeinfo->network;
#line 5820
  if (mac_id > 31U) {
#line 5821
    if (BTCoexDbgLevel == 1U) {
#line 5821
      printk("[BTCoex], %s, MACID =%d illegal!!\n", "btdm_1AntUpdateHalRAMask", mac_id);
    } else {

    }
#line 5823
    return;
  } else {

  }
#line 5826
  psta = pmlmeinfo->FW_sta_info[mac_id].psta;
#line 5827
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 5828
    if (BTCoexDbgLevel == 1U) {
#line 5828
      printk("[BTCoex], %s, Can\'t find station!!\n", "btdm_1AntUpdateHalRAMask");
    } else {

    }
#line 5830
    return;
  } else {

  }
#line 5833
  raid = psta->raid;
#line 5835
  switch (mac_id) {
  case 0U: 
#line 5837
  tmp = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
#line 5837
  supportRateNum = (int )tmp;
#line 5839
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
#line 5841
  if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
#line 5841
    tmp___0 = update_MSC_rate23a(& pmlmeinfo->ht_cap);
#line 5841
    tmp___1 = tmp___0;
  } else {
#line 5841
    tmp___1 = 0U;
  }
#line 5841
  mask = tmp___1 | mask;
#line 5843
  tmp___2 = support_short_GI23a(padapter, & pmlmeinfo->ht_cap);
#line 5843
  if (tmp___2 != 0) {
#line 5844
    shortGIrate = 1U;
  } else {

  }
#line 5845
  goto ldv_57482;
  case 1U: 
#line 5847
  tmp___3 = rtw_get_rateset_len23a((u8 *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates));
#line 5847
  supportRateNum = (int )tmp___3;
#line 5849
  mask = update_basic_rate23a((unsigned char *)(& cur_network->SupportedRates), (unsigned int )supportRateNum);
#line 5851
  goto ldv_57482;
  default: 
#line 5853
  tmp___4 = rtw_get_rateset_len23a((u8 *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates));
#line 5853
  supportRateNum = (int )tmp___4;
#line 5855
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
#line 5857
  goto ldv_57482;
  }
  ldv_57482: 
#line 5859
  mask = (u32 )((int )raid << 28) | mask;
#line 5860
  mask = mask;
#line 5861
  mask = ~ filter & mask;
#line 5862
  tmp___5 = get_highest_rate_idx23a(mask);
#line 5862
  init_rate = (unsigned int )tmp___5 & 63U;
#line 5864
  arg = (unsigned int )((u8 )mac_id) & 31U;
#line 5865
  arg = (u8 )((unsigned int )arg | 128U);
#line 5866
  if ((unsigned int )shortGIrate == 1U) {
#line 5867
    arg = (u8 )((unsigned int )arg | 32U);
  } else {

  }
#line 5869
  if (BTCoexDbgLevel == 1U) {
#line 5869
    printk("[BTCoex], Update FW RAID entry, MASK = 0x%08x, arg = 0x%02x\n", mask,
           (int )arg);
  } else {

  }
#line 5873
  rtl8723a_set_raid_cmd(padapter, mask, (int )arg);
#line 5875
  psta->init_rate = init_rate;
#line 5876
  pdmpriv->INIDATA_RATE[mac_id] = init_rate;
#line 5877
  return;
}
}
#line 5880 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_1AntUpdateHalRAMaskForSCO(struct rtw_adapter *padapter , u8 forceUpdate ) 
{ 
  struct btdm_8723a_1ant *pBtdm8723 ;
  struct sta_priv *pstapriv ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_info *psta ;
  u32 macid ;
  u32 filter ;

  {
#line 5887
  filter = 0U;
#line 5889
  pBtdm8723 = & ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant;
#line 5891
  if ((unsigned int )pBtdm8723->bRAChanged == 1U && (unsigned int )forceUpdate == 0U) {
#line 5892
    return;
  } else {

  }
#line 5894
  pstapriv = & padapter->stapriv;
#line 5895
  cur_network = & padapter->mlmeextpriv.mlmext_info.network;
#line 5896
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->MacAddress));
#line 5897
  macid = psta->mac_id;
#line 5899
  filter = filter | 1U;
#line 5900
  filter = filter | 2U;
#line 5901
  filter = filter | 4U;
#line 5902
  filter = filter | 8U;
#line 5903
  filter = filter | 16U;
#line 5904
  filter = filter | 32U;
#line 5906
  btdm_1AntUpdateHalRAMask(padapter, macid, filter);
#line 5908
  pBtdm8723->bRAChanged = 1U;
#line 5909
  return;
}
}
#line 5911 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_1AntRecoverHalRAMask(struct rtw_adapter *padapter ) 
{ 
  struct btdm_8723a_1ant *pBtdm8723 ;
  struct sta_priv *pstapriv ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_info *psta ;

  {
#line 5918
  pBtdm8723 = & ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant;
#line 5920
  if ((unsigned int )pBtdm8723->bRAChanged == 0U) {
#line 5921
    return;
  } else {

  }
#line 5923
  pstapriv = & padapter->stapriv;
#line 5924
  cur_network = & padapter->mlmeextpriv.mlmext_info.network;
#line 5925
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->MacAddress));
#line 5927
  Update_RA_Entry23a(padapter, psta);
#line 5929
  pBtdm8723->bRAChanged = 0U;
#line 5930
  return;
}
}
#line 5933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_1AntBTStateChangeHandler(struct rtw_adapter *padapter , enum bt_state_1ant oldState ,
                                          enum bt_state_1ant newState ) 
{ 
  struct hal_data_8723a *phaldata ;
  bool tmp ;
  u8 tmp___0 ;
  struct hal_data_8723a *Hal ;
  struct hal_data_8723a *Hal___0 ;

  {
#line 5938
  if (BTCoexDbgLevel == 1U) {
#line 5938
    printk("[BTCoex], BT state change, %s => %s\n", BtStateString[(unsigned int )oldState],
           BtStateString[(unsigned int )newState]);
  } else {

  }
#line 5944
  if ((unsigned int )newState != 0U) {
#line 5945
    btdm_SetFwIgnoreWlanAct(padapter, 0);
  } else {

  }
#line 5947
  tmp = check_fwstate(& padapter->mlmepriv, 8);
#line 5947
  if ((int )tmp) {
#line 5947
    tmp___0 = BTDM_IsWifiConnectionExist(padapter);
#line 5947
    if ((unsigned int )tmp___0 != 0U) {
#line 5949
      if ((unsigned int )newState == 5U || (unsigned int )newState == 6U) {
#line 5951
        btdm_1AntUpdateHalRAMaskForSCO(padapter, 0);
      } else {
#line 5954
        btdm_1AntRecoverHalRAMask(padapter);
      }
    } else {
#line 5957
      phaldata = (struct hal_data_8723a *)padapter->HalData;
#line 5958
      phaldata->bt_coexist.halCoex8723.btdm1Ant.bRAChanged = 0U;
    }
  } else {
#line 5957
    phaldata = (struct hal_data_8723a *)padapter->HalData;
#line 5958
    phaldata->bt_coexist.halCoex8723.btdm1Ant.bRAChanged = 0U;
  }
#line 5961
  if ((unsigned int )oldState == (unsigned int )newState) {
#line 5962
    return;
  } else {

  }
#line 5964
  if ((unsigned int )oldState == 4U) {
#line 5965
    Hal = (struct hal_data_8723a *)padapter->HalData;
#line 5966
    Hal->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCnt = 0U;
#line 5967
    Hal->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCntForSCO = 0U;
  } else {

  }
#line 5970
  if ((unsigned int )oldState == 5U || (unsigned int )oldState == 6U) {
#line 5972
    Hal___0 = (struct hal_data_8723a *)padapter->HalData;
#line 5973
    Hal___0->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCntForSCO = 0U;
  } else {

  }
#line 5977
  if ((unsigned int )oldState == 0U || (unsigned int )oldState == 1U) {
#line 5979
    if ((unsigned int )newState != 0U && (unsigned int )newState != 1U) {
#line 5981
      BTDM_SetSwRfRxLpfCorner(padapter, 1);
#line 5983
      BTDM_AGCTable(padapter, 1);
#line 5984
      BTDM_BBBackOffLevel(padapter, 1);
    } else {

    }
  } else
#line 5987
  if ((unsigned int )newState == 0U || (unsigned int )newState == 1U) {
#line 5989
    BTDM_SetSwRfRxLpfCorner(padapter, 0);
#line 5991
    BTDM_AGCTable(padapter, 0);
#line 5992
    BTDM_BBBackOffLevel(padapter, 0);
  } else {

  }
#line 5994
  return;
}
}
#line 5997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_1AntBtCoexistHandler(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex8723 ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 6003
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6004
  pBtCoex8723 = & pHalData->bt_coexist.halCoex8723;
#line 6005
  pBtdm8723 = & pBtCoex8723->btdm1Ant;
#line 6006
  padapter->pwrctrlpriv.btcoex_rfon = 0U;
#line 6007
  tmp___2 = rtl8723a_BT_enabled(padapter);
#line 6007
  if (tmp___2) {
#line 6007
    tmp___3 = 0;
  } else {
#line 6007
    tmp___3 = 1;
  }
#line 6007
  if (tmp___3) {
#line 6008
    if (BTCoexDbgLevel == 1U) {
#line 6008
      printk("[BTCoex], BT is disabled\n");
    } else {

    }
#line 6010
    tmp___0 = BTDM_IsWifiConnectionExist(padapter);
#line 6010
    if ((unsigned int )tmp___0 != 0U) {
#line 6011
      if (BTCoexDbgLevel == 1U) {
#line 6011
        printk("[BTCoex], wifi is connected\n");
      } else {

      }
#line 6014
      tmp = BTDM_IsWifiBusy(padapter);
#line 6014
      if ((unsigned int )tmp != 0U) {
#line 6015
        if (BTCoexDbgLevel == 1U) {
#line 6015
          printk("[BTCoex], Wifi is busy\n");
        } else {

        }
#line 6017
        btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
      } else {
#line 6020
        if (BTCoexDbgLevel == 1U) {
#line 6020
          printk("[BTCoex], Wifi is idle\n");
        } else {

        }
#line 6022
        _btdm_1AntSetPSTDMA(padapter, 1, 2, 1, 0, 9);
      }
    } else {
#line 6026
      if (BTCoexDbgLevel == 1U) {
#line 6026
        printk("[BTCoex], wifi is disconnected\n");
      } else {

      }
#line 6029
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
    }
  } else {
#line 6032
    if (BTCoexDbgLevel == 1U) {
#line 6032
      printk("[BTCoex], BT is enabled\n");
    } else {

    }
#line 6034
    tmp___1 = BTDM_IsWifiConnectionExist(padapter);
#line 6034
    if ((unsigned int )tmp___1 != 0U) {
#line 6035
      if (BTCoexDbgLevel == 1U) {
#line 6035
        printk("[BTCoex], wifi is connected\n");
      } else {

      }
#line 6038
      btdm_1AntWifiParaAdjust(padapter, 1);
#line 6039
      btdm_1AntCoexProcessForWifiConnect(padapter);
    } else {
#line 6041
      if (BTCoexDbgLevel == 1U) {
#line 6041
        printk("[BTCoex], wifi is disconnected\n");
      } else {

      }
#line 6046
      btdm_1AntWifiParaAdjust(padapter, 0);
#line 6047
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 0);
    }
  }
#line 6051
  btdm_1AntBTStateChangeHandler(padapter, (enum bt_state_1ant )pBtCoex8723->prec2hBtInfo,
                                (enum bt_state_1ant )pBtCoex8723->c2hBtInfo);
#line 6053
  pBtCoex8723->prec2hBtInfo = pBtCoex8723->c2hBtInfo;
#line 6054
  return;
}
}
#line 6056 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_1AntSignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 RSSI_WiFi_Cmpnstn ;
  u8 RSSI_BT_Cmpnstn ;

  {
#line 6063
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6064
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
#line 6065
  RSSI_WiFi_Cmpnstn = 0U;
#line 6066
  RSSI_BT_Cmpnstn = 0U;
#line 6068
  switch ((int )pBtdm8723->curPsTdma) {
  case 1: 
#line 6070
  RSSI_WiFi_Cmpnstn = 11U;
#line 6071
  goto ldv_57526;
  case 2: 
#line 6073
  RSSI_WiFi_Cmpnstn = 14U;
#line 6074
  goto ldv_57526;
  case 9: 
#line 6076
  RSSI_WiFi_Cmpnstn = 18U;
#line 6077
  goto ldv_57526;
  case 11: 
#line 6079
  RSSI_WiFi_Cmpnstn = 20U;
#line 6080
  goto ldv_57526;
  case 4: 
#line 6082
  RSSI_WiFi_Cmpnstn = 17U;
#line 6083
  goto ldv_57526;
  case 16: 
#line 6085
  RSSI_WiFi_Cmpnstn = 18U;
#line 6086
  goto ldv_57526;
  case 18: 
#line 6088
  RSSI_WiFi_Cmpnstn = 14U;
#line 6089
  goto ldv_57526;
  case 23: ;
  case 24: ;
  case 25: ;
  case 26: ;
  case 27: ;
  case 33: 
#line 6096
  RSSI_WiFi_Cmpnstn = 22U;
#line 6097
  goto ldv_57526;
  default: ;
#line 6099
  goto ldv_57526;
  }
  ldv_57526: ;
#line 6102
  if ((unsigned long )rssi_wifi != (unsigned long )((u8 *)0U) && (unsigned int )RSSI_WiFi_Cmpnstn != 0U) {
#line 6103
    if (BTCoexDbgLevel == 1U) {
#line 6103
      printk("[BTCoex], 1AntSgnlCmpnstn, case %d, WiFiCmpnstn =%d(%d => %d)\n", (int )pBtdm8723->curPsTdma,
             (int )RSSI_WiFi_Cmpnstn, (int )*rssi_wifi, (int )*rssi_wifi + (int )RSSI_WiFi_Cmpnstn);
    } else {

    }
#line 6108
    *rssi_wifi = (int )*rssi_wifi + (int )RSSI_WiFi_Cmpnstn;
  } else {

  }
#line 6111
  if ((unsigned long )rssi_bt != (unsigned long )((u8 *)0U) && (unsigned int )RSSI_BT_Cmpnstn != 0U) {
#line 6112
    if (BTCoexDbgLevel == 1U) {
#line 6112
      printk("[BTCoex], 1AntSgnlCmpnstn, case %d, BTCmpnstn =%d(%d => %d)\n", (int )pBtdm8723->curPsTdma,
             (int )RSSI_BT_Cmpnstn, (int )*rssi_bt, (int )*rssi_bt + (int )RSSI_BT_Cmpnstn);
    } else {

    }
#line 6116
    *rssi_bt = (int )*rssi_bt + (int )RSSI_BT_Cmpnstn;
  } else {

  }
#line 6118
  return;
}
}
#line 6120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_1AntParaInit(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;

  {
#line 6126
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6127
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 6128
  pBtdm8723 = & pBtCoex->btdm1Ant;
#line 6131
  rtl8723au_write8(padapter, 1902, 4);
#line 6132
  btdm_1AntPtaParaReload(padapter);
#line 6134
  pBtdm8723->wifiRssiThresh = 48U;
#line 6136
  pBtdm8723->bWiFiHalt = 0U;
#line 6137
  pBtdm8723->bRAChanged = 0U;
#line 6139
  if ((unsigned int )pBtCoex->c2hBtInfo != 0U && (unsigned int )pBtCoex->c2hBtInfo != 1U) {
#line 6141
    BTDM_SetSwRfRxLpfCorner(padapter, 1);
#line 6142
    BTDM_AGCTable(padapter, 1);
#line 6143
    BTDM_BBBackOffLevel(padapter, 1);
  } else {

  }
#line 6145
  return;
}
}
#line 6147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_1AntForHalt(struct rtw_adapter *padapter ) 
{ 


  {
#line 6149
  if (BTCoexDbgLevel == 1U) {
#line 6149
    printk("\n[BTCoex], 1Ant for halt\n");
  } else {

  }
#line 6151
  ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant.bWiFiHalt = 1U;
#line 6154
  btdm_1AntWifiParaAdjust(padapter, 0);
#line 6160
  btdm_1AntPsTdma(padapter, 0, 0);
#line 6162
  btdm_SetFwIgnoreWlanAct(padapter, 1);
#line 6163
  return;
}
}
#line 6165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_1AntLpsLeave(struct rtw_adapter *padapter ) 
{ 


  {
#line 6167
  if (BTCoexDbgLevel == 1U) {
#line 6167
    printk("\n[BTCoex], 1Ant for LPS Leave\n");
  } else {

  }
#line 6170
  ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant.bWiFiHalt = 1U;
#line 6173
  btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 8);
#line 6174
  return;
}
}
#line 6177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_1AntWifiAssociateNotify(struct rtw_adapter *padapter , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 BtState ;
  bool tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 6179
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6181
  if (BTCoexDbgLevel == 1U) {
#line 6181
    printk("\n[BTCoex], 1Ant for associate, type =%d\n", (int )type);
  } else {

  }
#line 6184
  if ((unsigned int )type != 0U) {
#line 6185
    rtl8723a_CheckAntenna_Selection(padapter);
#line 6186
    tmp = rtl8723a_BT_enabled(padapter);
#line 6186
    if (tmp) {
#line 6186
      tmp___0 = 0;
    } else {
#line 6186
      tmp___0 = 1;
    }
#line 6186
    if (tmp___0) {
#line 6187
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
    } else {
#line 6192
      pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 6193
      BtState = pBtCoex->c2hBtInfo;
#line 6195
      btdm_1AntTSFSwitch(padapter, 1);
#line 6197
      if ((unsigned int )BtState == 1U || (unsigned int )BtState == 2U) {
#line 6199
        btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 28);
      } else
#line 6201
      if ((unsigned int )BtState == 5U || (unsigned int )BtState == 6U) {
#line 6203
        btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 8);
#line 6205
        rtl8723au_write32(padapter, 1728, 1515870810U);
#line 6206
        rtl8723au_write32(padapter, 1732, 1515870810U);
      } else
#line 6207
      if ((unsigned int )BtState == 4U || (unsigned int )BtState == 7U) {
#line 6209
        if ((unsigned int )pBtCoex->c2hBtProfile == 32U) {
#line 6210
          btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 35);
        } else {
#line 6213
          btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 29);
        }
      } else {

      }
    }
  } else {
#line 6218
    tmp___2 = rtl8723a_BT_enabled(padapter);
#line 6218
    if (tmp___2) {
#line 6218
      tmp___3 = 0;
    } else {
#line 6218
      tmp___3 = 1;
    }
#line 6218
    if (tmp___3) {
#line 6219
      tmp___1 = BTDM_IsWifiConnectionExist(padapter);
#line 6219
      if ((unsigned int )tmp___1 == 0U) {
#line 6220
        btdm_1AntPsTdma(padapter, 0, 0);
#line 6221
        btdm_1AntTSFSwitch(padapter, 0);
      } else {

      }
    } else {

    }
#line 6225
    btdm_1AntBtCoexistHandler(padapter);
  }
#line 6227
  return;
}
}
#line 6230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_1AntMediaStatusNotify(struct rtw_adapter *padapter , enum rt_media_status mstatus ) 
{ 
  struct bt_coexist_8723a *pBtCoex ;
  bool tmp ;

  {
#line 6235
  pBtCoex = & ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723;
#line 6237
  if (BTCoexDbgLevel == 1U) {
#line 6237
    printk("\n\n[BTCoex]******************************\n");
  } else {

  }
#line 6239
  if (BTCoexDbgLevel == 1U) {
#line 6239
    printk("[BTCoex], MediaStatus, WiFi %s !!\n", (unsigned int )mstatus == 1U ? (char *)"CONNECT" : (char *)"DISCONNECT");
  } else {

  }
#line 6241
  if (BTCoexDbgLevel == 1U) {
#line 6241
    printk("[BTCoex]******************************\n");
  } else {

  }
#line 6243
  if ((unsigned int )mstatus == 1U) {
#line 6244
    tmp = check_fwstate(& padapter->mlmepriv, 8);
#line 6244
    if ((int )tmp) {
#line 6245
      if ((unsigned int )pBtCoex->c2hBtInfo == 5U || (unsigned int )pBtCoex->c2hBtInfo == 6U) {
#line 6247
        btdm_1AntUpdateHalRAMaskForSCO(padapter, 1);
      } else {

      }
    } else {

    }
#line 6250
    padapter->pwrctrlpriv.DelayLPSLastTimeStamp = jiffies;
#line 6251
    BTDM_1AntForDhcp(padapter);
  } else {
#line 6255
    rtl8723a_DeinitAntenna_Selection(padapter);
#line 6256
    btdm_1AntBtCoexistHandler(padapter);
#line 6257
    pBtCoex->btdm1Ant.bRAChanged = 0U;
  }
#line 6259
  return;
}
}
#line 6261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_1AntForDhcp(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 BtState ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;

  {
#line 6268
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6269
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 6270
  BtState = pBtCoex->c2hBtInfo;
#line 6271
  pBtdm8723 = & pBtCoex->btdm1Ant;
#line 6273
  if (BTCoexDbgLevel == 1U) {
#line 6273
    printk("\n[BTCoex], 1Ant for DHCP\n");
  } else {

  }
#line 6274
  if (BTCoexDbgLevel == 1U) {
#line 6274
    tmp = BTDM_IsWifiBusy(padapter);
#line 6274
    printk("[BTCoex], 1Ant for DHCP, WiFi is %s\n", (unsigned int )tmp != 0U ? (char *)"Busy" : (char *)"IDLE");
  } else {

  }
#line 6276
  if (BTCoexDbgLevel == 1U) {
#line 6276
    printk("[BTCoex], 1Ant for DHCP, %s\n", BtStateString[(int )BtState]);
  } else {

  }
#line 6279
  BTDM_1AntWifiAssociateNotify(padapter, 1);
#line 6280
  return;
}
}
#line 6282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_1AntWifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 BtState ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 6289
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6290
  BtState = pHalData->bt_coexist.halCoex8723.c2hBtInfo;
#line 6291
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 6292
  pBtdm8723 = & pBtCoex->btdm1Ant;
#line 6294
  if (BTCoexDbgLevel == 1U) {
#line 6294
    printk("\n[BTCoex], 1Ant for wifi scan =%d!!\n", (int )scanType);
  } else {

  }
#line 6296
  if (BTCoexDbgLevel == 1U) {
#line 6296
    tmp = BTDM_IsWifiBusy(padapter);
#line 6296
    printk("[BTCoex], 1Ant for wifi scan, WiFi is %s\n", (unsigned int )tmp != 0U ? (char *)"Busy" : (char *)"IDLE");
  } else {

  }
#line 6298
  if (BTCoexDbgLevel == 1U) {
#line 6298
    printk("[BTCoex], 1Ant for wifi scan, %s\n", BtStateString[(int )BtState]);
  } else {

  }
#line 6301
  if ((unsigned int )scanType != 0U) {
#line 6302
    rtl8723a_CheckAntenna_Selection(padapter);
#line 6303
    tmp___1 = rtl8723a_BT_enabled(padapter);
#line 6303
    if (tmp___1) {
#line 6303
      tmp___2 = 0;
    } else {
#line 6303
      tmp___2 = 1;
    }
#line 6303
    if (tmp___2) {
#line 6304
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
    } else {
#line 6305
      tmp___0 = BTDM_IsWifiConnectionExist(padapter);
#line 6305
      if ((unsigned int )tmp___0 == 0U) {
#line 6306
        BTDM_1AntWifiAssociateNotify(padapter, 1);
      } else
#line 6308
      if ((unsigned int )BtState == 5U || (unsigned int )BtState == 6U) {
#line 6310
        if ((unsigned int )pBtCoex->bC2hBtInquiryPage != 0U) {
#line 6311
          btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 32);
        } else {
#line 6314
          padapter->pwrctrlpriv.btcoex_rfon = 1U;
#line 6316
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 33);
        }
      } else
#line 6319
      if ((unsigned int )pBtCoex->bC2hBtInquiryPage == 1U) {
#line 6320
        padapter->pwrctrlpriv.btcoex_rfon = 1U;
#line 6321
        btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 30);
      } else
#line 6322
      if ((unsigned int )BtState == 4U) {
#line 6323
        padapter->pwrctrlpriv.btcoex_rfon = 1U;
#line 6324
        if ((unsigned int )pBtCoex->c2hBtProfile == 32U) {
#line 6325
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 34);
        } else {
#line 6328
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 4);
        }
      } else {
#line 6331
        padapter->pwrctrlpriv.btcoex_rfon = 1U;
#line 6332
        btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 5);
      }
    }
#line 6336
    btdm_NotifyFwScan(padapter, 1);
  } else {
#line 6339
    btdm_NotifyFwScan(padapter, 0);
#line 6340
    btdm_1AntBtCoexistHandler(padapter);
  }
#line 6342
  return;
}
}
#line 6344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_1AntFwC2hBtInfo8723A(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 u1tmp ;
  u8 btState ;

  {
#line 6352
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6353
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 6354
  pBtMgnt = & pBTInfo->BtMgnt;
#line 6355
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 6357
  u1tmp = pBtCoex->c2hBtInfoOriginal;
#line 6359
  btState = (unsigned int )u1tmp & 15U;
#line 6360
  pBtCoex->c2hBtProfile = (unsigned int )u1tmp & 224U;
#line 6363
  pBtMgnt->ExtConfig.bBTBusy = 0U;
#line 6364
  pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4096ULL;
#line 6367
  if (((unsigned long )btState & 4UL) != 0UL) {
#line 6368
    pBtCoex->bC2hBtInquiryPage = 1U;
  } else {
#line 6370
    pBtCoex->bC2hBtInquiryPage = 0U;
  }
#line 6371
  btState = (unsigned int )btState & 251U;
#line 6373
  if (((unsigned long )btState & 1UL) == 0UL) {
#line 6374
    pBtCoex->c2hBtInfo = 1U;
  } else {
#line 6376
    if ((unsigned int )btState == 1U) {
#line 6377
      pBtCoex->c2hBtInfo = 2U;
    } else
#line 6378
    if ((unsigned int )btState == 9U) {
#line 6379
      if ((unsigned int )pBtCoex->bC2hBtInquiryPage == 1U) {
#line 6380
        pBtCoex->c2hBtInfo = 7U;
      } else {
#line 6383
        pBtCoex->c2hBtInfo = 4U;
      }
#line 6385
      pBtMgnt->ExtConfig.bBTBusy = 1U;
    } else
#line 6386
    if ((unsigned int )btState == 3U) {
#line 6387
      pBtCoex->c2hBtInfo = 5U;
#line 6388
      pBtMgnt->ExtConfig.bBTBusy = 1U;
    } else
#line 6389
    if ((unsigned int )btState == 11U) {
#line 6390
      pBtCoex->c2hBtInfo = 6U;
#line 6391
      pBtMgnt->ExtConfig.bBTBusy = 1U;
    } else {
#line 6393
      pBtCoex->c2hBtInfo = 8U;
    }
#line 6394
    if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy != 0U) {
#line 6395
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffefffULL;
    } else {

    }
  }
#line 6399
  if ((unsigned int )pBtCoex->c2hBtInfo == 1U || (unsigned int )pBtCoex->c2hBtInfo == 2U) {
#line 6401
    if ((unsigned int )pBtCoex->bC2hBtInquiryPage != 0U) {
#line 6402
      pBtCoex->c2hBtInfo = 3U;
    } else {

    }
  } else {

  }
#line 6405
  if (BTCoexDbgLevel == 1U) {
#line 6405
    printk("[BTC2H], %s(%d)\n", BtStateString[(int )pBtCoex->c2hBtInfo], (int )pBtCoex->c2hBtInfo);
  } else {

  }
#line 6408
  if ((unsigned int )pBtCoex->c2hBtProfile != 32U) {
#line 6409
    pBtCoex->c2hBtProfile = (unsigned int )pBtCoex->c2hBtProfile & 223U;
  } else {

  }
#line 6410
  return;
}
}
#line 6412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_1AntBtCoexist8723A(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  unsigned long delta_time ;
  bool tmp ;
  bool tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 6418
  pmlmepriv = & padapter->mlmepriv;
#line 6419
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6421
  tmp = check_fwstate(pmlmepriv, 2048);
#line 6421
  if ((int )tmp) {
#line 6423
    if (BTCoexDbgLevel == 1U) {
#line 6423
      printk("[BTCoex], wifi is under scan progress!!\n");
    } else {

    }
#line 6425
    return;
  } else {

  }
#line 6428
  tmp___0 = check_fwstate(pmlmepriv, 128);
#line 6428
  if ((int )tmp___0) {
#line 6429
    if (BTCoexDbgLevel == 1U) {
#line 6429
      printk("[BTCoex], wifi is under link progress!!\n");
    } else {

    }
#line 6431
    return;
  } else {

  }
#line 6435
  delta_time = (unsigned long )jiffies - padapter->pwrctrlpriv.DelayLPSLastTimeStamp;
#line 6436
  tmp___1 = jiffies_to_msecs(delta_time);
#line 6436
  delta_time = (unsigned long )tmp___1;
#line 6437
  if (delta_time <= 499UL) {
#line 6438
    if (BTCoexDbgLevel == 1U) {
#line 6438
      printk("[BTCoex], wifi is under DHCP progress(%li ms)!!\n", delta_time);
    } else {

    }
#line 6440
    return;
  } else {

  }
#line 6443
  BTDM_CheckWiFiState(padapter);
#line 6445
  btdm_1AntBtCoexistHandler(padapter);
#line 6446
  return;
}
}
#line 6453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 btdm_ActionAlgorithm(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 bScoExist ;
  u8 bBtLinkExist ;
  u8 bBtHsModeExist ;
  u8 algorithm ;
  u32 tmp ;
  u8 tmp___0 ;
  u32 tmp___1 ;
  u8 tmp___2 ;
  u32 tmp___3 ;
  u8 tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___6 ;
  u8 tmp___7 ;
  u8 tmp___8 ;
  u8 tmp___9 ;
  u8 tmp___10 ;
  u8 tmp___11 ;
  u8 tmp___12 ;
  u8 tmp___13 ;
  u8 tmp___14 ;
  u8 tmp___15 ;
  u8 tmp___16 ;
  u8 tmp___17 ;
  u8 tmp___18 ;
  u8 tmp___19 ;
  u8 tmp___20 ;
  u8 tmp___21 ;
  u8 tmp___22 ;
  u8 tmp___23 ;
  u8 tmp___24 ;
  u8 tmp___25 ;
  u8 tmp___26 ;
  u8 tmp___27 ;
  u8 tmp___28 ;
  u8 tmp___29 ;
  u8 tmp___30 ;

  {
#line 6455
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 6456
  pBtMgnt = & pBTInfo->BtMgnt;
#line 6457
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6458
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 6459
  bScoExist = 0U;
#line 6459
  bBtLinkExist = 0U;
#line 6459
  bBtHsModeExist = 0U;
#line 6460
  algorithm = 0U;
#line 6462
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle != 0U) {
#line 6463
    bBtLinkExist = 1U;
  } else {

  }
#line 6464
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfSCO != 0U) {
#line 6465
    bScoExist = 1U;
  } else {

  }
#line 6471
  pBtdm8723->btStatus = 0U;
#line 6473
  if ((unsigned int )bScoExist != 0U || (unsigned int )bBtHsModeExist != 0U) {
#line 6473
    goto _L;
  } else {
#line 6473
    tmp___6 = BTHCI_CheckProfileExist(padapter, 3);
#line 6473
    if ((unsigned int )tmp___6 != 0U) {
      _L: /* CIL Label */ 
#line 6475
      if (BTCoexDbgLevel == 1U) {
#line 6475
        printk("[BTCoex], SCO or HID or HS exists, set BT non-idle !!!\n");
      } else {

      }
#line 6476
      pBtdm8723->btStatus = 2U;
    } else {
#line 6479
      if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
#line 6479
        tmp___0 = BTHCI_CheckProfileExist(padapter, 1);
#line 6479
        if ((unsigned int )tmp___0 != 0U) {
#line 6481
          tmp = BTDM_BtTxRxCounterL(padapter);
#line 6481
          if (tmp <= 99U) {
#line 6482
            if (BTCoexDbgLevel == 1U) {
#line 6482
              printk("[BTCoex], A2DP, low priority tx+rx < 100, set BT connected-idle!!!\n");
            } else {

            }
#line 6483
            pBtdm8723->btStatus = 1U;
          } else {
#line 6485
            if (BTCoexDbgLevel == 1U) {
#line 6485
              printk("[BTCoex], A2DP, low priority tx+rx >= 100, set BT non-idle!!!\n");
            } else {

            }
#line 6486
            pBtdm8723->btStatus = 2U;
          }
        } else {

        }
      } else {

      }
#line 6490
      if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
#line 6490
        tmp___2 = BTHCI_CheckProfileExist(padapter, 2);
#line 6490
        if ((unsigned int )tmp___2 != 0U) {
#line 6492
          tmp___1 = BTDM_BtTxRxCounterL(padapter);
#line 6492
          if (tmp___1 <= 599U) {
#line 6493
            if (BTCoexDbgLevel == 1U) {
#line 6493
              printk("[BTCoex], PAN, low priority tx+rx < 600, set BT connected-idle!!!\n");
            } else {

            }
#line 6494
            pBtdm8723->btStatus = 1U;
          } else
#line 6496
          if (pHalData->bt_coexist.halCoex8723.lowPriorityTx != 0U) {
#line 6497
            if (pHalData->bt_coexist.halCoex8723.lowPriorityRx / pHalData->bt_coexist.halCoex8723.lowPriorityTx > 9U) {
#line 6499
              if (BTCoexDbgLevel == 1U) {
#line 6499
                printk("[BTCoex], PAN, low priority rx/tx > 9, set BT connected-idle!!!\n");
              } else {

              }
#line 6500
              pBtdm8723->btStatus = 1U;
            } else {

            }
          } else {

          }
#line 6504
          if ((unsigned int )pBtdm8723->btStatus != 1U) {
#line 6505
            if (BTCoexDbgLevel == 1U) {
#line 6505
              printk("[BTCoex], PAN, set BT non-idle!!!\n");
            } else {

            }
#line 6506
            pBtdm8723->btStatus = 2U;
          } else {

          }
        } else {

        }
      } else {

      }
#line 6510
      if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 2U) {
#line 6510
        tmp___4 = BTHCI_CheckProfileExist(padapter, 1);
#line 6510
        if ((unsigned int )tmp___4 != 0U) {
#line 6510
          tmp___5 = BTHCI_CheckProfileExist(padapter, 2);
#line 6510
          if ((unsigned int )tmp___5 != 0U) {
#line 6513
            tmp___3 = BTDM_BtTxRxCounterL(padapter);
#line 6513
            if (tmp___3 <= 599U) {
#line 6514
              if (BTCoexDbgLevel == 1U) {
#line 6514
                printk("[BTCoex], PAN+A2DP, low priority tx+rx < 600, set BT connected-idle!!!\n");
              } else {

              }
#line 6515
              pBtdm8723->btStatus = 1U;
            } else
#line 6517
            if (pHalData->bt_coexist.halCoex8723.lowPriorityTx != 0U) {
#line 6518
              if (pHalData->bt_coexist.halCoex8723.lowPriorityRx / pHalData->bt_coexist.halCoex8723.lowPriorityTx > 9U) {
#line 6520
                if (BTCoexDbgLevel == 1U) {
#line 6520
                  printk("[BTCoex], PAN+A2DP, low priority rx/tx > 9, set BT connected-idle!!!\n");
                } else {

                }
#line 6521
                pBtdm8723->btStatus = 1U;
              } else {

              }
            } else {

            }
#line 6525
            if ((unsigned int )pBtdm8723->btStatus != 1U) {
#line 6526
              if (BTCoexDbgLevel == 1U) {
#line 6526
                printk("[BTCoex], PAN+A2DP, set BT non-idle!!!\n");
              } else {

              }
#line 6527
              pBtdm8723->btStatus = 2U;
            } else {

            }
          } else {

          }
        } else {

        }
      } else {

      }
    }
  }
#line 6531
  if ((unsigned int )pBtdm8723->btStatus != 0U) {
#line 6532
    pBtMgnt->ExtConfig.bBTBusy = 1U;
  } else {
#line 6534
    pBtMgnt->ExtConfig.bBTBusy = 0U;
  }
#line 6536
  if ((unsigned int )bBtLinkExist == 0U) {
#line 6537
    if (BTCoexDbgLevel == 1U) {
#line 6537
      printk("[BTCoex], No profile exists!!!\n");
    } else {

    }
#line 6538
    return (algorithm);
  } else {

  }
#line 6541
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
#line 6542
    if ((unsigned int )bScoExist != 0U) {
#line 6543
      if (BTCoexDbgLevel == 1U) {
#line 6543
        printk("[BTCoex], SCO only\n");
      } else {

      }
#line 6544
      algorithm = 1U;
    } else {
#line 6546
      tmp___9 = BTHCI_CheckProfileExist(padapter, 3);
#line 6546
      if ((unsigned int )tmp___9 != 0U) {
#line 6547
        if (BTCoexDbgLevel == 1U) {
#line 6547
          printk("[BTCoex], HID only\n");
        } else {

        }
#line 6548
        algorithm = 2U;
      } else {
#line 6549
        tmp___8 = BTHCI_CheckProfileExist(padapter, 1);
#line 6549
        if ((unsigned int )tmp___8 != 0U) {
#line 6550
          if (BTCoexDbgLevel == 1U) {
#line 6550
            printk("[BTCoex], A2DP only\n");
          } else {

          }
#line 6551
          algorithm = 3U;
        } else {
#line 6552
          tmp___7 = BTHCI_CheckProfileExist(padapter, 2);
#line 6552
          if ((unsigned int )tmp___7 != 0U) {
#line 6553
            if ((unsigned int )bBtHsModeExist != 0U) {
#line 6554
              if (BTCoexDbgLevel == 1U) {
#line 6554
                printk("[BTCoex], PAN(HS) only\n");
              } else {

              }
#line 6555
              algorithm = 5U;
            } else {
#line 6557
              if (BTCoexDbgLevel == 1U) {
#line 6557
                printk("[BTCoex], PAN(EDR) only\n");
              } else {

              }
#line 6558
              algorithm = 4U;
            }
          } else
#line 6561
          if (BTCoexDbgLevel == 1U) {
#line 6561
            printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d \n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {

          }
        }
      }
    }
  } else
#line 6565
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 2U) {
#line 6566
    if ((unsigned int )bScoExist != 0U) {
#line 6567
      tmp___12 = BTHCI_CheckProfileExist(padapter, 3);
#line 6567
      if ((unsigned int )tmp___12 != 0U) {
#line 6568
        if (BTCoexDbgLevel == 1U) {
#line 6568
          printk("[BTCoex], SCO + HID\n");
        } else {

        }
#line 6569
        algorithm = 2U;
      } else {
#line 6570
        tmp___11 = BTHCI_CheckProfileExist(padapter, 1);
#line 6570
        if ((unsigned int )tmp___11 != 0U) {
#line 6571
          if (BTCoexDbgLevel == 1U) {
#line 6571
            printk("[BTCoex], Error!!! SCO + A2DP\n");
          } else {

          }
        } else {
#line 6572
          tmp___10 = BTHCI_CheckProfileExist(padapter, 2);
#line 6572
          if ((unsigned int )tmp___10 != 0U) {
#line 6573
            if ((unsigned int )bBtHsModeExist != 0U) {
#line 6574
              if (BTCoexDbgLevel == 1U) {
#line 6574
                printk("[BTCoex], SCO + PAN(HS)\n");
              } else {

              }
#line 6575
              algorithm = 1U;
            } else {
#line 6577
              if (BTCoexDbgLevel == 1U) {
#line 6577
                printk("[BTCoex], SCO + PAN(EDR)\n");
              } else {

              }
#line 6578
              algorithm = 7U;
            }
          } else
#line 6581
          if (BTCoexDbgLevel == 1U) {
#line 6581
            printk("[BTCoex], Error!!! SCO exists but why NO matched ACL profile for NumberOfHandle =%d\n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {

          }
        }
      }
    } else {
#line 6585
      tmp___17 = BTHCI_CheckProfileExist(padapter, 3);
#line 6585
      if ((unsigned int )tmp___17 != 0U) {
#line 6585
        tmp___18 = BTHCI_CheckProfileExist(padapter, 1);
#line 6585
        if ((unsigned int )tmp___18 != 0U) {
#line 6587
          if (BTCoexDbgLevel == 1U) {
#line 6587
            printk("[BTCoex], HID + A2DP\n");
          } else {

          }
#line 6588
          algorithm = 9U;
        } else {
#line 6585
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 6589
        tmp___15 = BTHCI_CheckProfileExist(padapter, 3);
#line 6589
        if ((unsigned int )tmp___15 != 0U) {
#line 6589
          tmp___16 = BTHCI_CheckProfileExist(padapter, 2);
#line 6589
          if ((unsigned int )tmp___16 != 0U) {
#line 6591
            if ((unsigned int )bBtHsModeExist != 0U) {
#line 6592
              if (BTCoexDbgLevel == 1U) {
#line 6592
                printk("[BTCoex], HID + PAN(HS)\n");
              } else {

              }
#line 6593
              algorithm = 9U;
            } else {
#line 6595
              if (BTCoexDbgLevel == 1U) {
#line 6595
                printk("[BTCoex], HID + PAN(EDR)\n");
              } else {

              }
#line 6596
              algorithm = 7U;
            }
          } else {
#line 6589
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 6598
          tmp___13 = BTHCI_CheckProfileExist(padapter, 2);
#line 6598
          if ((unsigned int )tmp___13 != 0U) {
#line 6598
            tmp___14 = BTHCI_CheckProfileExist(padapter, 1);
#line 6598
            if ((unsigned int )tmp___14 != 0U) {
#line 6600
              if ((unsigned int )bBtHsModeExist != 0U) {
#line 6601
                if (BTCoexDbgLevel == 1U) {
#line 6601
                  printk("[BTCoex], A2DP + PAN(HS)\n");
                } else {

                }
#line 6602
                algorithm = 3U;
              } else {
#line 6604
                if (BTCoexDbgLevel == 1U) {
#line 6604
                  printk("[BTCoex], A2DP + PAN(EDR)\n");
                } else {

                }
#line 6605
                algorithm = 6U;
              }
            } else {
#line 6598
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 6608
          if (BTCoexDbgLevel == 1U) {
#line 6608
            printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {

          }
        }
      }
    }
  } else
#line 6612
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 3U) {
#line 6613
    if ((unsigned int )bScoExist != 0U) {
#line 6614
      tmp___23 = BTHCI_CheckProfileExist(padapter, 3);
#line 6614
      if ((unsigned int )tmp___23 != 0U) {
#line 6614
        tmp___24 = BTHCI_CheckProfileExist(padapter, 1);
#line 6614
        if ((unsigned int )tmp___24 != 0U) {
#line 6616
          if (BTCoexDbgLevel == 1U) {
#line 6616
            printk("[BTCoex], Error!!! SCO + HID + A2DP\n");
          } else {

          }
        } else {
#line 6614
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
#line 6617
        tmp___21 = BTHCI_CheckProfileExist(padapter, 3);
#line 6617
        if ((unsigned int )tmp___21 != 0U) {
#line 6617
          tmp___22 = BTHCI_CheckProfileExist(padapter, 2);
#line 6617
          if ((unsigned int )tmp___22 != 0U) {
#line 6619
            if ((unsigned int )bBtHsModeExist != 0U) {
#line 6620
              if (BTCoexDbgLevel == 1U) {
#line 6620
                printk("[BTCoex], SCO + HID + PAN(HS)\n");
              } else {

              }
#line 6621
              algorithm = 9U;
            } else {
#line 6623
              if (BTCoexDbgLevel == 1U) {
#line 6623
                printk("[BTCoex], SCO + HID + PAN(EDR)\n");
              } else {

              }
#line 6624
              algorithm = 7U;
            }
          } else {
#line 6617
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
#line 6626
          tmp___19 = BTHCI_CheckProfileExist(padapter, 2);
#line 6626
          if ((unsigned int )tmp___19 != 0U) {
#line 6626
            tmp___20 = BTHCI_CheckProfileExist(padapter, 1);
#line 6626
            if ((unsigned int )tmp___20 != 0U) {
#line 6628
              if ((unsigned int )bBtHsModeExist != 0U) {
#line 6629
                if (BTCoexDbgLevel == 1U) {
#line 6629
                  printk("[BTCoex], Error!!! SCO + A2DP + PAN(HS)\n");
                } else {

                }
#line 6630
                algorithm = 1U;
              } else
#line 6632
              if (BTCoexDbgLevel == 1U) {
#line 6632
                printk("[BTCoex], Error!!! SCO + A2DP + PAN(EDR)\n");
              } else {

              }
            } else {
#line 6626
              goto _L___3;
            }
          } else
          _L___3: /* CIL Label */ 
#line 6635
          if (BTCoexDbgLevel == 1U) {
#line 6635
            printk("[BTCoex], Error!!! SCO exists but why NO matched profile for NumberOfHandle =%d\n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {

          }
        }
      }
    } else {
#line 6639
      tmp___25 = BTHCI_CheckProfileExist(padapter, 3);
#line 6639
      if ((unsigned int )tmp___25 != 0U) {
#line 6639
        tmp___26 = BTHCI_CheckProfileExist(padapter, 2);
#line 6639
        if ((unsigned int )tmp___26 != 0U) {
#line 6639
          tmp___27 = BTHCI_CheckProfileExist(padapter, 1);
#line 6639
          if ((unsigned int )tmp___27 != 0U) {
#line 6642
            if ((unsigned int )bBtHsModeExist != 0U) {
#line 6643
              if (BTCoexDbgLevel == 1U) {
#line 6643
                printk("[BTCoex], HID + A2DP + PAN(HS)\n");
              } else {

              }
#line 6644
              algorithm = 10U;
            } else {
#line 6646
              if (BTCoexDbgLevel == 1U) {
#line 6646
                printk("[BTCoex], HID + A2DP + PAN(EDR)\n");
              } else {

              }
#line 6647
              algorithm = 8U;
            }
          } else {
#line 6639
            goto _L___7;
          }
        } else {
#line 6639
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 6650
      if (BTCoexDbgLevel == 1U) {
#line 6650
        printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
      } else {

      }
    }
  } else
#line 6654
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle > 2U) {
#line 6655
    if ((unsigned int )bScoExist != 0U) {
#line 6656
      tmp___28 = BTHCI_CheckProfileExist(padapter, 3);
#line 6656
      if ((unsigned int )tmp___28 != 0U) {
#line 6656
        tmp___29 = BTHCI_CheckProfileExist(padapter, 2);
#line 6656
        if ((unsigned int )tmp___29 != 0U) {
#line 6656
          tmp___30 = BTHCI_CheckProfileExist(padapter, 1);
#line 6656
          if ((unsigned int )tmp___30 != 0U) {
#line 6659
            if ((unsigned int )bBtHsModeExist != 0U) {
#line 6660
              if (BTCoexDbgLevel == 1U) {
#line 6660
                printk("[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
              } else {

              }
            } else
#line 6662
            if (BTCoexDbgLevel == 1U) {
#line 6662
              printk("[BTCoex], Error!!! SCO + HID + A2DP + PAN(EDR)\n");
            } else {

            }
          } else {
#line 6656
            goto _L___9;
          }
        } else {
#line 6656
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
#line 6664
      if (BTCoexDbgLevel == 1U) {
#line 6664
        printk("[BTCoex], Error!!! SCO exists but why NO matched profile for NumberOfHandle =%d\n",
               (int )pBtMgnt->ExtConfig.NumberOfHandle);
      } else {

      }
    } else
#line 6668
    if (BTCoexDbgLevel == 1U) {
#line 6668
      printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
    } else {

    }
  } else {

  }
#line 6672
  return (algorithm);
}
}
#line 6675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 btdm_NeedToDecBtPwr(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 6677
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6678
  bRet = 0U;
#line 6680
  tmp___0 = BT_Operation(padapter);
#line 6680
  if ((unsigned int )tmp___0 != 0U) {
#line 6681
    if (pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB > 47) {
#line 6682
      if (BTCoexDbgLevel == 1U) {
#line 6682
        printk("Need to decrease bt power for HS mode!!\n");
      } else {

      }
#line 6683
      bRet = 1U;
    } else
#line 6685
    if (BTCoexDbgLevel == 1U) {
#line 6685
      printk("NO Need to decrease bt power for HS mode!!\n");
    } else {

    }
  } else {
#line 6688
    tmp = BTDM_IsWifiConnectionExist(padapter);
#line 6688
    if ((unsigned int )tmp != 0U) {
#line 6689
      if (BTCoexDbgLevel == 1U) {
#line 6689
        printk("Need to decrease bt power for Wifi is connected!!\n");
      } else {

      }
#line 6690
      bRet = 1U;
    } else {

    }
  }
#line 6693
  return (bRet);
}
}
#line 6697 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_SetCoexTable(struct rtw_adapter *padapter , u32 val0x6c0 , u32 val0x6c8 ,
                              u8 val0x6cc ) 
{ 


  {
#line 6700
  if (BTCoexDbgLevel == 1U) {
#line 6700
    printk("set coex table, set 0x6c0 = 0x%x\n", val0x6c0);
  } else {

  }
#line 6701
  rtl8723au_write32(padapter, 1728, val0x6c0);
#line 6703
  if (BTCoexDbgLevel == 1U) {
#line 6703
    printk("set coex table, set 0x6c8 = 0x%x\n", val0x6c8);
  } else {

  }
#line 6704
  rtl8723au_write32(padapter, 1736, val0x6c8);
#line 6706
  if (BTCoexDbgLevel == 1U) {
#line 6706
    printk("set coex table, set 0x6cc = 0x%x\n", (int )val0x6cc);
  } else {

  }
#line 6707
  rtl8723au_write8(padapter, 1740, (int )val0x6cc);
#line 6708
  return;
}
}
#line 6711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_SetSwFullTimeDacSwing(struct rtw_adapter *padapter , u8 bSwDacSwingOn ,
                                       u32 swDacSwingLvl ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 6714
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6716
  if ((unsigned int )bSwDacSwingOn != 0U) {
#line 6717
    if (BTCoexDbgLevel == 1U) {
#line 6717
      printk("[BTCoex], SwDacSwing = 0x%x\n", swDacSwingLvl);
    } else {

    }
#line 6718
    PHY_SetBBReg(padapter, 2176U, 4278190080U, swDacSwingLvl);
#line 6719
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else {
#line 6721
    if (BTCoexDbgLevel == 1U) {
#line 6721
      printk("[BTCoex], SwDacSwing Off!\n");
    } else {

    }
#line 6722
    PHY_SetBBReg(padapter, 2176U, 4278190080U, 192U);
  }
#line 6724
  return;
}
}
#line 6727 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_SetFwDacSwingLevel(struct rtw_adapter *padapter , u8 dacSwingLvl ) 
{ 
  u8 H2C_Parameter[1U] ;

  {
#line 6729
  H2C_Parameter[0] = 0U;
#line 6731
  H2C_Parameter[0] = dacSwingLvl;
#line 6733
  if (BTCoexDbgLevel == 1U) {
#line 6733
    printk("[BTCoex], Set Dac Swing Level = 0x%x\n", (int )dacSwingLvl);
  } else {

  }
#line 6734
  if (BTCoexDbgLevel == 1U) {
#line 6734
    printk("[BTCoex], write 0x29 = 0x%x\n", (int )H2C_Parameter[0]);
  } else {

  }
#line 6736
  FillH2CCmd(padapter, 41, 1U, (u8 *)(& H2C_Parameter));
#line 6737
  return;
}
}
#line 6739 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2AntDecBtPwr(struct rtw_adapter *padapter , u8 bDecBtPwr ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 6741
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6742
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 6744
  if (BTCoexDbgLevel == 1U) {
#line 6744
    printk("[BTCoex], Dec BT power = %s\n", (unsigned int )bDecBtPwr != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
#line 6747
  pBtdm8723->bCurDecBtPwr = bDecBtPwr;
#line 6749
  if ((int )pBtdm8723->bPreDecBtPwr == (int )pBtdm8723->bCurDecBtPwr) {
#line 6750
    return;
  } else {

  }
#line 6752
  BTDM_SetFwDecBtPwr(padapter, (int )pBtdm8723->bCurDecBtPwr);
#line 6754
  pBtdm8723->bPreDecBtPwr = pBtdm8723->bCurDecBtPwr;
#line 6755
  return;
}
}
#line 6758 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2AntFwDacSwingLvl(struct rtw_adapter *padapter , u8 fwDacSwingLvl ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 6760
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6761
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 6763
  if (BTCoexDbgLevel == 1U) {
#line 6763
    printk("[BTCoex], set FW Dac Swing level = %d\n", (int )fwDacSwingLvl);
  } else {

  }
#line 6764
  pBtdm8723->curFwDacSwingLvl = fwDacSwingLvl;
#line 6769
  if ((int )pBtdm8723->preFwDacSwingLvl == (int )pBtdm8723->curFwDacSwingLvl) {
#line 6770
    return;
  } else {

  }
#line 6772
  btdm_SetFwDacSwingLevel(padapter, (int )pBtdm8723->curFwDacSwingLvl);
#line 6774
  pBtdm8723->preFwDacSwingLvl = pBtdm8723->curFwDacSwingLvl;
#line 6775
  return;
}
}
#line 6778 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2AntRfShrink(struct rtw_adapter *padapter , u8 bRxRfShrinkOn ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 6780
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6781
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 6783
  if (BTCoexDbgLevel == 1U) {
#line 6783
    printk("[BTCoex], turn Rx RF Shrink = %s\n", (unsigned int )bRxRfShrinkOn != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
#line 6786
  pBtdm8723->bCurRfRxLpfShrink = bRxRfShrinkOn;
#line 6791
  if ((int )pBtdm8723->bPreRfRxLpfShrink == (int )pBtdm8723->bCurRfRxLpfShrink) {
#line 6792
    return;
  } else {

  }
#line 6794
  BTDM_SetSwRfRxLpfCorner(padapter, (int )pBtdm8723->bCurRfRxLpfShrink);
#line 6796
  pBtdm8723->bPreRfRxLpfShrink = pBtdm8723->bCurRfRxLpfShrink;
#line 6797
  return;
}
}
#line 6800 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2AntLowPenaltyRa(struct rtw_adapter *padapter , u8 bLowPenaltyRa ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 6802
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6803
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 6805
  if (BTCoexDbgLevel == 1U) {
#line 6805
    printk("[BTCoex], turn LowPenaltyRA = %s\n", (unsigned int )bLowPenaltyRa != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
#line 6808
  pBtdm8723->bCurLowPenaltyRa = bLowPenaltyRa;
#line 6813
  if ((int )pBtdm8723->bPreLowPenaltyRa == (int )pBtdm8723->bCurLowPenaltyRa) {
#line 6814
    return;
  } else {

  }
#line 6816
  BTDM_SetSwPenaltyTxRateAdaptive(padapter, (int )pBtdm8723->bCurLowPenaltyRa);
#line 6818
  pBtdm8723->bPreLowPenaltyRa = pBtdm8723->bCurLowPenaltyRa;
#line 6819
  return;
}
}
#line 6822 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2AntDacSwing(struct rtw_adapter *padapter , u8 bDacSwingOn , u32 dacSwingLvl ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  unsigned long __ms ;
  unsigned long tmp ;

  {
#line 6825
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6826
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 6828
  if (BTCoexDbgLevel == 1U) {
#line 6828
    printk("[BTCoex], turn DacSwing =%s, dacSwingLvl = 0x%x\n", (unsigned int )bDacSwingOn != 0U ? (char *)"ON" : (char *)"OFF",
           dacSwingLvl);
  } else {

  }
#line 6831
  pBtdm8723->bCurDacSwingOn = bDacSwingOn;
#line 6832
  pBtdm8723->curDacSwingLvl = dacSwingLvl;
#line 6834
  if ((int )pBtdm8723->bPreDacSwingOn == (int )pBtdm8723->bCurDacSwingOn && pBtdm8723->preDacSwingLvl == pBtdm8723->curDacSwingLvl) {
#line 6836
    return;
  } else {

  }
#line 6838
  __ms = 30UL;
#line 6838
  goto ldv_57660;
  ldv_57659: 
#line 6838
  __const_udelay(4295000UL);
  ldv_57660: 
#line 6838
  tmp = __ms;
#line 6838
  __ms = __ms - 1UL;
#line 6838
  if (tmp != 0UL) {
#line 6840
    goto ldv_57659;
  } else {

  }
#line 6839
  btdm_SetSwFullTimeDacSwing(padapter, (int )bDacSwingOn, dacSwingLvl);
#line 6841
  pBtdm8723->bPreDacSwingOn = pBtdm8723->bCurDacSwingOn;
#line 6842
  pBtdm8723->preDacSwingLvl = pBtdm8723->curDacSwingLvl;
#line 6843
  return;
}
}
#line 6845 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2AntAdcBackOff(struct rtw_adapter *padapter , u8 bAdcBackOff ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 6847
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6848
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 6850
  if (BTCoexDbgLevel == 1U) {
#line 6850
    printk("[BTCoex], turn AdcBackOff = %s\n", (unsigned int )bAdcBackOff != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
#line 6853
  pBtdm8723->bCurAdcBackOff = bAdcBackOff;
#line 6855
  if ((int )pBtdm8723->bPreAdcBackOff == (int )pBtdm8723->bCurAdcBackOff) {
#line 6856
    return;
  } else {

  }
#line 6858
  BTDM_BBBackOffLevel(padapter, (int )pBtdm8723->bCurAdcBackOff);
#line 6860
  pBtdm8723->bPreAdcBackOff = pBtdm8723->bCurAdcBackOff;
#line 6861
  return;
}
}
#line 6863 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2AntAgcTable(struct rtw_adapter *padapter , u8 bAgcTableEn ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 6865
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6866
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 6868
  if (BTCoexDbgLevel == 1U) {
#line 6868
    printk("[BTCoex], %s Agc Table\n", (unsigned int )bAgcTableEn != 0U ? (char *)"Enable" : (char *)"Disable");
  } else {

  }
#line 6870
  pBtdm8723->bCurAgcTableEn = bAgcTableEn;
#line 6875
  if ((int )pBtdm8723->bPreAgcTableEn == (int )pBtdm8723->bCurAgcTableEn) {
#line 6876
    return;
  } else {

  }
#line 6878
  BTDM_AGCTable(padapter, (int )bAgcTableEn);
#line 6880
  pBtdm8723->bPreAgcTableEn = pBtdm8723->bCurAgcTableEn;
#line 6881
  return;
}
}
#line 6884 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2AntCoexTable(struct rtw_adapter *padapter , u32 val0x6c0 , u32 val0x6c8 ,
                               u8 val0x6cc ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 6887
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6888
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 6890
  if (BTCoexDbgLevel == 1U) {
#line 6890
    printk("[BTCoex], write Coex Table 0x6c0 = 0x%x, 0x6c8 = 0x%x, 0x6cc = 0x%x\n",
           val0x6c0, val0x6c8, (int )val0x6cc);
  } else {

  }
#line 6892
  pBtdm8723->curVal0x6c0 = val0x6c0;
#line 6893
  pBtdm8723->curVal0x6c8 = val0x6c8;
#line 6894
  pBtdm8723->curVal0x6cc = val0x6cc;
#line 6901
  if ((pBtdm8723->preVal0x6c0 == pBtdm8723->curVal0x6c0 && pBtdm8723->preVal0x6c8 == pBtdm8723->curVal0x6c8) && (int )pBtdm8723->preVal0x6cc == (int )pBtdm8723->curVal0x6cc) {
#line 6904
    return;
  } else {

  }
#line 6906
  btdm_SetCoexTable(padapter, val0x6c0, val0x6c8, (int )val0x6cc);
#line 6908
  pBtdm8723->preVal0x6c0 = pBtdm8723->curVal0x6c0;
#line 6909
  pBtdm8723->preVal0x6c8 = pBtdm8723->curVal0x6c8;
#line 6910
  pBtdm8723->preVal0x6cc = pBtdm8723->curVal0x6cc;
#line 6911
  return;
}
}
#line 6913 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2AntIgnoreWlanAct(struct rtw_adapter *padapter , u8 bEnable ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 6915
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6916
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 6918
  if (BTCoexDbgLevel == 1U) {
#line 6918
    printk("[BTCoex], turn Ignore WlanAct %s\n", (unsigned int )bEnable != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
#line 6920
  pBtdm8723->bCurIgnoreWlanAct = bEnable;
#line 6923
  if ((int )pBtdm8723->bPreIgnoreWlanAct == (int )pBtdm8723->bCurIgnoreWlanAct) {
#line 6924
    return;
  } else {

  }
#line 6926
  btdm_SetFwIgnoreWlanAct(padapter, (int )bEnable);
#line 6927
  pBtdm8723->bPreIgnoreWlanAct = pBtdm8723->bCurIgnoreWlanAct;
#line 6928
  return;
}
}
#line 6931 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2AntSetFw3a(struct rtw_adapter *padapter , u8 byte1 , u8 byte2 ,
                             u8 byte3 , u8 byte4 , u8 byte5 ) 
{ 
  u8 H2C_Parameter[5U] ;
  unsigned int tmp ;
  struct hal_data_8723a *pHalData ;

  {
#line 6934
  H2C_Parameter[0] = 0U;
#line 6934
  tmp = 1U;
#line 6934
  while (1) {
#line 6934
    if (tmp >= 5U) {
#line 6934
      break;
    } else {

    }
#line 6934
    H2C_Parameter[tmp] = (unsigned char)0;
#line 6934
    tmp = tmp + 1U;
  }
#line 6936
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6940
  if ((unsigned int )byte1 != 0U) {
#line 6941
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
#line 6942
  H2C_Parameter[0] = byte1;
#line 6943
  H2C_Parameter[1] = byte2;
#line 6944
  H2C_Parameter[2] = byte3;
#line 6945
  H2C_Parameter[3] = byte4;
#line 6946
  H2C_Parameter[4] = byte5;
#line 6948
  pHalData->bt_coexist.fw3aVal[0] = byte1;
#line 6949
  pHalData->bt_coexist.fw3aVal[1] = byte2;
#line 6950
  pHalData->bt_coexist.fw3aVal[2] = byte3;
#line 6951
  pHalData->bt_coexist.fw3aVal[3] = byte4;
#line 6952
  pHalData->bt_coexist.fw3aVal[4] = byte5;
#line 6954
  if (BTCoexDbgLevel == 1U) {
#line 6954
    printk("[BTCoex], FW write 0x3a(5bytes) = 0x%x%08x\n", (int )H2C_Parameter[0],
           ((((int )H2C_Parameter[1] << 24) | ((int )H2C_Parameter[2] << 16)) | ((int )H2C_Parameter[3] << 8)) | (int )H2C_Parameter[4]);
  } else {

  }
#line 6958
  FillH2CCmd(padapter, 58, 5U, (u8 *)(& H2C_Parameter));
#line 6959
  return;
}
}
#line 6961 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2AntPsTdma(struct rtw_adapter *padapter , u8 bTurnOn , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u32 btTxRxCnt ;
  u8 bTurnOnByCnt ;
  u8 psTdmaTypeByCnt ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 6963
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6964
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 6965
  btTxRxCnt = 0U;
#line 6966
  bTurnOnByCnt = 0U;
#line 6967
  psTdmaTypeByCnt = 0U;
#line 6969
  tmp = BTDM_BtTxRxCounterH(padapter);
#line 6969
  tmp___0 = BTDM_BtTxRxCounterL(padapter);
#line 6969
  btTxRxCnt = tmp + tmp___0;
#line 6970
  if (BTCoexDbgLevel == 1U) {
#line 6970
    printk("[BTCoex], BT TxRx Counters = %d\n", btTxRxCnt);
  } else {

  }
#line 6971
  if (btTxRxCnt > 3000U) {
#line 6972
    bTurnOnByCnt = 1U;
#line 6973
    psTdmaTypeByCnt = 8U;
#line 6975
    if (BTCoexDbgLevel == 1U) {
#line 6975
      printk("[BTCoex], For BTTxRxCounters, turn %s PS TDMA, type =%d\n", (unsigned int )bTurnOnByCnt != 0U ? (char *)"ON" : (char *)"OFF",
             (int )psTdmaTypeByCnt);
    } else {

    }
#line 6978
    pBtdm8723->bCurPsTdmaOn = bTurnOnByCnt;
#line 6979
    pBtdm8723->curPsTdma = psTdmaTypeByCnt;
  } else {
#line 6981
    if (BTCoexDbgLevel == 1U) {
#line 6981
      printk("[BTCoex], turn %s PS TDMA, type =%d\n", (unsigned int )bTurnOn != 0U ? (char *)"ON" : (char *)"OFF",
             (int )type);
    } else {

    }
#line 6984
    pBtdm8723->bCurPsTdmaOn = bTurnOn;
#line 6985
    pBtdm8723->curPsTdma = type;
  }
#line 6988
  if ((int )pBtdm8723->bPrePsTdmaOn == (int )pBtdm8723->bCurPsTdmaOn && (int )pBtdm8723->prePsTdma == (int )pBtdm8723->curPsTdma) {
#line 6990
    return;
  } else {

  }
#line 6992
  if ((unsigned int )bTurnOn != 0U) {
#line 6993
    switch ((int )type) {
    case 1: ;
    default: 
#line 6996
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 161, 152);
#line 6997
    goto ldv_57710;
    case 2: 
#line 6999
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 161, 152);
#line 7000
    goto ldv_57710;
    case 3: 
#line 7002
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 161, 152);
#line 7003
    goto ldv_57710;
    case 4: 
#line 7005
    btdm_2AntSetFw3a(padapter, 163, 5, 5, 161, 128);
#line 7006
    goto ldv_57710;
    case 5: 
#line 7008
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 32, 152);
#line 7009
    goto ldv_57710;
    case 6: 
#line 7011
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 32, 152);
#line 7012
    goto ldv_57710;
    case 7: 
#line 7014
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 32, 152);
#line 7015
    goto ldv_57710;
    case 8: 
#line 7017
    btdm_2AntSetFw3a(padapter, 163, 5, 5, 32, 128);
#line 7018
    goto ldv_57710;
    case 9: 
#line 7020
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 161, 152);
#line 7021
    goto ldv_57710;
    case 10: 
#line 7023
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 161, 152);
#line 7024
    goto ldv_57710;
    case 11: 
#line 7026
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 161, 152);
#line 7027
    goto ldv_57710;
    case 12: 
#line 7029
    btdm_2AntSetFw3a(padapter, 227, 5, 5, 161, 152);
#line 7030
    goto ldv_57710;
    case 13: 
#line 7032
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 32, 152);
#line 7033
    goto ldv_57710;
    case 14: 
#line 7035
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 32, 152);
#line 7036
    goto ldv_57710;
    case 15: 
#line 7038
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 32, 152);
#line 7039
    goto ldv_57710;
    case 16: 
#line 7041
    btdm_2AntSetFw3a(padapter, 227, 5, 5, 32, 152);
#line 7042
    goto ldv_57710;
    case 17: 
#line 7044
    btdm_2AntSetFw3a(padapter, 163, 47, 47, 32, 128);
#line 7045
    goto ldv_57710;
    case 18: 
#line 7047
    btdm_2AntSetFw3a(padapter, 227, 5, 5, 161, 152);
#line 7048
    goto ldv_57710;
    case 19: 
#line 7050
    btdm_2AntSetFw3a(padapter, 227, 37, 37, 161, 152);
#line 7051
    goto ldv_57710;
    case 20: 
#line 7053
    btdm_2AntSetFw3a(padapter, 227, 37, 37, 32, 152);
#line 7054
    goto ldv_57710;
    }
    ldv_57710: ;
  } else {
#line 7058
    switch ((int )type) {
    case 0: 
#line 7060
    btdm_2AntSetFw3a(padapter, 0, 0, 0, 8, 0);
#line 7061
    goto ldv_57731;
    case 1: 
#line 7063
    btdm_2AntSetFw3a(padapter, 0, 0, 0, 0, 0);
#line 7064
    goto ldv_57731;
    default: 
#line 7066
    btdm_2AntSetFw3a(padapter, 0, 0, 0, 8, 0);
#line 7067
    goto ldv_57731;
    }
    ldv_57731: ;
  }
#line 7072
  pBtdm8723->bPrePsTdmaOn = pBtdm8723->bCurPsTdmaOn;
#line 7073
  pBtdm8723->prePsTdma = pBtdm8723->curPsTdma;
#line 7074
  return;
}
}
#line 7076 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2AntBtInquiryPage(struct rtw_adapter *padapter ) 
{ 


  {
#line 7078
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7079
  btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7080
  btdm_2AntPsTdma(padapter, 1, 8);
#line 7081
  return;
}
}
#line 7083 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 btdm_HoldForBtInqPage(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 curTime ;

  {
#line 7085
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7086
  curTime = (u32 )jiffies;
#line 7088
  if ((unsigned int )pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage != 0U) {
#line 7090
    if (pHalData->bt_coexist.halCoex8723.btInqPageStartTime == 0UL) {
#line 7091
      pHalData->bt_coexist.halCoex8723.btInqPageStartTime = (unsigned long )curTime;
#line 7092
      if (BTCoexDbgLevel == 1U) {
#line 7092
        printk("[BTCoex], BT Inquiry/page is started at time : 0x%lx \n", pHalData->bt_coexist.halCoex8723.btInqPageStartTime);
      } else {

      }
    } else {

    }
  } else {

  }
#line 7096
  if (BTCoexDbgLevel == 1U) {
#line 7096
    printk("[BTCoex], BT Inquiry/page started time : 0x%lx, curTime : 0x%x \n", pHalData->bt_coexist.halCoex8723.btInqPageStartTime,
           curTime);
  } else {

  }
#line 7099
  if (pHalData->bt_coexist.halCoex8723.btInqPageStartTime != 0UL) {
#line 7100
    if ((unsigned long )curTime - pHalData->bt_coexist.halCoex8723.btInqPageStartTime > 9999999UL) {
#line 7101
      if (BTCoexDbgLevel == 1U) {
#line 7101
        printk("[BTCoex], BT Inquiry/page >= 10sec!!!");
      } else {

      }
#line 7102
      pHalData->bt_coexist.halCoex8723.btInqPageStartTime = 0UL;
    } else {

    }
  } else {

  }
#line 7106
  if (pHalData->bt_coexist.halCoex8723.btInqPageStartTime != 0UL) {
#line 7107
    btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7108
    btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7109
    btdm_2AntPsTdma(padapter, 1, 8);
#line 7110
    return (1U);
  } else {
#line 7112
    return (0U);
  }
}
}
#line 7116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 btdm_Is2Ant8723ACommonAction(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 bCommon ;
  bool tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  u8 tmp___4 ;
  bool tmp___5 ;
  u8 tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  u8 tmp___9 ;
  bool tmp___10 ;
  u8 tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;

  {
#line 7118
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7119
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 7120
  bCommon = 0U;
#line 7122
  if (BTCoexDbgLevel == 1U) {
#line 7122
    tmp = check_fwstate(& padapter->mlmepriv, 2176);
#line 7122
    tmp___0 = BTDM_IsWifiConnectionExist(padapter);
#line 7122
    printk("%s :BTDM_IsWifiConnectionExist =%x check_fwstate =%x pmlmepriv->fw_state = 0x%x\n",
           "btdm_Is2Ant8723ACommonAction", (int )tmp___0, (int )tmp, padapter->mlmepriv.fw_state);
  } else {

  }
#line 7124
  tmp___11 = BTDM_IsWifiConnectionExist(padapter);
#line 7124
  if ((unsigned int )tmp___11 == 0U) {
#line 7124
    tmp___12 = check_fwstate(& padapter->mlmepriv, 2176);
#line 7124
    if (tmp___12) {
#line 7124
      tmp___13 = 0;
    } else {
#line 7124
      tmp___13 = 1;
    }
#line 7124
    if (tmp___13) {
#line 7124
      if ((unsigned int )pBtdm8723->btStatus == 0U) {
#line 7127
        if (BTCoexDbgLevel == 1U) {
#line 7127
          printk("Wifi idle + Bt idle!!\n");
        } else {

        }
#line 7129
        btdm_2AntLowPenaltyRa(padapter, 0);
#line 7130
        btdm_2AntRfShrink(padapter, 0);
#line 7131
        btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7133
        btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7134
        btdm_2AntPsTdma(padapter, 0, 0);
#line 7135
        btdm_2AntFwDacSwingLvl(padapter, 32);
#line 7136
        btdm_2AntDecBtPwr(padapter, 0);
#line 7138
        btdm_2AntAgcTable(padapter, 0);
#line 7139
        btdm_2AntAdcBackOff(padapter, 0);
#line 7140
        btdm_2AntDacSwing(padapter, 0, 192U);
#line 7142
        bCommon = 1U;
      } else {
#line 7124
        goto _L___8;
      }
    } else {
#line 7124
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
#line 7143
    tmp___9 = BTDM_IsWifiConnectionExist(padapter);
#line 7143
    if ((unsigned int )tmp___9 != 0U) {
#line 7143
      goto _L___6;
    } else {
#line 7143
      tmp___10 = check_fwstate(& padapter->mlmepriv, 2176);
#line 7143
      if ((int )tmp___10) {
        _L___6: /* CIL Label */ 
#line 7143
        if ((unsigned int )pBtdm8723->btStatus == 0U) {
#line 7146
          if (BTCoexDbgLevel == 1U) {
#line 7146
            printk("Wifi non-idle + BT idle!!\n");
          } else {

          }
#line 7148
          btdm_2AntLowPenaltyRa(padapter, 1);
#line 7149
          btdm_2AntRfShrink(padapter, 0);
#line 7150
          btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7152
          btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7153
          btdm_2AntPsTdma(padapter, 0, 0);
#line 7154
          btdm_2AntFwDacSwingLvl(padapter, 32);
#line 7155
          btdm_2AntDecBtPwr(padapter, 1);
#line 7157
          btdm_2AntAgcTable(padapter, 0);
#line 7158
          btdm_2AntAdcBackOff(padapter, 0);
#line 7159
          btdm_2AntDacSwing(padapter, 0, 192U);
#line 7161
          bCommon = 1U;
        } else {
#line 7143
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
#line 7162
        tmp___6 = BTDM_IsWifiConnectionExist(padapter);
#line 7162
        if ((unsigned int )tmp___6 == 0U) {
#line 7162
          tmp___7 = check_fwstate(& padapter->mlmepriv, 2176);
#line 7162
          if (tmp___7) {
#line 7162
            tmp___8 = 0;
          } else {
#line 7162
            tmp___8 = 1;
          }
#line 7162
          if (tmp___8) {
#line 7162
            if ((unsigned int )pBtdm8723->btStatus == 1U) {
#line 7165
              if (BTCoexDbgLevel == 1U) {
#line 7165
                printk("Wifi idle + Bt connected idle!!\n");
              } else {

              }
#line 7167
              btdm_2AntLowPenaltyRa(padapter, 1);
#line 7168
              btdm_2AntRfShrink(padapter, 1);
#line 7169
              btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7171
              btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7172
              btdm_2AntPsTdma(padapter, 0, 0);
#line 7173
              btdm_2AntFwDacSwingLvl(padapter, 32);
#line 7174
              btdm_2AntDecBtPwr(padapter, 0);
#line 7176
              btdm_2AntAgcTable(padapter, 0);
#line 7177
              btdm_2AntAdcBackOff(padapter, 0);
#line 7178
              btdm_2AntDacSwing(padapter, 0, 192U);
#line 7180
              bCommon = 1U;
            } else {
#line 7162
              goto _L___4;
            }
          } else {
#line 7162
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
#line 7181
          tmp___4 = BTDM_IsWifiConnectionExist(padapter);
#line 7181
          if ((unsigned int )tmp___4 != 0U) {
#line 7181
            goto _L___2;
          } else {
#line 7181
            tmp___5 = check_fwstate(& padapter->mlmepriv, 2176);
#line 7181
            if ((int )tmp___5) {
              _L___2: /* CIL Label */ 
#line 7181
              if ((unsigned int )pBtdm8723->btStatus == 1U) {
#line 7184
                if (BTCoexDbgLevel == 1U) {
#line 7184
                  printk("Wifi non-idle + Bt connected idle!!\n");
                } else {

                }
#line 7186
                btdm_2AntLowPenaltyRa(padapter, 1);
#line 7187
                btdm_2AntRfShrink(padapter, 1);
#line 7188
                btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7190
                btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7191
                btdm_2AntPsTdma(padapter, 0, 0);
#line 7192
                btdm_2AntFwDacSwingLvl(padapter, 32);
#line 7193
                btdm_2AntDecBtPwr(padapter, 1);
#line 7195
                btdm_2AntAgcTable(padapter, 0);
#line 7196
                btdm_2AntAdcBackOff(padapter, 0);
#line 7197
                btdm_2AntDacSwing(padapter, 0, 192U);
#line 7199
                bCommon = 1U;
              } else {
#line 7181
                goto _L___1;
              }
            } else {
              _L___1: /* CIL Label */ 
#line 7200
              tmp___1 = BTDM_IsWifiConnectionExist(padapter);
#line 7200
              if ((unsigned int )tmp___1 == 0U) {
#line 7200
                tmp___2 = check_fwstate(& padapter->mlmepriv, 2176);
#line 7200
                if (tmp___2) {
#line 7200
                  tmp___3 = 0;
                } else {
#line 7200
                  tmp___3 = 1;
                }
#line 7200
                if (tmp___3) {
#line 7200
                  if ((unsigned int )pBtdm8723->btStatus == 2U) {
#line 7203
                    if (BTCoexDbgLevel == 1U) {
#line 7203
                      printk("Wifi idle + BT non-idle!!\n");
                    } else {

                    }
#line 7205
                    btdm_2AntLowPenaltyRa(padapter, 1);
#line 7206
                    btdm_2AntRfShrink(padapter, 1);
#line 7207
                    btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7209
                    btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7210
                    btdm_2AntPsTdma(padapter, 0, 0);
#line 7211
                    btdm_2AntFwDacSwingLvl(padapter, 32);
#line 7212
                    btdm_2AntDecBtPwr(padapter, 0);
#line 7214
                    btdm_2AntAgcTable(padapter, 0);
#line 7215
                    btdm_2AntAdcBackOff(padapter, 0);
#line 7216
                    btdm_2AntDacSwing(padapter, 0, 192U);
#line 7218
                    bCommon = 1U;
                  } else {
#line 7200
                    goto _L___0;
                  }
                } else {
#line 7200
                  goto _L___0;
                }
              } else {
                _L___0: /* CIL Label */ 
#line 7220
                if (BTCoexDbgLevel == 1U) {
#line 7220
                  printk("Wifi non-idle + BT non-idle!!\n");
                } else {

                }
#line 7221
                btdm_2AntLowPenaltyRa(padapter, 1);
#line 7222
                btdm_2AntRfShrink(padapter, 1);
#line 7223
                btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7224
                btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7225
                btdm_2AntFwDacSwingLvl(padapter, 32);
#line 7227
                bCommon = 0U;
              }
            }
          }
        }
      }
    }
  }
#line 7229
  return (bCommon);
}
}
#line 7233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2AntTdmaDurationAdjust(struct rtw_adapter *padapter , u8 bScoHid ,
                                        u8 bTxPause , u8 maxInterval ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  s32 up___0 ;
  s32 dn ;
  s32 m ;
  s32 n ;
  s32 WaitCount ;
  s32 result ;
  u8 retryCount ;
  bool tmp ;
  int tmp___0 ;

  {
#line 7236
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7237
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 7240
  retryCount = 0U;
#line 7242
  if (BTCoexDbgLevel == 1U) {
#line 7242
    printk("[BTCoex], TdmaDurationAdjust()\n");
  } else {

  }
#line 7244
  if ((unsigned int )pBtdm8723->bResetTdmaAdjust != 0U) {
#line 7245
    pBtdm8723->bResetTdmaAdjust = 0U;
#line 7246
    if (BTCoexDbgLevel == 1U) {
#line 7246
      printk("[BTCoex], first run TdmaDurationAdjust()!!\n");
    } else {

    }
#line 7247
    if ((unsigned int )bScoHid != 0U) {
#line 7248
      if ((unsigned int )bTxPause != 0U) {
#line 7249
        btdm_2AntPsTdma(padapter, 1, 15);
#line 7250
        pBtdm8723->psTdmaDuAdjType = 15U;
      } else {
#line 7252
        btdm_2AntPsTdma(padapter, 1, 11);
#line 7253
        pBtdm8723->psTdmaDuAdjType = 11U;
      }
    } else
#line 7256
    if ((unsigned int )bTxPause != 0U) {
#line 7257
      btdm_2AntPsTdma(padapter, 1, 7);
#line 7258
      pBtdm8723->psTdmaDuAdjType = 7U;
    } else {
#line 7260
      btdm_2AntPsTdma(padapter, 1, 3);
#line 7261
      pBtdm8723->psTdmaDuAdjType = 3U;
    }
#line 7264
    up___0 = 0;
#line 7265
    dn = 0;
#line 7266
    m = 1;
#line 7267
    n = 3;
#line 7268
    result = 0;
#line 7269
    WaitCount = 0;
  } else {
#line 7272
    retryCount = pHalData->bt_coexist.halCoex8723.btRetryCnt;
#line 7273
    if (BTCoexDbgLevel == 1U) {
#line 7273
      printk("[BTCoex], retryCount = %d\n", (int )retryCount);
    } else {

    }
#line 7274
    result = 0;
#line 7275
    WaitCount = WaitCount + 1;
#line 7277
    if ((unsigned int )retryCount == 0U) {
#line 7278
      up___0 = up___0 + 1;
#line 7279
      dn = dn - 1;
#line 7281
      if (dn <= 0) {
#line 7282
        dn = 0;
      } else {

      }
#line 7284
      if (up___0 >= n) {
#line 7285
        WaitCount = 0;
#line 7286
        n = 3;
#line 7287
        up___0 = 0;
#line 7288
        dn = 0;
#line 7289
        result = 1;
#line 7290
        if (BTCoexDbgLevel == 1U) {
#line 7290
          printk("[BTCoex], Increase wifi duration!!\n");
        } else {

        }
      } else {

      }
    } else
#line 7292
    if ((unsigned int )retryCount <= 3U) {
#line 7293
      up___0 = up___0 - 1;
#line 7294
      dn = dn + 1;
#line 7296
      if (up___0 <= 0) {
#line 7297
        up___0 = 0;
      } else {

      }
#line 7299
      if (dn == 2) {
#line 7300
        if (WaitCount <= 2) {
#line 7301
          m = m + 1;
        } else {
#line 7303
          m = 1;
        }
#line 7305
        if (m > 19) {
#line 7306
          m = 20;
        } else {

        }
#line 7308
        n = m * 3;
#line 7309
        up___0 = 0;
#line 7310
        dn = 0;
#line 7311
        WaitCount = 0;
#line 7312
        result = -1;
#line 7313
        if (BTCoexDbgLevel == 1U) {
#line 7313
          printk("[BTCoex], Decrease wifi duration for retryCounter<3!!\n");
        } else {

        }
      } else {

      }
    } else {
#line 7316
      if (WaitCount == 1) {
#line 7317
        m = m + 1;
      } else {
#line 7319
        m = 1;
      }
#line 7321
      if (m > 19) {
#line 7322
        m = 20;
      } else {

      }
#line 7323
      n = m * 3;
#line 7324
      up___0 = 0;
#line 7325
      dn = 0;
#line 7326
      WaitCount = 0;
#line 7327
      result = -1;
#line 7328
      if (BTCoexDbgLevel == 1U) {
#line 7328
        printk("[BTCoex], Decrease wifi duration for retryCounter>3!!\n");
      } else {

      }
    }
#line 7331
    if (BTCoexDbgLevel == 1U) {
#line 7331
      printk("[BTCoex], max Interval = %d\n", (int )maxInterval);
    } else {

    }
#line 7332
    if ((unsigned int )maxInterval == 1U) {
#line 7333
      if ((unsigned int )bTxPause != 0U) {
#line 7334
        if (BTCoexDbgLevel == 1U) {
#line 7334
          printk("[BTCoex], TxPause = 1\n");
        } else {

        }
#line 7335
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
#line 7336
          btdm_2AntPsTdma(padapter, 1, 5);
#line 7337
          pBtdm8723->psTdmaDuAdjType = 5U;
        } else
#line 7338
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7339
          btdm_2AntPsTdma(padapter, 1, 6);
#line 7340
          pBtdm8723->psTdmaDuAdjType = 6U;
        } else
#line 7341
        if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7342
          btdm_2AntPsTdma(padapter, 1, 7);
#line 7343
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
#line 7344
        if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
#line 7345
          btdm_2AntPsTdma(padapter, 1, 8);
#line 7346
          pBtdm8723->psTdmaDuAdjType = 8U;
        } else {

        }
#line 7348
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 7349
          btdm_2AntPsTdma(padapter, 1, 13);
#line 7350
          pBtdm8723->psTdmaDuAdjType = 13U;
        } else
#line 7351
        if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7352
          btdm_2AntPsTdma(padapter, 1, 14);
#line 7353
          pBtdm8723->psTdmaDuAdjType = 14U;
        } else
#line 7354
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7355
          btdm_2AntPsTdma(padapter, 1, 15);
#line 7356
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
#line 7357
        if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
#line 7358
          btdm_2AntPsTdma(padapter, 1, 16);
#line 7359
          pBtdm8723->psTdmaDuAdjType = 16U;
        } else {

        }
#line 7362
        if (result == -1) {
#line 7363
          if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
#line 7364
            btdm_2AntPsTdma(padapter, 1, 6);
#line 7365
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
#line 7366
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7367
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7368
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7369
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7370
            btdm_2AntPsTdma(padapter, 1, 8);
#line 7371
            pBtdm8723->psTdmaDuAdjType = 8U;
          } else
#line 7372
          if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
#line 7373
            btdm_2AntPsTdma(padapter, 1, 14);
#line 7374
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
#line 7375
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7376
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7377
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7378
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7379
            btdm_2AntPsTdma(padapter, 1, 16);
#line 7380
            pBtdm8723->psTdmaDuAdjType = 16U;
          } else {

          }
        } else
#line 7382
        if (result == 1) {
#line 7383
          if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
#line 7384
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7385
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7386
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7387
            btdm_2AntPsTdma(padapter, 1, 6);
#line 7388
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
#line 7389
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7390
            btdm_2AntPsTdma(padapter, 1, 5);
#line 7391
            pBtdm8723->psTdmaDuAdjType = 5U;
          } else
#line 7392
          if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
#line 7393
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7394
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7395
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7396
            btdm_2AntPsTdma(padapter, 1, 14);
#line 7397
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
#line 7398
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7399
            btdm_2AntPsTdma(padapter, 1, 13);
#line 7400
            pBtdm8723->psTdmaDuAdjType = 13U;
          } else {

          }
        } else {

        }
      } else {
#line 7404
        if (BTCoexDbgLevel == 1U) {
#line 7404
          printk("[BTCoex], TxPause = 0\n");
        } else {

        }
#line 7405
        if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
#line 7406
          btdm_2AntPsTdma(padapter, 1, 1);
#line 7407
          pBtdm8723->psTdmaDuAdjType = 1U;
        } else
#line 7408
        if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7409
          btdm_2AntPsTdma(padapter, 1, 2);
#line 7410
          pBtdm8723->psTdmaDuAdjType = 2U;
        } else
#line 7411
        if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7412
          btdm_2AntPsTdma(padapter, 1, 3);
#line 7413
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
#line 7414
        if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
#line 7415
          btdm_2AntPsTdma(padapter, 1, 4);
#line 7416
          pBtdm8723->psTdmaDuAdjType = 4U;
        } else {

        }
#line 7418
        if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
#line 7419
          btdm_2AntPsTdma(padapter, 1, 9);
#line 7420
          pBtdm8723->psTdmaDuAdjType = 9U;
        } else
#line 7421
        if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7422
          btdm_2AntPsTdma(padapter, 1, 10);
#line 7423
          pBtdm8723->psTdmaDuAdjType = 10U;
        } else
#line 7424
        if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7425
          btdm_2AntPsTdma(padapter, 1, 11);
#line 7426
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
#line 7427
        if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
#line 7428
          btdm_2AntPsTdma(padapter, 1, 12);
#line 7429
          pBtdm8723->psTdmaDuAdjType = 12U;
        } else {

        }
#line 7432
        if (result == -1) {
#line 7433
          if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
#line 7434
            btdm_2AntPsTdma(padapter, 1, 2);
#line 7435
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
#line 7436
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7437
            btdm_2AntPsTdma(padapter, 1, 3);
#line 7438
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 7439
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7440
            btdm_2AntPsTdma(padapter, 1, 4);
#line 7441
            pBtdm8723->psTdmaDuAdjType = 4U;
          } else
#line 7442
          if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 7443
            btdm_2AntPsTdma(padapter, 1, 10);
#line 7444
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
#line 7445
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7446
            btdm_2AntPsTdma(padapter, 1, 11);
#line 7447
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 7448
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7449
            btdm_2AntPsTdma(padapter, 1, 12);
#line 7450
            pBtdm8723->psTdmaDuAdjType = 12U;
          } else {

          }
        } else
#line 7452
        if (result == 1) {
#line 7453
          if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
#line 7454
            btdm_2AntPsTdma(padapter, 1, 3);
#line 7455
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 7456
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7457
            btdm_2AntPsTdma(padapter, 1, 2);
#line 7458
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
#line 7459
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7460
            btdm_2AntPsTdma(padapter, 1, 1);
#line 7461
            pBtdm8723->psTdmaDuAdjType = 1U;
          } else
#line 7462
          if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
#line 7463
            btdm_2AntPsTdma(padapter, 1, 11);
#line 7464
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 7465
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7466
            btdm_2AntPsTdma(padapter, 1, 10);
#line 7467
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
#line 7468
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7469
            btdm_2AntPsTdma(padapter, 1, 9);
#line 7470
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {

          }
        } else {

        }
      }
    } else
#line 7474
    if ((unsigned int )maxInterval == 2U) {
#line 7475
      if ((unsigned int )bTxPause != 0U) {
#line 7476
        if (BTCoexDbgLevel == 1U) {
#line 7476
          printk("[BTCoex], TxPause = 1\n");
        } else {

        }
#line 7477
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
#line 7478
          btdm_2AntPsTdma(padapter, 1, 6);
#line 7479
          pBtdm8723->psTdmaDuAdjType = 6U;
        } else
#line 7480
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7481
          btdm_2AntPsTdma(padapter, 1, 6);
#line 7482
          pBtdm8723->psTdmaDuAdjType = 6U;
        } else
#line 7483
        if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7484
          btdm_2AntPsTdma(padapter, 1, 7);
#line 7485
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
#line 7486
        if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
#line 7487
          btdm_2AntPsTdma(padapter, 1, 8);
#line 7488
          pBtdm8723->psTdmaDuAdjType = 8U;
        } else {

        }
#line 7490
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 7491
          btdm_2AntPsTdma(padapter, 1, 14);
#line 7492
          pBtdm8723->psTdmaDuAdjType = 14U;
        } else
#line 7493
        if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7494
          btdm_2AntPsTdma(padapter, 1, 14);
#line 7495
          pBtdm8723->psTdmaDuAdjType = 14U;
        } else
#line 7496
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7497
          btdm_2AntPsTdma(padapter, 1, 15);
#line 7498
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
#line 7499
        if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
#line 7500
          btdm_2AntPsTdma(padapter, 1, 16);
#line 7501
          pBtdm8723->psTdmaDuAdjType = 16U;
        } else {

        }
#line 7503
        if (result == -1) {
#line 7504
          if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
#line 7505
            btdm_2AntPsTdma(padapter, 1, 6);
#line 7506
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
#line 7507
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7508
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7509
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7510
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7511
            btdm_2AntPsTdma(padapter, 1, 8);
#line 7512
            pBtdm8723->psTdmaDuAdjType = 8U;
          } else
#line 7513
          if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
#line 7514
            btdm_2AntPsTdma(padapter, 1, 14);
#line 7515
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
#line 7516
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7517
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7518
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7519
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7520
            btdm_2AntPsTdma(padapter, 1, 16);
#line 7521
            pBtdm8723->psTdmaDuAdjType = 16U;
          } else {

          }
        } else
#line 7523
        if (result == 1) {
#line 7524
          if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
#line 7525
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7526
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7527
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7528
            btdm_2AntPsTdma(padapter, 1, 6);
#line 7529
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
#line 7530
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7531
            btdm_2AntPsTdma(padapter, 1, 6);
#line 7532
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
#line 7533
          if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
#line 7534
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7535
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7536
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7537
            btdm_2AntPsTdma(padapter, 1, 14);
#line 7538
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
#line 7539
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7540
            btdm_2AntPsTdma(padapter, 1, 14);
#line 7541
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else {

          }
        } else {

        }
      } else {
#line 7545
        if (BTCoexDbgLevel == 1U) {
#line 7545
          printk("[BTCoex], TxPause = 0\n");
        } else {

        }
#line 7546
        if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
#line 7547
          btdm_2AntPsTdma(padapter, 1, 2);
#line 7548
          pBtdm8723->psTdmaDuAdjType = 2U;
        } else
#line 7549
        if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7550
          btdm_2AntPsTdma(padapter, 1, 2);
#line 7551
          pBtdm8723->psTdmaDuAdjType = 2U;
        } else
#line 7552
        if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7553
          btdm_2AntPsTdma(padapter, 1, 3);
#line 7554
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
#line 7555
        if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
#line 7556
          btdm_2AntPsTdma(padapter, 1, 4);
#line 7557
          pBtdm8723->psTdmaDuAdjType = 4U;
        } else {

        }
#line 7559
        if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
#line 7560
          btdm_2AntPsTdma(padapter, 1, 10);
#line 7561
          pBtdm8723->psTdmaDuAdjType = 10U;
        } else
#line 7562
        if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7563
          btdm_2AntPsTdma(padapter, 1, 10);
#line 7564
          pBtdm8723->psTdmaDuAdjType = 10U;
        } else
#line 7565
        if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7566
          btdm_2AntPsTdma(padapter, 1, 11);
#line 7567
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
#line 7568
        if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
#line 7569
          btdm_2AntPsTdma(padapter, 1, 12);
#line 7570
          pBtdm8723->psTdmaDuAdjType = 12U;
        } else {

        }
#line 7572
        if (result == -1) {
#line 7573
          if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
#line 7574
            btdm_2AntPsTdma(padapter, 1, 2);
#line 7575
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
#line 7576
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7577
            btdm_2AntPsTdma(padapter, 1, 3);
#line 7578
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 7579
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7580
            btdm_2AntPsTdma(padapter, 1, 4);
#line 7581
            pBtdm8723->psTdmaDuAdjType = 4U;
          } else
#line 7582
          if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 7583
            btdm_2AntPsTdma(padapter, 1, 10);
#line 7584
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
#line 7585
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7586
            btdm_2AntPsTdma(padapter, 1, 11);
#line 7587
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 7588
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7589
            btdm_2AntPsTdma(padapter, 1, 12);
#line 7590
            pBtdm8723->psTdmaDuAdjType = 12U;
          } else {

          }
        } else
#line 7592
        if (result == 1) {
#line 7593
          if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
#line 7594
            btdm_2AntPsTdma(padapter, 1, 3);
#line 7595
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 7596
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7597
            btdm_2AntPsTdma(padapter, 1, 2);
#line 7598
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
#line 7599
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7600
            btdm_2AntPsTdma(padapter, 1, 2);
#line 7601
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
#line 7602
          if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
#line 7603
            btdm_2AntPsTdma(padapter, 1, 11);
#line 7604
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 7605
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7606
            btdm_2AntPsTdma(padapter, 1, 10);
#line 7607
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
#line 7608
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7609
            btdm_2AntPsTdma(padapter, 1, 10);
#line 7610
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else {

          }
        } else {

        }
      }
    } else
#line 7614
    if ((unsigned int )maxInterval == 3U) {
#line 7615
      if ((unsigned int )bTxPause != 0U) {
#line 7616
        if (BTCoexDbgLevel == 1U) {
#line 7616
          printk("[BTCoex], TxPause = 1\n");
        } else {

        }
#line 7617
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
#line 7618
          btdm_2AntPsTdma(padapter, 1, 7);
#line 7619
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
#line 7620
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7621
          btdm_2AntPsTdma(padapter, 1, 7);
#line 7622
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
#line 7623
        if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7624
          btdm_2AntPsTdma(padapter, 1, 7);
#line 7625
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
#line 7626
        if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
#line 7627
          btdm_2AntPsTdma(padapter, 1, 8);
#line 7628
          pBtdm8723->psTdmaDuAdjType = 8U;
        } else {

        }
#line 7630
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 7631
          btdm_2AntPsTdma(padapter, 1, 15);
#line 7632
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
#line 7633
        if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7634
          btdm_2AntPsTdma(padapter, 1, 15);
#line 7635
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
#line 7636
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7637
          btdm_2AntPsTdma(padapter, 1, 15);
#line 7638
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
#line 7639
        if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
#line 7640
          btdm_2AntPsTdma(padapter, 1, 16);
#line 7641
          pBtdm8723->psTdmaDuAdjType = 16U;
        } else {

        }
#line 7643
        if (result == -1) {
#line 7644
          if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
#line 7645
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7646
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7647
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7648
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7649
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7650
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7651
            btdm_2AntPsTdma(padapter, 1, 8);
#line 7652
            pBtdm8723->psTdmaDuAdjType = 8U;
          } else
#line 7653
          if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
#line 7654
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7655
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7656
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7657
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7658
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7659
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7660
            btdm_2AntPsTdma(padapter, 1, 16);
#line 7661
            pBtdm8723->psTdmaDuAdjType = 16U;
          } else {

          }
        } else
#line 7663
        if (result == 1) {
#line 7664
          if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
#line 7665
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7666
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7667
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7668
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7669
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7670
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7671
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7672
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7673
          if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
#line 7674
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7675
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7676
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7677
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7678
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7679
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7680
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7681
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else {

          }
        } else {

        }
      } else {
#line 7685
        if (BTCoexDbgLevel == 1U) {
#line 7685
          printk("[BTCoex], TxPause = 0\n");
        } else {

        }
#line 7686
        if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
#line 7687
          btdm_2AntPsTdma(padapter, 1, 3);
#line 7688
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
#line 7689
        if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7690
          btdm_2AntPsTdma(padapter, 1, 3);
#line 7691
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
#line 7692
        if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7693
          btdm_2AntPsTdma(padapter, 1, 3);
#line 7694
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
#line 7695
        if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
#line 7696
          btdm_2AntPsTdma(padapter, 1, 4);
#line 7697
          pBtdm8723->psTdmaDuAdjType = 4U;
        } else {

        }
#line 7699
        if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
#line 7700
          btdm_2AntPsTdma(padapter, 1, 11);
#line 7701
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
#line 7702
        if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7703
          btdm_2AntPsTdma(padapter, 1, 11);
#line 7704
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
#line 7705
        if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7706
          btdm_2AntPsTdma(padapter, 1, 11);
#line 7707
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
#line 7708
        if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
#line 7709
          btdm_2AntPsTdma(padapter, 1, 12);
#line 7710
          pBtdm8723->psTdmaDuAdjType = 12U;
        } else {

        }
#line 7712
        if (result == -1) {
#line 7713
          if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
#line 7714
            btdm_2AntPsTdma(padapter, 1, 3);
#line 7715
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 7716
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7717
            btdm_2AntPsTdma(padapter, 1, 3);
#line 7718
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 7719
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7720
            btdm_2AntPsTdma(padapter, 1, 4);
#line 7721
            pBtdm8723->psTdmaDuAdjType = 4U;
          } else
#line 7722
          if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 7723
            btdm_2AntPsTdma(padapter, 1, 11);
#line 7724
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 7725
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7726
            btdm_2AntPsTdma(padapter, 1, 11);
#line 7727
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 7728
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7729
            btdm_2AntPsTdma(padapter, 1, 12);
#line 7730
            pBtdm8723->psTdmaDuAdjType = 12U;
          } else {

          }
        } else
#line 7732
        if (result == 1) {
#line 7733
          if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
#line 7734
            btdm_2AntPsTdma(padapter, 1, 3);
#line 7735
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 7736
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7737
            btdm_2AntPsTdma(padapter, 1, 3);
#line 7738
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 7739
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7740
            btdm_2AntPsTdma(padapter, 1, 3);
#line 7741
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 7742
          if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
#line 7743
            btdm_2AntPsTdma(padapter, 1, 11);
#line 7744
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 7745
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7746
            btdm_2AntPsTdma(padapter, 1, 11);
#line 7747
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 7748
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7749
            btdm_2AntPsTdma(padapter, 1, 11);
#line 7750
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else {

          }
        } else {

        }
      }
    } else {

    }
  }
#line 7756
  if (BTCoexDbgLevel == 1U) {
#line 7756
    printk("[BTCoex], PsTdma type : recordPsTdma =%d\n", (int )pBtdm8723->psTdmaDuAdjType);
  } else {

  }
#line 7759
  if ((int )pBtdm8723->curPsTdma != (int )pBtdm8723->psTdmaDuAdjType) {
#line 7760
    if (BTCoexDbgLevel == 1U) {
#line 7760
      printk("[BTCoex], PsTdma type dismatch!!!, curPsTdma =%d, recordPsTdma =%d\n",
             (int )pBtdm8723->curPsTdma, (int )pBtdm8723->psTdmaDuAdjType);
    } else {

    }
#line 7763
    tmp = check_fwstate(& padapter->mlmepriv, 2176);
#line 7763
    if (tmp) {
#line 7763
      tmp___0 = 0;
    } else {
#line 7763
      tmp___0 = 1;
    }
#line 7763
    if (tmp___0) {
#line 7764
      btdm_2AntPsTdma(padapter, 1, (int )pBtdm8723->psTdmaDuAdjType);
    } else
#line 7766
    if (BTCoexDbgLevel == 1U) {
#line 7766
      printk("[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n");
    } else {

    }
  } else {

  }
#line 7768
  return;
}
}
#line 7772 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2Ant8723ASCOAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 7776
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 7776
  if ((unsigned int )tmp != 0U) {
#line 7777
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 7779
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 7781
  tmp___0 = BTDM_IsHT40(padapter);
#line 7781
  if ((unsigned int )tmp___0 != 0U) {
#line 7782
    if (BTCoexDbgLevel == 1U) {
#line 7782
      printk("HT40\n");
    } else {

    }
#line 7783
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 7785
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 7787
      if (BTCoexDbgLevel == 1U) {
#line 7787
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 7788
      rtl8723au_write8(padapter, 2179, 64);
#line 7789
      btdm_2AntPsTdma(padapter, 1, 11);
    } else {
#line 7791
      if (BTCoexDbgLevel == 1U) {
#line 7791
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 7792
      btdm_2AntPsTdma(padapter, 1, 15);
    }
#line 7796
    btdm_2AntAgcTable(padapter, 0);
#line 7797
    btdm_2AntAdcBackOff(padapter, 1);
#line 7798
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 7800
    if (BTCoexDbgLevel == 1U) {
#line 7800
      printk("HT20 or Legacy\n");
    } else {

    }
#line 7801
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 7802
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
#line 7805
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 7807
      if (BTCoexDbgLevel == 1U) {
#line 7807
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 7808
      rtl8723au_write8(padapter, 2179, 64);
#line 7809
      btdm_2AntPsTdma(padapter, 1, 11);
    } else {
#line 7811
      if (BTCoexDbgLevel == 1U) {
#line 7811
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 7812
      btdm_2AntPsTdma(padapter, 1, 15);
    }
#line 7816
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 7818
      if (BTCoexDbgLevel == 1U) {
#line 7818
        printk("Wifi rssi high \n");
      } else {

      }
#line 7819
      btdm_2AntAgcTable(padapter, 1);
#line 7820
      btdm_2AntAdcBackOff(padapter, 1);
#line 7821
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 7823
      if (BTCoexDbgLevel == 1U) {
#line 7823
        printk("Wifi rssi low \n");
      } else {

      }
#line 7824
      btdm_2AntAgcTable(padapter, 0);
#line 7825
      btdm_2AntAdcBackOff(padapter, 0);
#line 7826
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 7829
  return;
}
}
#line 7831 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2Ant8723AHIDAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 7835
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 7835
  if ((unsigned int )tmp != 0U) {
#line 7836
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 7838
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 7840
  tmp___0 = BTDM_IsHT40(padapter);
#line 7840
  if ((unsigned int )tmp___0 != 0U) {
#line 7841
    if (BTCoexDbgLevel == 1U) {
#line 7841
      printk("HT40\n");
    } else {

    }
#line 7842
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 7844
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 7846
      if (BTCoexDbgLevel == 1U) {
#line 7846
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 7847
      rtl8723au_write8(padapter, 2179, 64);
#line 7848
      btdm_2AntPsTdma(padapter, 1, 9);
    } else {
#line 7850
      if (BTCoexDbgLevel == 1U) {
#line 7850
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 7851
      btdm_2AntPsTdma(padapter, 1, 13);
    }
#line 7855
    btdm_2AntAgcTable(padapter, 0);
#line 7856
    btdm_2AntAdcBackOff(padapter, 0);
#line 7857
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 7859
    if (BTCoexDbgLevel == 1U) {
#line 7859
      printk("HT20 or Legacy\n");
    } else {

    }
#line 7860
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 7861
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
#line 7864
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 7866
      if (BTCoexDbgLevel == 1U) {
#line 7866
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 7867
      rtl8723au_write8(padapter, 2179, 64);
#line 7868
      btdm_2AntPsTdma(padapter, 1, 9);
    } else {
#line 7870
      if (BTCoexDbgLevel == 1U) {
#line 7870
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 7871
      btdm_2AntPsTdma(padapter, 1, 13);
    }
#line 7875
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 7877
      if (BTCoexDbgLevel == 1U) {
#line 7877
        printk("Wifi rssi high \n");
      } else {

      }
#line 7878
      btdm_2AntAgcTable(padapter, 1);
#line 7879
      btdm_2AntAdcBackOff(padapter, 1);
#line 7880
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 7882
      if (BTCoexDbgLevel == 1U) {
#line 7882
        printk("Wifi rssi low \n");
      } else {

      }
#line 7883
      btdm_2AntAgcTable(padapter, 0);
#line 7884
      btdm_2AntAdcBackOff(padapter, 0);
#line 7885
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 7888
  return;
}
}
#line 7891 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2Ant8723AA2DPAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  struct hal_data_8723a *pHalData ;
  u8 btInfoExt ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 7894
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7895
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
#line 7897
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 7897
  if ((unsigned int )tmp != 0U) {
#line 7898
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 7900
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 7902
  tmp___0 = BTDM_IsHT40(padapter);
#line 7902
  if ((unsigned int )tmp___0 != 0U) {
#line 7903
    if (BTCoexDbgLevel == 1U) {
#line 7903
      printk("HT40\n");
    } else {

    }
#line 7904
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 7907
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 7909
      if (BTCoexDbgLevel == 1U) {
#line 7909
        printk("Wifi rssi high \n");
      } else {

      }
#line 7910
      rtl8723au_write8(padapter, 2179, 64);
#line 7912
      if ((int )btInfoExt & 1) {
#line 7913
        if (BTCoexDbgLevel == 1U) {
#line 7913
          printk("a2dp basic rate \n");
        } else {

        }
#line 7914
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 3);
      } else {
#line 7916
        if (BTCoexDbgLevel == 1U) {
#line 7916
          printk("a2dp edr rate \n");
        } else {

        }
#line 7917
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
      }
    } else {
#line 7920
      if (BTCoexDbgLevel == 1U) {
#line 7920
        printk("Wifi rssi low \n");
      } else {

      }
#line 7921
      if ((int )btInfoExt & 1) {
#line 7922
        if (BTCoexDbgLevel == 1U) {
#line 7922
          printk("a2dp basic rate \n");
        } else {

        }
#line 7923
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 3);
      } else {
#line 7925
        if (BTCoexDbgLevel == 1U) {
#line 7925
          printk("a2dp edr rate \n");
        } else {

        }
#line 7926
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
      }
    }
#line 7931
    btdm_2AntAgcTable(padapter, 0);
#line 7932
    btdm_2AntAdcBackOff(padapter, 1);
#line 7933
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 7935
    if (BTCoexDbgLevel == 1U) {
#line 7935
      printk("HT20 or Legacy\n");
    } else {

    }
#line 7936
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 7937
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
#line 7940
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 7942
      if (BTCoexDbgLevel == 1U) {
#line 7942
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 7943
      rtl8723au_write8(padapter, 2179, 64);
#line 7944
      if ((int )btInfoExt & 1) {
#line 7945
        if (BTCoexDbgLevel == 1U) {
#line 7945
          printk("a2dp basic rate \n");
        } else {

        }
#line 7946
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 3);
      } else {
#line 7948
        if (BTCoexDbgLevel == 1U) {
#line 7948
          printk("a2dp edr rate \n");
        } else {

        }
#line 7949
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
      }
    } else {
#line 7952
      if (BTCoexDbgLevel == 1U) {
#line 7952
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 7953
      if ((int )btInfoExt & 1) {
#line 7954
        if (BTCoexDbgLevel == 1U) {
#line 7954
          printk("a2dp basic rate \n");
        } else {

        }
#line 7955
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 3);
      } else {
#line 7957
        if (BTCoexDbgLevel == 1U) {
#line 7957
          printk("a2dp edr rate \n");
        } else {

        }
#line 7958
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
      }
    }
#line 7963
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 7965
      if (BTCoexDbgLevel == 1U) {
#line 7965
        printk("Wifi rssi high \n");
      } else {

      }
#line 7966
      btdm_2AntAgcTable(padapter, 1);
#line 7967
      btdm_2AntAdcBackOff(padapter, 1);
#line 7968
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 7970
      if (BTCoexDbgLevel == 1U) {
#line 7970
        printk("Wifi rssi low \n");
      } else {

      }
#line 7971
      btdm_2AntAgcTable(padapter, 0);
#line 7972
      btdm_2AntAdcBackOff(padapter, 0);
#line 7973
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 7976
  return;
}
}
#line 7978 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2Ant8723APANEDRAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 7982
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 7982
  if ((unsigned int )tmp != 0U) {
#line 7983
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 7985
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 7987
  tmp___0 = BTDM_IsHT40(padapter);
#line 7987
  if ((unsigned int )tmp___0 != 0U) {
#line 7988
    if (BTCoexDbgLevel == 1U) {
#line 7988
      printk("HT40\n");
    } else {

    }
#line 7989
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 7992
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 7994
      if (BTCoexDbgLevel == 1U) {
#line 7994
        printk("Wifi rssi high \n");
      } else {

      }
#line 7995
      rtl8723au_write8(padapter, 2179, 64);
#line 7996
      btdm_2AntPsTdma(padapter, 1, 2);
    } else {
#line 7998
      if (BTCoexDbgLevel == 1U) {
#line 7998
        printk("Wifi rssi low \n");
      } else {

      }
#line 7999
      btdm_2AntPsTdma(padapter, 1, 6);
    }
#line 8003
    btdm_2AntAgcTable(padapter, 0);
#line 8004
    btdm_2AntAdcBackOff(padapter, 1);
#line 8005
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8007
    if (BTCoexDbgLevel == 1U) {
#line 8007
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8008
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8009
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
#line 8012
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8014
      if (BTCoexDbgLevel == 1U) {
#line 8014
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8015
      rtl8723au_write8(padapter, 2179, 64);
#line 8016
      btdm_2AntPsTdma(padapter, 1, 2);
    } else {
#line 8018
      if (BTCoexDbgLevel == 1U) {
#line 8018
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8019
      btdm_2AntPsTdma(padapter, 1, 6);
    }
#line 8023
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8025
      if (BTCoexDbgLevel == 1U) {
#line 8025
        printk("Wifi rssi high \n");
      } else {

      }
#line 8026
      btdm_2AntAgcTable(padapter, 1);
#line 8027
      btdm_2AntAdcBackOff(padapter, 1);
#line 8028
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8030
      if (BTCoexDbgLevel == 1U) {
#line 8030
        printk("Wifi rssi low \n");
      } else {

      }
#line 8031
      btdm_2AntAgcTable(padapter, 0);
#line 8032
      btdm_2AntAdcBackOff(padapter, 0);
#line 8033
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8036
  return;
}
}
#line 8039 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2Ant8723APANHSAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 tmp ;

  {
#line 8043
  tmp = BTDM_IsHT40(padapter);
#line 8043
  if ((unsigned int )tmp != 0U) {
#line 8044
    if (BTCoexDbgLevel == 1U) {
#line 8044
      printk("HT40\n");
    } else {

    }
#line 8045
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);
#line 8047
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8049
      if (BTCoexDbgLevel == 1U) {
#line 8049
        printk("Wifi rssi high \n");
      } else {

      }
#line 8050
      btdm_2AntDecBtPwr(padapter, 1);
    } else {
#line 8052
      if (BTCoexDbgLevel == 1U) {
#line 8052
        printk("Wifi rssi low \n");
      } else {

      }
#line 8053
      btdm_2AntDecBtPwr(padapter, 0);
    }
#line 8055
    btdm_2AntPsTdma(padapter, 0, 0);
#line 8058
    btdm_2AntAgcTable(padapter, 0);
#line 8059
    btdm_2AntAdcBackOff(padapter, 1);
#line 8060
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8062
    if (BTCoexDbgLevel == 1U) {
#line 8062
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8063
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);
#line 8065
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8067
      if (BTCoexDbgLevel == 1U) {
#line 8067
        printk("Wifi rssi high\n");
      } else {

      }
#line 8069
      btdm_2AntDecBtPwr(padapter, 1);
#line 8070
      btdm_2AntPsTdma(padapter, 0, 0);
#line 8073
      btdm_2AntAgcTable(padapter, 1);
#line 8074
      btdm_2AntAdcBackOff(padapter, 1);
#line 8075
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8077
      if (BTCoexDbgLevel == 1U) {
#line 8077
        printk("Wifi rssi low\n");
      } else {

      }
#line 8079
      btdm_2AntDecBtPwr(padapter, 0);
#line 8080
      btdm_2AntPsTdma(padapter, 0, 0);
#line 8083
      btdm_2AntAgcTable(padapter, 0);
#line 8084
      btdm_2AntAdcBackOff(padapter, 0);
#line 8085
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8088
  return;
}
}
#line 8091 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2Ant8723APANEDRA2DPAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 8094
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8096
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
#line 8098
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 8098
  if ((unsigned int )tmp != 0U) {
#line 8099
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 8101
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 8103
  tmp___0 = BTDM_IsHT40(padapter);
#line 8103
  if ((unsigned int )tmp___0 != 0U) {
#line 8104
    if (BTCoexDbgLevel == 1U) {
#line 8104
      printk("HT40\n");
    } else {

    }
#line 8105
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8107
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8109
      if (BTCoexDbgLevel == 1U) {
#line 8109
        printk("Wifi rssi high \n");
      } else {

      }
#line 8111
      rtl8723au_write8(padapter, 2179, 64);
#line 8113
      if ((int )btInfoExt & 1) {
#line 8114
        if (BTCoexDbgLevel == 1U) {
#line 8114
          printk("a2dp basic rate \n");
        } else {

        }
#line 8115
        btdm_2AntPsTdma(padapter, 1, 4);
      } else {
#line 8117
        if (BTCoexDbgLevel == 1U) {
#line 8117
          printk("a2dp edr rate \n");
        } else {

        }
#line 8118
        btdm_2AntPsTdma(padapter, 1, 2);
      }
    } else {
#line 8121
      if (BTCoexDbgLevel == 1U) {
#line 8121
        printk("Wifi rssi low \n");
      } else {

      }
#line 8123
      if ((int )btInfoExt & 1) {
#line 8124
        if (BTCoexDbgLevel == 1U) {
#line 8124
          printk("a2dp basic rate \n");
        } else {

        }
#line 8125
        btdm_2AntPsTdma(padapter, 1, 8);
      } else {
#line 8127
        if (BTCoexDbgLevel == 1U) {
#line 8127
          printk("a2dp edr rate \n");
        } else {

        }
#line 8128
        btdm_2AntPsTdma(padapter, 1, 6);
      }
    }
#line 8133
    btdm_2AntAgcTable(padapter, 0);
#line 8134
    btdm_2AntAdcBackOff(padapter, 1);
#line 8135
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8137
    if (BTCoexDbgLevel == 1U) {
#line 8137
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8138
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8139
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
#line 8141
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8143
      if (BTCoexDbgLevel == 1U) {
#line 8143
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8144
      rtl8723au_write8(padapter, 2179, 64);
#line 8146
      if ((int )btInfoExt & 1) {
#line 8147
        if (BTCoexDbgLevel == 1U) {
#line 8147
          printk("a2dp basic rate \n");
        } else {

        }
#line 8148
        btdm_2AntPsTdma(padapter, 1, 4);
      } else {
#line 8150
        if (BTCoexDbgLevel == 1U) {
#line 8150
          printk("a2dp edr rate \n");
        } else {

        }
#line 8151
        btdm_2AntPsTdma(padapter, 1, 2);
      }
    } else {
#line 8154
      if (BTCoexDbgLevel == 1U) {
#line 8154
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8156
      if ((int )btInfoExt & 1) {
#line 8157
        if (BTCoexDbgLevel == 1U) {
#line 8157
          printk("a2dp basic rate \n");
        } else {

        }
#line 8158
        btdm_2AntPsTdma(padapter, 1, 8);
      } else {
#line 8160
        if (BTCoexDbgLevel == 1U) {
#line 8160
          printk("a2dp edr rate \n");
        } else {

        }
#line 8161
        btdm_2AntPsTdma(padapter, 1, 6);
      }
    }
#line 8166
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8168
      if (BTCoexDbgLevel == 1U) {
#line 8168
        printk("Wifi rssi high \n");
      } else {

      }
#line 8169
      btdm_2AntAgcTable(padapter, 1);
#line 8170
      btdm_2AntAdcBackOff(padapter, 1);
#line 8171
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8173
      if (BTCoexDbgLevel == 1U) {
#line 8173
        printk("Wifi rssi low \n");
      } else {

      }
#line 8174
      btdm_2AntAgcTable(padapter, 0);
#line 8175
      btdm_2AntAdcBackOff(padapter, 0);
#line 8176
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8179
  return;
}
}
#line 8181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2Ant8723APANEDRHIDAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 8185
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 8185
  if ((unsigned int )tmp != 0U) {
#line 8186
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 8188
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 8190
  tmp___0 = BTDM_IsHT40(padapter);
#line 8190
  if ((unsigned int )tmp___0 != 0U) {
#line 8191
    if (BTCoexDbgLevel == 1U) {
#line 8191
      printk("HT40\n");
    } else {

    }
#line 8192
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8194
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8196
      if (BTCoexDbgLevel == 1U) {
#line 8196
        printk("Wifi rssi high \n");
      } else {

      }
#line 8197
      rtl8723au_write8(padapter, 2179, 64);
#line 8198
      btdm_2AntPsTdma(padapter, 1, 10);
    } else {
#line 8200
      if (BTCoexDbgLevel == 1U) {
#line 8200
        printk("Wifi rssi low \n");
      } else {

      }
#line 8201
      btdm_2AntPsTdma(padapter, 1, 14);
    }
#line 8205
    btdm_2AntAgcTable(padapter, 0);
#line 8206
    btdm_2AntAdcBackOff(padapter, 1);
#line 8207
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8209
    if (BTCoexDbgLevel == 1U) {
#line 8209
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8210
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8211
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
#line 8214
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8216
      if (BTCoexDbgLevel == 1U) {
#line 8216
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8217
      rtl8723au_write8(padapter, 2179, 64);
#line 8218
      btdm_2AntPsTdma(padapter, 1, 10);
    } else {
#line 8220
      if (BTCoexDbgLevel == 1U) {
#line 8220
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8221
      btdm_2AntPsTdma(padapter, 1, 14);
    }
#line 8225
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8227
      if (BTCoexDbgLevel == 1U) {
#line 8227
        printk("Wifi rssi high \n");
      } else {

      }
#line 8228
      btdm_2AntAgcTable(padapter, 1);
#line 8229
      btdm_2AntAdcBackOff(padapter, 1);
#line 8230
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8232
      if (BTCoexDbgLevel == 1U) {
#line 8232
        printk("Wifi rssi low \n");
      } else {

      }
#line 8233
      btdm_2AntAgcTable(padapter, 0);
#line 8234
      btdm_2AntAdcBackOff(padapter, 0);
#line 8235
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8238
  return;
}
}
#line 8241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2Ant8723AHIDA2DPPANEDRAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 8244
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8246
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
#line 8248
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 8248
  if ((unsigned int )tmp != 0U) {
#line 8249
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 8251
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 8253
  tmp___0 = BTDM_IsHT40(padapter);
#line 8253
  if ((unsigned int )tmp___0 != 0U) {
#line 8254
    if (BTCoexDbgLevel == 1U) {
#line 8254
      printk("HT40\n");
    } else {

    }
#line 8255
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8256
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8258
      if (BTCoexDbgLevel == 1U) {
#line 8258
        printk("Wifi rssi high \n");
      } else {

      }
#line 8259
      rtl8723au_write8(padapter, 2179, 64);
#line 8261
      if ((int )btInfoExt & 1) {
#line 8262
        if (BTCoexDbgLevel == 1U) {
#line 8262
          printk("a2dp basic rate \n");
        } else {

        }
#line 8263
        btdm_2AntPsTdma(padapter, 1, 12);
      } else {
#line 8265
        if (BTCoexDbgLevel == 1U) {
#line 8265
          printk("a2dp edr rate \n");
        } else {

        }
#line 8266
        btdm_2AntPsTdma(padapter, 1, 10);
      }
    } else {
#line 8269
      if (BTCoexDbgLevel == 1U) {
#line 8269
        printk("Wifi rssi low \n");
      } else {

      }
#line 8270
      if ((int )btInfoExt & 1) {
#line 8271
        if (BTCoexDbgLevel == 1U) {
#line 8271
          printk("a2dp basic rate \n");
        } else {

        }
#line 8272
        btdm_2AntPsTdma(padapter, 1, 16);
      } else {
#line 8274
        if (BTCoexDbgLevel == 1U) {
#line 8274
          printk("a2dp edr rate \n");
        } else {

        }
#line 8275
        btdm_2AntPsTdma(padapter, 1, 14);
      }
    }
#line 8280
    btdm_2AntAgcTable(padapter, 0);
#line 8281
    btdm_2AntAdcBackOff(padapter, 1);
#line 8282
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8284
    if (BTCoexDbgLevel == 1U) {
#line 8284
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8285
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 37, 0);
#line 8286
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 27, 0);
#line 8287
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8289
      if (BTCoexDbgLevel == 1U) {
#line 8289
        printk("Wifi rssi high \n");
      } else {

      }
#line 8290
      rtl8723au_write8(padapter, 2179, 64);
#line 8292
      if ((int )btInfoExt & 1) {
#line 8293
        if (BTCoexDbgLevel == 1U) {
#line 8293
          printk("a2dp basic rate \n");
        } else {

        }
#line 8294
        btdm_2AntPsTdma(padapter, 1, 12);
      } else {
#line 8296
        if (BTCoexDbgLevel == 1U) {
#line 8296
          printk("a2dp edr rate \n");
        } else {

        }
#line 8297
        btdm_2AntPsTdma(padapter, 1, 10);
      }
    } else {
#line 8300
      if (BTCoexDbgLevel == 1U) {
#line 8300
        printk("Wifi rssi low \n");
      } else {

      }
#line 8301
      if ((int )btInfoExt & 1) {
#line 8302
        if (BTCoexDbgLevel == 1U) {
#line 8302
          printk("a2dp basic rate \n");
        } else {

        }
#line 8303
        btdm_2AntPsTdma(padapter, 1, 16);
      } else {
#line 8305
        if (BTCoexDbgLevel == 1U) {
#line 8305
          printk("a2dp edr rate \n");
        } else {

        }
#line 8306
        btdm_2AntPsTdma(padapter, 1, 14);
      }
    }
#line 8311
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8313
      if (BTCoexDbgLevel == 1U) {
#line 8313
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8314
      btdm_2AntAgcTable(padapter, 1);
#line 8315
      btdm_2AntAdcBackOff(padapter, 1);
#line 8316
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8318
      if (BTCoexDbgLevel == 1U) {
#line 8318
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8319
      btdm_2AntAgcTable(padapter, 0);
#line 8320
      btdm_2AntAdcBackOff(padapter, 0);
#line 8321
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8324
  return;
}
}
#line 8326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2Ant8723AHIDA2DPAction(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 8328
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8331
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
#line 8333
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 8333
  if ((unsigned int )tmp != 0U) {
#line 8334
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 8336
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 8338
  tmp___0 = BTDM_IsHT40(padapter);
#line 8338
  if ((unsigned int )tmp___0 != 0U) {
#line 8339
    if (BTCoexDbgLevel == 1U) {
#line 8339
      printk("HT40\n");
    } else {

    }
#line 8340
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8341
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8343
      if (BTCoexDbgLevel == 1U) {
#line 8343
        printk("Wifi rssi high \n");
      } else {

      }
#line 8344
      rtl8723au_write8(padapter, 2179, 64);
#line 8346
      if ((int )btInfoExt & 1) {
#line 8347
        if (BTCoexDbgLevel == 1U) {
#line 8347
          printk("a2dp basic rate \n");
        } else {

        }
#line 8348
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 3);
      } else {
#line 8350
        if (BTCoexDbgLevel == 1U) {
#line 8350
          printk("a2dp edr rate \n");
        } else {

        }
#line 8351
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 1);
      }
    } else {
#line 8354
      if (BTCoexDbgLevel == 1U) {
#line 8354
        printk("Wifi rssi low \n");
      } else {

      }
#line 8355
      if ((int )btInfoExt & 1) {
#line 8356
        if (BTCoexDbgLevel == 1U) {
#line 8356
          printk("a2dp basic rate \n");
        } else {

        }
#line 8357
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 3);
      } else {
#line 8359
        if (BTCoexDbgLevel == 1U) {
#line 8359
          printk("a2dp edr rate \n");
        } else {

        }
#line 8360
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 1);
      }
    }
#line 8364
    btdm_2AntAgcTable(padapter, 0);
#line 8365
    btdm_2AntAdcBackOff(padapter, 1);
#line 8366
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8368
    if (BTCoexDbgLevel == 1U) {
#line 8368
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8369
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8370
    btRssiState1 = BTDM_CheckCoexRSSIState(padapter, 2, 27, 0);
#line 8372
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8374
      if (BTCoexDbgLevel == 1U) {
#line 8374
        printk("Wifi rssi high \n");
      } else {

      }
#line 8375
      rtl8723au_write8(padapter, 2179, 64);
#line 8377
      if ((int )btInfoExt & 1) {
#line 8378
        if (BTCoexDbgLevel == 1U) {
#line 8378
          printk("a2dp basic rate \n");
        } else {

        }
#line 8379
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 3);
      } else {
#line 8381
        if (BTCoexDbgLevel == 1U) {
#line 8381
          printk("a2dp edr rate \n");
        } else {

        }
#line 8382
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 1);
      }
    } else {
#line 8385
      if (BTCoexDbgLevel == 1U) {
#line 8385
        printk("Wifi rssi low \n");
      } else {

      }
#line 8386
      if ((int )btInfoExt & 1) {
#line 8387
        if (BTCoexDbgLevel == 1U) {
#line 8387
          printk("a2dp basic rate \n");
        } else {

        }
#line 8388
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 3);
      } else {
#line 8390
        if (BTCoexDbgLevel == 1U) {
#line 8390
          printk("a2dp edr rate \n");
        } else {

        }
#line 8391
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 1);
      }
    }
#line 8394
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8396
      if (BTCoexDbgLevel == 1U) {
#line 8396
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8398
      btdm_2AntAgcTable(padapter, 1);
#line 8399
      btdm_2AntAdcBackOff(padapter, 1);
#line 8400
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8402
      if (BTCoexDbgLevel == 1U) {
#line 8402
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8404
      btdm_2AntAgcTable(padapter, 0);
#line 8405
      btdm_2AntAdcBackOff(padapter, 0);
#line 8406
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8409
  return;
}
}
#line 8411 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_2Ant8723AA2dp(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 8413
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8416
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
#line 8418
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 8418
  if ((unsigned int )tmp != 0U) {
#line 8419
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 8421
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 8423
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 8424
  btdm_2AntIgnoreWlanAct(padapter, 0);
#line 8426
  tmp___0 = BTDM_IsHT40(padapter);
#line 8426
  if ((unsigned int )tmp___0 != 0U) {
#line 8427
    if (BTCoexDbgLevel == 1U) {
#line 8427
      printk("HT40\n");
    } else {

    }
#line 8428
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8430
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8432
      if (BTCoexDbgLevel == 1U) {
#line 8432
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8433
      rtl8723au_write8(padapter, 2179, 64);
#line 8434
      btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
    } else {
#line 8436
      if (BTCoexDbgLevel == 1U) {
#line 8436
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8437
      btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
    }
#line 8441
    btdm_2AntAgcTable(padapter, 0);
#line 8442
    btdm_2AntAdcBackOff(padapter, 1);
#line 8443
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8445
    if (BTCoexDbgLevel == 1U) {
#line 8445
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8446
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);
#line 8447
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
#line 8450
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8452
      if (BTCoexDbgLevel == 1U) {
#line 8452
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8453
      rtl8723au_write8(padapter, 2179, 64);
#line 8454
      btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
    } else {
#line 8456
      if (BTCoexDbgLevel == 1U) {
#line 8456
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8457
      btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
    }
#line 8461
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8463
      if (BTCoexDbgLevel == 1U) {
#line 8463
        printk("Wifi rssi high \n");
      } else {

      }
#line 8464
      btdm_2AntAgcTable(padapter, 1);
#line 8465
      btdm_2AntAdcBackOff(padapter, 1);
#line 8466
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8468
      if (BTCoexDbgLevel == 1U) {
#line 8468
        printk("Wifi rssi low \n");
      } else {

      }
#line 8469
      btdm_2AntAgcTable(padapter, 0);
#line 8470
      btdm_2AntAdcBackOff(padapter, 0);
#line 8471
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8474
  return;
}
}
#line 8477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_2AntParaInit(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 8480
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8481
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 8483
  if (BTCoexDbgLevel == 1U) {
#line 8483
    printk("[BTCoex], 2Ant Parameter Init!!\n");
  } else {

  }
#line 8486
  rtl8723au_write8(padapter, 1902, 4);
#line 8487
  rtl8723au_write8(padapter, 1912, 3);
#line 8488
  rtl8723au_write8(padapter, 64, 32);
#line 8491
  pBtdm8723->preVal0x6c0 = 0U;
#line 8492
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 8494
  pBtdm8723->bPrePsTdmaOn = 1U;
#line 8495
  btdm_2AntPsTdma(padapter, 0, 0);
#line 8497
  pBtdm8723->preFwDacSwingLvl = 16U;
#line 8498
  btdm_2AntFwDacSwingLvl(padapter, 32);
#line 8500
  pBtdm8723->bPreDecBtPwr = 1U;
#line 8501
  btdm_2AntDecBtPwr(padapter, 0);
#line 8503
  pBtdm8723->bPreAgcTableEn = 1U;
#line 8504
  btdm_2AntAgcTable(padapter, 0);
#line 8506
  pBtdm8723->bPreAdcBackOff = 1U;
#line 8507
  btdm_2AntAdcBackOff(padapter, 0);
#line 8509
  pBtdm8723->bPreLowPenaltyRa = 1U;
#line 8510
  btdm_2AntLowPenaltyRa(padapter, 0);
#line 8512
  pBtdm8723->bPreRfRxLpfShrink = 1U;
#line 8513
  btdm_2AntRfShrink(padapter, 0);
#line 8515
  pBtdm8723->bPreDacSwingOn = 1U;
#line 8516
  btdm_2AntDacSwing(padapter, 0, 192U);
#line 8518
  pBtdm8723->bPreIgnoreWlanAct = 1U;
#line 8519
  btdm_2AntIgnoreWlanAct(padapter, 0);
#line 8520
  return;
}
}
#line 8522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_2AntHwCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 


  {
#line 8524
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 8525
  return;
}
}
#line 8527 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_2AntFwCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 


  {
#line 8529
  btdm_2AntIgnoreWlanAct(padapter, 0);
#line 8530
  btdm_2AntPsTdma(padapter, 0, 0);
#line 8531
  btdm_2AntFwDacSwingLvl(padapter, 32);
#line 8532
  btdm_2AntDecBtPwr(padapter, 0);
#line 8533
  return;
}
}
#line 8535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_2AntSwCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 


  {
#line 8537
  btdm_2AntAgcTable(padapter, 0);
#line 8538
  btdm_2AntAdcBackOff(padapter, 0);
#line 8539
  btdm_2AntLowPenaltyRa(padapter, 0);
#line 8540
  btdm_2AntRfShrink(padapter, 0);
#line 8541
  btdm_2AntDacSwing(padapter, 0, 192U);
#line 8542
  return;
}
}
#line 8544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_2AntFwC2hBtInfo8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 btInfo ;
  u8 algorithm ;
  u8 bBtLinkExist ;
  u8 bBtHsModeExist ;

  {
#line 8546
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 8547
  pBtMgnt = & pBTInfo->BtMgnt;
#line 8548
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8549
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 8550
  btInfo = 0U;
#line 8551
  algorithm = 0U;
#line 8552
  bBtLinkExist = 0U;
#line 8552
  bBtHsModeExist = 0U;
#line 8554
  btInfo = pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal;
#line 8555
  pBtdm8723->btStatus = 0U;
#line 8558
  if (((unsigned long )btInfo & 4UL) != 0UL) {
#line 8559
    if ((unsigned int )pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage == 0U) {
#line 8560
      pBtMgnt->ExtConfig.bHoldForBtOperation = 1U;
#line 8561
      pBtMgnt->ExtConfig.bHoldPeriodCnt = 1U;
#line 8562
      btdm_2AntBtInquiryPage(padapter);
    } else {
#line 8564
      pBtMgnt->ExtConfig.bHoldPeriodCnt = pBtMgnt->ExtConfig.bHoldPeriodCnt + 1U;
#line 8565
      btdm_HoldForBtInqPage(padapter);
    }
#line 8567
    pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage = 1U;
  } else {
#line 8570
    pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage = 0U;
#line 8571
    pBtMgnt->ExtConfig.bHoldForBtOperation = 0U;
#line 8572
    pBtMgnt->ExtConfig.bHoldPeriodCnt = 0U;
  }
#line 8575
  if (BTCoexDbgLevel == 1U) {
#line 8575
    printk("[BTC2H], pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage =%x pBtMgnt->ExtConfig.bHoldPeriodCnt =%x pBtMgnt->ExtConfig.bHoldForBtOperation =%x\n",
           (int )pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage, pBtMgnt->ExtConfig.bHoldPeriodCnt,
           (int )pBtMgnt->ExtConfig.bHoldForBtOperation);
  } else {

  }
#line 8581
  if (BTCoexDbgLevel == 1U) {
#line 8581
    printk("[BTC2H],   btInfo =%x   pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal =%x\n",
           (int )btInfo, (int )pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal);
  } else {

  }
#line 8584
  if ((int )btInfo & 1) {
#line 8585
    if (BTCoexDbgLevel == 1U) {
#line 8585
      printk("[BTC2H], BTInfo: bConnect = true   btInfo =%x\n", (int )btInfo);
    } else {

    }
#line 8586
    bBtLinkExist = 1U;
#line 8587
    if (((unsigned long )btInfo & 240UL) != 0UL || (unsigned int )pHalData->bt_coexist.halCoex8723.btRetryCnt != 0U) {
#line 8589
      pBtdm8723->btStatus = 2U;
    } else {
#line 8591
      pBtdm8723->btStatus = 1U;
    }
#line 8594
    if (((unsigned long )btInfo & 2UL) != 0UL || ((unsigned long )btInfo & 16UL) != 0UL) {
#line 8595
      if (((int )((signed char )btInfo) < 0 || ((unsigned long )btInfo & 64UL) != 0UL) || ((unsigned long )btInfo & 32UL) != 0UL) {
#line 8596
        switch ((int )btInfo & 224) {
        case 32: ;
#line 8598
        if (BTCoexDbgLevel == 1U) {
#line 8598
          printk("[BTCoex], SCO + HID\n");
        } else {

        }
#line 8599
        algorithm = 2U;
#line 8600
        goto ldv_57849;
        case 64: ;
#line 8602
        if (BTCoexDbgLevel == 1U) {
#line 8602
          printk("[BTCoex], Error!!! SCO + A2DP\n");
        } else {

        }
#line 8603
        goto ldv_57849;
        case 128: ;
#line 8605
        if ((unsigned int )bBtHsModeExist != 0U) {
#line 8606
          if (BTCoexDbgLevel == 1U) {
#line 8606
            printk("[BTCoex], SCO + PAN(HS)\n");
          } else {

          }
#line 8607
          algorithm = 1U;
        } else {
#line 8609
          if (BTCoexDbgLevel == 1U) {
#line 8609
            printk("[BTCoex], SCO + PAN(EDR)\n");
          } else {

          }
#line 8610
          algorithm = 7U;
        }
#line 8612
        goto ldv_57849;
        case 96: ;
#line 8614
        if (BTCoexDbgLevel == 1U) {
#line 8614
          printk("[BTCoex], HID + A2DP\n");
        } else {

        }
#line 8615
        algorithm = 9U;
#line 8616
        goto ldv_57849;
        case 160: ;
#line 8618
        if ((unsigned int )bBtHsModeExist != 0U) {
#line 8619
          if (BTCoexDbgLevel == 1U) {
#line 8619
            printk("[BTCoex], HID + PAN(HS)\n");
          } else {

          }
#line 8620
          algorithm = 9U;
        } else {
#line 8622
          if (BTCoexDbgLevel == 1U) {
#line 8622
            printk("[BTCoex], HID + PAN(EDR)\n");
          } else {

          }
#line 8623
          algorithm = 7U;
        }
#line 8625
        goto ldv_57849;
        case 192: ;
#line 8627
        if ((unsigned int )bBtHsModeExist != 0U) {
#line 8628
          if (BTCoexDbgLevel == 1U) {
#line 8628
            printk("[BTCoex], A2DP + PAN(HS)\n");
          } else {

          }
#line 8629
          algorithm = 3U;
        } else {
#line 8631
          if (BTCoexDbgLevel == 1U) {
#line 8631
            printk("[BTCoex], A2DP + PAN(EDR)\n");
          } else {

          }
#line 8632
          algorithm = 6U;
        }
#line 8634
        goto ldv_57849;
        case 224: ;
#line 8636
        if ((unsigned int )bBtHsModeExist != 0U) {
#line 8637
          if (BTCoexDbgLevel == 1U) {
#line 8637
            printk("[BTCoex], HID + A2DP + PAN(HS)\n");
          } else {

          }
#line 8638
          algorithm = 9U;
        } else {
#line 8640
          if (BTCoexDbgLevel == 1U) {
#line 8640
            printk("[BTCoex], HID + A2DP + PAN(EDR)\n");
          } else {

          }
#line 8641
          algorithm = 8U;
        }
#line 8643
        goto ldv_57849;
        }
        ldv_57849: ;
      } else {
#line 8646
        if (BTCoexDbgLevel == 1U) {
#line 8646
          printk("[BTCoex], SCO only\n");
        } else {

        }
#line 8647
        algorithm = 1U;
      }
    } else {
#line 8650
      if (BTCoexDbgLevel == 1U) {
#line 8650
        printk("[BTCoex], non SCO\n");
      } else {

      }
#line 8651
      switch ((int )btInfo & 224) {
      case 32: ;
#line 8653
      if (BTCoexDbgLevel == 1U) {
#line 8653
        printk("[BTCoex], HID\n");
      } else {

      }
#line 8654
      algorithm = 2U;
#line 8655
      goto ldv_57857;
      case 64: ;
#line 8657
      if (BTCoexDbgLevel == 1U) {
#line 8657
        printk("[BTCoex],  A2DP\n");
      } else {

      }
#line 8658
      algorithm = 3U;
#line 8659
      goto ldv_57857;
      case 128: ;
#line 8661
      if (BTCoexDbgLevel == 1U) {
#line 8661
        printk("[BTCoex], PAN(EDR)\n");
      } else {

      }
#line 8662
      algorithm = 7U;
#line 8663
      goto ldv_57857;
      case 96: ;
#line 8665
      if (BTCoexDbgLevel == 1U) {
#line 8665
        printk("[BTCoex], HID + A2DP\n");
      } else {

      }
#line 8666
      algorithm = 9U;
#line 8667
      goto ldv_57857;
      case 160: ;
#line 8669
      if ((unsigned int )bBtHsModeExist != 0U) {
#line 8670
        if (BTCoexDbgLevel == 1U) {
#line 8670
          printk("[BTCoex], HID + PAN(HS)\n");
        } else {

        }
#line 8671
        algorithm = 9U;
      } else {
#line 8673
        if (BTCoexDbgLevel == 1U) {
#line 8673
          printk("[BTCoex], HID + PAN(EDR)\n");
        } else {

        }
#line 8674
        algorithm = 7U;
      }
#line 8676
      goto ldv_57857;
      case 192: ;
#line 8678
      if ((unsigned int )bBtHsModeExist != 0U) {
#line 8679
        if (BTCoexDbgLevel == 1U) {
#line 8679
          printk("[BTCoex], A2DP + PAN(HS)\n");
        } else {

        }
#line 8680
        algorithm = 3U;
      } else {
#line 8682
        if (BTCoexDbgLevel == 1U) {
#line 8682
          printk("[BTCoex], A2DP + PAN(EDR)\n");
        } else {

        }
#line 8683
        algorithm = 6U;
      }
#line 8685
      goto ldv_57857;
      case 224: ;
#line 8687
      if ((unsigned int )bBtHsModeExist != 0U) {
#line 8688
        if (BTCoexDbgLevel == 1U) {
#line 8688
          printk("[BTCoex], HID + A2DP + PAN(HS)\n");
        } else {

        }
#line 8689
        algorithm = 9U;
      } else {
#line 8691
        if (BTCoexDbgLevel == 1U) {
#line 8691
          printk("[BTCoex], HID + A2DP + PAN(EDR)\n");
        } else {

        }
#line 8692
        algorithm = 8U;
      }
#line 8694
      goto ldv_57857;
      }
      ldv_57857: ;
    }
  } else {
#line 8699
    if (BTCoexDbgLevel == 1U) {
#line 8699
      printk("[BTC2H], BTInfo: bConnect = false\n");
    } else {

    }
#line 8700
    pBtdm8723->btStatus = 0U;
  }
#line 8703
  pBtdm8723->curAlgorithm = algorithm;
#line 8704
  if (BTCoexDbgLevel == 1U) {
#line 8704
    printk("[BTCoex], Algorithm = %d \n", (int )pBtdm8723->curAlgorithm);
  } else {

  }
#line 8707
  BTDM_CheckWiFiState(padapter);
#line 8708
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 8709
    if (BTCoexDbgLevel == 1U) {
#line 8709
      printk("Action Manual control, won\'t execute bt coexist mechanism!!\n");
    } else {

    }
#line 8710
    return;
  } else {

  }
#line 8712
  return;
}
}
#line 8714 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_2AntBtCoexist8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 btInfoOriginal ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;

  {
#line 8716
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 8717
  pBtMgnt = & pBTInfo->BtMgnt;
#line 8718
  pBtDbg = & pBTInfo->BtDbg;
#line 8719
  btInfoOriginal = 0U;
#line 8720
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8721
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 8723
  tmp___1 = BTDM_BtProfileSupport(padapter);
#line 8723
  if ((unsigned int )tmp___1 != 0U) {
#line 8724
    if ((unsigned int )pBtMgnt->ExtConfig.bHoldForBtOperation != 0U) {
#line 8725
      if (BTCoexDbgLevel == 1U) {
#line 8725
        printk("Action for BT Operation adjust!!\n");
      } else {

      }
#line 8726
      return;
    } else {

    }
#line 8728
    if (pBtMgnt->ExtConfig.bHoldPeriodCnt != 0U) {
#line 8729
      if (BTCoexDbgLevel == 1U) {
#line 8729
        printk("Hold BT inquiry/page scan setting (cnt = %d)!!\n", pBtMgnt->ExtConfig.bHoldPeriodCnt);
      } else {

      }
#line 8731
      if (pBtMgnt->ExtConfig.bHoldPeriodCnt > 10U) {
#line 8732
        pBtMgnt->ExtConfig.bHoldPeriodCnt = 0U;
      } else {
#line 8735
        pBtMgnt->ExtConfig.bHoldPeriodCnt = pBtMgnt->ExtConfig.bHoldPeriodCnt + 1U;
      }
#line 8737
      return;
    } else {

    }
#line 8740
    if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 8741
      if (BTCoexDbgLevel == 1U) {
#line 8741
        printk("[Dbg control], ");
      } else {

      }
    } else {

    }
#line 8743
    pBtdm8723->curAlgorithm = btdm_ActionAlgorithm(padapter);
#line 8744
    if (BTCoexDbgLevel == 1U) {
#line 8744
      printk("[BTCoex], Algorithm = %d \n", (int )pBtdm8723->curAlgorithm);
    } else {

    }
#line 8746
    tmp = btdm_Is2Ant8723ACommonAction(padapter);
#line 8746
    if ((unsigned int )tmp != 0U) {
#line 8747
      if (BTCoexDbgLevel == 1U) {
#line 8747
        printk("Action 2-Ant common.\n");
      } else {

      }
#line 8748
      pBtdm8723->bResetTdmaAdjust = 1U;
    } else {
#line 8750
      if ((int )pBtdm8723->curAlgorithm != (int )pBtdm8723->preAlgorithm) {
#line 8751
        if (BTCoexDbgLevel == 1U) {
#line 8751
          printk("[BTCoex], preAlgorithm =%d, curAlgorithm =%d\n", (int )pBtdm8723->preAlgorithm,
                 (int )pBtdm8723->curAlgorithm);
        } else {

        }
#line 8753
        pBtdm8723->bResetTdmaAdjust = 1U;
      } else {

      }
#line 8755
      switch ((int )pBtdm8723->curAlgorithm) {
      case 1: ;
#line 8757
      if (BTCoexDbgLevel == 1U) {
#line 8757
        printk("Action 2-Ant, algorithm = SCO.\n");
      } else {

      }
#line 8758
      btdm_2Ant8723ASCOAction(padapter);
#line 8759
      goto ldv_57874;
      case 2: ;
#line 8761
      if (BTCoexDbgLevel == 1U) {
#line 8761
        printk("Action 2-Ant, algorithm = HID.\n");
      } else {

      }
#line 8762
      btdm_2Ant8723AHIDAction(padapter);
#line 8763
      goto ldv_57874;
      case 3: ;
#line 8765
      if (BTCoexDbgLevel == 1U) {
#line 8765
        printk("Action 2-Ant, algorithm = A2DP.\n");
      } else {

      }
#line 8766
      btdm_2Ant8723AA2DPAction(padapter);
#line 8767
      goto ldv_57874;
      case 4: ;
#line 8769
      if (BTCoexDbgLevel == 1U) {
#line 8769
        printk("Action 2-Ant, algorithm = PAN(EDR).\n");
      } else {

      }
#line 8770
      btdm_2Ant8723APANEDRAction(padapter);
#line 8771
      goto ldv_57874;
      case 5: ;
#line 8773
      if (BTCoexDbgLevel == 1U) {
#line 8773
        printk("Action 2-Ant, algorithm = HS mode.\n");
      } else {

      }
#line 8774
      btdm_2Ant8723APANHSAction(padapter);
#line 8775
      goto ldv_57874;
      case 6: ;
#line 8777
      if (BTCoexDbgLevel == 1U) {
#line 8777
        printk("Action 2-Ant, algorithm = PAN+A2DP.\n");
      } else {

      }
#line 8778
      btdm_2Ant8723APANEDRA2DPAction(padapter);
#line 8779
      goto ldv_57874;
      case 7: ;
#line 8781
      if (BTCoexDbgLevel == 1U) {
#line 8781
        printk("Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
      } else {

      }
#line 8782
      btdm_2Ant8723APANEDRHIDAction(padapter);
#line 8783
      goto ldv_57874;
      case 8: ;
#line 8785
      if (BTCoexDbgLevel == 1U) {
#line 8785
        printk("Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
      } else {

      }
#line 8786
      btdm_2Ant8723AHIDA2DPPANEDRAction(padapter);
#line 8787
      goto ldv_57874;
      case 9: ;
#line 8789
      if (BTCoexDbgLevel == 1U) {
#line 8789
        printk("Action 2-Ant, algorithm = HID+A2DP.\n");
      } else {

      }
#line 8790
      btdm_2Ant8723AHIDA2DPAction(padapter);
#line 8791
      goto ldv_57874;
      default: ;
#line 8793
      if (BTCoexDbgLevel == 1U) {
#line 8793
        printk("Action 2-Ant, algorithm = 0.\n");
      } else {

      }
#line 8794
      btdm_2Ant8723AA2DPAction(padapter);
#line 8795
      goto ldv_57874;
      }
      ldv_57874: 
#line 8797
      pBtdm8723->preAlgorithm = pBtdm8723->curAlgorithm;
    }
  } else {
#line 8800
    if (BTCoexDbgLevel == 1U) {
#line 8800
      printk("[BTCoex] Get bt info by fw!!\n");
    } else {

    }
#line 8802
    if ((unsigned int )pHalData->bt_coexist.halCoex8723.bC2hBtInfoReqSent != 0U) {
#line 8803
      if (BTCoexDbgLevel == 1U) {
#line 8803
        printk("[BTCoex] c2h for btInfo not rcvd yet!!\n");
      } else {

      }
    } else {

    }
#line 8805
    btInfoOriginal = pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal;
#line 8807
    if ((unsigned int )pBtMgnt->ExtConfig.bHoldForBtOperation != 0U) {
#line 8808
      if (BTCoexDbgLevel == 1U) {
#line 8808
        printk("Action for BT Operation adjust!!\n");
      } else {

      }
#line 8809
      return;
    } else {

    }
#line 8811
    if (pBtMgnt->ExtConfig.bHoldPeriodCnt != 0U) {
#line 8812
      if (BTCoexDbgLevel == 1U) {
#line 8812
        printk("Hold BT inquiry/page scan setting (cnt = %d)!!\n", pBtMgnt->ExtConfig.bHoldPeriodCnt);
      } else {

      }
#line 8815
      if (pBtMgnt->ExtConfig.bHoldPeriodCnt > 10U) {
#line 8816
        pBtMgnt->ExtConfig.bHoldPeriodCnt = 0U;
      } else {
#line 8819
        pBtMgnt->ExtConfig.bHoldPeriodCnt = pBtMgnt->ExtConfig.bHoldPeriodCnt + 1U;
      }
#line 8821
      return;
    } else {

    }
#line 8824
    if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 8825
      if (BTCoexDbgLevel == 1U) {
#line 8825
        printk("[Dbg control], ");
      } else {

      }
    } else {

    }
#line 8826
    tmp___0 = btdm_Is2Ant8723ACommonAction(padapter);
#line 8826
    if ((unsigned int )tmp___0 != 0U) {
#line 8827
      if (BTCoexDbgLevel == 1U) {
#line 8827
        printk("Action 2-Ant common.\n");
      } else {

      }
#line 8828
      pBtdm8723->bResetTdmaAdjust = 1U;
    } else {
#line 8830
      if ((int )pBtdm8723->curAlgorithm != (int )pBtdm8723->preAlgorithm) {
#line 8831
        if (BTCoexDbgLevel == 1U) {
#line 8831
          printk("[BTCoex], preAlgorithm =%d, curAlgorithm =%d\n", (int )pBtdm8723->preAlgorithm,
                 (int )pBtdm8723->curAlgorithm);
        } else {

        }
#line 8835
        pBtdm8723->bResetTdmaAdjust = 1U;
      } else {

      }
#line 8837
      switch ((int )pBtdm8723->curAlgorithm) {
      case 1: ;
#line 8839
      if (BTCoexDbgLevel == 1U) {
#line 8839
        printk("Action 2-Ant, algorithm = SCO.\n");
      } else {

      }
#line 8840
      btdm_2Ant8723ASCOAction(padapter);
#line 8841
      goto ldv_57885;
      case 2: ;
#line 8843
      if (BTCoexDbgLevel == 1U) {
#line 8843
        printk("Action 2-Ant, algorithm = HID.\n");
      } else {

      }
#line 8844
      btdm_2Ant8723AHIDAction(padapter);
#line 8845
      goto ldv_57885;
      case 3: ;
#line 8847
      if (BTCoexDbgLevel == 1U) {
#line 8847
        printk("Action 2-Ant, algorithm = A2DP.\n");
      } else {

      }
#line 8848
      btdm_2Ant8723AA2dp(padapter);
#line 8849
      goto ldv_57885;
      case 4: ;
#line 8851
      if (BTCoexDbgLevel == 1U) {
#line 8851
        printk("Action 2-Ant, algorithm = PAN(EDR).\n");
      } else {

      }
#line 8852
      btdm_2Ant8723APANEDRAction(padapter);
#line 8853
      goto ldv_57885;
      case 5: ;
#line 8855
      if (BTCoexDbgLevel == 1U) {
#line 8855
        printk("Action 2-Ant, algorithm = HS mode.\n");
      } else {

      }
#line 8856
      btdm_2Ant8723APANHSAction(padapter);
#line 8857
      goto ldv_57885;
      case 6: ;
#line 8859
      if (BTCoexDbgLevel == 1U) {
#line 8859
        printk("Action 2-Ant, algorithm = PAN+A2DP.\n");
      } else {

      }
#line 8860
      btdm_2Ant8723APANEDRA2DPAction(padapter);
#line 8861
      goto ldv_57885;
      case 7: ;
#line 8863
      if (BTCoexDbgLevel == 1U) {
#line 8863
        printk("Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
      } else {

      }
#line 8864
      btdm_2Ant8723APANEDRHIDAction(padapter);
#line 8865
      goto ldv_57885;
      case 8: ;
#line 8867
      if (BTCoexDbgLevel == 1U) {
#line 8867
        printk("Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
      } else {

      }
#line 8868
      btdm_2Ant8723AHIDA2DPPANEDRAction(padapter);
#line 8869
      goto ldv_57885;
      case 9: ;
#line 8871
      if (BTCoexDbgLevel == 1U) {
#line 8871
        printk("Action 2-Ant, algorithm = HID+A2DP.\n");
      } else {

      }
#line 8872
      btdm_2Ant8723AHIDA2DPAction(padapter);
#line 8873
      goto ldv_57885;
      default: ;
#line 8875
      if (BTCoexDbgLevel == 1U) {
#line 8875
        printk("Action 2-Ant, algorithm = 0.\n");
      } else {

      }
#line 8876
      btdm_2Ant8723AA2DPAction(padapter);
#line 8877
      goto ldv_57885;
      }
      ldv_57885: 
#line 8879
      pBtdm8723->preAlgorithm = pBtdm8723->curAlgorithm;
    }
  }
#line 8882
  return;
}
}
#line 8888 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 btCoexDbgBuf[100U]  ;
#line 8890 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static char const   * const  BtProfileString[5U]  = {      "NONE",      "A2DP",      "PAN",      "HID", 
        "SCO"};
#line 8898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static char const   * const  BtSpecString[7U]  = {      "1.0b",      "1.1",      "1.2",      "2.0+EDR", 
        "2.1+EDR",      "3.0+HS",      "4.0"};
#line 8908 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static char const   * const  BtLinkRoleString[2U]  = {      "Master",      "Slave"};
#line 8913 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static u8 btdm_BtWifiAntNum(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;

  {
#line 8915
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8916
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 8918
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num == 0U) {
#line 8919
    if ((unsigned int )pBtCoex->TotalAntNum == 0U) {
#line 8920
      return (0U);
    } else {
#line 8922
      return (1U);
    }
  } else {
#line 8924
    return (1U);
  }
#line 8926
  return (0U);
}
}
#line 8929 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_BtHwCountersMonitor(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 regHPTxRx ;
  u32 regLPTxRx ;
  u32 u4Tmp ;
  u32 regHPTx ;
  u32 regHPRx ;
  u32 regLPTx ;
  u32 regLPRx ;

  {
#line 8931
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8933
  regHPTx = 0U;
#line 8933
  regHPRx = 0U;
#line 8933
  regLPTx = 0U;
#line 8933
  regLPRx = 0U;
#line 8935
  regHPTxRx = 1904U;
#line 8936
  regLPTxRx = 1908U;
#line 8938
  u4Tmp = rtl8723au_read32(padapter, (int )((u16 )regHPTxRx));
#line 8939
  regHPTx = u4Tmp & 65535U;
#line 8940
  regHPRx = u4Tmp >> 16;
#line 8942
  u4Tmp = rtl8723au_read32(padapter, (int )((u16 )regLPTxRx));
#line 8943
  regLPTx = u4Tmp & 65535U;
#line 8944
  regLPRx = u4Tmp >> 16;
#line 8946
  pHalData->bt_coexist.halCoex8723.highPriorityTx = regHPTx;
#line 8947
  pHalData->bt_coexist.halCoex8723.highPriorityRx = regHPRx;
#line 8948
  pHalData->bt_coexist.halCoex8723.lowPriorityTx = regLPTx;
#line 8949
  pHalData->bt_coexist.halCoex8723.lowPriorityRx = regLPRx;
#line 8951
  if (BTCoexDbgLevel == 1U) {
#line 8951
    printk("High Priority Tx/Rx = %d / %d\n", regHPTx, regHPRx);
  } else {

  }
#line 8952
  if (BTCoexDbgLevel == 1U) {
#line 8952
    printk("Low Priority Tx/Rx = %d / %d\n", regLPTx, regLPRx);
  } else {

  }
#line 8955
  rtl8723au_write8(padapter, 1902, 12);
#line 8956
  return;
}
}
#line 8959 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_BtEnableDisableCheck8723A(struct rtw_adapter *padapter ) 
{ 
  u8 btAlife ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;

  {
#line 8961
  btAlife = 1U;
#line 8962
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8977
  if (((pHalData->bt_coexist.halCoex8723.highPriorityTx == 0U && pHalData->bt_coexist.halCoex8723.highPriorityRx == 0U) && pHalData->bt_coexist.halCoex8723.lowPriorityTx == 0U) && pHalData->bt_coexist.halCoex8723.lowPriorityRx == 0U) {
#line 8981
    btAlife = 0U;
  } else {

  }
#line 8982
  if (((pHalData->bt_coexist.halCoex8723.highPriorityTx == 60138U && pHalData->bt_coexist.halCoex8723.highPriorityRx == 60138U) && pHalData->bt_coexist.halCoex8723.lowPriorityTx == 60138U) && pHalData->bt_coexist.halCoex8723.lowPriorityRx == 60138U) {
#line 8986
    btAlife = 0U;
  } else {

  }
#line 8987
  if (((pHalData->bt_coexist.halCoex8723.highPriorityTx == 65535U && pHalData->bt_coexist.halCoex8723.highPriorityRx == 65535U) && pHalData->bt_coexist.halCoex8723.lowPriorityTx == 65535U) && pHalData->bt_coexist.halCoex8723.lowPriorityRx == 65535U) {
#line 8991
    btAlife = 0U;
  } else {

  }
#line 8992
  if ((unsigned int )btAlife != 0U) {
#line 8993
    pHalData->bt_coexist.btActiveZeroCnt = 0U;
#line 8994
    pHalData->bt_coexist.bCurBtDisabled = 0U;
#line 8995
    if (BTCoexDbgLevel == 1U) {
#line 8995
      printk("8723A BT is enabled !!\n");
    } else {

    }
  } else {
#line 8997
    pHalData->bt_coexist.btActiveZeroCnt = (u8 )((int )pHalData->bt_coexist.btActiveZeroCnt + 1);
#line 8998
    if (BTCoexDbgLevel == 1U) {
#line 8998
      printk("8723A bt all counters = 0, %d times!!\n", (int )pHalData->bt_coexist.btActiveZeroCnt);
    } else {

    }
#line 9000
    if ((unsigned int )pHalData->bt_coexist.btActiveZeroCnt > 1U) {
#line 9001
      pHalData->bt_coexist.bCurBtDisabled = 1U;
#line 9002
      if (BTCoexDbgLevel == 1U) {
#line 9002
        printk("8723A BT is disabled !!\n");
      } else {

      }
    } else {

    }
  }
#line 9007
  if ((unsigned int )pHalData->bt_coexist.bCurBtDisabled == 0U) {
#line 9008
    tmp = BTDM_IsWifiConnectionExist(padapter);
#line 9008
    if ((unsigned int )tmp != 0U) {
#line 9009
      BTDM_SetFwChnlInfo(padapter, 1);
    } else {
#line 9011
      BTDM_SetFwChnlInfo(padapter, 0);
    }
  } else {

  }
#line 9014
  if ((int )pHalData->bt_coexist.bPreBtDisabled != (int )pHalData->bt_coexist.bCurBtDisabled) {
#line 9016
    if (BTCoexDbgLevel == 1U) {
#line 9016
      printk("8723A BT is from %s to %s!!\n", (unsigned int )pHalData->bt_coexist.bPreBtDisabled != 0U ? (char *)"disabled" : (char *)"enabled",
             (unsigned int )pHalData->bt_coexist.bCurBtDisabled != 0U ? (char *)"disabled" : (char *)"enabled");
    } else {

    }
#line 9019
    pHalData->bt_coexist.bPreBtDisabled = pHalData->bt_coexist.bCurBtDisabled;
  } else {

  }
#line 9021
  return;
}
}
#line 9023 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_BTCoexist8723AHandler(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 9027
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9029
  tmp = btdm_BtWifiAntNum(padapter);
#line 9029
  if ((unsigned int )tmp == 0U) {
#line 9030
    if (BTCoexDbgLevel == 1U) {
#line 9030
      printk("[BTCoex], 2 Ant mechanism\n");
    } else {

    }
#line 9031
    BTDM_2AntBtCoexist8723A(padapter);
  } else {
#line 9033
    if (BTCoexDbgLevel == 1U) {
#line 9033
      printk("[BTCoex], 1 Ant mechanism\n");
    } else {

    }
#line 9034
    BTDM_1AntBtCoexist8723A(padapter);
  }
#line 9037
  tmp___0 = BTDM_IsSameCoexistState(padapter);
#line 9037
  if ((unsigned int )tmp___0 == 0U) {
#line 9038
    if (BTCoexDbgLevel == 1U) {
#line 9038
      printk("[BTCoex], Coexist State[bitMap] change from 0x%llx to 0x%llx\n", pHalData->bt_coexist.PreviousState,
             pHalData->bt_coexist.CurrentState);
    } else {

    }
#line 9041
    pHalData->bt_coexist.PreviousState = pHalData->bt_coexist.CurrentState;
#line 9043
    if (BTCoexDbgLevel == 1U) {
#line 9043
      printk("[");
    } else {

    }
#line 9044
    if ((int )pHalData->bt_coexist.CurrentState & 1) {
#line 9045
      if (BTCoexDbgLevel == 1U) {
#line 9045
        printk("BT 3.0, ");
      } else {

      }
    } else {

    }
#line 9046
    if ((pHalData->bt_coexist.CurrentState & 2ULL) != 0ULL) {
#line 9047
      if (BTCoexDbgLevel == 1U) {
#line 9047
        printk("HT20, ");
      } else {

      }
    } else {

    }
#line 9048
    if ((pHalData->bt_coexist.CurrentState & 4ULL) != 0ULL) {
#line 9049
      if (BTCoexDbgLevel == 1U) {
#line 9049
        printk("HT40, ");
      } else {

      }
    } else {

    }
#line 9050
    if ((pHalData->bt_coexist.CurrentState & 8ULL) != 0ULL) {
#line 9051
      if (BTCoexDbgLevel == 1U) {
#line 9051
        printk("Legacy, ");
      } else {

      }
    } else {

    }
#line 9052
    if ((pHalData->bt_coexist.CurrentState & 16ULL) != 0ULL) {
#line 9053
      if (BTCoexDbgLevel == 1U) {
#line 9053
        printk("Rssi_Low, ");
      } else {

      }
    } else {

    }
#line 9054
    if ((pHalData->bt_coexist.CurrentState & 32ULL) != 0ULL) {
#line 9055
      if (BTCoexDbgLevel == 1U) {
#line 9055
        printk("Rssi_Mid, ");
      } else {

      }
    } else {

    }
#line 9056
    if ((pHalData->bt_coexist.CurrentState & 64ULL) != 0ULL) {
#line 9057
      if (BTCoexDbgLevel == 1U) {
#line 9057
        printk("Rssi_High, ");
      } else {

      }
    } else {

    }
#line 9058
    if ((pHalData->bt_coexist.CurrentState & 256ULL) != 0ULL) {
#line 9059
      if (BTCoexDbgLevel == 1U) {
#line 9059
        printk("Wifi_Idle, ");
      } else {

      }
    } else {

    }
#line 9060
    if ((pHalData->bt_coexist.CurrentState & 512ULL) != 0ULL) {
#line 9061
      if (BTCoexDbgLevel == 1U) {
#line 9061
        printk("Wifi_Uplink, ");
      } else {

      }
    } else {

    }
#line 9062
    if ((pHalData->bt_coexist.CurrentState & 1024ULL) != 0ULL) {
#line 9063
      if (BTCoexDbgLevel == 1U) {
#line 9063
        printk("Wifi_Downlink, ");
      } else {

      }
    } else {

    }
#line 9064
    if ((pHalData->bt_coexist.CurrentState & 4096ULL) != 0ULL) {
#line 9065
      if (BTCoexDbgLevel == 1U) {
#line 9065
        printk("BT_idle, ");
      } else {

      }
    } else {

    }
#line 9066
    if ((pHalData->bt_coexist.CurrentState & 1048576ULL) != 0ULL) {
#line 9067
      if (BTCoexDbgLevel == 1U) {
#line 9067
        printk("PRO_HID, ");
      } else {

      }
    } else {

    }
#line 9068
    if ((pHalData->bt_coexist.CurrentState & 2097152ULL) != 0ULL) {
#line 9069
      if (BTCoexDbgLevel == 1U) {
#line 9069
        printk("PRO_A2DP, ");
      } else {

      }
    } else {

    }
#line 9070
    if ((pHalData->bt_coexist.CurrentState & 4194304ULL) != 0ULL) {
#line 9071
      if (BTCoexDbgLevel == 1U) {
#line 9071
        printk("PRO_PAN, ");
      } else {

      }
    } else {

    }
#line 9072
    if ((pHalData->bt_coexist.CurrentState & 8388608ULL) != 0ULL) {
#line 9073
      if (BTCoexDbgLevel == 1U) {
#line 9073
        printk("PRO_SCO, ");
      } else {

      }
    } else {

    }
#line 9074
    if (BTCoexDbgLevel == 1U) {
#line 9074
      printk("]\n");
    } else {

    }
  } else {

  }
#line 9076
  return;
}
}
#line 9079 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u32 BTDM_BtTxRxCounterH(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 counters ;

  {
#line 9081
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9082
  counters = 0U;
#line 9084
  counters = pHalData->bt_coexist.halCoex8723.highPriorityTx + pHalData->bt_coexist.halCoex8723.highPriorityRx;
#line 9086
  return (counters);
}
}
#line 9089 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u32 BTDM_BtTxRxCounterL(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 counters ;

  {
#line 9091
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9092
  counters = 0U;
#line 9094
  counters = pHalData->bt_coexist.halCoex8723.lowPriorityTx + pHalData->bt_coexist.halCoex8723.lowPriorityRx;
#line 9096
  return (counters);
}
}
#line 9099 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_SetFwChnlInfo(struct rtw_adapter *padapter , enum rt_media_status mstatus ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;
  u8 chnl ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  u8 tmp___3 ;

  {
#line 9101
  pmlmeext = & padapter->mlmeextpriv;
#line 9102
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9103
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9104
  H2C_Parameter[0] = 0U;
#line 9104
  tmp = 1U;
#line 9104
  while (1) {
#line 9104
    if (tmp >= 3U) {
#line 9104
      break;
    } else {

    }
#line 9104
    H2C_Parameter[tmp] = (unsigned char)0;
#line 9104
    tmp = tmp + 1U;
  }
#line 9108
  if ((unsigned int )mstatus == 1U) {
#line 9109
    H2C_Parameter[0] = 1U;
  } else {

  }
#line 9111
  tmp___2 = check_fwstate(& padapter->mlmepriv, 1);
#line 9111
  if ((int )tmp___2) {
#line 9113
    chnl = pmlmeext->cur_channel;
#line 9114
    tmp___0 = BTDM_IsHT40(padapter);
#line 9114
    if ((unsigned int )tmp___0 != 0U) {
#line 9115
      if ((unsigned int )pmlmeext->cur_ch_offset == 2U) {
#line 9116
        chnl = (unsigned int )chnl + 254U;
      } else
#line 9117
      if ((unsigned int )pmlmeext->cur_ch_offset == 1U) {
#line 9118
        chnl = (unsigned int )chnl + 2U;
      } else {

      }
    } else {

    }
#line 9120
    H2C_Parameter[1] = chnl;
  } else {
#line 9123
    tmp___1 = BT_Operation(padapter);
#line 9123
    if ((unsigned int )tmp___1 != 0U) {
#line 9124
      H2C_Parameter[1] = pBtMgnt->BTChannel;
    } else {
#line 9126
      H2C_Parameter[1] = pmlmeext->cur_channel;
    }
  }
#line 9129
  tmp___3 = BTDM_IsHT40(padapter);
#line 9129
  if ((unsigned int )tmp___3 != 0U) {
#line 9130
    H2C_Parameter[2] = 48U;
  } else {
#line 9132
    H2C_Parameter[2] = 32U;
  }
#line 9134
  FillH2CCmd(padapter, 25, 3U, (u8 *)(& H2C_Parameter));
#line 9135
  return;
}
}
#line 9137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsWifiConnectionExist(struct rtw_adapter *padapter ) 
{ 
  u8 bRet ;
  u8 tmp ;
  bool tmp___0 ;

  {
#line 9139
  bRet = 0U;
#line 9141
  tmp = BTHCI_HsConnectionEstablished(padapter);
#line 9141
  if ((unsigned int )tmp != 0U) {
#line 9142
    bRet = 1U;
  } else {

  }
#line 9144
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
#line 9144
  if ((int )tmp___0) {
#line 9145
    bRet = 1U;
  } else {

  }
#line 9147
  return (bRet);
}
}
#line 9150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_SetFw3a(struct rtw_adapter *padapter , u8 byte1 , u8 byte2 , u8 byte3 ,
                  u8 byte4 , u8 byte5 ) 
{ 
  u8 H2C_Parameter[5U] ;
  unsigned int tmp ;
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 BtState ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;

  {
#line 9159
  H2C_Parameter[0] = 0U;
#line 9159
  tmp = 1U;
#line 9159
  while (1) {
#line 9159
    if (tmp >= 5U) {
#line 9159
      break;
    } else {

    }
#line 9159
    H2C_Parameter[tmp] = (unsigned char)0;
#line 9159
    tmp = tmp + 1U;
  }
#line 9161
  tmp___3 = rtl8723a_BT_using_antenna_1(padapter);
#line 9161
  if ((int )tmp___3) {
#line 9162
    tmp___0 = check_fwstate(& padapter->mlmepriv, 8);
#line 9162
    if (tmp___0) {
#line 9162
      tmp___1 = 0;
    } else {
#line 9162
      tmp___1 = 1;
    }
#line 9162
    if (tmp___1) {
#line 9162
      tmp___2 = get_fwstate(& padapter->mlmepriv);
#line 9162
      if (tmp___2 != 0) {
#line 9165
        pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9166
        pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 9167
        BtState = pBtCoex->c2hBtInfo;
#line 9169
        if ((unsigned int )BtState != 1U && (unsigned int )BtState != 2U) {
#line 9171
          if (((unsigned long )byte1 & 16UL) != 0UL) {
#line 9172
            byte1 = (unsigned int )byte1 & 239U;
#line 9173
            byte1 = (u8 )((unsigned int )byte1 | 32U);
          } else {

          }
#line 9176
          byte5 = (u8 )((unsigned int )byte5 | 32U);
#line 9177
          if (((unsigned long )byte5 & 64UL) != 0UL) {
#line 9178
            byte5 = (unsigned int )byte5 & 191U;
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 9183
  H2C_Parameter[0] = byte1;
#line 9184
  H2C_Parameter[1] = byte2;
#line 9185
  H2C_Parameter[2] = byte3;
#line 9186
  H2C_Parameter[3] = byte4;
#line 9187
  H2C_Parameter[4] = byte5;
#line 9189
  if (BTCoexDbgLevel == 1U) {
#line 9189
    printk("[BTCoex], FW write 0x3a(5bytes) = 0x%02x%08x\n", (int )H2C_Parameter[0],
           ((((int )H2C_Parameter[1] << 24) | ((int )H2C_Parameter[2] << 16)) | ((int )H2C_Parameter[3] << 8)) | (int )H2C_Parameter[4]);
  } else {

  }
#line 9193
  FillH2CCmd(padapter, 58, 5U, (u8 *)(& H2C_Parameter));
#line 9194
  return;
}
}
#line 9196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_QueryBtInformation(struct rtw_adapter *padapter ) 
{ 
  u8 H2C_Parameter[1U] ;
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  bool tmp ;
  int tmp___0 ;

  {
#line 9198
  H2C_Parameter[0] = 0U;
#line 9202
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9203
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 9205
  tmp = rtl8723a_BT_enabled(padapter);
#line 9205
  if (tmp) {
#line 9205
    tmp___0 = 0;
  } else {
#line 9205
    tmp___0 = 1;
  }
#line 9205
  if (tmp___0) {
#line 9206
    pBtCoex->c2hBtInfo = 0U;
#line 9207
    pBtCoex->bC2hBtInfoReqSent = 0U;
#line 9208
    return;
  } else {

  }
#line 9211
  if ((unsigned int )pBtCoex->c2hBtInfo == 0U) {
#line 9212
    pBtCoex->c2hBtInfo = 1U;
  } else {

  }
#line 9214
  if ((unsigned int )pBtCoex->bC2hBtInfoReqSent == 1U) {
#line 9215
    if (BTCoexDbgLevel == 1U) {
#line 9215
      printk("[BTCoex], didn\'t recv previous BtInfo report!\n");
    } else {

    }
  } else {
#line 9217
    pBtCoex->bC2hBtInfoReqSent = 1U;
  }
#line 9219
  H2C_Parameter[0] = (u8 )((unsigned int )H2C_Parameter[0] | 1U);
#line 9224
  FillH2CCmd(padapter, 56, 1U, (u8 *)(& H2C_Parameter));
#line 9225
  return;
}
}
#line 9227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_SetSwRfRxLpfCorner(struct rtw_adapter *padapter , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 9229
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9231
  if ((unsigned int )type == 1U) {
#line 9233
    if (BTCoexDbgLevel == 1U) {
#line 9233
      printk("Shrink RF Rx LPF corner!!\n");
    } else {

    }
#line 9234
    PHY_SetRFReg(padapter, 0, 30U, 1048575U, 987127U);
#line 9235
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else
#line 9236
  if ((unsigned int )type == 0U) {
#line 9238
    if (BTCoexDbgLevel == 1U) {
#line 9238
      printk("Resume RF Rx LPF corner!!\n");
    } else {

    }
#line 9239
    PHY_SetRFReg(padapter, 0, 30U, 1048575U, pHalData->bt_coexist.BtRfRegOrigin1E);
  } else {

  }
#line 9241
  return;
}
}
#line 9244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_SetSwPenaltyTxRateAdaptive(struct rtw_adapter *padapter , u8 raType ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tmpU1 ;

  {
#line 9249
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9252
  tmpU1 = rtl8723au_read8(padapter, 1277);
#line 9253
  tmpU1 = (u8 )((unsigned int )tmpU1 | 1U);
#line 9254
  if ((unsigned int )raType == 1U) {
#line 9255
    tmpU1 = (unsigned int )tmpU1 & 251U;
#line 9256
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else
#line 9257
  if ((unsigned int )raType == 0U) {
#line 9258
    tmpU1 = (u8 )((unsigned int )tmpU1 | 4U);
  } else {

  }
#line 9261
  rtl8723au_write8(padapter, 1277, (int )tmpU1);
#line 9262
  return;
}
}
#line 9264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_SetFwDecBtPwr(struct rtw_adapter *padapter , u8 bDecBtPwr ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[1U] ;

  {
#line 9266
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9267
  H2C_Parameter[0] = 0U;
#line 9269
  H2C_Parameter[0] = 0U;
#line 9271
  if ((unsigned int )bDecBtPwr != 0U) {
#line 9272
    H2C_Parameter[0] = (u8 )((unsigned int )H2C_Parameter[0] | 2U);
#line 9273
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
#line 9276
  if (BTCoexDbgLevel == 1U) {
#line 9276
    printk("[BTCoex], decrease Bt Power : %s, write 0x21 = 0x%x\n", (unsigned int )bDecBtPwr != 0U ? (char *)"Yes!!" : (char *)"No!!",
           (int )H2C_Parameter[0]);
  } else {

  }
#line 9279
  FillH2CCmd(padapter, 33, 1U, (u8 *)(& H2C_Parameter));
#line 9280
  return;
}
}
#line 9282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_BtProfileSupport(struct rtw_adapter *padapter ) 
{ 
  u8 bRet ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;

  {
#line 9284
  bRet = 0U;
#line 9285
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9286
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9287
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9289
  if ((unsigned int )pBtMgnt->bSupportProfile != 0U && (unsigned int )pHalData->bt_coexist.halCoex8723.bForceFwBtInfo == 0U) {
#line 9291
    bRet = 1U;
  } else {

  }
#line 9293
  return (bRet);
}
}
#line 9296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_AdjustForBtOperation8723A(struct rtw_adapter *padapter ) 
{ 


  {
#line 9298
  return;
}
}
#line 9301 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_FwC2hBtRssi8723A(struct rtw_adapter *padapter , u8 *tmpBuf ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 percent ;
  u8 u1tmp ;

  {
#line 9303
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9304
  percent = 0U;
#line 9304
  u1tmp = 0U;
#line 9306
  u1tmp = *tmpBuf;
#line 9307
  percent = (unsigned int )((u8 )((int )u1tmp + 5)) * 2U;
#line 9309
  pHalData->bt_coexist.halCoex8723.btRssi = percent;
#line 9310
  return;
}
}
#line 9314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void rtl8723a_fw_c2h_BT_info(struct rtw_adapter *padapter , u8 *tmpBuf , u8 length ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 i ;
  u8 tmp ;

  {
#line 9322
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9323
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9324
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9325
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 9327
  pBtCoex->bC2hBtInfoReqSent = 0U;
#line 9329
  if (BTCoexDbgLevel == 1U) {
#line 9329
    printk("[BTC2H], BT info[%d]=[", (int )length);
  } else {

  }
#line 9331
  pBtCoex->btRetryCnt = 0U;
#line 9332
  i = 0U;
#line 9332
  goto ldv_58015;
  ldv_58014: ;
#line 9333
  switch ((int )i) {
  case 0: 
#line 9335
  pBtCoex->c2hBtInfoOriginal = *(tmpBuf + (unsigned long )i);
#line 9336
  goto ldv_58010;
  case 1: 
#line 9338
  pBtCoex->btRetryCnt = *(tmpBuf + (unsigned long )i);
#line 9339
  goto ldv_58010;
  case 2: 
#line 9341
  BTDM_FwC2hBtRssi8723A(padapter, tmpBuf + (unsigned long )i);
#line 9342
  goto ldv_58010;
  case 3: 
#line 9344
  pBtCoex->btInfoExt = (unsigned int )*(tmpBuf + (unsigned long )i) & 1U;
#line 9345
  goto ldv_58010;
  }
  ldv_58010: ;
#line 9348
  if ((int )i == (int )length + -1) {
#line 9349
    if (BTCoexDbgLevel == 1U) {
#line 9349
      printk("0x%02x]\n", (int )*(tmpBuf + (unsigned long )i));
    } else {

    }
  } else
#line 9351
  if (BTCoexDbgLevel == 1U) {
#line 9351
    printk("0x%02x, ", (int )*(tmpBuf + (unsigned long )i));
  } else {

  }
#line 9332
  i = (u8 )((int )i + 1);
  ldv_58015: ;
#line 9332
  if ((int )i < (int )length) {
#line 9334
    goto ldv_58014;
  } else {

  }

#line 9353
  if (BTCoexDbgLevel == 1U) {
#line 9353
    printk("[BTC2H], BT RSSI =%d\n", (int )pBtCoex->btRssi);
  } else {

  }
#line 9354
  if ((unsigned int )pBtCoex->btInfoExt != 0U) {
#line 9355
    if (BTCoexDbgLevel == 1U) {
#line 9355
      printk("[BTC2H], pBtCoex->btInfoExt =%x\n", (int )pBtCoex->btInfoExt);
    } else {

    }
  } else {

  }
#line 9357
  tmp = btdm_BtWifiAntNum(padapter);
#line 9357
  if ((unsigned int )tmp == 1U) {
#line 9358
    BTDM_1AntFwC2hBtInfo8723A(padapter);
  } else {
#line 9360
    BTDM_2AntFwC2hBtInfo8723A(padapter);
  }
#line 9362
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9363
    if (BTCoexDbgLevel == 1U) {
#line 9363
      printk("%s: Action Manual control!!\n", "rtl8723a_fw_c2h_BT_info");
    } else {

    }
#line 9364
    return;
  } else {

  }
#line 9367
  btdm_BTCoexist8723AHandler(padapter);
#line 9368
  return;
}
}
#line 9370 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_Display8723ABtCoexInfo(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 u1Tmp ;
  u8 u1Tmp1 ;
  u8 u1Tmp2 ;
  u8 i ;
  u8 btInfoExt ;
  u8 psTdmaCase ;
  u32 u4Tmp[4U] ;
  u8 antNum ;
  bool tmp ;
  int tmp___0 ;
  s32 tmp___1 ;
  u8 tmp___3 ;
  char *tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___7 ;
  char *tmp___8 ;
  u8 tmp___9 ;
  u8 tmp___10 ;
  u8 tmp___11 ;
  u8 tmp___12 ;
  u8 tmp___13 ;
  u8 tmp___14 ;

  {
#line 9372
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9373
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 9374
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9375
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9376
  psTdmaCase = 0U;
#line 9378
  antNum = 0U;
#line 9380
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n ============[BT Coexist info]============");
#line 9383
  tmp = rtl8723a_BT_coexist(padapter);
#line 9383
  if (tmp) {
#line 9383
    tmp___0 = 0;
  } else {
#line 9383
    tmp___0 = 1;
  }
#line 9383
  if (tmp___0) {
#line 9384
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n BT not exists !!!");
#line 9386
    return;
  } else {

  }
#line 9389
  antNum = btdm_BtWifiAntNum(padapter);
#line 9390
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d/%d ", (char *)"Ant mechanism PG/Now run :",
           (unsigned int )pHalData->bt_coexist.BT_Ant_Num == 0U ? 2 : 1, (unsigned int )antNum == 0U ? 2 : 1);
#line 9394
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9395
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"[Action Manual control]!!");
  } else {
#line 9398
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s / %d", (char *)"BT stack/ hci ext ver",
             (unsigned int )pBtMgnt->bSupportProfile != 0U ? (char *)"Yes" : (char *)"No",
             (int )pBtMgnt->ExtConfig.HCIExtensionVer);
  }
#line 9403
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\n %-35s = / %d", (char *)"Dot11 channel / BT channel",
           (int )pBtMgnt->BTChannel);
#line 9407
  tmp___1 = BTDM_GetRxSS(padapter);
#line 9407
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\n %-35s = %d / %d / %d", (char *)"Wifi/BT/HS rssi",
           tmp___1, (int )pHalData->bt_coexist.halCoex8723.btRssi, pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB);
#line 9413
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
#line 9414
    tmp___5 = BTDM_IsWifiBusy(padapter);
#line 9414
    if ((unsigned int )tmp___5 != 0U) {
#line 9414
      tmp___3 = BTDM_IsWifiUplink(padapter);
#line 9414
      tmp___4 = (unsigned int )tmp___3 != 0U ? (char *)"uplink" : (char *)"downlink";
    } else {
#line 9414
      tmp___4 = (char *)"idle";
    }
#line 9414
    tmp___9 = BTDM_Legacy(padapter);
#line 9414
    if ((unsigned int )tmp___9 == 0U) {
#line 9414
      tmp___7 = BTDM_IsHT40(padapter);
#line 9414
      tmp___8 = (unsigned int )tmp___7 != 0U ? (char *)"HT40" : (char *)"HT20";
    } else {
#line 9414
      tmp___8 = (char *)"Legacy";
    }
#line 9414
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\n %-35s = %s / %s ", (char *)"WIfi status",
             tmp___8, tmp___4);
#line 9419
    if ((unsigned int )pBtMgnt->bSupportProfile != 0U) {
#line 9420
      tmp___10 = BTHCI_CheckProfileExist(padapter, 1);
#line 9420
      tmp___11 = BTHCI_CheckProfileExist(padapter, 2);
#line 9420
      tmp___12 = BTHCI_CheckProfileExist(padapter, 3);
#line 9420
      tmp___13 = BTHCI_CheckProfileExist(padapter, 4);
#line 9420
      snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d / %d / %d / %d",
               (char *)"SCO/HID/PAN/A2DP", (unsigned int )tmp___13 != 0U, (unsigned int )tmp___12 != 0U,
               (unsigned int )tmp___11 != 0U, (unsigned int )tmp___10 != 0U);
#line 9427
      i = 0U;
#line 9427
      goto ldv_58034;
      ldv_58033: ;
#line 9428
      if ((unsigned int )pBtMgnt->ExtConfig.HCIExtensionVer != 0U) {
#line 9429
        snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s/ %s/ %s", (char *)"Bt link type/spec/role",
                 BtProfileString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile],
                 BtSpecString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec],
                 BtLinkRoleString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole]);
#line 9435
        btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
#line 9436
        snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s", (char *)"A2DP rate",
                 (int )btInfoExt & 1 ? (char *)"Basic rate" : (char *)"EDR rate");
      } else {
#line 9441
        snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s/ %s", (char *)"Bt link type/spec",
                 BtProfileString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile],
                 BtSpecString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec]);
      }
#line 9427
      i = (u8 )((int )i + 1);
      ldv_58034: ;
#line 9427
      if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
#line 9429
        goto ldv_58033;
      } else {

      }

    } else {

    }
  } else {

  }
#line 9451
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
#line 9452
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"============[Sw BT Coex mechanism]============");
#line 9454
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"AGC Table",
             (int )pBtCoex->btdm2Ant.bCurAgcTableEn);
#line 9457
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"ADC Backoff",
             (int )pBtCoex->btdm2Ant.bCurAdcBackOff);
#line 9460
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"Low penalty RA",
             (int )pBtCoex->btdm2Ant.bCurLowPenaltyRa);
#line 9463
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"RF Rx LPF Shrink",
             (int )pBtCoex->btdm2Ant.bCurRfRxLpfShrink);
  } else {

  }
#line 9467
  u4Tmp[0] = PHY_QueryRFReg(padapter, 0, 30U, 4080U);
#line 9468
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x", (char *)"RF-A, 0x1e[11:4]/original val",
           u4Tmp[0], pHalData->bt_coexist.BtRfRegOrigin1E);
#line 9473
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
#line 9474
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"============[Fw BT Coex mechanism]============");
  } else {

  }
#line 9477
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
#line 9478
    tmp___14 = btdm_BtWifiAntNum(padapter);
#line 9478
    if ((unsigned int )tmp___14 == 1U) {
#line 9479
      psTdmaCase = pHalData->bt_coexist.halCoex8723.btdm1Ant.curPsTdma;
    } else {
#line 9481
      psTdmaCase = pHalData->bt_coexist.halCoex8723.btdm2Ant.curPsTdma;
    }
#line 9482
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %02x %02x %02x %02x %02x case-%d",
             (char *)"PS TDMA(0x3a)", (int )pHalData->bt_coexist.fw3aVal[0], (int )pHalData->bt_coexist.fw3aVal[1],
             (int )pHalData->bt_coexist.fw3aVal[2], (int )pHalData->bt_coexist.fw3aVal[3],
             (int )pHalData->bt_coexist.fw3aVal[4], (int )psTdmaCase);
#line 9488
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"Decrease Bt Power",
             (int )pBtCoex->btdm2Ant.bCurDecBtPwr);
  } else {

  }
#line 9492
  u1Tmp = rtl8723au_read8(padapter, 1912);
#line 9493
  u1Tmp1 = rtl8723au_read8(padapter, 1923);
#line 9494
  u1Tmp2 = rtl8723au_read8(padapter, 1942);
#line 9495
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", (char *)"0x778/ 0x783/ 0x796",
           (int )u1Tmp, (int )u1Tmp1, (int )u1Tmp2);
#line 9499
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
#line 9500
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x / 0x%x", (char *)"Sw DacSwing Ctrl/Val",
             (int )pBtCoex->btdm2Ant.bCurDacSwingOn, pBtCoex->btdm2Ant.curDacSwingLvl);
  } else {

  }
#line 9504
  u4Tmp[0] = rtl8723au_read32(padapter, 2176);
#line 9505
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x880",
           u4Tmp[0]);
#line 9510
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
#line 9511
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"============[Hw BT Coex mechanism]============");
  } else {

  }
#line 9515
  u1Tmp = rtl8723au_read8(padapter, 64);
#line 9516
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x40", (int )u1Tmp);
#line 9520
  u4Tmp[0] = rtl8723au_read32(padapter, 1360);
#line 9521
  u1Tmp = rtl8723au_read8(padapter, 1314);
#line 9522
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/0x%x", (char *)"0x550(bcn contrl)/0x522",
           u4Tmp[0], (int )u1Tmp);
#line 9526
  u4Tmp[0] = rtl8723au_read32(padapter, 1156);
#line 9527
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x484(rate adaptive)",
           u4Tmp[0]);
#line 9531
  u4Tmp[0] = rtl8723au_read32(padapter, 80);
#line 9532
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0xc50(dig)",
           u4Tmp[0]);
#line 9536
  u4Tmp[0] = rtl8723au_read32(padapter, 3488);
#line 9537
  u4Tmp[1] = rtl8723au_read32(padapter, 3492);
#line 9538
  u4Tmp[2] = rtl8723au_read32(padapter, 3496);
#line 9539
  u4Tmp[3] = rtl8723au_read32(padapter, 3500);
#line 9540
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
           (char *)"0xda0/0xda4/0xda8/0xdac(FA cnt)", u4Tmp[0], u4Tmp[1], u4Tmp[2],
           u4Tmp[3]);
#line 9544
  u4Tmp[0] = rtl8723au_read32(padapter, 1728);
#line 9545
  u4Tmp[1] = rtl8723au_read32(padapter, 1732);
#line 9546
  u4Tmp[2] = rtl8723au_read32(padapter, 1736);
#line 9547
  u1Tmp = rtl8723au_read8(padapter, 1740);
#line 9548
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
           (char *)"0x6c0/0x6c4/0x6c8/0x6cc(coexTable)", u4Tmp[0], u4Tmp[1], u4Tmp[2],
           (int )u1Tmp);
#line 9553
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d / %d", (char *)"0x770(Hi pri Rx[31:16]/Tx[15:0])",
           pHalData->bt_coexist.halCoex8723.highPriorityRx, pHalData->bt_coexist.halCoex8723.highPriorityTx);
#line 9558
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d / %d", (char *)"0x774(Lo pri Rx[31:16]/Tx[15:0])",
           pHalData->bt_coexist.halCoex8723.lowPriorityRx, pHalData->bt_coexist.halCoex8723.lowPriorityTx);
#line 9564
  u1Tmp = rtl8723au_read8(padapter, 1051);
#line 9565
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x41b (hang chk == 0xf)",
           (int )u1Tmp);
#line 9568
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"lastHMEBoxNum",
           (int )pHalData->LastHMEBoxNum);
#line 9570
  return;
}
}
#line 9574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_8723ASignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi ,
                                         u8 *rssi_bt ) 
{ 
  u8 tmp ;

  {
#line 9577
  tmp = btdm_BtWifiAntNum(padapter);
#line 9577
  if ((unsigned int )tmp == 1U) {
#line 9578
    BTDM_1AntSignalCompensation(padapter, rssi_wifi, rssi_bt);
  } else {

  }
#line 9579
  return;
}
}
#line 9581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_8723AInit(struct rtw_adapter *padapter ) 
{ 
  u8 tmp ;

  {
#line 9583
  tmp = btdm_BtWifiAntNum(padapter);
#line 9583
  if ((unsigned int )tmp == 0U) {
#line 9584
    BTDM_2AntParaInit(padapter);
  } else {
#line 9586
    BTDM_1AntParaInit(padapter);
  }
#line 9587
  return;
}
}
#line 9589 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_HWCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9591
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9592
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9594
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9595
    return;
  } else {

  }
#line 9597
  tmp = btdm_BtWifiAntNum(padapter);
#line 9597
  if ((unsigned int )tmp == 0U) {
#line 9598
    BTDM_2AntHwCoexAllOff8723A(padapter);
  } else {

  }
#line 9599
  return;
}
}
#line 9601 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_FWCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9603
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9604
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9606
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9607
    return;
  } else {

  }
#line 9609
  tmp = btdm_BtWifiAntNum(padapter);
#line 9609
  if ((unsigned int )tmp == 0U) {
#line 9610
    BTDM_2AntFwCoexAllOff8723A(padapter);
  } else {

  }
#line 9611
  return;
}
}
#line 9613 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_SWCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9615
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9616
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9618
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9619
    return;
  } else {

  }
#line 9621
  tmp = btdm_BtWifiAntNum(padapter);
#line 9621
  if ((unsigned int )tmp == 0U) {
#line 9622
    BTDM_2AntSwCoexAllOff8723A(padapter);
  } else {

  }
#line 9623
  return;
}
}
#line 9626 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_Set8723ABtCoexCurrAntNum(struct rtw_adapter *padapter , u8 antNum ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;

  {
#line 9628
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9629
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 9631
  if ((unsigned int )antNum == 1U) {
#line 9632
    pBtCoex->TotalAntNum = 1U;
  } else
#line 9633
  if ((unsigned int )antNum == 2U) {
#line 9634
    pBtCoex->TotalAntNum = 0U;
  } else {

  }
#line 9635
  return;
}
}
#line 9637 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void rtl8723a_BT_lps_leave(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9639
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9640
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9642
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9643
    return;
  } else {

  }
#line 9645
  tmp = btdm_BtWifiAntNum(padapter);
#line 9645
  if ((unsigned int )tmp == 1U) {
#line 9646
    BTDM_1AntLpsLeave(padapter);
  } else {

  }
#line 9647
  return;
}
}
#line 9649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_ForHalt8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9651
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9652
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9654
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9655
    return;
  } else {

  }
#line 9657
  tmp = btdm_BtWifiAntNum(padapter);
#line 9657
  if ((unsigned int )tmp == 1U) {
#line 9658
    BTDM_1AntForHalt(padapter);
  } else {

  }
#line 9659
  return;
}
}
#line 9661 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_WifiScanNotify8723A(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9663
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9664
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9666
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9667
    return;
  } else {

  }
#line 9669
  tmp = btdm_BtWifiAntNum(padapter);
#line 9669
  if ((unsigned int )tmp == 1U) {
#line 9670
    BTDM_1AntWifiScanNotify(padapter, (int )scanType);
  } else {

  }
#line 9671
  return;
}
}
#line 9674 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_WifiAssociateNotify8723A(struct rtw_adapter *padapter , u8 action ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9676
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9677
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9679
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9680
    return;
  } else {

  }
#line 9682
  tmp = btdm_BtWifiAntNum(padapter);
#line 9682
  if ((unsigned int )tmp == 1U) {
#line 9683
    BTDM_1AntWifiAssociateNotify(padapter, (int )action);
  } else {

  }
#line 9684
  return;
}
}
#line 9687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_MediaStatusNotify8723A(struct rtw_adapter *padapter , enum rt_media_status mstatus ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9690
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9691
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9693
  if (BTCoexDbgLevel == 1U) {
#line 9693
    printk("[BTCoex], MediaStatusNotify, %s\n", (unsigned int )mstatus != 0U ? (char *)"connect" : (char *)"disconnect");
  } else {

  }
#line 9696
  BTDM_SetFwChnlInfo(padapter, mstatus);
#line 9698
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9699
    return;
  } else {

  }
#line 9701
  tmp = btdm_BtWifiAntNum(padapter);
#line 9701
  if ((unsigned int )tmp == 1U) {
#line 9702
    BTDM_1AntMediaStatusNotify(padapter, mstatus);
  } else {

  }
#line 9703
  return;
}
}
#line 9705 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_ForDhcp8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9707
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9708
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9710
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9711
    return;
  } else {

  }
#line 9713
  tmp = btdm_BtWifiAntNum(padapter);
#line 9713
  if ((unsigned int )tmp == 1U) {
#line 9714
    BTDM_1AntForDhcp(padapter);
  } else {

  }
#line 9715
  return;
}
}
#line 9717 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
bool rtl8723a_BT_using_antenna_1(struct rtw_adapter *padapter ) 
{ 
  u8 tmp ;

  {
#line 9719
  tmp = btdm_BtWifiAntNum(padapter);
#line 9719
  if ((unsigned int )tmp == 1U) {
#line 9720
    return (1);
  } else {
#line 9722
    return (0);
  }
}
}
#line 9725 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_BTCoexist8723A(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_coexist_8723a *pBtCoex ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 9732
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9733
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9734
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9735
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 9737
  if (BTCoexDbgLevel == 1U) {
#line 9737
    printk("[BTCoex], beacon RSSI = 0x%x(%d)\n", pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB,
           pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB);
  } else {

  }
#line 9741
  btdm_BtHwCountersMonitor(padapter);
#line 9742
  btdm_BtEnableDisableCheck8723A(padapter);
#line 9744
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9745
    if (BTCoexDbgLevel == 1U) {
#line 9745
      printk("%s: Action Manual control!!\n", "BTDM_BTCoexist8723A");
    } else {

    }
#line 9746
    return;
  } else {

  }
#line 9749
  if ((unsigned int )pBtCoex->bC2hBtInfoReqSent != 0U) {
#line 9750
    tmp = rtl8723a_BT_enabled(padapter);
#line 9750
    if (tmp) {
#line 9750
      tmp___0 = 0;
    } else {
#line 9750
      tmp___0 = 1;
    }
#line 9750
    if (tmp___0) {
#line 9751
      pBtCoex->c2hBtInfo = 0U;
    } else
#line 9753
    if ((unsigned int )pBtCoex->c2hBtInfo == 0U) {
#line 9754
      pBtCoex->c2hBtInfo = 1U;
    } else {

    }
#line 9757
    btdm_BTCoexist8723AHandler(padapter);
  } else {
#line 9758
    tmp___1 = rtl8723a_BT_enabled(padapter);
#line 9758
    if (tmp___1) {
#line 9758
      tmp___2 = 0;
    } else {
#line 9758
      tmp___2 = 1;
    }
#line 9758
    if (tmp___2) {
#line 9759
      pBtCoex->c2hBtInfo = 0U;
#line 9760
      btdm_BTCoexist8723AHandler(padapter);
    } else {

    }
  }
#line 9763
  BTDM_QueryBtInformation(padapter);
#line 9764
  return;
}
}
#line 9773 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void BTDM_SetAntenna(struct rtw_adapter *padapter , u8 who ) 
{ 


  {
#line 9775
  return;
}
}
#line 9778 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_SingleAnt(struct rtw_adapter *padapter , u8 bSingleAntOn , u8 bInterruptOn ,
                    u8 bMultiNAVOn ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;

  {
#line 9785
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9786
  H2C_Parameter[0] = 0U;
#line 9786
  tmp = 1U;
#line 9786
  while (1) {
#line 9786
    if (tmp >= 3U) {
#line 9786
      break;
    } else {

    }
#line 9786
    H2C_Parameter[tmp] = (unsigned char)0;
#line 9786
    tmp = tmp + 1U;
  }
#line 9788
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num != 1U) {
#line 9789
    return;
  } else {

  }
#line 9791
  H2C_Parameter[2] = 0U;
#line 9792
  H2C_Parameter[1] = 0U;
#line 9793
  H2C_Parameter[0] = 0U;
#line 9795
  if ((unsigned int )bInterruptOn != 0U) {
#line 9796
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 2U);
#line 9797
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
#line 9799
  pHalData->bt_coexist.bInterruptOn = bInterruptOn;
#line 9801
  if ((unsigned int )bSingleAntOn != 0U) {
#line 9802
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 16U);
#line 9803
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
#line 9805
  pHalData->bt_coexist.bSingleAntOn = bSingleAntOn;
#line 9807
  if ((unsigned int )bMultiNAVOn != 0U) {
#line 9808
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 32U);
#line 9809
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
#line 9811
  pHalData->bt_coexist.bMultiNAVOn = bMultiNAVOn;
#line 9813
  if (BTCoexDbgLevel == 1U) {
#line 9813
    printk("[DM][BT], SingleAntenna =[%s:%s:%s], write 0xe = 0x%x\n", (unsigned int )bSingleAntOn != 0U ? (char *)"ON" : (char *)"OFF",
           (unsigned int )bInterruptOn != 0U ? (char *)"ON" : (char *)"OFF", (unsigned int )bMultiNAVOn != 0U ? (char *)"ON" : (char *)"OFF",
           (((int )H2C_Parameter[0] << 16) | ((int )H2C_Parameter[1] << 8)) | (int )H2C_Parameter[2]);
  } else {

  }
#line 9814
  return;
}
}
#line 9818 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_CheckBTIdleChange1Ant(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  u8 stateChange ;
  u32 BT_Polling ;
  u32 Ratio_Act ;
  u32 Ratio_STA ;
  u32 BT_Active ;
  u32 BT_State ;
  u32 regBTActive ;
  u32 regBTState ;
  u32 regBTPolling ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 9820
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9821
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9822
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9824
  stateChange = 0U;
#line 9827
  regBTActive = 0U;
#line 9827
  regBTState = 0U;
#line 9827
  regBTPolling = 0U;
#line 9829
  tmp = rtl8723a_BT_coexist(padapter);
#line 9829
  if (tmp) {
#line 9829
    tmp___0 = 0;
  } else {
#line 9829
    tmp___0 = 1;
  }
#line 9829
  if (tmp___0) {
#line 9830
    return;
  } else {

  }
#line 9831
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9832
    return;
  } else {

  }
#line 9833
  if ((unsigned int )pHalData->bt_coexist.BT_CoexistType != 4U) {
#line 9834
    return;
  } else {

  }
#line 9835
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num != 1U) {
#line 9836
    return;
  } else {

  }
#line 9839
  if (BTCoexDbgLevel == 1U) {
#line 9839
    printk("[DM][BT], FirmwareVersion = 0x%x(%d)\n", (int )pHalData->FirmwareVersion,
           (int )pHalData->FirmwareVersion);
  } else {

  }
#line 9841
  regBTActive = 1092U;
#line 9842
  regBTState = 1096U;
#line 9843
  if ((unsigned int )pHalData->FirmwareVersion > 73U) {
#line 9844
    regBTPolling = 1100U;
  } else {
#line 9846
    regBTPolling = 1792U;
  }
#line 9848
  BT_Active = rtl8723au_read32(padapter, (int )((u16 )regBTActive));
#line 9849
  if (BTCoexDbgLevel == 1U) {
#line 9849
    printk("[DM][BT], BT_Active(0x%x) =%x\n", regBTActive, BT_Active);
  } else {

  }
#line 9850
  BT_Active = BT_Active & 16777215U;
#line 9852
  BT_State = rtl8723au_read32(padapter, (int )((u16 )regBTState));
#line 9853
  if (BTCoexDbgLevel == 1U) {
#line 9853
    printk("[DM][BT], BT_State(0x%x) =%x\n", regBTState, BT_State);
  } else {

  }
#line 9854
  BT_State = BT_State & 16777215U;
#line 9856
  BT_Polling = rtl8723au_read32(padapter, (int )((u16 )regBTPolling));
#line 9857
  if (BTCoexDbgLevel == 1U) {
#line 9857
    printk("[DM][BT], BT_Polling(0x%x) =%x\n", regBTPolling, BT_Polling);
  } else {

  }
#line 9859
  if ((BT_Active == 4294967295U && BT_State == 4294967295U) && BT_Polling == 4294967295U) {
#line 9860
    return;
  } else {

  }
#line 9861
  if (BT_Polling == 0U) {
#line 9862
    return;
  } else {

  }
#line 9864
  Ratio_Act = (BT_Active * 1000U) / BT_Polling;
#line 9865
  Ratio_STA = (BT_State * 1000U) / BT_Polling;
#line 9867
  pHalData->bt_coexist.Ratio_Tx = Ratio_Act;
#line 9868
  pHalData->bt_coexist.Ratio_PRI = Ratio_STA;
#line 9870
  if (BTCoexDbgLevel == 1U) {
#line 9870
    printk("[DM][BT], Ratio_Act =%d\n", Ratio_Act);
  } else {

  }
#line 9871
  if (BTCoexDbgLevel == 1U) {
#line 9871
    printk("[DM][BT], Ratio_STA =%d\n", Ratio_STA);
  } else {

  }
#line 9873
  if (Ratio_STA <= 59U && Ratio_Act <= 499U) {
#line 9874
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 32768ULL;
#line 9875
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffdffffULL;
#line 9876
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffeffffULL;
  } else {
#line 9878
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffff7fffULL;
#line 9880
    if (Ratio_STA != 0U) {
#line 9882
      if (Ratio_Act / Ratio_STA <= 1U) {
#line 9884
        pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = 1U;
#line 9885
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 65536ULL;
#line 9886
        pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = 0U;
#line 9887
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffdffffULL;
      } else {
#line 9890
        pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = 0U;
#line 9891
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffeffffULL;
#line 9892
        pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = 1U;
#line 9893
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 131072ULL;
      }
    } else {
#line 9897
      pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = 0U;
#line 9898
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffeffffULL;
#line 9899
      pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = 1U;
#line 9900
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 131072ULL;
    }
  }
#line 9905
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfSCO == 0U) {
#line 9907
    pBtMgnt->ExtConfig.bBTBusy = 0U;
#line 9908
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4096ULL;
  } else
#line 9910
  if (Ratio_STA <= 59U) {
#line 9911
    pBtMgnt->ExtConfig.bBTBusy = 0U;
#line 9912
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4096ULL;
  } else {
#line 9914
    pBtMgnt->ExtConfig.bBTBusy = 1U;
#line 9915
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffefffULL;
  }
#line 9919
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfSCO == 0U) {
#line 9921
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffff7ffffULL;
#line 9922
    pBtMgnt->ExtConfig.MIN_BT_RSSI = 0;
#line 9923
    BTDM_SetAntenna(padapter, 0);
  } else
#line 9925
  if ((int )pBtMgnt->ExtConfig.MIN_BT_RSSI < -4) {
#line 9926
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 524288ULL;
#line 9927
    if (BTCoexDbgLevel == 1U) {
#line 9927
      printk("[DM][BT], core stack notify bt rssi Low\n");
    } else {

    }
  } else {
#line 9929
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffff7ffffULL;
#line 9930
    if (BTCoexDbgLevel == 1U) {
#line 9930
      printk("[DM][BT], core stack notify bt rssi Normal\n");
    } else {

    }
  }
#line 9934
  if ((int )pHalData->bt_coexist.bBTBusyTraffic != (int )pBtMgnt->ExtConfig.bBTBusy) {
#line 9936
    pHalData->bt_coexist.bBTBusyTraffic = pBtMgnt->ExtConfig.bBTBusy;
#line 9937
    stateChange = 1U;
  } else {

  }
#line 9940
  if ((unsigned int )stateChange != 0U) {
#line 9941
    if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy == 0U) {
#line 9942
      if (BTCoexDbgLevel == 1U) {
#line 9942
        printk("[DM][BT], BT is idle or disable\n");
      } else {

      }
    } else
#line 9944
    if (BTCoexDbgLevel == 1U) {
#line 9944
      printk("[DM][BT], BT is non-idle\n");
    } else {

    }
  } else {

  }
#line 9946
  if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy == 0U) {
#line 9947
    if (BTCoexDbgLevel == 1U) {
#line 9947
      printk("[DM][BT], BT is idle or disable\n");
    } else {

    }
#line 9948
    tmp___1 = check_fwstate(& padapter->mlmepriv, 2176);
#line 9948
    if ((int )tmp___1) {
#line 9949
      BTDM_SetAntenna(padapter, 1);
    } else {

    }
  } else {

  }
#line 9951
  return;
}
}
#line 9967 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_DiminishWiFi(struct rtw_adapter *padapter , u8 bDACOn , u8 bInterruptOn ,
                       u8 DACSwingLevel , u8 bNAVOn ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;

  {
#line 9975
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9976
  H2C_Parameter[0] = 0U;
#line 9976
  tmp = 1U;
#line 9976
  while (1) {
#line 9976
    if (tmp >= 3U) {
#line 9976
      break;
    } else {

    }
#line 9976
    H2C_Parameter[tmp] = (unsigned char)0;
#line 9976
    tmp = tmp + 1U;
  }
#line 9978
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num != 0U) {
#line 9979
    return;
  } else {

  }
#line 9981
  if ((pHalData->bt_coexist.CurrentState & 524288ULL) != 0ULL && (unsigned int )DACSwingLevel == 32U) {
#line 9983
    if (BTCoexDbgLevel == 1U) {
#line 9983
      printk("[BT]DiminishWiFi 0x20 original, but set 0x18 for Low RSSI!\n");
    } else {

    }
#line 9984
    DACSwingLevel = 24U;
  } else {

  }
#line 9987
  H2C_Parameter[2] = 0U;
#line 9988
  H2C_Parameter[1] = DACSwingLevel;
#line 9989
  H2C_Parameter[0] = 0U;
#line 9990
  if ((unsigned int )bDACOn != 0U) {
#line 9991
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 1U);
#line 9992
    if ((unsigned int )bInterruptOn != 0U) {
#line 9993
      H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 2U);
    } else {

    }
#line 9994
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
#line 9996
  if ((unsigned int )bNAVOn != 0U) {
#line 9997
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 8U);
#line 9998
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
#line 10001
  if (BTCoexDbgLevel == 1U) {
#line 10001
    printk("[DM][BT], bDACOn = %s, bInterruptOn = %s, write 0xe = 0x%x\n", (unsigned int )bDACOn != 0U ? (char *)"ON" : (char *)"OFF",
           (unsigned int )bInterruptOn != 0U ? (char *)"ON" : (char *)"OFF", (((int )H2C_Parameter[0] << 16) | ((int )H2C_Parameter[1] << 8)) | (int )H2C_Parameter[2]);
  } else {

  }
#line 10004
  if (BTCoexDbgLevel == 1U) {
#line 10004
    printk("[DM][BT], bNAVOn = %s\n", (unsigned int )bNAVOn != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
#line 10005
  return;
}
}
#line 10013 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_ResetFWCoexState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10015
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10017
  pHalData->bt_coexist.CurrentState = 0ULL;
#line 10018
  pHalData->bt_coexist.PreviousState = 0ULL;
#line 10019
  return;
}
}
#line 10021 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void btdm_InitBtCoexistDM(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10023
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10026
  pHalData->bt_coexist.BtRfRegOrigin1E = PHY_QueryRFReg(padapter, 0, 30U, 1048575U);
#line 10027
  pHalData->bt_coexist.BtRfRegOrigin1F = PHY_QueryRFReg(padapter, 0, 31U, 240U);
#line 10029
  pHalData->bt_coexist.CurrentState = 0ULL;
#line 10030
  pHalData->bt_coexist.PreviousState = 0ULL;
#line 10032
  BTDM_8723AInit(padapter);
#line 10033
  pHalData->bt_coexist.bInitlized = 1U;
#line 10034
  return;
}
}
#line 10039 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_CheckAntSelMode(struct rtw_adapter *padapter ) 
{ 


  {
#line 10041
  return;
}
}
#line 10043 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_FwC2hBtRssi(struct rtw_adapter *padapter , u8 *tmpBuf ) 
{ 


  {
#line 10045
  BTDM_FwC2hBtRssi8723A(padapter, tmpBuf);
#line 10046
  return;
}
}
#line 10048 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_DisplayBtCoexInfo(struct rtw_adapter *padapter ) 
{ 


  {
#line 10050
  BTDM_Display8723ABtCoexInfo(padapter);
#line 10051
  return;
}
}
#line 10053 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_RejectAPAggregatedPacket(struct rtw_adapter *padapter , u8 bReject ) 
{ 


  {
#line 10055
  return;
}
}
#line 10057 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsHT40(struct rtw_adapter *padapter ) 
{ 
  u8 isht40 ;
  enum ht_channel_width bw ;

  {
#line 10059
  isht40 = 1U;
#line 10062
  bw = (enum ht_channel_width )padapter->mlmeextpriv.cur_bwmode;
#line 10064
  if ((unsigned int )bw == 0U) {
#line 10065
    isht40 = 0U;
  } else
#line 10066
  if ((unsigned int )bw == 1U) {
#line 10067
    isht40 = 1U;
  } else {

  }
#line 10069
  return (isht40);
}
}
#line 10072 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_Legacy(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  u8 isLegacy ;

  {
#line 10075
  isLegacy = 0U;
#line 10077
  pmlmeext = & padapter->mlmeextpriv;
#line 10078
  if (((unsigned int )pmlmeext->cur_wireless_mode == 1U || (unsigned int )pmlmeext->cur_wireless_mode == 2U) || (unsigned int )pmlmeext->cur_wireless_mode == 3U) {
#line 10081
    isLegacy = 1U;
  } else {

  }
#line 10083
  return (isLegacy);
}
}
#line 10086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_CheckWiFiState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 10093
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10094
  pmlmepriv = & padapter->mlmepriv;
#line 10095
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 10096
  pBtMgnt = & pBTInfo->BtMgnt;
#line 10098
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
#line 10099
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffeffULL;
#line 10101
    if ((int )pmlmepriv->LinkDetectInfo.bTxBusyTraffic) {
#line 10102
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 512ULL;
    } else {
#line 10104
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffdffULL;
    }
#line 10106
    if ((int )pmlmepriv->LinkDetectInfo.bRxBusyTraffic) {
#line 10107
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1024ULL;
    } else {
#line 10109
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffbffULL;
    }
  } else {
#line 10111
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 256ULL;
#line 10112
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffdffULL;
#line 10113
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffbffULL;
  }
#line 10116
  tmp___0 = BTDM_Legacy(padapter);
#line 10116
  if ((unsigned int )tmp___0 != 0U) {
#line 10117
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 8ULL;
#line 10118
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffdULL;
#line 10119
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffbULL;
  } else {
#line 10121
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffff7ULL;
#line 10122
    tmp = BTDM_IsHT40(padapter);
#line 10122
    if ((unsigned int )tmp != 0U) {
#line 10123
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4ULL;
#line 10124
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffdULL;
    } else {
#line 10126
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 2ULL;
#line 10127
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffbULL;
    }
  }
#line 10131
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
#line 10132
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1ULL;
  } else {
#line 10134
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffeULL;
  }
#line 10135
  return;
}
}
#line 10137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
s32 BTDM_GetRxSS(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  s32 UndecoratedSmoothedPWDB ;
  bool tmp ;

  {
#line 10142
  UndecoratedSmoothedPWDB = 0;
#line 10144
  pmlmepriv = & padapter->mlmepriv;
#line 10145
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10147
  tmp = check_fwstate(pmlmepriv, 1);
#line 10147
  if ((int )tmp) {
#line 10148
    UndecoratedSmoothedPWDB = ((struct hal_data_8723a *)padapter->HalData)->dmpriv.EntryMinUndecoratedSmoothedPWDB;
  } else {
#line 10150
    UndecoratedSmoothedPWDB = pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB;
  }
#line 10153
  if (BTCoexDbgLevel == 1U) {
#line 10153
    printk("BTDM_GetRxSS() = %d\n", UndecoratedSmoothedPWDB);
  } else {

  }
#line 10154
  return (UndecoratedSmoothedPWDB);
}
}
#line 10157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static s32 BTDM_GetRxBeaconSS(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  s32 pwdbBeacon ;
  bool tmp ;

  {
#line 10162
  pwdbBeacon = 0;
#line 10164
  pmlmepriv = & padapter->mlmepriv;
#line 10165
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10167
  tmp = check_fwstate(pmlmepriv, 1);
#line 10167
  if ((int )tmp) {
#line 10169
    pwdbBeacon = pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB;
  } else {

  }
#line 10171
  if (BTCoexDbgLevel == 1U) {
#line 10171
    printk("BTDM_GetRxBeaconSS() = %d\n", pwdbBeacon);
  } else {

  }
#line 10172
  return (pwdbBeacon);
}
}
#line 10176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_CheckCoexBcnRssiState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                              u8 RssiThresh1 ) 
{ 
  struct hal_data_8723a *pHalData ;
  s32 pwdbBeacon ;
  u8 bcnRssiState ;

  {
#line 10179
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10180
  pwdbBeacon = 0;
#line 10181
  bcnRssiState = 0U;
#line 10183
  pwdbBeacon = BTDM_GetRxBeaconSS(padapter);
#line 10185
  if ((unsigned int )levelNum == 2U) {
#line 10186
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffefffffffULL;
#line 10188
    if ((unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 2U || (unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 5U) {
#line 10190
      if ((int )RssiThresh + 6 <= pwdbBeacon) {
#line 10191
        bcnRssiState = 0U;
#line 10192
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 536870912ULL;
#line 10193
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
#line 10194
        if (BTCoexDbgLevel == 1U) {
#line 10194
          printk("[DM][BT], RSSI_BEACON state switch to High\n");
        } else {

        }
      } else {
#line 10196
        bcnRssiState = 5U;
#line 10197
        if (BTCoexDbgLevel == 1U) {
#line 10197
          printk("[DM][BT], RSSI_BEACON state stay at Low\n");
        } else {

        }
      }
    } else
#line 10200
    if ((int )RssiThresh > pwdbBeacon) {
#line 10201
      bcnRssiState = 2U;
#line 10202
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 134217728ULL;
#line 10203
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
#line 10204
      if (BTCoexDbgLevel == 1U) {
#line 10204
        printk("[DM][BT], RSSI_BEACON state switch to Low\n");
      } else {

      }
    } else {
#line 10206
      bcnRssiState = 3U;
#line 10207
      if (BTCoexDbgLevel == 1U) {
#line 10207
        printk("[DM][BT], RSSI_BEACON state stay at High\n");
      } else {

      }
    }
  } else
#line 10210
  if ((unsigned int )levelNum == 3U) {
#line 10211
    if ((int )RssiThresh > (int )RssiThresh1) {
#line 10212
      if (BTCoexDbgLevel == 1U) {
#line 10212
        printk("[DM][BT], RSSI_BEACON thresh error!!\n");
      } else {

      }
#line 10213
      return (pHalData->bt_coexist.preRssiStateBeacon);
    } else {

    }
#line 10216
    if ((unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 2U || (unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 5U) {
#line 10218
      if ((int )RssiThresh + 6 <= pwdbBeacon) {
#line 10219
        bcnRssiState = 1U;
#line 10220
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 268435456ULL;
#line 10221
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
#line 10222
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
#line 10223
        if (BTCoexDbgLevel == 1U) {
#line 10223
          printk("[DM][BT], RSSI_BEACON state switch to Medium\n");
        } else {

        }
      } else {
#line 10225
        bcnRssiState = 5U;
#line 10226
        if (BTCoexDbgLevel == 1U) {
#line 10226
          printk("[DM][BT], RSSI_BEACON state stay at Low\n");
        } else {

        }
      }
    } else
#line 10228
    if ((unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 1U || (unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 4U) {
#line 10230
      if ((int )RssiThresh1 + 6 <= pwdbBeacon) {
#line 10231
        bcnRssiState = 0U;
#line 10232
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 536870912ULL;
#line 10233
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
#line 10234
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffefffffffULL;
#line 10235
        if (BTCoexDbgLevel == 1U) {
#line 10235
          printk("[DM][BT], RSSI_BEACON state switch to High\n");
        } else {

        }
      } else
#line 10236
      if ((int )RssiThresh > pwdbBeacon) {
#line 10237
        bcnRssiState = 2U;
#line 10238
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 134217728ULL;
#line 10239
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
#line 10240
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffefffffffULL;
#line 10241
        if (BTCoexDbgLevel == 1U) {
#line 10241
          printk("[DM][BT], RSSI_BEACON state switch to Low\n");
        } else {

        }
      } else {
#line 10243
        bcnRssiState = 4U;
#line 10244
        if (BTCoexDbgLevel == 1U) {
#line 10244
          printk("[DM][BT], RSSI_BEACON state stay at Medium\n");
        } else {

        }
      }
    } else
#line 10247
    if ((int )RssiThresh1 > pwdbBeacon) {
#line 10248
      bcnRssiState = 1U;
#line 10249
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 268435456ULL;
#line 10250
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
#line 10251
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
#line 10252
      if (BTCoexDbgLevel == 1U) {
#line 10252
        printk("[DM][BT], RSSI_BEACON state switch to Medium\n");
      } else {

      }
    } else {
#line 10254
      bcnRssiState = 3U;
#line 10255
      if (BTCoexDbgLevel == 1U) {
#line 10255
        printk("[DM][BT], RSSI_BEACON state stay at High\n");
      } else {

      }
    }
  } else {

  }
#line 10260
  pHalData->bt_coexist.preRssiStateBeacon = bcnRssiState;
#line 10262
  return (bcnRssiState);
}
}
#line 10265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_CheckCoexRSSIState1(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                            u8 RssiThresh1 ) 
{ 
  struct hal_data_8723a *pHalData ;
  s32 UndecoratedSmoothedPWDB ;
  u8 btRssiState ;

  {
#line 10268
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10269
  UndecoratedSmoothedPWDB = 0;
#line 10270
  btRssiState = 0U;
#line 10272
  UndecoratedSmoothedPWDB = BTDM_GetRxSS(padapter);
#line 10274
  if ((unsigned int )levelNum == 2U) {
#line 10275
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffdffffffULL;
#line 10277
    if ((unsigned int )pHalData->bt_coexist.preRssiState1 == 2U || (unsigned int )pHalData->bt_coexist.preRssiState1 == 5U) {
#line 10279
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
#line 10280
        btRssiState = 0U;
#line 10281
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 67108864ULL;
#line 10282
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
#line 10283
        if (BTCoexDbgLevel == 1U) {
#line 10283
          printk("[DM][BT], RSSI_1 state switch to High\n");
        } else {

        }
      } else {
#line 10285
        btRssiState = 5U;
#line 10286
        if (BTCoexDbgLevel == 1U) {
#line 10286
          printk("[DM][BT], RSSI_1 state stay at Low\n");
        } else {

        }
      }
    } else
#line 10289
    if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
#line 10290
      btRssiState = 2U;
#line 10291
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16777216ULL;
#line 10292
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
#line 10293
      if (BTCoexDbgLevel == 1U) {
#line 10293
        printk("[DM][BT], RSSI_1 state switch to Low\n");
      } else {

      }
    } else {
#line 10295
      btRssiState = 3U;
#line 10296
      if (BTCoexDbgLevel == 1U) {
#line 10296
        printk("[DM][BT], RSSI_1 state stay at High\n");
      } else {

      }
    }
  } else
#line 10299
  if ((unsigned int )levelNum == 3U) {
#line 10300
    if ((int )RssiThresh > (int )RssiThresh1) {
#line 10301
      if (BTCoexDbgLevel == 1U) {
#line 10301
        printk("[DM][BT], RSSI_1 thresh error!!\n");
      } else {

      }
#line 10302
      return (pHalData->bt_coexist.preRssiState1);
    } else {

    }
#line 10305
    if ((unsigned int )pHalData->bt_coexist.preRssiState1 == 2U || (unsigned int )pHalData->bt_coexist.preRssiState1 == 5U) {
#line 10307
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
#line 10308
        btRssiState = 1U;
#line 10309
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 33554432ULL;
#line 10310
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
#line 10311
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
#line 10312
        if (BTCoexDbgLevel == 1U) {
#line 10312
          printk("[DM][BT], RSSI_1 state switch to Medium\n");
        } else {

        }
      } else {
#line 10314
        btRssiState = 5U;
#line 10315
        if (BTCoexDbgLevel == 1U) {
#line 10315
          printk("[DM][BT], RSSI_1 state stay at Low\n");
        } else {

        }
      }
    } else
#line 10317
    if ((unsigned int )pHalData->bt_coexist.preRssiState1 == 1U || (unsigned int )pHalData->bt_coexist.preRssiState1 == 4U) {
#line 10319
      if ((int )RssiThresh1 + 6 <= UndecoratedSmoothedPWDB) {
#line 10320
        btRssiState = 0U;
#line 10321
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 67108864ULL;
#line 10322
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
#line 10323
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffdffffffULL;
#line 10324
        if (BTCoexDbgLevel == 1U) {
#line 10324
          printk("[DM][BT], RSSI_1 state switch to High\n");
        } else {

        }
      } else
#line 10325
      if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
#line 10326
        btRssiState = 2U;
#line 10327
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16777216ULL;
#line 10328
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
#line 10329
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffdffffffULL;
#line 10330
        if (BTCoexDbgLevel == 1U) {
#line 10330
          printk("[DM][BT], RSSI_1 state switch to Low\n");
        } else {

        }
      } else {
#line 10332
        btRssiState = 4U;
#line 10333
        if (BTCoexDbgLevel == 1U) {
#line 10333
          printk("[DM][BT], RSSI_1 state stay at Medium\n");
        } else {

        }
      }
    } else
#line 10336
    if ((int )RssiThresh1 > UndecoratedSmoothedPWDB) {
#line 10337
      btRssiState = 1U;
#line 10338
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 33554432ULL;
#line 10339
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
#line 10340
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
#line 10341
      if (BTCoexDbgLevel == 1U) {
#line 10341
        printk("[DM][BT], RSSI_1 state switch to Medium\n");
      } else {

      }
    } else {
#line 10343
      btRssiState = 3U;
#line 10344
      if (BTCoexDbgLevel == 1U) {
#line 10344
        printk("[DM][BT], RSSI_1 state stay at High\n");
      } else {

      }
    }
  } else {

  }
#line 10349
  pHalData->bt_coexist.preRssiState1 = btRssiState;
#line 10351
  return (btRssiState);
}
}
#line 10354 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_CheckCoexRSSIState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                           u8 RssiThresh1 ) 
{ 
  struct hal_data_8723a *pHalData ;
  s32 UndecoratedSmoothedPWDB ;
  u8 btRssiState ;

  {
#line 10357
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10358
  UndecoratedSmoothedPWDB = 0;
#line 10359
  btRssiState = 0U;
#line 10361
  UndecoratedSmoothedPWDB = BTDM_GetRxSS(padapter);
#line 10363
  if ((unsigned int )levelNum == 2U) {
#line 10364
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffdfULL;
#line 10366
    if ((unsigned int )pHalData->bt_coexist.preRssiState == 2U || (unsigned int )pHalData->bt_coexist.preRssiState == 5U) {
#line 10368
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
#line 10369
        btRssiState = 0U;
#line 10370
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 64ULL;
#line 10371
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
#line 10372
        if (BTCoexDbgLevel == 1U) {
#line 10372
          printk("[DM][BT], RSSI state switch to High\n");
        } else {

        }
      } else {
#line 10374
        btRssiState = 5U;
#line 10375
        if (BTCoexDbgLevel == 1U) {
#line 10375
          printk("[DM][BT], RSSI state stay at Low\n");
        } else {

        }
      }
    } else
#line 10378
    if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
#line 10379
      btRssiState = 2U;
#line 10380
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16ULL;
#line 10381
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
#line 10382
      if (BTCoexDbgLevel == 1U) {
#line 10382
        printk("[DM][BT], RSSI state switch to Low\n");
      } else {

      }
    } else {
#line 10384
      btRssiState = 3U;
#line 10385
      if (BTCoexDbgLevel == 1U) {
#line 10385
        printk("[DM][BT], RSSI state stay at High\n");
      } else {

      }
    }
  } else
#line 10388
  if ((unsigned int )levelNum == 3U) {
#line 10389
    if ((int )RssiThresh > (int )RssiThresh1) {
#line 10390
      if (BTCoexDbgLevel == 1U) {
#line 10390
        printk("[DM][BT], RSSI thresh error!!\n");
      } else {

      }
#line 10391
      return (pHalData->bt_coexist.preRssiState);
    } else {

    }
#line 10394
    if ((unsigned int )pHalData->bt_coexist.preRssiState == 2U || (unsigned int )pHalData->bt_coexist.preRssiState == 5U) {
#line 10396
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
#line 10397
        btRssiState = 1U;
#line 10398
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 32ULL;
#line 10399
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
#line 10400
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
#line 10401
        if (BTCoexDbgLevel == 1U) {
#line 10401
          printk("[DM][BT], RSSI state switch to Medium\n");
        } else {

        }
      } else {
#line 10403
        btRssiState = 5U;
#line 10404
        if (BTCoexDbgLevel == 1U) {
#line 10404
          printk("[DM][BT], RSSI state stay at Low\n");
        } else {

        }
      }
    } else
#line 10406
    if ((unsigned int )pHalData->bt_coexist.preRssiState == 1U || (unsigned int )pHalData->bt_coexist.preRssiState == 4U) {
#line 10408
      if ((int )RssiThresh1 + 6 <= UndecoratedSmoothedPWDB) {
#line 10409
        btRssiState = 0U;
#line 10410
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 64ULL;
#line 10411
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
#line 10412
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffdfULL;
#line 10413
        if (BTCoexDbgLevel == 1U) {
#line 10413
          printk("[DM][BT], RSSI state switch to High\n");
        } else {

        }
      } else
#line 10414
      if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
#line 10415
        btRssiState = 2U;
#line 10416
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16ULL;
#line 10417
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
#line 10418
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffdfULL;
#line 10419
        if (BTCoexDbgLevel == 1U) {
#line 10419
          printk("[DM][BT], RSSI state switch to Low\n");
        } else {

        }
      } else {
#line 10421
        btRssiState = 4U;
#line 10422
        if (BTCoexDbgLevel == 1U) {
#line 10422
          printk("[DM][BT], RSSI state stay at Medium\n");
        } else {

        }
      }
    } else
#line 10425
    if ((int )RssiThresh1 > UndecoratedSmoothedPWDB) {
#line 10426
      btRssiState = 1U;
#line 10427
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 32ULL;
#line 10428
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
#line 10429
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
#line 10430
      if (BTCoexDbgLevel == 1U) {
#line 10430
        printk("[DM][BT], RSSI state switch to Medium\n");
      } else {

      }
    } else {
#line 10432
      btRssiState = 3U;
#line 10433
      if (BTCoexDbgLevel == 1U) {
#line 10433
        printk("[DM][BT], RSSI state stay at High\n");
      } else {

      }
    }
  } else {

  }
#line 10438
  pHalData->bt_coexist.preRssiState = btRssiState;
#line 10440
  return (btRssiState);
}
}
#line 10443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
bool rtl8723a_BT_disable_EDCA_turbo(struct rtw_adapter *padapter ) 
{ 
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  u8 bBtChangeEDCA ;
  u32 EDCA_BT_BE ;
  u32 cur_EDCA_reg ;
  bool bRet ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 10447
  bBtChangeEDCA = 0U;
#line 10448
  EDCA_BT_BE = 6202411U;
#line 10449
  bRet = 0;
#line 10451
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10452
  pBtMgnt = & pHalData->BtInfo.BtMgnt;
#line 10454
  tmp = rtl8723a_BT_coexist(padapter);
#line 10454
  if (tmp) {
#line 10454
    tmp___0 = 0;
  } else {
#line 10454
    tmp___0 = 1;
  }
#line 10454
  if (tmp___0) {
#line 10455
    bRet = 0;
#line 10456
    pHalData->bt_coexist.lastBtEdca = 0U;
#line 10457
    return (bRet);
  } else {

  }
#line 10459
  if ((unsigned int )pBtMgnt->bSupportProfile == 0U && (unsigned int )pHalData->bt_coexist.BT_CoexistType != 4U) {
#line 10461
    bRet = 0;
#line 10462
    pHalData->bt_coexist.lastBtEdca = 0U;
#line 10463
    return (bRet);
  } else {

  }
#line 10466
  tmp___1 = rtl8723a_BT_using_antenna_1(padapter);
#line 10466
  if ((int )tmp___1) {
#line 10467
    bRet = 0;
#line 10468
    pHalData->bt_coexist.lastBtEdca = 0U;
#line 10469
    return (bRet);
  } else {

  }
#line 10472
  if ((unsigned int )pHalData->bt_coexist.exec_cnt <= 2U) {
#line 10473
    pHalData->bt_coexist.exec_cnt = (u8 )((int )pHalData->bt_coexist.exec_cnt + 1);
  } else {
#line 10475
    pHalData->bt_coexist.bEDCAInitialized = 1U;
  }
#line 10478
  if ((pHalData->bt_coexist.CurrentState & 4096ULL) == 0ULL) {
#line 10479
    if (BTCoexDbgLevel == 1U) {
#line 10479
      printk("BT state non idle, set bt EDCA\n");
    } else {

    }
#line 10482
    if ((int )pHalData->odmpriv.DM_EDCA_Table.bCurrentTurboEDCA) {
#line 10483
      bBtChangeEDCA = 1U;
#line 10484
      pHalData->odmpriv.DM_EDCA_Table.bCurrentTurboEDCA = 0;
#line 10485
      pHalData->dmpriv.prv_traffic_idx = 3U;
    } else {

    }
#line 10487
    cur_EDCA_reg = rtl8723au_read32(padapter, 1288);
#line 10489
    if (cur_EDCA_reg != EDCA_BT_BE) {
#line 10490
      bBtChangeEDCA = 1U;
    } else {

    }
#line 10491
    if ((unsigned int )bBtChangeEDCA != 0U || (unsigned int )pHalData->bt_coexist.bEDCAInitialized == 0U) {
#line 10492
      rtl8723au_write32(padapter, 1288, EDCA_BT_BE);
#line 10494
      pHalData->bt_coexist.lastBtEdca = EDCA_BT_BE;
    } else {

    }
#line 10496
    bRet = 1;
  } else {
#line 10498
    if (BTCoexDbgLevel == 1U) {
#line 10498
      printk("BT state idle, set original EDCA\n");
    } else {

    }
#line 10499
    pHalData->bt_coexist.lastBtEdca = 0U;
#line 10500
    bRet = 0;
  }
#line 10502
  return (bRet);
}
}
#line 10506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_Balance(struct rtw_adapter *padapter , u8 bBalanceOn , u8 ms0 , u8 ms1 ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;

  {
#line 10513
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10514
  H2C_Parameter[0] = 0U;
#line 10514
  tmp = 1U;
#line 10514
  while (1) {
#line 10514
    if (tmp >= 3U) {
#line 10514
      break;
    } else {

    }
#line 10514
    H2C_Parameter[tmp] = (unsigned char)0;
#line 10514
    tmp = tmp + 1U;
  }
#line 10516
  if ((unsigned int )bBalanceOn != 0U) {
#line 10517
    H2C_Parameter[2] = 1U;
#line 10518
    H2C_Parameter[1] = ms1;
#line 10519
    H2C_Parameter[0] = ms0;
#line 10520
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {
#line 10522
    H2C_Parameter[2] = 0U;
#line 10523
    H2C_Parameter[1] = 0U;
#line 10524
    H2C_Parameter[0] = 0U;
  }
#line 10526
  pHalData->bt_coexist.bBalanceOn = bBalanceOn;
#line 10528
  if (BTCoexDbgLevel == 1U) {
#line 10528
    printk("[DM][BT], Balance =[%s:%dms:%dms], write 0xc = 0x%x\n", (unsigned int )bBalanceOn != 0U ? (char *)"ON" : (char *)"OFF",
           (int )ms0, (int )ms1, (((int )H2C_Parameter[0] << 16) | ((int )H2C_Parameter[1] << 8)) | (int )H2C_Parameter[2]);
  } else {

  }
#line 10532
  FillH2CCmd(padapter, 12, 3U, (u8 *)(& H2C_Parameter));
#line 10533
  return;
}
}
#line 10535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_AGCTable(struct rtw_adapter *padapter , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10537
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10538
  if ((unsigned int )type == 0U) {
#line 10539
    if (BTCoexDbgLevel == 1U) {
#line 10539
      printk("[BT]AGCTable Off!\n");
    } else {

    }
#line 10540
    rtl8723au_write32(padapter, 3192, 1679556609U);
#line 10541
    rtl8723au_write32(padapter, 3192, 1662844929U);
#line 10542
    rtl8723au_write32(padapter, 3192, 1646133249U);
#line 10543
    rtl8723au_write32(padapter, 3192, 1629421569U);
#line 10544
    rtl8723au_write32(padapter, 3192, 1612709889U);
#line 10546
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 204800U);
#line 10547
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 462848U);
#line 10548
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 720896U);
#line 10549
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 1032192U);
#line 10550
    PHY_SetRFReg(padapter, 0, 26U, 1048575U, 197461U);
#line 10552
    pHalData->bt_coexist.b8723aAgcTableOn = 0U;
  } else
#line 10553
  if ((unsigned int )type == 1U) {
#line 10554
    if (BTCoexDbgLevel == 1U) {
#line 10554
      printk("[BT]AGCTable On!\n");
    } else {

    }
#line 10555
    rtl8723au_write32(padapter, 3192, 1310457857U);
#line 10556
    rtl8723au_write32(padapter, 3192, 1293746177U);
#line 10557
    rtl8723au_write32(padapter, 3192, 1277034497U);
#line 10558
    rtl8723au_write32(padapter, 3192, 1260322817U);
#line 10559
    rtl8723au_write32(padapter, 3192, 1243611137U);
#line 10561
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 901120U);
#line 10562
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 589824U);
#line 10563
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 331776U);
#line 10564
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 73728U);
#line 10565
    PHY_SetRFReg(padapter, 0, 26U, 1048575U, 853U);
#line 10567
    pHalData->bt_coexist.b8723aAgcTableOn = 1U;
#line 10569
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else {

  }
#line 10571
  return;
}
}
#line 10573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_BBBackOffLevel(struct rtw_adapter *padapter , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10575
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10577
  if ((unsigned int )type == 0U) {
#line 10578
    if (BTCoexDbgLevel == 1U) {
#line 10578
      printk("[BT]BBBackOffLevel Off!\n");
    } else {

    }
#line 10579
    rtl8723au_write32(padapter, 3076, 60839441U);
  } else
#line 10580
  if ((unsigned int )type == 1U) {
#line 10581
    if (BTCoexDbgLevel == 1U) {
#line 10581
      printk("[BT]BBBackOffLevel On!\n");
    } else {

    }
#line 10582
    rtl8723au_write32(padapter, 3076, 60847633U);
#line 10583
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else {

  }
#line 10585
  return;
}
}
#line 10587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_FWCoexAllOff(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10589
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10591
  if (BTCoexDbgLevel == 1U) {
#line 10591
    printk("BTDM_FWCoexAllOff()\n");
  } else {

  }
#line 10592
  if ((unsigned int )pHalData->bt_coexist.bFWCoexistAllOff != 0U) {
#line 10593
    return;
  } else {

  }
#line 10594
  if (BTCoexDbgLevel == 1U) {
#line 10594
    printk("BTDM_FWCoexAllOff(), real Do\n");
  } else {

  }
#line 10596
  BTDM_FWCoexAllOff8723A(padapter);
#line 10598
  pHalData->bt_coexist.bFWCoexistAllOff = 1U;
#line 10599
  return;
}
}
#line 10601 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_SWCoexAllOff(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10603
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10605
  if (BTCoexDbgLevel == 1U) {
#line 10605
    printk("BTDM_SWCoexAllOff()\n");
  } else {

  }
#line 10606
  if ((unsigned int )pHalData->bt_coexist.bSWCoexistAllOff != 0U) {
#line 10607
    return;
  } else {

  }
#line 10608
  if (BTCoexDbgLevel == 1U) {
#line 10608
    printk("BTDM_SWCoexAllOff(), real Do\n");
  } else {

  }
#line 10609
  BTDM_SWCoexAllOff8723A(padapter);
#line 10611
  pHalData->bt_coexist.bSWCoexistAllOff = 1U;
#line 10612
  return;
}
}
#line 10614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_HWCoexAllOff(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10616
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10618
  if (BTCoexDbgLevel == 1U) {
#line 10618
    printk("BTDM_HWCoexAllOff()\n");
  } else {

  }
#line 10619
  if ((unsigned int )pHalData->bt_coexist.bHWCoexistAllOff != 0U) {
#line 10620
    return;
  } else {

  }
#line 10621
  if (BTCoexDbgLevel == 1U) {
#line 10621
    printk("BTDM_HWCoexAllOff(), real Do\n");
  } else {

  }
#line 10623
  BTDM_HWCoexAllOff8723A(padapter);
#line 10625
  pHalData->bt_coexist.bHWCoexistAllOff = 1U;
#line 10626
  return;
}
}
#line 10628 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_CoexAllOff(struct rtw_adapter *padapter ) 
{ 


  {
#line 10630
  BTDM_FWCoexAllOff(padapter);
#line 10631
  BTDM_SWCoexAllOff(padapter);
#line 10632
  BTDM_HWCoexAllOff(padapter);
#line 10633
  return;
}
}
#line 10635 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void rtl8723a_BT_disable_coexist(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *ppwrctrl ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 10637
  ppwrctrl = & padapter->pwrctrlpriv;
#line 10639
  tmp = rtl8723a_BT_coexist(padapter);
#line 10639
  if (tmp) {
#line 10639
    tmp___0 = 0;
  } else {
#line 10639
    tmp___0 = 1;
  }
#line 10639
  if (tmp___0) {
#line 10640
    return;
  } else {

  }
#line 10643
  tmp___1 = rtl8723a_BT_using_antenna_1(padapter);
#line 10643
  if ((int )tmp___1) {
#line 10644
    return;
  } else {

  }
#line 10647
  if ((unsigned int )ppwrctrl->reg_rfoff == 0U) {
#line 10648
    if (BTCoexDbgLevel == 1U) {
#line 10648
      printk("[BT][DM], Before enter IPS, turn off all Coexist DM\n");
    } else {

    }
#line 10649
    btdm_ResetFWCoexState(padapter);
#line 10650
    BTDM_CoexAllOff(padapter);
#line 10651
    BTDM_SetAntenna(padapter, 2);
  } else {

  }
#line 10653
  return;
}
}
#line 10655 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) 
{ 


  {
#line 10657
  BTDM_8723ASignalCompensation(padapter, rssi_wifi, rssi_bt);
#line 10658
  return;
}
}
#line 10660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void rtl8723a_BT_do_coexist(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  bool tmp ;
  int tmp___0 ;

  {
#line 10662
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10664
  tmp = rtl8723a_BT_coexist(padapter);
#line 10664
  if (tmp) {
#line 10664
    tmp___0 = 0;
  } else {
#line 10664
    tmp___0 = 1;
  }
#line 10664
  if (tmp___0) {
#line 10665
    if (BTCoexDbgLevel == 1U) {
#line 10665
      printk("[DM][BT], BT not exists!!\n");
    } else {

    }
#line 10666
    return;
  } else {

  }
#line 10669
  if ((unsigned int )pHalData->bt_coexist.bInitlized == 0U) {
#line 10670
    if (BTCoexDbgLevel == 1U) {
#line 10670
      printk("[DM][BT], btdm_InitBtCoexistDM()\n");
    } else {

    }
#line 10671
    btdm_InitBtCoexistDM(padapter);
  } else {

  }
#line 10674
  if (BTCoexDbgLevel == 1U) {
#line 10674
    printk("\n\n[DM][BT], BTDM start!!\n");
  } else {

  }
#line 10676
  BTDM_PWDBMonitor(padapter);
#line 10678
  if (BTCoexDbgLevel == 1U) {
#line 10678
    printk("[DM][BT], HW type is 8723\n");
  } else {

  }
#line 10679
  BTDM_BTCoexist8723A(padapter);
#line 10680
  if (BTCoexDbgLevel == 1U) {
#line 10680
    printk("[DM][BT], BTDM end!!\n\n");
  } else {

  }
#line 10681
  return;
}
}
#line 10683 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_UpdateCoexState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tmp ;

  {
#line 10685
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10687
  tmp = BTDM_IsSameCoexistState(padapter);
#line 10687
  if ((unsigned int )tmp == 0U) {
#line 10688
    if (BTCoexDbgLevel == 1U) {
#line 10688
      printk("[BTCoex], Coexist State[bitMap] change from 0x%llx to 0x%llx,  changeBits = 0x%llx\n",
             pHalData->bt_coexist.PreviousState, pHalData->bt_coexist.CurrentState,
             pHalData->bt_coexist.PreviousState ^ pHalData->bt_coexist.CurrentState);
    } else {

    }
#line 10692
    pHalData->bt_coexist.PreviousState = pHalData->bt_coexist.CurrentState;
  } else {

  }
#line 10694
  return;
}
}
#line 10696 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsSameCoexistState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10698
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10700
  if (pHalData->bt_coexist.PreviousState == pHalData->bt_coexist.CurrentState) {
#line 10701
    return (1U);
  } else {
#line 10703
    if (BTCoexDbgLevel == 1U) {
#line 10703
      printk("[DM][BT], Coexist state changed!!\n");
    } else {

    }
#line 10704
    return (0U);
  }
}
}
#line 10708 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_PWDBMonitor(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;
  s32 tmpBTEntryMaxPWDB ;
  s32 tmpBTEntryMinPWDB ;
  u8 i ;
  u32 __i ;
  u8 *ptr ;

  {
#line 10710
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 10711
  pBtMgnt = & pBTInfo->BtMgnt;
#line 10712
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10713
  H2C_Parameter[0] = 0U;
#line 10713
  tmp = 1U;
#line 10713
  while (1) {
#line 10713
    if (tmp >= 3U) {
#line 10713
      break;
    } else {

    }
#line 10713
    H2C_Parameter[tmp] = (unsigned char)0;
#line 10713
    tmp = tmp + 1U;
  }
#line 10714
  tmpBTEntryMaxPWDB = 0;
#line 10714
  tmpBTEntryMinPWDB = 255;
#line 10717
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
#line 10718
    i = 0U;
#line 10718
    goto ldv_58302;
    ldv_58301: ;
#line 10719
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed != 0U) {
#line 10720
      if (pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB < tmpBTEntryMinPWDB) {
#line 10721
        tmpBTEntryMinPWDB = pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB;
      } else {

      }
#line 10722
      if (pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB > tmpBTEntryMaxPWDB) {
#line 10723
        tmpBTEntryMaxPWDB = pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB;
      } else {

      }
#line 10725
      H2C_Parameter[2] = (unsigned char )pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB;
#line 10726
      H2C_Parameter[0] = 63U - (unsigned int )i;
#line 10727
      if (BTCoexDbgLevel == 1U) {
#line 10727
        printk("RSSI report for BT[%d], H2C_Par = 0x%x\n", (int )i, (int )H2C_Parameter[0]);
      } else {

      }
#line 10728
      FillH2CCmd(padapter, 5, 3U, (u8 *)(& H2C_Parameter));
#line 10729
      if (BTCoexDbgLevel == 1U) {
#line 10729
        ptr = (u8 *)(& pBTInfo->BtAsocEntry[(int )i].BTRemoteMACAddr);
#line 10729
        printk("BT_Entry Mac :");
#line 10729
        printk(" ");
#line 10729
        __i = 0U;
#line 10729
        goto ldv_58299;
        ldv_58298: 
#line 10729
        printk("%02X%s", (int )*(ptr + (unsigned long )__i), __i == 5U ? (char *)"" : (char *)"-");
#line 10729
        __i = __i + 1U;
        ldv_58299: ;
#line 10729
        if (__i <= 5U) {
#line 10731
          goto ldv_58298;
        } else {

        }
#line 10729
        printk("\n");
      } else {

      }
#line 10731
      if (BTCoexDbgLevel == 1U) {
#line 10731
        printk("BT rx pwdb[%d] = 0x%x(%d)\n", (int )i, pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB,
               pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB);
      } else {

      }
    } else {

    }
#line 10718
    i = (u8 )((int )i + 1);
    ldv_58302: ;
#line 10718
    if ((unsigned int )i <= 1U) {
#line 10720
      goto ldv_58301;
    } else {

    }

#line 10737
    if (tmpBTEntryMaxPWDB != 0) {
#line 10738
      pHalData->dmpriv.BT_EntryMaxUndecoratedSmoothedPWDB = tmpBTEntryMaxPWDB;
#line 10739
      if (BTCoexDbgLevel == 1U) {
#line 10739
        printk("BT_EntryMaxPWDB = 0x%x(%d)\n", tmpBTEntryMaxPWDB, tmpBTEntryMaxPWDB);
      } else {

      }
    } else {
#line 10742
      pHalData->dmpriv.BT_EntryMaxUndecoratedSmoothedPWDB = 0;
    }
#line 10744
    if (tmpBTEntryMinPWDB != 255) {
#line 10745
      pHalData->dmpriv.BT_EntryMinUndecoratedSmoothedPWDB = tmpBTEntryMinPWDB;
#line 10746
      if (BTCoexDbgLevel == 1U) {
#line 10746
        printk("BT_EntryMinPWDB = 0x%x(%d)\n", tmpBTEntryMinPWDB, tmpBTEntryMinPWDB);
      } else {

      }
    } else {
#line 10749
      pHalData->dmpriv.BT_EntryMinUndecoratedSmoothedPWDB = 0;
    }
  } else {

  }
#line 10751
  return;
}
}
#line 10754 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsBTBusy(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 10756
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 10757
  pBtMgnt = & pBTInfo->BtMgnt;
#line 10759
  if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy != 0U) {
#line 10760
    return (1U);
  } else {
#line 10762
    return (0U);
  }
}
}
#line 10765 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsWifiBusy(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_traffic *pBtTraffic ;

  {
#line 10768
  pmlmepriv = & padapter->mlmepriv;
#line 10769
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 10770
  pBtTraffic = & pBTInfo->BtTraffic;
#line 10772
  if (((int )pmlmepriv->LinkDetectInfo.bBusyTraffic || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bTxBusyTraffic != 0U) || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bRxBusyTraffic != 0U) {
#line 10775
    return (1U);
  } else {
#line 10777
    return (0U);
  }
}
}
#line 10780 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsCoexistStateChanged(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10782
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10784
  if (pHalData->bt_coexist.PreviousState == pHalData->bt_coexist.CurrentState) {
#line 10785
    return (0U);
  } else {
#line 10787
    return (1U);
  }
}
}
#line 10790 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsWifiUplink(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_traffic *pBtTraffic ;

  {
#line 10797
  pmlmepriv = & padapter->mlmepriv;
#line 10798
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 10799
  pBtTraffic = & pBTInfo->BtTraffic;
#line 10801
  if ((int )pmlmepriv->LinkDetectInfo.bTxBusyTraffic || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bTxBusyTraffic != 0U) {
#line 10803
    return (1U);
  } else {
#line 10805
    return (0U);
  }
}
}
#line 10808 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsWifiDownlink(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_traffic *pBtTraffic ;

  {
#line 10815
  pmlmepriv = & padapter->mlmepriv;
#line 10816
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 10817
  pBtTraffic = & pBTInfo->BtTraffic;
#line 10819
  if ((int )pmlmepriv->LinkDetectInfo.bRxBusyTraffic || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bRxBusyTraffic != 0U) {
#line 10821
    return (1U);
  } else {
#line 10823
    return (0U);
  }
}
}
#line 10826 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsBTHSMode(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 10832
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10833
  pBtMgnt = & pHalData->BtInfo.BtMgnt;
#line 10835
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
#line 10836
    return (1U);
  } else {
#line 10838
    return (0U);
  }
}
}
#line 10841 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsBTUplink(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10843
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10845
  if ((unsigned int )pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic != 0U) {
#line 10846
    return (1U);
  } else {
#line 10848
    return (0U);
  }
}
}
#line 10851 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsBTDownlink(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10853
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10855
  if ((unsigned int )pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic != 0U) {
#line 10856
    return (1U);
  } else {
#line 10858
    return (0U);
  }
}
}
#line 10861 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_AdjustForBtOperation(struct rtw_adapter *padapter ) 
{ 


  {
#line 10863
  if (BTCoexDbgLevel == 1U) {
#line 10863
    printk("[BT][DM], BTDM_AdjustForBtOperation()\n");
  } else {

  }
#line 10864
  BTDM_AdjustForBtOperation8723A(padapter);
#line 10865
  return;
}
}
#line 10867 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_SetBtCoexCurrAntNum(struct rtw_adapter *padapter , u8 antNum ) 
{ 


  {
#line 10869
  BTDM_Set8723ABtCoexCurrAntNum(padapter, (int )antNum);
#line 10870
  return;
}
}
#line 10872 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_ForHalt(struct rtw_adapter *padapter ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 10874
  tmp = rtl8723a_BT_coexist(padapter);
#line 10874
  if (tmp) {
#line 10874
    tmp___0 = 0;
  } else {
#line 10874
    tmp___0 = 1;
  }
#line 10874
  if (tmp___0) {
#line 10875
    return;
  } else {

  }
#line 10877
  BTDM_ForHalt8723A(padapter);
#line 10878
  ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.bInitlized = 0U;
#line 10879
  return;
}
}
#line 10881 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 10883
  tmp = rtl8723a_BT_coexist(padapter);
#line 10883
  if (tmp) {
#line 10883
    tmp___0 = 0;
  } else {
#line 10883
    tmp___0 = 1;
  }
#line 10883
  if (tmp___0) {
#line 10884
    return;
  } else {

  }
#line 10886
  BTDM_WifiScanNotify8723A(padapter, (int )scanType);
#line 10887
  return;
}
}
#line 10889 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_WifiAssociateNotify(struct rtw_adapter *padapter , u8 action ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 10891
  tmp = rtl8723a_BT_coexist(padapter);
#line 10891
  if (tmp) {
#line 10891
    tmp___0 = 0;
  } else {
#line 10891
    tmp___0 = 1;
  }
#line 10891
  if (tmp___0) {
#line 10892
    return;
  } else {

  }
#line 10894
  BTDM_WifiAssociateNotify8723A(padapter, (int )action);
#line 10895
  return;
}
}
#line 10897 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void rtl8723a_BT_mediastatus_notify(struct rtw_adapter *padapter , enum rt_media_status mstatus ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 10900
  tmp = rtl8723a_BT_coexist(padapter);
#line 10900
  if (tmp) {
#line 10900
    tmp___0 = 0;
  } else {
#line 10900
    tmp___0 = 1;
  }
#line 10900
  if (tmp___0) {
#line 10901
    return;
  } else {

  }
#line 10903
  BTDM_MediaStatusNotify8723A(padapter, mstatus);
#line 10904
  return;
}
}
#line 10906 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void rtl8723a_BT_specialpacket_notify(struct rtw_adapter *padapter ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 10908
  tmp = rtl8723a_BT_coexist(padapter);
#line 10908
  if (tmp) {
#line 10908
    tmp___0 = 0;
  } else {
#line 10908
    tmp___0 = 1;
  }
#line 10908
  if (tmp___0) {
#line 10909
    return;
  } else {

  }
#line 10911
  BTDM_ForDhcp8723A(padapter);
#line 10912
  return;
}
}
#line 10914 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void BTDM_ResetActionProfileState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10916
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10918
  pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffff0fffffULL;
#line 10919
  return;
}
}
#line 10923 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsActionSCO(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;

  {
#line 10931
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10932
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 10933
  pBtMgnt = & pBTInfo->BtMgnt;
#line 10934
  pBtDbg = & pBTInfo->BtDbg;
#line 10935
  bRet = 0U;
#line 10937
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 10938
    if (pBtDbg->dbgProfile == 1U) {
#line 10939
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 8388608ULL;
#line 10940
      bRet = 1U;
    } else {

    }
  } else
#line 10943
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfSCO != 0U) {
#line 10944
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 8388608ULL;
#line 10945
    bRet = 1U;
  } else {

  }
#line 10948
  return (bRet);
}
}
#line 10951 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsActionHID(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct hal_data_8723a *pHalData ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;

  {
#line 10959
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10960
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 10961
  pBtMgnt = & pBTInfo->BtMgnt;
#line 10962
  pBtDbg = & pBTInfo->BtDbg;
#line 10963
  bRet = 0U;
#line 10965
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 10966
    if (pBtDbg->dbgProfile == 2U) {
#line 10967
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1048576ULL;
#line 10968
      bRet = 1U;
    } else {

    }
  } else {
#line 10971
    tmp = BTHCI_CheckProfileExist(padapter, 3);
#line 10971
    if ((unsigned int )tmp != 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
#line 10973
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1048576ULL;
#line 10974
      bRet = 1U;
    } else {

    }
  }
#line 10977
  return (bRet);
}
}
#line 10980 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsActionA2DP(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;

  {
#line 10988
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10989
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 10990
  pBtMgnt = & pBTInfo->BtMgnt;
#line 10991
  pBtDbg = & pBTInfo->BtDbg;
#line 10992
  bRet = 0U;
#line 10994
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 10995
    if (pBtDbg->dbgProfile == 3U) {
#line 10996
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 2097152ULL;
#line 10997
      bRet = 1U;
    } else {

    }
  } else {
#line 11000
    tmp = BTHCI_CheckProfileExist(padapter, 1);
#line 11000
    if ((unsigned int )tmp != 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
#line 11002
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 2097152ULL;
#line 11003
      bRet = 1U;
    } else {

    }
  }
#line 11006
  return (bRet);
}
}
#line 11009 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsActionPAN(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;

  {
#line 11017
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11018
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11019
  pBtMgnt = & pBTInfo->BtMgnt;
#line 11020
  pBtDbg = & pBTInfo->BtDbg;
#line 11021
  bRet = 0U;
#line 11023
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 11024
    if (pBtDbg->dbgProfile == 4U) {
#line 11025
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4194304ULL;
#line 11026
      bRet = 1U;
    } else {

    }
  } else {
#line 11029
    tmp = BTHCI_CheckProfileExist(padapter, 2);
#line 11029
    if ((unsigned int )tmp != 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
#line 11031
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4194304ULL;
#line 11032
      bRet = 1U;
    } else {

    }
  }
#line 11035
  return (bRet);
}
}
#line 11038 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsActionHIDA2DP(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 11046
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11047
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11048
  pBtMgnt = & pBTInfo->BtMgnt;
#line 11049
  pBtDbg = & pBTInfo->BtDbg;
#line 11050
  bRet = 0U;
#line 11052
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 11053
    if (pBtDbg->dbgProfile == 5U) {
#line 11054
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 3145728ULL;
#line 11055
      bRet = 1U;
    } else {

    }
  } else {
#line 11058
    tmp = BTHCI_CheckProfileExist(padapter, 3);
#line 11058
    if ((unsigned int )tmp != 0U) {
#line 11058
      tmp___0 = BTHCI_CheckProfileExist(padapter, 1);
#line 11058
      if ((unsigned int )tmp___0 != 0U) {
#line 11060
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 3145728ULL;
#line 11061
        bRet = 1U;
      } else {

      }
    } else {

    }
  }
#line 11064
  return (bRet);
}
}
#line 11067 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsActionHIDPAN(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 11074
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11075
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11076
  pBtDbg = & pBTInfo->BtDbg;
#line 11077
  bRet = 0U;
#line 11079
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 11080
    if (pBtDbg->dbgProfile == 6U) {
#line 11081
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 5242880ULL;
#line 11082
      bRet = 1U;
    } else {

    }
  } else {
#line 11085
    tmp = BTHCI_CheckProfileExist(padapter, 3);
#line 11085
    if ((unsigned int )tmp != 0U) {
#line 11085
      tmp___0 = BTHCI_CheckProfileExist(padapter, 2);
#line 11085
      if ((unsigned int )tmp___0 != 0U) {
#line 11087
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 5242880ULL;
#line 11088
        bRet = 1U;
      } else {

      }
    } else {

    }
  }
#line 11091
  return (bRet);
}
}
#line 11094 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 BTDM_IsActionPANA2DP(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 11101
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11102
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11103
  pBtDbg = & pBTInfo->BtDbg;
#line 11104
  bRet = 0U;
#line 11106
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 11107
    if (pBtDbg->dbgProfile == 7U) {
#line 11108
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 6291456ULL;
#line 11109
      bRet = 1U;
    } else {

    }
  } else {
#line 11112
    tmp = BTHCI_CheckProfileExist(padapter, 2);
#line 11112
    if ((unsigned int )tmp != 0U) {
#line 11112
      tmp___0 = BTHCI_CheckProfileExist(padapter, 1);
#line 11112
      if ((unsigned int )tmp___0 != 0U) {
#line 11113
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 6291456ULL;
#line 11114
        bRet = 1U;
      } else {

      }
    } else {

    }
  }
#line 11117
  return (bRet);
}
}
#line 11120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
bool rtl8723a_BT_enabled(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 11122
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11124
  if ((unsigned int )pHalData->bt_coexist.bCurBtDisabled != 0U) {
#line 11125
    return (0);
  } else {
#line 11127
    return (1);
  }
}
}
#line 11138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
static void halbt_InitHwConfig8723A(struct rtw_adapter *padapter ) 
{ 


  {
#line 11140
  return;
}
}
#line 11145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 HALBT_GetPGAntNum(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 11147
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11149
  return (pHalData->bt_coexist.BT_Ant_Num);
}
}
#line 11152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void HALBT_SetKey(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTinfo ;
  struct bt_asoc_entry *pBtAssocEntry ;
  u16 usConfig ;

  {
#line 11156
  usConfig = 0U;
#line 11158
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11159
  pBtAssocEntry = (struct bt_asoc_entry *)(& pBTinfo->BtAsocEntry) + (unsigned long )EntryNum;
#line 11161
  pBtAssocEntry->HwCAMIndex = (unsigned int )EntryNum + 12U;
#line 11163
  usConfig = 32784U;
#line 11164
  rtl8723a_cam_write(padapter, (int )pBtAssocEntry->HwCAMIndex, (int )usConfig, (u8 const   *)(& pBtAssocEntry->BTRemoteMACAddr),
                     (u8 const   *)(& pBtAssocEntry->PTK) + 32U);
#line 11167
  return;
}
}
#line 11169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void HALBT_RemoveKey(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTinfo ;
  struct bt_asoc_entry *pBtAssocEntry ;

  {
#line 11174
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11175
  pBtAssocEntry = (struct bt_asoc_entry *)(& pBTinfo->BtAsocEntry) + (unsigned long )EntryNum;
#line 11177
  if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].HwCAMIndex != 0U) {
#line 11179
    if ((unsigned int )pBtAssocEntry->HwCAMIndex > 11U && (unsigned int )pBtAssocEntry->HwCAMIndex <= 15U) {
#line 11181
      rtl8723a_cam_empty_entry(padapter, (int )pBtAssocEntry->HwCAMIndex);
    } else {

    }
#line 11183
    pBTinfo->BtAsocEntry[(int )EntryNum].HwCAMIndex = 0U;
  } else {

  }
#line 11185
  return;
}
}
#line 11187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void rtl8723a_BT_init_hal_vars(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 11191
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11193
  pHalData->bt_coexist.BluetoothCoexist = pHalData->EEPROMBluetoothCoexist;
#line 11194
  pHalData->bt_coexist.BT_Ant_Num = pHalData->EEPROMBluetoothAntNum;
#line 11195
  pHalData->bt_coexist.BT_CoexistType = pHalData->EEPROMBluetoothType;
#line 11196
  pHalData->bt_coexist.BT_Ant_isolation = pHalData->EEPROMBluetoothAntIsolation;
#line 11197
  pHalData->bt_coexist.bt_radiosharedtype = pHalData->EEPROMBluetoothRadioShared;
#line 11199
  if (GlobalDebugLevel23A > 6U) {
#line 11199
    tmp = rtl8723a_BT_coexist(padapter);
#line 11199
    rt_trace(16384, 7, "BT Coexistance = 0x%x\n", (int )tmp);
  } else {

  }
#line 11202
  tmp___0 = rtl8723a_BT_coexist(padapter);
#line 11202
  if ((int )tmp___0) {
#line 11203
    if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num == 0U) {
#line 11204
      BTDM_SetBtCoexCurrAntNum(padapter, 2);
#line 11205
      if (GlobalDebugLevel23A > 6U) {
#line 11205
        rt_trace(16384, 7, "BlueTooth BT_Ant_Num = Antx2\n");
      } else {

      }
    } else
#line 11207
    if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num == 1U) {
#line 11208
      BTDM_SetBtCoexCurrAntNum(padapter, 1);
#line 11209
      if (GlobalDebugLevel23A > 6U) {
#line 11209
        rt_trace(16384, 7, "BlueTooth BT_Ant_Num = Antx1\n");
      } else {

      }
    } else {

    }
#line 11212
    pHalData->bt_coexist.bBTBusyTraffic = 0U;
#line 11213
    pHalData->bt_coexist.bBTTrafficModeSet = 0U;
#line 11214
    pHalData->bt_coexist.bBTNonTrafficModeSet = 0U;
#line 11215
    pHalData->bt_coexist.CurrentState = 0ULL;
#line 11216
    pHalData->bt_coexist.PreviousState = 0ULL;
#line 11218
    if (GlobalDebugLevel23A > 6U) {
#line 11218
      rt_trace(16384, 7, "bt_radiosharedType = 0x%x\n", (int )pHalData->bt_coexist.bt_radiosharedtype);
    } else {

    }
  } else {

  }
#line 11220
  return;
}
}
#line 11224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
bool rtl8723a_BT_coexist(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 11226
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11228
  if ((unsigned int )pHalData->bt_coexist.BluetoothCoexist != 0U) {
#line 11229
    return (1);
  } else {
#line 11231
    return (0);
  }
}
}
#line 11234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
u8 HALBT_BTChipType(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 11236
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11238
  return (pHalData->bt_coexist.BT_CoexistType);
}
}
#line 11241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void rtl8723a_BT_init_hwconfig(struct rtw_adapter *padapter ) 
{ 


  {
#line 11243
  halbt_InitHwConfig8723A(padapter);
#line 11244
  rtl8723a_BT_do_coexist(padapter);
#line 11245
  return;
}
}
#line 11247 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void HALBT_SetRtsCtsNoLenLimit(struct rtw_adapter *padapter ) 
{ 


  {
#line 11249
  return;
}
}
#line 11253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.c"
void rtl8723a_dual_antenna_detection(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *pDM_Odm ;
  struct sw_ant_sw *pDM_SWAT_Table ;
  u8 i ;
  u8 btAntNum ;
  u8 tmp ;
  bool tmp___0 ;

  {
#line 11260
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11261
  pDM_Odm = & pHalData->odmpriv;
#line 11262
  pDM_SWAT_Table = & pDM_Odm->DM_SWAT_Table;
#line 11271
  if ((unsigned int )pHalData->bAntennaDetected == 0U) {
#line 11272
    tmp = HALBT_GetPGAntNum(padapter);
#line 11272
    btAntNum = tmp;
#line 11275
    if ((unsigned int )btAntNum == 0U) {
#line 11276
      pDM_SWAT_Table->ANTB_ON = 1;
    } else
#line 11277
    if ((unsigned int )btAntNum == 1U) {
#line 11278
      pDM_SWAT_Table->ANTB_ON = 0;
    } else {
#line 11280
      pDM_SWAT_Table->ANTB_ON = 1;
    }
#line 11282
    if ((unsigned int )pHalData->CustomerID != 9U) {
#line 11283
      i = 0U;
#line 11283
      goto ldv_58479;
      ldv_58478: 
#line 11284
      tmp___0 = ODM_SingleDualAntennaDetection(& pHalData->odmpriv, 0);
#line 11284
      if ((int )tmp___0) {
#line 11286
        goto ldv_58477;
      } else {

      }
#line 11283
      i = (u8 )((int )i + 1);
      ldv_58479: ;
#line 11283
      if ((unsigned int )i <= 9U) {
#line 11285
        goto ldv_58478;
      } else {

      }
      ldv_58477: ;
#line 11290
      if ((unsigned int )btAntNum == 0U) {
#line 11291
        BTDM_SetBtCoexCurrAntNum(padapter, (int )pDM_SWAT_Table->ANTB_ON ? 2 : 1);
      } else {

      }
    } else {

    }
#line 11295
    pHalData->bAntennaDetected = 1U;
  } else {

  }
#line 11297
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
bool ldv_queue_work_on_763(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
bool ldv_queue_delayed_work_on_764(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
bool ldv_queue_work_on_765(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void ldv_flush_workqueue_766(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
bool ldv_queue_delayed_work_on_767(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_mod_timer_768(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 329
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 329
  ldv_func_res = tmp;
#line 331
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 333
  return (ldv_func_res);
}
}
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_769(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 340
  tmp = del_timer_sync(ldv_func_arg1);
#line 340
  ldv_func_res = tmp;
#line 342
  disable_suitable_timer_11(ldv_func_arg1);
#line 344
  return (ldv_func_res);
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_770(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 351
  tmp = del_timer_sync(ldv_func_arg1);
#line 351
  ldv_func_res = tmp;
#line 353
  disable_suitable_timer_11(ldv_func_arg1);
#line 355
  return (ldv_func_res);
}
}
#line 358 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_771(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 362
  tmp = del_timer_sync(ldv_func_arg1);
#line 362
  ldv_func_res = tmp;
#line 364
  disable_suitable_timer_11(ldv_func_arg1);
#line 366
  return (ldv_func_res);
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_772(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 373
  tmp = del_timer_sync(ldv_func_arg1);
#line 373
  ldv_func_res = tmp;
#line 375
  disable_suitable_timer_11(ldv_func_arg1);
#line 377
  return (ldv_func_res);
}
}
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_mod_timer_773(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 384
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 384
  ldv_func_res = tmp;
#line 386
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 388
  return (ldv_func_res);
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_774(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 395
  tmp = del_timer_sync(ldv_func_arg1);
#line 395
  ldv_func_res = tmp;
#line 397
  disable_suitable_timer_11(ldv_func_arg1);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_mod_timer_775(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 406
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 406
  ldv_func_res = tmp;
#line 408
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 410
  return (ldv_func_res);
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_776(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
#line 417
  tmp = del_timer_sync(ldv_func_arg1);
#line 417
  ldv_func_res = tmp;
#line 419
  disable_suitable_timer_11(ldv_func_arg1);
#line 421
  return (ldv_func_res);
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_777(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
#line 428
  tmp = del_timer_sync(ldv_func_arg1);
#line 428
  ldv_func_res = tmp;
#line 430
  disable_suitable_timer_11(ldv_func_arg1);
#line 432
  return (ldv_func_res);
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_778(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
#line 439
  tmp = del_timer_sync(ldv_func_arg1);
#line 439
  ldv_func_res = tmp;
#line 441
  disable_suitable_timer_11(ldv_func_arg1);
#line 443
  return (ldv_func_res);
}
}
#line 446 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_779(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;

  {
#line 450
  tmp = del_timer_sync(ldv_func_arg1);
#line 450
  ldv_func_res = tmp;
#line 452
  disable_suitable_timer_11(ldv_func_arg1);
#line 454
  return (ldv_func_res);
}
}
#line 457 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_780(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;

  {
#line 461
  tmp = del_timer_sync(ldv_func_arg1);
#line 461
  ldv_func_res = tmp;
#line 463
  disable_suitable_timer_11(ldv_func_arg1);
#line 465
  return (ldv_func_res);
}
}
#line 468 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_781(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___17 ldv_func_res ;
  int tmp ;

  {
#line 472
  tmp = del_timer_sync(ldv_func_arg1);
#line 472
  ldv_func_res = tmp;
#line 474
  disable_suitable_timer_11(ldv_func_arg1);
#line 476
  return (ldv_func_res);
}
}
#line 479 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_782(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___18 ldv_func_res ;
  int tmp ;

  {
#line 483
  tmp = del_timer_sync(ldv_func_arg1);
#line 483
  ldv_func_res = tmp;
#line 485
  disable_suitable_timer_11(ldv_func_arg1);
#line 487
  return (ldv_func_res);
}
}
#line 490 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_mod_timer_783(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___19 ldv_func_res ;
  int tmp ;

  {
#line 494
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 494
  ldv_func_res = tmp;
#line 496
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
#line 498
  return (ldv_func_res);
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_784(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___20 ldv_func_res ;
  int tmp ;

  {
#line 505
  tmp = del_timer_sync(ldv_func_arg1);
#line 505
  ldv_func_res = tmp;
#line 507
  disable_suitable_timer_11(ldv_func_arg1);
#line 509
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_811(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_813(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_812(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_815(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_814(struct workqueue_struct *ldv_func_arg1 ) ;
#line 34 "drivers/staging/rtl8723au/include/rtw_ap.h"
void update_sta_info23a_apmode23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 38
void rtw_set_macaddr_acl23a(struct rtw_adapter *padapter , int mode ) ;
#line 39
int rtw_acl_add_sta23a(struct rtw_adapter *padapter , u8 *addr ) ;
#line 40
int rtw_acl_remove_sta23a(struct rtw_adapter *padapter , u8 *addr ) ;
#line 44
u8 bss_cap_update_on_sta_leave23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 49
int rtw_ap_inform_ch_switch23a(struct rtw_adapter *padapter , u8 new_ch , u8 ch_offset ) ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
void init_mlme_ap_info23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct lock_class_key __key ;

  {
#line 31
  pmlmepriv = & padapter->mlmepriv;
#line 32
  pstapriv = & padapter->stapriv;
#line 33
  pacl_list = & pstapriv->acl_list;
#line 35
  spinlock_check(& pmlmepriv->bcn_update_lock);
#line 35
  __raw_spin_lock_init(& pmlmepriv->bcn_update_lock.__annonCompField18.rlock, "&(&pmlmepriv->bcn_update_lock)->rlock",
                       & __key);
#line 38
  _rtw_init_queue23a(& pacl_list->acl_node_q);
#line 40
  start_ap_mode23a(padapter);
#line 41
  return;
}
}
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
void free_mlme_ap_info23a(struct rtw_adapter *padapter ) 
{ 
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 45
  psta = (struct sta_info *)0;
#line 46
  pstapriv = & padapter->stapriv;
#line 47
  pmlmepriv = & padapter->mlmepriv;
#line 48
  pmlmeext = & padapter->mlmeextpriv;
#line 49
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 51
  pmlmepriv->update_bcn = 0U;
#line 52
  pmlmeext->bstart_bss = 0U;
#line 54
  rtw_sta_flush23a(padapter);
#line 56
  pmlmeinfo->state = 0U;
#line 59
  rtw_free_all_stainfo23a(padapter);
#line 62
  psta = rtw_get_bcmc_stainfo23a(padapter);
#line 63
  spin_lock_bh(& pstapriv->sta_hash_lock);
#line 64
  rtw_free_stainfo23a(padapter, psta);
#line 65
  spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 66
  return;
}
}
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static void update_BCNTIM(struct rtw_adapter *padapter ) 
{ 
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork_mlmeext ;
  unsigned char *pie ;
  u8 *p ;
  u8 *dst_ie ;
  u8 *premainder_ie ;
  u8 *pbackup_remainder_ie ;
  uint offset ;
  uint tmp_len ;
  uint tim_ielen ;
  uint tim_ie_offset ;
  uint remainder_ielen ;
  void *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;

  {
#line 70
  pstapriv = & padapter->stapriv;
#line 71
  pmlmeext = & padapter->mlmeextpriv;
#line 72
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 73
  pnetwork_mlmeext = & pmlmeinfo->network;
#line 74
  pie = (unsigned char *)(& pnetwork_mlmeext->IEs);
#line 75
  premainder_ie = (u8 *)0U;
#line 75
  pbackup_remainder_ie = (u8 *)0U;
#line 78
  p = rtw_get_ie23a(pie, 5, (int *)(& tim_ielen), (int )pnetwork_mlmeext->IELength);
#line 80
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && tim_ielen != 0U) {
#line 81
    tim_ielen = tim_ielen + 2U;
#line 83
    premainder_ie = p + (unsigned long )tim_ielen;
#line 85
    tim_ie_offset = (unsigned int )((long )p) - (unsigned int )((long )pie);
#line 87
    remainder_ielen = (pnetwork_mlmeext->IELength - tim_ie_offset) - tim_ielen;
#line 90
    dst_ie = p;
  } else {
#line 92
    tim_ielen = 0U;
#line 95
    offset = 0U;
#line 98
    p = rtw_get_ie23a(pie, 0, (int *)(& tmp_len), (int )pnetwork_mlmeext->IELength);
#line 100
    if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
#line 101
      offset = (tmp_len + offset) + 2U;
    } else {

    }
#line 104
    p = rtw_get_ie23a(pie, 1, (int *)(& tmp_len), (int )pnetwork_mlmeext->IELength);
#line 106
    if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
#line 107
      offset = (tmp_len + offset) + 2U;
    } else {

    }
#line 110
    offset = offset + 3U;
#line 112
    premainder_ie = pie + (unsigned long )offset;
#line 114
    remainder_ielen = (pnetwork_mlmeext->IELength - offset) - tim_ielen;
#line 117
    dst_ie = pie + (unsigned long )offset;
  }
#line 120
  if (remainder_ielen != 0U) {
#line 121
    tmp = kmalloc((size_t )remainder_ielen, 32U);
#line 121
    pbackup_remainder_ie = (u8 *)tmp;
#line 122
    if ((unsigned long )pbackup_remainder_ie != (unsigned long )((u8 *)0U) && (unsigned long )premainder_ie != (unsigned long )((u8 *)0U)) {
#line 123
      memcpy((void *)pbackup_remainder_ie, (void const   *)premainder_ie, (size_t )remainder_ielen);
    } else {

    }
  } else {

  }
#line 126
  tmp___0 = dst_ie;
#line 126
  dst_ie = dst_ie + 1;
#line 126
  *tmp___0 = 5U;
#line 128
  if (((int )pstapriv->tim_bitmap & 65280) != 0 && ((int )pstapriv->tim_bitmap & 252) != 0) {
#line 129
    tim_ielen = 5U;
  } else {
#line 131
    tim_ielen = 4U;
  }
#line 133
  tmp___1 = dst_ie;
#line 133
  dst_ie = dst_ie + 1;
#line 133
  *tmp___1 = (u8 )tim_ielen;
#line 135
  tmp___2 = dst_ie;
#line 135
  dst_ie = dst_ie + 1;
#line 135
  *tmp___2 = 0U;
#line 136
  tmp___3 = dst_ie;
#line 136
  dst_ie = dst_ie + 1;
#line 136
  *tmp___3 = 1U;
#line 138
  if ((int )pstapriv->tim_bitmap & 1) {
#line 139
    tmp___4 = dst_ie;
#line 139
    dst_ie = dst_ie + 1;
#line 139
    *tmp___4 = 1U;
  } else {
#line 141
    tmp___5 = dst_ie;
#line 141
    dst_ie = dst_ie + 1;
#line 141
    *tmp___5 = 0U;
  }
#line 143
  if (tim_ielen == 4U) {
#line 144
    tmp___6 = dst_ie;
#line 144
    dst_ie = dst_ie + 1;
#line 144
    *tmp___6 = (u8 )pstapriv->tim_bitmap;
  } else
#line 145
  if (tim_ielen == 5U) {
#line 146
    put_unaligned_le16((int )pstapriv->tim_bitmap, (void *)dst_ie);
#line 147
    dst_ie = dst_ie + 2UL;
  } else {

  }
#line 151
  if ((unsigned long )pbackup_remainder_ie != (unsigned long )((u8 *)0U)) {
#line 152
    memcpy((void *)dst_ie, (void const   *)pbackup_remainder_ie, (size_t )remainder_ielen);
#line 154
    kfree((void const   *)pbackup_remainder_ie);
  } else {

  }
#line 157
  offset = (unsigned int )((long )dst_ie) - (unsigned int )((long )pie);
#line 158
  pnetwork_mlmeext->IELength = offset + remainder_ielen;
#line 160
  set_tx_beacon_cmd23a(padapter);
#line 161
  return;
}
}
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static u8 chk_sta_is_alive(struct sta_info *psta ) 
{ 
  u8 ret ;

  {
#line 165
  ret = 0U;
#line 167
  if (psta->sta_stats.last_rx_data_pkts + psta->sta_stats.last_rx_ctrl_pkts != psta->sta_stats.rx_data_pkts + psta->sta_stats.rx_ctrl_pkts) {
#line 170
    ret = 1U;
  } else {

  }
#line 172
  psta->sta_stats.last_rx_mgnt_pkts = psta->sta_stats.rx_mgnt_pkts;
#line 172
  psta->sta_stats.last_rx_beacon_pkts = psta->sta_stats.rx_beacon_pkts;
#line 172
  psta->sta_stats.last_rx_probereq_pkts = psta->sta_stats.rx_probereq_pkts;
#line 172
  psta->sta_stats.last_rx_probersp_pkts = psta->sta_stats.rx_probersp_pkts;
#line 172
  psta->sta_stats.last_rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts;
#line 172
  psta->sta_stats.last_rx_probersp_uo_pkts = psta->sta_stats.rx_probersp_uo_pkts;
#line 172
  psta->sta_stats.last_rx_ctrl_pkts = psta->sta_stats.rx_ctrl_pkts;
#line 172
  psta->sta_stats.last_rx_data_pkts = psta->sta_stats.rx_data_pkts;
#line 174
  return (ret);
}
}
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
void expire_timeout_chk23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  u8 updated ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  u8 chk_alive_num ;
  struct sta_info *chk_alive_list[32U] ;
  int i ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  u8 tmp ;
  struct mlme_ext_priv *pmlmeext ;
  u32 tmp___0 ;
  u8 tmp___1 ;
  u8 backup_oper_channel ;
  struct mlme_ext_priv *pmlmeext___0 ;
  u8 tmp___2 ;
  int ret ;
  int tmp___3 ;

  {
#line 180
  updated = 0U;
#line 182
  pstapriv = & padapter->stapriv;
#line 183
  chk_alive_num = 0U;
#line 187
  spin_lock_bh(& pstapriv->auth_list_lock);
#line 189
  phead = & pstapriv->auth_list;
#line 192
  plist = phead->next;
#line 192
  ptmp = plist->next;
#line 192
  goto ldv_55757;
  ldv_55756: 
#line 193
  __mptr = (struct list_head  const  *)plist;
#line 193
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb80UL;
#line 195
  if (psta->expire_to != 0U) {
#line 196
    psta->expire_to = psta->expire_to - 1U;
#line 197
    if (psta->expire_to == 0U) {
#line 198
      list_del_init(& psta->auth_list);
#line 199
      pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt - 1);
#line 201
      if (GlobalDebugLevel23A > 3U) {
#line 201
        printk("\016RTL8723AU: auth expire %pM\n", (u8 *)(& psta->hwaddr));
      } else {

      }
#line 203
      spin_unlock_bh(& pstapriv->auth_list_lock);
#line 205
      spin_lock_bh(& pstapriv->sta_hash_lock);
#line 206
      rtw_free_stainfo23a(padapter, psta);
#line 207
      spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 209
      spin_lock_bh(& pstapriv->auth_list_lock);
    } else {

    }
  } else {

  }
#line 192
  plist = ptmp;
#line 192
  ptmp = plist->next;
  ldv_55757: ;
#line 192
  if ((unsigned long )plist != (unsigned long )phead) {
#line 194
    goto ldv_55756;
  } else {

  }
#line 215
  spin_unlock_bh(& pstapriv->auth_list_lock);
#line 217
  spin_lock_bh(& pstapriv->asoc_list_lock);
#line 219
  phead = & pstapriv->asoc_list;
#line 222
  plist = phead->next;
#line 222
  ptmp = plist->next;
#line 222
  goto ldv_55765;
  ldv_55764: 
#line 223
  __mptr___0 = (struct list_head  const  *)plist;
#line 223
  psta = (struct sta_info *)__mptr___0 + 0xffffffffffffeb90UL;
#line 225
  tmp = chk_sta_is_alive(psta);
#line 225
  if ((unsigned int )tmp != 0U || psta->expire_to == 0U) {
#line 226
    psta->expire_to = pstapriv->expire_to;
#line 227
    psta->keep_alive_trycnt = 0U;
  } else {
#line 229
    psta->expire_to = psta->expire_to - 1U;
  }
#line 232
  if (psta->expire_to == 0U) {
#line 233
    pmlmeext = & padapter->mlmeextpriv;
#line 235
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
#line 236
      psta->expire_to = pstapriv->expire_to;
#line 237
      goto ldv_55762;
    } else {

    }
#line 240
    if ((psta->state & 4U) != 0U) {
#line 241
      if ((psta->state & 1024U) == 0U) {
#line 243
        psta->expire_to = pstapriv->expire_to;
#line 244
        psta->state = psta->state | 1024U;
#line 247
        tmp___0 = CHKBIT(psta->aid);
#line 247
        pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap | (int )((u16 )tmp___0);
#line 248
        update_beacon23a(padapter, 5, (u8 *)0U, 0);
#line 250
        if ((unsigned int )pmlmeext->active_keep_alive_check == 0U) {
#line 251
          goto ldv_55762;
        } else {

        }
      } else {

      }
    } else {

    }
#line 255
    if ((unsigned int )pmlmeext->active_keep_alive_check != 0U) {
#line 256
      tmp___1 = chk_alive_num;
#line 256
      chk_alive_num = (u8 )((int )chk_alive_num + 1);
#line 256
      chk_alive_list[(int )tmp___1] = psta;
#line 257
      goto ldv_55762;
    } else {

    }
#line 260
    list_del_init(& psta->asoc_list);
#line 261
    pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
#line 263
    if (GlobalDebugLevel23A > 3U) {
#line 263
      printk("\016RTL8723AU: asoc expire %pM, state = 0x%x\n", (u8 *)(& psta->hwaddr),
             psta->state);
    } else {

    }
#line 265
    updated = ap_free_sta23a(padapter, psta, 0, 3);
  } else
#line 268
  if (psta->sleepq_len > (unsigned int )(256 / (int )pstapriv->asoc_list_cnt) && padapter->xmitpriv.free_xmitframe_cnt < 128 / (int )pstapriv->asoc_list_cnt) {
#line 271
    if (GlobalDebugLevel23A > 3U) {
#line 271
      printk("\016RTL8723AU: %s sta:%pM, sleepq_len:%u, free_xmitframe_cnt:%u, asoc_list_cnt:%u, clear sleep_q\n",
             "expire_timeout_chk23a", (u8 *)(& psta->hwaddr), psta->sleepq_len, padapter->xmitpriv.free_xmitframe_cnt,
             (int )pstapriv->asoc_list_cnt);
    } else {

    }
#line 277
    wakeup_sta_to_xmit23a(padapter, psta);
  } else {

  }
  ldv_55762: 
#line 222
  plist = ptmp;
#line 222
  ptmp = plist->next;
  ldv_55765: ;
#line 222
  if ((unsigned long )plist != (unsigned long )phead) {
#line 224
    goto ldv_55764;
  } else {

  }
#line 282
  spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 284
  if ((unsigned int )chk_alive_num != 0U) {
#line 286
    backup_oper_channel = 0U;
#line 287
    pmlmeext___0 = & padapter->mlmeextpriv;
#line 289
    tmp___2 = rtw_get_oper_ch23a(padapter);
#line 289
    if ((int )tmp___2 != (int )pmlmeext___0->cur_channel) {
#line 290
      backup_oper_channel = rtw_get_oper_ch23a(padapter);
#line 291
      SelectChannel23a(padapter, (int )pmlmeext___0->cur_channel);
    } else {

    }
#line 295
    i = 0;
#line 295
    goto ldv_55772;
    ldv_55771: 
#line 297
    ret = 0;
#line 299
    psta = chk_alive_list[i];
#line 300
    if ((psta->state & 1U) == 0U) {
#line 301
      goto ldv_55770;
    } else {

    }
#line 303
    if ((psta->state & 4U) != 0U) {
#line 304
      ret = issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), 0U, 1,
                              50);
    } else {
#line 306
      ret = issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), 0U, 3,
                              50);
    }
#line 308
    psta->keep_alive_trycnt = (u8 )((int )psta->keep_alive_trycnt + 1);
#line 309
    if (ret == 1) {
#line 310
      if (GlobalDebugLevel23A > 3U) {
#line 310
        printk("\016RTL8723AU: asoc check, sta(%pM) is alive\n", (u8 *)(& psta->hwaddr));
      } else {

      }
#line 312
      psta->expire_to = pstapriv->expire_to;
#line 313
      psta->keep_alive_trycnt = 0U;
#line 314
      goto ldv_55770;
    } else
#line 315
    if ((unsigned int )psta->keep_alive_trycnt <= 3U) {
#line 316
      if (GlobalDebugLevel23A > 3U) {
#line 316
        printk("\016RTL8723AU: ack check for asoc expire, keep_alive_trycnt =%d\n",
               (int )psta->keep_alive_trycnt);
      } else {

      }
#line 317
      psta->expire_to = 1U;
#line 318
      goto ldv_55770;
    } else {

    }
#line 321
    psta->keep_alive_trycnt = 0U;
#line 323
    if (GlobalDebugLevel23A > 3U) {
#line 323
      printk("\016RTL8723AU: asoc expire %pM, state = 0x%x\n", (u8 *)(& psta->hwaddr),
             psta->state);
    } else {

    }
#line 325
    spin_lock_bh(& pstapriv->asoc_list_lock);
#line 326
    tmp___3 = list_empty((struct list_head  const  *)(& psta->asoc_list));
#line 326
    if (tmp___3 == 0) {
#line 327
      list_del_init(& psta->asoc_list);
#line 328
      pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
#line 329
      updated = ap_free_sta23a(padapter, psta, 0, 3);
    } else {

    }
#line 331
    spin_unlock_bh(& pstapriv->asoc_list_lock);
    ldv_55770: 
#line 295
    i = i + 1;
    ldv_55772: ;
#line 295
    if ((int )chk_alive_num > i) {
#line 297
      goto ldv_55771;
    } else {

    }

#line 335
    if ((unsigned int )backup_oper_channel != 0U) {
#line 336
      SelectChannel23a(padapter, (int )backup_oper_channel);
    } else {

    }
  } else {

  }
#line 339
  associated_clients_update23a(padapter, (int )updated);
#line 340
  return;
}
}
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
void add_RATid23a(struct rtw_adapter *padapter , struct sta_info *psta , u8 rssi_level ) 
{ 
  int i ;
  u8 rf_type ;
  u32 init_rate ;
  unsigned char sta_band ;
  unsigned char raid ;
  unsigned char shortGIrate ;
  unsigned char limit ;
  unsigned int tx_ra_bitmap ;
  struct ht_priv *psta_ht ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pcur_network ;
  int tmp ;
  unsigned char tmp___0 ;
  u8 arg ;

  {
#line 346
  init_rate = 0U;
#line 347
  sta_band = 0U;
#line 347
  shortGIrate = 0U;
#line 349
  tx_ra_bitmap = 0U;
#line 350
  psta_ht = (struct ht_priv *)0;
#line 351
  pmlmepriv = & padapter->mlmepriv;
#line 352
  pcur_network = & pmlmepriv->cur_network.network;
#line 354
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 355
    psta_ht = & psta->htpriv;
  } else {
#line 357
    return;
  }
#line 359
  if ((psta->state & 1U) == 0U) {
#line 360
    return;
  } else {

  }
#line 363
  i = 0;
#line 363
  goto ldv_55791;
  ldv_55790: ;
#line 364
  if ((unsigned int )psta->bssrateset[i] != 0U) {
#line 365
    tmp = rtw_get_bit_value_from_ieee_value23a((int )psta->bssrateset[i] & 127);
#line 365
    tx_ra_bitmap = (unsigned int )tmp | tx_ra_bitmap;
  } else {

  }
#line 363
  i = i + 1;
  ldv_55791: ;
#line 363
  if ((unsigned int )i <= 15U) {
#line 365
    goto ldv_55790;
  } else {

  }

#line 368
  if ((int )psta_ht->ht_option) {
#line 369
    rf_type = rtl8723a_get_rf_type(padapter);
#line 371
    if ((unsigned int )rf_type == 2U) {
#line 372
      limit = 16U;
    } else {
#line 374
      limit = 8U;
    }
#line 376
    i = 0;
#line 376
    goto ldv_55794;
    ldv_55793: ;
#line 377
    if ((int )((unsigned long )psta_ht->ht_cap.mcs.rx_mask[i / 8] >> i % 8) & 1) {
#line 378
      tx_ra_bitmap = (unsigned int )(1UL << (i + 12)) | tx_ra_bitmap;
    } else {

    }
#line 376
    i = i + 1;
    ldv_55794: ;
#line 376
    if ((int )limit > i) {
#line 378
      goto ldv_55793;
    } else {

    }
#line 382
    shortGIrate = psta_ht->sgi;
  } else {

  }
#line 385
  if (pcur_network->DSConfig > 14U) {
#line 387
    if ((tx_ra_bitmap & 268431360U) != 0U) {
#line 388
      sta_band = (unsigned int )sta_band | 20U;
    } else {
#line 390
      sta_band = (unsigned int )sta_band | 4U;
    }
  } else
#line 392
  if ((tx_ra_bitmap & 268431360U) != 0U) {
#line 393
    sta_band = (unsigned int )sta_band | 11U;
  } else
#line 394
  if ((tx_ra_bitmap & 4080U) != 0U) {
#line 395
    sta_band = (unsigned int )sta_band | 3U;
  } else {
#line 397
    sta_band = (unsigned int )sta_band | 1U;
  }
#line 400
  psta->wireless_mode = sta_band;
#line 402
  raid = networktype_to_raid23a((int )sta_band);
#line 403
  tmp___0 = get_highest_rate_idx23a(tx_ra_bitmap & 268435455U);
#line 403
  init_rate = (u32 )tmp___0 & 63U;
#line 405
  if (psta->aid <= 31U) {
#line 406
    arg = 0U;
#line 408
    arg = (unsigned int )((u8 )psta->mac_id) & 31U;
#line 410
    arg = (u8 )((unsigned int )arg | 128U);
#line 412
    if ((unsigned int )shortGIrate == 1U) {
#line 413
      arg = (u8 )((unsigned int )arg | 32U);
    } else {

    }
#line 415
    tx_ra_bitmap = (unsigned int )((int )raid << 28) | tx_ra_bitmap;
#line 417
    if (GlobalDebugLevel23A > 3U) {
#line 417
      printk("\016RTL8723AU: %s => mac_id:%d , raid:%d , bitmap = 0x%x, arg = 0x%x\n",
             "add_RATid23a", psta->mac_id, (int )raid, tx_ra_bitmap, (int )arg);
    } else {

    }
#line 425
    rtl8723a_add_rateatid(padapter, tx_ra_bitmap, (int )arg, (int )rssi_level);
#line 427
    if ((unsigned int )shortGIrate == 1U) {
#line 428
      init_rate = init_rate | 64U;
    } else {

    }
#line 431
    psta->raid = raid;
#line 432
    psta->init_rate = (u8 )init_rate;
  } else
#line 435
  if (GlobalDebugLevel23A > 3U) {
#line 435
    printk("\016RTL8723AU: station aid %d exceed the max number\n", psta->aid);
  } else {

  }
#line 436
  return;
}
}
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static void update_bmc_sta(struct rtw_adapter *padapter ) 
{ 
  u32 init_rate ;
  unsigned char network_type ;
  unsigned char raid ;
  int i ;
  int supportRateNum ;
  unsigned int tx_ra_bitmap ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pcur_network ;
  struct sta_info *psta ;
  struct sta_info *tmp ;
  uint tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char tmp___3 ;
  u8 arg ;

  {
#line 440
  init_rate = 0U;
#line 442
  supportRateNum = 0;
#line 443
  tx_ra_bitmap = 0U;
#line 444
  pmlmepriv = & padapter->mlmepriv;
#line 445
  pcur_network = & pmlmepriv->cur_network.network;
#line 446
  tmp = rtw_get_bcmc_stainfo23a(padapter);
#line 446
  psta = tmp;
#line 448
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 449
    psta->aid = 0U;
#line 450
    psta->mac_id = psta->aid + 1U;
#line 452
    psta->qos_option = 0U;
#line 453
    psta->htpriv.ht_option = 0;
#line 455
    psta->ieee8021x_blocked = 0U;
#line 457
    memset((void *)(& psta->sta_stats), 0, 168UL);
#line 461
    tmp___0 = rtw_get_rateset_len23a((u8 *)(& pcur_network->SupportedRates));
#line 461
    supportRateNum = (int )tmp___0;
#line 462
    tmp___1 = rtw_check_network_type23a((unsigned char *)(& pcur_network->SupportedRates),
                                        supportRateNum, 1);
#line 462
    network_type = (unsigned char )tmp___1;
#line 464
    memcpy((void *)(& psta->bssrateset), (void const   *)(& pcur_network->SupportedRates),
             (size_t )supportRateNum);
#line 465
    psta->bssratelen = (u32 )supportRateNum;
#line 468
    i = 0;
#line 468
    goto ldv_55811;
    ldv_55810: ;
#line 469
    if ((unsigned int )psta->bssrateset[i] != 0U) {
#line 470
      tmp___2 = rtw_get_bit_value_from_ieee_value23a((int )psta->bssrateset[i] & 127);
#line 470
      tx_ra_bitmap = (unsigned int )tmp___2 | tx_ra_bitmap;
    } else {

    }
#line 468
    i = i + 1;
    ldv_55811: ;
#line 468
    if (i < supportRateNum) {
#line 470
      goto ldv_55810;
    } else {

    }

#line 473
    if (pcur_network->DSConfig > 14U) {
#line 475
      network_type = 4U;
#line 476
      tx_ra_bitmap = 336U;
    } else {
#line 479
      network_type = 1U;
#line 480
      tx_ra_bitmap = 15U;
    }
#line 483
    raid = networktype_to_raid23a((int )network_type);
#line 484
    tmp___3 = get_highest_rate_idx23a(tx_ra_bitmap & 268435455U);
#line 484
    init_rate = (u32 )tmp___3 & 63U;
#line 487
    rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 1);
#line 490
    arg = 0U;
#line 492
    arg = (unsigned int )((u8 )psta->mac_id) & 31U;
#line 494
    arg = (u8 )((unsigned int )arg | 128U);
#line 496
    tx_ra_bitmap = (unsigned int )((int )raid << 28) | tx_ra_bitmap;
#line 498
    if (GlobalDebugLevel23A > 3U) {
#line 498
      printk("\016RTL8723AU: update_bmc_sta, mask = 0x%x, arg = 0x%x\n", tx_ra_bitmap,
             (int )arg);
    } else {

    }
#line 504
    rtl8723a_add_rateatid(padapter, tx_ra_bitmap, (int )arg, 0);
#line 508
    psta->raid = raid;
#line 509
    psta->init_rate = (u8 )init_rate;
#line 511
    spin_lock_bh(& psta->lock);
#line 512
    psta->state = 1U;
#line 513
    spin_unlock_bh(& psta->lock);
  } else
#line 516
  if (GlobalDebugLevel23A > 3U) {
#line 516
    printk("\016RTL8723AU: add_RATid23a_bmc_sta error!\n");
  } else {

  }
#line 517
  return;
}
}
#line 526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
void update_sta_info23a_apmode23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct ht_priv *phtpriv_ap ;
  struct ht_priv *phtpriv_sta ;

  {
#line 528
  pmlmepriv = & padapter->mlmepriv;
#line 529
  psecuritypriv = & padapter->securitypriv;
#line 530
  pmlmeext = & padapter->mlmeextpriv;
#line 531
  phtpriv_ap = & pmlmepriv->htpriv;
#line 532
  phtpriv_sta = & psta->htpriv;
#line 535
  psta->mac_id = psta->aid + 1U;
#line 536
  if (GlobalDebugLevel23A > 3U) {
#line 536
    printk("\016RTL8723AU: %s\n", "update_sta_info23a_apmode23a");
  } else {

  }
#line 539
  rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 1);
#line 541
  if (psecuritypriv->dot11AuthAlgrthm == 2U) {
#line 542
    psta->ieee8021x_blocked = 1U;
  } else {
#line 544
    psta->ieee8021x_blocked = 0U;
  }
#line 549
  VCS_update23a(padapter, psta);
#line 551
  if ((int )phtpriv_sta->ht_option) {
#line 553
    phtpriv_sta->ampdu_enable = phtpriv_ap->ampdu_enable;
#line 556
    if ((((int )phtpriv_sta->ht_cap.cap_info & (int )phtpriv_ap->ht_cap.cap_info) & 96) != 0) {
#line 557
      phtpriv_sta->sgi = 1U;
    } else {

    }
#line 560
    if ((((int )phtpriv_sta->ht_cap.cap_info & (int )phtpriv_ap->ht_cap.cap_info) & 2) != 0) {
#line 562
      phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
#line 563
      phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
    } else {

    }
#line 567
    psta->qos_option = 1U;
  } else {
#line 570
    phtpriv_sta->ampdu_enable = 0;
#line 572
    phtpriv_sta->sgi = 0U;
#line 573
    phtpriv_sta->bwmode = 0U;
#line 574
    phtpriv_sta->ch_offset = 0U;
  }
#line 578
  send_delba23a(padapter, 0, (u8 *)(& psta->hwaddr));
#line 581
  send_delba23a(padapter, 1, (u8 *)(& psta->hwaddr));
#line 582
  phtpriv_sta->agg_enable_bitmap = 0U;
#line 583
  phtpriv_sta->candidate_tid_bitmap = 0U;
#line 587
  memset((void *)(& psta->sta_stats), 0, 168UL);
#line 589
  spin_lock_bh(& psta->lock);
#line 590
  psta->state = psta->state | 1U;
#line 591
  spin_unlock_bh(& psta->lock);
#line 592
  return;
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static void update_hw_ht_param(struct rtw_adapter *padapter ) 
{ 
  unsigned char max_AMPDU_len ;
  unsigned char min_MPDU_spacing ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 598
  pmlmeext = & padapter->mlmeextpriv;
#line 599
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 601
  if (GlobalDebugLevel23A > 3U) {
#line 601
    printk("\016RTL8723AU: %s\n", "update_hw_ht_param");
  } else {

  }
#line 608
  max_AMPDU_len = (unsigned int )pmlmeinfo->ht_cap.ampdu_params_info & 3U;
#line 611
  min_MPDU_spacing = (unsigned char )(((int )pmlmeinfo->ht_cap.ampdu_params_info & 28) >> 2);
#line 614
  rtl8723a_set_ampdu_min_space(padapter, (int )min_MPDU_spacing);
#line 615
  rtl8723a_set_ampdu_factor(padapter, (int )max_AMPDU_len);
#line 618
  pmlmeinfo->SM_PS = (u8 )(((int )pmlmeinfo->ht_cap.cap_info & 12) >> 2);
#line 620
  if ((unsigned int )pmlmeinfo->SM_PS == 0U) {
#line 621
    if (GlobalDebugLevel23A > 3U) {
#line 621
      printk("\016RTL8723AU: %s(): WLAN_HT_CAP_SM_PS_STATIC\n", "update_hw_ht_param");
    } else {

    }
  } else {

  }
#line 622
  return;
}
}
#line 624 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static void start_bss_network(struct rtw_adapter *padapter , u8 *pbuf ) 
{ 
  u8 const   *p ;
  u8 val8 ;
  u8 cur_channel ;
  u8 cur_bwmode ;
  u8 cur_ch_offset ;
  u16 bcn_interval ;
  u32 acparm ;
  struct registry_priv *pregpriv ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct wlan_bssid_ex *pnetwork ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork_mlmeext ;
  struct ieee80211_ht_operation *pht_info ;
  u8 const   *tmp ;
  int tmp___0 ;

  {
#line 630
  pregpriv = & padapter->registrypriv;
#line 631
  pmlmepriv = & padapter->mlmepriv;
#line 632
  psecuritypriv = & padapter->securitypriv;
#line 633
  pnetwork = & pmlmepriv->cur_network.network;
#line 634
  pmlmeext = & padapter->mlmeextpriv;
#line 635
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 636
  pnetwork_mlmeext = & pmlmeinfo->network;
#line 637
  pht_info = (struct ieee80211_ht_operation *)0;
#line 639
  bcn_interval = pnetwork->beacon_interval;
#line 640
  cur_channel = (u8 )pnetwork->DSConfig;
#line 641
  cur_bwmode = 0U;
#line 642
  cur_ch_offset = 0U;
#line 647
  tmp = cfg80211_find_vendor_ie(20722U, 4, (u8 const   *)(& pnetwork->IEs), (int )pnetwork->IELength);
#line 647
  if ((unsigned long )tmp == (unsigned long )((u8 const   *)0U)) {
#line 651
    pmlmeext->bstart_bss = 1U;
  } else {

  }
#line 656
  if (pmlmepriv->qos_option != 0U) {
#line 657
    pmlmeinfo->WMM_enable = 1U;
  } else {

  }
#line 658
  if ((int )pmlmepriv->htpriv.ht_option) {
#line 659
    pmlmeinfo->WMM_enable = 1U;
#line 660
    pmlmeinfo->HT_enable = 1U;
#line 662
    update_hw_ht_param(padapter);
  } else {

  }
#line 665
  if (pmlmepriv->cur_network.join_res != 1) {
#line 668
    if (psecuritypriv->dot11PrivacyAlgrthm != 1027073U && psecuritypriv->dot11PrivacyAlgrthm != 1027077U) {
#line 672
      flush_all_cam_entry23a(padapter);
    } else {

    }
  } else {

  }
#line 676
  rtl8723a_set_media_status(padapter, 3);
#line 679
  hw_var_set_bssid(padapter, (u8 *)(& pnetwork->MacAddress));
#line 682
  acparm = 3093015U;
#line 683
  rtl8723a_set_ac_param_vo(padapter, acparm);
#line 684
  acparm = 6177559U;
#line 685
  rtl8723a_set_ac_param_vi(padapter, acparm);
#line 686
  acparm = 6202411U;
#line 687
  rtl8723a_set_ac_param_be(padapter, acparm);
#line 688
  acparm = 42052U;
#line 689
  rtl8723a_set_ac_param_bk(padapter, acparm);
#line 692
  val8 = psecuritypriv->dot11AuthAlgrthm == 2U ? 204U : 207U;
#line 694
  rtl8723a_set_sec_cfg(padapter, (int )val8);
#line 697
  rtl8723a_set_beacon_interval(padapter, (int )bcn_interval);
#line 699
  UpdateBrateTbl23a(padapter, (u8 *)(& pnetwork->SupportedRates));
#line 700
  HalSetBrateCfg23a(padapter, (u8 *)(& pnetwork->SupportedRates));
#line 702
  if (pmlmepriv->cur_network.join_res == 0) {
#line 708
    rtl8723a_odm_support_ability_set(padapter, 268435455U);
  } else {

  }
#line 713
  p = cfg80211_find_ie(61, (u8 const   *)(& pnetwork->IEs), (int )pnetwork->IELength);
#line 715
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 716
    pht_info = (struct ieee80211_ht_operation *)p + 2U;
#line 718
    if ((unsigned int )pregpriv->cbw40_enable != 0U && ((int )pht_info->ht_param & 4) != 0) {
#line 721
      cur_bwmode = 1U;
#line 722
      switch ((int )pht_info->ht_param & 3) {
      case 1: 
#line 727
      cur_ch_offset = 1U;
#line 728
      goto ldv_55852;
      case 3: 
#line 730
      cur_ch_offset = 2U;
#line 731
      goto ldv_55852;
      default: 
#line 733
      cur_ch_offset = 0U;
#line 734
      goto ldv_55852;
      }
      ldv_55852: ;
    } else {

    }
  } else {

  }
#line 739
  set_channel_bwmode23a(padapter, (int )cur_channel, (int )cur_ch_offset, (int )cur_bwmode);
#line 741
  if (GlobalDebugLevel23A > 3U) {
#line 741
    printk("\016RTL8723AU: CH =%d, BW =%d, offset =%d\n", (int )cur_channel, (int )cur_bwmode,
           (int )cur_ch_offset);
  } else {

  }
#line 744
  pmlmeext->cur_channel = cur_channel;
#line 745
  pmlmeext->cur_bwmode = cur_bwmode;
#line 746
  pmlmeext->cur_ch_offset = cur_ch_offset;
#line 747
  pmlmeext->cur_wireless_mode = (unsigned char )pmlmepriv->cur_network.network_type;
#line 750
  update_wireless_mode23a(padapter);
#line 753
  update_capinfo23a(padapter, (int )pnetwork->capability);
#line 756
  memcpy((void *)pnetwork_mlmeext, (void const   *)pnetwork, (size_t )pnetwork->Length);
#line 758
  if ((unsigned int )pmlmeext->bstart_bss != 0U) {
#line 759
    update_beacon23a(padapter, 5, (u8 *)0U, 0);
#line 762
    tmp___0 = send_beacon23a(padapter);
#line 762
    if (tmp___0 == 0) {
#line 763
      if (GlobalDebugLevel23A > 3U) {
#line 763
        printk("\016RTL8723AU: issue_beacon23a, fail!\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 767
  update_bmc_sta(padapter);
#line 768
  return;
}
}
#line 770 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
int rtw_check_beacon_data23a(struct rtw_adapter *padapter , struct ieee80211_mgmt *mgmt ,
                             unsigned int len ) 
{ 
  int ret ;
  u8 *p ;
  u8 *pHT_caps_ie ;
  u8 *pHT_info_ie ;
  struct sta_info *psta ;
  u16 ht_cap ;
  uint ie_len ;
  int group_cipher ;
  int pairwise_cipher ;
  u8 channel ;
  u8 network_type ;
  u8 supportRate[16U] ;
  int supportRateNum ;
  u8 WMM_PARA_IE[6U] ;
  struct registry_priv *pregistrypriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pbss_network ;
  u8 *ie ;
  u8 *pbuf ;
  bool tmp ;
  int tmp___0 ;
  u8 *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  u8 rf_type ;
  struct ieee80211_ht_cap *pht_cap ;

  {
#line 773
  ret = 1;
#line 775
  pHT_caps_ie = (u8 *)0U;
#line 776
  pHT_info_ie = (u8 *)0U;
#line 777
  psta = (struct sta_info *)0;
#line 778
  ht_cap = 0U;
#line 779
  ie_len = 0U;
#line 782
  supportRateNum = 0;
#line 783
  WMM_PARA_IE[0] = 0U;
#line 783
  WMM_PARA_IE[1] = 80U;
#line 783
  WMM_PARA_IE[2] = 242U;
#line 783
  WMM_PARA_IE[3] = 2U;
#line 783
  WMM_PARA_IE[4] = 1U;
#line 783
  WMM_PARA_IE[5] = 1U;
#line 784
  pregistrypriv = & padapter->registrypriv;
#line 785
  psecuritypriv = & padapter->securitypriv;
#line 786
  pmlmepriv = & padapter->mlmepriv;
#line 787
  pbss_network = & pmlmepriv->cur_network.network;
#line 788
  ie = (u8 *)(& pbss_network->IEs);
#line 789
  pbuf = (u8 *)(& mgmt->u.beacon.variable);
#line 791
  len = len - 36U;
#line 803
  if (GlobalDebugLevel23A > 3U) {
#line 803
    printk("\016RTL8723AU: %s, len =%d\n", "rtw_check_beacon_data23a", len);
  } else {

  }
#line 805
  tmp = check_fwstate(pmlmepriv, 16);
#line 805
  if (tmp) {
#line 805
    tmp___0 = 0;
  } else {
#line 805
    tmp___0 = 1;
  }
#line 805
  if (tmp___0) {
#line 806
    return (0);
  } else {

  }
#line 808
  if (len > 768U) {
#line 809
    return (0);
  } else {

  }
#line 811
  pbss_network->IELength = len;
#line 813
  memset((void *)ie, 0, 768UL);
#line 815
  memcpy((void *)ie, (void const   *)pbuf, (size_t )pbss_network->IELength);
#line 817
  if ((unsigned int )pbss_network->ifmode != 3U && (unsigned int )pbss_network->ifmode != 9U) {
#line 819
    return (0);
  } else {

  }
#line 821
  pbss_network->Rssi = 0L;
#line 823
  tmp___1 = myid(& padapter->eeprompriv);
#line 823
  memcpy((void *)(& pbss_network->MacAddress), (void const   *)tmp___1, 6UL);
#line 826
  p = rtw_get_ie23a(ie, 0, (int *)(& ie_len), (int )pbss_network->IELength);
#line 827
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
#line 828
    memset((void *)(& pbss_network->Ssid), 0, 33UL);
#line 829
    memcpy((void *)(& pbss_network->Ssid.ssid), (void const   *)p + 2U, (size_t )ie_len);
#line 830
    pbss_network->Ssid.ssid_len = (u8 )ie_len;
  } else {

  }
#line 834
  channel = 0U;
#line 835
  p = rtw_get_ie23a(ie, 3, (int *)(& ie_len), (int )pbss_network->IELength);
#line 837
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
#line 838
    channel = *(p + 2UL);
  } else {

  }
#line 840
  pbss_network->DSConfig = (u32 )channel;
#line 842
  memset((void *)(& supportRate), 0, 16UL);
#line 844
  p = rtw_get_ie23a(ie, 1, (int *)(& ie_len), (int )pbss_network->IELength);
#line 846
  if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
#line 847
    memcpy((void *)(& supportRate), (void const   *)p + 2U, (size_t )ie_len);
#line 848
    supportRateNum = (int )ie_len;
  } else {

  }
#line 852
  p = rtw_get_ie23a(ie, 50, (int *)(& ie_len), (int )pbss_network->IELength);
#line 854
  if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
#line 855
    memcpy((void *)(& supportRate) + (unsigned long )supportRateNum, (void const   *)p + 2U,
             (size_t )ie_len);
#line 856
    supportRateNum = (int )((uint )supportRateNum + ie_len);
  } else {

  }
#line 859
  tmp___2 = rtw_check_network_type23a((unsigned char *)(& supportRate), supportRateNum,
                                      (int )channel);
#line 859
  network_type = (u8 )tmp___2;
#line 862
  rtw_set_supported_rate23a((u8 *)(& pbss_network->SupportedRates), (uint )network_type);
#line 865
  p = rtw_get_ie23a(ie, 42, (int *)(& ie_len), (int )pbss_network->IELength);
#line 867
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
#line 868
    ERP_IE_handler23a(padapter, (u8 const   *)p);
  } else {

  }
#line 871
  if (((unsigned long )pbss_network->capability & 16UL) != 0UL) {
#line 872
    pbss_network->Privacy = 1U;
  } else {
#line 874
    pbss_network->Privacy = 0U;
  }
#line 876
  psecuritypriv->wpa_psk = 0U;
#line 879
  group_cipher = 0;
#line 879
  pairwise_cipher = 0;
#line 880
  psecuritypriv->wpa2_group_cipher = 0U;
#line 881
  psecuritypriv->wpa2_pairwise_cipher = 0U;
#line 882
  p = rtw_get_ie23a(ie, 48, (int *)(& ie_len), (int )pbss_network->IELength);
#line 884
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
#line 885
    tmp___3 = rtw_parse_wpa2_ie23a((u8 const   *)p, (int )(ie_len + 2U), & group_cipher,
                                   & pairwise_cipher, (int *)0);
#line 885
    if (tmp___3 == 1) {
#line 887
      psecuritypriv->dot11AuthAlgrthm = 2U;
#line 889
      psecuritypriv->dot8021xalg = 1U;
#line 890
      psecuritypriv->wpa_psk = psecuritypriv->wpa_psk | 2U;
#line 892
      psecuritypriv->wpa2_group_cipher = (unsigned int )group_cipher;
#line 893
      psecuritypriv->wpa2_pairwise_cipher = (unsigned int )pairwise_cipher;
    } else {

    }
  } else {

  }
#line 898
  ie_len = 0U;
#line 899
  group_cipher = 0;
#line 900
  pairwise_cipher = 0;
#line 901
  psecuritypriv->wpa_group_cipher = 0U;
#line 902
  psecuritypriv->wpa_pairwise_cipher = 0U;
#line 903
  p = ie;
  ldv_55882: 
#line 904
  p = rtw_get_ie23a(p, 221, (int *)(& ie_len), (int )((pbss_network->IELength - ie_len) - 2U));
#line 906
  if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
#line 906
    tmp___5 = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                     4UL);
#line 906
    if (tmp___5 == 0) {
#line 907
      tmp___4 = rtw_parse_wpa_ie23a((u8 const   *)p, (int )(ie_len + 2U), & group_cipher,
                                    & pairwise_cipher, (int *)0);
#line 907
      if (tmp___4 == 1) {
#line 909
        psecuritypriv->dot11AuthAlgrthm = 2U;
#line 912
        psecuritypriv->dot8021xalg = 1U;
#line 914
        psecuritypriv->wpa_psk = psecuritypriv->wpa_psk | 1U;
#line 916
        psecuritypriv->wpa_group_cipher = (unsigned int )group_cipher;
#line 917
        psecuritypriv->wpa_pairwise_cipher = (unsigned int )pairwise_cipher;
      } else {

      }
#line 919
      goto ldv_55881;
    } else {

    }
  } else {

  }
#line 922
  if ((unsigned long )p == (unsigned long )((u8 *)0U) || ie_len == 0U) {
#line 923
    goto ldv_55881;
  } else {

  }
#line 903
  p = p + (unsigned long )(ie_len + 2U);
#line 924
  goto ldv_55882;
  ldv_55881: 
#line 927
  ie_len = 0U;
#line 928
  pmlmepriv->qos_option = 0U;
#line 929
  if ((unsigned int )pregistrypriv->wmm_enable != 0U) {
#line 930
    p = ie;
    ldv_55884: 
#line 931
    p = rtw_get_ie23a(p, 221, (int *)(& ie_len), (int )((pbss_network->IELength - ie_len) - 2U));
#line 934
    if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
#line 934
      tmp___6 = memcmp((void const   *)p + 2U, (void const   *)(& WMM_PARA_IE), 6UL);
#line 934
      if (tmp___6 == 0) {
#line 935
        pmlmepriv->qos_option = 1U;
#line 937
        *(p + 8UL) = (u8 )((unsigned int )*(p + 8UL) | 128U);
#line 942
        *(p + 10UL) = (unsigned int )*(p + 10UL) & 239U;
#line 943
        *(p + 14UL) = (unsigned int )*(p + 14UL) & 239U;
#line 944
        *(p + 18UL) = (unsigned int )*(p + 18UL) & 239U;
#line 945
        *(p + 22UL) = (unsigned int )*(p + 22UL) & 239U;
#line 946
        goto ldv_55883;
      } else {

      }
    } else {

    }
#line 948
    if ((unsigned long )p == (unsigned long )((u8 *)0U) || ie_len == 0U) {
#line 949
      goto ldv_55883;
    } else {

    }
#line 930
    p = p + (unsigned long )(ie_len + 2U);
#line 950
    goto ldv_55884;
    ldv_55883: ;
  } else {

  }
#line 953
  p = rtw_get_ie23a(ie, 45, (int *)(& ie_len), (int )pbss_network->IELength);
#line 955
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
#line 958
    pht_cap = (struct ieee80211_ht_cap *)p + 2U;
#line 960
    pHT_caps_ie = p;
#line 962
    ht_cap = 1U;
#line 963
    network_type = (u8 )((unsigned int )network_type | 8U);
#line 965
    rf_type = rtl8723a_get_rf_type(padapter);
#line 967
    if (((unsigned long )psecuritypriv->wpa_pairwise_cipher & 16UL) != 0UL || ((unsigned long )psecuritypriv->wpa2_pairwise_cipher & 16UL) != 0UL) {
#line 969
      pht_cap->ampdu_params_info = (u8 )((unsigned int )pht_cap->ampdu_params_info | 28U);
    } else {
#line 971
      pht_cap->ampdu_params_info = pht_cap->ampdu_params_info;
    }
#line 974
    pht_cap->ampdu_params_info = (u8 )((unsigned int )pht_cap->ampdu_params_info | 3U);
#line 976
    if ((unsigned int )rf_type == 3U) {
#line 977
      pht_cap->mcs.rx_mask[0] = 255U;
#line 978
      pht_cap->mcs.rx_mask[1] = 0U;
    } else {

    }
#line 981
    memcpy((void *)(& pmlmepriv->htpriv.ht_cap), (void const   *)p + 2U, (size_t )ie_len);
  } else {

  }
#line 985
  p = rtw_get_ie23a(ie, 61, (int *)(& ie_len), (int )pbss_network->IELength);
#line 987
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
#line 988
    pHT_info_ie = p;
  } else {

  }
#line 990
  pmlmepriv->cur_network.network_type = (int )network_type;
#line 992
  pmlmepriv->htpriv.ht_option = 0;
#line 995
  if ((unsigned int )pregistrypriv->ht_enable != 0U && (unsigned int )ht_cap != 0U) {
#line 996
    pmlmepriv->htpriv.ht_option = 1;
#line 997
    pmlmepriv->qos_option = 1U;
#line 999
    if ((unsigned int )pregistrypriv->ampdu_enable == 1U) {
#line 1000
      pmlmepriv->htpriv.ampdu_enable = 1;
    } else {

    }
#line 1002
    HT_caps_handler23a(padapter, (u8 const   *)pHT_caps_ie);
#line 1004
    HT_info_handler23a(padapter, (u8 const   *)pHT_info_ie);
  } else {

  }
#line 1007
  pbss_network->Length = get_wlan_bssid_ex_sz(pbss_network);
#line 1010
  start_bss_network(padapter, (u8 *)pbss_network);
#line 1013
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pbss_network->MacAddress));
#line 1014
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1015
    psta = rtw_alloc_stainfo23a(& padapter->stapriv, (u8 const   *)(& pbss_network->MacAddress),
                                208U);
#line 1018
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1019
      return (0);
    } else {

    }
  } else {

  }
#line 1022
  psta->state = psta->state | 16U;
#line 1023
  rtw_indicate_connect23a(padapter);
#line 1026
  pmlmepriv->cur_network.join_res = 1;
#line 1028
  return (ret);
}
}
#line 1031 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
void rtw_set_macaddr_acl23a(struct rtw_adapter *padapter , int mode ) 
{ 
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;

  {
#line 1033
  pstapriv = & padapter->stapriv;
#line 1034
  pacl_list = & pstapriv->acl_list;
#line 1036
  if (GlobalDebugLevel23A > 3U) {
#line 1036
    printk("\016RTL8723AU: %s, mode =%d\n", "rtw_set_macaddr_acl23a", mode);
  } else {

  }
#line 1038
  pacl_list->mode = mode;
#line 1039
  return;
}
}
#line 1041 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
int rtw_acl_add_sta23a(struct rtw_adapter *padapter , u8 *addr ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  u8 added ;
  int i ;
  int ret ;
  struct rtw_wlan_acl_node *paclnode ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head *tmp___0 ;

  {
#line 1044
  added = 0U;
#line 1045
  ret = 0;
#line 1047
  pstapriv = & padapter->stapriv;
#line 1048
  pacl_list = & pstapriv->acl_list;
#line 1049
  pacl_node_q = & pacl_list->acl_node_q;
#line 1051
  if (GlobalDebugLevel23A > 3U) {
#line 1051
    printk("\016RTL8723AU: %s(acl_num =%d) =%pM\n", "rtw_acl_add_sta23a", pacl_list->num,
           addr);
  } else {

  }
#line 1053
  if (pacl_list->num > 15) {
#line 1054
    return (-1);
  } else {

  }
#line 1056
  spin_lock_bh(& pacl_node_q->lock);
#line 1058
  phead = get_list_head(pacl_node_q);
#line 1060
  plist = phead->next;
#line 1060
  goto ldv_55912;
  ldv_55911: 
#line 1061
  __mptr = (struct list_head  const  *)plist;
#line 1061
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
#line 1063
  tmp = memcmp((void const   *)(& paclnode->addr), (void const   *)addr, 6UL);
#line 1063
  if (tmp == 0) {
#line 1064
    if ((unsigned int )paclnode->valid == 1U) {
#line 1065
      added = 1U;
#line 1066
      if (GlobalDebugLevel23A > 3U) {
#line 1066
        printk("\016RTL8723AU: %s, sta has been added\n", "rtw_acl_add_sta23a");
      } else {

      }
#line 1067
      goto ldv_55910;
    } else {

    }
  } else {

  }
#line 1060
  plist = plist->next;
  ldv_55912: ;
#line 1060
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1062
    goto ldv_55911;
  } else {

  }
  ldv_55910: 
#line 1072
  spin_unlock_bh(& pacl_node_q->lock);
#line 1074
  if ((unsigned int )added != 0U) {
#line 1075
    return (ret);
  } else {

  }
#line 1077
  spin_lock_bh(& pacl_node_q->lock);
#line 1079
  i = 0;
#line 1079
  goto ldv_55915;
  ldv_55914: 
#line 1080
  paclnode = (struct rtw_wlan_acl_node *)(& pacl_list->aclnode) + (unsigned long )i;
#line 1082
  if ((unsigned int )paclnode->valid == 0U) {
#line 1083
    INIT_LIST_HEAD(& paclnode->list);
#line 1085
    memcpy((void *)(& paclnode->addr), (void const   *)addr, 6UL);
#line 1087
    paclnode->valid = 1U;
#line 1089
    tmp___0 = get_list_head(pacl_node_q);
#line 1089
    list_add_tail(& paclnode->list, tmp___0);
#line 1091
    pacl_list->num = pacl_list->num + 1;
#line 1093
    goto ldv_55913;
  } else {

  }
#line 1079
  i = i + 1;
  ldv_55915: ;
#line 1079
  if (i <= 15) {
#line 1081
    goto ldv_55914;
  } else {

  }
  ldv_55913: ;
#line 1097
  if (GlobalDebugLevel23A > 3U) {
#line 1097
    printk("\016RTL8723AU: %s, acl_num =%d\n", "rtw_acl_add_sta23a", pacl_list->num);
  } else {

  }
#line 1099
  spin_unlock_bh(& pacl_node_q->lock);
#line 1100
  return (ret);
}
}
#line 1103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
int rtw_acl_remove_sta23a(struct rtw_adapter *padapter , u8 *addr ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct rtw_wlan_acl_node *paclnode ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 1107
  pstapriv = & padapter->stapriv;
#line 1108
  pacl_list = & pstapriv->acl_list;
#line 1109
  pacl_node_q = & pacl_list->acl_node_q;
#line 1111
  if (GlobalDebugLevel23A > 3U) {
#line 1111
    printk("\016RTL8723AU: %s(acl_num =%d) = %pM\n", "rtw_acl_remove_sta23a", pacl_list->num,
           addr);
  } else {

  }
#line 1113
  spin_lock_bh(& pacl_node_q->lock);
#line 1115
  phead = get_list_head(pacl_node_q);
#line 1117
  plist = phead->next;
#line 1117
  ptmp = plist->next;
#line 1117
  goto ldv_55931;
  ldv_55930: 
#line 1118
  __mptr = (struct list_head  const  *)plist;
#line 1118
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
#line 1120
  tmp = memcmp((void const   *)(& paclnode->addr), (void const   *)addr, 6UL);
#line 1120
  if (tmp == 0) {
#line 1121
    if ((unsigned int )paclnode->valid != 0U) {
#line 1122
      paclnode->valid = 0U;
#line 1124
      list_del_init(& paclnode->list);
#line 1126
      pacl_list->num = pacl_list->num - 1;
    } else {

    }
  } else {

  }
#line 1117
  plist = ptmp;
#line 1117
  ptmp = plist->next;
  ldv_55931: ;
#line 1117
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1119
    goto ldv_55930;
  } else {

  }
#line 1131
  spin_unlock_bh(& pacl_node_q->lock);
#line 1133
  if (GlobalDebugLevel23A > 3U) {
#line 1133
    printk("\016RTL8723AU: %s, acl_num =%d\n", "rtw_acl_remove_sta23a", pacl_list->num);
  } else {

  }
#line 1135
  return (0);
}
}
#line 1138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static void update_bcn_fixed_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1140
  if (GlobalDebugLevel23A > 3U) {
#line 1140
    printk("\016RTL8723AU: %s\n", "update_bcn_fixed_ie");
  } else {

  }
#line 1141
  return;
}
}
#line 1143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static void update_bcn_erpinfo_ie(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  unsigned char *p ;
  unsigned char *ie ;
  u32 len ;
  u8 *tmp ;

  {
#line 1145
  pmlmepriv = & padapter->mlmepriv;
#line 1146
  pmlmeext = & padapter->mlmeextpriv;
#line 1147
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1148
  pnetwork = & pmlmeinfo->network;
#line 1149
  ie = (unsigned char *)(& pnetwork->IEs);
#line 1150
  len = 0U;
#line 1152
  if (GlobalDebugLevel23A > 3U) {
#line 1152
    printk("\016RTL8723AU: %s, ERP_enable =%d\n", "update_bcn_erpinfo_ie", (int )pmlmeinfo->ERP_enable);
  } else {

  }
#line 1154
  if ((unsigned int )pmlmeinfo->ERP_enable == 0U) {
#line 1155
    return;
  } else {

  }
#line 1158
  tmp = rtw_get_ie23a(ie, 42, (int *)(& len), (int )pnetwork->IELength);
#line 1158
  p = tmp;
#line 1159
  if ((unsigned long )p != (unsigned long )((unsigned char *)0U) && len != 0U) {
#line 1160
    if (pmlmepriv->num_sta_non_erp == 1) {
#line 1161
      *(p + 2UL) = (unsigned int )*(p + 2UL) | 3U;
    } else {
#line 1164
      *(p + 2UL) = (unsigned int )*(p + 2UL) & 252U;
    }
#line 1167
    if (pmlmepriv->num_sta_no_short_preamble > 0) {
#line 1168
      *(p + 2UL) = (unsigned int )*(p + 2UL) | 4U;
    } else {
#line 1170
      *(p + 2UL) = (unsigned int )*(p + 2UL) & 251U;
    }
#line 1172
    ERP_IE_handler23a(padapter, (u8 const   *)p);
  } else {

  }
#line 1174
  return;
}
}
#line 1176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static void update_bcn_htcap_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1178
  if (GlobalDebugLevel23A > 3U) {
#line 1178
    printk("\016RTL8723AU: %s\n", "update_bcn_htcap_ie");
  } else {

  }
#line 1179
  return;
}
}
#line 1181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static void update_bcn_htinfo_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1183
  if (GlobalDebugLevel23A > 3U) {
#line 1183
    printk("\016RTL8723AU: %s\n", "update_bcn_htinfo_ie");
  } else {

  }
#line 1184
  return;
}
}
#line 1186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static void update_bcn_rsn_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1188
  if (GlobalDebugLevel23A > 3U) {
#line 1188
    printk("\016RTL8723AU: %s\n", "update_bcn_rsn_ie");
  } else {

  }
#line 1189
  return;
}
}
#line 1191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static void update_bcn_wpa_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1193
  if (GlobalDebugLevel23A > 3U) {
#line 1193
    printk("\016RTL8723AU: %s\n", "update_bcn_wpa_ie");
  } else {

  }
#line 1194
  return;
}
}
#line 1196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static void update_bcn_wmm_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1198
  if (GlobalDebugLevel23A > 3U) {
#line 1198
    printk("\016RTL8723AU: %s\n", "update_bcn_wmm_ie");
  } else {

  }
#line 1199
  return;
}
}
#line 1201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static void update_bcn_wps_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1203
  if (GlobalDebugLevel23A > 3U) {
#line 1203
    printk("\016RTL8723AU: %s\n", "update_bcn_wps_ie");
  } else {

  }
#line 1204
  return;
}
}
#line 1206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static void update_bcn_p2p_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1208
  return;
}
}
#line 1210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static void update_bcn_vendor_spec_ie(struct rtw_adapter *padapter , u8 *oui ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1212
  if (GlobalDebugLevel23A > 3U) {
#line 1212
    printk("\016RTL8723AU: %s\n", "update_bcn_vendor_spec_ie");
  } else {

  }
#line 1214
  tmp___2 = memcmp((void const   *)(& RTW_WPA_OUI23A_TYPE), (void const   *)oui, 4UL);
#line 1214
  if (tmp___2 == 0) {
#line 1215
    update_bcn_wpa_ie(padapter);
  } else {
#line 1216
    tmp___1 = memcmp((void const   *)(& WMM_OUI23A), (void const   *)oui, 4UL);
#line 1216
    if (tmp___1 == 0) {
#line 1217
      update_bcn_wmm_ie(padapter);
    } else {
#line 1218
      tmp___0 = memcmp((void const   *)(& WPS_OUI23A), (void const   *)oui, 4UL);
#line 1218
      if (tmp___0 == 0) {
#line 1219
        update_bcn_wps_ie(padapter);
      } else {
#line 1220
        tmp = memcmp((void const   *)(& P2P_OUI23A), (void const   *)oui, 4UL);
#line 1220
        if (tmp == 0) {
#line 1221
          update_bcn_p2p_ie(padapter);
        } else
#line 1223
        if (GlobalDebugLevel23A > 3U) {
#line 1223
          printk("\016RTL8723AU: unknown OUI type!\n");
        } else {

        }
      }
    }
  }
#line 1224
  return;
}
}
#line 1226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
void update_beacon23a(struct rtw_adapter *padapter , u8 ie_id , u8 *oui , u8 tx ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;

  {
#line 1234
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 1235
    return;
  } else {

  }
#line 1237
  pmlmepriv = & padapter->mlmepriv;
#line 1238
  pmlmeext = & padapter->mlmeextpriv;
#line 1241
  if ((unsigned int )pmlmeext->bstart_bss == 0U) {
#line 1242
    return;
  } else {

  }
#line 1244
  spin_lock_bh(& pmlmepriv->bcn_update_lock);
#line 1246
  switch ((int )ie_id) {
  case 255: 
#line 1249
  update_bcn_fixed_ie(padapter);
#line 1250
  goto ldv_55989;
  case 5: 
#line 1253
  update_BCNTIM(padapter);
#line 1254
  goto ldv_55989;
  case 42: 
#line 1257
  update_bcn_erpinfo_ie(padapter);
#line 1258
  goto ldv_55989;
  case 45: 
#line 1261
  update_bcn_htcap_ie(padapter);
#line 1262
  goto ldv_55989;
  case 48: 
#line 1265
  update_bcn_rsn_ie(padapter);
#line 1266
  goto ldv_55989;
  case 61: 
#line 1269
  update_bcn_htinfo_ie(padapter);
#line 1270
  goto ldv_55989;
  case 221: 
#line 1273
  update_bcn_vendor_spec_ie(padapter, oui);
#line 1274
  goto ldv_55989;
  default: ;
#line 1277
  goto ldv_55989;
  }
  ldv_55989: 
#line 1280
  pmlmepriv->update_bcn = 1U;
#line 1282
  spin_unlock_bh(& pmlmepriv->bcn_update_lock);
#line 1284
  if ((unsigned int )tx != 0U) {
#line 1285
    set_tx_beacon_cmd23a(padapter);
  } else {

  }
#line 1286
  return;
}
}
#line 1300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
static int rtw_ht_operation_update(struct rtw_adapter *padapter ) 
{ 
  u16 cur_op_mode ;
  u16 new_op_mode ;
  int op_mode_changes ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv_ap ;

  {
#line 1303
  op_mode_changes = 0;
#line 1304
  pmlmepriv = & padapter->mlmepriv;
#line 1305
  phtpriv_ap = & pmlmepriv->htpriv;
#line 1307
  if ((int )pmlmepriv->htpriv.ht_option) {
#line 1308
    return (0);
  } else {

  }
#line 1313
  if (GlobalDebugLevel23A > 3U) {
#line 1313
    printk("\016RTL8723AU: %s current operation mode = 0x%X\n", "rtw_ht_operation_update",
           (int )pmlmepriv->ht_op_mode);
  } else {

  }
#line 1316
  if (((int )pmlmepriv->ht_op_mode & 4) == 0 && pmlmepriv->num_sta_ht_no_gf != 0) {
#line 1318
    pmlmepriv->ht_op_mode = (u16 )((unsigned int )pmlmepriv->ht_op_mode | 4U);
#line 1320
    op_mode_changes = op_mode_changes + 1;
  } else
#line 1321
  if (((int )pmlmepriv->ht_op_mode & 4) != 0 && pmlmepriv->num_sta_ht_no_gf == 0) {
#line 1324
    pmlmepriv->ht_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 65531U;
#line 1326
    op_mode_changes = op_mode_changes + 1;
  } else {

  }
#line 1329
  if (((int )pmlmepriv->ht_op_mode & 16) == 0 && (pmlmepriv->num_sta_no_ht != 0 || pmlmepriv->olbc_ht != 0)) {
#line 1331
    pmlmepriv->ht_op_mode = (u16 )((unsigned int )pmlmepriv->ht_op_mode | 16U);
#line 1332
    op_mode_changes = op_mode_changes + 1;
  } else
#line 1333
  if (((int )pmlmepriv->ht_op_mode & 16) != 0 && (pmlmepriv->num_sta_no_ht == 0 && pmlmepriv->olbc_ht == 0)) {
#line 1336
    pmlmepriv->ht_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 65519U;
#line 1338
    op_mode_changes = op_mode_changes + 1;
  } else {

  }
#line 1345
  if (pmlmepriv->num_sta_no_ht != 0 || ((int )pmlmepriv->ht_op_mode & 4) != 0) {
#line 1347
    new_op_mode = 3U;
  } else
#line 1348
  if (((int )phtpriv_ap->ht_cap.cap_info & 2) != 0 && pmlmepriv->num_sta_ht_20mhz != 0) {
#line 1351
    new_op_mode = 2U;
  } else
#line 1352
  if (pmlmepriv->olbc_ht != 0) {
#line 1353
    new_op_mode = 1U;
  } else {
#line 1355
    new_op_mode = 0U;
  }
#line 1357
  cur_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 3U;
#line 1358
  if ((int )cur_op_mode != (int )new_op_mode) {
#line 1359
    pmlmepriv->ht_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 65532U;
#line 1360
    pmlmepriv->ht_op_mode = (u16 )((int )pmlmepriv->ht_op_mode | (int )new_op_mode);
#line 1361
    op_mode_changes = op_mode_changes + 1;
  } else {

  }
#line 1364
  if (GlobalDebugLevel23A > 3U) {
#line 1364
    printk("\016RTL8723AU: %s new operation mode = 0x%X changes =%d\n", "rtw_ht_operation_update",
           (int )pmlmepriv->ht_op_mode, op_mode_changes);
  } else {

  }
#line 1367
  return (op_mode_changes);
}
}
#line 1370 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
void associated_clients_update23a(struct rtw_adapter *padapter , u8 updated ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct list_head  const  *__mptr ;

  {
#line 1373
  if ((unsigned int )updated == 1U) {
#line 1376
    pstapriv = & padapter->stapriv;
#line 1378
    spin_lock_bh(& pstapriv->asoc_list_lock);
#line 1380
    phead = & pstapriv->asoc_list;
#line 1382
    plist = phead->next;
#line 1382
    ptmp = plist->next;
#line 1382
    goto ldv_56018;
    ldv_56017: 
#line 1383
    __mptr = (struct list_head  const  *)plist;
#line 1383
    psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
#line 1385
    VCS_update23a(padapter, psta);
#line 1382
    plist = ptmp;
#line 1382
    ptmp = plist->next;
    ldv_56018: ;
#line 1382
    if ((unsigned long )plist != (unsigned long )phead) {
#line 1384
      goto ldv_56017;
    } else {

    }
#line 1388
    spin_unlock_bh(& pstapriv->asoc_list_lock);
  } else {

  }
#line 1390
  return;
}
}
#line 1393 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
void bss_cap_update_on_sta_join23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 beacon_updated ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  u16 ht_capab ;
  int tmp ;

  {
#line 1395
  beacon_updated = 0U;
#line 1396
  pmlmepriv = & padapter->mlmepriv;
#line 1397
  pmlmeext = & padapter->mlmeextpriv;
#line 1399
  if (((unsigned long )psta->flags & 128UL) == 0UL) {
#line 1400
    if ((unsigned int )psta->no_short_preamble_set == 0U) {
#line 1401
      psta->no_short_preamble_set = 1U;
#line 1403
      pmlmepriv->num_sta_no_short_preamble = pmlmepriv->num_sta_no_short_preamble + 1;
#line 1405
      if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_preamble == 1) {
#line 1407
        beacon_updated = 1U;
#line 1408
        update_beacon23a(padapter, 255, (u8 *)0U, 1);
      } else {

      }
    } else {

    }
  } else
#line 1413
  if ((unsigned int )psta->no_short_preamble_set != 0U) {
#line 1414
    psta->no_short_preamble_set = 0U;
#line 1416
    pmlmepriv->num_sta_no_short_preamble = pmlmepriv->num_sta_no_short_preamble - 1;
#line 1418
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_preamble == 0) {
#line 1420
      beacon_updated = 1U;
#line 1421
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
#line 1427
  if (psta->flags < 0) {
#line 1428
    if ((unsigned int )psta->nonerp_set == 0U) {
#line 1429
      psta->nonerp_set = 1U;
#line 1431
      pmlmepriv->num_sta_non_erp = pmlmepriv->num_sta_non_erp + 1;
#line 1433
      if (pmlmepriv->num_sta_non_erp == 1) {
#line 1434
        beacon_updated = 1U;
#line 1435
        update_beacon23a(padapter, 42, (u8 *)0U, 1);
      } else {

      }
    } else {

    }
  } else
#line 1440
  if ((unsigned int )psta->nonerp_set != 0U) {
#line 1441
    psta->nonerp_set = 0U;
#line 1443
    pmlmepriv->num_sta_non_erp = pmlmepriv->num_sta_non_erp - 1;
#line 1445
    if (pmlmepriv->num_sta_non_erp == 0) {
#line 1446
      beacon_updated = 1U;
#line 1447
      update_beacon23a(padapter, 42, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
#line 1453
  if (((int )psta->capability & 1024) == 0) {
#line 1454
    if ((unsigned int )psta->no_short_slot_time_set == 0U) {
#line 1455
      psta->no_short_slot_time_set = 1U;
#line 1457
      pmlmepriv->num_sta_no_short_slot_time = pmlmepriv->num_sta_no_short_slot_time + 1;
#line 1459
      if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_slot_time == 1) {
#line 1461
        beacon_updated = 1U;
#line 1462
        update_beacon23a(padapter, 255, (u8 *)0U, 1);
      } else {

      }
    } else {

    }
  } else
#line 1467
  if ((unsigned int )psta->no_short_slot_time_set != 0U) {
#line 1468
    psta->no_short_slot_time_set = 0U;
#line 1470
    pmlmepriv->num_sta_no_short_slot_time = pmlmepriv->num_sta_no_short_slot_time - 1;
#line 1472
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_slot_time == 0) {
#line 1474
      beacon_updated = 1U;
#line 1475
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
#line 1480
  if (((unsigned long )psta->flags & 2048UL) != 0UL) {
#line 1481
    ht_capab = psta->htpriv.ht_cap.cap_info;
#line 1483
    if (GlobalDebugLevel23A > 3U) {
#line 1483
      printk("\016RTL8723AU: HT: STA %pM HT Capabilities Info: 0x%04x\n", (u8 *)(& psta->hwaddr),
             (int )ht_capab);
    } else {

    }
#line 1486
    if ((unsigned int )psta->no_ht_set != 0U) {
#line 1487
      psta->no_ht_set = 0U;
#line 1488
      pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht - 1;
    } else {

    }
#line 1491
    if (((int )ht_capab & 16) == 0) {
#line 1492
      if ((unsigned int )psta->no_ht_gf_set == 0U) {
#line 1493
        psta->no_ht_gf_set = 1U;
#line 1494
        pmlmepriv->num_sta_ht_no_gf = pmlmepriv->num_sta_ht_no_gf + 1;
      } else {

      }
#line 1496
      if (GlobalDebugLevel23A > 3U) {
#line 1496
        printk("\016RTL8723AU: %s STA %pM - no greenfield, num of non-gf stations %d\n",
               "bss_cap_update_on_sta_join23a", (u8 *)(& psta->hwaddr), pmlmepriv->num_sta_ht_no_gf);
      } else {

      }
    } else {

    }
#line 1501
    if (((int )ht_capab & 2) == 0) {
#line 1502
      if ((unsigned int )psta->ht_20mhz_set == 0U) {
#line 1503
        psta->ht_20mhz_set = 1U;
#line 1504
        pmlmepriv->num_sta_ht_20mhz = pmlmepriv->num_sta_ht_20mhz + 1;
      } else {

      }
#line 1506
      if (GlobalDebugLevel23A > 3U) {
#line 1506
        printk("\016RTL8723AU: %s STA %pM - 20 MHz HT, num of 20MHz HT STAs %d\n",
               "bss_cap_update_on_sta_join23a", (u8 *)(& psta->hwaddr), pmlmepriv->num_sta_ht_20mhz);
      } else {

      }
    } else {

    }
  } else {
#line 1512
    if ((unsigned int )psta->no_ht_set == 0U) {
#line 1513
      psta->no_ht_set = 1U;
#line 1514
      pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht + 1;
    } else {

    }
#line 1516
    if ((int )pmlmepriv->htpriv.ht_option) {
#line 1517
      if (GlobalDebugLevel23A > 3U) {
#line 1517
        printk("\016RTL8723AU: %s STA %pM - no HT, num of non-HT stations %d\n", "bss_cap_update_on_sta_join23a",
               (u8 *)(& psta->hwaddr), pmlmepriv->num_sta_no_ht);
      } else {

      }
    } else {

    }
  }
#line 1523
  tmp = rtw_ht_operation_update(padapter);
#line 1523
  if (tmp > 0) {
#line 1524
    update_beacon23a(padapter, 45, (u8 *)0U, 0);
#line 1525
    update_beacon23a(padapter, 61, (u8 *)0U, 1);
  } else {

  }
#line 1529
  associated_clients_update23a(padapter, (int )beacon_updated);
#line 1531
  if (GlobalDebugLevel23A > 3U) {
#line 1531
    printk("\016RTL8723AU: %s, updated =%d\n", "bss_cap_update_on_sta_join23a", (int )beacon_updated);
  } else {

  }
#line 1532
  return;
}
}
#line 1534 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
u8 bss_cap_update_on_sta_leave23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 beacon_updated ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  int tmp ;

  {
#line 1536
  beacon_updated = 0U;
#line 1537
  pmlmepriv = & padapter->mlmepriv;
#line 1538
  pmlmeext = & padapter->mlmeextpriv;
#line 1540
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1541
    return (beacon_updated);
  } else {

  }
#line 1543
  if ((unsigned int )psta->no_short_preamble_set != 0U) {
#line 1544
    psta->no_short_preamble_set = 0U;
#line 1545
    pmlmepriv->num_sta_no_short_preamble = pmlmepriv->num_sta_no_short_preamble - 1;
#line 1546
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_preamble == 0) {
#line 1548
      beacon_updated = 1U;
#line 1549
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
#line 1553
  if ((unsigned int )psta->nonerp_set != 0U) {
#line 1554
    psta->nonerp_set = 0U;
#line 1555
    pmlmepriv->num_sta_non_erp = pmlmepriv->num_sta_non_erp - 1;
#line 1556
    if (pmlmepriv->num_sta_non_erp == 0) {
#line 1557
      beacon_updated = 1U;
#line 1558
      update_beacon23a(padapter, 42, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
#line 1563
  if ((unsigned int )psta->no_short_slot_time_set != 0U) {
#line 1564
    psta->no_short_slot_time_set = 0U;
#line 1565
    pmlmepriv->num_sta_no_short_slot_time = pmlmepriv->num_sta_no_short_slot_time - 1;
#line 1566
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_slot_time == 0) {
#line 1568
      beacon_updated = 1U;
#line 1569
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
#line 1573
  if ((unsigned int )psta->no_ht_gf_set != 0U) {
#line 1574
    psta->no_ht_gf_set = 0U;
#line 1575
    pmlmepriv->num_sta_ht_no_gf = pmlmepriv->num_sta_ht_no_gf - 1;
  } else {

  }
#line 1578
  if ((unsigned int )psta->no_ht_set != 0U) {
#line 1579
    psta->no_ht_set = 0U;
#line 1580
    pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht - 1;
  } else {

  }
#line 1583
  if ((unsigned int )psta->ht_20mhz_set != 0U) {
#line 1584
    psta->ht_20mhz_set = 0U;
#line 1585
    pmlmepriv->num_sta_ht_20mhz = pmlmepriv->num_sta_ht_20mhz - 1;
  } else {

  }
#line 1588
  tmp = rtw_ht_operation_update(padapter);
#line 1588
  if (tmp > 0) {
#line 1589
    update_beacon23a(padapter, 45, (u8 *)0U, 0);
#line 1590
    update_beacon23a(padapter, 61, (u8 *)0U, 1);
  } else {

  }
#line 1595
  if (GlobalDebugLevel23A > 3U) {
#line 1595
    printk("\016RTL8723AU: %s, updated =%d\n", "bss_cap_update_on_sta_leave23a", (int )beacon_updated);
  } else {

  }
#line 1597
  return (beacon_updated);
}
}
#line 1600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
u8 ap_free_sta23a(struct rtw_adapter *padapter , struct sta_info *psta , bool active ,
                  u16 reason ) 
{ 
  struct sta_priv *pstapriv ;
  u8 beacon_updated ;

  {
#line 1602
  pstapriv = & padapter->stapriv;
#line 1603
  beacon_updated = 0U;
#line 1605
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1606
    return (beacon_updated);
  } else {

  }
#line 1608
  if ((int )active) {
#line 1610
    send_delba23a(padapter, 0, (u8 *)(& psta->hwaddr));
#line 1613
    send_delba23a(padapter, 1, (u8 *)(& psta->hwaddr));
#line 1615
    issue_deauth23a(padapter, (unsigned char *)(& psta->hwaddr), (int )reason);
  } else {

  }
#line 1618
  psta->htpriv.agg_enable_bitmap = 0U;
#line 1619
  psta->htpriv.candidate_tid_bitmap = 0U;
#line 1625
  rtw_clearstakey_cmd23a(padapter, (u8 *)psta, (int )((unsigned int )((unsigned char )psta->mac_id) + 3U),
                         1);
#line 1628
  spin_lock_bh(& psta->lock);
#line 1629
  psta->state = psta->state & 4294967294U;
#line 1630
  spin_unlock_bh(& psta->lock);
#line 1632
  rtw_cfg80211_indicate_sta_disassoc(padapter, (unsigned char *)(& psta->hwaddr),
                                     (int )reason);
#line 1634
  report_del_sta_event23a(padapter, (unsigned char *)(& psta->hwaddr), (int )reason);
#line 1636
  beacon_updated = bss_cap_update_on_sta_leave23a(padapter, psta);
#line 1638
  spin_lock_bh(& pstapriv->sta_hash_lock);
#line 1639
  rtw_free_stainfo23a(padapter, psta);
#line 1640
  spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 1642
  return (beacon_updated);
}
}
#line 1645 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
int rtw_ap_inform_ch_switch23a(struct rtw_adapter *padapter , u8 new_ch , u8 ch_offset ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 bc_addr___0[6U] ;
  struct list_head  const  *__mptr ;

  {
#line 1648
  psta = (struct sta_info *)0;
#line 1649
  pstapriv = & padapter->stapriv;
#line 1650
  pmlmeext = & padapter->mlmeextpriv;
#line 1651
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1652
  bc_addr___0[0] = 255U;
#line 1652
  bc_addr___0[1] = 255U;
#line 1652
  bc_addr___0[2] = 255U;
#line 1652
  bc_addr___0[3] = 255U;
#line 1652
  bc_addr___0[4] = 255U;
#line 1652
  bc_addr___0[5] = 255U;
#line 1654
  if ((pmlmeinfo->state & 3U) != 3U) {
#line 1655
    return (0);
  } else {

  }
#line 1657
  if (GlobalDebugLevel23A > 3U) {
#line 1657
    printk("\016RTL8723AU: %s(%s): with ch:%u, offset:%u\n", "rtw_ap_inform_ch_switch23a",
           (char *)(& (padapter->pnetdev)->name), (int )new_ch, (int )ch_offset);
  } else {

  }
#line 1660
  spin_lock_bh(& pstapriv->asoc_list_lock);
#line 1661
  phead = & pstapriv->asoc_list;
#line 1663
  plist = phead->next;
#line 1663
  goto ldv_56061;
  ldv_56060: 
#line 1664
  __mptr = (struct list_head  const  *)plist;
#line 1664
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
#line 1666
  issue_action_spct_ch_switch23a(padapter, (u8 *)(& psta->hwaddr), (int )new_ch, (int )ch_offset);
#line 1667
  psta->expire_to = 5U < pstapriv->expire_to * 2U ? 5U : pstapriv->expire_to * 2U;
#line 1663
  plist = plist->next;
  ldv_56061: ;
#line 1663
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1665
    goto ldv_56060;
  } else {

  }
#line 1669
  spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 1671
  issue_action_spct_ch_switch23a(padapter, (u8 *)(& bc_addr___0), (int )new_ch, (int )ch_offset);
#line 1673
  return (0);
}
}
#line 1676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
int rtw_sta_flush23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 bc_addr___0[6U] ;
  u8 chk_alive_num ;
  struct sta_info *chk_alive_list[32U] ;
  int i ;
  struct list_head  const  *__mptr ;
  u8 tmp ;

  {
#line 1680
  pstapriv = & padapter->stapriv;
#line 1681
  pmlmeext = & padapter->mlmeextpriv;
#line 1682
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1683
  bc_addr___0[0] = 255U;
#line 1683
  bc_addr___0[1] = 255U;
#line 1683
  bc_addr___0[2] = 255U;
#line 1683
  bc_addr___0[3] = 255U;
#line 1683
  bc_addr___0[4] = 255U;
#line 1683
  bc_addr___0[5] = 255U;
#line 1684
  chk_alive_num = 0U;
#line 1688
  if (GlobalDebugLevel23A > 3U) {
#line 1688
    printk("\016RTL8723AU: %s(%s)\n", "rtw_sta_flush23a", (char *)(& (padapter->pnetdev)->name));
  } else {

  }
#line 1690
  if ((pmlmeinfo->state & 3U) != 3U) {
#line 1691
    return (0);
  } else {

  }
#line 1693
  spin_lock_bh(& pstapriv->asoc_list_lock);
#line 1694
  phead = & pstapriv->asoc_list;
#line 1696
  plist = phead->next;
#line 1696
  ptmp = plist->next;
#line 1696
  goto ldv_56081;
  ldv_56080: 
#line 1697
  __mptr = (struct list_head  const  *)plist;
#line 1697
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
#line 1700
  list_del_init(& psta->asoc_list);
#line 1701
  pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
#line 1704
  tmp = chk_alive_num;
#line 1704
  chk_alive_num = (u8 )((int )chk_alive_num + 1);
#line 1704
  chk_alive_list[(int )tmp] = psta;
#line 1696
  plist = ptmp;
#line 1696
  ptmp = plist->next;
  ldv_56081: ;
#line 1696
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1698
    goto ldv_56080;
  } else {

  }
#line 1706
  spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 1709
  i = 0;
#line 1709
  goto ldv_56084;
  ldv_56083: 
#line 1710
  ap_free_sta23a(padapter, chk_alive_list[i], 1, 3);
#line 1709
  i = i + 1;
  ldv_56084: ;
#line 1709
  if ((int )chk_alive_num > i) {
#line 1711
    goto ldv_56083;
  } else {

  }
#line 1713
  issue_deauth23a(padapter, (unsigned char *)(& bc_addr___0), 3);
#line 1715
  associated_clients_update23a(padapter, 1);
#line 1717
  return (0);
}
}
#line 1721 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
void sta_info_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  int flags ;
  struct mlme_priv *pmlmepriv ;

  {
#line 1723
  flags = psta->flags;
#line 1724
  pmlmepriv = & padapter->mlmepriv;
#line 1727
  if ((flags & 512) != 0) {
#line 1728
    psta->qos_option = 1U;
  } else {
#line 1730
    psta->qos_option = 0U;
  }
#line 1732
  if (pmlmepriv->qos_option == 0U) {
#line 1733
    psta->qos_option = 0U;
  } else {

  }
#line 1736
  if ((flags & 2048) != 0) {
#line 1737
    psta->htpriv.ht_option = 1;
#line 1738
    psta->qos_option = 1U;
  } else {
#line 1740
    psta->htpriv.ht_option = 0;
  }
#line 1743
  if (! pmlmepriv->htpriv.ht_option) {
#line 1744
    psta->htpriv.ht_option = 0;
  } else {

  }
#line 1746
  update_sta_info23a_apmode23a(padapter, psta);
#line 1747
  return;
}
}
#line 1750 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
void ap_sta_info_defer_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 


  {
#line 1752
  if ((int )psta->state & 1) {
#line 1754
    add_RATid23a(padapter, psta, 0);
  } else {

  }
#line 1755
  return;
}
}
#line 1759 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
void rtw_ap_restore_network(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *mlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct security_priv *psecuritypriv ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  u8 chk_alive_num ;
  struct sta_info *chk_alive_list[32U] ;
  int i ;
  struct list_head  const  *__mptr ;
  u8 tmp ;

  {
#line 1761
  mlmepriv = & padapter->mlmepriv;
#line 1762
  pmlmeext = & padapter->mlmeextpriv;
#line 1763
  pstapriv = & padapter->stapriv;
#line 1765
  psecuritypriv = & padapter->securitypriv;
#line 1767
  chk_alive_num = 0U;
#line 1771
  rtw_setopmode_cmd23a(padapter, 3);
#line 1773
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
#line 1775
  start_bss_network(padapter, (u8 *)(& mlmepriv->cur_network.network));
#line 1777
  if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027074U || padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
#line 1782
    rtw_set_key23a(padapter, psecuritypriv, (int )psecuritypriv->dot118021XGrpKeyid,
                   0);
  } else {

  }
#line 1787
  if (padapter->securitypriv.dot11PrivacyAlgrthm != 1027074U && padapter->securitypriv.dot11PrivacyAlgrthm != 1027076U) {
#line 1791
    return;
  } else {

  }
#line 1794
  spin_lock_bh(& pstapriv->asoc_list_lock);
#line 1796
  phead = & pstapriv->asoc_list;
#line 1798
  plist = phead->next;
#line 1798
  ptmp = plist->next;
#line 1798
  goto ldv_56113;
  ldv_56112: 
#line 1799
  __mptr = (struct list_head  const  *)plist;
#line 1799
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
#line 1801
  tmp = chk_alive_num;
#line 1801
  chk_alive_num = (u8 )((int )chk_alive_num + 1);
#line 1801
  chk_alive_list[(int )tmp] = psta;
#line 1798
  plist = ptmp;
#line 1798
  ptmp = plist->next;
  ldv_56113: ;
#line 1798
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1800
    goto ldv_56112;
  } else {

  }
#line 1804
  spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 1806
  i = 0;
#line 1806
  goto ldv_56116;
  ldv_56115: 
#line 1807
  psta = chk_alive_list[i];
#line 1809
  if ((int )psta->state & 1) {
#line 1810
    Update_RA_Entry23a(padapter, psta);
#line 1812
    rtw_setstakey_cmd23a(padapter, (u8 *)psta, 1);
  } else {

  }
#line 1806
  i = i + 1;
  ldv_56116: ;
#line 1806
  if ((int )chk_alive_num > i) {
#line 1808
    goto ldv_56115;
  } else {

  }

#line 1813
  return;
}
}
#line 1817 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
void start_ap_mode23a(struct rtw_adapter *padapter ) 
{ 
  int i ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct wlan_acl_pool *pacl_list ;

  {
#line 1820
  pmlmepriv = & padapter->mlmepriv;
#line 1821
  pstapriv = & padapter->stapriv;
#line 1822
  pmlmeext = & padapter->mlmeextpriv;
#line 1823
  pacl_list = & pstapriv->acl_list;
#line 1825
  pmlmepriv->update_bcn = 0U;
#line 1828
  pmlmeext->bstart_bss = 0U;
#line 1830
  pmlmepriv->num_sta_non_erp = 0;
#line 1832
  pmlmepriv->num_sta_no_short_slot_time = 0;
#line 1834
  pmlmepriv->num_sta_no_short_preamble = 0;
#line 1836
  pmlmepriv->num_sta_ht_no_gf = 0;
#line 1837
  pmlmepriv->num_sta_no_ht = 0;
#line 1838
  pmlmepriv->num_sta_ht_20mhz = 0;
#line 1840
  pmlmepriv->olbc = 0;
#line 1842
  pmlmepriv->olbc_ht = 0;
#line 1844
  pmlmepriv->ht_op_mode = 0U;
#line 1846
  i = 0;
#line 1846
  goto ldv_56127;
  ldv_56126: 
#line 1847
  pstapriv->sta_aid[i] = (struct sta_info *)0;
#line 1846
  i = i + 1;
  ldv_56127: ;
#line 1846
  if (i <= 31) {
#line 1848
    goto ldv_56126;
  } else {

  }
#line 1850
  INIT_LIST_HEAD(& pacl_list->acl_node_q.queue);
#line 1851
  pacl_list->num = 0;
#line 1852
  pacl_list->mode = 0;
#line 1853
  i = 0;
#line 1853
  goto ldv_56130;
  ldv_56129: 
#line 1854
  INIT_LIST_HEAD(& pacl_list->aclnode[i].list);
#line 1855
  pacl_list->aclnode[i].valid = 0U;
#line 1853
  i = i + 1;
  ldv_56130: ;
#line 1853
  if (i <= 15) {
#line 1855
    goto ldv_56129;
  } else {

  }

#line 1860
  return;
}
}
#line 1859 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.c"
void stop_ap_mode23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct rtw_wlan_acl_node *paclnode ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  struct list_head  const  *__mptr ;

  {
#line 1863
  psta = (struct sta_info *)0;
#line 1864
  pstapriv = & padapter->stapriv;
#line 1865
  pmlmepriv = & padapter->mlmepriv;
#line 1866
  pmlmeext = & padapter->mlmeextpriv;
#line 1867
  pacl_list = & pstapriv->acl_list;
#line 1868
  pacl_node_q = & pacl_list->acl_node_q;
#line 1870
  pmlmepriv->update_bcn = 0U;
#line 1871
  pmlmeext->bstart_bss = 0U;
#line 1874
  memset((void *)(& padapter->securitypriv), 0, 4272UL);
#line 1875
  padapter->securitypriv.ndisauthtype = 0U;
#line 1876
  padapter->securitypriv.ndisencryptstatus = 1U;
#line 1879
  spin_lock_bh(& pacl_node_q->lock);
#line 1880
  phead = get_list_head(pacl_node_q);
#line 1882
  plist = phead->next;
#line 1882
  ptmp = plist->next;
#line 1882
  goto ldv_56148;
  ldv_56147: 
#line 1883
  __mptr = (struct list_head  const  *)plist;
#line 1883
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
#line 1885
  if ((unsigned int )paclnode->valid == 1U) {
#line 1886
    paclnode->valid = 0U;
#line 1888
    list_del_init(& paclnode->list);
#line 1890
    pacl_list->num = pacl_list->num - 1;
  } else {

  }
#line 1882
  plist = ptmp;
#line 1882
  ptmp = plist->next;
  ldv_56148: ;
#line 1882
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1884
    goto ldv_56147;
  } else {

  }
#line 1893
  spin_unlock_bh(& pacl_node_q->lock);
#line 1895
  if (GlobalDebugLevel23A > 3U) {
#line 1895
    printk("\016RTL8723AU: %s, free acl_node_queue, num =%d\n", "stop_ap_mode23a",
           pacl_list->num);
  } else {

  }
#line 1897
  rtw_sta_flush23a(padapter);
#line 1900
  rtw_free_all_stainfo23a(padapter);
#line 1902
  psta = rtw_get_bcmc_stainfo23a(padapter);
#line 1903
  spin_lock_bh(& pstapriv->sta_hash_lock);
#line 1904
  rtw_free_stainfo23a(padapter, psta);
#line 1905
  spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 1907
  rtw_init_bcmc_stainfo23a(padapter);
#line 1909
  rtw23a_free_mlme_priv_ie_data(pmlmepriv);
#line 1910
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
bool ldv_queue_work_on_811(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 277
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 277
  ldv_func_res = tmp;
#line 279
  activate_work_2(ldv_func_arg3, 2);
#line 281
  return (ldv_func_res);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
bool ldv_queue_delayed_work_on_812(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 288
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 288
  ldv_func_res = tmp;
#line 290
  activate_work_2(& ldv_func_arg3->work, 2);
#line 292
  return (ldv_func_res);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
bool ldv_queue_work_on_813(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_2(ldv_func_arg3, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void ldv_flush_workqueue_814(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 309
  flush_workqueue(ldv_func_arg1);
#line 311
  call_and_disable_all_2(2);
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
bool ldv_queue_delayed_work_on_815(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 318
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 318
  ldv_func_res = tmp;
#line 320
  activate_work_2(& ldv_func_arg3->work, 2);
#line 322
  return (ldv_func_res);
}
}
#line 8 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *memset(void * , int  , size_t  ) ;
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 7 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_module_refcounter  =    1;
#line 10 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_get(struct module *module ) 
{ 


  {
#line 13
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 15
    ldv_module_refcounter = ldv_module_refcounter + 1;
  } else {

  }
#line 16
  return;
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_try_module_get(struct module *module ) 
{ 
  int module_get_succeeded ;

  {
#line 25
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 28
    module_get_succeeded = ldv_undef_int();
#line 30
    if (module_get_succeeded == 1) {
#line 32
      ldv_module_refcounter = ldv_module_refcounter + 1;
#line 34
      return (1);
    } else {
#line 39
      return (0);
    }
  } else {

  }
#line 41
  return (0);
}
}
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put(struct module *module ) 
{ 


  {
#line 48
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 50
    if (ldv_module_refcounter <= 1) {
#line 50
      ldv_error();
    } else {

    }
#line 52
    ldv_module_refcounter = ldv_module_refcounter - 1;
  } else {

  }
#line 54
  return;
}
}
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put_and_exit(void) 
{ 


  {
#line 59
  ldv_module_put((struct module *)1);
  LDV_STOP: ;
#line 61
  goto LDV_STOP;
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
unsigned int ldv_module_refcount(void) 
{ 


  {
#line 68
  return ((unsigned int )(ldv_module_refcounter + -1));
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 75
  if (ldv_module_refcounter != 1) {
#line 75
    ldv_error();
  } else {

  }
#line 79
  return;
}
}
