extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 36 "include/uapi/linux/types.h"
typedef __u64 __le64;
#line 39 "include/uapi/linux/types.h"
typedef __u16 __sum16;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 216 "include/linux/types.h"
typedef u64 cycle_t;
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 234 "include/linux/printk.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 465 "include/linux/kernel.h"
enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_RUNNING = 1,
    SYSTEM_HALT = 2,
    SYSTEM_POWER_OFF = 3,
    SYSTEM_RESTART = 4
} ;
#line 687 "include/linux/list.h"
struct lockdep_map;
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_15 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 328 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_25 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_24 {
   struct __anonstruct____missing_field_name_25 __annonCompField11 ;
   struct __anonstruct____missing_field_name_26 __annonCompField12 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_24 __annonCompField13 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_27 __annonCompField14 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_31 __annonCompField16 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_30 __annonCompField17 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct timespec;
#line 71
struct compat_timespec;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct __anonstruct_futex_34 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct __anonstruct_nanosleep_35 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 72
struct pollfd;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct __anonstruct_poll_36 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
union __anonunion____missing_field_name_33 {
   struct __anonstruct_futex_34 futex ;
   struct __anonstruct_nanosleep_35 nanosleep ;
   struct __anonstruct_poll_36 poll ;
};
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_33 __annonCompField18 ;
};
#line 72 "./arch/x86/include/asm/preempt.h"
typedef int pao_T__;
#line 77 "./arch/x86/include/asm/preempt.h"
typedef int pao_T_____0;
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 106 "include/linux/debugobjects.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 242 "include/linux/timer.h"
struct hrtimer;
#line 243
enum hrtimer_restart;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 1170 "include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 296 "include/linux/rcupdate.h"
struct notifier_block;
#line 1120 "include/linux/rcupdate.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 837 "include/uapi/linux/sysctl.h"
struct ctl_table;
#line 838
struct nsproxy;
#line 839
struct ctl_table_root;
#line 840
struct ctl_table_header;
#line 841
struct ctl_dir;
#line 37 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 57 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 96 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 117 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 122 "include/linux/sysctl.h"
struct __anonstruct____missing_field_name_47 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 122 "include/linux/sysctl.h"
union __anonunion____missing_field_name_46 {
   struct __anonstruct____missing_field_name_47 __annonCompField19 ;
   struct callback_head rcu ;
};
#line 122
struct ctl_table_set;
#line 122 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_46 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 143 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 149 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 154 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 616
struct vm_area_struct;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 90 "include/linux/mmzone.h"
struct free_area {
   struct list_head free_list[6U] ;
   unsigned long nr_free ;
};
#line 96
struct pglist_data;
#line 97 "include/linux/mmzone.h"
struct zone_padding {
   char x[0U] ;
};
#line 202 "include/linux/mmzone.h"
struct zone_reclaim_stat {
   unsigned long recent_rotated[2U] ;
   unsigned long recent_scanned[2U] ;
};
#line 215
struct zone;
#line 215 "include/linux/mmzone.h"
struct lruvec {
   struct list_head lists[5U] ;
   struct zone_reclaim_stat reclaim_stat ;
   struct zone *zone ;
};
#line 247 "include/linux/mmzone.h"
struct per_cpu_pages {
   int count ;
   int high ;
   int batch ;
   struct list_head lists[3U] ;
};
#line 260 "include/linux/mmzone.h"
struct per_cpu_pageset {
   struct per_cpu_pages pcp ;
   s8 expire ;
   s8 stat_threshold ;
   s8 vm_stat_diff[39U] ;
};
#line 270
enum zone_type {
    ZONE_DMA = 0,
    ZONE_DMA32 = 1,
    ZONE_NORMAL = 2,
    ZONE_MOVABLE = 3,
    __MAX_NR_ZONES = 4
} ;
#line 278 "include/linux/mmzone.h"
struct zone {
   unsigned long watermark[3U] ;
   long lowmem_reserve[4U] ;
   int node ;
   unsigned int inactive_ratio ;
   struct pglist_data *zone_pgdat ;
   struct per_cpu_pageset *pageset ;
   unsigned long dirty_balance_reserve ;
   unsigned long min_unmapped_pages ;
   unsigned long min_slab_pages ;
   unsigned long zone_start_pfn ;
   unsigned long managed_pages ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   char const   *name ;
   int nr_migrate_reserve_block ;
   unsigned long nr_isolate_pageblock ;
   seqlock_t span_seqlock ;
   wait_queue_head_t *wait_table ;
   unsigned long wait_table_hash_nr_entries ;
   unsigned long wait_table_bits ;
   struct zone_padding _pad1_ ;
   struct free_area free_area[11U] ;
   unsigned long flags ;
   spinlock_t lock ;
   struct zone_padding _pad2_ ;
   spinlock_t lru_lock ;
   struct lruvec lruvec ;
   atomic_long_t inactive_age ;
   unsigned long percpu_drift_mark ;
   unsigned long compact_cached_free_pfn ;
   unsigned long compact_cached_migrate_pfn[2U] ;
   unsigned int compact_considered ;
   unsigned int compact_defer_shift ;
   int compact_order_failed ;
   bool compact_blockskip_flush ;
   struct zone_padding _pad3_ ;
   atomic_long_t vm_stat[39U] ;
};
#line 567 "include/linux/mmzone.h"
struct zonelist_cache {
   unsigned short z_to_n[4096U] ;
   unsigned long fullzones[64U] ;
   unsigned long last_full_zap ;
};
#line 654 "include/linux/mmzone.h"
struct zoneref {
   struct zone *zone ;
   int zone_idx ;
};
#line 667 "include/linux/mmzone.h"
struct zonelist {
   struct zonelist_cache *zlcache_ptr ;
   struct zoneref _zonerefs[4097U] ;
   struct zonelist_cache zlcache ;
};
#line 705 "include/linux/mmzone.h"
struct pglist_data {
   struct zone node_zones[4U] ;
   struct zonelist node_zonelists[2U] ;
   int nr_zones ;
   spinlock_t node_size_lock ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   wait_queue_head_t kswapd_wait ;
   wait_queue_head_t pfmemalloc_wait ;
   struct task_struct *kswapd ;
   int kswapd_max_order ;
   enum zone_type classzone_idx ;
   spinlock_t numabalancing_migrate_lock ;
   unsigned long numabalancing_migrate_next_window ;
   unsigned long numabalancing_migrate_nr_pages ;
   unsigned long first_deferred_pfn ;
};
#line 773 "include/linux/mmzone.h"
typedef struct pglist_data pg_data_t;
#line 796
struct rw_semaphore;
#line 797 "include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 64 "./arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 172 "./arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 133 "./arch/x86/include/asm/topology.h"
struct pci_bus;
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_113 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_113 mm_context_t;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 60 "include/linux/kmemleak.h"
struct kmem_cache;
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 33
struct inode;
#line 34
struct dentry;
#line 35
struct user_namespace;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_146 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_147 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_145 {
   struct __anonstruct____missing_field_name_146 __annonCompField33 ;
   struct __anonstruct____missing_field_name_147 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_145 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_148 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_154 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_152 {
   union __anonunion____missing_field_name_153 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_151 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_152 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_149 {
   union __anonunion____missing_field_name_150 __annonCompField37 ;
   union __anonunion____missing_field_name_151 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_157 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_156 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_157 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_158 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_148 __annonCompField36 ;
   struct __anonstruct____missing_field_name_149 __annonCompField42 ;
   union __anonunion____missing_field_name_155 __annonCompField45 ;
   union __anonunion____missing_field_name_158 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_159 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_159 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_161 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_161 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_162 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_162 kgid_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_163 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_163 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_165 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_166 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_167 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_170 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_169 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_170 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_171 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_172 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_164 {
   int _pad[28U] ;
   struct __anonstruct__kill_165 _kill ;
   struct __anonstruct__timer_166 _timer ;
   struct __anonstruct__rt_167 _rt ;
   struct __anonstruct__sigchld_168 _sigchld ;
   struct __anonstruct__sigfault_169 _sigfault ;
   struct __anonstruct__sigpoll_171 _sigpoll ;
   struct __anonstruct__sigsys_172 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_164 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct cred;
#line 38
struct key_type;
#line 42 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_179 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_180 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_182 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_181 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_182 __annonCompField49 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_183 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_185 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_184 {
   union __anonunion_payload_185 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_179 __annonCompField47 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_180 __annonCompField48 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_181 __annonCompField50 ;
   union __anonunion_type_data_183 type_data ;
   union __anonunion____missing_field_name_184 __annonCompField51 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369 "include/linux/cred.h"
union __anonunion____missing_field_name_186 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 369 "include/linux/cred.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_186 __annonCompField52 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 31
struct kernfs_node;
#line 32
struct kernfs_ops;
#line 33
struct kernfs_open_file;
#line 75 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270
struct kernfs_root;
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1161
struct uts_namespace;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 599 "include/linux/slab.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw;
#line 68
struct ethtool_eeprom;
#line 112
struct ethtool_cmd;
#line 145
struct ethtool_rxnfc;
#line 150
struct ethtool_pauseparam;
#line 159
struct ieee_ets;
#line 173
struct ethtool_wolinfo;
#line 197
struct ethtool_channels;
#line 199
struct dcb_app;
#line 233
struct ethtool_coalesce;
#line 245
struct ethtool_ringparam;
#line 248
struct ieee_pfc;
#line 135 "./arch/x86/include/uapi/asm/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
struct iattr;
#line 54
struct super_block;
#line 55
struct file_system_type;
#line 56
struct kernfs_open_node;
#line 57
struct kernfs_iattrs;
#line 80 "include/linux/elf.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_209 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_209 __annonCompField56 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_210 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_210 __annonCompField57 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 650
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 70 "include/linux/resource_ext.h"
struct hotplug_slot;
#line 70 "include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "include/linux/pci.h"
typedef int pci_power_t;
#line 137 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 190 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 196
enum pcie_link_width {
    PCIE_LNK_WIDTH_RESRV = 0,
    PCIE_LNK_X1 = 1,
    PCIE_LNK_X2 = 2,
    PCIE_LNK_X4 = 4,
    PCIE_LNK_X8 = 8,
    PCIE_LNK_X12 = 12,
    PCIE_LNK_X16 = 16,
    PCIE_LNK_X32 = 32,
    PCIE_LNK_WIDTH_UNKNOWN = 255
} ;
#line 208
enum pci_bus_speed {
    PCI_SPEED_33MHz = 0,
    PCI_SPEED_66MHz = 1,
    PCI_SPEED_66MHz_PCIX = 2,
    PCI_SPEED_100MHz_PCIX = 3,
    PCI_SPEED_133MHz_PCIX = 4,
    PCI_SPEED_66MHz_PCIX_ECC = 5,
    PCI_SPEED_100MHz_PCIX_ECC = 6,
    PCI_SPEED_133MHz_PCIX_ECC = 7,
    PCI_SPEED_66MHz_PCIX_266 = 9,
    PCI_SPEED_100MHz_PCIX_266 = 10,
    PCI_SPEED_133MHz_PCIX_266 = 11,
    AGP_UNKNOWN = 12,
    AGP_1X = 13,
    AGP_2X = 14,
    AGP_4X = 15,
    AGP_8X = 16,
    PCI_SPEED_66MHz_PCIX_533 = 17,
    PCI_SPEED_100MHz_PCIX_533 = 18,
    PCI_SPEED_133MHz_PCIX_533 = 19,
    PCIE_SPEED_2_5GT = 20,
    PCIE_SPEED_5_0GT = 21,
    PCIE_SPEED_8_0GT = 22,
    PCI_SPEED_UNKNOWN = 255
} ;
#line 247
struct pcie_link_state;
#line 248
struct pci_vpd;
#line 249
struct pci_sriov;
#line 250
struct pci_ats;
#line 251
struct proc_dir_entry;
#line 251
struct pci_driver;
#line 251 "include/linux/pci.h"
union __anonunion____missing_field_name_220 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 251 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned char ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char no_64bit_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   unsigned char irq_managed : 1 ;
   unsigned char has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_220 __annonCompField58 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 440
struct pci_ops;
#line 440
struct msi_controller;
#line 440 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 563 "include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus * , unsigned int  , int  ) ;
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 591 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 605 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 615 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 648 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 66
struct bdi_writeback;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 1200
struct kvec;
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 19 "include/linux/dmapool.h"
struct dma_pool;
#line 35 "include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 34 "./arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 56 "include/linux/prefetch.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion____missing_field_name_221 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_221 __annonCompField59 ;
   unsigned long nr_segs ;
};
#line 1182 "include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38
struct kiocb;
#line 38 "include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_223 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_223 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_224 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_224 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_225 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_225 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_226 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_226 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_227 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_227 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_228 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_228 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_229 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_229 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_230 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_230 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_231 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_232 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_231 ifr_ifrn ;
   union __anonunion_ifr_ifru_232 ifr_ifru ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_237 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_236 {
   struct __anonstruct____missing_field_name_237 __annonCompField60 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_236 __annonCompField61 ;
};
#line 50 "include/linux/lockref.h"
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_239 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion____missing_field_name_238 {
   struct __anonstruct____missing_field_name_239 __annonCompField62 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_238 __annonCompField63 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_240 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_240 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_244 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_243 {
   struct __anonstruct____missing_field_name_244 __annonCompField64 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_243 __annonCompField65 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 47
struct block_device;
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 60 "include/uapi/linux/fs.h"
struct export_operations;
#line 62
struct poll_table_struct;
#line 63
struct kstatfs;
#line 64
struct swap_info_struct;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_248 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_248 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_249 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_249 __annonCompField67 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_252 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_253 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_254 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_252 __annonCompField68 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_253 __annonCompField69 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_254 __annonCompField70 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_255 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_255 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 946
struct net;
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_257 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_256 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_257 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_256 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 18 "./arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 45 "./arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 123 "include/linux/random.h"
enum ldv_25040 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
#line 53 "include/uapi/linux/net.h"
typedef enum ldv_25040 socket_state;
#line 70 "include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
#line 93 "include/linux/net.h"
struct proto_ops;
#line 93 "include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
#line 119 "include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   int (*set_peek_off)(struct sock * , int  ) ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 161 "./arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 66 "include/linux/netdev_features.h"
union __anonunion_in6_u_272 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 66 "include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_272 in6_u ;
};
#line 46 "include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 218 "include/net/flow_dissector.h"
struct pipe_buf_operations;
#line 218 "include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 27 "include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
#line 61 "include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
#line 86 "include/linux/splice.h"
struct napi_struct;
#line 87 "include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_277 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_278 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};
#line 172 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned char orig_proto ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion____missing_field_name_277 __annonCompField74 ;
   union __anonunion____missing_field_name_278 __annonCompField75 ;
};
#line 189 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 215
struct skb_frag_struct;
#line 215 "include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;
#line 216 "include/linux/skbuff.h"
struct __anonstruct_page_279 {
   struct page *p ;
};
#line 216 "include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_279 page ;
   __u32 page_offset ;
   __u32 size ;
};
#line 249 "include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
};
#line 319 "include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   u32 tskey ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};
#line 403 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 404 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_281 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 404 "include/linux/skbuff.h"
union __anonunion____missing_field_name_280 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_281 __annonCompField76 ;
};
#line 404 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion____missing_field_name_280 __annonCompField77 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_284 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_283 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_284 __annonCompField78 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_282 {
   struct __anonstruct____missing_field_name_283 __annonCompField79 ;
   struct rb_node rbnode ;
};
#line 457
struct sec_path;
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_286 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_285 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_286 __annonCompField81 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_287 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_288 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_289 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 457 "include/linux/skbuff.h"
struct sk_buff {
   union __anonunion____missing_field_name_282 __annonCompField80 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_285 __annonCompField82 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_287 __annonCompField83 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_288 __annonCompField84 ;
   union __anonunion____missing_field_name_289 __annonCompField85 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 718
struct dst_entry;
#line 767
struct rtable;
#line 890
enum pkt_hash_types {
    PKT_HASH_TYPE_NONE = 0,
    PKT_HASH_TYPE_L2 = 1,
    PKT_HASH_TYPE_L3 = 2,
    PKT_HASH_TYPE_L4 = 3
} ;
#line 34 "include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 189 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 245 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 267 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 293 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 322 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 339 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 438 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 475 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 503 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 605 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 637 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 679 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 712 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 728 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 748 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 759 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 778 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 828 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 999 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 1007 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1083 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 99 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * , u8 const    ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*get_tunable)(struct net_device * , struct ethtool_tunable  const  * , void * ) ;
   int (*set_tunable)(struct net_device * , struct ethtool_tunable  const  * , void const   * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 146 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 79 "include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 89 "include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 179 "include/net/inet_frag.h"
struct ipv4_devconf;
#line 180
struct fib_rules_ops;
#line 181
struct fib_table;
#line 182 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
#line 24 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 29
struct inet_peer_base;
#line 29
struct xt_table;
#line 29 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 113
struct neighbour;
#line 113 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 72 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};
#line 39 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 39
struct rt6_info;
#line 39
struct rt6_statistics;
#line 39
struct fib6_table;
#line 39 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};
#line 85 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 91 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};
#line 20
struct sctp_mib;
#line 21 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 134 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 79 "include/uapi/linux/netfilter.h"
struct nf_logger;
#line 80 "include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 23 "include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 25 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 30 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 44 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 49 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 54 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 65 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 73
struct ip_conntrack_stat;
#line 73
struct nf_ct_event_notifier;
#line 73
struct nf_exp_event_notifier;
#line 73 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 115
struct nft_af_info;
#line 116 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};
#line 465 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 672 "include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 21 "include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 30 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 88
struct mpls_route;
#line 89 "include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
#line 16 "include/net/netns/mpls.h"
struct proc_ns_operations;
#line 17 "include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
#line 11 "include/linux/ns_common.h"
struct net_generic;
#line 12
struct netns_ipvs;
#line 13 "include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 241 "include/net/net_namespace.h"
struct __anonstruct_possible_net_t_306 {
   struct net *net ;
};
#line 241 "include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_306 possible_net_t;
#line 376
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
#line 383 "include/net/net_namespace.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
#line 32 "include/linux/of.h"
typedef u32 phandle;
#line 34 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 44 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 1084 "include/linux/of.h"
struct mii_ioctl_data {
   __u16 phy_id ;
   __u16 reg_num ;
   __u16 val_in ;
   __u16 val_out ;
};
#line 338 "include/linux/mii.h"
enum ldv_28664 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
} ;
#line 80 "include/linux/phy.h"
typedef enum ldv_28664 phy_interface_t;
#line 126
enum ldv_28718 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
} ;
#line 133
struct phy_device;
#line 133 "include/linux/phy.h"
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_28718 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};
#line 214
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
#line 229 "include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 323
struct phy_driver;
#line 323 "include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
#line 429 "include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const   *driver_data ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*link_change_notify)(struct phy_device * ) ;
   int (*read_mmd_indirect)(struct phy_device * , int  , int  , int  ) ;
   void (*write_mmd_indirect)(struct phy_device * , int  , int  , int  , u32  ) ;
   int (*module_info)(struct phy_device * , struct ethtool_modinfo * ) ;
   int (*module_eeprom)(struct phy_device * , struct ethtool_eeprom * , u8 * ) ;
   struct device_driver driver ;
};
#line 803 "include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};
#line 25 "include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
} ;
#line 33 "include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};
#line 68 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 84
struct packet_type;
#line 85
struct dsa_switch;
#line 85 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 123
struct dsa_switch_driver;
#line 123 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 194 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   u32 (*get_phy_flags)(struct dsa_switch * , int  ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*adjust_link)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*fixed_link_update)(struct dsa_switch * , int  , struct fixed_phy_status * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
   void (*get_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*suspend)(struct dsa_switch * ) ;
   int (*resume)(struct dsa_switch * ) ;
   int (*port_enable)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*port_disable)(struct dsa_switch * , int  , struct phy_device * ) ;
   int (*set_eee)(struct dsa_switch * , int  , struct phy_device * , struct ethtool_eee * ) ;
   int (*get_eee)(struct dsa_switch * , int  , struct ethtool_eee * ) ;
   int (*get_temp)(struct dsa_switch * , int * ) ;
   int (*get_temp_limit)(struct dsa_switch * , int * ) ;
   int (*set_temp_limit)(struct dsa_switch * , int  ) ;
   int (*get_temp_alarm)(struct dsa_switch * , bool * ) ;
   int (*get_eeprom_len)(struct dsa_switch * ) ;
   int (*get_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_regs_len)(struct dsa_switch * , int  ) ;
   void (*get_regs)(struct dsa_switch * , int  , struct ethtool_regs * , void * ) ;
   int (*port_join_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_leave_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_stp_update)(struct dsa_switch * , int  , u8  ) ;
   int (*fdb_add)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_del)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_getnext)(struct dsa_switch * , int  , unsigned char * , bool * ) ;
};
#line 320 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 87 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
#line 132 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
#line 144 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 164 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 187 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 202 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 236 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_setqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_getqcnstats)(struct net_device * , struct ieee_qcn_stats * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   int (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   int (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 105 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 515 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 97 "include/linux/security.h"
struct xfrm_policy;
#line 98
struct xfrm_state;
#line 114
struct request_sock;
#line 1628
struct mnt_namespace;
#line 1629
struct ipc_namespace;
#line 1630 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 147 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 106 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 182 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 321
enum macvlan_mode {
    MACVLAN_MODE_PRIVATE = 1,
    MACVLAN_MODE_VEPA = 2,
    MACVLAN_MODE_BRIDGE = 4,
    MACVLAN_MODE_PASSTHRU = 8,
    MACVLAN_MODE_SOURCE = 16
} ;
#line 643 "include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};
#line 16 "include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};
#line 118 "include/uapi/linux/if_bonding.h"
struct netpoll_info;
#line 119
struct wireless_dev;
#line 120
struct wpan_dev;
#line 121
struct mpls_dev;
#line 65 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 110 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 129 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 190
struct neigh_parms;
#line 191 "include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};
#line 211 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 216 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 245 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 295 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 331
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
} ;
#line 339 "include/linux/netdevice.h"
typedef enum gro_result gro_result_t;
#line 340
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 388 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 389 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 537
struct Qdisc;
#line 537 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};
#line 607 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 619 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 631 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 683 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 706 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 719 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 730 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 741 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 757 "include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 770 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_get_vf_stats)(struct net_device * , int  , struct ifla_vf_stats * ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device * , int  , bool  ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  , u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       struct net_device * , int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  , int  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_item_id * ) ;
   int (*ndo_get_phys_port_name)(struct net_device * , char * , size_t  ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff * , struct net_device * ,
                                           netdev_features_t  ) ;
   int (*ndo_set_tx_maxrate)(struct net_device * , int  , u32  ) ;
   int (*ndo_get_iflink)(struct net_device  const  * ) ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_adj_list_316 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_317 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257
struct iw_handler_def;
#line 1257
struct iw_public_data;
#line 1257
struct switchdev_ops;
#line 1257
struct vlan_info;
#line 1257
struct tipc_bearer;
#line 1257
struct in_device;
#line 1257
struct dn_dev;
#line 1257
struct inet6_dev;
#line 1257
struct tcf_proto;
#line 1257
struct cpu_rmap;
#line 1257
struct pcpu_lstats;
#line 1257
struct pcpu_sw_netstats;
#line 1257
struct pcpu_dstats;
#line 1257
struct pcpu_vstats;
#line 1257 "include/linux/netdevice.h"
union __anonunion____missing_field_name_318 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1257
struct garp_port;
#line 1257
struct mrp_port;
#line 1257
struct rtnl_link_ops;
#line 1257 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_316 adj_list ;
   struct __anonstruct_all_adj_list_317 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct switchdev_ops  const  *switchdev_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion____missing_field_name_318 __annonCompField95 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};
#line 1978 "include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   bool (*id_match)(struct packet_type * , struct sock * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
#line 2025 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 2893
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
} ;
#line 193 "include/linux/vmalloc.h"
struct iphdr {
   unsigned char ihl : 4 ;
   unsigned char version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};
#line 131 "include/linux/uaccess.h"
struct page_counter {
   atomic_long_t count ;
   unsigned long limit ;
   struct page_counter *parent ;
   unsigned long watermark ;
   unsigned long failcnt ;
};
#line 170 "./arch/x86/include/asm/cacheflush.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};
#line 49 "include/uapi/linux/filter.h"
struct bpf_insn {
   __u8 code ;
   unsigned char dst_reg : 4 ;
   unsigned char src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};
#line 81 "include/uapi/linux/bpf.h"
enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4
} ;
#line 273
struct bpf_prog_aux;
#line 314 "include/linux/filter.h"
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};
#line 325 "include/linux/filter.h"
union __anonunion____missing_field_name_329 {
   struct sock_filter insns[0U] ;
   struct bpf_insn insnsi[0U] ;
};
#line 325 "include/linux/filter.h"
struct bpf_prog {
   u16 pages ;
   bool jited ;
   bool gpl_compatible ;
   u32 len ;
   enum bpf_prog_type type ;
   struct bpf_prog_aux *aux ;
   struct sock_fprog_kern *orig_prog ;
   unsigned int (*bpf_func)(struct sk_buff  const  * , struct bpf_insn  const  * ) ;
   union __anonunion____missing_field_name_329 __annonCompField100 ;
};
#line 342 "include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   struct callback_head rcu ;
   struct bpf_prog *prog ;
};
#line 101 "include/linux/rculist_nulls.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 136 "include/linux/rtnetlink.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};
#line 25 "include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const   *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device * ) ;
   int maxtype ;
   struct nla_policy  const  *policy ;
   int (*validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*newlink)(struct net * , struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   int (*changelink)(struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   void (*dellink)(struct net_device * , struct list_head * ) ;
   size_t (*get_size)(struct net_device  const  * ) ;
   int (*fill_info)(struct sk_buff * , struct net_device  const  * ) ;
   size_t (*get_xstats_size)(struct net_device  const  * ) ;
   int (*fill_xstats)(struct sk_buff * , struct net_device  const  * ) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy  const  *slave_policy ;
   int (*slave_validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*slave_changelink)(struct net_device * , struct net_device * , struct nlattr ** ,
                           struct nlattr ** ) ;
   size_t (*get_slave_size)(struct net_device  const  * , struct net_device  const  * ) ;
   int (*fill_slave_info)(struct sk_buff * , struct net_device  const  * , struct net_device  const  * ) ;
   struct net *(*get_link_net)(struct net_device  const  * ) ;
};
#line 171
struct neigh_table;
#line 171 "include/net/rtnetlink.h"
struct neigh_parms {
   possible_net_t net ;
   struct net_device *dev ;
   struct list_head list ;
   int (*neigh_setup)(struct neighbour * ) ;
   void (*neigh_cleanup)(struct neighbour * ) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[13U] ;
   unsigned long data_state[1U] ;
};
#line 110 "include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};
#line 129
struct neigh_ops;
#line 129 "include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   struct neigh_ops  const  *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};
#line 158 "include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour * , struct sk_buff * ) ;
   void (*error_report)(struct neighbour * , struct sk_buff * ) ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   int (*connected_output)(struct neighbour * , struct sk_buff * ) ;
};
#line 166 "include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   possible_net_t net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};
#line 174 "include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};
#line 187 "include/net/neighbour.h"
struct neigh_table {
   int family ;
   int entry_size ;
   int key_len ;
   __be16 protocol ;
   __u32 (*hash)(void const   * , struct net_device  const  * , __u32 * ) ;
   bool (*key_eq)(struct neighbour  const  * , void const   * ) ;
   int (*constructor)(struct neighbour * ) ;
   int (*pconstructor)(struct pneigh_entry * ) ;
   void (*pdestructor)(struct pneigh_entry * ) ;
   void (*proxy_redo)(struct sk_buff * ) ;
   char *id ;
   struct neigh_parms parms ;
   struct list_head parms_list ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};
#line 519
struct dn_route;
#line 519 "include/net/neighbour.h"
union __anonunion____missing_field_name_340 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};
#line 519 "include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff * ) ;
   int (*output)(struct sock * , struct sk_buff * ) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion____missing_field_name_340 __annonCompField101 ;
};
#line 555 "include/net/dst.h"
struct hwtstamp_config {
   int flags ;
   int tx_type ;
   int rx_filter ;
};
#line 124 "include/net/sock.h"
struct __anonstruct_socket_lock_t_341 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};
#line 124 "include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_341 socket_lock_t;
#line 124
struct proto;
#line 130 "include/net/sock.h"
typedef __u32 __portpair;
#line 131 "include/net/sock.h"
typedef __u64 __addrpair;
#line 132 "include/net/sock.h"
struct __anonstruct____missing_field_name_343 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_342 {
   __addrpair skc_addrpair ;
   struct __anonstruct____missing_field_name_343 __annonCompField102 ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_344 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};
#line 132 "include/net/sock.h"
struct __anonstruct____missing_field_name_346 {
   __be16 skc_dport ;
   __u16 skc_num ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_345 {
   __portpair skc_portpair ;
   struct __anonstruct____missing_field_name_346 __annonCompField105 ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_347 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_348 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};
#line 132 "include/net/sock.h"
struct sock_common {
   union __anonunion____missing_field_name_342 __annonCompField103 ;
   union __anonunion____missing_field_name_344 __annonCompField104 ;
   union __anonunion____missing_field_name_345 __annonCompField106 ;
   unsigned short skc_family ;
   unsigned char volatile   skc_state ;
   unsigned char skc_reuse : 4 ;
   unsigned char skc_reuseport : 1 ;
   unsigned char skc_ipv6only : 1 ;
   unsigned char skc_net_refcnt : 1 ;
   int skc_bound_dev_if ;
   union __anonunion____missing_field_name_347 __annonCompField107 ;
   struct proto *skc_prot ;
   possible_net_t skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   atomic64_t skc_cookie ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion____missing_field_name_348 __annonCompField108 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};
#line 219
struct cg_proto;
#line 220 "include/net/sock.h"
struct __anonstruct_sk_backlog_349 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
#line 220 "include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_349 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   u16 sk_incoming_cpu ;
   __u32 sk_txhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned char sk_shutdown : 2 ;
   unsigned char sk_no_check_tx : 1 ;
   unsigned char sk_no_check_rx : 1 ;
   unsigned char sk_userlocks : 4 ;
   unsigned char sk_protocol ;
   unsigned short sk_type ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   u32 sk_ack_backlog ;
   u32 sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred  const  *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   u16 sk_tsflags ;
   u32 sk_tskey ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock * ) ;
   void (*sk_data_ready)(struct sock * ) ;
   void (*sk_write_space)(struct sock * ) ;
   void (*sk_error_report)(struct sock * ) ;
   int (*sk_backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*sk_destruct)(struct sock * ) ;
};
#line 906
struct request_sock_ops;
#line 907
struct timewait_sock_ops;
#line 908
struct inet_hashinfo;
#line 909
struct raw_hashinfo;
#line 923
struct udp_table;
#line 923 "include/net/sock.h"
union __anonunion_h_352 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};
#line 923 "include/net/sock.h"
struct proto {
   void (*close)(struct sock * , long  ) ;
   int (*connect)(struct sock * , struct sockaddr * , int  ) ;
   int (*disconnect)(struct sock * , int  ) ;
   struct sock *(*accept)(struct sock * , int  , int * ) ;
   int (*ioctl)(struct sock * , int  , unsigned long  ) ;
   int (*init)(struct sock * ) ;
   void (*destroy)(struct sock * ) ;
   void (*shutdown)(struct sock * , int  ) ;
   int (*setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_ioctl)(struct sock * , unsigned int  , unsigned long  ) ;
   int (*sendmsg)(struct sock * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct sock * , struct msghdr * , size_t  , int  , int  , int * ) ;
   int (*sendpage)(struct sock * , struct page * , int  , size_t  , int  ) ;
   int (*bind)(struct sock * , struct sockaddr * , int  ) ;
   int (*backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*release_cb)(struct sock * ) ;
   void (*hash)(struct sock * ) ;
   void (*unhash)(struct sock * ) ;
   void (*rehash)(struct sock * ) ;
   int (*get_port)(struct sock * , unsigned short  ) ;
   void (*clear_sk)(struct sock * , int  ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock  const  * ) ;
   void (*enter_memory_pressure)(struct sock * ) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_352 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup * , struct cgroup_subsys * ) ;
   void (*destroy_cgroup)(struct mem_cgroup * ) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup * ) ;
};
#line 1046 "include/net/sock.h"
struct cg_proto {
   struct page_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};
#line 174 "include/linux/jhash.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock * , struct request_sock * ) ;
   void (*send_ack)(struct sock * , struct sk_buff * , struct request_sock * ) ;
   void (*send_reset)(struct sock * , struct sk_buff * ) ;
   void (*destructor)(struct request_sock * ) ;
   void (*syn_ack_timeout)(struct request_sock  const  * ) ;
};
#line 46 "include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   struct sock *rsk_listener ;
   u16 mss ;
   u8 num_retrans ;
   unsigned char cookie_ts : 1 ;
   unsigned char num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   struct timer_list rsk_timer ;
   struct request_sock_ops  const  *rsk_ops ;
   struct sock *sk ;
   u32 *saved_syn ;
   u32 secid ;
   u32 peer_secid ;
};
#line 330 "include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock * , struct sock * , void * ) ;
   void (*twsk_destructor)(struct sock * ) ;
};
#line 132 "include/net/inet_timewait_sock.h"
struct tcphdr {
   __be16 source ;
   __be16 dest ;
   __be32 seq ;
   __be32 ack_seq ;
   unsigned char res1 : 4 ;
   unsigned char doff : 4 ;
   unsigned char fin : 1 ;
   unsigned char syn : 1 ;
   unsigned char rst : 1 ;
   unsigned char psh : 1 ;
   unsigned char ack : 1 ;
   unsigned char urg : 1 ;
   unsigned char ece : 1 ;
   unsigned char cwr : 1 ;
   __be16 window ;
   __sum16 check ;
   __be16 urg_ptr ;
};
#line 106 "include/uapi/linux/ipv6.h"
struct ipv6hdr {
   unsigned char priority : 4 ;
   unsigned char version : 4 ;
   __u8 flow_lbl[3U] ;
   __be16 payload_len ;
   __u8 nexthdr ;
   __u8 hop_limit ;
   struct in6_addr saddr ;
   struct in6_addr daddr ;
};
#line 174 "include/uapi/linux/ipv6.h"
struct ipv6_stable_secret {
   bool initialized ;
   struct in6_addr secret ;
};
#line 60 "include/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 accept_ra_from_local ;
   __s32 optimistic_dad ;
   __s32 use_optimistic ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   __s32 accept_ra_mtu ;
   struct ipv6_stable_secret stable_secret ;
   void *sysctl ;
};
#line 100 "include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};
#line 109 "include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};
#line 141 "include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};
#line 152 "include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6 ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};
#line 163 "include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   __u8 addr_gen_mode ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};
#line 971 "include/net/ipv6.h"
union __anonunion____missing_field_name_377 {
   __be32 a4 ;
   __be32 a6[4U] ;
   struct in6_addr in6 ;
};
#line 971 "include/net/ipv6.h"
struct inetpeer_addr_base {
   union __anonunion____missing_field_name_377 __annonCompField111 ;
};
#line 25 "include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};
#line 30 "include/net/inetpeer.h"
union __anonunion____missing_field_name_378 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};
#line 30 "include/net/inetpeer.h"
struct __anonstruct____missing_field_name_380 {
   atomic_t rid ;
};
#line 30 "include/net/inetpeer.h"
union __anonunion____missing_field_name_379 {
   struct __anonstruct____missing_field_name_380 __annonCompField113 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};
#line 30 "include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[16U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion____missing_field_name_378 __annonCompField112 ;
   union __anonunion____missing_field_name_379 __annonCompField114 ;
   __u32 dtime ;
   atomic_t refcnt ;
};
#line 61 "include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   int total ;
};
#line 50 "./include/uapi/linux/route.h"
struct uncached_list;
#line 51 "./include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
   struct uncached_list *rt_uncached_list ;
};
#line 63 "include/uapi/linux/if_vlan.h"
struct vlan_hdr {
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};
#line 42 "include/linux/if_vlan.h"
struct vlan_ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_vlan_proto ;
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};
#line 80 "include/linux/if_vlan.h"
struct vlan_pcpu_stats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 rx_multicast ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
   u32 rx_errors ;
   u32 tx_dropped ;
};
#line 126
struct netpoll;
#line 14 "include/linux/if_macvlan.h"
struct macvlan_port;
#line 15
struct macvtap_queue;
#line 16 "include/linux/if_macvlan.h"
struct macvlan_dev {
   struct net_device *dev ;
   struct list_head list ;
   struct hlist_node hlist ;
   struct macvlan_port *port ;
   struct net_device *lowerdev ;
   void *fwd_priv ;
   struct vlan_pcpu_stats *pcpu_stats ;
   unsigned long mc_filter[4U] ;
   netdev_features_t set_features ;
   enum macvlan_mode mode ;
   u16 flags ;
   struct macvtap_queue *taps[256U] ;
   struct list_head queue_list ;
   int numvtaps ;
   int numqueues ;
   netdev_features_t tap_features ;
   int minor ;
   int nest_level ;
   struct netpoll *netpoll ;
   unsigned int macaddr_count ;
};
#line 64 "include/linux/aer.h"
struct cyclecounter {
   cycle_t (*read)(struct cyclecounter  const  * ) ;
   cycle_t mask ;
   u32 mult ;
   u32 shift ;
};
#line 45 "include/linux/timecounter.h"
struct timecounter {
   struct cyclecounter  const  *cc ;
   cycle_t cycle_last ;
   u64 nsec ;
   u64 mask ;
   u64 frac ;
};
#line 122 "./include/uapi/linux/pps.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 135 "include/linux/pps_kernel.h"
struct ptp_clock_time {
   __s64 sec ;
   __u32 nsec ;
   __u32 reserved ;
};
#line 56 "./include/uapi/linux/ptp_clock.h"
struct ptp_extts_request {
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[2U] ;
};
#line 62 "./include/uapi/linux/ptp_clock.h"
struct ptp_perout_request {
   struct ptp_clock_time start ;
   struct ptp_clock_time period ;
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[4U] ;
};
#line 83
enum ptp_pin_function {
    PTP_PF_NONE = 0,
    PTP_PF_EXTTS = 1,
    PTP_PF_PEROUT = 2,
    PTP_PF_PHYSYNC = 3
} ;
#line 90 "./include/uapi/linux/ptp_clock.h"
struct ptp_pin_desc {
   char name[64U] ;
   unsigned int index ;
   unsigned int func ;
   unsigned int chan ;
   unsigned int rsv[5U] ;
};
#line 134
enum ldv_36003 {
    PTP_CLK_REQ_EXTTS = 0,
    PTP_CLK_REQ_PEROUT = 1,
    PTP_CLK_REQ_PPS = 2
} ;
#line 140 "./include/uapi/linux/ptp_clock.h"
union __anonunion____missing_field_name_390 {
   struct ptp_extts_request extts ;
   struct ptp_perout_request perout ;
};
#line 140 "./include/uapi/linux/ptp_clock.h"
struct ptp_clock_request {
   enum ldv_36003 type ;
   union __anonunion____missing_field_name_390 __annonCompField116 ;
};
#line 40 "include/linux/ptp_clock_kernel.h"
struct ptp_clock_info {
   struct module *owner ;
   char name[16U] ;
   s32 max_adj ;
   int n_alarm ;
   int n_ext_ts ;
   int n_per_out ;
   int n_pins ;
   int pps ;
   struct ptp_pin_desc *pin_config ;
   int (*adjfreq)(struct ptp_clock_info * , s32  ) ;
   int (*adjtime)(struct ptp_clock_info * , s64  ) ;
   int (*gettime64)(struct ptp_clock_info * , struct timespec * ) ;
   int (*settime64)(struct ptp_clock_info * , struct timespec  const  * ) ;
   int (*enable)(struct ptp_clock_info * , struct ptp_clock_request * , int  ) ;
   int (*verify)(struct ptp_clock_info * , unsigned int  , enum ptp_pin_function  ,
                 unsigned int  ) ;
};
#line 113
struct ptp_clock;
#line 29 "include/linux/mdio.h"
struct mdio_if_info {
   int prtad ;
   u32 mmds ;
   unsigned int mode_support ;
   struct net_device *dev ;
   int (*mdio_read)(struct net_device * , int  , int  , u16  ) ;
   int (*mdio_write)(struct net_device * , int  , int  , u16  , u16  ) ;
};
#line 175 "include/linux/mdio.h"
struct ixgbe_thermal_diode_data {
   u8 location ;
   u8 temp ;
   u8 caution_thresh ;
   u8 max_op_thresh ;
};
#line 228 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_thermal_sensor_data {
   struct ixgbe_thermal_diode_data sensor[3U] ;
};
#line 2643 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_read_393 {
   __le64 buffer_addr ;
   __le32 cmd_type_len ;
   __le32 olinfo_status ;
};
#line 2643 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_wb_394 {
   __le64 rsvd ;
   __le32 nxtseq_seed ;
   __le32 status ;
};
#line 2643 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union ixgbe_adv_tx_desc {
   struct __anonstruct_read_393 read ;
   struct __anonstruct_wb_394 wb ;
};
#line 2657 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_read_395 {
   __le64 pkt_addr ;
   __le64 hdr_addr ;
};
#line 2657 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_hs_rss_399 {
   __le16 pkt_info ;
   __le16 hdr_info ;
};
#line 2657 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union __anonunion_lo_dword_398 {
   __le32 data ;
   struct __anonstruct_hs_rss_399 hs_rss ;
};
#line 2657 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_csum_ip_401 {
   __le16 ip_id ;
   __le16 csum ;
};
#line 2657 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union __anonunion_hi_dword_400 {
   __le32 rss ;
   struct __anonstruct_csum_ip_401 csum_ip ;
};
#line 2657 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_lower_397 {
   union __anonunion_lo_dword_398 lo_dword ;
   union __anonunion_hi_dword_400 hi_dword ;
};
#line 2657 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_upper_402 {
   __le32 status_error ;
   __le16 length ;
   __le16 vlan ;
};
#line 2657 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_wb_396 {
   struct __anonstruct_lower_397 lower ;
   struct __anonstruct_upper_402 upper ;
};
#line 2657 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union ixgbe_adv_rx_desc {
   struct __anonstruct_read_395 read ;
   struct __anonstruct_wb_396 wb ;
};
#line 2754 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
typedef u32 ixgbe_autoneg_advertised;
#line 2756 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
typedef u32 ixgbe_link_speed;
#line 2768 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_formatted_403 {
   u8 vm_pool ;
   u8 flow_type ;
   __be16 vlan_id ;
   __be32 dst_ip[4U] ;
   __be32 src_ip[4U] ;
   __be16 src_port ;
   __be16 dst_port ;
   __be16 flex_bytes ;
   __be16 bkt_hash ;
};
#line 2768 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union ixgbe_atr_input {
   struct __anonstruct_formatted_403 formatted ;
   __be32 dword_stream[11U] ;
};
#line 2881 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_formatted_404 {
   u8 vm_pool ;
   u8 flow_type ;
   __be16 vlan_id ;
};
#line 2881 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_port_405 {
   __be16 src ;
   __be16 dst ;
};
#line 2881 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union ixgbe_atr_hash_dword {
   struct __anonstruct_formatted_404 formatted ;
   __be32 ip ;
   struct __anonstruct_port_405 port ;
   __be16 flex_bytes ;
   __be32 dword ;
};
#line 2925
enum ixgbe_eeprom_type {
    ixgbe_eeprom_uninitialized = 0,
    ixgbe_eeprom_spi = 1,
    ixgbe_flash = 2,
    ixgbe_eeprom_none = 3
} ;
#line 2932
enum ixgbe_mac_type {
    ixgbe_mac_unknown = 0,
    ixgbe_mac_82598EB = 1,
    ixgbe_mac_82599EB = 2,
    ixgbe_mac_X540 = 3,
    ixgbe_mac_X550 = 4,
    ixgbe_mac_X550EM_x = 5,
    ixgbe_num_macs = 6
} ;
#line 2942
enum ixgbe_phy_type {
    ixgbe_phy_unknown = 0,
    ixgbe_phy_none = 1,
    ixgbe_phy_tn = 2,
    ixgbe_phy_aq = 3,
    ixgbe_phy_x550em_kr = 4,
    ixgbe_phy_x550em_kx4 = 5,
    ixgbe_phy_x550em_ext_t = 6,
    ixgbe_phy_cu_unknown = 7,
    ixgbe_phy_qt = 8,
    ixgbe_phy_xaui = 9,
    ixgbe_phy_nl = 10,
    ixgbe_phy_sfp_passive_tyco = 11,
    ixgbe_phy_sfp_passive_unknown = 12,
    ixgbe_phy_sfp_active_unknown = 13,
    ixgbe_phy_sfp_avago = 14,
    ixgbe_phy_sfp_ftl = 15,
    ixgbe_phy_sfp_ftl_active = 16,
    ixgbe_phy_sfp_unknown = 17,
    ixgbe_phy_sfp_intel = 18,
    ixgbe_phy_qsfp_passive_unknown = 19,
    ixgbe_phy_qsfp_active_unknown = 20,
    ixgbe_phy_qsfp_intel = 21,
    ixgbe_phy_qsfp_unknown = 22,
    ixgbe_phy_sfp_unsupported = 23,
    ixgbe_phy_generic = 24
} ;
#line 2970
enum ixgbe_sfp_type {
    ixgbe_sfp_type_da_cu = 0,
    ixgbe_sfp_type_sr = 1,
    ixgbe_sfp_type_lr = 2,
    ixgbe_sfp_type_da_cu_core0 = 3,
    ixgbe_sfp_type_da_cu_core1 = 4,
    ixgbe_sfp_type_srlr_core0 = 5,
    ixgbe_sfp_type_srlr_core1 = 6,
    ixgbe_sfp_type_da_act_lmt_core0 = 7,
    ixgbe_sfp_type_da_act_lmt_core1 = 8,
    ixgbe_sfp_type_1g_cu_core0 = 9,
    ixgbe_sfp_type_1g_cu_core1 = 10,
    ixgbe_sfp_type_1g_sx_core0 = 11,
    ixgbe_sfp_type_1g_sx_core1 = 12,
    ixgbe_sfp_type_1g_lx_core0 = 13,
    ixgbe_sfp_type_1g_lx_core1 = 14,
    ixgbe_sfp_type_not_present = 65534,
    ixgbe_sfp_type_unknown = 65535
} ;
#line 2990
enum ixgbe_media_type {
    ixgbe_media_type_unknown = 0,
    ixgbe_media_type_fiber = 1,
    ixgbe_media_type_fiber_qsfp = 2,
    ixgbe_media_type_fiber_lco = 3,
    ixgbe_media_type_copper = 4,
    ixgbe_media_type_backplane = 5,
    ixgbe_media_type_cx4 = 6,
    ixgbe_media_type_virtual = 7
} ;
#line 3001
enum ixgbe_fc_mode {
    ixgbe_fc_none = 0,
    ixgbe_fc_rx_pause = 1,
    ixgbe_fc_tx_pause = 2,
    ixgbe_fc_full = 3,
    ixgbe_fc_default = 4
} ;
#line 3009
enum ixgbe_smart_speed {
    ixgbe_smart_speed_auto = 0,
    ixgbe_smart_speed_on = 1,
    ixgbe_smart_speed_off = 2
} ;
#line 3015
enum ixgbe_bus_type {
    ixgbe_bus_type_unknown = 0,
    ixgbe_bus_type_pci = 1,
    ixgbe_bus_type_pcix = 2,
    ixgbe_bus_type_pci_express = 3,
    ixgbe_bus_type_reserved = 4
} ;
#line 3023
enum ixgbe_bus_speed {
    ixgbe_bus_speed_unknown = 0,
    ixgbe_bus_speed_33 = 33,
    ixgbe_bus_speed_66 = 66,
    ixgbe_bus_speed_100 = 100,
    ixgbe_bus_speed_120 = 120,
    ixgbe_bus_speed_133 = 133,
    ixgbe_bus_speed_2500 = 2500,
    ixgbe_bus_speed_5000 = 5000,
    ixgbe_bus_speed_8000 = 8000,
    ixgbe_bus_speed_reserved = 8001
} ;
#line 3036
enum ixgbe_bus_width {
    ixgbe_bus_width_unknown = 0,
    ixgbe_bus_width_pcie_x1 = 1,
    ixgbe_bus_width_pcie_x2 = 2,
    ixgbe_bus_width_pcie_x4 = 4,
    ixgbe_bus_width_pcie_x8 = 8,
    ixgbe_bus_width_32 = 32,
    ixgbe_bus_width_64 = 64,
    ixgbe_bus_width_reserved = 65
} ;
#line 3047 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_addr_filter_info {
   u32 num_mc_addrs ;
   u32 rar_used_count ;
   u32 mta_in_use ;
   u32 overflow_promisc ;
   bool uc_set_promisc ;
   bool user_set_promisc ;
};
#line 3078 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_bus_info {
   enum ixgbe_bus_speed speed ;
   enum ixgbe_bus_width width ;
   enum ixgbe_bus_type type ;
   u16 func ;
   u16 lan_id ;
};
#line 3088 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_fc_info {
   u32 high_water[8U] ;
   u32 low_water[8U] ;
   u16 pause_time ;
   bool send_xon ;
   bool strict_ieee ;
   bool disable_fc_autoneg ;
   bool fc_was_autonegged ;
   enum ixgbe_fc_mode current_mode ;
   enum ixgbe_fc_mode requested_mode ;
};
#line 3101 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hw_stats {
   u64 crcerrs ;
   u64 illerrc ;
   u64 errbc ;
   u64 mspdc ;
   u64 mpctotal ;
   u64 mpc[8U] ;
   u64 mlfc ;
   u64 mrfc ;
   u64 rlec ;
   u64 lxontxc ;
   u64 lxonrxc ;
   u64 lxofftxc ;
   u64 lxoffrxc ;
   u64 pxontxc[8U] ;
   u64 pxonrxc[8U] ;
   u64 pxofftxc[8U] ;
   u64 pxoffrxc[8U] ;
   u64 prc64 ;
   u64 prc127 ;
   u64 prc255 ;
   u64 prc511 ;
   u64 prc1023 ;
   u64 prc1522 ;
   u64 gprc ;
   u64 bprc ;
   u64 mprc ;
   u64 gptc ;
   u64 gorc ;
   u64 gotc ;
   u64 rnbc[8U] ;
   u64 ruc ;
   u64 rfc ;
   u64 roc ;
   u64 rjc ;
   u64 mngprc ;
   u64 mngpdc ;
   u64 mngptc ;
   u64 tor ;
   u64 tpr ;
   u64 tpt ;
   u64 ptc64 ;
   u64 ptc127 ;
   u64 ptc255 ;
   u64 ptc511 ;
   u64 ptc1023 ;
   u64 ptc1522 ;
   u64 mptc ;
   u64 bptc ;
   u64 xec ;
   u64 rqsmr[16U] ;
   u64 tqsmr[8U] ;
   u64 qprc[16U] ;
   u64 qptc[16U] ;
   u64 qbrc[16U] ;
   u64 qbtc[16U] ;
   u64 qprdc[16U] ;
   u64 pxon2offc[8U] ;
   u64 fdirustat_add ;
   u64 fdirustat_remove ;
   u64 fdirfstat_fadd ;
   u64 fdirfstat_fremove ;
   u64 fdirmatch ;
   u64 fdirmiss ;
   u64 fccrc ;
   u64 fcoerpdc ;
   u64 fcoeprc ;
   u64 fcoeptc ;
   u64 fcoedwrc ;
   u64 fcoedwtc ;
   u64 fcoe_noddp ;
   u64 fcoe_noddp_ext_buff ;
   u64 b2ospc ;
   u64 b2ogprc ;
   u64 o2bgptc ;
   u64 o2bspc ;
};
#line 3186 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_eeprom_operations {
   s32 (*init_params)(struct ixgbe_hw * ) ;
   s32 (*read)(struct ixgbe_hw * , u16  , u16 * ) ;
   s32 (*read_buffer)(struct ixgbe_hw * , u16  , u16  , u16 * ) ;
   s32 (*write)(struct ixgbe_hw * , u16  , u16  ) ;
   s32 (*write_buffer)(struct ixgbe_hw * , u16  , u16  , u16 * ) ;
   s32 (*validate_checksum)(struct ixgbe_hw * , u16 * ) ;
   s32 (*update_checksum)(struct ixgbe_hw * ) ;
   s32 (*calc_checksum)(struct ixgbe_hw * ) ;
};
#line 3199 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_mac_operations {
   s32 (*init_hw)(struct ixgbe_hw * ) ;
   s32 (*reset_hw)(struct ixgbe_hw * ) ;
   s32 (*start_hw)(struct ixgbe_hw * ) ;
   s32 (*clear_hw_cntrs)(struct ixgbe_hw * ) ;
   enum ixgbe_media_type (*get_media_type)(struct ixgbe_hw * ) ;
   s32 (*get_mac_addr)(struct ixgbe_hw * , u8 * ) ;
   s32 (*get_san_mac_addr)(struct ixgbe_hw * , u8 * ) ;
   s32 (*get_device_caps)(struct ixgbe_hw * , u16 * ) ;
   s32 (*get_wwn_prefix)(struct ixgbe_hw * , u16 * , u16 * ) ;
   s32 (*stop_adapter)(struct ixgbe_hw * ) ;
   s32 (*get_bus_info)(struct ixgbe_hw * ) ;
   void (*set_lan_id)(struct ixgbe_hw * ) ;
   s32 (*read_analog_reg8)(struct ixgbe_hw * , u32  , u8 * ) ;
   s32 (*write_analog_reg8)(struct ixgbe_hw * , u32  , u8  ) ;
   s32 (*setup_sfp)(struct ixgbe_hw * ) ;
   s32 (*disable_rx_buff)(struct ixgbe_hw * ) ;
   s32 (*enable_rx_buff)(struct ixgbe_hw * ) ;
   s32 (*enable_rx_dma)(struct ixgbe_hw * , u32  ) ;
   s32 (*acquire_swfw_sync)(struct ixgbe_hw * , u32  ) ;
   void (*release_swfw_sync)(struct ixgbe_hw * , u32  ) ;
   s32 (*prot_autoc_read)(struct ixgbe_hw * , bool * , u32 * ) ;
   s32 (*prot_autoc_write)(struct ixgbe_hw * , u32  , bool  ) ;
   void (*disable_tx_laser)(struct ixgbe_hw * ) ;
   void (*enable_tx_laser)(struct ixgbe_hw * ) ;
   void (*flap_tx_laser)(struct ixgbe_hw * ) ;
   void (*stop_link_on_d3)(struct ixgbe_hw * ) ;
   s32 (*setup_link)(struct ixgbe_hw * , ixgbe_link_speed  , bool  ) ;
   s32 (*check_link)(struct ixgbe_hw * , ixgbe_link_speed * , bool * , bool  ) ;
   s32 (*get_link_capabilities)(struct ixgbe_hw * , ixgbe_link_speed * , bool * ) ;
   void (*set_rxpba)(struct ixgbe_hw * , int  , u32  , int  ) ;
   s32 (*led_on)(struct ixgbe_hw * , u32  ) ;
   s32 (*led_off)(struct ixgbe_hw * , u32  ) ;
   s32 (*blink_led_start)(struct ixgbe_hw * , u32  ) ;
   s32 (*blink_led_stop)(struct ixgbe_hw * , u32  ) ;
   s32 (*set_rar)(struct ixgbe_hw * , u32  , u8 * , u32  , u32  ) ;
   s32 (*clear_rar)(struct ixgbe_hw * , u32  ) ;
   s32 (*set_vmdq)(struct ixgbe_hw * , u32  , u32  ) ;
   s32 (*set_vmdq_san_mac)(struct ixgbe_hw * , u32  ) ;
   s32 (*clear_vmdq)(struct ixgbe_hw * , u32  , u32  ) ;
   s32 (*init_rx_addrs)(struct ixgbe_hw * ) ;
   s32 (*update_mc_addr_list)(struct ixgbe_hw * , struct net_device * ) ;
   s32 (*enable_mc)(struct ixgbe_hw * ) ;
   s32 (*disable_mc)(struct ixgbe_hw * ) ;
   s32 (*clear_vfta)(struct ixgbe_hw * ) ;
   s32 (*set_vfta)(struct ixgbe_hw * , u32  , u32  , bool  ) ;
   s32 (*init_uta_tables)(struct ixgbe_hw * ) ;
   void (*set_mac_anti_spoofing)(struct ixgbe_hw * , bool  , int  ) ;
   void (*set_vlan_anti_spoofing)(struct ixgbe_hw * , bool  , int  ) ;
   s32 (*fc_enable)(struct ixgbe_hw * ) ;
   s32 (*set_fw_drv_ver)(struct ixgbe_hw * , u8  , u8  , u8  , u8  ) ;
   s32 (*get_thermal_sensor_data)(struct ixgbe_hw * ) ;
   s32 (*init_thermal_sensor_thresh)(struct ixgbe_hw * ) ;
   void (*disable_rx)(struct ixgbe_hw * ) ;
   void (*enable_rx)(struct ixgbe_hw * ) ;
   void (*set_source_address_pruning)(struct ixgbe_hw * , bool  , unsigned int  ) ;
   void (*set_ethertype_anti_spoofing)(struct ixgbe_hw * , bool  , int  ) ;
   s32 (*dmac_config)(struct ixgbe_hw * ) ;
   s32 (*dmac_update_tcs)(struct ixgbe_hw * ) ;
   s32 (*dmac_config_tcs)(struct ixgbe_hw * ) ;
};
#line 3277 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_phy_operations {
   s32 (*identify)(struct ixgbe_hw * ) ;
   s32 (*identify_sfp)(struct ixgbe_hw * ) ;
   s32 (*init)(struct ixgbe_hw * ) ;
   s32 (*reset)(struct ixgbe_hw * ) ;
   s32 (*read_reg)(struct ixgbe_hw * , u32  , u32  , u16 * ) ;
   s32 (*write_reg)(struct ixgbe_hw * , u32  , u32  , u16  ) ;
   s32 (*read_reg_mdi)(struct ixgbe_hw * , u32  , u32  , u16 * ) ;
   s32 (*write_reg_mdi)(struct ixgbe_hw * , u32  , u32  , u16  ) ;
   s32 (*setup_link)(struct ixgbe_hw * ) ;
   s32 (*setup_internal_link)(struct ixgbe_hw * ) ;
   s32 (*setup_link_speed)(struct ixgbe_hw * , ixgbe_link_speed  , bool  ) ;
   s32 (*check_link)(struct ixgbe_hw * , ixgbe_link_speed * , bool * ) ;
   s32 (*get_firmware_version)(struct ixgbe_hw * , u16 * ) ;
   s32 (*read_i2c_byte)(struct ixgbe_hw * , u8  , u8  , u8 * ) ;
   s32 (*write_i2c_byte)(struct ixgbe_hw * , u8  , u8  , u8  ) ;
   s32 (*read_i2c_sff8472)(struct ixgbe_hw * , u8  , u8 * ) ;
   s32 (*read_i2c_eeprom)(struct ixgbe_hw * , u8  , u8 * ) ;
   s32 (*write_i2c_eeprom)(struct ixgbe_hw * , u8  , u8  ) ;
   s32 (*read_i2c_combined)(struct ixgbe_hw * , u8  , u16  , u16 * ) ;
   s32 (*write_i2c_combined)(struct ixgbe_hw * , u8  , u16  , u16  ) ;
   s32 (*check_overtemp)(struct ixgbe_hw * ) ;
   s32 (*set_phy_power)(struct ixgbe_hw * , bool  ) ;
   s32 (*handle_lasi)(struct ixgbe_hw * ) ;
};
#line 3303 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_eeprom_info {
   struct ixgbe_eeprom_operations ops ;
   enum ixgbe_eeprom_type type ;
   u32 semaphore_delay ;
   u16 word_size ;
   u16 address_bits ;
   u16 word_page_size ;
};
#line 3312 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_mac_info {
   struct ixgbe_mac_operations ops ;
   enum ixgbe_mac_type type ;
   u8 addr[6U] ;
   u8 perm_addr[6U] ;
   u8 san_addr[6U] ;
   u16 wwnn_prefix ;
   u16 wwpn_prefix ;
   u16 max_msix_vectors ;
   u32 mta_shadow[128U] ;
   s32 mc_filter_type ;
   u32 mcft_size ;
   u32 vft_size ;
   u32 num_rar_entries ;
   u32 rar_highwater ;
   u32 rx_pb_size ;
   u32 max_tx_queues ;
   u32 max_rx_queues ;
   u32 orig_autoc ;
   u32 orig_autoc2 ;
   bool orig_link_settings_stored ;
   bool autotry_restart ;
   u8 flags ;
   u8 san_mac_rar_index ;
   struct ixgbe_thermal_sensor_data thermal_sensor_data ;
   bool set_lben ;
};
#line 3344 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_phy_info {
   struct ixgbe_phy_operations ops ;
   struct mdio_if_info mdio ;
   enum ixgbe_phy_type type ;
   u32 id ;
   enum ixgbe_sfp_type sfp_type ;
   bool sfp_setup_needed ;
   u32 revision ;
   enum ixgbe_media_type media_type ;
   u8 lan_id ;
   u32 phy_semaphore_mask ;
   bool reset_disable ;
   ixgbe_autoneg_advertised autoneg_advertised ;
   enum ixgbe_smart_speed smart_speed ;
   bool smart_speed_active ;
   bool multispeed_fiber ;
   bool reset_if_overtemp ;
   bool qsfp_shared_i2c_bus ;
   u32 nw_mng_if_sel ;
};
#line 124 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
struct ixgbe_mbx_operations;
#line 125 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
struct ixgbe_mbx_operations {
   s32 (*init_params)(struct ixgbe_hw * ) ;
   s32 (*read)(struct ixgbe_hw * , u32 * , u16  , u16  ) ;
   s32 (*write)(struct ixgbe_hw * , u32 * , u16  , u16  ) ;
   s32 (*read_posted)(struct ixgbe_hw * , u32 * , u16  , u16  ) ;
   s32 (*write_posted)(struct ixgbe_hw * , u32 * , u16  , u16  ) ;
   s32 (*check_for_msg)(struct ixgbe_hw * , u16  ) ;
   s32 (*check_for_ack)(struct ixgbe_hw * , u16  ) ;
   s32 (*check_for_rst)(struct ixgbe_hw * , u16  ) ;
};
#line 3378 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_mbx_stats {
   u32 msgs_tx ;
   u32 msgs_rx ;
   u32 acks ;
   u32 reqs ;
   u32 rsts ;
};
#line 3387 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_mbx_info {
   struct ixgbe_mbx_operations ops ;
   struct ixgbe_mbx_stats stats ;
   u32 timeout ;
   u32 usec_delay ;
   u32 v2p_mailbox ;
   u16 size ;
};
#line 3396 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hw {
   u8 *hw_addr ;
   void *back ;
   struct ixgbe_mac_info mac ;
   struct ixgbe_addr_filter_info addr_ctrl ;
   struct ixgbe_fc_info fc ;
   struct ixgbe_phy_info phy ;
   struct ixgbe_eeprom_info eeprom ;
   struct ixgbe_bus_info bus ;
   struct ixgbe_mbx_info mbx ;
   u32 const   *mvals ;
   u16 device_id ;
   u16 vendor_id ;
   u16 subsystem_device_id ;
   u16 subsystem_vendor_id ;
   u8 revision_id ;
   bool adapter_stopped ;
   bool force_full_reset ;
   bool allow_unsupported_sfp ;
   bool wol_enabled ;
};
#line 3418 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_info {
   enum ixgbe_mac_type mac ;
   s32 (*get_invariants)(struct ixgbe_hw * ) ;
   struct ixgbe_mac_operations *mac_ops ;
   struct ixgbe_eeprom_operations *eeprom_ops ;
   struct ixgbe_phy_operations *phy_ops ;
   struct ixgbe_mbx_operations *mbx_ops ;
   u32 const   *mvals ;
};
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
enum strict_prio_type {
    prio_none = 0,
    prio_group = 1,
    prio_link = 2
} ;
#line 77 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct dcb_support {
   u32 capabilities ;
   u8 traffic_classes ;
   u8 pfc_traffic_classes ;
};
#line 97 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct tc_bw_alloc {
   u8 bwg_id ;
   u8 bwg_percent ;
   u8 link_percent ;
   u8 up_to_tc_bitmap ;
   u16 data_credits_refill ;
   u16 data_credits_max ;
   enum strict_prio_type prio_type ;
};
#line 109
enum dcb_pfc_type {
    pfc_disabled = 0,
    pfc_enabled_full = 1,
    pfc_enabled_tx = 2,
    pfc_enabled_rx = 3
} ;
#line 116 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct tc_configuration {
   struct tc_bw_alloc path[2U] ;
   enum dcb_pfc_type dcb_pfc ;
   u16 desc_credits_max ;
   u8 tc ;
};
#line 125 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct dcb_num_tcs {
   u8 pg_tcs ;
   u8 pfc_tcs ;
};
#line 130 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct ixgbe_dcb_config {
   struct dcb_support support ;
   struct dcb_num_tcs num_tcs ;
   struct tc_configuration tc_config[8U] ;
   u8 bw_percentage[2U][8U] ;
   bool pfc_mode_enable ;
   u32 dcb_cfg_version ;
   u32 link_speed ;
};
#line 339 "./include/uapi/scsi/fc/fc_fs.h"
struct ixgbe_fcoe_ddp {
   int len ;
   u32 err ;
   unsigned int sgc ;
   struct scatterlist *sgl ;
   dma_addr_t udp ;
   u64 *udl ;
   struct dma_pool *pool ;
};
#line 69 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.h"
struct ixgbe_fcoe_ddp_pool {
   struct dma_pool *pool ;
   u64 noddp ;
   u64 noddp_ext_buff ;
};
#line 76 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.h"
struct ixgbe_fcoe {
   struct ixgbe_fcoe_ddp_pool *ddp_pool ;
   atomic_t refcnt ;
   spinlock_t lock ;
   struct ixgbe_fcoe_ddp ddp[2048U] ;
   void *extra_ddp_buffer ;
   dma_addr_t extra_ddp_buffer_dma ;
   unsigned long mode ;
   u8 up ;
};
#line 143 "include/net/busy_poll.h"
struct vf_data_storage {
   unsigned char vf_mac_addresses[6U] ;
   u16 vf_mc_hashes[30U] ;
   u16 num_vf_mc_hashes ;
   u16 default_vf_vlan_id ;
   u16 vlans_enabled ;
   bool clear_to_send ;
   bool pf_set_mac ;
   u16 pf_vlan ;
   u16 pf_qos ;
   u16 tx_rate ;
   u16 vlan_count ;
   u8 spoofchk_enabled ;
   bool rss_query_enabled ;
   unsigned int vf_api ;
};
#line 157 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct vf_macvlans {
   struct list_head l ;
   int vf ;
   bool free ;
   bool is_macvlan ;
   u8 vf_macvlan[6U] ;
};
#line 165 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_tx_buffer {
   union ixgbe_adv_tx_desc *next_to_watch ;
   unsigned long time_stamp ;
   struct sk_buff *skb ;
   unsigned int bytecount ;
   unsigned short gso_segs ;
   __be16 protocol ;
   dma_addr_t dma ;
   __u32 len ;
   u32 tx_flags ;
};
#line 186 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_rx_buffer {
   struct sk_buff *skb ;
   dma_addr_t dma ;
   struct page *page ;
   unsigned int page_offset ;
};
#line 193 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_queue_stats {
   u64 packets ;
   u64 bytes ;
   u64 yields ;
   u64 misses ;
   u64 cleaned ;
};
#line 202 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_tx_queue_stats {
   u64 restart_queue ;
   u64 tx_busy ;
   u64 tx_done_old ;
};
#line 209 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_rx_queue_stats {
   u64 rsc_count ;
   u64 rsc_flush ;
   u64 non_eop_descs ;
   u64 alloc_rx_page_failed ;
   u64 alloc_rx_buff_failed ;
   u64 csum_err ;
};
#line 228
struct ixgbe_adapter;
#line 228 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_fwd_adapter {
   unsigned long active_vlans[64U] ;
   struct net_device *netdev ;
   struct ixgbe_adapter *real_adapter ;
   unsigned int tx_base_queue ;
   unsigned int rx_base_queue ;
   int pool ;
};
#line 237
struct ixgbe_q_vector;
#line 237 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
union __anonunion____missing_field_name_406 {
   struct ixgbe_tx_buffer *tx_buffer_info ;
   struct ixgbe_rx_buffer *rx_buffer_info ;
};
#line 237 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct __anonstruct____missing_field_name_408 {
   u8 atr_sample_rate ;
   u8 atr_count ;
};
#line 237 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
union __anonunion____missing_field_name_407 {
   u16 next_to_alloc ;
   struct __anonstruct____missing_field_name_408 __annonCompField119 ;
};
#line 237 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
union __anonunion____missing_field_name_409 {
   struct ixgbe_tx_queue_stats tx_stats ;
   struct ixgbe_rx_queue_stats rx_stats ;
};
#line 237 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_ring {
   struct ixgbe_ring *next ;
   struct ixgbe_q_vector *q_vector ;
   struct net_device *netdev ;
   struct device *dev ;
   struct ixgbe_fwd_adapter *l2_accel_priv ;
   void *desc ;
   union __anonunion____missing_field_name_406 __annonCompField118 ;
   unsigned long state ;
   u8 *tail ;
   dma_addr_t dma ;
   unsigned int size ;
   u16 count ;
   u8 queue_index ;
   u8 reg_idx ;
   u16 next_to_use ;
   u16 next_to_clean ;
   union __anonunion____missing_field_name_407 __annonCompField120 ;
   u8 dcb_tc ;
   struct ixgbe_queue_stats stats ;
   struct u64_stats_sync syncp ;
   union __anonunion____missing_field_name_409 __annonCompField121 ;
};
#line 302 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_ring_feature {
   u16 limit ;
   u16 indices ;
   u16 mask ;
   u16 offset ;
};
#line 352 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_ring_container {
   struct ixgbe_ring *ring ;
   unsigned int total_bytes ;
   unsigned int total_packets ;
   u16 work_limit ;
   u8 count ;
   u8 itr ;
};
#line 362 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_q_vector {
   struct ixgbe_adapter *adapter ;
   int cpu ;
   u16 v_idx ;
   u16 itr ;
   struct ixgbe_ring_container rx ;
   struct ixgbe_ring_container tx ;
   struct napi_struct napi ;
   cpumask_t affinity_mask ;
   int numa_node ;
   struct callback_head rcu ;
   char name[25U] ;
   atomic_t state ;
   struct ixgbe_ring ring[0U] ;
};
#line 474 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct hwmon_attr {
   struct device_attribute dev_attr ;
   struct ixgbe_hw *hw ;
   struct ixgbe_thermal_diode_data *sensor ;
   char name[12U] ;
};
#line 525 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct hwmon_buff {
   struct attribute_group group ;
   struct attribute_group  const  *groups[2U] ;
   struct attribute *attrs[13U] ;
   struct hwmon_attr hwmon_list[12U] ;
   unsigned int n_hwmon ;
};
#line 559 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_mac_addr {
   u8 addr[6U] ;
   u16 queue ;
   u16 state ;
};
#line 586 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_adapter {
   unsigned long active_vlans[64U] ;
   struct net_device *netdev ;
   struct pci_dev *pdev ;
   unsigned long state ;
   u32 flags ;
   u32 flags2 ;
   int num_tx_queues ;
   u16 tx_itr_setting ;
   u16 tx_work_limit ;
   int num_rx_queues ;
   u16 rx_itr_setting ;
   struct ixgbe_ring *tx_ring[64U] ;
   u64 restart_queue ;
   u64 lsc_int ;
   u32 tx_timeout_count ;
   struct ixgbe_ring *rx_ring[64U] ;
   int num_rx_pools ;
   int num_rx_queues_per_pool ;
   u64 hw_csum_rx_error ;
   u64 hw_rx_no_dma_resources ;
   u64 rsc_total_count ;
   u64 rsc_total_flush ;
   u64 non_eop_descs ;
   u32 alloc_rx_page_failed ;
   u32 alloc_rx_buff_failed ;
   struct ixgbe_q_vector *q_vector[64U] ;
   struct ieee_pfc *ixgbe_ieee_pfc ;
   struct ieee_ets *ixgbe_ieee_ets ;
   struct ixgbe_dcb_config dcb_cfg ;
   struct ixgbe_dcb_config temp_dcb_cfg ;
   u8 dcb_set_bitmap ;
   u8 dcbx_cap ;
   enum ixgbe_fc_mode last_lfc_mode ;
   int num_q_vectors ;
   int max_q_vectors ;
   struct ixgbe_ring_feature ring_feature[5U] ;
   struct msix_entry *msix_entries ;
   u32 test_icr ;
   struct ixgbe_ring test_tx_ring ;
   struct ixgbe_ring test_rx_ring ;
   struct ixgbe_hw hw ;
   u16 msg_enable ;
   struct ixgbe_hw_stats stats ;
   u64 tx_busy ;
   unsigned int tx_ring_count ;
   unsigned int rx_ring_count ;
   u32 link_speed ;
   bool link_up ;
   unsigned long link_check_timeout ;
   struct timer_list service_timer ;
   struct work_struct service_task ;
   struct hlist_head fdir_filter_list ;
   unsigned long fdir_overflow ;
   union ixgbe_atr_input fdir_mask ;
   int fdir_filter_count ;
   u32 fdir_pballoc ;
   u32 atr_sample_rate ;
   spinlock_t fdir_perfect_lock ;
   struct ixgbe_fcoe fcoe ;
   u8 *io_addr ;
   u32 wol ;
   u16 bridge_mode ;
   u16 eeprom_verh ;
   u16 eeprom_verl ;
   u16 eeprom_cap ;
   u32 interrupt_event ;
   u32 led_reg ;
   struct ptp_clock *ptp_clock ;
   struct ptp_clock_info ptp_caps ;
   struct work_struct ptp_tx_work ;
   struct sk_buff *ptp_tx_skb ;
   struct hwtstamp_config tstamp_config ;
   unsigned long ptp_tx_start ;
   unsigned long last_overflow_check ;
   unsigned long last_rx_ptp_check ;
   unsigned long last_rx_timestamp ;
   spinlock_t tmreg_lock ;
   struct cyclecounter cc ;
   struct timecounter tc ;
   u32 base_incval ;
   unsigned long active_vfs[1U] ;
   unsigned int num_vfs ;
   struct vf_data_storage *vfinfo ;
   int vf_rate_link_speed ;
   struct vf_macvlans vf_mvs ;
   struct vf_macvlans *mv_list ;
   u32 timer_event_accumulator ;
   u32 vferr_refcount ;
   struct ixgbe_mac_addr *mac_table ;
   u16 vxlan_port ;
   struct kobject *info_kobj ;
   struct hwmon_buff *ixgbe_hwmon_buff ;
   struct dentry *ixgbe_dbg_adapter ;
   u8 default_up ;
   unsigned long fwd_bitmask ;
   u8 rss_indir_tbl[512U] ;
   u32 rss_key[10U] ;
};
#line 796 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_fdir_filter {
   struct hlist_node fdir_node ;
   union ixgbe_atr_input filter ;
   u16 sw_idx ;
   u16 action ;
};
#line 816 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
union __anonunion____missing_field_name_410 {
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
#line 816 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_cb {
   union __anonunion____missing_field_name_410 __annonCompField122 ;
   dma_addr_t dma ;
   u16 append_cnt ;
   bool page_released ;
};
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
struct ixgbe_reg_info {
   u32 ofs ;
   char *name ;
};
#line 560 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
struct my_u0 {
   u64 a ;
   u64 b ;
};
#line 7202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
union __anonunion_hdr_412 {
   unsigned char *network ;
   struct iphdr *ipv4 ;
   struct ipv6hdr *ipv6 ;
};
#line 2831 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef bool ldv_func_ret_type;
#line 2842 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef bool ldv_func_ret_type___0;
#line 2853 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef bool ldv_func_ret_type___1;
#line 2872 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 2907 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 2942 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef int ldv_func_ret_type___4;
#line 2955 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef int ldv_func_ret_type___5;
#line 2976 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef int ldv_func_ret_type___6;
#line 2989 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef int ldv_func_ret_type___7;
#line 3026 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef int ldv_func_ret_type___8;
#line 3037 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef int ldv_func_ret_type___9;
#line 3056 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef int ldv_func_ret_type___10;
#line 3067 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef int ldv_func_ret_type___11;
#line 3088 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef bool ldv_func_ret_type___12;
#line 3115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
typedef int ldv_func_ret_type___13;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 244 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union __anonunion_cmd_or_resp_322 {
   u8 cmd_resv ;
   u8 ret_status ;
};
#line 244 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_hdr {
   u8 cmd ;
   u8 buf_len ;
   union __anonunion_cmd_or_resp_322 cmd_or_resp ;
   u8 checksum ;
};
#line 2606 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_drv_info {
   struct ixgbe_hic_hdr hdr ;
   u8 port_num ;
   u8 ver_sub ;
   u8 ver_build ;
   u8 ver_min ;
   u8 ver_maj ;
   u8 pad ;
   u16 pad2 ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 173 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h"
struct ixgbe_stats {
   char stat_string[32U] ;
   int type ;
   int sizeof_stat ;
   int stat_offset ;
};
#line 1267 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
struct ixgbe_reg_test {
   u16 reg ;
   u8 array_len ;
   u8 test_type ;
   u32 mask ;
   u32 write ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 2587 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_hdr2_req {
   u8 cmd ;
   u8 buf_lenh ;
   u8 buf_lenl ;
   u8 checksum ;
};
#line 2594 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_hdr2_rsp {
   u8 cmd ;
   u8 buf_lenl ;
   u8 buf_lenh_status ;
   u8 checksum ;
};
#line 2601 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union ixgbe_hic_hdr2 {
   struct ixgbe_hic_hdr2_req req ;
   struct ixgbe_hic_hdr2_rsp rsp ;
};
#line 2617 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_read_shadow_ram {
   union ixgbe_hic_hdr2 hdr ;
   u32 address ;
   u16 length ;
   u16 pad2 ;
   u16 data ;
   u16 pad3 ;
};
#line 2627 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_write_shadow_ram {
   union ixgbe_hic_hdr2 hdr ;
   __be32 address ;
   __be16 length ;
   u16 pad2 ;
   u16 data ;
   u16 pad3 ;
};
#line 2636 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_disable_rxen {
   struct ixgbe_hic_hdr hdr ;
   u8 port_number ;
   u8 pad2 ;
   u16 pad3 ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 2688 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_adv_tx_context_desc {
   __le32 vlan_macip_lens ;
   __le32 seqnum_seed ;
   __le32 type_tucmd_mlhl ;
   __le32 mss_l4len_idx ;
};
#line 81 "include/linux/timekeeping.h"
enum tk_offsets {
    TK_OFFS_REAL = 0,
    TK_OFFS_BOOT = 1,
    TK_OFFS_TAI = 2,
    TK_OFFS_MAX = 3
} ;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 48 "include/linux/pps_kernel.h"
struct pps_event_time {
   struct timespec ts_real ;
};
#line 141 "include/linux/ptp_clock_kernel.h"
union __anonunion____missing_field_name_321 {
   u64 timestamp ;
   struct pps_event_time pps_times ;
};
#line 141 "include/linux/ptp_clock_kernel.h"
struct ptp_clock_event {
   int type ;
   int index ;
   union __anonunion____missing_field_name_321 __annonCompField96 ;
};
#line 608 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
typedef bool ldv_func_ret_type___14;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 17 "include/linux/smp.h"
struct call_single_data {
   struct llist_node llist ;
   void (*func)(void * ) ;
   void *info ;
   unsigned int flags ;
};
#line 44 "./include/uapi/linux/fiemap.h"
struct bio_set;
#line 45
struct bio;
#line 46
struct bio_integrity_payload;
#line 17 "include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 28 "include/linux/blk_types.h"
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned int bi_idx ;
   unsigned int bi_bvec_done ;
};
#line 40 "include/linux/blk_types.h"
union __anonunion____missing_field_name_236___0 {
   struct bio_integrity_payload *bi_integrity ;
};
#line 40 "include/linux/blk_types.h"
struct bio {
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   struct bvec_iter bi_iter ;
   unsigned int bi_phys_segments ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   atomic_t __bi_remaining ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   union __anonunion____missing_field_name_236___0 __annonCompField65 ;
   unsigned short bi_vcnt ;
   unsigned short bi_max_vecs ;
   atomic_t __bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 61 "include/uapi/linux/fs.h"
struct hd_geometry;
#line 1555 "include/linux/fs.h"
struct block_device_operations;
#line 163 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct fc_frame_header {
   __u8 fh_r_ctl ;
   __u8 fh_d_id[3U] ;
   __u8 fh_cs_ctl ;
   __u8 fh_s_id[3U] ;
   __u8 fh_type ;
   __u8 fh_f_ctl[3U] ;
   __u8 fh_seq_id ;
   __u8 fh_df_ctl ;
   __be16 fh_seq_cnt ;
   __be16 fh_ox_id ;
   __be16 fh_rx_id ;
   __be32 fh_parm_offset ;
};
#line 339 "./include/uapi/scsi/fc/fc_fs.h"
struct fcoe_hdr {
   __u8 fcoe_ver ;
   __u8 fcoe_resvd[12U] ;
   __u8 fcoe_sof ;
};
#line 56 "include/scsi/fc/fc_fcoe.h"
struct fcoe_crc_eof {
   __le32 fcoe_crc32 ;
   __u8 fcoe_eof ;
   __u8 fcoe_resvd[3U] ;
};
#line 80 "include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};
#line 89 "include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
#line 101 "include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};
#line 155 "include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 162
struct disk_events;
#line 163
struct timer_rand_state;
#line 163
struct blk_integrity;
#line 163 "include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};
#line 72 "include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 32 "include/linux/backing-dev-defs.h"
typedef int congested_fn(void * , int  );
#line 41 "include/linux/backing-dev-defs.h"
struct bdi_writeback_congested {
   unsigned long state ;
   atomic_t refcnt ;
   struct backing_dev_info *bdi ;
   int blkcg_id ;
   struct rb_node rb_node ;
};
#line 60 "include/linux/backing-dev-defs.h"
union __anonunion____missing_field_name_392 {
   struct work_struct release_work ;
   struct callback_head rcu ;
};
#line 60 "include/linux/backing-dev-defs.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned long state ;
   unsigned long last_old_flush ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   struct list_head b_dirty_time ;
   spinlock_t list_lock ;
   struct percpu_counter stat[4U] ;
   struct bdi_writeback_congested *congested ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   spinlock_t work_lock ;
   struct list_head work_list ;
   struct delayed_work dwork ;
   struct percpu_ref refcnt ;
   struct fprop_local_percpu memcg_completions ;
   struct cgroup_subsys_state *memcg_css ;
   struct cgroup_subsys_state *blkcg_css ;
   struct list_head memcg_node ;
   struct list_head blkcg_node ;
   union __anonunion____missing_field_name_392 __annonCompField121 ;
};
#line 132 "include/linux/backing-dev-defs.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   atomic_long_t tot_write_bandwidth ;
   struct bdi_writeback wb ;
   struct radix_tree_root cgwb_tree ;
   struct rb_root cgwb_congested_tree ;
   atomic_t usage_cnt ;
   wait_queue_head_t wb_waitq ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 11 "include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t  , void * );
#line 12 "include/linux/mempool.h"
typedef void mempool_free_t(void * , void * );
#line 13 "include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 24 "include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 78 "include/linux/mempool.h"
union __anonunion____missing_field_name_393 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 78 "include/linux/mempool.h"
union __anonunion____missing_field_name_394 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 78 "include/linux/mempool.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion____missing_field_name_393 __annonCompField122 ;
   union __anonunion____missing_field_name_394 __annonCompField123 ;
   unsigned int flags ;
};
#line 92 "include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 326 "include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   struct bvec_iter bip_iter ;
   bio_end_io_t *bip_end_io ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_max_vcnt ;
   unsigned short bip_flags ;
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};
#line 541 "include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 662 "include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t *bio_pool ;
   mempool_t *bvec_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};
#line 64 "include/uapi/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
#line 22 "include/linux/bsg.h"
struct elevator_queue;
#line 24
struct request;
#line 26
struct bsg_job;
#line 27
struct blkcg_gq;
#line 28
struct blk_flush_queue;
#line 49 "include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request * , int  );
#line 50 "include/linux/blkdev.h"
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_395 {
   struct call_single_data csd ;
   unsigned long fifo_time ;
};
#line 75
struct blk_mq_ctx;
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_396 {
   struct hlist_node hash ;
   struct list_head ipi_list ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_397 {
   struct rb_node rb_node ;
   void *completion_data ;
};
#line 75 "include/linux/blkdev.h"
struct __anonstruct_elv_399 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 75 "include/linux/blkdev.h"
struct __anonstruct_flush_400 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_398 {
   struct __anonstruct_elv_399 elv ;
   struct __anonstruct_flush_400 flush ;
};
#line 75 "include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   union __anonunion____missing_field_name_395 __annonCompField124 ;
   struct request_queue *q ;
   struct blk_mq_ctx *mq_ctx ;
   u64 cmd_flags ;
   unsigned int cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   union __anonunion____missing_field_name_396 __annonCompField125 ;
   union __anonunion____missing_field_name_397 __annonCompField126 ;
   union __anonunion____missing_field_name_398 __annonCompField127 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   struct request_list *rl ;
   unsigned long long start_time_ns ;
   unsigned long long io_start_time_ns ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   void *special ;
   int tag ;
   int errors ;
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
#line 113 "include/linux/hashtable.h"
struct elevator_type;
#line 12 "include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
#line 15 "include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
#line 17 "include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
#line 19 "include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
#line 21 "include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
#line 24 "include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue * , int  );
#line 26 "include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
#line 27 "include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
#line 28 "include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
#line 29 "include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue * , int  );
#line 31 "include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq * );
#line 32 "include/linux/elevator.h"
typedef void elevator_exit_icq_fn(struct io_cq * );
#line 33 "include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue * , struct request * , struct bio * ,
                                gfp_t  );
#line 35 "include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request * );
#line 36 "include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
#line 37 "include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
#line 39 "include/linux/elevator.h"
typedef int elevator_init_fn(struct request_queue * , struct elevator_type * );
#line 41 "include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue * );
#line 42 "include/linux/elevator.h"
typedef void elevator_registered_fn(struct request_queue * );
#line 43 "include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
   elevator_registered_fn *elevator_registered_fn ;
};
#line 74 "include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
#line 82 "include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
#line 103 "include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned char registered : 1 ;
   struct hlist_head hash[64U] ;
};
#line 210 "include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue * );
#line 211 "include/linux/blkdev.h"
typedef void make_request_fn(struct request_queue * , struct bio * );
#line 212 "include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue * , struct request * );
#line 213 "include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue * , struct request * );
#line 214 "include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
#line 222 "include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
#line 224 "include/linux/blkdev.h"
typedef void softirq_done_fn(struct request * );
#line 225 "include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request * );
#line 226 "include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue * );
#line 227 "include/linux/blkdev.h"
typedef int bsg_job_fn(struct bsg_job * );
#line 228
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
#line 235 "include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
#line 241 "include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
   int alloc_policy ;
   int next_tag ;
};
#line 252 "include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int chunk_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
   unsigned char raid_partial_stripes_expensive ;
};
#line 285
struct blk_mq_ops;
#line 285
struct blk_mq_hw_ctx;
#line 285
struct throtl_data;
#line 285
struct blk_mq_tag_set;
#line 285 "include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   struct blk_mq_ops *mq_ops ;
   unsigned int *mq_map ;
   struct blk_mq_ctx *queue_ctx ;
   unsigned int nr_queues ;
   struct blk_mq_hw_ctx **queue_hw_ctx ;
   unsigned int nr_hw_queues ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   struct kobject mq_kobj ;
   struct device *dev ;
   int rpm_status ;
   unsigned int nr_pending ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   unsigned int flush_flags ;
   unsigned char flush_not_queueable : 1 ;
   struct blk_flush_queue *fq ;
   struct list_head requeue_list ;
   spinlock_t requeue_lock ;
   struct work_struct requeue_work ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
   atomic_t mq_freeze_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
   struct bsg_class_device bsg_dev ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
   wait_queue_head_t mq_freeze_wq ;
   struct percpu_ref mq_usage_counter ;
   struct list_head all_q_node ;
   struct blk_mq_tag_set *tag_set ;
   struct list_head tag_set_list ;
};
#line 1020 "include/linux/blkdev.h"
struct blk_plug {
   struct list_head list ;
   struct list_head mq_list ;
   struct list_head cb_list ;
};
#line 1398 "include/linux/blkdev.h"
struct blk_integrity_iter {
   void *prot_buf ;
   void *data_buf ;
   sector_t seed ;
   unsigned int data_size ;
   unsigned short interval ;
   char const   *disk_name ;
};
#line 1427 "include/linux/blkdev.h"
typedef int integrity_processing_fn(struct blk_integrity_iter * );
#line 1428 "include/linux/blkdev.h"
struct blk_integrity {
   integrity_processing_fn *generate_fn ;
   integrity_processing_fn *verify_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short interval ;
   unsigned short tag_size ;
   char const   *name ;
   struct kobject kobj ;
};
#line 1482 "include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   void (*release)(struct gendisk * , fmode_t  ) ;
   int (*rw_page)(struct block_device * , sector_t  , struct page * , int  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   long (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ,
                         long  ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
#line 100 "include/linux/transport_class.h"
struct blk_mq_tags;
#line 101 "include/linux/transport_class.h"
struct blk_mq_cpu_notifier {
   struct list_head list ;
   void *data ;
   int (*notify)(void * , unsigned long  , unsigned int  ) ;
};
#line 14 "include/linux/blk-mq.h"
struct blk_align_bitmap;
#line 14 "include/linux/blk-mq.h"
struct blk_mq_ctxmap {
   unsigned int size ;
   unsigned int bits_per_word ;
   struct blk_align_bitmap *map ;
};
#line 20 "include/linux/blk-mq.h"
struct __anonstruct____missing_field_name_402 {
   spinlock_t lock ;
   struct list_head dispatch ;
};
#line 20 "include/linux/blk-mq.h"
struct blk_mq_hw_ctx {
   struct __anonstruct____missing_field_name_402 __annonCompField128 ;
   unsigned long state ;
   struct delayed_work run_work ;
   struct delayed_work delay_work ;
   cpumask_var_t cpumask ;
   int next_cpu ;
   int next_cpu_batch ;
   unsigned long flags ;
   struct request_queue *queue ;
   struct blk_flush_queue *fq ;
   void *driver_data ;
   struct blk_mq_ctxmap ctx_map ;
   unsigned int nr_ctx ;
   struct blk_mq_ctx **ctxs ;
   atomic_t wait_index ;
   struct blk_mq_tags *tags ;
   unsigned long queued ;
   unsigned long run ;
   unsigned long dispatched[10U] ;
   unsigned int numa_node ;
   unsigned int queue_num ;
   atomic_t nr_active ;
   struct blk_mq_cpu_notifier cpu_notifier ;
   struct kobject kobj ;
};
#line 63 "include/linux/blk-mq.h"
struct blk_mq_tag_set {
   struct blk_mq_ops *ops ;
   unsigned int nr_hw_queues ;
   unsigned int queue_depth ;
   unsigned int reserved_tags ;
   unsigned int cmd_size ;
   int numa_node ;
   unsigned int timeout ;
   unsigned int flags ;
   void *driver_data ;
   struct blk_mq_tags **tags ;
   struct mutex tag_list_lock ;
   struct list_head tag_list ;
};
#line 80 "include/linux/blk-mq.h"
struct blk_mq_queue_data {
   struct request *rq ;
   struct list_head *list ;
   bool last ;
};
#line 87 "include/linux/blk-mq.h"
typedef int queue_rq_fn(struct blk_mq_hw_ctx * , struct blk_mq_queue_data  const  * );
#line 88 "include/linux/blk-mq.h"
typedef struct blk_mq_hw_ctx *map_queue_fn(struct request_queue * , int const    );
#line 89 "include/linux/blk-mq.h"
typedef enum blk_eh_timer_return timeout_fn(struct request * , bool  );
#line 90 "include/linux/blk-mq.h"
typedef int init_hctx_fn(struct blk_mq_hw_ctx * , void * , unsigned int  );
#line 91 "include/linux/blk-mq.h"
typedef void exit_hctx_fn(struct blk_mq_hw_ctx * , unsigned int  );
#line 92 "include/linux/blk-mq.h"
typedef int init_request_fn(void * , struct request * , unsigned int  , unsigned int  ,
                            unsigned int  );
#line 94 "include/linux/blk-mq.h"
typedef void exit_request_fn(void * , struct request * , unsigned int  , unsigned int  );
#line 100 "include/linux/blk-mq.h"
struct blk_mq_ops {
   queue_rq_fn *queue_rq ;
   map_queue_fn *map_queue ;
   timeout_fn *timeout ;
   softirq_done_fn *complete ;
   init_hctx_fn *init_hctx ;
   exit_hctx_fn *exit_hctx ;
   init_request_fn *init_request ;
   exit_request_fn *exit_request ;
};
#line 1 "<compiler builtins>"
void __builtin_prefetch(void const   *  , ...) ;
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 217 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit_lock(long nr , unsigned long volatile   *addr ) 
{ 
  int tmp ;

  {
#line 219
  tmp = test_and_set_bit(nr, addr);
#line 219
  return (tmp);
}
}
#line 250 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 252
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 252
  return ((int )((signed char )c) != 0);
}
}
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 314 "./arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 396 "./arch/x86/include/asm/bitops.h"
__inline static int ffs(int x ) 
{ 
  int r ;

  {
#line 410
  __asm__  ("bsfl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 423
  return (r + 1);
}
}
#line 14 "include/asm-generic/bitops/find.h"
extern unsigned long find_next_bit(unsigned long const   * , unsigned long  , unsigned long  ) ;
#line 42
extern unsigned long find_first_bit(unsigned long const   * , unsigned long  ) ;
#line 53
extern unsigned long find_first_zero_bit(unsigned long const   * , unsigned long  ) ;
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 225 "include/linux/bitops.h"
extern unsigned long find_last_bit(unsigned long const   * , unsigned long  ) ;
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 59 "include/linux/dynamic_debug.h"
extern void __dynamic_netdev_dbg(struct _ddebug * , struct net_device  const  * ,
                                 char const   *  , ...) ;
#line 431 "include/linux/printk.h"
extern void print_hex_dump(char const   * , char const   * , int  , int  , int  ,
                           void const   * , size_t  , bool  ) ;
#line 405 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 473
extern enum system_states system_state ;
#line 5 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_err_ptr(long error ) ;
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 295 "include/linux/percpu-defs.h"
extern void __bad_size_call_parameter(void) ;
#line 18 "include/asm-generic/percpu.h"
extern unsigned long __per_cpu_offset[8192U] ;
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 609 "include/linux/list.h"
__inline static int hlist_empty(struct hlist_head  const  *h ) 
{ 


  {
#line 611
  return ((unsigned long )h->first == (unsigned long )((struct hlist_node */* const  */)0));
}
}
#line 614 "include/linux/list.h"
__inline static void __hlist_del(struct hlist_node *n ) 
{ 
  struct hlist_node *next ;
  struct hlist_node **pprev ;

  {
#line 616
  next = n->next;
#line 617
  pprev = n->pprev;
#line 618
  *pprev = next;
#line 619
  if ((unsigned long )next != (unsigned long )((struct hlist_node *)0)) {
#line 620
    next->pprev = pprev;
  } else {

  }
#line 621
  return;
}
}
#line 623 "include/linux/list.h"
__inline static void hlist_del(struct hlist_node *n ) 
{ 


  {
#line 625
  __hlist_del(n);
#line 626
  n->next = (struct hlist_node *)-2401263026317557504L;
#line 627
  n->pprev = (struct hlist_node **)-2401263026316508672L;
#line 628
  return;
}
}
#line 23 "./arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *memset(void * , int  , size_t  ) ;
#line 65
extern char *strcpy(char * , char const   * ) ;
#line 26 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 112 "include/linux/bitmap.h"
extern int __bitmap_weight(unsigned long const   * , unsigned int  ) ;
#line 298 "include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , unsigned int nbits ) 
{ 
  int tmp___0 ;

  {
#line 302
  tmp___0 = __bitmap_weight(src, nbits);
#line 302
  return (tmp___0);
}
}
#line 66 "include/asm-generic/bug.h"
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
#line 71
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 37 "include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 88
extern struct cpumask  const  * const  cpu_possible_mask ;
#line 89
extern struct cpumask  const  * const  cpu_online_mask ;
#line 114 "include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 117
  __ret_warn_once = (unsigned int )nr_cpu_ids <= cpu;
#line 117
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 117
  if (tmp___1 != 0L) {
#line 117
    __ret_warn_on = ! __warned;
#line 117
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp != 0L) {
#line 117
      warn_slowpath_null("include/linux/cpumask.h", 117);
    } else {

    }
#line 117
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp___0 != 0L) {
#line 117
      __warned = 1;
    } else {

    }
  } else {

  }
#line 117
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 119
  return (cpu);
}
}
#line 184 "include/linux/cpumask.h"
__inline static unsigned int cpumask_next(int n , struct cpumask  const  *srcp ) 
{ 
  unsigned long tmp ;

  {
#line 187
  if (n != -1) {
#line 188
    cpumask_check((unsigned int )n);
  } else {

  }
#line 189
  tmp = find_next_bit((unsigned long const   *)(& srcp->bits), (unsigned long )nr_cpu_ids,
                      (unsigned long )(n + 1));
#line 189
  return ((unsigned int )tmp);
}
}
#line 474 "include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
#line 476
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), (unsigned int )nr_cpu_ids);
#line 476
  return ((unsigned int )tmp);
}
}
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 693 "./arch/x86/include/asm/processor.h"
__inline static void prefetchw(void const   *x ) 
{ 


  {
#line 695
  __asm__  volatile   ("661:\n\tprefetcht0 %P1\n662:\n.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\n663:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6641f - .\n .word ( 6*32+ 8)\n .byte 663b-661b\n .byte 6651f-6641f\n .byte 663b-662b\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6641:\n\tprefetchw %P1\n6651:\n\t.popsection": : "i" (0),
                       "m" (*((char const   *)x)));
#line 696
  return;
}
}
#line 13 "./arch/x86/include/asm/cmpxchg.h"
extern void __cmpxchg_wrong_size(void) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 175 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_cmpxchg(atomic_t *v , int old , int new ) 
{ 
  int __ret ;
  int __old ;
  int __new ;
  u8 volatile   *__ptr ;
  u16 volatile   *__ptr___0 ;
  u32 volatile   *__ptr___1 ;
  u64 volatile   *__ptr___2 ;

  {
#line 177
  __old = old;
#line 177
  __new = new;
#line 177
  switch (4UL) {
  case 1UL: 
#line 177
  __ptr = (u8 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1": "=a" (__ret),
                       "+m" (*__ptr): "q" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5616;
  case 2UL: 
#line 177
  __ptr___0 = (u16 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1": "=a" (__ret),
                       "+m" (*__ptr___0): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5616;
  case 4UL: 
#line 177
  __ptr___1 = (u32 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1": "=a" (__ret),
                       "+m" (*__ptr___1): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5616;
  case 8UL: 
#line 177
  __ptr___2 = (u64 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1": "=a" (__ret),
                       "+m" (*__ptr___2): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5616;
  default: 
#line 177
  __cmpxchg_wrong_size();
  }
  ldv_5616: ;
#line 177
  return (__ret);
}
}
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 333
extern void lock_acquire(struct lockdep_map * , unsigned int  , int  , int  , int  ,
                         struct lockdep_map * , unsigned long  ) ;
#line 337
extern void lock_release(struct lockdep_map * , int  , unsigned long  ) ;
#line 545
extern void lockdep_rcu_suspicious(char const   * , int const    , char const   * ) ;
#line 173 "include/linux/mutex.h"
extern int mutex_trylock(struct mutex * ) ;
#line 176
int ldv_mutex_trylock_13(struct mutex *ldv_func_arg1 ) ;
#line 178
extern void mutex_unlock(struct mutex * ) ;
#line 181
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_15(struct mutex *ldv_func_arg1 ) ;
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 18 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
extern void mutex_lock(struct mutex * ) ;
#line 21
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_16(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) ;
#line 38
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) ;
#line 47
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 51
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 60
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
#line 61
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
#line 64
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
#line 8 "./arch/x86/include/asm/preempt.h"
extern int __preempt_count ;
#line 20 "./arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void) 
{ 
  int pfo_ret__ ;

  {
#line 22
  switch (4UL) {
  case 1UL: 
#line 22
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6474;
  case 2UL: 
#line 22
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6474;
  case 4UL: 
#line 22
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6474;
  case 8UL: 
#line 22
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6474;
  default: 
#line 22
  __bad_percpu_size();
  }
  ldv_6474: ;
#line 22
  return (pfo_ret__ & 2147483647);
}
}
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6531;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6531;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6531;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6531;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6531: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6543;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6543;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6543;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6543;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6543: ;
#line 79
  return;
}
}
#line 7 "include/linux/bottom_half.h"
extern void __local_bh_disable_ip(unsigned long  , unsigned int  ) ;
#line 16 "include/linux/bottom_half.h"
__inline static void local_bh_disable(void) 
{ 


  {
#line 18
  __local_bh_disable_ip(0UL, 512U);
#line 19
  return;
}
}
#line 22
extern void __local_bh_enable_ip(unsigned long  , unsigned int  ) ;
#line 29 "include/linux/bottom_half.h"
__inline static void local_bh_enable(void) 
{ 


  {
#line 31
  __local_bh_enable_ip(0UL, 512U);
#line 32
  return;
}
}
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField17.rlock);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField17.rlock);
#line 313
  return;
}
}
#line 355 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 357
  _raw_spin_unlock(& lock->__annonCompField17.rlock);
#line 358
  return;
}
}
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 170 "include/linux/timer.h"
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 173
int ldv_mod_timer_25(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 177
int ldv_mod_timer_28(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 229
extern int del_timer_sync(struct timer_list * ) ;
#line 232
int ldv_del_timer_sync_26(struct timer_list *ldv_func_arg1 ) ;
#line 268 "include/linux/rcupdate.h"
__inline static void __rcu_read_lock(void) 
{ 


  {
#line 270
  __preempt_count_add(1);
#line 270
  __asm__  volatile   ("": : : "memory");
#line 271
  return;
}
}
#line 273 "include/linux/rcupdate.h"
__inline static void __rcu_read_unlock(void) 
{ 


  {
#line 275
  __asm__  volatile   ("": : : "memory");
#line 275
  __preempt_count_sub(1);
#line 276
  return;
}
}
#line 104 "include/linux/rcutree.h"
extern bool rcu_is_watching(void) ;
#line 447 "include/linux/rcupdate.h"
__inline static void rcu_lock_acquire(struct lockdep_map *map ) 
{ 


  {
#line 449
  lock_acquire(map, 0U, 0, 2, 0, (struct lockdep_map *)0, 0UL);
#line 450
  return;
}
}
#line 452 "include/linux/rcupdate.h"
__inline static void rcu_lock_release(struct lockdep_map *map ) 
{ 


  {
#line 454
  lock_release(map, 1, 0UL);
#line 455
  return;
}
}
#line 457
extern struct lockdep_map rcu_lock_map ;
#line 461
extern int debug_lockdep_rcu_enabled(void) ;
#line 843 "include/linux/rcupdate.h"
__inline static void rcu_read_lock(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 845
  __rcu_read_lock();
#line 847
  rcu_lock_acquire(& rcu_lock_map);
#line 848
  tmp = debug_lockdep_rcu_enabled();
#line 848
  if (tmp != 0 && ! __warned) {
#line 848
    tmp___0 = rcu_is_watching();
#line 848
    if (tmp___0) {
#line 848
      tmp___1 = 0;
    } else {
#line 848
      tmp___1 = 1;
    }
#line 848
    if (tmp___1) {
#line 848
      __warned = 1;
#line 848
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 849, "rcu_read_lock() used illegally while idle");
    } else {

    }
  } else {

  }
#line 851
  return;
}
}
#line 897 "include/linux/rcupdate.h"
__inline static void rcu_read_unlock(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 899
  tmp = debug_lockdep_rcu_enabled();
#line 899
  if (tmp != 0 && ! __warned) {
#line 899
    tmp___0 = rcu_is_watching();
#line 899
    if (tmp___0) {
#line 899
      tmp___1 = 0;
    } else {
#line 899
      tmp___1 = 1;
    }
#line 899
    if (tmp___1) {
#line 899
      __warned = 1;
#line 899
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 900, "rcu_read_unlock() used illegally while idle");
    } else {

    }
  } else {

  }
#line 902
  __rcu_read_unlock();
#line 903
  rcu_lock_release(& rcu_lock_map);
#line 904
  return;
}
}
#line 181 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 352
extern struct workqueue_struct *system_wq ;
#line 429
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 433
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 439
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 443
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 452
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 455
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
#line 464
extern bool cancel_work_sync(struct work_struct * ) ;
#line 467
bool ldv_cancel_work_sync_31(struct work_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_5(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 528 "include/linux/workqueue.h"
__inline static bool schedule_work(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 530
  tmp = queue_work(system_wq, work);
#line 530
  return (tmp);
}
}
#line 158 "include/linux/memory_hotplug.h"
extern pg_data_t *node_data[] ;
#line 58 "./arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 58
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 58
  return (ret);
}
}
#line 66 "./arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 66
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 67
  return;
}
}
#line 181
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 190 "./arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ 
  void *tmp ;

  {
#line 192
  tmp = ioremap_nocache(offset, size);
#line 192
  return (tmp);
}
}
#line 195
extern void iounmap(void volatile   * ) ;
#line 38 "./arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 71 "include/linux/topology.h"
extern int numa_node ;
#line 75 "include/linux/topology.h"
__inline static int numa_node_id(void) 
{ 
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 77
  __vpp_verify = (void const   *)0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  switch (4UL) {
  case 1UL: 
#line 77
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (numa_node));
#line 77
  goto ldv_13601;
  case 2UL: 
#line 77
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (numa_node));
#line 77
  goto ldv_13601;
  case 4UL: 
#line 77
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (numa_node));
#line 77
  goto ldv_13601;
  case 8UL: 
#line 77
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (numa_node));
#line 77
  goto ldv_13601;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_13601: 
#line 77
  pscr_ret__ = pfo_ret__;
#line 77
  goto ldv_13607;
  case 2UL: ;
#line 77
  switch (4UL) {
  case 1UL: 
#line 77
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (numa_node));
#line 77
  goto ldv_13611;
  case 2UL: 
#line 77
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (numa_node));
#line 77
  goto ldv_13611;
  case 4UL: 
#line 77
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (numa_node));
#line 77
  goto ldv_13611;
  case 8UL: 
#line 77
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (numa_node));
#line 77
  goto ldv_13611;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_13611: 
#line 77
  pscr_ret__ = pfo_ret_____0;
#line 77
  goto ldv_13607;
  case 4UL: ;
#line 77
  switch (4UL) {
  case 1UL: 
#line 77
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (numa_node));
#line 77
  goto ldv_13620;
  case 2UL: 
#line 77
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (numa_node));
#line 77
  goto ldv_13620;
  case 4UL: 
#line 77
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (numa_node));
#line 77
  goto ldv_13620;
  case 8UL: 
#line 77
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (numa_node));
#line 77
  goto ldv_13620;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_13620: 
#line 77
  pscr_ret__ = pfo_ret_____1;
#line 77
  goto ldv_13607;
  case 8UL: ;
#line 77
  switch (4UL) {
  case 1UL: 
#line 77
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (numa_node));
#line 77
  goto ldv_13629;
  case 2UL: 
#line 77
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (numa_node));
#line 77
  goto ldv_13629;
  case 4UL: 
#line 77
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (numa_node));
#line 77
  goto ldv_13629;
  case 8UL: 
#line 77
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (numa_node));
#line 77
  goto ldv_13629;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_13629: 
#line 77
  pscr_ret__ = pfo_ret_____2;
#line 77
  goto ldv_13607;
  default: 
#line 77
  __bad_size_call_parameter();
#line 77
  goto ldv_13607;
  }
  ldv_13607: ;
#line 77
  return (pscr_ret__);
}
}
#line 166 "include/linux/topology.h"
__inline static int numa_mem_id(void) 
{ 
  int tmp ;

  {
#line 168
  tmp = numa_node_id();
#line 168
  return (tmp);
}
}
#line 263 "include/linux/gfp.h"
__inline static int gfp_zonelist(gfp_t flags ) 
{ 
  long tmp ;

  {
#line 265
  tmp = ldv__builtin_expect((flags & 262144U) != 0U, 0L);
#line 265
  if (tmp != 0L) {
#line 266
    return (1);
  } else {

  }
#line 268
  return (0);
}
}
#line 280 "include/linux/gfp.h"
__inline static struct zonelist *node_zonelist(int nid , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 282
  tmp = gfp_zonelist(flags);
#line 282
  return ((struct zonelist *)(& (node_data[nid])->node_zonelists) + (unsigned long )tmp);
}
}
#line 293
extern struct page *__alloc_pages_nodemask(gfp_t  , unsigned int  , struct zonelist * ,
                                           nodemask_t * ) ;
#line 297 "include/linux/gfp.h"
__inline static struct page *__alloc_pages(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ) 
{ 
  struct page *tmp ;

  {
#line 300
  tmp = __alloc_pages_nodemask(gfp_mask, order, zonelist, (nodemask_t *)0);
#line 300
  return (tmp);
}
}
#line 303 "include/linux/gfp.h"
__inline static struct page *alloc_pages_node(int nid , gfp_t gfp_mask , unsigned int order ) 
{ 
  struct zonelist *tmp ;
  struct page *tmp___0 ;

  {
#line 307
  if (nid < 0) {
#line 308
    nid = numa_node_id();
  } else {

  }
#line 310
  tmp = node_zonelist(nid, gfp_mask);
#line 310
  tmp___0 = __alloc_pages(gfp_mask, order, tmp);
#line 310
  return (tmp___0);
}
}
#line 366
extern void __free_pages(struct page * , unsigned int  ) ;
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 289
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 525 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 527
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 528
    return ((void *)0);
  } else {

  }
#line 529
  tmp = __kmalloc(n * size, flags);
#line 529
  return (tmp);
}
}
#line 538 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 540
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 540
  return (tmp);
}
}
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct work_struct *ldv_work_struct_9_2  ;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_20  ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *mbx_ops_generic_group0  ;
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ethtool_eeprom *ixgbe_ethtool_ops_group2  ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_5_1  =    0;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct timer_list *ldv_timer_list_10_2  ;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_4_2  ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_7_1  ;
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_3_2  =    0;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_work_9_3  ;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_6_1  =    0;
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_14  ;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_6_2  ;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_37  ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_17  ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_6_0  ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_2_3  ;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_19  ;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_27  ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_9  ;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_7_2  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct inode *ixgbe_dbg_netdev_ops_fops_group1  ;
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_7_3  =    0;
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct pci_dev *ixgbe_driver_group1  ;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_2_2  ;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_7  ;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *eeprom_ops_82599_group0  ;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *mac_ops_82599_group0  ;
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_1_3  =    0;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_2_2  ;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_5_2  ;
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct pci_dev *ixgbe_err_handler_group0  ;
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_1_0  ;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_3_0  ;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_26  ;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct file *ixgbe_dbg_reg_ops_fops_group2  ;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_28  ;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *mac_ops_82598_group0  ;
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_timer_10_2  ;
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_1_1  =    0;
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_7_2  ;
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_work_8_3  ;
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_3_1  ;
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct net_device *ixgbe_netdev_ops_group1  ;
#line 110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_31  ;
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *eeprom_ops_82598_group0  ;
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ethtool_cmd *ixgbe_ethtool_ops_group1  ;
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_4_1  =    0;
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_8  ;
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_15  ;
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_5_0  ;
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_7_3  ;
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_work_8_0  ;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_21  ;
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_33  ;
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct work_struct *ldv_work_struct_8_0  ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_4_0  ;
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_6_3  ;
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_4_0  =    0;
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_2_2  =    0;
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_2_0  ;
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_4_0  ;
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_6_1  ;
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_3_0  ;
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_7_0  ;
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_6_1  ;
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_timer_10_0  ;
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_3_3  ;
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_3_2  ;
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct net_device *ixgbe_ethtool_ops_group6  ;
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_10  ;
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_1_0  =    0;
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct net_device *dcbnl_ops_group0  ;
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_2_1  ;
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_6_2  ;
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_2  ;
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_25  ;
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_timer_10_1  ;
#line 144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_2_0  ;
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ethtool_rxnfc *ixgbe_ethtool_ops_group7  ;
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_11  ;
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_1_2  =    0;
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_4_3  =    0;
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_18  ;
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ethtool_pauseparam *ixgbe_ethtool_ops_group3  ;
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct timer_list *ldv_timer_list_10_3  ;
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_6_0  =    0;
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_4_1  ;
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct work_struct *ldv_work_struct_9_1  ;
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *eeprom_ops_X550_group0  ;
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_5_3  ;
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_32  ;
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *phy_ops_X550EM_x_group0  ;
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ieee_ets *dcbnl_ops_group3  ;
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int pci_counter  ;
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_6_0  ;
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_7_2  =    0;
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_30  ;
#line 164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_work_8_1  ;
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_0  ;
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_5_3  ;
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_2_0  =    0;
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_12  ;
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *mac_ops_X550EM_x_group0  ;
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_4_3  ;
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_22  ;
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_29  ;
#line 173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ethtool_wolinfo *ixgbe_ethtool_ops_group8  ;
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct work_struct *ldv_work_struct_8_1  ;
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_work_9_0  ;
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *mac_ops_X540_group0  ;
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ref_cnt  ;
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_1_1  ;
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct file *ixgbe_dbg_netdev_ops_fops_group2  ;
#line 180 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_6_3  =    0;
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct work_struct *ldv_work_struct_8_3  ;
#line 182 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_23  ;
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_5_2  =    0;
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct timer_list *ldv_timer_list_10_0  ;
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_2_1  =    0;
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_3_0  =    0;
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_2_1  ;
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *phy_ops_X540_group0  ;
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_6  ;
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_7_1  ;
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_1_3  ;
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_5_0  ;
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *mac_ops_X550_group0  ;
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_7_1  =    0;
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_4_1  ;
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_38  ;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ethtool_channels *ixgbe_ethtool_ops_group4  ;
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_39  ;
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct dcb_app *dcbnl_ops_group1  ;
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct timer_list *ldv_timer_list_10_1  ;
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_3  ;
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_1_0  ;
#line 203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_3_2  ;
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_6_3  ;
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_4  ;
#line 206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct work_struct *ldv_work_struct_9_0  ;
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct work_struct *ldv_work_struct_9_3  ;
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_3_3  ;
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_36  ;
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_work_9_2  ;
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_work_9_1  ;
#line 212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_5  ;
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *phy_ops_X550_group0  ;
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_13  ;
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_3_1  =    0;
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_7_0  ;
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_5_2  ;
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_4_3  ;
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_4_2  =    0;
#line 220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_24  ;
#line 221 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_6_2  =    0;
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_1  ;
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_1_2  ;
#line 224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_2_3  ;
#line 225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_1_1  ;
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *phy_ops_82598_group0  ;
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_4_2  ;
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *eeprom_ops_X550EM_x_group0  ;
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_3_1  ;
#line 230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_5_1  ;
#line 231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct work_struct *ldv_work_struct_8_2  ;
#line 232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *eeprom_ops_X540_group0  ;
#line 233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ethtool_coalesce *ixgbe_ethtool_ops_group5  ;
#line 234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_16  ;
#line 235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct inode *ixgbe_dbg_reg_ops_fops_group1  ;
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_1_2  ;
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_5_3  =    0;
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_5_1  ;
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_7_0  =    0;
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_2_3  =    0;
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_line_1_3  ;
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_5_0  =    0;
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_work_8_2  ;
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ethtool_ringparam *ixgbe_ethtool_ops_group0  ;
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_34  ;
#line 247 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_timer_10_3  ;
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ieee_pfc *dcbnl_ops_group2  ;
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_3_3  =    0;
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void *ldv_irq_data_7_3  ;
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_state_variable_35  ;
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
struct ixgbe_hw *phy_ops_82599_group0  ;
#line 253
void activate_suitable_irq_4(int line , void *data ) ;
#line 254
int ldv_irq_3(int state , int line , void *data ) ;
#line 255
void disable_suitable_irq_2(int line , void *data ) ;
#line 256
void disable_suitable_irq_7(int line , void *data ) ;
#line 257
void activate_suitable_irq_3(int line , void *data ) ;
#line 258
void ldv_net_device_ops_38(void) ;
#line 259
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) ;
#line 260
void choose_interrupt_4(void) ;
#line 261
void work_init_9(void) ;
#line 262
void invoke_work_8(void) ;
#line 263
void ldv_initialize_ixgbe_phy_operations_16(void) ;
#line 264
int reg_timer_10(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 265
void ldv_initialize_ixgbe_mbx_operations_26(void) ;
#line 266
void ldv_initialize_dcbnl_rtnl_ops_13(void) ;
#line 268
void ldv_timer_10(int state , struct timer_list *timer ) ;
#line 270
void ldv_initialize_ixgbe_eeprom_operations_24(void) ;
#line 271
void ldv_file_operations_12(void) ;
#line 272
void ldv_initialize_ixgbe_phy_operations_28(void) ;
#line 275
void activate_suitable_irq_2(int line , void *data ) ;
#line 277
void work_init_8(void) ;
#line 278
void activate_suitable_timer_10(struct timer_list *timer , unsigned long data ) ;
#line 279
void ldv_initialize_ethtool_ops_35(void) ;
#line 280
void call_and_disable_all_9(int state ) ;
#line 281
void choose_interrupt_1(void) ;
#line 282
int reg_check_2(irqreturn_t (*handler)(int  , void * ) ) ;
#line 283
void ldv_initialize_ixgbe_eeprom_operations_18(void) ;
#line 284
void call_and_disable_work_8(struct work_struct *work ) ;
#line 285
void activate_suitable_irq_7(int line , void *data ) ;
#line 286
int reg_check_3(irqreturn_t (*handler)(int  , void * ) ) ;
#line 288
void ldv_initialize_ixgbe_mac_operations_30(void) ;
#line 289
void disable_work_8(struct work_struct *work ) ;
#line 290
void activate_work_9(struct work_struct *work , int state ) ;
#line 292
int reg_check_7(irqreturn_t (*handler)(int  , void * ) ) ;
#line 293
int ldv_irq_4(int state , int line , void *data ) ;
#line 294
void ldv_initialize_ixgbe_mac_operations_34(void) ;
#line 296
void activate_pending_timer_10(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 297
void ldv_initialize_ixgbe_eeprom_operations_29(void) ;
#line 298
void ldv_initialize_ixgbe_eeprom_operations_19(void) ;
#line 301
void call_and_disable_all_8(int state ) ;
#line 303
void ldv_initialize_ixgbe_phy_operations_23(void) ;
#line 304
void disable_suitable_irq_1(int line , void *data ) ;
#line 305
void ldv_initialize_ixgbe_phy_operations_17(void) ;
#line 306
void activate_suitable_irq_1(int line , void *data ) ;
#line 307
void ldv_initialize_ixgbe_phy_operations_32(void) ;
#line 308
int reg_check_4(irqreturn_t (*handler)(int  , void * ) ) ;
#line 309
void ldv_initialize_ixgbe_mac_operations_21(void) ;
#line 310
void activate_work_8(struct work_struct *work , int state ) ;
#line 311
int ldv_irq_2(int state , int line , void *data ) ;
#line 312
void ldv_pci_driver_36(void) ;
#line 313
void ldv_initialize_ixgbe_eeprom_operations_33(void) ;
#line 314
void choose_interrupt_2(void) ;
#line 315
void ldv_initialize_pci_error_handlers_37(void) ;
#line 316
void disable_suitable_timer_10(struct timer_list *timer ) ;
#line 317
void disable_work_9(struct work_struct *work ) ;
#line 318
void ldv_initialize_ixgbe_mac_operations_25(void) ;
#line 319
void disable_suitable_irq_4(int line , void *data ) ;
#line 320
void ldv_initialize_ixgbe_mac_operations_20(void) ;
#line 321
void disable_suitable_irq_3(int line , void *data ) ;
#line 322
void timer_init_10(void) ;
#line 324
int ldv_irq_1(int state , int line , void *data ) ;
#line 326
void choose_timer_10(void) ;
#line 327
void choose_interrupt_3(void) ;
#line 328
void ldv_file_operations_11(void) ;
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 317 "include/linux/device.h"
extern int driver_for_each_device(struct device_driver * , struct device * , void * ,
                                  int (*)(struct device * , void * ) ) ;
#line 104 "include/linux/pm_wakeup.h"
extern int device_set_wakeup_enable(struct device * , bool  ) ;
#line 832 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 835
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 836
    return ((char const   *)dev->init_name);
  } else {

  }
#line 838
  tmp = kobject_name(& dev->kobj);
#line 838
  return (tmp);
}
}
#line 845 "include/linux/device.h"
__inline static int dev_to_node(struct device *dev ) 
{ 


  {
#line 847
  return (dev->numa_node);
}
}
#line 849 "include/linux/device.h"
__inline static void set_dev_node(struct device *dev , int node ) 
{ 


  {
#line 851
  dev->numa_node = node;
#line 852
  return;
}
}
#line 863 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 865
  return ((void *)dev->driver_data);
}
}
#line 868 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 870
  dev->driver_data = data;
#line 871
  return;
}
}
#line 1084
extern void dev_err(struct device  const  * , char const   *  , ...) ;
#line 1086
extern void dev_warn(struct device  const  * , char const   *  , ...) ;
#line 1090
extern void _dev_info(struct device  const  * , char const   *  , ...) ;
#line 399 "include/linux/pci.h"
__inline static int pci_channel_offline(struct pci_dev *pdev ) 
{ 


  {
#line 401
  return (pdev->error_state != 1U);
}
}
#line 812
extern void pci_dev_put(struct pci_dev * ) ;
#line 835
extern int pci_find_ext_capability(struct pci_dev * , int  ) ;
#line 841
extern struct pci_dev *pci_get_device(unsigned int  , unsigned int  , struct pci_dev * ) ;
#line 859
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
#line 861
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 865
extern int pci_bus_write_config_word(struct pci_bus * , unsigned int  , int  , u16  ) ;
#line 885 "include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ 
  int tmp ;

  {
#line 887
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
#line 887
  return (tmp);
}
}
#line 889 "include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp ;

  {
#line 892
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
#line 892
  return (tmp);
}
}
#line 898 "include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val ) 
{ 
  int tmp ;

  {
#line 900
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, (int )val);
#line 900
  return (tmp);
}
}
#line 908
extern int pcie_capability_read_word(struct pci_dev * , int  , u16 * ) ;
#line 912
extern int pcie_capability_clear_and_set_word(struct pci_dev * , int  , u16  , u16  ) ;
#line 917 "include/linux/pci.h"
__inline static int pcie_capability_set_word(struct pci_dev *dev , int pos , u16 set ) 
{ 
  int tmp ;

  {
#line 920
  tmp = pcie_capability_clear_and_set_word(dev, pos, 0, (int )set);
#line 920
  return (tmp);
}
}
#line 951
extern int pci_enable_device_mem(struct pci_dev * ) ;
#line 966
extern void pci_disable_device(struct pci_dev * ) ;
#line 969
extern void pci_set_master(struct pci_dev * ) ;
#line 985
extern int pci_wait_for_pending_transaction(struct pci_dev * ) ;
#line 993
extern int pcie_get_minimum_link(struct pci_dev * , enum pci_bus_speed * , enum pcie_link_width * ) ;
#line 1011
extern int pci_select_bars(struct pci_dev * , unsigned long  ) ;
#line 1024
extern int pci_save_state(struct pci_dev * ) ;
#line 1025
extern void pci_restore_state(struct pci_dev * ) ;
#line 1038
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 1044
extern int pci_wake_from_d3(struct pci_dev * , bool  ) ;
#line 1045
extern int pci_prepare_to_sleep(struct pci_dev * ) ;
#line 1098
extern int pci_request_selected_regions(struct pci_dev * , int  , char const   * ) ;
#line 1100
extern void pci_release_selected_regions(struct pci_dev * , int  ) ;
#line 1140
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1144
int ldv___pci_register_driver_34(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) ;
#line 1153
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1156
void ldv_pci_unregister_driver_35(struct pci_driver *ldv_func_arg1 ) ;
#line 400 "include/linux/page-flags.h"
__inline static int PageTail(struct page  const  *page ) 
{ 
  int tmp ;

  {
#line 400
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& page->flags));
#line 400
  return (tmp);
}
}
#line 440 "include/linux/mm.h"
__inline static struct page *compound_head_by_tail(struct page *tail ) 
{ 
  struct page *head ;
  int tmp ;
  long tmp___0 ;

  {
#line 442
  head = tail->__annonCompField46.first_page;
#line 449
  __asm__  volatile   ("": : : "memory");
#line 450
  tmp = PageTail((struct page  const  *)tail);
#line 450
  tmp___0 = ldv__builtin_expect(tmp != 0, 1L);
#line 450
  if (tmp___0 != 0L) {
#line 451
    return (head);
  } else {

  }
#line 452
  return (tail);
}
}
#line 461 "include/linux/mm.h"
__inline static struct page *compound_head(struct page *page ) 
{ 
  struct page *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 463
  tmp___0 = PageTail((struct page  const  *)page);
#line 463
  tmp___1 = ldv__builtin_expect(tmp___0 != 0, 0L);
#line 463
  if (tmp___1 != 0L) {
#line 464
    tmp = compound_head_by_tail(page);
#line 464
    return (tmp);
  } else {

  }
#line 465
  return (page);
}
}
#line 496 "include/linux/mm.h"
__inline static int page_count(struct page *page ) 
{ 
  struct page *tmp ;
  int tmp___0 ;

  {
#line 498
  tmp = compound_head(page);
#line 498
  tmp___0 = atomic_read((atomic_t const   *)(& tmp->__annonCompField42.__annonCompField41.__annonCompField40._count));
#line 498
  return (tmp___0);
}
}
#line 760 "include/linux/mm.h"
__inline static int page_to_nid(struct page  const  *page ) 
{ 


  {
#line 762
  return ((int )(page->flags >> 54));
}
}
#line 924 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 926
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 1213 "include/linux/pci.h"
extern void pci_disable_msix(struct pci_dev * ) ;
#line 73 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 75
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 42
extern void debug_dma_mapping_error(struct device * , dma_addr_t  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 67
extern void debug_dma_sync_single_range_for_cpu(struct device * , dma_addr_t  , unsigned long  ,
                                                size_t  , int  ) ;
#line 73
extern void debug_dma_sync_single_range_for_device(struct device * , dma_addr_t  ,
                                                   unsigned long  , size_t  , int  ) ;
#line 30 "./arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops ;
#line 32 "./arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 10 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 19
  if (tmp___1 != 0L) {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_26793: ;
#line 19
    goto ldv_26793;
  } else {

  }
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
#line 26
  return (addr);
}
}
#line 29 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 36
  if (tmp___1 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_26802: ;
#line 36
    goto ldv_26802;
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
#line 40
  return;
}
}
#line 76 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 80
  tmp = get_dma_ops(dev);
#line 80
  ops = tmp;
#line 83
  tmp___0 = lowmem_page_address((struct page  const  *)page);
#line 83
  kmemcheck_mark_initialized(tmp___0 + offset, (unsigned int )size);
#line 84
  tmp___1 = valid_dma_direction((int )dir);
#line 84
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 84
  if (tmp___2 != 0L) {
#line 84
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (84), "i" (12UL));
    ldv_26837: ;
#line 84
    goto ldv_26837;
  } else {

  }
#line 85
  addr = (*(ops->map_page))(dev, page, offset, size, dir, (struct dma_attrs *)0);
#line 86
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, 0);
#line 88
  return (addr);
}
}
#line 91 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 94
  tmp = get_dma_ops(dev);
#line 94
  ops = tmp;
#line 96
  tmp___0 = valid_dma_direction((int )dir);
#line 96
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 96
  if (tmp___1 != 0L) {
#line 96
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (96), "i" (12UL));
    ldv_26845: ;
#line 96
    goto ldv_26845;
  } else {

  }
#line 97
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 98
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)0);
  } else {

  }
#line 99
  debug_dma_unmap_page(dev, addr, size, (int )dir, 0);
#line 100
  return;
}
}
#line 126 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_range_for_cpu(struct device *dev , dma_addr_t addr ,
                                                   unsigned long offset , size_t size ,
                                                   enum dma_data_direction dir ) 
{ 
  struct dma_map_ops  const  *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 132
  tmp = get_dma_ops(dev);
#line 132
  ops = (struct dma_map_ops  const  *)tmp;
#line 134
  tmp___0 = valid_dma_direction((int )dir);
#line 134
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 134
  if (tmp___1 != 0L) {
#line 134
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (134), "i" (12UL));
    ldv_26870: ;
#line 134
    goto ldv_26870;
  } else {

  }
#line 135
  if ((unsigned long )ops->sync_single_for_cpu != (unsigned long )((void (*/* const  */)(struct device * ,
                                                                                         dma_addr_t  ,
                                                                                         size_t  ,
                                                                                         enum dma_data_direction  ))0)) {
#line 136
    (*(ops->sync_single_for_cpu))(dev, addr + (unsigned long long )offset, size, dir);
  } else {

  }
#line 137
  debug_dma_sync_single_range_for_cpu(dev, addr, offset, size, (int )dir);
#line 138
  return;
}
}
#line 140 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_range_for_device(struct device *dev , dma_addr_t addr ,
                                                      unsigned long offset , size_t size ,
                                                      enum dma_data_direction dir ) 
{ 
  struct dma_map_ops  const  *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 146
  tmp = get_dma_ops(dev);
#line 146
  ops = (struct dma_map_ops  const  *)tmp;
#line 148
  tmp___0 = valid_dma_direction((int )dir);
#line 148
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 148
  if (tmp___1 != 0L) {
#line 148
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (148), "i" (12UL));
    ldv_26879: ;
#line 148
    goto ldv_26879;
  } else {

  }
#line 149
  if ((unsigned long )ops->sync_single_for_device != (unsigned long )((void (*/* const  */)(struct device * ,
                                                                                            dma_addr_t  ,
                                                                                            size_t  ,
                                                                                            enum dma_data_direction  ))0)) {
#line 150
    (*(ops->sync_single_for_device))(dev, addr + (unsigned long long )offset, size,
                                     dir);
  } else {

  }
#line 151
  debug_dma_sync_single_range_for_device(dev, addr, offset, size, (int )dir);
#line 152
  return;
}
}
#line 47 "./arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;

  {
#line 49
  tmp = get_dma_ops(dev);
#line 49
  ops = tmp;
#line 50
  debug_dma_mapping_error(dev, dma_addr);
#line 51
  if ((unsigned long )ops->mapping_error != (unsigned long )((int (*)(struct device * ,
                                                                      dma_addr_t  ))0)) {
#line 52
    tmp___0 = (*(ops->mapping_error))(dev, dma_addr);
#line 52
    return (tmp___0);
  } else {

  }
#line 54
  return (dma_addr == 0ULL);
}
}
#line 60
extern int dma_supported(struct device * , u64  ) ;
#line 61
extern int dma_set_mask(struct device * , u64  ) ;
#line 131
extern void *dma_alloc_attrs(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
#line 136
extern void dma_free_attrs(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
#line 101 "include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 103
  tmp = dma_supported(dev, mask);
#line 103
  if (tmp == 0) {
#line 104
    return (-5);
  } else {

  }
#line 105
  dev->coherent_dma_mask = mask;
#line 106
  return (0);
}
}
#line 116 "include/linux/dma-mapping.h"
__inline static int dma_set_mask_and_coherent(struct device *dev , u64 mask ) 
{ 
  int rc ;
  int tmp ;

  {
#line 118
  tmp = dma_set_mask(dev, mask);
#line 118
  rc = tmp;
#line 119
  if (rc == 0) {
#line 120
    dma_set_coherent_mask(dev, mask);
  } else {

  }
#line 121
  return (rc);
}
}
#line 1468 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1470
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1470
  return (tmp);
}
}
#line 1473 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
#line 1475
  dev_set_drvdata(& pdev->dev, data);
#line 1476
  return;
}
}
#line 1481 "include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
#line 1483
  tmp = dev_name(& pdev->dev);
#line 1483
  return (tmp);
}
}
#line 1673
extern int pci_sriov_set_totalvfs(struct pci_dev * , u16  ) ;
#line 1715 "include/linux/pci.h"
__inline static int pci_pcie_cap(struct pci_dev *dev ) 
{ 


  {
#line 1717
  return ((int )dev->pcie_cap);
}
}
#line 1726 "include/linux/pci.h"
__inline static bool pci_is_pcie(struct pci_dev *dev ) 
{ 
  int tmp ;

  {
#line 1728
  tmp = pci_pcie_cap(dev);
#line 1728
  return (tmp != 0);
}
}
#line 1735 "include/linux/pci.h"
__inline static u16 pcie_caps_reg(struct pci_dev  const  *dev ) 
{ 


  {
#line 1737
  return ((u16 )dev->pcie_flags_reg);
}
}
#line 1744 "include/linux/pci.h"
__inline static int pci_pcie_type(struct pci_dev  const  *dev ) 
{ 
  u16 tmp ;

  {
#line 1746
  tmp = pcie_caps_reg(dev);
#line 1746
  return (((int )tmp & 240) >> 4);
}
}
#line 1854 "include/linux/pci.h"
__inline static struct device_node *pci_device_to_OF_node(struct pci_dev  const  *pdev ) 
{ 


  {
#line 1856
  return ((unsigned long )pdev != (unsigned long )((struct pci_dev  const  *)0) ? (struct device_node *)pdev->dev.of_node : (struct device_node *)0);
}
}
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 48
extern void usleep_range(unsigned long  , unsigned long  ) ;
#line 72 "include/linux/dynamic_queue_limits.h"
__inline static void dql_queued(struct dql *dql , unsigned int count ) 
{ 
  long tmp ;

  {
#line 74
  tmp = ldv__builtin_expect(count > 268435455U, 0L);
#line 74
  if (tmp != 0L) {
#line 74
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/dynamic_queue_limits.h"),
                         "i" (74), "i" (12UL));
    ldv_28189: ;
#line 74
    goto ldv_28189;
  } else {

  }
#line 76
  dql->last_obj_cnt = count;
#line 83
  __asm__  volatile   ("": : : "memory");
#line 85
  dql->num_queued = dql->num_queued + count;
#line 86
  return;
}
}
#line 89 "include/linux/dynamic_queue_limits.h"
__inline static int dql_avail(struct dql  const  *dql ) 
{ 
  unsigned int __var ;
  unsigned int __var___0 ;

  {
#line 91
  __var = 0U;
#line 91
  __var___0 = 0U;
#line 91
  return ((int )((unsigned int )*((unsigned int const volatile   *)(& dql->adj_limit)) - (unsigned int )*((unsigned int const volatile   *)(& dql->num_queued))));
}
}
#line 95
extern void dql_completed(struct dql * , unsigned int  ) ;
#line 98
extern void dql_reset(struct dql * ) ;
#line 220 "include/linux/net.h"
extern int net_ratelimit(void) ;
#line 22 "./arch/x86/include/asm/checksum_64.h"
__inline static __sum16 csum_fold(__wsum sum ) 
{ 


  {
#line 24
  __asm__  ("  addl %1,%0\n  adcl $0xffff,%0": "=r" (sum): "r" (sum << 16), "0" (sum & 4294901760U));
#line 29
  return ((__sum16 )(~ sum >> 16));
}
}
#line 87 "./arch/x86/include/asm/checksum_64.h"
__inline static __wsum csum_tcpudp_nofold(__be32 saddr , __be32 daddr , unsigned short len ,
                                          unsigned short proto , __wsum sum ) 
{ 


  {
#line 90
  __asm__  ("  addl %1, %0\n  adcl %2, %0\n  adcl %3, %0\n  adcl $0, %0\n": "=r" (sum): "g" (daddr),
            "g" (saddr), "g" (((int )len + (int )proto) << 8), "0" (sum));
#line 97
  return (sum);
}
}
#line 112 "./arch/x86/include/asm/checksum_64.h"
__inline static __sum16 csum_tcpudp_magic(__be32 saddr , __be32 daddr , unsigned short len ,
                                          unsigned short proto , __wsum sum ) 
{ 
  __wsum tmp ;
  __sum16 tmp___0 ;

  {
#line 116
  tmp = csum_tcpudp_nofold(saddr, daddr, (int )len, (int )proto, sum);
#line 116
  tmp___0 = csum_fold(tmp);
#line 116
  return (tmp___0);
}
}
#line 179
extern __sum16 csum_ipv6_magic(struct in6_addr  const  * , struct in6_addr  const  * ,
                               __u32  , unsigned short  , __wsum  ) ;
#line 230 "include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t const   *frag ) 
{ 


  {
#line 232
  return ((unsigned int )frag->size);
}
}
#line 245 "include/linux/skbuff.h"
__inline static void skb_frag_size_sub(skb_frag_t *frag , int delta ) 
{ 


  {
#line 247
  frag->size = frag->size - (__u32 )delta;
#line 248
  return;
}
}
#line 775
extern void consume_skb(struct sk_buff * ) ;
#line 852
extern int pskb_expand_head(struct sk_buff * , int  , int  , gfp_t  ) ;
#line 862
extern int skb_pad(struct sk_buff * , int  ) ;
#line 926 "include/linux/skbuff.h"
__inline static void skb_set_hash(struct sk_buff *skb , __u32 hash , enum pkt_hash_types type ) 
{ 


  {
#line 928
  skb->l4_hash = (unsigned int )type == 3U;
#line 929
  skb->sw_hash = 0U;
#line 930
  skb->hash = hash;
#line 931
  return;
}
}
#line 976 "include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 978
  return ((unsigned char *)skb->head + (unsigned long )skb->end);
}
}
#line 1085 "include/linux/skbuff.h"
__inline static struct sk_buff *skb_get(struct sk_buff *skb ) 
{ 


  {
#line 1087
  atomic_inc(& skb->users);
#line 1088
  return (skb);
}
}
#line 1127 "include/linux/skbuff.h"
__inline static int skb_header_cloned(struct sk_buff  const  *skb ) 
{ 
  int dataref ;
  unsigned char *tmp ;

  {
#line 1131
  if ((unsigned int )*((unsigned char *)skb + 142UL) == 0U) {
#line 1132
    return (0);
  } else {

  }
#line 1134
  tmp = skb_end_pointer(skb);
#line 1134
  dataref = atomic_read((atomic_t const   *)(& ((struct skb_shared_info *)tmp)->dataref));
#line 1135
  dataref = (dataref & 65535) - (dataref >> 16);
#line 1136
  return (dataref != 1);
}
}
#line 1567 "include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff  const  *skb ) 
{ 


  {
#line 1569
  return ((unsigned int )skb->data_len != 0U);
}
}
#line 1572 "include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff  const  *skb ) 
{ 


  {
#line 1574
  return ((unsigned int )skb->len - (unsigned int )skb->data_len);
}
}
#line 1643
extern void skb_add_rx_frag(struct sk_buff * , int  , struct page * , int  , int  ,
                            unsigned int  ) ;
#line 1654 "include/linux/skbuff.h"
__inline static unsigned char *skb_tail_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 1656
  return ((unsigned char *)skb->head + (unsigned long )skb->tail);
}
}
#line 1693 "include/linux/skbuff.h"
__inline static unsigned char *__skb_put(struct sk_buff *skb , unsigned int len ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  bool tmp___1 ;
  long tmp___2 ;

  {
#line 1695
  tmp___0 = skb_tail_pointer((struct sk_buff  const  *)skb);
#line 1695
  tmp = tmp___0;
#line 1696
  tmp___1 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 1696
  tmp___2 = ldv__builtin_expect((long )tmp___1, 0L);
#line 1696
  if (tmp___2 != 0L) {
#line 1696
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/skbuff.h"),
                         "i" (1696), "i" (12UL));
    ldv_35045: ;
#line 1696
    goto ldv_35045;
  } else {

  }
#line 1697
  skb->tail = skb->tail + len;
#line 1698
  skb->len = skb->len + len;
#line 1699
  return (tmp);
}
}
#line 1723
extern unsigned char *__pskb_pull_tail(struct sk_buff * , int  ) ;
#line 1739 "include/linux/skbuff.h"
__inline static int pskb_may_pull(struct sk_buff *skb , unsigned int len ) 
{ 
  unsigned int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned int tmp___2 ;
  unsigned char *tmp___3 ;

  {
#line 1741
  tmp = skb_headlen((struct sk_buff  const  *)skb);
#line 1741
  tmp___0 = ldv__builtin_expect(tmp >= len, 1L);
#line 1741
  if (tmp___0 != 0L) {
#line 1742
    return (1);
  } else {

  }
#line 1743
  tmp___1 = ldv__builtin_expect(skb->len < len, 0L);
#line 1743
  if (tmp___1 != 0L) {
#line 1744
    return (0);
  } else {

  }
#line 1745
  tmp___2 = skb_headlen((struct sk_buff  const  *)skb);
#line 1745
  tmp___3 = __pskb_pull_tail(skb, (int )(len - tmp___2));
#line 1745
  return ((unsigned long )tmp___3 != (unsigned long )((unsigned char *)0U));
}
}
#line 1754 "include/linux/skbuff.h"
__inline static unsigned int skb_headroom(struct sk_buff  const  *skb ) 
{ 


  {
#line 1756
  return ((unsigned int )((long )skb->data) - (unsigned int )((long )skb->head));
}
}
#line 1884 "include/linux/skbuff.h"
__inline static unsigned char *skb_transport_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1886
  return ((unsigned char *)skb->head + (unsigned long )skb->transport_header);
}
}
#line 1901 "include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1903
  return ((unsigned char *)skb->head + (unsigned long )skb->network_header);
}
}
#line 1971 "include/linux/skbuff.h"
__inline static int skb_transport_offset(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 1973
  tmp = skb_transport_header(skb);
#line 1973
  return ((int )((unsigned int )((long )tmp) - (unsigned int )((long )skb->data)));
}
}
#line 1976 "include/linux/skbuff.h"
__inline static u32 skb_network_header_len(struct sk_buff  const  *skb ) 
{ 


  {
#line 1978
  return ((u32 )((int )skb->transport_header - (int )skb->network_header));
}
}
#line 1986 "include/linux/skbuff.h"
__inline static int skb_network_offset(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 1988
  tmp = skb_network_header(skb);
#line 1988
  return ((int )((unsigned int )((long )tmp) - (unsigned int )((long )skb->data)));
}
}
#line 2202
extern struct sk_buff *__napi_alloc_skb(struct napi_struct * , unsigned int  , gfp_t  ) ;
#line 2204 "include/linux/skbuff.h"
__inline static struct sk_buff *napi_alloc_skb(struct napi_struct *napi , unsigned int length ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2207
  tmp = __napi_alloc_skb(napi, length, 32U);
#line 2207
  return (tmp);
}
}
#line 2219 "include/linux/skbuff.h"
__inline static struct page *__dev_alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 2230
  gfp_mask = gfp_mask | 24832U;
#line 2232
  tmp = alloc_pages_node(-1, gfp_mask, order);
#line 2232
  return (tmp);
}
}
#line 2235 "include/linux/skbuff.h"
__inline static struct page *dev_alloc_pages(unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 2237
  tmp = __dev_alloc_pages(32U, order);
#line 2237
  return (tmp);
}
}
#line 2276 "include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t const   *frag ) 
{ 


  {
#line 2278
  return ((struct page *)frag->page.p);
}
}
#line 2334 "include/linux/skbuff.h"
__inline static void *skb_frag_address(skb_frag_t const   *frag ) 
{ 
  struct page *tmp ;
  void *tmp___0 ;

  {
#line 2336
  tmp = skb_frag_page(frag);
#line 2336
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
#line 2336
  return (tmp___0 + (unsigned long )frag->page_offset);
}
}
#line 2394 "include/linux/skbuff.h"
__inline static dma_addr_t skb_frag_dma_map(struct device *dev , skb_frag_t const   *frag ,
                                            size_t offset , size_t size , enum dma_data_direction dir ) 
{ 
  struct page *tmp ;
  dma_addr_t tmp___0 ;

  {
#line 2399
  tmp = skb_frag_page(frag);
#line 2399
  tmp___0 = dma_map_page(dev, tmp, (size_t )frag->page_offset + offset, size, dir);
#line 2399
  return (tmp___0);
}
}
#line 2431 "include/linux/skbuff.h"
__inline static int __skb_cow(struct sk_buff *skb , unsigned int headroom , int cloned ) 
{ 
  int delta ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _max1 ;
  int _max2 ;
  int _max1___0 ;
  int _max2___0 ;
  int tmp___1 ;

  {
#line 2434
  delta = 0;
#line 2436
  tmp___0 = skb_headroom((struct sk_buff  const  *)skb);
#line 2436
  if (tmp___0 < headroom) {
#line 2437
    tmp = skb_headroom((struct sk_buff  const  *)skb);
#line 2437
    delta = (int )(headroom - tmp);
  } else {

  }
#line 2439
  if (delta != 0 || cloned != 0) {
#line 2440
    _max1 = 32;
#line 2440
    _max2 = 64;
#line 2440
    _max1___0 = 32;
#line 2440
    _max2___0 = 64;
#line 2440
    tmp___1 = pskb_expand_head(skb, (((_max1 > _max2 ? _max1 : _max2) + -1) + delta) & - (_max1___0 > _max2___0 ? _max1___0 : _max2___0),
                               0, 32U);
#line 2440
    return (tmp___1);
  } else {

  }
#line 2442
  return (0);
}
}
#line 2472 "include/linux/skbuff.h"
__inline static int skb_cow_head(struct sk_buff *skb , unsigned int headroom ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2474
  tmp = skb_header_cloned((struct sk_buff  const  *)skb);
#line 2474
  tmp___0 = __skb_cow(skb, headroom, tmp);
#line 2474
  return (tmp___0);
}
}
#line 2505 "include/linux/skbuff.h"
__inline static int skb_put_padto(struct sk_buff *skb , unsigned int len ) 
{ 
  unsigned int size ;
  int tmp ;
  long tmp___0 ;

  {
#line 2507
  size = skb->len;
#line 2509
  tmp___0 = ldv__builtin_expect(size < len, 0L);
#line 2509
  if (tmp___0 != 0L) {
#line 2510
    len = len - size;
#line 2511
    tmp = skb_pad(skb, (int )len);
#line 2511
    if (tmp != 0) {
#line 2512
      return (-12);
    } else {

    }
#line 2513
    __skb_put(skb, len);
  } else {

  }
#line 2515
  return (0);
}
}
#line 2704
extern int skb_copy_bits(struct sk_buff  const  * , int  , void * , int  ) ;
#line 2752 "include/linux/skbuff.h"
__inline static void *__skb_header_pointer(struct sk_buff  const  *skb , int offset ,
                                           int len , void *data , int hlen , void *buffer ) 
{ 
  int tmp ;

  {
#line 2755
  if (hlen - offset >= len) {
#line 2756
    return (data + (unsigned long )offset);
  } else {

  }
#line 2758
  if ((unsigned long )skb == (unsigned long )((struct sk_buff  const  *)0)) {
#line 2760
    return ((void *)0);
  } else {
#line 2758
    tmp = skb_copy_bits(skb, offset, buffer, len);
#line 2758
    if (tmp < 0) {
#line 2760
      return ((void *)0);
    } else {

    }
  }
#line 2762
  return (buffer);
}
}
#line 2766 "include/linux/skbuff.h"
__inline static void *skb_header_pointer(struct sk_buff  const  *skb , int offset ,
                                         int len , void *buffer ) 
{ 
  unsigned int tmp ;
  void *tmp___0 ;

  {
#line 2768
  tmp = skb_headlen(skb);
#line 2768
  tmp___0 = __skb_header_pointer(skb, offset, len, (void *)skb->data, (int )tmp, buffer);
#line 2768
  return (tmp___0);
}
}
#line 2804 "include/linux/skbuff.h"
__inline static void skb_copy_to_linear_data(struct sk_buff *skb , void const   *from ,
                                             unsigned int const   len ) 
{ 


  {
#line 2808
  memcpy((void *)skb->data, from, (size_t )len);
#line 2809
  return;
}
}
#line 2866
extern void skb_clone_tx_timestamp(struct sk_buff * ) ;
#line 2912
extern void skb_tstamp_tx(struct sk_buff * , struct skb_shared_hwtstamps * ) ;
#line 2915 "include/linux/skbuff.h"
__inline static void sw_tx_timestamp(struct sk_buff *skb ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 2917
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2917
  if (((int )((struct skb_shared_info *)tmp)->tx_flags & 2) != 0) {
#line 2917
    tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2917
    if (((int )((struct skb_shared_info *)tmp___0)->tx_flags & 4) == 0) {
#line 2919
      skb_tstamp_tx(skb, (struct skb_shared_hwtstamps *)0);
    } else {

    }
  } else {

  }
#line 2920
  return;
}
}
#line 2934 "include/linux/skbuff.h"
__inline static void skb_tx_timestamp(struct sk_buff *skb ) 
{ 


  {
#line 2936
  skb_clone_tx_timestamp(skb);
#line 2937
  sw_tx_timestamp(skb);
#line 2938
  return;
}
}
#line 3306 "include/linux/skbuff.h"
__inline static void skb_record_rx_queue(struct sk_buff *skb , u16 rx_queue ) 
{ 


  {
#line 3308
  skb->queue_mapping = (unsigned int )rx_queue + 1U;
#line 3309
  return;
}
}
#line 3311 "include/linux/skbuff.h"
__inline static u16 skb_get_rx_queue(struct sk_buff  const  *skb ) 
{ 


  {
#line 3313
  return ((unsigned int )((u16 )skb->queue_mapping) + 65535U);
}
}
#line 3316 "include/linux/skbuff.h"
__inline static bool skb_rx_queue_recorded(struct sk_buff  const  *skb ) 
{ 


  {
#line 3318
  return ((unsigned int )((unsigned short )skb->queue_mapping) != 0U);
}
}
#line 3385 "include/linux/skbuff.h"
__inline static bool skb_is_gso(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 3387
  tmp = skb_end_pointer(skb);
#line 3387
  return ((unsigned int )((struct skb_shared_info *)tmp)->gso_size != 0U);
}
}
#line 3391 "include/linux/skbuff.h"
__inline static bool skb_is_gso_v6(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 3393
  tmp = skb_end_pointer(skb);
#line 3393
  return (((int )((struct skb_shared_info *)tmp)->gso_type & 16) != 0);
}
}
#line 3427 "include/linux/skbuff.h"
__inline static void skb_checksum_none_assert(struct sk_buff  const  *skb ) 
{ 


  {
#line 3429
  return;
}
}
#line 71 "include/linux/u64_stats_sync.h"
__inline static void u64_stats_init(struct u64_stats_sync *syncp ) 
{ 


  {
#line 73
  return;
}
}
#line 123 "include/linux/u64_stats_sync.h"
__inline static unsigned int u64_stats_fetch_begin_irq(struct u64_stats_sync  const  *syncp ) 
{ 


  {
#line 131
  return (0U);
}
}
#line 135 "include/linux/u64_stats_sync.h"
__inline static bool u64_stats_fetch_retry_irq(struct u64_stats_sync  const  *syncp ,
                                               unsigned int start ) 
{ 


  {
#line 144
  return (0);
}
}
#line 11 "include/linux/hardirq.h"
extern void synchronize_irq(unsigned int  ) ;
#line 127 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 132 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 135
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 135
  return (tmp);
}
}
#line 141
__inline static int ldv_request_irq_17(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 145
__inline static int ldv_request_irq_18(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 149
__inline static int ldv_request_irq_20(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 153
__inline static int ldv_request_irq_21(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 162
extern void free_irq(unsigned int  , void * ) ;
#line 165
void ldv_free_irq_19(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 169
void ldv_free_irq_22(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 173
void ldv_free_irq_23(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 177
void ldv_free_irq_24(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 263
extern int irq_set_affinity_hint(unsigned int  , struct cpumask  const  * ) ;
#line 45 "include/linux/mii.h"
__inline static struct mii_ioctl_data *if_mii(struct ifreq *rq ) 
{ 


  {
#line 47
  return ((struct mii_ioctl_data *)(& rq->ifr_ifru));
}
}
#line 35 "include/net/dcbnl.h"
extern u8 dcb_ieee_getapp_mask(struct net_device * , struct dcb_app * ) ;
#line 391 "include/linux/netdevice.h"
extern void __napi_schedule(struct napi_struct * ) ;
#line 394 "include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n ) 
{ 
  int tmp ;

  {
#line 396
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& n->state));
#line 396
  return (tmp != 0);
}
}
#line 408 "include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n ) 
{ 
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 410
  tmp = napi_disable_pending(n);
#line 410
  if (tmp) {
#line 410
    tmp___0 = 0;
  } else {
#line 410
    tmp___0 = 1;
  }
#line 410
  if (tmp___0) {
#line 410
    tmp___1 = test_and_set_bit(0L, (unsigned long volatile   *)(& n->state));
#line 410
    if (tmp___1 == 0) {
#line 410
      tmp___2 = 1;
    } else {
#line 410
      tmp___2 = 0;
    }
  } else {
#line 410
    tmp___2 = 0;
  }
#line 410
  return ((bool )tmp___2);
}
}
#line 421 "include/linux/netdevice.h"
__inline static void napi_schedule(struct napi_struct *n ) 
{ 
  bool tmp ;

  {
#line 423
  tmp = napi_schedule_prep(n);
#line 423
  if ((int )tmp) {
#line 424
    __napi_schedule(n);
  } else {

  }
#line 425
  return;
}
}
#line 458 "include/linux/netdevice.h"
__inline static void napi_complete(struct napi_struct *n ) 
{ 


  {
#line 460
  return;
}
}
#line 496
extern void napi_disable(struct napi_struct * ) ;
#line 505 "include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 507
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& n->state));
#line 507
  tmp___0 = ldv__builtin_expect(tmp == 0, 0L);
#line 507
  if (tmp___0 != 0L) {
#line 507
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/netdevice.h"),
                         "i" (507), "i" (12UL));
    ldv_43593: ;
#line 507
    goto ldv_43593;
  } else {

  }
#line 508
  __asm__  volatile   ("": : : "memory");
#line 509
  clear_bit(0L, (unsigned long volatile   *)(& n->state));
#line 510
  return;
}
}
#line 1771 "include/linux/netdevice.h"
__inline static int netdev_get_prio_tc_map(struct net_device  const  *dev , u32 prio ) 
{ 


  {
#line 1773
  return ((int )dev->prio_tc_map[prio & 15U]);
}
}
#line 1777 "include/linux/netdevice.h"
__inline static int netdev_set_prio_tc_map(struct net_device *dev , u8 prio , u8 tc ) 
{ 


  {
#line 1779
  if ((int )dev->num_tc <= (int )tc) {
#line 1780
    return (-22);
  } else {

  }
#line 1782
  dev->prio_tc_map[(int )prio & 15] = (unsigned int )tc & 15U;
#line 1783
  return (0);
}
}
#line 1787 "include/linux/netdevice.h"
__inline static void netdev_reset_tc(struct net_device *dev ) 
{ 


  {
#line 1789
  dev->num_tc = 0U;
#line 1790
  memset((void *)(& dev->tc_to_txq), 0, 64UL);
#line 1791
  memset((void *)(& dev->prio_tc_map), 0, 16UL);
#line 1792
  return;
}
}
#line 1806 "include/linux/netdevice.h"
__inline static int netdev_set_num_tc(struct net_device *dev , u8 num_tc ) 
{ 


  {
#line 1808
  if ((unsigned int )num_tc > 16U) {
#line 1809
    return (-22);
  } else {

  }
#line 1811
  dev->num_tc = num_tc;
#line 1812
  return (0);
}
}
#line 1816 "include/linux/netdevice.h"
__inline static int netdev_get_num_tc(struct net_device *dev ) 
{ 


  {
#line 1818
  return ((int )dev->num_tc);
}
}
#line 1822 "include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device  const  *dev ,
                                                         unsigned int index ) 
{ 


  {
#line 1825
  return ((struct netdev_queue *)dev->_tx + (unsigned long )index);
}
}
#line 1880 "include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device  const  *dev ) 
{ 


  {
#line 1882
  return ((void *)dev + 3008U);
}
}
#line 2202
extern void free_netdev(struct net_device * ) ;
#line 2205
void ldv_free_netdev_30(struct net_device *dev ) ;
#line 2209
void ldv_free_netdev_33(struct net_device *dev ) ;
#line 2505
extern void netif_schedule_queue(struct netdev_queue * ) ;
#line 2515 "include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue ) 
{ 


  {
#line 2517
  clear_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2518
  return;
}
}
#line 2531 "include/linux/netdevice.h"
__inline static void netif_tx_start_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2535
  i = 0U;
#line 2535
  goto ldv_44667;
  ldv_44666: 
#line 2536
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2536
  txq = tmp;
#line 2537
  netif_tx_start_queue(txq);
#line 2535
  i = i + 1U;
  ldv_44667: ;
#line 2535
  if (dev->num_tx_queues > i) {
#line 2537
    goto ldv_44666;
  } else {

  }

#line 2542
  return;
}
}
#line 2541
extern void netif_tx_wake_queue(struct netdev_queue * ) ;
#line 2555 "include/linux/netdevice.h"
__inline static void netif_tx_wake_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2559
  i = 0U;
#line 2559
  goto ldv_44680;
  ldv_44679: 
#line 2560
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2560
  txq = tmp;
#line 2561
  netif_tx_wake_queue(txq);
#line 2559
  i = i + 1U;
  ldv_44680: ;
#line 2559
  if (dev->num_tx_queues > i) {
#line 2561
    goto ldv_44679;
  } else {

  }

#line 2566
  return;
}
}
#line 2565 "include/linux/netdevice.h"
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue ) 
{ 


  {
#line 2567
  set_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2568
  return;
}
}
#line 2582
extern void netif_tx_stop_all_queues(struct net_device * ) ;
#line 2584 "include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue  const  *dev_queue ) 
{ 
  int tmp ;

  {
#line 2586
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev_queue->state));
#line 2586
  return (tmp != 0);
}
}
#line 2600 "include/linux/netdevice.h"
__inline static bool netif_xmit_stopped(struct netdev_queue  const  *dev_queue ) 
{ 


  {
#line 2602
  return (((unsigned long )dev_queue->state & 3UL) != 0UL);
}
}
#line 2645 "include/linux/netdevice.h"
__inline static void netdev_tx_sent_queue(struct netdev_queue *dev_queue , unsigned int bytes ) 
{ 
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 2649
  dql_queued(& dev_queue->dql, bytes);
#line 2651
  tmp = dql_avail((struct dql  const  *)(& dev_queue->dql));
#line 2651
  tmp___0 = ldv__builtin_expect(tmp >= 0, 1L);
#line 2651
  if (tmp___0 != 0L) {
#line 2652
    return;
  } else {

  }
#line 2654
  set_bit(1L, (unsigned long volatile   *)(& dev_queue->state));
#line 2661
  __asm__  volatile   ("mfence": : : "memory");
#line 2664
  tmp___1 = dql_avail((struct dql  const  *)(& dev_queue->dql));
#line 2664
  tmp___2 = ldv__builtin_expect(tmp___1 >= 0, 0L);
#line 2664
  if (tmp___2 != 0L) {
#line 2665
    clear_bit(1L, (unsigned long volatile   *)(& dev_queue->state));
  } else {

  }
#line 2666
  return;
}
}
#line 2683 "include/linux/netdevice.h"
__inline static void netdev_tx_completed_queue(struct netdev_queue *dev_queue , unsigned int pkts ,
                                               unsigned int bytes ) 
{ 
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2687
  tmp = ldv__builtin_expect(bytes == 0U, 0L);
#line 2687
  if (tmp != 0L) {
#line 2688
    return;
  } else {

  }
#line 2690
  dql_completed(& dev_queue->dql, bytes);
#line 2697
  __asm__  volatile   ("mfence": : : "memory");
#line 2699
  tmp___0 = dql_avail((struct dql  const  *)(& dev_queue->dql));
#line 2699
  if (tmp___0 < 0) {
#line 2700
    return;
  } else {

  }
#line 2702
  tmp___1 = test_and_clear_bit(1L, (unsigned long volatile   *)(& dev_queue->state));
#line 2702
  if (tmp___1 != 0) {
#line 2703
    netif_schedule_queue(dev_queue);
  } else {

  }
#line 2704
  return;
}
}
#line 2723 "include/linux/netdevice.h"
__inline static void netdev_tx_reset_queue(struct netdev_queue *q ) 
{ 


  {
#line 2726
  clear_bit(1L, (unsigned long volatile   *)(& q->state));
#line 2727
  dql_reset(& q->dql);
#line 2728
  return;
}
}
#line 2769 "include/linux/netdevice.h"
__inline static bool netif_running(struct net_device  const  *dev ) 
{ 
  int tmp ;

  {
#line 2771
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev->state));
#line 2771
  return (tmp != 0);
}
}
#line 2788 "include/linux/netdevice.h"
__inline static void netif_start_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2790
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2790
  txq = tmp;
#line 2792
  netif_tx_start_queue(txq);
#line 2793
  return;
}
}
#line 2802 "include/linux/netdevice.h"
__inline static void netif_stop_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2804
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2804
  txq = tmp;
#line 2805
  netif_tx_stop_queue(txq);
#line 2806
  return;
}
}
#line 2815 "include/linux/netdevice.h"
__inline static bool __netif_subqueue_stopped(struct net_device  const  *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  bool tmp___0 ;

  {
#line 2818
  tmp = netdev_get_tx_queue(dev, (unsigned int )queue_index);
#line 2818
  txq = tmp;
#line 2820
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)txq);
#line 2820
  return (tmp___0);
}
}
#line 2829
extern void netif_wake_subqueue(struct net_device * , u16  ) ;
#line 2832
extern int netif_set_xps_queue(struct net_device * , struct cpumask  const  * , u16  ) ;
#line 2867
extern int netif_set_real_num_tx_queues(struct net_device * , unsigned int  ) ;
#line 2870
extern int netif_set_real_num_rx_queues(struct net_device * , unsigned int  ) ;
#line 2900
extern void __dev_kfree_skb_any(struct sk_buff * , enum skb_free_reason  ) ;
#line 2931 "include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb ) 
{ 


  {
#line 2933
  __dev_kfree_skb_any(skb, 1);
#line 2934
  return;
}
}
#line 2936 "include/linux/netdevice.h"
__inline static void dev_consume_skb_any(struct sk_buff *skb ) 
{ 


  {
#line 2938
  __dev_kfree_skb_any(skb, 0);
#line 2939
  return;
}
}
#line 2943
extern int netif_receive_skb_sk(struct sock * , struct sk_buff * ) ;
#line 2944 "include/linux/netdevice.h"
__inline static int netif_receive_skb(struct sk_buff *skb ) 
{ 
  int tmp ;

  {
#line 2946
  tmp = netif_receive_skb_sk(skb->sk, skb);
#line 2946
  return (tmp);
}
}
#line 2948
extern gro_result_t napi_gro_receive(struct napi_struct * , struct sk_buff * ) ;
#line 2949
extern void napi_gro_flush(struct napi_struct * , bool  ) ;
#line 3038 "include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device  const  *dev ) 
{ 
  int tmp ;

  {
#line 3040
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& dev->state));
#line 3040
  return (tmp == 0);
}
}
#line 3047
extern void netif_carrier_on(struct net_device * ) ;
#line 3049
extern void netif_carrier_off(struct net_device * ) ;
#line 3117
extern void netif_device_detach(struct net_device * ) ;
#line 3119
extern void netif_device_attach(struct net_device * ) ;
#line 3159 "include/linux/netdevice.h"
__inline static u32 netif_msg_init(int debug_value , int default_msg_enable_bits ) 
{ 


  {
#line 3162
  if (debug_value < 0 || (unsigned int )debug_value > 31U) {
#line 3163
    return ((u32 )default_msg_enable_bits);
  } else {

  }
#line 3164
  if (debug_value == 0) {
#line 3165
    return (0U);
  } else {

  }
#line 3167
  return ((u32 )((1 << debug_value) + -1));
}
}
#line 3170 "include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq , int cpu ) 
{ 


  {
#line 3172
  spin_lock(& txq->_xmit_lock);
#line 3173
  txq->xmit_lock_owner = cpu;
#line 3174
  return;
}
}
#line 3190 "include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq ) 
{ 


  {
#line 3192
  txq->xmit_lock_owner = -1;
#line 3193
  spin_unlock(& txq->_xmit_lock);
#line 3194
  return;
}
}
#line 3282 "include/linux/netdevice.h"
__inline static void netif_tx_disable(struct net_device *dev ) 
{ 
  unsigned int i ;
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 3287
  local_bh_disable();
#line 3288
  __vpp_verify = (void const   *)0;
#line 3288
  switch (4UL) {
  case 1UL: ;
#line 3288
  switch (4UL) {
  case 1UL: 
#line 3288
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 3288
  goto ldv_45242;
  case 2UL: 
#line 3288
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3288
  goto ldv_45242;
  case 4UL: 
#line 3288
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3288
  goto ldv_45242;
  case 8UL: 
#line 3288
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3288
  goto ldv_45242;
  default: 
#line 3288
  __bad_percpu_size();
  }
  ldv_45242: 
#line 3288
  pscr_ret__ = pfo_ret__;
#line 3288
  goto ldv_45248;
  case 2UL: ;
#line 3288
  switch (4UL) {
  case 1UL: 
#line 3288
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 3288
  goto ldv_45252;
  case 2UL: 
#line 3288
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3288
  goto ldv_45252;
  case 4UL: 
#line 3288
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3288
  goto ldv_45252;
  case 8UL: 
#line 3288
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3288
  goto ldv_45252;
  default: 
#line 3288
  __bad_percpu_size();
  }
  ldv_45252: 
#line 3288
  pscr_ret__ = pfo_ret_____0;
#line 3288
  goto ldv_45248;
  case 4UL: ;
#line 3288
  switch (4UL) {
  case 1UL: 
#line 3288
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 3288
  goto ldv_45261;
  case 2UL: 
#line 3288
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3288
  goto ldv_45261;
  case 4UL: 
#line 3288
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3288
  goto ldv_45261;
  case 8UL: 
#line 3288
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3288
  goto ldv_45261;
  default: 
#line 3288
  __bad_percpu_size();
  }
  ldv_45261: 
#line 3288
  pscr_ret__ = pfo_ret_____1;
#line 3288
  goto ldv_45248;
  case 8UL: ;
#line 3288
  switch (4UL) {
  case 1UL: 
#line 3288
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 3288
  goto ldv_45270;
  case 2UL: 
#line 3288
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3288
  goto ldv_45270;
  case 4UL: 
#line 3288
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3288
  goto ldv_45270;
  case 8UL: 
#line 3288
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3288
  goto ldv_45270;
  default: 
#line 3288
  __bad_percpu_size();
  }
  ldv_45270: 
#line 3288
  pscr_ret__ = pfo_ret_____2;
#line 3288
  goto ldv_45248;
  default: 
#line 3288
  __bad_size_call_parameter();
#line 3288
  goto ldv_45248;
  }
  ldv_45248: 
#line 3288
  cpu = pscr_ret__;
#line 3289
  i = 0U;
#line 3289
  goto ldv_45280;
  ldv_45279: 
#line 3290
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 3290
  txq = tmp;
#line 3292
  __netif_tx_lock(txq, cpu);
#line 3293
  netif_tx_stop_queue(txq);
#line 3294
  __netif_tx_unlock(txq);
#line 3289
  i = i + 1U;
  ldv_45280: ;
#line 3289
  if (dev->num_tx_queues > i) {
#line 3291
    goto ldv_45279;
  } else {

  }
#line 3296
  local_bh_enable();
#line 3297
  return;
}
}
#line 3352
extern int register_netdev(struct net_device * ) ;
#line 3355
int ldv_register_netdev_29(struct net_device *dev ) ;
#line 3357
extern void unregister_netdev(struct net_device * ) ;
#line 3360
void ldv_unregister_netdev_27(struct net_device *dev ) ;
#line 3364
void ldv_unregister_netdev_32(struct net_device *dev ) ;
#line 3384
extern int dev_addr_add(struct net_device * , unsigned char const   * , unsigned char  ) ;
#line 3386
extern int dev_addr_del(struct net_device * , unsigned char const   * , unsigned char  ) ;
#line 3488
extern struct net_device *netdev_all_upper_get_next_dev_rcu(struct net_device * ,
                                                            struct list_head ** ) ;
#line 3549
extern void netdev_rss_key_fill(void * , size_t  ) ;
#line 3730 "include/linux/netdevice.h"
__inline static void netif_set_gso_max_size(struct net_device *dev , unsigned int size ) 
{ 


  {
#line 3733
  dev->gso_max_size = size;
#line 3734
  return;
}
}
#line 3749 "include/linux/netdevice.h"
__inline static bool netif_is_macvlan(struct net_device *dev ) 
{ 


  {
#line 3751
  return ((dev->priv_flags & 2097152U) != 0U);
}
}
#line 3826
extern void netdev_crit(struct net_device  const  * , char const   *  , ...) ;
#line 3828
extern void netdev_err(struct net_device  const  * , char const   *  , ...) ;
#line 3830
extern void netdev_warn(struct net_device  const  * , char const   *  , ...) ;
#line 3834
extern void netdev_info(struct net_device  const  * , char const   *  , ...) ;
#line 70 "include/linux/vmalloc.h"
extern void *vzalloc(unsigned long  ) ;
#line 73
extern void *vzalloc_node(unsigned long  , int  ) ;
#line 83
extern void vfree(void const   * ) ;
#line 23 "include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 25
  tmp = skb_network_header(skb);
#line 25
  return ((struct iphdr *)tmp);
}
}
#line 27 "include/linux/rtnetlink.h"
extern void rtnl_lock(void) ;
#line 28
extern void rtnl_unlock(void) ;
#line 103
extern int ndo_dflt_fdb_add(struct ndmsg * , struct nlattr ** , struct net_device * ,
                            unsigned char const   * , u16  , u16  ) ;
#line 115
extern int ndo_dflt_bridge_getlink(struct sk_buff * , u32  , u32  , struct net_device * ,
                                   u16  , u32  , u32  , int  , u32  , int (*)(struct sk_buff * ,
                                                                              struct net_device * ,
                                                                              u32  ) ) ;
#line 241 "include/net/netlink.h"
extern struct nlattr *nla_find(struct nlattr  const  * , int  , int  ) ;
#line 292 "include/net/netlink.h"
__inline static void *nlmsg_data(struct nlmsghdr  const  *nlh ) 
{ 


  {
#line 294
  return ((void *)nlh + 16U);
}
}
#line 301 "include/net/netlink.h"
__inline static int nlmsg_len(struct nlmsghdr  const  *nlh ) 
{ 


  {
#line 303
  return ((int )((unsigned int )nlh->nlmsg_len - 16U));
}
}
#line 311 "include/net/netlink.h"
__inline static struct nlattr *nlmsg_attrdata(struct nlmsghdr  const  *nlh , int hdrlen ) 
{ 
  unsigned char *data ;
  void *tmp ;

  {
#line 314
  tmp = nlmsg_data(nlh);
#line 314
  data = (unsigned char *)tmp;
#line 315
  return ((struct nlattr *)(data + ((unsigned long )((unsigned int )hdrlen + 3U) & 4294967292UL)));
}
}
#line 323 "include/net/netlink.h"
__inline static int nlmsg_attrlen(struct nlmsghdr  const  *nlh , int hdrlen ) 
{ 
  int tmp ;

  {
#line 325
  tmp = nlmsg_len(nlh);
#line 325
  return ((int )((unsigned int )tmp - (((unsigned int )hdrlen + 3U) & 4294967292U)));
}
}
#line 387 "include/net/netlink.h"
__inline static struct nlattr *nlmsg_find_attr(struct nlmsghdr  const  *nlh , int hdrlen ,
                                               int attrtype ) 
{ 
  int tmp ;
  struct nlattr *tmp___0 ;
  struct nlattr *tmp___1 ;

  {
#line 390
  tmp = nlmsg_attrlen(nlh, hdrlen);
#line 390
  tmp___0 = nlmsg_attrdata(nlh, hdrlen);
#line 390
  tmp___1 = nla_find((struct nlattr  const  *)tmp___0, tmp, attrtype);
#line 390
  return (tmp___1);
}
}
#line 660 "include/net/netlink.h"
__inline static int nla_type(struct nlattr  const  *nla ) 
{ 


  {
#line 662
  return ((int )nla->nla_type & -49153);
}
}
#line 669 "include/net/netlink.h"
__inline static void *nla_data(struct nlattr  const  *nla ) 
{ 


  {
#line 671
  return ((void *)nla + 4U);
}
}
#line 678 "include/net/netlink.h"
__inline static int nla_len(struct nlattr  const  *nla ) 
{ 


  {
#line 680
  return ((int )nla->nla_len + -4);
}
}
#line 688 "include/net/netlink.h"
__inline static int nla_ok(struct nlattr  const  *nla , int remaining ) 
{ 


  {
#line 690
  return ((remaining > 3 && (unsigned int )((unsigned short )nla->nla_len) > 3U) && (int )nla->nla_len <= remaining);
}
}
#line 703 "include/net/netlink.h"
__inline static struct nlattr *nla_next(struct nlattr  const  *nla , int *remaining ) 
{ 
  int totlen ;

  {
#line 705
  totlen = ((int )nla->nla_len + 3) & -4;
#line 707
  *remaining = *remaining - totlen;
#line 708
  return ((struct nlattr *)nla + (unsigned long )totlen);
}
}
#line 1010 "include/net/netlink.h"
__inline static u16 nla_get_u16(struct nlattr  const  *nla ) 
{ 
  void *tmp ;

  {
#line 1012
  tmp = nla_data(nla);
#line 1012
  return (*((u16 *)tmp));
}
}
#line 27 "include/linux/tcp.h"
__inline static struct tcphdr *tcp_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 29
  tmp = skb_transport_header(skb);
#line 29
  return ((struct tcphdr *)tmp);
}
}
#line 32 "include/linux/tcp.h"
__inline static unsigned int tcp_hdrlen(struct sk_buff  const  *skb ) 
{ 
  struct tcphdr *tmp ;

  {
#line 34
  tmp = tcp_hdr(skb);
#line 34
  return ((unsigned int )((int )tmp->doff * 4));
}
}
#line 74 "include/linux/ipv6.h"
__inline static struct ipv6hdr *ipv6_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 76
  tmp = skb_network_header(skb);
#line 76
  return ((struct ipv6hdr *)tmp);
}
}
#line 32 "include/linux/etherdevice.h"
extern u32 eth_get_headlen(void * , unsigned int  ) ;
#line 33
extern __be16 eth_type_trans(struct sk_buff * , struct net_device * ) ;
#line 47
extern int eth_validate_addr(struct net_device * ) ;
#line 49
extern struct net_device *alloc_etherdev_mqs(int  , unsigned int  , unsigned int  ) ;
#line 59 "include/linux/etherdevice.h"
static u8 const   eth_reserved_addr_base[6U]  = {      1U,      128U,      194U,      0U, 
        0U,      0U};
#line 71 "include/linux/etherdevice.h"
__inline static bool is_link_local_ether_addr(u8 const   *addr ) 
{ 
  __be16 *a ;
  __be16 const   *b ;
  __be16 m ;

  {
#line 73
  a = (__be16 *)addr;
#line 74
  b = (__be16 const   *)(& eth_reserved_addr_base);
#line 75
  m = 61695U;
#line 78
  return ((((unsigned int )*((u32 const   *)addr) ^ (unsigned int )*((u32 const   *)b)) | (unsigned int )(((int )*(a + 2UL) ^ (int )((unsigned short )*(b + 2UL))) & (int )m)) == 0U);
}
}
#line 93 "include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const   *addr ) 
{ 


  {
#line 96
  return (((unsigned int )*((u32 const   *)addr) | (unsigned int )*((u16 const   *)addr + 4U)) == 0U);
}
}
#line 111 "include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const   *addr ) 
{ 
  u32 a ;

  {
#line 114
  a = *((u32 const   *)addr);
#line 121
  return ((a & 1U) != 0U);
}
}
#line 170 "include/linux/etherdevice.h"
__inline static bool is_unicast_ether_addr(u8 const   *addr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 172
  tmp = is_multicast_ether_addr(addr);
#line 172
  if ((int )tmp != 0) {
#line 172
    tmp___0 = 0;
  } else {
#line 172
    tmp___0 = 1;
  }
#line 172
  return ((bool )tmp___0);
}
}
#line 186 "include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const   *addr ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 190
  tmp = is_multicast_ether_addr(addr);
#line 190
  if (tmp) {
#line 190
    tmp___0 = 0;
  } else {
#line 190
    tmp___0 = 1;
  }
#line 190
  if (tmp___0) {
#line 190
    tmp___1 = is_zero_ether_addr(addr);
#line 190
    if (tmp___1) {
#line 190
      tmp___2 = 0;
    } else {
#line 190
      tmp___2 = 1;
    }
#line 190
    if (tmp___2) {
#line 190
      tmp___3 = 1;
    } else {
#line 190
      tmp___3 = 0;
    }
  } else {
#line 190
    tmp___3 = 0;
  }
#line 190
  return ((bool )tmp___3);
}
}
#line 244 "include/linux/etherdevice.h"
__inline static void eth_zero_addr(u8 *addr ) 
{ 


  {
#line 246
  memset((void *)addr, 0, 6UL);
#line 247
  return;
}
}
#line 271 "include/linux/etherdevice.h"
__inline static void ether_addr_copy(u8 *dst , u8 const   *src ) 
{ 


  {
#line 274
  *((u32 *)dst) = *((u32 const   *)src);
#line 275
  *((u16 *)dst + 4U) = *((u16 const   *)src + 4U);
#line 276
  return;
}
}
#line 310 "include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 const   *addr1 , u8 const   *addr2 ) 
{ 
  u32 fold ;

  {
#line 313
  fold = ((unsigned int )*((u32 const   *)addr1) ^ (unsigned int )*((u32 const   *)addr2)) | (unsigned int )((int )((unsigned short )*((u16 const   *)addr1 + 4U)) ^ (int )((unsigned short )*((u16 const   *)addr2 + 4U)));
#line 316
  return (fold == 0U);
}
}
#line 445 "include/linux/etherdevice.h"
__inline static int eth_skb_pad(struct sk_buff *skb ) 
{ 
  int tmp ;

  {
#line 447
  tmp = skb_put_padto(skb, 60U);
#line 447
  return (tmp);
}
}
#line 409 "include/linux/if_vlan.h"
__inline static void __vlan_hwaccel_put_tag(struct sk_buff *skb , __be16 vlan_proto ,
                                            u16 vlan_tci ) 
{ 


  {
#line 412
  skb->vlan_proto = vlan_proto;
#line 413
  skb->vlan_tci = (__u16 )((unsigned int )vlan_tci | 4096U);
#line 414
  return;
}
}
#line 481 "include/linux/if_vlan.h"
__inline static __be16 __vlan_get_protocol(struct sk_buff *skb , __be16 type , int *depth ) 
{ 
  unsigned int vlan_depth ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  struct vlan_hdr *vh ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 484
  vlan_depth = (unsigned int )skb->mac_len;
#line 490
  if ((unsigned int )type == 129U || (unsigned int )type == 43144U) {
#line 491
    if (vlan_depth != 0U) {
#line 492
      __ret_warn_on = vlan_depth <= 3U;
#line 492
      tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 492
      if (tmp != 0L) {
#line 492
        warn_slowpath_null("include/linux/if_vlan.h", 492);
      } else {

      }
#line 492
      tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 492
      if (tmp___0 != 0L) {
#line 493
        return (0U);
      } else {

      }
#line 494
      vlan_depth = vlan_depth - 4U;
    } else {
#line 496
      vlan_depth = 14U;
    }
    ldv_54225: 
#line 501
    tmp___1 = pskb_may_pull(skb, vlan_depth + 4U);
#line 501
    tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 501
    if (tmp___2 != 0L) {
#line 503
      return (0U);
    } else {

    }
#line 505
    vh = (struct vlan_hdr *)skb->data + (unsigned long )vlan_depth;
#line 506
    type = vh->h_vlan_encapsulated_proto;
#line 507
    vlan_depth = vlan_depth + 4U;
#line 509
    if ((unsigned int )type == 129U || (unsigned int )type == 43144U) {
#line 511
      goto ldv_54225;
    } else {

    }

  } else {

  }
#line 512
  if ((unsigned long )depth != (unsigned long )((int *)0)) {
#line 513
    *depth = (int )vlan_depth;
  } else {

  }
#line 515
  return (type);
}
}
#line 525 "include/linux/if_vlan.h"
__inline static __be16 vlan_get_protocol(struct sk_buff *skb ) 
{ 
  __be16 tmp ;

  {
#line 527
  tmp = __vlan_get_protocol(skb, (int )skb->protocol, (int *)0);
#line 527
  return (tmp);
}
}
#line 188 "include/net/vxlan.h"
extern void vxlan_get_rx_port(struct net_device * ) ;
#line 15 "include/linux/of_net.h"
extern void const   *of_get_mac_address(struct device_node * ) ;
#line 42 "include/linux/aer.h"
extern int pci_enable_pcie_error_reporting(struct pci_dev * ) ;
#line 43
extern int pci_disable_pcie_error_reporting(struct pci_dev * ) ;
#line 44
extern int pci_cleanup_aer_uncorrect_error_status(struct pci_dev * ) ;
#line 90 "include/linux/mdio.h"
extern int mdio_mii_ioctl(struct mdio_if_info  const  * , struct mii_ioctl_data * ,
                          int  ) ;
#line 121 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
void ixgbe_init_mbx_params_pf(struct ixgbe_hw *hw ) ;
#line 41 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
s32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw , u8 *pba_num , u32 pba_num_size ) ;
#line 44
enum ixgbe_bus_width ixgbe_convert_bus_width(u16 link_status ) ;
#line 45
enum ixgbe_bus_speed ixgbe_convert_bus_speed(u16 link_status ) ;
#line 53
s32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw ) ;
#line 63
s32 ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw , u16 offset , u16 *data ) ;
#line 84
bool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw ) ;
#line 116
bool ixgbe_mng_enabled(struct ixgbe_hw *hw ) ;
#line 142
u16 ixgbe_read_pci_cfg_word(struct ixgbe_hw *hw , u32 reg ) ;
#line 143
void ixgbe_write_pci_cfg_word(struct ixgbe_hw *hw , u32 reg , u16 value ) ;
#line 145 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static bool ixgbe_removed(void *addr ) 
{ 
  long tmp ;

  {
#line 147
  tmp = ldv__builtin_expect((unsigned long )addr == (unsigned long )((void *)0), 0L);
#line 147
  return (tmp != 0L);
}
}
#line 150 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg(struct ixgbe_hw *hw , u32 reg , u32 value ) 
{ 
  u8 *reg_addr ;
  u8 *__var ;
  bool tmp ;

  {
#line 152
  __var = (u8 *)0U;
#line 152
  reg_addr = *((u8 * volatile  *)(& hw->hw_addr));
#line 154
  tmp = ixgbe_removed((void *)reg_addr);
#line 154
  if ((int )tmp) {
#line 155
    return;
  } else {

  }
#line 156
  writel(value, (void volatile   *)reg_addr + (unsigned long )reg);
#line 157
  return;
}
}
#line 179
u32 ixgbe_read_reg(struct ixgbe_hw *hw , u32 reg ) ;
#line 149 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
u8 ixgbe_dcb_get_tc_from_up(struct ixgbe_dcb_config *cfg , int direction , u8 up___0 ) ;
#line 152
s32 ixgbe_dcb_calculate_tc_credits(struct ixgbe_hw *hw , struct ixgbe_dcb_config *dcb_config ,
                                   int max_frame , u8 direction ) ;
#line 156
s32 ixgbe_dcb_hw_ets(struct ixgbe_hw *hw , struct ieee_ets *ets , int max_frame ) ;
#line 159
s32 ixgbe_dcb_hw_pfc_config(struct ixgbe_hw *hw , u8 pfc_en , u8 *prio_tc ) ;
#line 160
s32 ixgbe_dcb_hw_config(struct ixgbe_hw *hw , struct ixgbe_dcb_config *dcb_config ) ;
#line 29 "include/linux/dca.h"
extern void dca_register_notify(struct notifier_block * ) ;
#line 30
extern void dca_unregister_notify(struct notifier_block * ) ;
#line 68
extern int dca_add_requester(struct device * ) ;
#line 69
extern int dca_remove_requester(struct device * ) ;
#line 71
extern u8 dca3_get_tag(struct device * , int  ) ;
#line 121 "include/net/busy_poll.h"
__inline static void skb_mark_napi_id(struct sk_buff *skb , struct napi_struct *napi ) 
{ 


  {
#line 124
  skb->__annonCompField83.napi_id = napi->napi_id;
#line 125
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static unsigned int ixgbe_rx_bufsz(struct ixgbe_ring *ring ) 
{ 
  int tmp ;

  {
#line 337
  tmp = constant_test_bit(6L, (unsigned long const volatile   *)(& ring->state));
#line 337
  if (tmp != 0) {
#line 338
    return (4096U);
  } else {

  }
#line 341
  return (2048U);
}
}
#line 344 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static unsigned int ixgbe_rx_pg_order(struct ixgbe_ring *ring ) 
{ 
  int tmp ;

  {
#line 347
  tmp = constant_test_bit(6L, (unsigned long const volatile   *)(& ring->state));
#line 347
  if (tmp != 0) {
#line 348
    return (1U);
  } else {

  }
#line 350
  return (0U);
}
}
#line 407 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static void ixgbe_qv_init_lock(struct ixgbe_q_vector *q_vector ) 
{ 


  {
#line 410
  atomic_set(& q_vector->state, 0);
#line 411
  return;
}
}
#line 414 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static bool ixgbe_qv_lock_napi(struct ixgbe_q_vector *q_vector ) 
{ 
  int rc ;
  int tmp ;

  {
#line 416
  tmp = atomic_cmpxchg(& q_vector->state, 0, 1);
#line 416
  rc = tmp;
#line 419
  if (rc != 0) {
#line 420
    (q_vector->tx.ring)->stats.yields = (q_vector->tx.ring)->stats.yields + 1ULL;
  } else {

  }
#line 423
  return (rc == 0);
}
}
#line 427 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static void ixgbe_qv_unlock_napi(struct ixgbe_q_vector *q_vector ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;

  {
#line 429
  tmp = atomic_read((atomic_t const   *)(& q_vector->state));
#line 429
  __ret_warn_on = tmp != 1;
#line 429
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 429
  if (tmp___0 != 0L) {
#line 429
    warn_slowpath_null("/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h",
                       429);
  } else {

  }
#line 429
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 432
  if ((unsigned long )q_vector->napi.gro_list != (unsigned long )((struct sk_buff *)0)) {
#line 433
    napi_gro_flush(& q_vector->napi, 0);
  } else {

  }
#line 436
  atomic_set(& q_vector->state, 0);
#line 437
  return;
}
}
#line 440 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static bool ixgbe_qv_lock_poll(struct ixgbe_q_vector *q_vector ) 
{ 
  int rc ;
  int tmp ;

  {
#line 442
  tmp = atomic_cmpxchg(& q_vector->state, 0, 2);
#line 442
  rc = tmp;
#line 445
  if (rc != 0) {
#line 446
    (q_vector->tx.ring)->stats.yields = (q_vector->tx.ring)->stats.yields + 1ULL;
  } else {

  }
#line 448
  return (rc == 0);
}
}
#line 452 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static void ixgbe_qv_unlock_poll(struct ixgbe_q_vector *q_vector ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;

  {
#line 454
  tmp = atomic_read((atomic_t const   *)(& q_vector->state));
#line 454
  __ret_warn_on = tmp != 2;
#line 454
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 454
  if (tmp___0 != 0L) {
#line 454
    warn_slowpath_null("/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h",
                       454);
  } else {

  }
#line 454
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 457
  atomic_set(& q_vector->state, 0);
#line 458
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static bool ixgbe_qv_busy_polling(struct ixgbe_q_vector *q_vector ) 
{ 
  int tmp ;

  {
#line 463
  tmp = atomic_read((atomic_t const   *)(& q_vector->state));
#line 463
  return (tmp == 2);
}
}
#line 467 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static bool ixgbe_qv_disable(struct ixgbe_q_vector *q_vector ) 
{ 
  int rc ;
  int tmp ;

  {
#line 469
  tmp = atomic_cmpxchg(& q_vector->state, 0, 3);
#line 469
  rc = tmp;
#line 472
  return (rc == 0);
}
}
#line 546 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static __le32 ixgbe_test_staterr(union ixgbe_adv_rx_desc *rx_desc , u32 const   stat_err_bits ) 
{ 


  {
#line 549
  return (rx_desc->wb.upper.status_error & (__le32 )stat_err_bits);
}
}
#line 552 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static u16 ixgbe_desc_unused(struct ixgbe_ring *ring ) 
{ 
  u16 ntc ;
  u16 ntu ;

  {
#line 554
  ntc = ring->next_to_clean;
#line 555
  ntu = ring->next_to_use;
#line 557
  return (((((int )ntc <= (int )ntu ? ring->count : 0U) + (unsigned int )ntc) - (unsigned int )ntu) + 65535U);
}
}
#line 782 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static u8 ixgbe_max_rss_indices(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 784
  switch ((unsigned int )adapter->hw.mac.type) {
  case 1U: ;
  case 2U: ;
  case 3U: ;
#line 788
  return (16U);
  case 4U: ;
  case 5U: ;
#line 791
  return (64U);
  default: ;
#line 793
  return (0U);
  }
}
}
#line 836
struct ixgbe_info ixgbe_82598_info ;
#line 837
struct ixgbe_info ixgbe_82599_info ;
#line 838
struct ixgbe_info ixgbe_X540_info ;
#line 839
struct ixgbe_info ixgbe_X550_info ;
#line 840
struct ixgbe_info ixgbe_X550EM_x_info ;
#line 842
struct dcbnl_rtnl_ops  const  dcbnl_ops ;
#line 845
char ixgbe_driver_name[6U] ;
#line 846
char const   ixgbe_driver_version[8U] ;
#line 848
char ixgbe_default_device_descr[39U] ;
#line 851
void ixgbe_up(struct ixgbe_adapter *adapter ) ;
#line 852
void ixgbe_down(struct ixgbe_adapter *adapter ) ;
#line 853
void ixgbe_reinit_locked(struct ixgbe_adapter *adapter ) ;
#line 854
void ixgbe_reset(struct ixgbe_adapter *adapter ) ;
#line 855
void ixgbe_set_ethtool_ops(struct net_device *netdev ) ;
#line 856
int ixgbe_setup_rx_resources(struct ixgbe_ring *rx_ring ) ;
#line 857
int ixgbe_setup_tx_resources(struct ixgbe_ring *tx_ring ) ;
#line 858
void ixgbe_free_rx_resources(struct ixgbe_ring *rx_ring ) ;
#line 859
void ixgbe_free_tx_resources(struct ixgbe_ring *tx_ring ) ;
#line 860
void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) ;
#line 861
void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) ;
#line 862
void ixgbe_disable_rx_queue(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) ;
#line 863
void ixgbe_update_stats(struct ixgbe_adapter *adapter ) ;
#line 864
int ixgbe_init_interrupt_scheme(struct ixgbe_adapter *adapter ) ;
#line 865
int ixgbe_wol_supported(struct ixgbe_adapter *adapter , u16 device_id , u16 subdevice_id ) ;
#line 868
void ixgbe_full_sync_mac_table(struct ixgbe_adapter *adapter ) ;
#line 870
int ixgbe_add_mac_filter(struct ixgbe_adapter *adapter , u8 *addr , u16 queue ) ;
#line 872
int ixgbe_del_mac_filter(struct ixgbe_adapter *adapter , u8 *addr , u16 queue ) ;
#line 874
void ixgbe_clear_interrupt_scheme(struct ixgbe_adapter *adapter ) ;
#line 875
netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb , struct ixgbe_adapter *adapter ,
                                  struct ixgbe_ring *tx_ring ) ;
#line 877
void ixgbe_unmap_and_free_tx_resource(struct ixgbe_ring *ring , struct ixgbe_tx_buffer *tx_buffer ) ;
#line 879
void ixgbe_alloc_rx_buffers(struct ixgbe_ring *rx_ring , u16 cleaned_count ) ;
#line 880
void ixgbe_write_eitr(struct ixgbe_q_vector *q_vector ) ;
#line 881
int ixgbe_poll(struct napi_struct *napi , int budget ) ;
#line 883
s32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw ) ;
#line 884
s32 ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw , u32 fdirctrl ) ;
#line 885
s32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw , u32 fdirctrl ) ;
#line 886
s32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw , union ixgbe_atr_hash_dword input ,
                                          union ixgbe_atr_hash_dword common , u8 queue ) ;
#line 890
s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw , union ixgbe_atr_input *input_mask ) ;
#line 892
s32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw , union ixgbe_atr_input *input ,
                                          u16 soft_id , u8 queue ) ;
#line 900
void ixgbe_set_rx_mode(struct net_device *netdev ) ;
#line 902
void ixgbe_set_rx_drop_en(struct ixgbe_adapter *adapter ) ;
#line 904
int ixgbe_setup_tc(struct net_device *dev , u8 tc ) ;
#line 905
void ixgbe_tx_ctxtdesc(struct ixgbe_ring *tx_ring , u32 vlan_macip_lens , u32 fcoe_sof_eof ,
                       u32 type_tucmd , u32 mss_l4len_idx ) ;
#line 906
void ixgbe_do_reset(struct net_device *netdev ) ;
#line 908
void ixgbe_sysfs_exit(struct ixgbe_adapter *adapter ) ;
#line 909
int ixgbe_sysfs_init(struct ixgbe_adapter *adapter ) ;
#line 912
void ixgbe_configure_fcoe(struct ixgbe_adapter *adapter ) ;
#line 913
int ixgbe_fso(struct ixgbe_ring *tx_ring , struct ixgbe_tx_buffer *first , u8 *hdr_len ) ;
#line 915
int ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter , union ixgbe_adv_rx_desc *rx_desc ,
                   struct sk_buff *skb ) ;
#line 917
int ixgbe_fcoe_ddp_get(struct net_device *netdev , u16 xid , struct scatterlist *sgl ,
                       unsigned int sgc ) ;
#line 919
int ixgbe_fcoe_ddp_target(struct net_device *netdev , u16 xid , struct scatterlist *sgl ,
                          unsigned int sgc ) ;
#line 921
int ixgbe_fcoe_ddp_put(struct net_device *netdev , u16 xid ) ;
#line 922
int ixgbe_setup_fcoe_ddp_resources(struct ixgbe_adapter *adapter ) ;
#line 923
void ixgbe_free_fcoe_ddp_resources(struct ixgbe_adapter *adapter ) ;
#line 924
int ixgbe_fcoe_enable(struct net_device *netdev ) ;
#line 925
int ixgbe_fcoe_disable(struct net_device *netdev ) ;
#line 930
int ixgbe_fcoe_get_wwn(struct net_device *netdev , u64 *wwn , int type ) ;
#line 931
int ixgbe_fcoe_get_hbainfo(struct net_device *netdev , struct netdev_fcoe_hbainfo *info ) ;
#line 933
u8 ixgbe_fcoe_get_tc(struct ixgbe_adapter *adapter ) ;
#line 936
void ixgbe_dbg_adapter_init(struct ixgbe_adapter *adapter ) ;
#line 937
void ixgbe_dbg_adapter_exit(struct ixgbe_adapter *adapter ) ;
#line 938
void ixgbe_dbg_init(void) ;
#line 939
void ixgbe_dbg_exit(void) ;
#line 946 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static struct netdev_queue *txring_txq(struct ixgbe_ring  const  *ring ) 
{ 
  struct netdev_queue *tmp ;

  {
#line 948
  tmp = netdev_get_tx_queue((struct net_device  const  *)ring->netdev, (unsigned int )ring->queue_index);
#line 948
  return (tmp);
}
}
#line 951
void ixgbe_ptp_init(struct ixgbe_adapter *adapter ) ;
#line 952
void ixgbe_ptp_suspend(struct ixgbe_adapter *adapter ) ;
#line 953
void ixgbe_ptp_stop(struct ixgbe_adapter *adapter ) ;
#line 954
void ixgbe_ptp_overflow_check(struct ixgbe_adapter *adapter ) ;
#line 955
void ixgbe_ptp_rx_hang(struct ixgbe_adapter *adapter ) ;
#line 956
void ixgbe_ptp_rx_hwtstamp(struct ixgbe_adapter *adapter , struct sk_buff *skb ) ;
#line 957
int ixgbe_ptp_set_ts_config(struct ixgbe_adapter *adapter , struct ifreq *ifr ) ;
#line 958
int ixgbe_ptp_get_ts_config(struct ixgbe_adapter *adapter , struct ifreq *ifr ) ;
#line 959
void ixgbe_ptp_start_cyclecounter(struct ixgbe_adapter *adapter ) ;
#line 960
void ixgbe_ptp_reset(struct ixgbe_adapter *adapter ) ;
#line 961
void ixgbe_ptp_check_pps_event(struct ixgbe_adapter *adapter , u32 eicr ) ;
#line 963
void ixgbe_sriov_reinit(struct ixgbe_adapter *adapter ) ;
#line 969
u32 ixgbe_rss_indir_tbl_entries(struct ixgbe_adapter *adapter ) ;
#line 38 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h"
void ixgbe_restore_vf_multicasts(struct ixgbe_adapter *adapter ) ;
#line 40
void ixgbe_msg_task(struct ixgbe_adapter *adapter ) ;
#line 41
int ixgbe_vf_configuration(struct pci_dev *pdev , unsigned int event_mask ) ;
#line 42
void ixgbe_disable_tx_rx(struct ixgbe_adapter *adapter ) ;
#line 43
void ixgbe_ping_all_vfs(struct ixgbe_adapter *adapter ) ;
#line 44
int ixgbe_ndo_set_vf_mac(struct net_device *netdev , int vf , u8 *mac ) ;
#line 45
int ixgbe_ndo_set_vf_vlan(struct net_device *netdev , int vf , u16 vlan , u8 qos ) ;
#line 47
int ixgbe_ndo_set_vf_bw(struct net_device *netdev , int vf , int min_tx_rate , int max_tx_rate ) ;
#line 49
int ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev , int vf , bool setting ) ;
#line 50
int ixgbe_ndo_set_vf_rss_query_en(struct net_device *netdev , int vf , bool setting ) ;
#line 52
int ixgbe_ndo_get_vf_config(struct net_device *netdev , int vf , struct ifla_vf_info *ivi ) ;
#line 54
void ixgbe_check_vf_rate_limit(struct ixgbe_adapter *adapter ) ;
#line 55
int ixgbe_disable_sriov(struct ixgbe_adapter *adapter ) ;
#line 57
void ixgbe_enable_sriov(struct ixgbe_adapter *adapter ) ;
#line 59
int ixgbe_pci_sriov_configure(struct pci_dev *dev , int num_vfs ) ;
#line 69 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h"
char ixgbe_driver_name[6U]  = {      'i',      'x',      'g',      'b', 
        'e',      '\000'};
#line 70 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h"
static char const   ixgbe_driver_string[47U]  = 
#line 70
  {      'I',      'n',      't',      'e', 
        'l',      '(',      'R',      ')', 
        ' ',      '1',      '0',      ' ', 
        'G',      'i',      'g',      'a', 
        'b',      'i',      't',      ' ', 
        'P',      'C',      'I',      ' ', 
        'E',      'x',      'p',      'r', 
        'e',      's',      's',      ' ', 
        'N',      'e',      't',      'w', 
        'o',      'r',      'k',      ' ', 
        'D',      'r',      'i',      'v', 
        'e',      'r',      '\000'};
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
char ixgbe_default_device_descr[39U]  = 
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
  {      'I',      'n',      't',      'e', 
        'l',      '(',      'R',      ')', 
        ' ',      '1',      '0',      ' ', 
        'G',      'i',      'g',      'a', 
        'b',      'i',      't',      ' ', 
        'N',      'e',      't',      'w', 
        'o',      'r',      'k',      ' ', 
        'C',      'o',      'n',      'n', 
        'e',      'c',      't',      'i', 
        'o',      'n',      '\000'};
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
char const   ixgbe_driver_version[8U]  = 
#line 80
  {      '4',      '.',      '0',      '.', 
        '1',      '-',      'k',      '\000'};
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static char const   ixgbe_copyright[43U]  = 
#line 81
  {      'C',      'o',      'p',      'y', 
        'r',      'i',      'g',      'h', 
        't',      ' ',      '(',      'c', 
        ')',      ' ',      '1',      '9', 
        '9',      '9',      '-',      '2', 
        '0',      '1',      '4',      ' ', 
        'I',      'n',      't',      'e', 
        'l',      ' ',      'C',      'o', 
        'r',      'p',      'o',      'r', 
        'a',      't',      'i',      'o', 
        'n',      '.',      '\000'};
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static char const   ixgbe_overheat_msg[153U]  = 
#line 84
  {      'N',      'e',      't',      'w', 
        'o',      'r',      'k',      ' ', 
        'a',      'd',      'a',      'p', 
        't',      'e',      'r',      ' ', 
        'h',      'a',      's',      ' ', 
        'b',      'e',      'e',      'n', 
        ' ',      's',      't',      'o', 
        'p',      'p',      'e',      'd', 
        ' ',      'b',      'e',      'c', 
        'a',      'u',      's',      'e', 
        ' ',      'i',      't',      ' ', 
        'h',      'a',      's',      ' ', 
        'o',      'v',      'e',      'r', 
        ' ',      'h',      'e',      'a', 
        't',      'e',      'd',      '.', 
        ' ',      'R',      'e',      's', 
        't',      'a',      'r',      't', 
        ' ',      't',      'h',      'e', 
        ' ',      'c',      'o',      'm', 
        'p',      'u',      't',      'e', 
        'r',      '.',      ' ',      'I', 
        'f',      ' ',      't',      'h', 
        'e',      ' ',      'p',      'r', 
        'o',      'b',      'l',      'e', 
        'm',      ' ',      'p',      'e', 
        'r',      's',      'i',      's', 
        't',      's',      ',',      ' ', 
        'p',      'o',      'w',      'e', 
        'r',      ' ',      'o',      'f', 
        'f',      ' ',      't',      'h', 
        'e',      ' ',      's',      'y', 
        's',      't',      'e',      'm', 
        ' ',      'a',      'n',      'd', 
        ' ',      'r',      'e',      'p', 
        'l',      'a',      'c',      'e', 
        ' ',      't',      'h',      'e', 
        ' ',      'a',      'd',      'a', 
        'p',      't',      'e',      'r', 
        '\000'};
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct ixgbe_info  const  *ixgbe_info_tbl[5U]  = {      (struct ixgbe_info  const  *)(& ixgbe_82598_info),      (struct ixgbe_info  const  *)(& ixgbe_82599_info),      (struct ixgbe_info  const  *)(& ixgbe_X540_info),      (struct ixgbe_info  const  *)(& ixgbe_X550_info), 
        (struct ixgbe_info  const  *)(& ixgbe_X550EM_x_info)};
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct pci_device_id  const  ixgbe_pci_tbl[35U]  = 
#line 102
  {      {32902U, 4278U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4294U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4295U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4296U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 5387U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4317U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4332U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4337U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4321U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4340U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4315U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 5384U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4343U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 4348U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5399U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 4347U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5383U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5396U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 4345U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5418U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5417U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5404U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 4344U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5416U, 4294967295U, 4294967295U, 0U, 0U, 2UL}, 
        {32902U, 5453U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5455U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5464U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5463U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5450U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5472U, 4294967295U, 4294967295U, 0U, 0U, 2UL}, 
        {32902U, 5475U, 4294967295U, 4294967295U, 0U, 0U, 3UL}, 
        {32902U, 5546U, 4294967295U, 4294967295U, 0U, 0U, 4UL}, 
        {32902U, 5547U, 4294967295U, 4294967295U, 0U, 0U, 4UL}, 
        {32902U, 5549U, 4294967295U, 4294967295U, 0U, 0U, 4UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
struct pci_device_id  const  __mod_pci__ixgbe_pci_tbl_device_table[35U]  ;
#line 143
static int ixgbe_notify_dca(struct notifier_block *nb , unsigned long event , void *p ) ;
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct notifier_block dca_notifier  =    {& ixgbe_notify_dca, (struct notifier_block *)0, 0};
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static unsigned int max_vfs  ;
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static unsigned int allow_unsupported_sfp  ;
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int debug  =    -1;
#line 174
static bool ixgbe_check_cfg_remove(struct ixgbe_hw *hw , struct pci_dev *pdev ) ;
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_read_pci_cfg_word_parent(struct ixgbe_adapter *adapter , u32 reg ,
                                          u16 *value ) 
{ 
  struct pci_dev *parent_dev ;
  struct pci_bus *parent_bus ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 182
  parent_bus = ((adapter->pdev)->bus)->parent;
#line 183
  if ((unsigned long )parent_bus == (unsigned long )((struct pci_bus *)0)) {
#line 184
    return (-1);
  } else {

  }
#line 186
  parent_dev = parent_bus->self;
#line 187
  if ((unsigned long )parent_dev == (unsigned long )((struct pci_dev *)0)) {
#line 188
    return (-1);
  } else {

  }
#line 190
  tmp = pci_is_pcie(parent_dev);
#line 190
  if (tmp) {
#line 190
    tmp___0 = 0;
  } else {
#line 190
    tmp___0 = 1;
  }
#line 190
  if (tmp___0) {
#line 191
    return (-1);
  } else {

  }
#line 193
  pcie_capability_read_word(parent_dev, (int )reg, value);
#line 194
  if ((unsigned int )*value == 65535U) {
#line 194
    tmp___1 = ixgbe_check_cfg_remove(& adapter->hw, parent_dev);
#line 194
    if ((int )tmp___1) {
#line 196
      return (-1);
    } else {

    }
  } else {

  }
#line 197
  return (0);
}
}
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static s32 ixgbe_get_parent_bus_info(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u16 link_status ;
  int err ;

  {
#line 202
  hw = & adapter->hw;
#line 203
  link_status = 0U;
#line 206
  hw->bus.type = 3;
#line 211
  err = ixgbe_read_pci_cfg_word_parent(adapter, 18U, & link_status);
#line 214
  if (err != 0) {
#line 215
    return (err);
  } else {

  }
#line 217
  hw->bus.width = ixgbe_convert_bus_width((int )link_status);
#line 218
  hw->bus.speed = ixgbe_convert_bus_speed((int )link_status);
#line 220
  return (0);
}
}
#line 232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_pcie_from_parent(struct ixgbe_hw *hw ) 
{ 


  {
#line 234
  switch ((int )hw->device_id) {
  case 5450: ;
  case 5464: ;
#line 237
  return (1);
  default: ;
#line 239
  return (0);
  }
}
}
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_minimum_link(struct ixgbe_adapter *adapter , int expected_gts ) 
{ 
  int max_gts ;
  enum pci_bus_speed speed ;
  enum pcie_link_width width ;
  struct pci_dev *pdev ;
  bool tmp ;
  int tmp___0 ;

  {
#line 246
  max_gts = 0;
#line 247
  speed = 255;
#line 248
  width = 255;
#line 253
  tmp = ixgbe_pcie_from_parent(& adapter->hw);
#line 253
  if ((int )tmp) {
#line 254
    pdev = (((adapter->pdev)->bus)->parent)->self;
  } else {
#line 256
    pdev = adapter->pdev;
  }
#line 258
  tmp___0 = pcie_get_minimum_link(pdev, & speed, & width);
#line 258
  if ((tmp___0 != 0 || (unsigned int )speed == 255U) || (unsigned int )width == 255U) {
#line 260
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Unable to determine PCI Express bandwidth.\n");
#line 261
    return;
  } else {

  }
#line 264
  switch ((unsigned int )speed) {
  case 20U: 
#line 267
  max_gts = (int )((unsigned int )width * 2U);
#line 268
  goto ldv_57104;
  case 21U: 
#line 271
  max_gts = (int )((unsigned int )width * 4U);
#line 272
  goto ldv_57104;
  case 22U: 
#line 275
  max_gts = (int )((unsigned int )width * 8U);
#line 276
  goto ldv_57104;
  default: 
#line 278
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Unable to determine PCI Express bandwidth.\n");
#line 279
  return;
  }
  ldv_57104: 
#line 282
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "PCI Express bandwidth of %dGT/s available\n",
            max_gts);
#line 284
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "(Speed:%s, Width: x%d, Encoding Loss:%s)\n",
            (unsigned int )speed != 22U ? ((unsigned int )speed != 21U ? ((unsigned int )speed == 20U ? (char *)"2.5GT/s" : (char *)"Unknown") : (char *)"5.0GT/s") : (char *)"8.0GT/s",
            (unsigned int )width, (unsigned int )speed != 20U ? ((unsigned int )speed != 21U ? ((unsigned int )speed == 22U ? (char *)"<2%" : (char *)"Unknown") : (char *)"20%") : (char *)"20%");
#line 295
  if (max_gts < expected_gts) {
#line 296
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "This is not sufficient for optimal performance of this card.\n");
#line 297
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "For optimal performance, at least %dGT/s of bandwidth is required.\n",
             expected_gts);
#line 299
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "A slot with more lanes and/or higher speed is suggested.\n");
  } else {

  }
#line 301
  return;
}
}
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_service_event_schedule(struct ixgbe_adapter *adapter ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 305
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 305
  if (tmp == 0) {
#line 305
    tmp___0 = constant_test_bit(4L, (unsigned long const volatile   *)(& adapter->state));
#line 305
    if (tmp___0 == 0) {
#line 305
      tmp___1 = test_and_set_bit(5L, (unsigned long volatile   *)(& adapter->state));
#line 305
      if (tmp___1 == 0) {
#line 308
        schedule_work(& adapter->service_task);
      } else {

      }
    } else {

    }
  } else {

  }
#line 309
  return;
}
}
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_remove_adapter(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_adapter *adapter ;
  int tmp ;

  {
#line 313
  adapter = (struct ixgbe_adapter *)hw->back;
#line 315
  if ((unsigned long )hw->hw_addr == (unsigned long )((u8 *)0U)) {
#line 316
    return;
  } else {

  }
#line 317
  hw->hw_addr = (u8 *)0U;
#line 318
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Adapter removed\n");
#line 319
  tmp = constant_test_bit(6L, (unsigned long const volatile   *)(& adapter->state));
#line 319
  if (tmp != 0) {
#line 320
    ixgbe_service_event_schedule(adapter);
  } else {

  }
#line 321
  return;
}
}
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_remove(struct ixgbe_hw *hw , u32 reg ) 
{ 
  u32 value ;

  {
#line 333
  if (reg == 8U) {
#line 334
    ixgbe_remove_adapter(hw);
#line 335
    return;
  } else {

  }
#line 337
  value = ixgbe_read_reg(hw, 8U);
#line 338
  if (value == 4294967295U) {
#line 339
    ixgbe_remove_adapter(hw);
  } else {

  }
#line 340
  return;
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
u32 ixgbe_read_reg(struct ixgbe_hw *hw , u32 reg ) 
{ 
  u8 *reg_addr ;
  u8 *__var ;
  u32 value ;
  bool tmp ;
  long tmp___0 ;

  {
#line 357
  __var = (u8 *)0U;
#line 357
  reg_addr = *((u8 * volatile  *)(& hw->hw_addr));
#line 360
  tmp = ixgbe_removed((void *)reg_addr);
#line 360
  if ((int )tmp) {
#line 361
    return (4294967295U);
  } else {

  }
#line 362
  value = readl((void const volatile   *)reg_addr + (unsigned long )reg);
#line 363
  tmp___0 = ldv__builtin_expect(value == 4294967295U, 0L);
#line 363
  if (tmp___0 != 0L) {
#line 364
    ixgbe_check_remove(hw, reg);
  } else {

  }
#line 365
  return (value);
}
}
#line 368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_check_cfg_remove(struct ixgbe_hw *hw , struct pci_dev *pdev ) 
{ 
  u16 value ;

  {
#line 372
  pci_read_config_word((struct pci_dev  const  *)pdev, 0, & value);
#line 373
  if ((unsigned int )value == 65535U) {
#line 374
    ixgbe_remove_adapter(hw);
#line 375
    return (1);
  } else {

  }
#line 377
  return (0);
}
}
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
u16 ixgbe_read_pci_cfg_word(struct ixgbe_hw *hw , u32 reg ) 
{ 
  struct ixgbe_adapter *adapter ;
  u16 value ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 382
  adapter = (struct ixgbe_adapter *)hw->back;
#line 385
  tmp = ixgbe_removed((void *)hw->hw_addr);
#line 385
  if ((int )tmp) {
#line 386
    return (65535U);
  } else {

  }
#line 387
  pci_read_config_word((struct pci_dev  const  *)adapter->pdev, (int )reg, & value);
#line 388
  if ((unsigned int )value == 65535U) {
#line 388
    tmp___0 = ixgbe_check_cfg_remove(hw, adapter->pdev);
#line 388
    if ((int )tmp___0) {
#line 390
      return (65535U);
    } else {

    }
  } else {

  }
#line 391
  return (value);
}
}
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u32 ixgbe_read_pci_cfg_dword(struct ixgbe_hw *hw , u32 reg ) 
{ 
  struct ixgbe_adapter *adapter ;
  u32 value ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 397
  adapter = (struct ixgbe_adapter *)hw->back;
#line 400
  tmp = ixgbe_removed((void *)hw->hw_addr);
#line 400
  if ((int )tmp) {
#line 401
    return (4294967295U);
  } else {

  }
#line 402
  pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, (int )reg, & value);
#line 403
  if (value == 4294967295U) {
#line 403
    tmp___0 = ixgbe_check_cfg_remove(hw, adapter->pdev);
#line 403
    if ((int )tmp___0) {
#line 405
      return (4294967295U);
    } else {

    }
  } else {

  }
#line 406
  return (value);
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_write_pci_cfg_word(struct ixgbe_hw *hw , u32 reg , u16 value ) 
{ 
  struct ixgbe_adapter *adapter ;
  bool tmp ;

  {
#line 412
  adapter = (struct ixgbe_adapter *)hw->back;
#line 414
  tmp = ixgbe_removed((void *)hw->hw_addr);
#line 414
  if ((int )tmp) {
#line 415
    return;
  } else {

  }
#line 416
  pci_write_config_word((struct pci_dev  const  *)adapter->pdev, (int )reg, (int )value);
#line 417
  return;
}
}
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_service_event_complete(struct ixgbe_adapter *adapter ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 421
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& adapter->state));
#line 421
  tmp___0 = ldv__builtin_expect(tmp == 0, 0L);
#line 421
  if (tmp___0 != 0L) {
#line 421
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"),
                         "i" (421), "i" (12UL));
    ldv_57154: ;
#line 421
    goto ldv_57154;
  } else {

  }
#line 424
  __asm__  volatile   ("": : : "memory");
#line 425
  clear_bit(5L, (unsigned long volatile   *)(& adapter->state));
#line 426
  return;
}
}
#line 433 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct ixgbe_reg_info  const  ixgbe_reg_info_tbl[19U]  = 
#line 433
  {      {0U, (char *)"CTRL"}, 
        {8U, (char *)"STATUS"}, 
        {24U, (char *)"CTRL_EXT"}, 
        {2048U, (char *)"EICR"}, 
        {8448U, (char *)"SRRCTL"}, 
        {8704U, (char *)"DRXCTL"}, 
        {4104U, (char *)"RDLEN"}, 
        {4112U, (char *)"RDH"}, 
        {4120U, (char *)"RDT"}, 
        {4136U, (char *)"RXDCTL"}, 
        {4096U, (char *)"RDBAL"}, 
        {4100U, (char *)"RDBAH"}, 
        {24576U, (char *)"TDBAL"}, 
        {24580U, (char *)"TDBAH"}, 
        {24584U, (char *)"TDLEN"}, 
        {24592U, (char *)"TDH"}, 
        {24600U, (char *)"TDT"}, 
        {24616U, (char *)"TXDCTL"}, 
        {0U, (char *)0}};
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_regdump(struct ixgbe_hw *hw , struct ixgbe_reg_info *reginfo ) 
{ 
  int i ;
  int j ;
  char rname[16U] ;
  u32 regs[64U] ;
  u32 tmp ;

  {
#line 471
  i = 0;
#line 471
  j = 0;
#line 475
  switch (reginfo->ofs) {
  case 8448U: 
#line 477
  i = 0;
#line 477
  goto ldv_57169;
  ldv_57168: 
#line 478
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 15 ? (i + 2112) * 4 : (i <= 63 ? i * 64 + 4116 : (i + -64) * 64 + 53268)));
#line 477
  i = i + 1;
  ldv_57169: ;
#line 477
  if (i <= 63) {
#line 479
    goto ldv_57168;
  } else {

  }

#line 479
  goto ldv_57171;
  case 8704U: 
#line 481
  i = 0;
#line 481
  goto ldv_57174;
  ldv_57173: 
#line 482
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 15 ? (i + 2176) * 4 : (i <= 63 ? i * 64 + 4108 : (i + -64) * 64 + 53260)));
#line 481
  i = i + 1;
  ldv_57174: ;
#line 481
  if (i <= 63) {
#line 483
    goto ldv_57173;
  } else {

  }

#line 483
  goto ldv_57171;
  case 4104U: 
#line 485
  i = 0;
#line 485
  goto ldv_57178;
  ldv_57177: 
#line 486
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 63 ? i * 64 + 4104 : (i + -64) * 64 + 53256));
#line 485
  i = i + 1;
  ldv_57178: ;
#line 485
  if (i <= 63) {
#line 487
    goto ldv_57177;
  } else {

  }

#line 487
  goto ldv_57171;
  case 4112U: 
#line 489
  i = 0;
#line 489
  goto ldv_57182;
  ldv_57181: 
#line 490
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 63 ? i * 64 + 4112 : (i + -64) * 64 + 53264));
#line 489
  i = i + 1;
  ldv_57182: ;
#line 489
  if (i <= 63) {
#line 491
    goto ldv_57181;
  } else {

  }

#line 491
  goto ldv_57171;
  case 4120U: 
#line 493
  i = 0;
#line 493
  goto ldv_57186;
  ldv_57185: 
#line 494
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 63 ? i * 64 + 4120 : (i + -64) * 64 + 53272));
#line 493
  i = i + 1;
  ldv_57186: ;
#line 493
  if (i <= 63) {
#line 495
    goto ldv_57185;
  } else {

  }

#line 495
  goto ldv_57171;
  case 4136U: 
#line 497
  i = 0;
#line 497
  goto ldv_57190;
  ldv_57189: 
#line 498
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 63 ? i * 64 + 4136 : (i + -64) * 64 + 53288));
#line 497
  i = i + 1;
  ldv_57190: ;
#line 497
  if (i <= 63) {
#line 499
    goto ldv_57189;
  } else {

  }

#line 499
  goto ldv_57171;
  case 4096U: 
#line 501
  i = 0;
#line 501
  goto ldv_57194;
  ldv_57193: 
#line 502
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 63 ? (i + 64) * 64 : (i + 768) * 64));
#line 501
  i = i + 1;
  ldv_57194: ;
#line 501
  if (i <= 63) {
#line 503
    goto ldv_57193;
  } else {

  }

#line 503
  goto ldv_57171;
  case 4100U: 
#line 505
  i = 0;
#line 505
  goto ldv_57198;
  ldv_57197: 
#line 506
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 63 ? i * 64 + 4100 : (i + -64) * 64 + 53252));
#line 505
  i = i + 1;
  ldv_57198: ;
#line 505
  if (i <= 63) {
#line 507
    goto ldv_57197;
  } else {

  }

#line 507
  goto ldv_57171;
  case 24576U: 
#line 509
  i = 0;
#line 509
  goto ldv_57202;
  ldv_57201: 
#line 510
  regs[i] = ixgbe_read_reg(hw, (u32 )((i + 384) * 64));
#line 509
  i = i + 1;
  ldv_57202: ;
#line 509
  if (i <= 63) {
#line 511
    goto ldv_57201;
  } else {

  }

#line 511
  goto ldv_57171;
  case 24580U: 
#line 513
  i = 0;
#line 513
  goto ldv_57206;
  ldv_57205: 
#line 514
  regs[i] = ixgbe_read_reg(hw, (u32 )(i * 64 + 24580));
#line 513
  i = i + 1;
  ldv_57206: ;
#line 513
  if (i <= 63) {
#line 515
    goto ldv_57205;
  } else {

  }

#line 515
  goto ldv_57171;
  case 24584U: 
#line 517
  i = 0;
#line 517
  goto ldv_57210;
  ldv_57209: 
#line 518
  regs[i] = ixgbe_read_reg(hw, (u32 )(i * 64 + 24584));
#line 517
  i = i + 1;
  ldv_57210: ;
#line 517
  if (i <= 63) {
#line 519
    goto ldv_57209;
  } else {

  }

#line 519
  goto ldv_57171;
  case 24592U: 
#line 521
  i = 0;
#line 521
  goto ldv_57214;
  ldv_57213: 
#line 522
  regs[i] = ixgbe_read_reg(hw, (u32 )(i * 64 + 24592));
#line 521
  i = i + 1;
  ldv_57214: ;
#line 521
  if (i <= 63) {
#line 523
    goto ldv_57213;
  } else {

  }

#line 523
  goto ldv_57171;
  case 24600U: 
#line 525
  i = 0;
#line 525
  goto ldv_57218;
  ldv_57217: 
#line 526
  regs[i] = ixgbe_read_reg(hw, (u32 )(i * 64 + 24600));
#line 525
  i = i + 1;
  ldv_57218: ;
#line 525
  if (i <= 63) {
#line 527
    goto ldv_57217;
  } else {

  }

#line 527
  goto ldv_57171;
  case 24616U: 
#line 529
  i = 0;
#line 529
  goto ldv_57222;
  ldv_57221: 
#line 530
  regs[i] = ixgbe_read_reg(hw, (u32 )(i * 64 + 24616));
#line 529
  i = i + 1;
  ldv_57222: ;
#line 529
  if (i <= 63) {
#line 531
    goto ldv_57221;
  } else {

  }

#line 531
  goto ldv_57171;
  default: 
#line 533
  tmp = ixgbe_read_reg(hw, reginfo->ofs);
#line 533
  printk("\016ixgbe: %-15s %08x\n", reginfo->name, tmp);
#line 535
  return;
  }
  ldv_57171: 
#line 538
  i = 0;
#line 538
  goto ldv_57229;
  ldv_57228: 
#line 539
  snprintf((char *)(& rname), 16UL, "%s[%d-%d]", reginfo->name, i * 8, i * 8 + 7);
#line 540
  printk("\vixgbe: %-15s", (char *)(& rname));
#line 541
  j = 0;
#line 541
  goto ldv_57226;
  ldv_57225: 
#line 542
  printk(" %08x", regs[i * 8 + j]);
#line 541
  j = j + 1;
  ldv_57226: ;
#line 541
  if (j <= 7) {
#line 543
    goto ldv_57225;
  } else {

  }
#line 543
  printk("\n");
#line 538
  i = i + 1;
  ldv_57229: ;
#line 538
  if (i <= 7) {
#line 540
    goto ldv_57228;
  } else {

  }

#line 545
  return;
}
}
#line 551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_dump(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct ixgbe_hw *hw ;
  struct ixgbe_reg_info *reginfo ;
  int n ;
  struct ixgbe_ring *tx_ring ;
  struct ixgbe_tx_buffer *tx_buffer ;
  union ixgbe_adv_tx_desc *tx_desc ;
  struct my_u0 *u0 ;
  struct ixgbe_ring *rx_ring ;
  union ixgbe_adv_rx_desc *rx_desc ;
  struct ixgbe_rx_buffer *rx_buffer_info ;
  u32 staterr ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;

  {
#line 553
  netdev = adapter->netdev;
#line 554
  hw = & adapter->hw;
#line 556
  n = 0;
#line 565
  i = 0;
#line 567
  if (((int )adapter->msg_enable & 8192) == 0) {
#line 568
    return;
  } else {

  }
#line 571
  if ((unsigned long )netdev != (unsigned long )((struct net_device *)0)) {
#line 572
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Net device Info\n");
#line 573
    printk("\016ixgbe: Device Name     state            trans_start      last_rx\n");
#line 575
    printk("\016ixgbe: %-15s %016lX %016lX %016lX\n", (char *)(& netdev->name), netdev->state,
           netdev->trans_start, netdev->last_rx);
  } else {

  }
#line 583
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Register Dump\n");
#line 584
  printk("\016ixgbe:  Register Name   Value\n");
#line 585
  reginfo = (struct ixgbe_reg_info *)(& ixgbe_reg_info_tbl);
#line 585
  goto ldv_57251;
  ldv_57250: 
#line 587
  ixgbe_regdump(hw, reginfo);
#line 586
  reginfo = reginfo + 1;
  ldv_57251: ;
#line 585
  if ((unsigned long )reginfo->name != (unsigned long )((char *)0)) {
#line 588
    goto ldv_57250;
  } else {

  }

#line 591
  if ((unsigned long )netdev == (unsigned long )((struct net_device *)0)) {
#line 592
    return;
  } else {
#line 591
    tmp = netif_running((struct net_device  const  *)netdev);
#line 591
    if (tmp) {
#line 591
      tmp___0 = 0;
    } else {
#line 591
      tmp___0 = 1;
    }
#line 591
    if (tmp___0) {
#line 592
      return;
    } else {

    }
  }
#line 594
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "TX Rings Summary\n");
#line 595
  printk("\016ixgbe:  %s     %s              %s        %s\n", (char *)"Queue [NTU] [NTC] [bi(ntc)->dma  ]",
         (char *)"leng", (char *)"ntw", (char *)"timestamp");
#line 598
  n = 0;
#line 598
  goto ldv_57254;
  ldv_57253: 
#line 599
  tx_ring = adapter->tx_ring[n];
#line 600
  tx_buffer = tx_ring->__annonCompField118.tx_buffer_info + (unsigned long )tx_ring->next_to_clean;
#line 601
  printk("\016ixgbe:  %5d %5X %5X %016llX %08X %p %016llX\n", n, (int )tx_ring->next_to_use,
         (int )tx_ring->next_to_clean, tx_buffer->dma, tx_buffer->len, tx_buffer->next_to_watch,
         (unsigned long long )tx_buffer->time_stamp);
#line 598
  n = n + 1;
  ldv_57254: ;
#line 598
  if (adapter->num_tx_queues > n) {
#line 600
    goto ldv_57253;
  } else {

  }

#line 610
  if (((int )adapter->msg_enable & 1024) == 0) {
#line 611
    goto rx_ring_summary;
  } else {

  }
#line 613
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "TX Rings Dump\n");
#line 650
  n = 0;
#line 650
  goto ldv_57261;
  ldv_57260: 
#line 651
  tx_ring = adapter->tx_ring[n];
#line 652
  printk("\016ixgbe: ------------------------------------\n");
#line 653
  printk("\016ixgbe: TX QUEUE INDEX = %d\n", (int )tx_ring->queue_index);
#line 654
  printk("\016ixgbe: ------------------------------------\n");
#line 655
  printk("\016ixgbe: %s%s    %s              %s        %s          %s\n", (char *)"T [desc]     [address 63:0  ] ",
         (char *)"[PlPOIdStDDt Ln] [bi->dma       ] ", (char *)"leng", (char *)"ntw",
         (char *)"timestamp", (char *)"bi->skb");
#line 660
  i = 0;
#line 660
  goto ldv_57258;
  ldv_57257: 
#line 661
  tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc + (unsigned long )i;
#line 662
  tx_buffer = tx_ring->__annonCompField118.tx_buffer_info + (unsigned long )i;
#line 663
  u0 = (struct my_u0 *)tx_desc;
#line 664
  if (tx_buffer->len != 0U) {
#line 665
    printk("\016ixgbe: T [0x%03X]    %016llX %016llX %016llX %08X %p %016llX %p",
           i, u0->a, u0->b, tx_buffer->dma, tx_buffer->len, tx_buffer->next_to_watch,
           (unsigned long long )tx_buffer->time_stamp, tx_buffer->skb);
#line 674
    if ((int )tx_ring->next_to_use == i && (int )tx_ring->next_to_clean == i) {
#line 676
      printk(" NTC/U\n");
    } else
#line 677
    if ((int )tx_ring->next_to_use == i) {
#line 678
      printk(" NTU\n");
    } else
#line 679
    if ((int )tx_ring->next_to_clean == i) {
#line 680
      printk(" NTC\n");
    } else {
#line 682
      printk("\n");
    }
#line 684
    if (((int )adapter->msg_enable & 4096) != 0 && (unsigned long )tx_buffer->skb != (unsigned long )((struct sk_buff *)0)) {
#line 686
      print_hex_dump("\016", "", 1, 16, 1, (void const   *)(tx_buffer->skb)->data,
                     (size_t )tx_buffer->len, 1);
    } else {

    }
  } else {

  }
#line 660
  i = i + 1;
  ldv_57258: ;
#line 660
  if ((unsigned long )tx_ring->desc != (unsigned long )((void *)0) && (int )tx_ring->count > i) {
#line 662
    goto ldv_57257;
  } else {

  }
#line 650
  n = n + 1;
  ldv_57261: ;
#line 650
  if (adapter->num_tx_queues > n) {
#line 652
    goto ldv_57260;
  } else {

  }

  rx_ring_summary: 
#line 697
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "RX Rings Summary\n");
#line 698
  printk("\016ixgbe: Queue [NTU] [NTC]\n");
#line 699
  n = 0;
#line 699
  goto ldv_57264;
  ldv_57263: 
#line 700
  rx_ring = adapter->rx_ring[n];
#line 701
  printk("\016ixgbe: %5d %5X %5X\n", n, (int )rx_ring->next_to_use, (int )rx_ring->next_to_clean);
#line 699
  n = n + 1;
  ldv_57264: ;
#line 699
  if (adapter->num_rx_queues > n) {
#line 701
    goto ldv_57263;
  } else {

  }

#line 706
  if (((int )adapter->msg_enable & 2048) == 0) {
#line 707
    return;
  } else {

  }
#line 709
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "RX Rings Dump\n");
#line 756
  n = 0;
#line 756
  goto ldv_57270;
  ldv_57269: 
#line 757
  rx_ring = adapter->rx_ring[n];
#line 758
  printk("\016ixgbe: ------------------------------------\n");
#line 759
  printk("\016ixgbe: RX QUEUE INDEX = %d\n", (int )rx_ring->queue_index);
#line 760
  printk("\016ixgbe: ------------------------------------\n");
#line 761
  printk("\016ixgbe: %s%s%s", (char *)"R  [desc]      [ PktBuf     A0] ", (char *)"[  HeadBuf   DD] [bi->dma       ] [bi->skb       ] ",
         (char *)"<-- Adv Rx Read format\n");
#line 765
  printk("\016ixgbe: %s%s%s", (char *)"RWB[desc]      [PcsmIpSHl PtRs] ", (char *)"[vl er S cks ln] ---------------- [bi->skb       ] ",
         (char *)"<-- Adv Rx Write-Back format\n");
#line 770
  i = 0;
#line 770
  goto ldv_57267;
  ldv_57266: 
#line 771
  rx_buffer_info = rx_ring->__annonCompField118.rx_buffer_info + (unsigned long )i;
#line 772
  rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long )i;
#line 773
  u0 = (struct my_u0 *)rx_desc;
#line 774
  staterr = rx_desc->wb.upper.status_error;
#line 775
  if ((int )staterr & 1) {
#line 777
    printk("\016ixgbe: RWB[0x%03X]     %016llX %016llX ---------------- %p", i, u0->a,
           u0->b, rx_buffer_info->skb);
  } else {
#line 783
    printk("\016ixgbe: R  [0x%03X]     %016llX %016llX %016llX %p", i, u0->a, u0->b,
           rx_buffer_info->dma, rx_buffer_info->skb);
#line 790
    if (((int )adapter->msg_enable & 4096) != 0 && rx_buffer_info->dma != 0ULL) {
#line 792
      tmp___1 = ixgbe_rx_bufsz(rx_ring);
#line 792
      tmp___2 = lowmem_page_address((struct page  const  *)rx_buffer_info->page);
#line 792
      print_hex_dump("\016", "", 1, 16, 1, (void const   *)tmp___2 + (unsigned long )rx_buffer_info->page_offset,
                     (size_t )tmp___1, 1);
    } else {

    }
  }
#line 800
  if ((int )rx_ring->next_to_use == i) {
#line 801
    printk(" NTU\n");
  } else
#line 802
  if ((int )rx_ring->next_to_clean == i) {
#line 803
    printk(" NTC\n");
  } else {
#line 805
    printk("\n");
  }
#line 770
  i = i + 1;
  ldv_57267: ;
#line 770
  if ((int )rx_ring->count > i) {
#line 772
    goto ldv_57266;
  } else {

  }
#line 756
  n = n + 1;
  ldv_57270: ;
#line 756
  if (adapter->num_rx_queues > n) {
#line 758
    goto ldv_57269;
  } else {

  }

#line 763
  return;
}
}
#line 811 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_release_hw_control(struct ixgbe_adapter *adapter ) 
{ 
  u32 ctrl_ext ;

  {
#line 816
  ctrl_ext = ixgbe_read_reg(& adapter->hw, 24U);
#line 817
  ixgbe_write_reg(& adapter->hw, 24U, ctrl_ext & 4026531839U);
#line 818
  return;
}
}
#line 821 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_get_hw_control(struct ixgbe_adapter *adapter ) 
{ 
  u32 ctrl_ext ;

  {
#line 826
  ctrl_ext = ixgbe_read_reg(& adapter->hw, 24U);
#line 827
  ixgbe_write_reg(& adapter->hw, 24U, ctrl_ext | 268435456U);
#line 828
  return;
}
}
#line 839 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_ivar(struct ixgbe_adapter *adapter , s8 direction , u8 queue ,
                           u8 msix_vector ) 
{ 
  u32 ivar ;
  u32 index ;
  struct ixgbe_hw *hw ;

  {
#line 843
  hw = & adapter->hw;
#line 844
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 846
  msix_vector = (u8 )((unsigned int )msix_vector | 128U);
#line 847
  if ((int )direction == -1) {
#line 848
    direction = 0;
  } else {

  }
#line 849
  index = (u32 )(((int )direction * 64 + (int )queue) >> 2) & 31U;
#line 850
  ivar = ixgbe_read_reg(hw, (index + 576U) * 4U);
#line 851
  ivar = (u32 )(~ (255 << ((int )queue & 3) * 8)) & ivar;
#line 852
  ivar = (u32 )((int )msix_vector << ((int )queue & 3) * 8) | ivar;
#line 853
  ixgbe_write_reg(hw, (index + 576U) * 4U, ivar);
#line 854
  goto ldv_57290;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: ;
#line 859
  if ((int )direction == -1) {
#line 861
    msix_vector = (u8 )((unsigned int )msix_vector | 128U);
#line 862
    index = (u32 )(((int )queue & 1) * 8);
#line 863
    ivar = ixgbe_read_reg(& adapter->hw, 2560U);
#line 864
    ivar = (u32 )(~ (255 << (int )index)) & ivar;
#line 865
    ivar = (u32 )((int )msix_vector << (int )index) | ivar;
#line 866
    ixgbe_write_reg(& adapter->hw, 2560U, ivar);
#line 867
    goto ldv_57290;
  } else {
#line 870
    msix_vector = (u8 )((unsigned int )msix_vector | 128U);
#line 871
    index = (u32 )((((int )queue & 1) * 2 + (int )direction) * 8);
#line 872
    ivar = ixgbe_read_reg(hw, (u32 )((((int )queue >> 1) + 576) * 4));
#line 873
    ivar = (u32 )(~ (255 << (int )index)) & ivar;
#line 874
    ivar = (u32 )((int )msix_vector << (int )index) | ivar;
#line 875
    ixgbe_write_reg(hw, (u32 )((((int )queue >> 1) + 576) * 4), ivar);
#line 876
    goto ldv_57290;
  }
  default: ;
#line 879
  goto ldv_57290;
  }
  ldv_57290: ;
#line 882
  return;
}
}
#line 883 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_irq_rearm_queues(struct ixgbe_adapter *adapter , u64 qmask ) 
{ 
  u32 mask ;

  {
#line 888
  switch ((unsigned int )adapter->hw.mac.type) {
  case 1U: 
#line 890
  mask = (u32 )qmask & 65535U;
#line 891
  ixgbe_write_reg(& adapter->hw, 2056U, mask);
#line 892
  goto ldv_57302;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 897
  mask = (u32 )qmask;
#line 898
  ixgbe_write_reg(& adapter->hw, 2704U, mask);
#line 899
  mask = (u32 )(qmask >> 32);
#line 900
  ixgbe_write_reg(& adapter->hw, 2708U, mask);
#line 901
  goto ldv_57302;
  default: ;
#line 903
  goto ldv_57302;
  }
  ldv_57302: ;
#line 906
  return;
}
}
#line 907 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_unmap_and_free_tx_resource(struct ixgbe_ring *ring , struct ixgbe_tx_buffer *tx_buffer ) 
{ 


  {
#line 910
  if ((unsigned long )tx_buffer->skb != (unsigned long )((struct sk_buff *)0)) {
#line 911
    dev_kfree_skb_any(tx_buffer->skb);
#line 912
    if (tx_buffer->len != 0U) {
#line 913
      dma_unmap_single_attrs(ring->dev, tx_buffer->dma, (size_t )tx_buffer->len, 1,
                             (struct dma_attrs *)0);
    } else {

    }
  } else
#line 917
  if (tx_buffer->len != 0U) {
#line 918
    dma_unmap_page(ring->dev, tx_buffer->dma, (size_t )tx_buffer->len, 1);
  } else {

  }
#line 923
  tx_buffer->next_to_watch = (union ixgbe_adv_tx_desc *)0;
#line 924
  tx_buffer->skb = (struct sk_buff *)0;
#line 925
  tx_buffer->len = 0U;
#line 926
  return;
}
}
#line 929 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_xoff_rx_lfc(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct ixgbe_hw_stats *hwstats ;
  int i ;
  u32 data ;

  {
#line 931
  hw = & adapter->hw;
#line 932
  hwstats = & adapter->stats;
#line 936
  if ((unsigned int )hw->fc.current_mode != 3U && (unsigned int )hw->fc.current_mode != 1U) {
#line 938
    return;
  } else {

  }
#line 940
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 942
  data = ixgbe_read_reg(hw, 53096U);
#line 943
  goto ldv_57320;
  default: 
#line 945
  data = ixgbe_read_reg(hw, 16808U);
  }
  ldv_57320: 
#line 947
  hwstats->lxoffrxc = hwstats->lxoffrxc + (u64 )data;
#line 950
  if (data == 0U) {
#line 951
    return;
  } else {

  }
#line 953
  i = 0;
#line 953
  goto ldv_57323;
  ldv_57322: 
#line 954
  clear_bit(3L, (unsigned long volatile   *)(& (adapter->tx_ring[i])->state));
#line 953
  i = i + 1;
  ldv_57323: ;
#line 953
  if (adapter->num_tx_queues > i) {
#line 955
    goto ldv_57322;
  } else {

  }

#line 960
  return;
}
}
#line 958 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_xoff_received(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct ixgbe_hw_stats *hwstats ;
  u32 xoff[8U] ;
  unsigned int tmp ;
  u8 tc ;
  int i ;
  bool pfc_en ;
  u32 pxoffrxc ;
  int tmp___0 ;
  struct ixgbe_ring *tx_ring ;

  {
#line 960
  hw = & adapter->hw;
#line 961
  hwstats = & adapter->stats;
#line 962
  xoff[0] = 0U;
#line 962
  tmp = 1U;
#line 962
  while (1) {
#line 962
    if (tmp >= 8U) {
#line 962
      break;
    } else {

    }
#line 962
    xoff[tmp] = 0U;
#line 962
    tmp = tmp + 1U;
  }
#line 965
  pfc_en = adapter->dcb_cfg.pfc_mode_enable;
#line 967
  if ((unsigned long )adapter->ixgbe_ieee_pfc != (unsigned long )((struct ieee_pfc *)0)) {
#line 968
    pfc_en = ((int )pfc_en | ((unsigned int )(adapter->ixgbe_ieee_pfc)->pfc_en != 0U)) != 0;
  } else {

  }
#line 970
  if ((adapter->flags & 4096U) == 0U || ! pfc_en) {
#line 971
    ixgbe_update_xoff_rx_lfc(adapter);
#line 972
    return;
  } else {

  }
#line 976
  i = 0;
#line 976
  goto ldv_57339;
  ldv_57338: ;
#line 979
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 981
  pxoffrxc = ixgbe_read_reg(hw, (u32 )((i + 13256) * 4));
#line 982
  goto ldv_57336;
  default: 
#line 984
  pxoffrxc = ixgbe_read_reg(hw, (u32 )((i + 4184) * 4));
  }
  ldv_57336: 
#line 986
  hwstats->pxoffrxc[i] = hwstats->pxoffrxc[i] + (u64 )pxoffrxc;
#line 988
  tmp___0 = netdev_get_prio_tc_map((struct net_device  const  *)adapter->netdev, (u32 )i);
#line 988
  tc = (u8 )tmp___0;
#line 989
  xoff[(int )tc] = xoff[(int )tc] + pxoffrxc;
#line 976
  i = i + 1;
  ldv_57339: ;
#line 976
  if (((adapter->flags & 4096U) != 0U ? 8 : 1) > i) {
#line 978
    goto ldv_57338;
  } else {

  }
#line 993
  i = 0;
#line 993
  goto ldv_57343;
  ldv_57342: 
#line 994
  tx_ring = adapter->tx_ring[i];
#line 996
  tc = tx_ring->dcb_tc;
#line 997
  if (xoff[(int )tc] != 0U) {
#line 998
    clear_bit(3L, (unsigned long volatile   *)(& tx_ring->state));
  } else {

  }
#line 993
  i = i + 1;
  ldv_57343: ;
#line 993
  if (adapter->num_tx_queues > i) {
#line 995
    goto ldv_57342;
  } else {

  }

#line 1000
  return;
}
}
#line 1002 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u64 ixgbe_get_tx_completed(struct ixgbe_ring *ring ) 
{ 


  {
#line 1004
  return (ring->stats.packets);
}
}
#line 1007 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u64 ixgbe_get_tx_pending(struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_hw *hw ;
  u32 head ;
  u32 tail ;
  void *tmp ;

  {
#line 1013
  if ((unsigned long )ring->l2_accel_priv != (unsigned long )((struct ixgbe_fwd_adapter *)0)) {
#line 1014
    adapter = (ring->l2_accel_priv)->real_adapter;
  } else {
#line 1016
    tmp = netdev_priv((struct net_device  const  *)ring->netdev);
#line 1016
    adapter = (struct ixgbe_adapter *)tmp;
  }
#line 1018
  hw = & adapter->hw;
#line 1019
  head = ixgbe_read_reg(hw, (u32 )((int )ring->reg_idx * 64 + 24592));
#line 1020
  tail = ixgbe_read_reg(hw, (u32 )((int )ring->reg_idx * 64 + 24600));
#line 1022
  if (head != tail) {
#line 1023
    return ((u64 )(head < tail ? tail - head : ((u32 )ring->count + tail) - head));
  } else {

  }
#line 1026
  return (0ULL);
}
}
#line 1029 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_check_tx_hang(struct ixgbe_ring *tx_ring ) 
{ 
  u32 tx_done ;
  u64 tmp ;
  u32 tx_done_old ;
  u32 tx_pending ;
  u64 tmp___0 ;
  int tmp___1 ;

  {
#line 1031
  tmp = ixgbe_get_tx_completed(tx_ring);
#line 1031
  tx_done = (u32 )tmp;
#line 1032
  tx_done_old = (u32 )tx_ring->__annonCompField121.tx_stats.tx_done_old;
#line 1033
  tmp___0 = ixgbe_get_tx_pending(tx_ring);
#line 1033
  tx_pending = (u32 )tmp___0;
#line 1035
  clear_bit(2L, (unsigned long volatile   *)(& tx_ring->state));
#line 1049
  if (tx_done_old == tx_done && tx_pending != 0U) {
#line 1051
    tmp___1 = test_and_set_bit(3L, (unsigned long volatile   *)(& tx_ring->state));
#line 1051
    return (tmp___1 != 0);
  } else {

  }
#line 1054
  tx_ring->__annonCompField121.tx_stats.tx_done_old = (u64 )tx_done;
#line 1056
  clear_bit(3L, (unsigned long volatile   *)(& tx_ring->state));
#line 1058
  return (0);
}
}
#line 1065 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_tx_timeout_reset(struct ixgbe_adapter *adapter ) 
{ 
  int tmp ;

  {
#line 1069
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 1069
  if (tmp == 0) {
#line 1070
    adapter->flags2 = adapter->flags2 | 64U;
#line 1071
    if ((int )adapter->msg_enable & 1) {
#line 1071
      netdev_warn((struct net_device  const  *)adapter->netdev, "initiating reset due to tx timeout\n");
    } else {

    }
#line 1072
    ixgbe_service_event_schedule(adapter);
  } else {

  }
#line 1074
  return;
}
}
#line 1081 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector , struct ixgbe_ring *tx_ring ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_tx_buffer *tx_buffer ;
  union ixgbe_adv_tx_desc *tx_desc ;
  unsigned int total_bytes ;
  unsigned int total_packets ;
  unsigned int budget ;
  unsigned int i ;
  int tmp ;
  union ixgbe_adv_tx_desc *eop_desc ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  struct ixgbe_hw *hw ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  struct netdev_queue *tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  u16 tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;

  {
#line 1084
  adapter = q_vector->adapter;
#line 1087
  total_bytes = 0U;
#line 1087
  total_packets = 0U;
#line 1088
  budget = (unsigned int )q_vector->tx.work_limit;
#line 1089
  i = (unsigned int )tx_ring->next_to_clean;
#line 1091
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 1091
  if (tmp != 0) {
#line 1092
    return (1);
  } else {

  }
#line 1094
  tx_buffer = tx_ring->__annonCompField118.tx_buffer_info + (unsigned long )i;
#line 1095
  tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc + (unsigned long )i;
#line 1096
  i = i - (unsigned int )tx_ring->count;
  ldv_57380: 
#line 1099
  eop_desc = tx_buffer->next_to_watch;
#line 1102
  if ((unsigned long )eop_desc == (unsigned long )((union ixgbe_adv_tx_desc *)0)) {
#line 1103
    goto ldv_57376;
  } else {

  }
#line 1109
  if ((eop_desc->wb.status & 1U) == 0U) {
#line 1110
    goto ldv_57376;
  } else {

  }
#line 1113
  tx_buffer->next_to_watch = (union ixgbe_adv_tx_desc *)0;
#line 1116
  total_bytes = tx_buffer->bytecount + total_bytes;
#line 1117
  total_packets = (unsigned int )tx_buffer->gso_segs + total_packets;
#line 1120
  dev_consume_skb_any(tx_buffer->skb);
#line 1123
  dma_unmap_single_attrs(tx_ring->dev, tx_buffer->dma, (size_t )tx_buffer->len, 1,
                         (struct dma_attrs *)0);
#line 1129
  tx_buffer->skb = (struct sk_buff *)0;
#line 1130
  tx_buffer->len = 0U;
#line 1133
  goto ldv_57378;
  ldv_57377: 
#line 1134
  tx_buffer = tx_buffer + 1;
#line 1135
  tx_desc = tx_desc + 1;
#line 1136
  i = i + 1U;
#line 1137
  tmp___0 = ldv__builtin_expect(i == 0U, 0L);
#line 1137
  if (tmp___0 != 0L) {
#line 1138
    i = i - (unsigned int )tx_ring->count;
#line 1139
    tx_buffer = tx_ring->__annonCompField118.tx_buffer_info;
#line 1140
    tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc;
  } else {

  }
#line 1144
  if (tx_buffer->len != 0U) {
#line 1145
    dma_unmap_page(tx_ring->dev, tx_buffer->dma, (size_t )tx_buffer->len, 1);
#line 1149
    tx_buffer->len = 0U;
  } else {

  }
  ldv_57378: ;
#line 1133
  if ((unsigned long )tx_desc != (unsigned long )eop_desc) {
#line 1135
    goto ldv_57377;
  } else {

  }
#line 1154
  tx_buffer = tx_buffer + 1;
#line 1155
  tx_desc = tx_desc + 1;
#line 1156
  i = i + 1U;
#line 1157
  tmp___1 = ldv__builtin_expect(i == 0U, 0L);
#line 1157
  if (tmp___1 != 0L) {
#line 1158
    i = i - (unsigned int )tx_ring->count;
#line 1159
    tx_buffer = tx_ring->__annonCompField118.tx_buffer_info;
#line 1160
    tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc;
  } else {

  }
#line 1164
  __builtin_prefetch((void const   *)tx_desc);
#line 1167
  budget = budget - 1U;
#line 1168
  tmp___2 = ldv__builtin_expect(budget != 0U, 1L);
#line 1168
  if (tmp___2 != 0L) {
#line 1170
    goto ldv_57380;
  } else {

  }
  ldv_57376: 
#line 1170
  i = (unsigned int )tx_ring->count + i;
#line 1171
  tx_ring->next_to_clean = (u16 )i;
#line 1172
  u64_stats_init(& tx_ring->syncp);
#line 1173
  tx_ring->stats.bytes = tx_ring->stats.bytes + (u64 )total_bytes;
#line 1174
  tx_ring->stats.packets = tx_ring->stats.packets + (u64 )total_packets;
#line 1175
  u64_stats_init(& tx_ring->syncp);
#line 1176
  q_vector->tx.total_bytes = q_vector->tx.total_bytes + total_bytes;
#line 1177
  q_vector->tx.total_packets = q_vector->tx.total_packets + total_packets;
#line 1179
  tmp___5 = constant_test_bit(2L, (unsigned long const volatile   *)(& tx_ring->state));
#line 1179
  if (tmp___5 != 0) {
#line 1179
    tmp___6 = ixgbe_check_tx_hang(tx_ring);
#line 1179
    if ((int )tmp___6) {
#line 1181
      hw = & adapter->hw;
#line 1182
      if ((int )adapter->msg_enable & 1) {
#line 1194
        tmp___3 = ixgbe_read_reg(hw, (u32 )((int )tx_ring->reg_idx * 64 + 24600));
#line 1194
        tmp___4 = ixgbe_read_reg(hw, (u32 )((int )tx_ring->reg_idx * 64 + 24592));
#line 1194
        netdev_err((struct net_device  const  *)adapter->netdev, "Detected Tx Unit Hang\n  Tx Queue             <%d>\n  TDH, TDT             <%x>, <%x>\n  next_to_use          <%x>\n  next_to_clean        <%x>\ntx_buffer_info[next_to_clean]\n  time_stamp           <%lx>\n  jiffies              <%lx>\n",
                   (int )tx_ring->queue_index, tmp___4, tmp___3, (int )tx_ring->next_to_use,
                   i, (tx_ring->__annonCompField118.tx_buffer_info + (unsigned long )i)->time_stamp,
                   jiffies);
      } else {

      }
#line 1196
      netif_stop_subqueue(tx_ring->netdev, (int )tx_ring->queue_index);
#line 1198
      if (((int )adapter->msg_enable & 2) != 0) {
#line 1200
        netdev_info((struct net_device  const  *)adapter->netdev, "tx hang %d detected on queue %d, resetting adapter\n",
                    adapter->tx_timeout_count + 1U, (int )tx_ring->queue_index);
      } else {

      }
#line 1203
      ixgbe_tx_timeout_reset(adapter);
#line 1206
      return (1);
    } else {

    }
  } else {

  }
#line 1209
  tmp___7 = txring_txq((struct ixgbe_ring  const  *)tx_ring);
#line 1209
  netdev_tx_completed_queue(tmp___7, total_packets, total_bytes);
#line 1213
  if (total_packets != 0U) {
#line 1213
    tmp___10 = netif_carrier_ok((struct net_device  const  *)tx_ring->netdev);
#line 1213
    if ((int )tmp___10) {
#line 1213
      tmp___11 = ixgbe_desc_unused(tx_ring);
#line 1213
      if ((unsigned int )tmp___11 > 41U) {
#line 1213
        tmp___12 = 1;
      } else {
#line 1213
        tmp___12 = 0;
      }
    } else {
#line 1213
      tmp___12 = 0;
    }
  } else {
#line 1213
    tmp___12 = 0;
  }
#line 1213
  tmp___13 = ldv__builtin_expect((long )tmp___12, 0L);
#line 1213
  if (tmp___13 != 0L) {
#line 1218
    __asm__  volatile   ("mfence": : : "memory");
#line 1219
    tmp___8 = __netif_subqueue_stopped((struct net_device  const  *)tx_ring->netdev,
                                       (int )tx_ring->queue_index);
#line 1219
    if ((int )tmp___8) {
#line 1219
      tmp___9 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 1219
      if (tmp___9 == 0) {
#line 1222
        netif_wake_subqueue(tx_ring->netdev, (int )tx_ring->queue_index);
#line 1224
        tx_ring->__annonCompField121.tx_stats.restart_queue = tx_ring->__annonCompField121.tx_stats.restart_queue + 1ULL;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1228
  return (budget != 0U);
}
}
#line 1232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_tx_dca(struct ixgbe_adapter *adapter , struct ixgbe_ring *tx_ring ,
                                int cpu ) 
{ 
  struct ixgbe_hw *hw ;
  u32 txctrl ;
  u8 tmp ;
  u16 reg_offset ;

  {
#line 1236
  hw = & adapter->hw;
#line 1237
  tmp = dca3_get_tag(tx_ring->dev, cpu);
#line 1237
  txctrl = (u32 )tmp;
#line 1240
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 1242
  reg_offset = (unsigned int )((u16 )((int )tx_ring->reg_idx + 7296)) * 4U;
#line 1243
  goto ldv_57391;
  case 2U: ;
  case 3U: 
#line 1246
  reg_offset = (unsigned int )((u16 )tx_ring->reg_idx) * 64U + 24588U;
#line 1247
  txctrl = txctrl << 24;
#line 1248
  goto ldv_57391;
  default: ;
#line 1251
  return;
  }
  ldv_57391: 
#line 1259
  txctrl = txctrl | 8736U;
#line 1263
  ixgbe_write_reg(hw, (u32 )reg_offset, txctrl);
#line 1264
  return;
}
}
#line 1266 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_rx_dca(struct ixgbe_adapter *adapter , struct ixgbe_ring *rx_ring ,
                                int cpu ) 
{ 
  struct ixgbe_hw *hw ;
  u32 rxctrl ;
  u8 tmp ;
  u8 reg_idx ;

  {
#line 1270
  hw = & adapter->hw;
#line 1271
  tmp = dca3_get_tag(rx_ring->dev, cpu);
#line 1271
  rxctrl = (u32 )tmp;
#line 1272
  reg_idx = rx_ring->reg_idx;
#line 1275
  switch ((unsigned int )hw->mac.type) {
  case 2U: ;
  case 3U: 
#line 1278
  rxctrl = rxctrl << 24;
#line 1279
  goto ldv_57405;
  default: ;
#line 1281
  goto ldv_57405;
  }
  ldv_57405: 
#line 1289
  rxctrl = rxctrl | 544U;
#line 1292
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 15U ? ((int )reg_idx + 2176) * 4 : ((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4108 : ((int )reg_idx + -64) * 64 + 53260)),
                  rxctrl);
#line 1293
  return;
}
}
#line 1295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_dca(struct ixgbe_q_vector *q_vector ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_ring *ring ;
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 1297
  adapter = q_vector->adapter;
#line 1299
  __preempt_count_add(1);
#line 1299
  __asm__  volatile   ("": : : "memory");
#line 1299
  __vpp_verify = (void const   *)0;
#line 1299
  switch (4UL) {
  case 1UL: ;
#line 1299
  switch (4UL) {
  case 1UL: 
#line 1299
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 1299
  goto ldv_57418;
  case 2UL: 
#line 1299
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1299
  goto ldv_57418;
  case 4UL: 
#line 1299
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1299
  goto ldv_57418;
  case 8UL: 
#line 1299
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1299
  goto ldv_57418;
  default: 
#line 1299
  __bad_percpu_size();
  }
  ldv_57418: 
#line 1299
  pscr_ret__ = pfo_ret__;
#line 1299
  goto ldv_57424;
  case 2UL: ;
#line 1299
  switch (4UL) {
  case 1UL: 
#line 1299
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 1299
  goto ldv_57428;
  case 2UL: 
#line 1299
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1299
  goto ldv_57428;
  case 4UL: 
#line 1299
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1299
  goto ldv_57428;
  case 8UL: 
#line 1299
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1299
  goto ldv_57428;
  default: 
#line 1299
  __bad_percpu_size();
  }
  ldv_57428: 
#line 1299
  pscr_ret__ = pfo_ret_____0;
#line 1299
  goto ldv_57424;
  case 4UL: ;
#line 1299
  switch (4UL) {
  case 1UL: 
#line 1299
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 1299
  goto ldv_57437;
  case 2UL: 
#line 1299
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1299
  goto ldv_57437;
  case 4UL: 
#line 1299
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1299
  goto ldv_57437;
  case 8UL: 
#line 1299
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1299
  goto ldv_57437;
  default: 
#line 1299
  __bad_percpu_size();
  }
  ldv_57437: 
#line 1299
  pscr_ret__ = pfo_ret_____1;
#line 1299
  goto ldv_57424;
  case 8UL: ;
#line 1299
  switch (4UL) {
  case 1UL: 
#line 1299
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 1299
  goto ldv_57446;
  case 2UL: 
#line 1299
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1299
  goto ldv_57446;
  case 4UL: 
#line 1299
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1299
  goto ldv_57446;
  case 8UL: 
#line 1299
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1299
  goto ldv_57446;
  default: 
#line 1299
  __bad_percpu_size();
  }
  ldv_57446: 
#line 1299
  pscr_ret__ = pfo_ret_____2;
#line 1299
  goto ldv_57424;
  default: 
#line 1299
  __bad_size_call_parameter();
#line 1299
  goto ldv_57424;
  }
  ldv_57424: 
#line 1299
  cpu = pscr_ret__;
#line 1301
  if (q_vector->cpu == cpu) {
#line 1302
    goto out_no_update;
  } else {

  }
#line 1304
  ring = q_vector->tx.ring;
#line 1304
  goto ldv_57457;
  ldv_57456: 
#line 1305
  ixgbe_update_tx_dca(adapter, ring, cpu);
#line 1304
  ring = ring->next;
  ldv_57457: ;
#line 1304
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 1306
    goto ldv_57456;
  } else {

  }
#line 1307
  ring = q_vector->rx.ring;
#line 1307
  goto ldv_57460;
  ldv_57459: 
#line 1308
  ixgbe_update_rx_dca(adapter, ring, cpu);
#line 1307
  ring = ring->next;
  ldv_57460: ;
#line 1307
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 1309
    goto ldv_57459;
  } else {

  }
#line 1310
  q_vector->cpu = cpu;
  out_no_update: 
#line 1312
  __asm__  volatile   ("": : : "memory");
#line 1312
  __preempt_count_sub(1);
#line 1313
  return;
}
}
#line 1315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_dca(struct ixgbe_adapter *adapter ) 
{ 
  int i ;

  {
#line 1319
  if ((adapter->flags & 256U) == 0U) {
#line 1320
    return;
  } else {

  }
#line 1323
  ixgbe_write_reg(& adapter->hw, 69748U, 2U);
#line 1325
  i = 0;
#line 1325
  goto ldv_57467;
  ldv_57466: 
#line 1326
  (adapter->q_vector[i])->cpu = -1;
#line 1327
  ixgbe_update_dca(adapter->q_vector[i]);
#line 1325
  i = i + 1;
  ldv_57467: ;
#line 1325
  if (adapter->num_q_vectors > i) {
#line 1327
    goto ldv_57466;
  } else {

  }

#line 1332
  return;
}
}
#line 1331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int __ixgbe_notify_dca(struct device *dev , void *data ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  unsigned long event ;
  int tmp___0 ;

  {
#line 1333
  tmp = dev_get_drvdata((struct device  const  *)dev);
#line 1333
  adapter = (struct ixgbe_adapter *)tmp;
#line 1334
  event = *((unsigned long *)data);
#line 1336
  if ((adapter->flags & 512U) == 0U) {
#line 1337
    return (0);
  } else {

  }
#line 1339
  switch (event) {
  case 1UL: ;
#line 1342
  if ((adapter->flags & 256U) != 0U) {
#line 1343
    goto ldv_57476;
  } else {

  }
#line 1344
  tmp___0 = dca_add_requester(dev);
#line 1344
  if (tmp___0 == 0) {
#line 1345
    adapter->flags = adapter->flags | 256U;
#line 1346
    ixgbe_setup_dca(adapter);
#line 1347
    goto ldv_57476;
  } else {

  }
  case 2UL: ;
#line 1351
  if ((adapter->flags & 256U) != 0U) {
#line 1352
    dca_remove_requester(dev);
#line 1353
    adapter->flags = adapter->flags & 4294967039U;
#line 1354
    ixgbe_write_reg(& adapter->hw, 69748U, 1U);
  } else {

  }
#line 1356
  goto ldv_57476;
  }
  ldv_57476: ;
#line 1359
  return (0);
}
}
#line 1363 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_rx_hash(struct ixgbe_ring *ring , union ixgbe_adv_rx_desc *rx_desc ,
                                   struct sk_buff *skb ) 
{ 


  {
#line 1367
  if (((ring->netdev)->features & 8589934592ULL) != 0ULL) {
#line 1368
    skb_set_hash(skb, rx_desc->wb.lower.hi_dword.rss, 2);
  } else {

  }
#line 1370
  return;
}
}
#line 1381 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_rx_is_fcoe(struct ixgbe_ring *ring , union ixgbe_adv_rx_desc *rx_desc ) 
{ 
  __le16 pkt_info ;
  int tmp ;

  {
#line 1384
  pkt_info = rx_desc->wb.lower.lo_dword.hs_rss.pkt_info;
#line 1386
  tmp = constant_test_bit(6L, (unsigned long const volatile   *)(& ring->state));
#line 1386
  return ((bool )(tmp != 0 && ((int )pkt_info & 112) == 32));
}
}
#line 1399 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_rx_checksum(struct ixgbe_ring *ring , union ixgbe_adv_rx_desc *rx_desc ,
                                       struct sk_buff *skb ) 
{ 
  __le16 pkt_info ;
  __le16 hdr_info ;
  bool encap_pkt ;
  __le32 tmp ;
  __le32 tmp___0 ;
  __le32 tmp___1 ;
  int tmp___2 ;
  __le32 tmp___3 ;
  __le32 tmp___4 ;
  __le32 tmp___5 ;

  {
#line 1403
  pkt_info = rx_desc->wb.lower.lo_dword.hs_rss.pkt_info;
#line 1404
  hdr_info = rx_desc->wb.lower.lo_dword.hs_rss.hdr_info;
#line 1405
  encap_pkt = 0;
#line 1407
  skb_checksum_none_assert((struct sk_buff  const  *)skb);
#line 1410
  if (((ring->netdev)->features & 17179869184ULL) == 0ULL) {
#line 1411
    return;
  } else {

  }
#line 1413
  if (((int )pkt_info & 2048) != 0 && (int )hdr_info & 1) {
#line 1415
    encap_pkt = 1;
#line 1416
    skb->encapsulation = 1U;
#line 1417
    skb->ip_summed = 0U;
  } else {

  }
#line 1421
  tmp = ixgbe_test_staterr(rx_desc, 64U);
#line 1421
  if (tmp != 0U) {
#line 1421
    tmp___0 = ixgbe_test_staterr(rx_desc, 2147483648U);
#line 1421
    if (tmp___0 != 0U) {
#line 1423
      ring->__annonCompField121.rx_stats.csum_err = ring->__annonCompField121.rx_stats.csum_err + 1ULL;
#line 1424
      return;
    } else {

    }
  } else {

  }
#line 1427
  tmp___1 = ixgbe_test_staterr(rx_desc, 32U);
#line 1427
  if (tmp___1 == 0U) {
#line 1428
    return;
  } else {

  }
#line 1430
  tmp___3 = ixgbe_test_staterr(rx_desc, 1073741824U);
#line 1430
  if (tmp___3 != 0U) {
#line 1435
    if (((int )pkt_info & 512) != 0) {
#line 1435
      tmp___2 = constant_test_bit(5L, (unsigned long const volatile   *)(& ring->state));
#line 1435
      if (tmp___2 != 0) {
#line 1437
        return;
      } else {

      }
    } else {

    }
#line 1439
    ring->__annonCompField121.rx_stats.csum_err = ring->__annonCompField121.rx_stats.csum_err + 1ULL;
#line 1440
    return;
  } else {

  }
#line 1444
  skb->ip_summed = 1U;
#line 1445
  if ((int )encap_pkt) {
#line 1446
    tmp___4 = ixgbe_test_staterr(rx_desc, 256U);
#line 1446
    if (tmp___4 == 0U) {
#line 1447
      return;
    } else {

    }
#line 1449
    tmp___5 = ixgbe_test_staterr(rx_desc, 67108864U);
#line 1449
    if (tmp___5 != 0U) {
#line 1450
      ring->__annonCompField121.rx_stats.csum_err = ring->__annonCompField121.rx_stats.csum_err + 1ULL;
#line 1451
      return;
    } else {

    }
#line 1454
    skb->csum_level = 1U;
  } else {

  }
#line 1456
  return;
}
}
#line 1458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_alloc_mapped_page(struct ixgbe_ring *rx_ring , struct ixgbe_rx_buffer *bi ) 
{ 
  struct page *page ;
  dma_addr_t dma ;
  long tmp ;
  unsigned int tmp___0 ;
  long tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
#line 1461
  page = bi->page;
#line 1465
  tmp = ldv__builtin_expect((unsigned long )page != (unsigned long )((struct page *)0),
                         1L);
#line 1465
  if (tmp != 0L) {
#line 1466
    return (1);
  } else {

  }
#line 1469
  tmp___0 = ixgbe_rx_pg_order(rx_ring);
#line 1469
  page = dev_alloc_pages(tmp___0);
#line 1470
  tmp___1 = ldv__builtin_expect((unsigned long )page == (unsigned long )((struct page *)0),
                             0L);
#line 1470
  if (tmp___1 != 0L) {
#line 1471
    rx_ring->__annonCompField121.rx_stats.alloc_rx_page_failed = rx_ring->__annonCompField121.rx_stats.alloc_rx_page_failed + 1ULL;
#line 1472
    return (0);
  } else {

  }
#line 1476
  tmp___2 = ixgbe_rx_pg_order(rx_ring);
#line 1476
  dma = dma_map_page(rx_ring->dev, page, 0UL, 4096UL << (int )tmp___2, 2);
#line 1483
  tmp___4 = dma_mapping_error(rx_ring->dev, dma);
#line 1483
  if (tmp___4 != 0) {
#line 1484
    tmp___3 = ixgbe_rx_pg_order(rx_ring);
#line 1484
    __free_pages(page, tmp___3);
#line 1486
    rx_ring->__annonCompField121.rx_stats.alloc_rx_page_failed = rx_ring->__annonCompField121.rx_stats.alloc_rx_page_failed + 1ULL;
#line 1487
    return (0);
  } else {

  }
#line 1490
  bi->dma = dma;
#line 1491
  bi->page = page;
#line 1492
  bi->page_offset = 0U;
#line 1494
  return (1);
}
}
#line 1502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_alloc_rx_buffers(struct ixgbe_ring *rx_ring , u16 cleaned_count ) 
{ 
  union ixgbe_adv_rx_desc *rx_desc ;
  struct ixgbe_rx_buffer *bi ;
  u16 i ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 1506
  i = rx_ring->next_to_use;
#line 1509
  if ((unsigned int )cleaned_count == 0U) {
#line 1510
    return;
  } else {

  }
#line 1512
  rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long )i;
#line 1513
  bi = rx_ring->__annonCompField118.rx_buffer_info + (unsigned long )i;
#line 1514
  i = (int )i - (int )rx_ring->count;
  ldv_57510: 
#line 1517
  tmp = ixgbe_alloc_mapped_page(rx_ring, bi);
#line 1517
  if (tmp) {
#line 1517
    tmp___0 = 0;
  } else {
#line 1517
    tmp___0 = 1;
  }
#line 1517
  if (tmp___0) {
#line 1518
    goto ldv_57509;
  } else {

  }
#line 1524
  rx_desc->read.pkt_addr = bi->dma + (dma_addr_t )bi->page_offset;
#line 1526
  rx_desc = rx_desc + 1;
#line 1527
  bi = bi + 1;
#line 1528
  i = (u16 )((int )i + 1);
#line 1529
  tmp___1 = ldv__builtin_expect((unsigned int )i == 0U, 0L);
#line 1529
  if (tmp___1 != 0L) {
#line 1530
    rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc;
#line 1531
    bi = rx_ring->__annonCompField118.rx_buffer_info;
#line 1532
    i = (int )i - (int )rx_ring->count;
  } else {

  }
#line 1536
  rx_desc->wb.upper.status_error = 0U;
#line 1538
  cleaned_count = (u16 )((int )cleaned_count - 1);
#line 1539
  if ((unsigned int )cleaned_count != 0U) {
#line 1541
    goto ldv_57510;
  } else {

  }
  ldv_57509: 
#line 1541
  i = (int )rx_ring->count + (int )i;
#line 1543
  if ((int )rx_ring->next_to_use != (int )i) {
#line 1544
    rx_ring->next_to_use = i;
#line 1547
    rx_ring->__annonCompField120.next_to_alloc = i;
#line 1554
    __asm__  volatile   ("sfence": : : "memory");
#line 1555
    writel((unsigned int )i, (void volatile   *)rx_ring->tail);
  } else {

  }
#line 1557
  return;
}
}
#line 1559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_rsc_gso_size(struct ixgbe_ring *ring , struct sk_buff *skb ) 
{ 
  u16 hdr_len ;
  unsigned int tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 1562
  tmp = skb_headlen((struct sk_buff  const  *)skb);
#line 1562
  hdr_len = (u16 )tmp;
#line 1565
  tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1565
  ((struct skb_shared_info *)tmp___0)->gso_size = (unsigned short )((((skb->len - (unsigned int )hdr_len) + (unsigned int )((struct ixgbe_cb *)(& skb->cb))->append_cnt) - 1U) / (unsigned int )((struct ixgbe_cb *)(& skb->cb))->append_cnt);
#line 1567
  tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1567
  ((struct skb_shared_info *)tmp___1)->gso_type = 1U;
#line 1568
  return;
}
}
#line 1570 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_rsc_stats(struct ixgbe_ring *rx_ring , struct sk_buff *skb ) 
{ 


  {
#line 1574
  if ((unsigned int )((struct ixgbe_cb *)(& skb->cb))->append_cnt == 0U) {
#line 1575
    return;
  } else {

  }
#line 1577
  rx_ring->__annonCompField121.rx_stats.rsc_count = rx_ring->__annonCompField121.rx_stats.rsc_count + (u64 )((struct ixgbe_cb *)(& skb->cb))->append_cnt;
#line 1578
  rx_ring->__annonCompField121.rx_stats.rsc_flush = rx_ring->__annonCompField121.rx_stats.rsc_flush + 1ULL;
#line 1580
  ixgbe_set_rsc_gso_size(rx_ring, skb);
#line 1583
  ((struct ixgbe_cb *)(& skb->cb))->append_cnt = 0U;
#line 1584
  return;
}
}
#line 1596 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_process_skb_fields(struct ixgbe_ring *rx_ring , union ixgbe_adv_rx_desc *rx_desc ,
                                     struct sk_buff *skb ) 
{ 
  struct net_device *dev ;
  __le32 tmp ;
  long tmp___0 ;
  u16 vid ;
  __le32 tmp___1 ;

  {
#line 1600
  dev = rx_ring->netdev;
#line 1602
  ixgbe_update_rsc_stats(rx_ring, skb);
#line 1604
  ixgbe_rx_hash(rx_ring, rx_desc, skb);
#line 1606
  ixgbe_rx_checksum(rx_ring, rx_desc, skb);
#line 1608
  tmp = ixgbe_test_staterr(rx_desc, 65536U);
#line 1608
  tmp___0 = ldv__builtin_expect(tmp != 0U, 0L);
#line 1608
  if (tmp___0 != 0L) {
#line 1609
    ixgbe_ptp_rx_hwtstamp((rx_ring->q_vector)->adapter, skb);
  } else {

  }
#line 1611
  if ((dev->features & 256ULL) != 0ULL) {
#line 1611
    tmp___1 = ixgbe_test_staterr(rx_desc, 8U);
#line 1611
    if (tmp___1 != 0U) {
#line 1613
      vid = rx_desc->wb.upper.vlan;
#line 1614
      __vlan_hwaccel_put_tag(skb, 129, (int )vid);
    } else {

    }
  } else {

  }
#line 1617
  skb_record_rx_queue(skb, (int )rx_ring->queue_index);
#line 1619
  skb->protocol = eth_type_trans(skb, dev);
#line 1620
  return;
}
}
#line 1622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_rx_skb(struct ixgbe_q_vector *q_vector , struct sk_buff *skb ) 
{ 
  bool tmp ;

  {
#line 1625
  tmp = ixgbe_qv_busy_polling(q_vector);
#line 1625
  if ((int )tmp) {
#line 1626
    netif_receive_skb(skb);
  } else {
#line 1628
    napi_gro_receive(& q_vector->napi, skb);
  }
#line 1629
  return;
}
}
#line 1642 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_is_non_eop(struct ixgbe_ring *rx_ring , union ixgbe_adv_rx_desc *rx_desc ,
                             struct sk_buff *skb ) 
{ 
  u32 ntc ;
  __le32 rsc_enabled ;
  u32 rsc_cnt ;
  long tmp ;
  int tmp___0 ;
  __le32 tmp___1 ;
  long tmp___2 ;

  {
#line 1646
  ntc = (u32 )((int )rx_ring->next_to_clean + 1);
#line 1649
  ntc = (u32 )rx_ring->count > ntc ? ntc : 0U;
#line 1650
  rx_ring->next_to_clean = (u16 )ntc;
#line 1652
  __builtin_prefetch((void const   *)rx_ring->desc + (unsigned long )ntc);
#line 1655
  tmp___0 = constant_test_bit(4L, (unsigned long const volatile   *)(& rx_ring->state));
#line 1655
  if (tmp___0 != 0) {
#line 1656
    rsc_enabled = rx_desc->wb.lower.lo_dword.data & 1966080U;
#line 1659
    tmp = ldv__builtin_expect(rsc_enabled != 0U, 0L);
#line 1659
    if (tmp != 0L) {
#line 1660
      rsc_cnt = rsc_enabled;
#line 1662
      rsc_cnt = rsc_cnt >> 17;
#line 1663
      ((struct ixgbe_cb *)(& skb->cb))->append_cnt = (unsigned int )((int )((struct ixgbe_cb *)(& skb->cb))->append_cnt + (int )((u16 )rsc_cnt)) - 1U;
#line 1666
      ntc = rx_desc->wb.upper.status_error;
#line 1667
      ntc = ntc & 1048560U;
#line 1668
      ntc = ntc >> 4;
    } else {

    }
  } else {

  }
#line 1673
  tmp___1 = ixgbe_test_staterr(rx_desc, 2U);
#line 1673
  tmp___2 = ldv__builtin_expect(tmp___1 != 0U, 1L);
#line 1673
  if (tmp___2 != 0L) {
#line 1674
    return (0);
  } else {

  }
#line 1677
  (rx_ring->__annonCompField118.rx_buffer_info + (unsigned long )ntc)->skb = skb;
#line 1678
  rx_ring->__annonCompField121.rx_stats.non_eop_descs = rx_ring->__annonCompField121.rx_stats.non_eop_descs + 1ULL;
#line 1680
  return (1);
}
}
#line 1695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_pull_tail(struct ixgbe_ring *rx_ring , struct sk_buff *skb ) 
{ 
  struct skb_frag_struct *frag ;
  unsigned char *tmp ;
  unsigned char *va ;
  unsigned int pull_len ;
  void *tmp___0 ;

  {
#line 1698
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1698
  frag = (struct skb_frag_struct *)(& ((struct skb_shared_info *)tmp)->frags);
#line 1707
  tmp___0 = skb_frag_address((skb_frag_t const   *)frag);
#line 1707
  va = (unsigned char *)tmp___0;
#line 1713
  pull_len = eth_get_headlen((void *)va, 256U);
#line 1716
  skb_copy_to_linear_data(skb, (void const   *)va, (pull_len + 7U) & 4294967288U);
#line 1719
  skb_frag_size_sub(frag, (int )pull_len);
#line 1720
  frag->page_offset = frag->page_offset + pull_len;
#line 1721
  skb->data_len = skb->data_len - pull_len;
#line 1722
  skb->tail = skb->tail + pull_len;
#line 1723
  return;
}
}
#line 1735 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_dma_sync_frag(struct ixgbe_ring *rx_ring , struct sk_buff *skb ) 
{ 
  unsigned int tmp ;
  struct skb_frag_struct *frag ;
  unsigned char *tmp___0 ;
  unsigned int tmp___1 ;
  long tmp___2 ;

  {
#line 1739
  tmp___2 = ldv__builtin_expect((long )((struct ixgbe_cb *)(& skb->cb))->page_released,
                             0L);
#line 1739
  if (tmp___2 != 0L) {
#line 1740
    tmp = ixgbe_rx_pg_order(rx_ring);
#line 1740
    dma_unmap_page(rx_ring->dev, ((struct ixgbe_cb *)(& skb->cb))->dma, 4096UL << (int )tmp,
                   2);
#line 1742
    ((struct ixgbe_cb *)(& skb->cb))->page_released = 0;
  } else {
#line 1744
    tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1744
    frag = (struct skb_frag_struct *)(& ((struct skb_shared_info *)tmp___0)->frags);
#line 1746
    tmp___1 = ixgbe_rx_bufsz(rx_ring);
#line 1746
    dma_sync_single_range_for_cpu(rx_ring->dev, ((struct ixgbe_cb *)(& skb->cb))->dma,
                                  (unsigned long )frag->page_offset, (size_t )tmp___1,
                                  2);
  }
#line 1752
  ((struct ixgbe_cb *)(& skb->cb))->dma = 0ULL;
#line 1753
  return;
}
}
#line 1773 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_cleanup_headers(struct ixgbe_ring *rx_ring , union ixgbe_adv_rx_desc *rx_desc ,
                                  struct sk_buff *skb ) 
{ 
  struct net_device *netdev ;
  __le32 tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 1777
  netdev = rx_ring->netdev;
#line 1780
  tmp = ixgbe_test_staterr(rx_desc, 989855744U);
#line 1780
  tmp___0 = ldv__builtin_expect((long )(tmp != 0U && (netdev->features & 274877906944ULL) == 0ULL),
                             0L);
#line 1780
  if (tmp___0 != 0L) {
#line 1783
    dev_kfree_skb_any(skb);
#line 1784
    return (1);
  } else {

  }
#line 1788
  tmp___1 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 1788
  if ((int )tmp___1) {
#line 1789
    ixgbe_pull_tail(rx_ring, skb);
  } else {

  }
#line 1793
  tmp___2 = ixgbe_rx_is_fcoe(rx_ring, rx_desc);
#line 1793
  if ((int )tmp___2) {
#line 1794
    return (0);
  } else {

  }
#line 1798
  tmp___3 = eth_skb_pad(skb);
#line 1798
  if (tmp___3 != 0) {
#line 1799
    return (1);
  } else {

  }
#line 1801
  return (0);
}
}
#line 1811 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_reuse_rx_page(struct ixgbe_ring *rx_ring , struct ixgbe_rx_buffer *old_buff ) 
{ 
  struct ixgbe_rx_buffer *new_buff ;
  u16 nta ;
  unsigned int tmp ;

  {
#line 1815
  nta = rx_ring->__annonCompField120.next_to_alloc;
#line 1817
  new_buff = rx_ring->__annonCompField118.rx_buffer_info + (unsigned long )nta;
#line 1820
  nta = (u16 )((int )nta + 1);
#line 1821
  rx_ring->__annonCompField120.next_to_alloc = (int )rx_ring->count > (int )nta ? nta : 0U;
#line 1824
  *new_buff = *old_buff;
#line 1827
  tmp = ixgbe_rx_bufsz(rx_ring);
#line 1827
  dma_sync_single_range_for_device(rx_ring->dev, new_buff->dma, (unsigned long )new_buff->page_offset,
                                   (size_t )tmp, 2);
#line 1830
  return;
}
}
#line 1833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_page_is_reserved(struct page *page ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1835
  tmp = page_to_nid((struct page  const  *)page);
#line 1835
  tmp___0 = numa_mem_id();
#line 1835
  return ((bool )(tmp != tmp___0 || (int )page->__annonCompField42.__annonCompField37.pfmemalloc));
}
}
#line 1853 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_add_rx_frag(struct ixgbe_ring *rx_ring , struct ixgbe_rx_buffer *rx_buffer ,
                              union ixgbe_adv_rx_desc *rx_desc , struct sk_buff *skb ) 
{ 
  struct page *page ;
  unsigned int size ;
  unsigned int truesize ;
  unsigned int tmp ;
  unsigned char *va ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  unsigned char *tmp___8 ;
  bool tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;

  {
#line 1858
  page = rx_buffer->page;
#line 1859
  size = (unsigned int )rx_desc->wb.upper.length;
#line 1861
  tmp = ixgbe_rx_bufsz(rx_ring);
#line 1861
  truesize = tmp;
#line 1868
  if (size <= 256U) {
#line 1868
    tmp___6 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 1868
    if (tmp___6) {
#line 1868
      tmp___7 = 0;
    } else {
#line 1868
      tmp___7 = 1;
    }
#line 1868
    if (tmp___7) {
#line 1869
      tmp___0 = lowmem_page_address((struct page  const  *)page);
#line 1869
      va = (unsigned char *)tmp___0 + (unsigned long )rx_buffer->page_offset;
#line 1871
      tmp___1 = __skb_put(skb, size);
#line 1871
      memcpy((void *)tmp___1, (void const   *)va, (size_t )(size + 7U) & 4294967288UL);
#line 1874
      tmp___2 = ixgbe_page_is_reserved(page);
#line 1874
      if (tmp___2) {
#line 1874
        tmp___3 = 0;
      } else {
#line 1874
        tmp___3 = 1;
      }
#line 1874
      tmp___4 = ldv__builtin_expect((long )tmp___3, 1L);
#line 1874
      if (tmp___4 != 0L) {
#line 1875
        return (1);
      } else {

      }
#line 1878
      tmp___5 = ixgbe_rx_pg_order(rx_ring);
#line 1878
      __free_pages(page, tmp___5);
#line 1879
      return (0);
    } else {

    }
  } else {

  }
#line 1882
  tmp___8 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1882
  skb_add_rx_frag(skb, (int )((struct skb_shared_info *)tmp___8)->nr_frags, page,
                  (int )rx_buffer->page_offset, (int )size, truesize);
#line 1886
  tmp___9 = ixgbe_page_is_reserved(page);
#line 1886
  tmp___10 = ldv__builtin_expect((long )tmp___9, 0L);
#line 1886
  if (tmp___10 != 0L) {
#line 1887
    return (0);
  } else {

  }
#line 1891
  tmp___11 = page_count(page);
#line 1891
  tmp___12 = ldv__builtin_expect(tmp___11 != 1, 0L);
#line 1891
  if (tmp___12 != 0L) {
#line 1892
    return (0);
  } else {

  }
#line 1895
  rx_buffer->page_offset = rx_buffer->page_offset ^ truesize;
#line 1907
  atomic_inc(& page->__annonCompField42.__annonCompField41.__annonCompField40._count);
#line 1909
  return (1);
}
}
#line 1912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct sk_buff *ixgbe_fetch_rx_buffer(struct ixgbe_ring *rx_ring , union ixgbe_adv_rx_desc *rx_desc ) 
{ 
  struct ixgbe_rx_buffer *rx_buffer ;
  struct sk_buff *skb ;
  struct page *page ;
  void *page_addr ;
  void *tmp ;
  long tmp___0 ;
  __le32 tmp___1 ;
  long tmp___2 ;
  __le32 tmp___3 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  unsigned int tmp___6 ;
  bool tmp___7 ;

  {
#line 1919
  rx_buffer = rx_ring->__annonCompField118.rx_buffer_info + (unsigned long )rx_ring->next_to_clean;
#line 1920
  page = rx_buffer->page;
#line 1921
  prefetchw((void const   *)page);
#line 1923
  skb = rx_buffer->skb;
#line 1925
  tmp___5 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                             1L);
#line 1925
  if (tmp___5 != 0L) {
#line 1926
    tmp = lowmem_page_address((struct page  const  *)page);
#line 1926
    page_addr = tmp + (unsigned long )rx_buffer->page_offset;
#line 1930
    __builtin_prefetch((void const   *)page_addr);
#line 1932
    __builtin_prefetch((void const   *)page_addr + 64U);
#line 1936
    skb = napi_alloc_skb(& (rx_ring->q_vector)->napi, 256U);
#line 1938
    tmp___0 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                               0L);
#line 1938
    if (tmp___0 != 0L) {
#line 1939
      rx_ring->__annonCompField121.rx_stats.alloc_rx_buff_failed = rx_ring->__annonCompField121.rx_stats.alloc_rx_buff_failed + 1ULL;
#line 1940
      return ((struct sk_buff *)0);
    } else {

    }
#line 1948
    prefetchw((void const   *)skb->data);
#line 1956
    tmp___1 = ixgbe_test_staterr(rx_desc, 2U);
#line 1956
    tmp___2 = ldv__builtin_expect(tmp___1 != 0U, 1L);
#line 1956
    if (tmp___2 != 0L) {
#line 1957
      goto dma_sync;
    } else {

    }
#line 1959
    ((struct ixgbe_cb *)(& skb->cb))->dma = rx_buffer->dma;
  } else {
#line 1961
    tmp___3 = ixgbe_test_staterr(rx_desc, 2U);
#line 1961
    if (tmp___3 != 0U) {
#line 1962
      ixgbe_dma_sync_frag(rx_ring, skb);
    } else {

    }
    dma_sync: 
#line 1966
    tmp___4 = ixgbe_rx_bufsz(rx_ring);
#line 1966
    dma_sync_single_range_for_cpu(rx_ring->dev, rx_buffer->dma, (unsigned long )rx_buffer->page_offset,
                                  (size_t )tmp___4, 2);
#line 1972
    rx_buffer->skb = (struct sk_buff *)0;
  }
#line 1976
  tmp___7 = ixgbe_add_rx_frag(rx_ring, rx_buffer, rx_desc, skb);
#line 1976
  if ((int )tmp___7) {
#line 1978
    ixgbe_reuse_rx_page(rx_ring, rx_buffer);
  } else
#line 1979
  if (((struct ixgbe_cb *)(& skb->cb))->dma == rx_buffer->dma) {
#line 1981
    ((struct ixgbe_cb *)(& skb->cb))->page_released = 1;
  } else {
#line 1984
    tmp___6 = ixgbe_rx_pg_order(rx_ring);
#line 1984
    dma_unmap_page(rx_ring->dev, rx_buffer->dma, 4096UL << (int )tmp___6, 2);
  }
#line 1990
  rx_buffer->page = (struct page *)0;
#line 1992
  return (skb);
}
}
#line 2008 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector , struct ixgbe_ring *rx_ring ,
                              int const   budget ) 
{ 
  unsigned int total_rx_bytes ;
  unsigned int total_rx_packets ;
  struct ixgbe_adapter *adapter ;
  int ddp_bytes ;
  unsigned int mss ;
  u16 cleaned_count ;
  u16 tmp ;
  union ixgbe_adv_rx_desc *rx_desc ;
  struct sk_buff *skb ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  long tmp___3 ;

  {
#line 2012
  total_rx_bytes = 0U;
#line 2012
  total_rx_packets = 0U;
#line 2014
  adapter = q_vector->adapter;
#line 2016
  mss = 0U;
#line 2018
  tmp = ixgbe_desc_unused(rx_ring);
#line 2018
  cleaned_count = tmp;
#line 2020
  goto ldv_57599;
  ldv_57600: ;
#line 2025
  if ((unsigned int )cleaned_count > 15U) {
#line 2026
    ixgbe_alloc_rx_buffers(rx_ring, (int )cleaned_count);
#line 2027
    cleaned_count = 0U;
  } else {

  }
#line 2030
  rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long )rx_ring->next_to_clean;
#line 2032
  if (rx_desc->wb.upper.status_error == 0U) {
#line 2033
    goto ldv_57598;
  } else {

  }
#line 2039
  __asm__  volatile   ("": : : "memory");
#line 2042
  skb = ixgbe_fetch_rx_buffer(rx_ring, rx_desc);
#line 2045
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 2046
    goto ldv_57598;
  } else {

  }
#line 2048
  cleaned_count = (u16 )((int )cleaned_count + 1);
#line 2051
  tmp___0 = ixgbe_is_non_eop(rx_ring, rx_desc, skb);
#line 2051
  if ((int )tmp___0) {
#line 2052
    goto ldv_57599;
  } else {

  }
#line 2055
  tmp___1 = ixgbe_cleanup_headers(rx_ring, rx_desc, skb);
#line 2055
  if ((int )tmp___1) {
#line 2056
    goto ldv_57599;
  } else {

  }
#line 2059
  total_rx_bytes = skb->len + total_rx_bytes;
#line 2062
  ixgbe_process_skb_fields(rx_ring, rx_desc, skb);
#line 2066
  tmp___2 = ixgbe_rx_is_fcoe(rx_ring, rx_desc);
#line 2066
  if ((int )tmp___2) {
#line 2067
    ddp_bytes = ixgbe_fcoe_ddp(adapter, rx_desc, skb);
#line 2069
    if (ddp_bytes > 0) {
#line 2070
      if (mss == 0U) {
#line 2071
        mss = (rx_ring->netdev)->mtu - 46U;
#line 2075
        if (mss > 512U) {
#line 2076
          mss = mss & 4294966784U;
        } else {

        }
      } else {

      }
#line 2078
      total_rx_bytes = total_rx_bytes + (unsigned int )ddp_bytes;
#line 2079
      total_rx_packets = (((unsigned int )ddp_bytes + mss) - 1U) / mss + total_rx_packets;
    } else {

    }
#line 2082
    if (ddp_bytes == 0) {
#line 2083
      dev_kfree_skb_any(skb);
#line 2084
      goto ldv_57599;
    } else {

    }
  } else {

  }
#line 2089
  skb_mark_napi_id(skb, & q_vector->napi);
#line 2090
  ixgbe_rx_skb(q_vector, skb);
#line 2093
  total_rx_packets = total_rx_packets + 1U;
  ldv_57599: 
#line 2020
  tmp___3 = ldv__builtin_expect((unsigned int )budget > total_rx_packets, 1L);
#line 2020
  if (tmp___3 != 0L) {
#line 2022
    goto ldv_57600;
  } else {

  }
  ldv_57598: 
#line 2096
  u64_stats_init(& rx_ring->syncp);
#line 2097
  rx_ring->stats.packets = rx_ring->stats.packets + (u64 )total_rx_packets;
#line 2098
  rx_ring->stats.bytes = rx_ring->stats.bytes + (u64 )total_rx_bytes;
#line 2099
  u64_stats_init(& rx_ring->syncp);
#line 2100
  q_vector->rx.total_packets = q_vector->rx.total_packets + total_rx_packets;
#line 2101
  q_vector->rx.total_bytes = q_vector->rx.total_bytes + total_rx_bytes;
#line 2103
  return ((int )total_rx_packets);
}
}
#line 2108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_low_latency_recv(struct napi_struct *napi ) 
{ 
  struct ixgbe_q_vector *q_vector ;
  struct napi_struct  const  *__mptr ;
  struct ixgbe_adapter *adapter ;
  struct ixgbe_ring *ring ;
  int found ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 2111
  __mptr = (struct napi_struct  const  *)napi;
#line 2111
  q_vector = (struct ixgbe_q_vector *)__mptr + 0xffffffffffffffc0UL;
#line 2112
  adapter = q_vector->adapter;
#line 2114
  found = 0;
#line 2116
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 2116
  if (tmp != 0) {
#line 2117
    return (-1);
  } else {

  }
#line 2119
  tmp___0 = ixgbe_qv_lock_poll(q_vector);
#line 2119
  if (tmp___0) {
#line 2119
    tmp___1 = 0;
  } else {
#line 2119
    tmp___1 = 1;
  }
#line 2119
  if (tmp___1) {
#line 2120
    return (-2);
  } else {

  }
#line 2122
  ring = q_vector->rx.ring;
#line 2122
  goto ldv_57612;
  ldv_57611: 
#line 2123
  found = ixgbe_clean_rx_irq(q_vector, ring, 4);
#line 2125
  if (found != 0) {
#line 2126
    ring->stats.cleaned = ring->stats.cleaned + (u64 )found;
  } else {
#line 2128
    ring->stats.misses = ring->stats.misses + 1ULL;
  }
#line 2130
  if (found != 0) {
#line 2131
    goto ldv_57610;
  } else {

  }
#line 2122
  ring = ring->next;
  ldv_57612: ;
#line 2122
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 2124
    goto ldv_57611;
  } else {

  }
  ldv_57610: 
#line 2134
  ixgbe_qv_unlock_poll(q_vector);
#line 2136
  return (found);
}
}
#line 2147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_msix(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_q_vector *q_vector ;
  int v_idx ;
  u32 mask ;
  u32 eitrsel ;
  struct ixgbe_ring *ring ;

  {
#line 2154
  if (adapter->num_vfs > 32U) {
#line 2155
    eitrsel = (u32 )((1 << (int )(adapter->num_vfs - 32U)) + -1);
#line 2156
    ixgbe_write_reg(& adapter->hw, 2196U, eitrsel);
  } else {

  }
#line 2163
  v_idx = 0;
#line 2163
  goto ldv_57628;
  ldv_57627: 
#line 2165
  q_vector = adapter->q_vector[v_idx];
#line 2167
  ring = q_vector->rx.ring;
#line 2167
  goto ldv_57622;
  ldv_57621: 
#line 2168
  ixgbe_set_ivar(adapter, 0, (int )ring->reg_idx, (int )((u8 )v_idx));
#line 2167
  ring = ring->next;
  ldv_57622: ;
#line 2167
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 2169
    goto ldv_57621;
  } else {

  }
#line 2170
  ring = q_vector->tx.ring;
#line 2170
  goto ldv_57625;
  ldv_57624: 
#line 2171
  ixgbe_set_ivar(adapter, 1, (int )ring->reg_idx, (int )((u8 )v_idx));
#line 2170
  ring = ring->next;
  ldv_57625: ;
#line 2170
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 2172
    goto ldv_57624;
  } else {

  }
#line 2173
  ixgbe_write_eitr(q_vector);
#line 2163
  v_idx = v_idx + 1;
  ldv_57628: ;
#line 2163
  if (adapter->num_q_vectors > v_idx) {
#line 2165
    goto ldv_57627;
  } else {

  }

#line 2176
  switch ((unsigned int )adapter->hw.mac.type) {
  case 1U: 
#line 2178
  ixgbe_set_ivar(adapter, -1, 97, (int )((u8 )v_idx));
#line 2180
  goto ldv_57631;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 2185
  ixgbe_set_ivar(adapter, -1, 1, (int )((u8 )v_idx));
#line 2186
  goto ldv_57631;
  default: ;
#line 2188
  goto ldv_57631;
  }
  ldv_57631: 
#line 2190
  ixgbe_write_reg(& adapter->hw, (u32 )(v_idx <= 23 ? (v_idx + 520) * 4 : (v_idx + 18600) * 4),
                  1950U);
#line 2193
  mask = 3222339583U;
#line 2194
  mask = mask & 2145910783U;
#line 2198
  ixgbe_write_reg(& adapter->hw, 2064U, mask);
#line 2199
  return;
}
}
#line 2223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_itr(struct ixgbe_q_vector *q_vector , struct ixgbe_ring_container *ring_container ) 
{ 
  int bytes ;
  int packets ;
  u32 timepassed_us ;
  u64 bytes_perint ;
  u8 itr_setting ;

  {
#line 2226
  bytes = (int )ring_container->total_bytes;
#line 2227
  packets = (int )ring_container->total_packets;
#line 2230
  itr_setting = ring_container->itr;
#line 2232
  if (packets == 0) {
#line 2233
    return;
  } else {

  }
#line 2241
  timepassed_us = (u32 )((int )q_vector->itr >> 2);
#line 2242
  if (timepassed_us == 0U) {
#line 2243
    return;
  } else {

  }
#line 2245
  bytes_perint = (u64 )((u32 )bytes / timepassed_us);
#line 2247
  switch ((int )itr_setting) {
  case 0: ;
#line 2249
  if (bytes_perint > 10ULL) {
#line 2250
    itr_setting = 1U;
  } else {

  }
#line 2251
  goto ldv_57652;
  case 1: ;
#line 2253
  if (bytes_perint > 20ULL) {
#line 2254
    itr_setting = 2U;
  } else
#line 2255
  if (bytes_perint <= 10ULL) {
#line 2256
    itr_setting = 0U;
  } else {

  }
#line 2257
  goto ldv_57652;
  case 2: ;
#line 2259
  if (bytes_perint <= 20ULL) {
#line 2260
    itr_setting = 1U;
  } else {

  }
#line 2261
  goto ldv_57652;
  }
  ldv_57652: 
#line 2265
  ring_container->total_bytes = 0U;
#line 2266
  ring_container->total_packets = 0U;
#line 2269
  ring_container->itr = itr_setting;
#line 2270
  return;
}
}
#line 2280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_write_eitr(struct ixgbe_q_vector *q_vector ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_hw *hw ;
  int v_idx ;
  u32 itr_reg ;

  {
#line 2282
  adapter = q_vector->adapter;
#line 2283
  hw = & adapter->hw;
#line 2284
  v_idx = (int )q_vector->v_idx;
#line 2285
  itr_reg = (u32 )q_vector->itr & 4088U;
#line 2287
  switch ((unsigned int )adapter->hw.mac.type) {
  case 1U: 
#line 2290
  itr_reg = (itr_reg << 16) | itr_reg;
#line 2291
  goto ldv_57663;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 2300
  itr_reg = itr_reg | 2147483648U;
#line 2301
  goto ldv_57663;
  default: ;
#line 2303
  goto ldv_57663;
  }
  ldv_57663: 
#line 2305
  ixgbe_write_reg(hw, (u32 )(v_idx <= 23 ? (v_idx + 520) * 4 : (v_idx + 18600) * 4),
                  itr_reg);
#line 2306
  return;
}
}
#line 2308 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_itr(struct ixgbe_q_vector *q_vector ) 
{ 
  u32 new_itr ;
  u8 current_itr ;
  u8 _max1 ;
  u8 _max2 ;

  {
#line 2310
  new_itr = (u32 )q_vector->itr;
#line 2313
  ixgbe_update_itr(q_vector, & q_vector->tx);
#line 2314
  ixgbe_update_itr(q_vector, & q_vector->rx);
#line 2316
  _max1 = q_vector->rx.itr;
#line 2316
  _max2 = q_vector->tx.itr;
#line 2316
  current_itr = (u8 )((int )_max1 > (int )_max2 ? _max1 : _max2);
#line 2318
  switch ((int )current_itr) {
  case 0: 
#line 2321
  new_itr = 40U;
#line 2322
  goto ldv_57678;
  case 1: 
#line 2324
  new_itr = 200U;
#line 2325
  goto ldv_57678;
  case 2: 
#line 2327
  new_itr = 500U;
#line 2328
  goto ldv_57678;
  default: ;
#line 2330
  goto ldv_57678;
  }
  ldv_57678: ;
#line 2333
  if ((u32 )q_vector->itr != new_itr) {
#line 2335
    new_itr = (((u32 )q_vector->itr * new_itr) * 10U) / (new_itr * 9U + (u32 )q_vector->itr);
#line 2339
    q_vector->itr = (u16 )new_itr;
#line 2341
    ixgbe_write_eitr(q_vector);
  } else {

  }
#line 2343
  return;
}
}
#line 2349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_overtemp_subtask(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 eicr ;
  int tmp ;
  u32 speed ;
  bool link_up ;
  s32 tmp___0 ;

  {
#line 2351
  hw = & adapter->hw;
#line 2352
  eicr = adapter->interrupt_event;
#line 2354
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 2354
  if (tmp != 0) {
#line 2355
    return;
  } else {

  }
#line 2357
  if ((adapter->flags2 & 4U) == 0U && (adapter->flags2 & 8U) == 0U) {
#line 2359
    return;
  } else {

  }
#line 2361
  adapter->flags2 = adapter->flags2 & 4294967287U;
#line 2363
  switch ((int )hw->device_id) {
  case 5404: ;
#line 2372
  if ((eicr & 16777216U) == 0U && (eicr & 1048576U) == 0U) {
#line 2374
    return;
  } else {

  }
#line 2376
  if ((eicr & 1048576U) == 0U && (unsigned long )hw->mac.ops.check_link != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                                                     ixgbe_link_speed * ,
                                                                                                     bool * ,
                                                                                                     bool  ))0)) {
#line 2378
    link_up = 0;
#line 2380
    (*(hw->mac.ops.check_link))(hw, & speed, & link_up, 0);
#line 2382
    if ((int )link_up) {
#line 2383
      return;
    } else {

    }
  } else {

  }
#line 2387
  tmp___0 = (*(hw->phy.ops.check_overtemp))(hw);
#line 2387
  if (tmp___0 != -26) {
#line 2388
    return;
  } else {

  }
#line 2390
  goto ldv_57690;
  default: ;
#line 2392
  if ((unsigned int )adapter->hw.mac.type > 2U) {
#line 2393
    return;
  } else {

  }
#line 2394
  if (((u32 )*(hw->mvals + 11UL) & eicr) == 0U) {
#line 2395
    return;
  } else {

  }
#line 2396
  goto ldv_57690;
  }
  ldv_57690: ;
#line 2398
  if ((int )adapter->msg_enable & 1) {
#line 2398
    netdev_crit((struct net_device  const  *)adapter->netdev, "%s\n", (char const   *)(& ixgbe_overheat_msg));
  } else {

  }
#line 2400
  adapter->interrupt_event = 0U;
#line 2401
  return;
}
}
#line 2403 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_fan_failure(struct ixgbe_adapter *adapter , u32 eicr ) 
{ 
  struct ixgbe_hw *hw ;

  {
#line 2405
  hw = & adapter->hw;
#line 2407
  if ((adapter->flags & 32768U) != 0U && ((u32 )*(hw->mvals + 12UL) & eicr) != 0U) {
#line 2409
    if (((int )adapter->msg_enable & 2) != 0) {
#line 2409
      netdev_crit((struct net_device  const  *)adapter->netdev, "Fan has stopped, replace the adapter\n");
    } else {

    }
#line 2411
    ixgbe_write_reg(hw, 2048U, *(hw->mvals + 12UL));
  } else {

  }
#line 2413
  return;
}
}
#line 2415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_overtemp_event(struct ixgbe_adapter *adapter , u32 eicr ) 
{ 
  struct ixgbe_hw *hw ;
  int tmp ;

  {
#line 2417
  hw = & adapter->hw;
#line 2419
  if ((adapter->flags2 & 4U) == 0U) {
#line 2420
    return;
  } else {

  }
#line 2422
  switch ((unsigned int )adapter->hw.mac.type) {
  case 2U: ;
#line 2428
  if (((u32 )*(hw->mvals + 11UL) & eicr) != 0U || (eicr & 1048576U) != 0U) {
#line 2428
    tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 2428
    if (tmp == 0) {
#line 2431
      adapter->interrupt_event = eicr;
#line 2432
      adapter->flags2 = adapter->flags2 | 8U;
#line 2433
      ixgbe_service_event_schedule(adapter);
#line 2434
      return;
    } else {

    }
  } else {

  }
#line 2436
  return;
  case 3U: ;
#line 2438
  if ((eicr & 8388608U) == 0U) {
#line 2439
    return;
  } else {

  }
#line 2440
  goto ldv_57704;
  default: ;
#line 2442
  return;
  }
  ldv_57704: ;
#line 2445
  if ((int )adapter->msg_enable & 1) {
#line 2445
    netdev_crit((struct net_device  const  *)adapter->netdev, "%s\n", (char const   *)(& ixgbe_overheat_msg));
  } else {

  }
#line 2446
  return;
}
}
#line 2448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_is_sfp(struct ixgbe_hw *hw ) 
{ 
  enum ixgbe_media_type tmp ;

  {
#line 2450
  switch ((unsigned int )hw->mac.type) {
  case 1U: ;
#line 2452
  if ((unsigned int )hw->phy.type == 10U) {
#line 2453
    return (1);
  } else {

  }
#line 2454
  return (0);
  case 2U: ;
  case 5U: 
#line 2457
  tmp = (*(hw->mac.ops.get_media_type))(hw);
#line 2457
  switch ((unsigned int )tmp) {
  case 1U: ;
  case 2U: ;
#line 2460
  return (1);
  default: ;
#line 2462
  return (0);
  }
  default: ;
#line 2465
  return (0);
  }
}
}
#line 2469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_sfp_event(struct ixgbe_adapter *adapter , u32 eicr ) 
{ 
  struct ixgbe_hw *hw ;
  int tmp ;
  int tmp___0 ;

  {
#line 2471
  hw = & adapter->hw;
#line 2473
  if (((u32 )*(hw->mvals + 13UL) & eicr) != 0U) {
#line 2475
    ixgbe_write_reg(hw, 2048U, *(hw->mvals + 13UL));
#line 2476
    tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 2476
    if (tmp == 0) {
#line 2477
      adapter->flags2 = adapter->flags2 | 32U;
#line 2478
      ixgbe_service_event_schedule(adapter);
    } else {

    }
  } else {

  }
#line 2482
  if (((u32 )*(hw->mvals + 12UL) & eicr) != 0U) {
#line 2484
    ixgbe_write_reg(hw, 2048U, *(hw->mvals + 12UL));
#line 2485
    tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 2485
    if (tmp___0 == 0) {
#line 2486
      adapter->flags = adapter->flags | 131072U;
#line 2487
      ixgbe_service_event_schedule(adapter);
    } else {

    }
  } else {

  }
#line 2490
  return;
}
}
#line 2492 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_lsc(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int tmp ;

  {
#line 2494
  hw = & adapter->hw;
#line 2496
  adapter->lsc_int = adapter->lsc_int + 1ULL;
#line 2497
  adapter->flags = adapter->flags | 65536U;
#line 2498
  adapter->link_check_timeout = jiffies;
#line 2499
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 2499
  if (tmp == 0) {
#line 2500
    ixgbe_write_reg(hw, 2184U, 1048576U);
#line 2501
    ixgbe_read_reg(hw, 8U);
#line 2502
    ixgbe_service_event_schedule(adapter);
  } else {

  }
#line 2504
  return;
}
}
#line 2506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_irq_enable_queues(struct ixgbe_adapter *adapter , u64 qmask ) 
{ 
  u32 mask ;
  struct ixgbe_hw *hw ;

  {
#line 2510
  hw = & adapter->hw;
#line 2512
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 2514
  mask = (u32 )qmask & 65535U;
#line 2515
  ixgbe_write_reg(hw, 2176U, mask);
#line 2516
  goto ldv_57732;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 2521
  mask = (u32 )qmask;
#line 2522
  if (mask != 0U) {
#line 2523
    ixgbe_write_reg(hw, 2720U, mask);
  } else {

  }
#line 2524
  mask = (u32 )(qmask >> 32);
#line 2525
  if (mask != 0U) {
#line 2526
    ixgbe_write_reg(hw, 2724U, mask);
  } else {

  }
#line 2527
  goto ldv_57732;
  default: ;
#line 2529
  goto ldv_57732;
  }
  ldv_57732: ;
#line 2533
  return;
}
}
#line 2534 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_irq_disable_queues(struct ixgbe_adapter *adapter , u64 qmask ) 
{ 
  u32 mask ;
  struct ixgbe_hw *hw ;

  {
#line 2538
  hw = & adapter->hw;
#line 2540
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 2542
  mask = (u32 )qmask & 65535U;
#line 2543
  ixgbe_write_reg(hw, 2184U, mask);
#line 2544
  goto ldv_57745;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 2549
  mask = (u32 )qmask;
#line 2550
  if (mask != 0U) {
#line 2551
    ixgbe_write_reg(hw, 2736U, mask);
  } else {

  }
#line 2552
  mask = (u32 )(qmask >> 32);
#line 2553
  if (mask != 0U) {
#line 2554
    ixgbe_write_reg(hw, 2740U, mask);
  } else {

  }
#line 2555
  goto ldv_57745;
  default: ;
#line 2557
  goto ldv_57745;
  }
  ldv_57745: ;
#line 2561
  return;
}
}
#line 2566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_irq_enable(struct ixgbe_adapter *adapter , bool queues ,
                                      bool flush ) 
{ 
  struct ixgbe_hw *hw ;
  u32 mask ;

  {
#line 2569
  hw = & adapter->hw;
#line 2570
  mask = 3222274048U;
#line 2573
  if ((adapter->flags & 65536U) != 0U) {
#line 2574
    mask = mask & 4293918719U;
  } else {

  }
#line 2576
  if ((adapter->flags2 & 4U) != 0U) {
#line 2577
    switch ((unsigned int )adapter->hw.mac.type) {
    case 2U: 
#line 2579
    mask = (u32 )*(hw->mvals + 11UL) | mask;
#line 2580
    goto ldv_57759;
    case 3U: ;
    case 4U: ;
    case 5U: 
#line 2584
    mask = mask | 8388608U;
#line 2585
    goto ldv_57759;
    default: ;
#line 2587
    goto ldv_57759;
    }
    ldv_57759: ;
  } else {

  }
#line 2589
  if ((adapter->flags & 32768U) != 0U) {
#line 2590
    mask = (u32 )*(hw->mvals + 12UL) | mask;
  } else {

  }
#line 2591
  switch ((unsigned int )adapter->hw.mac.type) {
  case 2U: 
#line 2593
  mask = (u32 )*(hw->mvals + 12UL) | mask;
#line 2594
  mask = (u32 )*(hw->mvals + 13UL) | mask;
  case 3U: ;
  case 4U: ;
  case 5U: ;
#line 2599
  if ((unsigned int )adapter->hw.phy.type == 6U) {
#line 2600
    mask = mask | 33554432U;
  } else {

  }
#line 2601
  mask = mask | 268435456U;
#line 2602
  mask = mask | 524288U;
#line 2603
  goto ldv_57768;
  default: ;
#line 2605
  goto ldv_57768;
  }
  ldv_57768: ;
#line 2608
  if ((adapter->flags & 262144U) != 0U && (adapter->flags2 & 128U) == 0U) {
#line 2610
    mask = mask | 65536U;
  } else {

  }
#line 2612
  ixgbe_write_reg(& adapter->hw, 2176U, mask);
#line 2613
  if ((int )queues) {
#line 2614
    ixgbe_irq_enable_queues(adapter, 0xffffffffffffffffULL);
  } else {

  }
#line 2615
  if ((int )flush) {
#line 2616
    ixgbe_read_reg(& adapter->hw, 8U);
  } else {

  }
#line 2617
  return;
}
}
#line 2619 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static irqreturn_t ixgbe_msix_other(int irq , void *data ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_hw *hw ;
  u32 eicr ;
  int reinit_count ;
  int i ;
  struct ixgbe_ring *ring ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 2621
  adapter = (struct ixgbe_adapter *)data;
#line 2622
  hw = & adapter->hw;
#line 2631
  eicr = ixgbe_read_reg(hw, 2056U);
#line 2640
  eicr = eicr & 4294901760U;
#line 2642
  ixgbe_write_reg(hw, 2048U, eicr);
#line 2644
  if ((eicr & 1048576U) != 0U) {
#line 2645
    ixgbe_check_lsc(adapter);
  } else {

  }
#line 2647
  if ((eicr & 524288U) != 0U) {
#line 2648
    ixgbe_msg_task(adapter);
  } else {

  }
#line 2650
  switch ((unsigned int )hw->mac.type) {
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: ;
#line 2655
  if ((unsigned int )hw->phy.type == 6U && (eicr & 33554432U) != 0U) {
#line 2657
    adapter->flags2 = adapter->flags2 | 2048U;
#line 2658
    ixgbe_service_event_schedule(adapter);
#line 2659
    ixgbe_write_reg(hw, 2048U, 33554432U);
  } else {

  }
#line 2662
  if ((eicr & 268435456U) != 0U) {
#line 2663
    if (((int )adapter->msg_enable & 4) != 0) {
#line 2663
      netdev_info((struct net_device  const  *)adapter->netdev, "Received ECC Err, initiating reset\n");
    } else {

    }
#line 2664
    adapter->flags2 = adapter->flags2 | 64U;
#line 2665
    ixgbe_service_event_schedule(adapter);
#line 2666
    ixgbe_write_reg(hw, 2048U, 268435456U);
  } else {

  }
#line 2669
  if ((eicr & 65536U) != 0U) {
#line 2670
    reinit_count = 0;
#line 2672
    i = 0;
#line 2672
    goto ldv_57785;
    ldv_57784: 
#line 2673
    ring = adapter->tx_ring[i];
#line 2674
    tmp = test_and_clear_bit(0L, (unsigned long volatile   *)(& ring->state));
#line 2674
    if (tmp != 0) {
#line 2676
      reinit_count = reinit_count + 1;
    } else {

    }
#line 2672
    i = i + 1;
    ldv_57785: ;
#line 2672
    if (adapter->num_tx_queues > i) {
#line 2674
      goto ldv_57784;
    } else {

    }

#line 2678
    if (reinit_count != 0) {
#line 2680
      ixgbe_write_reg(hw, 2184U, 65536U);
#line 2681
      adapter->flags2 = adapter->flags2 | 128U;
#line 2682
      ixgbe_service_event_schedule(adapter);
    } else {

    }
  } else {

  }
#line 2685
  ixgbe_check_sfp_event(adapter, eicr);
#line 2686
  ixgbe_check_overtemp_event(adapter, eicr);
#line 2687
  goto ldv_57787;
  default: ;
#line 2689
  goto ldv_57787;
  }
  ldv_57787: 
#line 2692
  ixgbe_check_fan_failure(adapter, eicr);
#line 2694
  tmp___0 = ldv__builtin_expect((eicr & 16777216U) != 0U, 0L);
#line 2694
  if (tmp___0 != 0L) {
#line 2695
    ixgbe_ptp_check_pps_event(adapter, eicr);
  } else {

  }
#line 2698
  tmp___1 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 2698
  if (tmp___1 == 0) {
#line 2699
    ixgbe_irq_enable(adapter, 0, 0);
  } else {

  }
#line 2701
  return (1);
}
}
#line 2704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static irqreturn_t ixgbe_msix_clean_rings(int irq , void *data ) 
{ 
  struct ixgbe_q_vector *q_vector ;

  {
#line 2706
  q_vector = (struct ixgbe_q_vector *)data;
#line 2710
  if ((unsigned long )q_vector->rx.ring != (unsigned long )((struct ixgbe_ring *)0) || (unsigned long )q_vector->tx.ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 2711
    napi_schedule(& q_vector->napi);
  } else {

  }
#line 2713
  return (1);
}
}
#line 2723 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_poll(struct napi_struct *napi , int budget ) 
{ 
  struct ixgbe_q_vector *q_vector ;
  struct napi_struct  const  *__mptr ;
  struct ixgbe_adapter *adapter ;
  struct ixgbe_ring *ring ;
  int per_ring_budget ;
  bool clean_complete ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int _max1 ;
  int _max2 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2726
  __mptr = (struct napi_struct  const  *)napi;
#line 2726
  q_vector = (struct ixgbe_q_vector *)__mptr + 0xffffffffffffffc0UL;
#line 2727
  adapter = q_vector->adapter;
#line 2730
  clean_complete = 1;
#line 2733
  if ((adapter->flags & 256U) != 0U) {
#line 2734
    ixgbe_update_dca(q_vector);
  } else {

  }
#line 2737
  ring = q_vector->tx.ring;
#line 2737
  goto ldv_57806;
  ldv_57805: 
#line 2738
  tmp = ixgbe_clean_tx_irq(q_vector, ring);
#line 2738
  clean_complete = ((int )clean_complete & (int )tmp) != 0;
#line 2737
  ring = ring->next;
  ldv_57806: ;
#line 2737
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 2739
    goto ldv_57805;
  } else {

  }
#line 2740
  tmp___0 = ixgbe_qv_lock_napi(q_vector);
#line 2740
  if (tmp___0) {
#line 2740
    tmp___1 = 0;
  } else {
#line 2740
    tmp___1 = 1;
  }
#line 2740
  if (tmp___1) {
#line 2741
    return (budget);
  } else {

  }
#line 2745
  if ((unsigned int )q_vector->rx.count > 1U) {
#line 2746
    _max1 = budget / (int )q_vector->rx.count;
#line 2746
    _max2 = 1;
#line 2746
    per_ring_budget = _max1 > _max2 ? _max1 : _max2;
  } else {
#line 2748
    per_ring_budget = budget;
  }
#line 2750
  ring = q_vector->rx.ring;
#line 2750
  goto ldv_57812;
  ldv_57811: 
#line 2751
  tmp___2 = ixgbe_clean_rx_irq(q_vector, ring, per_ring_budget);
#line 2751
  clean_complete = ((int )clean_complete & (tmp___2 < per_ring_budget)) != 0;
#line 2750
  ring = ring->next;
  ldv_57812: ;
#line 2750
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 2752
    goto ldv_57811;
  } else {

  }
#line 2754
  ixgbe_qv_unlock_napi(q_vector);
#line 2756
  if (! clean_complete) {
#line 2757
    return (budget);
  } else {

  }
#line 2760
  napi_complete(napi);
#line 2761
  if ((int )adapter->rx_itr_setting & 1) {
#line 2762
    ixgbe_set_itr(q_vector);
  } else {

  }
#line 2763
  tmp___3 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 2763
  if (tmp___3 == 0) {
#line 2764
    ixgbe_irq_enable_queues(adapter, 1ULL << (int )q_vector->v_idx);
  } else {

  }
#line 2766
  return (0);
}
}
#line 2776 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_request_msix_irqs(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int vector ;
  int err ;
  int ri ;
  int ti ;
  struct ixgbe_q_vector *q_vector ;
  struct msix_entry *entry ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2778
  netdev = adapter->netdev;
#line 2780
  ri = 0;
#line 2780
  ti = 0;
#line 2782
  vector = 0;
#line 2782
  goto ldv_57827;
  ldv_57826: 
#line 2783
  q_vector = adapter->q_vector[vector];
#line 2784
  entry = adapter->msix_entries + (unsigned long )vector;
#line 2786
  if ((unsigned long )q_vector->tx.ring != (unsigned long )((struct ixgbe_ring *)0) && (unsigned long )q_vector->rx.ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 2787
    tmp = ri;
#line 2787
    ri = ri + 1;
#line 2787
    snprintf((char *)(& q_vector->name), 24UL, "%s-%s-%d", (char *)(& netdev->name),
             (char *)"TxRx", tmp);
#line 2789
    ti = ti + 1;
  } else
#line 2790
  if ((unsigned long )q_vector->rx.ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 2791
    tmp___0 = ri;
#line 2791
    ri = ri + 1;
#line 2791
    snprintf((char *)(& q_vector->name), 24UL, "%s-%s-%d", (char *)(& netdev->name),
             (char *)"rx", tmp___0);
  } else
#line 2793
  if ((unsigned long )q_vector->tx.ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 2794
    tmp___1 = ti;
#line 2794
    ti = ti + 1;
#line 2794
    snprintf((char *)(& q_vector->name), 24UL, "%s-%s-%d", (char *)(& netdev->name),
             (char *)"tx", tmp___1);
  } else {
#line 2798
    goto ldv_57824;
  }
#line 2800
  err = ldv_request_irq_17(entry->vector, & ixgbe_msix_clean_rings, 0UL, (char const   *)(& q_vector->name),
                           (void *)q_vector);
#line 2802
  if (err != 0) {
#line 2803
    if (((int )adapter->msg_enable & 2) != 0) {
#line 2804
      netdev_err((struct net_device  const  *)adapter->netdev, "request_irq failed for MSIX interrupt Error: %d\n",
                 err);
    } else {

    }
#line 2805
    goto free_queue_irqs;
  } else {

  }
#line 2808
  if ((adapter->flags & 262144U) != 0U) {
#line 2810
    irq_set_affinity_hint(entry->vector, (struct cpumask  const  *)(& q_vector->affinity_mask));
  } else {

  }
  ldv_57824: 
#line 2782
  vector = vector + 1;
  ldv_57827: ;
#line 2782
  if (adapter->num_q_vectors > vector) {
#line 2784
    goto ldv_57826;
  } else {

  }
#line 2815
  err = ldv_request_irq_18((adapter->msix_entries + (unsigned long )vector)->vector,
                           & ixgbe_msix_other, 0UL, (char const   *)(& netdev->name),
                           (void *)adapter);
#line 2817
  if (err != 0) {
#line 2818
    if (((int )adapter->msg_enable & 2) != 0) {
#line 2818
      netdev_err((struct net_device  const  *)adapter->netdev, "request_irq for msix_other failed: %d\n",
                 err);
    } else {

    }
#line 2819
    goto free_queue_irqs;
  } else {

  }
#line 2822
  return (0);
  free_queue_irqs: ;
#line 2825
  goto ldv_57830;
  ldv_57829: 
#line 2826
  vector = vector - 1;
#line 2827
  irq_set_affinity_hint((adapter->msix_entries + (unsigned long )vector)->vector,
                        (struct cpumask  const  *)0);
#line 2829
  ldv_free_irq_19((adapter->msix_entries + (unsigned long )vector)->vector, (void *)adapter->q_vector[vector]);
  ldv_57830: ;
#line 2825
  if (vector != 0) {
#line 2827
    goto ldv_57829;
  } else {

  }
#line 2832
  adapter->flags = adapter->flags & 4294967287U;
#line 2833
  pci_disable_msix(adapter->pdev);
#line 2834
  kfree((void const   *)adapter->msix_entries);
#line 2835
  adapter->msix_entries = (struct msix_entry *)0;
#line 2836
  return (err);
}
}
#line 2844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static irqreturn_t ixgbe_intr(int irq , void *data ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_hw *hw ;
  struct ixgbe_q_vector *q_vector ;
  u32 eicr ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 2846
  adapter = (struct ixgbe_adapter *)data;
#line 2847
  hw = & adapter->hw;
#line 2848
  q_vector = adapter->q_vector[0];
#line 2855
  ixgbe_write_reg(hw, 2184U, 4294967295U);
#line 2859
  eicr = ixgbe_read_reg(hw, 2048U);
#line 2860
  if (eicr == 0U) {
#line 2868
    tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 2868
    if (tmp == 0) {
#line 2869
      ixgbe_irq_enable(adapter, 1, 1);
    } else {

    }
#line 2870
    return (0);
  } else {

  }
#line 2873
  if ((eicr & 1048576U) != 0U) {
#line 2874
    ixgbe_check_lsc(adapter);
  } else {

  }
#line 2876
  switch ((unsigned int )hw->mac.type) {
  case 2U: 
#line 2878
  ixgbe_check_sfp_event(adapter, eicr);
  case 3U: ;
  case 4U: ;
  case 5U: ;
#line 2883
  if ((eicr & 268435456U) != 0U) {
#line 2884
    if (((int )adapter->msg_enable & 4) != 0) {
#line 2884
      netdev_info((struct net_device  const  *)adapter->netdev, "Received ECC Err, initiating reset\n");
    } else {

    }
#line 2885
    adapter->flags2 = adapter->flags2 | 64U;
#line 2886
    ixgbe_service_event_schedule(adapter);
#line 2887
    ixgbe_write_reg(hw, 2048U, 268435456U);
  } else {

  }
#line 2889
  ixgbe_check_overtemp_event(adapter, eicr);
#line 2890
  goto ldv_57844;
  default: ;
#line 2892
  goto ldv_57844;
  }
  ldv_57844: 
#line 2895
  ixgbe_check_fan_failure(adapter, eicr);
#line 2896
  tmp___0 = ldv__builtin_expect((eicr & 16777216U) != 0U, 0L);
#line 2896
  if (tmp___0 != 0L) {
#line 2897
    ixgbe_ptp_check_pps_event(adapter, eicr);
  } else {

  }
#line 2900
  napi_schedule(& q_vector->napi);
#line 2906
  tmp___1 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 2906
  if (tmp___1 == 0) {
#line 2907
    ixgbe_irq_enable(adapter, 0, 0);
  } else {

  }
#line 2909
  return (1);
}
}
#line 2919 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_request_irq(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int err ;

  {
#line 2921
  netdev = adapter->netdev;
#line 2924
  if ((adapter->flags & 8U) != 0U) {
#line 2925
    err = ixgbe_request_msix_irqs(adapter);
  } else
#line 2926
  if ((adapter->flags & 2U) != 0U) {
#line 2927
    err = ldv_request_irq_20((adapter->pdev)->irq, & ixgbe_intr, 0UL, (char const   *)(& netdev->name),
                             (void *)adapter);
  } else {
#line 2930
    err = ldv_request_irq_21((adapter->pdev)->irq, & ixgbe_intr, 128UL, (char const   *)(& netdev->name),
                             (void *)adapter);
  }
#line 2933
  if (err != 0) {
#line 2934
    if (((int )adapter->msg_enable & 2) != 0) {
#line 2934
      netdev_err((struct net_device  const  *)adapter->netdev, "request_irq failed, Error %d\n",
                 err);
    } else {

    }
  } else {

  }
#line 2936
  return (err);
}
}
#line 2939 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_free_irq(struct ixgbe_adapter *adapter ) 
{ 
  int vector ;
  struct ixgbe_q_vector *q_vector ;
  struct msix_entry *entry ;
  int tmp ;

  {
#line 2943
  if ((adapter->flags & 8U) == 0U) {
#line 2944
    ldv_free_irq_22((adapter->pdev)->irq, (void *)adapter);
#line 2945
    return;
  } else {

  }
#line 2948
  vector = 0;
#line 2948
  goto ldv_57859;
  ldv_57858: 
#line 2949
  q_vector = adapter->q_vector[vector];
#line 2950
  entry = adapter->msix_entries + (unsigned long )vector;
#line 2953
  if ((unsigned long )q_vector->rx.ring == (unsigned long )((struct ixgbe_ring *)0) && (unsigned long )q_vector->tx.ring == (unsigned long )((struct ixgbe_ring *)0)) {
#line 2954
    goto ldv_57857;
  } else {

  }
#line 2957
  irq_set_affinity_hint(entry->vector, (struct cpumask  const  *)0);
#line 2959
  ldv_free_irq_23(entry->vector, (void *)q_vector);
  ldv_57857: 
#line 2948
  vector = vector + 1;
  ldv_57859: ;
#line 2948
  if (adapter->num_q_vectors > vector) {
#line 2950
    goto ldv_57858;
  } else {

  }
#line 2962
  tmp = vector;
#line 2962
  vector = vector + 1;
#line 2962
  ldv_free_irq_24((adapter->msix_entries + (unsigned long )tmp)->vector, (void *)adapter);
#line 2963
  return;
}
}
#line 2969 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_irq_disable(struct ixgbe_adapter *adapter ) 
{ 
  int vector ;
  int tmp ;

  {
#line 2971
  switch ((unsigned int )adapter->hw.mac.type) {
  case 1U: 
#line 2973
  ixgbe_write_reg(& adapter->hw, 2184U, 4294967295U);
#line 2974
  goto ldv_57865;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 2979
  ixgbe_write_reg(& adapter->hw, 2184U, 4294901760U);
#line 2980
  ixgbe_write_reg(& adapter->hw, 2736U, 4294967295U);
#line 2981
  ixgbe_write_reg(& adapter->hw, 2740U, 4294967295U);
#line 2982
  goto ldv_57865;
  default: ;
#line 2984
  goto ldv_57865;
  }
  ldv_57865: 
#line 2986
  ixgbe_read_reg(& adapter->hw, 8U);
#line 2987
  if ((adapter->flags & 8U) != 0U) {
#line 2990
    vector = 0;
#line 2990
    goto ldv_57873;
    ldv_57872: 
#line 2991
    synchronize_irq((adapter->msix_entries + (unsigned long )vector)->vector);
#line 2990
    vector = vector + 1;
    ldv_57873: ;
#line 2990
    if (adapter->num_q_vectors > vector) {
#line 2992
      goto ldv_57872;
    } else {

    }
#line 2993
    tmp = vector;
#line 2993
    vector = vector + 1;
#line 2993
    synchronize_irq((adapter->msix_entries + (unsigned long )tmp)->vector);
  } else {
#line 2995
    synchronize_irq((adapter->pdev)->irq);
  }
#line 2996
  return;
}
}
#line 3003 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_msi_and_legacy(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_q_vector *q_vector ;

  {
#line 3005
  q_vector = adapter->q_vector[0];
#line 3007
  ixgbe_write_eitr(q_vector);
#line 3009
  ixgbe_set_ivar(adapter, 0, 0, 0);
#line 3010
  ixgbe_set_ivar(adapter, 1, 0, 0);
#line 3012
  if (((int )adapter->msg_enable & 8192) != 0) {
#line 3012
    netdev_info((struct net_device  const  *)adapter->netdev, "Legacy interrupt IVAR setup done\n");
  } else {

  }
#line 3013
  return;
}
}
#line 3022 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_hw *hw ;
  u64 tdba ;
  int wait_loop ;
  u32 txdctl ;
  u8 reg_idx ;
  struct ixgbe_q_vector *q_vector ;
  int tmp ;
  u32 tmp___0 ;

  {
#line 3025
  hw = & adapter->hw;
#line 3026
  tdba = ring->dma;
#line 3027
  wait_loop = 10;
#line 3028
  txdctl = 33554432U;
#line 3029
  reg_idx = ring->reg_idx;
#line 3032
  ixgbe_write_reg(hw, (u32 )((int )reg_idx * 64 + 24616), 0U);
#line 3033
  ixgbe_read_reg(hw, 8U);
#line 3035
  ixgbe_write_reg(hw, (u32 )(((int )reg_idx + 384) * 64), (u32 )tdba);
#line 3037
  ixgbe_write_reg(hw, (u32 )((int )reg_idx * 64 + 24580), (u32 )(tdba >> 32));
#line 3038
  ixgbe_write_reg(hw, (u32 )((int )reg_idx * 64 + 24584), (u32 )ring->count * 16U);
#line 3040
  ixgbe_write_reg(hw, (u32 )((int )reg_idx * 64 + 24592), 0U);
#line 3041
  ixgbe_write_reg(hw, (u32 )((int )reg_idx * 64 + 24600), 0U);
#line 3042
  ring->tail = adapter->io_addr + (unsigned long )((int )reg_idx * 64 + 24600);
#line 3054
  if ((unsigned long )ring->q_vector == (unsigned long )((struct ixgbe_q_vector *)0) || (unsigned int )(ring->q_vector)->itr <= 39U) {
#line 3055
    txdctl = txdctl | 65536U;
  } else {
#line 3057
    txdctl = txdctl | 524288U;
  }
#line 3063
  txdctl = txdctl | 288U;
#line 3067
  if ((adapter->flags & 262144U) != 0U) {
#line 3068
    ring->__annonCompField120.__annonCompField119.atr_sample_rate = (u8 )adapter->atr_sample_rate;
#line 3069
    ring->__annonCompField120.__annonCompField119.atr_count = 0U;
#line 3070
    set_bit(0L, (unsigned long volatile   *)(& ring->state));
  } else {
#line 3072
    ring->__annonCompField120.__annonCompField119.atr_sample_rate = 0U;
  }
#line 3076
  tmp = test_and_set_bit(1L, (unsigned long volatile   *)(& ring->state));
#line 3076
  if (tmp == 0) {
#line 3077
    q_vector = ring->q_vector;
#line 3079
    if ((unsigned long )q_vector != (unsigned long )((struct ixgbe_q_vector *)0)) {
#line 3080
      netif_set_xps_queue(ring->netdev, (struct cpumask  const  *)(& q_vector->affinity_mask),
                          (int )ring->queue_index);
    } else {

    }
  } else {

  }
#line 3085
  clear_bit(3L, (unsigned long volatile   *)(& ring->state));
#line 3088
  ixgbe_write_reg(hw, (u32 )((int )reg_idx * 64 + 24616), txdctl);
#line 3091
  if ((unsigned int )hw->mac.type == 1U) {
#line 3091
    tmp___0 = ixgbe_read_reg(hw, 17060U);
#line 3091
    if ((tmp___0 & 1073741824U) == 0U) {
#line 3093
      return;
    } else {

    }
  } else {

  }
  ldv_57889: 
#line 3097
  usleep_range(1000UL, 2000UL);
#line 3098
  txdctl = ixgbe_read_reg(hw, (u32 )((int )reg_idx * 64 + 24616));
#line 3099
  wait_loop = wait_loop - 1;
#line 3099
  if (wait_loop != 0 && (txdctl & 33554432U) == 0U) {
#line 3101
    goto ldv_57889;
  } else {

  }

#line 3100
  if (wait_loop == 0) {
#line 3101
    if ((int )adapter->msg_enable & 1) {
#line 3101
      netdev_err((struct net_device  const  *)adapter->netdev, "Could not enable Tx Queue %d\n",
                 (int )reg_idx);
    } else {

    }
  } else {

  }
#line 3102
  return;
}
}
#line 3104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 rttdcs ;
  u32 mtqc ;
  u8 tcs ;
  int tmp ;
  u32 sectx ;
  u32 tmp___0 ;

  {
#line 3106
  hw = & adapter->hw;
#line 3108
  tmp = netdev_get_num_tc(adapter->netdev);
#line 3108
  tcs = (u8 )tmp;
#line 3110
  if ((unsigned int )hw->mac.type == 1U) {
#line 3111
    return;
  } else {

  }
#line 3114
  rttdcs = ixgbe_read_reg(hw, 18688U);
#line 3115
  rttdcs = rttdcs | 64U;
#line 3116
  ixgbe_write_reg(hw, 18688U, rttdcs);
#line 3119
  if ((adapter->flags & 8388608U) != 0U) {
#line 3120
    mtqc = 2U;
#line 3121
    if ((unsigned int )tcs > 4U) {
#line 3122
      mtqc = mtqc | 13U;
    } else
#line 3123
    if ((unsigned int )tcs > 1U) {
#line 3124
      mtqc = mtqc | 9U;
    } else
#line 3125
    if ((unsigned int )adapter->ring_feature[2].indices == 4U) {
#line 3126
      mtqc = mtqc | 8U;
    } else {
#line 3128
      mtqc = mtqc | 4U;
    }
  } else
#line 3130
  if ((unsigned int )tcs > 4U) {
#line 3131
    mtqc = 13U;
  } else
#line 3132
  if ((unsigned int )tcs > 1U) {
#line 3133
    mtqc = 9U;
  } else {
#line 3135
    mtqc = 0U;
  }
#line 3138
  ixgbe_write_reg(hw, 33056U, mtqc);
#line 3141
  if ((unsigned int )tcs != 0U) {
#line 3142
    tmp___0 = ixgbe_read_reg(hw, 34832U);
#line 3142
    sectx = tmp___0;
#line 3143
    sectx = sectx | 7936U;
#line 3144
    ixgbe_write_reg(hw, 34832U, sectx);
  } else {

  }
#line 3148
  rttdcs = rttdcs & 4294967231U;
#line 3149
  ixgbe_write_reg(hw, 18688U, rttdcs);
#line 3150
  return;
}
}
#line 3158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_tx(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 dmatxctl ;
  u32 i ;

  {
#line 3160
  hw = & adapter->hw;
#line 3164
  ixgbe_setup_mtqc(adapter);
#line 3166
  if ((unsigned int )hw->mac.type != 1U) {
#line 3168
    dmatxctl = ixgbe_read_reg(hw, 19072U);
#line 3169
    dmatxctl = dmatxctl | 1U;
#line 3170
    ixgbe_write_reg(hw, 19072U, dmatxctl);
  } else {

  }
#line 3174
  i = 0U;
#line 3174
  goto ldv_57906;
  ldv_57905: 
#line 3175
  ixgbe_configure_tx_ring(adapter, adapter->tx_ring[i]);
#line 3174
  i = i + 1U;
  ldv_57906: ;
#line 3174
  if ((u32 )adapter->num_tx_queues > i) {
#line 3176
    goto ldv_57905;
  } else {

  }

#line 3181
  return;
}
}
#line 3178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_enable_rx_drop(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_hw *hw ;
  u8 reg_idx ;
  u32 srrctl ;
  u32 tmp ;

  {
#line 3181
  hw = & adapter->hw;
#line 3182
  reg_idx = ring->reg_idx;
#line 3183
  tmp = ixgbe_read_reg(hw, (u32 )((unsigned int )reg_idx <= 15U ? ((int )reg_idx + 2112) * 4 : ((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4116 : ((int )reg_idx + -64) * 64 + 53268)));
#line 3183
  srrctl = tmp;
#line 3185
  srrctl = srrctl | 268435456U;
#line 3187
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 15U ? ((int )reg_idx + 2112) * 4 : ((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4116 : ((int )reg_idx + -64) * 64 + 53268)),
                  srrctl);
#line 3188
  return;
}
}
#line 3190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_disable_rx_drop(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_hw *hw ;
  u8 reg_idx ;
  u32 srrctl ;
  u32 tmp ;

  {
#line 3193
  hw = & adapter->hw;
#line 3194
  reg_idx = ring->reg_idx;
#line 3195
  tmp = ixgbe_read_reg(hw, (u32 )((unsigned int )reg_idx <= 15U ? ((int )reg_idx + 2112) * 4 : ((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4116 : ((int )reg_idx + -64) * 64 + 53268)));
#line 3195
  srrctl = tmp;
#line 3197
  srrctl = srrctl & 4026531839U;
#line 3199
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 15U ? ((int )reg_idx + 2112) * 4 : ((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4116 : ((int )reg_idx + -64) * 64 + 53268)),
                  srrctl);
#line 3200
  return;
}
}
#line 3203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_set_rx_drop_en(struct ixgbe_adapter *adapter ) 
{ 
  int i ;
  bool pfc_en ;

  {
#line 3209
  pfc_en = adapter->dcb_cfg.pfc_mode_enable;
#line 3211
  if ((unsigned long )adapter->ixgbe_ieee_pfc != (unsigned long )((struct ieee_pfc *)0)) {
#line 3212
    pfc_en = ((int )pfc_en | ((unsigned int )(adapter->ixgbe_ieee_pfc)->pfc_en != 0U)) != 0;
  } else {

  }
#line 3223
  if (adapter->num_vfs != 0U || ((adapter->num_rx_queues > 1 && ((unsigned int )adapter->hw.fc.current_mode & 2U) == 0U) && ! pfc_en)) {
#line 3225
    i = 0;
#line 3225
    goto ldv_57928;
    ldv_57927: 
#line 3226
    ixgbe_enable_rx_drop(adapter, adapter->rx_ring[i]);
#line 3225
    i = i + 1;
    ldv_57928: ;
#line 3225
    if (adapter->num_rx_queues > i) {
#line 3227
      goto ldv_57927;
    } else {

    }

  } else {
#line 3228
    i = 0;
#line 3228
    goto ldv_57931;
    ldv_57930: 
#line 3229
    ixgbe_disable_rx_drop(adapter, adapter->rx_ring[i]);
#line 3228
    i = i + 1;
    ldv_57931: ;
#line 3228
    if (adapter->num_rx_queues > i) {
#line 3230
      goto ldv_57930;
    } else {

    }

  }
#line 3236
  return;
}
}
#line 3235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_srrctl(struct ixgbe_adapter *adapter , struct ixgbe_ring *rx_ring ) 
{ 
  struct ixgbe_hw *hw ;
  u32 srrctl ;
  u8 reg_idx ;
  u16 mask ;
  unsigned int tmp ;

  {
#line 3238
  hw = & adapter->hw;
#line 3240
  reg_idx = rx_ring->reg_idx;
#line 3242
  if ((unsigned int )hw->mac.type == 1U) {
#line 3243
    mask = adapter->ring_feature[2].mask;
#line 3249
    reg_idx = (int )((u8 )mask) & (int )reg_idx;
  } else {

  }
#line 3253
  srrctl = 1024U;
#line 3256
  tmp = ixgbe_rx_bufsz(rx_ring);
#line 3256
  srrctl = (tmp >> 10) | srrctl;
#line 3259
  srrctl = srrctl | 33554432U;
#line 3261
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 15U ? ((int )reg_idx + 2112) * 4 : ((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4116 : ((int )reg_idx + -64) * 64 + 53268)),
                  srrctl);
#line 3262
  return;
}
}
#line 3273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
u32 ixgbe_rss_indir_tbl_entries(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 3275
  if ((unsigned int )adapter->hw.mac.type <= 3U) {
#line 3276
    return (128U);
  } else
#line 3277
  if ((adapter->flags & 8388608U) != 0U) {
#line 3278
    return (64U);
  } else {
#line 3280
    return (512U);
  }
}
}
#line 3290 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_store_reta(struct ixgbe_adapter *adapter ) 
{ 
  u32 i ;
  u32 reta_entries ;
  u32 tmp ;
  struct ixgbe_hw *hw ;
  u32 reta ;
  u32 indices_multi ;
  u8 *indir_tbl ;

  {
#line 3292
  tmp = ixgbe_rss_indir_tbl_entries(adapter);
#line 3292
  reta_entries = tmp;
#line 3293
  hw = & adapter->hw;
#line 3294
  reta = 0U;
#line 3296
  indir_tbl = (u8 *)(& adapter->rss_indir_tbl);
#line 3304
  if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 3305
    indices_multi = 17U;
  } else {
#line 3307
    indices_multi = 1U;
  }
#line 3310
  i = 0U;
#line 3310
  goto ldv_57954;
  ldv_57953: 
#line 3311
  reta = ((u32 )*(indir_tbl + (unsigned long )i) * indices_multi << (int )((i & 3U) * 8U)) | reta;
#line 3312
  if ((i & 3U) == 3U) {
#line 3313
    if (i <= 127U) {
#line 3314
      ixgbe_write_reg(hw, ((i >> 2) + 5888U) * 4U, reta);
    } else {
#line 3316
      ixgbe_write_reg(hw, ((i >> 2) + 15232U) * 4U, reta);
    }
#line 3318
    reta = 0U;
  } else {

  }
#line 3310
  i = i + 1U;
  ldv_57954: ;
#line 3310
  if (i < reta_entries) {
#line 3312
    goto ldv_57953;
  } else {

  }

#line 3317
  return;
}
}
#line 3330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_store_vfreta(struct ixgbe_adapter *adapter ) 
{ 
  u32 i ;
  u32 reta_entries ;
  u32 tmp ;
  struct ixgbe_hw *hw ;
  u32 vfreta ;
  unsigned int pf_pool ;

  {
#line 3332
  tmp = ixgbe_rss_indir_tbl_entries(adapter);
#line 3332
  reta_entries = tmp;
#line 3333
  hw = & adapter->hw;
#line 3334
  vfreta = 0U;
#line 3335
  pf_pool = adapter->num_vfs;
#line 3338
  i = 0U;
#line 3338
  goto ldv_57965;
  ldv_57964: 
#line 3339
  vfreta = ((unsigned int )adapter->rss_indir_tbl[i] << (int )((i & 3U) * 8U)) | vfreta;
#line 3340
  if ((i & 3U) == 3U) {
#line 3341
    ixgbe_write_reg(hw, (((i >> 2) + pf_pool * 16U) + 25600U) * 4U, vfreta);
#line 3343
    vfreta = 0U;
  } else {

  }
#line 3338
  i = i + 1U;
  ldv_57965: ;
#line 3338
  if (i < reta_entries) {
#line 3340
    goto ldv_57964;
  } else {

  }

#line 3345
  return;
}
}
#line 3348 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_reta(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 i ;
  u32 j ;
  u32 reta_entries ;
  u32 tmp ;
  u16 rss_i ;

  {
#line 3350
  hw = & adapter->hw;
#line 3352
  tmp = ixgbe_rss_indir_tbl_entries(adapter);
#line 3352
  reta_entries = tmp;
#line 3353
  rss_i = adapter->ring_feature[2].indices;
#line 3359
  if ((adapter->flags & 8388608U) != 0U && (unsigned int )rss_i <= 1U) {
#line 3360
    rss_i = 2U;
  } else {

  }
#line 3363
  i = 0U;
#line 3363
  goto ldv_57976;
  ldv_57975: 
#line 3364
  ixgbe_write_reg(hw, (i + 5920U) * 4U, adapter->rss_key[i]);
#line 3363
  i = i + 1U;
  ldv_57976: ;
#line 3363
  if (i <= 9U) {
#line 3365
    goto ldv_57975;
  } else {

  }
#line 3367
  memset((void *)(& adapter->rss_indir_tbl), 0, 512UL);
#line 3369
  i = 0U;
#line 3369
  j = 0U;
#line 3369
  goto ldv_57979;
  ldv_57978: ;
#line 3370
  if ((u32 )rss_i == j) {
#line 3371
    j = 0U;
  } else {

  }
#line 3373
  adapter->rss_indir_tbl[i] = (u8 )j;
#line 3369
  i = i + 1U;
#line 3369
  j = j + 1U;
  ldv_57979: ;
#line 3369
  if (i < reta_entries) {
#line 3371
    goto ldv_57978;
  } else {

  }
#line 3376
  ixgbe_store_reta(adapter);
#line 3377
  return;
}
}
#line 3379 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_vfreta(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u16 rss_i ;
  unsigned int pf_pool ;
  int i ;
  int j ;

  {
#line 3381
  hw = & adapter->hw;
#line 3382
  rss_i = adapter->ring_feature[2].indices;
#line 3383
  pf_pool = adapter->num_vfs;
#line 3387
  i = 0;
#line 3387
  goto ldv_57990;
  ldv_57989: 
#line 3388
  ixgbe_write_reg(hw, ((pf_pool * 16U + (unsigned int )i) + 24576U) * 4U, adapter->rss_key[i]);
#line 3387
  i = i + 1;
  ldv_57990: ;
#line 3387
  if (i <= 9) {
#line 3389
    goto ldv_57989;
  } else {

  }
#line 3392
  i = 0;
#line 3392
  j = 0;
#line 3392
  goto ldv_57993;
  ldv_57992: ;
#line 3393
  if ((int )rss_i == j) {
#line 3394
    j = 0;
  } else {

  }
#line 3396
  adapter->rss_indir_tbl[i] = (u8 )j;
#line 3392
  i = i + 1;
#line 3392
  j = j + 1;
  ldv_57993: ;
#line 3392
  if (i <= 63) {
#line 3394
    goto ldv_57992;
  } else {

  }
#line 3399
  ixgbe_store_vfreta(adapter);
#line 3400
  return;
}
}
#line 3402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_mrqc(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 mrqc ;
  u32 rss_field ;
  u32 vfmrqc ;
  u32 rxcsum ;
  u8 tcs ;
  int tmp ;
  unsigned int pf_pool ;

  {
#line 3404
  hw = & adapter->hw;
#line 3405
  mrqc = 0U;
#line 3405
  rss_field = 0U;
#line 3405
  vfmrqc = 0U;
#line 3409
  rxcsum = ixgbe_read_reg(hw, 20480U);
#line 3410
  rxcsum = rxcsum | 8192U;
#line 3411
  ixgbe_write_reg(hw, 20480U, rxcsum);
#line 3413
  if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 3414
    if ((unsigned int )adapter->ring_feature[2].mask != 0U) {
#line 3415
      mrqc = 1U;
    } else {

    }
  } else {
#line 3417
    tmp = netdev_get_num_tc(adapter->netdev);
#line 3417
    tcs = (u8 )tmp;
#line 3419
    if ((adapter->flags & 8388608U) != 0U) {
#line 3420
      if ((unsigned int )tcs > 4U) {
#line 3421
        mrqc = 12U;
      } else
#line 3422
      if ((unsigned int )tcs > 1U) {
#line 3423
        mrqc = 13U;
      } else
#line 3424
      if ((unsigned int )adapter->ring_feature[2].indices == 4U) {
#line 3425
        mrqc = 10U;
      } else {
#line 3427
        mrqc = 11U;
      }
    } else
#line 3429
    if ((unsigned int )tcs > 4U) {
#line 3430
      mrqc = 4U;
    } else
#line 3431
    if ((unsigned int )tcs > 1U) {
#line 3432
      mrqc = 5U;
    } else {
#line 3434
      mrqc = 1U;
    }
  }
#line 3439
  rss_field = rss_field | 3342336U;
#line 3444
  if ((adapter->flags2 & 256U) != 0U) {
#line 3445
    rss_field = rss_field | 4194304U;
  } else {

  }
#line 3446
  if ((adapter->flags2 & 512U) != 0U) {
#line 3447
    rss_field = rss_field | 8388608U;
  } else {

  }
#line 3449
  netdev_rss_key_fill((void *)(& adapter->rss_key), 40UL);
#line 3450
  if ((unsigned int )hw->mac.type > 3U && (adapter->flags & 8388608U) != 0U) {
#line 3452
    pf_pool = adapter->num_vfs;
#line 3455
    mrqc = mrqc | 8192U;
#line 3456
    ixgbe_write_reg(hw, 22552U, mrqc);
#line 3459
    ixgbe_setup_vfreta(adapter);
#line 3460
    vfmrqc = 1U;
#line 3461
    vfmrqc = vfmrqc | rss_field;
#line 3462
    ixgbe_write_reg(hw, (pf_pool + 3328U) * 4U, vfmrqc);
  } else {
#line 3464
    ixgbe_setup_reta(adapter);
#line 3465
    mrqc = mrqc | rss_field;
#line 3466
    ixgbe_write_reg(hw, 22552U, mrqc);
  }
#line 3468
  return;
}
}
#line 3475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_rscctl(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_hw *hw ;
  u32 rscctrl ;
  u8 reg_idx ;
  int tmp ;

  {
#line 3478
  hw = & adapter->hw;
#line 3480
  reg_idx = ring->reg_idx;
#line 3482
  tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& ring->state));
#line 3482
  if (tmp == 0) {
#line 3483
    return;
  } else {

  }
#line 3485
  rscctrl = ixgbe_read_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4140 : ((int )reg_idx + -64) * 64 + 53292));
#line 3486
  rscctrl = rscctrl | 1U;
#line 3492
  rscctrl = rscctrl | 12U;
#line 3493
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4140 : ((int )reg_idx + -64) * 64 + 53292),
                  rscctrl);
#line 3494
  return;
}
}
#line 3497 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_rx_desc_queue_enable(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_hw *hw ;
  int wait_loop ;
  u32 rxdctl ;
  u8 reg_idx ;
  bool tmp ;
  u32 tmp___0 ;

  {
#line 3500
  hw = & adapter->hw;
#line 3501
  wait_loop = 10;
#line 3503
  reg_idx = ring->reg_idx;
#line 3505
  tmp = ixgbe_removed((void *)hw->hw_addr);
#line 3505
  if ((int )tmp) {
#line 3506
    return;
  } else {

  }
#line 3508
  if ((unsigned int )hw->mac.type == 1U) {
#line 3508
    tmp___0 = ixgbe_read_reg(hw, 17060U);
#line 3508
    if ((tmp___0 & 1073741824U) == 0U) {
#line 3510
      return;
    } else {

    }
  } else {

  }
  ldv_58020: 
#line 3513
  usleep_range(1000UL, 2000UL);
#line 3514
  rxdctl = ixgbe_read_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4136 : ((int )reg_idx + -64) * 64 + 53288));
#line 3515
  wait_loop = wait_loop - 1;
#line 3515
  if (wait_loop != 0 && (rxdctl & 33554432U) == 0U) {
#line 3517
    goto ldv_58020;
  } else {

  }

#line 3517
  if (wait_loop == 0) {
#line 3518
    if ((int )adapter->msg_enable & 1) {
#line 3519
      netdev_err((struct net_device  const  *)adapter->netdev, "RXDCTL.ENABLE on Rx queue %d not set within the polling period\n",
                 (int )reg_idx);
    } else {

    }
  } else {

  }
#line 3520
  return;
}
}
#line 3523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_disable_rx_queue(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_hw *hw ;
  int wait_loop ;
  u32 rxdctl ;
  u8 reg_idx ;
  bool tmp ;
  u32 tmp___0 ;

  {
#line 3526
  hw = & adapter->hw;
#line 3527
  wait_loop = 10;
#line 3529
  reg_idx = ring->reg_idx;
#line 3531
  tmp = ixgbe_removed((void *)hw->hw_addr);
#line 3531
  if ((int )tmp) {
#line 3532
    return;
  } else {

  }
#line 3533
  rxdctl = ixgbe_read_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4136 : ((int )reg_idx + -64) * 64 + 53288));
#line 3534
  rxdctl = rxdctl & 4261412863U;
#line 3537
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4136 : ((int )reg_idx + -64) * 64 + 53288),
                  rxdctl);
#line 3539
  if ((unsigned int )hw->mac.type == 1U) {
#line 3539
    tmp___0 = ixgbe_read_reg(hw, 17060U);
#line 3539
    if ((tmp___0 & 1073741824U) == 0U) {
#line 3541
      return;
    } else {

    }
  } else {

  }
  ldv_58030: 
#line 3545
  __const_udelay(42950UL);
#line 3546
  rxdctl = ixgbe_read_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4136 : ((int )reg_idx + -64) * 64 + 53288));
#line 3547
  wait_loop = wait_loop - 1;
#line 3547
  if (wait_loop != 0 && (rxdctl & 33554432U) != 0U) {
#line 3549
    goto ldv_58030;
  } else {

  }

#line 3549
  if (wait_loop == 0) {
#line 3550
    if ((int )adapter->msg_enable & 1) {
#line 3551
      netdev_err((struct net_device  const  *)adapter->netdev, "RXDCTL.ENABLE on Rx queue %d not cleared within the polling period\n",
                 (int )reg_idx);
    } else {

    }
  } else {

  }
#line 3552
  return;
}
}
#line 3555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_hw *hw ;
  u64 rdba ;
  u32 rxdctl ;
  u8 reg_idx ;
  u16 tmp ;

  {
#line 3558
  hw = & adapter->hw;
#line 3559
  rdba = ring->dma;
#line 3561
  reg_idx = ring->reg_idx;
#line 3564
  rxdctl = ixgbe_read_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4136 : ((int )reg_idx + -64) * 64 + 53288));
#line 3565
  ixgbe_disable_rx_queue(adapter, ring);
#line 3567
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? ((int )reg_idx + 64) * 64 : ((int )reg_idx + 768) * 64),
                  (u32 )rdba);
#line 3568
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4100 : ((int )reg_idx + -64) * 64 + 53252),
                  (u32 )(rdba >> 32));
#line 3569
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4104 : ((int )reg_idx + -64) * 64 + 53256),
                  (u32 )ring->count * 16U);
#line 3571
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4112 : ((int )reg_idx + -64) * 64 + 53264),
                  0U);
#line 3572
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4120 : ((int )reg_idx + -64) * 64 + 53272),
                  0U);
#line 3573
  ring->tail = adapter->io_addr + (unsigned long )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4120 : ((int )reg_idx + -64) * 64 + 53272);
#line 3575
  ixgbe_configure_srrctl(adapter, ring);
#line 3576
  ixgbe_configure_rscctl(adapter, ring);
#line 3578
  if ((unsigned int )hw->mac.type == 1U) {
#line 3586
    rxdctl = rxdctl & 4290772992U;
#line 3587
    rxdctl = rxdctl | 525344U;
  } else {

  }
#line 3591
  rxdctl = rxdctl | 33554432U;
#line 3592
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4136 : ((int )reg_idx + -64) * 64 + 53288),
                  rxdctl);
#line 3594
  ixgbe_rx_desc_queue_enable(adapter, ring);
#line 3595
  tmp = ixgbe_desc_unused(ring);
#line 3595
  ixgbe_alloc_rx_buffers(ring, (int )tmp);
#line 3596
  return;
}
}
#line 3598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_psrtype(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int rss_i ;
  u16 pool ;
  u32 psrtype ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 3600
  hw = & adapter->hw;
#line 3601
  rss_i = (int )adapter->ring_feature[2].indices;
#line 3605
  psrtype = 4912U;
#line 3611
  if ((unsigned int )hw->mac.type == 1U) {
#line 3612
    return;
  } else {

  }
#line 3614
  if (rss_i > 3) {
#line 3615
    psrtype = psrtype | 1073741824U;
  } else
#line 3616
  if (rss_i > 1) {
#line 3617
    psrtype = psrtype | 536870912U;
  } else {

  }
#line 3619
  tmp = find_first_bit((unsigned long const   *)(& adapter->fwd_bitmask), 32UL);
#line 3619
  pool = (u16 )tmp;
#line 3619
  goto ldv_58048;
  ldv_58047: 
#line 3620
  ixgbe_write_reg(hw, (u32 )((int )pool + (int )adapter->ring_feature[1].offset <= 15 ? (((int )pool + (int )adapter->ring_feature[1].offset) + 5408) * 4 : (((int )pool + (int )adapter->ring_feature[1].offset) + 14976) * 4),
                  psrtype);
#line 3619
  tmp___0 = find_next_bit((unsigned long const   *)(& adapter->fwd_bitmask), 32UL,
                          (unsigned long )((int )pool + 1));
#line 3619
  pool = (u16 )tmp___0;
  ldv_58048: ;
#line 3619
  if ((unsigned int )pool <= 31U) {
#line 3621
    goto ldv_58047;
  } else {

  }

#line 3626
  return;
}
}
#line 3623 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_virtualization(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 reg_offset ;
  u32 vf_shift ;
  u32 gcr_ext ;
  u32 vmdctl ;
  int i ;

  {
#line 3625
  hw = & adapter->hw;
#line 3630
  if ((adapter->flags & 8388608U) == 0U) {
#line 3631
    return;
  } else {

  }
#line 3633
  vmdctl = ixgbe_read_reg(hw, 20912U);
#line 3634
  vmdctl = vmdctl | 1U;
#line 3635
  vmdctl = vmdctl & 4294959231U;
#line 3636
  vmdctl = (u32 )((int )adapter->ring_feature[1].offset << 7) | vmdctl;
#line 3637
  vmdctl = vmdctl | 1073741824U;
#line 3638
  ixgbe_write_reg(hw, 20912U, vmdctl);
#line 3640
  vf_shift = (u32 )adapter->ring_feature[1].offset & 31U;
#line 3641
  reg_offset = (int )adapter->ring_feature[1].offset > 31;
#line 3644
  ixgbe_write_reg(hw, (reg_offset + 5240U) * 4U, (u32 )(-1 << (int )vf_shift));
#line 3645
  ixgbe_write_reg(hw, ((reg_offset ^ 1U) + 5240U) * 4U, reg_offset - 1U);
#line 3646
  ixgbe_write_reg(hw, (reg_offset + 8260U) * 4U, (u32 )(-1 << (int )vf_shift));
#line 3647
  ixgbe_write_reg(hw, ((reg_offset ^ 1U) + 8260U) * 4U, reg_offset - 1U);
#line 3648
  if ((unsigned int )adapter->bridge_mode == 0U) {
#line 3649
    ixgbe_write_reg(hw, 33312U, 1U);
  } else {

  }
#line 3652
  (*(hw->mac.ops.set_vmdq))(hw, 0U, (u32 )adapter->ring_feature[1].offset);
#line 3658
  switch ((int )adapter->ring_feature[1].mask) {
  case 120: 
#line 3660
  gcr_ext = 1U;
#line 3661
  goto ldv_58060;
  case 124: 
#line 3663
  gcr_ext = 2U;
#line 3664
  goto ldv_58060;
  default: 
#line 3666
  gcr_ext = 3U;
#line 3667
  goto ldv_58060;
  }
  ldv_58060: 
#line 3670
  ixgbe_write_reg(hw, 69712U, gcr_ext);
#line 3674
  (*(hw->mac.ops.set_mac_anti_spoofing))(hw, adapter->num_vfs != 0U, (int )adapter->num_vfs);
#line 3680
  if ((unsigned long )hw->mac.ops.set_ethertype_anti_spoofing != (unsigned long )((void (*)(struct ixgbe_hw * ,
                                                                                            bool  ,
                                                                                            int  ))0)) {
#line 3681
    ixgbe_write_reg(hw, 20796U, 2684389580U);
  } else {

  }
#line 3687
  i = 0;
#line 3687
  goto ldv_58064;
  ldv_58063: ;
#line 3688
  if ((unsigned int )(adapter->vfinfo + (unsigned long )i)->spoofchk_enabled == 0U) {
#line 3689
    ixgbe_ndo_set_vf_spoofchk(adapter->netdev, i, 0);
  } else {

  }
#line 3692
  if ((unsigned long )hw->mac.ops.set_ethertype_anti_spoofing != (unsigned long )((void (*)(struct ixgbe_hw * ,
                                                                                            bool  ,
                                                                                            int  ))0)) {
#line 3693
    (*(hw->mac.ops.set_ethertype_anti_spoofing))(hw, 1, i);
  } else {

  }
#line 3696
  ixgbe_ndo_set_vf_rss_query_en(adapter->netdev, i, (int )(adapter->vfinfo + (unsigned long )i)->rss_query_enabled);
#line 3687
  i = i + 1;
  ldv_58064: ;
#line 3687
  if ((unsigned int )i < adapter->num_vfs) {
#line 3689
    goto ldv_58063;
  } else {

  }

#line 3694
  return;
}
}
#line 3701 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_rx_buffer_len(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct net_device *netdev ;
  int max_frame ;
  struct ixgbe_ring *rx_ring ;
  int i ;
  u32 mhadd ;
  u32 hlreg0 ;

  {
#line 3703
  hw = & adapter->hw;
#line 3704
  netdev = adapter->netdev;
#line 3705
  max_frame = (int )(netdev->mtu + 18U);
#line 3712
  if ((adapter->flags & 2097152U) != 0U && max_frame <= 3071) {
#line 3714
    max_frame = 3072;
  } else {

  }
#line 3719
  if (max_frame <= 1517) {
#line 3720
    max_frame = 1518;
  } else {

  }
#line 3722
  mhadd = ixgbe_read_reg(hw, 17000U);
#line 3723
  if ((u32 )max_frame != mhadd >> 16) {
#line 3724
    mhadd = mhadd & 65535U;
#line 3725
    mhadd = (u32 )(max_frame << 16) | mhadd;
#line 3727
    ixgbe_write_reg(hw, 17000U, mhadd);
  } else {

  }
#line 3730
  hlreg0 = ixgbe_read_reg(hw, 16960U);
#line 3732
  hlreg0 = hlreg0 | 4U;
#line 3733
  ixgbe_write_reg(hw, 16960U, hlreg0);
#line 3739
  i = 0;
#line 3739
  goto ldv_58077;
  ldv_58076: 
#line 3740
  rx_ring = adapter->rx_ring[i];
#line 3741
  if ((adapter->flags2 & 2U) != 0U) {
#line 3742
    set_bit(4L, (unsigned long volatile   *)(& rx_ring->state));
  } else {
#line 3744
    clear_bit(4L, (unsigned long volatile   *)(& rx_ring->state));
  }
#line 3739
  i = i + 1;
  ldv_58077: ;
#line 3739
  if (adapter->num_rx_queues > i) {
#line 3741
    goto ldv_58076;
  } else {

  }

#line 3746
  return;
}
}
#line 3748 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_rdrxctl(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 rdrxctl ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 3750
  hw = & adapter->hw;
#line 3751
  tmp = ixgbe_read_reg(hw, 12032U);
#line 3751
  rdrxctl = tmp;
#line 3753
  switch ((unsigned int )hw->mac.type) {
  case 4U: ;
  case 5U: ;
  case 1U: 
#line 3767
  rdrxctl = rdrxctl | 32U;
#line 3768
  goto ldv_58087;
  case 2U: ;
  case 3U: 
#line 3772
  tmp___0 = ixgbe_read_reg(hw, 12328U);
#line 3772
  ixgbe_write_reg(hw, 12328U, tmp___0 | 128U);
#line 3774
  rdrxctl = rdrxctl & 4290904063U;
#line 3776
  rdrxctl = rdrxctl | 100663296U;
#line 3777
  rdrxctl = rdrxctl | 2U;
#line 3778
  goto ldv_58087;
  default: ;
#line 3781
  return;
  }
  ldv_58087: 
#line 3784
  ixgbe_write_reg(hw, 12032U, rdrxctl);
#line 3785
  return;
}
}
#line 3793 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_rx(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int i ;
  u32 rxctrl ;
  u32 rfctl ;

  {
#line 3795
  hw = & adapter->hw;
#line 3800
  (*(hw->mac.ops.disable_rx))(hw);
#line 3802
  ixgbe_setup_psrtype(adapter);
#line 3803
  ixgbe_setup_rdrxctl(adapter);
#line 3806
  rfctl = ixgbe_read_reg(hw, 20488U);
#line 3807
  rfctl = rfctl & 4294967263U;
#line 3808
  if ((adapter->flags2 & 2U) == 0U) {
#line 3809
    rfctl = rfctl | 32U;
  } else {

  }
#line 3810
  ixgbe_write_reg(hw, 20488U, rfctl);
#line 3813
  ixgbe_setup_mrqc(adapter);
#line 3816
  ixgbe_set_rx_buffer_len(adapter);
#line 3822
  i = 0;
#line 3822
  goto ldv_58099;
  ldv_58098: 
#line 3823
  ixgbe_configure_rx_ring(adapter, adapter->rx_ring[i]);
#line 3822
  i = i + 1;
  ldv_58099: ;
#line 3822
  if (adapter->num_rx_queues > i) {
#line 3824
    goto ldv_58098;
  } else {

  }
#line 3825
  rxctrl = ixgbe_read_reg(hw, 12288U);
#line 3827
  if ((unsigned int )hw->mac.type == 1U) {
#line 3828
    rxctrl = rxctrl | 2U;
  } else {

  }
#line 3831
  rxctrl = rxctrl | 1U;
#line 3832
  (*(hw->mac.ops.enable_rx_dma))(hw, rxctrl);
#line 3833
  return;
}
}
#line 3835 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_vlan_rx_add_vid(struct net_device *netdev , __be16 proto , u16 vid ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;

  {
#line 3838
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 3838
  adapter = (struct ixgbe_adapter *)tmp;
#line 3839
  hw = & adapter->hw;
#line 3842
  (*(hw->mac.ops.set_vfta))(& adapter->hw, (u32 )vid, (u32 )adapter->ring_feature[1].offset,
                            1);
#line 3843
  set_bit((long )vid, (unsigned long volatile   *)(& adapter->active_vlans));
#line 3845
  return (0);
}
}
#line 3848 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_vlan_rx_kill_vid(struct net_device *netdev , __be16 proto , u16 vid ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;

  {
#line 3851
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 3851
  adapter = (struct ixgbe_adapter *)tmp;
#line 3852
  hw = & adapter->hw;
#line 3855
  (*(hw->mac.ops.set_vfta))(& adapter->hw, (u32 )vid, (u32 )adapter->ring_feature[1].offset,
                            0);
#line 3856
  clear_bit((long )vid, (unsigned long volatile   *)(& adapter->active_vlans));
#line 3858
  return (0);
}
}
#line 3865 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_vlan_strip_disable(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 vlnctrl ;
  int i ;
  int j ;
  struct ixgbe_ring *ring ;

  {
#line 3867
  hw = & adapter->hw;
#line 3871
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 3873
  vlnctrl = ixgbe_read_reg(hw, 20616U);
#line 3874
  vlnctrl = vlnctrl & 2147483647U;
#line 3875
  ixgbe_write_reg(hw, 20616U, vlnctrl);
#line 3876
  goto ldv_58123;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 3881
  i = 0;
#line 3881
  goto ldv_58131;
  ldv_58130: 
#line 3882
  ring = adapter->rx_ring[i];
#line 3884
  if ((unsigned long )ring->l2_accel_priv != (unsigned long )((struct ixgbe_fwd_adapter *)0)) {
#line 3885
    goto ldv_58129;
  } else {

  }
#line 3886
  j = (int )ring->reg_idx;
#line 3887
  vlnctrl = ixgbe_read_reg(hw, (u32 )(j <= 63 ? j * 64 + 4136 : (j + -64) * 64 + 53288));
#line 3888
  vlnctrl = vlnctrl & 3221225471U;
#line 3889
  ixgbe_write_reg(hw, (u32 )(j <= 63 ? j * 64 + 4136 : (j + -64) * 64 + 53288), vlnctrl);
  ldv_58129: 
#line 3881
  i = i + 1;
  ldv_58131: ;
#line 3881
  if (adapter->num_rx_queues > i) {
#line 3883
    goto ldv_58130;
  } else {

  }

#line 3891
  goto ldv_58123;
  default: ;
#line 3893
  goto ldv_58123;
  }
  ldv_58123: ;
#line 3896
  return;
}
}
#line 3901 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_vlan_strip_enable(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 vlnctrl ;
  int i ;
  int j ;
  struct ixgbe_ring *ring ;

  {
#line 3903
  hw = & adapter->hw;
#line 3907
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 3909
  vlnctrl = ixgbe_read_reg(hw, 20616U);
#line 3910
  vlnctrl = vlnctrl | 2147483648U;
#line 3911
  ixgbe_write_reg(hw, 20616U, vlnctrl);
#line 3912
  goto ldv_58142;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 3917
  i = 0;
#line 3917
  goto ldv_58150;
  ldv_58149: 
#line 3918
  ring = adapter->rx_ring[i];
#line 3920
  if ((unsigned long )ring->l2_accel_priv != (unsigned long )((struct ixgbe_fwd_adapter *)0)) {
#line 3921
    goto ldv_58148;
  } else {

  }
#line 3922
  j = (int )ring->reg_idx;
#line 3923
  vlnctrl = ixgbe_read_reg(hw, (u32 )(j <= 63 ? j * 64 + 4136 : (j + -64) * 64 + 53288));
#line 3924
  vlnctrl = vlnctrl | 1073741824U;
#line 3925
  ixgbe_write_reg(hw, (u32 )(j <= 63 ? j * 64 + 4136 : (j + -64) * 64 + 53288), vlnctrl);
  ldv_58148: 
#line 3917
  i = i + 1;
  ldv_58150: ;
#line 3917
  if (adapter->num_rx_queues > i) {
#line 3919
    goto ldv_58149;
  } else {

  }

#line 3927
  goto ldv_58142;
  default: ;
#line 3929
  goto ldv_58142;
  }
  ldv_58142: ;
#line 3932
  return;
}
}
#line 3933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_restore_vlan(struct ixgbe_adapter *adapter ) 
{ 
  u16 vid ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 3937
  ixgbe_vlan_rx_add_vid(adapter->netdev, 129, 0);
#line 3939
  tmp = find_first_bit((unsigned long const   *)(& adapter->active_vlans), 4096UL);
#line 3939
  vid = (u16 )tmp;
#line 3939
  goto ldv_58158;
  ldv_58157: 
#line 3940
  ixgbe_vlan_rx_add_vid(adapter->netdev, 129, (int )vid);
#line 3939
  tmp___0 = find_next_bit((unsigned long const   *)(& adapter->active_vlans), 4096UL,
                          (unsigned long )((int )vid + 1));
#line 3939
  vid = (u16 )tmp___0;
  ldv_58158: ;
#line 3939
  if ((unsigned int )vid <= 4095U) {
#line 3941
    goto ldv_58157;
  } else {

  }

#line 3946
  return;
}
}
#line 3952 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_write_mc_addr_list(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 3954
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 3954
  adapter = (struct ixgbe_adapter *)tmp;
#line 3955
  hw = & adapter->hw;
#line 3957
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 3957
  if (tmp___0) {
#line 3957
    tmp___1 = 0;
  } else {
#line 3957
    tmp___1 = 1;
  }
#line 3957
  if (tmp___1) {
#line 3958
    return (0);
  } else {

  }
#line 3960
  if ((unsigned long )hw->mac.ops.update_mc_addr_list != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                                   struct net_device * ))0)) {
#line 3961
    (*(hw->mac.ops.update_mc_addr_list))(hw, netdev);
  } else {
#line 3963
    return (-12);
  }
#line 3966
  ixgbe_restore_vf_multicasts(adapter);
#line 3969
  return (netdev->mc.count);
}
}
#line 3973 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_full_sync_mac_table(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int i ;

  {
#line 3975
  hw = & adapter->hw;
#line 3977
  i = 0;
#line 3977
  goto ldv_58171;
  ldv_58170: ;
#line 3978
  if (((int )(adapter->mac_table + (unsigned long )i)->state & 4) != 0) {
#line 3979
    (*(hw->mac.ops.set_rar))(hw, (u32 )i, (u8 *)(& (adapter->mac_table + (unsigned long )i)->addr),
                             (u32 )(adapter->mac_table + (unsigned long )i)->queue,
                             2147483648U);
  } else {
#line 3983
    (*(hw->mac.ops.clear_rar))(hw, (u32 )i);
  }
#line 3985
  (adapter->mac_table + (unsigned long )i)->state = (unsigned int )(adapter->mac_table + (unsigned long )i)->state & 65533U;
#line 3977
  i = i + 1;
  ldv_58171: ;
#line 3977
  if ((u32 )i < hw->mac.num_rar_entries) {
#line 3979
    goto ldv_58170;
  } else {

  }

#line 3984
  return;
}
}
#line 3990 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_sync_mac_table(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int i ;

  {
#line 3992
  hw = & adapter->hw;
#line 3994
  i = 0;
#line 3994
  goto ldv_58179;
  ldv_58178: ;
#line 3995
  if (((int )(adapter->mac_table + (unsigned long )i)->state & 2) != 0) {
#line 3996
    if (((int )(adapter->mac_table + (unsigned long )i)->state & 4) != 0) {
#line 3998
      (*(hw->mac.ops.set_rar))(hw, (u32 )i, (u8 *)(& (adapter->mac_table + (unsigned long )i)->addr),
                               (u32 )(adapter->mac_table + (unsigned long )i)->queue,
                               2147483648U);
    } else {
#line 4003
      (*(hw->mac.ops.clear_rar))(hw, (u32 )i);
    }
#line 4005
    (adapter->mac_table + (unsigned long )i)->state = (unsigned int )(adapter->mac_table + (unsigned long )i)->state & 65533U;
  } else {

  }
#line 3994
  i = i + 1;
  ldv_58179: ;
#line 3994
  if ((u32 )i < hw->mac.num_rar_entries) {
#line 3996
    goto ldv_58178;
  } else {

  }

#line 4001
  return;
}
}
#line 4011 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_flush_sw_mac_table(struct ixgbe_adapter *adapter ) 
{ 
  int i ;
  struct ixgbe_hw *hw ;

  {
#line 4014
  hw = & adapter->hw;
#line 4016
  i = 0;
#line 4016
  goto ldv_58187;
  ldv_58186: 
#line 4017
  (adapter->mac_table + (unsigned long )i)->state = (u16 )((unsigned int )(adapter->mac_table + (unsigned long )i)->state | 2U);
#line 4018
  (adapter->mac_table + (unsigned long )i)->state = (unsigned int )(adapter->mac_table + (unsigned long )i)->state & 65531U;
#line 4019
  eth_zero_addr((u8 *)(& (adapter->mac_table + (unsigned long )i)->addr));
#line 4020
  (adapter->mac_table + (unsigned long )i)->queue = 0U;
#line 4016
  i = i + 1;
  ldv_58187: ;
#line 4016
  if ((u32 )i < hw->mac.num_rar_entries) {
#line 4018
    goto ldv_58186;
  } else {

  }
#line 4022
  ixgbe_sync_mac_table(adapter);
#line 4023
  return;
}
}
#line 4025 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_available_rars(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int i ;
  int count ;

  {
#line 4027
  hw = & adapter->hw;
#line 4028
  count = 0;
#line 4030
  i = 0;
#line 4030
  goto ldv_58196;
  ldv_58195: ;
#line 4031
  if ((unsigned int )(adapter->mac_table + (unsigned long )i)->state == 0U) {
#line 4032
    count = count + 1;
  } else {

  }
#line 4030
  i = i + 1;
  ldv_58196: ;
#line 4030
  if ((u32 )i < hw->mac.num_rar_entries) {
#line 4032
    goto ldv_58195;
  } else {

  }

#line 4034
  return (count);
}
}
#line 4038 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_mac_set_default_filter(struct ixgbe_adapter *adapter , u8 *addr ) 
{ 
  struct ixgbe_hw *hw ;

  {
#line 4041
  hw = & adapter->hw;
#line 4043
  memcpy((void *)(& (adapter->mac_table)->addr), (void const   *)addr, 6UL);
#line 4044
  (adapter->mac_table)->queue = adapter->ring_feature[1].offset;
#line 4045
  (adapter->mac_table)->state = 5U;
#line 4047
  (*(hw->mac.ops.set_rar))(hw, 0U, (u8 *)(& (adapter->mac_table)->addr), (u32 )(adapter->mac_table)->queue,
                           2147483648U);
#line 4049
  return;
}
}
#line 4052 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_add_mac_filter(struct ixgbe_adapter *adapter , u8 *addr , u16 queue ) 
{ 
  struct ixgbe_hw *hw ;
  int i ;
  bool tmp ;

  {
#line 4054
  hw = & adapter->hw;
#line 4057
  tmp = is_zero_ether_addr((u8 const   *)addr);
#line 4057
  if ((int )tmp) {
#line 4058
    return (-22);
  } else {

  }
#line 4060
  i = 0;
#line 4060
  goto ldv_58212;
  ldv_58211: ;
#line 4061
  if (((int )(adapter->mac_table + (unsigned long )i)->state & 4) != 0) {
#line 4062
    goto ldv_58210;
  } else {

  }
#line 4063
  (adapter->mac_table + (unsigned long )i)->state = (u16 )((unsigned int )(adapter->mac_table + (unsigned long )i)->state | 6U);
#line 4065
  ether_addr_copy((u8 *)(& (adapter->mac_table + (unsigned long )i)->addr), (u8 const   *)addr);
#line 4066
  (adapter->mac_table + (unsigned long )i)->queue = queue;
#line 4067
  ixgbe_sync_mac_table(adapter);
#line 4068
  return (i);
  ldv_58210: 
#line 4060
  i = i + 1;
  ldv_58212: ;
#line 4060
  if ((u32 )i < hw->mac.num_rar_entries) {
#line 4062
    goto ldv_58211;
  } else {

  }

#line 4070
  return (-12);
}
}
#line 4073 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_del_mac_filter(struct ixgbe_adapter *adapter , u8 *addr , u16 queue ) 
{ 
  int i ;
  struct ixgbe_hw *hw ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 4077
  hw = & adapter->hw;
#line 4079
  tmp = is_zero_ether_addr((u8 const   *)addr);
#line 4079
  if ((int )tmp) {
#line 4080
    return (-22);
  } else {

  }
#line 4082
  i = 0;
#line 4082
  goto ldv_58222;
  ldv_58221: 
#line 4083
  tmp___0 = ether_addr_equal((u8 const   *)addr, (u8 const   *)(& (adapter->mac_table + (unsigned long )i)->addr));
#line 4083
  if ((int )tmp___0 && (int )(adapter->mac_table + (unsigned long )i)->queue == (int )queue) {
#line 4085
    (adapter->mac_table + (unsigned long )i)->state = (u16 )((unsigned int )(adapter->mac_table + (unsigned long )i)->state | 2U);
#line 4086
    (adapter->mac_table + (unsigned long )i)->state = (unsigned int )(adapter->mac_table + (unsigned long )i)->state & 65531U;
#line 4087
    eth_zero_addr((u8 *)(& (adapter->mac_table + (unsigned long )i)->addr));
#line 4088
    (adapter->mac_table + (unsigned long )i)->queue = 0U;
#line 4089
    ixgbe_sync_mac_table(adapter);
#line 4090
    return (0);
  } else {

  }
#line 4082
  i = i + 1;
  ldv_58222: ;
#line 4082
  if ((u32 )i < hw->mac.num_rar_entries) {
#line 4084
    goto ldv_58221;
  } else {

  }

#line 4093
  return (-12);
}
}
#line 4104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_write_uc_addr_list(struct net_device *netdev , int vfn ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int count ;
  int tmp___0 ;
  struct netdev_hw_addr *ha ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 4106
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 4106
  adapter = (struct ixgbe_adapter *)tmp;
#line 4107
  count = 0;
#line 4110
  tmp___0 = ixgbe_available_rars(adapter);
#line 4110
  if (netdev->uc.count > tmp___0) {
#line 4111
    return (-12);
  } else {

  }
#line 4113
  if (netdev->uc.count != 0) {
#line 4115
    __mptr = (struct list_head  const  *)netdev->uc.list.next;
#line 4115
    ha = (struct netdev_hw_addr *)__mptr;
#line 4115
    goto ldv_58236;
    ldv_58235: 
#line 4116
    ixgbe_del_mac_filter(adapter, (u8 *)(& ha->addr), (int )((u16 )vfn));
#line 4117
    ixgbe_add_mac_filter(adapter, (u8 *)(& ha->addr), (int )((u16 )vfn));
#line 4118
    count = count + 1;
#line 4115
    __mptr___0 = (struct list_head  const  *)ha->list.next;
#line 4115
    ha = (struct netdev_hw_addr *)__mptr___0;
    ldv_58236: ;
#line 4115
    if ((unsigned long )(& ha->list) != (unsigned long )(& netdev->uc.list)) {
#line 4117
      goto ldv_58235;
    } else {

    }

  } else {

  }
#line 4121
  return (count);
}
}
#line 4133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_set_rx_mode(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u32 fctrl ;
  u32 vmolr ;
  u32 vlnctrl ;
  int count ;
  u32 tmp___0 ;

  {
#line 4135
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 4135
  adapter = (struct ixgbe_adapter *)tmp;
#line 4136
  hw = & adapter->hw;
#line 4137
  vmolr = 150994944U;
#line 4142
  fctrl = ixgbe_read_reg(hw, 20608U);
#line 4143
  vlnctrl = ixgbe_read_reg(hw, 20616U);
#line 4146
  fctrl = fctrl & 4294967293U;
#line 4147
  fctrl = fctrl | 1024U;
#line 4148
  fctrl = fctrl | 8192U;
#line 4149
  fctrl = fctrl | 4096U;
#line 4152
  fctrl = fctrl & 4294966527U;
#line 4153
  vlnctrl = vlnctrl & 2684354559U;
#line 4154
  if ((netdev->flags & 256U) != 0U) {
#line 4155
    hw->addr_ctrl.user_set_promisc = 1;
#line 4156
    fctrl = fctrl | 768U;
#line 4157
    vmolr = vmolr | 268435456U;
#line 4162
    if ((adapter->flags & 8404992U) != 0U) {
#line 4164
      vlnctrl = vlnctrl | 1610612736U;
    } else {

    }
  } else {
#line 4166
    if ((netdev->flags & 512U) != 0U) {
#line 4167
      fctrl = fctrl | 256U;
#line 4168
      vmolr = vmolr | 268435456U;
    } else {

    }
#line 4170
    vlnctrl = vlnctrl | 1073741824U;
#line 4171
    hw->addr_ctrl.user_set_promisc = 0;
  }
#line 4179
  count = ixgbe_write_uc_addr_list(netdev, (int )adapter->ring_feature[1].offset);
#line 4180
  if (count < 0) {
#line 4181
    fctrl = fctrl | 512U;
#line 4182
    vmolr = vmolr | 67108864U;
  } else {

  }
#line 4189
  count = ixgbe_write_mc_addr_list(netdev);
#line 4190
  if (count < 0) {
#line 4191
    fctrl = fctrl | 256U;
#line 4192
    vmolr = vmolr | 268435456U;
  } else
#line 4193
  if (count != 0) {
#line 4194
    vmolr = vmolr | 33554432U;
  } else {

  }
#line 4197
  if ((unsigned int )hw->mac.type != 1U) {
#line 4198
    tmp___0 = ixgbe_read_reg(hw, (u32 )(((int )adapter->ring_feature[1].offset + 15360) * 4));
#line 4198
    vmolr = (tmp___0 & 3925868543U) | vmolr;
#line 4201
    ixgbe_write_reg(hw, (u32 )(((int )adapter->ring_feature[1].offset + 15360) * 4),
                    vmolr);
  } else {

  }
#line 4205
  if (((adapter->netdev)->features & 274877906944ULL) != 0ULL) {
#line 4208
    fctrl = fctrl | 5122U;
#line 4212
    fctrl = fctrl & 4294959103U;
  } else {

  }
#line 4216
  ixgbe_write_reg(hw, 20616U, vlnctrl);
#line 4217
  ixgbe_write_reg(hw, 20608U, fctrl);
#line 4219
  if ((netdev->features & 256ULL) != 0ULL) {
#line 4220
    ixgbe_vlan_strip_enable(adapter);
  } else {
#line 4222
    ixgbe_vlan_strip_disable(adapter);
  }
#line 4223
  return;
}
}
#line 4225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_napi_enable_all(struct ixgbe_adapter *adapter ) 
{ 
  int q_idx ;

  {
#line 4229
  q_idx = 0;
#line 4229
  goto ldv_58252;
  ldv_58251: 
#line 4230
  ixgbe_qv_init_lock(adapter->q_vector[q_idx]);
#line 4231
  napi_enable(& (adapter->q_vector[q_idx])->napi);
#line 4229
  q_idx = q_idx + 1;
  ldv_58252: ;
#line 4229
  if (adapter->num_q_vectors > q_idx) {
#line 4231
    goto ldv_58251;
  } else {

  }

#line 4236
  return;
}
}
#line 4235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_napi_disable_all(struct ixgbe_adapter *adapter ) 
{ 
  int q_idx ;
  bool tmp ;
  int tmp___0 ;

  {
#line 4239
  q_idx = 0;
#line 4239
  goto ldv_58262;
  ldv_58261: 
#line 4240
  napi_disable(& (adapter->q_vector[q_idx])->napi);
#line 4241
  goto ldv_58259;
  ldv_58258: 
#line 4242
  printk("\016ixgbe: QV %d locked\n", q_idx);
#line 4243
  usleep_range(1000UL, 20000UL);
  ldv_58259: 
#line 4241
  tmp = ixgbe_qv_disable(adapter->q_vector[q_idx]);
#line 4241
  if (tmp) {
#line 4241
    tmp___0 = 0;
  } else {
#line 4241
    tmp___0 = 1;
  }
#line 4241
  if (tmp___0) {
#line 4243
    goto ldv_58258;
  } else {

  }
#line 4239
  q_idx = q_idx + 1;
  ldv_58262: ;
#line 4239
  if (adapter->num_q_vectors > q_idx) {
#line 4241
    goto ldv_58261;
  } else {

  }

#line 4246
  return;
}
}
#line 4257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_dcb(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int max_frame ;
  int _max1 ;
  int _max2 ;
  u32 msb ;
  u16 rss_i ;

  {
#line 4259
  hw = & adapter->hw;
#line 4260
  max_frame = (int )((adapter->netdev)->mtu + 18U);
#line 4262
  if ((adapter->flags & 4096U) == 0U) {
#line 4263
    if ((unsigned int )hw->mac.type == 1U) {
#line 4264
      netif_set_gso_max_size(adapter->netdev, 65536U);
    } else {

    }
#line 4265
    return;
  } else {

  }
#line 4268
  if ((unsigned int )hw->mac.type == 1U) {
#line 4269
    netif_set_gso_max_size(adapter->netdev, 32768U);
  } else {

  }
#line 4272
  if (((adapter->netdev)->features & 2147483648ULL) != 0ULL) {
#line 4273
    _max1 = max_frame;
#line 4273
    _max2 = 3072;
#line 4273
    max_frame = _max1 > _max2 ? _max1 : _max2;
  } else {

  }
#line 4277
  if (((int )adapter->dcbx_cap & 4) != 0) {
#line 4278
    ixgbe_dcb_calculate_tc_credits(hw, & adapter->dcb_cfg, max_frame, 0);
#line 4280
    ixgbe_dcb_calculate_tc_credits(hw, & adapter->dcb_cfg, max_frame, 1);
#line 4282
    ixgbe_dcb_hw_config(hw, & adapter->dcb_cfg);
  } else
#line 4283
  if ((unsigned long )adapter->ixgbe_ieee_ets != (unsigned long )((struct ieee_ets *)0) && (unsigned long )adapter->ixgbe_ieee_pfc != (unsigned long )((struct ieee_pfc *)0)) {
#line 4284
    ixgbe_dcb_hw_ets(& adapter->hw, adapter->ixgbe_ieee_ets, max_frame);
#line 4287
    ixgbe_dcb_hw_pfc_config(& adapter->hw, (int )(adapter->ixgbe_ieee_pfc)->pfc_en,
                            (u8 *)(& (adapter->ixgbe_ieee_ets)->prio_tc));
  } else {

  }
#line 4293
  if ((unsigned int )hw->mac.type != 1U) {
#line 4294
    msb = 0U;
#line 4295
    rss_i = (unsigned int )adapter->ring_feature[2].indices + 65535U;
#line 4297
    goto ldv_58275;
    ldv_58274: 
#line 4298
    msb = msb + 1U;
#line 4299
    rss_i = (u16 )((int )rss_i >> 1);
    ldv_58275: ;
#line 4297
    if ((unsigned int )rss_i != 0U) {
#line 4299
      goto ldv_58274;
    } else {

    }
#line 4303
    ixgbe_write_reg(hw, 60528U, msb * 286331153U);
  } else {

  }
#line 4305
  return;
}
}
#line 4317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_hpbthresh(struct ixgbe_adapter *adapter , int pb ) 
{ 
  struct ixgbe_hw *hw ;
  struct net_device *dev ;
  int link ;
  int tc ;
  int kb ;
  int marker ;
  u32 dv_id ;
  u32 rx_pba ;
  u8 tmp ;
  u32 tmp___0 ;

  {
#line 4319
  hw = & adapter->hw;
#line 4320
  dev = adapter->netdev;
#line 4325
  link = (int )(dev->mtu + 38U);
#line 4325
  tc = link;
#line 4329
  if ((dev->features & 2147483648ULL) != 0ULL && tc <= 3071) {
#line 4329
    tmp = ixgbe_fcoe_get_tc(adapter);
#line 4329
    if ((int )tmp == pb) {
#line 4332
      tc = 3072;
    } else {

    }
  } else {

  }
#line 4336
  switch ((unsigned int )hw->mac.type) {
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 4340
  dv_id = (u32 )(((link * 288 + 3373344) / 25 + 1) + tc * 16);
#line 4341
  goto ldv_58292;
  default: 
#line 4343
  dv_id = (u32 )(((link * 288 + 2009376) / 25 + 1) + tc * 16);
#line 4344
  goto ldv_58292;
  }
  ldv_58292: ;
#line 4348
  if ((adapter->flags & 8388608U) != 0U) {
#line 4349
    dv_id = (u32 )(tc * 8) + dv_id;
  } else {

  }
#line 4352
  kb = (int )((dv_id + 8191U) / 8192U);
#line 4353
  tmp___0 = ixgbe_read_reg(hw, (u32 )((pb + 3840) * 4));
#line 4353
  rx_pba = tmp___0 >> 10;
#line 4355
  marker = (int )(rx_pba - (u32 )kb);
#line 4361
  if (marker < 0) {
#line 4362
    if ((int )adapter->msg_enable & 1) {
#line 4364
      netdev_warn((struct net_device  const  *)adapter->netdev, "Packet Buffer(%i) can not provide enoughheadroom to support flow control.Decrease MTU or number of traffic classes\n",
                  pb);
    } else {

    }
#line 4365
    marker = tc + 1;
  } else {

  }
#line 4368
  return (marker);
}
}
#line 4377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_lpbthresh(struct ixgbe_adapter *adapter , int pb ) 
{ 
  struct ixgbe_hw *hw ;
  struct net_device *dev ;
  int tc ;
  u32 dv_id ;
  int tmp ;

  {
#line 4379
  hw = & adapter->hw;
#line 4380
  dev = adapter->netdev;
#line 4385
  tc = (int )(dev->mtu + 18U);
#line 4389
  if ((dev->features & 2147483648ULL) != 0ULL && tc <= 3071) {
#line 4389
    tmp = netdev_get_prio_tc_map((struct net_device  const  *)dev, (u32 )adapter->fcoe.up);
#line 4389
    if (tmp == pb) {
#line 4392
      tc = 3072;
    } else {

    }
  } else {

  }
#line 4396
  switch ((unsigned int )hw->mac.type) {
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 4400
  dv_id = (u32 )((tc + 900) * 16 + 1);
#line 4401
  goto ldv_58305;
  default: 
#line 4403
  dv_id = (u32 )((tc + 900) * 32 + 2);
#line 4404
  goto ldv_58305;
  }
  ldv_58305: ;
#line 4408
  return ((int )((dv_id + 8191U) / 8192U));
}
}
#line 4414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_pbthresh_setup(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int num_tc ;
  int tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4416
  hw = & adapter->hw;
#line 4417
  tmp = netdev_get_num_tc(adapter->netdev);
#line 4417
  num_tc = tmp;
#line 4420
  if (num_tc == 0) {
#line 4421
    num_tc = 1;
  } else {

  }
#line 4423
  i = 0;
#line 4423
  goto ldv_58314;
  ldv_58313: 
#line 4424
  tmp___0 = ixgbe_hpbthresh(adapter, i);
#line 4424
  hw->fc.high_water[i] = (u32 )tmp___0;
#line 4425
  tmp___1 = ixgbe_lpbthresh(adapter, i);
#line 4425
  hw->fc.low_water[i] = (u32 )tmp___1;
#line 4428
  if (hw->fc.low_water[i] > hw->fc.high_water[i]) {
#line 4429
    hw->fc.low_water[i] = 0U;
  } else {

  }
#line 4423
  i = i + 1;
  ldv_58314: ;
#line 4423
  if (i < num_tc) {
#line 4425
    goto ldv_58313;
  } else {

  }

#line 4432
  goto ldv_58317;
  ldv_58316: 
#line 4433
  hw->fc.high_water[i] = 0U;
#line 4432
  i = i + 1;
  ldv_58317: ;
#line 4432
  if (i <= 7) {
#line 4434
    goto ldv_58316;
  } else {

  }

#line 4439
  return;
}
}
#line 4436 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_pb(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int hdrm ;
  u8 tc ;
  int tmp ;

  {
#line 4438
  hw = & adapter->hw;
#line 4440
  tmp = netdev_get_num_tc(adapter->netdev);
#line 4440
  tc = (u8 )tmp;
#line 4442
  if ((adapter->flags & 262144U) != 0U || (adapter->flags & 524288U) != 0U) {
#line 4444
    hdrm = 32 << (int )adapter->fdir_pballoc;
  } else {
#line 4446
    hdrm = 0;
  }
#line 4448
  (*(hw->mac.ops.set_rxpba))(hw, (int )tc, (u32 )hdrm, 0);
#line 4449
  ixgbe_pbthresh_setup(adapter);
#line 4450
  return;
}
}
#line 4452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_fdir_filter_restore(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct hlist_node *node2 ;
  struct ixgbe_fdir_filter *filter ;
  int tmp ;
  struct hlist_node *____ptr ;
  struct hlist_node  const  *__mptr ;
  struct ixgbe_fdir_filter *tmp___0 ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node  const  *__mptr___0 ;
  struct ixgbe_fdir_filter *tmp___1 ;

  {
#line 4454
  hw = & adapter->hw;
#line 4458
  spin_lock(& adapter->fdir_perfect_lock);
#line 4460
  tmp = hlist_empty((struct hlist_head  const  *)(& adapter->fdir_filter_list));
#line 4460
  if (tmp == 0) {
#line 4461
    ixgbe_fdir_set_input_mask_82599(hw, & adapter->fdir_mask);
  } else {

  }
#line 4463
  ____ptr = adapter->fdir_filter_list.first;
#line 4463
  if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
#line 4463
    __mptr = (struct hlist_node  const  *)____ptr;
#line 4463
    tmp___0 = (struct ixgbe_fdir_filter *)__mptr;
  } else {
#line 4463
    tmp___0 = (struct ixgbe_fdir_filter *)0;
  }
#line 4463
  filter = tmp___0;
#line 4463
  goto ldv_58341;
  ldv_58340: 
#line 4465
  ixgbe_fdir_write_perfect_filter_82599(hw, & filter->filter, (int )filter->sw_idx,
                                        (unsigned int )filter->action != 127U ? (int )(adapter->rx_ring[(int )filter->action])->reg_idx : 127);
#line 4463
  ____ptr___0 = node2;
#line 4463
  if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
#line 4463
    __mptr___0 = (struct hlist_node  const  *)____ptr___0;
#line 4463
    tmp___1 = (struct ixgbe_fdir_filter *)__mptr___0;
  } else {
#line 4463
    tmp___1 = (struct ixgbe_fdir_filter *)0;
  }
#line 4463
  filter = tmp___1;
  ldv_58341: ;
#line 4463
  if ((unsigned long )filter != (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 4463
    node2 = filter->fdir_node.next;
#line 4465
    goto ldv_58340;
  } else {

  }
#line 4473
  spin_unlock(& adapter->fdir_perfect_lock);
#line 4474
  return;
}
}
#line 4476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_macvlan_set_rx_mode(struct net_device *dev , unsigned int pool ,
                                      struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 vmolr ;

  {
#line 4479
  hw = & adapter->hw;
#line 4483
  vmolr = ixgbe_read_reg(hw, (pool + 15360U) * 4U);
#line 4484
  vmolr = vmolr | 184549376U;
#line 4487
  vmolr = vmolr & 4026531839U;
#line 4489
  if ((dev->flags & 512U) != 0U) {
#line 4490
    vmolr = vmolr | 268435456U;
  } else {
#line 4492
    vmolr = vmolr | 33554432U;
#line 4493
    (*(hw->mac.ops.update_mc_addr_list))(hw, dev);
  }
#line 4495
  ixgbe_write_uc_addr_list(adapter->netdev, (int )pool);
#line 4496
  ixgbe_write_reg(hw, (pool + 15360U) * 4U, vmolr);
#line 4497
  return;
}
}
#line 4499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_fwd_psrtype(struct ixgbe_fwd_adapter *vadapter ) 
{ 
  struct ixgbe_adapter *adapter ;
  int rss_i ;
  struct ixgbe_hw *hw ;
  u16 pool ;
  u32 psrtype ;

  {
#line 4501
  adapter = vadapter->real_adapter;
#line 4502
  rss_i = adapter->num_rx_queues_per_pool;
#line 4503
  hw = & adapter->hw;
#line 4504
  pool = (u16 )vadapter->pool;
#line 4505
  psrtype = 4912U;
#line 4511
  if ((unsigned int )hw->mac.type == 1U) {
#line 4512
    return;
  } else {

  }
#line 4514
  if (rss_i > 3) {
#line 4515
    psrtype = psrtype | 1073741824U;
  } else
#line 4516
  if (rss_i > 1) {
#line 4517
    psrtype = psrtype | 536870912U;
  } else {

  }
#line 4519
  ixgbe_write_reg(hw, (u32 )((int )pool + (int )adapter->ring_feature[1].offset <= 15 ? (((int )pool + (int )adapter->ring_feature[1].offset) + 5408) * 4 : (((int )pool + (int )adapter->ring_feature[1].offset) + 14976) * 4),
                  psrtype);
#line 4520
  return;
}
}
#line 4526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_clean_rx_ring(struct ixgbe_ring *rx_ring ) 
{ 
  struct device *dev ;
  unsigned long size ;
  u16 i ;
  struct ixgbe_rx_buffer *rx_buffer ;
  struct sk_buff *skb ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 4528
  dev = rx_ring->dev;
#line 4533
  if ((unsigned long )rx_ring->__annonCompField118.rx_buffer_info == (unsigned long )((struct ixgbe_rx_buffer *)0)) {
#line 4534
    return;
  } else {

  }
#line 4537
  i = 0U;
#line 4537
  goto ldv_58368;
  ldv_58367: 
#line 4538
  rx_buffer = rx_ring->__annonCompField118.rx_buffer_info + (unsigned long )i;
#line 4540
  if ((unsigned long )rx_buffer->skb != (unsigned long )((struct sk_buff *)0)) {
#line 4541
    skb = rx_buffer->skb;
#line 4542
    if ((int )((struct ixgbe_cb *)(& skb->cb))->page_released) {
#line 4543
      tmp = ixgbe_rx_bufsz(rx_ring);
#line 4543
      dma_unmap_page(dev, ((struct ixgbe_cb *)(& skb->cb))->dma, (size_t )tmp, 2);
    } else {

    }
#line 4547
    consume_skb(skb);
#line 4548
    rx_buffer->skb = (struct sk_buff *)0;
  } else {

  }
#line 4551
  if ((unsigned long )rx_buffer->page == (unsigned long )((struct page *)0)) {
#line 4552
    goto ldv_58366;
  } else {

  }
#line 4554
  tmp___0 = ixgbe_rx_pg_order(rx_ring);
#line 4554
  dma_unmap_page(dev, rx_buffer->dma, 4096UL << (int )tmp___0, 2);
#line 4556
  tmp___1 = ixgbe_rx_pg_order(rx_ring);
#line 4556
  __free_pages(rx_buffer->page, tmp___1);
#line 4558
  rx_buffer->page = (struct page *)0;
  ldv_58366: 
#line 4537
  i = (u16 )((int )i + 1);
  ldv_58368: ;
#line 4537
  if ((int )rx_ring->count > (int )i) {
#line 4539
    goto ldv_58367;
  } else {

  }
#line 4561
  size = (unsigned long )rx_ring->count * 32UL;
#line 4562
  memset((void *)rx_ring->__annonCompField118.rx_buffer_info, 0, size);
#line 4565
  memset(rx_ring->desc, 0, (size_t )rx_ring->size);
#line 4567
  rx_ring->__annonCompField120.next_to_alloc = 0U;
#line 4568
  rx_ring->next_to_clean = 0U;
#line 4569
  rx_ring->next_to_use = 0U;
#line 4570
  return;
}
}
#line 4572 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_disable_fwd_ring(struct ixgbe_fwd_adapter *vadapter , struct ixgbe_ring *rx_ring ) 
{ 
  struct ixgbe_adapter *adapter ;
  int index ;

  {
#line 4575
  adapter = vadapter->real_adapter;
#line 4576
  index = (int )((unsigned int )rx_ring->queue_index + vadapter->rx_base_queue);
#line 4579
  ixgbe_disable_rx_queue(adapter, rx_ring);
#line 4580
  usleep_range(10000UL, 20000UL);
#line 4581
  ixgbe_irq_disable_queues(adapter, 1ULL << index);
#line 4582
  ixgbe_clean_rx_ring(rx_ring);
#line 4583
  rx_ring->l2_accel_priv = (struct ixgbe_fwd_adapter *)0;
#line 4584
  return;
}
}
#line 4586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_fwd_ring_down(struct net_device *vdev , struct ixgbe_fwd_adapter *accel ) 
{ 
  struct ixgbe_adapter *adapter ;
  unsigned int rxbase ;
  unsigned int txbase ;
  int i ;

  {
#line 4589
  adapter = accel->real_adapter;
#line 4590
  rxbase = accel->rx_base_queue;
#line 4591
  txbase = accel->tx_base_queue;
#line 4594
  netif_tx_stop_all_queues(vdev);
#line 4596
  i = 0;
#line 4596
  goto ldv_58385;
  ldv_58384: 
#line 4597
  ixgbe_disable_fwd_ring(accel, adapter->rx_ring[rxbase + (unsigned int )i]);
#line 4598
  (adapter->rx_ring[rxbase + (unsigned int )i])->netdev = adapter->netdev;
#line 4596
  i = i + 1;
  ldv_58385: ;
#line 4596
  if (adapter->num_rx_queues_per_pool > i) {
#line 4598
    goto ldv_58384;
  } else {

  }
#line 4601
  i = 0;
#line 4601
  goto ldv_58388;
  ldv_58387: 
#line 4602
  (adapter->tx_ring[txbase + (unsigned int )i])->l2_accel_priv = (struct ixgbe_fwd_adapter *)0;
#line 4603
  (adapter->tx_ring[txbase + (unsigned int )i])->netdev = adapter->netdev;
#line 4601
  i = i + 1;
  ldv_58388: ;
#line 4601
  if (adapter->num_rx_queues_per_pool > i) {
#line 4603
    goto ldv_58387;
  } else {

  }

#line 4607
  return (0);
}
}
#line 4610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_fwd_ring_up(struct net_device *vdev , struct ixgbe_fwd_adapter *accel ) 
{ 
  struct ixgbe_adapter *adapter ;
  unsigned int rxbase ;
  unsigned int txbase ;
  unsigned int queues ;
  int i ;
  int baseq ;
  int err ;
  int tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  unsigned int __min1 ;
  unsigned int __min2 ;
  bool tmp___1 ;

  {
#line 4613
  adapter = accel->real_adapter;
#line 4615
  err = 0;
#line 4617
  tmp = variable_test_bit((long )accel->pool, (unsigned long const volatile   *)(& adapter->fwd_bitmask));
#line 4617
  if (tmp == 0) {
#line 4618
    return (0);
  } else {

  }
#line 4620
  baseq = accel->pool * adapter->num_rx_queues_per_pool;
#line 4621
  descriptor.modname = "ixgbe";
#line 4621
  descriptor.function = "ixgbe_fwd_ring_up";
#line 4621
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c";
#line 4621
  descriptor.format = "pool %i:%i queues %i:%i VSI bitmask %lx\n";
#line 4621
  descriptor.lineno = 4624U;
#line 4621
  descriptor.flags = 0U;
#line 4621
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4621
  if (tmp___0 != 0L) {
#line 4621
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)vdev, "pool %i:%i queues %i:%i VSI bitmask %lx\n",
                         accel->pool, adapter->num_rx_pools, baseq, adapter->num_rx_queues_per_pool + baseq,
                         adapter->fwd_bitmask);
  } else {

  }
#line 4626
  accel->netdev = vdev;
#line 4627
  rxbase = (unsigned int )baseq;
#line 4627
  accel->rx_base_queue = rxbase;
#line 4628
  txbase = (unsigned int )baseq;
#line 4628
  accel->tx_base_queue = txbase;
#line 4630
  i = 0;
#line 4630
  goto ldv_58404;
  ldv_58403: 
#line 4631
  ixgbe_disable_fwd_ring(accel, adapter->rx_ring[rxbase + (unsigned int )i]);
#line 4630
  i = i + 1;
  ldv_58404: ;
#line 4630
  if (adapter->num_rx_queues_per_pool > i) {
#line 4632
    goto ldv_58403;
  } else {

  }
#line 4633
  i = 0;
#line 4633
  goto ldv_58407;
  ldv_58406: 
#line 4634
  (adapter->rx_ring[rxbase + (unsigned int )i])->netdev = vdev;
#line 4635
  (adapter->rx_ring[rxbase + (unsigned int )i])->l2_accel_priv = accel;
#line 4636
  ixgbe_configure_rx_ring(adapter, adapter->rx_ring[rxbase + (unsigned int )i]);
#line 4633
  i = i + 1;
  ldv_58407: ;
#line 4633
  if (adapter->num_rx_queues_per_pool > i) {
#line 4635
    goto ldv_58406;
  } else {

  }
#line 4639
  i = 0;
#line 4639
  goto ldv_58410;
  ldv_58409: 
#line 4640
  (adapter->tx_ring[txbase + (unsigned int )i])->netdev = vdev;
#line 4641
  (adapter->tx_ring[txbase + (unsigned int )i])->l2_accel_priv = accel;
#line 4639
  i = i + 1;
  ldv_58410: ;
#line 4639
  if (adapter->num_rx_queues_per_pool > i) {
#line 4641
    goto ldv_58409;
  } else {

  }
#line 4644
  __min1 = (unsigned int )adapter->num_rx_queues_per_pool;
#line 4644
  __min2 = vdev->num_tx_queues;
#line 4644
  queues = __min1 < __min2 ? __min1 : __min2;
#line 4646
  err = netif_set_real_num_tx_queues(vdev, queues);
#line 4647
  if (err != 0) {
#line 4648
    goto fwd_queue_err;
  } else {

  }
#line 4650
  err = netif_set_real_num_rx_queues(vdev, queues);
#line 4651
  if (err != 0) {
#line 4652
    goto fwd_queue_err;
  } else {

  }
#line 4654
  tmp___1 = is_valid_ether_addr((u8 const   *)vdev->dev_addr);
#line 4654
  if ((int )tmp___1) {
#line 4655
    ixgbe_add_mac_filter(adapter, vdev->dev_addr, (int )((u16 )accel->pool));
  } else {

  }
#line 4657
  ixgbe_fwd_psrtype(accel);
#line 4658
  ixgbe_macvlan_set_rx_mode(vdev, (unsigned int )accel->pool, adapter);
#line 4659
  return (err);
  fwd_queue_err: 
#line 4661
  ixgbe_fwd_ring_down(vdev, accel);
#line 4662
  return (err);
}
}
#line 4665 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_dfwd(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *upper ;
  struct list_head *iter ;
  int err ;
  struct macvlan_dev *dfwd ;
  void *tmp ;
  struct ixgbe_fwd_adapter *vadapter ;
  bool tmp___0 ;

  {
#line 4671
  iter = & (adapter->netdev)->all_adj_list.upper;
#line 4671
  upper = netdev_all_upper_get_next_dev_rcu(adapter->netdev, & iter);
#line 4671
  goto ldv_58426;
  ldv_58425: 
#line 4672
  tmp___0 = netif_is_macvlan(upper);
#line 4672
  if ((int )tmp___0) {
#line 4673
    tmp = netdev_priv((struct net_device  const  *)upper);
#line 4673
    dfwd = (struct macvlan_dev *)tmp;
#line 4674
    vadapter = (struct ixgbe_fwd_adapter *)dfwd->fwd_priv;
#line 4676
    if ((unsigned long )dfwd->fwd_priv != (unsigned long )((void *)0)) {
#line 4677
      err = ixgbe_fwd_ring_up(upper, vadapter);
#line 4678
      if (err != 0) {
#line 4679
        goto ldv_58424;
      } else {

      }
    } else {

    }
  } else {

  }
  ldv_58424: 
#line 4671
  upper = netdev_all_upper_get_next_dev_rcu(adapter->netdev, & iter);
  ldv_58426: ;
#line 4671
  if ((unsigned long )upper != (unsigned long )((struct net_device *)0)) {
#line 4673
    goto ldv_58425;
  } else {

  }

#line 4678
  return;
}
}
#line 4685 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;

  {
#line 4687
  hw = & adapter->hw;
#line 4689
  ixgbe_configure_pb(adapter);
#line 4691
  ixgbe_configure_dcb(adapter);
#line 4697
  ixgbe_configure_virtualization(adapter);
#line 4699
  ixgbe_set_rx_mode(adapter->netdev);
#line 4700
  ixgbe_restore_vlan(adapter);
#line 4702
  switch ((unsigned int )hw->mac.type) {
  case 2U: ;
  case 3U: 
#line 4705
  (*(hw->mac.ops.disable_rx_buff))(hw);
#line 4706
  goto ldv_58434;
  default: ;
#line 4708
  goto ldv_58434;
  }
  ldv_58434: ;
#line 4711
  if ((adapter->flags & 262144U) != 0U) {
#line 4712
    ixgbe_init_fdir_signature_82599(& adapter->hw, adapter->fdir_pballoc);
  } else
#line 4714
  if ((adapter->flags & 524288U) != 0U) {
#line 4715
    ixgbe_init_fdir_perfect_82599(& adapter->hw, adapter->fdir_pballoc);
#line 4717
    ixgbe_fdir_filter_restore(adapter);
  } else {

  }
#line 4720
  switch ((unsigned int )hw->mac.type) {
  case 2U: ;
  case 3U: 
#line 4723
  (*(hw->mac.ops.enable_rx_buff))(hw);
#line 4724
  goto ldv_58438;
  default: ;
#line 4726
  goto ldv_58438;
  }
  ldv_58438: 
#line 4731
  ixgbe_configure_fcoe(adapter);
#line 4734
  ixgbe_configure_tx(adapter);
#line 4735
  ixgbe_configure_rx(adapter);
#line 4736
  ixgbe_configure_dfwd(adapter);
#line 4737
  return;
}
}
#line 4743 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_sfp_link_config(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 4751
  if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 4752
    adapter->flags2 = adapter->flags2 | 16U;
  } else {

  }
#line 4754
  adapter->flags2 = adapter->flags2 | 32U;
#line 4755
  return;
}
}
#line 4763 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_non_sfp_link_config(struct ixgbe_hw *hw ) 
{ 
  u32 speed ;
  bool autoneg ;
  bool link_up ;
  int ret ;

  {
#line 4766
  link_up = 0;
#line 4767
  ret = -8;
#line 4769
  if ((unsigned long )hw->mac.ops.check_link != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                          ixgbe_link_speed * ,
                                                                          bool * ,
                                                                          bool  ))0)) {
#line 4770
    ret = (*(hw->mac.ops.check_link))(hw, & speed, & link_up, 0);
  } else {

  }
#line 4772
  if (ret != 0) {
#line 4773
    return (ret);
  } else {

  }
#line 4775
  speed = hw->phy.autoneg_advertised;
#line 4776
  if (speed == 0U && (unsigned long )hw->mac.ops.get_link_capabilities != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                                                    ixgbe_link_speed * ,
                                                                                                    bool * ))0)) {
#line 4777
    ret = (*(hw->mac.ops.get_link_capabilities))(hw, & speed, & autoneg);
  } else {

  }
#line 4779
  if (ret != 0) {
#line 4780
    return (ret);
  } else {

  }
#line 4782
  if ((unsigned long )hw->mac.ops.setup_link != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                          ixgbe_link_speed  ,
                                                                          bool  ))0)) {
#line 4783
    ret = (*(hw->mac.ops.setup_link))(hw, speed, (int )link_up);
  } else {

  }
#line 4785
  return (ret);
}
}
#line 4788 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_gpie(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 gpie ;

  {
#line 4790
  hw = & adapter->hw;
#line 4791
  gpie = 0U;
#line 4793
  if ((adapter->flags & 8U) != 0U) {
#line 4794
    gpie = 2147483696U;
#line 4796
    gpie = gpie | 1073741824U;
#line 4801
    switch ((unsigned int )hw->mac.type) {
    case 1U: 
#line 4803
    ixgbe_write_reg(hw, 2192U, 65535U);
#line 4804
    goto ldv_58456;
    case 2U: ;
    case 3U: ;
    case 4U: ;
    case 5U: ;
    default: 
#line 4810
    ixgbe_write_reg(hw, 2768U, 4294967295U);
#line 4811
    ixgbe_write_reg(hw, 2772U, 4294967295U);
#line 4812
    goto ldv_58456;
    }
    ldv_58456: ;
  } else {
#line 4817
    ixgbe_write_reg(hw, 2192U, 65535U);
  }
#line 4823
  if ((adapter->flags & 8388608U) != 0U) {
#line 4824
    gpie = gpie & 4294918143U;
#line 4826
    switch ((int )adapter->ring_feature[1].mask) {
    case 120: 
#line 4828
    gpie = gpie | 16384U;
#line 4829
    goto ldv_58463;
    case 124: 
#line 4831
    gpie = gpie | 32768U;
#line 4832
    goto ldv_58463;
    default: 
#line 4834
    gpie = gpie | 49152U;
#line 4835
    goto ldv_58463;
    }
    ldv_58463: ;
  } else {

  }
#line 4840
  if ((adapter->flags2 & 4U) != 0U) {
#line 4841
    switch ((unsigned int )adapter->hw.mac.type) {
    case 2U: 
#line 4843
    gpie = gpie | 1U;
#line 4844
    goto ldv_58467;
    case 3U: 
#line 4846
    gpie = gpie | 8388608U;
#line 4847
    goto ldv_58467;
    default: ;
#line 4849
    goto ldv_58467;
    }
    ldv_58467: ;
  } else {

  }
#line 4854
  if ((adapter->flags & 32768U) != 0U) {
#line 4855
    gpie = (u32 )*(hw->mvals + 9UL) | gpie;
  } else {

  }
#line 4857
  if ((unsigned int )hw->mac.type == 2U) {
#line 4858
    gpie = gpie | 2U;
#line 4859
    gpie = gpie | 4U;
  } else {

  }
#line 4862
  ixgbe_write_reg(hw, 2200U, gpie);
#line 4863
  return;
}
}
#line 4865 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_up_complete(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int err ;
  u32 ctrl_ext ;
  bool tmp ;
  u32 esdp ;
  u32 tmp___0 ;

  {
#line 4867
  hw = & adapter->hw;
#line 4871
  ixgbe_get_hw_control(adapter);
#line 4872
  ixgbe_setup_gpie(adapter);
#line 4874
  if ((adapter->flags & 8U) != 0U) {
#line 4875
    ixgbe_configure_msix(adapter);
  } else {
#line 4877
    ixgbe_configure_msi_and_legacy(adapter);
  }
#line 4880
  if ((unsigned long )hw->mac.ops.enable_tx_laser != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
#line 4881
    (*(hw->mac.ops.enable_tx_laser))(hw);
  } else {

  }
#line 4883
  if ((unsigned long )hw->phy.ops.set_phy_power != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                             bool  ))0)) {
#line 4884
    (*(hw->phy.ops.set_phy_power))(hw, 1);
  } else {

  }
#line 4886
  __asm__  volatile   ("": : : "memory");
#line 4887
  clear_bit(2L, (unsigned long volatile   *)(& adapter->state));
#line 4888
  ixgbe_napi_enable_all(adapter);
#line 4890
  tmp = ixgbe_is_sfp(hw);
#line 4890
  if ((int )tmp) {
#line 4891
    ixgbe_sfp_link_config(adapter);
  } else {
#line 4893
    err = ixgbe_non_sfp_link_config(hw);
#line 4894
    if (err != 0) {
#line 4895
      if (((int )adapter->msg_enable & 2) != 0) {
#line 4895
        netdev_err((struct net_device  const  *)adapter->netdev, "link_config FAILED %d\n",
                   err);
      } else {

      }
    } else {

    }
  }
#line 4899
  ixgbe_read_reg(hw, 2048U);
#line 4900
  ixgbe_irq_enable(adapter, 1, 1);
#line 4906
  if ((adapter->flags & 32768U) != 0U) {
#line 4907
    tmp___0 = ixgbe_read_reg(hw, 32U);
#line 4907
    esdp = tmp___0;
#line 4908
    if ((esdp & 2U) != 0U) {
#line 4909
      if ((int )adapter->msg_enable & 1) {
#line 4909
        netdev_crit((struct net_device  const  *)adapter->netdev, "Fan has stopped, replace the adapter\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 4914
  adapter->flags = adapter->flags | 65536U;
#line 4915
  adapter->link_check_timeout = jiffies;
#line 4916
  ldv_mod_timer_25(& adapter->service_timer, jiffies);
#line 4919
  ctrl_ext = ixgbe_read_reg(hw, 24U);
#line 4920
  ctrl_ext = ctrl_ext | 16384U;
#line 4921
  ixgbe_write_reg(hw, 24U, ctrl_ext);
#line 4922
  return;
}
}
#line 4924 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_reinit_locked(struct ixgbe_adapter *adapter ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 4926
  tmp = preempt_count();
#line 4926
  __ret_warn_on = ((unsigned long )tmp & 2096896UL) != 0UL;
#line 4926
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 4926
  if (tmp___0 != 0L) {
#line 4926
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c",
                       4926);
  } else {

  }
#line 4926
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 4928
  (adapter->netdev)->trans_start = jiffies;
#line 4930
  goto ldv_58483;
  ldv_58482: 
#line 4931
  usleep_range(1000UL, 2000UL);
  ldv_58483: 
#line 4930
  tmp___1 = test_and_set_bit(1L, (unsigned long volatile   *)(& adapter->state));
#line 4930
  if (tmp___1 != 0) {
#line 4932
    goto ldv_58482;
  } else {

  }
#line 4932
  ixgbe_down(adapter);
#line 4939
  if ((adapter->flags & 8388608U) != 0U) {
#line 4940
    msleep(2000U);
  } else {

  }
#line 4941
  ixgbe_up(adapter);
#line 4942
  clear_bit(1L, (unsigned long volatile   *)(& adapter->state));
#line 4943
  return;
}
}
#line 4945 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_up(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 4948
  ixgbe_configure(adapter);
#line 4950
  ixgbe_up_complete(adapter);
#line 4951
  return;
}
}
#line 4953 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_reset(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct net_device *netdev ;
  int err ;
  u8 old_addr[6U] ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 4955
  hw = & adapter->hw;
#line 4956
  netdev = adapter->netdev;
#line 4960
  tmp = ixgbe_removed((void *)hw->hw_addr);
#line 4960
  if ((int )tmp) {
#line 4961
    return;
  } else {

  }
#line 4963
  goto ldv_58496;
  ldv_58495: 
#line 4964
  usleep_range(1000UL, 2000UL);
  ldv_58496: 
#line 4963
  tmp___0 = test_and_set_bit(7L, (unsigned long volatile   *)(& adapter->state));
#line 4963
  if (tmp___0 != 0) {
#line 4965
    goto ldv_58495;
  } else {

  }
#line 4967
  adapter->flags2 = adapter->flags2 & 4294967247U;
#line 4969
  adapter->flags = adapter->flags & 4294836223U;
#line 4971
  err = (*(hw->mac.ops.init_hw))(hw);
#line 4972
  switch (err) {
  case 0: ;
  case -20: ;
  case -19: ;
#line 4976
  goto ldv_58501;
  case -12: 
#line 4978
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "master disable timed out\n");
#line 4979
  goto ldv_58501;
  case -24: 
#line 4982
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "This device is a pre-production adapter/LOM. Please be aware there may be issues associated with your hardware.  If you are experiencing problems please contact your Intel or hardware representative who provided you with this hardware.\n");
#line 4988
  goto ldv_58501;
  default: 
#line 4990
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Hardware Error: %d\n",
          err);
  }
  ldv_58501: 
#line 4993
  clear_bit(7L, (unsigned long volatile   *)(& adapter->state));
#line 4995
  memcpy((void *)(& old_addr), (void const   *)(& (adapter->mac_table)->addr), (size_t )netdev->addr_len);
#line 4996
  ixgbe_flush_sw_mac_table(adapter);
#line 4997
  ixgbe_mac_set_default_filter(adapter, (u8 *)(& old_addr));
#line 5000
  if ((unsigned int )hw->mac.san_mac_rar_index != 0U) {
#line 5001
    (*(hw->mac.ops.set_vmdq_san_mac))(hw, (u32 )adapter->ring_feature[1].offset);
  } else {

  }
#line 5003
  tmp___1 = constant_test_bit(8L, (unsigned long const volatile   *)(& adapter->state));
#line 5003
  if (tmp___1 != 0) {
#line 5004
    ixgbe_ptp_reset(adapter);
  } else {

  }
#line 5006
  if ((unsigned long )hw->phy.ops.set_phy_power != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                             bool  ))0)) {
#line 5007
    tmp___2 = netif_running((struct net_device  const  *)adapter->netdev);
#line 5007
    if (tmp___2) {
#line 5007
      tmp___3 = 0;
    } else {
#line 5007
      tmp___3 = 1;
    }
#line 5007
    if (tmp___3 && adapter->wol == 0U) {
#line 5008
      (*(hw->phy.ops.set_phy_power))(hw, 0);
    } else {
#line 5010
      (*(hw->phy.ops.set_phy_power))(hw, 1);
    }
  } else {

  }
#line 5011
  return;
}
}
#line 5018 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_clean_tx_ring(struct ixgbe_ring *tx_ring ) 
{ 
  struct ixgbe_tx_buffer *tx_buffer_info ;
  unsigned long size ;
  u16 i ;
  struct netdev_queue *tmp ;

  {
#line 5025
  if ((unsigned long )tx_ring->__annonCompField118.tx_buffer_info == (unsigned long )((struct ixgbe_tx_buffer *)0)) {
#line 5026
    return;
  } else {

  }
#line 5029
  i = 0U;
#line 5029
  goto ldv_58512;
  ldv_58511: 
#line 5030
  tx_buffer_info = tx_ring->__annonCompField118.tx_buffer_info + (unsigned long )i;
#line 5031
  ixgbe_unmap_and_free_tx_resource(tx_ring, tx_buffer_info);
#line 5029
  i = (u16 )((int )i + 1);
  ldv_58512: ;
#line 5029
  if ((int )tx_ring->count > (int )i) {
#line 5031
    goto ldv_58511;
  } else {

  }
#line 5034
  tmp = txring_txq((struct ixgbe_ring  const  *)tx_ring);
#line 5034
  netdev_tx_reset_queue(tmp);
#line 5036
  size = (unsigned long )tx_ring->count * 48UL;
#line 5037
  memset((void *)tx_ring->__annonCompField118.tx_buffer_info, 0, size);
#line 5040
  memset(tx_ring->desc, 0, (size_t )tx_ring->size);
#line 5042
  tx_ring->next_to_use = 0U;
#line 5043
  tx_ring->next_to_clean = 0U;
#line 5044
  return;
}
}
#line 5050 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_clean_all_rx_rings(struct ixgbe_adapter *adapter ) 
{ 
  int i ;

  {
#line 5054
  i = 0;
#line 5054
  goto ldv_58519;
  ldv_58518: 
#line 5055
  ixgbe_clean_rx_ring(adapter->rx_ring[i]);
#line 5054
  i = i + 1;
  ldv_58519: ;
#line 5054
  if (adapter->num_rx_queues > i) {
#line 5056
    goto ldv_58518;
  } else {

  }

#line 5061
  return;
}
}
#line 5062 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_clean_all_tx_rings(struct ixgbe_adapter *adapter ) 
{ 
  int i ;

  {
#line 5066
  i = 0;
#line 5066
  goto ldv_58526;
  ldv_58525: 
#line 5067
  ixgbe_clean_tx_ring(adapter->tx_ring[i]);
#line 5066
  i = i + 1;
  ldv_58526: ;
#line 5066
  if (adapter->num_tx_queues > i) {
#line 5068
    goto ldv_58525;
  } else {

  }

#line 5073
  return;
}
}
#line 5070 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_fdir_filter_exit(struct ixgbe_adapter *adapter ) 
{ 
  struct hlist_node *node2 ;
  struct ixgbe_fdir_filter *filter ;
  struct hlist_node *____ptr ;
  struct hlist_node  const  *__mptr ;
  struct ixgbe_fdir_filter *tmp ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node  const  *__mptr___0 ;
  struct ixgbe_fdir_filter *tmp___0 ;

  {
#line 5075
  spin_lock(& adapter->fdir_perfect_lock);
#line 5077
  ____ptr = adapter->fdir_filter_list.first;
#line 5077
  if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
#line 5077
    __mptr = (struct hlist_node  const  *)____ptr;
#line 5077
    tmp = (struct ixgbe_fdir_filter *)__mptr;
  } else {
#line 5077
    tmp = (struct ixgbe_fdir_filter *)0;
  }
#line 5077
  filter = tmp;
#line 5077
  goto ldv_58543;
  ldv_58542: 
#line 5079
  hlist_del(& filter->fdir_node);
#line 5080
  kfree((void const   *)filter);
#line 5077
  ____ptr___0 = node2;
#line 5077
  if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
#line 5077
    __mptr___0 = (struct hlist_node  const  *)____ptr___0;
#line 5077
    tmp___0 = (struct ixgbe_fdir_filter *)__mptr___0;
  } else {
#line 5077
    tmp___0 = (struct ixgbe_fdir_filter *)0;
  }
#line 5077
  filter = tmp___0;
  ldv_58543: ;
#line 5077
  if ((unsigned long )filter != (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 5077
    node2 = filter->fdir_node.next;
#line 5079
    goto ldv_58542;
  } else {

  }
#line 5082
  adapter->fdir_filter_count = 0;
#line 5084
  spin_unlock(& adapter->fdir_perfect_lock);
#line 5085
  return;
}
}
#line 5087 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_down(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct ixgbe_hw *hw ;
  struct net_device *upper ;
  struct list_head *iter ;
  int i ;
  int tmp ;
  struct macvlan_dev *vlan ;
  void *tmp___0 ;
  bool tmp___1 ;
  u8 reg_idx ;
  u32 tmp___2 ;
  int tmp___3 ;

  {
#line 5089
  netdev = adapter->netdev;
#line 5090
  hw = & adapter->hw;
#line 5096
  tmp = test_and_set_bit(2L, (unsigned long volatile   *)(& adapter->state));
#line 5096
  if (tmp != 0) {
#line 5097
    return;
  } else {

  }
#line 5100
  (*(hw->mac.ops.disable_rx))(hw);
#line 5103
  i = 0;
#line 5103
  goto ldv_58554;
  ldv_58553: 
#line 5105
  ixgbe_disable_rx_queue(adapter, adapter->rx_ring[i]);
#line 5103
  i = i + 1;
  ldv_58554: ;
#line 5103
  if (adapter->num_rx_queues > i) {
#line 5105
    goto ldv_58553;
  } else {

  }
#line 5107
  usleep_range(10000UL, 20000UL);
#line 5109
  netif_tx_stop_all_queues(netdev);
#line 5112
  netif_carrier_off(netdev);
#line 5113
  netif_tx_disable(netdev);
#line 5116
  iter = & (adapter->netdev)->all_adj_list.upper;
#line 5116
  upper = netdev_all_upper_get_next_dev_rcu(adapter->netdev, & iter);
#line 5116
  goto ldv_58558;
  ldv_58557: 
#line 5117
  tmp___1 = netif_is_macvlan(upper);
#line 5117
  if ((int )tmp___1) {
#line 5118
    tmp___0 = netdev_priv((struct net_device  const  *)upper);
#line 5118
    vlan = (struct macvlan_dev *)tmp___0;
#line 5120
    if ((unsigned long )vlan->fwd_priv != (unsigned long )((void *)0)) {
#line 5121
      netif_tx_stop_all_queues(upper);
#line 5122
      netif_carrier_off(upper);
#line 5123
      netif_tx_disable(upper);
    } else {

    }
  } else {

  }
#line 5116
  upper = netdev_all_upper_get_next_dev_rcu(adapter->netdev, & iter);
  ldv_58558: ;
#line 5116
  if ((unsigned long )upper != (unsigned long )((struct net_device *)0)) {
#line 5118
    goto ldv_58557;
  } else {

  }
#line 5128
  ixgbe_irq_disable(adapter);
#line 5130
  ixgbe_napi_disable_all(adapter);
#line 5132
  adapter->flags2 = adapter->flags2 & 4294967103U;
#line 5134
  adapter->flags = adapter->flags & 4294901759U;
#line 5136
  ldv_del_timer_sync_26(& adapter->service_timer);
#line 5138
  if (adapter->num_vfs != 0U) {
#line 5140
    ixgbe_write_reg(& adapter->hw, 2196U, 0U);
#line 5143
    i = 0;
#line 5143
    goto ldv_58561;
    ldv_58560: 
#line 5144
    (adapter->vfinfo + (unsigned long )i)->clear_to_send = 0;
#line 5143
    i = i + 1;
    ldv_58561: ;
#line 5143
    if ((unsigned int )i < adapter->num_vfs) {
#line 5145
      goto ldv_58560;
    } else {

    }
#line 5147
    ixgbe_ping_all_vfs(adapter);
#line 5150
    ixgbe_disable_tx_rx(adapter);
  } else {

  }
#line 5154
  i = 0;
#line 5154
  goto ldv_58565;
  ldv_58564: 
#line 5155
  reg_idx = (adapter->tx_ring[i])->reg_idx;
#line 5156
  ixgbe_write_reg(hw, (u32 )((int )reg_idx * 64 + 24616), 67108864U);
#line 5154
  i = i + 1;
  ldv_58565: ;
#line 5154
  if (adapter->num_tx_queues > i) {
#line 5156
    goto ldv_58564;
  } else {

  }

#line 5160
  switch ((unsigned int )hw->mac.type) {
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 5165
  tmp___2 = ixgbe_read_reg(hw, 19072U);
#line 5165
  ixgbe_write_reg(hw, 19072U, tmp___2 & 4294967294U);
#line 5168
  goto ldv_58571;
  default: ;
#line 5170
  goto ldv_58571;
  }
  ldv_58571: 
#line 5173
  tmp___3 = pci_channel_offline(adapter->pdev);
#line 5173
  if (tmp___3 == 0) {
#line 5174
    ixgbe_reset(adapter);
  } else {

  }
#line 5177
  if ((unsigned long )hw->mac.ops.disable_tx_laser != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
#line 5178
    (*(hw->mac.ops.disable_tx_laser))(hw);
  } else {

  }
#line 5180
  ixgbe_clean_all_tx_rings(adapter);
#line 5181
  ixgbe_clean_all_rx_rings(adapter);
#line 5185
  ixgbe_setup_dca(adapter);
#line 5186
  return;
}
}
#line 5193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_tx_timeout(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 5195
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 5195
  adapter = (struct ixgbe_adapter *)tmp;
#line 5198
  ixgbe_tx_timeout_reset(adapter);
#line 5199
  return;
}
}
#line 5209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_sw_init(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct pci_dev *pdev ;
  unsigned int rss ;
  unsigned int fdir ;
  u32 fwsm ;
  int j ;
  struct tc_configuration *tc ;
  int __min1 ;
  u8 tmp ;
  int __min2 ;
  unsigned int tmp___0 ;
  int __min1___0 ;
  int __min2___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  s32 tmp___3 ;

  {
#line 5211
  hw = & adapter->hw;
#line 5212
  pdev = adapter->pdev;
#line 5222
  hw->vendor_id = pdev->vendor;
#line 5223
  hw->device_id = pdev->device;
#line 5224
  hw->revision_id = pdev->revision;
#line 5225
  hw->subsystem_vendor_id = pdev->subsystem_vendor;
#line 5226
  hw->subsystem_device_id = pdev->subsystem_device;
#line 5229
  tmp = ixgbe_max_rss_indices(adapter);
#line 5229
  __min1 = (int )tmp;
#line 5229
  tmp___0 = cpumask_weight(cpu_online_mask);
#line 5229
  __min2 = (int )tmp___0;
#line 5229
  rss = (unsigned int )(__min1 < __min2 ? __min1 : __min2);
#line 5230
  adapter->ring_feature[2].limit = (u16 )rss;
#line 5231
  adapter->flags2 = adapter->flags2 | 1U;
#line 5232
  adapter->flags2 = adapter->flags2 | 2U;
#line 5233
  adapter->max_q_vectors = 64;
#line 5234
  adapter->atr_sample_rate = 20U;
#line 5235
  __min1___0 = 63;
#line 5235
  tmp___1 = cpumask_weight(cpu_online_mask);
#line 5235
  __min2___0 = (int )tmp___1;
#line 5235
  fdir = (unsigned int )(__min1___0 < __min2___0 ? __min1___0 : __min2___0);
#line 5236
  adapter->ring_feature[3].limit = (u16 )fdir;
#line 5237
  adapter->fdir_pballoc = 1U;
#line 5239
  adapter->flags = adapter->flags | 512U;
#line 5242
  adapter->flags = adapter->flags | 1048576U;
#line 5243
  adapter->flags = adapter->flags & 4292870143U;
#line 5246
  adapter->fcoe.up = 3U;
#line 5250
  tmp___2 = kzalloc((unsigned long )hw->mac.num_rar_entries * 10UL, 32U);
#line 5250
  adapter->mac_table = (struct ixgbe_mac_addr *)tmp___2;
#line 5255
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 5257
  adapter->flags2 = adapter->flags2 & 4294967294U;
#line 5258
  adapter->flags2 = adapter->flags2 & 4294967293U;
#line 5260
  if ((unsigned int )hw->device_id == 4296U) {
#line 5261
    adapter->flags = adapter->flags | 32768U;
  } else {

  }
#line 5263
  adapter->max_q_vectors = 16;
#line 5264
  adapter->ring_feature[3].limit = 0U;
#line 5265
  adapter->atr_sample_rate = 0U;
#line 5266
  adapter->fdir_pballoc = 0U;
#line 5268
  adapter->flags = adapter->flags & 4293918719U;
#line 5269
  adapter->flags = adapter->flags & 4292870143U;
#line 5271
  adapter->fcoe.up = 0U;
#line 5274
  goto ldv_58594;
  case 2U: ;
#line 5276
  if ((unsigned int )hw->device_id == 5404U) {
#line 5277
    adapter->flags2 = adapter->flags2 | 4U;
  } else {

  }
#line 5278
  goto ldv_58594;
  case 3U: 
#line 5280
  fwsm = ixgbe_read_reg(hw, *(hw->mvals + 7UL));
#line 5281
  if ((int )fwsm & 1) {
#line 5282
    adapter->flags2 = adapter->flags2 | 4U;
  } else {

  }
#line 5283
  goto ldv_58594;
  case 5U: ;
  case 4U: 
#line 5287
  adapter->flags = adapter->flags & 4294966783U;
#line 5289
  goto ldv_58594;
  default: ;
#line 5291
  goto ldv_58594;
  }
  ldv_58594: 
#line 5296
  spinlock_check(& adapter->fcoe.lock);
#line 5296
  __raw_spin_lock_init(& adapter->fcoe.lock.__annonCompField17.rlock, "&(&adapter->fcoe.lock)->rlock",
                       & __key);
#line 5300
  spinlock_check(& adapter->fdir_perfect_lock);
#line 5300
  __raw_spin_lock_init(& adapter->fdir_perfect_lock.__annonCompField17.rlock, "&(&adapter->fdir_perfect_lock)->rlock",
                       & __key___0);
#line 5303
  switch ((unsigned int )hw->mac.type) {
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 5307
  adapter->dcb_cfg.num_tcs.pg_tcs = 4U;
#line 5308
  adapter->dcb_cfg.num_tcs.pfc_tcs = 4U;
#line 5309
  goto ldv_58605;
  default: 
#line 5311
  adapter->dcb_cfg.num_tcs.pg_tcs = 8U;
#line 5312
  adapter->dcb_cfg.num_tcs.pfc_tcs = 8U;
#line 5313
  goto ldv_58605;
  }
  ldv_58605: 
#line 5317
  j = 0;
#line 5317
  goto ldv_58608;
  ldv_58607: 
#line 5318
  tc = (struct tc_configuration *)(& adapter->dcb_cfg.tc_config) + (unsigned long )j;
#line 5319
  tc->path[0].bwg_id = 0U;
#line 5320
  tc->path[0].bwg_percent = ((unsigned int )((u8 )j) & 1U) + 12U;
#line 5321
  tc->path[1].bwg_id = 0U;
#line 5322
  tc->path[1].bwg_percent = ((unsigned int )((u8 )j) & 1U) + 12U;
#line 5323
  tc->dcb_pfc = 0;
#line 5317
  j = j + 1;
  ldv_58608: ;
#line 5317
  if (j <= 7) {
#line 5319
    goto ldv_58607;
  } else {

  }
#line 5327
  tc = (struct tc_configuration *)(& adapter->dcb_cfg.tc_config);
#line 5328
  tc->path[0].up_to_tc_bitmap = 255U;
#line 5329
  tc->path[1].up_to_tc_bitmap = 255U;
#line 5331
  adapter->dcb_cfg.bw_percentage[0][0] = 100U;
#line 5332
  adapter->dcb_cfg.bw_percentage[1][0] = 100U;
#line 5333
  adapter->dcb_cfg.pfc_mode_enable = 0;
#line 5334
  adapter->dcb_set_bitmap = 0U;
#line 5335
  adapter->dcbx_cap = 5U;
#line 5336
  memcpy((void *)(& adapter->temp_dcb_cfg), (void const   *)(& adapter->dcb_cfg),
           296UL);
#line 5342
  hw->fc.requested_mode = 3;
#line 5343
  hw->fc.current_mode = 3;
#line 5344
  ixgbe_pbthresh_setup(adapter);
#line 5345
  hw->fc.pause_time = 65535U;
#line 5346
  hw->fc.send_xon = 1;
#line 5347
  hw->fc.disable_fc_autoneg = ixgbe_device_supports_autoneg_fc(hw);
#line 5350
  if (max_vfs != 0U) {
#line 5351
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Enabling SR-IOV VFs using the max_vfs module parameter is deprecated - please use the pci sysfs interface instead.\n");
  } else {

  }
#line 5354
  if ((unsigned int )hw->mac.type != 1U) {
#line 5355
    if (max_vfs > 63U) {
#line 5356
      adapter->num_vfs = 0U;
#line 5357
      dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "max_vfs parameter out of range. Not assigning any SR-IOV VFs\n");
    } else {
#line 5359
      adapter->num_vfs = max_vfs;
    }
  } else {

  }
#line 5365
  adapter->rx_itr_setting = 1U;
#line 5366
  adapter->tx_itr_setting = 1U;
#line 5369
  adapter->tx_ring_count = 512U;
#line 5370
  adapter->rx_ring_count = 512U;
#line 5373
  adapter->tx_work_limit = 256U;
#line 5376
  tmp___3 = ixgbe_init_eeprom_params_generic(hw);
#line 5376
  if (tmp___3 != 0) {
#line 5377
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "EEPROM initialization failed\n");
#line 5378
    return (-5);
  } else {

  }
#line 5382
  set_bit(0L, (unsigned long volatile   *)(& adapter->fwd_bitmask));
#line 5383
  set_bit(2L, (unsigned long volatile   *)(& adapter->state));
#line 5385
  return (0);
}
}
#line 5394 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_setup_tx_resources(struct ixgbe_ring *tx_ring ) 
{ 
  struct device *dev ;
  int orig_node ;
  int tmp ;
  int ring_node ;
  int size ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 5396
  dev = tx_ring->dev;
#line 5397
  tmp = dev_to_node(dev);
#line 5397
  orig_node = tmp;
#line 5398
  ring_node = -1;
#line 5401
  size = (int )((unsigned int )tx_ring->count * 48U);
#line 5403
  if ((unsigned long )tx_ring->q_vector != (unsigned long )((struct ixgbe_q_vector *)0)) {
#line 5404
    ring_node = (tx_ring->q_vector)->numa_node;
  } else {

  }
#line 5406
  tmp___0 = vzalloc_node((unsigned long )size, ring_node);
#line 5406
  tx_ring->__annonCompField118.tx_buffer_info = (struct ixgbe_tx_buffer *)tmp___0;
#line 5407
  if ((unsigned long )tx_ring->__annonCompField118.tx_buffer_info == (unsigned long )((struct ixgbe_tx_buffer *)0)) {
#line 5408
    tmp___1 = vzalloc((unsigned long )size);
#line 5408
    tx_ring->__annonCompField118.tx_buffer_info = (struct ixgbe_tx_buffer *)tmp___1;
  } else {

  }
#line 5409
  if ((unsigned long )tx_ring->__annonCompField118.tx_buffer_info == (unsigned long )((struct ixgbe_tx_buffer *)0)) {
#line 5410
    goto err;
  } else {

  }
#line 5412
  u64_stats_init(& tx_ring->syncp);
#line 5415
  tx_ring->size = (unsigned int )tx_ring->count * 16U;
#line 5416
  tx_ring->size = (tx_ring->size + 4095U) & 4294963200U;
#line 5418
  set_dev_node(dev, ring_node);
#line 5419
  tx_ring->desc = dma_alloc_attrs(dev, (size_t )tx_ring->size, & tx_ring->dma, 208U,
                                  (struct dma_attrs *)0);
#line 5423
  set_dev_node(dev, orig_node);
#line 5424
  if ((unsigned long )tx_ring->desc == (unsigned long )((void *)0)) {
#line 5425
    tx_ring->desc = dma_alloc_attrs(dev, (size_t )tx_ring->size, & tx_ring->dma, 208U,
                                    (struct dma_attrs *)0);
  } else {

  }
#line 5427
  if ((unsigned long )tx_ring->desc == (unsigned long )((void *)0)) {
#line 5428
    goto err;
  } else {

  }
#line 5430
  tx_ring->next_to_use = 0U;
#line 5431
  tx_ring->next_to_clean = 0U;
#line 5432
  return (0);
  err: 
#line 5435
  vfree((void const   *)tx_ring->__annonCompField118.tx_buffer_info);
#line 5436
  tx_ring->__annonCompField118.tx_buffer_info = (struct ixgbe_tx_buffer *)0;
#line 5437
  dev_err((struct device  const  *)dev, "Unable to allocate memory for the Tx descriptor ring\n");
#line 5438
  return (-12);
}
}
#line 5451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_setup_all_tx_resources(struct ixgbe_adapter *adapter ) 
{ 
  int i ;
  int err ;
  int tmp ;

  {
#line 5453
  err = 0;
#line 5455
  i = 0;
#line 5455
  goto ldv_58626;
  ldv_58625: 
#line 5456
  err = ixgbe_setup_tx_resources(adapter->tx_ring[i]);
#line 5457
  if (err == 0) {
#line 5458
    goto ldv_58623;
  } else {

  }
#line 5460
  if (((int )adapter->msg_enable & 2) != 0) {
#line 5460
    netdev_err((struct net_device  const  *)adapter->netdev, "Allocation for Tx Queue %u failed\n",
               i);
  } else {

  }
#line 5461
  goto err_setup_tx;
  ldv_58623: 
#line 5455
  i = i + 1;
  ldv_58626: ;
#line 5455
  if (adapter->num_tx_queues > i) {
#line 5457
    goto ldv_58625;
  } else {

  }

#line 5464
  return (0);
  err_setup_tx: ;
#line 5467
  goto ldv_58629;
  ldv_58628: 
#line 5468
  ixgbe_free_tx_resources(adapter->tx_ring[i]);
  ldv_58629: 
#line 5467
  tmp = i;
#line 5467
  i = i - 1;
#line 5467
  if (tmp != 0) {
#line 5469
    goto ldv_58628;
  } else {

  }

#line 5469
  return (err);
}
}
#line 5478 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_setup_rx_resources(struct ixgbe_ring *rx_ring ) 
{ 
  struct device *dev ;
  int orig_node ;
  int tmp ;
  int ring_node ;
  int size ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 5480
  dev = rx_ring->dev;
#line 5481
  tmp = dev_to_node(dev);
#line 5481
  orig_node = tmp;
#line 5482
  ring_node = -1;
#line 5485
  size = (int )((unsigned int )rx_ring->count * 32U);
#line 5487
  if ((unsigned long )rx_ring->q_vector != (unsigned long )((struct ixgbe_q_vector *)0)) {
#line 5488
    ring_node = (rx_ring->q_vector)->numa_node;
  } else {

  }
#line 5490
  tmp___0 = vzalloc_node((unsigned long )size, ring_node);
#line 5490
  rx_ring->__annonCompField118.rx_buffer_info = (struct ixgbe_rx_buffer *)tmp___0;
#line 5491
  if ((unsigned long )rx_ring->__annonCompField118.rx_buffer_info == (unsigned long )((struct ixgbe_rx_buffer *)0)) {
#line 5492
    tmp___1 = vzalloc((unsigned long )size);
#line 5492
    rx_ring->__annonCompField118.rx_buffer_info = (struct ixgbe_rx_buffer *)tmp___1;
  } else {

  }
#line 5493
  if ((unsigned long )rx_ring->__annonCompField118.rx_buffer_info == (unsigned long )((struct ixgbe_rx_buffer *)0)) {
#line 5494
    goto err;
  } else {

  }
#line 5496
  u64_stats_init(& rx_ring->syncp);
#line 5499
  rx_ring->size = (unsigned int )rx_ring->count * 16U;
#line 5500
  rx_ring->size = (rx_ring->size + 4095U) & 4294963200U;
#line 5502
  set_dev_node(dev, ring_node);
#line 5503
  rx_ring->desc = dma_alloc_attrs(dev, (size_t )rx_ring->size, & rx_ring->dma, 208U,
                                  (struct dma_attrs *)0);
#line 5507
  set_dev_node(dev, orig_node);
#line 5508
  if ((unsigned long )rx_ring->desc == (unsigned long )((void *)0)) {
#line 5509
    rx_ring->desc = dma_alloc_attrs(dev, (size_t )rx_ring->size, & rx_ring->dma, 208U,
                                    (struct dma_attrs *)0);
  } else {

  }
#line 5511
  if ((unsigned long )rx_ring->desc == (unsigned long )((void *)0)) {
#line 5512
    goto err;
  } else {

  }
#line 5514
  rx_ring->next_to_clean = 0U;
#line 5515
  rx_ring->next_to_use = 0U;
#line 5517
  return (0);
  err: 
#line 5519
  vfree((void const   *)rx_ring->__annonCompField118.rx_buffer_info);
#line 5520
  rx_ring->__annonCompField118.rx_buffer_info = (struct ixgbe_rx_buffer *)0;
#line 5521
  dev_err((struct device  const  *)dev, "Unable to allocate memory for the Rx descriptor ring\n");
#line 5522
  return (-12);
}
}
#line 5535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_setup_all_rx_resources(struct ixgbe_adapter *adapter ) 
{ 
  int i ;
  int err ;
  int tmp ;

  {
#line 5537
  err = 0;
#line 5539
  i = 0;
#line 5539
  goto ldv_58647;
  ldv_58646: 
#line 5540
  err = ixgbe_setup_rx_resources(adapter->rx_ring[i]);
#line 5541
  if (err == 0) {
#line 5542
    goto ldv_58644;
  } else {

  }
#line 5544
  if (((int )adapter->msg_enable & 2) != 0) {
#line 5544
    netdev_err((struct net_device  const  *)adapter->netdev, "Allocation for Rx Queue %u failed\n",
               i);
  } else {

  }
#line 5545
  goto err_setup_rx;
  ldv_58644: 
#line 5539
  i = i + 1;
  ldv_58647: ;
#line 5539
  if (adapter->num_rx_queues > i) {
#line 5541
    goto ldv_58646;
  } else {

  }
#line 5549
  err = ixgbe_setup_fcoe_ddp_resources(adapter);
#line 5550
  if (err == 0) {
#line 5552
    return (0);
  } else {

  }
  err_setup_rx: ;
#line 5555
  goto ldv_58650;
  ldv_58649: 
#line 5556
  ixgbe_free_rx_resources(adapter->rx_ring[i]);
  ldv_58650: 
#line 5555
  tmp = i;
#line 5555
  i = i - 1;
#line 5555
  if (tmp != 0) {
#line 5557
    goto ldv_58649;
  } else {

  }

#line 5557
  return (err);
}
}
#line 5566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_free_tx_resources(struct ixgbe_ring *tx_ring ) 
{ 


  {
#line 5568
  ixgbe_clean_tx_ring(tx_ring);
#line 5570
  vfree((void const   *)tx_ring->__annonCompField118.tx_buffer_info);
#line 5571
  tx_ring->__annonCompField118.tx_buffer_info = (struct ixgbe_tx_buffer *)0;
#line 5574
  if ((unsigned long )tx_ring->desc == (unsigned long )((void *)0)) {
#line 5575
    return;
  } else {

  }
#line 5577
  dma_free_attrs(tx_ring->dev, (size_t )tx_ring->size, tx_ring->desc, tx_ring->dma,
                 (struct dma_attrs *)0);
#line 5580
  tx_ring->desc = (void *)0;
#line 5581
  return;
}
}
#line 5589 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_free_all_tx_resources(struct ixgbe_adapter *adapter ) 
{ 
  int i ;

  {
#line 5593
  i = 0;
#line 5593
  goto ldv_58660;
  ldv_58659: ;
#line 5594
  if ((unsigned long )(adapter->tx_ring[i])->desc != (unsigned long )((void *)0)) {
#line 5595
    ixgbe_free_tx_resources(adapter->tx_ring[i]);
  } else {

  }
#line 5593
  i = i + 1;
  ldv_58660: ;
#line 5593
  if (adapter->num_tx_queues > i) {
#line 5595
    goto ldv_58659;
  } else {

  }

#line 5600
  return;
}
}
#line 5604 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_free_rx_resources(struct ixgbe_ring *rx_ring ) 
{ 


  {
#line 5606
  ixgbe_clean_rx_ring(rx_ring);
#line 5608
  vfree((void const   *)rx_ring->__annonCompField118.rx_buffer_info);
#line 5609
  rx_ring->__annonCompField118.rx_buffer_info = (struct ixgbe_rx_buffer *)0;
#line 5612
  if ((unsigned long )rx_ring->desc == (unsigned long )((void *)0)) {
#line 5613
    return;
  } else {

  }
#line 5615
  dma_free_attrs(rx_ring->dev, (size_t )rx_ring->size, rx_ring->desc, rx_ring->dma,
                 (struct dma_attrs *)0);
#line 5618
  rx_ring->desc = (void *)0;
#line 5619
  return;
}
}
#line 5627 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_free_all_rx_resources(struct ixgbe_adapter *adapter ) 
{ 
  int i ;

  {
#line 5632
  ixgbe_free_fcoe_ddp_resources(adapter);
#line 5635
  i = 0;
#line 5635
  goto ldv_58670;
  ldv_58669: ;
#line 5636
  if ((unsigned long )(adapter->rx_ring[i])->desc != (unsigned long )((void *)0)) {
#line 5637
    ixgbe_free_rx_resources(adapter->rx_ring[i]);
  } else {

  }
#line 5635
  i = i + 1;
  ldv_58670: ;
#line 5635
  if (adapter->num_rx_queues > i) {
#line 5637
    goto ldv_58669;
  } else {

  }

#line 5642
  return;
}
}
#line 5647 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_change_mtu(struct net_device *netdev , int new_mtu ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int max_frame ;
  bool tmp___0 ;

  {
#line 5649
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 5649
  adapter = (struct ixgbe_adapter *)tmp;
#line 5650
  max_frame = new_mtu + 18;
#line 5653
  if (new_mtu <= 67 || max_frame > 9728) {
#line 5654
    return (-22);
  } else {

  }
#line 5661
  if (((adapter->flags & 8388608U) != 0U && (unsigned int )adapter->hw.mac.type == 2U) && max_frame > 1518) {
#line 5664
    if (((int )adapter->msg_enable & 2) != 0) {
#line 5664
      netdev_warn((struct net_device  const  *)adapter->netdev, "Setting MTU > 1500 will disable legacy VFs\n");
    } else {

    }
  } else {

  }
#line 5666
  if (((int )adapter->msg_enable & 2) != 0) {
#line 5666
    netdev_info((struct net_device  const  *)adapter->netdev, "changing MTU from %d to %d\n",
                netdev->mtu, new_mtu);
  } else {

  }
#line 5669
  netdev->mtu = (unsigned int )new_mtu;
#line 5671
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 5671
  if ((int )tmp___0) {
#line 5672
    ixgbe_reinit_locked(adapter);
  } else {

  }
#line 5674
  return (0);
}
}
#line 5689 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_open(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  int err ;
  int queues ;
  int tmp___0 ;

  {
#line 5691
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 5691
  adapter = (struct ixgbe_adapter *)tmp;
#line 5692
  hw = & adapter->hw;
#line 5696
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile   *)(& adapter->state));
#line 5696
  if (tmp___0 != 0) {
#line 5697
    return (-16);
  } else {

  }
#line 5699
  netif_carrier_off(netdev);
#line 5702
  err = ixgbe_setup_all_tx_resources(adapter);
#line 5703
  if (err != 0) {
#line 5704
    goto err_setup_tx;
  } else {

  }
#line 5707
  err = ixgbe_setup_all_rx_resources(adapter);
#line 5708
  if (err != 0) {
#line 5709
    goto err_setup_rx;
  } else {

  }
#line 5711
  ixgbe_configure(adapter);
#line 5713
  err = ixgbe_request_irq(adapter);
#line 5714
  if (err != 0) {
#line 5715
    goto err_req_irq;
  } else {

  }
#line 5718
  if (adapter->num_rx_pools > 1) {
#line 5719
    queues = adapter->num_rx_queues_per_pool;
  } else {
#line 5721
    queues = adapter->num_tx_queues;
  }
#line 5723
  err = netif_set_real_num_tx_queues(netdev, (unsigned int )queues);
#line 5724
  if (err != 0) {
#line 5725
    goto err_set_queues;
  } else {

  }
#line 5727
  if (adapter->num_rx_pools > 1 && adapter->num_rx_queues > 4) {
#line 5729
    queues = 4;
  } else {
#line 5731
    queues = adapter->num_rx_queues;
  }
#line 5732
  err = netif_set_real_num_rx_queues(netdev, (unsigned int )queues);
#line 5733
  if (err != 0) {
#line 5734
    goto err_set_queues;
  } else {

  }
#line 5736
  ixgbe_ptp_init(adapter);
#line 5738
  ixgbe_up_complete(adapter);
#line 5741
  vxlan_get_rx_port(netdev);
#line 5744
  return (0);
  err_set_queues: 
#line 5747
  ixgbe_free_irq(adapter);
  err_req_irq: 
#line 5749
  ixgbe_free_all_rx_resources(adapter);
#line 5750
  if ((unsigned long )hw->phy.ops.set_phy_power != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                             bool  ))0) && adapter->wol == 0U) {
#line 5751
    (*(hw->phy.ops.set_phy_power))(& adapter->hw, 0);
  } else {

  }
  err_setup_rx: 
#line 5753
  ixgbe_free_all_tx_resources(adapter);
  err_setup_tx: 
#line 5755
  ixgbe_reset(adapter);
#line 5757
  return (err);
}
}
#line 5760 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_close_suspend(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 5762
  ixgbe_ptp_suspend(adapter);
#line 5764
  ixgbe_down(adapter);
#line 5765
  ixgbe_free_irq(adapter);
#line 5767
  ixgbe_free_all_tx_resources(adapter);
#line 5768
  ixgbe_free_all_rx_resources(adapter);
#line 5769
  return;
}
}
#line 5782 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_close(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 5784
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 5784
  adapter = (struct ixgbe_adapter *)tmp;
#line 5786
  ixgbe_ptp_stop(adapter);
#line 5788
  ixgbe_close_suspend(adapter);
#line 5790
  ixgbe_fdir_filter_exit(adapter);
#line 5792
  ixgbe_release_hw_control(adapter);
#line 5794
  return (0);
}
}
#line 5798 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_resume(struct pci_dev *pdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  u32 err ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;

  {
#line 5800
  tmp = pci_get_drvdata(pdev);
#line 5800
  adapter = (struct ixgbe_adapter *)tmp;
#line 5801
  netdev = adapter->netdev;
#line 5804
  adapter->hw.hw_addr = adapter->io_addr;
#line 5805
  pci_set_power_state(pdev, 0);
#line 5806
  pci_restore_state(pdev);
#line 5811
  pci_save_state(pdev);
#line 5813
  tmp___0 = pci_enable_device_mem(pdev);
#line 5813
  err = (u32 )tmp___0;
#line 5814
  if (err != 0U) {
#line 5815
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Cannot enable PCI device from suspend\n");
#line 5816
    return ((int )err);
  } else {

  }
#line 5818
  __asm__  volatile   ("": : : "memory");
#line 5819
  clear_bit(3L, (unsigned long volatile   *)(& adapter->state));
#line 5820
  pci_set_master(pdev);
#line 5822
  pci_wake_from_d3(pdev, 0);
#line 5824
  ixgbe_reset(adapter);
#line 5826
  ixgbe_write_reg(& adapter->hw, 22544U, 4294967295U);
#line 5828
  rtnl_lock();
#line 5829
  tmp___1 = ixgbe_init_interrupt_scheme(adapter);
#line 5829
  err = (u32 )tmp___1;
#line 5830
  if (err == 0U) {
#line 5830
    tmp___3 = netif_running((struct net_device  const  *)netdev);
#line 5830
    if ((int )tmp___3) {
#line 5831
      tmp___2 = ixgbe_open(netdev);
#line 5831
      err = (u32 )tmp___2;
    } else {

    }
  } else {

  }
#line 5833
  rtnl_unlock();
#line 5835
  if (err != 0U) {
#line 5836
    return ((int )err);
  } else {

  }
#line 5838
  netif_device_attach(netdev);
#line 5840
  return (0);
}
}
#line 5844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int __ixgbe_shutdown(struct pci_dev *pdev , bool *enable_wake ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  struct ixgbe_hw *hw ;
  u32 ctrl ;
  u32 fctrl ;
  u32 wufc ;
  int retval ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 5846
  tmp = pci_get_drvdata(pdev);
#line 5846
  adapter = (struct ixgbe_adapter *)tmp;
#line 5847
  netdev = adapter->netdev;
#line 5848
  hw = & adapter->hw;
#line 5850
  wufc = adapter->wol;
#line 5852
  retval = 0;
#line 5855
  netif_device_detach(netdev);
#line 5857
  rtnl_lock();
#line 5858
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 5858
  if ((int )tmp___0) {
#line 5859
    ixgbe_close_suspend(adapter);
  } else {

  }
#line 5860
  rtnl_unlock();
#line 5862
  ixgbe_clear_interrupt_scheme(adapter);
#line 5865
  retval = pci_save_state(pdev);
#line 5866
  if (retval != 0) {
#line 5867
    return (retval);
  } else {

  }
#line 5870
  if ((unsigned long )hw->mac.ops.stop_link_on_d3 != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
#line 5871
    (*(hw->mac.ops.stop_link_on_d3))(hw);
  } else {

  }
#line 5873
  if (wufc != 0U) {
#line 5874
    ixgbe_set_rx_mode(netdev);
#line 5877
    if ((unsigned long )hw->mac.ops.enable_tx_laser != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
#line 5878
      (*(hw->mac.ops.enable_tx_laser))(hw);
    } else {

    }
#line 5881
    if ((wufc & 8U) != 0U) {
#line 5882
      fctrl = ixgbe_read_reg(hw, 20608U);
#line 5883
      fctrl = fctrl | 256U;
#line 5884
      ixgbe_write_reg(hw, 20608U, fctrl);
    } else {

    }
#line 5887
    ctrl = ixgbe_read_reg(hw, 0U);
#line 5888
    ctrl = ctrl | 4U;
#line 5889
    ixgbe_write_reg(hw, 0U, ctrl);
#line 5891
    ixgbe_write_reg(hw, 22536U, wufc);
  } else {
#line 5893
    ixgbe_write_reg(hw, 22528U, 0U);
#line 5894
    ixgbe_write_reg(hw, 22536U, 0U);
  }
#line 5897
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 5899
  pci_wake_from_d3(pdev, 0);
#line 5900
  goto ldv_58714;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 5905
  pci_wake_from_d3(pdev, wufc != 0U);
#line 5906
  goto ldv_58714;
  default: ;
#line 5908
  goto ldv_58714;
  }
  ldv_58714: 
#line 5911
  *enable_wake = wufc != 0U;
#line 5912
  if ((unsigned long )hw->phy.ops.set_phy_power != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                             bool  ))0) && ! *enable_wake) {
#line 5913
    (*(hw->phy.ops.set_phy_power))(hw, 0);
  } else {

  }
#line 5915
  ixgbe_release_hw_control(adapter);
#line 5917
  tmp___1 = test_and_set_bit(3L, (unsigned long volatile   *)(& adapter->state));
#line 5917
  if (tmp___1 == 0) {
#line 5918
    pci_disable_device(pdev);
  } else {

  }
#line 5920
  return (0);
}
}
#line 5924 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_suspend(struct pci_dev *pdev , pm_message_t state ) 
{ 
  int retval ;
  bool wake ;

  {
#line 5929
  retval = __ixgbe_shutdown(pdev, & wake);
#line 5930
  if (retval != 0) {
#line 5931
    return (retval);
  } else {

  }
#line 5933
  if ((int )wake) {
#line 5934
    pci_prepare_to_sleep(pdev);
  } else {
#line 5936
    pci_wake_from_d3(pdev, 0);
#line 5937
    pci_set_power_state(pdev, 3);
  }
#line 5940
  return (0);
}
}
#line 5944 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_shutdown(struct pci_dev *pdev ) 
{ 
  bool wake ;

  {
#line 5948
  __ixgbe_shutdown(pdev, & wake);
#line 5950
  if ((unsigned int )system_state == 3U) {
#line 5951
    pci_wake_from_d3(pdev, (int )wake);
#line 5952
    pci_set_power_state(pdev, 3);
  } else {

  }
#line 5954
  return;
}
}
#line 5960 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_update_stats(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct ixgbe_hw *hw ;
  struct ixgbe_hw_stats *hwstats ;
  u64 total_mpc ;
  u32 i ;
  u32 missed_rx ;
  u32 mpc ;
  u32 bprc ;
  u32 lxon ;
  u32 lxoff ;
  u32 xon_off_tot ;
  u64 non_eop_descs ;
  u64 restart_queue ;
  u64 tx_busy ;
  u64 alloc_rx_page_failed ;
  u64 alloc_rx_buff_failed ;
  u64 bytes ;
  u64 packets ;
  u64 hw_csum_rx_error ;
  int tmp ;
  int tmp___0 ;
  u64 rsc_count ;
  u64 rsc_flush ;
  struct ixgbe_ring *rx_ring ;
  struct ixgbe_ring *tx_ring ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;
  u32 tmp___23 ;
  u32 tmp___24 ;
  u32 tmp___25 ;
  u32 tmp___26 ;
  u32 tmp___27 ;
  u32 tmp___28 ;
  u32 tmp___29 ;
  u32 tmp___30 ;
  u32 tmp___31 ;
  u32 tmp___32 ;
  u32 tmp___33 ;
  u32 tmp___34 ;
  struct ixgbe_fcoe *fcoe ;
  struct ixgbe_fcoe_ddp_pool *ddp_pool ;
  unsigned int cpu ;
  u64 noddp ;
  u64 noddp_ext_buff ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  u32 tmp___35 ;
  u32 tmp___36 ;
  u32 tmp___37 ;
  u32 tmp___38 ;
  u32 tmp___39 ;
  u32 tmp___40 ;
  u32 tmp___41 ;
  u32 tmp___42 ;
  u32 tmp___43 ;
  u32 tmp___44 ;
  u32 tmp___45 ;
  u32 tmp___46 ;
  u32 tmp___47 ;
  u32 tmp___48 ;
  u32 tmp___49 ;
  u32 tmp___50 ;
  u32 tmp___51 ;
  u32 tmp___52 ;
  u32 tmp___53 ;
  u32 tmp___54 ;
  u32 tmp___55 ;
  u32 tmp___56 ;

  {
#line 5962
  netdev = adapter->netdev;
#line 5963
  hw = & adapter->hw;
#line 5964
  hwstats = & adapter->stats;
#line 5965
  total_mpc = 0ULL;
#line 5966
  missed_rx = 0U;
#line 5967
  non_eop_descs = 0ULL;
#line 5967
  restart_queue = 0ULL;
#line 5967
  tx_busy = 0ULL;
#line 5968
  alloc_rx_page_failed = 0ULL;
#line 5968
  alloc_rx_buff_failed = 0ULL;
#line 5969
  bytes = 0ULL;
#line 5969
  packets = 0ULL;
#line 5969
  hw_csum_rx_error = 0ULL;
#line 5971
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 5971
  if (tmp != 0) {
#line 5973
    return;
  } else {
#line 5971
    tmp___0 = constant_test_bit(1L, (unsigned long const volatile   *)(& adapter->state));
#line 5971
    if (tmp___0 != 0) {
#line 5973
      return;
    } else {

    }
  }
#line 5975
  if ((adapter->flags2 & 2U) != 0U) {
#line 5976
    rsc_count = 0ULL;
#line 5977
    rsc_flush = 0ULL;
#line 5978
    i = 0U;
#line 5978
    goto ldv_58755;
    ldv_58754: 
#line 5979
    rsc_count = (adapter->rx_ring[i])->__annonCompField121.rx_stats.rsc_count + rsc_count;
#line 5980
    rsc_flush = (adapter->rx_ring[i])->__annonCompField121.rx_stats.rsc_flush + rsc_flush;
#line 5978
    i = i + 1U;
    ldv_58755: ;
#line 5978
    if ((u32 )adapter->num_rx_queues > i) {
#line 5980
      goto ldv_58754;
    } else {

    }
#line 5982
    adapter->rsc_total_count = rsc_count;
#line 5983
    adapter->rsc_total_flush = rsc_flush;
  } else {

  }
#line 5986
  i = 0U;
#line 5986
  goto ldv_58759;
  ldv_58758: 
#line 5987
  rx_ring = adapter->rx_ring[i];
#line 5988
  non_eop_descs = rx_ring->__annonCompField121.rx_stats.non_eop_descs + non_eop_descs;
#line 5989
  alloc_rx_page_failed = rx_ring->__annonCompField121.rx_stats.alloc_rx_page_failed + alloc_rx_page_failed;
#line 5990
  alloc_rx_buff_failed = rx_ring->__annonCompField121.rx_stats.alloc_rx_buff_failed + alloc_rx_buff_failed;
#line 5991
  hw_csum_rx_error = rx_ring->__annonCompField121.rx_stats.csum_err + hw_csum_rx_error;
#line 5992
  bytes = rx_ring->stats.bytes + bytes;
#line 5993
  packets = rx_ring->stats.packets + packets;
#line 5986
  i = i + 1U;
  ldv_58759: ;
#line 5986
  if ((u32 )adapter->num_rx_queues > i) {
#line 5988
    goto ldv_58758;
  } else {

  }
#line 5995
  adapter->non_eop_descs = non_eop_descs;
#line 5996
  adapter->alloc_rx_page_failed = (u32 )alloc_rx_page_failed;
#line 5997
  adapter->alloc_rx_buff_failed = (u32 )alloc_rx_buff_failed;
#line 5998
  adapter->hw_csum_rx_error = hw_csum_rx_error;
#line 5999
  netdev->stats.rx_bytes = (unsigned long )bytes;
#line 6000
  netdev->stats.rx_packets = (unsigned long )packets;
#line 6002
  bytes = 0ULL;
#line 6003
  packets = 0ULL;
#line 6005
  i = 0U;
#line 6005
  goto ldv_58763;
  ldv_58762: 
#line 6006
  tx_ring = adapter->tx_ring[i];
#line 6007
  restart_queue = tx_ring->__annonCompField121.tx_stats.restart_queue + restart_queue;
#line 6008
  tx_busy = tx_ring->__annonCompField121.tx_stats.tx_busy + tx_busy;
#line 6009
  bytes = tx_ring->stats.bytes + bytes;
#line 6010
  packets = tx_ring->stats.packets + packets;
#line 6005
  i = i + 1U;
  ldv_58763: ;
#line 6005
  if ((u32 )adapter->num_tx_queues > i) {
#line 6007
    goto ldv_58762;
  } else {

  }
#line 6012
  adapter->restart_queue = restart_queue;
#line 6013
  adapter->tx_busy = tx_busy;
#line 6014
  netdev->stats.tx_bytes = (unsigned long )bytes;
#line 6015
  netdev->stats.tx_packets = (unsigned long )packets;
#line 6017
  tmp___1 = ixgbe_read_reg(hw, 16384U);
#line 6017
  hwstats->crcerrs = hwstats->crcerrs + (u64 )tmp___1;
#line 6020
  i = 0U;
#line 6020
  goto ldv_58773;
  ldv_58772: 
#line 6022
  mpc = ixgbe_read_reg(hw, (i + 4072U) * 4U);
#line 6023
  missed_rx = missed_rx + mpc;
#line 6024
  hwstats->mpc[i] = hwstats->mpc[i] + (u64 )mpc;
#line 6025
  total_mpc = hwstats->mpc[i] + total_mpc;
#line 6026
  tmp___2 = ixgbe_read_reg(hw, (i + 4032U) * 4U);
#line 6026
  hwstats->pxontxc[i] = hwstats->pxontxc[i] + (u64 )tmp___2;
#line 6027
  tmp___3 = ixgbe_read_reg(hw, (i + 4040U) * 4U);
#line 6027
  hwstats->pxofftxc[i] = hwstats->pxofftxc[i] + (u64 )tmp___3;
#line 6028
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 6030
  tmp___4 = ixgbe_read_reg(hw, (i + 4080U) * 4U);
#line 6030
  hwstats->rnbc[i] = hwstats->rnbc[i] + (u64 )tmp___4;
#line 6031
  tmp___5 = ixgbe_read_reg(hw, i * 64U + 24628U);
#line 6031
  hwstats->qbtc[i] = hwstats->qbtc[i] + (u64 )tmp___5;
#line 6032
  tmp___6 = ixgbe_read_reg(hw, i * 64U + 4148U);
#line 6032
  hwstats->qbrc[i] = hwstats->qbrc[i] + (u64 )tmp___6;
#line 6033
  tmp___7 = ixgbe_read_reg(hw, (i + 13248U) * 4U);
#line 6033
  hwstats->pxonrxc[i] = hwstats->pxonrxc[i] + (u64 )tmp___7;
#line 6035
  goto ldv_58766;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 6040
  tmp___8 = ixgbe_read_reg(hw, (i + 4176U) * 4U);
#line 6040
  hwstats->pxonrxc[i] = hwstats->pxonrxc[i] + (u64 )tmp___8;
#line 6042
  goto ldv_58766;
  default: ;
#line 6044
  goto ldv_58766;
  }
  ldv_58766: 
#line 6020
  i = i + 1U;
  ldv_58773: ;
#line 6020
  if (i <= 7U) {
#line 6022
    goto ldv_58772;
  } else {

  }
#line 6049
  i = 0U;
#line 6049
  goto ldv_58776;
  ldv_58775: 
#line 6050
  tmp___9 = ixgbe_read_reg(hw, i * 64U + 24624U);
#line 6050
  hwstats->qptc[i] = hwstats->qptc[i] + (u64 )tmp___9;
#line 6051
  tmp___10 = ixgbe_read_reg(hw, i * 64U + 4144U);
#line 6051
  hwstats->qprc[i] = hwstats->qprc[i] + (u64 )tmp___10;
#line 6052
  if ((((unsigned int )hw->mac.type == 2U || (unsigned int )hw->mac.type == 3U) || (unsigned int )hw->mac.type == 4U) || (unsigned int )hw->mac.type == 5U) {
#line 6056
    tmp___11 = ixgbe_read_reg(hw, (i + 4320U) * 8U);
#line 6056
    hwstats->qbtc[i] = hwstats->qbtc[i] + (u64 )tmp___11;
#line 6057
    ixgbe_read_reg(hw, i * 8U + 34564U);
#line 6058
    tmp___12 = ixgbe_read_reg(hw, i * 64U + 4148U);
#line 6058
    hwstats->qbrc[i] = hwstats->qbrc[i] + (u64 )tmp___12;
#line 6059
    ixgbe_read_reg(hw, i * 64U + 4152U);
  } else {

  }
#line 6049
  i = i + 1U;
  ldv_58776: ;
#line 6049
  if (i <= 15U) {
#line 6051
    goto ldv_58775;
  } else {

  }
#line 6063
  tmp___13 = ixgbe_read_reg(hw, 16500U);
#line 6063
  hwstats->gprc = hwstats->gprc + (u64 )tmp___13;
#line 6065
  hwstats->gprc = hwstats->gprc - (u64 )missed_rx;
#line 6067
  ixgbe_update_xoff_received(adapter);
#line 6070
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 6072
  tmp___14 = ixgbe_read_reg(hw, 53088U);
#line 6072
  hwstats->lxonrxc = hwstats->lxonrxc + (u64 )tmp___14;
#line 6073
  tmp___15 = ixgbe_read_reg(hw, 16524U);
#line 6073
  hwstats->gorc = hwstats->gorc + (u64 )tmp___15;
#line 6074
  tmp___16 = ixgbe_read_reg(hw, 16532U);
#line 6074
  hwstats->gotc = hwstats->gotc + (u64 )tmp___16;
#line 6075
  tmp___17 = ixgbe_read_reg(hw, 16580U);
#line 6075
  hwstats->tor = hwstats->tor + (u64 )tmp___17;
#line 6076
  goto ldv_58779;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 6081
  tmp___18 = ixgbe_read_reg(hw, 16836U);
#line 6081
  hwstats->o2bgptc = hwstats->o2bgptc + (u64 )tmp___18;
#line 6082
  tmp___19 = ixgbe_read_reg(hw, 34736U);
#line 6082
  hwstats->o2bspc = hwstats->o2bspc + (u64 )tmp___19;
#line 6083
  tmp___20 = ixgbe_read_reg(hw, 16832U);
#line 6083
  hwstats->b2ospc = hwstats->b2ospc + (u64 )tmp___20;
#line 6084
  tmp___21 = ixgbe_read_reg(hw, 12176U);
#line 6084
  hwstats->b2ogprc = hwstats->b2ogprc + (u64 )tmp___21;
  case 2U: 
#line 6086
  i = 0U;
#line 6086
  goto ldv_58785;
  ldv_58784: 
#line 6087
  tmp___22 = ixgbe_read_reg(hw, i * 64U + 5168U);
#line 6087
  adapter->hw_rx_no_dma_resources = adapter->hw_rx_no_dma_resources + (u64 )tmp___22;
#line 6086
  i = i + 1U;
  ldv_58785: ;
#line 6086
  if (i <= 15U) {
#line 6088
    goto ldv_58784;
  } else {

  }
#line 6089
  tmp___23 = ixgbe_read_reg(hw, 16520U);
#line 6089
  hwstats->gorc = hwstats->gorc + (u64 )tmp___23;
#line 6090
  ixgbe_read_reg(hw, 16524U);
#line 6091
  tmp___24 = ixgbe_read_reg(hw, 16528U);
#line 6091
  hwstats->gotc = hwstats->gotc + (u64 )tmp___24;
#line 6092
  ixgbe_read_reg(hw, 16532U);
#line 6093
  tmp___25 = ixgbe_read_reg(hw, 16576U);
#line 6093
  hwstats->tor = hwstats->tor + (u64 )tmp___25;
#line 6094
  ixgbe_read_reg(hw, 16580U);
#line 6095
  tmp___26 = ixgbe_read_reg(hw, 16804U);
#line 6095
  hwstats->lxonrxc = hwstats->lxonrxc + (u64 )tmp___26;
#line 6096
  tmp___27 = ixgbe_read_reg(hw, 61016U);
#line 6096
  hwstats->fdirmatch = hwstats->fdirmatch + (u64 )tmp___27;
#line 6097
  tmp___28 = ixgbe_read_reg(hw, 61020U);
#line 6097
  hwstats->fdirmiss = hwstats->fdirmiss + (u64 )tmp___28;
#line 6099
  tmp___29 = ixgbe_read_reg(hw, 20760U);
#line 6099
  hwstats->fccrc = hwstats->fccrc + (u64 )tmp___29;
#line 6100
  tmp___30 = ixgbe_read_reg(hw, 9244U);
#line 6100
  hwstats->fcoerpdc = hwstats->fcoerpdc + (u64 )tmp___30;
#line 6101
  tmp___31 = ixgbe_read_reg(hw, 9256U);
#line 6101
  hwstats->fcoeprc = hwstats->fcoeprc + (u64 )tmp___31;
#line 6102
  tmp___32 = ixgbe_read_reg(hw, 34692U);
#line 6102
  hwstats->fcoeptc = hwstats->fcoeptc + (u64 )tmp___32;
#line 6103
  tmp___33 = ixgbe_read_reg(hw, 9260U);
#line 6103
  hwstats->fcoedwrc = hwstats->fcoedwrc + (u64 )tmp___33;
#line 6104
  tmp___34 = ixgbe_read_reg(hw, 34696U);
#line 6104
  hwstats->fcoedwtc = hwstats->fcoedwtc + (u64 )tmp___34;
#line 6106
  if ((unsigned long )adapter->fcoe.ddp_pool != (unsigned long )((struct ixgbe_fcoe_ddp_pool *)0)) {
#line 6107
    fcoe = & adapter->fcoe;
#line 6110
    noddp = 0ULL;
#line 6110
    noddp_ext_buff = 0ULL;
#line 6111
    cpu = 4294967295U;
#line 6111
    goto ldv_58797;
    ldv_58796: 
#line 6112
    __vpp_verify = (void const   *)0;
#line 6112
    __asm__  ("": "=r" (__ptr): "0" (fcoe->ddp_pool));
#line 6112
    ddp_pool = (struct ixgbe_fcoe_ddp_pool *)(__per_cpu_offset[cpu] + __ptr);
#line 6113
    noddp = ddp_pool->noddp + noddp;
#line 6114
    noddp_ext_buff = ddp_pool->noddp_ext_buff + noddp_ext_buff;
    ldv_58797: 
#line 6111
    cpu = cpumask_next((int )cpu, cpu_possible_mask);
#line 6111
    if ((unsigned int )nr_cpu_ids > cpu) {
#line 6113
      goto ldv_58796;
    } else {

    }
#line 6116
    hwstats->fcoe_noddp = noddp;
#line 6117
    hwstats->fcoe_noddp_ext_buff = noddp_ext_buff;
  } else {

  }
#line 6120
  goto ldv_58779;
  default: ;
#line 6122
  goto ldv_58779;
  }
  ldv_58779: 
#line 6124
  bprc = ixgbe_read_reg(hw, 16504U);
#line 6125
  hwstats->bprc = hwstats->bprc + (u64 )bprc;
#line 6126
  tmp___35 = ixgbe_read_reg(hw, 16508U);
#line 6126
  hwstats->mprc = hwstats->mprc + (u64 )tmp___35;
#line 6127
  if ((unsigned int )hw->mac.type == 1U) {
#line 6128
    hwstats->mprc = hwstats->mprc - (u64 )bprc;
  } else {

  }
#line 6129
  tmp___36 = ixgbe_read_reg(hw, 16556U);
#line 6129
  hwstats->roc = hwstats->roc + (u64 )tmp___36;
#line 6130
  tmp___37 = ixgbe_read_reg(hw, 16476U);
#line 6130
  hwstats->prc64 = hwstats->prc64 + (u64 )tmp___37;
#line 6131
  tmp___38 = ixgbe_read_reg(hw, 16480U);
#line 6131
  hwstats->prc127 = hwstats->prc127 + (u64 )tmp___38;
#line 6132
  tmp___39 = ixgbe_read_reg(hw, 16484U);
#line 6132
  hwstats->prc255 = hwstats->prc255 + (u64 )tmp___39;
#line 6133
  tmp___40 = ixgbe_read_reg(hw, 16488U);
#line 6133
  hwstats->prc511 = hwstats->prc511 + (u64 )tmp___40;
#line 6134
  tmp___41 = ixgbe_read_reg(hw, 16492U);
#line 6134
  hwstats->prc1023 = hwstats->prc1023 + (u64 )tmp___41;
#line 6135
  tmp___42 = ixgbe_read_reg(hw, 16496U);
#line 6135
  hwstats->prc1522 = hwstats->prc1522 + (u64 )tmp___42;
#line 6136
  tmp___43 = ixgbe_read_reg(hw, 16448U);
#line 6136
  hwstats->rlec = hwstats->rlec + (u64 )tmp___43;
#line 6137
  lxon = ixgbe_read_reg(hw, 16224U);
#line 6138
  hwstats->lxontxc = hwstats->lxontxc + (u64 )lxon;
#line 6139
  lxoff = ixgbe_read_reg(hw, 16232U);
#line 6140
  hwstats->lxofftxc = hwstats->lxofftxc + (u64 )lxoff;
#line 6141
  tmp___44 = ixgbe_read_reg(hw, 16512U);
#line 6141
  hwstats->gptc = hwstats->gptc + (u64 )tmp___44;
#line 6142
  tmp___45 = ixgbe_read_reg(hw, 16624U);
#line 6142
  hwstats->mptc = hwstats->mptc + (u64 )tmp___45;
#line 6146
  xon_off_tot = lxon + lxoff;
#line 6147
  hwstats->gptc = hwstats->gptc - (u64 )xon_off_tot;
#line 6148
  hwstats->mptc = hwstats->mptc - (u64 )xon_off_tot;
#line 6149
  hwstats->gotc = hwstats->gotc - (u64 )(xon_off_tot * 64U);
#line 6150
  tmp___46 = ixgbe_read_reg(hw, 16548U);
#line 6150
  hwstats->ruc = hwstats->ruc + (u64 )tmp___46;
#line 6151
  tmp___47 = ixgbe_read_reg(hw, 16552U);
#line 6151
  hwstats->rfc = hwstats->rfc + (u64 )tmp___47;
#line 6152
  tmp___48 = ixgbe_read_reg(hw, 16560U);
#line 6152
  hwstats->rjc = hwstats->rjc + (u64 )tmp___48;
#line 6153
  tmp___49 = ixgbe_read_reg(hw, 16592U);
#line 6153
  hwstats->tpr = hwstats->tpr + (u64 )tmp___49;
#line 6154
  tmp___50 = ixgbe_read_reg(hw, 16600U);
#line 6154
  hwstats->ptc64 = hwstats->ptc64 + (u64 )tmp___50;
#line 6155
  hwstats->ptc64 = hwstats->ptc64 - (u64 )xon_off_tot;
#line 6156
  tmp___51 = ixgbe_read_reg(hw, 16604U);
#line 6156
  hwstats->ptc127 = hwstats->ptc127 + (u64 )tmp___51;
#line 6157
  tmp___52 = ixgbe_read_reg(hw, 16608U);
#line 6157
  hwstats->ptc255 = hwstats->ptc255 + (u64 )tmp___52;
#line 6158
  tmp___53 = ixgbe_read_reg(hw, 16612U);
#line 6158
  hwstats->ptc511 = hwstats->ptc511 + (u64 )tmp___53;
#line 6159
  tmp___54 = ixgbe_read_reg(hw, 16616U);
#line 6159
  hwstats->ptc1023 = hwstats->ptc1023 + (u64 )tmp___54;
#line 6160
  tmp___55 = ixgbe_read_reg(hw, 16620U);
#line 6160
  hwstats->ptc1522 = hwstats->ptc1522 + (u64 )tmp___55;
#line 6161
  tmp___56 = ixgbe_read_reg(hw, 16628U);
#line 6161
  hwstats->bptc = hwstats->bptc + (u64 )tmp___56;
#line 6164
  netdev->stats.multicast = (unsigned long )hwstats->mprc;
#line 6167
  netdev->stats.rx_errors = (unsigned long )(hwstats->crcerrs + hwstats->rlec);
#line 6168
  netdev->stats.rx_dropped = 0UL;
#line 6169
  netdev->stats.rx_length_errors = (unsigned long )hwstats->rlec;
#line 6170
  netdev->stats.rx_crc_errors = (unsigned long )hwstats->crcerrs;
#line 6171
  netdev->stats.rx_missed_errors = (unsigned long )total_mpc;
#line 6172
  return;
}
}
#line 6178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_fdir_reinit_subtask(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int i ;
  int tmp ;
  s32 tmp___0 ;

  {
#line 6180
  hw = & adapter->hw;
#line 6183
  if ((adapter->flags2 & 128U) == 0U) {
#line 6184
    return;
  } else {

  }
#line 6186
  adapter->flags2 = adapter->flags2 & 4294967167U;
#line 6189
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 6189
  if (tmp != 0) {
#line 6190
    return;
  } else {

  }
#line 6193
  if ((adapter->flags & 262144U) == 0U) {
#line 6194
    return;
  } else {

  }
#line 6196
  adapter->fdir_overflow = adapter->fdir_overflow + 1UL;
#line 6198
  tmp___0 = ixgbe_reinit_fdir_tables_82599(hw);
#line 6198
  if (tmp___0 == 0) {
#line 6199
    i = 0;
#line 6199
    goto ldv_58806;
    ldv_58805: 
#line 6200
    set_bit(0L, (unsigned long volatile   *)(& (adapter->tx_ring[i])->state));
#line 6199
    i = i + 1;
    ldv_58806: ;
#line 6199
    if (adapter->num_tx_queues > i) {
#line 6201
      goto ldv_58805;
    } else {

    }
#line 6203
    ixgbe_write_reg(hw, 2176U, 65536U);
  } else
#line 6205
  if (((int )adapter->msg_enable & 2) != 0) {
#line 6206
    netdev_err((struct net_device  const  *)adapter->netdev, "failed to finish FDIR re-initialization, ignored adding FDIR ATR filters\n");
  } else {

  }
#line 6207
  return;
}
}
#line 6219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_hang_subtask(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u64 eics ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  struct ixgbe_q_vector *qv ;

  {
#line 6221
  hw = & adapter->hw;
#line 6222
  eics = 0ULL;
#line 6226
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 6226
  if (tmp != 0) {
#line 6229
    return;
  } else {
#line 6226
    tmp___0 = constant_test_bit(4L, (unsigned long const volatile   *)(& adapter->state));
#line 6226
    if (tmp___0 != 0) {
#line 6229
      return;
    } else {
#line 6226
      tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& adapter->state));
#line 6226
      if (tmp___1 != 0) {
#line 6229
        return;
      } else {

      }
    }
  }
#line 6232
  tmp___2 = netif_carrier_ok((struct net_device  const  *)adapter->netdev);
#line 6232
  if ((int )tmp___2) {
#line 6233
    i = 0;
#line 6233
    goto ldv_58815;
    ldv_58814: 
#line 6234
    set_bit(2L, (unsigned long volatile   *)(& (adapter->tx_ring[i])->state));
#line 6233
    i = i + 1;
    ldv_58815: ;
#line 6233
    if (adapter->num_tx_queues > i) {
#line 6235
      goto ldv_58814;
    } else {

    }

  } else {

  }
#line 6237
  if ((adapter->flags & 8U) == 0U) {
#line 6243
    ixgbe_write_reg(hw, 2056U, 3221225472U);
  } else {
#line 6247
    i = 0;
#line 6247
    goto ldv_58819;
    ldv_58818: 
#line 6248
    qv = adapter->q_vector[i];
#line 6249
    if ((unsigned long )qv->rx.ring != (unsigned long )((struct ixgbe_ring *)0) || (unsigned long )qv->tx.ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 6250
      eics = (1ULL << i) | eics;
    } else {

    }
#line 6247
    i = i + 1;
    ldv_58819: ;
#line 6247
    if (adapter->num_q_vectors > i) {
#line 6249
      goto ldv_58818;
    } else {

    }

  }
#line 6255
  ixgbe_irq_rearm_queues(adapter, eics);
#line 6256
  return;
}
}
#line 6263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_update_link(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 link_speed ;
  bool link_up ;
  bool pfc_en ;

  {
#line 6265
  hw = & adapter->hw;
#line 6266
  link_speed = adapter->link_speed;
#line 6267
  link_up = adapter->link_up;
#line 6268
  pfc_en = adapter->dcb_cfg.pfc_mode_enable;
#line 6270
  if ((adapter->flags & 65536U) == 0U) {
#line 6271
    return;
  } else {

  }
#line 6273
  if ((unsigned long )hw->mac.ops.check_link != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                          ixgbe_link_speed * ,
                                                                          bool * ,
                                                                          bool  ))0)) {
#line 6274
    (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
  } else {
#line 6277
    link_speed = 128U;
#line 6278
    link_up = 1;
  }
#line 6281
  if ((unsigned long )adapter->ixgbe_ieee_pfc != (unsigned long )((struct ieee_pfc *)0)) {
#line 6282
    pfc_en = ((int )pfc_en | ((unsigned int )(adapter->ixgbe_ieee_pfc)->pfc_en != 0U)) != 0;
  } else {

  }
#line 6284
  if ((int )link_up && ((adapter->flags & 4096U) == 0U || ! pfc_en)) {
#line 6285
    (*(hw->mac.ops.fc_enable))(hw);
#line 6286
    ixgbe_set_rx_drop_en(adapter);
  } else {

  }
#line 6290
  if ((int )link_up || (long )((adapter->link_check_timeout - (unsigned long )jiffies) + 1000UL) < 0L) {
#line 6292
    adapter->flags = adapter->flags & 4294901759U;
#line 6293
    ixgbe_write_reg(hw, 2176U, 1048576U);
#line 6294
    ixgbe_read_reg(hw, 8U);
  } else {

  }
#line 6297
  adapter->link_up = link_up;
#line 6298
  adapter->link_speed = link_speed;
#line 6299
  return;
}
}
#line 6301 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_default_up(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct dcb_app app ;
  u8 up___0 ;
  int tmp ;

  {
#line 6304
  netdev = adapter->netdev;
#line 6305
  app.selector = 1U;
#line 6305
  app.priority = (unsigned char)0;
#line 6305
  app.protocol = 0U;
#line 6309
  up___0 = 0U;
#line 6311
  if (((int )adapter->dcbx_cap & 8) != 0) {
#line 6312
    up___0 = dcb_ieee_getapp_mask(netdev, & app);
  } else {

  }
#line 6314
  if ((unsigned int )up___0 > 1U) {
#line 6314
    tmp = ffs((int )up___0);
#line 6314
    adapter->default_up = (unsigned int )((u8 )tmp) + 255U;
  } else {
#line 6314
    adapter->default_up = 0U;
  }
#line 6315
  return;
}
}
#line 6323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_link_is_up(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct ixgbe_hw *hw ;
  struct net_device *upper ;
  struct list_head *iter ;
  u32 link_speed ;
  bool flow_rx ;
  bool flow_tx ;
  bool tmp ;
  u32 frctl ;
  u32 tmp___0 ;
  u32 rmcs ;
  u32 tmp___1 ;
  u32 mflcn ;
  u32 tmp___2 ;
  u32 fccfg ;
  u32 tmp___3 ;
  int tmp___4 ;
  struct macvlan_dev *vlan ;
  void *tmp___5 ;
  bool tmp___6 ;

  {
#line 6325
  netdev = adapter->netdev;
#line 6326
  hw = & adapter->hw;
#line 6329
  link_speed = adapter->link_speed;
#line 6333
  tmp = netif_carrier_ok((struct net_device  const  *)netdev);
#line 6333
  if ((int )tmp) {
#line 6334
    return;
  } else {

  }
#line 6336
  adapter->flags2 = adapter->flags2 & 4294967279U;
#line 6338
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 6340
  tmp___0 = ixgbe_read_reg(hw, 20608U);
#line 6340
  frctl = tmp___0;
#line 6341
  tmp___1 = ixgbe_read_reg(hw, 15616U);
#line 6341
  rmcs = tmp___1;
#line 6342
  flow_rx = (frctl & 32768U) != 0U;
#line 6343
  flow_tx = (rmcs & 8U) != 0U;
#line 6345
  goto ldv_58853;
  case 3U: ;
  case 4U: ;
  case 5U: ;
  case 2U: 
#line 6350
  tmp___2 = ixgbe_read_reg(hw, 17044U);
#line 6350
  mflcn = tmp___2;
#line 6351
  tmp___3 = ixgbe_read_reg(hw, 15616U);
#line 6351
  fccfg = tmp___3;
#line 6352
  flow_rx = (mflcn & 8U) != 0U;
#line 6353
  flow_tx = (fccfg & 8U) != 0U;
#line 6355
  goto ldv_58853;
  default: 
#line 6357
  flow_tx = 0;
#line 6358
  flow_rx = 0;
#line 6359
  goto ldv_58853;
  }
  ldv_58853: 
#line 6362
  adapter->last_rx_ptp_check = jiffies;
#line 6364
  tmp___4 = constant_test_bit(8L, (unsigned long const volatile   *)(& adapter->state));
#line 6364
  if (tmp___4 != 0) {
#line 6365
    ixgbe_ptp_start_cyclecounter(adapter);
  } else {

  }
#line 6367
  if ((int )adapter->msg_enable & 1) {
#line 6377
    netdev_info((struct net_device  const  *)adapter->netdev, "NIC Link is Up %s, Flow Control: %s\n",
                link_speed != 128U ? (link_speed != 32U ? (link_speed == 8U ? (char *)"100 Mbps" : (char *)"unknown speed") : (char *)"1 Gbps") : (char *)"10 Gbps",
                ! flow_rx || ! flow_tx ? ((int )flow_rx ? (char *)"RX" : ((int )flow_tx ? (char *)"TX" : (char *)"None")) : (char *)"RX/TX");
  } else {

  }
#line 6379
  netif_carrier_on(netdev);
#line 6380
  ixgbe_check_vf_rate_limit(adapter);
#line 6383
  netif_tx_wake_all_queues(adapter->netdev);
#line 6386
  rtnl_lock();
#line 6387
  iter = & (adapter->netdev)->all_adj_list.upper;
#line 6387
  upper = netdev_all_upper_get_next_dev_rcu(adapter->netdev, & iter);
#line 6387
  goto ldv_58863;
  ldv_58862: 
#line 6388
  tmp___6 = netif_is_macvlan(upper);
#line 6388
  if ((int )tmp___6) {
#line 6389
    tmp___5 = netdev_priv((struct net_device  const  *)upper);
#line 6389
    vlan = (struct macvlan_dev *)tmp___5;
#line 6391
    if ((unsigned long )vlan->fwd_priv != (unsigned long )((void *)0)) {
#line 6392
      netif_tx_wake_all_queues(upper);
    } else {

    }
  } else {

  }
#line 6387
  upper = netdev_all_upper_get_next_dev_rcu(adapter->netdev, & iter);
  ldv_58863: ;
#line 6387
  if ((unsigned long )upper != (unsigned long )((struct net_device *)0)) {
#line 6389
    goto ldv_58862;
  } else {

  }
#line 6395
  rtnl_unlock();
#line 6398
  ixgbe_update_default_up(adapter);
#line 6401
  ixgbe_ping_all_vfs(adapter);
#line 6402
  return;
}
}
#line 6409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_link_is_down(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct ixgbe_hw *hw ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 6411
  netdev = adapter->netdev;
#line 6412
  hw = & adapter->hw;
#line 6414
  adapter->link_up = 0;
#line 6415
  adapter->link_speed = 0U;
#line 6418
  tmp = netif_carrier_ok((struct net_device  const  *)netdev);
#line 6418
  if (tmp) {
#line 6418
    tmp___0 = 0;
  } else {
#line 6418
    tmp___0 = 1;
  }
#line 6418
  if (tmp___0) {
#line 6419
    return;
  } else {

  }
#line 6422
  tmp___1 = ixgbe_is_sfp(hw);
#line 6422
  if ((int )tmp___1 && (unsigned int )hw->mac.type == 1U) {
#line 6423
    adapter->flags2 = adapter->flags2 | 16U;
  } else {

  }
#line 6425
  tmp___2 = constant_test_bit(8L, (unsigned long const volatile   *)(& adapter->state));
#line 6425
  if (tmp___2 != 0) {
#line 6426
    ixgbe_ptp_start_cyclecounter(adapter);
  } else {

  }
#line 6428
  if ((int )adapter->msg_enable & 1) {
#line 6428
    netdev_info((struct net_device  const  *)adapter->netdev, "NIC Link is Down\n");
  } else {

  }
#line 6429
  netif_carrier_off(netdev);
#line 6432
  ixgbe_ping_all_vfs(adapter);
#line 6433
  return;
}
}
#line 6435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_ring_tx_pending(struct ixgbe_adapter *adapter ) 
{ 
  int i ;
  struct ixgbe_ring *tx_ring ;

  {
#line 6439
  i = 0;
#line 6439
  goto ldv_58876;
  ldv_58875: 
#line 6440
  tx_ring = adapter->tx_ring[i];
#line 6442
  if ((int )tx_ring->next_to_use != (int )tx_ring->next_to_clean) {
#line 6443
    return (1);
  } else {

  }
#line 6439
  i = i + 1;
  ldv_58876: ;
#line 6439
  if (adapter->num_tx_queues > i) {
#line 6441
    goto ldv_58875;
  } else {

  }

#line 6446
  return (0);
}
}
#line 6449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_vf_tx_pending(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct ixgbe_ring_feature *vmdq ;
  u32 q_per_pool ;
  int i ;
  int j ;
  u32 h ;
  u32 t ;

  {
#line 6451
  hw = & adapter->hw;
#line 6452
  vmdq = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 1UL;
#line 6453
  q_per_pool = (u32 )(- ((int )vmdq->mask) & (int )vmdq->mask);
#line 6457
  if (adapter->num_vfs == 0U) {
#line 6458
    return (0);
  } else {

  }
#line 6461
  if ((unsigned int )hw->mac.type > 3U) {
#line 6462
    return (0);
  } else {

  }
#line 6464
  i = 0;
#line 6464
  goto ldv_58892;
  ldv_58891: 
#line 6465
  j = 0;
#line 6465
  goto ldv_58889;
  ldv_58888: 
#line 6468
  h = ixgbe_read_reg(hw, (q_per_pool * (u32 )i + (u32 )j) * 64U + 24592U);
#line 6469
  t = ixgbe_read_reg(hw, (q_per_pool * (u32 )i + (u32 )j) * 64U + 24600U);
#line 6471
  if (h != t) {
#line 6472
    return (1);
  } else {

  }
#line 6465
  j = j + 1;
  ldv_58889: ;
#line 6465
  if ((u32 )j < q_per_pool) {
#line 6467
    goto ldv_58888;
  } else {

  }
#line 6464
  i = i + 1;
  ldv_58892: ;
#line 6464
  if ((unsigned int )i < adapter->num_vfs) {
#line 6466
    goto ldv_58891;
  } else {

  }

#line 6476
  return (0);
}
}
#line 6483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_flush_tx(struct ixgbe_adapter *adapter ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 6485
  tmp___1 = netif_carrier_ok((struct net_device  const  *)adapter->netdev);
#line 6485
  if (tmp___1) {
#line 6485
    tmp___2 = 0;
  } else {
#line 6485
    tmp___2 = 1;
  }
#line 6485
  if (tmp___2) {
#line 6486
    tmp = ixgbe_ring_tx_pending(adapter);
#line 6486
    if ((int )tmp) {
#line 6486
      goto _L;
    } else {
#line 6486
      tmp___0 = ixgbe_vf_tx_pending(adapter);
#line 6486
      if ((int )tmp___0) {
        _L: /* CIL Label */ 
#line 6493
        if ((int )adapter->msg_enable & 1) {
#line 6493
          netdev_warn((struct net_device  const  *)adapter->netdev, "initiating reset to clear Tx work after link loss\n");
        } else {

        }
#line 6494
        adapter->flags2 = adapter->flags2 | 64U;
      } else {

      }
    }
  } else {

  }
#line 6496
  return;
}
}
#line 6500 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_issue_vf_flr(struct ixgbe_adapter *adapter , struct pci_dev *vfdev ) 
{ 
  int tmp ;
  char const   *tmp___0 ;

  {
#line 6503
  tmp = pci_wait_for_pending_transaction(vfdev);
#line 6503
  if (tmp == 0) {
#line 6504
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Issuing VFLR with pending transactions\n");
  } else {

  }
#line 6506
  tmp___0 = pci_name((struct pci_dev  const  *)vfdev);
#line 6506
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Issuing VFLR for VF %s\n",
          tmp___0);
#line 6507
  pcie_capability_set_word(vfdev, 8, 32768);
#line 6509
  msleep(100U);
#line 6510
  return;
}
}
#line 6512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_for_bad_vf(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct pci_dev *pdev ;
  struct pci_dev *vfdev ;
  u32 gpc ;
  int pos ;
  unsigned short vf_id ;
  bool tmp ;
  int tmp___0 ;
  u16 status_reg ;

  {
#line 6514
  hw = & adapter->hw;
#line 6515
  pdev = adapter->pdev;
#line 6521
  tmp = netif_carrier_ok((struct net_device  const  *)adapter->netdev);
#line 6521
  if (tmp) {
#line 6521
    tmp___0 = 0;
  } else {
#line 6521
    tmp___0 = 1;
  }
#line 6521
  if (tmp___0) {
#line 6522
    return;
  } else {

  }
#line 6524
  gpc = ixgbe_read_reg(hw, 34720U);
#line 6525
  if (gpc != 0U) {
#line 6526
    return;
  } else {

  }
#line 6533
  if ((unsigned long )pdev == (unsigned long )((struct pci_dev *)0)) {
#line 6534
    return;
  } else {

  }
#line 6536
  pos = pci_find_ext_capability(pdev, 16);
#line 6537
  if (pos == 0) {
#line 6538
    return;
  } else {

  }
#line 6541
  pci_read_config_word((struct pci_dev  const  *)pdev, pos + 26, & vf_id);
#line 6544
  vfdev = pci_get_device((unsigned int )pdev->vendor, (unsigned int )vf_id, (struct pci_dev *)0);
#line 6545
  goto ldv_58912;
  ldv_58911: ;
#line 6546
  if ((unsigned int )*((unsigned char *)vfdev + 2531UL) != 0U && (unsigned long )vfdev->__annonCompField58.physfn == (unsigned long )pdev) {
#line 6549
    pci_read_config_word((struct pci_dev  const  *)vfdev, 6, & status_reg);
#line 6550
    if (((int )status_reg & 8192) != 0) {
#line 6552
      ixgbe_issue_vf_flr(adapter, vfdev);
    } else {

    }
  } else {

  }
#line 6555
  vfdev = pci_get_device((unsigned int )pdev->vendor, (unsigned int )vf_id, vfdev);
  ldv_58912: ;
#line 6545
  if ((unsigned long )vfdev != (unsigned long )((struct pci_dev *)0)) {
#line 6547
    goto ldv_58911;
  } else {

  }

#line 6552
  return;
}
}
#line 6559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_spoof_check(struct ixgbe_adapter *adapter ) 
{ 
  u32 ssvpc ;

  {
#line 6564
  if ((unsigned int )adapter->hw.mac.type == 1U || adapter->num_vfs == 0U) {
#line 6566
    return;
  } else {

  }
#line 6568
  ssvpc = ixgbe_read_reg(& adapter->hw, 34688U);
#line 6574
  if (ssvpc == 0U) {
#line 6575
    return;
  } else {

  }
#line 6577
  if ((int )adapter->msg_enable & 1) {
#line 6577
    netdev_warn((struct net_device  const  *)adapter->netdev, "%u Spoofed packets detected\n",
                ssvpc);
  } else {

  }
#line 6578
  return;
}
}
#line 6595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_subtask(struct ixgbe_adapter *adapter ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 6598
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 6598
  if (tmp != 0) {
#line 6601
    return;
  } else {
#line 6598
    tmp___0 = constant_test_bit(4L, (unsigned long const volatile   *)(& adapter->state));
#line 6598
    if (tmp___0 != 0) {
#line 6601
      return;
    } else {
#line 6598
      tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& adapter->state));
#line 6598
      if (tmp___1 != 0) {
#line 6601
        return;
      } else {

      }
    }
  }
#line 6603
  ixgbe_watchdog_update_link(adapter);
#line 6605
  if ((int )adapter->link_up) {
#line 6606
    ixgbe_watchdog_link_is_up(adapter);
  } else {
#line 6608
    ixgbe_watchdog_link_is_down(adapter);
  }
#line 6610
  ixgbe_check_for_bad_vf(adapter);
#line 6611
  ixgbe_spoof_check(adapter);
#line 6612
  ixgbe_update_stats(adapter);
#line 6614
  ixgbe_watchdog_flush_tx(adapter);
#line 6615
  return;
}
}
#line 6621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_sfp_detection_subtask(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  s32 err ;
  int tmp ;

  {
#line 6623
  hw = & adapter->hw;
#line 6627
  if ((adapter->flags2 & 16U) == 0U && (adapter->flags2 & 32U) == 0U) {
#line 6629
    return;
  } else {

  }
#line 6632
  tmp = test_and_set_bit(7L, (unsigned long volatile   *)(& adapter->state));
#line 6632
  if (tmp != 0) {
#line 6633
    return;
  } else {

  }
#line 6635
  err = (*(hw->phy.ops.identify_sfp))(hw);
#line 6636
  if (err == -19) {
#line 6637
    goto sfp_out;
  } else {

  }
#line 6639
  if (err == -20) {
#line 6642
    adapter->flags2 = adapter->flags2 | 32U;
  } else {

  }
#line 6646
  if (err != 0) {
#line 6647
    goto sfp_out;
  } else {

  }
#line 6650
  if ((adapter->flags2 & 32U) == 0U) {
#line 6651
    goto sfp_out;
  } else {

  }
#line 6653
  adapter->flags2 = adapter->flags2 & 4294967263U;
#line 6660
  if ((unsigned int )hw->mac.type == 1U) {
#line 6661
    err = (*(hw->phy.ops.reset))(hw);
  } else {
#line 6663
    err = (*(hw->mac.ops.setup_sfp))(hw);
  }
#line 6665
  if (err == -19) {
#line 6666
    goto sfp_out;
  } else {

  }
#line 6668
  adapter->flags = adapter->flags | 131072U;
#line 6669
  if (((int )adapter->msg_enable & 2) != 0) {
#line 6669
    netdev_info((struct net_device  const  *)adapter->netdev, "detected SFP+: %d\n",
                (unsigned int )hw->phy.sfp_type);
  } else {

  }
  sfp_out: 
#line 6672
  clear_bit(7L, (unsigned long volatile   *)(& adapter->state));
#line 6674
  if (err == -19 && (unsigned int )(adapter->netdev)->reg_state == 1U) {
#line 6676
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "failed to initialize because an unsupported SFP+ module type was detected.\n");
#line 6678
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Reload the driver after installing a supported module.\n");
#line 6680
    ldv_unregister_netdev_27(adapter->netdev);
  } else {

  }
#line 6682
  return;
}
}
#line 6688 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_sfp_link_config_subtask(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 speed ;
  bool autoneg ;
  int tmp ;

  {
#line 6690
  hw = & adapter->hw;
#line 6692
  autoneg = 0;
#line 6694
  if ((adapter->flags & 131072U) == 0U) {
#line 6695
    return;
  } else {

  }
#line 6698
  tmp = test_and_set_bit(7L, (unsigned long volatile   *)(& adapter->state));
#line 6698
  if (tmp != 0) {
#line 6699
    return;
  } else {

  }
#line 6701
  adapter->flags = adapter->flags & 4294836223U;
#line 6703
  speed = hw->phy.autoneg_advertised;
#line 6704
  if (speed == 0U && (unsigned long )hw->mac.ops.get_link_capabilities != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                                                    ixgbe_link_speed * ,
                                                                                                    bool * ))0)) {
#line 6705
    (*(hw->mac.ops.get_link_capabilities))(hw, & speed, & autoneg);
#line 6708
    if (! autoneg) {
#line 6709
      if ((speed & 128U) != 0U) {
#line 6710
        speed = 128U;
      } else {

      }
    } else {

    }
  } else {

  }
#line 6714
  if ((unsigned long )hw->mac.ops.setup_link != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                          ixgbe_link_speed  ,
                                                                          bool  ))0)) {
#line 6715
    (*(hw->mac.ops.setup_link))(hw, speed, 1);
  } else {

  }
#line 6717
  adapter->flags = adapter->flags | 65536U;
#line 6718
  adapter->link_check_timeout = jiffies;
#line 6719
  clear_bit(7L, (unsigned long volatile   *)(& adapter->state));
#line 6720
  return;
}
}
#line 6726 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_service_timer(unsigned long data ) 
{ 
  struct ixgbe_adapter *adapter ;
  unsigned long next_event_offset ;

  {
#line 6728
  adapter = (struct ixgbe_adapter *)data;
#line 6732
  if ((adapter->flags & 65536U) != 0U) {
#line 6733
    next_event_offset = 25UL;
  } else {
#line 6735
    next_event_offset = 500UL;
  }
#line 6738
  ldv_mod_timer_28(& adapter->service_timer, next_event_offset + (unsigned long )jiffies);
#line 6740
  ixgbe_service_event_schedule(adapter);
#line 6741
  return;
}
}
#line 6743 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_phy_interrupt_subtask(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 status ;
  s32 tmp ;

  {
#line 6745
  hw = & adapter->hw;
#line 6748
  if ((adapter->flags2 & 2048U) == 0U) {
#line 6749
    return;
  } else {

  }
#line 6751
  adapter->flags2 = adapter->flags2 & 4294965247U;
#line 6753
  if ((unsigned long )hw->phy.ops.handle_lasi == (unsigned long )((s32 (*)(struct ixgbe_hw * ))0)) {
#line 6754
    return;
  } else {

  }
#line 6756
  tmp = (*(hw->phy.ops.handle_lasi))(& adapter->hw);
#line 6756
  status = (u32 )tmp;
#line 6757
  if (status != 4294967270U) {
#line 6758
    return;
  } else {

  }
#line 6760
  if ((int )adapter->msg_enable & 1) {
#line 6760
    netdev_crit((struct net_device  const  *)adapter->netdev, "%s\n", (char const   *)(& ixgbe_overheat_msg));
  } else {

  }
#line 6761
  return;
}
}
#line 6763 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_reset_subtask(struct ixgbe_adapter *adapter ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 6765
  if ((adapter->flags2 & 64U) == 0U) {
#line 6766
    return;
  } else {

  }
#line 6768
  adapter->flags2 = adapter->flags2 & 4294967231U;
#line 6771
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 6771
  if (tmp != 0) {
#line 6774
    return;
  } else {
#line 6771
    tmp___0 = constant_test_bit(4L, (unsigned long const volatile   *)(& adapter->state));
#line 6771
    if (tmp___0 != 0) {
#line 6774
      return;
    } else {
#line 6771
      tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& adapter->state));
#line 6771
      if (tmp___1 != 0) {
#line 6774
        return;
      } else {

      }
    }
  }
#line 6776
  ixgbe_dump(adapter);
#line 6777
  netdev_err((struct net_device  const  *)adapter->netdev, "Reset adapter\n");
#line 6778
  adapter->tx_timeout_count = adapter->tx_timeout_count + 1U;
#line 6780
  rtnl_lock();
#line 6781
  ixgbe_reinit_locked(adapter);
#line 6782
  rtnl_unlock();
#line 6783
  return;
}
}
#line 6789 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_service_task(struct work_struct *work ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 6791
  __mptr = (struct work_struct  const  *)work;
#line 6791
  adapter = (struct ixgbe_adapter *)__mptr + 0xffffffffffff61d0UL;
#line 6794
  tmp___0 = ixgbe_removed((void *)adapter->hw.hw_addr);
#line 6794
  if ((int )tmp___0) {
#line 6795
    tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 6795
    if (tmp == 0) {
#line 6796
      rtnl_lock();
#line 6797
      ixgbe_down(adapter);
#line 6798
      rtnl_unlock();
    } else {

    }
#line 6800
    ixgbe_service_event_complete(adapter);
#line 6801
    return;
  } else {

  }
#line 6803
  ixgbe_reset_subtask(adapter);
#line 6804
  ixgbe_phy_interrupt_subtask(adapter);
#line 6805
  ixgbe_sfp_detection_subtask(adapter);
#line 6806
  ixgbe_sfp_link_config_subtask(adapter);
#line 6807
  ixgbe_check_overtemp_subtask(adapter);
#line 6808
  ixgbe_watchdog_subtask(adapter);
#line 6809
  ixgbe_fdir_reinit_subtask(adapter);
#line 6810
  ixgbe_check_hang_subtask(adapter);
#line 6812
  tmp___1 = constant_test_bit(8L, (unsigned long const volatile   *)(& adapter->state));
#line 6812
  if (tmp___1 != 0) {
#line 6813
    ixgbe_ptp_overflow_check(adapter);
#line 6814
    ixgbe_ptp_rx_hang(adapter);
  } else {

  }
#line 6817
  ixgbe_service_event_complete(adapter);
#line 6818
  return;
}
}
#line 6820 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_tso(struct ixgbe_ring *tx_ring , struct ixgbe_tx_buffer *first ,
                     u8 *hdr_len ) 
{ 
  struct sk_buff *skb ;
  u32 vlan_macip_lens ;
  u32 type_tucmd ;
  u32 mss_l4len_idx ;
  u32 l4len ;
  int err ;
  bool tmp ;
  int tmp___0 ;
  struct iphdr *iph ;
  struct iphdr *tmp___1 ;
  struct tcphdr *tmp___2 ;
  __sum16 tmp___3 ;
  struct ipv6hdr *tmp___4 ;
  struct tcphdr *tmp___5 ;
  struct ipv6hdr *tmp___6 ;
  struct ipv6hdr *tmp___7 ;
  __sum16 tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  int tmp___13 ;

  {
#line 6824
  skb = first->skb;
#line 6829
  if ((unsigned int )*((unsigned char *)skb + 145UL) != 6U) {
#line 6830
    return (0);
  } else {

  }
#line 6832
  tmp = skb_is_gso((struct sk_buff  const  *)skb);
#line 6832
  if (tmp) {
#line 6832
    tmp___0 = 0;
  } else {
#line 6832
    tmp___0 = 1;
  }
#line 6832
  if (tmp___0) {
#line 6833
    return (0);
  } else {

  }
#line 6835
  err = skb_cow_head(skb, 0U);
#line 6836
  if (err < 0) {
#line 6837
    return (err);
  } else {

  }
#line 6840
  type_tucmd = 2048U;
#line 6842
  if ((unsigned int )first->protocol == 8U) {
#line 6843
    tmp___1 = ip_hdr((struct sk_buff  const  *)skb);
#line 6843
    iph = tmp___1;
#line 6844
    iph->tot_len = 0U;
#line 6845
    iph->check = 0U;
#line 6846
    tmp___2 = tcp_hdr((struct sk_buff  const  *)skb);
#line 6846
    tmp___3 = csum_tcpudp_magic(iph->saddr, iph->daddr, 0, 6, 0U);
#line 6846
    tmp___2->check = ~ ((int )tmp___3);
#line 6850
    type_tucmd = type_tucmd | 1024U;
#line 6851
    first->tx_flags = first->tx_flags | 50U;
  } else {
#line 6854
    tmp___9 = skb_is_gso_v6((struct sk_buff  const  *)skb);
#line 6854
    if ((int )tmp___9) {
#line 6855
      tmp___4 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 6855
      tmp___4->payload_len = 0U;
#line 6856
      tmp___5 = tcp_hdr((struct sk_buff  const  *)skb);
#line 6856
      tmp___6 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 6856
      tmp___7 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 6856
      tmp___8 = csum_ipv6_magic((struct in6_addr  const  *)(& tmp___7->saddr), (struct in6_addr  const  *)(& tmp___6->daddr),
                                0U, 6, 0U);
#line 6856
      tmp___5->check = ~ ((int )tmp___8);
#line 6860
      first->tx_flags = first->tx_flags | 34U;
    } else {

    }
  }
#line 6865
  l4len = tcp_hdrlen((struct sk_buff  const  *)skb);
#line 6866
  tmp___10 = skb_transport_offset((struct sk_buff  const  *)skb);
#line 6866
  *hdr_len = (int )((u8 )tmp___10) + (int )((u8 )l4len);
#line 6869
  tmp___11 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 6869
  first->gso_segs = ((struct skb_shared_info *)tmp___11)->gso_segs;
#line 6870
  first->bytecount = first->bytecount + (unsigned int )(((int )first->gso_segs + -1) * (int )*hdr_len);
#line 6873
  mss_l4len_idx = l4len << 8;
#line 6874
  tmp___12 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 6874
  mss_l4len_idx = (u32 )((int )((struct skb_shared_info *)tmp___12)->gso_size << 16) | mss_l4len_idx;
#line 6877
  vlan_macip_lens = skb_network_header_len((struct sk_buff  const  *)skb);
#line 6878
  tmp___13 = skb_network_offset((struct sk_buff  const  *)skb);
#line 6878
  vlan_macip_lens = (u32 )(tmp___13 << 9) | vlan_macip_lens;
#line 6879
  vlan_macip_lens = (first->tx_flags & 4294901760U) | vlan_macip_lens;
#line 6881
  ixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, 0U, type_tucmd, mss_l4len_idx);
#line 6884
  return (1);
}
}
#line 6887 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_tx_csum(struct ixgbe_ring *tx_ring , struct ixgbe_tx_buffer *first ) 
{ 
  struct sk_buff *skb ;
  u32 vlan_macip_lens ;
  u32 mss_l4len_idx ;
  u32 type_tucmd ;
  u8 l4_hdr ;
  u32 tmp ;
  struct iphdr *tmp___0 ;
  u32 tmp___1 ;
  struct ipv6hdr *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;

  {
#line 6890
  skb = first->skb;
#line 6891
  vlan_macip_lens = 0U;
#line 6892
  mss_l4len_idx = 0U;
#line 6893
  type_tucmd = 0U;
#line 6895
  if ((unsigned int )*((unsigned char *)skb + 145UL) != 6U) {
#line 6896
    if ((first->tx_flags & 1U) == 0U && (first->tx_flags & 8U) == 0U) {
#line 6898
      return;
    } else {

    }
  } else {
#line 6900
    l4_hdr = 0U;
#line 6901
    switch ((int )first->protocol) {
    case 8: 
#line 6903
    tmp = skb_network_header_len((struct sk_buff  const  *)skb);
#line 6903
    vlan_macip_lens = tmp | vlan_macip_lens;
#line 6904
    type_tucmd = type_tucmd | 1024U;
#line 6905
    tmp___0 = ip_hdr((struct sk_buff  const  *)skb);
#line 6905
    l4_hdr = tmp___0->protocol;
#line 6906
    goto ldv_58974;
    case 56710: 
#line 6908
    tmp___1 = skb_network_header_len((struct sk_buff  const  *)skb);
#line 6908
    vlan_macip_lens = tmp___1 | vlan_macip_lens;
#line 6909
    tmp___2 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 6909
    l4_hdr = tmp___2->nexthdr;
#line 6910
    goto ldv_58974;
    default: 
#line 6912
    tmp___3 = net_ratelimit();
#line 6912
    tmp___4 = ldv__builtin_expect(tmp___3 != 0, 0L);
#line 6912
    if (tmp___4 != 0L) {
#line 6913
      dev_warn((struct device  const  *)tx_ring->dev, "partial checksum but proto=%x!\n",
               (int )first->protocol);
    } else {

    }
#line 6917
    goto ldv_58974;
    }
    ldv_58974: ;
#line 6920
    switch ((int )l4_hdr) {
    case 6: 
#line 6922
    type_tucmd = type_tucmd | 2048U;
#line 6923
    tmp___5 = tcp_hdrlen((struct sk_buff  const  *)skb);
#line 6923
    mss_l4len_idx = tmp___5 << 8;
#line 6925
    goto ldv_58978;
    case 132: 
#line 6927
    type_tucmd = type_tucmd | 4096U;
#line 6928
    mss_l4len_idx = 3072U;
#line 6930
    goto ldv_58978;
    case 17: 
#line 6932
    mss_l4len_idx = 2048U;
#line 6934
    goto ldv_58978;
    default: 
#line 6936
    tmp___6 = net_ratelimit();
#line 6936
    tmp___7 = ldv__builtin_expect(tmp___6 != 0, 0L);
#line 6936
    if (tmp___7 != 0L) {
#line 6937
      dev_warn((struct device  const  *)tx_ring->dev, "partial checksum but l4 proto=%x!\n",
               (int )l4_hdr);
    } else {

    }
#line 6941
    goto ldv_58978;
    }
    ldv_58978: 
#line 6945
    first->tx_flags = first->tx_flags | 32U;
  }
#line 6949
  tmp___8 = skb_network_offset((struct sk_buff  const  *)skb);
#line 6949
  vlan_macip_lens = (u32 )(tmp___8 << 9) | vlan_macip_lens;
#line 6950
  vlan_macip_lens = (first->tx_flags & 4294901760U) | vlan_macip_lens;
#line 6952
  ixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, 0U, type_tucmd, mss_l4len_idx);
#line 6953
  return;
}
}
#line 6961 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u32 ixgbe_tx_cmd_type(struct sk_buff *skb , u32 tx_flags ) 
{ 
  u32 cmd_type ;

  {
#line 6964
  cmd_type = 573571072U;
#line 6969
  cmd_type = (tx_flags & 1U) * 1073741824U | cmd_type;
#line 6973
  cmd_type = (tx_flags & 2U) * 1073741824U | cmd_type;
#line 6977
  cmd_type = (tx_flags & 4U) * 131072U | cmd_type;
#line 6981
  cmd_type = (unsigned int )skb->no_fcs * 33554432U ^ cmd_type;
#line 6983
  return (cmd_type);
}
}
#line 6986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_tx_olinfo_status(union ixgbe_adv_tx_desc *tx_desc , u32 tx_flags ,
                                   unsigned int paylen ) 
{ 
  u32 olinfo_status ;

  {
#line 6989
  olinfo_status = paylen << 14;
#line 6992
  olinfo_status = (tx_flags & 32U) * 16U | olinfo_status;
#line 6997
  olinfo_status = (tx_flags & 16U) * 16U | olinfo_status;
#line 7005
  olinfo_status = (tx_flags & 8U) * 16U | olinfo_status;
#line 7009
  tx_desc->read.olinfo_status = olinfo_status;
#line 7010
  return;
}
}
#line 7012 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int __ixgbe_maybe_stop_tx(struct ixgbe_ring *tx_ring , u16 size ) 
{ 
  u16 tmp ;
  long tmp___0 ;

  {
#line 7014
  netif_stop_subqueue(tx_ring->netdev, (int )tx_ring->queue_index);
#line 7020
  __asm__  volatile   ("mfence": : : "memory");
#line 7025
  tmp = ixgbe_desc_unused(tx_ring);
#line 7025
  tmp___0 = ldv__builtin_expect((int )tmp < (int )size, 1L);
#line 7025
  if (tmp___0 != 0L) {
#line 7026
    return (-16);
  } else {

  }
#line 7029
  netif_start_subqueue(tx_ring->netdev, (int )tx_ring->queue_index);
#line 7030
  tx_ring->__annonCompField121.tx_stats.restart_queue = tx_ring->__annonCompField121.tx_stats.restart_queue + 1ULL;
#line 7031
  return (0);
}
}
#line 7034 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static int ixgbe_maybe_stop_tx(struct ixgbe_ring *tx_ring , u16 size ) 
{ 
  u16 tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 7036
  tmp = ixgbe_desc_unused(tx_ring);
#line 7036
  tmp___0 = ldv__builtin_expect((int )tmp >= (int )size, 1L);
#line 7036
  if (tmp___0 != 0L) {
#line 7037
    return (0);
  } else {

  }
#line 7039
  tmp___1 = __ixgbe_maybe_stop_tx(tx_ring, (int )size);
#line 7039
  return (tmp___1);
}
}
#line 7045 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_tx_map(struct ixgbe_ring *tx_ring , struct ixgbe_tx_buffer *first ,
                         u8 const   hdr_len ) 
{ 
  struct sk_buff *skb ;
  struct ixgbe_tx_buffer *tx_buffer ;
  union ixgbe_adv_tx_desc *tx_desc ;
  struct skb_frag_struct *frag ;
  dma_addr_t dma ;
  unsigned int data_len ;
  unsigned int size ;
  u32 tx_flags ;
  u32 cmd_type ;
  u32 tmp ;
  u16 i ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  unsigned int __min1 ;
  unsigned int __min2 ;
  unsigned int tmp___4 ;
  struct netdev_queue *tmp___5 ;
  struct netdev_queue *tmp___6 ;
  bool tmp___7 ;

  {
#line 7049
  skb = first->skb;
#line 7055
  tx_flags = first->tx_flags;
#line 7056
  tmp = ixgbe_tx_cmd_type(skb, tx_flags);
#line 7056
  cmd_type = tmp;
#line 7057
  i = tx_ring->next_to_use;
#line 7059
  tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc + (unsigned long )i;
#line 7061
  ixgbe_tx_olinfo_status(tx_desc, tx_flags, skb->len - (unsigned int )hdr_len);
#line 7063
  size = skb_headlen((struct sk_buff  const  *)skb);
#line 7064
  data_len = skb->data_len;
#line 7067
  if ((tx_flags & 128U) != 0U) {
#line 7068
    if (data_len <= 7U) {
#line 7069
      size = (size + data_len) - 8U;
#line 7070
      data_len = 0U;
    } else {
#line 7072
      data_len = data_len - 8U;
    }
  } else {

  }
#line 7077
  dma = dma_map_single_attrs(tx_ring->dev, (void *)skb->data, (size_t )size, 1, (struct dma_attrs *)0);
#line 7079
  tx_buffer = first;
#line 7081
  tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 7081
  frag = (struct skb_frag_struct *)(& ((struct skb_shared_info *)tmp___0)->frags);
  ldv_59024: 
#line 7082
  tmp___1 = dma_mapping_error(tx_ring->dev, dma);
#line 7082
  if (tmp___1 != 0) {
#line 7083
    goto dma_error;
  } else {

  }
#line 7086
  tx_buffer->len = size;
#line 7087
  tx_buffer->dma = dma;
#line 7089
  tx_desc->read.buffer_addr = dma;
#line 7091
  goto ldv_59018;
  ldv_59017: 
#line 7092
  tx_desc->read.cmd_type_len = cmd_type ^ 16384U;
#line 7095
  i = (u16 )((int )i + 1);
#line 7096
  tx_desc = tx_desc + 1;
#line 7097
  if ((int )tx_ring->count == (int )i) {
#line 7098
    tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc;
#line 7099
    i = 0U;
  } else {

  }
#line 7101
  tx_desc->read.olinfo_status = 0U;
#line 7103
  dma = dma + 16384ULL;
#line 7104
  size = size - 16384U;
#line 7106
  tx_desc->read.buffer_addr = dma;
  ldv_59018: 
#line 7091
  tmp___2 = ldv__builtin_expect(size > 16384U, 0L);
#line 7091
  if (tmp___2 != 0L) {
#line 7093
    goto ldv_59017;
  } else {

  }
#line 7109
  tmp___3 = ldv__builtin_expect(data_len == 0U, 1L);
#line 7109
  if (tmp___3 != 0L) {
#line 7110
    goto ldv_59020;
  } else {

  }
#line 7112
  tx_desc->read.cmd_type_len = cmd_type ^ size;
#line 7114
  i = (u16 )((int )i + 1);
#line 7115
  tx_desc = tx_desc + 1;
#line 7116
  if ((int )tx_ring->count == (int )i) {
#line 7117
    tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc;
#line 7118
    i = 0U;
  } else {

  }
#line 7120
  tx_desc->read.olinfo_status = 0U;
#line 7123
  __min1 = data_len;
#line 7123
  tmp___4 = skb_frag_size((skb_frag_t const   *)frag);
#line 7123
  __min2 = tmp___4;
#line 7123
  size = __min1 < __min2 ? __min1 : __min2;
#line 7127
  data_len = data_len - size;
#line 7129
  dma = skb_frag_dma_map(tx_ring->dev, (skb_frag_t const   *)frag, 0UL, (size_t )size,
                         1);
#line 7132
  tx_buffer = tx_ring->__annonCompField118.tx_buffer_info + (unsigned long )i;
#line 7081
  frag = frag + 1;
#line 7133
  goto ldv_59024;
  ldv_59020: 
#line 7136
  cmd_type = (size | cmd_type) | 150994944U;
#line 7137
  tx_desc->read.cmd_type_len = cmd_type;
#line 7139
  tmp___5 = txring_txq((struct ixgbe_ring  const  *)tx_ring);
#line 7139
  netdev_tx_sent_queue(tmp___5, first->bytecount);
#line 7142
  first->time_stamp = jiffies;
#line 7152
  __asm__  volatile   ("sfence": : : "memory");
#line 7155
  first->next_to_watch = tx_desc;
#line 7157
  i = (u16 )((int )i + 1);
#line 7158
  if ((int )tx_ring->count == (int )i) {
#line 7159
    i = 0U;
  } else {

  }
#line 7161
  tx_ring->next_to_use = i;
#line 7163
  ixgbe_maybe_stop_tx(tx_ring, 21);
#line 7165
  tmp___6 = txring_txq((struct ixgbe_ring  const  *)tx_ring);
#line 7165
  tmp___7 = netif_xmit_stopped((struct netdev_queue  const  *)tmp___6);
#line 7165
  if ((int )tmp___7 || (unsigned int )*((unsigned char *)skb + 142UL) == 0U) {
#line 7166
    writel((unsigned int )i, (void volatile   *)tx_ring->tail);
#line 7171
    __asm__  volatile   ("": : : "memory");
  } else {

  }
#line 7174
  return;
  dma_error: 
#line 7176
  dev_err((struct device  const  *)tx_ring->dev, "TX DMA map failed\n");
  ldv_59026: 
#line 7180
  tx_buffer = tx_ring->__annonCompField118.tx_buffer_info + (unsigned long )i;
#line 7181
  ixgbe_unmap_and_free_tx_resource(tx_ring, tx_buffer);
#line 7182
  if ((unsigned long )tx_buffer == (unsigned long )first) {
#line 7183
    goto ldv_59025;
  } else {

  }
#line 7184
  if ((unsigned int )i == 0U) {
#line 7185
    i = tx_ring->count;
  } else {

  }
#line 7186
  i = (u16 )((int )i - 1);
#line 7187
  goto ldv_59026;
  ldv_59025: 
#line 7189
  tx_ring->next_to_use = i;
#line 7190
  return;
}
}
#line 7192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_atr(struct ixgbe_ring *ring , struct ixgbe_tx_buffer *first ) 
{ 
  struct ixgbe_q_vector *q_vector ;
  union ixgbe_atr_hash_dword input ;
  union ixgbe_atr_hash_dword common ;
  union __anonunion_hdr_412 hdr ;
  struct tcphdr *th ;
  __be16 vlan_id ;
  __u16 tmp ;

  {
#line 7195
  q_vector = ring->q_vector;
#line 7196
  input.dword = 0U;
#line 7197
  common.dword = 0U;
#line 7207
  if ((unsigned long )q_vector == (unsigned long )((struct ixgbe_q_vector *)0)) {
#line 7208
    return;
  } else {

  }
#line 7211
  if ((unsigned int )ring->__annonCompField120.__annonCompField119.atr_sample_rate == 0U) {
#line 7212
    return;
  } else {

  }
#line 7214
  ring->__annonCompField120.__annonCompField119.atr_count = (u8 )((int )ring->__annonCompField120.__annonCompField119.atr_count + 1);
#line 7217
  hdr.network = skb_network_header((struct sk_buff  const  *)first->skb);
#line 7220
  if (((unsigned int )first->protocol != 56710U || (unsigned int )(hdr.ipv6)->nexthdr != 6U) && ((unsigned int )first->protocol != 8U || (unsigned int )(hdr.ipv4)->protocol != 6U)) {
#line 7224
    return;
  } else {

  }
#line 7226
  th = tcp_hdr((struct sk_buff  const  *)first->skb);
#line 7229
  if ((unsigned long )th == (unsigned long )((struct tcphdr *)0) || (unsigned int )*((unsigned char *)th + 13UL) != 0U) {
#line 7230
    return;
  } else {

  }
#line 7233
  if ((unsigned int )*((unsigned char *)th + 13UL) == 0U && (int )ring->__annonCompField120.__annonCompField119.atr_count < (int )ring->__annonCompField120.__annonCompField119.atr_sample_rate) {
#line 7234
    return;
  } else {

  }
#line 7237
  ring->__annonCompField120.__annonCompField119.atr_count = 0U;
#line 7239
  tmp = __fswab16((int )((__u16 )(first->tx_flags >> 16)));
#line 7239
  vlan_id = tmp;
#line 7248
  input.formatted.vlan_id = vlan_id;
#line 7254
  if ((first->tx_flags & 65U) != 0U) {
#line 7255
    common.port.src = (__be16 )((unsigned int )((int )common.port.src ^ (int )th->dest) ^ 129U);
  } else {
#line 7257
    common.port.src = (__be16 )((int )common.port.src ^ ((int )th->dest ^ (int )first->protocol));
  }
#line 7258
  common.port.dst = (__be16 )((int )common.port.dst ^ (int )th->source);
#line 7260
  if ((unsigned int )first->protocol == 8U) {
#line 7261
    input.formatted.flow_type = 2U;
#line 7262
    common.ip = common.ip ^ ((hdr.ipv4)->saddr ^ (hdr.ipv4)->daddr);
  } else {
#line 7264
    input.formatted.flow_type = 6U;
#line 7265
    common.ip = common.ip ^ ((((((((hdr.ipv6)->saddr.in6_u.u6_addr32[0] ^ (hdr.ipv6)->saddr.in6_u.u6_addr32[1]) ^ (hdr.ipv6)->saddr.in6_u.u6_addr32[2]) ^ (hdr.ipv6)->saddr.in6_u.u6_addr32[3]) ^ (hdr.ipv6)->daddr.in6_u.u6_addr32[0]) ^ (hdr.ipv6)->daddr.in6_u.u6_addr32[1]) ^ (hdr.ipv6)->daddr.in6_u.u6_addr32[2]) ^ (hdr.ipv6)->daddr.in6_u.u6_addr32[3]);
  }
#line 7276
  ixgbe_fdir_add_signature_filter_82599(& (q_vector->adapter)->hw, input, common,
                                        (int )ring->queue_index);
#line 7278
  return;
}
}
#line 7280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u16 ixgbe_select_queue(struct net_device *dev , struct sk_buff *skb , void *accel_priv ,
                              u16 (*fallback)(struct net_device * , struct sk_buff * ) ) 
{ 
  struct ixgbe_fwd_adapter *fwd_adapter ;
  struct ixgbe_adapter *adapter ;
  struct ixgbe_ring_feature *f ;
  int txq ;
  __be16 tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___3 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  bool tmp___4 ;

  {
#line 7283
  fwd_adapter = (struct ixgbe_fwd_adapter *)accel_priv;
#line 7290
  if ((unsigned long )fwd_adapter != (unsigned long )((struct ixgbe_fwd_adapter *)0)) {
#line 7291
    return ((int )skb->queue_mapping + (int )((u16 )fwd_adapter->tx_base_queue));
  } else {

  }
#line 7299
  tmp = vlan_get_protocol(skb);
#line 7299
  switch ((int )tmp) {
  case 1673: ;
  case 5257: 
#line 7302
  tmp___0 = netdev_priv((struct net_device  const  *)dev);
#line 7302
  adapter = (struct ixgbe_adapter *)tmp___0;
#line 7304
  if ((adapter->flags & 2097152U) != 0U) {
#line 7305
    goto ldv_59053;
  } else {

  }
  default: 
#line 7307
  tmp___1 = (*fallback)(dev, skb);
#line 7307
  return (tmp___1);
  }
  ldv_59053: 
#line 7310
  f = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 7313
  tmp___4 = skb_rx_queue_recorded((struct sk_buff  const  *)skb);
#line 7313
  if ((int )tmp___4) {
#line 7312
    tmp___3 = skb_get_rx_queue((struct sk_buff  const  *)skb);
#line 7313
    txq = (int )tmp___3;
  } else {
#line 7313
    __vpp_verify = (void const   *)0;
#line 7313
    switch (4UL) {
    case 1UL: ;
#line 7313
    switch (4UL) {
    case 1UL: 
#line 7313
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 7313
    goto ldv_59060;
    case 2UL: 
#line 7313
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 7313
    goto ldv_59060;
    case 4UL: 
#line 7313
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 7313
    goto ldv_59060;
    case 8UL: 
#line 7313
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 7313
    goto ldv_59060;
    default: 
#line 7313
    __bad_percpu_size();
    }
    ldv_59060: 
#line 7313
    pscr_ret__ = pfo_ret__;
#line 7313
    goto ldv_59066;
    case 2UL: ;
#line 7313
    switch (4UL) {
    case 1UL: 
#line 7313
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 7313
    goto ldv_59070;
    case 2UL: 
#line 7313
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 7313
    goto ldv_59070;
    case 4UL: 
#line 7313
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 7313
    goto ldv_59070;
    case 8UL: 
#line 7313
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 7313
    goto ldv_59070;
    default: 
#line 7313
    __bad_percpu_size();
    }
    ldv_59070: 
#line 7313
    pscr_ret__ = pfo_ret_____0;
#line 7313
    goto ldv_59066;
    case 4UL: ;
#line 7313
    switch (4UL) {
    case 1UL: 
#line 7313
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 7313
    goto ldv_59079;
    case 2UL: 
#line 7313
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 7313
    goto ldv_59079;
    case 4UL: 
#line 7313
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 7313
    goto ldv_59079;
    case 8UL: 
#line 7313
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 7313
    goto ldv_59079;
    default: 
#line 7313
    __bad_percpu_size();
    }
    ldv_59079: 
#line 7313
    pscr_ret__ = pfo_ret_____1;
#line 7313
    goto ldv_59066;
    case 8UL: ;
#line 7313
    switch (4UL) {
    case 1UL: 
#line 7313
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 7313
    goto ldv_59088;
    case 2UL: 
#line 7313
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 7313
    goto ldv_59088;
    case 4UL: 
#line 7313
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 7313
    goto ldv_59088;
    case 8UL: 
#line 7313
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 7313
    goto ldv_59088;
    default: 
#line 7313
    __bad_percpu_size();
    }
    ldv_59088: 
#line 7313
    pscr_ret__ = pfo_ret_____2;
#line 7313
    goto ldv_59066;
    default: 
#line 7313
    __bad_size_call_parameter();
#line 7313
    goto ldv_59066;
    }
    ldv_59066: 
#line 7313
    txq = pscr_ret__;
  }
#line 7315
  goto ldv_59097;
  ldv_59096: 
#line 7316
  txq = txq - (int )f->indices;
  ldv_59097: ;
#line 7315
  if ((int )f->indices <= txq) {
#line 7317
    goto ldv_59096;
  } else {

  }

#line 7318
  return ((int )f->offset + (int )((u16 )txq));
}
}
#line 7324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb , struct ixgbe_adapter *adapter ,
                                  struct ixgbe_ring *tx_ring ) 
{ 
  struct ixgbe_tx_buffer *first ;
  int tso ;
  u32 tx_flags ;
  unsigned short f ;
  u16 count ;
  unsigned int tmp ;
  __be16 protocol ;
  u8 hdr_len ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  struct vlan_hdr *vhdr ;
  struct vlan_hdr _vhdr ;
  void *tmp___3 ;
  __u16 tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  struct vlan_ethhdr *vhdr___0 ;
  int tmp___10 ;
  __u16 tmp___11 ;
  int tmp___12 ;

  {
#line 7330
  tx_flags = 0U;
#line 7332
  tmp = skb_headlen((struct sk_buff  const  *)skb);
#line 7332
  count = (u16 )((tmp + 16383U) / 16384U);
#line 7333
  protocol = skb->protocol;
#line 7334
  hdr_len = 0U;
#line 7343
  f = 0U;
#line 7343
  goto ldv_59112;
  ldv_59111: 
#line 7344
  tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 7344
  count = (int )((u16 )((((struct skb_shared_info *)tmp___0)->frags[(int )f].size + 16383U) / 16384U)) + (int )count;
#line 7343
  f = (unsigned short )((int )f + 1);
  ldv_59112: 
#line 7343
  tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 7343
  if ((int )((unsigned short )((struct skb_shared_info *)tmp___1)->nr_frags) > (int )f) {
#line 7345
    goto ldv_59111;
  } else {

  }
#line 7346
  tmp___2 = ixgbe_maybe_stop_tx(tx_ring, (int )((unsigned int )count + 3U));
#line 7346
  if (tmp___2 != 0) {
#line 7347
    tx_ring->__annonCompField121.tx_stats.tx_busy = tx_ring->__annonCompField121.tx_stats.tx_busy + 1ULL;
#line 7348
    return (16);
  } else {

  }
#line 7352
  first = tx_ring->__annonCompField118.tx_buffer_info + (unsigned long )tx_ring->next_to_use;
#line 7353
  first->skb = skb;
#line 7354
  first->bytecount = skb->len;
#line 7355
  first->gso_segs = 1U;
#line 7358
  if (((int )skb->vlan_tci & 4096) != 0) {
#line 7359
    tx_flags = (u32 )(((int )skb->vlan_tci & -4097) << 16) | tx_flags;
#line 7360
    tx_flags = tx_flags | 1U;
  } else
#line 7362
  if ((unsigned int )protocol == 129U) {
#line 7364
    tmp___3 = skb_header_pointer((struct sk_buff  const  *)skb, 14, 4, (void *)(& _vhdr));
#line 7364
    vhdr = (struct vlan_hdr *)tmp___3;
#line 7365
    if ((unsigned long )vhdr == (unsigned long )((struct vlan_hdr *)0)) {
#line 7366
      goto out_drop;
    } else {

    }
#line 7368
    tmp___4 = __fswab16((int )vhdr->h_vlan_TCI);
#line 7368
    tx_flags = (u32 )((int )tmp___4 << 16) | tx_flags;
#line 7370
    tx_flags = tx_flags | 64U;
  } else {

  }
#line 7372
  protocol = vlan_get_protocol(skb);
#line 7374
  tmp___7 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 7374
  tmp___8 = ldv__builtin_expect((long )((struct skb_shared_info *)tmp___7)->tx_flags & 1L,
                             0L);
#line 7374
  if (tmp___8 != 0L && (unsigned long )adapter->ptp_clock != (unsigned long )((struct ptp_clock *)0)) {
#line 7374
    tmp___9 = test_and_set_bit_lock(9L, (unsigned long volatile   *)(& adapter->state));
#line 7374
    if (tmp___9 == 0) {
#line 7378
      tmp___5 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 7378
      tmp___6 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 7378
      ((struct skb_shared_info *)tmp___5)->tx_flags = (__u8 )((unsigned int )((struct skb_shared_info *)tmp___6)->tx_flags | 4U);
#line 7379
      tx_flags = tx_flags | 4U;
#line 7382
      adapter->ptp_tx_skb = skb_get(skb);
#line 7383
      adapter->ptp_tx_start = jiffies;
#line 7384
      schedule_work(& adapter->ptp_tx_work);
    } else {

    }
  } else {

  }
#line 7387
  skb_tx_timestamp(skb);
#line 7394
  if ((adapter->flags & 8388608U) != 0U) {
#line 7395
    tx_flags = tx_flags | 8U;
  } else {

  }
#line 7399
  if ((adapter->flags & 4096U) != 0U && ((tx_flags & 65U) != 0U || skb->priority != 7U)) {
#line 7402
    tx_flags = tx_flags & 536870911U;
#line 7403
    tx_flags = (skb->priority << 29) | tx_flags;
#line 7405
    if ((tx_flags & 64U) != 0U) {
#line 7408
      tmp___10 = skb_cow_head(skb, 0U);
#line 7408
      if (tmp___10 != 0) {
#line 7409
        goto out_drop;
      } else {

      }
#line 7410
      vhdr___0 = (struct vlan_ethhdr *)skb->data;
#line 7411
      tmp___11 = __fswab16((int )((__u16 )(tx_flags >> 16)));
#line 7411
      vhdr___0->h_vlan_TCI = tmp___11;
    } else {
#line 7414
      tx_flags = tx_flags | 1U;
    }
  } else {

  }
#line 7419
  first->tx_flags = tx_flags;
#line 7420
  first->protocol = protocol;
#line 7424
  if ((unsigned int )protocol == 1673U && ((tx_ring->netdev)->features & 538968064ULL) != 0ULL) {
#line 7426
    tso = ixgbe_fso(tx_ring, first, & hdr_len);
#line 7427
    if (tso < 0) {
#line 7428
      goto out_drop;
    } else {

    }
#line 7430
    goto xmit_fcoe;
  } else {

  }
#line 7434
  tso = ixgbe_tso(tx_ring, first, & hdr_len);
#line 7435
  if (tso < 0) {
#line 7436
    goto out_drop;
  } else
#line 7437
  if (tso == 0) {
#line 7438
    ixgbe_tx_csum(tx_ring, first);
  } else {

  }
#line 7441
  tmp___12 = constant_test_bit(0L, (unsigned long const volatile   *)(& tx_ring->state));
#line 7441
  if (tmp___12 != 0) {
#line 7442
    ixgbe_atr(tx_ring, first);
  } else {

  }
  xmit_fcoe: 
#line 7447
  ixgbe_tx_map(tx_ring, first, (int )hdr_len);
#line 7449
  return (0);
  out_drop: 
#line 7452
  dev_kfree_skb_any(first->skb);
#line 7453
  first->skb = (struct sk_buff *)0;
#line 7455
  return (0);
}
}
#line 7458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static netdev_tx_t __ixgbe_xmit_frame(struct sk_buff *skb , struct net_device *netdev ,
                                      struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_ring *tx_ring ;
  int tmp___0 ;
  netdev_tx_t tmp___1 ;

  {
#line 7462
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7462
  adapter = (struct ixgbe_adapter *)tmp;
#line 7469
  tmp___0 = skb_put_padto(skb, 17U);
#line 7469
  if (tmp___0 != 0) {
#line 7470
    return (0);
  } else {

  }
#line 7472
  tx_ring = (unsigned long )ring == (unsigned long )((struct ixgbe_ring *)0) ? adapter->tx_ring[(int )skb->queue_mapping] : ring;
#line 7474
  tmp___1 = ixgbe_xmit_frame_ring(skb, adapter, tx_ring);
#line 7474
  return (tmp___1);
}
}
#line 7477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static netdev_tx_t ixgbe_xmit_frame(struct sk_buff *skb , struct net_device *netdev ) 
{ 
  netdev_tx_t tmp ;

  {
#line 7480
  tmp = __ixgbe_xmit_frame(skb, netdev, (struct ixgbe_ring *)0);
#line 7480
  return (tmp);
}
}
#line 7490 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_set_mac(struct net_device *netdev , void *p ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  struct sockaddr *addr ;
  int ret ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 7492
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7492
  adapter = (struct ixgbe_adapter *)tmp;
#line 7493
  hw = & adapter->hw;
#line 7494
  addr = (struct sockaddr *)p;
#line 7497
  tmp___0 = is_valid_ether_addr((u8 const   *)(& addr->sa_data));
#line 7497
  if (tmp___0) {
#line 7497
    tmp___1 = 0;
  } else {
#line 7497
    tmp___1 = 1;
  }
#line 7497
  if (tmp___1) {
#line 7498
    return (-99);
  } else {

  }
#line 7500
  ixgbe_del_mac_filter(adapter, (u8 *)(& hw->mac.addr), (int )adapter->ring_feature[1].offset);
#line 7501
  memcpy((void *)netdev->dev_addr, (void const   *)(& addr->sa_data), (size_t )netdev->addr_len);
#line 7502
  memcpy((void *)(& hw->mac.addr), (void const   *)(& addr->sa_data), (size_t )netdev->addr_len);
#line 7504
  ret = ixgbe_add_mac_filter(adapter, (u8 *)(& hw->mac.addr), (int )adapter->ring_feature[1].offset);
#line 7505
  return (0 < ret ? 0 : ret);
}
}
#line 7509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_mdio_read(struct net_device *netdev , int prtad , int devad , u16 addr ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u16 value ;
  int rc ;

  {
#line 7511
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7511
  adapter = (struct ixgbe_adapter *)tmp;
#line 7512
  hw = & adapter->hw;
#line 7516
  if (hw->phy.mdio.prtad != prtad) {
#line 7517
    return (-22);
  } else {

  }
#line 7518
  rc = (*(hw->phy.ops.read_reg))(hw, (u32 )addr, (u32 )devad, & value);
#line 7519
  if (rc == 0) {
#line 7520
    rc = (int )value;
  } else {

  }
#line 7521
  return (rc);
}
}
#line 7524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_mdio_write(struct net_device *netdev , int prtad , int devad , u16 addr ,
                            u16 value ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  s32 tmp___0 ;

  {
#line 7527
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7527
  adapter = (struct ixgbe_adapter *)tmp;
#line 7528
  hw = & adapter->hw;
#line 7530
  if (hw->phy.mdio.prtad != prtad) {
#line 7531
    return (-22);
  } else {

  }
#line 7532
  tmp___0 = (*(hw->phy.ops.write_reg))(hw, (u32 )addr, (u32 )devad, (int )value);
#line 7532
  return (tmp___0);
}
}
#line 7535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_ioctl(struct net_device *netdev , struct ifreq *req , int cmd ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct mii_ioctl_data *tmp___2 ;
  int tmp___3 ;

  {
#line 7537
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7537
  adapter = (struct ixgbe_adapter *)tmp;
#line 7539
  switch (cmd) {
  case 35248: 
#line 7541
  tmp___0 = ixgbe_ptp_set_ts_config(adapter, req);
#line 7541
  return (tmp___0);
  case 35249: 
#line 7543
  tmp___1 = ixgbe_ptp_get_ts_config(adapter, req);
#line 7543
  return (tmp___1);
  default: 
#line 7545
  tmp___2 = if_mii(req);
#line 7545
  tmp___3 = mdio_mii_ioctl((struct mdio_if_info  const  *)(& adapter->hw.phy.mdio),
                           tmp___2, cmd);
#line 7545
  return (tmp___3);
  }
}
}
#line 7556 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_add_sanmac_netdev(struct net_device *dev ) 
{ 
  int err ;
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  bool tmp___0 ;

  {
#line 7558
  err = 0;
#line 7559
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 7559
  adapter = (struct ixgbe_adapter *)tmp;
#line 7560
  hw = & adapter->hw;
#line 7562
  tmp___0 = is_valid_ether_addr((u8 const   *)(& hw->mac.san_addr));
#line 7562
  if ((int )tmp___0) {
#line 7563
    rtnl_lock();
#line 7564
    err = dev_addr_add(dev, (unsigned char const   *)(& hw->mac.san_addr), 2);
#line 7565
    rtnl_unlock();
#line 7568
    (*(hw->mac.ops.set_vmdq_san_mac))(hw, (u32 )adapter->ring_feature[1].offset);
  } else {

  }
#line 7570
  return (err);
}
}
#line 7580 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_del_sanmac_netdev(struct net_device *dev ) 
{ 
  int err ;
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_mac_info *mac ;
  bool tmp___0 ;

  {
#line 7582
  err = 0;
#line 7583
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 7583
  adapter = (struct ixgbe_adapter *)tmp;
#line 7584
  mac = & adapter->hw.mac;
#line 7586
  tmp___0 = is_valid_ether_addr((u8 const   *)(& mac->san_addr));
#line 7586
  if ((int )tmp___0) {
#line 7587
    rtnl_lock();
#line 7588
    err = dev_addr_del(dev, (unsigned char const   *)(& mac->san_addr), 2);
#line 7589
    rtnl_unlock();
  } else {

  }
#line 7591
  return (err);
}
}
#line 7600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_netpoll(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int i ;
  int tmp___0 ;

  {
#line 7602
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7602
  adapter = (struct ixgbe_adapter *)tmp;
#line 7606
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 7606
  if (tmp___0 != 0) {
#line 7607
    return;
  } else {

  }
#line 7610
  i = 0;
#line 7610
  goto ldv_59184;
  ldv_59183: 
#line 7611
  ixgbe_msix_clean_rings(0, (void *)adapter->q_vector[i]);
#line 7610
  i = i + 1;
  ldv_59184: ;
#line 7610
  if (adapter->num_q_vectors > i) {
#line 7612
    goto ldv_59183;
  } else {

  }

#line 7617
  return;
}
}
#line 7615 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct rtnl_link_stats64 *ixgbe_get_stats64(struct net_device *netdev , struct rtnl_link_stats64 *stats ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int i ;
  struct ixgbe_ring *ring ;
  struct ixgbe_ring *__var ;
  u64 bytes ;
  u64 packets ;
  unsigned int start ;
  bool tmp___0 ;
  struct ixgbe_ring *ring___0 ;
  struct ixgbe_ring *__var___0 ;
  u64 bytes___0 ;
  u64 packets___0 ;
  unsigned int start___0 ;
  bool tmp___1 ;

  {
#line 7618
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7618
  adapter = (struct ixgbe_adapter *)tmp;
#line 7621
  rcu_read_lock();
#line 7622
  i = 0;
#line 7622
  goto ldv_59201;
  ldv_59200: 
#line 7623
  __var = (struct ixgbe_ring *)0;
#line 7623
  ring = *((struct ixgbe_ring * volatile  *)(& adapter->rx_ring) + (unsigned long )i);
#line 7627
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
    ldv_59198: 
#line 7629
    start = u64_stats_fetch_begin_irq((struct u64_stats_sync  const  *)(& ring->syncp));
#line 7630
    packets = ring->stats.packets;
#line 7631
    bytes = ring->stats.bytes;
#line 7632
    tmp___0 = u64_stats_fetch_retry_irq((struct u64_stats_sync  const  *)(& ring->syncp),
                                        start);
#line 7632
    if ((int )tmp___0) {
#line 7634
      goto ldv_59198;
    } else {

    }
#line 7633
    stats->rx_packets = stats->rx_packets + packets;
#line 7634
    stats->rx_bytes = stats->rx_bytes + bytes;
  } else {

  }
#line 7622
  i = i + 1;
  ldv_59201: ;
#line 7622
  if (adapter->num_rx_queues > i) {
#line 7624
    goto ldv_59200;
  } else {

  }
#line 7638
  i = 0;
#line 7638
  goto ldv_59212;
  ldv_59211: 
#line 7639
  __var___0 = (struct ixgbe_ring *)0;
#line 7639
  ring___0 = *((struct ixgbe_ring * volatile  *)(& adapter->tx_ring) + (unsigned long )i);
#line 7643
  if ((unsigned long )ring___0 != (unsigned long )((struct ixgbe_ring *)0)) {
    ldv_59209: 
#line 7645
    start___0 = u64_stats_fetch_begin_irq((struct u64_stats_sync  const  *)(& ring___0->syncp));
#line 7646
    packets___0 = ring___0->stats.packets;
#line 7647
    bytes___0 = ring___0->stats.bytes;
#line 7648
    tmp___1 = u64_stats_fetch_retry_irq((struct u64_stats_sync  const  *)(& ring___0->syncp),
                                        start___0);
#line 7648
    if ((int )tmp___1) {
#line 7650
      goto ldv_59209;
    } else {

    }
#line 7649
    stats->tx_packets = stats->tx_packets + packets___0;
#line 7650
    stats->tx_bytes = stats->tx_bytes + bytes___0;
  } else {

  }
#line 7638
  i = i + 1;
  ldv_59212: ;
#line 7638
  if (adapter->num_tx_queues > i) {
#line 7640
    goto ldv_59211;
  } else {

  }
#line 7653
  rcu_read_unlock();
#line 7655
  stats->multicast = (__u64 )netdev->stats.multicast;
#line 7656
  stats->rx_errors = (__u64 )netdev->stats.rx_errors;
#line 7657
  stats->rx_length_errors = (__u64 )netdev->stats.rx_length_errors;
#line 7658
  stats->rx_crc_errors = (__u64 )netdev->stats.rx_crc_errors;
#line 7659
  stats->rx_missed_errors = (__u64 )netdev->stats.rx_missed_errors;
#line 7660
  return (stats);
}
}
#line 7672 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_validate_rtr(struct ixgbe_adapter *adapter , u8 tc ) 
{ 
  struct ixgbe_hw *hw ;
  u32 reg ;
  u32 rsave ;
  int i ;
  u8 up2tc ;

  {
#line 7674
  hw = & adapter->hw;
#line 7681
  if ((unsigned int )hw->mac.type == 1U) {
#line 7682
    return;
  } else {

  }
#line 7684
  reg = ixgbe_read_reg(hw, 12320U);
#line 7685
  rsave = reg;
#line 7687
  i = 0;
#line 7687
  goto ldv_59224;
  ldv_59223: 
#line 7688
  up2tc = (u8 )(reg >> i * 3);
#line 7691
  if ((int )up2tc > (int )tc) {
#line 7692
    reg = reg & 4294967239U;
  } else {

  }
#line 7687
  i = i + 1;
  ldv_59224: ;
#line 7687
  if (i <= 7) {
#line 7689
    goto ldv_59223;
  } else {

  }

#line 7695
  if (reg != rsave) {
#line 7696
    ixgbe_write_reg(hw, 12320U, reg);
  } else {

  }
#line 7698
  return;
}
}
#line 7707 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_prio_tc_map(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *dev ;
  struct ixgbe_dcb_config *dcb_cfg ;
  struct ieee_ets *ets ;
  u8 prio ;
  u8 tc ;

  {
#line 7709
  dev = adapter->netdev;
#line 7710
  dcb_cfg = & adapter->dcb_cfg;
#line 7711
  ets = adapter->ixgbe_ieee_ets;
#line 7714
  prio = 0U;
#line 7714
  goto ldv_59235;
  ldv_59234: 
#line 7715
  tc = 0U;
#line 7717
  if (((int )adapter->dcbx_cap & 4) != 0) {
#line 7718
    tc = ixgbe_dcb_get_tc_from_up(dcb_cfg, 0, (int )prio);
  } else
#line 7719
  if ((unsigned long )ets != (unsigned long )((struct ieee_ets *)0)) {
#line 7720
    tc = ets->prio_tc[(int )prio];
  } else {

  }
#line 7722
  netdev_set_prio_tc_map(dev, (int )prio, (int )tc);
#line 7714
  prio = (u8 )((int )prio + 1);
  ldv_59235: ;
#line 7714
  if ((unsigned int )prio <= 7U) {
#line 7716
    goto ldv_59234;
  } else {

  }

#line 7721
  return;
}
}
#line 7733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_setup_tc(struct net_device *dev , u8 tc ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  bool pools ;
  unsigned long tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;

  {
#line 7735
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 7735
  adapter = (struct ixgbe_adapter *)tmp;
#line 7736
  hw = & adapter->hw;
#line 7740
  if ((int )adapter->dcb_cfg.num_tcs.pg_tcs < (int )tc || ((unsigned int )hw->mac.type == 1U && (unsigned int )tc <= 7U)) {
#line 7743
    return (-22);
  } else {

  }
#line 7745
  tmp___0 = find_first_zero_bit((unsigned long const   *)(& adapter->fwd_bitmask),
                                32UL);
#line 7745
  pools = tmp___0 > 1UL;
#line 7746
  if (((unsigned int )tc != 0U && (int )pools) && adapter->num_rx_pools > 8) {
#line 7747
    return (-16);
  } else {

  }
#line 7753
  tmp___1 = netif_running((struct net_device  const  *)dev);
#line 7753
  if ((int )tmp___1) {
#line 7754
    ixgbe_close(dev);
  } else {

  }
#line 7755
  ixgbe_clear_interrupt_scheme(adapter);
#line 7758
  if ((unsigned int )tc != 0U) {
#line 7759
    netdev_set_num_tc(dev, (int )tc);
#line 7760
    ixgbe_set_prio_tc_map(adapter);
#line 7762
    adapter->flags = adapter->flags | 4096U;
#line 7764
    if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 7765
      adapter->last_lfc_mode = adapter->hw.fc.requested_mode;
#line 7766
      adapter->hw.fc.requested_mode = 0;
    } else {

    }
  } else {
#line 7769
    netdev_reset_tc(dev);
#line 7771
    if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 7772
      adapter->hw.fc.requested_mode = adapter->last_lfc_mode;
    } else {

    }
#line 7774
    adapter->flags = adapter->flags & 4294963199U;
#line 7776
    adapter->temp_dcb_cfg.pfc_mode_enable = 0;
#line 7777
    adapter->dcb_cfg.pfc_mode_enable = 0;
  }
#line 7780
  ixgbe_validate_rtr(adapter, (int )tc);
#line 7783
  ixgbe_init_interrupt_scheme(adapter);
#line 7785
  tmp___3 = netif_running((struct net_device  const  *)dev);
#line 7785
  if ((int )tmp___3) {
#line 7786
    tmp___2 = ixgbe_open(dev);
#line 7786
    return (tmp___2);
  } else {

  }
#line 7788
  return (0);
}
}
#line 7792 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_sriov_reinit(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int tmp ;

  {
#line 7794
  netdev = adapter->netdev;
#line 7796
  rtnl_lock();
#line 7797
  tmp = netdev_get_num_tc(netdev);
#line 7797
  ixgbe_setup_tc(netdev, (int )((u8 )tmp));
#line 7798
  rtnl_unlock();
#line 7799
  return;
}
}
#line 7802 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_do_reset(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;

  {
#line 7804
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7804
  adapter = (struct ixgbe_adapter *)tmp;
#line 7806
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 7806
  if ((int )tmp___0) {
#line 7807
    ixgbe_reinit_locked(adapter);
  } else {
#line 7809
    ixgbe_reset(adapter);
  }
#line 7810
  return;
}
}
#line 7812 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static netdev_features_t ixgbe_fix_features(struct net_device *netdev , netdev_features_t features ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 7815
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7815
  adapter = (struct ixgbe_adapter *)tmp;
#line 7818
  if ((features & 17179869184ULL) == 0ULL) {
#line 7819
    features = features & 0xffffffffffff7fffULL;
  } else {

  }
#line 7822
  if ((adapter->flags2 & 1U) == 0U) {
#line 7823
    features = features & 0xffffffffffff7fffULL;
  } else {

  }
#line 7825
  return (features);
}
}
#line 7828 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_set_features(struct net_device *netdev , netdev_features_t features ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  netdev_features_t changed ;
  bool need_reset ;
  int tmp___0 ;

  {
#line 7831
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7831
  adapter = (struct ixgbe_adapter *)tmp;
#line 7832
  changed = netdev->features ^ features;
#line 7833
  need_reset = 0;
#line 7836
  if ((features & 32768ULL) == 0ULL) {
#line 7837
    if ((adapter->flags2 & 2U) != 0U) {
#line 7838
      need_reset = 1;
    } else {

    }
#line 7839
    adapter->flags2 = adapter->flags2 & 4294967293U;
  } else
#line 7840
  if ((int )adapter->flags2 & 1 && (adapter->flags2 & 2U) == 0U) {
#line 7842
    if ((unsigned int )adapter->rx_itr_setting == 1U || (unsigned int )adapter->rx_itr_setting > 24U) {
#line 7844
      adapter->flags2 = adapter->flags2 | 2U;
#line 7845
      need_reset = 1;
    } else
#line 7846
    if (((changed ^ features) & 32768ULL) != 0ULL) {
#line 7847
      if (((int )adapter->msg_enable & 2) != 0) {
#line 7848
        netdev_info((struct net_device  const  *)adapter->netdev, "rx-usecs set too low, disabling RSC\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 7856
  switch (features & 4294967296ULL) {
  case 0ULL: ;
#line 7859
  if ((adapter->flags & 524288U) == 0U) {
#line 7860
    need_reset = 1;
  } else {

  }
#line 7862
  adapter->flags = adapter->flags & 4294705151U;
#line 7863
  adapter->flags = adapter->flags | 524288U;
#line 7864
  goto ldv_59265;
  default: ;
#line 7867
  if ((adapter->flags & 524288U) != 0U) {
#line 7868
    need_reset = 1;
  } else {

  }
#line 7870
  adapter->flags = adapter->flags & 4294443007U;
#line 7873
  if ((adapter->flags & 8388608U) != 0U) {
#line 7874
    goto ldv_59265;
  } else {

  }
#line 7877
  tmp___0 = netdev_get_num_tc(netdev);
#line 7877
  if (tmp___0 > 1) {
#line 7878
    goto ldv_59265;
  } else {

  }
#line 7881
  if ((unsigned int )adapter->ring_feature[2].limit <= 1U) {
#line 7882
    goto ldv_59265;
  } else {

  }
#line 7885
  if (adapter->atr_sample_rate == 0U) {
#line 7886
    goto ldv_59265;
  } else {

  }
#line 7888
  adapter->flags = adapter->flags | 262144U;
#line 7889
  goto ldv_59265;
  }
  ldv_59265: ;
#line 7892
  if ((features & 256ULL) != 0ULL) {
#line 7893
    ixgbe_vlan_strip_enable(adapter);
  } else {
#line 7895
    ixgbe_vlan_strip_disable(adapter);
  }
#line 7897
  if ((changed & 274877906944ULL) != 0ULL) {
#line 7898
    need_reset = 1;
  } else {

  }
#line 7900
  netdev->features = features;
#line 7901
  if ((int )need_reset) {
#line 7902
    ixgbe_do_reset(netdev);
  } else {

  }
#line 7904
  return (0);
}
}
#line 7913 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_add_vxlan_port(struct net_device *dev , sa_family_t sa_family ,
                                 __be16 port ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u16 new_port ;
  __u16 tmp___0 ;

  {
#line 7916
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 7916
  adapter = (struct ixgbe_adapter *)tmp;
#line 7917
  hw = & adapter->hw;
#line 7918
  tmp___0 = __fswab16((int )port);
#line 7918
  new_port = tmp___0;
#line 7920
  if ((unsigned int )sa_family == 10U) {
#line 7921
    return;
  } else {

  }
#line 7923
  if ((int )adapter->vxlan_port == (int )new_port) {
#line 7924
    netdev_info((struct net_device  const  *)dev, "Port %d already offloaded\n", (int )new_port);
#line 7925
    return;
  } else {

  }
#line 7928
  if ((unsigned int )adapter->vxlan_port != 0U) {
#line 7929
    netdev_info((struct net_device  const  *)dev, "Hit Max num of UDP ports, not adding port %d\n",
                (int )new_port);
#line 7932
    return;
  } else {

  }
#line 7935
  adapter->vxlan_port = new_port;
#line 7936
  ixgbe_write_reg(hw, 20604U, (u32 )new_port);
#line 7937
  return;
}
}
#line 7945 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_del_vxlan_port(struct net_device *dev , sa_family_t sa_family ,
                                 __be16 port ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u16 new_port ;
  __u16 tmp___0 ;

  {
#line 7948
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 7948
  adapter = (struct ixgbe_adapter *)tmp;
#line 7949
  hw = & adapter->hw;
#line 7950
  tmp___0 = __fswab16((int )port);
#line 7950
  new_port = tmp___0;
#line 7952
  if ((unsigned int )sa_family == 10U) {
#line 7953
    return;
  } else {

  }
#line 7955
  if ((int )adapter->vxlan_port != (int )new_port) {
#line 7956
    netdev_info((struct net_device  const  *)dev, "Port %d was not found, not deleting\n",
                (int )new_port);
#line 7958
    return;
  } else {

  }
#line 7961
  adapter->vxlan_port = 0U;
#line 7962
  ixgbe_write_reg(hw, 20604U, 0U);
#line 7963
  return;
}
}
#line 7965 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_ndo_fdb_add(struct ndmsg *ndm , struct nlattr **tb , struct net_device *dev ,
                             unsigned char const   *addr , u16 vid , u16 flags ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 7971
  tmp = is_unicast_ether_addr(addr);
#line 7971
  if ((int )tmp) {
#line 7971
    goto _L;
  } else {
#line 7971
    tmp___0 = is_link_local_ether_addr(addr);
#line 7971
    if ((int )tmp___0) {
      _L: /* CIL Label */ 
#line 7972
      if (dev->uc.count > 14) {
#line 7973
        return (-12);
      } else {

      }
    } else {

    }
  }
#line 7976
  tmp___1 = ndo_dflt_fdb_add(ndm, tb, dev, addr, (int )vid, (int )flags);
#line 7976
  return (tmp___1);
}
}
#line 7986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_configure_bridge_mode(struct ixgbe_adapter *adapter , __u16 mode ) 
{ 
  struct ixgbe_hw *hw ;
  unsigned int p ;
  unsigned int num_pools ;
  u32 vmdctl ;

  {
#line 7989
  hw = & adapter->hw;
#line 7993
  switch ((int )mode) {
  case 1: 
#line 7996
  ixgbe_write_reg(& adapter->hw, 33312U, 0U);
#line 8002
  vmdctl = ixgbe_read_reg(hw, 22556U);
#line 8003
  vmdctl = vmdctl | 1073741824U;
#line 8004
  ixgbe_write_reg(hw, 22556U, vmdctl);
#line 8009
  num_pools = adapter->num_vfs + (unsigned int )adapter->num_rx_pools;
#line 8010
  p = 0U;
#line 8010
  goto ldv_59301;
  ldv_59300: ;
#line 8011
  if ((unsigned long )hw->mac.ops.set_source_address_pruning != (unsigned long )((void (*)(struct ixgbe_hw * ,
                                                                                           bool  ,
                                                                                           unsigned int  ))0)) {
#line 8012
    (*(hw->mac.ops.set_source_address_pruning))(hw, 1, p);
  } else {

  }
#line 8010
  p = p + 1U;
  ldv_59301: ;
#line 8010
  if (p < num_pools) {
#line 8012
    goto ldv_59300;
  } else {

  }

#line 8016
  goto ldv_59303;
  case 0: 
#line 8019
  ixgbe_write_reg(& adapter->hw, 33312U, 1U);
#line 8025
  vmdctl = ixgbe_read_reg(hw, 22556U);
#line 8026
  if (adapter->num_vfs == 0U) {
#line 8027
    vmdctl = vmdctl & 3221225471U;
  } else {

  }
#line 8028
  ixgbe_write_reg(hw, 22556U, vmdctl);
#line 8033
  num_pools = adapter->num_vfs + (unsigned int )adapter->num_rx_pools;
#line 8034
  p = 0U;
#line 8034
  goto ldv_59306;
  ldv_59305: ;
#line 8035
  if ((unsigned long )hw->mac.ops.set_source_address_pruning != (unsigned long )((void (*)(struct ixgbe_hw * ,
                                                                                           bool  ,
                                                                                           unsigned int  ))0)) {
#line 8036
    (*(hw->mac.ops.set_source_address_pruning))(hw, 0, p);
  } else {

  }
#line 8034
  p = p + 1U;
  ldv_59306: ;
#line 8034
  if (p < num_pools) {
#line 8036
    goto ldv_59305;
  } else {

  }

#line 8040
  goto ldv_59303;
  default: ;
#line 8042
  return (-22);
  }
  ldv_59303: 
#line 8045
  adapter->bridge_mode = mode;
#line 8047
  if ((int )adapter->msg_enable & 1) {
#line 8048
    netdev_info((struct net_device  const  *)adapter->netdev, "enabling bridge mode: %s\n",
                (unsigned int )mode == 1U ? (char *)"VEPA" : (char *)"VEB");
  } else {

  }
#line 8050
  return (0);
}
}
#line 8053 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_ndo_bridge_setlink(struct net_device *dev , struct nlmsghdr *nlh ,
                                    u16 flags ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct nlattr *attr ;
  struct nlattr *br_spec ;
  int rem ;
  void *tmp___0 ;
  int status ;
  __u16 mode ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 8056
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 8056
  adapter = (struct ixgbe_adapter *)tmp;
#line 8060
  if ((adapter->flags & 8388608U) == 0U) {
#line 8061
    return (-95);
  } else {

  }
#line 8063
  br_spec = nlmsg_find_attr((struct nlmsghdr  const  *)nlh, 16, 26);
#line 8064
  if ((unsigned long )br_spec == (unsigned long )((struct nlattr *)0)) {
#line 8065
    return (-22);
  } else {

  }
#line 8067
  tmp___0 = nla_data((struct nlattr  const  *)br_spec);
#line 8067
  attr = (struct nlattr *)tmp___0;
#line 8067
  rem = nla_len((struct nlattr  const  *)br_spec);
#line 8067
  goto ldv_59323;
  ldv_59322: 
#line 8071
  tmp___1 = nla_type((struct nlattr  const  *)attr);
#line 8071
  if (tmp___1 != 1) {
#line 8072
    goto ldv_59320;
  } else {

  }
#line 8074
  tmp___2 = nla_len((struct nlattr  const  *)attr);
#line 8074
  if ((unsigned int )tmp___2 <= 1U) {
#line 8075
    return (-22);
  } else {

  }
#line 8077
  mode = nla_get_u16((struct nlattr  const  *)attr);
#line 8078
  status = ixgbe_configure_bridge_mode(adapter, (int )mode);
#line 8079
  if (status != 0) {
#line 8080
    return (status);
  } else {

  }
#line 8082
  goto ldv_59321;
  ldv_59320: 
#line 8067
  attr = nla_next((struct nlattr  const  *)attr, & rem);
  ldv_59323: 
#line 8067
  tmp___3 = nla_ok((struct nlattr  const  *)attr, rem);
#line 8067
  if (tmp___3 != 0) {
#line 8069
    goto ldv_59322;
  } else {

  }
  ldv_59321: ;
#line 8085
  return (0);
}
}
#line 8088 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_ndo_bridge_getlink(struct sk_buff *skb , u32 pid , u32 seq , struct net_device *dev ,
                                    u32 filter_mask , int nlflags ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;

  {
#line 8092
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 8092
  adapter = (struct ixgbe_adapter *)tmp;
#line 8094
  if ((adapter->flags & 8388608U) == 0U) {
#line 8095
    return (0);
  } else {

  }
#line 8097
  tmp___0 = ndo_dflt_bridge_getlink(skb, pid, seq, dev, (int )adapter->bridge_mode,
                                    0U, 0U, nlflags, filter_mask, (int (*)(struct sk_buff * ,
                                                                           struct net_device * ,
                                                                           u32  ))0);
#line 8097
  return (tmp___0);
}
}
#line 8102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void *ixgbe_fwd_add(struct net_device *pdev , struct net_device *vdev ) 
{ 
  struct ixgbe_fwd_adapter *fwd_adapter ;
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int used_pools ;
  unsigned int limit ;
  int pool ;
  int err ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;

  {
#line 8104
  fwd_adapter = (struct ixgbe_fwd_adapter *)0;
#line 8105
  tmp = netdev_priv((struct net_device  const  *)pdev);
#line 8105
  adapter = (struct ixgbe_adapter *)tmp;
#line 8106
  used_pools = (int )(adapter->num_vfs + (unsigned int )adapter->num_rx_pools);
#line 8114
  if (used_pools > 63) {
#line 8115
    tmp___0 = ERR_PTR(-22L);
#line 8115
    return (tmp___0);
  } else {

  }
#line 8118
  if (vdev->num_rx_queues != vdev->num_tx_queues) {
#line 8119
    netdev_info((struct net_device  const  *)pdev, "%s: Only supports a single queue count for TX and RX\n",
                (char *)(& vdev->name));
#line 8121
    tmp___1 = ERR_PTR(-22L);
#line 8121
    return (tmp___1);
  } else {

  }
#line 8125
  if (vdev->num_tx_queues > 4U || vdev->num_tx_queues == 3U) {
#line 8127
    netdev_info((struct net_device  const  *)pdev, "%s: Supports RX/TX Queue counts 1,2, and 4\n",
                (char *)(& pdev->name));
#line 8130
    tmp___2 = ERR_PTR(-22L);
#line 8130
    return (tmp___2);
  } else {

  }
#line 8133
  if (((adapter->flags & 4096U) != 0U && adapter->num_rx_pools > 7) || adapter->num_rx_pools > 31) {
#line 8136
    tmp___3 = ERR_PTR(-16L);
#line 8136
    return (tmp___3);
  } else {

  }
#line 8138
  tmp___4 = kcalloc(1UL, 544UL, 208U);
#line 8138
  fwd_adapter = (struct ixgbe_fwd_adapter *)tmp___4;
#line 8139
  if ((unsigned long )fwd_adapter == (unsigned long )((struct ixgbe_fwd_adapter *)0)) {
#line 8140
    tmp___5 = ERR_PTR(-12L);
#line 8140
    return (tmp___5);
  } else {

  }
#line 8142
  tmp___6 = find_first_zero_bit((unsigned long const   *)(& adapter->fwd_bitmask),
                                32UL);
#line 8142
  pool = (int )tmp___6;
#line 8143
  adapter->num_rx_pools = adapter->num_rx_pools + 1;
#line 8144
  set_bit((long )pool, (unsigned long volatile   *)(& adapter->fwd_bitmask));
#line 8145
  tmp___7 = find_last_bit((unsigned long const   *)(& adapter->fwd_bitmask), 32UL);
#line 8145
  limit = (unsigned int )tmp___7;
#line 8148
  adapter->flags = adapter->flags | 8404992U;
#line 8149
  adapter->ring_feature[1].limit = (unsigned int )((u16 )limit) + 1U;
#line 8150
  adapter->ring_feature[2].limit = (u16 )vdev->num_tx_queues;
#line 8153
  tmp___8 = netdev_get_num_tc(pdev);
#line 8153
  err = ixgbe_setup_tc(pdev, (int )((u8 )tmp___8));
#line 8154
  if (err != 0) {
#line 8155
    goto fwd_add_err;
  } else {

  }
#line 8156
  fwd_adapter->pool = pool;
#line 8157
  fwd_adapter->real_adapter = adapter;
#line 8158
  err = ixgbe_fwd_ring_up(vdev, fwd_adapter);
#line 8159
  if (err != 0) {
#line 8160
    goto fwd_add_err;
  } else {

  }
#line 8161
  netif_tx_start_all_queues(vdev);
#line 8162
  return ((void *)fwd_adapter);
  fwd_add_err: 
#line 8165
  netdev_info((struct net_device  const  *)pdev, "%s: dfwd hardware acceleration failed\n",
              (char *)(& vdev->name));
#line 8167
  clear_bit((long )pool, (unsigned long volatile   *)(& adapter->fwd_bitmask));
#line 8168
  adapter->num_rx_pools = adapter->num_rx_pools - 1;
#line 8169
  kfree((void const   *)fwd_adapter);
#line 8170
  tmp___9 = ERR_PTR((long )err);
#line 8170
  return (tmp___9);
}
}
#line 8173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_fwd_del(struct net_device *pdev , void *priv ) 
{ 
  struct ixgbe_fwd_adapter *fwd_adapter ;
  struct ixgbe_adapter *adapter ;
  unsigned int limit ;
  unsigned long tmp ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
#line 8175
  fwd_adapter = (struct ixgbe_fwd_adapter *)priv;
#line 8176
  adapter = fwd_adapter->real_adapter;
#line 8179
  clear_bit((long )fwd_adapter->pool, (unsigned long volatile   *)(& adapter->fwd_bitmask));
#line 8180
  adapter->num_rx_pools = adapter->num_rx_pools - 1;
#line 8182
  tmp = find_last_bit((unsigned long const   *)(& adapter->fwd_bitmask), 32UL);
#line 8182
  limit = (unsigned int )tmp;
#line 8183
  adapter->ring_feature[1].limit = (unsigned int )((u16 )limit) + 1U;
#line 8184
  ixgbe_fwd_ring_down(fwd_adapter->netdev, fwd_adapter);
#line 8185
  tmp___0 = netdev_get_num_tc(pdev);
#line 8185
  ixgbe_setup_tc(pdev, (int )((u8 )tmp___0));
#line 8186
  descriptor.modname = "ixgbe";
#line 8186
  descriptor.function = "ixgbe_fwd_del";
#line 8186
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c";
#line 8186
  descriptor.format = "pool %i:%i queues %i:%i VSI bitmask %lx\n";
#line 8186
  descriptor.lineno = 8190U;
#line 8186
  descriptor.flags = 0U;
#line 8186
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 8186
  if (tmp___1 != 0L) {
#line 8186
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)pdev, "pool %i:%i queues %i:%i VSI bitmask %lx\n",
                         fwd_adapter->pool, adapter->num_rx_pools, fwd_adapter->rx_base_queue,
                         fwd_adapter->rx_base_queue + (unsigned int )adapter->num_rx_queues_per_pool,
                         adapter->fwd_bitmask);
  } else {

  }
#line 8191
  kfree((void const   *)fwd_adapter);
#line 8192
  return;
}
}
#line 8194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct net_device_ops  const  ixgbe_netdev_ops  = 
#line 8194
     {0, 0, & ixgbe_open, & ixgbe_close, & ixgbe_xmit_frame, & ixgbe_select_queue, 0,
    & ixgbe_set_rx_mode, & ixgbe_set_mac, & eth_validate_addr, & ixgbe_ioctl, 0, & ixgbe_change_mtu,
    0, & ixgbe_tx_timeout, & ixgbe_get_stats64, 0, & ixgbe_vlan_rx_add_vid, & ixgbe_vlan_rx_kill_vid,
    & ixgbe_netpoll, 0, 0, & ixgbe_low_latency_recv, & ixgbe_ndo_set_vf_mac, & ixgbe_ndo_set_vf_vlan,
    & ixgbe_ndo_set_vf_bw, & ixgbe_ndo_set_vf_spoofchk, & ixgbe_ndo_get_vf_config,
    0, 0, 0, 0, & ixgbe_ndo_set_vf_rss_query_en, & ixgbe_setup_tc, & ixgbe_fcoe_enable,
    & ixgbe_fcoe_disable, & ixgbe_fcoe_ddp_get, & ixgbe_fcoe_ddp_put, & ixgbe_fcoe_ddp_target,
    & ixgbe_fcoe_get_hbainfo, & ixgbe_fcoe_get_wwn, 0, 0, 0, & ixgbe_fix_features,
    & ixgbe_set_features, 0, 0, & ixgbe_ndo_fdb_add, 0, 0, & ixgbe_ndo_bridge_setlink,
    & ixgbe_ndo_bridge_getlink, 0, 0, 0, 0, & ixgbe_add_vxlan_port, & ixgbe_del_vxlan_port,
    & ixgbe_fwd_add, & ixgbe_fwd_del, 0, 0, 0, 0, 0};
#line 8252 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static int ixgbe_enumerate_functions(struct ixgbe_adapter *adapter ) 
{ 
  struct pci_dev *entry ;
  struct pci_dev *pdev ;
  int physfns ;
  bool tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 8254
  pdev = adapter->pdev;
#line 8255
  physfns = 0;
#line 8261
  tmp = ixgbe_pcie_from_parent(& adapter->hw);
#line 8261
  if ((int )tmp) {
#line 8262
    physfns = 4;
  } else {

  }
#line 8264
  __mptr = (struct list_head  const  *)((adapter->pdev)->bus)->devices.next;
#line 8264
  entry = (struct pci_dev *)__mptr;
#line 8264
  goto ldv_59366;
  ldv_59365: ;
#line 8266
  if ((unsigned int )*((unsigned char *)entry + 2531UL) != 0U) {
#line 8267
    goto ldv_59364;
  } else {

  }
#line 8275
  if ((int )entry->vendor != (int )pdev->vendor || (int )entry->device != (int )pdev->device) {
#line 8277
    return (-1);
  } else {

  }
#line 8279
  physfns = physfns + 1;
  ldv_59364: 
#line 8264
  __mptr___0 = (struct list_head  const  *)entry->bus_list.next;
#line 8264
  entry = (struct pci_dev *)__mptr___0;
  ldv_59366: ;
#line 8264
  if ((unsigned long )(& entry->bus_list) != (unsigned long )(& ((adapter->pdev)->bus)->devices)) {
#line 8266
    goto ldv_59365;
  } else {

  }

#line 8282
  return (physfns);
}
}
#line 8295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_wol_supported(struct ixgbe_adapter *adapter , u16 device_id , u16 subdevice_id ) 
{ 
  struct ixgbe_hw *hw ;
  u16 wol_cap ;
  int is_wol_supported ;

  {
#line 8298
  hw = & adapter->hw;
#line 8299
  wol_cap = (unsigned int )adapter->eeprom_cap & 12U;
#line 8300
  is_wol_supported = 0;
#line 8302
  switch ((int )device_id) {
  case 4347: ;
#line 8305
  switch ((int )subdevice_id) {
  case 4209: ;
  case 6096: ;
#line 8309
  if ((unsigned int )hw->bus.func != 0U) {
#line 8310
    goto ldv_59379;
  } else {

  }
  case 8475: ;
  case 4521: ;
  case 8050: ;
  case 1136: ;
  case 35190: 
#line 8316
  is_wol_supported = 1;
#line 8317
  goto ldv_59379;
  }
  ldv_59379: ;
#line 8319
  goto ldv_59385;
  case 5463: ;
#line 8322
  switch ((int )subdevice_id) {
  case 1: 
#line 8324
  is_wol_supported = 1;
#line 8325
  goto ldv_59388;
  }
  ldv_59388: ;
#line 8327
  goto ldv_59385;
  case 4344: ;
#line 8330
  if ((unsigned int )subdevice_id != 12U) {
#line 8331
    is_wol_supported = 1;
  } else {

  }
#line 8332
  goto ldv_59385;
  case 4343: 
#line 8334
  is_wol_supported = 1;
#line 8335
  goto ldv_59385;
  case 5416: ;
  case 5472: ;
  case 5475: ;
  case 5546: ;
  case 5547: ;
  case 5549: ;
#line 8343
  if ((unsigned int )wol_cap == 4U || ((unsigned int )wol_cap == 8U && (unsigned int )hw->bus.func == 0U)) {
#line 8346
    is_wol_supported = 1;
  } else {

  }
#line 8348
  goto ldv_59385;
  }
  ldv_59385: ;
#line 8351
  return (is_wol_supported);
}
}
#line 8358 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_get_platform_mac_addr(struct ixgbe_adapter *adapter ) 
{ 
  struct device_node *dp ;
  struct device_node *tmp ;
  struct ixgbe_hw *hw ;
  unsigned char const   *addr ;
  void const   *tmp___0 ;

  {
#line 8361
  tmp = pci_device_to_OF_node((struct pci_dev  const  *)adapter->pdev);
#line 8361
  dp = tmp;
#line 8362
  hw = & adapter->hw;
#line 8365
  tmp___0 = of_get_mac_address(dp);
#line 8365
  addr = (unsigned char const   *)tmp___0;
#line 8366
  if ((unsigned long )addr != (unsigned long )((unsigned char const   *)0U)) {
#line 8367
    ether_addr_copy((u8 *)(& hw->mac.perm_addr), addr);
#line 8368
    return;
  } else {

  }
#line 8370
  return;
}
}
#line 8388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_probe(struct pci_dev *pdev , struct pci_device_id  const  *ent ) 
{ 
  struct net_device *netdev ;
  struct ixgbe_adapter *adapter ;
  struct ixgbe_hw *hw ;
  struct ixgbe_info  const  *ii ;
  int i ;
  int err ;
  int pci_using_dac ;
  int expected_gts ;
  unsigned int indices ;
  u8 part_str[11U] ;
  bool disable_dev ;
  u16 device_caps ;
  u32 eec ;
  int __ret_warn_on ;
  char const   *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  u32 tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  bool tmp___7 ;
  u32 esdp ;
  u32 tmp___8 ;
  unsigned int fcoe_l ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp___9 ;
  s32 tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  int tmp___14 ;
  bool tmp___15 ;
  int _min1 ;
  int tmp___16 ;
  int _min2 ;
  int tmp___17 ;
  bool tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  bool tmp___21 ;
  bool tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
#line 8391
  adapter = (struct ixgbe_adapter *)0;
#line 8393
  ii = ixgbe_info_tbl[ent->driver_data];
#line 8395
  indices = 64U;
#line 8397
  disable_dev = 0;
#line 8406
  if ((unsigned int )*((unsigned char *)pdev + 2531UL) != 0U) {
#line 8407
    __ret_warn_on = 1;
#line 8407
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 8407
    if (tmp___0 != 0L) {
#line 8407
      tmp = pci_name((struct pci_dev  const  *)pdev);
#line 8407
      warn_slowpath_fmt("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c",
                        8408, "\v%s (%hx:%hx) should not be a VF!\n", tmp, (int )pdev->vendor,
                        (int )pdev->device);
    } else {

    }
#line 8407
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 8409
    return (-22);
  } else {

  }
#line 8412
  err = pci_enable_device_mem(pdev);
#line 8413
  if (err != 0) {
#line 8414
    return (err);
  } else {

  }
#line 8416
  tmp___1 = dma_set_mask_and_coherent(& pdev->dev, 0xffffffffffffffffULL);
#line 8416
  if (tmp___1 == 0) {
#line 8417
    pci_using_dac = 1;
  } else {
#line 8419
    err = dma_set_mask_and_coherent(& pdev->dev, 4294967295ULL);
#line 8420
    if (err != 0) {
#line 8421
      dev_err((struct device  const  *)(& pdev->dev), "No usable DMA configuration, aborting\n");
#line 8423
      goto err_dma;
    } else {

    }
#line 8425
    pci_using_dac = 0;
  }
#line 8428
  tmp___2 = pci_select_bars(pdev, 512UL);
#line 8428
  err = pci_request_selected_regions(pdev, tmp___2, (char const   *)(& ixgbe_driver_name));
#line 8430
  if (err != 0) {
#line 8431
    dev_err((struct device  const  *)(& pdev->dev), "pci_request_selected_regions failed 0x%x\n",
            err);
#line 8433
    goto err_pci_reg;
  } else {

  }
#line 8436
  pci_enable_pcie_error_reporting(pdev);
#line 8438
  pci_set_master(pdev);
#line 8439
  pci_save_state(pdev);
#line 8441
  if ((unsigned int )ii->mac == 1U) {
#line 8444
    indices = 32U;
  } else {

  }
#line 8450
  netdev = alloc_etherdev_mqs(143360, indices, indices);
#line 8451
  if ((unsigned long )netdev == (unsigned long )((struct net_device *)0)) {
#line 8452
    err = -12;
#line 8453
    goto err_alloc_etherdev;
  } else {

  }
#line 8456
  netdev->dev.parent = & pdev->dev;
#line 8458
  tmp___3 = netdev_priv((struct net_device  const  *)netdev);
#line 8458
  adapter = (struct ixgbe_adapter *)tmp___3;
#line 8460
  adapter->netdev = netdev;
#line 8461
  adapter->pdev = pdev;
#line 8462
  hw = & adapter->hw;
#line 8463
  hw->back = (void *)adapter;
#line 8464
  tmp___4 = netif_msg_init(debug, 7);
#line 8464
  adapter->msg_enable = (u16 )tmp___4;
#line 8466
  tmp___5 = ioremap(pdev->resource[0].start, pdev->resource[0].start != 0ULL || pdev->resource[0].end != pdev->resource[0].start ? (unsigned long )((pdev->resource[0].end - pdev->resource[0].start) + 1ULL) : 0UL);
#line 8466
  hw->hw_addr = (u8 *)tmp___5;
#line 8468
  adapter->io_addr = hw->hw_addr;
#line 8469
  if ((unsigned long )hw->hw_addr == (unsigned long )((u8 *)0U)) {
#line 8470
    err = -5;
#line 8471
    goto err_ioremap;
  } else {

  }
#line 8474
  netdev->netdev_ops = & ixgbe_netdev_ops;
#line 8475
  ixgbe_set_ethtool_ops(netdev);
#line 8476
  netdev->watchdog_timeo = 1250;
#line 8477
  tmp___6 = pci_name((struct pci_dev  const  *)pdev);
#line 8477
  strlcpy((char *)(& netdev->name), tmp___6, 16UL);
#line 8480
  memcpy((void *)(& hw->mac.ops), (void const   *)ii->mac_ops, 472UL);
#line 8481
  hw->mac.type = ii->mac;
#line 8482
  hw->mvals = ii->mvals;
#line 8485
  memcpy((void *)(& hw->eeprom.ops), (void const   *)ii->eeprom_ops, 64UL);
#line 8486
  eec = ixgbe_read_reg(hw, *(hw->mvals));
#line 8487
  tmp___7 = ixgbe_removed((void *)hw->hw_addr);
#line 8487
  if ((int )tmp___7) {
#line 8488
    err = -5;
#line 8489
    goto err_ioremap;
  } else {

  }
#line 8492
  if ((eec & 256U) == 0U) {
#line 8493
    hw->eeprom.ops.read = & ixgbe_read_eeprom_bit_bang_generic;
  } else {

  }
#line 8496
  memcpy((void *)(& hw->phy.ops), (void const   *)ii->phy_ops, 184UL);
#line 8497
  hw->phy.sfp_type = 65535;
#line 8499
  hw->phy.mdio.prtad = -1;
#line 8500
  hw->phy.mdio.mmds = 0U;
#line 8501
  hw->phy.mdio.mode_support = 6U;
#line 8502
  hw->phy.mdio.dev = netdev;
#line 8503
  hw->phy.mdio.mdio_read = & ixgbe_mdio_read;
#line 8504
  hw->phy.mdio.mdio_write = & ixgbe_mdio_write;
#line 8506
  (*(ii->get_invariants))(hw);
#line 8509
  err = ixgbe_sw_init(adapter);
#line 8510
  if (err != 0) {
#line 8511
    goto err_sw_init;
  } else {

  }
#line 8514
  switch ((unsigned int )adapter->hw.mac.type) {
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 8519
  ixgbe_write_reg(& adapter->hw, 22544U, 4294967295U);
#line 8520
  goto ldv_59431;
  default: ;
#line 8522
  goto ldv_59431;
  }
  ldv_59431: ;
#line 8529
  if ((adapter->flags & 32768U) != 0U) {
#line 8530
    tmp___8 = ixgbe_read_reg(hw, 32U);
#line 8530
    esdp = tmp___8;
#line 8531
    if ((esdp & 2U) != 0U) {
#line 8532
      if (((int )adapter->msg_enable & 2) != 0) {
#line 8532
        netdev_crit((struct net_device  const  *)adapter->netdev, "Fan has stopped, replace the adapter\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 8535
  if (allow_unsupported_sfp != 0U) {
#line 8536
    hw->allow_unsupported_sfp = allow_unsupported_sfp != 0U;
  } else {

  }
#line 8539
  hw->phy.reset_if_overtemp = 1;
#line 8540
  err = (*(hw->mac.ops.reset_hw))(hw);
#line 8541
  hw->phy.reset_if_overtemp = 0;
#line 8542
  if (err == -20 && (unsigned int )hw->mac.type == 1U) {
#line 8544
    err = 0;
  } else
#line 8545
  if (err == -19) {
#line 8546
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "failed to load because an unsupported SFP+ or QSFP module type was detected.\n");
#line 8547
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Reload the driver after installing a supported module.\n");
#line 8548
    goto err_sw_init;
  } else
#line 8549
  if (err != 0) {
#line 8550
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "HW Init failed: %d\n",
            err);
#line 8551
    goto err_sw_init;
  } else {

  }
#line 8556
  if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 8557
    goto skip_sriov;
  } else {

  }
#line 8559
  ixgbe_init_mbx_params_pf(hw);
#line 8560
  memcpy((void *)(& hw->mbx.ops), (void const   *)ii->mbx_ops, 64UL);
#line 8561
  pci_sriov_set_totalvfs(pdev, 63);
#line 8562
  ixgbe_enable_sriov(adapter);
  skip_sriov: 
#line 8566
  netdev->features = 25770918291ULL;
#line 8576
  netdev->hw_features = netdev->features | 4398046511104ULL;
#line 8578
  switch ((unsigned int )adapter->hw.mac.type) {
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 8583
  netdev->features = netdev->features | 1073741824ULL;
#line 8584
  netdev->hw_features = netdev->hw_features | 5368709120ULL;
#line 8586
  goto ldv_59439;
  default: ;
#line 8588
  goto ldv_59439;
  }
  ldv_59439: 
#line 8591
  netdev->hw_features = netdev->hw_features | 274877906944ULL;
#line 8592
  netdev->features = netdev->features | 512ULL;
#line 8594
  netdev->vlan_features = netdev->vlan_features | 65536ULL;
#line 8595
  netdev->vlan_features = netdev->vlan_features | 1048576ULL;
#line 8596
  netdev->vlan_features = netdev->vlan_features | 2ULL;
#line 8597
  netdev->vlan_features = netdev->vlan_features | 16ULL;
#line 8598
  netdev->vlan_features = netdev->vlan_features | 1ULL;
#line 8600
  netdev->priv_flags = netdev->priv_flags | 131072U;
#line 8601
  netdev->priv_flags = netdev->priv_flags | 524288U;
#line 8603
  switch ((unsigned int )adapter->hw.mac.type) {
  case 4U: ;
  case 5U: 
#line 8606
  netdev->hw_enc_features = netdev->hw_enc_features | 17179869184ULL;
#line 8607
  goto ldv_59443;
  default: ;
#line 8609
  goto ldv_59443;
  }
  ldv_59443: 
#line 8613
  netdev->dcbnl_ops = & dcbnl_ops;
#line 8617
  if ((adapter->flags & 1048576U) != 0U) {
#line 8620
    if ((unsigned long )hw->mac.ops.get_device_caps != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                                 u16 * ))0)) {
#line 8621
      (*(hw->mac.ops.get_device_caps))(hw, & device_caps);
#line 8622
      if (((int )device_caps & 2) != 0) {
#line 8623
        adapter->flags = adapter->flags & 4293918719U;
      } else {

      }
    } else {

    }
#line 8627
    __min1 = 8;
#line 8627
    tmp___9 = cpumask_weight(cpu_online_mask);
#line 8627
    __min2 = (int )tmp___9;
#line 8627
    fcoe_l = (unsigned int )(__min1 < __min2 ? __min1 : __min2);
#line 8628
    adapter->ring_feature[4].limit = (u16 )fcoe_l;
#line 8630
    netdev->features = netdev->features | 538968064ULL;
#line 8633
    netdev->vlan_features = netdev->vlan_features | 2686451712ULL;
  } else {

  }
#line 8638
  if (pci_using_dac != 0) {
#line 8639
    netdev->features = netdev->features | 32ULL;
#line 8640
    netdev->vlan_features = netdev->vlan_features | 32ULL;
  } else {

  }
#line 8643
  if ((int )adapter->flags2 & 1) {
#line 8644
    netdev->hw_features = netdev->hw_features | 32768ULL;
  } else {

  }
#line 8645
  if ((adapter->flags2 & 2U) != 0U) {
#line 8646
    netdev->features = netdev->features | 32768ULL;
  } else {

  }
#line 8649
  tmp___10 = (*(hw->eeprom.ops.validate_checksum))(hw, (u16 *)0U);
#line 8649
  if (tmp___10 < 0) {
#line 8650
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "The EEPROM Checksum Is Not Valid\n");
#line 8651
    err = -5;
#line 8652
    goto err_sw_init;
  } else {

  }
#line 8655
  ixgbe_get_platform_mac_addr(adapter);
#line 8657
  memcpy((void *)netdev->dev_addr, (void const   *)(& hw->mac.perm_addr), (size_t )netdev->addr_len);
#line 8659
  tmp___11 = is_valid_ether_addr((u8 const   *)netdev->dev_addr);
#line 8659
  if (tmp___11) {
#line 8659
    tmp___12 = 0;
  } else {
#line 8659
    tmp___12 = 1;
  }
#line 8659
  if (tmp___12) {
#line 8660
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "invalid MAC address\n");
#line 8661
    err = -5;
#line 8662
    goto err_sw_init;
  } else {

  }
#line 8665
  ixgbe_mac_set_default_filter(adapter, (u8 *)(& hw->mac.perm_addr));
#line 8667
  reg_timer_10(& adapter->service_timer, & ixgbe_service_timer, (unsigned long )adapter);
#line 8670
  tmp___13 = ixgbe_removed((void *)hw->hw_addr);
#line 8670
  if ((int )tmp___13) {
#line 8671
    err = -5;
#line 8672
    goto err_sw_init;
  } else {

  }
#line 8674
  __init_work(& adapter->service_task, 0);
#line 8674
  __constr_expr_0.counter = 137438953408L;
#line 8674
  adapter->service_task.data = __constr_expr_0;
#line 8674
  lockdep_init_map(& adapter->service_task.lockdep_map, "(&adapter->service_task)",
                   & __key, 0);
#line 8674
  INIT_LIST_HEAD(& adapter->service_task.entry);
#line 8674
  adapter->service_task.func = & ixgbe_service_task;
#line 8675
  set_bit(6L, (unsigned long volatile   *)(& adapter->state));
#line 8676
  clear_bit(5L, (unsigned long volatile   *)(& adapter->state));
#line 8678
  err = ixgbe_init_interrupt_scheme(adapter);
#line 8679
  if (err != 0) {
#line 8680
    goto err_sw_init;
  } else {

  }
#line 8683
  adapter->wol = 0U;
#line 8684
  (*(hw->eeprom.ops.read))(hw, 44, & adapter->eeprom_cap);
#line 8685
  tmp___14 = ixgbe_wol_supported(adapter, (int )pdev->device, (int )pdev->subsystem_device);
#line 8685
  hw->wol_enabled = tmp___14 != 0;
#line 8687
  if ((int )hw->wol_enabled) {
#line 8688
    adapter->wol = 2U;
  } else {

  }
#line 8690
  device_set_wakeup_enable(& (adapter->pdev)->dev, adapter->wol != 0U);
#line 8693
  (*(hw->eeprom.ops.read))(hw, 46, & adapter->eeprom_verh);
#line 8694
  (*(hw->eeprom.ops.read))(hw, 45, & adapter->eeprom_verl);
#line 8697
  (*(hw->mac.ops.get_bus_info))(hw);
#line 8698
  tmp___15 = ixgbe_pcie_from_parent(hw);
#line 8698
  if ((int )tmp___15) {
#line 8699
    ixgbe_get_parent_bus_info(adapter);
  } else {

  }
#line 8706
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 8708
  tmp___16 = ixgbe_enumerate_functions(adapter);
#line 8708
  _min1 = tmp___16 * 10;
#line 8708
  _min2 = 16;
#line 8708
  expected_gts = _min1 < _min2 ? _min1 : _min2;
#line 8709
  goto ldv_59455;
  default: 
#line 8711
  tmp___17 = ixgbe_enumerate_functions(adapter);
#line 8711
  expected_gts = tmp___17 * 10;
#line 8712
  goto ldv_59455;
  }
  ldv_59455: ;
#line 8716
  if (expected_gts > 0) {
#line 8717
    ixgbe_check_minimum_link(adapter, expected_gts);
  } else {

  }
#line 8719
  err = ixgbe_read_pba_string_generic(hw, (u8 *)(& part_str), 11U);
#line 8720
  if (err != 0) {
#line 8721
    strlcpy((char *)(& part_str), "Unknown", 11UL);
  } else {

  }
#line 8722
  tmp___18 = ixgbe_is_sfp(hw);
#line 8722
  if ((int )tmp___18 && (unsigned int )hw->phy.sfp_type != 65534U) {
#line 8723
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "MAC: %d, PHY: %d, SFP+: %d, PBA No: %s\n",
              (unsigned int )hw->mac.type, (unsigned int )hw->phy.type, (unsigned int )hw->phy.sfp_type,
              (u8 *)(& part_str));
  } else {
#line 8727
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "MAC: %d, PHY: %d, PBA No: %s\n",
              (unsigned int )hw->mac.type, (unsigned int )hw->phy.type, (u8 *)(& part_str));
  }
#line 8730
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "%pM\n", netdev->dev_addr);
#line 8733
  err = (*(hw->mac.ops.start_hw))(hw);
#line 8734
  if (err == -24) {
#line 8736
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "This device is a pre-production adapter/LOM. Please be aware there may be issues associated with your hardware.  If you are experiencing problems please contact your Intel or hardware representative who provided you with this hardware.\n");
  } else {

  }
#line 8743
  strcpy((char *)(& netdev->name), "eth%d");
#line 8744
  err = ldv_register_netdev_29(netdev);
#line 8745
  if (err != 0) {
#line 8746
    goto err_register;
  } else {

  }
#line 8748
  pci_set_drvdata(pdev, (void *)adapter);
#line 8751
  if ((unsigned long )hw->mac.ops.disable_tx_laser != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
#line 8752
    (*(hw->mac.ops.disable_tx_laser))(hw);
  } else {

  }
#line 8755
  netif_carrier_off(netdev);
#line 8758
  tmp___19 = dca_add_requester(& pdev->dev);
#line 8758
  if (tmp___19 == 0) {
#line 8759
    adapter->flags = adapter->flags | 256U;
#line 8760
    ixgbe_setup_dca(adapter);
  } else {

  }
#line 8763
  if ((adapter->flags & 8388608U) != 0U) {
#line 8764
    if (((int )adapter->msg_enable & 2) != 0) {
#line 8764
      netdev_info((struct net_device  const  *)adapter->netdev, "IOV is enabled with %d VFs\n",
                  adapter->num_vfs);
    } else {

    }
#line 8765
    i = 0;
#line 8765
    goto ldv_59459;
    ldv_59458: 
#line 8766
    ixgbe_vf_configuration(pdev, (unsigned int )(i | 268435456));
#line 8765
    i = i + 1;
    ldv_59459: ;
#line 8765
    if ((unsigned int )i < adapter->num_vfs) {
#line 8767
      goto ldv_59458;
    } else {

    }

  } else {

  }
#line 8772
  if ((unsigned long )hw->mac.ops.set_fw_drv_ver != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                              u8  ,
                                                                              u8  ,
                                                                              u8  ,
                                                                              u8  ))0)) {
#line 8773
    (*(hw->mac.ops.set_fw_drv_ver))(hw, 255, 255, 255, 255);
  } else {

  }
#line 8777
  ixgbe_add_sanmac_netdev(netdev);
#line 8779
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "%s\n", (char *)(& ixgbe_default_device_descr));
#line 8782
  tmp___20 = ixgbe_sysfs_init(adapter);
#line 8782
  if (tmp___20 != 0) {
#line 8783
    if (((int )adapter->msg_enable & 2) != 0) {
#line 8783
      netdev_err((struct net_device  const  *)adapter->netdev, "failed to allocate sysfs resources\n");
    } else {

    }
  } else {

  }
#line 8786
  ixgbe_dbg_adapter_init(adapter);
#line 8789
  tmp___21 = ixgbe_mng_enabled(hw);
#line 8789
  if ((int )tmp___21) {
#line 8789
    tmp___22 = ixgbe_is_sfp(hw);
#line 8789
    if ((int )tmp___22) {
#line 8789
      if ((unsigned long )hw->mac.ops.setup_link != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                              ixgbe_link_speed  ,
                                                                              bool  ))0)) {
#line 8790
        (*(hw->mac.ops.setup_link))(hw, 160U, 1);
      } else {

      }
    } else {

    }
  } else {

  }
#line 8794
  return (0);
  err_register: 
#line 8797
  ixgbe_release_hw_control(adapter);
#line 8798
  ixgbe_clear_interrupt_scheme(adapter);
  err_sw_init: 
#line 8800
  ixgbe_disable_sriov(adapter);
#line 8801
  adapter->flags2 = adapter->flags2 & 4294967279U;
#line 8802
  iounmap((void volatile   *)adapter->io_addr);
#line 8803
  kfree((void const   *)adapter->mac_table);
  err_ioremap: 
#line 8805
  tmp___23 = test_and_set_bit(3L, (unsigned long volatile   *)(& adapter->state));
#line 8805
  disable_dev = tmp___23 == 0;
#line 8806
  ldv_free_netdev_30(netdev);
  err_alloc_etherdev: 
#line 8808
  tmp___24 = pci_select_bars(pdev, 512UL);
#line 8808
  pci_release_selected_regions(pdev, tmp___24);
  err_pci_reg: ;
  err_dma: ;
#line 8812
  if ((unsigned long )adapter == (unsigned long )((struct ixgbe_adapter *)0) || (int )disable_dev) {
#line 8813
    pci_disable_device(pdev);
  } else {

  }
#line 8814
  return (err);
}
}
#line 8826 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_remove(struct pci_dev *pdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool disable_dev ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 8828
  tmp = pci_get_drvdata(pdev);
#line 8828
  adapter = (struct ixgbe_adapter *)tmp;
#line 8833
  if ((unsigned long )adapter == (unsigned long )((struct ixgbe_adapter *)0)) {
#line 8834
    return;
  } else {

  }
#line 8836
  netdev = adapter->netdev;
#line 8837
  ixgbe_dbg_adapter_exit(adapter);
#line 8839
  set_bit(4L, (unsigned long volatile   *)(& adapter->state));
#line 8840
  ldv_cancel_work_sync_31(& adapter->service_task);
#line 8844
  if ((adapter->flags & 256U) != 0U) {
#line 8845
    adapter->flags = adapter->flags & 4294967039U;
#line 8846
    dca_remove_requester(& pdev->dev);
#line 8847
    ixgbe_write_reg(& adapter->hw, 69748U, 1U);
  } else {

  }
#line 8852
  ixgbe_sysfs_exit(adapter);
#line 8856
  ixgbe_del_sanmac_netdev(netdev);
#line 8858
  if ((unsigned int )netdev->reg_state == 1U) {
#line 8859
    ldv_unregister_netdev_32(netdev);
  } else {

  }
#line 8866
  if (max_vfs != 0U) {
#line 8867
    ixgbe_disable_sriov(adapter);
  } else {

  }
#line 8869
  ixgbe_clear_interrupt_scheme(adapter);
#line 8871
  ixgbe_release_hw_control(adapter);
#line 8874
  kfree((void const   *)adapter->ixgbe_ieee_pfc);
#line 8875
  kfree((void const   *)adapter->ixgbe_ieee_ets);
#line 8878
  iounmap((void volatile   *)adapter->io_addr);
#line 8879
  tmp___0 = pci_select_bars(pdev, 512UL);
#line 8879
  pci_release_selected_regions(pdev, tmp___0);
#line 8882
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "complete\n");
#line 8884
  kfree((void const   *)adapter->mac_table);
#line 8885
  tmp___1 = test_and_set_bit(3L, (unsigned long volatile   *)(& adapter->state));
#line 8885
  disable_dev = tmp___1 == 0;
#line 8886
  ldv_free_netdev_33(netdev);
#line 8888
  pci_disable_pcie_error_reporting(pdev);
#line 8890
  if ((int )disable_dev) {
#line 8891
    pci_disable_device(pdev);
  } else {

  }
#line 8892
  return;
}
}
#line 8902 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static pci_ers_result_t ixgbe_io_error_detected(struct pci_dev *pdev , pci_channel_state_t state ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  struct ixgbe_hw *hw ;
  struct pci_dev *bdev ;
  struct pci_dev *vfdev ;
  u32 dw0 ;
  u32 dw1 ;
  u32 dw2 ;
  u32 dw3 ;
  int vf ;
  int pos ;
  u16 req_id ;
  u16 pf_func ;
  int tmp___0 ;
  bool tmp___1 ;
  unsigned int device_id ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;

  {
#line 8905
  tmp = pci_get_drvdata(pdev);
#line 8905
  adapter = (struct ixgbe_adapter *)tmp;
#line 8906
  netdev = adapter->netdev;
#line 8909
  hw = & adapter->hw;
#line 8915
  if ((unsigned int )adapter->hw.mac.type == 1U || adapter->num_vfs == 0U) {
#line 8917
    goto skip_bad_vf_detection;
  } else {

  }
#line 8919
  bdev = (pdev->bus)->self;
#line 8920
  goto ldv_59486;
  ldv_59485: 
#line 8921
  bdev = (bdev->bus)->self;
  ldv_59486: ;
#line 8920
  if ((unsigned long )bdev != (unsigned long )((struct pci_dev *)0)) {
#line 8920
    tmp___0 = pci_pcie_type((struct pci_dev  const  *)bdev);
#line 8920
    if (tmp___0 != 4) {
#line 8922
      goto ldv_59485;
    } else {
#line 8925
      goto ldv_59487;
    }
  } else {

  }
  ldv_59487: ;
#line 8923
  if ((unsigned long )bdev == (unsigned long )((struct pci_dev *)0)) {
#line 8924
    goto skip_bad_vf_detection;
  } else {

  }
#line 8926
  pos = pci_find_ext_capability(bdev, 1);
#line 8927
  if (pos == 0) {
#line 8928
    goto skip_bad_vf_detection;
  } else {

  }
#line 8930
  dw0 = ixgbe_read_pci_cfg_dword(hw, (u32 )(pos + 28));
#line 8931
  dw1 = ixgbe_read_pci_cfg_dword(hw, (u32 )(pos + 32));
#line 8932
  dw2 = ixgbe_read_pci_cfg_dword(hw, (u32 )(pos + 36));
#line 8933
  dw3 = ixgbe_read_pci_cfg_dword(hw, (u32 )(pos + 40));
#line 8934
  tmp___1 = ixgbe_removed((void *)hw->hw_addr);
#line 8934
  if ((int )tmp___1) {
#line 8935
    goto skip_bad_vf_detection;
  } else {

  }
#line 8937
  req_id = (u16 )(dw1 >> 16);
#line 8939
  if (((int )req_id & 128) == 0) {
#line 8940
    goto skip_bad_vf_detection;
  } else {

  }
#line 8942
  pf_func = (unsigned int )req_id & 1U;
#line 8943
  if ((((unsigned int )pf_func ^ pdev->devfn) & 1U) == 0U) {
#line 8946
    vf = ((int )req_id & 127) >> 1;
#line 8947
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "VF %d has caused a PCIe error\n",
            vf);
#line 8948
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "TLP: dw0: %8.8x\tdw1: %8.8x\tdw2: %8.8x\tdw3: %8.8x\n",
            dw0, dw1, dw2, dw3);
#line 8951
    switch ((unsigned int )adapter->hw.mac.type) {
    case 2U: 
#line 8953
    device_id = 4333U;
#line 8954
    goto ldv_59490;
    case 3U: 
#line 8956
    device_id = 5397U;
#line 8957
    goto ldv_59490;
    case 4U: 
#line 8959
    device_id = 5477U;
#line 8960
    goto ldv_59490;
    case 5U: 
#line 8962
    device_id = 5544U;
#line 8963
    goto ldv_59490;
    default: 
#line 8965
    device_id = 0U;
#line 8966
    goto ldv_59490;
    }
    ldv_59490: 
#line 8970
    vfdev = pci_get_device(32902U, device_id, (struct pci_dev *)0);
#line 8971
    goto ldv_59497;
    ldv_59496: ;
#line 8972
    if (vfdev->devfn == ((unsigned int )req_id & 255U)) {
#line 8973
      goto ldv_59495;
    } else {

    }
#line 8974
    vfdev = pci_get_device(32902U, device_id, vfdev);
    ldv_59497: ;
#line 8971
    if ((unsigned long )vfdev != (unsigned long )((struct pci_dev *)0)) {
#line 8973
      goto ldv_59496;
    } else {

    }
    ldv_59495: ;
#line 8982
    if ((unsigned long )vfdev != (unsigned long )((struct pci_dev *)0)) {
#line 8983
      ixgbe_issue_vf_flr(adapter, vfdev);
#line 8985
      pci_dev_put(vfdev);
    } else {

    }
#line 8988
    pci_cleanup_aer_uncorrect_error_status(pdev);
  } else {

  }
#line 8997
  adapter->vferr_refcount = adapter->vferr_refcount + 1U;
#line 8999
  return (5U);
  skip_bad_vf_detection: 
#line 9003
  tmp___2 = constant_test_bit(6L, (unsigned long const volatile   *)(& adapter->state));
#line 9003
  if (tmp___2 == 0) {
#line 9004
    return (4U);
  } else {

  }
#line 9006
  rtnl_lock();
#line 9007
  netif_device_detach(netdev);
#line 9009
  if (state == 3U) {
#line 9010
    rtnl_unlock();
#line 9011
    return (4U);
  } else {

  }
#line 9014
  tmp___3 = netif_running((struct net_device  const  *)netdev);
#line 9014
  if ((int )tmp___3) {
#line 9015
    ixgbe_down(adapter);
  } else {

  }
#line 9017
  tmp___4 = test_and_set_bit(3L, (unsigned long volatile   *)(& adapter->state));
#line 9017
  if (tmp___4 == 0) {
#line 9018
    pci_disable_device(pdev);
  } else {

  }
#line 9019
  rtnl_unlock();
#line 9022
  return (3U);
}
}
#line 9031 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static pci_ers_result_t ixgbe_io_slot_reset(struct pci_dev *pdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  pci_ers_result_t result ;
  int err ;
  int tmp___0 ;

  {
#line 9033
  tmp = pci_get_drvdata(pdev);
#line 9033
  adapter = (struct ixgbe_adapter *)tmp;
#line 9037
  tmp___0 = pci_enable_device_mem(pdev);
#line 9037
  if (tmp___0 != 0) {
#line 9038
    if (((int )adapter->msg_enable & 2) != 0) {
#line 9038
      netdev_err((struct net_device  const  *)adapter->netdev, "Cannot re-enable PCI device after reset.\n");
    } else {

    }
#line 9039
    result = 4U;
  } else {
#line 9041
    __asm__  volatile   ("": : : "memory");
#line 9042
    clear_bit(3L, (unsigned long volatile   *)(& adapter->state));
#line 9043
    adapter->hw.hw_addr = adapter->io_addr;
#line 9044
    pci_set_master(pdev);
#line 9045
    pci_restore_state(pdev);
#line 9046
    pci_save_state(pdev);
#line 9048
    pci_wake_from_d3(pdev, 0);
#line 9050
    ixgbe_reset(adapter);
#line 9051
    ixgbe_write_reg(& adapter->hw, 22544U, 4294967295U);
#line 9052
    result = 5U;
  }
#line 9055
  err = pci_cleanup_aer_uncorrect_error_status(pdev);
#line 9056
  if (err != 0) {
#line 9057
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "pci_cleanup_aer_uncorrect_error_status failed 0x%0x\n",
            err);
  } else {

  }
#line 9062
  return (result);
}
}
#line 9072 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_io_resume(struct pci_dev *pdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;

  {
#line 9074
  tmp = pci_get_drvdata(pdev);
#line 9074
  adapter = (struct ixgbe_adapter *)tmp;
#line 9075
  netdev = adapter->netdev;
#line 9078
  if (adapter->vferr_refcount != 0U) {
#line 9079
    if ((int )adapter->msg_enable & 1) {
#line 9079
      netdev_info((struct net_device  const  *)adapter->netdev, "Resuming after VF err\n");
    } else {

    }
#line 9080
    adapter->vferr_refcount = adapter->vferr_refcount - 1U;
#line 9081
    return;
  } else {

  }
#line 9085
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 9085
  if ((int )tmp___0) {
#line 9086
    ixgbe_up(adapter);
  } else {

  }
#line 9088
  netif_device_attach(netdev);
#line 9089
  return;
}
}
#line 9091 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct pci_error_handlers  const  ixgbe_err_handler  =    {(pci_ers_result_t (*)(struct pci_dev * , enum pci_channel_state  ))(& ixgbe_io_error_detected),
    0, 0, & ixgbe_io_slot_reset, 0, & ixgbe_io_resume};
#line 9097 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct pci_driver ixgbe_driver  = 
#line 9097
     {{0, 0}, (char const   *)(& ixgbe_driver_name), (struct pci_device_id  const  *)(& ixgbe_pci_tbl),
    & ixgbe_probe, & ixgbe_remove, & ixgbe_suspend, 0, 0, & ixgbe_resume, & ixgbe_shutdown,
    & ixgbe_pci_sriov_configure, & ixgbe_err_handler, {0, 0, 0, 0, (_Bool)0, 0, 0,
                                                       0, 0, 0, 0, 0, 0, 0, 0, 0},
    {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}};
#line 9117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_init_module(void) 
{ 
  int ret ;

  {
#line 9120
  printk("\016ixgbe: %s - version %s\n", (char const   *)(& ixgbe_driver_string),
         (char const   *)(& ixgbe_driver_version));
#line 9121
  printk("\016ixgbe: %s\n", (char const   *)(& ixgbe_copyright));
#line 9123
  ixgbe_dbg_init();
#line 9125
  ret = ldv___pci_register_driver_34(& ixgbe_driver, & __this_module, "ixgbe");
#line 9126
  if (ret != 0) {
#line 9127
    ixgbe_dbg_exit();
#line 9128
    return (ret);
  } else {

  }
#line 9132
  dca_register_notify(& dca_notifier);
#line 9135
  return (0);
}
}
#line 9146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_exit_module(void) 
{ 


  {
#line 9149
  dca_unregister_notify(& dca_notifier);
#line 9151
  ldv_pci_unregister_driver_35(& ixgbe_driver);
#line 9153
  ixgbe_dbg_exit();
#line 9154
  return;
}
}
#line 9157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_notify_dca(struct notifier_block *nb , unsigned long event , void *p ) 
{ 
  int ret_val ;

  {
#line 9162
  ret_val = driver_for_each_device(& ixgbe_driver.driver, (struct device *)0, (void *)(& event),
                                   & __ixgbe_notify_dca);
#line 9165
  return (ret_val != 0 ? 32770 : 0);
}
}
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
extern int ldv_resume_early_36(void) ;
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_retval_2  ;
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_retval_5  ;
#line 335
extern int ldv_ndo_uninit_38(void) ;
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_retval_6  ;
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_retval_1  ;
#line 338
extern void ldv_initialize(void) ;
#line 339
extern int ldv_probe_37(void) ;
#line 340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_retval_9  ;
#line 341
extern int ldv_suspend_37(void) ;
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_retval_4  ;
#line 343
extern int ldv_release_37(void) ;
#line 344
extern int ldv_ndo_init_38(void) ;
#line 345
void ldv_check_final_state(void) ;
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_retval_8  ;
#line 347
extern int ldv_suspend_late_36(void) ;
#line 348 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_retval_3  ;
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void activate_suitable_irq_4(int line , void *data ) 
{ 


  {
#line 352
  if (ldv_irq_4_0 == 0) {
#line 353
    ldv_irq_line_4_0 = line;
#line 354
    ldv_irq_data_4_0 = data;
#line 355
    ldv_irq_4_0 = 1;
#line 356
    return;
  } else {

  }
#line 358
  if (ldv_irq_4_1 == 0) {
#line 359
    ldv_irq_line_4_1 = line;
#line 360
    ldv_irq_data_4_1 = data;
#line 361
    ldv_irq_4_1 = 1;
#line 362
    return;
  } else {

  }
#line 364
  if (ldv_irq_4_2 == 0) {
#line 365
    ldv_irq_line_4_2 = line;
#line 366
    ldv_irq_data_4_2 = data;
#line 367
    ldv_irq_4_2 = 1;
#line 368
    return;
  } else {

  }
#line 370
  if (ldv_irq_4_3 == 0) {
#line 371
    ldv_irq_line_4_3 = line;
#line 372
    ldv_irq_data_4_3 = data;
#line 373
    ldv_irq_4_3 = 1;
#line 374
    return;
  } else {

  }
#line 376
  return;
}
}
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_3(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 382
  tmp = __VERIFIER_nondet_int();
#line 382
  irq_retval = (irqreturn_t )tmp;
#line 384
  if (state != 0) {
#line 385
    tmp___0 = __VERIFIER_nondet_int();
#line 385
    switch (tmp___0) {
    case 0: ;
#line 387
    if (state == 1) {
#line 388
      LDV_IN_INTERRUPT = 2;
#line 389
      irq_retval = ixgbe_intr(line, data);
#line 390
      LDV_IN_INTERRUPT = 1;
#line 391
      return (state);
    } else {

    }
#line 394
    goto ldv_59571;
    default: 
#line 395
    ldv_stop();
    }
    ldv_59571: ;
  } else {

  }
#line 398
  return (state);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void disable_suitable_irq_2(int line , void *data ) 
{ 


  {
#line 403
  if (ldv_irq_2_0 != 0 && line == ldv_irq_line_2_0) {
#line 404
    ldv_irq_2_0 = 0;
#line 405
    return;
  } else {

  }
#line 407
  if (ldv_irq_2_1 != 0 && line == ldv_irq_line_2_1) {
#line 408
    ldv_irq_2_1 = 0;
#line 409
    return;
  } else {

  }
#line 411
  if (ldv_irq_2_2 != 0 && line == ldv_irq_line_2_2) {
#line 412
    ldv_irq_2_2 = 0;
#line 413
    return;
  } else {

  }
#line 415
  if (ldv_irq_2_3 != 0 && line == ldv_irq_line_2_3) {
#line 416
    ldv_irq_2_3 = 0;
#line 417
    return;
  } else {

  }
#line 419
  return;
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void activate_suitable_irq_3(int line , void *data ) 
{ 


  {
#line 424
  if (ldv_irq_3_0 == 0) {
#line 425
    ldv_irq_line_3_0 = line;
#line 426
    ldv_irq_data_3_0 = data;
#line 427
    ldv_irq_3_0 = 1;
#line 428
    return;
  } else {

  }
#line 430
  if (ldv_irq_3_1 == 0) {
#line 431
    ldv_irq_line_3_1 = line;
#line 432
    ldv_irq_data_3_1 = data;
#line 433
    ldv_irq_3_1 = 1;
#line 434
    return;
  } else {

  }
#line 436
  if (ldv_irq_3_2 == 0) {
#line 437
    ldv_irq_line_3_2 = line;
#line 438
    ldv_irq_data_3_2 = data;
#line 439
    ldv_irq_3_2 = 1;
#line 440
    return;
  } else {

  }
#line 442
  if (ldv_irq_3_3 == 0) {
#line 443
    ldv_irq_line_3_3 = line;
#line 444
    ldv_irq_data_3_3 = data;
#line 445
    ldv_irq_3_3 = 1;
#line 446
    return;
  } else {

  }
#line 448
  return;
}
}
#line 452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_net_device_ops_38(void) 
{ 
  void *tmp ;

  {
#line 453
  tmp = ldv_init_zalloc(3008UL);
#line 453
  ixgbe_netdev_ops_group1 = (struct net_device *)tmp;
#line 454
  return;
}
}
#line 457 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 458
  if ((unsigned long )handler == (unsigned long )(& ixgbe_msix_clean_rings)) {
#line 459
    return (1);
  } else {

  }
#line 461
  return (0);
}
}
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void choose_interrupt_4(void) 
{ 
  int tmp ;

  {
#line 466
  tmp = __VERIFIER_nondet_int();
#line 466
  switch (tmp) {
  case 0: 
#line 468
  ldv_irq_4_0 = ldv_irq_4(ldv_irq_4_0, ldv_irq_line_4_0, ldv_irq_data_4_0);
#line 470
  goto ldv_59593;
  case 1: 
#line 472
  ldv_irq_4_0 = ldv_irq_4(ldv_irq_4_1, ldv_irq_line_4_1, ldv_irq_data_4_1);
#line 474
  goto ldv_59593;
  case 2: 
#line 476
  ldv_irq_4_0 = ldv_irq_4(ldv_irq_4_2, ldv_irq_line_4_2, ldv_irq_data_4_2);
#line 478
  goto ldv_59593;
  case 3: 
#line 480
  ldv_irq_4_0 = ldv_irq_4(ldv_irq_4_3, ldv_irq_line_4_3, ldv_irq_data_4_3);
#line 482
  goto ldv_59593;
  default: 
#line 483
  ldv_stop();
  }
  ldv_59593: ;
#line 485
  return;
}
}
#line 489 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void invoke_work_8(void) 
{ 
  int tmp ;

  {
#line 491
  tmp = __VERIFIER_nondet_int();
#line 491
  switch (tmp) {
  case 0: ;
#line 493
  if (ldv_work_8_0 == 2 || ldv_work_8_0 == 3) {
#line 494
    ldv_work_8_0 = 4;
#line 495
    ixgbe_service_task(ldv_work_struct_8_0);
#line 496
    ldv_work_8_0 = 1;
  } else {

  }
#line 499
  goto ldv_59604;
  case 1: ;
#line 501
  if (ldv_work_8_1 == 2 || ldv_work_8_1 == 3) {
#line 502
    ldv_work_8_1 = 4;
#line 503
    ixgbe_service_task(ldv_work_struct_8_0);
#line 504
    ldv_work_8_1 = 1;
  } else {

  }
#line 507
  goto ldv_59604;
  case 2: ;
#line 509
  if (ldv_work_8_2 == 2 || ldv_work_8_2 == 3) {
#line 510
    ldv_work_8_2 = 4;
#line 511
    ixgbe_service_task(ldv_work_struct_8_0);
#line 512
    ldv_work_8_2 = 1;
  } else {

  }
#line 515
  goto ldv_59604;
  case 3: ;
#line 517
  if (ldv_work_8_3 == 2 || ldv_work_8_3 == 3) {
#line 518
    ldv_work_8_3 = 4;
#line 519
    ixgbe_service_task(ldv_work_struct_8_0);
#line 520
    ldv_work_8_3 = 1;
  } else {

  }
#line 523
  goto ldv_59604;
  default: 
#line 524
  ldv_stop();
  }
  ldv_59604: ;
#line 526
  return;
}
}
#line 530 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int reg_timer_10(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 531
  if ((unsigned long )function == (unsigned long )(& ixgbe_service_timer)) {
#line 532
    activate_suitable_timer_10(timer, data);
  } else {

  }
#line 533
  return (0);
}
}
#line 537 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_timer_10(int state , struct timer_list *timer ) 
{ 


  {
#line 538
  LDV_IN_INTERRUPT = 2;
#line 539
  ixgbe_service_timer(timer->data);
#line 540
  LDV_IN_INTERRUPT = 1;
#line 541
  return;
}
}
#line 544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void activate_suitable_irq_2(int line , void *data ) 
{ 


  {
#line 545
  if (ldv_irq_2_0 == 0) {
#line 546
    ldv_irq_line_2_0 = line;
#line 547
    ldv_irq_data_2_0 = data;
#line 548
    ldv_irq_2_0 = 1;
#line 549
    return;
  } else {

  }
#line 551
  if (ldv_irq_2_1 == 0) {
#line 552
    ldv_irq_line_2_1 = line;
#line 553
    ldv_irq_data_2_1 = data;
#line 554
    ldv_irq_2_1 = 1;
#line 555
    return;
  } else {

  }
#line 557
  if (ldv_irq_2_2 == 0) {
#line 558
    ldv_irq_line_2_2 = line;
#line 559
    ldv_irq_data_2_2 = data;
#line 560
    ldv_irq_2_2 = 1;
#line 561
    return;
  } else {

  }
#line 563
  if (ldv_irq_2_3 == 0) {
#line 564
    ldv_irq_line_2_3 = line;
#line 565
    ldv_irq_data_2_3 = data;
#line 566
    ldv_irq_2_3 = 1;
#line 567
    return;
  } else {

  }
#line 569
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void work_init_8(void) 
{ 


  {
#line 574
  ldv_work_8_0 = 0;
#line 575
  ldv_work_8_1 = 0;
#line 576
  ldv_work_8_2 = 0;
#line 577
  ldv_work_8_3 = 0;
#line 578
  return;
}
}
#line 581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void activate_suitable_timer_10(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 582
  if (ldv_timer_10_0 == 0 || ldv_timer_10_0 == 2) {
#line 583
    ldv_timer_list_10_0 = timer;
#line 584
    ldv_timer_list_10_0->data = data;
#line 585
    ldv_timer_10_0 = 1;
#line 586
    return;
  } else {

  }
#line 588
  if (ldv_timer_10_1 == 0 || ldv_timer_10_1 == 2) {
#line 589
    ldv_timer_list_10_1 = timer;
#line 590
    ldv_timer_list_10_1->data = data;
#line 591
    ldv_timer_10_1 = 1;
#line 592
    return;
  } else {

  }
#line 594
  if (ldv_timer_10_2 == 0 || ldv_timer_10_2 == 2) {
#line 595
    ldv_timer_list_10_2 = timer;
#line 596
    ldv_timer_list_10_2->data = data;
#line 597
    ldv_timer_10_2 = 1;
#line 598
    return;
  } else {

  }
#line 600
  if (ldv_timer_10_3 == 0 || ldv_timer_10_3 == 2) {
#line 601
    ldv_timer_list_10_3 = timer;
#line 602
    ldv_timer_list_10_3->data = data;
#line 603
    ldv_timer_10_3 = 1;
#line 604
    return;
  } else {

  }
#line 606
  return;
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void choose_interrupt_1(void) 
{ 
  int tmp ;

  {
#line 611
  tmp = __VERIFIER_nondet_int();
#line 611
  switch (tmp) {
  case 0: 
#line 613
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_0, ldv_irq_line_1_0, ldv_irq_data_1_0);
#line 615
  goto ldv_59634;
  case 1: 
#line 617
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_1, ldv_irq_line_1_1, ldv_irq_data_1_1);
#line 619
  goto ldv_59634;
  case 2: 
#line 621
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_2, ldv_irq_line_1_2, ldv_irq_data_1_2);
#line 623
  goto ldv_59634;
  case 3: 
#line 625
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_3, ldv_irq_line_1_3, ldv_irq_data_1_3);
#line 627
  goto ldv_59634;
  default: 
#line 628
  ldv_stop();
  }
  ldv_59634: ;
#line 630
  return;
}
}
#line 634 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int reg_check_2(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 635
  if ((unsigned long )handler == (unsigned long )(& ixgbe_msix_other)) {
#line 636
    return (1);
  } else {

  }
#line 638
  return (0);
}
}
#line 642 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void call_and_disable_work_8(struct work_struct *work ) 
{ 


  {
#line 645
  if ((ldv_work_8_0 == 2 || ldv_work_8_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_0) {
#line 647
    ixgbe_service_task(work);
#line 648
    ldv_work_8_0 = 1;
#line 649
    return;
  } else {

  }
#line 651
  if ((ldv_work_8_1 == 2 || ldv_work_8_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_1) {
#line 653
    ixgbe_service_task(work);
#line 654
    ldv_work_8_1 = 1;
#line 655
    return;
  } else {

  }
#line 657
  if ((ldv_work_8_2 == 2 || ldv_work_8_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_2) {
#line 659
    ixgbe_service_task(work);
#line 660
    ldv_work_8_2 = 1;
#line 661
    return;
  } else {

  }
#line 663
  if ((ldv_work_8_3 == 2 || ldv_work_8_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_3) {
#line 665
    ixgbe_service_task(work);
#line 666
    ldv_work_8_3 = 1;
#line 667
    return;
  } else {

  }
#line 669
  return;
}
}
#line 672 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int reg_check_3(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 673
  if ((unsigned long )handler == (unsigned long )(& ixgbe_intr)) {
#line 674
    return (1);
  } else {

  }
#line 676
  return (0);
}
}
#line 680 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void disable_work_8(struct work_struct *work ) 
{ 


  {
#line 682
  if ((ldv_work_8_0 == 3 || ldv_work_8_0 == 2) && (unsigned long )ldv_work_struct_8_0 == (unsigned long )work) {
#line 684
    ldv_work_8_0 = 1;
  } else {

  }
#line 686
  if ((ldv_work_8_1 == 3 || ldv_work_8_1 == 2) && (unsigned long )ldv_work_struct_8_1 == (unsigned long )work) {
#line 688
    ldv_work_8_1 = 1;
  } else {

  }
#line 690
  if ((ldv_work_8_2 == 3 || ldv_work_8_2 == 2) && (unsigned long )ldv_work_struct_8_2 == (unsigned long )work) {
#line 692
    ldv_work_8_2 = 1;
  } else {

  }
#line 694
  if ((ldv_work_8_3 == 3 || ldv_work_8_3 == 2) && (unsigned long )ldv_work_struct_8_3 == (unsigned long )work) {
#line 696
    ldv_work_8_3 = 1;
  } else {

  }
#line 697
  return;
}
}
#line 701 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_4(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 703
  tmp = __VERIFIER_nondet_int();
#line 703
  irq_retval = (irqreturn_t )tmp;
#line 705
  if (state != 0) {
#line 706
    tmp___0 = __VERIFIER_nondet_int();
#line 706
    switch (tmp___0) {
    case 0: ;
#line 708
    if (state == 1) {
#line 709
      LDV_IN_INTERRUPT = 2;
#line 710
      irq_retval = ixgbe_intr(line, data);
#line 711
      LDV_IN_INTERRUPT = 1;
#line 712
      return (state);
    } else {

    }
#line 715
    goto ldv_59664;
    default: 
#line 716
    ldv_stop();
    }
    ldv_59664: ;
  } else {

  }
#line 719
  return (state);
}
}
#line 723 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void activate_pending_timer_10(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 724
  if ((unsigned long )ldv_timer_list_10_0 == (unsigned long )timer) {
#line 725
    if (ldv_timer_10_0 == 2 || pending_flag != 0) {
#line 726
      ldv_timer_list_10_0 = timer;
#line 727
      ldv_timer_list_10_0->data = data;
#line 728
      ldv_timer_10_0 = 1;
    } else {

    }
#line 730
    return;
  } else {

  }
#line 733
  if ((unsigned long )ldv_timer_list_10_1 == (unsigned long )timer) {
#line 734
    if (ldv_timer_10_1 == 2 || pending_flag != 0) {
#line 735
      ldv_timer_list_10_1 = timer;
#line 736
      ldv_timer_list_10_1->data = data;
#line 737
      ldv_timer_10_1 = 1;
    } else {

    }
#line 739
    return;
  } else {

  }
#line 742
  if ((unsigned long )ldv_timer_list_10_2 == (unsigned long )timer) {
#line 743
    if (ldv_timer_10_2 == 2 || pending_flag != 0) {
#line 744
      ldv_timer_list_10_2 = timer;
#line 745
      ldv_timer_list_10_2->data = data;
#line 746
      ldv_timer_10_2 = 1;
    } else {

    }
#line 748
    return;
  } else {

  }
#line 751
  if ((unsigned long )ldv_timer_list_10_3 == (unsigned long )timer) {
#line 752
    if (ldv_timer_10_3 == 2 || pending_flag != 0) {
#line 753
      ldv_timer_list_10_3 = timer;
#line 754
      ldv_timer_list_10_3->data = data;
#line 755
      ldv_timer_10_3 = 1;
    } else {

    }
#line 757
    return;
  } else {

  }
#line 759
  activate_suitable_timer_10(timer, data);
#line 760
  return;
}
}
#line 763 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void call_and_disable_all_8(int state ) 
{ 


  {
#line 765
  if (ldv_work_8_0 == state) {
#line 766
    call_and_disable_work_8(ldv_work_struct_8_0);
  } else {

  }
#line 767
  if (ldv_work_8_1 == state) {
#line 768
    call_and_disable_work_8(ldv_work_struct_8_1);
  } else {

  }
#line 769
  if (ldv_work_8_2 == state) {
#line 770
    call_and_disable_work_8(ldv_work_struct_8_2);
  } else {

  }
#line 771
  if (ldv_work_8_3 == state) {
#line 772
    call_and_disable_work_8(ldv_work_struct_8_3);
  } else {

  }
#line 773
  return;
}
}
#line 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void disable_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 777
  if (ldv_irq_1_0 != 0 && line == ldv_irq_line_1_0) {
#line 778
    ldv_irq_1_0 = 0;
#line 779
    return;
  } else {

  }
#line 781
  if (ldv_irq_1_1 != 0 && line == ldv_irq_line_1_1) {
#line 782
    ldv_irq_1_1 = 0;
#line 783
    return;
  } else {

  }
#line 785
  if (ldv_irq_1_2 != 0 && line == ldv_irq_line_1_2) {
#line 786
    ldv_irq_1_2 = 0;
#line 787
    return;
  } else {

  }
#line 789
  if (ldv_irq_1_3 != 0 && line == ldv_irq_line_1_3) {
#line 790
    ldv_irq_1_3 = 0;
#line 791
    return;
  } else {

  }
#line 793
  return;
}
}
#line 797 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void activate_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 798
  if (ldv_irq_1_0 == 0) {
#line 799
    ldv_irq_line_1_0 = line;
#line 800
    ldv_irq_data_1_0 = data;
#line 801
    ldv_irq_1_0 = 1;
#line 802
    return;
  } else {

  }
#line 804
  if (ldv_irq_1_1 == 0) {
#line 805
    ldv_irq_line_1_1 = line;
#line 806
    ldv_irq_data_1_1 = data;
#line 807
    ldv_irq_1_1 = 1;
#line 808
    return;
  } else {

  }
#line 810
  if (ldv_irq_1_2 == 0) {
#line 811
    ldv_irq_line_1_2 = line;
#line 812
    ldv_irq_data_1_2 = data;
#line 813
    ldv_irq_1_2 = 1;
#line 814
    return;
  } else {

  }
#line 816
  if (ldv_irq_1_3 == 0) {
#line 817
    ldv_irq_line_1_3 = line;
#line 818
    ldv_irq_data_1_3 = data;
#line 819
    ldv_irq_1_3 = 1;
#line 820
    return;
  } else {

  }
#line 822
  return;
}
}
#line 826 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int reg_check_4(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 827
  if ((unsigned long )handler == (unsigned long )(& ixgbe_intr)) {
#line 828
    return (1);
  } else {

  }
#line 830
  return (0);
}
}
#line 834 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void activate_work_8(struct work_struct *work , int state ) 
{ 


  {
#line 835
  if (ldv_work_8_0 == 0) {
#line 836
    ldv_work_struct_8_0 = work;
#line 837
    ldv_work_8_0 = state;
#line 838
    return;
  } else {

  }
#line 841
  if (ldv_work_8_1 == 0) {
#line 842
    ldv_work_struct_8_1 = work;
#line 843
    ldv_work_8_1 = state;
#line 844
    return;
  } else {

  }
#line 847
  if (ldv_work_8_2 == 0) {
#line 848
    ldv_work_struct_8_2 = work;
#line 849
    ldv_work_8_2 = state;
#line 850
    return;
  } else {

  }
#line 853
  if (ldv_work_8_3 == 0) {
#line 854
    ldv_work_struct_8_3 = work;
#line 855
    ldv_work_8_3 = state;
#line 856
    return;
  } else {

  }
#line 858
  return;
}
}
#line 861 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_2(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 863
  tmp = __VERIFIER_nondet_int();
#line 863
  irq_retval = (irqreturn_t )tmp;
#line 865
  if (state != 0) {
#line 866
    tmp___0 = __VERIFIER_nondet_int();
#line 866
    switch (tmp___0) {
    case 0: ;
#line 868
    if (state == 1) {
#line 869
      LDV_IN_INTERRUPT = 2;
#line 870
      irq_retval = ixgbe_msix_other(line, data);
#line 871
      LDV_IN_INTERRUPT = 1;
#line 872
      return (state);
    } else {

    }
#line 875
    goto ldv_59698;
    default: 
#line 876
    ldv_stop();
    }
    ldv_59698: ;
  } else {

  }
#line 879
  return (state);
}
}
#line 883 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_pci_driver_36(void) 
{ 
  void *tmp ;

  {
#line 884
  tmp = ldv_init_zalloc(2976UL);
#line 884
  ixgbe_driver_group1 = (struct pci_dev *)tmp;
#line 885
  return;
}
}
#line 888 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void choose_interrupt_2(void) 
{ 
  int tmp ;

  {
#line 889
  tmp = __VERIFIER_nondet_int();
#line 889
  switch (tmp) {
  case 0: 
#line 891
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_0, ldv_irq_line_2_0, ldv_irq_data_2_0);
#line 893
  goto ldv_59707;
  case 1: 
#line 895
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_1, ldv_irq_line_2_1, ldv_irq_data_2_1);
#line 897
  goto ldv_59707;
  case 2: 
#line 899
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_2, ldv_irq_line_2_2, ldv_irq_data_2_2);
#line 901
  goto ldv_59707;
  case 3: 
#line 903
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_3, ldv_irq_line_2_3, ldv_irq_data_2_3);
#line 905
  goto ldv_59707;
  default: 
#line 906
  ldv_stop();
  }
  ldv_59707: ;
#line 908
  return;
}
}
#line 912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_initialize_pci_error_handlers_37(void) 
{ 
  void *tmp ;

  {
#line 913
  tmp = __VERIFIER_nondet_pointer();
#line 913
  ixgbe_err_handler_group0 = (struct pci_dev *)tmp;
#line 914
  return;
}
}
#line 916 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void disable_suitable_timer_10(struct timer_list *timer ) 
{ 


  {
#line 917
  if (ldv_timer_10_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_0) {
#line 918
    ldv_timer_10_0 = 0;
#line 919
    return;
  } else {

  }
#line 921
  if (ldv_timer_10_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_1) {
#line 922
    ldv_timer_10_1 = 0;
#line 923
    return;
  } else {

  }
#line 925
  if (ldv_timer_10_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_2) {
#line 926
    ldv_timer_10_2 = 0;
#line 927
    return;
  } else {

  }
#line 929
  if (ldv_timer_10_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_3) {
#line 930
    ldv_timer_10_3 = 0;
#line 931
    return;
  } else {

  }
#line 933
  return;
}
}
#line 937 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void disable_suitable_irq_4(int line , void *data ) 
{ 


  {
#line 938
  if (ldv_irq_4_0 != 0 && line == ldv_irq_line_4_0) {
#line 939
    ldv_irq_4_0 = 0;
#line 940
    return;
  } else {

  }
#line 942
  if (ldv_irq_4_1 != 0 && line == ldv_irq_line_4_1) {
#line 943
    ldv_irq_4_1 = 0;
#line 944
    return;
  } else {

  }
#line 946
  if (ldv_irq_4_2 != 0 && line == ldv_irq_line_4_2) {
#line 947
    ldv_irq_4_2 = 0;
#line 948
    return;
  } else {

  }
#line 950
  if (ldv_irq_4_3 != 0 && line == ldv_irq_line_4_3) {
#line 951
    ldv_irq_4_3 = 0;
#line 952
    return;
  } else {

  }
#line 954
  return;
}
}
#line 958 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void disable_suitable_irq_3(int line , void *data ) 
{ 


  {
#line 959
  if (ldv_irq_3_0 != 0 && line == ldv_irq_line_3_0) {
#line 960
    ldv_irq_3_0 = 0;
#line 961
    return;
  } else {

  }
#line 963
  if (ldv_irq_3_1 != 0 && line == ldv_irq_line_3_1) {
#line 964
    ldv_irq_3_1 = 0;
#line 965
    return;
  } else {

  }
#line 967
  if (ldv_irq_3_2 != 0 && line == ldv_irq_line_3_2) {
#line 968
    ldv_irq_3_2 = 0;
#line 969
    return;
  } else {

  }
#line 971
  if (ldv_irq_3_3 != 0 && line == ldv_irq_line_3_3) {
#line 972
    ldv_irq_3_3 = 0;
#line 973
    return;
  } else {

  }
#line 975
  return;
}
}
#line 979 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void timer_init_10(void) 
{ 


  {
#line 980
  ldv_timer_10_0 = 0;
#line 981
  ldv_timer_10_1 = 0;
#line 982
  ldv_timer_10_2 = 0;
#line 983
  ldv_timer_10_3 = 0;
#line 984
  return;
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_irq_1(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 989
  tmp = __VERIFIER_nondet_int();
#line 989
  irq_retval = (irqreturn_t )tmp;
#line 991
  if (state != 0) {
#line 992
    tmp___0 = __VERIFIER_nondet_int();
#line 992
    switch (tmp___0) {
    case 0: ;
#line 994
    if (state == 1) {
#line 995
      LDV_IN_INTERRUPT = 2;
#line 996
      irq_retval = ixgbe_msix_clean_rings(line, data);
#line 997
      LDV_IN_INTERRUPT = 1;
#line 998
      return (state);
    } else {

    }
#line 1001
    goto ldv_59736;
    default: 
#line 1002
    ldv_stop();
    }
    ldv_59736: ;
  } else {

  }
#line 1005
  return (state);
}
}
#line 1010 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void choose_timer_10(void) 
{ 
  int tmp ;

  {
#line 1011
  tmp = __VERIFIER_nondet_int();
#line 1011
  switch (tmp) {
  case 0: ;
#line 1013
  if (ldv_timer_10_0 == 1) {
#line 1014
    ldv_timer_10_0 = 2;
#line 1015
    ldv_timer_10(ldv_timer_10_0, ldv_timer_list_10_0);
  } else {

  }
#line 1018
  goto ldv_59744;
  case 1: ;
#line 1020
  if (ldv_timer_10_1 == 1) {
#line 1021
    ldv_timer_10_1 = 2;
#line 1022
    ldv_timer_10(ldv_timer_10_1, ldv_timer_list_10_1);
  } else {

  }
#line 1025
  goto ldv_59744;
  case 2: ;
#line 1027
  if (ldv_timer_10_2 == 1) {
#line 1028
    ldv_timer_10_2 = 2;
#line 1029
    ldv_timer_10(ldv_timer_10_2, ldv_timer_list_10_2);
  } else {

  }
#line 1032
  goto ldv_59744;
  case 3: ;
#line 1034
  if (ldv_timer_10_3 == 1) {
#line 1035
    ldv_timer_10_3 = 2;
#line 1036
    ldv_timer_10(ldv_timer_10_3, ldv_timer_list_10_3);
  } else {

  }
#line 1039
  goto ldv_59744;
  default: 
#line 1040
  ldv_stop();
  }
  ldv_59744: ;
#line 1042
  return;
}
}
#line 1046 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void choose_interrupt_3(void) 
{ 
  int tmp ;

  {
#line 1047
  tmp = __VERIFIER_nondet_int();
#line 1047
  switch (tmp) {
  case 0: 
#line 1049
  ldv_irq_3_0 = ldv_irq_3(ldv_irq_3_0, ldv_irq_line_3_0, ldv_irq_data_3_0);
#line 1051
  goto ldv_59753;
  case 1: 
#line 1053
  ldv_irq_3_0 = ldv_irq_3(ldv_irq_3_1, ldv_irq_line_3_1, ldv_irq_data_3_1);
#line 1055
  goto ldv_59753;
  case 2: 
#line 1057
  ldv_irq_3_0 = ldv_irq_3(ldv_irq_3_2, ldv_irq_line_3_2, ldv_irq_data_3_2);
#line 1059
  goto ldv_59753;
  case 3: 
#line 1061
  ldv_irq_3_0 = ldv_irq_3(ldv_irq_3_3, ldv_irq_line_3_3, ldv_irq_data_3_3);
#line 1063
  goto ldv_59753;
  default: 
#line 1064
  ldv_stop();
  }
  ldv_59753: ;
#line 1066
  return;
}
}
#line 1071
void ldv_main_exported_33(void) ;
#line 1072
void ldv_main_exported_32(void) ;
#line 1073
void ldv_main_exported_34(void) ;
#line 1074
void ldv_main_exported_31(void) ;
#line 1075
void ldv_main_exported_21(void) ;
#line 1076
void ldv_main_exported_17(void) ;
#line 1077
void ldv_main_exported_20(void) ;
#line 1078
void ldv_main_exported_15(void) ;
#line 1079
void ldv_main_exported_14(void) ;
#line 1080
void ldv_main_exported_18(void) ;
#line 1081
void ldv_main_exported_16(void) ;
#line 1082
void ldv_main_exported_19(void) ;
#line 1088
void ldv_main_exported_13(void) ;
#line 1089
void ldv_main_exported_26(void) ;
#line 1090
void ldv_main_exported_35(void) ;
#line 1091
void ldv_main_exported_25(void) ;
#line 1092
void ldv_main_exported_22(void) ;
#line 1093
void ldv_main_exported_24(void) ;
#line 1094
void ldv_main_exported_23(void) ;
#line 1095
void ldv_main_exported_11(void) ;
#line 1096
void ldv_main_exported_12(void) ;
#line 1097
void ldv_main_exported_27(void) ;
#line 1098
void ldv_main_exported_28(void) ;
#line 1099
void ldv_main_exported_30(void) ;
#line 1100
void ldv_main_exported_29(void) ;
#line 1104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void main(void) 
{ 
  void *ldvarg431 ;
  void *tmp ;
  unsigned long ldvarg432 ;
  struct notifier_block *ldvarg430 ;
  void *tmp___0 ;
  int ldvarg433 ;
  pm_message_t ldvarg435 ;
  struct pci_device_id *ldvarg434 ;
  void *tmp___1 ;
  u32 ldvarg469 ;
  u16 ldvarg458 ;
  u64 *ldvarg463 ;
  void *tmp___2 ;
  struct netdev_fcoe_hbainfo *ldvarg487 ;
  void *tmp___3 ;
  struct ifreq *ldvarg500 ;
  void *tmp___4 ;
  __be16 ldvarg476 ;
  u16 ldvarg479 ;
  struct scatterlist *ldvarg473 ;
  void *tmp___5 ;
  int ldvarg485 ;
  unsigned int ldvarg464 ;
  unsigned int ldvarg472 ;
  struct napi_struct *ldvarg461 ;
  void *tmp___6 ;
  bool ldvarg452 ;
  u16 (*ldvarg449)(struct net_device * , struct sk_buff * ) ;
  struct nlattr **ldvarg457 ;
  void *tmp___7 ;
  void *ldvarg450 ;
  void *tmp___8 ;
  netdev_features_t ldvarg446 ;
  void *ldvarg488 ;
  void *tmp___9 ;
  struct sk_buff *ldvarg468 ;
  void *tmp___10 ;
  struct sk_buff *ldvarg496 ;
  void *tmp___11 ;
  u8 *ldvarg484 ;
  void *tmp___12 ;
  int ldvarg483 ;
  u16 ldvarg490 ;
  struct rtnl_link_stats64 *ldvarg443 ;
  void *tmp___13 ;
  int ldvarg499 ;
  int ldvarg498 ;
  netdev_features_t ldvarg493 ;
  __be16 ldvarg480 ;
  u8 ldvarg489 ;
  void *ldvarg445 ;
  void *tmp___14 ;
  u16 ldvarg466 ;
  sa_family_t ldvarg448 ;
  struct ifla_vf_info *ldvarg497 ;
  void *tmp___15 ;
  u16 ldvarg474 ;
  struct scatterlist *ldvarg465 ;
  void *tmp___16 ;
  int ldvarg495 ;
  int ldvarg482 ;
  u16 ldvarg477 ;
  __be16 ldvarg459 ;
  u16 ldvarg475 ;
  __be16 ldvarg447 ;
  int ldvarg462 ;
  int ldvarg491 ;
  struct nlmsghdr *ldvarg478 ;
  void *tmp___17 ;
  sa_family_t ldvarg460 ;
  u32 ldvarg471 ;
  bool ldvarg494 ;
  struct sk_buff *ldvarg451 ;
  void *tmp___18 ;
  int ldvarg486 ;
  unsigned char *ldvarg455 ;
  void *tmp___19 ;
  u16 ldvarg454 ;
  int ldvarg481 ;
  int ldvarg467 ;
  struct ndmsg *ldvarg456 ;
  void *tmp___20 ;
  u16 ldvarg492 ;
  int ldvarg453 ;
  u8 ldvarg444 ;
  u32 ldvarg470 ;
  enum pci_channel_state ldvarg553 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
#line 1107
  tmp = ldv_init_zalloc(1UL);
#line 1107
  ldvarg431 = tmp;
#line 1109
  tmp___0 = ldv_init_zalloc(24UL);
#line 1109
  ldvarg430 = (struct notifier_block *)tmp___0;
#line 1112
  tmp___1 = ldv_init_zalloc(32UL);
#line 1112
  ldvarg434 = (struct pci_device_id *)tmp___1;
#line 1115
  tmp___2 = ldv_init_zalloc(8UL);
#line 1115
  ldvarg463 = (u64 *)tmp___2;
#line 1116
  tmp___3 = ldv_init_zalloc(896UL);
#line 1116
  ldvarg487 = (struct netdev_fcoe_hbainfo *)tmp___3;
#line 1117
  tmp___4 = ldv_init_zalloc(40UL);
#line 1117
  ldvarg500 = (struct ifreq *)tmp___4;
#line 1120
  tmp___5 = ldv_init_zalloc(40UL);
#line 1120
  ldvarg473 = (struct scatterlist *)tmp___5;
#line 1124
  tmp___6 = ldv_init_zalloc(280UL);
#line 1124
  ldvarg461 = (struct napi_struct *)tmp___6;
#line 1127
  tmp___7 = ldv_init_zalloc(8UL);
#line 1127
  ldvarg457 = (struct nlattr **)tmp___7;
#line 1128
  tmp___8 = ldv_init_zalloc(1UL);
#line 1128
  ldvarg450 = tmp___8;
#line 1130
  tmp___9 = ldv_init_zalloc(1UL);
#line 1130
  ldvarg488 = tmp___9;
#line 1131
  tmp___10 = ldv_init_zalloc(232UL);
#line 1131
  ldvarg468 = (struct sk_buff *)tmp___10;
#line 1132
  tmp___11 = ldv_init_zalloc(232UL);
#line 1132
  ldvarg496 = (struct sk_buff *)tmp___11;
#line 1133
  tmp___12 = ldv_init_zalloc(1UL);
#line 1133
  ldvarg484 = (u8 *)tmp___12;
#line 1136
  tmp___13 = ldv_init_zalloc(184UL);
#line 1136
  ldvarg443 = (struct rtnl_link_stats64 *)tmp___13;
#line 1142
  tmp___14 = ldv_init_zalloc(1UL);
#line 1142
  ldvarg445 = tmp___14;
#line 1145
  tmp___15 = ldv_init_zalloc(64UL);
#line 1145
  ldvarg497 = (struct ifla_vf_info *)tmp___15;
#line 1147
  tmp___16 = ldv_init_zalloc(40UL);
#line 1147
  ldvarg465 = (struct scatterlist *)tmp___16;
#line 1156
  tmp___17 = ldv_init_zalloc(16UL);
#line 1156
  ldvarg478 = (struct nlmsghdr *)tmp___17;
#line 1160
  tmp___18 = ldv_init_zalloc(232UL);
#line 1160
  ldvarg451 = (struct sk_buff *)tmp___18;
#line 1162
  tmp___19 = ldv_init_zalloc(1UL);
#line 1162
  ldvarg455 = (unsigned char *)tmp___19;
#line 1166
  tmp___20 = ldv_init_zalloc(12UL);
#line 1166
  ldvarg456 = (struct ndmsg *)tmp___20;
#line 1105
  ldv_initialize();
#line 1108
  ldv_memset((void *)(& ldvarg432), 0, 8UL);
#line 1110
  ldv_memset((void *)(& ldvarg433), 0, 4UL);
#line 1111
  ldv_memset((void *)(& ldvarg435), 0, 4UL);
#line 1113
  ldv_memset((void *)(& ldvarg469), 0, 4UL);
#line 1114
  ldv_memset((void *)(& ldvarg458), 0, 2UL);
#line 1118
  ldv_memset((void *)(& ldvarg476), 0, 2UL);
#line 1119
  ldv_memset((void *)(& ldvarg479), 0, 2UL);
#line 1121
  ldv_memset((void *)(& ldvarg485), 0, 4UL);
#line 1122
  ldv_memset((void *)(& ldvarg464), 0, 4UL);
#line 1123
  ldv_memset((void *)(& ldvarg472), 0, 4UL);
#line 1125
  ldv_memset((void *)(& ldvarg452), 0, 1UL);
#line 1126
  ldv_memset((void *)(& ldvarg449), 0, 8UL);
#line 1129
  ldv_memset((void *)(& ldvarg446), 0, 8UL);
#line 1134
  ldv_memset((void *)(& ldvarg483), 0, 4UL);
#line 1135
  ldv_memset((void *)(& ldvarg490), 0, 2UL);
#line 1137
  ldv_memset((void *)(& ldvarg499), 0, 4UL);
#line 1138
  ldv_memset((void *)(& ldvarg498), 0, 4UL);
#line 1139
  ldv_memset((void *)(& ldvarg493), 0, 8UL);
#line 1140
  ldv_memset((void *)(& ldvarg480), 0, 2UL);
#line 1141
  ldv_memset((void *)(& ldvarg489), 0, 1UL);
#line 1143
  ldv_memset((void *)(& ldvarg466), 0, 2UL);
#line 1144
  ldv_memset((void *)(& ldvarg448), 0, 2UL);
#line 1146
  ldv_memset((void *)(& ldvarg474), 0, 2UL);
#line 1148
  ldv_memset((void *)(& ldvarg495), 0, 4UL);
#line 1149
  ldv_memset((void *)(& ldvarg482), 0, 4UL);
#line 1150
  ldv_memset((void *)(& ldvarg477), 0, 2UL);
#line 1151
  ldv_memset((void *)(& ldvarg459), 0, 2UL);
#line 1152
  ldv_memset((void *)(& ldvarg475), 0, 2UL);
#line 1153
  ldv_memset((void *)(& ldvarg447), 0, 2UL);
#line 1154
  ldv_memset((void *)(& ldvarg462), 0, 4UL);
#line 1155
  ldv_memset((void *)(& ldvarg491), 0, 4UL);
#line 1157
  ldv_memset((void *)(& ldvarg460), 0, 2UL);
#line 1158
  ldv_memset((void *)(& ldvarg471), 0, 4UL);
#line 1159
  ldv_memset((void *)(& ldvarg494), 0, 1UL);
#line 1161
  ldv_memset((void *)(& ldvarg486), 0, 4UL);
#line 1163
  ldv_memset((void *)(& ldvarg454), 0, 2UL);
#line 1164
  ldv_memset((void *)(& ldvarg481), 0, 4UL);
#line 1165
  ldv_memset((void *)(& ldvarg467), 0, 4UL);
#line 1167
  ldv_memset((void *)(& ldvarg492), 0, 2UL);
#line 1168
  ldv_memset((void *)(& ldvarg453), 0, 4UL);
#line 1169
  ldv_memset((void *)(& ldvarg444), 0, 1UL);
#line 1170
  ldv_memset((void *)(& ldvarg470), 0, 4UL);
#line 1171
  ldv_memset((void *)(& ldvarg553), 0, 4UL);
#line 1173
  ldv_state_variable_33 = 0;
#line 1174
  ldv_state_variable_32 = 0;
#line 1175
  ldv_state_variable_21 = 0;
#line 1177
  ldv_state_variable_7 = 1;
#line 1178
  ldv_state_variable_26 = 0;
#line 1179
  ldv_state_variable_17 = 0;
#line 1181
  ldv_state_variable_2 = 1;
#line 1183
  ldv_state_variable_1 = 1;
#line 1184
  ldv_state_variable_18 = 0;
#line 1185
  ldv_state_variable_30 = 0;
#line 1186
  ldv_state_variable_16 = 0;
#line 1187
  ldv_state_variable_27 = 0;
#line 1188
  ldv_state_variable_25 = 0;
#line 1189
  ldv_state_variable_28 = 0;
#line 1190
  ldv_state_variable_20 = 0;
#line 1191
  ldv_state_variable_14 = 0;
#line 1192
  ldv_state_variable_24 = 0;
#line 1194
  timer_init_10();
#line 1196
  ldv_state_variable_10 = 1;
#line 1197
  ldv_state_variable_31 = 0;
#line 1198
  ldv_state_variable_35 = 0;
#line 1199
  ldv_state_variable_11 = 0;
#line 1200
  ldv_state_variable_22 = 0;
#line 1201
  ref_cnt = 0;
#line 1202
  ldv_state_variable_0 = 1;
#line 1203
  ldv_state_variable_13 = 0;
#line 1204
  ldv_state_variable_23 = 0;
#line 1205
  ldv_state_variable_29 = 0;
#line 1207
  ldv_state_variable_6 = 1;
#line 1208
  ldv_state_variable_39 = 0;
#line 1209
  ldv_state_variable_36 = 0;
#line 1211
  ldv_state_variable_3 = 1;
#line 1213
  work_init_9();
#line 1215
  ldv_state_variable_9 = 1;
#line 1216
  ldv_state_variable_12 = 0;
#line 1217
  ldv_state_variable_15 = 0;
#line 1218
  ldv_state_variable_38 = 0;
#line 1220
  work_init_8();
#line 1222
  ldv_state_variable_8 = 1;
#line 1224
  ldv_state_variable_4 = 1;
#line 1225
  ldv_state_variable_34 = 0;
#line 1226
  ldv_state_variable_37 = 0;
#line 1227
  ldv_state_variable_19 = 0;
#line 1229
  ldv_state_variable_5 = 1;
  ldv_60000: 
#line 1231
  tmp___21 = __VERIFIER_nondet_int();
#line 1231
  switch (tmp___21) {
  case 0: ;
#line 1235
  if (ldv_state_variable_33 != 0) {
#line 1236
    ldv_main_exported_33();
  } else {

  }
#line 1239
  goto ldv_59891;
  case 1: ;
#line 1243
  if (ldv_state_variable_32 != 0) {
#line 1244
    ldv_main_exported_32();
  } else {

  }
#line 1247
  goto ldv_59891;
  case 2: ;
#line 1251
  if (ldv_state_variable_21 != 0) {
#line 1252
    ldv_main_exported_21();
  } else {

  }
#line 1255
  goto ldv_59891;
  case 3: ;
#line 1262
  goto ldv_59891;
  case 4: ;
#line 1266
  if (ldv_state_variable_26 != 0) {
#line 1267
    ldv_main_exported_26();
  } else {

  }
#line 1270
  goto ldv_59891;
  case 5: ;
#line 1274
  if (ldv_state_variable_17 != 0) {
#line 1275
    ldv_main_exported_17();
  } else {

  }
#line 1278
  goto ldv_59891;
  case 6: ;
#line 1282
  if (ldv_state_variable_2 != 0) {
#line 1283
    choose_interrupt_2();
  } else {

  }
#line 1286
  goto ldv_59891;
  case 7: ;
#line 1290
  if (ldv_state_variable_1 != 0) {
#line 1291
    choose_interrupt_1();
  } else {

  }
#line 1294
  goto ldv_59891;
  case 8: ;
#line 1298
  if (ldv_state_variable_18 != 0) {
#line 1299
    ldv_main_exported_18();
  } else {

  }
#line 1302
  goto ldv_59891;
  case 9: ;
#line 1306
  if (ldv_state_variable_30 != 0) {
#line 1307
    ldv_main_exported_30();
  } else {

  }
#line 1310
  goto ldv_59891;
  case 10: ;
#line 1314
  if (ldv_state_variable_16 != 0) {
#line 1315
    ldv_main_exported_16();
  } else {

  }
#line 1318
  goto ldv_59891;
  case 11: ;
#line 1322
  if (ldv_state_variable_27 != 0) {
#line 1323
    ldv_main_exported_27();
  } else {

  }
#line 1326
  goto ldv_59891;
  case 12: ;
#line 1330
  if (ldv_state_variable_25 != 0) {
#line 1331
    ldv_main_exported_25();
  } else {

  }
#line 1334
  goto ldv_59891;
  case 13: ;
#line 1338
  if (ldv_state_variable_28 != 0) {
#line 1339
    ldv_main_exported_28();
  } else {

  }
#line 1342
  goto ldv_59891;
  case 14: ;
#line 1346
  if (ldv_state_variable_20 != 0) {
#line 1347
    ldv_main_exported_20();
  } else {

  }
#line 1350
  goto ldv_59891;
  case 15: ;
#line 1354
  if (ldv_state_variable_14 != 0) {
#line 1355
    ldv_main_exported_14();
  } else {

  }
#line 1358
  goto ldv_59891;
  case 16: ;
#line 1362
  if (ldv_state_variable_24 != 0) {
#line 1363
    ldv_main_exported_24();
  } else {

  }
#line 1366
  goto ldv_59891;
  case 17: ;
#line 1370
  if (ldv_state_variable_10 != 0) {
#line 1371
    choose_timer_10();
  } else {

  }
#line 1374
  goto ldv_59891;
  case 18: ;
#line 1378
  if (ldv_state_variable_31 != 0) {
#line 1379
    ldv_main_exported_31();
  } else {

  }
#line 1382
  goto ldv_59891;
  case 19: ;
#line 1386
  if (ldv_state_variable_35 != 0) {
#line 1387
    ldv_main_exported_35();
  } else {

  }
#line 1390
  goto ldv_59891;
  case 20: ;
#line 1394
  if (ldv_state_variable_11 != 0) {
#line 1395
    ldv_main_exported_11();
  } else {

  }
#line 1398
  goto ldv_59891;
  case 21: ;
#line 1402
  if (ldv_state_variable_22 != 0) {
#line 1403
    ldv_main_exported_22();
  } else {

  }
#line 1406
  goto ldv_59891;
  case 22: ;
#line 1410
  if (ldv_state_variable_0 != 0) {
#line 1411
    tmp___22 = __VERIFIER_nondet_int();
#line 1411
    switch (tmp___22) {
    case 0: ;
#line 1414
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 1416
      ixgbe_exit_module();
#line 1417
      ldv_state_variable_0 = 2;
#line 1418
      goto ldv_final;
    } else {

    }
#line 1421
    goto ldv_59916;
    case 1: ;
#line 1424
    if (ldv_state_variable_0 == 1) {
#line 1426
      ldv_retval_1 = ixgbe_init_module();
#line 1428
      if (ldv_retval_1 == 0) {
#line 1429
        ldv_state_variable_0 = 3;
#line 1430
        ldv_state_variable_31 = 1;
#line 1431
        ldv_state_variable_19 = 1;
#line 1432
        ldv_initialize_ixgbe_eeprom_operations_19();
#line 1433
        ldv_state_variable_24 = 1;
#line 1434
        ldv_initialize_ixgbe_eeprom_operations_24();
#line 1435
        ldv_state_variable_37 = 1;
#line 1436
        ldv_initialize_pci_error_handlers_37();
#line 1437
        ldv_state_variable_34 = 1;
#line 1438
        ldv_initialize_ixgbe_mac_operations_34();
#line 1439
        ldv_state_variable_20 = 1;
#line 1440
        ldv_initialize_ixgbe_mac_operations_20();
#line 1441
        ldv_state_variable_15 = 1;
#line 1442
        ldv_state_variable_14 = 1;
#line 1443
        ldv_state_variable_12 = 1;
#line 1444
        ldv_file_operations_12();
#line 1445
        ldv_state_variable_28 = 1;
#line 1446
        ldv_initialize_ixgbe_phy_operations_28();
#line 1447
        ldv_state_variable_39 = 1;
#line 1448
        ldv_state_variable_25 = 1;
#line 1449
        ldv_initialize_ixgbe_mac_operations_25();
#line 1450
        ldv_state_variable_27 = 1;
#line 1451
        ldv_state_variable_29 = 1;
#line 1452
        ldv_initialize_ixgbe_eeprom_operations_29();
#line 1453
        ldv_state_variable_16 = 1;
#line 1454
        ldv_initialize_ixgbe_phy_operations_16();
#line 1455
        ldv_state_variable_13 = 1;
#line 1456
        ldv_initialize_dcbnl_rtnl_ops_13();
#line 1457
        ldv_state_variable_23 = 1;
#line 1458
        ldv_initialize_ixgbe_phy_operations_23();
#line 1459
        ldv_state_variable_30 = 1;
#line 1460
        ldv_initialize_ixgbe_mac_operations_30();
#line 1461
        ldv_state_variable_18 = 1;
#line 1462
        ldv_initialize_ixgbe_eeprom_operations_18();
#line 1463
        ldv_state_variable_22 = 1;
#line 1464
        ldv_state_variable_17 = 1;
#line 1465
        ldv_initialize_ixgbe_phy_operations_17();
#line 1466
        ldv_state_variable_26 = 1;
#line 1467
        ldv_initialize_ixgbe_mbx_operations_26();
#line 1468
        ldv_state_variable_21 = 1;
#line 1469
        ldv_initialize_ixgbe_mac_operations_21();
#line 1470
        ldv_state_variable_11 = 1;
#line 1471
        ldv_file_operations_11();
#line 1472
        ldv_state_variable_32 = 1;
#line 1473
        ldv_initialize_ixgbe_phy_operations_32();
#line 1474
        ldv_state_variable_33 = 1;
#line 1475
        ldv_initialize_ixgbe_eeprom_operations_33();
#line 1476
        ldv_state_variable_35 = 1;
#line 1477
        ldv_initialize_ethtool_ops_35();
      } else {

      }
#line 1479
      if (ldv_retval_1 != 0) {
#line 1480
        ldv_state_variable_0 = 2;
#line 1481
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 1485
    goto ldv_59916;
    default: 
#line 1486
    ldv_stop();
    }
    ldv_59916: ;
  } else {

  }
#line 1490
  goto ldv_59891;
  case 23: ;
#line 1494
  if (ldv_state_variable_13 != 0) {
#line 1495
    ldv_main_exported_13();
  } else {

  }
#line 1498
  goto ldv_59891;
  case 24: ;
#line 1502
  if (ldv_state_variable_23 != 0) {
#line 1503
    ldv_main_exported_23();
  } else {

  }
#line 1506
  goto ldv_59891;
  case 25: ;
#line 1510
  if (ldv_state_variable_29 != 0) {
#line 1511
    ldv_main_exported_29();
  } else {

  }
#line 1514
  goto ldv_59891;
  case 26: ;
#line 1521
  goto ldv_59891;
  case 27: ;
#line 1525
  if (ldv_state_variable_39 != 0) {
#line 1526
    tmp___23 = __VERIFIER_nondet_int();
#line 1526
    switch (tmp___23) {
    case 0: ;
#line 1529
    if (ldv_state_variable_39 == 1) {
#line 1531
      ixgbe_notify_dca(ldvarg430, ldvarg432, ldvarg431);
#line 1533
      ldv_state_variable_39 = 1;
    } else {

    }
#line 1536
    goto ldv_59925;
    default: 
#line 1537
    ldv_stop();
    }
    ldv_59925: ;
  } else {

  }
#line 1541
  goto ldv_59891;
  case 28: ;
#line 1545
  if (ldv_state_variable_36 != 0) {
#line 1546
    tmp___24 = __VERIFIER_nondet_int();
#line 1546
    switch (tmp___24) {
    case 0: ;
#line 1549
    if (ldv_state_variable_36 == 2 && pci_counter == 0) {
#line 1551
      ldv_retval_6 = ixgbe_suspend(ixgbe_driver_group1, ldvarg435);
#line 1552
      if (ldv_retval_6 == 0) {
#line 1553
        ldv_state_variable_36 = 3;
      } else {

      }
    } else {

    }
#line 1557
    goto ldv_59929;
    case 1: ;
#line 1560
    if (ldv_state_variable_36 == 4) {
#line 1562
      ldv_retval_5 = ixgbe_resume(ixgbe_driver_group1);
#line 1563
      if (ldv_retval_5 == 0) {
#line 1564
        ldv_state_variable_36 = 2;
      } else {

      }
    } else {

    }
#line 1568
    if (ldv_state_variable_36 == 3) {
#line 1570
      ldv_retval_5 = ixgbe_resume(ixgbe_driver_group1);
#line 1571
      if (ldv_retval_5 == 0) {
#line 1572
        ldv_state_variable_36 = 2;
      } else {

      }
    } else {

    }
#line 1576
    if (ldv_state_variable_36 == 5) {
#line 1578
      ldv_retval_5 = ixgbe_resume(ixgbe_driver_group1);
#line 1579
      if (ldv_retval_5 == 0) {
#line 1580
        ldv_state_variable_36 = 2;
      } else {

      }
    } else {

    }
#line 1584
    goto ldv_59929;
    case 2: ;
#line 1587
    if (ldv_state_variable_36 == 1) {
#line 1589
      ldv_retval_4 = ixgbe_probe(ixgbe_driver_group1, (struct pci_device_id  const  *)ldvarg434);
#line 1590
      if (ldv_retval_4 == 0) {
#line 1591
        ldv_state_variable_36 = 2;
#line 1592
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1596
    goto ldv_59929;
    case 3: ;
#line 1599
    if (ldv_state_variable_36 == 4) {
#line 1601
      ixgbe_shutdown(ixgbe_driver_group1);
#line 1602
      ldv_state_variable_36 = 4;
    } else {

    }
#line 1605
    if (ldv_state_variable_36 == 3) {
#line 1607
      ixgbe_shutdown(ixgbe_driver_group1);
#line 1608
      ldv_state_variable_36 = 3;
    } else {

    }
#line 1611
    if (ldv_state_variable_36 == 2) {
#line 1613
      ixgbe_shutdown(ixgbe_driver_group1);
#line 1614
      ldv_state_variable_36 = 2;
    } else {

    }
#line 1617
    if (ldv_state_variable_36 == 5) {
#line 1619
      ixgbe_shutdown(ixgbe_driver_group1);
#line 1620
      ldv_state_variable_36 = 5;
    } else {

    }
#line 1623
    goto ldv_59929;
    case 4: ;
#line 1626
    if (ldv_state_variable_36 == 4) {
#line 1628
      ixgbe_pci_sriov_configure(ixgbe_driver_group1, ldvarg433);
#line 1630
      ldv_state_variable_36 = 4;
    } else {

    }
#line 1633
    if (ldv_state_variable_36 == 1) {
#line 1635
      ixgbe_pci_sriov_configure(ixgbe_driver_group1, ldvarg433);
#line 1637
      ldv_state_variable_36 = 1;
    } else {

    }
#line 1640
    if (ldv_state_variable_36 == 3) {
#line 1642
      ixgbe_pci_sriov_configure(ixgbe_driver_group1, ldvarg433);
#line 1644
      ldv_state_variable_36 = 3;
    } else {

    }
#line 1647
    if (ldv_state_variable_36 == 2) {
#line 1649
      ixgbe_pci_sriov_configure(ixgbe_driver_group1, ldvarg433);
#line 1651
      ldv_state_variable_36 = 2;
    } else {

    }
#line 1654
    if (ldv_state_variable_36 == 5) {
#line 1656
      ixgbe_pci_sriov_configure(ixgbe_driver_group1, ldvarg433);
#line 1658
      ldv_state_variable_36 = 5;
    } else {

    }
#line 1661
    goto ldv_59929;
    case 5: ;
#line 1664
    if (ldv_state_variable_36 == 4) {
#line 1666
      ixgbe_remove(ixgbe_driver_group1);
#line 1667
      ldv_state_variable_36 = 1;
    } else {

    }
#line 1670
    if (ldv_state_variable_36 == 3) {
#line 1672
      ixgbe_remove(ixgbe_driver_group1);
#line 1673
      ldv_state_variable_36 = 1;
    } else {

    }
#line 1676
    if (ldv_state_variable_36 == 2) {
#line 1678
      ixgbe_remove(ixgbe_driver_group1);
#line 1679
      ldv_state_variable_36 = 1;
    } else {

    }
#line 1682
    if (ldv_state_variable_36 == 5) {
#line 1684
      ixgbe_remove(ixgbe_driver_group1);
#line 1685
      ldv_state_variable_36 = 1;
    } else {

    }
#line 1688
    goto ldv_59929;
    case 6: ;
#line 1691
    if (ldv_state_variable_36 == 3) {
#line 1693
      ldv_retval_3 = ldv_suspend_late_36();
#line 1694
      if (ldv_retval_3 == 0) {
#line 1695
        ldv_state_variable_36 = 4;
      } else {

      }
    } else {

    }
#line 1699
    goto ldv_59929;
    case 7: ;
#line 1702
    if (ldv_state_variable_36 == 4) {
#line 1704
      ldv_retval_2 = ldv_resume_early_36();
#line 1705
      if (ldv_retval_2 == 0) {
#line 1706
        ldv_state_variable_36 = 5;
      } else {

      }
    } else {

    }
#line 1710
    if (ldv_state_variable_36 == 3) {
#line 1712
      ldv_retval_2 = ldv_resume_early_36();
#line 1713
      if (ldv_retval_2 == 0) {
#line 1714
        ldv_state_variable_36 = 5;
      } else {

      }
    } else {

    }
#line 1718
    goto ldv_59929;
    default: 
#line 1719
    ldv_stop();
    }
    ldv_59929: ;
  } else {

  }
#line 1723
  goto ldv_59891;
  case 29: ;
#line 1727
  if (ldv_state_variable_3 != 0) {
#line 1728
    choose_interrupt_3();
  } else {

  }
#line 1731
  goto ldv_59891;
  case 30: ;
#line 1738
  goto ldv_59891;
  case 31: ;
#line 1742
  if (ldv_state_variable_12 != 0) {
#line 1743
    ldv_main_exported_12();
  } else {

  }
#line 1746
  goto ldv_59891;
  case 32: ;
#line 1750
  if (ldv_state_variable_15 != 0) {
#line 1751
    ldv_main_exported_15();
  } else {

  }
#line 1754
  goto ldv_59891;
  case 33: ;
#line 1758
  if (ldv_state_variable_38 != 0) {
#line 1759
    tmp___25 = __VERIFIER_nondet_int();
#line 1759
    switch (tmp___25) {
    case 0: ;
#line 1762
    if (ldv_state_variable_38 == 1) {
#line 1764
      ixgbe_ioctl(ixgbe_netdev_ops_group1, ldvarg500, ldvarg499);
#line 1766
      ldv_state_variable_38 = 1;
    } else {

    }
#line 1769
    if (ldv_state_variable_38 == 3) {
#line 1771
      ixgbe_ioctl(ixgbe_netdev_ops_group1, ldvarg500, ldvarg499);
#line 1773
      ldv_state_variable_38 = 3;
    } else {

    }
#line 1776
    if (ldv_state_variable_38 == 2) {
#line 1778
      ixgbe_ioctl(ixgbe_netdev_ops_group1, ldvarg500, ldvarg499);
#line 1780
      ldv_state_variable_38 = 2;
    } else {

    }
#line 1783
    goto ldv_59944;
    case 1: ;
#line 1786
    if (ldv_state_variable_38 == 1) {
#line 1788
      ixgbe_ndo_get_vf_config(ixgbe_netdev_ops_group1, ldvarg498, ldvarg497);
#line 1790
      ldv_state_variable_38 = 1;
    } else {

    }
#line 1793
    if (ldv_state_variable_38 == 3) {
#line 1795
      ixgbe_ndo_get_vf_config(ixgbe_netdev_ops_group1, ldvarg498, ldvarg497);
#line 1797
      ldv_state_variable_38 = 3;
    } else {

    }
#line 1800
    if (ldv_state_variable_38 == 2) {
#line 1802
      ixgbe_ndo_get_vf_config(ixgbe_netdev_ops_group1, ldvarg498, ldvarg497);
#line 1804
      ldv_state_variable_38 = 2;
    } else {

    }
#line 1807
    goto ldv_59944;
    case 2: ;
#line 1810
    if (ldv_state_variable_38 == 2) {
#line 1812
      ldv_retval_9 = ixgbe_open(ixgbe_netdev_ops_group1);
#line 1813
      if (ldv_retval_9 == 0) {
#line 1814
        ldv_state_variable_38 = 3;
      } else {

      }
    } else {

    }
#line 1818
    goto ldv_59944;
    case 3: ;
#line 1821
    if (ldv_state_variable_38 == 3) {
#line 1823
      ixgbe_xmit_frame(ldvarg496, ixgbe_netdev_ops_group1);
#line 1825
      ldv_state_variable_38 = 3;
    } else {

    }
#line 1828
    goto ldv_59944;
    case 4: ;
#line 1831
    if (ldv_state_variable_38 == 1) {
#line 1833
      ixgbe_ndo_set_vf_spoofchk(ixgbe_netdev_ops_group1, ldvarg495, (int )ldvarg494);
#line 1835
      ldv_state_variable_38 = 1;
    } else {

    }
#line 1838
    if (ldv_state_variable_38 == 3) {
#line 1840
      ixgbe_ndo_set_vf_spoofchk(ixgbe_netdev_ops_group1, ldvarg495, (int )ldvarg494);
#line 1842
      ldv_state_variable_38 = 3;
    } else {

    }
#line 1845
    if (ldv_state_variable_38 == 2) {
#line 1847
      ixgbe_ndo_set_vf_spoofchk(ixgbe_netdev_ops_group1, ldvarg495, (int )ldvarg494);
#line 1849
      ldv_state_variable_38 = 2;
    } else {

    }
#line 1852
    goto ldv_59944;
    case 5: ;
#line 1855
    if (ldv_state_variable_38 == 1) {
#line 1857
      ixgbe_fix_features(ixgbe_netdev_ops_group1, ldvarg493);
#line 1859
      ldv_state_variable_38 = 1;
    } else {

    }
#line 1862
    if (ldv_state_variable_38 == 3) {
#line 1864
      ixgbe_fix_features(ixgbe_netdev_ops_group1, ldvarg493);
#line 1866
      ldv_state_variable_38 = 3;
    } else {

    }
#line 1869
    if (ldv_state_variable_38 == 2) {
#line 1871
      ixgbe_fix_features(ixgbe_netdev_ops_group1, ldvarg493);
#line 1873
      ldv_state_variable_38 = 2;
    } else {

    }
#line 1876
    goto ldv_59944;
    case 6: ;
#line 1879
    if (ldv_state_variable_38 == 3) {
#line 1881
      ixgbe_close(ixgbe_netdev_ops_group1);
#line 1882
      ldv_state_variable_38 = 2;
    } else {

    }
#line 1885
    goto ldv_59944;
    case 7: ;
#line 1888
    if (ldv_state_variable_38 == 1) {
#line 1890
      ixgbe_set_rx_mode(ixgbe_netdev_ops_group1);
#line 1892
      ldv_state_variable_38 = 1;
    } else {

    }
#line 1895
    if (ldv_state_variable_38 == 3) {
#line 1897
      ixgbe_set_rx_mode(ixgbe_netdev_ops_group1);
#line 1899
      ldv_state_variable_38 = 3;
    } else {

    }
#line 1902
    if (ldv_state_variable_38 == 2) {
#line 1904
      ixgbe_set_rx_mode(ixgbe_netdev_ops_group1);
#line 1906
      ldv_state_variable_38 = 2;
    } else {

    }
#line 1909
    goto ldv_59944;
    case 8: ;
#line 1912
    if (ldv_state_variable_38 == 1) {
#line 1914
      eth_validate_addr(ixgbe_netdev_ops_group1);
#line 1916
      ldv_state_variable_38 = 1;
    } else {

    }
#line 1919
    if (ldv_state_variable_38 == 3) {
#line 1921
      eth_validate_addr(ixgbe_netdev_ops_group1);
#line 1923
      ldv_state_variable_38 = 3;
    } else {

    }
#line 1926
    if (ldv_state_variable_38 == 2) {
#line 1928
      eth_validate_addr(ixgbe_netdev_ops_group1);
#line 1930
      ldv_state_variable_38 = 2;
    } else {

    }
#line 1933
    goto ldv_59944;
    case 9: ;
#line 1936
    if (ldv_state_variable_38 == 1) {
#line 1938
      ixgbe_fcoe_ddp_put(ixgbe_netdev_ops_group1, (int )ldvarg492);
#line 1940
      ldv_state_variable_38 = 1;
    } else {

    }
#line 1943
    if (ldv_state_variable_38 == 3) {
#line 1945
      ixgbe_fcoe_ddp_put(ixgbe_netdev_ops_group1, (int )ldvarg492);
#line 1947
      ldv_state_variable_38 = 3;
    } else {

    }
#line 1950
    if (ldv_state_variable_38 == 2) {
#line 1952
      ixgbe_fcoe_ddp_put(ixgbe_netdev_ops_group1, (int )ldvarg492);
#line 1954
      ldv_state_variable_38 = 2;
    } else {

    }
#line 1957
    goto ldv_59944;
    case 10: ;
#line 1960
    if (ldv_state_variable_38 == 1) {
#line 1962
      ixgbe_ndo_set_vf_vlan(ixgbe_netdev_ops_group1, ldvarg491, (int )ldvarg490, (int )ldvarg489);
#line 1964
      ldv_state_variable_38 = 1;
    } else {

    }
#line 1967
    if (ldv_state_variable_38 == 3) {
#line 1969
      ixgbe_ndo_set_vf_vlan(ixgbe_netdev_ops_group1, ldvarg491, (int )ldvarg490, (int )ldvarg489);
#line 1971
      ldv_state_variable_38 = 3;
    } else {

    }
#line 1974
    if (ldv_state_variable_38 == 2) {
#line 1976
      ixgbe_ndo_set_vf_vlan(ixgbe_netdev_ops_group1, ldvarg491, (int )ldvarg490, (int )ldvarg489);
#line 1978
      ldv_state_variable_38 = 2;
    } else {

    }
#line 1981
    goto ldv_59944;
    case 11: ;
#line 1984
    if (ldv_state_variable_38 == 1) {
#line 1986
      ixgbe_fwd_del(ixgbe_netdev_ops_group1, ldvarg488);
#line 1988
      ldv_state_variable_38 = 1;
    } else {

    }
#line 1991
    if (ldv_state_variable_38 == 3) {
#line 1993
      ixgbe_fwd_del(ixgbe_netdev_ops_group1, ldvarg488);
#line 1995
      ldv_state_variable_38 = 3;
    } else {

    }
#line 1998
    if (ldv_state_variable_38 == 2) {
#line 2000
      ixgbe_fwd_del(ixgbe_netdev_ops_group1, ldvarg488);
#line 2002
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2005
    goto ldv_59944;
    case 12: ;
#line 2008
    if (ldv_state_variable_38 == 1) {
#line 2010
      ixgbe_fcoe_get_hbainfo(ixgbe_netdev_ops_group1, ldvarg487);
#line 2012
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2015
    if (ldv_state_variable_38 == 3) {
#line 2017
      ixgbe_fcoe_get_hbainfo(ixgbe_netdev_ops_group1, ldvarg487);
#line 2019
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2022
    if (ldv_state_variable_38 == 2) {
#line 2024
      ixgbe_fcoe_get_hbainfo(ixgbe_netdev_ops_group1, ldvarg487);
#line 2026
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2029
    goto ldv_59944;
    case 13: ;
#line 2032
    if (ldv_state_variable_38 == 3) {
#line 2034
      ixgbe_change_mtu(ixgbe_netdev_ops_group1, ldvarg486);
#line 2036
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2039
    if (ldv_state_variable_38 == 2) {
#line 2041
      ixgbe_change_mtu(ixgbe_netdev_ops_group1, ldvarg486);
#line 2043
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2046
    goto ldv_59944;
    case 14: ;
#line 2049
    if (ldv_state_variable_38 == 1) {
#line 2051
      ixgbe_ndo_set_vf_mac(ixgbe_netdev_ops_group1, ldvarg485, ldvarg484);
#line 2053
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2056
    if (ldv_state_variable_38 == 3) {
#line 2058
      ixgbe_ndo_set_vf_mac(ixgbe_netdev_ops_group1, ldvarg485, ldvarg484);
#line 2060
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2063
    if (ldv_state_variable_38 == 2) {
#line 2065
      ixgbe_ndo_set_vf_mac(ixgbe_netdev_ops_group1, ldvarg485, ldvarg484);
#line 2067
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2070
    goto ldv_59944;
    case 15: ;
#line 2073
    if (ldv_state_variable_38 == 1) {
#line 2075
      ixgbe_ndo_set_vf_bw(ixgbe_netdev_ops_group1, ldvarg483, ldvarg482, ldvarg481);
#line 2077
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2080
    if (ldv_state_variable_38 == 3) {
#line 2082
      ixgbe_ndo_set_vf_bw(ixgbe_netdev_ops_group1, ldvarg483, ldvarg482, ldvarg481);
#line 2084
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2087
    if (ldv_state_variable_38 == 2) {
#line 2089
      ixgbe_ndo_set_vf_bw(ixgbe_netdev_ops_group1, ldvarg483, ldvarg482, ldvarg481);
#line 2091
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2094
    goto ldv_59944;
    case 16: ;
#line 2097
    if (ldv_state_variable_38 == 1) {
#line 2099
      ixgbe_vlan_rx_kill_vid(ixgbe_netdev_ops_group1, (int )ldvarg480, (int )ldvarg479);
#line 2101
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2104
    if (ldv_state_variable_38 == 3) {
#line 2106
      ixgbe_vlan_rx_kill_vid(ixgbe_netdev_ops_group1, (int )ldvarg480, (int )ldvarg479);
#line 2108
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2111
    if (ldv_state_variable_38 == 2) {
#line 2113
      ixgbe_vlan_rx_kill_vid(ixgbe_netdev_ops_group1, (int )ldvarg480, (int )ldvarg479);
#line 2115
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2118
    goto ldv_59944;
    case 17: ;
#line 2121
    if (ldv_state_variable_38 == 1) {
#line 2123
      ixgbe_ndo_bridge_setlink(ixgbe_netdev_ops_group1, ldvarg478, (int )ldvarg477);
#line 2125
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2128
    if (ldv_state_variable_38 == 3) {
#line 2130
      ixgbe_ndo_bridge_setlink(ixgbe_netdev_ops_group1, ldvarg478, (int )ldvarg477);
#line 2132
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2135
    if (ldv_state_variable_38 == 2) {
#line 2137
      ixgbe_ndo_bridge_setlink(ixgbe_netdev_ops_group1, ldvarg478, (int )ldvarg477);
#line 2139
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2142
    goto ldv_59944;
    case 18: ;
#line 2145
    if (ldv_state_variable_38 == 1) {
#line 2147
      ixgbe_vlan_rx_add_vid(ixgbe_netdev_ops_group1, (int )ldvarg476, (int )ldvarg475);
#line 2149
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2152
    if (ldv_state_variable_38 == 3) {
#line 2154
      ixgbe_vlan_rx_add_vid(ixgbe_netdev_ops_group1, (int )ldvarg476, (int )ldvarg475);
#line 2156
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2159
    if (ldv_state_variable_38 == 2) {
#line 2161
      ixgbe_vlan_rx_add_vid(ixgbe_netdev_ops_group1, (int )ldvarg476, (int )ldvarg475);
#line 2163
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2166
    goto ldv_59944;
    case 19: ;
#line 2169
    if (ldv_state_variable_38 == 1) {
#line 2171
      ixgbe_fwd_add(ixgbe_netdev_ops_group1, ixgbe_netdev_ops_group1);
#line 2173
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2176
    if (ldv_state_variable_38 == 3) {
#line 2178
      ixgbe_fwd_add(ixgbe_netdev_ops_group1, ixgbe_netdev_ops_group1);
#line 2180
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2183
    if (ldv_state_variable_38 == 2) {
#line 2185
      ixgbe_fwd_add(ixgbe_netdev_ops_group1, ixgbe_netdev_ops_group1);
#line 2187
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2190
    goto ldv_59944;
    case 20: ;
#line 2193
    if (ldv_state_variable_38 == 1) {
#line 2195
      ixgbe_fcoe_ddp_target(ixgbe_netdev_ops_group1, (int )ldvarg474, ldvarg473, ldvarg472);
#line 2197
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2200
    if (ldv_state_variable_38 == 3) {
#line 2202
      ixgbe_fcoe_ddp_target(ixgbe_netdev_ops_group1, (int )ldvarg474, ldvarg473, ldvarg472);
#line 2204
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2207
    if (ldv_state_variable_38 == 2) {
#line 2209
      ixgbe_fcoe_ddp_target(ixgbe_netdev_ops_group1, (int )ldvarg474, ldvarg473, ldvarg472);
#line 2211
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2214
    goto ldv_59944;
    case 21: ;
#line 2217
    if (ldv_state_variable_38 == 1) {
#line 2219
      ixgbe_fcoe_enable(ixgbe_netdev_ops_group1);
#line 2221
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2224
    if (ldv_state_variable_38 == 3) {
#line 2226
      ixgbe_fcoe_enable(ixgbe_netdev_ops_group1);
#line 2228
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2231
    if (ldv_state_variable_38 == 2) {
#line 2233
      ixgbe_fcoe_enable(ixgbe_netdev_ops_group1);
#line 2235
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2238
    goto ldv_59944;
    case 22: ;
#line 2241
    if (ldv_state_variable_38 == 1) {
#line 2243
      ixgbe_ndo_bridge_getlink(ldvarg468, ldvarg470, ldvarg469, ixgbe_netdev_ops_group1,
                               ldvarg471, ldvarg467);
#line 2245
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2248
    if (ldv_state_variable_38 == 3) {
#line 2250
      ixgbe_ndo_bridge_getlink(ldvarg468, ldvarg470, ldvarg469, ixgbe_netdev_ops_group1,
                               ldvarg471, ldvarg467);
#line 2252
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2255
    if (ldv_state_variable_38 == 2) {
#line 2257
      ixgbe_ndo_bridge_getlink(ldvarg468, ldvarg470, ldvarg469, ixgbe_netdev_ops_group1,
                               ldvarg471, ldvarg467);
#line 2259
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2262
    goto ldv_59944;
    case 23: ;
#line 2265
    if (ldv_state_variable_38 == 1) {
#line 2267
      ixgbe_fcoe_ddp_get(ixgbe_netdev_ops_group1, (int )ldvarg466, ldvarg465, ldvarg464);
#line 2269
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2272
    if (ldv_state_variable_38 == 3) {
#line 2274
      ixgbe_fcoe_ddp_get(ixgbe_netdev_ops_group1, (int )ldvarg466, ldvarg465, ldvarg464);
#line 2276
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2279
    if (ldv_state_variable_38 == 2) {
#line 2281
      ixgbe_fcoe_ddp_get(ixgbe_netdev_ops_group1, (int )ldvarg466, ldvarg465, ldvarg464);
#line 2283
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2286
    goto ldv_59944;
    case 24: ;
#line 2289
    if (ldv_state_variable_38 == 1) {
#line 2291
      ixgbe_fcoe_get_wwn(ixgbe_netdev_ops_group1, ldvarg463, ldvarg462);
#line 2293
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2296
    if (ldv_state_variable_38 == 3) {
#line 2298
      ixgbe_fcoe_get_wwn(ixgbe_netdev_ops_group1, ldvarg463, ldvarg462);
#line 2300
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2303
    if (ldv_state_variable_38 == 2) {
#line 2305
      ixgbe_fcoe_get_wwn(ixgbe_netdev_ops_group1, ldvarg463, ldvarg462);
#line 2307
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2310
    goto ldv_59944;
    case 25: ;
#line 2313
    if (ldv_state_variable_38 == 1) {
#line 2315
      ixgbe_low_latency_recv(ldvarg461);
#line 2317
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2320
    if (ldv_state_variable_38 == 3) {
#line 2322
      ixgbe_low_latency_recv(ldvarg461);
#line 2324
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2327
    if (ldv_state_variable_38 == 2) {
#line 2329
      ixgbe_low_latency_recv(ldvarg461);
#line 2331
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2334
    goto ldv_59944;
    case 26: ;
#line 2337
    if (ldv_state_variable_38 == 1) {
#line 2339
      ixgbe_del_vxlan_port(ixgbe_netdev_ops_group1, (int )ldvarg460, (int )ldvarg459);
#line 2341
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2344
    if (ldv_state_variable_38 == 3) {
#line 2346
      ixgbe_del_vxlan_port(ixgbe_netdev_ops_group1, (int )ldvarg460, (int )ldvarg459);
#line 2348
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2351
    if (ldv_state_variable_38 == 2) {
#line 2353
      ixgbe_del_vxlan_port(ixgbe_netdev_ops_group1, (int )ldvarg460, (int )ldvarg459);
#line 2355
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2358
    goto ldv_59944;
    case 27: ;
#line 2361
    if (ldv_state_variable_38 == 1) {
#line 2363
      ixgbe_netpoll(ixgbe_netdev_ops_group1);
#line 2365
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2368
    if (ldv_state_variable_38 == 3) {
#line 2370
      ixgbe_netpoll(ixgbe_netdev_ops_group1);
#line 2372
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2375
    if (ldv_state_variable_38 == 2) {
#line 2377
      ixgbe_netpoll(ixgbe_netdev_ops_group1);
#line 2379
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2382
    goto ldv_59944;
    case 28: ;
#line 2385
    if (ldv_state_variable_38 == 1) {
#line 2387
      ixgbe_ndo_fdb_add(ldvarg456, ldvarg457, ixgbe_netdev_ops_group1, (unsigned char const   *)ldvarg455,
                        (int )ldvarg458, (int )ldvarg454);
#line 2389
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2392
    if (ldv_state_variable_38 == 3) {
#line 2394
      ixgbe_ndo_fdb_add(ldvarg456, ldvarg457, ixgbe_netdev_ops_group1, (unsigned char const   *)ldvarg455,
                        (int )ldvarg458, (int )ldvarg454);
#line 2396
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2399
    if (ldv_state_variable_38 == 2) {
#line 2401
      ixgbe_ndo_fdb_add(ldvarg456, ldvarg457, ixgbe_netdev_ops_group1, (unsigned char const   *)ldvarg455,
                        (int )ldvarg458, (int )ldvarg454);
#line 2403
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2406
    goto ldv_59944;
    case 29: ;
#line 2409
    if (ldv_state_variable_38 == 1) {
#line 2411
      ixgbe_ndo_set_vf_rss_query_en(ixgbe_netdev_ops_group1, ldvarg453, (int )ldvarg452);
#line 2413
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2416
    if (ldv_state_variable_38 == 3) {
#line 2418
      ixgbe_ndo_set_vf_rss_query_en(ixgbe_netdev_ops_group1, ldvarg453, (int )ldvarg452);
#line 2420
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2423
    if (ldv_state_variable_38 == 2) {
#line 2425
      ixgbe_ndo_set_vf_rss_query_en(ixgbe_netdev_ops_group1, ldvarg453, (int )ldvarg452);
#line 2427
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2430
    goto ldv_59944;
    case 30: ;
#line 2433
    if (ldv_state_variable_38 == 1) {
#line 2435
      ixgbe_select_queue(ixgbe_netdev_ops_group1, ldvarg451, ldvarg450, ldvarg449);
#line 2437
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2440
    if (ldv_state_variable_38 == 3) {
#line 2442
      ixgbe_select_queue(ixgbe_netdev_ops_group1, ldvarg451, ldvarg450, ldvarg449);
#line 2444
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2447
    if (ldv_state_variable_38 == 2) {
#line 2449
      ixgbe_select_queue(ixgbe_netdev_ops_group1, ldvarg451, ldvarg450, ldvarg449);
#line 2451
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2454
    goto ldv_59944;
    case 31: ;
#line 2457
    if (ldv_state_variable_38 == 1) {
#line 2459
      ixgbe_add_vxlan_port(ixgbe_netdev_ops_group1, (int )ldvarg448, (int )ldvarg447);
#line 2461
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2464
    if (ldv_state_variable_38 == 3) {
#line 2466
      ixgbe_add_vxlan_port(ixgbe_netdev_ops_group1, (int )ldvarg448, (int )ldvarg447);
#line 2468
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2471
    if (ldv_state_variable_38 == 2) {
#line 2473
      ixgbe_add_vxlan_port(ixgbe_netdev_ops_group1, (int )ldvarg448, (int )ldvarg447);
#line 2475
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2478
    goto ldv_59944;
    case 32: ;
#line 2481
    if (ldv_state_variable_38 == 1) {
#line 2483
      ixgbe_set_features(ixgbe_netdev_ops_group1, ldvarg446);
#line 2485
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2488
    if (ldv_state_variable_38 == 3) {
#line 2490
      ixgbe_set_features(ixgbe_netdev_ops_group1, ldvarg446);
#line 2492
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2495
    if (ldv_state_variable_38 == 2) {
#line 2497
      ixgbe_set_features(ixgbe_netdev_ops_group1, ldvarg446);
#line 2499
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2502
    goto ldv_59944;
    case 33: ;
#line 2505
    if (ldv_state_variable_38 == 1) {
#line 2507
      ixgbe_fcoe_disable(ixgbe_netdev_ops_group1);
#line 2509
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2512
    if (ldv_state_variable_38 == 3) {
#line 2514
      ixgbe_fcoe_disable(ixgbe_netdev_ops_group1);
#line 2516
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2519
    if (ldv_state_variable_38 == 2) {
#line 2521
      ixgbe_fcoe_disable(ixgbe_netdev_ops_group1);
#line 2523
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2526
    goto ldv_59944;
    case 34: ;
#line 2529
    if (ldv_state_variable_38 == 1) {
#line 2531
      ixgbe_set_mac(ixgbe_netdev_ops_group1, ldvarg445);
#line 2533
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2536
    if (ldv_state_variable_38 == 3) {
#line 2538
      ixgbe_set_mac(ixgbe_netdev_ops_group1, ldvarg445);
#line 2540
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2543
    if (ldv_state_variable_38 == 2) {
#line 2545
      ixgbe_set_mac(ixgbe_netdev_ops_group1, ldvarg445);
#line 2547
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2550
    goto ldv_59944;
    case 35: ;
#line 2553
    if (ldv_state_variable_38 == 1) {
#line 2555
      ixgbe_setup_tc(ixgbe_netdev_ops_group1, (int )ldvarg444);
#line 2557
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2560
    if (ldv_state_variable_38 == 3) {
#line 2562
      ixgbe_setup_tc(ixgbe_netdev_ops_group1, (int )ldvarg444);
#line 2564
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2567
    if (ldv_state_variable_38 == 2) {
#line 2569
      ixgbe_setup_tc(ixgbe_netdev_ops_group1, (int )ldvarg444);
#line 2571
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2574
    goto ldv_59944;
    case 36: ;
#line 2577
    if (ldv_state_variable_38 == 1) {
#line 2579
      ixgbe_get_stats64(ixgbe_netdev_ops_group1, ldvarg443);
#line 2581
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2584
    if (ldv_state_variable_38 == 3) {
#line 2586
      ixgbe_get_stats64(ixgbe_netdev_ops_group1, ldvarg443);
#line 2588
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2591
    if (ldv_state_variable_38 == 2) {
#line 2593
      ixgbe_get_stats64(ixgbe_netdev_ops_group1, ldvarg443);
#line 2595
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2598
    goto ldv_59944;
    case 37: ;
#line 2601
    if (ldv_state_variable_38 == 1) {
#line 2603
      ixgbe_tx_timeout(ixgbe_netdev_ops_group1);
#line 2605
      ldv_state_variable_38 = 1;
    } else {

    }
#line 2608
    if (ldv_state_variable_38 == 3) {
#line 2610
      ixgbe_tx_timeout(ixgbe_netdev_ops_group1);
#line 2612
      ldv_state_variable_38 = 3;
    } else {

    }
#line 2615
    if (ldv_state_variable_38 == 2) {
#line 2617
      ixgbe_tx_timeout(ixgbe_netdev_ops_group1);
#line 2619
      ldv_state_variable_38 = 2;
    } else {

    }
#line 2622
    goto ldv_59944;
    case 38: ;
#line 2625
    if (ldv_state_variable_38 == 1) {
#line 2627
      ldv_retval_8 = ldv_ndo_init_38();
#line 2628
      if (ldv_retval_8 == 0) {
#line 2629
        ldv_state_variable_38 = 2;
#line 2630
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 2634
    goto ldv_59944;
    case 39: ;
#line 2637
    if (ldv_state_variable_38 == 2) {
#line 2639
      ldv_ndo_uninit_38();
#line 2640
      ldv_state_variable_38 = 1;
#line 2641
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 2644
    goto ldv_59944;
    default: 
#line 2645
    ldv_stop();
    }
    ldv_59944: ;
  } else {

  }
#line 2649
  goto ldv_59891;
  case 34: ;
#line 2653
  if (ldv_state_variable_8 != 0) {
#line 2654
    invoke_work_8();
  } else {

  }
#line 2657
  goto ldv_59891;
  case 35: ;
#line 2661
  if (ldv_state_variable_4 != 0) {
#line 2662
    choose_interrupt_4();
  } else {

  }
#line 2665
  goto ldv_59891;
  case 36: ;
#line 2669
  if (ldv_state_variable_34 != 0) {
#line 2670
    ldv_main_exported_34();
  } else {

  }
#line 2673
  goto ldv_59891;
  case 37: ;
#line 2677
  if (ldv_state_variable_37 != 0) {
#line 2678
    tmp___26 = __VERIFIER_nondet_int();
#line 2678
    switch (tmp___26) {
    case 0: ;
#line 2681
    if (ldv_state_variable_37 == 3) {
#line 2683
      ixgbe_io_resume(ixgbe_err_handler_group0);
#line 2685
      ldv_state_variable_37 = 2;
    } else {

    }
#line 2688
    goto ldv_59990;
    case 1: ;
#line 2691
    if (ldv_state_variable_37 == 1) {
#line 2693
      ixgbe_io_slot_reset(ixgbe_err_handler_group0);
#line 2695
      ldv_state_variable_37 = 1;
    } else {

    }
#line 2698
    if (ldv_state_variable_37 == 3) {
#line 2700
      ixgbe_io_slot_reset(ixgbe_err_handler_group0);
#line 2702
      ldv_state_variable_37 = 3;
    } else {

    }
#line 2705
    if (ldv_state_variable_37 == 2) {
#line 2707
      ixgbe_io_slot_reset(ixgbe_err_handler_group0);
#line 2709
      ldv_state_variable_37 = 2;
    } else {

    }
#line 2712
    goto ldv_59990;
    case 2: ;
#line 2715
    if (ldv_state_variable_37 == 1) {
#line 2717
      ixgbe_io_error_detected(ixgbe_err_handler_group0, (pci_channel_state_t )ldvarg553);
#line 2719
      ldv_state_variable_37 = 1;
    } else {

    }
#line 2722
    if (ldv_state_variable_37 == 3) {
#line 2724
      ixgbe_io_error_detected(ixgbe_err_handler_group0, (pci_channel_state_t )ldvarg553);
#line 2726
      ldv_state_variable_37 = 3;
    } else {

    }
#line 2729
    if (ldv_state_variable_37 == 2) {
#line 2731
      ixgbe_io_error_detected(ixgbe_err_handler_group0, (pci_channel_state_t )ldvarg553);
#line 2733
      ldv_state_variable_37 = 2;
    } else {

    }
#line 2736
    goto ldv_59990;
    case 3: ;
#line 2739
    if (ldv_state_variable_37 == 2) {
#line 2741
      ldv_suspend_37();
#line 2743
      ldv_state_variable_37 = 3;
    } else {

    }
#line 2746
    goto ldv_59990;
    case 4: ;
#line 2749
    if (ldv_state_variable_37 == 3) {
#line 2751
      ldv_release_37();
#line 2753
      ldv_state_variable_37 = 1;
#line 2754
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 2757
    if (ldv_state_variable_37 == 2) {
#line 2759
      ldv_release_37();
#line 2761
      ldv_state_variable_37 = 1;
#line 2762
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 2765
    goto ldv_59990;
    case 5: ;
#line 2768
    if (ldv_state_variable_37 == 1) {
#line 2770
      ldv_probe_37();
#line 2772
      ldv_state_variable_37 = 2;
#line 2773
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 2776
    goto ldv_59990;
    default: 
#line 2777
    ldv_stop();
    }
    ldv_59990: ;
  } else {

  }
#line 2781
  goto ldv_59891;
  case 38: ;
#line 2785
  if (ldv_state_variable_19 != 0) {
#line 2786
    ldv_main_exported_19();
  } else {

  }
#line 2789
  goto ldv_59891;
  case 39: ;
#line 2796
  goto ldv_59891;
  default: 
#line 2797
  ldv_stop();
  }
  ldv_59891: ;
#line 2799
  goto ldv_60000;
  ldv_final: 
#line 2801
  ldv_check_final_state();
#line 2802
  return;
}
}
#line 2805 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
#line 2808
  tmp = ldv_err_ptr(error);
#line 2808
  return (tmp);
}
}
#line 2829 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 2833
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 2833
  ldv_func_res = tmp;
#line 2835
  activate_work_9(ldv_func_arg3, 2);
#line 2837
  return (ldv_func_res);
}
}
#line 2840 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 2844
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 2844
  ldv_func_res = tmp;
#line 2846
  activate_work_9(& ldv_func_arg3->work, 2);
#line 2848
  return (ldv_func_res);
}
}
#line 2851 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 2855
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 2855
  ldv_func_res = tmp;
#line 2857
  activate_work_9(ldv_func_arg3, 2);
#line 2859
  return (ldv_func_res);
}
}
#line 2862 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 2865
  flush_workqueue(ldv_func_arg1);
#line 2867
  call_and_disable_all_9(2);
#line 2868
  return;
}
}
#line 2870 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 2874
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 2874
  ldv_func_res = tmp;
#line 2876
  activate_work_9(& ldv_func_arg3->work, 2);
#line 2878
  return (ldv_func_res);
}
}
#line 2881 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2884
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 2886
  mutex_lock(ldv_func_arg1);
#line 2887
  return;
}
}
#line 2889 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2892
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 2894
  mutex_unlock(ldv_func_arg1);
#line 2895
  return;
}
}
#line 2897 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2900
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 2902
  mutex_lock(ldv_func_arg1);
#line 2903
  return;
}
}
#line 2905 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_mutex_trylock_13(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2909
  tmp = mutex_trylock(ldv_func_arg1);
#line 2909
  ldv_func_res = tmp;
#line 2911
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 2911
  return (tmp___0);
#line 2913
  return (ldv_func_res);
}
}
#line 2916 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2919
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 2921
  mutex_unlock(ldv_func_arg1);
#line 2922
  return;
}
}
#line 2924 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_mutex_unlock_15(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2927
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 2929
  mutex_unlock(ldv_func_arg1);
#line 2930
  return;
}
}
#line 2932 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_mutex_lock_16(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2935
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 2937
  mutex_lock(ldv_func_arg1);
#line 2938
  return;
}
}
#line 2940 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
__inline static int ldv_request_irq_17(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2944
  tmp = request_irq(irq, handler, flags, name, dev);
#line 2944
  ldv_func_res = tmp;
#line 2946
  tmp___0 = reg_check_7(handler);
#line 2946
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 2947
    activate_suitable_irq_7((int )irq, dev);
  } else {

  }
#line 2950
  return (ldv_func_res);
}
}
#line 2953 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
__inline static int ldv_request_irq_18(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2957
  tmp = request_irq(irq, handler, flags, name, dev);
#line 2957
  ldv_func_res = tmp;
#line 2959
  tmp___0 = reg_check_7(handler);
#line 2959
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 2960
    activate_suitable_irq_7((int )irq, dev);
  } else {

  }
#line 2963
  return (ldv_func_res);
}
}
#line 2966 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_free_irq_19(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 2969
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 2971
  disable_suitable_irq_7((int )ldv_func_arg1, ldv_func_arg2);
#line 2972
  return;
}
}
#line 2974 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
__inline static int ldv_request_irq_20(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2978
  tmp = request_irq(irq, handler, flags, name, dev);
#line 2978
  ldv_func_res = tmp;
#line 2980
  tmp___0 = reg_check_7(handler);
#line 2980
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 2981
    activate_suitable_irq_7((int )irq, dev);
  } else {

  }
#line 2984
  return (ldv_func_res);
}
}
#line 2987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
__inline static int ldv_request_irq_21(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2991
  tmp = request_irq(irq, handler, flags, name, dev);
#line 2991
  ldv_func_res = tmp;
#line 2993
  tmp___0 = reg_check_7(handler);
#line 2993
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 2994
    activate_suitable_irq_7((int )irq, dev);
  } else {

  }
#line 2997
  return (ldv_func_res);
}
}
#line 3000 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_free_irq_22(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 3003
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 3005
  disable_suitable_irq_7((int )ldv_func_arg1, ldv_func_arg2);
#line 3006
  return;
}
}
#line 3008 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_free_irq_23(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 3011
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 3013
  disable_suitable_irq_7((int )ldv_func_arg1, ldv_func_arg2);
#line 3014
  return;
}
}
#line 3016 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_free_irq_24(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 3019
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 3021
  disable_suitable_irq_7((int )ldv_func_arg1, ldv_func_arg2);
#line 3022
  return;
}
}
#line 3024 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_mod_timer_25(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 3028
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3028
  ldv_func_res = tmp;
#line 3030
  activate_pending_timer_10(ldv_func_arg1, ldv_func_arg2, 1);
#line 3032
  return (ldv_func_res);
}
}
#line 3035 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_del_timer_sync_26(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 3039
  tmp = del_timer_sync(ldv_func_arg1);
#line 3039
  ldv_func_res = tmp;
#line 3041
  disable_suitable_timer_10(ldv_func_arg1);
#line 3043
  return (ldv_func_res);
}
}
#line 3046 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_unregister_netdev_27(struct net_device *dev ) 
{ 


  {
#line 3049
  unregister_netdev(dev);
#line 3051
  ldv_state_variable_38 = 0;
#line 3052
  return;
}
}
#line 3054 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_mod_timer_28(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 3058
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3058
  ldv_func_res = tmp;
#line 3060
  activate_pending_timer_10(ldv_func_arg1, ldv_func_arg2, 1);
#line 3062
  return (ldv_func_res);
}
}
#line 3065 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv_register_netdev_29(struct net_device *dev ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 3069
  tmp = register_netdev(dev);
#line 3069
  ldv_func_res = tmp;
#line 3071
  ldv_state_variable_38 = 1;
#line 3072
  ldv_net_device_ops_38();
#line 3075
  return (ldv_func_res);
}
}
#line 3078 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_free_netdev_30(struct net_device *dev ) 
{ 


  {
#line 3081
  free_netdev(dev);
#line 3083
  ldv_state_variable_38 = 0;
#line 3084
  return;
}
}
#line 3086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
bool ldv_cancel_work_sync_31(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  bool tmp ;

  {
#line 3090
  tmp = cancel_work_sync(ldv_func_arg1);
#line 3090
  ldv_func_res = tmp;
#line 3092
  disable_work_9(ldv_func_arg1);
#line 3094
  return (ldv_func_res);
}
}
#line 3097 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_unregister_netdev_32(struct net_device *dev ) 
{ 


  {
#line 3100
  unregister_netdev(dev);
#line 3102
  ldv_state_variable_38 = 0;
#line 3103
  return;
}
}
#line 3105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_free_netdev_33(struct net_device *dev ) 
{ 


  {
#line 3108
  free_netdev(dev);
#line 3110
  ldv_state_variable_38 = 0;
#line 3111
  return;
}
}
#line 3113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
int ldv___pci_register_driver_34(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
#line 3117
  tmp = __pci_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 3117
  ldv_func_res = tmp;
#line 3119
  ldv_state_variable_36 = 1;
#line 3120
  ldv_pci_driver_36();
#line 3123
  return (ldv_func_res);
}
}
#line 3126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.o.c.prepared"
void ldv_pci_unregister_driver_35(struct pci_driver *ldv_func_arg1 ) 
{ 


  {
#line 3129
  pci_unregister_driver(ldv_func_arg1);
#line 3131
  ldv_state_variable_36 = 0;
#line 3132
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_79(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_77(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_80(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_81(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.o.c.prepared"
void ldv_mutex_lock_76(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_78(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_82(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_71(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_73(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_72(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_75(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_74(struct workqueue_struct *ldv_func_arg1 ) ;
#line 35 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
u16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw ) ;
#line 37
s32 ixgbe_init_hw_generic(struct ixgbe_hw *hw ) ;
#line 38
s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw ) ;
#line 39
s32 ixgbe_start_hw_gen2(struct ixgbe_hw *hw ) ;
#line 40
s32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw ) ;
#line 43
s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw , u8 *mac_addr ) ;
#line 46
s32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw ) ;
#line 47
void ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw ) ;
#line 48
s32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw ) ;
#line 50
s32 ixgbe_led_on_generic(struct ixgbe_hw *hw , u32 index ) ;
#line 51
s32 ixgbe_led_off_generic(struct ixgbe_hw *hw , u32 index ) ;
#line 54
s32 ixgbe_write_eeprom_generic(struct ixgbe_hw *hw , u16 offset , u16 data ) ;
#line 55
s32 ixgbe_write_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw , u16 offset ,
                                               u16 words , u16 *data ) ;
#line 57
s32 ixgbe_read_eerd_generic(struct ixgbe_hw *hw , u16 offset , u16 *data ) ;
#line 58
s32 ixgbe_read_eerd_buffer_generic(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                   u16 *data ) ;
#line 60
s32 ixgbe_write_eewr_generic(struct ixgbe_hw *hw , u16 offset , u16 data ) ;
#line 61
s32 ixgbe_write_eewr_buffer_generic(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                    u16 *data ) ;
#line 65
s32 ixgbe_read_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                              u16 *data ) ;
#line 67
s32 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw ) ;
#line 68
s32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw , u16 *checksum_val ) ;
#line 70
s32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw ) ;
#line 72
s32 ixgbe_set_rar_generic(struct ixgbe_hw *hw , u32 index , u8 *addr , u32 vmdq ,
                          u32 enable_addr ) ;
#line 74
s32 ixgbe_clear_rar_generic(struct ixgbe_hw *hw , u32 index ) ;
#line 75
s32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw ) ;
#line 76
s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw , struct net_device *netdev ) ;
#line 78
s32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw ) ;
#line 79
s32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw ) ;
#line 80
s32 ixgbe_disable_rx_buff_generic(struct ixgbe_hw *hw ) ;
#line 81
s32 ixgbe_enable_rx_buff_generic(struct ixgbe_hw *hw ) ;
#line 82
s32 ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw , u32 regval ) ;
#line 83
s32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw ) ;
#line 85
void ixgbe_fc_autoneg(struct ixgbe_hw *hw ) ;
#line 87
s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw , u32 mask ) ;
#line 88
void ixgbe_release_swfw_sync(struct ixgbe_hw *hw , u32 mask ) ;
#line 89
s32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw , u8 *san_mac_addr ) ;
#line 90
s32 ixgbe_set_vmdq_generic(struct ixgbe_hw *hw , u32 rar , u32 vmdq ) ;
#line 91
s32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw , u32 vmdq ) ;
#line 92
s32 ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw , u32 rar , u32 vmdq ) ;
#line 93
s32 ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw ) ;
#line 94
s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw , u32 vlan , u32 vind , bool vlan_on ) ;
#line 96
s32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw ) ;
#line 97
s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw , ixgbe_link_speed *speed , bool *link_up ,
                                 bool link_up_wait_to_complete ) ;
#line 100
s32 ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw , u16 *wwnn_prefix , u16 *wwpn_prefix ) ;
#line 103
s32 prot_autoc_read_generic(struct ixgbe_hw *hw , bool *locked , u32 *reg_val ) ;
#line 104
s32 prot_autoc_write_generic(struct ixgbe_hw *hw , u32 reg_val , bool locked ) ;
#line 106
s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw , u32 index ) ;
#line 107
s32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw , u32 index ) ;
#line 108
void ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw , bool enable , int pf ) ;
#line 109
void ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw , bool enable , int vf ) ;
#line 110
s32 ixgbe_get_device_caps_generic(struct ixgbe_hw *hw , u16 *device_caps ) ;
#line 111
s32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw , u8 maj , u8 min , u8 build ,
                                 u8 sub ) ;
#line 113
s32 ixgbe_host_interface_command(struct ixgbe_hw *hw , u32 *buffer , u32 length ,
                                 u32 timeout , bool return_data ) ;
#line 115
void ixgbe_clear_tx_pending(struct ixgbe_hw *hw ) ;
#line 118
void ixgbe_set_rxpba_generic(struct ixgbe_hw *hw , int num_pb , u32 headroom , int strategy ) ;
#line 121
u32 const   ixgbe_mvals_8259X[24U] ;
#line 133
s32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw ) ;
#line 134
s32 ixgbe_init_thermal_sensor_thresh_generic(struct ixgbe_hw *hw ) ;
#line 135
void ixgbe_disable_rx_generic(struct ixgbe_hw *hw ) ;
#line 136
void ixgbe_enable_rx_generic(struct ixgbe_hw *hw ) ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw ) ;
#line 39
static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw ) ;
#line 40
static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw ) ;
#line 41
static s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw ) ;
#line 42
static void ixgbe_standby_eeprom(struct ixgbe_hw *hw ) ;
#line 43
static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw , u16 data , u16 count ) ;
#line 45
static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw , u16 count ) ;
#line 46
static void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw , u32 *eec ) ;
#line 47
static void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw , u32 *eec ) ;
#line 48
static void ixgbe_release_eeprom(struct ixgbe_hw *hw ) ;
#line 50
static s32 ixgbe_mta_vector(struct ixgbe_hw *hw , u8 *mc_addr ) ;
#line 51
static s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw , u32 ee_reg ) ;
#line 52
static s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                             u16 *data ) ;
#line 54
static s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                              u16 *data ) ;
#line 56
static s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw , u16 offset ) ;
#line 58
static s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw ) ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
u32 const   ixgbe_mvals_8259X[24U]  = 
#line 61
  {      65552U,      65564U,      66048U,      66064U, 
        65872U,      65856U,      65888U,      65864U, 
        1U,      2U,      4U,      16777216U, 
        33554432U,      67108864U,      69768U,      69772U, 
        1U,      2U,      4U,      8U, 
        0U,      0U,      0U,      40U};
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
bool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw ) 
{ 
  bool supported ;
  ixgbe_link_speed speed ;
  bool link_up ;

  {
#line 76
  supported = 0;
#line 80
  switch ((unsigned int )hw->phy.media_type) {
  case 1U: 
#line 82
  (*(hw->mac.ops.check_link))(hw, & speed, & link_up, 0);
#line 84
  if ((int )link_up) {
#line 85
    supported = speed == 32U;
  } else {
#line 88
    supported = 1;
  }
#line 89
  goto ldv_54449;
  case 5U: 
#line 91
  supported = 1;
#line 92
  goto ldv_54449;
  case 4U: ;
#line 95
  switch ((int )hw->device_id) {
  case 5404: ;
  case 5416: ;
  case 5472: ;
  case 5475: ;
  case 5549: 
#line 101
  supported = 1;
#line 102
  goto ldv_54457;
  default: ;
#line 104
  goto ldv_54457;
  }
  ldv_54457: ;
  default: ;
#line 107
  goto ldv_54449;
  }
  ldv_54449: ;
#line 110
  return (supported);
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_setup_fc(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;
  u32 reg ;
  u32 reg_bp ;
  u16 reg_cu ;
  bool locked ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  bool tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;

  {
#line 121
  ret_val = 0;
#line 122
  reg = 0U;
#line 122
  reg_bp = 0U;
#line 123
  reg_cu = 0U;
#line 124
  locked = 0;
#line 130
  if ((int )hw->fc.strict_ieee && (unsigned int )hw->fc.requested_mode == 1U) {
#line 131
    descriptor.modname = "ixgbe";
#line 131
    descriptor.function = "ixgbe_setup_fc";
#line 131
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 131
    descriptor.format = "ixgbe_fc_rx_pause not valid in strict IEEE mode\n";
#line 131
    descriptor.lineno = 131U;
#line 131
    descriptor.flags = 0U;
#line 131
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 131
    if (tmp != 0L) {
#line 131
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
    } else {

    }
#line 132
    return (-13);
  } else {

  }
#line 139
  if ((unsigned int )hw->fc.requested_mode == 4U) {
#line 140
    hw->fc.requested_mode = 3;
  } else {

  }
#line 147
  switch ((unsigned int )hw->phy.media_type) {
  case 5U: 
#line 150
  ret_val = (*(hw->mac.ops.prot_autoc_read))(hw, & locked, & reg_bp);
#line 151
  if (ret_val != 0) {
#line 152
    return (ret_val);
  } else {

  }
  case 1U: 
#line 156
  reg = ixgbe_read_reg(hw, 16920U);
#line 158
  goto ldv_54472;
  case 4U: 
#line 160
  (*(hw->phy.ops.read_reg))(hw, 16U, 7U, & reg_cu);
#line 162
  goto ldv_54472;
  default: ;
#line 164
  goto ldv_54472;
  }
  ldv_54472: ;
#line 177
  switch ((unsigned int )hw->fc.requested_mode) {
  case 0U: 
#line 180
  reg = reg & 4294966911U;
#line 181
  if ((unsigned int )hw->phy.media_type == 5U) {
#line 182
    reg_bp = reg_bp & 3489660927U;
  } else
#line 184
  if ((unsigned int )hw->phy.media_type == 4U) {
#line 185
    reg_cu = (unsigned int )reg_cu & 62463U;
  } else {

  }
#line 186
  goto ldv_54476;
  case 2U: 
#line 192
  reg = reg | 256U;
#line 193
  reg = reg & 4294967167U;
#line 194
  if ((unsigned int )hw->phy.media_type == 5U) {
#line 195
    reg_bp = reg_bp | 536870912U;
#line 196
    reg_bp = reg_bp & 4026531839U;
  } else
#line 197
  if ((unsigned int )hw->phy.media_type == 4U) {
#line 198
    reg_cu = (u16 )((unsigned int )reg_cu | 2048U);
#line 199
    reg_cu = (unsigned int )reg_cu & 64511U;
  } else {

  }
#line 201
  goto ldv_54476;
  case 1U: ;
  case 3U: 
#line 214
  reg = reg | 384U;
#line 215
  if ((unsigned int )hw->phy.media_type == 5U) {
#line 216
    reg_bp = reg_bp | 805306368U;
  } else
#line 218
  if ((unsigned int )hw->phy.media_type == 4U) {
#line 219
    reg_cu = (u16 )((unsigned int )reg_cu | 3072U);
  } else {

  }
#line 220
  goto ldv_54476;
  default: 
#line 222
  descriptor___0.modname = "ixgbe";
#line 222
  descriptor___0.function = "ixgbe_setup_fc";
#line 222
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 222
  descriptor___0.format = "Flow control param set incorrectly\n";
#line 222
  descriptor___0.lineno = 222U;
#line 222
  descriptor___0.flags = 0U;
#line 222
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 222
  if (tmp___0 != 0L) {
#line 222
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Flow control param set incorrectly\n");
  } else {

  }
#line 223
  return (-4);
  }
  ldv_54476: ;
#line 226
  if ((unsigned int )hw->mac.type != 3U) {
#line 231
    ixgbe_write_reg(hw, 16920U, reg);
#line 232
    reg = ixgbe_read_reg(hw, 16904U);
#line 235
    if ((int )hw->fc.strict_ieee) {
#line 236
      reg = reg & 4294705151U;
    } else {

    }
#line 238
    ixgbe_write_reg(hw, 16904U, reg);
#line 239
    descriptor___1.modname = "ixgbe";
#line 239
    descriptor___1.function = "ixgbe_setup_fc";
#line 239
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 239
    descriptor___1.format = "Set up FC; PCS1GLCTL = 0x%08X\n";
#line 239
    descriptor___1.lineno = 239U;
#line 239
    descriptor___1.flags = 0U;
#line 239
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 239
    if (tmp___1 != 0L) {
#line 239
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Set up FC; PCS1GLCTL = 0x%08X\n", reg);
    } else {

    }
  } else {

  }
#line 247
  if ((unsigned int )hw->phy.media_type == 5U) {
#line 252
    ret_val = (*(hw->mac.ops.prot_autoc_write))(hw, reg_bp, (int )locked);
#line 253
    if (ret_val != 0) {
#line 254
      return (ret_val);
    } else {

    }
  } else
#line 256
  if ((unsigned int )hw->phy.media_type == 4U) {
#line 256
    tmp___2 = ixgbe_device_supports_autoneg_fc(hw);
#line 256
    if ((int )tmp___2) {
#line 258
      (*(hw->phy.ops.write_reg))(hw, 16U, 7U, (int )reg_cu);
    } else {

    }
  } else {

  }
#line 262
  descriptor___2.modname = "ixgbe";
#line 262
  descriptor___2.function = "ixgbe_setup_fc";
#line 262
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 262
  descriptor___2.format = "Set up FC; IXGBE_AUTOC = 0x%08X\n";
#line 262
  descriptor___2.lineno = 262U;
#line 262
  descriptor___2.flags = 0U;
#line 262
  tmp___3 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 262
  if (tmp___3 != 0L) {
#line 262
    __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Set up FC; IXGBE_AUTOC = 0x%08X\n", reg);
  } else {

  }
#line 263
  return (ret_val);
}
}
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;
  u32 ctrl_ext ;

  {
#line 281
  hw->phy.media_type = (*(hw->mac.ops.get_media_type))(hw);
#line 284
  (*(hw->phy.ops.identify))(hw);
#line 287
  (*(hw->mac.ops.clear_vfta))(hw);
#line 290
  (*(hw->mac.ops.clear_hw_cntrs))(hw);
#line 293
  ctrl_ext = ixgbe_read_reg(hw, 24U);
#line 294
  ctrl_ext = ctrl_ext | 65536U;
#line 295
  ixgbe_write_reg(hw, 24U, ctrl_ext);
#line 296
  ixgbe_read_reg(hw, 8U);
#line 299
  ret_val = ixgbe_setup_fc(hw);
#line 300
  if (ret_val == 0) {
#line 301
    return (0);
  } else {

  }
#line 304
  hw->adapter_stopped = 0;
#line 306
  return (ret_val);
}
}
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_start_hw_gen2(struct ixgbe_hw *hw ) 
{ 
  u32 i ;
  u32 regval ;
  u32 regval___0 ;

  {
#line 324
  i = 0U;
#line 324
  goto ldv_54494;
  ldv_54493: 
#line 325
  ixgbe_write_reg(hw, 18692U, i);
#line 326
  ixgbe_write_reg(hw, 18820U, 0U);
#line 324
  i = i + 1U;
  ldv_54494: ;
#line 324
  if (hw->mac.max_tx_queues > i) {
#line 326
    goto ldv_54493;
  } else {

  }
#line 328
  ixgbe_read_reg(hw, 8U);
#line 332
  i = 0U;
#line 332
  goto ldv_54498;
  ldv_54497: 
#line 335
  regval = ixgbe_read_reg(hw, i * 64U + 24588U);
#line 336
  regval = regval & 4294965247U;
#line 337
  ixgbe_write_reg(hw, i * 64U + 24588U, regval);
#line 332
  i = i + 1U;
  ldv_54498: ;
#line 332
  if (hw->mac.max_tx_queues > i) {
#line 334
    goto ldv_54497;
  } else {

  }
#line 340
  i = 0U;
#line 340
  goto ldv_54502;
  ldv_54501: 
#line 343
  regval___0 = ixgbe_read_reg(hw, i <= 15U ? (i + 2176U) * 4U : (i <= 63U ? i * 64U + 4108U : (i + 67108800U) * 64U + 53260U));
#line 344
  regval___0 = regval___0 & 4294926335U;
#line 346
  ixgbe_write_reg(hw, i <= 15U ? (i + 2176U) * 4U : (i <= 63U ? i * 64U + 4108U : (i + 67108800U) * 64U + 53260U),
                  regval___0);
#line 340
  i = i + 1U;
  ldv_54502: ;
#line 340
  if (hw->mac.max_rx_queues > i) {
#line 342
    goto ldv_54501;
  } else {

  }

#line 349
  return (0);
}
}
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_hw_generic(struct ixgbe_hw *hw ) 
{ 
  s32 status ;

  {
#line 367
  status = (*(hw->mac.ops.reset_hw))(hw);
#line 369
  if (status == 0) {
#line 371
    status = (*(hw->mac.ops.start_hw))(hw);
  } else {

  }
#line 374
  return (status);
}
}
#line 384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw ) 
{ 
  u16 i ;

  {
#line 386
  i = 0U;
#line 388
  ixgbe_read_reg(hw, 16384U);
#line 389
  ixgbe_read_reg(hw, 16388U);
#line 390
  ixgbe_read_reg(hw, 16392U);
#line 391
  ixgbe_read_reg(hw, 16400U);
#line 392
  i = 0U;
#line 392
  goto ldv_54513;
  ldv_54512: 
#line 393
  ixgbe_read_reg(hw, (u32 )(((int )i + 4072) * 4));
#line 392
  i = (u16 )((int )i + 1);
  ldv_54513: ;
#line 392
  if ((unsigned int )i <= 7U) {
#line 394
    goto ldv_54512;
  } else {

  }
#line 395
  ixgbe_read_reg(hw, 16436U);
#line 396
  ixgbe_read_reg(hw, 16440U);
#line 397
  ixgbe_read_reg(hw, 16448U);
#line 398
  ixgbe_read_reg(hw, 16224U);
#line 399
  ixgbe_read_reg(hw, 16232U);
#line 400
  if ((unsigned int )hw->mac.type > 1U) {
#line 401
    ixgbe_read_reg(hw, 16804U);
#line 402
    ixgbe_read_reg(hw, 16808U);
  } else {
#line 404
    ixgbe_read_reg(hw, 53088U);
#line 405
    ixgbe_read_reg(hw, 53096U);
  }
#line 408
  i = 0U;
#line 408
  goto ldv_54516;
  ldv_54515: 
#line 409
  ixgbe_read_reg(hw, (u32 )(((int )i + 4032) * 4));
#line 410
  ixgbe_read_reg(hw, (u32 )(((int )i + 4040) * 4));
#line 411
  if ((unsigned int )hw->mac.type > 1U) {
#line 412
    ixgbe_read_reg(hw, (u32 )(((int )i + 4176) * 4));
#line 413
    ixgbe_read_reg(hw, (u32 )(((int )i + 4184) * 4));
  } else {
#line 415
    ixgbe_read_reg(hw, (u32 )(((int )i + 13248) * 4));
#line 416
    ixgbe_read_reg(hw, (u32 )(((int )i + 13256) * 4));
  }
#line 408
  i = (u16 )((int )i + 1);
  ldv_54516: ;
#line 408
  if ((unsigned int )i <= 7U) {
#line 410
    goto ldv_54515;
  } else {

  }

#line 419
  if ((unsigned int )hw->mac.type > 1U) {
#line 420
    i = 0U;
#line 420
    goto ldv_54519;
    ldv_54518: 
#line 421
    ixgbe_read_reg(hw, (u32 )(((int )i + 3216) * 4));
#line 420
    i = (u16 )((int )i + 1);
    ldv_54519: ;
#line 420
    if ((unsigned int )i <= 7U) {
#line 422
      goto ldv_54518;
    } else {

    }

  } else {

  }
#line 422
  ixgbe_read_reg(hw, 16476U);
#line 423
  ixgbe_read_reg(hw, 16480U);
#line 424
  ixgbe_read_reg(hw, 16484U);
#line 425
  ixgbe_read_reg(hw, 16488U);
#line 426
  ixgbe_read_reg(hw, 16492U);
#line 427
  ixgbe_read_reg(hw, 16496U);
#line 428
  ixgbe_read_reg(hw, 16500U);
#line 429
  ixgbe_read_reg(hw, 16504U);
#line 430
  ixgbe_read_reg(hw, 16508U);
#line 431
  ixgbe_read_reg(hw, 16512U);
#line 432
  ixgbe_read_reg(hw, 16520U);
#line 433
  ixgbe_read_reg(hw, 16524U);
#line 434
  ixgbe_read_reg(hw, 16528U);
#line 435
  ixgbe_read_reg(hw, 16532U);
#line 436
  if ((unsigned int )hw->mac.type == 1U) {
#line 437
    i = 0U;
#line 437
    goto ldv_54522;
    ldv_54521: 
#line 438
    ixgbe_read_reg(hw, (u32 )(((int )i + 4080) * 4));
#line 437
    i = (u16 )((int )i + 1);
    ldv_54522: ;
#line 437
    if ((unsigned int )i <= 7U) {
#line 439
      goto ldv_54521;
    } else {

    }

  } else {

  }
#line 439
  ixgbe_read_reg(hw, 16548U);
#line 440
  ixgbe_read_reg(hw, 16552U);
#line 441
  ixgbe_read_reg(hw, 16556U);
#line 442
  ixgbe_read_reg(hw, 16560U);
#line 443
  ixgbe_read_reg(hw, 16564U);
#line 444
  ixgbe_read_reg(hw, 16568U);
#line 445
  ixgbe_read_reg(hw, 53136U);
#line 446
  ixgbe_read_reg(hw, 16576U);
#line 447
  ixgbe_read_reg(hw, 16580U);
#line 448
  ixgbe_read_reg(hw, 16592U);
#line 449
  ixgbe_read_reg(hw, 16596U);
#line 450
  ixgbe_read_reg(hw, 16600U);
#line 451
  ixgbe_read_reg(hw, 16604U);
#line 452
  ixgbe_read_reg(hw, 16608U);
#line 453
  ixgbe_read_reg(hw, 16612U);
#line 454
  ixgbe_read_reg(hw, 16616U);
#line 455
  ixgbe_read_reg(hw, 16620U);
#line 456
  ixgbe_read_reg(hw, 16624U);
#line 457
  ixgbe_read_reg(hw, 16628U);
#line 458
  i = 0U;
#line 458
  goto ldv_54525;
  ldv_54524: 
#line 459
  ixgbe_read_reg(hw, (u32 )((int )i * 64 + 4144));
#line 460
  ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24624));
#line 461
  if ((unsigned int )hw->mac.type > 1U) {
#line 462
    ixgbe_read_reg(hw, (u32 )((int )i * 64 + 4148));
#line 463
    ixgbe_read_reg(hw, (u32 )((int )i * 64 + 4152));
#line 464
    ixgbe_read_reg(hw, (u32 )(((int )i + 4320) * 8));
#line 465
    ixgbe_read_reg(hw, (u32 )((int )i * 8 + 34564));
#line 466
    ixgbe_read_reg(hw, (u32 )((int )i * 64 + 5168));
  } else {
#line 468
    ixgbe_read_reg(hw, (u32 )((int )i * 64 + 4148));
#line 469
    ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24628));
  }
#line 458
  i = (u16 )((int )i + 1);
  ldv_54525: ;
#line 458
  if ((unsigned int )i <= 15U) {
#line 460
    goto ldv_54524;
  } else {

  }

#line 473
  if ((unsigned int )hw->mac.type == 4U || (unsigned int )hw->mac.type == 3U) {
#line 474
    if (hw->phy.id == 0U) {
#line 475
      (*(hw->phy.ops.identify))(hw);
    } else {

    }
#line 476
    (*(hw->phy.ops.read_reg))(hw, 59408U, 3U, & i);
#line 477
    (*(hw->phy.ops.read_reg))(hw, 59409U, 3U, & i);
#line 478
    (*(hw->phy.ops.read_reg))(hw, 59424U, 3U, & i);
#line 479
    (*(hw->phy.ops.read_reg))(hw, 59425U, 3U, & i);
  } else {

  }
#line 482
  return (0);
}
}
#line 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw , u8 *pba_num , u32 pba_num_size ) 
{ 
  s32 ret_val ;
  u16 data ;
  u16 pba_ptr ;
  u16 offset ;
  u16 length ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;
  struct _ddebug descriptor___4 ;
  long tmp___4 ;
  struct _ddebug descriptor___5 ;
  long tmp___5 ;
  struct _ddebug descriptor___6 ;
  long tmp___6 ;
  struct _ddebug descriptor___7 ;
  long tmp___7 ;

  {
#line 502
  if ((unsigned long )pba_num == (unsigned long )((u8 *)0U)) {
#line 503
    descriptor.modname = "ixgbe";
#line 503
    descriptor.function = "ixgbe_read_pba_string_generic";
#line 503
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 503
    descriptor.format = "PBA string buffer was null\n";
#line 503
    descriptor.lineno = 503U;
#line 503
    descriptor.flags = 0U;
#line 503
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 503
    if (tmp != 0L) {
#line 503
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PBA string buffer was null\n");
    } else {

    }
#line 504
    return (-32);
  } else {

  }
#line 507
  ret_val = (*(hw->eeprom.ops.read))(hw, 21, & data);
#line 508
  if (ret_val != 0) {
#line 509
    descriptor___0.modname = "ixgbe";
#line 509
    descriptor___0.function = "ixgbe_read_pba_string_generic";
#line 509
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 509
    descriptor___0.format = "NVM Read Error\n";
#line 509
    descriptor___0.lineno = 509U;
#line 509
    descriptor___0.flags = 0U;
#line 509
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 509
    if (tmp___0 != 0L) {
#line 509
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "NVM Read Error\n");
    } else {

    }
#line 510
    return (ret_val);
  } else {

  }
#line 513
  ret_val = (*(hw->eeprom.ops.read))(hw, 22, & pba_ptr);
#line 514
  if (ret_val != 0) {
#line 515
    descriptor___1.modname = "ixgbe";
#line 515
    descriptor___1.function = "ixgbe_read_pba_string_generic";
#line 515
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 515
    descriptor___1.format = "NVM Read Error\n";
#line 515
    descriptor___1.lineno = 515U;
#line 515
    descriptor___1.flags = 0U;
#line 515
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 515
    if (tmp___1 != 0L) {
#line 515
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "NVM Read Error\n");
    } else {

    }
#line 516
    return (ret_val);
  } else {

  }
#line 524
  if ((unsigned int )data != 64250U) {
#line 525
    descriptor___2.modname = "ixgbe";
#line 525
    descriptor___2.function = "ixgbe_read_pba_string_generic";
#line 525
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 525
    descriptor___2.format = "NVM PBA number is not stored as string\n";
#line 525
    descriptor___2.lineno = 525U;
#line 525
    descriptor___2.flags = 0U;
#line 525
    tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 525
    if (tmp___2 != 0L) {
#line 525
      __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "NVM PBA number is not stored as string\n");
    } else {

    }
#line 528
    if (pba_num_size <= 10U) {
#line 529
      descriptor___3.modname = "ixgbe";
#line 529
      descriptor___3.function = "ixgbe_read_pba_string_generic";
#line 529
      descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 529
      descriptor___3.format = "PBA string buffer too small\n";
#line 529
      descriptor___3.lineno = 529U;
#line 529
      descriptor___3.flags = 0U;
#line 529
      tmp___3 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
#line 529
      if (tmp___3 != 0L) {
#line 529
        __dynamic_netdev_dbg(& descriptor___3, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "PBA string buffer too small\n");
      } else {

      }
#line 530
      return (-25);
    } else {

    }
#line 534
    *pba_num = (unsigned int )((u8 )((int )data >> 12)) & 15U;
#line 535
    *(pba_num + 1UL) = (unsigned int )((u8 )((int )data >> 8)) & 15U;
#line 536
    *(pba_num + 2UL) = (unsigned int )((u8 )((int )data >> 4)) & 15U;
#line 537
    *(pba_num + 3UL) = (unsigned int )((u8 )data) & 15U;
#line 538
    *(pba_num + 4UL) = (unsigned int )((u8 )((int )pba_ptr >> 12)) & 15U;
#line 539
    *(pba_num + 5UL) = (unsigned int )((u8 )((int )pba_ptr >> 8)) & 15U;
#line 540
    *(pba_num + 6UL) = 45U;
#line 541
    *(pba_num + 7UL) = 0U;
#line 542
    *(pba_num + 8UL) = (unsigned int )((u8 )((int )pba_ptr >> 4)) & 15U;
#line 543
    *(pba_num + 9UL) = (unsigned int )((u8 )pba_ptr) & 15U;
#line 546
    *(pba_num + 10UL) = 0U;
#line 549
    offset = 0U;
#line 549
    goto ldv_54544;
    ldv_54543: ;
#line 550
    if ((unsigned int )*(pba_num + (unsigned long )offset) <= 9U) {
#line 551
      *(pba_num + (unsigned long )offset) = (unsigned int )*(pba_num + (unsigned long )offset) + 48U;
    } else
#line 552
    if ((unsigned int )*(pba_num + (unsigned long )offset) <= 15U) {
#line 553
      *(pba_num + (unsigned long )offset) = (unsigned int )*(pba_num + (unsigned long )offset) + 55U;
    } else {

    }
#line 549
    offset = (u16 )((int )offset + 1);
    ldv_54544: ;
#line 549
    if ((unsigned int )offset <= 9U) {
#line 551
      goto ldv_54543;
    } else {

    }

#line 556
    return (0);
  } else {

  }
#line 559
  ret_val = (*(hw->eeprom.ops.read))(hw, (int )pba_ptr, & length);
#line 560
  if (ret_val != 0) {
#line 561
    descriptor___4.modname = "ixgbe";
#line 561
    descriptor___4.function = "ixgbe_read_pba_string_generic";
#line 561
    descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 561
    descriptor___4.format = "NVM Read Error\n";
#line 561
    descriptor___4.lineno = 561U;
#line 561
    descriptor___4.flags = 0U;
#line 561
    tmp___4 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
#line 561
    if (tmp___4 != 0L) {
#line 561
      __dynamic_netdev_dbg(& descriptor___4, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "NVM Read Error\n");
    } else {

    }
#line 562
    return (ret_val);
  } else {

  }
#line 565
  if ((unsigned int )length == 65535U || (unsigned int )length == 0U) {
#line 566
    descriptor___5.modname = "ixgbe";
#line 566
    descriptor___5.function = "ixgbe_read_pba_string_generic";
#line 566
    descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 566
    descriptor___5.format = "NVM PBA number section invalid length\n";
#line 566
    descriptor___5.lineno = 566U;
#line 566
    descriptor___5.flags = 0U;
#line 566
    tmp___5 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
#line 566
    if (tmp___5 != 0L) {
#line 566
      __dynamic_netdev_dbg(& descriptor___5, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "NVM PBA number section invalid length\n");
    } else {

    }
#line 567
    return (-31);
  } else {

  }
#line 571
  if ((unsigned int )length * 2U - 1U > pba_num_size) {
#line 572
    descriptor___6.modname = "ixgbe";
#line 572
    descriptor___6.function = "ixgbe_read_pba_string_generic";
#line 572
    descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 572
    descriptor___6.format = "PBA string buffer too small\n";
#line 572
    descriptor___6.lineno = 572U;
#line 572
    descriptor___6.flags = 0U;
#line 572
    tmp___6 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
#line 572
    if (tmp___6 != 0L) {
#line 572
      __dynamic_netdev_dbg(& descriptor___6, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PBA string buffer too small\n");
    } else {

    }
#line 573
    return (-25);
  } else {

  }
#line 577
  pba_ptr = (u16 )((int )pba_ptr + 1);
#line 578
  length = (u16 )((int )length - 1);
#line 580
  offset = 0U;
#line 580
  goto ldv_54551;
  ldv_54550: 
#line 581
  ret_val = (*(hw->eeprom.ops.read))(hw, (int )pba_ptr + (int )offset, & data);
#line 582
  if (ret_val != 0) {
#line 583
    descriptor___7.modname = "ixgbe";
#line 583
    descriptor___7.function = "ixgbe_read_pba_string_generic";
#line 583
    descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 583
    descriptor___7.format = "NVM Read Error\n";
#line 583
    descriptor___7.lineno = 583U;
#line 583
    descriptor___7.flags = 0U;
#line 583
    tmp___7 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
#line 583
    if (tmp___7 != 0L) {
#line 583
      __dynamic_netdev_dbg(& descriptor___7, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "NVM Read Error\n");
    } else {

    }
#line 584
    return (ret_val);
  } else {

  }
#line 586
  *(pba_num + (unsigned long )((int )offset * 2)) = (unsigned char )((int )data >> 8);
#line 587
  *(pba_num + ((unsigned long )((int )offset * 2) + 1UL)) = (unsigned char )data;
#line 580
  offset = (u16 )((int )offset + 1);
  ldv_54551: ;
#line 580
  if ((int )offset < (int )length) {
#line 582
    goto ldv_54550;
  } else {

  }
#line 589
  *(pba_num + (unsigned long )((int )offset * 2)) = 0U;
#line 591
  return (0);
}
}
#line 603 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw , u8 *mac_addr ) 
{ 
  u32 rar_high ;
  u32 rar_low ;
  u16 i ;

  {
#line 609
  rar_high = ixgbe_read_reg(hw, 21508U);
#line 610
  rar_low = ixgbe_read_reg(hw, 21504U);
#line 612
  i = 0U;
#line 612
  goto ldv_54561;
  ldv_54560: 
#line 613
  *(mac_addr + (unsigned long )i) = (unsigned char )(rar_low >> (int )i * 8);
#line 612
  i = (u16 )((int )i + 1);
  ldv_54561: ;
#line 612
  if ((unsigned int )i <= 3U) {
#line 614
    goto ldv_54560;
  } else {

  }
#line 615
  i = 0U;
#line 615
  goto ldv_54564;
  ldv_54563: 
#line 616
  *(mac_addr + ((unsigned long )i + 4UL)) = (unsigned char )(rar_high >> (int )i * 8);
#line 615
  i = (u16 )((int )i + 1);
  ldv_54564: ;
#line 615
  if ((unsigned int )i <= 1U) {
#line 617
    goto ldv_54563;
  } else {

  }

#line 618
  return (0);
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
enum ixgbe_bus_width ixgbe_convert_bus_width(u16 link_status ) 
{ 


  {
#line 623
  switch ((int )link_status & 1008) {
  case 16: ;
#line 625
  return (1);
  case 32: ;
#line 627
  return (2);
  case 64: ;
#line 629
  return (4);
  case 128: ;
#line 631
  return (8);
  default: ;
#line 633
  return (0);
  }
}
}
#line 637 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
enum ixgbe_bus_speed ixgbe_convert_bus_speed(u16 link_status ) 
{ 


  {
#line 639
  switch ((int )link_status & 15) {
  case 1: ;
#line 641
  return (2500);
  case 2: ;
#line 643
  return (5000);
  case 3: ;
#line 645
  return (8000);
  default: ;
#line 647
  return (0);
  }
}
}
#line 657 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw ) 
{ 
  u16 link_status ;

  {
#line 661
  hw->bus.type = 3;
#line 664
  link_status = ixgbe_read_pci_cfg_word(hw, 178U);
#line 666
  hw->bus.width = ixgbe_convert_bus_width((int )link_status);
#line 667
  hw->bus.speed = ixgbe_convert_bus_speed((int )link_status);
#line 669
  (*(hw->mac.ops.set_lan_id))(hw);
#line 671
  return (0);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_bus_info *bus ;
  u32 reg ;

  {
#line 683
  bus = & hw->bus;
#line 686
  reg = ixgbe_read_reg(hw, 8U);
#line 687
  bus->func = (u16 )((reg & 12U) >> 2);
#line 688
  bus->lan_id = bus->func;
#line 691
  reg = ixgbe_read_reg(hw, *(hw->mvals + 4UL));
#line 692
  if ((reg & 1073741824U) != 0U) {
#line 693
    bus->func = (u16 )((unsigned int )bus->func ^ 1U);
  } else {

  }
#line 694
  return;
}
}
#line 705 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw ) 
{ 
  u32 reg_val ;
  u16 i ;
  s32 tmp ;

  {
#line 714
  hw->adapter_stopped = 1;
#line 717
  (*(hw->mac.ops.disable_rx))(hw);
#line 720
  ixgbe_write_reg(hw, 2184U, 4294967295U);
#line 723
  ixgbe_read_reg(hw, 2048U);
#line 726
  i = 0U;
#line 726
  goto ldv_54596;
  ldv_54595: 
#line 727
  ixgbe_write_reg(hw, (u32 )((int )i * 64 + 24616), 67108864U);
#line 726
  i = (u16 )((int )i + 1);
  ldv_54596: ;
#line 726
  if ((u32 )i < hw->mac.max_tx_queues) {
#line 728
    goto ldv_54595;
  } else {

  }
#line 730
  i = 0U;
#line 730
  goto ldv_54599;
  ldv_54598: 
#line 731
  reg_val = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 63U ? (int )i * 64 + 4136 : ((int )i + -64) * 64 + 53288));
#line 732
  reg_val = reg_val & 4261412863U;
#line 733
  reg_val = reg_val | 67108864U;
#line 734
  ixgbe_write_reg(hw, (u32 )((unsigned int )i <= 63U ? (int )i * 64 + 4136 : ((int )i + -64) * 64 + 53288),
                  reg_val);
#line 730
  i = (u16 )((int )i + 1);
  ldv_54599: ;
#line 730
  if ((u32 )i < hw->mac.max_rx_queues) {
#line 732
    goto ldv_54598;
  } else {

  }
#line 738
  ixgbe_read_reg(hw, 8U);
#line 739
  usleep_range(1000UL, 2000UL);
#line 745
  tmp = ixgbe_disable_pcie_master(hw);
#line 745
  return (tmp);
}
}
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_led_on_generic(struct ixgbe_hw *hw , u32 index ) 
{ 
  u32 led_reg ;
  u32 tmp ;

  {
#line 755
  tmp = ixgbe_read_reg(hw, 512U);
#line 755
  led_reg = tmp;
#line 758
  led_reg = (u32 )(~ (15 << (int )(index * 8U))) & led_reg;
#line 759
  led_reg = (u32 )(14 << (int )(index * 8U)) | led_reg;
#line 760
  ixgbe_write_reg(hw, 512U, led_reg);
#line 761
  ixgbe_read_reg(hw, 8U);
#line 763
  return (0);
}
}
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_led_off_generic(struct ixgbe_hw *hw , u32 index ) 
{ 
  u32 led_reg ;
  u32 tmp ;

  {
#line 773
  tmp = ixgbe_read_reg(hw, 512U);
#line 773
  led_reg = tmp;
#line 776
  led_reg = (u32 )(~ (15 << (int )(index * 8U))) & led_reg;
#line 777
  led_reg = (u32 )(15 << (int )(index * 8U)) | led_reg;
#line 778
  ixgbe_write_reg(hw, 512U, led_reg);
#line 779
  ixgbe_read_reg(hw, 8U);
#line 781
  return (0);
}
}
#line 791 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_eeprom_info *eeprom ;
  u32 eec ;
  u16 eeprom_size ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 793
  eeprom = & hw->eeprom;
#line 797
  if ((unsigned int )eeprom->type == 0U) {
#line 798
    eeprom->type = 3;
#line 801
    eeprom->semaphore_delay = 10U;
#line 803
    eeprom->word_page_size = 0U;
#line 809
    eec = ixgbe_read_reg(hw, *(hw->mvals));
#line 810
    if ((eec & 256U) != 0U) {
#line 811
      eeprom->type = 1;
#line 817
      eeprom_size = (unsigned short )((eec & 30720U) >> 11);
#line 819
      eeprom->word_size = (u16 )(1 << ((int )eeprom_size + 6));
    } else {

    }
#line 823
    if ((eec & 1024U) != 0U) {
#line 824
      eeprom->address_bits = 16U;
    } else {
#line 826
      eeprom->address_bits = 8U;
    }
#line 827
    descriptor.modname = "ixgbe";
#line 827
    descriptor.function = "ixgbe_init_eeprom_params_generic";
#line 827
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 827
    descriptor.format = "Eeprom params: type = %d, size = %d, address bits: %d\n";
#line 827
    descriptor.lineno = 828U;
#line 827
    descriptor.flags = 0U;
#line 827
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 827
    if (tmp != 0L) {
#line 827
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Eeprom params: type = %d, size = %d, address bits: %d\n",
                           (unsigned int )eeprom->type, (int )eeprom->word_size, (int )eeprom->address_bits);
    } else {

    }
  } else {

  }
#line 831
  return (0);
}
}
#line 843 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_write_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw , u16 offset ,
                                               u16 words , u16 *data ) 
{ 
  s32 status ;
  u16 i ;
  u16 count ;

  {
#line 849
  (*(hw->eeprom.ops.init_params))(hw);
#line 851
  if ((unsigned int )words == 0U) {
#line 852
    return (-32);
  } else {

  }
#line 854
  if ((int )offset + (int )words > (int )hw->eeprom.word_size) {
#line 855
    return (-1);
  } else {

  }
#line 861
  if ((unsigned int )hw->eeprom.word_page_size == 0U && (unsigned int )words > 128U) {
#line 863
    ixgbe_detect_eeprom_page_size_generic(hw, (int )offset);
  } else {

  }
#line 870
  i = 0U;
#line 870
  goto ldv_54630;
  ldv_54629: 
#line 871
  count = (u16 )(512 < (int )words - (int )i ? 512 : (int )words - (int )i);
#line 873
  status = ixgbe_write_eeprom_buffer_bit_bang(hw, (int )offset + (int )i, (int )count,
                                              data + (unsigned long )i);
#line 876
  if (status != 0) {
#line 877
    goto ldv_54628;
  } else {

  }
#line 870
  i = (unsigned int )i + 512U;
  ldv_54630: ;
#line 870
  if ((int )i < (int )words) {
#line 872
    goto ldv_54629;
  } else {

  }
  ldv_54628: ;
#line 880
  return (status);
}
}
#line 893 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                              u16 *data ) 
{ 
  s32 status ;
  u16 word ;
  u16 page_size ;
  u16 i ;
  u8 write_opcode ;
  s32 tmp ;

  {
#line 900
  write_opcode = 2U;
#line 903
  status = ixgbe_acquire_eeprom(hw);
#line 904
  if (status != 0) {
#line 905
    return (status);
  } else {

  }
#line 907
  tmp = ixgbe_ready_eeprom(hw);
#line 907
  if (tmp != 0) {
#line 908
    ixgbe_release_eeprom(hw);
#line 909
    return (-1);
  } else {

  }
#line 912
  i = 0U;
#line 912
  goto ldv_54645;
  ldv_54644: 
#line 913
  ixgbe_standby_eeprom(hw);
#line 916
  ixgbe_shift_out_eeprom_bits(hw, 6, 8);
#line 920
  ixgbe_standby_eeprom(hw);
#line 925
  if ((unsigned int )hw->eeprom.address_bits == 8U && (int )offset + (int )i > 127) {
#line 927
    write_opcode = (u8 )((unsigned int )write_opcode | 8U);
  } else {

  }
#line 930
  ixgbe_shift_out_eeprom_bits(hw, (int )write_opcode, 8);
#line 932
  ixgbe_shift_out_eeprom_bits(hw, (int )((unsigned int )((unsigned short )((int )offset + (int )i)) * 2U),
                              (int )hw->eeprom.address_bits);
#line 935
  page_size = hw->eeprom.word_page_size;
  ldv_54643: 
#line 939
  word = *(data + (unsigned long )i);
#line 940
  word = (u16 )((int )((short )((int )word >> 8)) | (int )((short )((int )word << 8)));
#line 941
  ixgbe_shift_out_eeprom_bits(hw, (int )word, 16);
#line 943
  if ((unsigned int )page_size == 0U) {
#line 944
    goto ldv_54642;
  } else {

  }
#line 947
  if ((((int )offset + (int )i) & ((int )page_size + -1)) == (int )page_size + -1) {
#line 949
    goto ldv_54642;
  } else {

  }
#line 950
  i = (u16 )((int )i + 1);
#line 950
  if ((int )i < (int )words) {
#line 952
    goto ldv_54643;
  } else {

  }
  ldv_54642: 
#line 952
  ixgbe_standby_eeprom(hw);
#line 953
  usleep_range(10000UL, 20000UL);
#line 912
  i = (u16 )((int )i + 1);
  ldv_54645: ;
#line 912
  if ((int )i < (int )words) {
#line 914
    goto ldv_54644;
  } else {

  }
#line 956
  ixgbe_release_eeprom(hw);
#line 958
  return (0);
}
}
#line 970 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_write_eeprom_generic(struct ixgbe_hw *hw , u16 offset , u16 data ) 
{ 
  s32 tmp ;

  {
#line 972
  (*(hw->eeprom.ops.init_params))(hw);
#line 974
  if ((int )hw->eeprom.word_size <= (int )offset) {
#line 975
    return (-1);
  } else {

  }
#line 977
  tmp = ixgbe_write_eeprom_buffer_bit_bang(hw, (int )offset, 1, & data);
#line 977
  return (tmp);
}
}
#line 989 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                              u16 *data ) 
{ 
  s32 status ;
  u16 i ;
  u16 count ;

  {
#line 995
  (*(hw->eeprom.ops.init_params))(hw);
#line 997
  if ((unsigned int )words == 0U) {
#line 998
    return (-32);
  } else {

  }
#line 1000
  if ((int )offset + (int )words > (int )hw->eeprom.word_size) {
#line 1001
    return (-1);
  } else {

  }
#line 1008
  i = 0U;
#line 1008
  goto ldv_54662;
  ldv_54661: 
#line 1009
  count = (u16 )(512 < (int )words - (int )i ? 512 : (int )words - (int )i);
#line 1012
  status = ixgbe_read_eeprom_buffer_bit_bang(hw, (int )offset + (int )i, (int )count,
                                             data + (unsigned long )i);
#line 1015
  if (status != 0) {
#line 1016
    return (status);
  } else {

  }
#line 1008
  i = (unsigned int )i + 512U;
  ldv_54662: ;
#line 1008
  if ((int )i < (int )words) {
#line 1010
    goto ldv_54661;
  } else {

  }

#line 1019
  return (0);
}
}
#line 1031 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                             u16 *data ) 
{ 
  s32 status ;
  u16 word_in ;
  u8 read_opcode ;
  u16 i ;
  s32 tmp ;

  {
#line 1036
  read_opcode = 3U;
#line 1040
  status = ixgbe_acquire_eeprom(hw);
#line 1041
  if (status != 0) {
#line 1042
    return (status);
  } else {

  }
#line 1044
  tmp = ixgbe_ready_eeprom(hw);
#line 1044
  if (tmp != 0) {
#line 1045
    ixgbe_release_eeprom(hw);
#line 1046
    return (-1);
  } else {

  }
#line 1049
  i = 0U;
#line 1049
  goto ldv_54675;
  ldv_54674: 
#line 1050
  ixgbe_standby_eeprom(hw);
#line 1054
  if ((unsigned int )hw->eeprom.address_bits == 8U && (int )offset + (int )i > 127) {
#line 1056
    read_opcode = (u8 )((unsigned int )read_opcode | 8U);
  } else {

  }
#line 1059
  ixgbe_shift_out_eeprom_bits(hw, (int )read_opcode, 8);
#line 1061
  ixgbe_shift_out_eeprom_bits(hw, (int )((unsigned int )((unsigned short )((int )offset + (int )i)) * 2U),
                              (int )hw->eeprom.address_bits);
#line 1065
  word_in = ixgbe_shift_in_eeprom_bits(hw, 16);
#line 1066
  *(data + (unsigned long )i) = (u16 )((int )((short )((int )word_in >> 8)) | (int )((short )((int )word_in << 8)));
#line 1049
  i = (u16 )((int )i + 1);
  ldv_54675: ;
#line 1049
  if ((int )i < (int )words) {
#line 1051
    goto ldv_54674;
  } else {

  }
#line 1070
  ixgbe_release_eeprom(hw);
#line 1072
  return (0);
}
}
#line 1083 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw , u16 offset , u16 *data ) 
{ 
  s32 tmp ;

  {
#line 1086
  (*(hw->eeprom.ops.init_params))(hw);
#line 1088
  if ((int )hw->eeprom.word_size <= (int )offset) {
#line 1089
    return (-1);
  } else {

  }
#line 1091
  tmp = ixgbe_read_eeprom_buffer_bit_bang(hw, (int )offset, 1, data);
#line 1091
  return (tmp);
}
}
#line 1103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_eerd_buffer_generic(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                   u16 *data ) 
{ 
  u32 eerd ;
  s32 status ;
  u32 i ;
  u32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
#line 1110
  (*(hw->eeprom.ops.init_params))(hw);
#line 1112
  if ((unsigned int )words == 0U) {
#line 1113
    return (-32);
  } else {

  }
#line 1115
  if ((int )hw->eeprom.word_size <= (int )offset) {
#line 1116
    return (-1);
  } else {

  }
#line 1118
  i = 0U;
#line 1118
  goto ldv_54694;
  ldv_54693: 
#line 1119
  eerd = (((u32 )offset + i) << 2) | 1U;
#line 1122
  ixgbe_write_reg(hw, 65556U, eerd);
#line 1123
  status = ixgbe_poll_eerd_eewr_done(hw, 0U);
#line 1125
  if (status == 0) {
#line 1126
    tmp = ixgbe_read_reg(hw, 65556U);
#line 1126
    *(data + (unsigned long )i) = (u16 )(tmp >> 16);
  } else {
#line 1129
    descriptor.modname = "ixgbe";
#line 1129
    descriptor.function = "ixgbe_read_eerd_buffer_generic";
#line 1129
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1129
    descriptor.format = "Eeprom read timed out\n";
#line 1129
    descriptor.lineno = 1129U;
#line 1129
    descriptor.flags = 0U;
#line 1129
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1129
    if (tmp___0 != 0L) {
#line 1129
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Eeprom read timed out\n");
    } else {

    }
#line 1130
    return (status);
  }
#line 1118
  i = i + 1U;
  ldv_54694: ;
#line 1118
  if ((u32 )words > i) {
#line 1120
    goto ldv_54693;
  } else {

  }

#line 1134
  return (0);
}
}
#line 1146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw , u16 offset ) 
{ 
  u16 data[128U] ;
  s32 status ;
  u16 i ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 1153
  i = 0U;
#line 1153
  goto ldv_54704;
  ldv_54703: 
#line 1154
  data[(int )i] = i;
#line 1153
  i = (u16 )((int )i + 1);
  ldv_54704: ;
#line 1153
  if ((unsigned int )i <= 127U) {
#line 1155
    goto ldv_54703;
  } else {

  }
#line 1156
  hw->eeprom.word_page_size = 128U;
#line 1157
  status = ixgbe_write_eeprom_buffer_bit_bang(hw, (int )offset, 128, (u16 *)(& data));
#line 1159
  hw->eeprom.word_page_size = 0U;
#line 1160
  if (status != 0) {
#line 1161
    return (status);
  } else {

  }
#line 1163
  status = ixgbe_read_eeprom_buffer_bit_bang(hw, (int )offset, 1, (u16 *)(& data));
#line 1164
  if (status != 0) {
#line 1165
    return (status);
  } else {

  }
#line 1171
  hw->eeprom.word_page_size = 128U - (unsigned int )data[0];
#line 1173
  descriptor.modname = "ixgbe";
#line 1173
  descriptor.function = "ixgbe_detect_eeprom_page_size_generic";
#line 1173
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1173
  descriptor.format = "Detected EEPROM page size = %d words.\n";
#line 1173
  descriptor.lineno = 1174U;
#line 1173
  descriptor.flags = 0U;
#line 1173
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1173
  if (tmp != 0L) {
#line 1173
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Detected EEPROM page size = %d words.\n", (int )hw->eeprom.word_page_size);
  } else {

  }
#line 1175
  return (0);
}
}
#line 1186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_eerd_generic(struct ixgbe_hw *hw , u16 offset , u16 *data ) 
{ 
  s32 tmp ;

  {
#line 1188
  tmp = ixgbe_read_eerd_buffer_generic(hw, (int )offset, 1, data);
#line 1188
  return (tmp);
}
}
#line 1200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_write_eewr_buffer_generic(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                    u16 *data ) 
{ 
  u32 eewr ;
  s32 status ;
  u16 i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
#line 1207
  (*(hw->eeprom.ops.init_params))(hw);
#line 1209
  if ((unsigned int )words == 0U) {
#line 1210
    return (-32);
  } else {

  }
#line 1212
  if ((int )hw->eeprom.word_size <= (int )offset) {
#line 1213
    return (-1);
  } else {

  }
#line 1215
  i = 0U;
#line 1215
  goto ldv_54726;
  ldv_54725: 
#line 1216
  eewr = (u32 )(((((int )offset + (int )i) << 2) | ((int )*(data + (unsigned long )i) << 16)) | 1);
#line 1220
  status = ixgbe_poll_eerd_eewr_done(hw, 1U);
#line 1221
  if (status != 0) {
#line 1222
    descriptor.modname = "ixgbe";
#line 1222
    descriptor.function = "ixgbe_write_eewr_buffer_generic";
#line 1222
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1222
    descriptor.format = "Eeprom write EEWR timed out\n";
#line 1222
    descriptor.lineno = 1222U;
#line 1222
    descriptor.flags = 0U;
#line 1222
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1222
    if (tmp != 0L) {
#line 1222
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Eeprom write EEWR timed out\n");
    } else {

    }
#line 1223
    return (status);
  } else {

  }
#line 1226
  ixgbe_write_reg(hw, 65560U, eewr);
#line 1228
  status = ixgbe_poll_eerd_eewr_done(hw, 1U);
#line 1229
  if (status != 0) {
#line 1230
    descriptor___0.modname = "ixgbe";
#line 1230
    descriptor___0.function = "ixgbe_write_eewr_buffer_generic";
#line 1230
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1230
    descriptor___0.format = "Eeprom write EEWR timed out\n";
#line 1230
    descriptor___0.lineno = 1230U;
#line 1230
    descriptor___0.flags = 0U;
#line 1230
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 1230
    if (tmp___0 != 0L) {
#line 1230
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Eeprom write EEWR timed out\n");
    } else {

    }
#line 1231
    return (status);
  } else {

  }
#line 1215
  i = (u16 )((int )i + 1);
  ldv_54726: ;
#line 1215
  if ((int )i < (int )words) {
#line 1217
    goto ldv_54725;
  } else {

  }

#line 1235
  return (0);
}
}
#line 1246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_write_eewr_generic(struct ixgbe_hw *hw , u16 offset , u16 data ) 
{ 
  s32 tmp ;

  {
#line 1248
  tmp = ixgbe_write_eewr_buffer_generic(hw, (int )offset, 1, & data);
#line 1248
  return (tmp);
}
}
#line 1259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw , u32 ee_reg ) 
{ 
  u32 i ;
  u32 reg ;

  {
#line 1264
  i = 0U;
#line 1264
  goto ldv_54740;
  ldv_54739: ;
#line 1265
  if (ee_reg == 0U) {
#line 1266
    reg = ixgbe_read_reg(hw, 65556U);
  } else {
#line 1268
    reg = ixgbe_read_reg(hw, 65560U);
  }
#line 1270
  if ((reg & 2U) != 0U) {
#line 1271
    return (0);
  } else {

  }
#line 1273
  __const_udelay(21475UL);
#line 1264
  i = i + 1U;
  ldv_54740: ;
#line 1264
  if (i <= 99999U) {
#line 1266
    goto ldv_54739;
  } else {

  }

#line 1275
  return (-1);
}
}
#line 1285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw ) 
{ 
  u32 eec ;
  u32 i ;
  s32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
#line 1290
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1U);
#line 1290
  if (tmp != 0) {
#line 1291
    return (-16);
  } else {

  }
#line 1293
  eec = ixgbe_read_reg(hw, *(hw->mvals));
#line 1296
  eec = eec | 64U;
#line 1297
  ixgbe_write_reg(hw, *(hw->mvals), eec);
#line 1299
  i = 0U;
#line 1299
  goto ldv_54749;
  ldv_54748: 
#line 1300
  eec = ixgbe_read_reg(hw, *(hw->mvals));
#line 1301
  if ((eec & 128U) != 0U) {
#line 1302
    goto ldv_54747;
  } else {

  }
#line 1303
  __const_udelay(21475UL);
#line 1299
  i = i + 1U;
  ldv_54749: ;
#line 1299
  if (i <= 999U) {
#line 1301
    goto ldv_54748;
  } else {

  }
  ldv_54747: ;
#line 1307
  if ((eec & 128U) == 0U) {
#line 1308
    eec = eec & 4294967231U;
#line 1309
    ixgbe_write_reg(hw, *(hw->mvals), eec);
#line 1310
    descriptor.modname = "ixgbe";
#line 1310
    descriptor.function = "ixgbe_acquire_eeprom";
#line 1310
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1310
    descriptor.format = "Could not acquire EEPROM grant\n";
#line 1310
    descriptor.lineno = 1310U;
#line 1310
    descriptor.flags = 0U;
#line 1310
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1310
    if (tmp___0 != 0L) {
#line 1310
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Could not acquire EEPROM grant\n");
    } else {

    }
#line 1312
    (*(hw->mac.ops.release_swfw_sync))(hw, 1U);
#line 1313
    return (-1);
  } else {

  }
#line 1318
  eec = eec & 4294967292U;
#line 1319
  ixgbe_write_reg(hw, *(hw->mvals), eec);
#line 1320
  ixgbe_read_reg(hw, 8U);
#line 1321
  __const_udelay(4295UL);
#line 1322
  return (0);
}
}
#line 1331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw ) 
{ 
  u32 timeout ;
  u32 i ;
  u32 swsm ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;

  {
#line 1333
  timeout = 2000U;
#line 1338
  i = 0U;
#line 1338
  goto ldv_54760;
  ldv_54759: 
#line 1343
  swsm = ixgbe_read_reg(hw, *(hw->mvals + 5UL));
#line 1344
  if ((swsm & 1U) == 0U) {
#line 1345
    goto ldv_54758;
  } else {

  }
#line 1346
  usleep_range(50UL, 100UL);
#line 1338
  i = i + 1U;
  ldv_54760: ;
#line 1338
  if (i < timeout) {
#line 1340
    goto ldv_54759;
  } else {

  }
  ldv_54758: ;
#line 1349
  if (i == timeout) {
#line 1350
    descriptor.modname = "ixgbe";
#line 1350
    descriptor.function = "ixgbe_get_eeprom_semaphore";
#line 1350
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1350
    descriptor.format = "Driver can\'t access the Eeprom - SMBI Semaphore not granted.\n";
#line 1350
    descriptor.lineno = 1350U;
#line 1350
    descriptor.flags = 0U;
#line 1350
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1350
    if (tmp != 0L) {
#line 1350
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Driver can\'t access the Eeprom - SMBI Semaphore not granted.\n");
    } else {

    }
#line 1356
    ixgbe_release_eeprom_semaphore(hw);
#line 1358
    usleep_range(50UL, 100UL);
#line 1363
    swsm = ixgbe_read_reg(hw, *(hw->mvals + 5UL));
#line 1364
    if ((int )swsm & 1) {
#line 1365
      descriptor___0.modname = "ixgbe";
#line 1365
      descriptor___0.function = "ixgbe_get_eeprom_semaphore";
#line 1365
      descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1365
      descriptor___0.format = "Software semaphore SMBI between device drivers not granted.\n";
#line 1365
      descriptor___0.lineno = 1365U;
#line 1365
      descriptor___0.flags = 0U;
#line 1365
      tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 1365
      if (tmp___0 != 0L) {
#line 1365
        __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Software semaphore SMBI between device drivers not granted.\n");
      } else {

      }
#line 1366
      return (-1);
    } else {

    }
  } else {

  }
#line 1371
  i = 0U;
#line 1371
  goto ldv_54766;
  ldv_54765: 
#line 1372
  swsm = ixgbe_read_reg(hw, *(hw->mvals + 5UL));
#line 1375
  swsm = swsm | 2U;
#line 1376
  ixgbe_write_reg(hw, *(hw->mvals + 5UL), swsm);
#line 1381
  swsm = ixgbe_read_reg(hw, *(hw->mvals + 5UL));
#line 1382
  if ((swsm & 2U) != 0U) {
#line 1383
    goto ldv_54764;
  } else {

  }
#line 1385
  usleep_range(50UL, 100UL);
#line 1371
  i = i + 1U;
  ldv_54766: ;
#line 1371
  if (i < timeout) {
#line 1373
    goto ldv_54765;
  } else {

  }
  ldv_54764: ;
#line 1391
  if (i >= timeout) {
#line 1392
    descriptor___1.modname = "ixgbe";
#line 1392
    descriptor___1.function = "ixgbe_get_eeprom_semaphore";
#line 1392
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1392
    descriptor___1.format = "SWESMBI Software EEPROM semaphore not granted.\n";
#line 1392
    descriptor___1.lineno = 1392U;
#line 1392
    descriptor___1.flags = 0U;
#line 1392
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 1392
    if (tmp___1 != 0L) {
#line 1392
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "SWESMBI Software EEPROM semaphore not granted.\n");
    } else {

    }
#line 1393
    ixgbe_release_eeprom_semaphore(hw);
#line 1394
    return (-1);
  } else {

  }
#line 1397
  return (0);
}
}
#line 1406 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw ) 
{ 
  u32 swsm ;

  {
#line 1410
  swsm = ixgbe_read_reg(hw, *(hw->mvals + 5UL));
#line 1413
  swsm = swsm & 4294967292U;
#line 1414
  ixgbe_write_reg(hw, *(hw->mvals + 5UL), swsm);
#line 1415
  ixgbe_read_reg(hw, 8U);
#line 1416
  return;
}
}
#line 1422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw ) 
{ 
  u16 i ;
  u8 spi_stat_reg ;
  u16 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
#line 1433
  i = 0U;
#line 1433
  goto ldv_54779;
  ldv_54778: 
#line 1434
  ixgbe_shift_out_eeprom_bits(hw, 5, 8);
#line 1436
  tmp = ixgbe_shift_in_eeprom_bits(hw, 8);
#line 1436
  spi_stat_reg = (unsigned char )tmp;
#line 1437
  if (((int )spi_stat_reg & 1) == 0) {
#line 1438
    goto ldv_54777;
  } else {

  }
#line 1440
  __const_udelay(21475UL);
#line 1441
  ixgbe_standby_eeprom(hw);
#line 1433
  i = (unsigned int )i + 5U;
  ldv_54779: ;
#line 1433
  if ((unsigned int )i <= 4999U) {
#line 1435
    goto ldv_54778;
  } else {

  }
  ldv_54777: ;
#line 1448
  if ((unsigned int )i > 4999U) {
#line 1449
    descriptor.modname = "ixgbe";
#line 1449
    descriptor.function = "ixgbe_ready_eeprom";
#line 1449
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1449
    descriptor.format = "SPI EEPROM Status error\n";
#line 1449
    descriptor.lineno = 1449U;
#line 1449
    descriptor.flags = 0U;
#line 1449
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1449
    if (tmp___0 != 0L) {
#line 1449
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "SPI EEPROM Status error\n");
    } else {

    }
#line 1450
    return (-1);
  } else {

  }
#line 1453
  return (0);
}
}
#line 1460 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_standby_eeprom(struct ixgbe_hw *hw ) 
{ 
  u32 eec ;

  {
#line 1464
  eec = ixgbe_read_reg(hw, *(hw->mvals));
#line 1467
  eec = eec | 2U;
#line 1468
  ixgbe_write_reg(hw, *(hw->mvals), eec);
#line 1469
  ixgbe_read_reg(hw, 8U);
#line 1470
  __const_udelay(4295UL);
#line 1471
  eec = eec & 4294967293U;
#line 1472
  ixgbe_write_reg(hw, *(hw->mvals), eec);
#line 1473
  ixgbe_read_reg(hw, 8U);
#line 1474
  __const_udelay(4295UL);
#line 1476
  return;
}
}
#line 1483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw , u16 data , u16 count ) 
{ 
  u32 eec ;
  u32 mask ;
  u32 i ;

  {
#line 1490
  eec = ixgbe_read_reg(hw, *(hw->mvals));
#line 1496
  mask = (u32 )(1 << ((int )count + -1));
#line 1498
  i = 0U;
#line 1498
  goto ldv_54795;
  ldv_54794: ;
#line 1506
  if (((u32 )data & mask) != 0U) {
#line 1507
    eec = eec | 4U;
  } else {
#line 1509
    eec = eec & 4294967291U;
  }
#line 1511
  ixgbe_write_reg(hw, *(hw->mvals), eec);
#line 1512
  ixgbe_read_reg(hw, 8U);
#line 1514
  __const_udelay(4295UL);
#line 1516
  ixgbe_raise_eeprom_clk(hw, & eec);
#line 1517
  ixgbe_lower_eeprom_clk(hw, & eec);
#line 1523
  mask = mask >> 1;
#line 1498
  i = i + 1U;
  ldv_54795: ;
#line 1498
  if ((u32 )count > i) {
#line 1500
    goto ldv_54794;
  } else {

  }
#line 1527
  eec = eec & 4294967291U;
#line 1528
  ixgbe_write_reg(hw, *(hw->mvals), eec);
#line 1529
  ixgbe_read_reg(hw, 8U);
#line 1530
  return;
}
}
#line 1536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw , u16 count ) 
{ 
  u32 eec ;
  u32 i ;
  u16 data ;

  {
#line 1540
  data = 0U;
#line 1549
  eec = ixgbe_read_reg(hw, *(hw->mvals));
#line 1551
  eec = eec & 4294967283U;
#line 1553
  i = 0U;
#line 1553
  goto ldv_54805;
  ldv_54804: 
#line 1554
  data = (int )data << 1U;
#line 1555
  ixgbe_raise_eeprom_clk(hw, & eec);
#line 1557
  eec = ixgbe_read_reg(hw, *(hw->mvals));
#line 1559
  eec = eec & 4294967291U;
#line 1560
  if ((eec & 8U) != 0U) {
#line 1561
    data = (u16 )((unsigned int )data | 1U);
  } else {

  }
#line 1563
  ixgbe_lower_eeprom_clk(hw, & eec);
#line 1553
  i = i + 1U;
  ldv_54805: ;
#line 1553
  if ((u32 )count > i) {
#line 1555
    goto ldv_54804;
  } else {

  }

#line 1566
  return (data);
}
}
#line 1574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw , u32 *eec ) 
{ 


  {
#line 1580
  *eec = *eec | 1U;
#line 1581
  ixgbe_write_reg(hw, *(hw->mvals), *eec);
#line 1582
  ixgbe_read_reg(hw, 8U);
#line 1583
  __const_udelay(4295UL);
#line 1585
  return;
}
}
#line 1591 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw , u32 *eec ) 
{ 


  {
#line 1597
  *eec = *eec & 4294967294U;
#line 1598
  ixgbe_write_reg(hw, *(hw->mvals), *eec);
#line 1599
  ixgbe_read_reg(hw, 8U);
#line 1600
  __const_udelay(4295UL);
#line 1602
  return;
}
}
#line 1607 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_release_eeprom(struct ixgbe_hw *hw ) 
{ 
  u32 eec ;

  {
#line 1611
  eec = ixgbe_read_reg(hw, *(hw->mvals));
#line 1613
  eec = eec | 2U;
#line 1614
  eec = eec & 4294967294U;
#line 1616
  ixgbe_write_reg(hw, *(hw->mvals), eec);
#line 1617
  ixgbe_read_reg(hw, 8U);
#line 1619
  __const_udelay(4295UL);
#line 1622
  eec = eec & 4294967231U;
#line 1623
  ixgbe_write_reg(hw, *(hw->mvals), eec);
#line 1625
  (*(hw->mac.ops.release_swfw_sync))(hw, 1U);
#line 1631
  usleep_range((unsigned long )(hw->eeprom.semaphore_delay * 1000U), (unsigned long )(hw->eeprom.semaphore_delay * 2000U));
#line 1633
  return;
}
}
#line 1639 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw ) 
{ 
  u16 i ;
  u16 j ;
  u16 checksum ;
  u16 length ;
  u16 pointer ;
  u16 word ;
  struct _ddebug descriptor ;
  long tmp ;
  s32 tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  s32 tmp___2 ;
  struct _ddebug descriptor___1 ;
  long tmp___3 ;
  s32 tmp___4 ;
  struct _ddebug descriptor___2 ;
  long tmp___5 ;
  s32 tmp___6 ;

  {
#line 1643
  checksum = 0U;
#line 1644
  length = 0U;
#line 1645
  pointer = 0U;
#line 1646
  word = 0U;
#line 1649
  i = 0U;
#line 1649
  goto ldv_54832;
  ldv_54831: 
#line 1650
  tmp___0 = (*(hw->eeprom.ops.read))(hw, (int )i, & word);
#line 1650
  if (tmp___0 != 0) {
#line 1651
    descriptor.modname = "ixgbe";
#line 1651
    descriptor.function = "ixgbe_calc_eeprom_checksum_generic";
#line 1651
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1651
    descriptor.format = "EEPROM read failed\n";
#line 1651
    descriptor.lineno = 1651U;
#line 1651
    descriptor.flags = 0U;
#line 1651
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1651
    if (tmp != 0L) {
#line 1651
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 1652
    goto ldv_54830;
  } else {

  }
#line 1654
  checksum = (int )checksum + (int )word;
#line 1649
  i = (u16 )((int )i + 1);
  ldv_54832: ;
#line 1649
  if ((unsigned int )i <= 62U) {
#line 1651
    goto ldv_54831;
  } else {

  }
  ldv_54830: 
#line 1658
  i = 3U;
#line 1658
  goto ldv_54841;
  ldv_54840: 
#line 1659
  tmp___2 = (*(hw->eeprom.ops.read))(hw, (int )i, & pointer);
#line 1659
  if (tmp___2 != 0) {
#line 1660
    descriptor___0.modname = "ixgbe";
#line 1660
    descriptor___0.function = "ixgbe_calc_eeprom_checksum_generic";
#line 1660
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1660
    descriptor___0.format = "EEPROM read failed\n";
#line 1660
    descriptor___0.lineno = 1660U;
#line 1660
    descriptor___0.flags = 0U;
#line 1660
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 1660
    if (tmp___1 != 0L) {
#line 1660
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 1661
    return (-1);
  } else {

  }
#line 1665
  if ((unsigned int )pointer == 65535U || (unsigned int )pointer == 0U) {
#line 1666
    goto ldv_54834;
  } else {

  }
#line 1668
  tmp___4 = (*(hw->eeprom.ops.read))(hw, (int )pointer, & length);
#line 1668
  if (tmp___4 != 0) {
#line 1669
    descriptor___1.modname = "ixgbe";
#line 1669
    descriptor___1.function = "ixgbe_calc_eeprom_checksum_generic";
#line 1669
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1669
    descriptor___1.format = "EEPROM read failed\n";
#line 1669
    descriptor___1.lineno = 1669U;
#line 1669
    descriptor___1.flags = 0U;
#line 1669
    tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 1669
    if (tmp___3 != 0L) {
#line 1669
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 1670
    return (-1);
  } else {

  }
#line 1673
  if ((unsigned int )length == 65535U || (unsigned int )length == 0U) {
#line 1674
    goto ldv_54834;
  } else {

  }
#line 1676
  j = (unsigned int )pointer + 1U;
#line 1676
  goto ldv_54838;
  ldv_54837: 
#line 1677
  tmp___6 = (*(hw->eeprom.ops.read))(hw, (int )j, & word);
#line 1677
  if (tmp___6 != 0) {
#line 1678
    descriptor___2.modname = "ixgbe";
#line 1678
    descriptor___2.function = "ixgbe_calc_eeprom_checksum_generic";
#line 1678
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1678
    descriptor___2.format = "EEPROM read failed\n";
#line 1678
    descriptor___2.lineno = 1678U;
#line 1678
    descriptor___2.flags = 0U;
#line 1678
    tmp___5 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 1678
    if (tmp___5 != 0L) {
#line 1678
      __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 1679
    return (-1);
  } else {

  }
#line 1681
  checksum = (int )checksum + (int )word;
#line 1676
  j = (u16 )((int )j + 1);
  ldv_54838: ;
#line 1676
  if ((int )j <= (int )pointer + (int )length) {
#line 1678
    goto ldv_54837;
  } else {

  }

  ldv_54834: 
#line 1658
  i = (u16 )((int )i + 1);
  ldv_54841: ;
#line 1658
  if ((unsigned int )i <= 14U) {
#line 1660
    goto ldv_54840;
  } else {

  }
#line 1685
  checksum = 47802U - (unsigned int )checksum;
#line 1687
  return ((s32 )checksum);
}
}
#line 1698 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw , u16 *checksum_val ) 
{ 
  s32 status ;
  u16 checksum ;
  u16 read_checksum ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
#line 1703
  read_checksum = 0U;
#line 1710
  status = (*(hw->eeprom.ops.read))(hw, 0, & checksum);
#line 1711
  if (status != 0) {
#line 1712
    descriptor.modname = "ixgbe";
#line 1712
    descriptor.function = "ixgbe_validate_eeprom_checksum_generic";
#line 1712
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1712
    descriptor.format = "EEPROM read failed\n";
#line 1712
    descriptor.lineno = 1712U;
#line 1712
    descriptor.flags = 0U;
#line 1712
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1712
    if (tmp != 0L) {
#line 1712
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 1713
    return (status);
  } else {

  }
#line 1716
  status = (*(hw->eeprom.ops.calc_checksum))(hw);
#line 1717
  if (status < 0) {
#line 1718
    return (status);
  } else {

  }
#line 1720
  checksum = (unsigned short )status;
#line 1722
  status = (*(hw->eeprom.ops.read))(hw, 63, & read_checksum);
#line 1723
  if (status != 0) {
#line 1724
    descriptor___0.modname = "ixgbe";
#line 1724
    descriptor___0.function = "ixgbe_validate_eeprom_checksum_generic";
#line 1724
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1724
    descriptor___0.format = "EEPROM read failed\n";
#line 1724
    descriptor___0.lineno = 1724U;
#line 1724
    descriptor___0.flags = 0U;
#line 1724
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 1724
    if (tmp___0 != 0L) {
#line 1724
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 1725
    return (status);
  } else {

  }
#line 1731
  if ((int )read_checksum != (int )checksum) {
#line 1732
    status = -2;
  } else {

  }
#line 1735
  if ((unsigned long )checksum_val != (unsigned long )((u16 *)0U)) {
#line 1736
    *checksum_val = checksum;
  } else {

  }
#line 1738
  return (status);
}
}
#line 1745 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 checksum ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 1755
  status = (*(hw->eeprom.ops.read))(hw, 0, & checksum);
#line 1756
  if (status != 0) {
#line 1757
    descriptor.modname = "ixgbe";
#line 1757
    descriptor.function = "ixgbe_update_eeprom_checksum_generic";
#line 1757
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1757
    descriptor.format = "EEPROM read failed\n";
#line 1757
    descriptor.lineno = 1757U;
#line 1757
    descriptor.flags = 0U;
#line 1757
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1757
    if (tmp != 0L) {
#line 1757
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 1758
    return (status);
  } else {

  }
#line 1761
  status = (*(hw->eeprom.ops.calc_checksum))(hw);
#line 1762
  if (status < 0) {
#line 1763
    return (status);
  } else {

  }
#line 1765
  checksum = (unsigned short )status;
#line 1767
  status = (*(hw->eeprom.ops.write))(hw, 63, (int )checksum);
#line 1769
  return (status);
}
}
#line 1782 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_rar_generic(struct ixgbe_hw *hw , u32 index , u8 *addr , u32 vmdq ,
                          u32 enable_addr ) 
{ 
  u32 rar_low ;
  u32 rar_high ;
  u32 rar_entries ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 1786
  rar_entries = hw->mac.num_rar_entries;
#line 1789
  if (index >= rar_entries) {
#line 1790
    descriptor.modname = "ixgbe";
#line 1790
    descriptor.function = "ixgbe_set_rar_generic";
#line 1790
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1790
    descriptor.format = "RAR index %d is out of range.\n";
#line 1790
    descriptor.lineno = 1790U;
#line 1790
    descriptor.flags = 0U;
#line 1790
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1790
    if (tmp != 0L) {
#line 1790
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "RAR index %d is out of range.\n", index);
    } else {

    }
#line 1791
    return (-32);
  } else {

  }
#line 1795
  (*(hw->mac.ops.set_vmdq))(hw, index, vmdq);
#line 1801
  rar_low = (((unsigned int )*addr | ((unsigned int )*(addr + 1UL) << 8)) | ((unsigned int )*(addr + 2UL) << 16)) | ((unsigned int )*(addr + 3UL) << 24);
#line 1810
  rar_high = ixgbe_read_reg(hw, index <= 15U ? index * 8U + 21508U : index * 8U + 41476U);
#line 1811
  rar_high = rar_high & 2147418112U;
#line 1812
  rar_high = ((unsigned int )*(addr + 4UL) | ((unsigned int )*(addr + 5UL) << 8)) | rar_high;
#line 1814
  if (enable_addr != 0U) {
#line 1815
    rar_high = rar_high | 2147483648U;
  } else {

  }
#line 1817
  ixgbe_write_reg(hw, index <= 15U ? (index + 2688U) * 8U : (index + 5184U) * 8U,
                  rar_low);
#line 1818
  ixgbe_write_reg(hw, index <= 15U ? index * 8U + 21508U : index * 8U + 41476U, rar_high);
#line 1820
  return (0);
}
}
#line 1830 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_clear_rar_generic(struct ixgbe_hw *hw , u32 index ) 
{ 
  u32 rar_high ;
  u32 rar_entries ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 1833
  rar_entries = hw->mac.num_rar_entries;
#line 1836
  if (index >= rar_entries) {
#line 1837
    descriptor.modname = "ixgbe";
#line 1837
    descriptor.function = "ixgbe_clear_rar_generic";
#line 1837
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1837
    descriptor.format = "RAR index %d is out of range.\n";
#line 1837
    descriptor.lineno = 1837U;
#line 1837
    descriptor.flags = 0U;
#line 1837
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1837
    if (tmp != 0L) {
#line 1837
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "RAR index %d is out of range.\n", index);
    } else {

    }
#line 1838
    return (-32);
  } else {

  }
#line 1846
  rar_high = ixgbe_read_reg(hw, index <= 15U ? index * 8U + 21508U : index * 8U + 41476U);
#line 1847
  rar_high = rar_high & 2147418112U;
#line 1849
  ixgbe_write_reg(hw, index <= 15U ? (index + 2688U) * 8U : (index + 5184U) * 8U,
                  0U);
#line 1850
  ixgbe_write_reg(hw, index <= 15U ? index * 8U + 21508U : index * 8U + 41476U, rar_high);
#line 1853
  (*(hw->mac.ops.clear_vmdq))(hw, index, 4294967295U);
#line 1855
  return (0);
}
}
#line 1866 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw ) 
{ 
  u32 i ;
  u32 rar_entries ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  struct _ddebug descriptor___2 ;
  long tmp___4 ;
  struct _ddebug descriptor___3 ;
  long tmp___5 ;

  {
#line 1869
  rar_entries = hw->mac.num_rar_entries;
#line 1876
  tmp___2 = is_valid_ether_addr((u8 const   *)(& hw->mac.addr));
#line 1876
  if (tmp___2) {
#line 1876
    tmp___3 = 0;
  } else {
#line 1876
    tmp___3 = 1;
  }
#line 1876
  if (tmp___3) {
#line 1878
    (*(hw->mac.ops.get_mac_addr))(hw, (u8 *)(& hw->mac.addr));
#line 1880
    descriptor.modname = "ixgbe";
#line 1880
    descriptor.function = "ixgbe_init_rx_addrs_generic";
#line 1880
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1880
    descriptor.format = " Keeping Current RAR0 Addr =%pM\n";
#line 1880
    descriptor.lineno = 1880U;
#line 1880
    descriptor.flags = 0U;
#line 1880
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1880
    if (tmp != 0L) {
#line 1880
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           " Keeping Current RAR0 Addr =%pM\n", (u8 *)(& hw->mac.addr));
    } else {

    }
  } else {
#line 1883
    descriptor___0.modname = "ixgbe";
#line 1883
    descriptor___0.function = "ixgbe_init_rx_addrs_generic";
#line 1883
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1883
    descriptor___0.format = "Overriding MAC Address in RAR[0]\n";
#line 1883
    descriptor___0.lineno = 1883U;
#line 1883
    descriptor___0.flags = 0U;
#line 1883
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 1883
    if (tmp___0 != 0L) {
#line 1883
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Overriding MAC Address in RAR[0]\n");
    } else {

    }
#line 1884
    descriptor___1.modname = "ixgbe";
#line 1884
    descriptor___1.function = "ixgbe_init_rx_addrs_generic";
#line 1884
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1884
    descriptor___1.format = " New MAC Addr =%pM\n";
#line 1884
    descriptor___1.lineno = 1884U;
#line 1884
    descriptor___1.flags = 0U;
#line 1884
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 1884
    if (tmp___1 != 0L) {
#line 1884
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           " New MAC Addr =%pM\n", (u8 *)(& hw->mac.addr));
    } else {

    }
#line 1886
    (*(hw->mac.ops.set_rar))(hw, 0U, (u8 *)(& hw->mac.addr), 0U, 2147483648U);
#line 1889
    (*(hw->mac.ops.clear_vmdq))(hw, 0U, 4294967295U);
  }
#line 1891
  hw->addr_ctrl.overflow_promisc = 0U;
#line 1893
  hw->addr_ctrl.rar_used_count = 1U;
#line 1896
  descriptor___2.modname = "ixgbe";
#line 1896
  descriptor___2.function = "ixgbe_init_rx_addrs_generic";
#line 1896
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1896
  descriptor___2.format = "Clearing RAR[1-%d]\n";
#line 1896
  descriptor___2.lineno = 1896U;
#line 1896
  descriptor___2.flags = 0U;
#line 1896
  tmp___4 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 1896
  if (tmp___4 != 0L) {
#line 1896
    __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Clearing RAR[1-%d]\n", rar_entries - 1U);
  } else {

  }
#line 1897
  i = 1U;
#line 1897
  goto ldv_54891;
  ldv_54890: 
#line 1898
  ixgbe_write_reg(hw, i <= 15U ? (i + 2688U) * 8U : (i + 5184U) * 8U, 0U);
#line 1899
  ixgbe_write_reg(hw, i <= 15U ? i * 8U + 21508U : i * 8U + 41476U, 0U);
#line 1897
  i = i + 1U;
  ldv_54891: ;
#line 1897
  if (i < rar_entries) {
#line 1899
    goto ldv_54890;
  } else {

  }
#line 1903
  hw->addr_ctrl.mta_in_use = 0U;
#line 1904
  ixgbe_write_reg(hw, 20624U, (u32 )hw->mac.mc_filter_type);
#line 1906
  descriptor___3.modname = "ixgbe";
#line 1906
  descriptor___3.function = "ixgbe_init_rx_addrs_generic";
#line 1906
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1906
  descriptor___3.format = " Clearing MTA\n";
#line 1906
  descriptor___3.lineno = 1906U;
#line 1906
  descriptor___3.flags = 0U;
#line 1906
  tmp___5 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
#line 1906
  if (tmp___5 != 0L) {
#line 1906
    __dynamic_netdev_dbg(& descriptor___3, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Clearing MTA\n");
  } else {

  }
#line 1907
  i = 0U;
#line 1907
  goto ldv_54895;
  ldv_54894: 
#line 1908
  ixgbe_write_reg(hw, (i + 5248U) * 4U, 0U);
#line 1907
  i = i + 1U;
  ldv_54895: ;
#line 1907
  if (hw->mac.mcft_size > i) {
#line 1909
    goto ldv_54894;
  } else {

  }

#line 1910
  if ((unsigned long )hw->mac.ops.init_uta_tables != (unsigned long )((s32 (*)(struct ixgbe_hw * ))0)) {
#line 1911
    (*(hw->mac.ops.init_uta_tables))(hw);
  } else {

  }
#line 1913
  return (0);
}
}
#line 1928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_mta_vector(struct ixgbe_hw *hw , u8 *mc_addr ) 
{ 
  u32 vector ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 1930
  vector = 0U;
#line 1932
  switch (hw->mac.mc_filter_type) {
  case 0: 
#line 1934
  vector = (u32 )(((int )*(mc_addr + 4UL) >> 4) | ((int )*(mc_addr + 5UL) << 4));
#line 1935
  goto ldv_54903;
  case 1: 
#line 1937
  vector = (u32 )(((int )*(mc_addr + 4UL) >> 3) | ((int )*(mc_addr + 5UL) << 5));
#line 1938
  goto ldv_54903;
  case 2: 
#line 1940
  vector = (u32 )(((int )*(mc_addr + 4UL) >> 2) | ((int )*(mc_addr + 5UL) << 6));
#line 1941
  goto ldv_54903;
  case 3: 
#line 1943
  vector = (u32 )((int )*(mc_addr + 4UL) | ((int )*(mc_addr + 5UL) << 8));
#line 1944
  goto ldv_54903;
  default: 
#line 1946
  descriptor.modname = "ixgbe";
#line 1946
  descriptor.function = "ixgbe_mta_vector";
#line 1946
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1946
  descriptor.format = "MC filter type param set incorrectly\n";
#line 1946
  descriptor.lineno = 1946U;
#line 1946
  descriptor.flags = 0U;
#line 1946
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1946
  if (tmp != 0L) {
#line 1946
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "MC filter type param set incorrectly\n");
  } else {

  }
#line 1947
  goto ldv_54903;
  }
  ldv_54903: 
#line 1951
  vector = vector & 4095U;
#line 1952
  return ((s32 )vector);
}
}
#line 1962 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_set_mta(struct ixgbe_hw *hw , u8 *mc_addr ) 
{ 
  u32 vector ;
  u32 vector_bit ;
  u32 vector_reg ;
  s32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
#line 1968
  hw->addr_ctrl.mta_in_use = hw->addr_ctrl.mta_in_use + 1U;
#line 1970
  tmp = ixgbe_mta_vector(hw, mc_addr);
#line 1970
  vector = (u32 )tmp;
#line 1971
  descriptor.modname = "ixgbe";
#line 1971
  descriptor.function = "ixgbe_set_mta";
#line 1971
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1971
  descriptor.format = " bit-vector = 0x%03X\n";
#line 1971
  descriptor.lineno = 1971U;
#line 1971
  descriptor.flags = 0U;
#line 1971
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1971
  if (tmp___0 != 0L) {
#line 1971
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " bit-vector = 0x%03X\n", vector);
  } else {

  }
#line 1982
  vector_reg = (vector >> 5) & 127U;
#line 1983
  vector_bit = vector & 31U;
#line 1984
  hw->mac.mta_shadow[vector_reg] = hw->mac.mta_shadow[vector_reg] | (u32 )(1 << (int )vector_bit);
#line 1985
  return;
}
}
#line 1997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw , struct net_device *netdev ) 
{ 
  struct netdev_hw_addr *ha ;
  u32 i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct list_head  const  *__mptr ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;

  {
#line 2007
  hw->addr_ctrl.num_mc_addrs = (u32 )netdev->mc.count;
#line 2008
  hw->addr_ctrl.mta_in_use = 0U;
#line 2011
  descriptor.modname = "ixgbe";
#line 2011
  descriptor.function = "ixgbe_update_mc_addr_list_generic";
#line 2011
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2011
  descriptor.format = " Clearing MTA\n";
#line 2011
  descriptor.lineno = 2011U;
#line 2011
  descriptor.flags = 0U;
#line 2011
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2011
  if (tmp != 0L) {
#line 2011
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Clearing MTA\n");
  } else {

  }
#line 2012
  memset((void *)(& hw->mac.mta_shadow), 0, 512UL);
#line 2015
  __mptr = (struct list_head  const  *)netdev->mc.list.next;
#line 2015
  ha = (struct netdev_hw_addr *)__mptr;
#line 2015
  goto ldv_54933;
  ldv_54932: 
#line 2016
  descriptor___0.modname = "ixgbe";
#line 2016
  descriptor___0.function = "ixgbe_update_mc_addr_list_generic";
#line 2016
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2016
  descriptor___0.format = " Adding the multicast addresses:\n";
#line 2016
  descriptor___0.lineno = 2016U;
#line 2016
  descriptor___0.flags = 0U;
#line 2016
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 2016
  if (tmp___0 != 0L) {
#line 2016
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Adding the multicast addresses:\n");
  } else {

  }
#line 2017
  ixgbe_set_mta(hw, (u8 *)(& ha->addr));
#line 2015
  __mptr___0 = (struct list_head  const  *)ha->list.next;
#line 2015
  ha = (struct netdev_hw_addr *)__mptr___0;
  ldv_54933: ;
#line 2015
  if ((unsigned long )(& ha->list) != (unsigned long )(& netdev->mc.list)) {
#line 2017
    goto ldv_54932;
  } else {

  }
#line 2021
  i = 0U;
#line 2021
  goto ldv_54936;
  ldv_54935: 
#line 2022
  ixgbe_write_reg(hw, (i << 2) + 20992U, hw->mac.mta_shadow[i]);
#line 2021
  i = i + 1U;
  ldv_54936: ;
#line 2021
  if (hw->mac.mcft_size > i) {
#line 2023
    goto ldv_54935;
  } else {

  }

#line 2025
  if (hw->addr_ctrl.mta_in_use != 0U) {
#line 2026
    ixgbe_write_reg(hw, 20624U, (u32 )(hw->mac.mc_filter_type | 4));
  } else {

  }
#line 2029
  descriptor___1.modname = "ixgbe";
#line 2029
  descriptor___1.function = "ixgbe_update_mc_addr_list_generic";
#line 2029
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2029
  descriptor___1.format = "ixgbe_update_mc_addr_list_generic Complete\n";
#line 2029
  descriptor___1.lineno = 2029U;
#line 2029
  descriptor___1.flags = 0U;
#line 2029
  tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 2029
  if (tmp___1 != 0L) {
#line 2029
    __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "ixgbe_update_mc_addr_list_generic Complete\n");
  } else {

  }
#line 2030
  return (0);
}
}
#line 2039 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_addr_filter_info *a ;

  {
#line 2041
  a = & hw->addr_ctrl;
#line 2043
  if (a->mta_in_use != 0U) {
#line 2044
    ixgbe_write_reg(hw, 20624U, (u32 )(hw->mac.mc_filter_type | 4));
  } else {

  }
#line 2047
  return (0);
}
}
#line 2056 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_addr_filter_info *a ;

  {
#line 2058
  a = & hw->addr_ctrl;
#line 2060
  if (a->mta_in_use != 0U) {
#line 2061
    ixgbe_write_reg(hw, 20624U, (u32 )hw->mac.mc_filter_type);
  } else {

  }
#line 2063
  return (0);
}
}
#line 2072 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw ) 
{ 
  u32 mflcn_reg ;
  u32 fccfg_reg ;
  u32 reg ;
  u32 fcrtl ;
  u32 fcrth ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  u32 tmp___1 ;

  {
#line 2080
  if ((unsigned int )hw->fc.pause_time == 0U) {
#line 2081
    return (-13);
  } else {

  }
#line 2084
  i = 0;
#line 2084
  goto ldv_54959;
  ldv_54958: ;
#line 2085
  if (((unsigned int )hw->fc.current_mode & 2U) != 0U && hw->fc.high_water[i] != 0U) {
#line 2087
    if (hw->fc.low_water[i] == 0U || hw->fc.low_water[i] >= hw->fc.high_water[i]) {
#line 2089
      descriptor.modname = "ixgbe";
#line 2089
      descriptor.function = "ixgbe_fc_enable_generic";
#line 2089
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2089
      descriptor.format = "Invalid water mark configuration\n";
#line 2089
      descriptor.lineno = 2089U;
#line 2089
      descriptor.flags = 0U;
#line 2089
      tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2089
      if (tmp != 0L) {
#line 2089
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Invalid water mark configuration\n");
      } else {

      }
#line 2090
      return (-13);
    } else {

    }
  } else {

  }
#line 2084
  i = i + 1;
  ldv_54959: ;
#line 2084
  if (i <= 7) {
#line 2086
    goto ldv_54958;
  } else {

  }
#line 2096
  ixgbe_fc_autoneg(hw);
#line 2099
  mflcn_reg = ixgbe_read_reg(hw, 17044U);
#line 2100
  mflcn_reg = mflcn_reg & 4294963203U;
#line 2102
  fccfg_reg = ixgbe_read_reg(hw, 15616U);
#line 2103
  fccfg_reg = fccfg_reg & 4294967271U;
#line 2115
  switch ((unsigned int )hw->fc.current_mode) {
  case 0U: ;
#line 2121
  goto ldv_54962;
  case 1U: 
#line 2131
  mflcn_reg = mflcn_reg | 8U;
#line 2132
  goto ldv_54962;
  case 2U: 
#line 2138
  fccfg_reg = fccfg_reg | 8U;
#line 2139
  goto ldv_54962;
  case 3U: 
#line 2142
  mflcn_reg = mflcn_reg | 8U;
#line 2143
  fccfg_reg = fccfg_reg | 8U;
#line 2144
  goto ldv_54962;
  default: 
#line 2146
  descriptor___0.modname = "ixgbe";
#line 2146
  descriptor___0.function = "ixgbe_fc_enable_generic";
#line 2146
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2146
  descriptor___0.format = "Flow control param set incorrectly\n";
#line 2146
  descriptor___0.lineno = 2146U;
#line 2146
  descriptor___0.flags = 0U;
#line 2146
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 2146
  if (tmp___0 != 0L) {
#line 2146
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Flow control param set incorrectly\n");
  } else {

  }
#line 2147
  return (-4);
  }
  ldv_54962: 
#line 2151
  mflcn_reg = mflcn_reg | 2U;
#line 2152
  ixgbe_write_reg(hw, 17044U, mflcn_reg);
#line 2153
  ixgbe_write_reg(hw, 15616U, fccfg_reg);
#line 2156
  i = 0;
#line 2156
  goto ldv_54969;
  ldv_54968: ;
#line 2157
  if (((unsigned int )hw->fc.current_mode & 2U) != 0U && hw->fc.high_water[i] != 0U) {
#line 2159
    fcrtl = (hw->fc.low_water[i] << 10) | 2147483648U;
#line 2160
    ixgbe_write_reg(hw, (u32 )((i + 3208) * 4), fcrtl);
#line 2161
    fcrth = (hw->fc.high_water[i] << 10) | 2147483648U;
  } else {
#line 2163
    ixgbe_write_reg(hw, (u32 )((i + 3208) * 4), 0U);
#line 2170
    tmp___1 = ixgbe_read_reg(hw, (u32 )((i + 3840) * 4));
#line 2170
    fcrth = tmp___1 - 32U;
  }
#line 2173
  ixgbe_write_reg(hw, (u32 )((i + 3224) * 4), fcrth);
#line 2156
  i = i + 1;
  ldv_54969: ;
#line 2156
  if (i <= 7) {
#line 2158
    goto ldv_54968;
  } else {

  }
#line 2177
  reg = (u32 )((int )hw->fc.pause_time * 65537);
#line 2178
  i = 0;
#line 2178
  goto ldv_54972;
  ldv_54971: 
#line 2179
  ixgbe_write_reg(hw, (u32 )((i + 3200) * 4), reg);
#line 2178
  i = i + 1;
  ldv_54972: ;
#line 2178
  if (i <= 3) {
#line 2180
    goto ldv_54971;
  } else {

  }
#line 2181
  ixgbe_write_reg(hw, 12960U, (unsigned int )hw->fc.pause_time / 2U);
#line 2183
  return (0);
}
}
#line 2199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_negotiate_fc(struct ixgbe_hw *hw , u32 adv_reg , u32 lp_reg , u32 adv_sym ,
                              u32 adv_asm , u32 lp_sym , u32 lp_asm ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;

  {
#line 2202
  if (adv_reg == 0U || lp_reg == 0U) {
#line 2203
    return (-27);
  } else {

  }
#line 2205
  if ((adv_reg & adv_sym) != 0U && (lp_reg & lp_sym) != 0U) {
#line 2213
    if ((unsigned int )hw->fc.requested_mode == 3U) {
#line 2214
      hw->fc.current_mode = 3;
#line 2215
      descriptor.modname = "ixgbe";
#line 2215
      descriptor.function = "ixgbe_negotiate_fc";
#line 2215
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2215
      descriptor.format = "Flow Control = FULL.\n";
#line 2215
      descriptor.lineno = 2215U;
#line 2215
      descriptor.flags = 0U;
#line 2215
      tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2215
      if (tmp != 0L) {
#line 2215
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Flow Control = FULL.\n");
      } else {

      }
    } else {
#line 2217
      hw->fc.current_mode = 1;
#line 2218
      descriptor___0.modname = "ixgbe";
#line 2218
      descriptor___0.function = "ixgbe_negotiate_fc";
#line 2218
      descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2218
      descriptor___0.format = "Flow Control=RX PAUSE frames only\n";
#line 2218
      descriptor___0.lineno = 2218U;
#line 2218
      descriptor___0.flags = 0U;
#line 2218
      tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 2218
      if (tmp___0 != 0L) {
#line 2218
        __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Flow Control=RX PAUSE frames only\n");
      } else {

      }
    }
  } else
#line 2220
  if ((((adv_reg & adv_sym) == 0U && (adv_reg & adv_asm) != 0U) && (lp_reg & lp_sym) != 0U) && (lp_reg & lp_asm) != 0U) {
#line 2222
    hw->fc.current_mode = 2;
#line 2223
    descriptor___1.modname = "ixgbe";
#line 2223
    descriptor___1.function = "ixgbe_negotiate_fc";
#line 2223
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2223
    descriptor___1.format = "Flow Control = TX PAUSE frames only.\n";
#line 2223
    descriptor___1.lineno = 2223U;
#line 2223
    descriptor___1.flags = 0U;
#line 2223
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 2223
    if (tmp___1 != 0L) {
#line 2223
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flow Control = TX PAUSE frames only.\n");
    } else {

    }
  } else
#line 2224
  if ((((adv_reg & adv_sym) != 0U && (adv_reg & adv_asm) != 0U) && (lp_reg & lp_sym) == 0U) && (lp_reg & lp_asm) != 0U) {
#line 2226
    hw->fc.current_mode = 1;
#line 2227
    descriptor___2.modname = "ixgbe";
#line 2227
    descriptor___2.function = "ixgbe_negotiate_fc";
#line 2227
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2227
    descriptor___2.format = "Flow Control = RX PAUSE frames only.\n";
#line 2227
    descriptor___2.lineno = 2227U;
#line 2227
    descriptor___2.flags = 0U;
#line 2227
    tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 2227
    if (tmp___2 != 0L) {
#line 2227
      __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flow Control = RX PAUSE frames only.\n");
    } else {

    }
  } else {
#line 2229
    hw->fc.current_mode = 0;
#line 2230
    descriptor___3.modname = "ixgbe";
#line 2230
    descriptor___3.function = "ixgbe_negotiate_fc";
#line 2230
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2230
    descriptor___3.format = "Flow Control = NONE.\n";
#line 2230
    descriptor___3.lineno = 2230U;
#line 2230
    descriptor___3.flags = 0U;
#line 2230
    tmp___3 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
#line 2230
    if (tmp___3 != 0L) {
#line 2230
      __dynamic_netdev_dbg(& descriptor___3, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flow Control = NONE.\n");
    } else {

    }
  }
#line 2232
  return (0);
}
}
#line 2241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_fc_autoneg_fiber(struct ixgbe_hw *hw ) 
{ 
  u32 pcs_anadv_reg ;
  u32 pcs_lpab_reg ;
  u32 linkstat ;
  s32 ret_val ;

  {
#line 2252
  linkstat = ixgbe_read_reg(hw, 16908U);
#line 2253
  if ((linkstat & 65536U) == 0U || (linkstat & 262144U) != 0U) {
#line 2255
    return (-27);
  } else {

  }
#line 2257
  pcs_anadv_reg = ixgbe_read_reg(hw, 16920U);
#line 2258
  pcs_lpab_reg = ixgbe_read_reg(hw, 16924U);
#line 2260
  ret_val = ixgbe_negotiate_fc(hw, pcs_anadv_reg, pcs_lpab_reg, 128U, 256U, 128U,
                               256U);
#line 2266
  return (ret_val);
}
}
#line 2275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_fc_autoneg_backplane(struct ixgbe_hw *hw ) 
{ 
  u32 links2 ;
  u32 anlp1_reg ;
  u32 autoc_reg ;
  u32 links ;
  s32 ret_val ;

  {
#line 2285
  links = ixgbe_read_reg(hw, 17060U);
#line 2286
  if ((int )links >= 0) {
#line 2287
    return (-27);
  } else {

  }
#line 2289
  if ((unsigned int )hw->mac.type == 2U) {
#line 2290
    links2 = ixgbe_read_reg(hw, 17188U);
#line 2291
    if ((links2 & 64U) == 0U) {
#line 2292
      return (-27);
    } else {

    }
  } else {

  }
#line 2298
  autoc_reg = ixgbe_read_reg(hw, 17056U);
#line 2299
  anlp1_reg = ixgbe_read_reg(hw, 17072U);
#line 2301
  ret_val = ixgbe_negotiate_fc(hw, autoc_reg, anlp1_reg, 268435456U, 536870912U, 1024U,
                               2048U);
#line 2305
  return (ret_val);
}
}
#line 2314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_fc_autoneg_copper(struct ixgbe_hw *hw ) 
{ 
  u16 technology_ability_reg ;
  u16 lp_technology_ability_reg ;
  s32 tmp ;

  {
#line 2316
  technology_ability_reg = 0U;
#line 2317
  lp_technology_ability_reg = 0U;
#line 2319
  (*(hw->phy.ops.read_reg))(hw, 16U, 7U, & technology_ability_reg);
#line 2322
  (*(hw->phy.ops.read_reg))(hw, 19U, 7U, & lp_technology_ability_reg);
#line 2326
  tmp = ixgbe_negotiate_fc(hw, (unsigned int )technology_ability_reg, (unsigned int )lp_technology_ability_reg,
                           1024U, 2048U, 1024U, 2048U);
#line 2326
  return (tmp);
}
}
#line 2339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_fc_autoneg(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;
  ixgbe_link_speed speed ;
  bool link_up ;
  bool tmp ;

  {
#line 2341
  ret_val = -27;
#line 2354
  if ((int )hw->fc.disable_fc_autoneg) {
#line 2355
    goto out;
  } else {

  }
#line 2357
  (*(hw->mac.ops.check_link))(hw, & speed, & link_up, 0);
#line 2358
  if (! link_up) {
#line 2359
    goto out;
  } else {

  }
#line 2361
  switch ((unsigned int )hw->phy.media_type) {
  case 1U: ;
#line 2364
  if (speed == 32U) {
#line 2365
    ret_val = ixgbe_fc_autoneg_fiber(hw);
  } else {

  }
#line 2366
  goto ldv_55017;
  case 5U: 
#line 2370
  ret_val = ixgbe_fc_autoneg_backplane(hw);
#line 2371
  goto ldv_55017;
  case 4U: 
#line 2375
  tmp = ixgbe_device_supports_autoneg_fc(hw);
#line 2375
  if ((int )tmp) {
#line 2376
    ret_val = ixgbe_fc_autoneg_copper(hw);
  } else {

  }
#line 2377
  goto ldv_55017;
  default: ;
#line 2380
  goto ldv_55017;
  }
  ldv_55017: ;
  out: ;
#line 2384
  if (ret_val == 0) {
#line 2385
    hw->fc.fc_was_autonegged = 1;
  } else {
#line 2387
    hw->fc.fc_was_autonegged = 0;
#line 2388
    hw->fc.current_mode = hw->fc.requested_mode;
  }
#line 2390
  return;
}
}
#line 2402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static u32 ixgbe_pcie_timeout_poll(struct ixgbe_hw *hw ) 
{ 
  s16 devctl2 ;
  u32 pollcnt ;
  u16 tmp ;

  {
#line 2407
  tmp = ixgbe_read_pci_cfg_word(hw, 200U);
#line 2407
  devctl2 = (s16 )tmp;
#line 2408
  devctl2 = (int )devctl2 & 15;
#line 2410
  switch ((int )devctl2) {
  case 6: 
#line 2412
  pollcnt = 1300U;
#line 2413
  goto ldv_55027;
  case 9: 
#line 2415
  pollcnt = 5200U;
#line 2416
  goto ldv_55027;
  case 10: 
#line 2418
  pollcnt = 20000U;
#line 2419
  goto ldv_55027;
  case 13: 
#line 2421
  pollcnt = 80000U;
#line 2422
  goto ldv_55027;
  case 14: 
#line 2424
  pollcnt = 34000U;
#line 2425
  goto ldv_55027;
  case 1: ;
  case 2: ;
  case 5: ;
  case 0: ;
  default: 
#line 2431
  pollcnt = 800U;
#line 2432
  goto ldv_55027;
  }
  ldv_55027: ;
#line 2436
  return ((pollcnt * 11U) / 10U);
}
}
#line 2448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw ) 
{ 
  u32 i ;
  u32 poll ;
  u16 value ;
  u32 tmp ;
  bool tmp___0 ;
  u32 tmp___1 ;
  struct _ddebug descriptor ;
  long tmp___2 ;
  bool tmp___3 ;
  struct _ddebug descriptor___0 ;
  long tmp___4 ;

  {
#line 2454
  ixgbe_write_reg(hw, 0U, 4U);
#line 2457
  tmp = ixgbe_read_reg(hw, 8U);
#line 2457
  if ((tmp & 524288U) == 0U) {
#line 2459
    return (0);
  } else {
#line 2457
    tmp___0 = ixgbe_removed((void *)hw->hw_addr);
#line 2457
    if ((int )tmp___0) {
#line 2459
      return (0);
    } else {

    }
  }
#line 2462
  i = 0U;
#line 2462
  goto ldv_55044;
  ldv_55043: 
#line 2463
  __const_udelay(429500UL);
#line 2464
  tmp___1 = ixgbe_read_reg(hw, 8U);
#line 2464
  if ((tmp___1 & 524288U) == 0U) {
#line 2465
    return (0);
  } else {

  }
#line 2462
  i = i + 1U;
  ldv_55044: ;
#line 2462
  if (i <= 799U) {
#line 2464
    goto ldv_55043;
  } else {

  }
#line 2476
  descriptor.modname = "ixgbe";
#line 2476
  descriptor.function = "ixgbe_disable_pcie_master";
#line 2476
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2476
  descriptor.format = "GIO Master Disable bit didn\'t clear - requesting resets\n";
#line 2476
  descriptor.lineno = 2476U;
#line 2476
  descriptor.flags = 0U;
#line 2476
  tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2476
  if (tmp___2 != 0L) {
#line 2476
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "GIO Master Disable bit didn\'t clear - requesting resets\n");
  } else {

  }
#line 2477
  hw->mac.flags = (u8 )((unsigned int )hw->mac.flags | 1U);
#line 2483
  poll = ixgbe_pcie_timeout_poll(hw);
#line 2484
  i = 0U;
#line 2484
  goto ldv_55049;
  ldv_55048: 
#line 2485
  __const_udelay(429500UL);
#line 2486
  value = ixgbe_read_pci_cfg_word(hw, 170U);
#line 2487
  tmp___3 = ixgbe_removed((void *)hw->hw_addr);
#line 2487
  if ((int )tmp___3) {
#line 2488
    return (0);
  } else {

  }
#line 2489
  if (((int )value & 32) == 0) {
#line 2490
    return (0);
  } else {

  }
#line 2484
  i = i + 1U;
  ldv_55049: ;
#line 2484
  if (i < poll) {
#line 2486
    goto ldv_55048;
  } else {

  }
#line 2493
  descriptor___0.modname = "ixgbe";
#line 2493
  descriptor___0.function = "ixgbe_disable_pcie_master";
#line 2493
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2493
  descriptor___0.format = "PCIe transaction pending bit also did not clear.\n";
#line 2493
  descriptor___0.lineno = 2493U;
#line 2493
  descriptor___0.flags = 0U;
#line 2493
  tmp___4 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 2493
  if (tmp___4 != 0L) {
#line 2493
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "PCIe transaction pending bit also did not clear.\n");
  } else {

  }
#line 2494
  return (-12);
}
}
#line 2505 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw , u32 mask ) 
{ 
  u32 gssr ;
  u32 swmask ;
  u32 fwmask ;
  u32 timeout ;
  u32 i ;
  s32 tmp ;

  {
#line 2507
  gssr = 0U;
#line 2508
  swmask = mask;
#line 2509
  fwmask = mask << 5;
#line 2510
  timeout = 200U;
#line 2513
  i = 0U;
#line 2513
  goto ldv_55062;
  ldv_55061: 
#line 2518
  tmp = ixgbe_get_eeprom_semaphore(hw);
#line 2518
  if (tmp != 0) {
#line 2519
    return (-16);
  } else {

  }
#line 2521
  gssr = ixgbe_read_reg(hw, 65888U);
#line 2522
  if (((fwmask | swmask) & gssr) == 0U) {
#line 2523
    gssr = gssr | swmask;
#line 2524
    ixgbe_write_reg(hw, 65888U, gssr);
#line 2525
    ixgbe_release_eeprom_semaphore(hw);
#line 2526
    return (0);
  } else {
#line 2529
    ixgbe_release_eeprom_semaphore(hw);
#line 2530
    usleep_range(5000UL, 10000UL);
  }
#line 2513
  i = i + 1U;
  ldv_55062: ;
#line 2513
  if (i < timeout) {
#line 2515
    goto ldv_55061;
  } else {

  }

#line 2535
  if (((fwmask | swmask) & gssr) != 0U) {
#line 2536
    ixgbe_release_swfw_sync(hw, (fwmask | swmask) & gssr);
  } else {

  }
#line 2538
  usleep_range(5000UL, 10000UL);
#line 2539
  return (-16);
}
}
#line 2550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_release_swfw_sync(struct ixgbe_hw *hw , u32 mask ) 
{ 
  u32 gssr ;
  u32 swmask ;

  {
#line 2553
  swmask = mask;
#line 2555
  ixgbe_get_eeprom_semaphore(hw);
#line 2557
  gssr = ixgbe_read_reg(hw, 65888U);
#line 2558
  gssr = ~ swmask & gssr;
#line 2559
  ixgbe_write_reg(hw, 65888U, gssr);
#line 2561
  ixgbe_release_eeprom_semaphore(hw);
#line 2562
  return;
}
}
#line 2573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 prot_autoc_read_generic(struct ixgbe_hw *hw , bool *locked , u32 *reg_val ) 
{ 


  {
#line 2575
  *locked = 0;
#line 2576
  *reg_val = ixgbe_read_reg(hw, 17056U);
#line 2577
  return (0);
}
}
#line 2587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 prot_autoc_write_generic(struct ixgbe_hw *hw , u32 reg_val , bool locked ) 
{ 


  {
#line 2589
  ixgbe_write_reg(hw, 17056U, reg_val);
#line 2590
  return (0);
}
}
#line 2600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_disable_rx_buff_generic(struct ixgbe_hw *hw ) 
{ 
  int i ;
  int secrxreg ;
  u32 tmp ;
  u32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
#line 2606
  tmp = ixgbe_read_reg(hw, 36096U);
#line 2606
  secrxreg = (int )tmp;
#line 2607
  secrxreg = secrxreg | 2;
#line 2608
  ixgbe_write_reg(hw, 36096U, (u32 )secrxreg);
#line 2609
  i = 0;
#line 2609
  goto ldv_55087;
  ldv_55086: 
#line 2610
  tmp___0 = ixgbe_read_reg(hw, 36100U);
#line 2610
  secrxreg = (int )tmp___0;
#line 2611
  if (secrxreg & 1) {
#line 2612
    goto ldv_55085;
  } else {
#line 2615
    __const_udelay(4295000UL);
  }
#line 2609
  i = i + 1;
  ldv_55087: ;
#line 2609
  if (i <= 39) {
#line 2611
    goto ldv_55086;
  } else {

  }
  ldv_55085: ;
#line 2619
  if (i > 39) {
#line 2620
    descriptor.modname = "ixgbe";
#line 2620
    descriptor.function = "ixgbe_disable_rx_buff_generic";
#line 2620
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2620
    descriptor.format = "Rx unit being enabled before security path fully disabled. Continuing with init.\n";
#line 2620
    descriptor.lineno = 2620U;
#line 2620
    descriptor.flags = 0U;
#line 2620
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2620
    if (tmp___1 != 0L) {
#line 2620
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Rx unit being enabled before security path fully disabled. Continuing with init.\n");
    } else {

    }
  } else {

  }
#line 2622
  return (0);
}
}
#line 2632 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_enable_rx_buff_generic(struct ixgbe_hw *hw ) 
{ 
  int secrxreg ;
  u32 tmp ;

  {
#line 2636
  tmp = ixgbe_read_reg(hw, 36096U);
#line 2636
  secrxreg = (int )tmp;
#line 2637
  secrxreg = secrxreg & -3;
#line 2638
  ixgbe_write_reg(hw, 36096U, (u32 )secrxreg);
#line 2639
  ixgbe_read_reg(hw, 8U);
#line 2641
  return (0);
}
}
#line 2651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw , u32 regval ) 
{ 


  {
#line 2653
  if ((int )regval & 1) {
#line 2654
    (*(hw->mac.ops.enable_rx))(hw);
  } else {
#line 2656
    (*(hw->mac.ops.disable_rx))(hw);
  }
#line 2658
  return (0);
}
}
#line 2666 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw , u32 index ) 
{ 
  ixgbe_link_speed speed ;
  bool link_up ;
  u32 autoc_reg ;
  u32 tmp ;
  u32 led_reg ;
  u32 tmp___0 ;
  bool locked ;
  s32 ret_val ;

  {
#line 2668
  speed = 0U;
#line 2669
  link_up = 0;
#line 2670
  tmp = ixgbe_read_reg(hw, 17056U);
#line 2670
  autoc_reg = tmp;
#line 2671
  tmp___0 = ixgbe_read_reg(hw, 512U);
#line 2671
  led_reg = tmp___0;
#line 2672
  locked = 0;
#line 2679
  (*(hw->mac.ops.check_link))(hw, & speed, & link_up, 0);
#line 2681
  if (! link_up) {
#line 2682
    ret_val = (*(hw->mac.ops.prot_autoc_read))(hw, & locked, & autoc_reg);
#line 2683
    if (ret_val != 0) {
#line 2684
      return (ret_val);
    } else {

    }
#line 2686
    autoc_reg = autoc_reg | 4096U;
#line 2687
    autoc_reg = autoc_reg | 1U;
#line 2689
    ret_val = (*(hw->mac.ops.prot_autoc_write))(hw, autoc_reg, (int )locked);
#line 2690
    if (ret_val != 0) {
#line 2691
      return (ret_val);
    } else {

    }
#line 2693
    ixgbe_read_reg(hw, 8U);
#line 2695
    usleep_range(10000UL, 20000UL);
  } else {

  }
#line 2698
  led_reg = (u32 )(~ (15 << (int )(index * 8U))) & led_reg;
#line 2699
  led_reg = (u32 )(128 << (int )(index * 8U)) | led_reg;
#line 2700
  ixgbe_write_reg(hw, 512U, led_reg);
#line 2701
  ixgbe_read_reg(hw, 8U);
#line 2703
  return (0);
}
}
#line 2711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw , u32 index ) 
{ 
  u32 autoc_reg ;
  u32 led_reg ;
  u32 tmp ;
  bool locked ;
  s32 ret_val ;

  {
#line 2713
  autoc_reg = 0U;
#line 2714
  tmp = ixgbe_read_reg(hw, 512U);
#line 2714
  led_reg = tmp;
#line 2715
  locked = 0;
#line 2718
  ret_val = (*(hw->mac.ops.prot_autoc_read))(hw, & locked, & autoc_reg);
#line 2719
  if (ret_val != 0) {
#line 2720
    return (ret_val);
  } else {

  }
#line 2722
  autoc_reg = autoc_reg & 4294967294U;
#line 2723
  autoc_reg = autoc_reg | 4096U;
#line 2725
  ret_val = (*(hw->mac.ops.prot_autoc_write))(hw, autoc_reg, (int )locked);
#line 2726
  if (ret_val != 0) {
#line 2727
    return (ret_val);
  } else {

  }
#line 2729
  led_reg = (u32 )(~ (15 << (int )(index * 8U))) & led_reg;
#line 2730
  led_reg = (u32 )(~ (128 << (int )(index * 8U))) & led_reg;
#line 2731
  led_reg = (u32 )(4 << (int )(index * 8U)) | led_reg;
#line 2732
  ixgbe_write_reg(hw, 512U, led_reg);
#line 2733
  ixgbe_read_reg(hw, 8U);
#line 2735
  return (0);
}
}
#line 2747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_get_san_mac_addr_offset(struct ixgbe_hw *hw , u16 *san_mac_offset ) 
{ 
  s32 ret_val ;

  {
#line 2756
  ret_val = (*(hw->eeprom.ops.read))(hw, 40, san_mac_offset);
#line 2758
  if (ret_val != 0) {
#line 2759
    netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
               "eeprom read at offset %d failed\n", 40);
  } else {

  }
#line 2762
  return (ret_val);
}
}
#line 2775 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw , u8 *san_mac_addr ) 
{ 
  u16 san_mac_data ;
  u16 san_mac_offset ;
  u8 i ;
  s32 ret_val ;

  {
#line 2785
  ret_val = ixgbe_get_san_mac_addr_offset(hw, & san_mac_offset);
#line 2786
  if ((ret_val != 0 || (unsigned int )san_mac_offset == 0U) || (unsigned int )san_mac_offset == 65535U) {
#line 2788
    goto san_mac_addr_clr;
  } else {

  }
#line 2791
  (*(hw->mac.ops.set_lan_id))(hw);
#line 2793
  if ((unsigned int )hw->bus.func != 0U) {
#line 2793
    san_mac_offset = (unsigned int )san_mac_offset + 3U;
  } else {
#line 2793
    san_mac_offset = san_mac_offset;
  }
#line 2795
  i = 0U;
#line 2795
  goto ldv_55131;
  ldv_55130: 
#line 2796
  ret_val = (*(hw->eeprom.ops.read))(hw, (int )san_mac_offset, & san_mac_data);
#line 2798
  if (ret_val != 0) {
#line 2799
    netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
               "eeprom read at offset %d failed\n", (int )san_mac_offset);
#line 2801
    goto san_mac_addr_clr;
  } else {

  }
#line 2803
  *(san_mac_addr + (unsigned long )((int )i * 2)) = (unsigned char )san_mac_data;
#line 2804
  *(san_mac_addr + ((unsigned long )((int )i * 2) + 1UL)) = (unsigned char )((int )san_mac_data >> 8);
#line 2805
  san_mac_offset = (u16 )((int )san_mac_offset + 1);
#line 2795
  i = (u8 )((int )i + 1);
  ldv_55131: ;
#line 2795
  if ((unsigned int )i <= 2U) {
#line 2797
    goto ldv_55130;
  } else {

  }

#line 2807
  return (0);
  san_mac_addr_clr: 
#line 2813
  i = 0U;
#line 2813
  goto ldv_55134;
  ldv_55133: 
#line 2814
  *(san_mac_addr + (unsigned long )i) = 255U;
#line 2813
  i = (u8 )((int )i + 1);
  ldv_55134: ;
#line 2813
  if ((unsigned int )i <= 5U) {
#line 2815
    goto ldv_55133;
  } else {

  }

#line 2815
  return (ret_val);
}
}
#line 2825 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
u16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw ) 
{ 
  u16 msix_count ;
  u16 max_msix_count ;
  u16 pcie_offset ;
  bool tmp ;

  {
#line 2831
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 2833
  pcie_offset = 98U;
#line 2834
  max_msix_count = 19U;
#line 2835
  goto ldv_55143;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 2840
  pcie_offset = 114U;
#line 2841
  max_msix_count = 64U;
#line 2842
  goto ldv_55143;
  default: ;
#line 2844
  return (1U);
  }
  ldv_55143: 
#line 2847
  msix_count = ixgbe_read_pci_cfg_word(hw, (u32 )pcie_offset);
#line 2848
  tmp = ixgbe_removed((void *)hw->hw_addr);
#line 2848
  if ((int )tmp) {
#line 2849
    msix_count = 0U;
  } else {

  }
#line 2850
  msix_count = (unsigned int )msix_count & 2047U;
#line 2853
  msix_count = (u16 )((int )msix_count + 1);
#line 2855
  if ((int )msix_count > (int )max_msix_count) {
#line 2856
    msix_count = max_msix_count;
  } else {

  }
#line 2858
  return (msix_count);
}
}
#line 2867 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw , u32 rar , u32 vmdq ) 
{ 
  u32 mpsar_lo ;
  u32 mpsar_hi ;
  u32 rar_entries ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;

  {
#line 2870
  rar_entries = hw->mac.num_rar_entries;
#line 2873
  if (rar >= rar_entries) {
#line 2874
    descriptor.modname = "ixgbe";
#line 2874
    descriptor.function = "ixgbe_clear_vmdq_generic";
#line 2874
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2874
    descriptor.format = "RAR index %d is out of range.\n";
#line 2874
    descriptor.lineno = 2874U;
#line 2874
    descriptor.flags = 0U;
#line 2874
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2874
    if (tmp != 0L) {
#line 2874
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "RAR index %d is out of range.\n", rar);
    } else {

    }
#line 2875
    return (-32);
  } else {

  }
#line 2878
  mpsar_lo = ixgbe_read_reg(hw, (rar + 5312U) * 8U);
#line 2879
  mpsar_hi = ixgbe_read_reg(hw, rar * 8U + 42500U);
#line 2881
  tmp___0 = ixgbe_removed((void *)hw->hw_addr);
#line 2881
  if ((int )tmp___0) {
#line 2882
    return (0);
  } else {

  }
#line 2884
  if (mpsar_lo == 0U && mpsar_hi == 0U) {
#line 2885
    return (0);
  } else {

  }
#line 2887
  if (vmdq == 4294967295U) {
#line 2888
    if (mpsar_lo != 0U) {
#line 2889
      ixgbe_write_reg(hw, (rar + 5312U) * 8U, 0U);
#line 2890
      mpsar_lo = 0U;
    } else {

    }
#line 2892
    if (mpsar_hi != 0U) {
#line 2893
      ixgbe_write_reg(hw, rar * 8U + 42500U, 0U);
#line 2894
      mpsar_hi = 0U;
    } else {

    }
  } else
#line 2896
  if (vmdq <= 31U) {
#line 2897
    mpsar_lo = (u32 )(~ (1 << (int )vmdq)) & mpsar_lo;
#line 2898
    ixgbe_write_reg(hw, (rar + 5312U) * 8U, mpsar_lo);
  } else {
#line 2900
    mpsar_hi = (u32 )(~ (1 << (int )(vmdq - 32U))) & mpsar_hi;
#line 2901
    ixgbe_write_reg(hw, rar * 8U + 42500U, mpsar_hi);
  }
#line 2905
  if ((mpsar_lo == 0U && mpsar_hi == 0U) && rar != 0U) {
#line 2906
    (*(hw->mac.ops.clear_rar))(hw, rar);
  } else {

  }
#line 2907
  return (0);
}
}
#line 2916 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_vmdq_generic(struct ixgbe_hw *hw , u32 rar , u32 vmdq ) 
{ 
  u32 mpsar ;
  u32 rar_entries ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 2919
  rar_entries = hw->mac.num_rar_entries;
#line 2922
  if (rar >= rar_entries) {
#line 2923
    descriptor.modname = "ixgbe";
#line 2923
    descriptor.function = "ixgbe_set_vmdq_generic";
#line 2923
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2923
    descriptor.format = "RAR index %d is out of range.\n";
#line 2923
    descriptor.lineno = 2923U;
#line 2923
    descriptor.flags = 0U;
#line 2923
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2923
    if (tmp != 0L) {
#line 2923
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "RAR index %d is out of range.\n", rar);
    } else {

    }
#line 2924
    return (-32);
  } else {

  }
#line 2927
  if (vmdq <= 31U) {
#line 2928
    mpsar = ixgbe_read_reg(hw, (rar + 5312U) * 8U);
#line 2929
    mpsar = (u32 )(1 << (int )vmdq) | mpsar;
#line 2930
    ixgbe_write_reg(hw, (rar + 5312U) * 8U, mpsar);
  } else {
#line 2932
    mpsar = ixgbe_read_reg(hw, rar * 8U + 42500U);
#line 2933
    mpsar = (u32 )(1 << (int )(vmdq - 32U)) | mpsar;
#line 2934
    ixgbe_write_reg(hw, rar * 8U + 42500U, mpsar);
  }
#line 2936
  return (0);
}
}
#line 2949 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw , u32 vmdq ) 
{ 
  u32 rar ;

  {
#line 2951
  rar = (u32 )hw->mac.san_mac_rar_index;
#line 2953
  if (vmdq <= 31U) {
#line 2954
    ixgbe_write_reg(hw, (rar + 5312U) * 8U, (u32 )(1 << (int )vmdq));
#line 2955
    ixgbe_write_reg(hw, rar * 8U + 42500U, 0U);
  } else {
#line 2957
    ixgbe_write_reg(hw, (rar + 5312U) * 8U, 0U);
#line 2958
    ixgbe_write_reg(hw, rar * 8U + 42500U, (u32 )(1 << (int )(vmdq - 32U)));
  }
#line 2961
  return (0);
}
}
#line 2968 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw ) 
{ 
  int i ;

  {
#line 2972
  i = 0;
#line 2972
  goto ldv_55178;
  ldv_55177: 
#line 2973
  ixgbe_write_reg(hw, (u32 )((i + 15616) * 4), 0U);
#line 2972
  i = i + 1;
  ldv_55178: ;
#line 2972
  if (i <= 127) {
#line 2974
    goto ldv_55177;
  } else {

  }

#line 2975
  return (0);
}
}
#line 2986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_find_vlvf_slot(struct ixgbe_hw *hw , u32 vlan ) 
{ 
  u32 bits ;
  u32 first_empty_slot ;
  s32 regindex ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 2988
  bits = 0U;
#line 2989
  first_empty_slot = 0U;
#line 2993
  if (vlan == 0U) {
#line 2994
    return (0);
  } else {

  }
#line 3000
  regindex = 1;
#line 3000
  goto ldv_55189;
  ldv_55188: 
#line 3001
  bits = ixgbe_read_reg(hw, (u32 )((regindex + 15424) * 4));
#line 3002
  if (bits == 0U && first_empty_slot == 0U) {
#line 3003
    first_empty_slot = (u32 )regindex;
  } else
#line 3004
  if ((bits & 4095U) == vlan) {
#line 3005
    goto ldv_55187;
  } else {

  }
#line 3000
  regindex = regindex + 1;
  ldv_55189: ;
#line 3000
  if (regindex <= 63) {
#line 3002
    goto ldv_55188;
  } else {

  }
  ldv_55187: ;
#line 3013
  if (regindex > 63) {
#line 3014
    if (first_empty_slot != 0U) {
#line 3015
      regindex = (s32 )first_empty_slot;
    } else {
#line 3017
      descriptor.modname = "ixgbe";
#line 3017
      descriptor.function = "ixgbe_find_vlvf_slot";
#line 3017
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 3017
      descriptor.format = "No space in VLVF.\n";
#line 3017
      descriptor.lineno = 3017U;
#line 3017
      descriptor.flags = 0U;
#line 3017
      tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 3017
      if (tmp != 0L) {
#line 3017
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "No space in VLVF.\n");
      } else {

      }
#line 3018
      regindex = -25;
    }
  } else {

  }
#line 3022
  return (regindex);
}
}
#line 3034 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw , u32 vlan , u32 vind , bool vlan_on ) 
{ 
  s32 regindex ;
  u32 bitindex ;
  u32 vfta ;
  u32 bits ;
  u32 vt ;
  u32 targetbit ;
  bool vfta_changed ;
  s32 vlvf_index ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 3043
  vfta_changed = 0;
#line 3045
  if (vlan > 4095U) {
#line 3046
    return (-5);
  } else {

  }
#line 3060
  regindex = (s32 )(vlan >> 5) & 127;
#line 3061
  bitindex = vlan & 31U;
#line 3062
  targetbit = (u32 )(1 << (int )bitindex);
#line 3063
  vfta = ixgbe_read_reg(hw, (u32 )((regindex + 10240) * 4));
#line 3065
  if ((int )vlan_on) {
#line 3066
    if ((vfta & targetbit) == 0U) {
#line 3067
      vfta = vfta | targetbit;
#line 3068
      vfta_changed = 1;
    } else {

    }
  } else
#line 3071
  if ((vfta & targetbit) != 0U) {
#line 3072
    vfta = ~ targetbit & vfta;
#line 3073
    vfta_changed = 1;
  } else {

  }
#line 3085
  vt = ixgbe_read_reg(hw, 20912U);
#line 3086
  if ((int )vt & 1) {
#line 3089
    vlvf_index = ixgbe_find_vlvf_slot(hw, vlan);
#line 3090
    if (vlvf_index < 0) {
#line 3091
      return (vlvf_index);
    } else {

    }
#line 3093
    if ((int )vlan_on) {
#line 3095
      if (vind <= 31U) {
#line 3096
        bits = ixgbe_read_reg(hw, (u32 )((vlvf_index + 7744) * 8));
#line 3098
        bits = (u32 )(1 << (int )vind) | bits;
#line 3099
        ixgbe_write_reg(hw, (u32 )((vlvf_index + 7744) * 8), bits);
      } else {
#line 3103
        bits = ixgbe_read_reg(hw, (u32 )(vlvf_index * 8 + 61956));
#line 3105
        bits = (u32 )(1 << (int )(vind - 32U)) | bits;
#line 3106
        ixgbe_write_reg(hw, (u32 )(vlvf_index * 8 + 61956), bits);
      }
    } else
#line 3112
    if (vind <= 31U) {
#line 3113
      bits = ixgbe_read_reg(hw, (u32 )((vlvf_index + 7744) * 8));
#line 3115
      bits = (u32 )(~ (1 << (int )vind)) & bits;
#line 3116
      ixgbe_write_reg(hw, (u32 )((vlvf_index + 7744) * 8), bits);
#line 3119
      tmp = ixgbe_read_reg(hw, (u32 )(vlvf_index * 8 + 61956));
#line 3119
      bits = tmp | bits;
    } else {
#line 3122
      bits = ixgbe_read_reg(hw, (u32 )(vlvf_index * 8 + 61956));
#line 3124
      bits = (u32 )(~ (1 << (int )(vind - 32U))) & bits;
#line 3125
      ixgbe_write_reg(hw, (u32 )(vlvf_index * 8 + 61956), bits);
#line 3128
      tmp___0 = ixgbe_read_reg(hw, (u32 )((vlvf_index + 7744) * 8));
#line 3128
      bits = tmp___0 | bits;
    }
#line 3148
    if (bits != 0U) {
#line 3149
      ixgbe_write_reg(hw, (u32 )((vlvf_index + 15424) * 4), vlan | 2147483648U);
#line 3151
      if (! vlan_on) {
#line 3155
        vfta_changed = 0;
      } else {

      }
    } else {
#line 3158
      ixgbe_write_reg(hw, (u32 )((vlvf_index + 15424) * 4), 0U);
    }
  } else {

  }
#line 3162
  if ((int )vfta_changed) {
#line 3163
    ixgbe_write_reg(hw, (u32 )((regindex + 10240) * 4), vfta);
  } else {

  }
#line 3165
  return (0);
}
}
#line 3174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw ) 
{ 
  u32 offset ;

  {
#line 3178
  offset = 0U;
#line 3178
  goto ldv_55211;
  ldv_55210: 
#line 3179
  ixgbe_write_reg(hw, (offset + 10240U) * 4U, 0U);
#line 3178
  offset = offset + 1U;
  ldv_55211: ;
#line 3178
  if (hw->mac.vft_size > offset) {
#line 3180
    goto ldv_55210;
  } else {

  }
#line 3181
  offset = 0U;
#line 3181
  goto ldv_55214;
  ldv_55213: 
#line 3182
  ixgbe_write_reg(hw, (offset + 15424U) * 4U, 0U);
#line 3183
  ixgbe_write_reg(hw, (offset + 7744U) * 8U, 0U);
#line 3184
  ixgbe_write_reg(hw, offset * 8U + 61956U, 0U);
#line 3181
  offset = offset + 1U;
  ldv_55214: ;
#line 3181
  if (offset <= 63U) {
#line 3183
    goto ldv_55213;
  } else {

  }

#line 3187
  return (0);
}
}
#line 3199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw , ixgbe_link_speed *speed , bool *link_up ,
                                 bool link_up_wait_to_complete ) 
{ 
  u32 links_reg ;
  u32 links_orig ;
  u32 i ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 3206
  links_orig = ixgbe_read_reg(hw, 17060U);
#line 3208
  links_reg = ixgbe_read_reg(hw, 17060U);
#line 3210
  if (links_orig != links_reg) {
#line 3211
    descriptor.modname = "ixgbe";
#line 3211
    descriptor.function = "ixgbe_check_mac_link_generic";
#line 3211
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 3211
    descriptor.format = "LINKS changed from %08X to %08X\n";
#line 3211
    descriptor.lineno = 3212U;
#line 3211
    descriptor.flags = 0U;
#line 3211
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 3211
    if (tmp != 0L) {
#line 3211
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "LINKS changed from %08X to %08X\n", links_orig, links_reg);
    } else {

    }
  } else {

  }
#line 3215
  if ((int )link_up_wait_to_complete) {
#line 3216
    i = 0U;
#line 3216
    goto ldv_55229;
    ldv_55228: ;
#line 3217
    if ((links_reg & 1073741824U) != 0U) {
#line 3218
      *link_up = 1;
#line 3219
      goto ldv_55227;
    } else {
#line 3221
      *link_up = 0;
    }
#line 3223
    msleep(100U);
#line 3224
    links_reg = ixgbe_read_reg(hw, 17060U);
#line 3216
    i = i + 1U;
    ldv_55229: ;
#line 3216
    if (i <= 89U) {
#line 3218
      goto ldv_55228;
    } else {

    }
    ldv_55227: ;
  } else
#line 3227
  if ((links_reg & 1073741824U) != 0U) {
#line 3228
    *link_up = 1;
  } else {
#line 3230
    *link_up = 0;
  }
#line 3233
  switch (links_reg & 805306368U) {
  case 805306368U: ;
#line 3235
  if ((unsigned int )hw->mac.type > 3U && (links_reg & 134217728U) != 0U) {
#line 3237
    *speed = 1024U;
  } else {
#line 3239
    *speed = 128U;
  }
#line 3240
  goto ldv_55231;
  case 536870912U: 
#line 3242
  *speed = 32U;
#line 3243
  goto ldv_55231;
  case 268435456U: ;
#line 3245
  if ((unsigned int )hw->mac.type > 3U && (links_reg & 134217728U) != 0U) {
#line 3247
    *speed = 2048U;
  } else {
#line 3249
    *speed = 8U;
  }
#line 3250
  goto ldv_55231;
  default: 
#line 3252
  *speed = 0U;
  }
  ldv_55231: ;
#line 3255
  return (0);
}
}
#line 3268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw , u16 *wwnn_prefix , u16 *wwpn_prefix ) 
{ 
  u16 offset ;
  u16 caps ;
  u16 alt_san_mac_blk_offset ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;

  {
#line 3275
  *wwnn_prefix = 65535U;
#line 3276
  *wwpn_prefix = 65535U;
#line 3279
  offset = 39U;
#line 3280
  tmp = (*(hw->eeprom.ops.read))(hw, (int )offset, & alt_san_mac_blk_offset);
#line 3280
  if (tmp != 0) {
#line 3281
    goto wwn_prefix_err;
  } else {

  }
#line 3283
  if ((unsigned int )alt_san_mac_blk_offset == 0U || (unsigned int )alt_san_mac_blk_offset == 65535U) {
#line 3285
    return (0);
  } else {

  }
#line 3288
  offset = alt_san_mac_blk_offset;
#line 3289
  tmp___0 = (*(hw->eeprom.ops.read))(hw, (int )offset, & caps);
#line 3289
  if (tmp___0 != 0) {
#line 3290
    goto wwn_prefix_err;
  } else {

  }
#line 3291
  if (((int )caps & 1) == 0) {
#line 3292
    return (0);
  } else {

  }
#line 3295
  offset = (unsigned int )alt_san_mac_blk_offset + 7U;
#line 3296
  tmp___1 = (*(hw->eeprom.ops.read))(hw, (int )offset, wwnn_prefix);
#line 3296
  if (tmp___1 != 0) {
#line 3297
    netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
               "eeprom read at offset %d failed\n", (int )offset);
  } else {

  }
#line 3299
  offset = (unsigned int )alt_san_mac_blk_offset + 8U;
#line 3300
  tmp___2 = (*(hw->eeprom.ops.read))(hw, (int )offset, wwpn_prefix);
#line 3300
  if (tmp___2 != 0) {
#line 3301
    goto wwn_prefix_err;
  } else {

  }
#line 3303
  return (0);
  wwn_prefix_err: 
#line 3306
  netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
             "eeprom read at offset %d failed\n", (int )offset);
#line 3307
  return (0);
}
}
#line 3317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw , bool enable , int pf ) 
{ 
  int j ;
  int pf_target_reg ;
  int pf_target_shift ;
  u32 pfvfspoof ;

  {
#line 3320
  pf_target_reg = pf >> 3;
#line 3321
  pf_target_shift = pf % 8;
#line 3322
  pfvfspoof = 0U;
#line 3324
  if ((unsigned int )hw->mac.type == 1U) {
#line 3325
    return;
  } else {

  }
#line 3327
  if ((int )enable) {
#line 3328
    pfvfspoof = 255U;
  } else {

  }
#line 3334
  j = 0;
#line 3334
  goto ldv_55254;
  ldv_55253: 
#line 3335
  ixgbe_write_reg(hw, (u32 )((j + 8320) * 4), pfvfspoof);
#line 3334
  j = j + 1;
  ldv_55254: ;
#line 3334
  if (j < pf_target_reg) {
#line 3336
    goto ldv_55253;
  } else {

  }
#line 3341
  pfvfspoof = (u32 )((1 << pf_target_shift) + -1) & pfvfspoof;
#line 3342
  ixgbe_write_reg(hw, (u32 )((j + 8320) * 4), pfvfspoof);
#line 3348
  j = j + 1;
#line 3348
  goto ldv_55257;
  ldv_55256: 
#line 3349
  ixgbe_write_reg(hw, (u32 )((j + 8320) * 4), 0U);
#line 3348
  j = j + 1;
  ldv_55257: ;
#line 3348
  if (j <= 7) {
#line 3350
    goto ldv_55256;
  } else {

  }

#line 3355
  return;
}
}
#line 3359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw , bool enable , int vf ) 
{ 
  int vf_target_reg ;
  int vf_target_shift ;
  u32 pfvfspoof ;

  {
#line 3361
  vf_target_reg = vf >> 3;
#line 3362
  vf_target_shift = vf % 8 + 8;
#line 3365
  if ((unsigned int )hw->mac.type == 1U) {
#line 3366
    return;
  } else {

  }
#line 3368
  pfvfspoof = ixgbe_read_reg(hw, (u32 )((vf_target_reg + 8320) * 4));
#line 3369
  if ((int )enable) {
#line 3370
    pfvfspoof = (u32 )(1 << vf_target_shift) | pfvfspoof;
  } else {
#line 3372
    pfvfspoof = (u32 )(~ (1 << vf_target_shift)) & pfvfspoof;
  }
#line 3373
  ixgbe_write_reg(hw, (u32 )((vf_target_reg + 8320) * 4), pfvfspoof);
#line 3374
  return;
}
}
#line 3384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_device_caps_generic(struct ixgbe_hw *hw , u16 *device_caps ) 
{ 


  {
#line 3386
  (*(hw->eeprom.ops.read))(hw, 44, device_caps);
#line 3388
  return (0);
}
}
#line 3398 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_set_rxpba_generic(struct ixgbe_hw *hw , int num_pb , u32 headroom , int strategy ) 
{ 
  u32 pbsize ;
  int i ;
  u32 rxpktsize ;
  u32 txpktsize ;
  u32 txpbthresh ;

  {
#line 3403
  pbsize = hw->mac.rx_pb_size;
#line 3404
  i = 0;
#line 3408
  pbsize = pbsize - headroom;
#line 3410
  if (num_pb == 0) {
#line 3411
    num_pb = 1;
  } else {

  }
#line 3416
  switch (strategy) {
  case 1: 
#line 3421
  rxpktsize = (pbsize * 10U) / (u32 )(num_pb * 8);
#line 3422
  pbsize = pbsize - (u32 )(num_pb / 2) * rxpktsize;
#line 3423
  rxpktsize = rxpktsize << 10;
#line 3424
  goto ldv_55284;
  ldv_55283: 
#line 3425
  ixgbe_write_reg(hw, (u32 )((i + 3840) * 4), rxpktsize);
#line 3424
  i = i + 1;
  ldv_55284: ;
#line 3424
  if (num_pb / 2 > i) {
#line 3426
    goto ldv_55283;
  } else {

  }

  case 0: 
#line 3429
  rxpktsize = pbsize / (u32 )(num_pb - i) << 10;
#line 3430
  goto ldv_55288;
  ldv_55287: 
#line 3431
  ixgbe_write_reg(hw, (u32 )((i + 3840) * 4), rxpktsize);
#line 3430
  i = i + 1;
  ldv_55288: ;
#line 3430
  if (i < num_pb) {
#line 3432
    goto ldv_55287;
  } else {

  }

#line 3432
  goto ldv_55290;
  default: ;
#line 3434
  goto ldv_55290;
  }
  ldv_55290: 
#line 3442
  txpktsize = (u32 )(163840 / num_pb);
#line 3443
  txpbthresh = txpktsize / 1024U - 10U;
#line 3444
  i = 0;
#line 3444
  goto ldv_55293;
  ldv_55292: 
#line 3445
  ixgbe_write_reg(hw, (u32 )((i + 13056) * 4), txpktsize);
#line 3446
  ixgbe_write_reg(hw, (u32 )((i + 4692) * 4), txpbthresh);
#line 3444
  i = i + 1;
  ldv_55293: ;
#line 3444
  if (i < num_pb) {
#line 3446
    goto ldv_55292;
  } else {

  }

#line 3450
  goto ldv_55296;
  ldv_55295: 
#line 3451
  ixgbe_write_reg(hw, (u32 )((i + 3840) * 4), 0U);
#line 3452
  ixgbe_write_reg(hw, (u32 )((i + 13056) * 4), 0U);
#line 3453
  ixgbe_write_reg(hw, (u32 )((i + 4692) * 4), 0U);
#line 3450
  i = i + 1;
  ldv_55296: ;
#line 3450
  if (i <= 7) {
#line 3452
    goto ldv_55295;
  } else {

  }

#line 3457
  return;
}
}
#line 3465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static u8 ixgbe_calculate_checksum(u8 *buffer , u32 length ) 
{ 
  u32 i ;
  u8 sum ;

  {
#line 3468
  sum = 0U;
#line 3470
  if ((unsigned long )buffer == (unsigned long )((u8 *)0U)) {
#line 3471
    return (0U);
  } else {

  }
#line 3473
  i = 0U;
#line 3473
  goto ldv_55305;
  ldv_55304: 
#line 3474
  sum = (int )*(buffer + (unsigned long )i) + (int )sum;
#line 3473
  i = i + 1U;
  ldv_55305: ;
#line 3473
  if (i < length) {
#line 3475
    goto ldv_55304;
  } else {

  }

#line 3476
  return (- ((int )sum));
}
}
#line 3496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_host_interface_command(struct ixgbe_hw *hw , u32 *buffer , u32 length ,
                                 u32 timeout , bool return_data ) 
{ 
  u32 hicr ;
  u32 i ;
  u32 bi ;
  u32 fwsts ;
  u32 hdr_size ;
  u16 buf_len ;
  u16 dword_len ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  u32 tmp___3 ;
  struct _ddebug descriptor___3 ;
  long tmp___4 ;

  {
#line 3501
  hdr_size = 4U;
#line 3504
  if (length == 0U || length > 1792U) {
#line 3505
    descriptor.modname = "ixgbe";
#line 3505
    descriptor.function = "ixgbe_host_interface_command";
#line 3505
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 3505
    descriptor.format = "Buffer length failure buffersize-%d.\n";
#line 3505
    descriptor.lineno = 3505U;
#line 3505
    descriptor.flags = 0U;
#line 3505
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 3505
    if (tmp != 0L) {
#line 3505
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Buffer length failure buffersize-%d.\n", length);
    } else {

    }
#line 3506
    return (-33);
  } else {

  }
#line 3510
  fwsts = ixgbe_read_reg(hw, 89868U);
#line 3511
  ixgbe_write_reg(hw, 89868U, fwsts | 512U);
#line 3514
  hicr = ixgbe_read_reg(hw, 89856U);
#line 3515
  if ((hicr & 1U) == 0U) {
#line 3516
    descriptor___0.modname = "ixgbe";
#line 3516
    descriptor___0.function = "ixgbe_host_interface_command";
#line 3516
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 3516
    descriptor___0.format = "IXGBE_HOST_EN bit disabled.\n";
#line 3516
    descriptor___0.lineno = 3516U;
#line 3516
    descriptor___0.flags = 0U;
#line 3516
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 3516
    if (tmp___0 != 0L) {
#line 3516
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "IXGBE_HOST_EN bit disabled.\n");
    } else {

    }
#line 3517
    return (-33);
  } else {

  }
#line 3521
  if ((length & 3U) != 0U) {
#line 3522
    descriptor___1.modname = "ixgbe";
#line 3522
    descriptor___1.function = "ixgbe_host_interface_command";
#line 3522
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 3522
    descriptor___1.format = "Buffer length failure, not aligned to dword";
#line 3522
    descriptor___1.lineno = 3522U;
#line 3522
    descriptor___1.flags = 0U;
#line 3522
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 3522
    if (tmp___1 != 0L) {
#line 3522
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Buffer length failure, not aligned to dword");
    } else {

    }
#line 3523
    return (-32);
  } else {

  }
#line 3526
  dword_len = (u16 )(length >> 2);
#line 3532
  i = 0U;
#line 3532
  goto ldv_55326;
  ldv_55325: 
#line 3533
  ixgbe_write_reg(hw, (i << 2) + 88064U, *(buffer + (unsigned long )i));
#line 3532
  i = i + 1U;
  ldv_55326: ;
#line 3532
  if ((u32 )dword_len > i) {
#line 3534
    goto ldv_55325;
  } else {

  }
#line 3537
  ixgbe_write_reg(hw, 89856U, hicr | 2U);
#line 3539
  i = 0U;
#line 3539
  goto ldv_55330;
  ldv_55329: 
#line 3540
  hicr = ixgbe_read_reg(hw, 89856U);
#line 3541
  if ((hicr & 2U) == 0U) {
#line 3542
    goto ldv_55328;
  } else {

  }
#line 3543
  usleep_range(1000UL, 2000UL);
#line 3539
  i = i + 1U;
  ldv_55330: ;
#line 3539
  if (i < timeout) {
#line 3541
    goto ldv_55329;
  } else {

  }
  ldv_55328: ;
#line 3547
  if (timeout != 0U && i == timeout) {
#line 3547
    goto _L;
  } else {
#line 3547
    tmp___3 = ixgbe_read_reg(hw, 89856U);
#line 3547
    if ((tmp___3 & 4U) == 0U) {
      _L: /* CIL Label */ 
#line 3549
      descriptor___2.modname = "ixgbe";
#line 3549
      descriptor___2.function = "ixgbe_host_interface_command";
#line 3549
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 3549
      descriptor___2.format = "Command has failed with no status valid.\n";
#line 3549
      descriptor___2.lineno = 3549U;
#line 3549
      descriptor___2.flags = 0U;
#line 3549
      tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 3549
      if (tmp___2 != 0L) {
#line 3549
        __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Command has failed with no status valid.\n");
      } else {

      }
#line 3550
      return (-33);
    } else {

    }
  }
#line 3553
  if (! return_data) {
#line 3554
    return (0);
  } else {

  }
#line 3557
  dword_len = (u16 )(hdr_size >> 2);
#line 3560
  bi = 0U;
#line 3560
  goto ldv_55333;
  ldv_55332: 
#line 3561
  *(buffer + (unsigned long )bi) = ixgbe_read_reg(hw, (bi << 2) + 88064U);
#line 3560
  bi = bi + 1U;
  ldv_55333: ;
#line 3560
  if ((u32 )dword_len > bi) {
#line 3562
    goto ldv_55332;
  } else {

  }
#line 3566
  buf_len = (u16 )((struct ixgbe_hic_hdr *)buffer)->buf_len;
#line 3567
  if ((unsigned int )buf_len == 0U) {
#line 3568
    return (0);
  } else {

  }
#line 3570
  if ((u32 )buf_len + hdr_size > length) {
#line 3571
    descriptor___3.modname = "ixgbe";
#line 3571
    descriptor___3.function = "ixgbe_host_interface_command";
#line 3571
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 3571
    descriptor___3.format = "Buffer not large enough for reply message.\n";
#line 3571
    descriptor___3.lineno = 3571U;
#line 3571
    descriptor___3.flags = 0U;
#line 3571
    tmp___4 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
#line 3571
    if (tmp___4 != 0L) {
#line 3571
      __dynamic_netdev_dbg(& descriptor___3, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Buffer not large enough for reply message.\n");
    } else {

    }
#line 3572
    return (-33);
  } else {

  }
#line 3576
  dword_len = (u16 )(((int )buf_len + 3) >> 2);
#line 3579
  goto ldv_55337;
  ldv_55336: 
#line 3580
  *(buffer + (unsigned long )bi) = ixgbe_read_reg(hw, (bi << 2) + 88064U);
#line 3579
  bi = bi + 1U;
  ldv_55337: ;
#line 3579
  if ((u32 )dword_len >= bi) {
#line 3581
    goto ldv_55336;
  } else {

  }

#line 3584
  return (0);
}
}
#line 3600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw , u8 maj , u8 min , u8 build ,
                                 u8 sub ) 
{ 
  struct ixgbe_hic_drv_info fw_cmd ;
  int i ;
  s32 ret_val ;
  s32 tmp ;

  {
#line 3607
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1024U);
#line 3607
  if (tmp != 0) {
#line 3608
    return (-16);
  } else {

  }
#line 3610
  fw_cmd.hdr.cmd = 221U;
#line 3611
  fw_cmd.hdr.buf_len = 5U;
#line 3612
  fw_cmd.hdr.cmd_or_resp.cmd_resv = 0U;
#line 3613
  fw_cmd.port_num = (unsigned char )hw->bus.func;
#line 3614
  fw_cmd.ver_maj = maj;
#line 3615
  fw_cmd.ver_min = min;
#line 3616
  fw_cmd.ver_build = build;
#line 3617
  fw_cmd.ver_sub = sub;
#line 3618
  fw_cmd.hdr.checksum = 0U;
#line 3619
  fw_cmd.hdr.checksum = ixgbe_calculate_checksum((u8 *)(& fw_cmd), (u32 )((int )fw_cmd.hdr.buf_len + 4));
#line 3621
  fw_cmd.pad = 0U;
#line 3622
  fw_cmd.pad2 = 0U;
#line 3624
  i = 0;
#line 3624
  goto ldv_55352;
  ldv_55351: 
#line 3625
  ret_val = ixgbe_host_interface_command(hw, (u32 *)(& fw_cmd), 12U, 500U, 1);
#line 3629
  if (ret_val != 0) {
#line 3630
    goto ldv_55349;
  } else {

  }
#line 3632
  if ((unsigned int )fw_cmd.hdr.cmd_or_resp.ret_status == 1U) {
#line 3634
    ret_val = 0;
  } else {
#line 3636
    ret_val = -33;
  }
#line 3638
  goto ldv_55350;
  ldv_55349: 
#line 3624
  i = i + 1;
  ldv_55352: ;
#line 3624
  if (i <= 3) {
#line 3626
    goto ldv_55351;
  } else {

  }
  ldv_55350: 
#line 3641
  (*(hw->mac.ops.release_swfw_sync))(hw, 1024U);
#line 3642
  return (ret_val);
}
}
#line 3653 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_clear_tx_pending(struct ixgbe_hw *hw ) 
{ 
  u32 gcr_ext ;
  u32 hlreg0 ;
  u32 i ;
  u32 poll ;
  u16 value ;
  bool tmp ;

  {
#line 3662
  if (((int )hw->mac.flags & 1) == 0) {
#line 3663
    return;
  } else {

  }
#line 3670
  hlreg0 = ixgbe_read_reg(hw, 16960U);
#line 3671
  ixgbe_write_reg(hw, 16960U, hlreg0 | 32768U);
#line 3674
  ixgbe_read_reg(hw, 8U);
#line 3675
  usleep_range(3000UL, 6000UL);
#line 3680
  poll = ixgbe_pcie_timeout_poll(hw);
#line 3681
  i = 0U;
#line 3681
  goto ldv_55363;
  ldv_55362: 
#line 3682
  usleep_range(100UL, 200UL);
#line 3683
  value = ixgbe_read_pci_cfg_word(hw, 170U);
#line 3684
  tmp = ixgbe_removed((void *)hw->hw_addr);
#line 3684
  if ((int )tmp) {
#line 3685
    goto ldv_55361;
  } else {

  }
#line 3686
  if (((int )value & 32) == 0) {
#line 3687
    goto ldv_55361;
  } else {

  }
#line 3681
  i = i + 1U;
  ldv_55363: ;
#line 3681
  if (i < poll) {
#line 3683
    goto ldv_55362;
  } else {

  }
  ldv_55361: 
#line 3691
  gcr_ext = ixgbe_read_reg(hw, 69712U);
#line 3692
  ixgbe_write_reg(hw, 69712U, gcr_ext | 1073741824U);
#line 3696
  ixgbe_read_reg(hw, 8U);
#line 3697
  __const_udelay(85900UL);
#line 3700
  ixgbe_write_reg(hw, 69712U, gcr_ext);
#line 3701
  ixgbe_write_reg(hw, 16960U, hlreg0);
#line 3702
  return;
}
}
#line 3704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static u8 const   ixgbe_emc_temp_data[4U]  = {      0U,      1U,      35U,      42U};
#line 3710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static u8 const   ixgbe_emc_therm_limit[4U]  = {      32U,      25U,      26U,      48U};
#line 3725 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_get_ets_data(struct ixgbe_hw *hw , u16 *ets_cfg , u16 *ets_offset ) 
{ 
  s32 status ;

  {
#line 3730
  status = (*(hw->eeprom.ops.read))(hw, 38, ets_offset);
#line 3731
  if (status != 0) {
#line 3732
    return (status);
  } else {

  }
#line 3734
  if ((unsigned int )*ets_offset == 0U || (unsigned int )*ets_offset == 65535U) {
#line 3735
    return (2147483647);
  } else {

  }
#line 3737
  status = (*(hw->eeprom.ops.read))(hw, (int )*ets_offset, ets_cfg);
#line 3738
  if (status != 0) {
#line 3739
    return (status);
  } else {

  }
#line 3741
  if (((int )*ets_cfg & 56) != 0) {
#line 3742
    return (2147483647);
  } else {

  }
#line 3744
  return (0);
}
}
#line 3753 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 ets_offset ;
  u16 ets_cfg ;
  u16 ets_sensor ;
  u8 num_sensors ;
  u8 i ;
  struct ixgbe_thermal_sensor_data *data ;
  u32 tmp ;
  u8 sensor_index ;
  u8 sensor_location ;

  {
#line 3761
  data = & hw->mac.thermal_sensor_data;
#line 3764
  tmp = ixgbe_read_reg(hw, 8U);
#line 3764
  if ((tmp & 4U) != 0U) {
#line 3765
    return (2147483647);
  } else {

  }
#line 3767
  status = ixgbe_get_ets_data(hw, & ets_cfg, & ets_offset);
#line 3768
  if (status != 0) {
#line 3769
    return (status);
  } else {

  }
#line 3771
  num_sensors = (unsigned int )((u8 )ets_cfg) & 7U;
#line 3772
  if ((unsigned int )num_sensors > 3U) {
#line 3773
    num_sensors = 3U;
  } else {

  }
#line 3775
  i = 0U;
#line 3775
  goto ldv_55385;
  ldv_55384: 
#line 3779
  status = (*(hw->eeprom.ops.read))(hw, (int )((unsigned int )((int )((u16 )i) + (int )ets_offset) + 1U),
                                    & ets_sensor);
#line 3781
  if (status != 0) {
#line 3782
    return (status);
  } else {

  }
#line 3784
  sensor_index = (u8 )(((int )ets_sensor & 768) >> 8);
#line 3786
  sensor_location = (u8 )(((int )ets_sensor & 15360) >> 10);
#line 3789
  if ((unsigned int )sensor_location != 0U) {
#line 3790
    status = (*(hw->phy.ops.read_i2c_byte))(hw, (int )ixgbe_emc_temp_data[(int )sensor_index],
                                            248, & data->sensor[(int )i].temp);
#line 3794
    if (status != 0) {
#line 3795
      return (status);
    } else {

    }
  } else {

  }
#line 3775
  i = (u8 )((int )i + 1);
  ldv_55385: ;
#line 3775
  if ((int )i < (int )num_sensors) {
#line 3777
    goto ldv_55384;
  } else {

  }

#line 3799
  return (0);
}
}
#line 3809 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_thermal_sensor_thresh_generic(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 ets_offset ;
  u16 ets_cfg ;
  u16 ets_sensor ;
  u8 low_thresh_delta ;
  u8 num_sensors ;
  u8 therm_limit ;
  u8 i ;
  struct ixgbe_thermal_sensor_data *data ;
  u32 tmp ;
  u8 sensor_index ;
  u8 sensor_location ;
  s32 tmp___0 ;

  {
#line 3819
  data = & hw->mac.thermal_sensor_data;
#line 3821
  memset((void *)data, 0, 12UL);
#line 3824
  tmp = ixgbe_read_reg(hw, 8U);
#line 3824
  if ((tmp & 4U) != 0U) {
#line 3825
    return (2147483647);
  } else {

  }
#line 3827
  status = ixgbe_get_ets_data(hw, & ets_cfg, & ets_offset);
#line 3828
  if (status != 0) {
#line 3829
    return (status);
  } else {

  }
#line 3831
  low_thresh_delta = (u8 )(((int )ets_cfg & 1984) >> 6);
#line 3833
  num_sensors = (unsigned int )((u8 )ets_cfg) & 7U;
#line 3834
  if ((unsigned int )num_sensors > 3U) {
#line 3835
    num_sensors = 3U;
  } else {

  }
#line 3837
  i = 0U;
#line 3837
  goto ldv_55403;
  ldv_55402: 
#line 3841
  tmp___0 = (*(hw->eeprom.ops.read))(hw, (int )((unsigned int )((int )((u16 )i) + (int )ets_offset) + 1U),
                                     & ets_sensor);
#line 3841
  if (tmp___0 != 0) {
#line 3842
    netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
               "eeprom read at offset %d failed\n", ((int )ets_offset + 1) + (int )i);
#line 3844
    goto ldv_55401;
  } else {

  }
#line 3846
  sensor_index = (u8 )(((int )ets_sensor & 768) >> 8);
#line 3848
  sensor_location = (u8 )(((int )ets_sensor & 15360) >> 10);
#line 3850
  therm_limit = (u8 )ets_sensor;
#line 3852
  (*(hw->phy.ops.write_i2c_byte))(hw, (int )ixgbe_emc_therm_limit[(int )sensor_index],
                                  248, (int )therm_limit);
#line 3856
  if ((unsigned int )sensor_location == 0U) {
#line 3857
    goto ldv_55401;
  } else {

  }
#line 3859
  data->sensor[(int )i].location = sensor_location;
#line 3860
  data->sensor[(int )i].caution_thresh = therm_limit;
#line 3861
  data->sensor[(int )i].max_op_thresh = (int )therm_limit - (int )low_thresh_delta;
  ldv_55401: 
#line 3837
  i = (u8 )((int )i + 1);
  ldv_55403: ;
#line 3837
  if ((int )i < (int )num_sensors) {
#line 3839
    goto ldv_55402;
  } else {

  }

#line 3864
  return (0);
}
}
#line 3867 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_disable_rx_generic(struct ixgbe_hw *hw ) 
{ 
  u32 rxctrl ;
  u32 pfdtxgswc ;

  {
#line 3871
  rxctrl = ixgbe_read_reg(hw, 12288U);
#line 3872
  if ((int )rxctrl & 1) {
#line 3873
    if ((unsigned int )hw->mac.type != 1U) {
#line 3876
      pfdtxgswc = ixgbe_read_reg(hw, 33312U);
#line 3877
      if ((int )pfdtxgswc & 1) {
#line 3878
        pfdtxgswc = pfdtxgswc & 4294967294U;
#line 3879
        ixgbe_write_reg(hw, 33312U, pfdtxgswc);
#line 3880
        hw->mac.set_lben = 1;
      } else {
#line 3882
        hw->mac.set_lben = 0;
      }
    } else {

    }
#line 3885
    rxctrl = rxctrl & 4294967294U;
#line 3886
    ixgbe_write_reg(hw, 12288U, rxctrl);
  } else {

  }
#line 3888
  return;
}
}
#line 3890 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_enable_rx_generic(struct ixgbe_hw *hw ) 
{ 
  u32 rxctrl ;
  u32 pfdtxgswc ;

  {
#line 3894
  rxctrl = ixgbe_read_reg(hw, 12288U);
#line 3895
  ixgbe_write_reg(hw, 12288U, rxctrl | 1U);
#line 3897
  if ((unsigned int )hw->mac.type != 1U) {
#line 3898
    if ((int )hw->mac.set_lben) {
#line 3901
      pfdtxgswc = ixgbe_read_reg(hw, 33312U);
#line 3902
      pfdtxgswc = pfdtxgswc | 1U;
#line 3903
      ixgbe_write_reg(hw, 33312U, pfdtxgswc);
#line 3904
      hw->mac.set_lben = 0;
    } else {

    }
  } else {

  }
#line 3906
  return;
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.o.c.prepared"
bool ldv_queue_work_on_71(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 359
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 359
  ldv_func_res = tmp;
#line 361
  activate_work_9(ldv_func_arg3, 2);
#line 363
  return (ldv_func_res);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.o.c.prepared"
bool ldv_queue_delayed_work_on_72(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 370
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 370
  ldv_func_res = tmp;
#line 372
  activate_work_9(& ldv_func_arg3->work, 2);
#line 374
  return (ldv_func_res);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.o.c.prepared"
bool ldv_queue_work_on_73(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 381
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 381
  ldv_func_res = tmp;
#line 383
  activate_work_9(ldv_func_arg3, 2);
#line 385
  return (ldv_func_res);
}
}
#line 388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.o.c.prepared"
void ldv_flush_workqueue_74(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 391
  flush_workqueue(ldv_func_arg1);
#line 393
  call_and_disable_all_9(2);
#line 394
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.o.c.prepared"
bool ldv_queue_delayed_work_on_75(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 400
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 400
  ldv_func_res = tmp;
#line 402
  activate_work_9(& ldv_func_arg3->work, 2);
#line 404
  return (ldv_func_res);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.o.c.prepared"
void ldv_mutex_lock_76(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 410
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 412
  mutex_lock(ldv_func_arg1);
#line 413
  return;
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.o.c.prepared"
void ldv_mutex_unlock_77(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 418
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 420
  mutex_unlock(ldv_func_arg1);
#line 421
  return;
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.o.c.prepared"
void ldv_mutex_lock_78(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 426
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 428
  mutex_lock(ldv_func_arg1);
#line 429
  return;
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.o.c.prepared"
int ldv_mutex_trylock_79(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 435
  tmp = mutex_trylock(ldv_func_arg1);
#line 435
  ldv_func_res = tmp;
#line 437
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 437
  return (tmp___0);
#line 439
  return (ldv_func_res);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.o.c.prepared"
void ldv_mutex_unlock_80(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 445
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 447
  mutex_unlock(ldv_func_arg1);
#line 448
  return;
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.o.c.prepared"
void ldv_mutex_unlock_81(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 453
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 455
  mutex_unlock(ldv_func_arg1);
#line 456
  return;
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.o.c.prepared"
void ldv_mutex_lock_82(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 461
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 463
  mutex_lock(ldv_func_arg1);
#line 464
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 7 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 178 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 402
extern int sprintf(char * , char const   *  , ...) ;
#line 598 "include/linux/list.h"
__inline static void INIT_HLIST_NODE(struct hlist_node *h ) 
{ 


  {
#line 600
  h->next = (struct hlist_node *)0;
#line 601
  h->pprev = (struct hlist_node **)0;
#line 602
  return;
}
}
#line 638 "include/linux/list.h"
__inline static void hlist_add_head(struct hlist_node *n , struct hlist_head *h ) 
{ 
  struct hlist_node *first ;

  {
#line 640
  first = h->first;
#line 641
  n->next = first;
#line 642
  if ((unsigned long )first != (unsigned long )((struct hlist_node *)0)) {
#line 643
    first->pprev = & n->next;
  } else {

  }
#line 644
  h->first = n;
#line 645
  n->pprev = & h->first;
#line 646
  return;
}
}
#line 658 "include/linux/list.h"
__inline static void hlist_add_behind(struct hlist_node *n , struct hlist_node *prev ) 
{ 


  {
#line 661
  n->next = prev->next;
#line 662
  prev->next = n;
#line 663
  n->pprev = & prev->next;
#line 665
  if ((unsigned long )n->next != (unsigned long )((struct hlist_node *)0)) {
#line 666
    (n->next)->pprev = & n->next;
  } else {

  }
#line 667
  return;
}
}
#line 63 "./arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_107(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_105(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_108(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_109(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void ldv_mutex_lock_104(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_106(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_110(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_99(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_101(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_100(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_103(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_102(struct workqueue_struct *ldv_func_arg1 ) ;
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
int ldv_irq_6(int state , int line , void *data ) ;
#line 268
void activate_suitable_irq_6(int line , void *data ) ;
#line 272
void choose_interrupt_5(void) ;
#line 273
void disable_suitable_irq_5(int line , void *data ) ;
#line 275
int ldv_irq_5(int state , int line , void *data ) ;
#line 290
int reg_check_6(irqreturn_t (*handler)(int  , void * ) ) ;
#line 294
void choose_interrupt_6(void) ;
#line 298
void disable_suitable_irq_6(int line , void *data ) ;
#line 299
void activate_suitable_irq_5(int line , void *data ) ;
#line 322
int ldv_irq_7(int state , int line , void *data ) ;
#line 328
void choose_interrupt_7(void) ;
#line 329
int reg_check_5(irqreturn_t (*handler)(int  , void * ) ) ;
#line 141 "include/linux/interrupt.h"
__inline static int ldv_request_irq_17(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 145
__inline static int ldv_request_irq_18(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 149
__inline static int ldv_request_irq_20(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 161
void ldv_free_irq_114(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 81 "include/linux/pm_wakeup.h"
__inline static bool device_can_wakeup(struct device *dev ) 
{ 


  {
#line 83
  return ((int )dev->power.can_wakeup != 0);
}
}
#line 59 "include/linux/dma-debug.h"
extern void debug_dma_sync_single_for_cpu(struct device * , dma_addr_t  , size_t  ,
                                          int  ) ;
#line 63
extern void debug_dma_sync_single_for_device(struct device * , dma_addr_t  , size_t  ,
                                             int  ) ;
#line 102 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev , dma_addr_t addr ,
                                             size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 106
  tmp = get_dma_ops(dev);
#line 106
  ops = tmp;
#line 108
  tmp___0 = valid_dma_direction((int )dir);
#line 108
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 108
  if (tmp___1 != 0L) {
#line 108
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (108), "i" (12UL));
    ldv_28538: ;
#line 108
    goto ldv_28538;
  } else {

  }
#line 109
  if ((unsigned long )ops->sync_single_for_cpu != (unsigned long )((void (*)(struct device * ,
                                                                             dma_addr_t  ,
                                                                             size_t  ,
                                                                             enum dma_data_direction  ))0)) {
#line 110
    (*(ops->sync_single_for_cpu))(dev, addr, size, dir);
  } else {

  }
#line 111
  debug_dma_sync_single_for_cpu(dev, addr, size, (int )dir);
#line 112
  return;
}
}
#line 114 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev , dma_addr_t addr ,
                                                size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 118
  tmp = get_dma_ops(dev);
#line 118
  ops = tmp;
#line 120
  tmp___0 = valid_dma_direction((int )dir);
#line 120
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 120
  if (tmp___1 != 0L) {
#line 120
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (120), "i" (12UL));
    ldv_28546: ;
#line 120
    goto ldv_28546;
  } else {

  }
#line 121
  if ((unsigned long )ops->sync_single_for_device != (unsigned long )((void (*)(struct device * ,
                                                                                dma_addr_t  ,
                                                                                size_t  ,
                                                                                enum dma_data_direction  ))0)) {
#line 122
    (*(ops->sync_single_for_device))(dev, addr, size, dir);
  } else {

  }
#line 123
  debug_dma_sync_single_for_device(dev, addr, size, (int )dir);
#line 124
  return;
}
}
#line 47 "include/linux/delay.h"
extern unsigned long msleep_interruptible(unsigned int  ) ;
#line 772 "include/linux/skbuff.h"
extern void kfree_skb(struct sk_buff * ) ;
#line 783
extern struct sk_buff *__alloc_skb(unsigned int  , gfp_t  , int  , int  ) ;
#line 787 "include/linux/skbuff.h"
__inline static struct sk_buff *alloc_skb(unsigned int size , gfp_t priority ) 
{ 
  struct sk_buff *tmp ;

  {
#line 790
  tmp = __alloc_skb(size, priority, 0, -1);
#line 790
  return (tmp);
}
}
#line 1692
extern unsigned char *skb_put(struct sk_buff * , unsigned int  ) ;
#line 113 "include/uapi/linux/ethtool.h"
__inline static void ethtool_cmd_speed_set(struct ethtool_cmd *ep , __u32 speed ) 
{ 


  {
#line 117
  ep->speed = (unsigned short )speed;
#line 118
  ep->speed_hi = (unsigned short )(speed >> 16);
#line 119
  return;
}
}
#line 121 "include/uapi/linux/ethtool.h"
__inline static __u32 ethtool_cmd_speed(struct ethtool_cmd  const  *ep ) 
{ 


  {
#line 123
  return ((__u32 )(((int )ep->speed_hi << 16) | (int )ep->speed));
}
}
#line 819 "include/uapi/linux/ethtool.h"
__inline static __u64 ethtool_get_flow_spec_ring(__u64 ring_cookie ) 
{ 


  {
#line 821
  return (ring_cookie & 4294967295ULL);
}
}
#line 824 "include/uapi/linux/ethtool.h"
__inline static __u64 ethtool_get_flow_spec_ring_vf(__u64 ring_cookie ) 
{ 


  {
#line 826
  return ((ring_cookie & 1095216660480ULL) >> 32);
}
}
#line 85 "include/linux/ethtool.h"
extern u32 ethtool_op_get_link(struct net_device * ) ;
#line 86
extern int ethtool_op_get_ts_info(struct net_device * , struct ethtool_ts_info * ) ;
#line 2182 "include/linux/netdevice.h"
extern int dev_open(struct net_device * ) ;
#line 2183
extern int dev_close(struct net_device * ) ;
#line 3475
extern struct rtnl_link_stats64 *dev_get_stats(struct net_device * , struct rtnl_link_stats64 * ) ;
#line 69 "include/linux/vmalloc.h"
extern void *vmalloc(unsigned long  ) ;
#line 56 "include/linux/highmem.h"
__inline static void *kmap(struct page *page ) 
{ 
  void *tmp ;

  {
#line 58
  __might_sleep("include/linux/highmem.h", 58, 0);
#line 59
  tmp = lowmem_page_address((struct page  const  *)page);
#line 59
  return (tmp);
}
}
#line 62 "include/linux/highmem.h"
__inline static void kunmap(struct page *page ) 
{ 


  {
#line 64
  return;
}
}
#line 177 "include/linux/ptp_clock_kernel.h"
extern int ptp_clock_index(struct ptp_clock * ) ;
#line 895 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
s32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw , union ixgbe_atr_input *input ,
                                          u16 soft_id ) ;
#line 898
void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input , union ixgbe_atr_input *input_mask ) ;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static struct ixgbe_stats  const  ixgbe_gstrings_stats[57U]  = 
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
  {      {{'r', 'x', '_', 'p', 'a', 'c', 'k', 'e', 't', 's', '\000'}, 0, 8, 0}, 
        {{'t', 'x', '_', 'p', 'a', 'c', 'k', 'e', 't', 's', '\000'}, 0, 8, 8}, 
        {{'r', 'x', '_', 'b', 'y', 't', 'e', 's', '\000'}, 0, 8, 16}, 
        {{'t', 'x', '_', 'b', 'y', 't', 'e', 's', '\000'}, 0, 8, 24}, 
        {{'r', 'x', '_', 'p', 'k', 't', 's', '_', 'n', 'i', 'c', '\000'}, 1, 8, 39032}, 
        {{'t',
       'x', '_', 'p', 'k', 't', 's', '_', 'n', 'i', 'c', '\000'}, 1, 8, 39056}, 
        {{'r', 'x', '_', 'b', 'y', 't', 'e', 's', '_', 'n', 'i', 'c', '\000'}, 1, 8,
      39064}, 
        {{'t', 'x', '_', 'b', 'y', 't', 'e', 's', '_', 'n', 'i', 'c', '\000'}, 1, 8,
      39072}, 
        {{'l', 's', 'c', '_', 'i', 'n', 't', '\000'}, 1, 8, 1096}, 
        {{'t', 'x', '_', 'b', 'u', 's', 'y', '\000'}, 1, 8, 40336}, 
        {{'n', 'o', 'n', '_', 'e', 'o', 'p', '_', 'd', 'e', 's', 'c', 's', '\000'}, 1,
      8, 1664}, 
        {{'r', 'x', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 0, 8, 32}, 
        {{'t', 'x', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 0, 8, 40}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '\000'}, 0, 8, 48}, 
        {{'t', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '\000'}, 0, 8, 56}, 
        {{'m', 'u', 'l', 't', 'i', 'c', 'a', 's', 't', '\000'}, 0, 8, 64}, 
        {{'b', 'r', 'o', 'a', 'd', 'c', 'a', 's', 't', '\000'}, 1, 8, 39040}, 
        {{'r', 'x', '_', 'n', 'o', '_', 'b', 'u', 'f', 'f', 'e', 'r', '_', 'c', 'o',
       'u', 'n', 't', '\000'}, 1, 8, 39080}, 
        {{'c', 'o', 'l', 'l', 'i', 's', 'i', 'o', 'n', 's', '\000'}, 0, 8, 72}, 
        {{'r', 'x', '_', 'o', 'v', 'e', 'r', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'},
      0, 8, 88}, 
        {{'r', 'x', '_', 'c', 'r', 'c', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 0,
      8, 96}, 
        {{'r', 'x', '_', 'f', 'r', 'a', 'm', 'e', '_', 'e', 'r', 'r', 'o', 'r', 's',
       '\000'}, 0, 8, 104}, 
        {{'h', 'w', '_', 'r', 's', 'c', '_', 'a', 'g', 'g', 'r', 'e', 'g', 'a', 't',
       'e', 'd', '\000'}, 1, 8, 1648}, 
        {{'h', 'w', '_', 'r', 's', 'c', '_', 'f', 'l', 'u', 's', 'h', 'e', 'd', '\000'},
      1, 8, 1656}, 
        {{'f', 'd', 'i', 'r', '_', 'm', 'a', 't', 'c', 'h', '\000'}, 1, 8, 40224}, 
        {{'f', 'd', 'i', 'r', '_', 'm', 'i', 's', 's', '\000'}, 1, 8, 40232}, 
        {{'f', 'd', 'i', 'r', '_', 'o', 'v', 'e', 'r', 'f', 'l', 'o', 'w', '\000'}, 1,
      8, 40584}, 
        {{'r', 'x', '_', 'f', 'i', 'f', 'o', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'},
      0, 8, 112}, 
        {{'r', 'x', '_', 'm', 'i', 's', 's', 'e', 'd', '_', 'e', 'r', 'r', 'o', 'r',
       's', '\000'}, 0, 8, 120}, 
        {{'t', 'x', '_', 'a', 'b', 'o', 'r', 't', 'e', 'd', '_', 'e', 'r', 'r', 'o',
       'r', 's', '\000'}, 0, 8, 128}, 
        {{'t', 'x', '_', 'c', 'a', 'r', 'r', 'i', 'e', 'r', '_', 'e', 'r', 'r', 'o',
       'r', 's', '\000'}, 0, 8, 136}, 
        {{'t', 'x', '_', 'f', 'i', 'f', 'o', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'},
      0, 8, 144}, 
        {{'t', 'x', '_', 'h', 'e', 'a', 'r', 't', 'b', 'e', 'a', 't', '_', 'e', 'r',
       'r', 'o', 'r', 's', '\000'}, 0, 8, 152}, 
        {{'t', 'x', '_', 't', 'i', 'm', 'e', 'o', 'u', 't', '_', 'c', 'o', 'u', 'n',
       't', '\000'}, 1, 4, 1104}, 
        {{'t', 'x', '_', 'r', 'e', 's', 't', 'a', 'r', 't', '_', 'q', 'u', 'e', 'u',
       'e', '\000'}, 1, 8, 1088}, 
        {{'r', 'x', '_', 'l', 'o', 'n', 'g', '_', 'l', 'e', 'n', 'g', 't', 'h', '_',
       'e', 'r', 'r', 'o', 'r', 's', '\000'}, 1, 8, 39160}, 
        {{'r', 'x', '_', 's', 'h', 'o', 'r', 't', '_', 'l', 'e', 'n', 'g', 't', 'h',
       '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 1, 8, 39144}, 
        {{'t', 'x', '_', 'f', 'l', 'o', 'w', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l',
       '_', 'x', 'o', 'n', '\000'}, 1, 8, 38696}, 
        {{'r', 'x', '_', 'f', 'l', 'o', 'w', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l',
       '_', 'x', 'o', 'n', '\000'}, 1, 8, 38704}, 
        {{'t', 'x', '_', 'f', 'l', 'o', 'w', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l',
       '_', 'x', 'o', 'f', 'f', '\000'}, 1, 8, 38712}, 
        {{'r', 'x', '_', 'f', 'l', 'o', 'w', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l',
       '_', 'x', 'o', 'f', 'f', '\000'}, 1, 8, 38720}, 
        {{'r', 'x', '_', 'c', 's', 'u', 'm', '_', 'o', 'f', 'f', 'l', 'o', 'a', 'd',
       '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 1, 8, 1632}, 
        {{'a', 'l', 'l', 'o', 'c', '_', 'r', 'x', '_', 'p', 'a', 'g', 'e', '_', 'f',
       'a', 'i', 'l', 'e', 'd', '\000'}, 1, 4, 1672}, 
        {{'a', 'l', 'l', 'o', 'c', '_', 'r', 'x', '_', 'b', 'u', 'f', 'f', '_', 'f',
       'a', 'i', 'l', 'e', 'd', '\000'}, 1, 4, 1676}, 
        {{'r', 'x', '_', 'n', 'o', '_', 'd', 'm', 'a', '_', 'r', 'e', 's', 'o', 'u',
       'r', 'c', 'e', 's', '\000'}, 1, 8, 1640}, 
        {{'o', 's', '2', 'b', 'm', 'c', '_', 'r', 'x', '_', 'b', 'y', '_', 'b', 'm',
       'c', '\000'}, 1, 8, 40320}, 
        {{'o', 's', '2', 'b', 'm', 'c', '_', 't', 'x', '_', 'b', 'y', '_', 'b', 'm',
       'c', '\000'}, 1, 8, 40304}, 
        {{'o', 's', '2', 'b', 'm', 'c', '_', 't', 'x', '_', 'b', 'y', '_', 'h', 'o',
       's', 't', '\000'}, 1, 8, 40328}, 
        {{'o', 's', '2', 'b', 'm', 'c', '_', 'r', 'x', '_', 'b', 'y', '_', 'h', 'o',
       's', 't', '\000'}, 1, 8, 40312}, 
        {{'f', 'c', 'o', 'e', '_', 'b', 'a', 'd', '_', 'f', 'c', 'c', 'r', 'c', '\000'},
      1, 8, 40240}, 
        {{'r', 'x', '_', 'f', 'c', 'o', 'e', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd',
       '\000'}, 1, 8, 40248}, 
        {{'r', 'x', '_', 'f', 'c', 'o', 'e', '_', 'p', 'a', 'c', 'k', 'e', 't', 's',
       '\000'}, 1, 8, 40256}, 
        {{'r', 'x', '_', 'f', 'c', 'o', 'e', '_', 'd', 'w', 'o', 'r', 'd', 's', '\000'},
      1, 8, 40272}, 
        {{'f', 'c', 'o', 'e', '_', 'n', 'o', 'd', 'd', 'p', '\000'}, 1, 8, 40288}, 
        {{'f', 'c', 'o', 'e', '_', 'n', 'o', 'd', 'd', 'p', '_', 'e', 'x', 't', '_',
       'b', 'u', 'f', 'f', '\000'}, 1, 8, 40296}, 
        {{'t', 'x', '_', 'f', 'c', 'o', 'e', '_', 'p', 'a', 'c', 'k', 'e', 't', 's',
       '\000'}, 1, 8, 40264}, 
        {{'t', 'x', '_', 'f', 'c', 'o', 'e', '_', 'd', 'w', 'o', 'r', 'd', 's', '\000'},
      1, 8, 40280}};
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static char const   ixgbe_gstrings_test[5U][32U]  = { {        'R',        'e',        'g',        'i', 
            's',        't',        'e',        'r', 
            ' ',        't',        'e',        's', 
            't',        ' ',        ' ',        '(', 
            'o',        'f',        'f',        'l', 
            'i',        'n',        'e',        ')', 
            '\000'}, 
   {        'E',        'e',        'p',        'r', 
            'o',        'm',        ' ',        't', 
            'e',        's',        't',        ' ', 
            ' ',        ' ',        ' ',        '(', 
            'o',        'f',        'f',        'l', 
            'i',        'n',        'e',        ')', 
            '\000'}, 
   {        'I',        'n',        't',        'e', 
            'r',        'r',        'u',        'p', 
            't',        ' ',        't',        'e', 
            's',        't',        ' ',        '(', 
            'o',        'f',        'f',        'l', 
            'i',        'n',        'e',        ')', 
            '\000'}, 
   {        'L',        'o',        'o',        'p', 
            'b',        'a',        'c',        'k', 
            ' ',        't',        'e',        's', 
            't',        ' ',        ' ',        '(', 
            'o',        'f',        'f',        'l', 
            'i',        'n',        'e',        ')', 
            '\000'}, 
   {        'L',        'i',        'n',        'k', 
            ' ',        't',        'e',        's', 
            't',        ' ',        ' ',        ' ', 
            '(',        'o',        'n',        '/', 
            'o',        'f',        'f',        'l', 
            'i',        'n',        'e',        ')', 
            '\000'}};
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_settings(struct net_device *netdev , struct ethtool_cmd *ecmd ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  ixgbe_link_speed supported_link ;
  u32 link_speed ;
  bool autoneg ;
  bool link_up ;

  {
#line 157
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 157
  adapter = (struct ixgbe_adapter *)tmp;
#line 158
  hw = & adapter->hw;
#line 160
  link_speed = 0U;
#line 161
  autoneg = 0;
#line 164
  (*(hw->mac.ops.get_link_capabilities))(hw, & supported_link, & autoneg);
#line 167
  if ((supported_link & 128U) != 0U) {
#line 168
    ecmd->supported = ecmd->supported | 4096U;
  } else {

  }
#line 169
  if ((supported_link & 32U) != 0U) {
#line 170
    ecmd->supported = ecmd->supported | 32U;
  } else {

  }
#line 171
  if ((supported_link & 8U) != 0U) {
#line 172
    ecmd->supported = ecmd->supported | 8U;
  } else {

  }
#line 175
  if (hw->phy.autoneg_advertised != 0U) {
#line 176
    if ((hw->phy.autoneg_advertised & 8U) != 0U) {
#line 177
      ecmd->advertising = ecmd->advertising | 8U;
    } else {

    }
#line 178
    if ((hw->phy.autoneg_advertised & 128U) != 0U) {
#line 179
      ecmd->advertising = ecmd->advertising | 4096U;
    } else {

    }
#line 180
    if ((hw->phy.autoneg_advertised & 32U) != 0U) {
#line 181
      ecmd->advertising = ecmd->advertising | 32U;
    } else {

    }
  } else {
#line 184
    if ((supported_link & 128U) != 0U) {
#line 185
      ecmd->advertising = ecmd->advertising | 4096U;
    } else {

    }
#line 186
    if ((supported_link & 32U) != 0U) {
#line 187
      ecmd->advertising = ecmd->advertising | 32U;
    } else {

    }
#line 188
    if ((supported_link & 8U) != 0U) {
#line 189
      ecmd->advertising = ecmd->advertising | 8U;
    } else {

    }
#line 191
    if ((int )hw->phy.multispeed_fiber && ! autoneg) {
#line 192
      if ((supported_link & 128U) != 0U) {
#line 193
        ecmd->advertising = 4096U;
      } else {

      }
    } else {

    }
  }
#line 197
  if ((int )autoneg) {
#line 198
    ecmd->supported = ecmd->supported | 64U;
#line 199
    ecmd->advertising = ecmd->advertising | 64U;
#line 200
    ecmd->autoneg = 1U;
  } else {
#line 202
    ecmd->autoneg = 0U;
  }
#line 204
  ecmd->transceiver = 1U;
#line 207
  switch ((unsigned int )adapter->hw.phy.type) {
  case 2U: ;
  case 3U: ;
  case 6U: ;
  case 7U: 
#line 212
  ecmd->supported = ecmd->supported | 128U;
#line 213
  ecmd->advertising = ecmd->advertising | 128U;
#line 214
  ecmd->port = 0U;
#line 215
  goto ldv_55616;
  case 8U: 
#line 217
  ecmd->supported = ecmd->supported | 1024U;
#line 218
  ecmd->advertising = ecmd->advertising | 1024U;
#line 219
  ecmd->port = 3U;
#line 220
  goto ldv_55616;
  case 10U: ;
  case 11U: ;
  case 12U: ;
  case 15U: ;
  case 14U: ;
  case 18U: ;
  case 17U: ;
#line 229
  switch ((unsigned int )adapter->hw.phy.sfp_type) {
  case 0U: ;
  case 3U: ;
  case 4U: 
#line 233
  ecmd->supported = ecmd->supported | 1024U;
#line 234
  ecmd->advertising = ecmd->advertising | 1024U;
#line 235
  ecmd->port = 5U;
#line 236
  goto ldv_55628;
  case 1U: ;
  case 2U: ;
  case 5U: ;
  case 6U: ;
  case 11U: ;
  case 12U: ;
  case 13U: ;
  case 14U: 
#line 245
  ecmd->supported = ecmd->supported | 1024U;
#line 246
  ecmd->advertising = ecmd->advertising | 1024U;
#line 247
  ecmd->port = 3U;
#line 248
  goto ldv_55628;
  case 65534U: 
#line 250
  ecmd->supported = ecmd->supported | 1024U;
#line 251
  ecmd->advertising = ecmd->advertising | 1024U;
#line 252
  ecmd->port = 239U;
#line 253
  goto ldv_55628;
  case 9U: ;
  case 10U: 
#line 256
  ecmd->supported = ecmd->supported | 128U;
#line 257
  ecmd->advertising = ecmd->advertising | 128U;
#line 258
  ecmd->port = 0U;
#line 259
  goto ldv_55628;
  case 65535U: ;
  default: 
#line 262
  ecmd->supported = ecmd->supported | 1024U;
#line 263
  ecmd->advertising = ecmd->advertising | 1024U;
#line 264
  ecmd->port = 255U;
#line 265
  goto ldv_55628;
  }
  ldv_55628: ;
#line 267
  goto ldv_55616;
  case 9U: 
#line 269
  ecmd->supported = ecmd->supported | 1024U;
#line 270
  ecmd->advertising = ecmd->advertising | 1024U;
#line 271
  ecmd->port = 239U;
#line 272
  goto ldv_55616;
  case 0U: ;
  case 24U: ;
  case 23U: ;
  default: 
#line 277
  ecmd->supported = ecmd->supported | 1024U;
#line 278
  ecmd->advertising = ecmd->advertising | 1024U;
#line 279
  ecmd->port = 255U;
#line 280
  goto ldv_55616;
  }
  ldv_55616: 
#line 283
  (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
#line 284
  if ((int )link_up) {
#line 285
    switch (link_speed) {
    case 128U: 
#line 287
    ethtool_cmd_speed_set(ecmd, 10000U);
#line 288
    goto ldv_55648;
    case 32U: 
#line 290
    ethtool_cmd_speed_set(ecmd, 1000U);
#line 291
    goto ldv_55648;
    case 8U: 
#line 293
    ethtool_cmd_speed_set(ecmd, 100U);
#line 294
    goto ldv_55648;
    default: ;
#line 296
    goto ldv_55648;
    }
    ldv_55648: 
#line 298
    ecmd->duplex = 1U;
  } else {
#line 300
    ethtool_cmd_speed_set(ecmd, 4294967295U);
#line 301
    ecmd->duplex = 255U;
  }
#line 304
  return (0);
}
}
#line 307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_settings(struct net_device *netdev , struct ethtool_cmd *ecmd ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u32 advertised ;
  u32 old ;
  s32 err ;
  int tmp___0 ;
  u32 speed ;
  __u32 tmp___1 ;

  {
#line 310
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 310
  adapter = (struct ixgbe_adapter *)tmp;
#line 311
  hw = & adapter->hw;
#line 313
  err = 0;
#line 315
  if ((unsigned int )hw->phy.media_type == 4U || (int )hw->phy.multispeed_fiber) {
#line 321
    if ((ecmd->advertising & ~ ecmd->supported) != 0U) {
#line 322
      return (-22);
    } else {

    }
#line 325
    if ((unsigned int )ecmd->autoneg == 0U && (int )hw->phy.multispeed_fiber) {
#line 326
      if (ecmd->advertising == 4128U) {
#line 329
        return (-22);
      } else {

      }
    } else {

    }
#line 332
    old = hw->phy.autoneg_advertised;
#line 333
    advertised = 0U;
#line 334
    if ((ecmd->advertising & 4096U) != 0U) {
#line 335
      advertised = advertised | 128U;
    } else {

    }
#line 337
    if ((ecmd->advertising & 32U) != 0U) {
#line 338
      advertised = advertised | 32U;
    } else {

    }
#line 340
    if ((ecmd->advertising & 8U) != 0U) {
#line 341
      advertised = advertised | 8U;
    } else {

    }
#line 343
    if (old == advertised) {
#line 344
      return (err);
    } else {

    }
#line 346
    goto ldv_55662;
    ldv_55661: 
#line 347
    usleep_range(1000UL, 2000UL);
    ldv_55662: 
#line 346
    tmp___0 = test_and_set_bit(7L, (unsigned long volatile   *)(& adapter->state));
#line 346
    if (tmp___0 != 0) {
#line 348
      goto ldv_55661;
    } else {

    }
#line 349
    hw->mac.autotry_restart = 1;
#line 350
    err = (*(hw->mac.ops.setup_link))(hw, advertised, 1);
#line 351
    if (err != 0) {
#line 352
      if (((int )adapter->msg_enable & 2) != 0) {
#line 352
        netdev_info((struct net_device  const  *)adapter->netdev, "setup link failed with code %d\n",
                    err);
      } else {

      }
#line 353
      (*(hw->mac.ops.setup_link))(hw, old, 1);
    } else {

    }
#line 355
    clear_bit(7L, (unsigned long volatile   *)(& adapter->state));
  } else {
#line 358
    tmp___1 = ethtool_cmd_speed((struct ethtool_cmd  const  *)ecmd);
#line 358
    speed = tmp___1;
#line 359
    if (((unsigned int )ecmd->autoneg == 1U || ecmd->advertising != 4096U) || (u32 )ecmd->duplex + speed != 10001U) {
#line 362
      return (-22);
    } else {

    }
  }
#line 365
  return (err);
}
}
#line 368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_pauseparam(struct net_device *netdev , struct ethtool_pauseparam *pause ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  bool tmp___0 ;

  {
#line 371
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 371
  adapter = (struct ixgbe_adapter *)tmp;
#line 372
  hw = & adapter->hw;
#line 374
  tmp___0 = ixgbe_device_supports_autoneg_fc(hw);
#line 374
  if ((int )tmp___0 && ! hw->fc.disable_fc_autoneg) {
#line 376
    pause->autoneg = 1U;
  } else {
#line 378
    pause->autoneg = 0U;
  }
#line 380
  if ((unsigned int )hw->fc.current_mode == 1U) {
#line 381
    pause->rx_pause = 1U;
  } else
#line 382
  if ((unsigned int )hw->fc.current_mode == 2U) {
#line 383
    pause->tx_pause = 1U;
  } else
#line 384
  if ((unsigned int )hw->fc.current_mode == 3U) {
#line 385
    pause->rx_pause = 1U;
#line 386
    pause->tx_pause = 1U;
  } else {

  }
#line 388
  return;
}
}
#line 390 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_pauseparam(struct net_device *netdev , struct ethtool_pauseparam *pause ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  struct ixgbe_fc_info fc ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 393
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 393
  adapter = (struct ixgbe_adapter *)tmp;
#line 394
  hw = & adapter->hw;
#line 395
  fc = hw->fc;
#line 398
  if ((unsigned int )hw->mac.type == 1U && (adapter->flags & 4096U) != 0U) {
#line 400
    return (-22);
  } else {

  }
#line 403
  if (pause->autoneg == 1U) {
#line 403
    tmp___0 = ixgbe_device_supports_autoneg_fc(hw);
#line 403
    if (tmp___0) {
#line 403
      tmp___1 = 0;
    } else {
#line 403
      tmp___1 = 1;
    }
#line 403
    if (tmp___1) {
#line 405
      return (-22);
    } else {

    }
  } else {

  }
#line 407
  fc.disable_fc_autoneg = pause->autoneg != 1U;
#line 409
  if ((pause->rx_pause != 0U && pause->tx_pause != 0U) || pause->autoneg != 0U) {
#line 410
    fc.requested_mode = 3;
  } else
#line 411
  if (pause->rx_pause != 0U && pause->tx_pause == 0U) {
#line 412
    fc.requested_mode = 1;
  } else
#line 413
  if (pause->rx_pause == 0U && pause->tx_pause != 0U) {
#line 414
    fc.requested_mode = 2;
  } else {
#line 416
    fc.requested_mode = 0;
  }
#line 419
  tmp___3 = memcmp((void const   *)(& fc), (void const   *)(& hw->fc), 80UL);
#line 419
  if (tmp___3 != 0) {
#line 420
    hw->fc = fc;
#line 421
    tmp___2 = netif_running((struct net_device  const  *)netdev);
#line 421
    if ((int )tmp___2) {
#line 422
      ixgbe_reinit_locked(adapter);
    } else {
#line 424
      ixgbe_reset(adapter);
    }
  } else {

  }
#line 427
  return (0);
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static u32 ixgbe_get_msglevel(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 432
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 432
  adapter = (struct ixgbe_adapter *)tmp;
#line 433
  return ((u32 )adapter->msg_enable);
}
}
#line 436 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_set_msglevel(struct net_device *netdev , u32 data ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 438
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 438
  adapter = (struct ixgbe_adapter *)tmp;
#line 439
  adapter->msg_enable = (u16 )data;
#line 440
  return;
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_regs_len(struct net_device *netdev ) 
{ 


  {
#line 445
  return (4556);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_regs(struct net_device *netdev , struct ethtool_regs *regs ,
                           void *p ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u32 *regs_buff ;
  u8 i ;

  {
#line 453
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 453
  adapter = (struct ixgbe_adapter *)tmp;
#line 454
  hw = & adapter->hw;
#line 455
  regs_buff = (u32 *)p;
#line 458
  memset(p, 0, 4556UL);
#line 460
  regs->version = (((unsigned int )hw->mac.type << 24) | (unsigned int )((int )hw->revision_id << 16)) | (unsigned int )hw->device_id;
#line 464
  *regs_buff = ixgbe_read_reg(hw, 0U);
#line 465
  *(regs_buff + 1UL) = ixgbe_read_reg(hw, 8U);
#line 466
  *(regs_buff + 2UL) = ixgbe_read_reg(hw, 24U);
#line 467
  *(regs_buff + 3UL) = ixgbe_read_reg(hw, 32U);
#line 468
  *(regs_buff + 4UL) = ixgbe_read_reg(hw, 40U);
#line 469
  *(regs_buff + 5UL) = ixgbe_read_reg(hw, 512U);
#line 470
  *(regs_buff + 6UL) = ixgbe_read_reg(hw, 72U);
#line 471
  *(regs_buff + 7UL) = ixgbe_read_reg(hw, 76U);
#line 474
  *(regs_buff + 8UL) = ixgbe_read_reg(hw, *(hw->mvals));
#line 475
  *(regs_buff + 9UL) = ixgbe_read_reg(hw, 65556U);
#line 476
  *(regs_buff + 10UL) = ixgbe_read_reg(hw, *(hw->mvals + 1UL));
#line 477
  *(regs_buff + 11UL) = ixgbe_read_reg(hw, 65808U);
#line 478
  *(regs_buff + 12UL) = ixgbe_read_reg(hw, 65812U);
#line 479
  *(regs_buff + 13UL) = ixgbe_read_reg(hw, 65816U);
#line 480
  *(regs_buff + 14UL) = ixgbe_read_reg(hw, 65820U);
#line 481
  *(regs_buff + 15UL) = ixgbe_read_reg(hw, 65824U);
#line 482
  *(regs_buff + 16UL) = ixgbe_read_reg(hw, 65852U);
#line 483
  *(regs_buff + 17UL) = ixgbe_read_reg(hw, *(hw->mvals + 2UL));
#line 488
  *(regs_buff + 18UL) = ixgbe_read_reg(hw, 2056U);
#line 489
  *(regs_buff + 19UL) = ixgbe_read_reg(hw, 2056U);
#line 490
  *(regs_buff + 20UL) = ixgbe_read_reg(hw, 2176U);
#line 491
  *(regs_buff + 21UL) = ixgbe_read_reg(hw, 2184U);
#line 492
  *(regs_buff + 22UL) = ixgbe_read_reg(hw, 2064U);
#line 493
  *(regs_buff + 23UL) = ixgbe_read_reg(hw, 2192U);
#line 494
  *(regs_buff + 24UL) = ixgbe_read_reg(hw, 2080U);
#line 495
  *(regs_buff + 25UL) = ixgbe_read_reg(hw, 2304U);
#line 496
  *(regs_buff + 26UL) = ixgbe_read_reg(hw, 0U);
#line 497
  *(regs_buff + 27UL) = ixgbe_read_reg(hw, 8192U);
#line 498
  *(regs_buff + 28UL) = ixgbe_read_reg(hw, 69736U);
#line 499
  *(regs_buff + 29UL) = ixgbe_read_reg(hw, 2200U);
#line 502
  *(regs_buff + 30UL) = ixgbe_read_reg(hw, 12296U);
#line 503
  *(regs_buff + 31UL) = ixgbe_read_reg(hw, 12800U);
#line 504
  *(regs_buff + 32UL) = ixgbe_read_reg(hw, 12804U);
#line 505
  *(regs_buff + 33UL) = ixgbe_read_reg(hw, 12808U);
#line 506
  *(regs_buff + 34UL) = ixgbe_read_reg(hw, 12812U);
#line 507
  i = 0U;
#line 507
  goto ldv_55707;
  ldv_55706: ;
#line 508
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 510
  *(regs_buff + (unsigned long )((int )i + 35)) = ixgbe_read_reg(hw, (u32 )(((int )i + 1604) * 8));
#line 511
  *(regs_buff + (unsigned long )((int )i + 43)) = ixgbe_read_reg(hw, (u32 )(((int )i + 1612) * 8));
#line 512
  goto ldv_55700;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 517
  *(regs_buff + (unsigned long )((int )i + 35)) = ixgbe_read_reg(hw, (u32 )(((int )i + 3208) * 4));
#line 518
  *(regs_buff + (unsigned long )((int )i + 43)) = ixgbe_read_reg(hw, (u32 )(((int )i + 3224) * 4));
#line 519
  goto ldv_55700;
  default: ;
#line 521
  goto ldv_55700;
  }
  ldv_55700: 
#line 507
  i = (u8 )((int )i + 1);
  ldv_55707: ;
#line 507
  if ((unsigned int )i <= 7U) {
#line 509
    goto ldv_55706;
  } else {

  }
#line 524
  *(regs_buff + 51UL) = ixgbe_read_reg(hw, 12960U);
#line 525
  *(regs_buff + 52UL) = ixgbe_read_reg(hw, 52736U);
#line 528
  i = 0U;
#line 528
  goto ldv_55710;
  ldv_55709: 
#line 529
  *(regs_buff + (unsigned long )((int )i + 53)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 63U ? ((int )i + 64) * 64 : ((int )i + 768) * 64));
#line 528
  i = (u8 )((int )i + 1);
  ldv_55710: ;
#line 528
  if ((unsigned int )i <= 63U) {
#line 530
    goto ldv_55709;
  } else {

  }
#line 530
  i = 0U;
#line 530
  goto ldv_55713;
  ldv_55712: 
#line 531
  *(regs_buff + (unsigned long )((int )i + 117)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 63U ? (int )i * 64 + 4100 : ((int )i + -64) * 64 + 53252));
#line 530
  i = (u8 )((int )i + 1);
  ldv_55713: ;
#line 530
  if ((unsigned int )i <= 63U) {
#line 532
    goto ldv_55712;
  } else {

  }
#line 532
  i = 0U;
#line 532
  goto ldv_55716;
  ldv_55715: 
#line 533
  *(regs_buff + (unsigned long )((int )i + 181)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 63U ? (int )i * 64 + 4104 : ((int )i + -64) * 64 + 53256));
#line 532
  i = (u8 )((int )i + 1);
  ldv_55716: ;
#line 532
  if ((unsigned int )i <= 63U) {
#line 534
    goto ldv_55715;
  } else {

  }
#line 534
  i = 0U;
#line 534
  goto ldv_55719;
  ldv_55718: 
#line 535
  *(regs_buff + (unsigned long )((int )i + 245)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 63U ? (int )i * 64 + 4112 : ((int )i + -64) * 64 + 53264));
#line 534
  i = (u8 )((int )i + 1);
  ldv_55719: ;
#line 534
  if ((unsigned int )i <= 63U) {
#line 536
    goto ldv_55718;
  } else {

  }
#line 536
  i = 0U;
#line 536
  goto ldv_55722;
  ldv_55721: 
#line 537
  *(regs_buff + (unsigned long )((int )i + 309)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 63U ? (int )i * 64 + 4120 : ((int )i + -64) * 64 + 53272));
#line 536
  i = (u8 )((int )i + 1);
  ldv_55722: ;
#line 536
  if ((unsigned int )i <= 63U) {
#line 538
    goto ldv_55721;
  } else {

  }
#line 538
  i = 0U;
#line 538
  goto ldv_55725;
  ldv_55724: 
#line 539
  *(regs_buff + (unsigned long )((int )i + 373)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 63U ? (int )i * 64 + 4136 : ((int )i + -64) * 64 + 53288));
#line 538
  i = (u8 )((int )i + 1);
  ldv_55725: ;
#line 538
  if ((unsigned int )i <= 63U) {
#line 540
    goto ldv_55724;
  } else {

  }
#line 540
  i = 0U;
#line 540
  goto ldv_55728;
  ldv_55727: 
#line 541
  *(regs_buff + (unsigned long )((int )i + 437)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 15U ? ((int )i + 2112) * 4 : ((unsigned int )i <= 63U ? (int )i * 64 + 4116 : ((int )i + -64) * 64 + 53268)));
#line 540
  i = (u8 )((int )i + 1);
  ldv_55728: ;
#line 540
  if ((unsigned int )i <= 15U) {
#line 542
    goto ldv_55727;
  } else {

  }
#line 542
  i = 0U;
#line 542
  goto ldv_55731;
  ldv_55730: 
#line 543
  *(regs_buff + (unsigned long )((int )i + 453)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 15U ? ((int )i + 2176) * 4 : ((unsigned int )i <= 63U ? (int )i * 64 + 4108 : ((int )i + -64) * 64 + 53260)));
#line 542
  i = (u8 )((int )i + 1);
  ldv_55731: ;
#line 542
  if ((unsigned int )i <= 15U) {
#line 544
    goto ldv_55730;
  } else {

  }
#line 544
  *(regs_buff + 469UL) = ixgbe_read_reg(hw, 12032U);
#line 545
  i = 0U;
#line 545
  goto ldv_55734;
  ldv_55733: 
#line 546
  *(regs_buff + (unsigned long )((int )i + 470)) = ixgbe_read_reg(hw, (u32 )(((int )i + 3840) * 4));
#line 545
  i = (u8 )((int )i + 1);
  ldv_55734: ;
#line 545
  if ((unsigned int )i <= 7U) {
#line 547
    goto ldv_55733;
  } else {

  }
#line 547
  *(regs_buff + 478UL) = ixgbe_read_reg(hw, 12288U);
#line 548
  *(regs_buff + 479UL) = ixgbe_read_reg(hw, 15620U);
#line 551
  *(regs_buff + 480UL) = ixgbe_read_reg(hw, 20480U);
#line 552
  *(regs_buff + 481UL) = ixgbe_read_reg(hw, 20488U);
#line 553
  i = 0U;
#line 553
  goto ldv_55737;
  ldv_55736: 
#line 554
  *(regs_buff + (unsigned long )((int )i + 482)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 15U ? ((int )i + 2688) * 8 : ((int )i + 5184) * 8));
#line 553
  i = (u8 )((int )i + 1);
  ldv_55737: ;
#line 553
  if ((unsigned int )i <= 15U) {
#line 555
    goto ldv_55736;
  } else {

  }
#line 555
  i = 0U;
#line 555
  goto ldv_55740;
  ldv_55739: 
#line 556
  *(regs_buff + (unsigned long )((int )i + 498)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 15U ? (int )i * 8 + 21508 : (int )i * 8 + 41476));
#line 555
  i = (u8 )((int )i + 1);
  ldv_55740: ;
#line 555
  if ((unsigned int )i <= 15U) {
#line 557
    goto ldv_55739;
  } else {

  }
#line 557
  *(regs_buff + 514UL) = ixgbe_read_reg(hw, 21632U);
#line 558
  *(regs_buff + 515UL) = ixgbe_read_reg(hw, 20608U);
#line 559
  *(regs_buff + 516UL) = ixgbe_read_reg(hw, 20616U);
#line 560
  *(regs_buff + 517UL) = ixgbe_read_reg(hw, 20624U);
#line 561
  *(regs_buff + 518UL) = ixgbe_read_reg(hw, 22552U);
#line 562
  *(regs_buff + 519UL) = ixgbe_read_reg(hw, 22556U);
#line 563
  i = 0U;
#line 563
  goto ldv_55743;
  ldv_55742: 
#line 564
  *(regs_buff + (unsigned long )((int )i + 520)) = ixgbe_read_reg(hw, (u32 )(((int )i + 5792) * 4));
#line 563
  i = (u8 )((int )i + 1);
  ldv_55743: ;
#line 563
  if ((unsigned int )i <= 7U) {
#line 565
    goto ldv_55742;
  } else {

  }
#line 565
  i = 0U;
#line 565
  goto ldv_55746;
  ldv_55745: 
#line 566
  *(regs_buff + (unsigned long )((int )i + 528)) = ixgbe_read_reg(hw, (u32 )(((int )i + 5800) * 4));
#line 565
  i = (u8 )((int )i + 1);
  ldv_55746: ;
#line 565
  if ((unsigned int )i <= 7U) {
#line 567
    goto ldv_55745;
  } else {

  }
#line 567
  *(regs_buff + 536UL) = ixgbe_read_reg(hw, 23232U);
#line 570
  i = 0U;
#line 570
  goto ldv_55749;
  ldv_55748: 
#line 571
  *(regs_buff + (unsigned long )((int )i + 537)) = ixgbe_read_reg(hw, (u32 )(((int )i + 384) * 64));
#line 570
  i = (u8 )((int )i + 1);
  ldv_55749: ;
#line 570
  if ((unsigned int )i <= 31U) {
#line 572
    goto ldv_55748;
  } else {

  }
#line 572
  i = 0U;
#line 572
  goto ldv_55752;
  ldv_55751: 
#line 573
  *(regs_buff + (unsigned long )((int )i + 569)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24580));
#line 572
  i = (u8 )((int )i + 1);
  ldv_55752: ;
#line 572
  if ((unsigned int )i <= 31U) {
#line 574
    goto ldv_55751;
  } else {

  }
#line 574
  i = 0U;
#line 574
  goto ldv_55755;
  ldv_55754: 
#line 575
  *(regs_buff + (unsigned long )((int )i + 601)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24584));
#line 574
  i = (u8 )((int )i + 1);
  ldv_55755: ;
#line 574
  if ((unsigned int )i <= 31U) {
#line 576
    goto ldv_55754;
  } else {

  }
#line 576
  i = 0U;
#line 576
  goto ldv_55758;
  ldv_55757: 
#line 577
  *(regs_buff + (unsigned long )((int )i + 633)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24592));
#line 576
  i = (u8 )((int )i + 1);
  ldv_55758: ;
#line 576
  if ((unsigned int )i <= 31U) {
#line 578
    goto ldv_55757;
  } else {

  }
#line 578
  i = 0U;
#line 578
  goto ldv_55761;
  ldv_55760: 
#line 579
  *(regs_buff + (unsigned long )((int )i + 665)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24600));
#line 578
  i = (u8 )((int )i + 1);
  ldv_55761: ;
#line 578
  if ((unsigned int )i <= 31U) {
#line 580
    goto ldv_55760;
  } else {

  }
#line 580
  i = 0U;
#line 580
  goto ldv_55764;
  ldv_55763: 
#line 581
  *(regs_buff + (unsigned long )((int )i + 697)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24616));
#line 580
  i = (u8 )((int )i + 1);
  ldv_55764: ;
#line 580
  if ((unsigned int )i <= 31U) {
#line 582
    goto ldv_55763;
  } else {

  }
#line 582
  i = 0U;
#line 582
  goto ldv_55767;
  ldv_55766: 
#line 583
  *(regs_buff + (unsigned long )((int )i + 729)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24632));
#line 582
  i = (u8 )((int )i + 1);
  ldv_55767: ;
#line 582
  if ((unsigned int )i <= 31U) {
#line 584
    goto ldv_55766;
  } else {

  }
#line 584
  i = 0U;
#line 584
  goto ldv_55770;
  ldv_55769: 
#line 585
  *(regs_buff + (unsigned long )((int )i + 761)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24636));
#line 584
  i = (u8 )((int )i + 1);
  ldv_55770: ;
#line 584
  if ((unsigned int )i <= 31U) {
#line 586
    goto ldv_55769;
  } else {

  }
#line 586
  *(regs_buff + 793UL) = ixgbe_read_reg(hw, 32256U);
#line 587
  i = 0U;
#line 587
  goto ldv_55773;
  ldv_55772: 
#line 588
  *(regs_buff + (unsigned long )((int )i + 794)) = ixgbe_read_reg(hw, (u32 )(((int )i + 7296) * 4));
#line 587
  i = (u8 )((int )i + 1);
  ldv_55773: ;
#line 587
  if ((unsigned int )i <= 15U) {
#line 589
    goto ldv_55772;
  } else {

  }
#line 589
  *(regs_buff + 810UL) = ixgbe_read_reg(hw, 51968U);
#line 590
  i = 0U;
#line 590
  goto ldv_55776;
  ldv_55775: 
#line 591
  *(regs_buff + (unsigned long )((int )i + 811)) = ixgbe_read_reg(hw, (u32 )(((int )i + 13056) * 4));
#line 590
  i = (u8 )((int )i + 1);
  ldv_55776: ;
#line 590
  if ((unsigned int )i <= 7U) {
#line 592
    goto ldv_55775;
  } else {

  }
#line 592
  *(regs_buff + 819UL) = ixgbe_read_reg(hw, 52496U);
#line 595
  *(regs_buff + 820UL) = ixgbe_read_reg(hw, 22528U);
#line 596
  *(regs_buff + 821UL) = ixgbe_read_reg(hw, 22536U);
#line 597
  *(regs_buff + 822UL) = ixgbe_read_reg(hw, 22544U);
#line 598
  *(regs_buff + 823UL) = ixgbe_read_reg(hw, 22584U);
#line 599
  *(regs_buff + 824UL) = ixgbe_read_reg(hw, 22592U);
#line 600
  *(regs_buff + 825UL) = ixgbe_read_reg(hw, 22656U);
#line 601
  *(regs_buff + 826UL) = ixgbe_read_reg(hw, 22784U);
#line 602
  *(regs_buff + 827UL) = ixgbe_read_reg(hw, 23040U);
#line 603
  *(regs_buff + 828UL) = ixgbe_read_reg(hw, 36864U);
#line 606
  *(regs_buff + 829UL) = ixgbe_read_reg(hw, 15616U);
#line 607
  *(regs_buff + 831UL) = ixgbe_read_reg(hw, 52480U);
#line 609
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 611
  *(regs_buff + 830UL) = ixgbe_read_reg(hw, 32576U);
#line 612
  *(regs_buff + 832UL) = ixgbe_read_reg(hw, 20640U);
#line 613
  i = 0U;
#line 613
  goto ldv_55780;
  ldv_55779: 
#line 614
  *(regs_buff + (unsigned long )((int )i + 833)) = ixgbe_read_reg(hw, (u32 )(((int )i + 3848) * 4));
#line 613
  i = (u8 )((int )i + 1);
  ldv_55780: ;
#line 613
  if ((unsigned int )i <= 7U) {
#line 615
    goto ldv_55779;
  } else {

  }
#line 616
  i = 0U;
#line 616
  goto ldv_55783;
  ldv_55782: 
#line 617
  *(regs_buff + (unsigned long )((int )i + 841)) = ixgbe_read_reg(hw, (u32 )(((int )i + 3856) * 4));
#line 616
  i = (u8 )((int )i + 1);
  ldv_55783: ;
#line 616
  if ((unsigned int )i <= 7U) {
#line 618
    goto ldv_55782;
  } else {

  }
#line 619
  i = 0U;
#line 619
  goto ldv_55786;
  ldv_55785: 
#line 620
  *(regs_buff + (unsigned long )((int )i + 849)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24620));
#line 619
  i = (u8 )((int )i + 1);
  ldv_55786: ;
#line 619
  if ((unsigned int )i <= 7U) {
#line 621
    goto ldv_55785;
  } else {

  }
#line 622
  i = 0U;
#line 622
  goto ldv_55789;
  ldv_55788: 
#line 623
  *(regs_buff + (unsigned long )((int )i + 857)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 25132));
#line 622
  i = (u8 )((int )i + 1);
  ldv_55789: ;
#line 622
  if ((unsigned int )i <= 7U) {
#line 624
    goto ldv_55788;
  } else {

  }

#line 625
  goto ldv_55791;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 630
  *(regs_buff + 830UL) = ixgbe_read_reg(hw, 18688U);
#line 631
  *(regs_buff + 832UL) = ixgbe_read_reg(hw, 9264U);
#line 632
  i = 0U;
#line 632
  goto ldv_55797;
  ldv_55796: 
#line 633
  *(regs_buff + (unsigned long )((int )i + 833)) = ixgbe_read_reg(hw, (u32 )(((int )i + 2128) * 4));
#line 632
  i = (u8 )((int )i + 1);
  ldv_55797: ;
#line 632
  if ((unsigned int )i <= 7U) {
#line 634
    goto ldv_55796;
  } else {

  }
#line 635
  i = 0U;
#line 635
  goto ldv_55800;
  ldv_55799: 
#line 636
  *(regs_buff + (unsigned long )((int )i + 841)) = ixgbe_read_reg(hw, (u32 )(((int )i + 2136) * 4));
#line 635
  i = (u8 )((int )i + 1);
  ldv_55800: ;
#line 635
  if ((unsigned int )i <= 7U) {
#line 637
    goto ldv_55799;
  } else {

  }
#line 638
  i = 0U;
#line 638
  goto ldv_55803;
  ldv_55802: 
#line 639
  *(regs_buff + (unsigned long )((int )i + 849)) = ixgbe_read_reg(hw, (u32 )(((int )i + 4676) * 4));
#line 638
  i = (u8 )((int )i + 1);
  ldv_55803: ;
#line 638
  if ((unsigned int )i <= 7U) {
#line 640
    goto ldv_55802;
  } else {

  }
#line 641
  i = 0U;
#line 641
  goto ldv_55806;
  ldv_55805: 
#line 642
  *(regs_buff + (unsigned long )((int )i + 857)) = ixgbe_read_reg(hw, (u32 )(((int )i + 4684) * 4));
#line 641
  i = (u8 )((int )i + 1);
  ldv_55806: ;
#line 641
  if ((unsigned int )i <= 7U) {
#line 643
    goto ldv_55805;
  } else {

  }

#line 644
  goto ldv_55791;
  default: ;
#line 646
  goto ldv_55791;
  }
  ldv_55791: 
#line 649
  i = 0U;
#line 649
  goto ldv_55810;
  ldv_55809: 
#line 650
  *(regs_buff + (unsigned long )((int )i + 865)) = ixgbe_read_reg(hw, (u32 )(((int )i + 13128) * 4));
#line 649
  i = (u8 )((int )i + 1);
  ldv_55810: ;
#line 649
  if ((unsigned int )i <= 7U) {
#line 651
    goto ldv_55809;
  } else {

  }
#line 652
  i = 0U;
#line 652
  goto ldv_55813;
  ldv_55812: 
#line 653
  *(regs_buff + (unsigned long )((int )i + 873)) = ixgbe_read_reg(hw, (u32 )(((int )i + 13136) * 4));
#line 652
  i = (u8 )((int )i + 1);
  ldv_55813: ;
#line 652
  if ((unsigned int )i <= 7U) {
#line 654
    goto ldv_55812;
  } else {

  }
#line 657
  *(regs_buff + 881UL) = (u32 )adapter->stats.crcerrs;
#line 658
  *(regs_buff + 882UL) = (u32 )adapter->stats.illerrc;
#line 659
  *(regs_buff + 883UL) = (u32 )adapter->stats.errbc;
#line 660
  *(regs_buff + 884UL) = (u32 )adapter->stats.mspdc;
#line 661
  i = 0U;
#line 661
  goto ldv_55816;
  ldv_55815: 
#line 662
  *(regs_buff + (unsigned long )((int )i + 885)) = (u32 )adapter->stats.mpc[(int )i];
#line 661
  i = (u8 )((int )i + 1);
  ldv_55816: ;
#line 661
  if ((unsigned int )i <= 7U) {
#line 663
    goto ldv_55815;
  } else {

  }
#line 663
  *(regs_buff + 893UL) = (u32 )adapter->stats.mlfc;
#line 664
  *(regs_buff + 894UL) = (u32 )adapter->stats.mrfc;
#line 665
  *(regs_buff + 895UL) = (u32 )adapter->stats.rlec;
#line 666
  *(regs_buff + 896UL) = (u32 )adapter->stats.lxontxc;
#line 667
  *(regs_buff + 897UL) = (u32 )adapter->stats.lxonrxc;
#line 668
  *(regs_buff + 898UL) = (u32 )adapter->stats.lxofftxc;
#line 669
  *(regs_buff + 899UL) = (u32 )adapter->stats.lxoffrxc;
#line 670
  i = 0U;
#line 670
  goto ldv_55819;
  ldv_55818: 
#line 671
  *(regs_buff + (unsigned long )((int )i + 900)) = (u32 )adapter->stats.pxontxc[(int )i];
#line 670
  i = (u8 )((int )i + 1);
  ldv_55819: ;
#line 670
  if ((unsigned int )i <= 7U) {
#line 672
    goto ldv_55818;
  } else {

  }
#line 672
  i = 0U;
#line 672
  goto ldv_55822;
  ldv_55821: 
#line 673
  *(regs_buff + (unsigned long )((int )i + 908)) = (u32 )adapter->stats.pxonrxc[(int )i];
#line 672
  i = (u8 )((int )i + 1);
  ldv_55822: ;
#line 672
  if ((unsigned int )i <= 7U) {
#line 674
    goto ldv_55821;
  } else {

  }
#line 674
  i = 0U;
#line 674
  goto ldv_55825;
  ldv_55824: 
#line 675
  *(regs_buff + (unsigned long )((int )i + 916)) = (u32 )adapter->stats.pxofftxc[(int )i];
#line 674
  i = (u8 )((int )i + 1);
  ldv_55825: ;
#line 674
  if ((unsigned int )i <= 7U) {
#line 676
    goto ldv_55824;
  } else {

  }
#line 676
  i = 0U;
#line 676
  goto ldv_55828;
  ldv_55827: 
#line 677
  *(regs_buff + (unsigned long )((int )i + 924)) = (u32 )adapter->stats.pxoffrxc[(int )i];
#line 676
  i = (u8 )((int )i + 1);
  ldv_55828: ;
#line 676
  if ((unsigned int )i <= 7U) {
#line 678
    goto ldv_55827;
  } else {

  }
#line 678
  *(regs_buff + 932UL) = (u32 )adapter->stats.prc64;
#line 679
  *(regs_buff + 933UL) = (u32 )adapter->stats.prc127;
#line 680
  *(regs_buff + 934UL) = (u32 )adapter->stats.prc255;
#line 681
  *(regs_buff + 935UL) = (u32 )adapter->stats.prc511;
#line 682
  *(regs_buff + 936UL) = (u32 )adapter->stats.prc1023;
#line 683
  *(regs_buff + 937UL) = (u32 )adapter->stats.prc1522;
#line 684
  *(regs_buff + 938UL) = (u32 )adapter->stats.gprc;
#line 685
  *(regs_buff + 939UL) = (u32 )adapter->stats.bprc;
#line 686
  *(regs_buff + 940UL) = (u32 )adapter->stats.mprc;
#line 687
  *(regs_buff + 941UL) = (u32 )adapter->stats.gptc;
#line 688
  *(regs_buff + 942UL) = (u32 )adapter->stats.gorc;
#line 689
  *(regs_buff + 944UL) = (u32 )adapter->stats.gotc;
#line 690
  i = 0U;
#line 690
  goto ldv_55831;
  ldv_55830: 
#line 691
  *(regs_buff + (unsigned long )((int )i + 946)) = (u32 )adapter->stats.rnbc[(int )i];
#line 690
  i = (u8 )((int )i + 1);
  ldv_55831: ;
#line 690
  if ((unsigned int )i <= 7U) {
#line 692
    goto ldv_55830;
  } else {

  }
#line 692
  *(regs_buff + 954UL) = (u32 )adapter->stats.ruc;
#line 693
  *(regs_buff + 955UL) = (u32 )adapter->stats.rfc;
#line 694
  *(regs_buff + 956UL) = (u32 )adapter->stats.roc;
#line 695
  *(regs_buff + 957UL) = (u32 )adapter->stats.rjc;
#line 696
  *(regs_buff + 958UL) = (u32 )adapter->stats.mngprc;
#line 697
  *(regs_buff + 959UL) = (u32 )adapter->stats.mngpdc;
#line 698
  *(regs_buff + 960UL) = (u32 )adapter->stats.mngptc;
#line 699
  *(regs_buff + 961UL) = (u32 )adapter->stats.tor;
#line 700
  *(regs_buff + 963UL) = (u32 )adapter->stats.tpr;
#line 701
  *(regs_buff + 964UL) = (u32 )adapter->stats.tpt;
#line 702
  *(regs_buff + 965UL) = (u32 )adapter->stats.ptc64;
#line 703
  *(regs_buff + 966UL) = (u32 )adapter->stats.ptc127;
#line 704
  *(regs_buff + 967UL) = (u32 )adapter->stats.ptc255;
#line 705
  *(regs_buff + 968UL) = (u32 )adapter->stats.ptc511;
#line 706
  *(regs_buff + 969UL) = (u32 )adapter->stats.ptc1023;
#line 707
  *(regs_buff + 970UL) = (u32 )adapter->stats.ptc1522;
#line 708
  *(regs_buff + 971UL) = (u32 )adapter->stats.mptc;
#line 709
  *(regs_buff + 972UL) = (u32 )adapter->stats.bptc;
#line 710
  *(regs_buff + 973UL) = (u32 )adapter->stats.xec;
#line 711
  i = 0U;
#line 711
  goto ldv_55834;
  ldv_55833: 
#line 712
  *(regs_buff + (unsigned long )((int )i + 974)) = (u32 )adapter->stats.qprc[(int )i];
#line 711
  i = (u8 )((int )i + 1);
  ldv_55834: ;
#line 711
  if ((unsigned int )i <= 15U) {
#line 713
    goto ldv_55833;
  } else {

  }
#line 713
  i = 0U;
#line 713
  goto ldv_55837;
  ldv_55836: 
#line 714
  *(regs_buff + (unsigned long )((int )i + 990)) = (u32 )adapter->stats.qptc[(int )i];
#line 713
  i = (u8 )((int )i + 1);
  ldv_55837: ;
#line 713
  if ((unsigned int )i <= 15U) {
#line 715
    goto ldv_55836;
  } else {

  }
#line 715
  i = 0U;
#line 715
  goto ldv_55840;
  ldv_55839: 
#line 716
  *(regs_buff + (unsigned long )((int )i + 1006)) = (u32 )adapter->stats.qbrc[(int )i];
#line 715
  i = (u8 )((int )i + 1);
  ldv_55840: ;
#line 715
  if ((unsigned int )i <= 15U) {
#line 717
    goto ldv_55839;
  } else {

  }
#line 717
  i = 0U;
#line 717
  goto ldv_55843;
  ldv_55842: 
#line 718
  *(regs_buff + (unsigned long )((int )i + 1022)) = (u32 )adapter->stats.qbtc[(int )i];
#line 717
  i = (u8 )((int )i + 1);
  ldv_55843: ;
#line 717
  if ((unsigned int )i <= 15U) {
#line 719
    goto ldv_55842;
  } else {

  }
#line 721
  *(regs_buff + 1038UL) = ixgbe_read_reg(hw, 16896U);
#line 722
  *(regs_buff + 1039UL) = ixgbe_read_reg(hw, 16904U);
#line 723
  *(regs_buff + 1040UL) = ixgbe_read_reg(hw, 16908U);
#line 724
  *(regs_buff + 1041UL) = ixgbe_read_reg(hw, 16912U);
#line 725
  *(regs_buff + 1042UL) = ixgbe_read_reg(hw, 16916U);
#line 726
  *(regs_buff + 1043UL) = ixgbe_read_reg(hw, 16920U);
#line 727
  *(regs_buff + 1044UL) = ixgbe_read_reg(hw, 16924U);
#line 728
  *(regs_buff + 1045UL) = ixgbe_read_reg(hw, 16928U);
#line 729
  *(regs_buff + 1046UL) = ixgbe_read_reg(hw, 16932U);
#line 730
  *(regs_buff + 1047UL) = ixgbe_read_reg(hw, 16960U);
#line 731
  *(regs_buff + 1048UL) = ixgbe_read_reg(hw, 16964U);
#line 732
  *(regs_buff + 1049UL) = ixgbe_read_reg(hw, 16968U);
#line 733
  *(regs_buff + 1050UL) = ixgbe_read_reg(hw, 16972U);
#line 734
  *(regs_buff + 1051UL) = ixgbe_read_reg(hw, 16976U);
#line 735
  *(regs_buff + 1052UL) = ixgbe_read_reg(hw, 16980U);
#line 736
  *(regs_buff + 1053UL) = ixgbe_read_reg(hw, 16984U);
#line 737
  *(regs_buff + 1054UL) = ixgbe_read_reg(hw, 16988U);
#line 738
  *(regs_buff + 1055UL) = ixgbe_read_reg(hw, 16992U);
#line 739
  *(regs_buff + 1056UL) = ixgbe_read_reg(hw, 16996U);
#line 740
  *(regs_buff + 1057UL) = ixgbe_read_reg(hw, 17000U);
#line 741
  *(regs_buff + 1058UL) = ixgbe_read_reg(hw, 17004U);
#line 742
  *(regs_buff + 1059UL) = ixgbe_read_reg(hw, 17032U);
#line 743
  *(regs_buff + 1060UL) = ixgbe_read_reg(hw, 17036U);
#line 744
  *(regs_buff + 1061UL) = ixgbe_read_reg(hw, 17040U);
#line 745
  *(regs_buff + 1062UL) = ixgbe_read_reg(hw, 17048U);
#line 746
  *(regs_buff + 1063UL) = ixgbe_read_reg(hw, 17052U);
#line 747
  *(regs_buff + 1064UL) = ixgbe_read_reg(hw, 17056U);
#line 748
  *(regs_buff + 1065UL) = ixgbe_read_reg(hw, 17060U);
#line 749
  *(regs_buff + 1066UL) = ixgbe_read_reg(hw, 17064U);
#line 750
  *(regs_buff + 1067UL) = ixgbe_read_reg(hw, 17068U);
#line 751
  *(regs_buff + 1068UL) = ixgbe_read_reg(hw, 17072U);
#line 752
  *(regs_buff + 1069UL) = ixgbe_read_reg(hw, 17076U);
#line 753
  *(regs_buff + 1070UL) = ixgbe_read_reg(hw, 18432U);
#line 756
  *(regs_buff + 1071UL) = ixgbe_read_reg(hw, 11296U);
#line 757
  i = 0U;
#line 757
  goto ldv_55846;
  ldv_55845: 
#line 758
  *(regs_buff + (unsigned long )((int )i + 1072)) = ixgbe_read_reg(hw, (u32 )(((int )i + 2816) * 4));
#line 757
  i = (u8 )((int )i + 1);
  ldv_55846: ;
#line 757
  if ((unsigned int )i <= 7U) {
#line 759
    goto ldv_55845;
  } else {

  }
#line 759
  *(regs_buff + 1080UL) = ixgbe_read_reg(hw, 12040U);
#line 760
  i = 0U;
#line 760
  goto ldv_55849;
  ldv_55848: 
#line 761
  *(regs_buff + (unsigned long )((int )i + 1081)) = ixgbe_read_reg(hw, (u32 )(((int )i + 3012) * 4));
#line 760
  i = (u8 )((int )i + 1);
  ldv_55849: ;
#line 760
  if ((unsigned int )i <= 3U) {
#line 762
    goto ldv_55848;
  } else {

  }
#line 762
  *(regs_buff + 1085UL) = ixgbe_read_reg(hw, 12064U);
#line 763
  *(regs_buff + 1086UL) = ixgbe_read_reg(hw, 31776U);
#line 764
  i = 0U;
#line 764
  goto ldv_55852;
  ldv_55851: 
#line 765
  *(regs_buff + (unsigned long )((int )i + 1087)) = ixgbe_read_reg(hw, (u32 )(((int )i + 7936) * 4));
#line 764
  i = (u8 )((int )i + 1);
  ldv_55852: ;
#line 764
  if ((unsigned int )i <= 7U) {
#line 766
    goto ldv_55851;
  } else {

  }
#line 766
  *(regs_buff + 1095UL) = ixgbe_read_reg(hw, 32520U);
#line 767
  i = 0U;
#line 767
  goto ldv_55855;
  ldv_55854: 
#line 768
  *(regs_buff + (unsigned long )((int )i + 1096)) = ixgbe_read_reg(hw, (u32 )(((int )i + 8132) * 4));
#line 767
  i = (u8 )((int )i + 1);
  ldv_55855: ;
#line 767
  if ((unsigned int )i <= 3U) {
#line 769
    goto ldv_55854;
  } else {

  }
#line 769
  *(regs_buff + 1100UL) = ixgbe_read_reg(hw, 32544U);
#line 770
  *(regs_buff + 1101UL) = ixgbe_read_reg(hw, 50688U);
#line 771
  *(regs_buff + 1102UL) = ixgbe_read_reg(hw, 50704U);
#line 772
  *(regs_buff + 1103UL) = ixgbe_read_reg(hw, 50708U);
#line 773
  *(regs_buff + 1104UL) = ixgbe_read_reg(hw, 50712U);
#line 774
  *(regs_buff + 1105UL) = ixgbe_read_reg(hw, 50716U);
#line 775
  *(regs_buff + 1106UL) = ixgbe_read_reg(hw, 13824U);
#line 776
  *(regs_buff + 1107UL) = ixgbe_read_reg(hw, 13840U);
#line 777
  *(regs_buff + 1108UL) = ixgbe_read_reg(hw, 13844U);
#line 778
  *(regs_buff + 1109UL) = ixgbe_read_reg(hw, 13848U);
#line 779
  *(regs_buff + 1110UL) = ixgbe_read_reg(hw, 13852U);
#line 780
  i = 0U;
#line 780
  goto ldv_55858;
  ldv_55857: 
#line 781
  *(regs_buff + (unsigned long )((int )i + 1111)) = ixgbe_read_reg(hw, (u32 )(((int )i + 17444) * 4));
#line 780
  i = (u8 )((int )i + 1);
  ldv_55858: ;
#line 780
  if ((unsigned int )i <= 7U) {
#line 782
    goto ldv_55857;
  } else {

  }
#line 782
  *(regs_buff + 1119UL) = ixgbe_read_reg(hw, 20644U);
#line 783
  *(regs_buff + 1120UL) = ixgbe_read_reg(hw, 17080U);
#line 784
  *(regs_buff + 1121UL) = ixgbe_read_reg(hw, 17088U);
#line 785
  *(regs_buff + 1122UL) = ixgbe_read_reg(hw, 17092U);
#line 786
  *(regs_buff + 1123UL) = ixgbe_read_reg(hw, 17096U);
#line 787
  *(regs_buff + 1124UL) = ixgbe_read_reg(hw, 17100U);
#line 788
  *(regs_buff + 1125UL) = ixgbe_read_reg(hw, 69740U);
#line 789
  *(regs_buff + 1126UL) = ixgbe_read_reg(hw, 49920U);
#line 790
  *(regs_buff + 1127UL) = ixgbe_read_reg(hw, 13056U);
#line 793
  *(regs_buff + 1128UL) = ixgbe_read_reg(hw, 17044U);
#line 796
  *(regs_buff + 1129UL) = ixgbe_read_reg(hw, 12320U);
#line 797
  *(regs_buff + 1130UL) = ixgbe_read_reg(hw, 51200U);
#line 798
  i = 0U;
#line 798
  goto ldv_55861;
  ldv_55860: 
#line 799
  *(regs_buff + (unsigned long )((int )i + 1131)) = ixgbe_read_reg(hw, (u32 )(((int )i + 8376) * 4));
#line 798
  i = (u8 )((int )i + 1);
  ldv_55861: ;
#line 798
  if ((unsigned int )i <= 3U) {
#line 800
    goto ldv_55860;
  } else {

  }
#line 800
  *(regs_buff + 1135UL) = ixgbe_read_reg(hw, 18816U);
#line 802
  *(regs_buff + 1136UL) = ixgbe_read_reg(hw, 18828U);
#line 806
  *(regs_buff + 1137UL) = ixgbe_read_reg(hw, 35584U);
#line 807
  *(regs_buff + 1138UL) = ixgbe_read_reg(hw, 19088U);
#line 808
  return;
}
}
#line 810 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_eeprom_len(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 812
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 812
  adapter = (struct ixgbe_adapter *)tmp;
#line 813
  return ((int )adapter->hw.eeprom.word_size * 2);
}
}
#line 816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_eeprom(struct net_device *netdev , struct ethtool_eeprom *eeprom ,
                            u8 *bytes ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u16 *eeprom_buff ;
  int first_word ;
  int last_word ;
  int eeprom_len ;
  int ret_val ;
  u16 i ;
  void *tmp___0 ;

  {
#line 819
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 819
  adapter = (struct ixgbe_adapter *)tmp;
#line 820
  hw = & adapter->hw;
#line 823
  ret_val = 0;
#line 826
  if (eeprom->len == 0U) {
#line 827
    return (-22);
  } else {

  }
#line 829
  eeprom->magic = (__u32 )((int )hw->vendor_id | ((int )hw->device_id << 16));
#line 831
  first_word = (int )(eeprom->offset >> 1);
#line 832
  last_word = (int )(((eeprom->offset + eeprom->len) - 1U) >> 1);
#line 833
  eeprom_len = (last_word - first_word) + 1;
#line 835
  tmp___0 = kmalloc((unsigned long )eeprom_len * 2UL, 208U);
#line 835
  eeprom_buff = (u16 *)tmp___0;
#line 836
  if ((unsigned long )eeprom_buff == (unsigned long )((u16 *)0U)) {
#line 837
    return (-12);
  } else {

  }
#line 839
  ret_val = (*(hw->eeprom.ops.read_buffer))(hw, (int )((u16 )first_word), (int )((u16 )eeprom_len),
                                            eeprom_buff);
#line 843
  i = 0U;
#line 843
  goto ldv_55881;
  ldv_55880: 
#line 843
  i = (u16 )((int )i + 1);
  ldv_55881: ;
#line 843
  if ((int )i < eeprom_len) {
#line 845
    goto ldv_55880;
  } else {

  }
#line 846
  memcpy((void *)bytes, (void const   *)eeprom_buff + ((unsigned long )eeprom->offset & 1UL),
           (size_t )eeprom->len);
#line 847
  kfree((void const   *)eeprom_buff);
#line 849
  return (ret_val);
}
}
#line 852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_eeprom(struct net_device *netdev , struct ethtool_eeprom *eeprom ,
                            u8 *bytes ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u16 *eeprom_buff ;
  void *ptr ;
  int max_len ;
  int first_word ;
  int last_word ;
  int ret_val ;
  u16 i ;
  void *tmp___0 ;

  {
#line 855
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 855
  adapter = (struct ixgbe_adapter *)tmp;
#line 856
  hw = & adapter->hw;
#line 859
  ret_val = 0;
#line 862
  if (eeprom->len == 0U) {
#line 863
    return (-22);
  } else {

  }
#line 865
  if (eeprom->magic != (__u32 )((int )hw->vendor_id | ((int )hw->device_id << 16))) {
#line 866
    return (-22);
  } else {

  }
#line 868
  max_len = (int )hw->eeprom.word_size * 2;
#line 870
  first_word = (int )(eeprom->offset >> 1);
#line 871
  last_word = (int )(((eeprom->offset + eeprom->len) - 1U) >> 1);
#line 872
  tmp___0 = kmalloc((size_t )max_len, 208U);
#line 872
  eeprom_buff = (u16 *)tmp___0;
#line 873
  if ((unsigned long )eeprom_buff == (unsigned long )((u16 *)0U)) {
#line 874
    return (-12);
  } else {

  }
#line 876
  ptr = (void *)eeprom_buff;
#line 878
  if ((int )eeprom->offset & 1) {
#line 883
    ret_val = (*(hw->eeprom.ops.read))(hw, (int )((u16 )first_word), eeprom_buff);
#line 884
    if (ret_val != 0) {
#line 885
      goto err;
    } else {

    }
#line 887
    ptr = ptr + 1;
  } else {

  }
#line 889
  if ((int )(eeprom->offset + eeprom->len) & 1) {
#line 894
    ret_val = (*(hw->eeprom.ops.read))(hw, (int )((u16 )last_word), eeprom_buff + (unsigned long )(last_word - first_word));
#line 896
    if (ret_val != 0) {
#line 897
      goto err;
    } else {

    }
  } else {

  }
#line 901
  i = 0U;
#line 901
  goto ldv_55899;
  ldv_55898: 
#line 901
  i = (u16 )((int )i + 1);
  ldv_55899: ;
#line 901
  if ((int )i < (last_word - first_word) + 1) {
#line 903
    goto ldv_55898;
  } else {

  }
#line 904
  memcpy(ptr, (void const   *)bytes, (size_t )eeprom->len);
#line 906
  i = 0U;
#line 906
  goto ldv_55902;
  ldv_55901: 
#line 906
  i = (u16 )((int )i + 1);
  ldv_55902: ;
#line 906
  if ((int )i < (last_word - first_word) + 1) {
#line 908
    goto ldv_55901;
  } else {

  }
#line 909
  ret_val = (*(hw->eeprom.ops.write_buffer))(hw, (int )((u16 )first_word), (int )((unsigned int )((int )((u16 )last_word) - (int )((u16 )first_word)) + 1U),
                                             eeprom_buff);
#line 914
  if (ret_val == 0) {
#line 915
    (*(hw->eeprom.ops.update_checksum))(hw);
  } else {

  }
  err: 
#line 918
  kfree((void const   *)eeprom_buff);
#line 919
  return (ret_val);
}
}
#line 922 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_drvinfo(struct net_device *netdev , struct ethtool_drvinfo *drvinfo ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  u32 nvm_track_id ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 925
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 925
  adapter = (struct ixgbe_adapter *)tmp;
#line 928
  strlcpy((char *)(& drvinfo->driver), (char const   *)(& ixgbe_driver_name), 32UL);
#line 929
  strlcpy((char *)(& drvinfo->version), (char const   *)(& ixgbe_driver_version),
          32UL);
#line 932
  nvm_track_id = (u32 )(((int )adapter->eeprom_verh << 16) | (int )adapter->eeprom_verl);
#line 934
  snprintf((char *)(& drvinfo->fw_version), 32UL, "0x%08x", nvm_track_id);
#line 937
  tmp___0 = pci_name((struct pci_dev  const  *)adapter->pdev);
#line 937
  strlcpy((char *)(& drvinfo->bus_info), tmp___0, 32UL);
#line 939
  drvinfo->n_stats = netdev->num_tx_queues * 10U + 89U;
#line 940
  drvinfo->testinfo_len = 5U;
#line 941
  tmp___1 = ixgbe_get_regs_len(netdev);
#line 941
  drvinfo->regdump_len = (__u32 )tmp___1;
#line 942
  return;
}
}
#line 944 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_ringparam(struct net_device *netdev , struct ethtool_ringparam *ring ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_ring *tx_ring ;
  struct ixgbe_ring *rx_ring ;

  {
#line 947
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 947
  adapter = (struct ixgbe_adapter *)tmp;
#line 948
  tx_ring = adapter->tx_ring[0];
#line 949
  rx_ring = adapter->rx_ring[0];
#line 951
  ring->rx_max_pending = 4096U;
#line 952
  ring->tx_max_pending = 4096U;
#line 953
  ring->rx_pending = (__u32 )rx_ring->count;
#line 954
  ring->tx_pending = (__u32 )tx_ring->count;
#line 955
  return;
}
}
#line 957 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_ringparam(struct net_device *netdev , struct ethtool_ringparam *ring ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_ring *temp_ring ;
  int i ;
  int err ;
  u32 new_rx_count ;
  u32 new_tx_count ;
  u32 __min1 ;
  u32 __max1 ;
  u32 __max2 ;
  u32 __min2 ;
  u32 __min1___0 ;
  u32 __max1___0 ;
  u32 __max2___0 ;
  u32 __min2___0 ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int __max1___1 ;
  int __max2___1 ;
  void *tmp___3 ;

  {
#line 960
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 960
  adapter = (struct ixgbe_adapter *)tmp;
#line 962
  err = 0;
#line 965
  if (ring->rx_mini_pending != 0U || ring->rx_jumbo_pending != 0U) {
#line 966
    return (-22);
  } else {

  }
#line 968
  __max1 = ring->tx_pending;
#line 968
  __max2 = 64U;
#line 968
  __min1 = __max1 > __max2 ? __max1 : __max2;
#line 968
  __min2 = 4096U;
#line 968
  new_tx_count = __min1 < __min2 ? __min1 : __min2;
#line 970
  new_tx_count = (new_tx_count + 7U) & 4294967288U;
#line 972
  __max1___0 = ring->rx_pending;
#line 972
  __max2___0 = 64U;
#line 972
  __min1___0 = __max1___0 > __max2___0 ? __max1___0 : __max2___0;
#line 972
  __min2___0 = 4096U;
#line 972
  new_rx_count = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
#line 974
  new_rx_count = (new_rx_count + 7U) & 4294967288U;
#line 976
  if (adapter->tx_ring_count == new_tx_count && adapter->rx_ring_count == new_rx_count) {
#line 979
    return (0);
  } else {

  }
#line 982
  goto ldv_55942;
  ldv_55941: 
#line 983
  usleep_range(1000UL, 2000UL);
  ldv_55942: 
#line 982
  tmp___0 = test_and_set_bit(1L, (unsigned long volatile   *)(& adapter->state));
#line 982
  if (tmp___0 != 0) {
#line 984
    goto ldv_55941;
  } else {

  }
#line 985
  tmp___1 = netif_running((struct net_device  const  *)adapter->netdev);
#line 985
  if (tmp___1) {
#line 985
    tmp___2 = 0;
  } else {
#line 985
    tmp___2 = 1;
  }
#line 985
  if (tmp___2) {
#line 986
    i = 0;
#line 986
    goto ldv_55945;
    ldv_55944: 
#line 987
    (adapter->tx_ring[i])->count = (u16 )new_tx_count;
#line 986
    i = i + 1;
    ldv_55945: ;
#line 986
    if (adapter->num_tx_queues > i) {
#line 988
      goto ldv_55944;
    } else {

    }
#line 988
    i = 0;
#line 988
    goto ldv_55948;
    ldv_55947: 
#line 989
    (adapter->rx_ring[i])->count = (u16 )new_rx_count;
#line 988
    i = i + 1;
    ldv_55948: ;
#line 988
    if (adapter->num_rx_queues > i) {
#line 990
      goto ldv_55947;
    } else {

    }
#line 990
    adapter->tx_ring_count = new_tx_count;
#line 991
    adapter->rx_ring_count = new_rx_count;
#line 992
    goto clear_reset;
  } else {

  }
#line 996
  __max1___1 = adapter->num_tx_queues;
#line 996
  __max2___1 = adapter->num_rx_queues;
#line 996
  i = __max1___1 > __max2___1 ? __max1___1 : __max2___1;
#line 997
  tmp___3 = vmalloc((unsigned long )i * 4096UL);
#line 997
  temp_ring = (struct ixgbe_ring *)tmp___3;
#line 999
  if ((unsigned long )temp_ring == (unsigned long )((struct ixgbe_ring *)0)) {
#line 1000
    err = -12;
#line 1001
    goto clear_reset;
  } else {

  }
#line 1004
  ixgbe_down(adapter);
#line 1012
  if (adapter->tx_ring_count != new_tx_count) {
#line 1013
    i = 0;
#line 1013
    goto ldv_55959;
    ldv_55958: 
#line 1014
    memcpy((void *)temp_ring + (unsigned long )i, (void const   *)adapter->tx_ring[i],
             4096UL);
#line 1017
    (temp_ring + (unsigned long )i)->count = (u16 )new_tx_count;
#line 1018
    err = ixgbe_setup_tx_resources(temp_ring + (unsigned long )i);
#line 1019
    if (err != 0) {
#line 1020
      goto ldv_55955;
      ldv_55954: 
#line 1021
      i = i - 1;
#line 1022
      ixgbe_free_tx_resources(temp_ring + (unsigned long )i);
      ldv_55955: ;
#line 1020
      if (i != 0) {
#line 1022
        goto ldv_55954;
      } else {

      }

#line 1024
      goto err_setup;
    } else {

    }
#line 1013
    i = i + 1;
    ldv_55959: ;
#line 1013
    if (adapter->num_tx_queues > i) {
#line 1015
      goto ldv_55958;
    } else {

    }
#line 1028
    i = 0;
#line 1028
    goto ldv_55962;
    ldv_55961: 
#line 1029
    ixgbe_free_tx_resources(adapter->tx_ring[i]);
#line 1031
    memcpy((void *)adapter->tx_ring[i], (void const   *)temp_ring + (unsigned long )i,
             4096UL);
#line 1028
    i = i + 1;
    ldv_55962: ;
#line 1028
    if (adapter->num_tx_queues > i) {
#line 1030
      goto ldv_55961;
    } else {

    }
#line 1035
    adapter->tx_ring_count = new_tx_count;
  } else {

  }
#line 1039
  if (adapter->rx_ring_count != new_rx_count) {
#line 1040
    i = 0;
#line 1040
    goto ldv_55968;
    ldv_55967: 
#line 1041
    memcpy((void *)temp_ring + (unsigned long )i, (void const   *)adapter->rx_ring[i],
             4096UL);
#line 1044
    (temp_ring + (unsigned long )i)->count = (u16 )new_rx_count;
#line 1045
    err = ixgbe_setup_rx_resources(temp_ring + (unsigned long )i);
#line 1046
    if (err != 0) {
#line 1047
      goto ldv_55965;
      ldv_55964: 
#line 1048
      i = i - 1;
#line 1049
      ixgbe_free_rx_resources(temp_ring + (unsigned long )i);
      ldv_55965: ;
#line 1047
      if (i != 0) {
#line 1049
        goto ldv_55964;
      } else {

      }

#line 1051
      goto err_setup;
    } else {

    }
#line 1040
    i = i + 1;
    ldv_55968: ;
#line 1040
    if (adapter->num_rx_queues > i) {
#line 1042
      goto ldv_55967;
    } else {

    }
#line 1056
    i = 0;
#line 1056
    goto ldv_55971;
    ldv_55970: 
#line 1057
    ixgbe_free_rx_resources(adapter->rx_ring[i]);
#line 1059
    memcpy((void *)adapter->rx_ring[i], (void const   *)temp_ring + (unsigned long )i,
             4096UL);
#line 1056
    i = i + 1;
    ldv_55971: ;
#line 1056
    if (adapter->num_rx_queues > i) {
#line 1058
      goto ldv_55970;
    } else {

    }
#line 1063
    adapter->rx_ring_count = new_rx_count;
  } else {

  }
  err_setup: 
#line 1067
  ixgbe_up(adapter);
#line 1068
  vfree((void const   *)temp_ring);
  clear_reset: 
#line 1070
  clear_bit(1L, (unsigned long volatile   *)(& adapter->state));
#line 1071
  return (err);
}
}
#line 1074 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_sset_count(struct net_device *netdev , int sset ) 
{ 


  {
#line 1076
  switch (sset) {
  case 0: ;
#line 1078
  return (5);
  case 1: ;
#line 1080
  return ((int )(netdev->num_tx_queues * 10U + 89U));
  default: ;
#line 1082
  return (-95);
  }
}
}
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_ethtool_stats(struct net_device *netdev , struct ethtool_stats *stats ,
                                    u64 *data ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct rtnl_link_stats64 temp ;
  struct rtnl_link_stats64  const  *net_stats ;
  unsigned int start ;
  struct ixgbe_ring *ring ;
  int i ;
  int j ;
  char *p ;
  struct rtnl_link_stats64 *tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1089
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1089
  adapter = (struct ixgbe_adapter *)tmp;
#line 1095
  p = (char *)0;
#line 1097
  ixgbe_update_stats(adapter);
#line 1098
  tmp___0 = dev_get_stats(netdev, & temp);
#line 1098
  net_stats = (struct rtnl_link_stats64  const  *)tmp___0;
#line 1099
  i = 0;
#line 1099
  goto ldv_56003;
  ldv_56002: ;
#line 1100
  switch (ixgbe_gstrings_stats[i].type) {
  case 0: 
#line 1102
  p = (char *)net_stats + (unsigned long )ixgbe_gstrings_stats[i].stat_offset;
#line 1104
  goto ldv_55998;
  case 1: 
#line 1106
  p = (char *)adapter + (unsigned long )ixgbe_gstrings_stats[i].stat_offset;
#line 1108
  goto ldv_55998;
  default: 
#line 1110
  *(data + (unsigned long )i) = 0ULL;
#line 1111
  goto ldv_56001;
  }
  ldv_55998: 
#line 1114
  *(data + (unsigned long )i) = ixgbe_gstrings_stats[i].sizeof_stat == 8 ? *((u64 *)p) : (u64 )*((u32 *)p);
  ldv_56001: 
#line 1099
  i = i + 1;
  ldv_56003: ;
#line 1099
  if ((unsigned int )i <= 56U) {
#line 1101
    goto ldv_56002;
  } else {

  }
#line 1117
  j = 0;
#line 1117
  goto ldv_56009;
  ldv_56008: 
#line 1118
  ring = adapter->tx_ring[j];
#line 1119
  if ((unsigned long )ring == (unsigned long )((struct ixgbe_ring *)0)) {
#line 1120
    *(data + (unsigned long )i) = 0ULL;
#line 1121
    *(data + ((unsigned long )i + 1UL)) = 0ULL;
#line 1122
    i = i + 2;
#line 1124
    *(data + (unsigned long )i) = 0ULL;
#line 1125
    *(data + ((unsigned long )i + 1UL)) = 0ULL;
#line 1126
    *(data + ((unsigned long )i + 2UL)) = 0ULL;
#line 1127
    i = i + 3;
#line 1129
    goto ldv_56005;
  } else {

  }
  ldv_56006: 
#line 1133
  start = u64_stats_fetch_begin_irq((struct u64_stats_sync  const  *)(& ring->syncp));
#line 1134
  *(data + (unsigned long )i) = ring->stats.packets;
#line 1135
  *(data + ((unsigned long )i + 1UL)) = ring->stats.bytes;
#line 1136
  tmp___1 = u64_stats_fetch_retry_irq((struct u64_stats_sync  const  *)(& ring->syncp),
                                      start);
#line 1136
  if ((int )tmp___1) {
#line 1138
    goto ldv_56006;
  } else {

  }
#line 1137
  i = i + 2;
#line 1139
  *(data + (unsigned long )i) = ring->stats.yields;
#line 1140
  *(data + ((unsigned long )i + 1UL)) = ring->stats.misses;
#line 1141
  *(data + ((unsigned long )i + 2UL)) = ring->stats.cleaned;
#line 1142
  i = i + 3;
  ldv_56005: 
#line 1117
  j = j + 1;
  ldv_56009: ;
#line 1117
  if ((unsigned int )j < netdev->num_tx_queues) {
#line 1119
    goto ldv_56008;
  } else {

  }
#line 1145
  j = 0;
#line 1145
  goto ldv_56015;
  ldv_56014: 
#line 1146
  ring = adapter->rx_ring[j];
#line 1147
  if ((unsigned long )ring == (unsigned long )((struct ixgbe_ring *)0)) {
#line 1148
    *(data + (unsigned long )i) = 0ULL;
#line 1149
    *(data + ((unsigned long )i + 1UL)) = 0ULL;
#line 1150
    i = i + 2;
#line 1152
    *(data + (unsigned long )i) = 0ULL;
#line 1153
    *(data + ((unsigned long )i + 1UL)) = 0ULL;
#line 1154
    *(data + ((unsigned long )i + 2UL)) = 0ULL;
#line 1155
    i = i + 3;
#line 1157
    goto ldv_56011;
  } else {

  }
  ldv_56012: 
#line 1161
  start = u64_stats_fetch_begin_irq((struct u64_stats_sync  const  *)(& ring->syncp));
#line 1162
  *(data + (unsigned long )i) = ring->stats.packets;
#line 1163
  *(data + ((unsigned long )i + 1UL)) = ring->stats.bytes;
#line 1164
  tmp___2 = u64_stats_fetch_retry_irq((struct u64_stats_sync  const  *)(& ring->syncp),
                                      start);
#line 1164
  if ((int )tmp___2) {
#line 1166
    goto ldv_56012;
  } else {

  }
#line 1165
  i = i + 2;
#line 1167
  *(data + (unsigned long )i) = ring->stats.yields;
#line 1168
  *(data + ((unsigned long )i + 1UL)) = ring->stats.misses;
#line 1169
  *(data + ((unsigned long )i + 2UL)) = ring->stats.cleaned;
#line 1170
  i = i + 3;
  ldv_56011: 
#line 1145
  j = j + 1;
  ldv_56015: ;
#line 1145
  if ((unsigned int )j < netdev->num_tx_queues) {
#line 1147
    goto ldv_56014;
  } else {

  }
#line 1174
  j = 0;
#line 1174
  goto ldv_56018;
  ldv_56017: 
#line 1175
  tmp___3 = i;
#line 1175
  i = i + 1;
#line 1175
  *(data + (unsigned long )tmp___3) = adapter->stats.pxontxc[j];
#line 1176
  tmp___4 = i;
#line 1176
  i = i + 1;
#line 1176
  *(data + (unsigned long )tmp___4) = adapter->stats.pxofftxc[j];
#line 1174
  j = j + 1;
  ldv_56018: ;
#line 1174
  if (j <= 7) {
#line 1176
    goto ldv_56017;
  } else {

  }
#line 1178
  j = 0;
#line 1178
  goto ldv_56021;
  ldv_56020: 
#line 1179
  tmp___5 = i;
#line 1179
  i = i + 1;
#line 1179
  *(data + (unsigned long )tmp___5) = adapter->stats.pxonrxc[j];
#line 1180
  tmp___6 = i;
#line 1180
  i = i + 1;
#line 1180
  *(data + (unsigned long )tmp___6) = adapter->stats.pxoffrxc[j];
#line 1178
  j = j + 1;
  ldv_56021: ;
#line 1178
  if (j <= 7) {
#line 1180
    goto ldv_56020;
  } else {

  }

#line 1185
  return;
}
}
#line 1184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_strings(struct net_device *netdev , u32 stringset , u8 *data ) 
{ 
  char *p ;
  int i ;

  {
#line 1187
  p = (char *)data;
#line 1190
  switch (stringset) {
  case 0U: 
#line 1192
  i = 0;
#line 1192
  goto ldv_56032;
  ldv_56031: 
#line 1193
  memcpy((void *)data, (void const   *)(& ixgbe_gstrings_test) + (unsigned long )i,
           32UL);
#line 1194
  data = data + 32UL;
#line 1192
  i = i + 1;
  ldv_56032: ;
#line 1192
  if ((unsigned int )i <= 4U) {
#line 1194
    goto ldv_56031;
  } else {

  }

#line 1196
  goto ldv_56034;
  case 1U: 
#line 1198
  i = 0;
#line 1198
  goto ldv_56039;
  ldv_56038: 
#line 1199
  memcpy((void *)p, (void const   *)(& ixgbe_gstrings_stats[i].stat_string), 32UL);
#line 1201
  p = p + 32UL;
#line 1198
  i = i + 1;
  ldv_56039: ;
#line 1198
  if ((unsigned int )i <= 56U) {
#line 1200
    goto ldv_56038;
  } else {

  }
#line 1203
  i = 0;
#line 1203
  goto ldv_56042;
  ldv_56041: 
#line 1204
  sprintf(p, "tx_queue_%u_packets", i);
#line 1205
  p = p + 32UL;
#line 1206
  sprintf(p, "tx_queue_%u_bytes", i);
#line 1207
  p = p + 32UL;
#line 1209
  sprintf(p, "tx_queue_%u_bp_napi_yield", i);
#line 1210
  p = p + 32UL;
#line 1211
  sprintf(p, "tx_queue_%u_bp_misses", i);
#line 1212
  p = p + 32UL;
#line 1213
  sprintf(p, "tx_queue_%u_bp_cleaned", i);
#line 1214
  p = p + 32UL;
#line 1203
  i = i + 1;
  ldv_56042: ;
#line 1203
  if ((unsigned int )i < netdev->num_tx_queues) {
#line 1205
    goto ldv_56041;
  } else {

  }
#line 1217
  i = 0;
#line 1217
  goto ldv_56045;
  ldv_56044: 
#line 1218
  sprintf(p, "rx_queue_%u_packets", i);
#line 1219
  p = p + 32UL;
#line 1220
  sprintf(p, "rx_queue_%u_bytes", i);
#line 1221
  p = p + 32UL;
#line 1223
  sprintf(p, "rx_queue_%u_bp_poll_yield", i);
#line 1224
  p = p + 32UL;
#line 1225
  sprintf(p, "rx_queue_%u_bp_misses", i);
#line 1226
  p = p + 32UL;
#line 1227
  sprintf(p, "rx_queue_%u_bp_cleaned", i);
#line 1228
  p = p + 32UL;
#line 1217
  i = i + 1;
  ldv_56045: ;
#line 1217
  if ((unsigned int )i < netdev->num_tx_queues) {
#line 1219
    goto ldv_56044;
  } else {

  }
#line 1231
  i = 0;
#line 1231
  goto ldv_56048;
  ldv_56047: 
#line 1232
  sprintf(p, "tx_pb_%u_pxon", i);
#line 1233
  p = p + 32UL;
#line 1234
  sprintf(p, "tx_pb_%u_pxoff", i);
#line 1235
  p = p + 32UL;
#line 1231
  i = i + 1;
  ldv_56048: ;
#line 1231
  if (i <= 7) {
#line 1233
    goto ldv_56047;
  } else {

  }
#line 1237
  i = 0;
#line 1237
  goto ldv_56051;
  ldv_56050: 
#line 1238
  sprintf(p, "rx_pb_%u_pxon", i);
#line 1239
  p = p + 32UL;
#line 1240
  sprintf(p, "rx_pb_%u_pxoff", i);
#line 1241
  p = p + 32UL;
#line 1237
  i = i + 1;
  ldv_56051: ;
#line 1237
  if (i <= 7) {
#line 1239
    goto ldv_56050;
  } else {

  }

#line 1244
  goto ldv_56034;
  }
  ldv_56034: ;
#line 1247
  return;
}
}
#line 1248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_link_test(struct ixgbe_adapter *adapter , u64 *data ) 
{ 
  struct ixgbe_hw *hw ;
  bool link_up ;
  u32 link_speed ;
  bool tmp ;

  {
#line 1250
  hw = & adapter->hw;
#line 1252
  link_speed = 0U;
#line 1254
  tmp = ixgbe_removed((void *)hw->hw_addr);
#line 1254
  if ((int )tmp) {
#line 1255
    *data = 1ULL;
#line 1256
    return (1);
  } else {

  }
#line 1258
  *data = 0ULL;
#line 1260
  (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 1);
#line 1261
  if ((int )link_up) {
#line 1262
    return ((int )*data);
  } else {
#line 1264
    *data = 1ULL;
  }
#line 1265
  return ((int )*data);
}
}
#line 1295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static struct ixgbe_reg_test  const  reg_test_82599[20U]  = 
#line 1295
  {      {12832U, 1U, 1U, 2148007920U, 2148007920U}, 
        {12896U, 1U, 1U, 2148007920U, 2148007920U}, 
        {12296U, 1U, 1U, 4294967295U, 4294967295U}, 
        {20616U, 1U, 1U, 0U, 0U}, 
        {4096U, 4U, 1U, 4294967168U, 4294967168U}, 
        {4100U, 4U, 1U, 4294967295U, 4294967295U}, 
        {4104U, 4U, 1U, 1048448U, 1048575U}, 
        {4136U, 4U, 3U, 0U, 33554432U}, 
        {4120U, 4U, 1U, 65535U, 65535U}, 
        {4136U, 4U, 3U, 0U, 0U}, 
        {12896U, 1U, 1U, 2148007920U, 2148007920U}, 
        {12800U, 1U, 1U, 4294967295U, 4294967295U}, 
        {24576U, 4U, 1U, 4294967168U, 4294967295U}, 
        {24580U, 4U, 1U, 4294967295U, 4294967295U}, 
        {24584U, 4U, 1U, 1048448U, 1048448U}, 
        {12288U, 1U, 2U, 1U, 1U}, 
        {21504U, 16U, 5U, 4294967295U, 4294967295U}, 
        {21504U, 16U, 6U, 2147614719U, 2148335615U}, 
        {20992U, 128U, 4U, 4294967295U, 4294967295U}, 
        {0U, (unsigned char)0, (unsigned char)0, 0U, 0U}};
#line 1319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static struct ixgbe_reg_test  const  reg_test_82598[22U]  = 
#line 1319
  {      {12832U, 1U, 1U, 2148007920U, 2148007920U}, 
        {12896U, 1U, 1U, 2148007920U, 2148007920U}, 
        {12296U, 1U, 1U, 4294967295U, 4294967295U}, 
        {20616U, 1U, 1U, 0U, 0U}, 
        {4096U, 4U, 1U, 4294967168U, 4294967295U}, 
        {4100U, 4U, 1U, 4294967295U, 4294967295U}, 
        {4104U, 4U, 1U, 1048448U, 1048575U}, 
        {4136U, 4U, 3U, 0U, 33554432U}, 
        {4120U, 4U, 1U, 65535U, 65535U}, 
        {4136U, 4U, 3U, 0U, 0U}, 
        {12896U, 1U, 1U, 2148007920U, 2148007920U}, 
        {12800U, 1U, 1U, 4294967295U, 4294967295U}, 
        {51968U, 1U, 1U, 255U, 255U}, 
        {24576U, 4U, 1U, 4294967168U, 4294967295U}, 
        {24580U, 4U, 1U, 4294967295U, 4294967295U}, 
        {24584U, 4U, 1U, 1048448U, 1048575U}, 
        {12288U, 1U, 2U, 3U, 3U}, 
        {32256U, 1U, 2U, 5U, 5U}, 
        {21504U, 16U, 5U, 4294967295U, 4294967295U}, 
        {21504U, 16U, 6U, 2148335615U, 2148335615U}, 
        {20992U, 128U, 4U, 4294967295U, 4294967295U}, 
        {0U, (unsigned char)0, (unsigned char)0, 0U, 0U}};
#line 1346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static bool reg_pattern_test(struct ixgbe_adapter *adapter , u64 *data , int reg ,
                             u32 mask , u32 write ) 
{ 
  u32 pat ;
  u32 val ;
  u32 before ;
  u32 test_pattern[4U] ;
  bool tmp ;

  {
#line 1350
  test_pattern[0] = 1515870810U;
#line 1350
  test_pattern[1] = 2779096485U;
#line 1350
  test_pattern[2] = 0U;
#line 1350
  test_pattern[3] = 4294967295U;
#line 1353
  tmp = ixgbe_removed((void *)adapter->hw.hw_addr);
#line 1353
  if ((int )tmp) {
#line 1354
    *data = 1ULL;
#line 1355
    return (1);
  } else {

  }
#line 1357
  pat = 0U;
#line 1357
  goto ldv_56082;
  ldv_56081: 
#line 1358
  before = ixgbe_read_reg(& adapter->hw, (u32 )reg);
#line 1359
  ixgbe_write_reg(& adapter->hw, (u32 )reg, test_pattern[pat] & write);
#line 1360
  val = ixgbe_read_reg(& adapter->hw, (u32 )reg);
#line 1361
  if (((test_pattern[pat] & write) & mask) != val) {
#line 1362
    if ((int )adapter->msg_enable & 1) {
#line 1363
      netdev_err((struct net_device  const  *)adapter->netdev, "pattern test reg %04X failed: got 0x%08X expected 0x%08X\n",
                 reg, val, (test_pattern[pat] & write) & mask);
    } else {

    }
#line 1364
    *data = (u64 )reg;
#line 1365
    ixgbe_write_reg(& adapter->hw, (u32 )reg, before);
#line 1366
    return (1);
  } else {

  }
#line 1368
  ixgbe_write_reg(& adapter->hw, (u32 )reg, before);
#line 1357
  pat = pat + 1U;
  ldv_56082: ;
#line 1357
  if (pat <= 3U) {
#line 1359
    goto ldv_56081;
  } else {

  }

#line 1370
  return (0);
}
}
#line 1373 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static bool reg_set_and_check(struct ixgbe_adapter *adapter , u64 *data , int reg ,
                              u32 mask , u32 write ) 
{ 
  u32 val ;
  u32 before ;
  bool tmp ;

  {
#line 1378
  tmp = ixgbe_removed((void *)adapter->hw.hw_addr);
#line 1378
  if ((int )tmp) {
#line 1379
    *data = 1ULL;
#line 1380
    return (1);
  } else {

  }
#line 1382
  before = ixgbe_read_reg(& adapter->hw, (u32 )reg);
#line 1383
  ixgbe_write_reg(& adapter->hw, (u32 )reg, write & mask);
#line 1384
  val = ixgbe_read_reg(& adapter->hw, (u32 )reg);
#line 1385
  if (((write ^ val) & mask) != 0U) {
#line 1386
    if ((int )adapter->msg_enable & 1) {
#line 1387
      netdev_err((struct net_device  const  *)adapter->netdev, "set/check reg %04X test failed: got 0x%08X expected 0x%08X\n",
                 reg, val & mask, write & mask);
    } else {

    }
#line 1388
    *data = (u64 )reg;
#line 1389
    ixgbe_write_reg(& adapter->hw, (u32 )reg, before);
#line 1390
    return (1);
  } else {

  }
#line 1392
  ixgbe_write_reg(& adapter->hw, (u32 )reg, before);
#line 1393
  return (0);
}
}
#line 1396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_reg_test(struct ixgbe_adapter *adapter , u64 *data ) 
{ 
  struct ixgbe_reg_test  const  *test ;
  u32 value ;
  u32 before ;
  u32 after ;
  u32 i ;
  u32 toggle ;
  bool tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  bool b ;

  {
#line 1402
  tmp = ixgbe_removed((void *)adapter->hw.hw_addr);
#line 1402
  if ((int )tmp) {
#line 1403
    if ((int )adapter->msg_enable & 1) {
#line 1403
      netdev_err((struct net_device  const  *)adapter->netdev, "Adapter removed - register test blocked\n");
    } else {

    }
#line 1404
    *data = 1ULL;
#line 1405
    return (1);
  } else {

  }
#line 1407
  switch ((unsigned int )adapter->hw.mac.type) {
  case 1U: 
#line 1409
  toggle = 2147480575U;
#line 1410
  test = (struct ixgbe_reg_test  const  *)(& reg_test_82598);
#line 1411
  goto ldv_56104;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 1416
  toggle = 2147480335U;
#line 1417
  test = (struct ixgbe_reg_test  const  *)(& reg_test_82599);
#line 1418
  goto ldv_56104;
  default: 
#line 1420
  *data = 1ULL;
#line 1421
  return (1);
  }
  ldv_56104: 
#line 1430
  before = ixgbe_read_reg(& adapter->hw, 8U);
#line 1431
  tmp___0 = ixgbe_read_reg(& adapter->hw, 8U);
#line 1431
  value = tmp___0 & toggle;
#line 1432
  ixgbe_write_reg(& adapter->hw, 8U, toggle);
#line 1433
  tmp___1 = ixgbe_read_reg(& adapter->hw, 8U);
#line 1433
  after = tmp___1 & toggle;
#line 1434
  if (value != after) {
#line 1435
    if ((int )adapter->msg_enable & 1) {
#line 1436
      netdev_err((struct net_device  const  *)adapter->netdev, "failed STATUS register test got: 0x%08X expected: 0x%08X\n",
                 after, value);
    } else {

    }
#line 1437
    *data = 1ULL;
#line 1438
    return (1);
  } else {

  }
#line 1441
  ixgbe_write_reg(& adapter->hw, 8U, before);
#line 1447
  goto ldv_56122;
  ldv_56121: 
#line 1448
  i = 0U;
#line 1448
  goto ldv_56119;
  ldv_56118: 
#line 1449
  b = 0;
#line 1451
  switch ((int )test->test_type) {
  case 1: 
#line 1453
  b = reg_pattern_test(adapter, data, (int )((u32 )test->reg + i * 64U), test->mask,
                       test->write);
#line 1457
  goto ldv_56112;
  case 2: 
#line 1459
  b = reg_set_and_check(adapter, data, (int )((u32 )test->reg + i * 64U), test->mask,
                        test->write);
#line 1463
  goto ldv_56112;
  case 3: 
#line 1465
  ixgbe_write_reg(& adapter->hw, (u32 )test->reg + i * 64U, test->write);
#line 1468
  goto ldv_56112;
  case 4: 
#line 1470
  b = reg_pattern_test(adapter, data, (int )((u32 )test->reg + i * 4U), test->mask,
                       test->write);
#line 1474
  goto ldv_56112;
  case 5: 
#line 1476
  b = reg_pattern_test(adapter, data, (int )((u32 )test->reg + i * 8U), test->mask,
                       test->write);
#line 1480
  goto ldv_56112;
  case 6: 
#line 1482
  b = reg_pattern_test(adapter, data, (int )(((u32 )test->reg + i * 8U) + 4U), test->mask,
                       test->write);
#line 1486
  goto ldv_56112;
  }
  ldv_56112: ;
#line 1488
  if ((int )b) {
#line 1489
    return (1);
  } else {

  }
#line 1448
  i = i + 1U;
  ldv_56119: ;
#line 1448
  if ((u32 )test->array_len > i) {
#line 1450
    goto ldv_56118;
  } else {

  }
#line 1491
  test = test + 1;
  ldv_56122: ;
#line 1447
  if ((unsigned int )((unsigned short )test->reg) != 0U) {
#line 1449
    goto ldv_56121;
  } else {

  }
#line 1494
  *data = 0ULL;
#line 1495
  return (0);
}
}
#line 1498 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_eeprom_test(struct ixgbe_adapter *adapter , u64 *data ) 
{ 
  struct ixgbe_hw *hw ;
  s32 tmp ;

  {
#line 1500
  hw = & adapter->hw;
#line 1501
  tmp = (*(hw->eeprom.ops.validate_checksum))(hw, (u16 *)0U);
#line 1501
  if (tmp != 0) {
#line 1502
    *data = 1ULL;
  } else {
#line 1504
    *data = 0ULL;
  }
#line 1505
  return ((int )*data);
}
}
#line 1508 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static irqreturn_t ixgbe_test_intr(int irq , void *data ) 
{ 
  struct net_device *netdev ;
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  u32 tmp___0 ;

  {
#line 1510
  netdev = (struct net_device *)data;
#line 1511
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1511
  adapter = (struct ixgbe_adapter *)tmp;
#line 1513
  tmp___0 = ixgbe_read_reg(& adapter->hw, 2048U);
#line 1513
  adapter->test_icr = adapter->test_icr | tmp___0;
#line 1515
  return (1);
}
}
#line 1518 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_intr_test(struct ixgbe_adapter *adapter , u64 *data ) 
{ 
  struct net_device *netdev ;
  u32 mask ;
  u32 i ;
  u32 shared_int ;
  u32 irq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1520
  netdev = adapter->netdev;
#line 1521
  i = 0U;
#line 1521
  shared_int = 1U;
#line 1522
  irq = (adapter->pdev)->irq;
#line 1524
  *data = 0ULL;
#line 1527
  if ((unsigned long )adapter->msix_entries != (unsigned long )((struct msix_entry *)0)) {
#line 1529
    return (0);
  } else
#line 1530
  if ((adapter->flags & 2U) != 0U) {
#line 1531
    shared_int = 0U;
#line 1532
    tmp = ldv_request_irq_17(irq, & ixgbe_test_intr, 0UL, (char const   *)(& netdev->name),
                             (void *)netdev);
#line 1532
    if (tmp != 0) {
#line 1534
      *data = 1ULL;
#line 1535
      return (-1);
    } else {

    }
  } else {
#line 1537
    tmp___1 = ldv_request_irq_18(irq, & ixgbe_test_intr, 256UL, (char const   *)(& netdev->name),
                                 (void *)netdev);
#line 1537
    if (tmp___1 == 0) {
#line 1539
      shared_int = 0U;
    } else {
#line 1540
      tmp___0 = ldv_request_irq_20(irq, & ixgbe_test_intr, 128UL, (char const   *)(& netdev->name),
                                   (void *)netdev);
#line 1540
      if (tmp___0 != 0) {
#line 1542
        *data = 1ULL;
#line 1543
        return (-1);
      } else {

      }
    }
  }
#line 1545
  if (((int )adapter->msg_enable & 8192) != 0) {
#line 1546
    netdev_info((struct net_device  const  *)adapter->netdev, "testing %s interrupt\n",
                shared_int != 0U ? (char *)"shared" : (char *)"unshared");
  } else {

  }
#line 1549
  ixgbe_write_reg(& adapter->hw, 2184U, 4294967295U);
#line 1550
  ixgbe_read_reg(& adapter->hw, 8U);
#line 1551
  usleep_range(10000UL, 20000UL);
#line 1554
  goto ldv_56146;
  ldv_56145: 
#line 1556
  mask = (u32 )(1 << (int )i);
#line 1558
  if (shared_int == 0U) {
#line 1566
    adapter->test_icr = 0U;
#line 1567
    ixgbe_write_reg(& adapter->hw, 2184U, ~ mask & 32767U);
#line 1569
    ixgbe_write_reg(& adapter->hw, 2056U, ~ mask & 32767U);
#line 1571
    ixgbe_read_reg(& adapter->hw, 8U);
#line 1572
    usleep_range(10000UL, 20000UL);
#line 1574
    if ((adapter->test_icr & mask) != 0U) {
#line 1575
      *data = 3ULL;
#line 1576
      goto ldv_56144;
    } else {

    }
  } else {

  }
#line 1586
  adapter->test_icr = 0U;
#line 1587
  ixgbe_write_reg(& adapter->hw, 2176U, mask);
#line 1588
  ixgbe_write_reg(& adapter->hw, 2056U, mask);
#line 1589
  ixgbe_read_reg(& adapter->hw, 8U);
#line 1590
  usleep_range(10000UL, 20000UL);
#line 1592
  if ((adapter->test_icr & mask) == 0U) {
#line 1593
    *data = 4ULL;
#line 1594
    goto ldv_56144;
  } else {

  }
#line 1597
  if (shared_int == 0U) {
#line 1605
    adapter->test_icr = 0U;
#line 1606
    ixgbe_write_reg(& adapter->hw, 2184U, ~ mask & 32767U);
#line 1608
    ixgbe_write_reg(& adapter->hw, 2056U, ~ mask & 32767U);
#line 1610
    ixgbe_read_reg(& adapter->hw, 8U);
#line 1611
    usleep_range(10000UL, 20000UL);
#line 1613
    if (adapter->test_icr != 0U) {
#line 1614
      *data = 5ULL;
#line 1615
      goto ldv_56144;
    } else {

    }
  } else {

  }
#line 1554
  i = i + 1U;
  ldv_56146: ;
#line 1554
  if (i <= 9U) {
#line 1556
    goto ldv_56145;
  } else {

  }
  ldv_56144: 
#line 1621
  ixgbe_write_reg(& adapter->hw, 2184U, 4294967295U);
#line 1622
  ixgbe_read_reg(& adapter->hw, 8U);
#line 1623
  usleep_range(10000UL, 20000UL);
#line 1626
  ldv_free_irq_114(irq, (void *)netdev);
#line 1628
  return ((int )*data);
}
}
#line 1631 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_free_desc_rings(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_ring *tx_ring ;
  struct ixgbe_ring *rx_ring ;
  struct ixgbe_hw *hw ;
  u32 reg_ctl ;

  {
#line 1633
  tx_ring = & adapter->test_tx_ring;
#line 1634
  rx_ring = & adapter->test_rx_ring;
#line 1635
  hw = & adapter->hw;
#line 1641
  (*(hw->mac.ops.disable_rx))(hw);
#line 1642
  ixgbe_disable_rx_queue(adapter, rx_ring);
#line 1645
  reg_ctl = ixgbe_read_reg(hw, (u32 )((int )tx_ring->reg_idx * 64 + 24616));
#line 1646
  reg_ctl = reg_ctl & 4261412863U;
#line 1647
  ixgbe_write_reg(hw, (u32 )((int )tx_ring->reg_idx * 64 + 24616), reg_ctl);
#line 1649
  switch ((unsigned int )hw->mac.type) {
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 1654
  reg_ctl = ixgbe_read_reg(hw, 19072U);
#line 1655
  reg_ctl = reg_ctl & 4294967294U;
#line 1656
  ixgbe_write_reg(hw, 19072U, reg_ctl);
#line 1657
  goto ldv_56158;
  default: ;
#line 1659
  goto ldv_56158;
  }
  ldv_56158: 
#line 1662
  ixgbe_reset(adapter);
#line 1664
  ixgbe_free_tx_resources(& adapter->test_tx_ring);
#line 1665
  ixgbe_free_rx_resources(& adapter->test_rx_ring);
#line 1666
  return;
}
}
#line 1668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_setup_desc_rings(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_ring *tx_ring ;
  struct ixgbe_ring *rx_ring ;
  struct ixgbe_hw *hw ;
  u32 rctl ;
  u32 reg_data ;
  int ret_val ;
  int err ;

  {
#line 1670
  tx_ring = & adapter->test_tx_ring;
#line 1671
  rx_ring = & adapter->test_rx_ring;
#line 1672
  hw = & adapter->hw;
#line 1678
  tx_ring->count = 512U;
#line 1679
  tx_ring->queue_index = 0U;
#line 1680
  tx_ring->dev = & (adapter->pdev)->dev;
#line 1681
  tx_ring->netdev = adapter->netdev;
#line 1682
  tx_ring->reg_idx = (adapter->tx_ring[0])->reg_idx;
#line 1684
  err = ixgbe_setup_tx_resources(tx_ring);
#line 1685
  if (err != 0) {
#line 1686
    return (1);
  } else {

  }
#line 1688
  switch ((unsigned int )adapter->hw.mac.type) {
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 1693
  reg_data = ixgbe_read_reg(& adapter->hw, 19072U);
#line 1694
  reg_data = reg_data | 1U;
#line 1695
  ixgbe_write_reg(& adapter->hw, 19072U, reg_data);
#line 1696
  goto ldv_56174;
  default: ;
#line 1698
  goto ldv_56174;
  }
  ldv_56174: 
#line 1701
  ixgbe_configure_tx_ring(adapter, tx_ring);
#line 1704
  rx_ring->count = 512U;
#line 1705
  rx_ring->queue_index = 0U;
#line 1706
  rx_ring->dev = & (adapter->pdev)->dev;
#line 1707
  rx_ring->netdev = adapter->netdev;
#line 1708
  rx_ring->reg_idx = (adapter->rx_ring[0])->reg_idx;
#line 1710
  err = ixgbe_setup_rx_resources(rx_ring);
#line 1711
  if (err != 0) {
#line 1712
    ret_val = 4;
#line 1713
    goto err_nomem;
  } else {

  }
#line 1716
  (*(hw->mac.ops.disable_rx))(hw);
#line 1718
  ixgbe_configure_rx_ring(adapter, rx_ring);
#line 1720
  rctl = ixgbe_read_reg(& adapter->hw, 12288U);
#line 1721
  rctl = rctl | 2U;
#line 1722
  ixgbe_write_reg(& adapter->hw, 12288U, rctl);
#line 1724
  (*(hw->mac.ops.enable_rx))(hw);
#line 1726
  return (0);
  err_nomem: 
#line 1729
  ixgbe_free_desc_rings(adapter);
#line 1730
  return (ret_val);
}
}
#line 1733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_setup_loopback_test(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 reg_data ;
  u8 atlas ;

  {
#line 1735
  hw = & adapter->hw;
#line 1740
  reg_data = ixgbe_read_reg(hw, 16960U);
#line 1741
  reg_data = reg_data | 32768U;
#line 1742
  ixgbe_write_reg(hw, 16960U, reg_data);
#line 1744
  reg_data = ixgbe_read_reg(hw, 20608U);
#line 1745
  reg_data = reg_data | 1282U;
#line 1746
  ixgbe_write_reg(hw, 20608U, reg_data);
#line 1749
  switch ((unsigned int )adapter->hw.mac.type) {
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 1753
  reg_data = ixgbe_read_reg(hw, 17200U);
#line 1754
  reg_data = reg_data | 1U;
#line 1755
  ixgbe_write_reg(hw, 17200U, reg_data);
#line 1756
  goto ldv_56185;
  default: ;
#line 1758
  if (hw->mac.orig_autoc != 0U) {
#line 1759
    reg_data = hw->mac.orig_autoc | 1U;
#line 1760
    ixgbe_write_reg(hw, 17056U, reg_data);
  } else {
#line 1762
    return (10);
  }
  }
  ldv_56185: 
#line 1765
  ixgbe_read_reg(hw, 8U);
#line 1766
  usleep_range(10000UL, 20000UL);
#line 1769
  if ((unsigned int )hw->mac.type == 1U) {
#line 1772
    (*(hw->mac.ops.read_analog_reg8))(hw, 36U, & atlas);
#line 1773
    atlas = (u8 )((unsigned int )atlas | 16U);
#line 1774
    (*(hw->mac.ops.write_analog_reg8))(hw, 36U, (int )atlas);
#line 1776
    (*(hw->mac.ops.read_analog_reg8))(hw, 11U, & atlas);
#line 1777
    atlas = (u8 )((unsigned int )atlas | 240U);
#line 1778
    (*(hw->mac.ops.write_analog_reg8))(hw, 11U, (int )atlas);
#line 1780
    (*(hw->mac.ops.read_analog_reg8))(hw, 12U, & atlas);
#line 1781
    atlas = (u8 )((unsigned int )atlas | 240U);
#line 1782
    (*(hw->mac.ops.write_analog_reg8))(hw, 12U, (int )atlas);
#line 1784
    (*(hw->mac.ops.read_analog_reg8))(hw, 13U, & atlas);
#line 1785
    atlas = (u8 )((unsigned int )atlas | 240U);
#line 1786
    (*(hw->mac.ops.write_analog_reg8))(hw, 13U, (int )atlas);
  } else {

  }
#line 1789
  return (0);
}
}
#line 1792 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_loopback_cleanup(struct ixgbe_adapter *adapter ) 
{ 
  u32 reg_data ;

  {
#line 1796
  reg_data = ixgbe_read_reg(& adapter->hw, 16960U);
#line 1797
  reg_data = reg_data & 4294934527U;
#line 1798
  ixgbe_write_reg(& adapter->hw, 16960U, reg_data);
#line 1799
  return;
}
}
#line 1801 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_create_lbtest_frame(struct sk_buff *skb , unsigned int frame_size ) 
{ 


  {
#line 1804
  memset((void *)skb->data, 255, (size_t )frame_size);
#line 1805
  frame_size = frame_size >> 1;
#line 1806
  memset((void *)skb->data + (unsigned long )frame_size, 170, (size_t )(frame_size / 2U - 1U));
#line 1807
  memset((void *)skb->data + (unsigned long )(frame_size + 10U), 190, 1UL);
#line 1808
  memset((void *)skb->data + (unsigned long )(frame_size + 12U), 175, 1UL);
#line 1809
  return;
}
}
#line 1811 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static bool ixgbe_check_lbtest_frame(struct ixgbe_rx_buffer *rx_buffer , unsigned int frame_size ) 
{ 
  unsigned char *data ;
  bool match ;
  void *tmp ;

  {
#line 1815
  match = 1;
#line 1817
  frame_size = frame_size >> 1;
#line 1819
  tmp = kmap(rx_buffer->page);
#line 1819
  data = (unsigned char *)tmp + (unsigned long )rx_buffer->page_offset;
#line 1821
  if (((unsigned int )*(data + 3UL) != 255U || (unsigned int )*(data + (unsigned long )(frame_size + 10U)) != 190U) || (unsigned int )*(data + (unsigned long )(frame_size + 12U)) != 175U) {
#line 1824
    match = 0;
  } else {

  }
#line 1826
  kunmap(rx_buffer->page);
#line 1828
  return (match);
}
}
#line 1831 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static u16 ixgbe_clean_test_rings(struct ixgbe_ring *rx_ring , struct ixgbe_ring *tx_ring ,
                                  unsigned int size ) 
{ 
  union ixgbe_adv_rx_desc *rx_desc ;
  struct ixgbe_rx_buffer *rx_buffer ;
  struct ixgbe_tx_buffer *tx_buffer ;
  u16 rx_ntc ;
  u16 tx_ntc ;
  u16 count ;
  unsigned int tmp ;
  bool tmp___0 ;
  unsigned int tmp___1 ;
  __le32 tmp___2 ;
  struct netdev_queue *tmp___3 ;

  {
#line 1838
  count = 0U;
#line 1841
  rx_ntc = rx_ring->next_to_clean;
#line 1842
  tx_ntc = tx_ring->next_to_clean;
#line 1843
  rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long )rx_ntc;
#line 1845
  goto ldv_56214;
  ldv_56213: 
#line 1847
  rx_buffer = rx_ring->__annonCompField118.rx_buffer_info + (unsigned long )rx_ntc;
#line 1850
  tmp = ixgbe_rx_bufsz(rx_ring);
#line 1850
  dma_sync_single_for_cpu(rx_ring->dev, rx_buffer->dma, (size_t )tmp, 2);
#line 1856
  tmp___0 = ixgbe_check_lbtest_frame(rx_buffer, size);
#line 1856
  if ((int )tmp___0) {
#line 1857
    count = (u16 )((int )count + 1);
  } else {

  }
#line 1860
  tmp___1 = ixgbe_rx_bufsz(rx_ring);
#line 1860
  dma_sync_single_for_device(rx_ring->dev, rx_buffer->dma, (size_t )tmp___1, 2);
#line 1866
  tx_buffer = tx_ring->__annonCompField118.tx_buffer_info + (unsigned long )tx_ntc;
#line 1867
  ixgbe_unmap_and_free_tx_resource(tx_ring, tx_buffer);
#line 1870
  rx_ntc = (u16 )((int )rx_ntc + 1);
#line 1871
  if ((int )rx_ring->count == (int )rx_ntc) {
#line 1872
    rx_ntc = 0U;
  } else {

  }
#line 1873
  tx_ntc = (u16 )((int )tx_ntc + 1);
#line 1874
  if ((int )tx_ring->count == (int )tx_ntc) {
#line 1875
    tx_ntc = 0U;
  } else {

  }
#line 1878
  rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long )rx_ntc;
  ldv_56214: 
#line 1845
  tmp___2 = ixgbe_test_staterr(rx_desc, 1U);
#line 1845
  if (tmp___2 != 0U) {
#line 1847
    goto ldv_56213;
  } else {

  }
#line 1881
  tmp___3 = txring_txq((struct ixgbe_ring  const  *)tx_ring);
#line 1881
  netdev_tx_reset_queue(tmp___3);
#line 1884
  ixgbe_alloc_rx_buffers(rx_ring, (int )count);
#line 1885
  rx_ring->next_to_clean = rx_ntc;
#line 1886
  tx_ring->next_to_clean = tx_ntc;
#line 1888
  return (count);
}
}
#line 1891 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_run_loopback_test(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_ring *tx_ring ;
  struct ixgbe_ring *rx_ring ;
  int i ;
  int j ;
  int lc ;
  int good_cnt ;
  int ret_val ;
  unsigned int size ;
  netdev_tx_t tx_ret_val ;
  struct sk_buff *skb ;
  u32 flags_orig ;
  u16 tmp ;

  {
#line 1893
  tx_ring = & adapter->test_tx_ring;
#line 1894
  rx_ring = & adapter->test_rx_ring;
#line 1895
  ret_val = 0;
#line 1896
  size = 1024U;
#line 1899
  flags_orig = adapter->flags;
#line 1902
  adapter->flags = adapter->flags & 4294963199U;
#line 1905
  skb = alloc_skb(size, 208U);
#line 1906
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 1907
    return (11);
  } else {

  }
#line 1910
  ixgbe_create_lbtest_frame(skb, size);
#line 1911
  skb_put(skb, size);
#line 1919
  if ((int )rx_ring->count <= (int )tx_ring->count) {
#line 1920
    lc = (int )((unsigned int )tx_ring->count / 64U) * 2 + 1;
  } else {
#line 1922
    lc = (int )((unsigned int )rx_ring->count / 64U) * 2 + 1;
  }
#line 1924
  j = 0;
#line 1924
  goto ldv_56235;
  ldv_56234: 
#line 1926
  good_cnt = 0;
#line 1929
  i = 0;
#line 1929
  goto ldv_56231;
  ldv_56230: 
#line 1930
  skb_get(skb);
#line 1931
  tx_ret_val = ixgbe_xmit_frame_ring(skb, adapter, tx_ring);
#line 1934
  if ((int )tx_ret_val == 0) {
#line 1935
    good_cnt = good_cnt + 1;
  } else {

  }
#line 1929
  i = i + 1;
  ldv_56231: ;
#line 1929
  if (i <= 63) {
#line 1931
    goto ldv_56230;
  } else {

  }

#line 1938
  if (good_cnt != 64) {
#line 1939
    ret_val = 12;
#line 1940
    goto ldv_56233;
  } else {

  }
#line 1944
  msleep(200U);
#line 1946
  tmp = ixgbe_clean_test_rings(rx_ring, tx_ring, size);
#line 1946
  good_cnt = (int )tmp;
#line 1947
  if (good_cnt != 64) {
#line 1948
    ret_val = 13;
#line 1949
    goto ldv_56233;
  } else {

  }
#line 1924
  j = j + 1;
  ldv_56235: ;
#line 1924
  if (j <= lc) {
#line 1926
    goto ldv_56234;
  } else {

  }
  ldv_56233: 
#line 1954
  kfree_skb(skb);
#line 1955
  adapter->flags = flags_orig;
#line 1957
  return (ret_val);
}
}
#line 1960 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_loopback_test(struct ixgbe_adapter *adapter , u64 *data ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1962
  tmp = ixgbe_setup_desc_rings(adapter);
#line 1962
  *data = (u64 )tmp;
#line 1963
  if (*data != 0ULL) {
#line 1964
    goto out;
  } else {

  }
#line 1965
  tmp___0 = ixgbe_setup_loopback_test(adapter);
#line 1965
  *data = (u64 )tmp___0;
#line 1966
  if (*data != 0ULL) {
#line 1967
    goto err_loopback;
  } else {

  }
#line 1968
  tmp___1 = ixgbe_run_loopback_test(adapter);
#line 1968
  *data = (u64 )tmp___1;
#line 1969
  ixgbe_loopback_cleanup(adapter);
  err_loopback: 
#line 1972
  ixgbe_free_desc_rings(adapter);
  out: ;
#line 1974
  return ((int )*data);
}
}
#line 1977 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_diag_test(struct net_device *netdev , struct ethtool_test *eth_test ,
                            u64 *data ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  bool if_running ;
  bool tmp___0 ;
  bool tmp___1 ;
  struct ixgbe_hw *hw ;
  int i ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1980
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1980
  adapter = (struct ixgbe_adapter *)tmp;
#line 1981
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 1981
  if_running = tmp___0;
#line 1983
  tmp___1 = ixgbe_removed((void *)adapter->hw.hw_addr);
#line 1983
  if ((int )tmp___1) {
#line 1984
    if (((int )adapter->msg_enable & 8192) != 0) {
#line 1984
      netdev_err((struct net_device  const  *)adapter->netdev, "Adapter removed - test blocked\n");
    } else {

    }
#line 1985
    *data = 1ULL;
#line 1986
    *(data + 1UL) = 1ULL;
#line 1987
    *(data + 2UL) = 1ULL;
#line 1988
    *(data + 3UL) = 1ULL;
#line 1989
    *(data + 4UL) = 1ULL;
#line 1990
    eth_test->flags = eth_test->flags | 2U;
#line 1991
    return;
  } else {

  }
#line 1993
  set_bit(0L, (unsigned long volatile   *)(& adapter->state));
#line 1994
  if (eth_test->flags == 1U) {
#line 1995
    hw = & adapter->hw;
#line 1997
    if ((adapter->flags & 8388608U) != 0U) {
#line 1999
      i = 0;
#line 1999
      goto ldv_56253;
      ldv_56252: ;
#line 2000
      if ((int )(adapter->vfinfo + (unsigned long )i)->clear_to_send) {
#line 2001
        netdev_warn((struct net_device  const  *)netdev, "offline diagnostic is not supported when VFs are present\n");
#line 2002
        *data = 1ULL;
#line 2003
        *(data + 1UL) = 1ULL;
#line 2004
        *(data + 2UL) = 1ULL;
#line 2005
        *(data + 3UL) = 1ULL;
#line 2006
        *(data + 4UL) = 1ULL;
#line 2007
        eth_test->flags = eth_test->flags | 2U;
#line 2008
        clear_bit(0L, (unsigned long volatile   *)(& adapter->state));
#line 2010
        goto skip_ol_tests;
      } else {

      }
#line 1999
      i = i + 1;
      ldv_56253: ;
#line 1999
      if ((unsigned int )i < adapter->num_vfs) {
#line 2001
        goto ldv_56252;
      } else {

      }

    } else {

    }
#line 2016
    if (((int )adapter->msg_enable & 8192) != 0) {
#line 2016
      netdev_info((struct net_device  const  *)adapter->netdev, "offline testing starting\n");
    } else {

    }
#line 2021
    tmp___2 = ixgbe_link_test(adapter, data + 4UL);
#line 2021
    if (tmp___2 != 0) {
#line 2022
      eth_test->flags = eth_test->flags | 2U;
    } else {

    }
#line 2024
    if ((int )if_running) {
#line 2026
      dev_close(netdev);
    } else {
#line 2028
      ixgbe_reset(adapter);
    }
#line 2030
    if (((int )adapter->msg_enable & 8192) != 0) {
#line 2030
      netdev_info((struct net_device  const  *)adapter->netdev, "register testing starting\n");
    } else {

    }
#line 2031
    tmp___3 = ixgbe_reg_test(adapter, data);
#line 2031
    if (tmp___3 != 0) {
#line 2032
      eth_test->flags = eth_test->flags | 2U;
    } else {

    }
#line 2034
    ixgbe_reset(adapter);
#line 2035
    if (((int )adapter->msg_enable & 8192) != 0) {
#line 2035
      netdev_info((struct net_device  const  *)adapter->netdev, "eeprom testing starting\n");
    } else {

    }
#line 2036
    tmp___4 = ixgbe_eeprom_test(adapter, data + 1UL);
#line 2036
    if (tmp___4 != 0) {
#line 2037
      eth_test->flags = eth_test->flags | 2U;
    } else {

    }
#line 2039
    ixgbe_reset(adapter);
#line 2040
    if (((int )adapter->msg_enable & 8192) != 0) {
#line 2040
      netdev_info((struct net_device  const  *)adapter->netdev, "interrupt testing starting\n");
    } else {

    }
#line 2041
    tmp___5 = ixgbe_intr_test(adapter, data + 2UL);
#line 2041
    if (tmp___5 != 0) {
#line 2042
      eth_test->flags = eth_test->flags | 2U;
    } else {

    }
#line 2046
    if ((adapter->flags & 8404992U) != 0U) {
#line 2048
      if (((int )adapter->msg_enable & 8192) != 0) {
#line 2048
        netdev_info((struct net_device  const  *)adapter->netdev, "Skip MAC loopback diagnostic in VT mode\n");
      } else {

      }
#line 2049
      *(data + 3UL) = 0ULL;
#line 2050
      goto skip_loopback;
    } else {

    }
#line 2053
    ixgbe_reset(adapter);
#line 2054
    if (((int )adapter->msg_enable & 8192) != 0) {
#line 2054
      netdev_info((struct net_device  const  *)adapter->netdev, "loopback testing starting\n");
    } else {

    }
#line 2055
    tmp___6 = ixgbe_loopback_test(adapter, data + 3UL);
#line 2055
    if (tmp___6 != 0) {
#line 2056
      eth_test->flags = eth_test->flags | 2U;
    } else {

    }
    skip_loopback: 
#line 2059
    ixgbe_reset(adapter);
#line 2062
    clear_bit(0L, (unsigned long volatile   *)(& adapter->state));
#line 2063
    if ((int )if_running) {
#line 2064
      dev_open(netdev);
    } else
#line 2065
    if ((unsigned long )hw->mac.ops.disable_tx_laser != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
#line 2066
      (*(hw->mac.ops.disable_tx_laser))(hw);
    } else {

    }
  } else {
#line 2068
    if (((int )adapter->msg_enable & 8192) != 0) {
#line 2068
      netdev_info((struct net_device  const  *)adapter->netdev, "online testing starting\n");
    } else {

    }
#line 2071
    tmp___7 = ixgbe_link_test(adapter, data + 4UL);
#line 2071
    if (tmp___7 != 0) {
#line 2072
      eth_test->flags = eth_test->flags | 2U;
    } else {

    }
#line 2075
    *data = 0ULL;
#line 2076
    *(data + 1UL) = 0ULL;
#line 2077
    *(data + 2UL) = 0ULL;
#line 2078
    *(data + 3UL) = 0ULL;
#line 2080
    clear_bit(0L, (unsigned long volatile   *)(& adapter->state));
  }
  skip_ol_tests: 
#line 2084
  msleep_interruptible(4000U);
#line 2085
  return;
}
}
#line 2087 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_wol_exclusion(struct ixgbe_adapter *adapter , struct ethtool_wolinfo *wol ) 
{ 
  struct ixgbe_hw *hw ;
  int retval ;
  int tmp ;

  {
#line 2090
  hw = & adapter->hw;
#line 2091
  retval = 0;
#line 2094
  tmp = ixgbe_wol_supported(adapter, (int )hw->device_id, (int )hw->subsystem_device_id);
#line 2094
  if (tmp == 0) {
#line 2096
    retval = 1;
#line 2097
    wol->supported = 0U;
  } else {

  }
#line 2100
  return (retval);
}
}
#line 2103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_wol(struct net_device *netdev , struct ethtool_wolinfo *wol ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 2106
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2106
  adapter = (struct ixgbe_adapter *)tmp;
#line 2108
  wol->supported = 46U;
#line 2110
  wol->wolopts = 0U;
#line 2112
  tmp___0 = ixgbe_wol_exclusion(adapter, wol);
#line 2112
  if (tmp___0 != 0) {
#line 2114
    return;
  } else {
#line 2112
    tmp___1 = device_can_wakeup(& (adapter->pdev)->dev);
#line 2112
    if (tmp___1) {
#line 2112
      tmp___2 = 0;
    } else {
#line 2112
      tmp___2 = 1;
    }
#line 2112
    if (tmp___2) {
#line 2114
      return;
    } else {

    }
  }
#line 2116
  if ((adapter->wol & 4U) != 0U) {
#line 2117
    wol->wolopts = wol->wolopts | 2U;
  } else {

  }
#line 2118
  if ((adapter->wol & 8U) != 0U) {
#line 2119
    wol->wolopts = wol->wolopts | 4U;
  } else {

  }
#line 2120
  if ((adapter->wol & 16U) != 0U) {
#line 2121
    wol->wolopts = wol->wolopts | 8U;
  } else {

  }
#line 2122
  if ((adapter->wol & 2U) != 0U) {
#line 2123
    wol->wolopts = wol->wolopts | 32U;
  } else {

  }
#line 2124
  return;
}
}
#line 2126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_wol(struct net_device *netdev , struct ethtool_wolinfo *wol ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2128
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2128
  adapter = (struct ixgbe_adapter *)tmp;
#line 2130
  if ((wol->wolopts & 81U) != 0U) {
#line 2131
    return (-95);
  } else {

  }
#line 2133
  tmp___0 = ixgbe_wol_exclusion(adapter, wol);
#line 2133
  if (tmp___0 != 0) {
#line 2134
    return (wol->wolopts != 0U ? -95 : 0);
  } else {

  }
#line 2136
  adapter->wol = 0U;
#line 2138
  if ((wol->wolopts & 2U) != 0U) {
#line 2139
    adapter->wol = adapter->wol | 4U;
  } else {

  }
#line 2140
  if ((wol->wolopts & 4U) != 0U) {
#line 2141
    adapter->wol = adapter->wol | 8U;
  } else {

  }
#line 2142
  if ((wol->wolopts & 8U) != 0U) {
#line 2143
    adapter->wol = adapter->wol | 16U;
  } else {

  }
#line 2144
  if ((wol->wolopts & 32U) != 0U) {
#line 2145
    adapter->wol = adapter->wol | 2U;
  } else {

  }
#line 2147
  device_set_wakeup_enable(& (adapter->pdev)->dev, adapter->wol != 0U);
#line 2149
  return (0);
}
}
#line 2152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_nway_reset(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;

  {
#line 2154
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2154
  adapter = (struct ixgbe_adapter *)tmp;
#line 2156
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 2156
  if ((int )tmp___0) {
#line 2157
    ixgbe_reinit_locked(adapter);
  } else {

  }
#line 2159
  return (0);
}
}
#line 2162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_phys_id(struct net_device *netdev , enum ethtool_phys_id_state state ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;

  {
#line 2165
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2165
  adapter = (struct ixgbe_adapter *)tmp;
#line 2166
  hw = & adapter->hw;
#line 2168
  switch ((unsigned int )state) {
  case 1U: 
#line 2170
  adapter->led_reg = ixgbe_read_reg(hw, 512U);
#line 2171
  return (2);
  case 2U: 
#line 2174
  (*(hw->mac.ops.led_on))(hw, 14U);
#line 2175
  goto ldv_56284;
  case 3U: 
#line 2178
  (*(hw->mac.ops.led_off))(hw, 14U);
#line 2179
  goto ldv_56284;
  case 0U: 
#line 2183
  ixgbe_write_reg(& adapter->hw, 512U, adapter->led_reg);
#line 2184
  goto ldv_56284;
  }
  ldv_56284: ;
#line 2187
  return (0);
}
}
#line 2190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_coalesce(struct net_device *netdev , struct ethtool_coalesce *ec ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 2193
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2193
  adapter = (struct ixgbe_adapter *)tmp;
#line 2196
  if ((unsigned int )adapter->rx_itr_setting <= 1U) {
#line 2197
    ec->rx_coalesce_usecs = (__u32 )adapter->rx_itr_setting;
  } else {
#line 2199
    ec->rx_coalesce_usecs = (__u32 )((int )adapter->rx_itr_setting >> 2);
  }
#line 2202
  if ((unsigned int )(adapter->q_vector[0])->tx.count != 0U && (unsigned int )(adapter->q_vector[0])->rx.count != 0U) {
#line 2203
    return (0);
  } else {

  }
#line 2206
  if ((unsigned int )adapter->tx_itr_setting <= 1U) {
#line 2207
    ec->tx_coalesce_usecs = (__u32 )adapter->tx_itr_setting;
  } else {
#line 2209
    ec->tx_coalesce_usecs = (__u32 )((int )adapter->tx_itr_setting >> 2);
  }
#line 2211
  return (0);
}
}
#line 2218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static bool ixgbe_update_rsc(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;

  {
#line 2220
  netdev = adapter->netdev;
#line 2223
  if ((adapter->flags2 & 1U) == 0U || (netdev->features & 32768ULL) == 0ULL) {
#line 2225
    return (0);
  } else {

  }
#line 2228
  if ((unsigned int )adapter->rx_itr_setting == 1U || (unsigned int )adapter->rx_itr_setting > 24U) {
#line 2230
    if ((adapter->flags2 & 2U) == 0U) {
#line 2231
      adapter->flags2 = adapter->flags2 | 2U;
#line 2232
      if (((int )adapter->msg_enable & 2) != 0) {
#line 2232
        netdev_info((struct net_device  const  *)adapter->netdev, "rx-usecs value high enough to re-enable RSC\n");
      } else {

      }
#line 2233
      return (1);
    } else {

    }
  } else
#line 2236
  if ((adapter->flags2 & 2U) != 0U) {
#line 2237
    adapter->flags2 = adapter->flags2 & 4294967293U;
#line 2238
    if (((int )adapter->msg_enable & 2) != 0) {
#line 2238
      netdev_info((struct net_device  const  *)adapter->netdev, "rx-usecs set too low, disabling RSC\n");
    } else {

    }
#line 2239
    return (1);
  } else {

  }
#line 2241
  return (0);
}
}
#line 2244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_coalesce(struct net_device *netdev , struct ethtool_coalesce *ec ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_q_vector *q_vector ;
  int i ;
  u16 tx_itr_param ;
  u16 rx_itr_param ;
  u16 tx_itr_prev ;
  bool need_reset ;
  bool tmp___0 ;

  {
#line 2247
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2247
  adapter = (struct ixgbe_adapter *)tmp;
#line 2251
  need_reset = 0;
#line 2253
  if ((unsigned int )(adapter->q_vector[0])->tx.count != 0U && (unsigned int )(adapter->q_vector[0])->rx.count != 0U) {
#line 2255
    if (ec->tx_coalesce_usecs != 0U) {
#line 2256
      return (-22);
    } else {

    }
#line 2257
    tx_itr_prev = adapter->rx_itr_setting;
  } else {
#line 2259
    tx_itr_prev = adapter->tx_itr_setting;
  }
#line 2262
  if (ec->rx_coalesce_usecs > 1022U || ec->tx_coalesce_usecs > 1022U) {
#line 2264
    return (-22);
  } else {

  }
#line 2266
  if (ec->rx_coalesce_usecs > 1U) {
#line 2267
    adapter->rx_itr_setting = (int )((u16 )ec->rx_coalesce_usecs) << 2U;
  } else {
#line 2269
    adapter->rx_itr_setting = (u16 )ec->rx_coalesce_usecs;
  }
#line 2271
  if ((unsigned int )adapter->rx_itr_setting == 1U) {
#line 2272
    rx_itr_param = 200U;
  } else {
#line 2274
    rx_itr_param = adapter->rx_itr_setting;
  }
#line 2276
  if (ec->tx_coalesce_usecs > 1U) {
#line 2277
    adapter->tx_itr_setting = (int )((u16 )ec->tx_coalesce_usecs) << 2U;
  } else {
#line 2279
    adapter->tx_itr_setting = (u16 )ec->tx_coalesce_usecs;
  }
#line 2281
  if ((unsigned int )adapter->tx_itr_setting == 1U) {
#line 2282
    tx_itr_param = 400U;
  } else {
#line 2284
    tx_itr_param = adapter->tx_itr_setting;
  }
#line 2287
  if ((unsigned int )(adapter->q_vector[0])->tx.count != 0U && (unsigned int )(adapter->q_vector[0])->rx.count != 0U) {
#line 2288
    adapter->tx_itr_setting = adapter->rx_itr_setting;
  } else {

  }
#line 2291
  if ((unsigned int )adapter->tx_itr_setting != 1U && (unsigned int )adapter->tx_itr_setting <= 39U) {
#line 2293
    if ((unsigned int )tx_itr_prev == 1U || (unsigned int )tx_itr_prev > 39U) {
#line 2295
      need_reset = 1;
    } else {

    }
  } else
#line 2297
  if ((unsigned int )tx_itr_prev != 1U && (unsigned int )tx_itr_prev <= 39U) {
#line 2299
    need_reset = 1;
  } else {

  }
#line 2303
  tmp___0 = ixgbe_update_rsc(adapter);
#line 2303
  need_reset = ((int )need_reset | (int )tmp___0) != 0;
#line 2305
  i = 0;
#line 2305
  goto ldv_56308;
  ldv_56307: 
#line 2306
  q_vector = adapter->q_vector[i];
#line 2307
  if ((unsigned int )q_vector->tx.count != 0U && (unsigned int )q_vector->rx.count == 0U) {
#line 2309
    q_vector->itr = tx_itr_param;
  } else {
#line 2312
    q_vector->itr = rx_itr_param;
  }
#line 2313
  ixgbe_write_eitr(q_vector);
#line 2305
  i = i + 1;
  ldv_56308: ;
#line 2305
  if (adapter->num_q_vectors > i) {
#line 2307
    goto ldv_56307;
  } else {

  }

#line 2321
  if ((int )need_reset) {
#line 2322
    ixgbe_do_reset(netdev);
  } else {

  }
#line 2324
  return (0);
}
}
#line 2327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_ethtool_fdir_entry(struct ixgbe_adapter *adapter , struct ethtool_rxnfc *cmd ) 
{ 
  union ixgbe_atr_input *mask ;
  struct ethtool_rx_flow_spec *fsp ;
  struct hlist_node *node2 ;
  struct ixgbe_fdir_filter *rule ;
  struct hlist_node *____ptr ;
  struct hlist_node  const  *__mptr ;
  struct ixgbe_fdir_filter *tmp ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node  const  *__mptr___0 ;
  struct ixgbe_fdir_filter *tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;

  {
#line 2330
  mask = & adapter->fdir_mask;
#line 2331
  fsp = & cmd->fs;
#line 2334
  rule = (struct ixgbe_fdir_filter *)0;
#line 2337
  cmd->data = (__u64 )((1024 << (int )adapter->fdir_pballoc) + -2);
#line 2339
  ____ptr = adapter->fdir_filter_list.first;
#line 2339
  if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
#line 2339
    __mptr = (struct hlist_node  const  *)____ptr;
#line 2339
    tmp = (struct ixgbe_fdir_filter *)__mptr;
  } else {
#line 2339
    tmp = (struct ixgbe_fdir_filter *)0;
  }
#line 2339
  rule = tmp;
#line 2339
  goto ldv_56329;
  ldv_56328: ;
#line 2341
  if (fsp->location <= (__u32 )rule->sw_idx) {
#line 2342
    goto ldv_56327;
  } else {

  }
#line 2339
  ____ptr___0 = node2;
#line 2339
  if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
#line 2339
    __mptr___0 = (struct hlist_node  const  *)____ptr___0;
#line 2339
    tmp___0 = (struct ixgbe_fdir_filter *)__mptr___0;
  } else {
#line 2339
    tmp___0 = (struct ixgbe_fdir_filter *)0;
  }
#line 2339
  rule = tmp___0;
  ldv_56329: ;
#line 2339
  if ((unsigned long )rule != (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 2339
    node2 = rule->fdir_node.next;
#line 2341
    goto ldv_56328;
  } else {

  }
  ldv_56327: ;
#line 2345
  if ((unsigned long )rule == (unsigned long )((struct ixgbe_fdir_filter *)0) || fsp->location != (__u32 )rule->sw_idx) {
#line 2346
    return (-22);
  } else {

  }
#line 2351
  switch ((int )rule->filter.formatted.flow_type) {
  case 2: 
#line 2353
  fsp->flow_type = 1U;
#line 2354
  goto ldv_56331;
  case 1: 
#line 2356
  fsp->flow_type = 2U;
#line 2357
  goto ldv_56331;
  case 3: 
#line 2359
  fsp->flow_type = 3U;
#line 2360
  goto ldv_56331;
  case 0: 
#line 2362
  fsp->flow_type = 13U;
#line 2363
  fsp->h_u.usr_ip4_spec.ip_ver = 1U;
#line 2364
  fsp->h_u.usr_ip4_spec.proto = 0U;
#line 2365
  fsp->m_u.usr_ip4_spec.proto = 0U;
#line 2366
  goto ldv_56331;
  default: ;
#line 2368
  return (-22);
  }
  ldv_56331: 
#line 2371
  fsp->h_u.tcp_ip4_spec.psrc = rule->filter.formatted.src_port;
#line 2372
  fsp->m_u.tcp_ip4_spec.psrc = mask->formatted.src_port;
#line 2373
  fsp->h_u.tcp_ip4_spec.pdst = rule->filter.formatted.dst_port;
#line 2374
  fsp->m_u.tcp_ip4_spec.pdst = mask->formatted.dst_port;
#line 2375
  fsp->h_u.tcp_ip4_spec.ip4src = rule->filter.formatted.src_ip[0];
#line 2376
  fsp->m_u.tcp_ip4_spec.ip4src = mask->formatted.src_ip[0];
#line 2377
  fsp->h_u.tcp_ip4_spec.ip4dst = rule->filter.formatted.dst_ip[0];
#line 2378
  fsp->m_u.tcp_ip4_spec.ip4dst = mask->formatted.dst_ip[0];
#line 2379
  fsp->h_ext.vlan_tci = rule->filter.formatted.vlan_id;
#line 2380
  fsp->m_ext.vlan_tci = mask->formatted.vlan_id;
#line 2381
  fsp->h_ext.vlan_etype = rule->filter.formatted.flex_bytes;
#line 2382
  fsp->m_ext.vlan_etype = mask->formatted.flex_bytes;
#line 2383
  tmp___1 = __fswab32((__u32 )rule->filter.formatted.vm_pool);
#line 2383
  fsp->h_ext.data[1] = tmp___1;
#line 2384
  tmp___2 = __fswab32((__u32 )mask->formatted.vm_pool);
#line 2384
  fsp->m_ext.data[1] = tmp___2;
#line 2385
  fsp->flow_type = fsp->flow_type | 2147483648U;
#line 2388
  if ((unsigned int )rule->action == 127U) {
#line 2389
    fsp->ring_cookie = 0xffffffffffffffffULL;
  } else {
#line 2391
    fsp->ring_cookie = (__u64 )rule->action;
  }
#line 2393
  return (0);
}
}
#line 2396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_ethtool_fdir_all(struct ixgbe_adapter *adapter , struct ethtool_rxnfc *cmd ,
                                      u32 *rule_locs ) 
{ 
  struct hlist_node *node2 ;
  struct ixgbe_fdir_filter *rule ;
  int cnt ;
  struct hlist_node *____ptr ;
  struct hlist_node  const  *__mptr ;
  struct ixgbe_fdir_filter *tmp ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node  const  *__mptr___0 ;
  struct ixgbe_fdir_filter *tmp___0 ;

  {
#line 2402
  cnt = 0;
#line 2405
  cmd->data = (__u64 )((1024 << (int )adapter->fdir_pballoc) + -2);
#line 2407
  ____ptr = adapter->fdir_filter_list.first;
#line 2407
  if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
#line 2407
    __mptr = (struct hlist_node  const  *)____ptr;
#line 2407
    tmp = (struct ixgbe_fdir_filter *)__mptr;
  } else {
#line 2407
    tmp = (struct ixgbe_fdir_filter *)0;
  }
#line 2407
  rule = tmp;
#line 2407
  goto ldv_56354;
  ldv_56353: ;
#line 2409
  if ((__u32 )cnt == cmd->rule_cnt) {
#line 2410
    return (-90);
  } else {

  }
#line 2411
  *(rule_locs + (unsigned long )cnt) = (u32 )rule->sw_idx;
#line 2412
  cnt = cnt + 1;
#line 2407
  ____ptr___0 = node2;
#line 2407
  if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
#line 2407
    __mptr___0 = (struct hlist_node  const  *)____ptr___0;
#line 2407
    tmp___0 = (struct ixgbe_fdir_filter *)__mptr___0;
  } else {
#line 2407
    tmp___0 = (struct ixgbe_fdir_filter *)0;
  }
#line 2407
  rule = tmp___0;
  ldv_56354: ;
#line 2407
  if ((unsigned long )rule != (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 2407
    node2 = rule->fdir_node.next;
#line 2409
    goto ldv_56353;
  } else {

  }
#line 2415
  cmd->rule_cnt = (__u32 )cnt;
#line 2417
  return (0);
}
}
#line 2420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_rss_hash_opts(struct ixgbe_adapter *adapter , struct ethtool_rxnfc *cmd ) 
{ 


  {
#line 2423
  cmd->data = 0ULL;
#line 2426
  switch (cmd->flow_type) {
  case 1U: 
#line 2428
  cmd->data = cmd->data | 192ULL;
  case 2U: ;
#line 2431
  if ((adapter->flags2 & 256U) != 0U) {
#line 2432
    cmd->data = cmd->data | 192ULL;
  } else {

  }
  case 3U: ;
  case 4U: ;
  case 9U: ;
  case 10U: ;
  case 16U: 
#line 2439
  cmd->data = cmd->data | 48ULL;
#line 2440
  goto ldv_56367;
  case 5U: 
#line 2442
  cmd->data = cmd->data | 192ULL;
  case 6U: ;
#line 2445
  if ((adapter->flags2 & 512U) != 0U) {
#line 2446
    cmd->data = cmd->data | 192ULL;
  } else {

  }
  case 7U: ;
  case 8U: ;
  case 11U: ;
  case 12U: ;
  case 17U: 
#line 2453
  cmd->data = cmd->data | 48ULL;
#line 2454
  goto ldv_56367;
  default: ;
#line 2456
  return (-22);
  }
  ldv_56367: ;
#line 2459
  return (0);
}
}
#line 2462 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_rxnfc(struct net_device *dev , struct ethtool_rxnfc *cmd , u32 *rule_locs ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int ret ;

  {
#line 2465
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 2465
  adapter = (struct ixgbe_adapter *)tmp;
#line 2466
  ret = -95;
#line 2468
  switch (cmd->cmd) {
  case 45U: 
#line 2470
  cmd->data = (__u64 )adapter->num_rx_queues;
#line 2471
  ret = 0;
#line 2472
  goto ldv_56384;
  case 46U: 
#line 2474
  cmd->rule_cnt = (__u32 )adapter->fdir_filter_count;
#line 2475
  ret = 0;
#line 2476
  goto ldv_56384;
  case 47U: 
#line 2478
  ret = ixgbe_get_ethtool_fdir_entry(adapter, cmd);
#line 2479
  goto ldv_56384;
  case 48U: 
#line 2481
  ret = ixgbe_get_ethtool_fdir_all(adapter, cmd, rule_locs);
#line 2482
  goto ldv_56384;
  case 41U: 
#line 2484
  ret = ixgbe_get_rss_hash_opts(adapter, cmd);
#line 2485
  goto ldv_56384;
  default: ;
#line 2487
  goto ldv_56384;
  }
  ldv_56384: ;
#line 2490
  return (ret);
}
}
#line 2493 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_update_ethtool_fdir_entry(struct ixgbe_adapter *adapter , struct ixgbe_fdir_filter *input ,
                                           u16 sw_idx ) 
{ 
  struct ixgbe_hw *hw ;
  struct hlist_node *node2 ;
  struct ixgbe_fdir_filter *rule ;
  struct ixgbe_fdir_filter *parent ;
  int err ;
  struct hlist_node *____ptr ;
  struct hlist_node  const  *__mptr ;
  struct ixgbe_fdir_filter *tmp ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node  const  *__mptr___0 ;
  struct ixgbe_fdir_filter *tmp___0 ;

  {
#line 2497
  hw = & adapter->hw;
#line 2500
  err = -22;
#line 2502
  parent = (struct ixgbe_fdir_filter *)0;
#line 2503
  rule = (struct ixgbe_fdir_filter *)0;
#line 2505
  ____ptr = adapter->fdir_filter_list.first;
#line 2505
  if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
#line 2505
    __mptr = (struct hlist_node  const  *)____ptr;
#line 2505
    tmp = (struct ixgbe_fdir_filter *)__mptr;
  } else {
#line 2505
    tmp = (struct ixgbe_fdir_filter *)0;
  }
#line 2505
  rule = tmp;
#line 2505
  goto ldv_56411;
  ldv_56410: ;
#line 2508
  if ((int )rule->sw_idx >= (int )sw_idx) {
#line 2509
    goto ldv_56409;
  } else {

  }
#line 2510
  parent = rule;
#line 2505
  ____ptr___0 = node2;
#line 2505
  if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
#line 2505
    __mptr___0 = (struct hlist_node  const  *)____ptr___0;
#line 2505
    tmp___0 = (struct ixgbe_fdir_filter *)__mptr___0;
  } else {
#line 2505
    tmp___0 = (struct ixgbe_fdir_filter *)0;
  }
#line 2505
  rule = tmp___0;
  ldv_56411: ;
#line 2505
  if ((unsigned long )rule != (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 2505
    node2 = rule->fdir_node.next;
#line 2507
    goto ldv_56410;
  } else {

  }
  ldv_56409: ;
#line 2514
  if ((unsigned long )rule != (unsigned long )((struct ixgbe_fdir_filter *)0) && (int )rule->sw_idx == (int )sw_idx) {
#line 2515
    if ((unsigned long )input == (unsigned long )((struct ixgbe_fdir_filter *)0) || (int )rule->filter.formatted.bkt_hash != (int )input->filter.formatted.bkt_hash) {
#line 2517
      err = ixgbe_fdir_erase_perfect_filter_82599(hw, & rule->filter, (int )sw_idx);
    } else {

    }
#line 2522
    hlist_del(& rule->fdir_node);
#line 2523
    kfree((void const   *)rule);
#line 2524
    adapter->fdir_filter_count = adapter->fdir_filter_count - 1;
  } else {

  }
#line 2531
  if ((unsigned long )input == (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 2532
    return (err);
  } else {

  }
#line 2535
  INIT_HLIST_NODE(& input->fdir_node);
#line 2538
  if ((unsigned long )parent != (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 2539
    hlist_add_behind(& input->fdir_node, & parent->fdir_node);
  } else {
#line 2541
    hlist_add_head(& input->fdir_node, & adapter->fdir_filter_list);
  }
#line 2545
  adapter->fdir_filter_count = adapter->fdir_filter_count + 1;
#line 2547
  return (0);
}
}
#line 2550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_flowspec_to_flow_type(struct ethtool_rx_flow_spec *fsp , u8 *flow_type ) 
{ 


  {
#line 2553
  switch (fsp->flow_type & 2147483647U) {
  case 1U: 
#line 2555
  *flow_type = 2U;
#line 2556
  goto ldv_56417;
  case 2U: 
#line 2558
  *flow_type = 1U;
#line 2559
  goto ldv_56417;
  case 3U: 
#line 2561
  *flow_type = 3U;
#line 2562
  goto ldv_56417;
  case 13U: ;
#line 2564
  switch ((int )fsp->h_u.usr_ip4_spec.proto) {
  case 6: 
#line 2566
  *flow_type = 2U;
#line 2567
  goto ldv_56422;
  case 17: 
#line 2569
  *flow_type = 1U;
#line 2570
  goto ldv_56422;
  case 132: 
#line 2572
  *flow_type = 3U;
#line 2573
  goto ldv_56422;
  case 0: ;
#line 2575
  if ((unsigned int )fsp->m_u.usr_ip4_spec.proto == 0U) {
#line 2576
    *flow_type = 0U;
#line 2577
    goto ldv_56422;
  } else {

  }
  default: ;
#line 2580
  return (0);
  }
  ldv_56422: ;
#line 2582
  goto ldv_56417;
  default: ;
#line 2584
  return (0);
  }
  ldv_56417: ;
#line 2587
  return (1);
}
}
#line 2590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_add_ethtool_fdir_entry(struct ixgbe_adapter *adapter , struct ethtool_rxnfc *cmd ) 
{ 
  struct ethtool_rx_flow_spec *fsp ;
  struct ixgbe_hw *hw ;
  struct ixgbe_fdir_filter *input ;
  union ixgbe_atr_input mask ;
  u8 queue ;
  int err ;
  u32 ring ;
  __u64 tmp ;
  u8 vf ;
  __u64 tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2593
  fsp = & cmd->fs;
#line 2595
  hw = & adapter->hw;
#line 2601
  if ((adapter->flags & 524288U) == 0U) {
#line 2602
    return (-95);
  } else {

  }
#line 2607
  if (fsp->ring_cookie == 0xffffffffffffffffULL) {
#line 2608
    queue = 127U;
  } else {
#line 2610
    tmp = ethtool_get_flow_spec_ring(fsp->ring_cookie);
#line 2610
    ring = (u32 )tmp;
#line 2611
    tmp___0 = ethtool_get_flow_spec_ring_vf(fsp->ring_cookie);
#line 2611
    vf = (u8 )tmp___0;
#line 2613
    if ((unsigned int )vf == 0U && (u32 )adapter->num_rx_queues <= ring) {
#line 2614
      return (-22);
    } else
#line 2615
    if ((unsigned int )vf != 0U && ((unsigned int )vf > adapter->num_vfs || (u32 )adapter->num_rx_queues_per_pool <= ring)) {
#line 2618
      return (-22);
    } else {

    }
#line 2621
    if ((unsigned int )vf == 0U) {
#line 2622
      queue = (adapter->rx_ring[ring])->reg_idx;
    } else {
#line 2624
      queue = (int )((u8 )((int )vf + -1)) * (int )((u8 )adapter->num_rx_queues_per_pool) + (int )((u8 )ring);
    }
  }
#line 2629
  if (fsp->location >= (__u32 )((1024 << (int )adapter->fdir_pballoc) + -2)) {
#line 2630
    if ((int )adapter->msg_enable & 1) {
#line 2630
      netdev_err((struct net_device  const  *)adapter->netdev, "Location out of range\n");
    } else {

    }
#line 2631
    return (-22);
  } else {

  }
#line 2634
  tmp___1 = kzalloc(64UL, 32U);
#line 2634
  input = (struct ixgbe_fdir_filter *)tmp___1;
#line 2635
  if ((unsigned long )input == (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 2636
    return (-12);
  } else {

  }
#line 2638
  memset((void *)(& mask), 0, 44UL);
#line 2641
  input->sw_idx = (u16 )fsp->location;
#line 2644
  tmp___2 = ixgbe_flowspec_to_flow_type(fsp, & input->filter.formatted.flow_type);
#line 2644
  if (tmp___2 == 0) {
#line 2646
    if ((int )adapter->msg_enable & 1) {
#line 2646
      netdev_err((struct net_device  const  *)adapter->netdev, "Unrecognized flow type\n");
    } else {

    }
#line 2647
    goto err_out;
  } else {

  }
#line 2650
  mask.formatted.flow_type = 7U;
#line 2653
  if ((unsigned int )input->filter.formatted.flow_type == 0U) {
#line 2654
    mask.formatted.flow_type = (unsigned int )mask.formatted.flow_type & 4U;
  } else {

  }
#line 2657
  input->filter.formatted.src_ip[0] = fsp->h_u.tcp_ip4_spec.ip4src;
#line 2658
  mask.formatted.src_ip[0] = fsp->m_u.tcp_ip4_spec.ip4src;
#line 2659
  input->filter.formatted.dst_ip[0] = fsp->h_u.tcp_ip4_spec.ip4dst;
#line 2660
  mask.formatted.dst_ip[0] = fsp->m_u.tcp_ip4_spec.ip4dst;
#line 2661
  input->filter.formatted.src_port = fsp->h_u.tcp_ip4_spec.psrc;
#line 2662
  mask.formatted.src_port = fsp->m_u.tcp_ip4_spec.psrc;
#line 2663
  input->filter.formatted.dst_port = fsp->h_u.tcp_ip4_spec.pdst;
#line 2664
  mask.formatted.dst_port = fsp->m_u.tcp_ip4_spec.pdst;
#line 2666
  if ((int )fsp->flow_type < 0) {
#line 2667
    tmp___3 = __fswab32(fsp->h_ext.data[1]);
#line 2667
    input->filter.formatted.vm_pool = (unsigned char )tmp___3;
#line 2669
    tmp___4 = __fswab32(fsp->m_ext.data[1]);
#line 2669
    mask.formatted.vm_pool = (unsigned char )tmp___4;
#line 2671
    input->filter.formatted.vlan_id = fsp->h_ext.vlan_tci;
#line 2672
    mask.formatted.vlan_id = fsp->m_ext.vlan_tci;
#line 2673
    input->filter.formatted.flex_bytes = fsp->h_ext.vlan_etype;
#line 2675
    mask.formatted.flex_bytes = fsp->m_ext.vlan_etype;
  } else {

  }
#line 2679
  if (fsp->ring_cookie == 0xffffffffffffffffULL) {
#line 2680
    input->action = 127U;
  } else {
#line 2682
    input->action = (u16 )fsp->ring_cookie;
  }
#line 2684
  spin_lock(& adapter->fdir_perfect_lock);
#line 2686
  tmp___6 = hlist_empty((struct hlist_head  const  *)(& adapter->fdir_filter_list));
#line 2686
  if (tmp___6 != 0) {
#line 2688
    memcpy((void *)(& adapter->fdir_mask), (void const   *)(& mask), 44UL);
#line 2689
    err = ixgbe_fdir_set_input_mask_82599(hw, & mask);
#line 2690
    if (err != 0) {
#line 2691
      if ((int )adapter->msg_enable & 1) {
#line 2691
        netdev_err((struct net_device  const  *)adapter->netdev, "Error writing mask\n");
      } else {

      }
#line 2692
      goto err_out_w_lock;
    } else {

    }
  } else {
#line 2694
    tmp___5 = memcmp((void const   *)(& adapter->fdir_mask), (void const   *)(& mask),
                     44UL);
#line 2694
    if (tmp___5 != 0) {
#line 2695
      if ((int )adapter->msg_enable & 1) {
#line 2695
        netdev_err((struct net_device  const  *)adapter->netdev, "Only one mask supported per port\n");
      } else {

      }
#line 2696
      goto err_out_w_lock;
    } else {

    }
  }
#line 2700
  ixgbe_atr_compute_perfect_hash_82599(& input->filter, & mask);
#line 2703
  err = ixgbe_fdir_write_perfect_filter_82599(hw, & input->filter, (int )input->sw_idx,
                                              (int )queue);
#line 2705
  if (err != 0) {
#line 2706
    goto err_out_w_lock;
  } else {

  }
#line 2708
  ixgbe_update_ethtool_fdir_entry(adapter, input, (int )input->sw_idx);
#line 2710
  spin_unlock(& adapter->fdir_perfect_lock);
#line 2712
  return (err);
  err_out_w_lock: 
#line 2714
  spin_unlock(& adapter->fdir_perfect_lock);
  err_out: 
#line 2716
  kfree((void const   *)input);
#line 2717
  return (-22);
}
}
#line 2720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_del_ethtool_fdir_entry(struct ixgbe_adapter *adapter , struct ethtool_rxnfc *cmd ) 
{ 
  struct ethtool_rx_flow_spec *fsp ;
  int err ;

  {
#line 2723
  fsp = & cmd->fs;
#line 2727
  spin_lock(& adapter->fdir_perfect_lock);
#line 2728
  err = ixgbe_update_ethtool_fdir_entry(adapter, (struct ixgbe_fdir_filter *)0, (int )((u16 )fsp->location));
#line 2729
  spin_unlock(& adapter->fdir_perfect_lock);
#line 2731
  return (err);
}
}
#line 2736 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_rss_hash_opt(struct ixgbe_adapter *adapter , struct ethtool_rxnfc *nfc ) 
{ 
  u32 flags2 ;
  struct ixgbe_hw *hw ;
  u32 mrqc ;
  unsigned int pf_pool ;

  {
#line 2739
  flags2 = adapter->flags2;
#line 2745
  if ((nfc->data & 0xffffffffffffff0fULL) != 0ULL) {
#line 2747
    return (-22);
  } else {

  }
#line 2749
  switch (nfc->flow_type) {
  case 1U: ;
  case 5U: ;
#line 2752
  if ((((nfc->data & 16ULL) == 0ULL || (nfc->data & 32ULL) == 0ULL) || (nfc->data & 64ULL) == 0ULL) || (nfc->data & 128ULL) == 0ULL) {
#line 2756
    return (-22);
  } else {

  }
#line 2757
  goto ldv_56455;
  case 2U: ;
#line 2759
  if ((nfc->data & 16ULL) == 0ULL || (nfc->data & 32ULL) == 0ULL) {
#line 2761
    return (-22);
  } else {

  }
#line 2762
  switch (nfc->data & 192ULL) {
  case 0ULL: 
#line 2764
  flags2 = flags2 & 4294967039U;
#line 2765
  goto ldv_56458;
  case 192ULL: 
#line 2767
  flags2 = flags2 | 256U;
#line 2768
  goto ldv_56458;
  default: ;
#line 2770
  return (-22);
  }
  ldv_56458: ;
#line 2772
  goto ldv_56455;
  case 6U: ;
#line 2774
  if ((nfc->data & 16ULL) == 0ULL || (nfc->data & 32ULL) == 0ULL) {
#line 2776
    return (-22);
  } else {

  }
#line 2777
  switch (nfc->data & 192ULL) {
  case 0ULL: 
#line 2779
  flags2 = flags2 & 4294966783U;
#line 2780
  goto ldv_56463;
  case 192ULL: 
#line 2782
  flags2 = flags2 | 512U;
#line 2783
  goto ldv_56463;
  default: ;
#line 2785
  return (-22);
  }
  ldv_56463: ;
#line 2787
  goto ldv_56455;
  case 4U: ;
  case 9U: ;
  case 10U: ;
  case 3U: ;
  case 8U: ;
  case 11U: ;
  case 12U: ;
  case 7U: ;
#line 2796
  if ((((nfc->data & 16ULL) == 0ULL || (nfc->data & 32ULL) == 0ULL) || (nfc->data & 64ULL) != 0ULL) || (nfc->data & 128ULL) != 0ULL) {
#line 2800
    return (-22);
  } else {

  }
#line 2801
  goto ldv_56455;
  default: ;
#line 2803
  return (-22);
  }
  ldv_56455: ;
#line 2807
  if (adapter->flags2 != flags2) {
#line 2808
    hw = & adapter->hw;
#line 2810
    pf_pool = adapter->num_vfs;
#line 2812
    if ((unsigned int )hw->mac.type > 3U && (adapter->flags & 8388608U) != 0U) {
#line 2814
      mrqc = ixgbe_read_reg(hw, (pf_pool + 3328U) * 4U);
    } else {
#line 2816
      mrqc = ixgbe_read_reg(hw, 22552U);
    }
#line 2818
    if ((flags2 & 768U) != 0U && (adapter->flags2 & 768U) == 0U) {
#line 2820
      if ((int )adapter->msg_enable & 1) {
#line 2820
        netdev_warn((struct net_device  const  *)adapter->netdev, "enabling UDP RSS: fragmented packets may arrive out of order to the stack above\n");
      } else {

      }
    } else {

    }
#line 2822
    adapter->flags2 = flags2;
#line 2825
    mrqc = mrqc | 3342336U;
#line 2830
    mrqc = mrqc & 4282384383U;
#line 2833
    if ((flags2 & 256U) != 0U) {
#line 2834
      mrqc = mrqc | 4194304U;
    } else {

    }
#line 2836
    if ((flags2 & 512U) != 0U) {
#line 2837
      mrqc = mrqc | 8388608U;
    } else {

    }
#line 2839
    if ((unsigned int )hw->mac.type > 3U && (adapter->flags & 8388608U) != 0U) {
#line 2841
      ixgbe_write_reg(hw, (pf_pool + 3328U) * 4U, mrqc);
    } else {
#line 2843
      ixgbe_write_reg(hw, 22552U, mrqc);
    }
  } else {

  }
#line 2846
  return (0);
}
}
#line 2849 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_rxnfc(struct net_device *dev , struct ethtool_rxnfc *cmd ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int ret ;

  {
#line 2851
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 2851
  adapter = (struct ixgbe_adapter *)tmp;
#line 2852
  ret = -95;
#line 2854
  switch (cmd->cmd) {
  case 50U: 
#line 2856
  ret = ixgbe_add_ethtool_fdir_entry(adapter, cmd);
#line 2857
  goto ldv_56485;
  case 49U: 
#line 2859
  ret = ixgbe_del_ethtool_fdir_entry(adapter, cmd);
#line 2860
  goto ldv_56485;
  case 42U: 
#line 2862
  ret = ixgbe_set_rss_hash_opt(adapter, cmd);
#line 2863
  goto ldv_56485;
  default: ;
#line 2865
  goto ldv_56485;
  }
  ldv_56485: ;
#line 2868
  return (ret);
}
}
#line 2871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static u32 ixgbe_get_rxfh_key_size(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 2873
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2873
  adapter = (struct ixgbe_adapter *)tmp;
#line 2875
  return (40U);
}
}
#line 2878 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static u32 ixgbe_rss_indir_size(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  u32 tmp___0 ;

  {
#line 2880
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2880
  adapter = (struct ixgbe_adapter *)tmp;
#line 2882
  tmp___0 = ixgbe_rss_indir_tbl_entries(adapter);
#line 2882
  return (tmp___0);
}
}
#line 2885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_reta(struct ixgbe_adapter *adapter , u32 *indir ) 
{ 
  int i ;
  int reta_size ;
  u32 tmp ;

  {
#line 2887
  tmp = ixgbe_rss_indir_tbl_entries(adapter);
#line 2887
  reta_size = (int )tmp;
#line 2889
  i = 0;
#line 2889
  goto ldv_56504;
  ldv_56503: 
#line 2890
  *(indir + (unsigned long )i) = (u32 )adapter->rss_indir_tbl[i];
#line 2889
  i = i + 1;
  ldv_56504: ;
#line 2889
  if (i < reta_size) {
#line 2891
    goto ldv_56503;
  } else {

  }

#line 2896
  return;
}
}
#line 2893 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_rxfh(struct net_device *netdev , u32 *indir , u8 *key , u8 *hfunc ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  u32 tmp___0 ;

  {
#line 2896
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2896
  adapter = (struct ixgbe_adapter *)tmp;
#line 2898
  if ((unsigned long )hfunc != (unsigned long )((u8 *)0U)) {
#line 2899
    *hfunc = 1U;
  } else {

  }
#line 2901
  if ((unsigned long )indir != (unsigned long )((u32 *)0U)) {
#line 2902
    ixgbe_get_reta(adapter, indir);
  } else {

  }
#line 2904
  if ((unsigned long )key != (unsigned long )((u8 *)0U)) {
#line 2905
    tmp___0 = ixgbe_get_rxfh_key_size(netdev);
#line 2905
    memcpy((void *)key, (void const   *)(& adapter->rss_key), (size_t )tmp___0);
  } else {

  }
#line 2907
  return (0);
}
}
#line 2910 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_ts_info(struct net_device *dev , struct ethtool_ts_info *info ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2913
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 2913
  adapter = (struct ixgbe_adapter *)tmp;
#line 2915
  switch ((unsigned int )adapter->hw.mac.type) {
  case 4U: ;
  case 5U: ;
  case 3U: ;
  case 2U: 
#line 2920
  info->so_timestamping = 95U;
#line 2928
  if ((unsigned long )adapter->ptp_clock != (unsigned long )((struct ptp_clock *)0)) {
#line 2929
    info->phc_index = ptp_clock_index(adapter->ptp_clock);
  } else {
#line 2931
    info->phc_index = -1;
  }
#line 2933
  info->tx_types = 3U;
#line 2937
  info->rx_filters = 32753U;
#line 2950
  goto ldv_56522;
  default: 
#line 2952
  tmp___0 = ethtool_op_get_ts_info(dev, info);
#line 2952
  return (tmp___0);
  }
  ldv_56522: ;
#line 2954
  return (0);
}
}
#line 2957 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static unsigned int ixgbe_max_channels(struct ixgbe_adapter *adapter ) 
{ 
  unsigned int max_combined ;
  u8 tcs ;
  int tmp ;
  u8 tmp___0 ;

  {
#line 2960
  tmp = netdev_get_num_tc(adapter->netdev);
#line 2960
  tcs = (u8 )tmp;
#line 2962
  if ((adapter->flags & 8U) == 0U) {
#line 2964
    max_combined = 1U;
  } else
#line 2965
  if ((adapter->flags & 8388608U) != 0U) {
#line 2967
    max_combined = 1U;
  } else
#line 2968
  if ((unsigned int )tcs > 1U) {
#line 2970
    if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 2972
      max_combined = 4U;
    } else
#line 2973
    if ((unsigned int )tcs > 4U) {
#line 2975
      max_combined = 8U;
    } else {
#line 2978
      max_combined = 16U;
    }
  } else
#line 2980
  if (adapter->atr_sample_rate != 0U) {
#line 2982
    max_combined = 63U;
  } else {
#line 2985
    tmp___0 = ixgbe_max_rss_indices(adapter);
#line 2985
    max_combined = (unsigned int )tmp___0;
  }
#line 2988
  return (max_combined);
}
}
#line 2991 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_channels(struct net_device *dev , struct ethtool_channels *ch ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2994
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 2994
  adapter = (struct ixgbe_adapter *)tmp;
#line 2997
  ch->max_combined = ixgbe_max_channels(adapter);
#line 3000
  if ((adapter->flags & 8U) != 0U) {
#line 3001
    ch->max_other = 1U;
#line 3002
    ch->other_count = 1U;
  } else {

  }
#line 3006
  ch->combined_count = (__u32 )adapter->ring_feature[2].indices;
#line 3009
  if (ch->combined_count == 1U) {
#line 3010
    return;
  } else {

  }
#line 3013
  if ((adapter->flags & 8388608U) != 0U) {
#line 3014
    return;
  } else {

  }
#line 3017
  tmp___0 = netdev_get_num_tc(dev);
#line 3017
  if (tmp___0 > 1) {
#line 3018
    return;
  } else {

  }
#line 3021
  if (adapter->atr_sample_rate == 0U) {
#line 3022
    return;
  } else {

  }
#line 3025
  ch->combined_count = (__u32 )adapter->ring_feature[3].indices;
#line 3026
  return;
}
}
#line 3028 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_channels(struct net_device *dev , struct ethtool_channels *ch ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  unsigned int count ;
  u8 max_rss_indices ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 3031
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 3031
  adapter = (struct ixgbe_adapter *)tmp;
#line 3032
  count = ch->combined_count;
#line 3033
  tmp___0 = ixgbe_max_rss_indices(adapter);
#line 3033
  max_rss_indices = tmp___0;
#line 3036
  if ((count == 0U || ch->rx_count != 0U) || ch->tx_count != 0U) {
#line 3037
    return (-22);
  } else {

  }
#line 3040
  if (ch->other_count != 1U) {
#line 3041
    return (-22);
  } else {

  }
#line 3044
  tmp___1 = ixgbe_max_channels(adapter);
#line 3044
  if (tmp___1 < count) {
#line 3045
    return (-22);
  } else {

  }
#line 3048
  adapter->ring_feature[3].limit = (u16 )count;
#line 3051
  if ((unsigned int )max_rss_indices < count) {
#line 3052
    count = (unsigned int )max_rss_indices;
  } else {

  }
#line 3053
  adapter->ring_feature[2].limit = (u16 )count;
#line 3057
  if (count > 8U) {
#line 3058
    count = 8U;
  } else {

  }
#line 3059
  adapter->ring_feature[4].limit = (u16 )count;
#line 3063
  tmp___2 = netdev_get_num_tc(dev);
#line 3063
  tmp___3 = ixgbe_setup_tc(dev, (int )((u8 )tmp___2));
#line 3063
  return (tmp___3);
}
}
#line 3066 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_module_info(struct net_device *dev , struct ethtool_modinfo *modinfo ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  s32 status ;
  u8 sff8472_rev ;
  u8 addr_mode ;
  bool page_swap ;

  {
#line 3069
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 3069
  adapter = (struct ixgbe_adapter *)tmp;
#line 3070
  hw = & adapter->hw;
#line 3073
  page_swap = 0;
#line 3076
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 94, & sff8472_rev);
#line 3079
  if (status != 0) {
#line 3080
    return (-5);
  } else {

  }
#line 3083
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 92, & addr_mode);
#line 3086
  if (status != 0) {
#line 3087
    return (-5);
  } else {

  }
#line 3089
  if (((int )addr_mode & 4) != 0) {
#line 3090
    if ((int )adapter->msg_enable & 1) {
#line 3090
      netdev_err((struct net_device  const  *)adapter->netdev, "Address change required to access page 0xA2, but not supported. Please report the module type to the driver maintainers.\n");
    } else {

    }
#line 3091
    page_swap = 1;
  } else {

  }
#line 3094
  if ((unsigned int )sff8472_rev == 0U || (int )page_swap) {
#line 3096
    modinfo->type = 1U;
#line 3097
    modinfo->eeprom_len = 256U;
  } else {
#line 3100
    modinfo->type = 2U;
#line 3101
    modinfo->eeprom_len = 512U;
  }
#line 3104
  return (0);
}
}
#line 3107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_module_eeprom(struct net_device *dev , struct ethtool_eeprom *ee ,
                                   u8 *data ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  s32 status ;
  u8 databyte ;
  int i ;
  int tmp___0 ;

  {
#line 3111
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 3111
  adapter = (struct ixgbe_adapter *)tmp;
#line 3112
  hw = & adapter->hw;
#line 3113
  status = -17;
#line 3114
  databyte = 255U;
#line 3115
  i = 0;
#line 3117
  if (ee->len == 0U) {
#line 3118
    return (-22);
  } else {

  }
#line 3120
  i = (int )ee->offset;
#line 3120
  goto ldv_56562;
  ldv_56561: 
#line 3122
  tmp___0 = constant_test_bit(7L, (unsigned long const volatile   *)(& adapter->state));
#line 3122
  if (tmp___0 != 0) {
#line 3123
    return (-16);
  } else {

  }
#line 3125
  if (i <= 255) {
#line 3126
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw, (int )((u8 )i), & databyte);
  } else {
#line 3128
    status = (*(hw->phy.ops.read_i2c_sff8472))(hw, (int )((u8 )i), & databyte);
  }
#line 3130
  if (status != 0) {
#line 3131
    return (-5);
  } else {

  }
#line 3133
  *(data + (unsigned long )((__u32 )i - ee->offset)) = databyte;
#line 3120
  i = i + 1;
  ldv_56562: ;
#line 3120
  if ((__u32 )i < ee->offset + ee->len) {
#line 3122
    goto ldv_56561;
  } else {

  }

#line 3136
  return (0);
}
}
#line 3139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static struct ethtool_ops  const  ixgbe_ethtool_ops  = 
#line 3139
     {& ixgbe_get_settings, & ixgbe_set_settings, & ixgbe_get_drvinfo, & ixgbe_get_regs_len,
    & ixgbe_get_regs, & ixgbe_get_wol, & ixgbe_set_wol, & ixgbe_get_msglevel, & ixgbe_set_msglevel,
    & ixgbe_nway_reset, & ethtool_op_get_link, & ixgbe_get_eeprom_len, & ixgbe_get_eeprom,
    & ixgbe_set_eeprom, & ixgbe_get_coalesce, & ixgbe_set_coalesce, & ixgbe_get_ringparam,
    & ixgbe_set_ringparam, & ixgbe_get_pauseparam, & ixgbe_set_pauseparam, & ixgbe_diag_test,
    & ixgbe_get_strings, & ixgbe_set_phys_id, & ixgbe_get_ethtool_stats, 0, 0, 0,
    0, & ixgbe_get_sset_count, & ixgbe_get_rxnfc, & ixgbe_set_rxnfc, 0, 0, & ixgbe_get_rxfh_key_size,
    & ixgbe_rss_indir_size, & ixgbe_get_rxfh, 0, & ixgbe_get_channels, & ixgbe_set_channels,
    0, 0, 0, & ixgbe_get_ts_info, & ixgbe_get_module_info, & ixgbe_get_module_eeprom,
    0, 0, 0, 0};
#line 3177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
void ixgbe_set_ethtool_ops(struct net_device *netdev ) 
{ 


  {
#line 3179
  netdev->ethtool_ops = & ixgbe_ethtool_ops;
#line 3180
  return;
}
}
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void disable_suitable_irq_7(int line , void *data ) 
{ 


  {
#line 333
  if (ldv_irq_7_0 != 0 && line == ldv_irq_line_7_0) {
#line 334
    ldv_irq_7_0 = 0;
#line 335
    return;
  } else {

  }
#line 337
  if (ldv_irq_7_1 != 0 && line == ldv_irq_line_7_1) {
#line 338
    ldv_irq_7_1 = 0;
#line 339
    return;
  } else {

  }
#line 341
  if (ldv_irq_7_2 != 0 && line == ldv_irq_line_7_2) {
#line 342
    ldv_irq_7_2 = 0;
#line 343
    return;
  } else {

  }
#line 345
  if (ldv_irq_7_3 != 0 && line == ldv_irq_line_7_3) {
#line 346
    ldv_irq_7_3 = 0;
#line 347
    return;
  } else {

  }
#line 349
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
int ldv_irq_6(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 355
  tmp = __VERIFIER_nondet_int();
#line 355
  irq_retval = (irqreturn_t )tmp;
#line 357
  if (state != 0) {
#line 358
    tmp___0 = __VERIFIER_nondet_int();
#line 358
    switch (tmp___0) {
    case 0: ;
#line 360
    if (state == 1) {
#line 361
      LDV_IN_INTERRUPT = 2;
#line 362
      irq_retval = ixgbe_test_intr(line, data);
#line 363
      LDV_IN_INTERRUPT = 1;
#line 364
      return (state);
    } else {

    }
#line 367
    goto ldv_56579;
    default: 
#line 368
    ldv_stop();
    }
    ldv_56579: ;
  } else {

  }
#line 371
  return (state);
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void activate_suitable_irq_6(int line , void *data ) 
{ 


  {
#line 376
  if (ldv_irq_6_0 == 0) {
#line 377
    ldv_irq_line_6_0 = line;
#line 378
    ldv_irq_data_6_0 = data;
#line 379
    ldv_irq_6_0 = 1;
#line 380
    return;
  } else {

  }
#line 382
  if (ldv_irq_6_1 == 0) {
#line 383
    ldv_irq_line_6_1 = line;
#line 384
    ldv_irq_data_6_1 = data;
#line 385
    ldv_irq_6_1 = 1;
#line 386
    return;
  } else {

  }
#line 388
  if (ldv_irq_6_2 == 0) {
#line 389
    ldv_irq_line_6_2 = line;
#line 390
    ldv_irq_data_6_2 = data;
#line 391
    ldv_irq_6_2 = 1;
#line 392
    return;
  } else {

  }
#line 394
  if (ldv_irq_6_3 == 0) {
#line 395
    ldv_irq_line_6_3 = line;
#line 396
    ldv_irq_data_6_3 = data;
#line 397
    ldv_irq_6_3 = 1;
#line 398
    return;
  } else {

  }
#line 400
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void choose_interrupt_5(void) 
{ 
  int tmp ;

  {
#line 405
  tmp = __VERIFIER_nondet_int();
#line 405
  switch (tmp) {
  case 0: 
#line 407
  ldv_irq_5_0 = ldv_irq_5(ldv_irq_5_0, ldv_irq_line_5_0, ldv_irq_data_5_0);
#line 409
  goto ldv_56589;
  case 1: 
#line 411
  ldv_irq_5_0 = ldv_irq_5(ldv_irq_5_1, ldv_irq_line_5_1, ldv_irq_data_5_1);
#line 413
  goto ldv_56589;
  case 2: 
#line 415
  ldv_irq_5_0 = ldv_irq_5(ldv_irq_5_2, ldv_irq_line_5_2, ldv_irq_data_5_2);
#line 417
  goto ldv_56589;
  case 3: 
#line 419
  ldv_irq_5_0 = ldv_irq_5(ldv_irq_5_3, ldv_irq_line_5_3, ldv_irq_data_5_3);
#line 421
  goto ldv_56589;
  default: 
#line 422
  ldv_stop();
  }
  ldv_56589: ;
#line 424
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void disable_suitable_irq_5(int line , void *data ) 
{ 


  {
#line 429
  if (ldv_irq_5_0 != 0 && line == ldv_irq_line_5_0) {
#line 430
    ldv_irq_5_0 = 0;
#line 431
    return;
  } else {

  }
#line 433
  if (ldv_irq_5_1 != 0 && line == ldv_irq_line_5_1) {
#line 434
    ldv_irq_5_1 = 0;
#line 435
    return;
  } else {

  }
#line 437
  if (ldv_irq_5_2 != 0 && line == ldv_irq_line_5_2) {
#line 438
    ldv_irq_5_2 = 0;
#line 439
    return;
  } else {

  }
#line 441
  if (ldv_irq_5_3 != 0 && line == ldv_irq_line_5_3) {
#line 442
    ldv_irq_5_3 = 0;
#line 443
    return;
  } else {

  }
#line 445
  return;
}
}
#line 449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
int ldv_irq_5(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 451
  tmp = __VERIFIER_nondet_int();
#line 451
  irq_retval = (irqreturn_t )tmp;
#line 453
  if (state != 0) {
#line 454
    tmp___0 = __VERIFIER_nondet_int();
#line 454
    switch (tmp___0) {
    case 0: ;
#line 456
    if (state == 1) {
#line 457
      LDV_IN_INTERRUPT = 2;
#line 458
      irq_retval = ixgbe_test_intr(line, data);
#line 459
      LDV_IN_INTERRUPT = 1;
#line 460
      return (state);
    } else {

    }
#line 463
    goto ldv_56605;
    default: 
#line 464
    ldv_stop();
    }
    ldv_56605: ;
  } else {

  }
#line 467
  return (state);
}
}
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void ldv_initialize_ethtool_ops_35(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 472
  tmp = ldv_init_zalloc(36UL);
#line 472
  ixgbe_ethtool_ops_group0 = (struct ethtool_ringparam *)tmp;
#line 473
  tmp___0 = ldv_init_zalloc(16UL);
#line 473
  ixgbe_ethtool_ops_group2 = (struct ethtool_eeprom *)tmp___0;
#line 474
  tmp___1 = ldv_init_zalloc(44UL);
#line 474
  ixgbe_ethtool_ops_group1 = (struct ethtool_cmd *)tmp___1;
#line 475
  tmp___2 = ldv_init_zalloc(16UL);
#line 475
  ixgbe_ethtool_ops_group3 = (struct ethtool_pauseparam *)tmp___2;
#line 476
  tmp___3 = ldv_init_zalloc(36UL);
#line 476
  ixgbe_ethtool_ops_group4 = (struct ethtool_channels *)tmp___3;
#line 477
  tmp___4 = ldv_init_zalloc(92UL);
#line 477
  ixgbe_ethtool_ops_group5 = (struct ethtool_coalesce *)tmp___4;
#line 478
  tmp___5 = ldv_init_zalloc(3008UL);
#line 478
  ixgbe_ethtool_ops_group6 = (struct net_device *)tmp___5;
#line 479
  tmp___6 = ldv_init_zalloc(192UL);
#line 479
  ixgbe_ethtool_ops_group7 = (struct ethtool_rxnfc *)tmp___6;
#line 480
  tmp___7 = ldv_init_zalloc(20UL);
#line 480
  ixgbe_ethtool_ops_group8 = (struct ethtool_wolinfo *)tmp___7;
#line 481
  return;
}
}
#line 483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void activate_suitable_irq_7(int line , void *data ) 
{ 


  {
#line 484
  if (ldv_irq_7_0 == 0) {
#line 485
    ldv_irq_line_7_0 = line;
#line 486
    ldv_irq_data_7_0 = data;
#line 487
    ldv_irq_7_0 = 1;
#line 488
    return;
  } else {

  }
#line 490
  if (ldv_irq_7_1 == 0) {
#line 491
    ldv_irq_line_7_1 = line;
#line 492
    ldv_irq_data_7_1 = data;
#line 493
    ldv_irq_7_1 = 1;
#line 494
    return;
  } else {

  }
#line 496
  if (ldv_irq_7_2 == 0) {
#line 497
    ldv_irq_line_7_2 = line;
#line 498
    ldv_irq_data_7_2 = data;
#line 499
    ldv_irq_7_2 = 1;
#line 500
    return;
  } else {

  }
#line 502
  if (ldv_irq_7_3 == 0) {
#line 503
    ldv_irq_line_7_3 = line;
#line 504
    ldv_irq_data_7_3 = data;
#line 505
    ldv_irq_7_3 = 1;
#line 506
    return;
  } else {

  }
#line 508
  return;
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
int reg_check_6(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 513
  if ((unsigned long )handler == (unsigned long )(& ixgbe_test_intr)) {
#line 514
    return (1);
  } else {

  }
#line 516
  return (0);
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
int reg_check_7(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 521
  if ((unsigned long )handler == (unsigned long )(& ixgbe_test_intr)) {
#line 522
    return (1);
  } else {

  }
#line 524
  return (0);
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void choose_interrupt_6(void) 
{ 
  int tmp ;

  {
#line 529
  tmp = __VERIFIER_nondet_int();
#line 529
  switch (tmp) {
  case 0: 
#line 531
  ldv_irq_6_0 = ldv_irq_6(ldv_irq_6_0, ldv_irq_line_6_0, ldv_irq_data_6_0);
#line 533
  goto ldv_56628;
  case 1: 
#line 535
  ldv_irq_6_0 = ldv_irq_6(ldv_irq_6_1, ldv_irq_line_6_1, ldv_irq_data_6_1);
#line 537
  goto ldv_56628;
  case 2: 
#line 539
  ldv_irq_6_0 = ldv_irq_6(ldv_irq_6_2, ldv_irq_line_6_2, ldv_irq_data_6_2);
#line 541
  goto ldv_56628;
  case 3: 
#line 543
  ldv_irq_6_0 = ldv_irq_6(ldv_irq_6_3, ldv_irq_line_6_3, ldv_irq_data_6_3);
#line 545
  goto ldv_56628;
  default: 
#line 546
  ldv_stop();
  }
  ldv_56628: ;
#line 548
  return;
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void disable_suitable_irq_6(int line , void *data ) 
{ 


  {
#line 553
  if (ldv_irq_6_0 != 0 && line == ldv_irq_line_6_0) {
#line 554
    ldv_irq_6_0 = 0;
#line 555
    return;
  } else {

  }
#line 557
  if (ldv_irq_6_1 != 0 && line == ldv_irq_line_6_1) {
#line 558
    ldv_irq_6_1 = 0;
#line 559
    return;
  } else {

  }
#line 561
  if (ldv_irq_6_2 != 0 && line == ldv_irq_line_6_2) {
#line 562
    ldv_irq_6_2 = 0;
#line 563
    return;
  } else {

  }
#line 565
  if (ldv_irq_6_3 != 0 && line == ldv_irq_line_6_3) {
#line 566
    ldv_irq_6_3 = 0;
#line 567
    return;
  } else {

  }
#line 569
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void activate_suitable_irq_5(int line , void *data ) 
{ 


  {
#line 574
  if (ldv_irq_5_0 == 0) {
#line 575
    ldv_irq_line_5_0 = line;
#line 576
    ldv_irq_data_5_0 = data;
#line 577
    ldv_irq_5_0 = 1;
#line 578
    return;
  } else {

  }
#line 580
  if (ldv_irq_5_1 == 0) {
#line 581
    ldv_irq_line_5_1 = line;
#line 582
    ldv_irq_data_5_1 = data;
#line 583
    ldv_irq_5_1 = 1;
#line 584
    return;
  } else {

  }
#line 586
  if (ldv_irq_5_2 == 0) {
#line 587
    ldv_irq_line_5_2 = line;
#line 588
    ldv_irq_data_5_2 = data;
#line 589
    ldv_irq_5_2 = 1;
#line 590
    return;
  } else {

  }
#line 592
  if (ldv_irq_5_3 == 0) {
#line 593
    ldv_irq_line_5_3 = line;
#line 594
    ldv_irq_data_5_3 = data;
#line 595
    ldv_irq_5_3 = 1;
#line 596
    return;
  } else {

  }
#line 598
  return;
}
}
#line 602 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
int ldv_irq_7(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 604
  tmp = __VERIFIER_nondet_int();
#line 604
  irq_retval = (irqreturn_t )tmp;
#line 606
  if (state != 0) {
#line 607
    tmp___0 = __VERIFIER_nondet_int();
#line 607
    switch (tmp___0) {
    case 0: ;
#line 609
    if (state == 1) {
#line 610
      LDV_IN_INTERRUPT = 2;
#line 611
      irq_retval = ixgbe_test_intr(line, data);
#line 612
      LDV_IN_INTERRUPT = 1;
#line 613
      return (state);
    } else {

    }
#line 616
    goto ldv_56648;
    default: 
#line 617
    ldv_stop();
    }
    ldv_56648: ;
  } else {

  }
#line 620
  return (state);
}
}
#line 624 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void choose_interrupt_7(void) 
{ 
  int tmp ;

  {
#line 625
  tmp = __VERIFIER_nondet_int();
#line 625
  switch (tmp) {
  case 0: 
#line 627
  ldv_irq_7_0 = ldv_irq_7(ldv_irq_7_0, ldv_irq_line_7_0, ldv_irq_data_7_0);
#line 629
  goto ldv_56654;
  case 1: 
#line 631
  ldv_irq_7_0 = ldv_irq_7(ldv_irq_7_1, ldv_irq_line_7_1, ldv_irq_data_7_1);
#line 633
  goto ldv_56654;
  case 2: 
#line 635
  ldv_irq_7_0 = ldv_irq_7(ldv_irq_7_2, ldv_irq_line_7_2, ldv_irq_data_7_2);
#line 637
  goto ldv_56654;
  case 3: 
#line 639
  ldv_irq_7_0 = ldv_irq_7(ldv_irq_7_3, ldv_irq_line_7_3, ldv_irq_data_7_3);
#line 641
  goto ldv_56654;
  default: 
#line 642
  ldv_stop();
  }
  ldv_56654: ;
#line 644
  return;
}
}
#line 648 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
int reg_check_5(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 649
  if ((unsigned long )handler == (unsigned long )(& ixgbe_test_intr)) {
#line 650
    return (1);
  } else {

  }
#line 652
  return (0);
}
}
#line 657 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void ldv_main_exported_35(void) 
{ 
  u64 *ldvarg335 ;
  void *tmp ;
  u32 *ldvarg342 ;
  void *tmp___0 ;
  struct ethtool_regs *ldvarg328 ;
  void *tmp___1 ;
  struct ethtool_stats *ldvarg330 ;
  void *tmp___2 ;
  u8 *ldvarg325 ;
  void *tmp___3 ;
  struct ethtool_ts_info *ldvarg338 ;
  void *tmp___4 ;
  struct ethtool_modinfo *ldvarg332 ;
  void *tmp___5 ;
  void *ldvarg327 ;
  void *tmp___6 ;
  u8 *ldvarg340 ;
  void *tmp___7 ;
  u8 *ldvarg333 ;
  void *tmp___8 ;
  u64 *ldvarg329 ;
  void *tmp___9 ;
  struct ethtool_test *ldvarg336 ;
  void *tmp___10 ;
  u32 ldvarg334 ;
  struct ethtool_drvinfo *ldvarg331 ;
  void *tmp___11 ;
  u8 *ldvarg341 ;
  void *tmp___12 ;
  u8 *ldvarg326 ;
  void *tmp___13 ;
  u32 *ldvarg345 ;
  void *tmp___14 ;
  u8 *ldvarg339 ;
  void *tmp___15 ;
  enum ethtool_phys_id_state ldvarg344 ;
  u32 ldvarg337 ;
  int ldvarg343 ;
  int tmp___16 ;

  {
#line 658
  tmp = ldv_init_zalloc(8UL);
#line 658
  ldvarg335 = (u64 *)tmp;
#line 659
  tmp___0 = ldv_init_zalloc(4UL);
#line 659
  ldvarg342 = (u32 *)tmp___0;
#line 660
  tmp___1 = ldv_init_zalloc(12UL);
#line 660
  ldvarg328 = (struct ethtool_regs *)tmp___1;
#line 661
  tmp___2 = ldv_init_zalloc(8UL);
#line 661
  ldvarg330 = (struct ethtool_stats *)tmp___2;
#line 662
  tmp___3 = ldv_init_zalloc(1UL);
#line 662
  ldvarg325 = (u8 *)tmp___3;
#line 663
  tmp___4 = ldv_init_zalloc(44UL);
#line 663
  ldvarg338 = (struct ethtool_ts_info *)tmp___4;
#line 664
  tmp___5 = ldv_init_zalloc(44UL);
#line 664
  ldvarg332 = (struct ethtool_modinfo *)tmp___5;
#line 665
  tmp___6 = ldv_init_zalloc(1UL);
#line 665
  ldvarg327 = tmp___6;
#line 666
  tmp___7 = ldv_init_zalloc(1UL);
#line 666
  ldvarg340 = (u8 *)tmp___7;
#line 667
  tmp___8 = ldv_init_zalloc(1UL);
#line 667
  ldvarg333 = (u8 *)tmp___8;
#line 668
  tmp___9 = ldv_init_zalloc(8UL);
#line 668
  ldvarg329 = (u64 *)tmp___9;
#line 669
  tmp___10 = ldv_init_zalloc(16UL);
#line 669
  ldvarg336 = (struct ethtool_test *)tmp___10;
#line 671
  tmp___11 = ldv_init_zalloc(196UL);
#line 671
  ldvarg331 = (struct ethtool_drvinfo *)tmp___11;
#line 672
  tmp___12 = ldv_init_zalloc(1UL);
#line 672
  ldvarg341 = (u8 *)tmp___12;
#line 673
  tmp___13 = ldv_init_zalloc(1UL);
#line 673
  ldvarg326 = (u8 *)tmp___13;
#line 674
  tmp___14 = ldv_init_zalloc(4UL);
#line 674
  ldvarg345 = (u32 *)tmp___14;
#line 675
  tmp___15 = ldv_init_zalloc(1UL);
#line 675
  ldvarg339 = (u8 *)tmp___15;
#line 670
  ldv_memset((void *)(& ldvarg334), 0, 4UL);
#line 676
  ldv_memset((void *)(& ldvarg344), 0, 4UL);
#line 677
  ldv_memset((void *)(& ldvarg337), 0, 4UL);
#line 678
  ldv_memset((void *)(& ldvarg343), 0, 4UL);
#line 680
  tmp___16 = __VERIFIER_nondet_int();
#line 680
  switch (tmp___16) {
  case 0: ;
#line 683
  if (ldv_state_variable_35 == 1) {
#line 685
    ixgbe_set_rxnfc(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group7);
#line 687
    ldv_state_variable_35 = 1;
  } else {

  }
#line 690
  goto ldv_56689;
  case 1: ;
#line 693
  if (ldv_state_variable_35 == 1) {
#line 695
    ixgbe_get_rxnfc(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group7, ldvarg345);
#line 697
    ldv_state_variable_35 = 1;
  } else {

  }
#line 700
  goto ldv_56689;
  case 2: ;
#line 703
  if (ldv_state_variable_35 == 1) {
#line 705
    ixgbe_get_ringparam(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group0);
#line 707
    ldv_state_variable_35 = 1;
  } else {

  }
#line 710
  goto ldv_56689;
  case 3: ;
#line 713
  if (ldv_state_variable_35 == 1) {
#line 715
    ixgbe_get_pauseparam(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group3);
#line 717
    ldv_state_variable_35 = 1;
  } else {

  }
#line 720
  goto ldv_56689;
  case 4: ;
#line 723
  if (ldv_state_variable_35 == 1) {
#line 725
    ixgbe_set_phys_id(ixgbe_ethtool_ops_group6, ldvarg344);
#line 727
    ldv_state_variable_35 = 1;
  } else {

  }
#line 730
  goto ldv_56689;
  case 5: ;
#line 733
  if (ldv_state_variable_35 == 1) {
#line 735
    ixgbe_get_settings(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group1);
#line 737
    ldv_state_variable_35 = 1;
  } else {

  }
#line 740
  goto ldv_56689;
  case 6: ;
#line 743
  if (ldv_state_variable_35 == 1) {
#line 745
    ixgbe_get_sset_count(ixgbe_ethtool_ops_group6, ldvarg343);
#line 747
    ldv_state_variable_35 = 1;
  } else {

  }
#line 750
  goto ldv_56689;
  case 7: ;
#line 753
  if (ldv_state_variable_35 == 1) {
#line 755
    ixgbe_get_rxfh(ixgbe_ethtool_ops_group6, ldvarg342, ldvarg341, ldvarg340);
#line 757
    ldv_state_variable_35 = 1;
  } else {

  }
#line 760
  goto ldv_56689;
  case 8: ;
#line 763
  if (ldv_state_variable_35 == 1) {
#line 765
    ixgbe_set_channels(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group4);
#line 767
    ldv_state_variable_35 = 1;
  } else {

  }
#line 770
  goto ldv_56689;
  case 9: ;
#line 773
  if (ldv_state_variable_35 == 1) {
#line 775
    ixgbe_set_coalesce(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group5);
#line 777
    ldv_state_variable_35 = 1;
  } else {

  }
#line 780
  goto ldv_56689;
  case 10: ;
#line 783
  if (ldv_state_variable_35 == 1) {
#line 785
    ixgbe_get_module_eeprom(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group2, ldvarg339);
#line 787
    ldv_state_variable_35 = 1;
  } else {

  }
#line 790
  goto ldv_56689;
  case 11: ;
#line 793
  if (ldv_state_variable_35 == 1) {
#line 795
    ixgbe_get_ts_info(ixgbe_ethtool_ops_group6, ldvarg338);
#line 797
    ldv_state_variable_35 = 1;
  } else {

  }
#line 800
  goto ldv_56689;
  case 12: ;
#line 803
  if (ldv_state_variable_35 == 1) {
#line 805
    ixgbe_set_msglevel(ixgbe_ethtool_ops_group6, ldvarg337);
#line 807
    ldv_state_variable_35 = 1;
  } else {

  }
#line 810
  goto ldv_56689;
  case 13: ;
#line 813
  if (ldv_state_variable_35 == 1) {
#line 815
    ixgbe_get_eeprom_len(ixgbe_ethtool_ops_group6);
#line 817
    ldv_state_variable_35 = 1;
  } else {

  }
#line 820
  goto ldv_56689;
  case 14: ;
#line 823
  if (ldv_state_variable_35 == 1) {
#line 825
    ixgbe_diag_test(ixgbe_ethtool_ops_group6, ldvarg336, ldvarg335);
#line 827
    ldv_state_variable_35 = 1;
  } else {

  }
#line 830
  goto ldv_56689;
  case 15: ;
#line 833
  if (ldv_state_variable_35 == 1) {
#line 835
    ixgbe_nway_reset(ixgbe_ethtool_ops_group6);
#line 837
    ldv_state_variable_35 = 1;
  } else {

  }
#line 840
  goto ldv_56689;
  case 16: ;
#line 843
  if (ldv_state_variable_35 == 1) {
#line 845
    ixgbe_get_strings(ixgbe_ethtool_ops_group6, ldvarg334, ldvarg333);
#line 847
    ldv_state_variable_35 = 1;
  } else {

  }
#line 850
  goto ldv_56689;
  case 17: ;
#line 853
  if (ldv_state_variable_35 == 1) {
#line 855
    ixgbe_get_module_info(ixgbe_ethtool_ops_group6, ldvarg332);
#line 857
    ldv_state_variable_35 = 1;
  } else {

  }
#line 860
  goto ldv_56689;
  case 18: ;
#line 863
  if (ldv_state_variable_35 == 1) {
#line 865
    ixgbe_get_rxfh_key_size(ixgbe_ethtool_ops_group6);
#line 867
    ldv_state_variable_35 = 1;
  } else {

  }
#line 870
  goto ldv_56689;
  case 19: ;
#line 873
  if (ldv_state_variable_35 == 1) {
#line 875
    ethtool_op_get_link(ixgbe_ethtool_ops_group6);
#line 877
    ldv_state_variable_35 = 1;
  } else {

  }
#line 880
  goto ldv_56689;
  case 20: ;
#line 883
  if (ldv_state_variable_35 == 1) {
#line 885
    ixgbe_get_channels(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group4);
#line 887
    ldv_state_variable_35 = 1;
  } else {

  }
#line 890
  goto ldv_56689;
  case 21: ;
#line 893
  if (ldv_state_variable_35 == 1) {
#line 895
    ixgbe_get_drvinfo(ixgbe_ethtool_ops_group6, ldvarg331);
#line 897
    ldv_state_variable_35 = 1;
  } else {

  }
#line 900
  goto ldv_56689;
  case 22: ;
#line 903
  if (ldv_state_variable_35 == 1) {
#line 905
    ixgbe_set_pauseparam(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group3);
#line 907
    ldv_state_variable_35 = 1;
  } else {

  }
#line 910
  goto ldv_56689;
  case 23: ;
#line 913
  if (ldv_state_variable_35 == 1) {
#line 915
    ixgbe_get_ethtool_stats(ixgbe_ethtool_ops_group6, ldvarg330, ldvarg329);
#line 917
    ldv_state_variable_35 = 1;
  } else {

  }
#line 920
  goto ldv_56689;
  case 24: ;
#line 923
  if (ldv_state_variable_35 == 1) {
#line 925
    ixgbe_get_coalesce(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group5);
#line 927
    ldv_state_variable_35 = 1;
  } else {

  }
#line 930
  goto ldv_56689;
  case 25: ;
#line 933
  if (ldv_state_variable_35 == 1) {
#line 935
    ixgbe_get_regs(ixgbe_ethtool_ops_group6, ldvarg328, ldvarg327);
#line 937
    ldv_state_variable_35 = 1;
  } else {

  }
#line 940
  goto ldv_56689;
  case 26: ;
#line 943
  if (ldv_state_variable_35 == 1) {
#line 945
    ixgbe_rss_indir_size(ixgbe_ethtool_ops_group6);
#line 947
    ldv_state_variable_35 = 1;
  } else {

  }
#line 950
  goto ldv_56689;
  case 27: ;
#line 953
  if (ldv_state_variable_35 == 1) {
#line 955
    ixgbe_set_wol(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group8);
#line 957
    ldv_state_variable_35 = 1;
  } else {

  }
#line 960
  goto ldv_56689;
  case 28: ;
#line 963
  if (ldv_state_variable_35 == 1) {
#line 965
    ixgbe_set_settings(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group1);
#line 967
    ldv_state_variable_35 = 1;
  } else {

  }
#line 970
  goto ldv_56689;
  case 29: ;
#line 973
  if (ldv_state_variable_35 == 1) {
#line 975
    ixgbe_get_eeprom(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group2, ldvarg326);
#line 977
    ldv_state_variable_35 = 1;
  } else {

  }
#line 980
  goto ldv_56689;
  case 30: ;
#line 983
  if (ldv_state_variable_35 == 1) {
#line 985
    ixgbe_get_wol(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group8);
#line 987
    ldv_state_variable_35 = 1;
  } else {

  }
#line 990
  goto ldv_56689;
  case 31: ;
#line 993
  if (ldv_state_variable_35 == 1) {
#line 995
    ixgbe_set_eeprom(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group2, ldvarg325);
#line 997
    ldv_state_variable_35 = 1;
  } else {

  }
#line 1000
  goto ldv_56689;
  case 32: ;
#line 1003
  if (ldv_state_variable_35 == 1) {
#line 1005
    ixgbe_get_msglevel(ixgbe_ethtool_ops_group6);
#line 1007
    ldv_state_variable_35 = 1;
  } else {

  }
#line 1010
  goto ldv_56689;
  case 33: ;
#line 1013
  if (ldv_state_variable_35 == 1) {
#line 1015
    ixgbe_get_regs_len(ixgbe_ethtool_ops_group6);
#line 1017
    ldv_state_variable_35 = 1;
  } else {

  }
#line 1020
  goto ldv_56689;
  case 34: ;
#line 1023
  if (ldv_state_variable_35 == 1) {
#line 1025
    ixgbe_set_ringparam(ixgbe_ethtool_ops_group6, ixgbe_ethtool_ops_group0);
#line 1027
    ldv_state_variable_35 = 1;
  } else {

  }
#line 1030
  goto ldv_56689;
  default: 
#line 1031
  ldv_stop();
  }
  ldv_56689: ;
#line 1035
  return;
}
}
#line 1060 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
bool ldv_queue_work_on_99(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1064
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1064
  ldv_func_res = tmp;
#line 1066
  activate_work_9(ldv_func_arg3, 2);
#line 1068
  return (ldv_func_res);
}
}
#line 1071 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
bool ldv_queue_delayed_work_on_100(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1075
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1075
  ldv_func_res = tmp;
#line 1077
  activate_work_9(& ldv_func_arg3->work, 2);
#line 1079
  return (ldv_func_res);
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
bool ldv_queue_work_on_101(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1086
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1086
  ldv_func_res = tmp;
#line 1088
  activate_work_9(ldv_func_arg3, 2);
#line 1090
  return (ldv_func_res);
}
}
#line 1093 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void ldv_flush_workqueue_102(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1096
  flush_workqueue(ldv_func_arg1);
#line 1098
  call_and_disable_all_9(2);
#line 1099
  return;
}
}
#line 1101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
bool ldv_queue_delayed_work_on_103(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1105
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1105
  ldv_func_res = tmp;
#line 1107
  activate_work_9(& ldv_func_arg3->work, 2);
#line 1109
  return (ldv_func_res);
}
}
#line 1112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void ldv_mutex_lock_104(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1115
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1117
  mutex_lock(ldv_func_arg1);
#line 1118
  return;
}
}
#line 1120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void ldv_mutex_unlock_105(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1123
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1125
  mutex_unlock(ldv_func_arg1);
#line 1126
  return;
}
}
#line 1128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void ldv_mutex_lock_106(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1131
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1133
  mutex_lock(ldv_func_arg1);
#line 1134
  return;
}
}
#line 1136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
int ldv_mutex_trylock_107(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1140
  tmp = mutex_trylock(ldv_func_arg1);
#line 1140
  ldv_func_res = tmp;
#line 1142
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1142
  return (tmp___0);
#line 1144
  return (ldv_func_res);
}
}
#line 1147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void ldv_mutex_unlock_108(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1150
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1152
  mutex_unlock(ldv_func_arg1);
#line 1153
  return;
}
}
#line 1155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void ldv_mutex_unlock_109(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1158
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 1160
  mutex_unlock(ldv_func_arg1);
#line 1161
  return;
}
}
#line 1163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void ldv_mutex_lock_110(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1166
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 1168
  mutex_lock(ldv_func_arg1);
#line 1169
  return;
}
}
#line 1210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.o.c.prepared"
void ldv_free_irq_114(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 1213
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 1215
  disable_suitable_irq_7((int )ldv_func_arg1, ldv_func_arg2);
#line 1216
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_143(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_141(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_144(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_mutex_lock_140(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_142(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_146(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_137(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_136(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_139(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_138(struct workqueue_struct *ldv_func_arg1 ) ;
#line 91 "./arch/x86/include/asm/io.h"
__inline static void writeq(unsigned long val , void volatile   *addr ) 
{ 


  {
#line 91
  __asm__  volatile   ("movq %0,%1": : "r" (val), "m" (*((unsigned long volatile   *)addr)): "memory");
#line 92
  return;
}
}
#line 124 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
struct ixgbe_mbx_operations mbx_ops_generic ;
#line 169 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg64(struct ixgbe_hw *hw , u32 reg , u64 value ) 
{ 
  u8 *reg_addr ;
  u8 *__var ;
  bool tmp ;

  {
#line 171
  __var = (u8 *)0U;
#line 171
  reg_addr = *((u8 * volatile  *)(& hw->hw_addr));
#line 173
  tmp = ixgbe_removed((void *)reg_addr);
#line 173
  if ((int )tmp) {
#line 174
    return;
  } else {

  }
#line 175
  writeq((unsigned long )value, (void volatile   *)reg_addr + (unsigned long )reg);
#line 176
  return;
}
}
#line 118 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h"
s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw ) ;
#line 119
s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw ) ;
#line 120
s32 ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                               u16 *phy_data ) ;
#line 122
s32 ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                                u16 phy_data ) ;
#line 128
s32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw ) ;
#line 129
s32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                       bool autoneg_wait_to_complete ) ;
#line 132
s32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw , ixgbe_link_speed *speed ,
                                               bool *autoneg ) ;
#line 135
bool ixgbe_check_reset_blocked(struct ixgbe_hw *hw ) ;
#line 138
s32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw , ixgbe_link_speed *speed , bool *link_up ) ;
#line 141
s32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw ) ;
#line 142
s32 ixgbe_get_phy_firmware_version_tnx(struct ixgbe_hw *hw , u16 *firmware_version ) ;
#line 149
s32 ixgbe_identify_module_generic(struct ixgbe_hw *hw ) ;
#line 151
s32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw , u16 *list_offset , u16 *data_offset ) ;
#line 154
s32 ixgbe_tn_check_overtemp(struct ixgbe_hw *hw ) ;
#line 155
s32 ixgbe_read_i2c_byte_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                u8 *data ) ;
#line 157
s32 ixgbe_write_i2c_byte_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                 u8 data ) ;
#line 159
s32 ixgbe_read_i2c_eeprom_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 *eeprom_data ) ;
#line 161
s32 ixgbe_read_i2c_sff8472_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 *sff8472_data ) ;
#line 163
s32 ixgbe_write_i2c_eeprom_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 eeprom_data ) ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw ) ;
#line 45
static void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw ) ;
#line 46
static void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw ) ;
#line 47
static s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                                 bool autoneg_wait_to_complete ) ;
#line 50
static s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                           bool autoneg_wait_to_complete ) ;
#line 53
static void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw ) ;
#line 54
static s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw , bool autoneg_wait_to_complete ) ;
#line 56
static s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                      bool autoneg_wait_to_complete ) ;
#line 59
static s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                         bool autoneg_wait_to_complete ) ;
#line 62
static s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw ) ;
#line 63
static s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                     u8 *data ) ;
#line 65
static s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                      u8 data ) ;
#line 67
static s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw ) ;
#line 68
static bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw ) ;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
bool ixgbe_mng_enabled(struct ixgbe_hw *hw ) 
{ 
  u32 fwsm ;
  u32 manc ;
  u32 factps ;

  {
#line 74
  fwsm = ixgbe_read_reg(hw, *(hw->mvals + 7UL));
#line 75
  if ((fwsm & 14U) != 4U) {
#line 76
    return (0);
  } else {

  }
#line 78
  manc = ixgbe_read_reg(hw, 22560U);
#line 79
  if ((manc & 131072U) == 0U) {
#line 80
    return (0);
  } else {

  }
#line 82
  factps = ixgbe_read_reg(hw, *(hw->mvals + 4UL));
#line 83
  if ((factps & 536870912U) != 0U) {
#line 84
    return (0);
  } else {

  }
#line 86
  return (1);
}
}
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_init_mac_link_ops_82599(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mac_info *mac ;
  enum ixgbe_media_type tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  enum ixgbe_media_type tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;

  {
#line 91
  mac = & hw->mac;
#line 96
  tmp = (*(mac->ops.get_media_type))(hw);
#line 96
  if ((unsigned int )tmp == 1U) {
#line 96
    tmp___0 = ixgbe_mng_enabled(hw);
#line 96
    if (tmp___0) {
#line 96
      tmp___1 = 0;
    } else {
#line 96
      tmp___1 = 1;
    }
#line 96
    if (tmp___1) {
#line 98
      mac->ops.disable_tx_laser = & ixgbe_disable_tx_laser_multispeed_fiber;
#line 100
      mac->ops.enable_tx_laser = & ixgbe_enable_tx_laser_multispeed_fiber;
#line 102
      mac->ops.flap_tx_laser = & ixgbe_flap_tx_laser_multispeed_fiber;
    } else {
#line 104
      mac->ops.disable_tx_laser = (void (*)(struct ixgbe_hw * ))0;
#line 105
      mac->ops.enable_tx_laser = (void (*)(struct ixgbe_hw * ))0;
#line 106
      mac->ops.flap_tx_laser = (void (*)(struct ixgbe_hw * ))0;
    }
  } else {
#line 104
    mac->ops.disable_tx_laser = (void (*)(struct ixgbe_hw * ))0;
#line 105
    mac->ops.enable_tx_laser = (void (*)(struct ixgbe_hw * ))0;
#line 106
    mac->ops.flap_tx_laser = (void (*)(struct ixgbe_hw * ))0;
  }
#line 109
  if ((int )hw->phy.multispeed_fiber) {
#line 111
    mac->ops.setup_link = & ixgbe_setup_mac_link_multispeed_fiber;
  } else {
#line 113
    tmp___2 = (*(mac->ops.get_media_type))(hw);
#line 113
    if ((unsigned int )tmp___2 == 5U && ((unsigned int )hw->phy.smart_speed == 0U || (unsigned int )hw->phy.smart_speed == 1U)) {
#line 113
      tmp___3 = ixgbe_verify_lesm_fw_enabled_82599(hw);
#line 113
      if (tmp___3) {
#line 113
        tmp___4 = 0;
      } else {
#line 113
        tmp___4 = 1;
      }
#line 113
      if (tmp___4) {
#line 118
        mac->ops.setup_link = & ixgbe_setup_mac_link_smartspeed;
      } else {
#line 120
        mac->ops.setup_link = & ixgbe_setup_mac_link_82599;
      }
    } else {
#line 120
      mac->ops.setup_link = & ixgbe_setup_mac_link_82599;
    }
  }
#line 121
  return;
}
}
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;
  u16 list_offset ;
  u16 data_offset ;
  u16 data_value ;
  s32 tmp ;
  s32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
#line 129
  if ((unsigned int )hw->phy.sfp_type != 65535U) {
#line 130
    ixgbe_init_mac_link_ops_82599(hw);
#line 132
    hw->phy.ops.reset = (s32 (*)(struct ixgbe_hw * ))0;
#line 134
    ret_val = ixgbe_get_sfp_init_sequence_offsets(hw, & list_offset, & data_offset);
#line 136
    if (ret_val != 0) {
#line 137
      return (ret_val);
    } else {

    }
#line 140
    ret_val = (*(hw->mac.ops.acquire_swfw_sync))(hw, 8U);
#line 142
    if (ret_val != 0) {
#line 143
      return (-16);
    } else {

    }
#line 145
    data_offset = (u16 )((int )data_offset + 1);
#line 145
    tmp = (*(hw->eeprom.ops.read))(hw, (int )data_offset, & data_value);
#line 145
    if (tmp != 0) {
#line 146
      goto setup_sfp_err;
    } else {

    }
#line 147
    goto ldv_54457;
    ldv_54456: 
#line 148
    ixgbe_write_reg(hw, 85760U, (u32 )data_value);
#line 149
    ixgbe_read_reg(hw, 8U);
#line 150
    data_offset = (u16 )((int )data_offset + 1);
#line 150
    tmp___0 = (*(hw->eeprom.ops.read))(hw, (int )data_offset, & data_value);
#line 150
    if (tmp___0 != 0) {
#line 151
      goto setup_sfp_err;
    } else {

    }
    ldv_54457: ;
#line 147
    if ((unsigned int )data_value != 65535U) {
#line 149
      goto ldv_54456;
    } else {

    }
#line 155
    (*(hw->mac.ops.release_swfw_sync))(hw, 8U);
#line 160
    usleep_range((unsigned long )(hw->eeprom.semaphore_delay * 1000U), (unsigned long )(hw->eeprom.semaphore_delay * 2000U));
#line 164
    ret_val = (*(hw->mac.ops.prot_autoc_write))(hw, hw->mac.orig_autoc | 24576U, 0);
#line 168
    if (ret_val != 0) {
#line 169
      descriptor.modname = "ixgbe";
#line 169
      descriptor.function = "ixgbe_setup_sfp_modules_82599";
#line 169
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 169
      descriptor.format = " sfp module setup not complete\n";
#line 169
      descriptor.lineno = 169U;
#line 169
      descriptor.flags = 0U;
#line 169
      tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 169
      if (tmp___1 != 0L) {
#line 169
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             " sfp module setup not complete\n");
      } else {

      }
#line 170
      return (-30);
    } else {

    }
  } else {

  }
#line 174
  return (0);
  setup_sfp_err: 
#line 178
  (*(hw->mac.ops.release_swfw_sync))(hw, 8U);
#line 182
  usleep_range((unsigned long )(hw->eeprom.semaphore_delay * 1000U), (unsigned long )(hw->eeprom.semaphore_delay * 2000U));
#line 184
  netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
             "eeprom read at offset %d failed\n", (int )data_offset);
#line 185
  return (-30);
}
}
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 prot_autoc_read_82599(struct ixgbe_hw *hw , bool *locked , u32 *reg_val ) 
{ 
  s32 ret_val ;
  bool tmp ;

  {
#line 204
  *locked = 0;
#line 206
  tmp = ixgbe_verify_lesm_fw_enabled_82599(hw);
#line 206
  if ((int )tmp) {
#line 207
    ret_val = (*(hw->mac.ops.acquire_swfw_sync))(hw, 8U);
#line 209
    if (ret_val != 0) {
#line 210
      return (-16);
    } else {

    }
#line 212
    *locked = 1;
  } else {

  }
#line 215
  *reg_val = ixgbe_read_reg(hw, 17056U);
#line 216
  return (0);
}
}
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 prot_autoc_write_82599(struct ixgbe_hw *hw , u32 autoc , bool locked ) 
{ 
  s32 ret_val ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 231
  ret_val = 0;
#line 234
  tmp = ixgbe_check_reset_blocked(hw);
#line 234
  if ((int )tmp) {
#line 235
    goto out;
  } else {

  }
#line 241
  if (! locked) {
#line 241
    tmp___0 = ixgbe_verify_lesm_fw_enabled_82599(hw);
#line 241
    if ((int )tmp___0) {
#line 242
      ret_val = (*(hw->mac.ops.acquire_swfw_sync))(hw, 8U);
#line 244
      if (ret_val != 0) {
#line 245
        return (-16);
      } else {

      }
#line 247
      locked = 1;
    } else {

    }
  } else {

  }
#line 250
  ixgbe_write_reg(hw, 17056U, autoc);
#line 251
  ret_val = ixgbe_reset_pipeline_82599(hw);
  out: ;
#line 257
  if ((int )locked) {
#line 258
    (*(hw->mac.ops.release_swfw_sync))(hw, 8U);
  } else {

  }
#line 260
  return (ret_val);
}
}
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_get_invariants_82599(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mac_info *mac ;

  {
#line 265
  mac = & hw->mac;
#line 267
  ixgbe_init_mac_link_ops_82599(hw);
#line 269
  mac->mcft_size = 128U;
#line 270
  mac->vft_size = 128U;
#line 271
  mac->num_rar_entries = 128U;
#line 272
  mac->rx_pb_size = 512U;
#line 273
  mac->max_rx_queues = 128U;
#line 274
  mac->max_tx_queues = 128U;
#line 275
  mac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);
#line 277
  return (0);
}
}
#line 289 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_init_phy_ops_82599(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mac_info *mac ;
  struct ixgbe_phy_info *phy ;
  s32 ret_val ;
  u32 esdp ;
  enum ixgbe_media_type tmp ;

  {
#line 291
  mac = & hw->mac;
#line 292
  phy = & hw->phy;
#line 296
  if ((unsigned int )hw->device_id == 5464U) {
#line 298
    hw->phy.qsfp_shared_i2c_bus = 1;
#line 301
    esdp = ixgbe_read_reg(hw, 32U);
#line 302
    esdp = esdp | 256U;
#line 303
    esdp = esdp & 4294966783U;
#line 304
    esdp = esdp & 4294967294U;
#line 305
    esdp = esdp & 4294901759U;
#line 306
    esdp = esdp & 4294836223U;
#line 307
    ixgbe_write_reg(hw, 32U, esdp);
#line 308
    ixgbe_read_reg(hw, 8U);
#line 310
    phy->ops.read_i2c_byte = & ixgbe_read_i2c_byte_82599;
#line 311
    phy->ops.write_i2c_byte = & ixgbe_write_i2c_byte_82599;
  } else {

  }
#line 315
  ret_val = (*(phy->ops.identify))(hw);
#line 318
  ixgbe_init_mac_link_ops_82599(hw);
#line 321
  tmp = (*(mac->ops.get_media_type))(hw);
#line 321
  if ((unsigned int )tmp == 4U) {
#line 322
    mac->ops.setup_link = & ixgbe_setup_copper_link_82599;
#line 323
    mac->ops.get_link_capabilities = & ixgbe_get_copper_link_capabilities_generic;
  } else {

  }
#line 328
  switch ((unsigned int )hw->phy.type) {
  case 2U: 
#line 330
  phy->ops.check_link = & ixgbe_check_phy_link_tnx;
#line 331
  phy->ops.setup_link = & ixgbe_setup_phy_link_tnx;
#line 332
  phy->ops.get_firmware_version = & ixgbe_get_phy_firmware_version_tnx;
#line 334
  goto ldv_54486;
  default: ;
#line 336
  goto ldv_54486;
  }
  ldv_54486: ;
#line 339
  return (ret_val);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw , ixgbe_link_speed *speed ,
                                             bool *autoneg ) 
{ 
  u32 autoc ;

  {
#line 354
  autoc = 0U;
#line 357
  if ((((((unsigned int )hw->phy.sfp_type == 9U || (unsigned int )hw->phy.sfp_type == 10U) || (unsigned int )hw->phy.sfp_type == 13U) || (unsigned int )hw->phy.sfp_type == 14U) || (unsigned int )hw->phy.sfp_type == 11U) || (unsigned int )hw->phy.sfp_type == 12U) {
#line 363
    *speed = 32U;
#line 364
    *autoneg = 1;
#line 365
    return (0);
  } else {

  }
#line 373
  if ((int )hw->mac.orig_link_settings_stored) {
#line 374
    autoc = hw->mac.orig_autoc;
  } else {
#line 376
    autoc = ixgbe_read_reg(hw, 17056U);
  }
#line 378
  switch (autoc & 57344U) {
  case 0U: 
#line 380
  *speed = 32U;
#line 381
  *autoneg = 0;
#line 382
  goto ldv_54495;
  case 8192U: 
#line 385
  *speed = 128U;
#line 386
  *autoneg = 0;
#line 387
  goto ldv_54495;
  case 16384U: 
#line 390
  *speed = 32U;
#line 391
  *autoneg = 1;
#line 392
  goto ldv_54495;
  case 24576U: 
#line 395
  *speed = 128U;
#line 396
  *autoneg = 0;
#line 397
  goto ldv_54495;
  case 32768U: ;
  case 49152U: 
#line 401
  *speed = 0U;
#line 402
  if ((autoc & 65536U) != 0U) {
#line 403
    *speed = *speed | 128U;
  } else {

  }
#line 404
  if ((int )autoc < 0) {
#line 405
    *speed = *speed | 128U;
  } else {

  }
#line 406
  if ((autoc & 1073741824U) != 0U) {
#line 407
    *speed = *speed | 32U;
  } else {

  }
#line 408
  *autoneg = 1;
#line 409
  goto ldv_54495;
  case 57344U: 
#line 412
  *speed = 8U;
#line 413
  if ((autoc & 65536U) != 0U) {
#line 414
    *speed = *speed | 128U;
  } else {

  }
#line 415
  if ((int )autoc < 0) {
#line 416
    *speed = *speed | 128U;
  } else {

  }
#line 417
  if ((autoc & 1073741824U) != 0U) {
#line 418
    *speed = *speed | 32U;
  } else {

  }
#line 419
  *autoneg = 1;
#line 420
  goto ldv_54495;
  case 40960U: 
#line 423
  *speed = 40U;
#line 424
  *autoneg = 0;
#line 425
  goto ldv_54495;
  default: ;
#line 428
  return (-8);
  }
  ldv_54495: ;
#line 431
  if ((int )hw->phy.multispeed_fiber) {
#line 432
    *speed = *speed | 160U;
#line 436
    if ((unsigned int )hw->phy.media_type == 2U) {
#line 437
      *autoneg = 0;
    } else {
#line 439
      *autoneg = 1;
    }
  } else {

  }
#line 442
  return (0);
}
}
#line 451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static enum ixgbe_media_type ixgbe_get_media_type_82599(struct ixgbe_hw *hw ) 
{ 


  {
#line 454
  switch ((unsigned int )hw->phy.type) {
  case 7U: ;
  case 2U: ;
#line 457
  return (4);
  default: ;
#line 460
  goto ldv_54510;
  }
  ldv_54510: ;
#line 463
  switch ((int )hw->device_id) {
  case 4343: ;
  case 5396: ;
  case 4344: ;
  case 5399: ;
  case 5418: ;
  case 4348: ;
#line 471
  return (5);
  case 4347: ;
  case 5417: ;
  case 5383: ;
  case 5453: ;
  case 5450: ;
  case 5463: ;
#line 479
  return (1);
  case 4345: ;
#line 482
  return (6);
  case 5404: ;
#line 485
  return (4);
  case 5455: ;
#line 488
  return (3);
  case 5464: ;
#line 491
  return (2);
  default: ;
#line 494
  return (0);
  }
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw ) 
{ 
  u32 autoc2_reg ;
  u32 fwsm ;
  u16 ee_ctrl_2 ;

  {
#line 508
  ee_ctrl_2 = 0U;
#line 510
  (*(hw->eeprom.ops.read))(hw, 1, & ee_ctrl_2);
#line 513
  fwsm = ixgbe_read_reg(hw, *(hw->mvals + 7UL));
#line 515
  if (((fwsm & 14U) != 4U && ! hw->wol_enabled) && ((int )ee_ctrl_2 & 2) != 0) {
#line 518
    autoc2_reg = ixgbe_read_reg(hw, 17064U);
#line 519
    autoc2_reg = autoc2_reg | 1342177280U;
#line 520
    ixgbe_write_reg(hw, 17064U, autoc2_reg);
  } else {

  }
#line 522
  return;
}
}
#line 532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw , bool autoneg_wait_to_complete ) 
{ 
  u32 autoc_reg ;
  u32 links_reg ;
  u32 i ;
  s32 status ;
  bool got_lock ;
  bool tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
#line 538
  status = 0;
#line 539
  got_lock = 0;
#line 541
  tmp = ixgbe_verify_lesm_fw_enabled_82599(hw);
#line 541
  if ((int )tmp) {
#line 542
    status = (*(hw->mac.ops.acquire_swfw_sync))(hw, 8U);
#line 544
    if (status != 0) {
#line 545
      return (status);
    } else {

    }
#line 547
    got_lock = 1;
  } else {

  }
#line 551
  ixgbe_reset_pipeline_82599(hw);
#line 553
  if ((int )got_lock) {
#line 554
    (*(hw->mac.ops.release_swfw_sync))(hw, 8U);
  } else {

  }
#line 557
  if ((int )autoneg_wait_to_complete) {
#line 558
    autoc_reg = ixgbe_read_reg(hw, 17056U);
#line 559
    if (((autoc_reg & 57344U) == 32768U || (autoc_reg & 57344U) == 49152U) || (autoc_reg & 57344U) == 57344U) {
#line 565
      links_reg = 0U;
#line 566
      i = 0U;
#line 566
      goto ldv_54545;
      ldv_54544: 
#line 567
      links_reg = ixgbe_read_reg(hw, 17060U);
#line 568
      if ((int )links_reg < 0) {
#line 569
        goto ldv_54543;
      } else {

      }
#line 570
      msleep(100U);
#line 566
      i = i + 1U;
      ldv_54545: ;
#line 566
      if (i <= 44U) {
#line 568
        goto ldv_54544;
      } else {

      }
      ldv_54543: ;
#line 572
      if ((int )links_reg >= 0) {
#line 573
        status = -14;
#line 574
        descriptor.modname = "ixgbe";
#line 574
        descriptor.function = "ixgbe_start_mac_link_82599";
#line 574
        descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 574
        descriptor.format = "Autoneg did not complete.\n";
#line 574
        descriptor.lineno = 574U;
#line 574
        descriptor.flags = 0U;
#line 574
        tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 574
        if (tmp___0 != 0L) {
#line 574
          __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                               "Autoneg did not complete.\n");
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 580
  msleep(50U);
#line 582
  return (status);
}
}
#line 593 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw ) 
{ 
  u32 esdp_reg ;
  u32 tmp ;
  bool tmp___0 ;

  {
#line 595
  tmp = ixgbe_read_reg(hw, 32U);
#line 595
  esdp_reg = tmp;
#line 598
  tmp___0 = ixgbe_check_reset_blocked(hw);
#line 598
  if ((int )tmp___0) {
#line 599
    return;
  } else {

  }
#line 602
  esdp_reg = esdp_reg | 8U;
#line 603
  ixgbe_write_reg(hw, 32U, esdp_reg);
#line 604
  ixgbe_read_reg(hw, 8U);
#line 605
  __const_udelay(429500UL);
#line 607
  return;
}
}
#line 616 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw ) 
{ 
  u32 esdp_reg ;
  u32 tmp ;

  {
#line 618
  tmp = ixgbe_read_reg(hw, 32U);
#line 618
  esdp_reg = tmp;
#line 621
  esdp_reg = esdp_reg & 4294967287U;
#line 622
  ixgbe_write_reg(hw, 32U, esdp_reg);
#line 623
  ixgbe_read_reg(hw, 8U);
#line 624
  msleep(100U);
#line 625
  return;
}
}
#line 639 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw ) 
{ 
  bool tmp ;

  {
#line 642
  tmp = ixgbe_check_reset_blocked(hw);
#line 642
  if ((int )tmp) {
#line 643
    return;
  } else {

  }
#line 645
  if ((int )hw->mac.autotry_restart) {
#line 646
    ixgbe_disable_tx_laser_multispeed_fiber(hw);
#line 647
    ixgbe_enable_tx_laser_multispeed_fiber(hw);
#line 648
    hw->mac.autotry_restart = 0;
  } else {

  }
#line 650
  return;
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                                 bool autoneg_wait_to_complete ) 
{ 
  s32 status ;
  ixgbe_link_speed link_speed ;
  ixgbe_link_speed highest_link_speed ;
  u32 speedcnt ;
  u32 esdp_reg ;
  u32 tmp ;
  u32 i ;
  bool link_up ;
  bool autoneg ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;

  {
#line 664
  status = 0;
#line 665
  link_speed = 0U;
#line 666
  highest_link_speed = 0U;
#line 667
  speedcnt = 0U;
#line 668
  tmp = ixgbe_read_reg(hw, 32U);
#line 668
  esdp_reg = tmp;
#line 669
  i = 0U;
#line 670
  link_up = 0;
#line 671
  autoneg = 0;
#line 674
  status = (*(hw->mac.ops.get_link_capabilities))(hw, & link_speed, & autoneg);
#line 676
  if (status != 0) {
#line 677
    return (status);
  } else {

  }
#line 679
  speed = speed & link_speed;
#line 685
  if ((speed & 128U) != 0U) {
#line 686
    speedcnt = speedcnt + 1U;
#line 687
    highest_link_speed = 128U;
#line 690
    status = (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
#line 692
    if (status != 0) {
#line 693
      return (status);
    } else {

    }
#line 695
    if (link_speed == 128U && (int )link_up) {
#line 696
      goto out;
    } else {

    }
#line 699
    switch ((unsigned int )hw->phy.media_type) {
    case 1U: 
#line 701
    esdp_reg = esdp_reg | 8224U;
#line 702
    ixgbe_write_reg(hw, 32U, esdp_reg);
#line 703
    ixgbe_read_reg(hw, 8U);
#line 704
    goto ldv_54574;
    case 2U: ;
#line 707
    goto ldv_54574;
    default: 
#line 709
    descriptor.modname = "ixgbe";
#line 709
    descriptor.function = "ixgbe_setup_mac_link_multispeed_fiber";
#line 709
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 709
    descriptor.format = "Unexpected media type.\n";
#line 709
    descriptor.lineno = 709U;
#line 709
    descriptor.flags = 0U;
#line 709
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 709
    if (tmp___0 != 0L) {
#line 709
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Unexpected media type.\n");
    } else {

    }
#line 710
    goto ldv_54574;
    }
    ldv_54574: 
#line 714
    msleep(40U);
#line 716
    status = ixgbe_setup_mac_link_82599(hw, 128U, (int )autoneg_wait_to_complete);
#line 719
    if (status != 0) {
#line 720
      return (status);
    } else {

    }
#line 723
    if ((unsigned long )hw->mac.ops.flap_tx_laser != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
#line 724
      (*(hw->mac.ops.flap_tx_laser))(hw);
    } else {

    }
#line 731
    i = 0U;
#line 731
    goto ldv_54580;
    ldv_54579: 
#line 733
    msleep(100U);
#line 736
    status = (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
#line 738
    if (status != 0) {
#line 739
      return (status);
    } else {

    }
#line 741
    if ((int )link_up) {
#line 742
      goto out;
    } else {

    }
#line 731
    i = i + 1U;
    ldv_54580: ;
#line 731
    if (i <= 4U) {
#line 733
      goto ldv_54579;
    } else {

    }

  } else {

  }
#line 746
  if ((speed & 32U) != 0U) {
#line 747
    speedcnt = speedcnt + 1U;
#line 748
    if (highest_link_speed == 0U) {
#line 749
      highest_link_speed = 32U;
    } else {

    }
#line 752
    status = (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
#line 754
    if (status != 0) {
#line 755
      return (status);
    } else {

    }
#line 757
    if (link_speed == 32U && (int )link_up) {
#line 758
      goto out;
    } else {

    }
#line 761
    switch ((unsigned int )hw->phy.media_type) {
    case 1U: 
#line 763
    esdp_reg = esdp_reg & 4294967263U;
#line 764
    esdp_reg = esdp_reg | 8192U;
#line 765
    ixgbe_write_reg(hw, 32U, esdp_reg);
#line 766
    ixgbe_read_reg(hw, 8U);
#line 767
    goto ldv_54583;
    case 2U: ;
#line 770
    goto ldv_54583;
    default: 
#line 772
    descriptor___0.modname = "ixgbe";
#line 772
    descriptor___0.function = "ixgbe_setup_mac_link_multispeed_fiber";
#line 772
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 772
    descriptor___0.format = "Unexpected media type.\n";
#line 772
    descriptor___0.lineno = 772U;
#line 772
    descriptor___0.flags = 0U;
#line 772
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 772
    if (tmp___1 != 0L) {
#line 772
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Unexpected media type.\n");
    } else {

    }
#line 773
    goto ldv_54583;
    }
    ldv_54583: 
#line 777
    msleep(40U);
#line 779
    status = ixgbe_setup_mac_link_82599(hw, 32U, (int )autoneg_wait_to_complete);
#line 782
    if (status != 0) {
#line 783
      return (status);
    } else {

    }
#line 786
    if ((unsigned long )hw->mac.ops.flap_tx_laser != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
#line 787
      (*(hw->mac.ops.flap_tx_laser))(hw);
    } else {

    }
#line 790
    msleep(100U);
#line 793
    status = (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
#line 795
    if (status != 0) {
#line 796
      return (status);
    } else {

    }
#line 798
    if ((int )link_up) {
#line 799
      goto out;
    } else {

    }
  } else {

  }
#line 807
  if (speedcnt > 1U) {
#line 808
    status = ixgbe_setup_mac_link_multispeed_fiber(hw, highest_link_speed, (int )autoneg_wait_to_complete);
  } else {

  }
  out: 
#line 814
  hw->phy.autoneg_advertised = 0U;
#line 816
  if ((speed & 128U) != 0U) {
#line 817
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 128U;
  } else {

  }
#line 819
  if ((speed & 32U) != 0U) {
#line 820
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 32U;
  } else {

  }
#line 822
  return (status);
}
}
#line 833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                           bool autoneg_wait_to_complete ) 
{ 
  s32 status ;
  ixgbe_link_speed link_speed ;
  s32 i ;
  s32 j ;
  bool link_up ;
  u32 autoc_reg ;
  u32 tmp ;
  unsigned long __ms ;
  unsigned long tmp___0 ;
  unsigned long __ms___0 ;
  unsigned long tmp___1 ;
  struct _ddebug descriptor ;
  long tmp___2 ;

  {
#line 837
  status = 0;
#line 838
  link_speed = 0U;
#line 840
  link_up = 0;
#line 841
  tmp = ixgbe_read_reg(hw, 17056U);
#line 841
  autoc_reg = tmp;
#line 844
  hw->phy.autoneg_advertised = 0U;
#line 846
  if ((speed & 128U) != 0U) {
#line 847
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 128U;
  } else {

  }
#line 849
  if ((speed & 32U) != 0U) {
#line 850
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 32U;
  } else {

  }
#line 852
  if ((speed & 8U) != 0U) {
#line 853
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 8U;
  } else {

  }
#line 863
  hw->phy.smart_speed_active = 0;
#line 864
  j = 0;
#line 864
  goto ldv_54607;
  ldv_54606: 
#line 865
  status = ixgbe_setup_mac_link_82599(hw, speed, (int )autoneg_wait_to_complete);
#line 867
  if (status != 0) {
#line 868
    goto out;
  } else {

  }
#line 876
  i = 0;
#line 876
  goto ldv_54604;
  ldv_54603: 
#line 877
  __ms = 100UL;
#line 877
  goto ldv_54601;
  ldv_54600: 
#line 877
  __const_udelay(4295000UL);
  ldv_54601: 
#line 877
  tmp___0 = __ms;
#line 877
  __ms = __ms - 1UL;
#line 877
  if (tmp___0 != 0UL) {
#line 879
    goto ldv_54600;
  } else {

  }
#line 880
  status = (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
#line 882
  if (status != 0) {
#line 883
    goto out;
  } else {

  }
#line 885
  if ((int )link_up) {
#line 886
    goto out;
  } else {

  }
#line 876
  i = i + 1;
  ldv_54604: ;
#line 876
  if (i <= 4) {
#line 878
    goto ldv_54603;
  } else {

  }
#line 864
  j = j + 1;
  ldv_54607: ;
#line 864
  if (j <= 2) {
#line 866
    goto ldv_54606;
  } else {

  }

#line 894
  if ((autoc_reg & 65536U) == 0U || (autoc_reg & 3221225472U) == 0U) {
#line 896
    goto out;
  } else {

  }
#line 899
  hw->phy.smart_speed_active = 1;
#line 900
  status = ixgbe_setup_mac_link_82599(hw, speed, (int )autoneg_wait_to_complete);
#line 902
  if (status != 0) {
#line 903
    goto out;
  } else {

  }
#line 911
  i = 0;
#line 911
  goto ldv_54614;
  ldv_54613: 
#line 912
  __ms___0 = 100UL;
#line 912
  goto ldv_54611;
  ldv_54610: 
#line 912
  __const_udelay(4295000UL);
  ldv_54611: 
#line 912
  tmp___1 = __ms___0;
#line 912
  __ms___0 = __ms___0 - 1UL;
#line 912
  if (tmp___1 != 0UL) {
#line 914
    goto ldv_54610;
  } else {

  }
#line 915
  status = (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
#line 917
  if (status != 0) {
#line 918
    goto out;
  } else {

  }
#line 920
  if ((int )link_up) {
#line 921
    goto out;
  } else {

  }
#line 911
  i = i + 1;
  ldv_54614: ;
#line 911
  if (i <= 5) {
#line 913
    goto ldv_54613;
  } else {

  }
#line 925
  hw->phy.smart_speed_active = 0;
#line 926
  status = ixgbe_setup_mac_link_82599(hw, speed, (int )autoneg_wait_to_complete);
  out: ;
#line 930
  if ((int )link_up && link_speed == 32U) {
#line 931
    descriptor.modname = "ixgbe";
#line 931
    descriptor.function = "ixgbe_setup_mac_link_smartspeed";
#line 931
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 931
    descriptor.format = "Smartspeed has downgraded the link speed from the maximum advertised\n";
#line 931
    descriptor.lineno = 931U;
#line 931
    descriptor.flags = 0U;
#line 931
    tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 931
    if (tmp___2 != 0L) {
#line 931
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Smartspeed has downgraded the link speed from the maximum advertised\n");
    } else {

    }
  } else {

  }
#line 932
  return (status);
}
}
#line 943 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                      bool autoneg_wait_to_complete ) 
{ 
  bool autoneg ;
  s32 status ;
  u32 pma_pmd_1g ;
  u32 link_mode ;
  u32 links_reg ;
  u32 i ;
  u32 autoc2 ;
  u32 tmp ;
  u32 pma_pmd_10g_serial ;
  ixgbe_link_speed link_capabilities ;
  u32 current_autoc ;
  u32 tmp___0 ;
  u32 orig_autoc ;
  u32 autoc ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
#line 947
  autoneg = 0;
#line 950
  tmp = ixgbe_read_reg(hw, 17064U);
#line 950
  autoc2 = tmp;
#line 951
  pma_pmd_10g_serial = autoc2 & 196608U;
#line 952
  link_capabilities = 0U;
#line 955
  tmp___0 = ixgbe_read_reg(hw, 17056U);
#line 955
  current_autoc = tmp___0;
#line 957
  orig_autoc = 0U;
#line 959
  autoc = current_autoc;
#line 962
  status = (*(hw->mac.ops.get_link_capabilities))(hw, & link_capabilities, & autoneg);
#line 964
  if (status != 0) {
#line 965
    return (status);
  } else {

  }
#line 967
  speed = speed & link_capabilities;
#line 969
  if (speed == 0U) {
#line 970
    return (-8);
  } else {

  }
#line 973
  if ((int )hw->mac.orig_link_settings_stored) {
#line 974
    orig_autoc = hw->mac.orig_autoc;
  } else {
#line 976
    orig_autoc = autoc;
  }
#line 978
  link_mode = autoc & 57344U;
#line 979
  pma_pmd_1g = autoc & 512U;
#line 981
  if ((link_mode == 32768U || link_mode == 49152U) || link_mode == 57344U) {
#line 985
    autoc = autoc & 1073676287U;
#line 986
    if ((speed & 128U) != 0U) {
#line 987
      if ((int )orig_autoc < 0) {
#line 988
        autoc = autoc | 2147483648U;
      } else {

      }
#line 989
      if ((orig_autoc & 65536U) != 0U && ! hw->phy.smart_speed_active) {
#line 991
        autoc = autoc | 65536U;
      } else {

      }
    } else {

    }
#line 993
    if ((speed & 32U) != 0U) {
#line 994
      autoc = autoc | 1073741824U;
    } else {

    }
  } else
#line 995
  if (pma_pmd_1g == 0U && (link_mode == 0U || link_mode == 16384U)) {
#line 999
    if (speed == 128U && pma_pmd_10g_serial == 131072U) {
#line 1001
      autoc = autoc & 4294909951U;
#line 1002
      autoc = autoc | 24576U;
    } else {

    }
  } else
#line 1004
  if (pma_pmd_10g_serial == 131072U && link_mode == 24576U) {
#line 1007
    if (speed == 32U && pma_pmd_1g == 0U) {
#line 1009
      autoc = autoc & 4294909951U;
#line 1010
      if ((int )autoneg) {
#line 1011
        autoc = autoc | 16384U;
      } else {
#line 1013
        autoc = autoc;
      }
    } else {

    }
  } else {

  }
#line 1017
  if (autoc != current_autoc) {
#line 1019
    status = (*(hw->mac.ops.prot_autoc_write))(hw, autoc, 0);
#line 1020
    if (status != 0) {
#line 1021
      return (status);
    } else {

    }
#line 1024
    if ((int )autoneg_wait_to_complete) {
#line 1025
      if ((link_mode == 32768U || link_mode == 49152U) || link_mode == 57344U) {
#line 1028
        links_reg = 0U;
#line 1029
        i = 0U;
#line 1029
        goto ldv_54637;
        ldv_54636: 
#line 1030
        links_reg = ixgbe_read_reg(hw, 17060U);
#line 1032
        if ((int )links_reg < 0) {
#line 1033
          goto ldv_54635;
        } else {

        }
#line 1034
        msleep(100U);
#line 1029
        i = i + 1U;
        ldv_54637: ;
#line 1029
        if (i <= 44U) {
#line 1031
          goto ldv_54636;
        } else {

        }
        ldv_54635: ;
#line 1036
        if ((int )links_reg >= 0) {
#line 1037
          status = -14;
#line 1039
          descriptor.modname = "ixgbe";
#line 1039
          descriptor.function = "ixgbe_setup_mac_link_82599";
#line 1039
          descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1039
          descriptor.format = "Autoneg did not complete.\n";
#line 1039
          descriptor.lineno = 1039U;
#line 1039
          descriptor.flags = 0U;
#line 1039
          tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1039
          if (tmp___1 != 0L) {
#line 1039
            __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                                 "Autoneg did not complete.\n");
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
#line 1045
    msleep(50U);
  } else {

  }
#line 1048
  return (status);
}
}
#line 1059 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                         bool autoneg_wait_to_complete ) 
{ 
  s32 status ;

  {
#line 1066
  status = (*(hw->phy.ops.setup_link_speed))(hw, speed, (int )autoneg_wait_to_complete);
#line 1069
  ixgbe_start_mac_link_82599(hw, (int )autoneg_wait_to_complete);
#line 1071
  return (status);
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw ) 
{ 
  ixgbe_link_speed link_speed ;
  s32 status ;
  u32 ctrl ;
  u32 i ;
  u32 autoc ;
  u32 autoc2 ;
  u32 curr_lms ;
  bool link_up ;
  u32 tmp ;
  u32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
#line 1088
  link_up = 0;
#line 1091
  status = (*(hw->mac.ops.stop_adapter))(hw);
#line 1092
  if (status != 0) {
#line 1093
    return (status);
  } else {

  }
#line 1096
  ixgbe_clear_tx_pending(hw);
#line 1101
  status = (*(hw->phy.ops.init))(hw);
#line 1103
  if (status == -19) {
#line 1104
    return (status);
  } else {

  }
#line 1107
  if ((int )hw->phy.sfp_setup_needed) {
#line 1108
    status = (*(hw->mac.ops.setup_sfp))(hw);
#line 1109
    hw->phy.sfp_setup_needed = 0;
  } else {

  }
#line 1112
  if (status == -19) {
#line 1113
    return (status);
  } else {

  }
#line 1116
  if (! hw->phy.reset_disable && (unsigned long )hw->phy.ops.reset != (unsigned long )((s32 (*)(struct ixgbe_hw * ))0)) {
#line 1117
    (*(hw->phy.ops.reset))(hw);
  } else {

  }
#line 1120
  tmp = ixgbe_read_reg(hw, 17056U);
#line 1120
  curr_lms = tmp & 57344U;
  mac_reset_top: 
#line 1129
  ctrl = 8U;
#line 1130
  if (! hw->force_full_reset) {
#line 1131
    (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
#line 1132
    if ((int )link_up) {
#line 1133
      ctrl = 67108864U;
    } else {

    }
  } else {

  }
#line 1136
  tmp___0 = ixgbe_read_reg(hw, 0U);
#line 1136
  ctrl = tmp___0 | ctrl;
#line 1137
  ixgbe_write_reg(hw, 0U, ctrl);
#line 1138
  ixgbe_read_reg(hw, 8U);
#line 1141
  i = 0U;
#line 1141
  goto ldv_54660;
  ldv_54659: 
#line 1142
  __const_udelay(4295UL);
#line 1143
  ctrl = ixgbe_read_reg(hw, 0U);
#line 1144
  if ((ctrl & 67108872U) == 0U) {
#line 1145
    goto ldv_54658;
  } else {

  }
#line 1141
  i = i + 1U;
  ldv_54660: ;
#line 1141
  if (i <= 9U) {
#line 1143
    goto ldv_54659;
  } else {

  }
  ldv_54658: ;
#line 1148
  if ((ctrl & 67108872U) != 0U) {
#line 1149
    status = -15;
#line 1150
    descriptor.modname = "ixgbe";
#line 1150
    descriptor.function = "ixgbe_reset_hw_82599";
#line 1150
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1150
    descriptor.format = "Reset polling failed to complete.\n";
#line 1150
    descriptor.lineno = 1150U;
#line 1150
    descriptor.flags = 0U;
#line 1150
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1150
    if (tmp___1 != 0L) {
#line 1150
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Reset polling failed to complete.\n");
    } else {

    }
  } else {

  }
#line 1153
  msleep(50U);
#line 1160
  if ((int )hw->mac.flags & 1) {
#line 1161
    hw->mac.flags = (unsigned int )hw->mac.flags & 254U;
#line 1162
    goto mac_reset_top;
  } else {

  }
#line 1170
  autoc = ixgbe_read_reg(hw, 17056U);
#line 1171
  autoc2 = ixgbe_read_reg(hw, 17064U);
#line 1174
  if ((autoc2 & 1879048192U) != 0U) {
#line 1175
    autoc2 = autoc2 & 2415919103U;
#line 1176
    ixgbe_write_reg(hw, 17064U, autoc2);
#line 1177
    ixgbe_read_reg(hw, 8U);
  } else {

  }
#line 1180
  if (! hw->mac.orig_link_settings_stored) {
#line 1181
    hw->mac.orig_autoc = autoc;
#line 1182
    hw->mac.orig_autoc2 = autoc2;
#line 1183
    hw->mac.orig_link_settings_stored = 1;
  } else {
#line 1192
    if ((int )hw->phy.multispeed_fiber) {
#line 1192
      tmp___2 = ixgbe_mng_enabled(hw);
#line 1192
      if ((int )tmp___2) {
#line 1194
        hw->mac.orig_autoc = (hw->mac.orig_autoc & 4294909951U) | curr_lms;
      } else {
#line 1192
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1192
    if ((int )hw->wol_enabled) {
#line 1194
      hw->mac.orig_autoc = (hw->mac.orig_autoc & 4294909951U) | curr_lms;
    } else {

    }
#line 1198
    if (hw->mac.orig_autoc != autoc) {
#line 1199
      status = (*(hw->mac.ops.prot_autoc_write))(hw, hw->mac.orig_autoc, 0);
#line 1202
      if (status != 0) {
#line 1203
        return (status);
      } else {

      }
    } else {

    }
#line 1206
    if (((hw->mac.orig_autoc2 ^ autoc2) & 4294901760U) != 0U) {
#line 1208
      autoc2 = autoc2 & 65535U;
#line 1209
      autoc2 = (hw->mac.orig_autoc2 & 4294901760U) | autoc2;
#line 1211
      ixgbe_write_reg(hw, 17064U, autoc2);
    } else {

    }
  }
#line 1216
  (*(hw->mac.ops.get_mac_addr))(hw, (u8 *)(& hw->mac.perm_addr));
#line 1223
  hw->mac.num_rar_entries = 128U;
#line 1224
  (*(hw->mac.ops.init_rx_addrs))(hw);
#line 1227
  (*(hw->mac.ops.get_san_mac_addr))(hw, (u8 *)(& hw->mac.san_addr));
#line 1230
  tmp___3 = is_valid_ether_addr((u8 const   *)(& hw->mac.san_addr));
#line 1230
  if ((int )tmp___3) {
#line 1231
    (*(hw->mac.ops.set_rar))(hw, hw->mac.num_rar_entries - 1U, (u8 *)(& hw->mac.san_addr),
                             0U, 2147483648U);
#line 1235
    hw->mac.san_mac_rar_index = (unsigned int )((u8 )hw->mac.num_rar_entries) - 1U;
#line 1238
    hw->mac.num_rar_entries = hw->mac.num_rar_entries - 1U;
  } else {

  }
#line 1242
  (*(hw->mac.ops.get_wwn_prefix))(hw, & hw->mac.wwnn_prefix, & hw->mac.wwpn_prefix);
#line 1245
  return (status);
}
}
#line 1252 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw ) 
{ 
  int i ;
  u32 fdirctrl ;
  u32 tmp ;
  u32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  struct _ddebug descriptor___0 ;
  long tmp___5 ;

  {
#line 1255
  tmp = ixgbe_read_reg(hw, 60928U);
#line 1255
  fdirctrl = tmp;
#line 1257
  fdirctrl = fdirctrl & 4294967287U;
#line 1263
  i = 0;
#line 1263
  goto ldv_54670;
  ldv_54669: 
#line 1264
  tmp___0 = ixgbe_read_reg(hw, 60972U);
#line 1264
  if ((tmp___0 & 3U) == 0U) {
#line 1266
    goto ldv_54668;
  } else {

  }
#line 1267
  __const_udelay(42950UL);
#line 1263
  i = i + 1;
  ldv_54670: ;
#line 1263
  if (i <= 9) {
#line 1265
    goto ldv_54669;
  } else {

  }
  ldv_54668: ;
#line 1269
  if (i > 9) {
#line 1270
    descriptor.modname = "ixgbe";
#line 1270
    descriptor.function = "ixgbe_reinit_fdir_tables_82599";
#line 1270
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1270
    descriptor.format = "Flow Director previous command isn\'t complete, aborting table re-initialization.\n";
#line 1270
    descriptor.lineno = 1270U;
#line 1270
    descriptor.flags = 0U;
#line 1270
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1270
    if (tmp___1 != 0L) {
#line 1270
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flow Director previous command isn\'t complete, aborting table re-initialization.\n");
    } else {

    }
#line 1271
    return (-23);
  } else {

  }
#line 1274
  ixgbe_write_reg(hw, 60984U, 0U);
#line 1275
  ixgbe_read_reg(hw, 8U);
#line 1283
  tmp___2 = ixgbe_read_reg(hw, 60972U);
#line 1283
  ixgbe_write_reg(hw, 60972U, tmp___2 | 256U);
#line 1286
  ixgbe_read_reg(hw, 8U);
#line 1287
  tmp___3 = ixgbe_read_reg(hw, 60972U);
#line 1287
  ixgbe_write_reg(hw, 60972U, tmp___3 & 4294967039U);
#line 1290
  ixgbe_read_reg(hw, 8U);
#line 1295
  ixgbe_write_reg(hw, 60968U, 0U);
#line 1296
  ixgbe_read_reg(hw, 8U);
#line 1298
  ixgbe_write_reg(hw, 60928U, fdirctrl);
#line 1299
  ixgbe_read_reg(hw, 8U);
#line 1302
  i = 0;
#line 1302
  goto ldv_54675;
  ldv_54674: 
#line 1303
  tmp___4 = ixgbe_read_reg(hw, 60928U);
#line 1303
  if ((tmp___4 & 8U) != 0U) {
#line 1305
    goto ldv_54673;
  } else {

  }
#line 1306
  usleep_range(1000UL, 2000UL);
#line 1302
  i = i + 1;
  ldv_54675: ;
#line 1302
  if (i <= 9) {
#line 1304
    goto ldv_54674;
  } else {

  }
  ldv_54673: ;
#line 1308
  if (i > 9) {
#line 1309
    descriptor___0.modname = "ixgbe";
#line 1309
    descriptor___0.function = "ixgbe_reinit_fdir_tables_82599";
#line 1309
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1309
    descriptor___0.format = "Flow Director Signature poll time exceeded!\n";
#line 1309
    descriptor___0.lineno = 1309U;
#line 1309
    descriptor___0.flags = 0U;
#line 1309
    tmp___5 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 1309
    if (tmp___5 != 0L) {
#line 1309
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flow Director Signature poll time exceeded!\n");
    } else {

    }
#line 1310
    return (-23);
  } else {

  }
#line 1314
  ixgbe_read_reg(hw, 61008U);
#line 1315
  ixgbe_read_reg(hw, 61012U);
#line 1316
  ixgbe_read_reg(hw, 61016U);
#line 1317
  ixgbe_read_reg(hw, 61020U);
#line 1318
  ixgbe_read_reg(hw, 61004U);
#line 1320
  return (0);
}
}
#line 1328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_fdir_enable_82599(struct ixgbe_hw *hw , u32 fdirctrl ) 
{ 
  int i ;
  u32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
#line 1333
  ixgbe_write_reg(hw, 61032U, 1034753250U);
#line 1334
  ixgbe_write_reg(hw, 61036U, 390936084U);
#line 1349
  ixgbe_write_reg(hw, 60928U, fdirctrl);
#line 1350
  ixgbe_read_reg(hw, 8U);
#line 1351
  i = 0;
#line 1351
  goto ldv_54684;
  ldv_54683: 
#line 1352
  tmp = ixgbe_read_reg(hw, 60928U);
#line 1352
  if ((tmp & 8U) != 0U) {
#line 1354
    goto ldv_54682;
  } else {

  }
#line 1355
  usleep_range(1000UL, 2000UL);
#line 1351
  i = i + 1;
  ldv_54684: ;
#line 1351
  if (i <= 9) {
#line 1353
    goto ldv_54683;
  } else {

  }
  ldv_54682: ;
#line 1358
  if (i > 9) {
#line 1359
    descriptor.modname = "ixgbe";
#line 1359
    descriptor.function = "ixgbe_fdir_enable_82599";
#line 1359
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1359
    descriptor.format = "Flow Director poll time exceeded!\n";
#line 1359
    descriptor.lineno = 1359U;
#line 1359
    descriptor.flags = 0U;
#line 1359
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1359
    if (tmp___0 != 0L) {
#line 1359
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flow Director poll time exceeded!\n");
    } else {

    }
  } else {

  }
#line 1361
  return;
}
}
#line 1368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw , u32 fdirctrl ) 
{ 


  {
#line 1376
  fdirctrl = fdirctrl | 1241907200U;
#line 1381
  ixgbe_fdir_enable_82599(hw, fdirctrl);
#line 1383
  return (0);
}
}
#line 1392 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw , u32 fdirctrl ) 
{ 


  {
#line 1403
  fdirctrl = fdirctrl | 1241939760U;
#line 1411
  ixgbe_fdir_enable_82599(hw, fdirctrl);
#line 1413
  return (0);
}
}
#line 1450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static u32 ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input , union ixgbe_atr_hash_dword common ) 
{ 
  u32 hi_hash_dword ;
  u32 lo_hash_dword ;
  u32 flow_vm_vlan ;
  u32 sig_hash ;
  u32 bucket_hash ;
  u32 common_hash ;
  __u32 tmp ;
  __u32 tmp___0 ;
  u32 n ;
  u32 n___0 ;
  u32 n___1 ;
  u32 n___2 ;
  u32 n___3 ;
  u32 n___4 ;
  u32 n___5 ;
  u32 n___6 ;
  u32 n___7 ;
  u32 n___8 ;
  u32 n___9 ;
  u32 n___10 ;
  u32 n___11 ;
  u32 n___12 ;
  u32 n___13 ;
  u32 n___14 ;

  {
#line 1454
  sig_hash = 0U;
#line 1454
  bucket_hash = 0U;
#line 1454
  common_hash = 0U;
#line 1457
  tmp = __fswab32(input.dword);
#line 1457
  flow_vm_vlan = tmp;
#line 1460
  tmp___0 = __fswab32(common.dword);
#line 1460
  hi_hash_dword = tmp___0;
#line 1463
  lo_hash_dword = (hi_hash_dword << 16) | (hi_hash_dword >> (8UL * sizeof(hi_hash_dword) - 16UL));
#line 1466
  hi_hash_dword = ((flow_vm_vlan >> 16) ^ flow_vm_vlan) ^ hi_hash_dword;
#line 1469
  n = 0U;
#line 1469
  if ((353178624 >> (int )n) & 1) {
#line 1469
    common_hash = (lo_hash_dword >> (int )n) ^ common_hash;
  } else
#line 1469
  if ((1034753250 >> (int )n) & 1) {
#line 1469
    bucket_hash = (lo_hash_dword >> (int )n) ^ bucket_hash;
  } else
#line 1469
  if ((390936084 >> (int )n) & 1) {
#line 1469
    sig_hash = (lo_hash_dword << (int )(16U - n)) ^ sig_hash;
  } else {

  }
#line 1469
  if ((353178624 >> (int )(n + 16U)) & 1) {
#line 1469
    common_hash = (hi_hash_dword >> (int )n) ^ common_hash;
  } else
#line 1469
  if ((1034753250 >> (int )(n + 16U)) & 1) {
#line 1469
    bucket_hash = (hi_hash_dword >> (int )n) ^ bucket_hash;
  } else
#line 1469
  if ((390936084 >> (int )(n + 16U)) & 1) {
#line 1469
    sig_hash = (hi_hash_dword << (int )(16U - n)) ^ sig_hash;
  } else {

  }
#line 1476
  lo_hash_dword = ((flow_vm_vlan << 16) ^ flow_vm_vlan) ^ lo_hash_dword;
#line 1479
  n___0 = 1U;
#line 1479
  if ((353178624 >> (int )n___0) & 1) {
#line 1479
    common_hash = (lo_hash_dword >> (int )n___0) ^ common_hash;
  } else
#line 1479
  if ((1034753250 >> (int )n___0) & 1) {
#line 1479
    bucket_hash = (lo_hash_dword >> (int )n___0) ^ bucket_hash;
  } else
#line 1479
  if ((390936084 >> (int )n___0) & 1) {
#line 1479
    sig_hash = (lo_hash_dword << (int )(16U - n___0)) ^ sig_hash;
  } else {

  }
#line 1479
  if ((353178624 >> (int )(n___0 + 16U)) & 1) {
#line 1479
    common_hash = (hi_hash_dword >> (int )n___0) ^ common_hash;
  } else
#line 1479
  if ((1034753250 >> (int )(n___0 + 16U)) & 1) {
#line 1479
    bucket_hash = (hi_hash_dword >> (int )n___0) ^ bucket_hash;
  } else
#line 1479
  if ((390936084 >> (int )(n___0 + 16U)) & 1) {
#line 1479
    sig_hash = (hi_hash_dword << (int )(16U - n___0)) ^ sig_hash;
  } else {

  }
#line 1480
  n___1 = 2U;
#line 1480
  if ((353178624 >> (int )n___1) & 1) {
#line 1480
    common_hash = (lo_hash_dword >> (int )n___1) ^ common_hash;
  } else
#line 1480
  if ((1034753250 >> (int )n___1) & 1) {
#line 1480
    bucket_hash = (lo_hash_dword >> (int )n___1) ^ bucket_hash;
  } else
#line 1480
  if ((390936084 >> (int )n___1) & 1) {
#line 1480
    sig_hash = (lo_hash_dword << (int )(16U - n___1)) ^ sig_hash;
  } else {

  }
#line 1480
  if ((353178624 >> (int )(n___1 + 16U)) & 1) {
#line 1480
    common_hash = (hi_hash_dword >> (int )n___1) ^ common_hash;
  } else
#line 1480
  if ((1034753250 >> (int )(n___1 + 16U)) & 1) {
#line 1480
    bucket_hash = (hi_hash_dword >> (int )n___1) ^ bucket_hash;
  } else
#line 1480
  if ((390936084 >> (int )(n___1 + 16U)) & 1) {
#line 1480
    sig_hash = (hi_hash_dword << (int )(16U - n___1)) ^ sig_hash;
  } else {

  }
#line 1481
  n___2 = 3U;
#line 1481
  if ((353178624 >> (int )n___2) & 1) {
#line 1481
    common_hash = (lo_hash_dword >> (int )n___2) ^ common_hash;
  } else
#line 1481
  if ((1034753250 >> (int )n___2) & 1) {
#line 1481
    bucket_hash = (lo_hash_dword >> (int )n___2) ^ bucket_hash;
  } else
#line 1481
  if ((390936084 >> (int )n___2) & 1) {
#line 1481
    sig_hash = (lo_hash_dword << (int )(16U - n___2)) ^ sig_hash;
  } else {

  }
#line 1481
  if ((353178624 >> (int )(n___2 + 16U)) & 1) {
#line 1481
    common_hash = (hi_hash_dword >> (int )n___2) ^ common_hash;
  } else
#line 1481
  if ((1034753250 >> (int )(n___2 + 16U)) & 1) {
#line 1481
    bucket_hash = (hi_hash_dword >> (int )n___2) ^ bucket_hash;
  } else
#line 1481
  if ((390936084 >> (int )(n___2 + 16U)) & 1) {
#line 1481
    sig_hash = (hi_hash_dword << (int )(16U - n___2)) ^ sig_hash;
  } else {

  }
#line 1482
  n___3 = 4U;
#line 1482
  if ((353178624 >> (int )n___3) & 1) {
#line 1482
    common_hash = (lo_hash_dword >> (int )n___3) ^ common_hash;
  } else
#line 1482
  if ((1034753250 >> (int )n___3) & 1) {
#line 1482
    bucket_hash = (lo_hash_dword >> (int )n___3) ^ bucket_hash;
  } else
#line 1482
  if ((390936084 >> (int )n___3) & 1) {
#line 1482
    sig_hash = (lo_hash_dword << (int )(16U - n___3)) ^ sig_hash;
  } else {

  }
#line 1482
  if ((353178624 >> (int )(n___3 + 16U)) & 1) {
#line 1482
    common_hash = (hi_hash_dword >> (int )n___3) ^ common_hash;
  } else
#line 1482
  if ((1034753250 >> (int )(n___3 + 16U)) & 1) {
#line 1482
    bucket_hash = (hi_hash_dword >> (int )n___3) ^ bucket_hash;
  } else
#line 1482
  if ((390936084 >> (int )(n___3 + 16U)) & 1) {
#line 1482
    sig_hash = (hi_hash_dword << (int )(16U - n___3)) ^ sig_hash;
  } else {

  }
#line 1483
  n___4 = 5U;
#line 1483
  if ((353178624 >> (int )n___4) & 1) {
#line 1483
    common_hash = (lo_hash_dword >> (int )n___4) ^ common_hash;
  } else
#line 1483
  if ((1034753250 >> (int )n___4) & 1) {
#line 1483
    bucket_hash = (lo_hash_dword >> (int )n___4) ^ bucket_hash;
  } else
#line 1483
  if ((390936084 >> (int )n___4) & 1) {
#line 1483
    sig_hash = (lo_hash_dword << (int )(16U - n___4)) ^ sig_hash;
  } else {

  }
#line 1483
  if ((353178624 >> (int )(n___4 + 16U)) & 1) {
#line 1483
    common_hash = (hi_hash_dword >> (int )n___4) ^ common_hash;
  } else
#line 1483
  if ((1034753250 >> (int )(n___4 + 16U)) & 1) {
#line 1483
    bucket_hash = (hi_hash_dword >> (int )n___4) ^ bucket_hash;
  } else
#line 1483
  if ((390936084 >> (int )(n___4 + 16U)) & 1) {
#line 1483
    sig_hash = (hi_hash_dword << (int )(16U - n___4)) ^ sig_hash;
  } else {

  }
#line 1484
  n___5 = 6U;
#line 1484
  if ((353178624 >> (int )n___5) & 1) {
#line 1484
    common_hash = (lo_hash_dword >> (int )n___5) ^ common_hash;
  } else
#line 1484
  if ((1034753250 >> (int )n___5) & 1) {
#line 1484
    bucket_hash = (lo_hash_dword >> (int )n___5) ^ bucket_hash;
  } else
#line 1484
  if ((390936084 >> (int )n___5) & 1) {
#line 1484
    sig_hash = (lo_hash_dword << (int )(16U - n___5)) ^ sig_hash;
  } else {

  }
#line 1484
  if ((353178624 >> (int )(n___5 + 16U)) & 1) {
#line 1484
    common_hash = (hi_hash_dword >> (int )n___5) ^ common_hash;
  } else
#line 1484
  if ((1034753250 >> (int )(n___5 + 16U)) & 1) {
#line 1484
    bucket_hash = (hi_hash_dword >> (int )n___5) ^ bucket_hash;
  } else
#line 1484
  if ((390936084 >> (int )(n___5 + 16U)) & 1) {
#line 1484
    sig_hash = (hi_hash_dword << (int )(16U - n___5)) ^ sig_hash;
  } else {

  }
#line 1485
  n___6 = 7U;
#line 1485
  if ((353178624 >> (int )n___6) & 1) {
#line 1485
    common_hash = (lo_hash_dword >> (int )n___6) ^ common_hash;
  } else
#line 1485
  if ((1034753250 >> (int )n___6) & 1) {
#line 1485
    bucket_hash = (lo_hash_dword >> (int )n___6) ^ bucket_hash;
  } else
#line 1485
  if ((390936084 >> (int )n___6) & 1) {
#line 1485
    sig_hash = (lo_hash_dword << (int )(16U - n___6)) ^ sig_hash;
  } else {

  }
#line 1485
  if ((353178624 >> (int )(n___6 + 16U)) & 1) {
#line 1485
    common_hash = (hi_hash_dword >> (int )n___6) ^ common_hash;
  } else
#line 1485
  if ((1034753250 >> (int )(n___6 + 16U)) & 1) {
#line 1485
    bucket_hash = (hi_hash_dword >> (int )n___6) ^ bucket_hash;
  } else
#line 1485
  if ((390936084 >> (int )(n___6 + 16U)) & 1) {
#line 1485
    sig_hash = (hi_hash_dword << (int )(16U - n___6)) ^ sig_hash;
  } else {

  }
#line 1486
  n___7 = 8U;
#line 1486
  if ((353178624 >> (int )n___7) & 1) {
#line 1486
    common_hash = (lo_hash_dword >> (int )n___7) ^ common_hash;
  } else
#line 1486
  if ((1034753250 >> (int )n___7) & 1) {
#line 1486
    bucket_hash = (lo_hash_dword >> (int )n___7) ^ bucket_hash;
  } else
#line 1486
  if ((390936084 >> (int )n___7) & 1) {
#line 1486
    sig_hash = (lo_hash_dword << (int )(16U - n___7)) ^ sig_hash;
  } else {

  }
#line 1486
  if ((353178624 >> (int )(n___7 + 16U)) & 1) {
#line 1486
    common_hash = (hi_hash_dword >> (int )n___7) ^ common_hash;
  } else
#line 1486
  if ((1034753250 >> (int )(n___7 + 16U)) & 1) {
#line 1486
    bucket_hash = (hi_hash_dword >> (int )n___7) ^ bucket_hash;
  } else
#line 1486
  if ((390936084 >> (int )(n___7 + 16U)) & 1) {
#line 1486
    sig_hash = (hi_hash_dword << (int )(16U - n___7)) ^ sig_hash;
  } else {

  }
#line 1487
  n___8 = 9U;
#line 1487
  if ((353178624 >> (int )n___8) & 1) {
#line 1487
    common_hash = (lo_hash_dword >> (int )n___8) ^ common_hash;
  } else
#line 1487
  if ((1034753250 >> (int )n___8) & 1) {
#line 1487
    bucket_hash = (lo_hash_dword >> (int )n___8) ^ bucket_hash;
  } else
#line 1487
  if ((390936084 >> (int )n___8) & 1) {
#line 1487
    sig_hash = (lo_hash_dword << (int )(16U - n___8)) ^ sig_hash;
  } else {

  }
#line 1487
  if ((353178624 >> (int )(n___8 + 16U)) & 1) {
#line 1487
    common_hash = (hi_hash_dword >> (int )n___8) ^ common_hash;
  } else
#line 1487
  if ((1034753250 >> (int )(n___8 + 16U)) & 1) {
#line 1487
    bucket_hash = (hi_hash_dword >> (int )n___8) ^ bucket_hash;
  } else
#line 1487
  if ((390936084 >> (int )(n___8 + 16U)) & 1) {
#line 1487
    sig_hash = (hi_hash_dword << (int )(16U - n___8)) ^ sig_hash;
  } else {

  }
#line 1488
  n___9 = 10U;
#line 1488
  if ((353178624 >> (int )n___9) & 1) {
#line 1488
    common_hash = (lo_hash_dword >> (int )n___9) ^ common_hash;
  } else
#line 1488
  if ((1034753250 >> (int )n___9) & 1) {
#line 1488
    bucket_hash = (lo_hash_dword >> (int )n___9) ^ bucket_hash;
  } else
#line 1488
  if ((390936084 >> (int )n___9) & 1) {
#line 1488
    sig_hash = (lo_hash_dword << (int )(16U - n___9)) ^ sig_hash;
  } else {

  }
#line 1488
  if ((353178624 >> (int )(n___9 + 16U)) & 1) {
#line 1488
    common_hash = (hi_hash_dword >> (int )n___9) ^ common_hash;
  } else
#line 1488
  if ((1034753250 >> (int )(n___9 + 16U)) & 1) {
#line 1488
    bucket_hash = (hi_hash_dword >> (int )n___9) ^ bucket_hash;
  } else
#line 1488
  if ((390936084 >> (int )(n___9 + 16U)) & 1) {
#line 1488
    sig_hash = (hi_hash_dword << (int )(16U - n___9)) ^ sig_hash;
  } else {

  }
#line 1489
  n___10 = 11U;
#line 1489
  if ((353178624 >> (int )n___10) & 1) {
#line 1489
    common_hash = (lo_hash_dword >> (int )n___10) ^ common_hash;
  } else
#line 1489
  if ((1034753250 >> (int )n___10) & 1) {
#line 1489
    bucket_hash = (lo_hash_dword >> (int )n___10) ^ bucket_hash;
  } else
#line 1489
  if ((390936084 >> (int )n___10) & 1) {
#line 1489
    sig_hash = (lo_hash_dword << (int )(16U - n___10)) ^ sig_hash;
  } else {

  }
#line 1489
  if ((353178624 >> (int )(n___10 + 16U)) & 1) {
#line 1489
    common_hash = (hi_hash_dword >> (int )n___10) ^ common_hash;
  } else
#line 1489
  if ((1034753250 >> (int )(n___10 + 16U)) & 1) {
#line 1489
    bucket_hash = (hi_hash_dword >> (int )n___10) ^ bucket_hash;
  } else
#line 1489
  if ((390936084 >> (int )(n___10 + 16U)) & 1) {
#line 1489
    sig_hash = (hi_hash_dword << (int )(16U - n___10)) ^ sig_hash;
  } else {

  }
#line 1490
  n___11 = 12U;
#line 1490
  if ((353178624 >> (int )n___11) & 1) {
#line 1490
    common_hash = (lo_hash_dword >> (int )n___11) ^ common_hash;
  } else
#line 1490
  if ((1034753250 >> (int )n___11) & 1) {
#line 1490
    bucket_hash = (lo_hash_dword >> (int )n___11) ^ bucket_hash;
  } else
#line 1490
  if ((390936084 >> (int )n___11) & 1) {
#line 1490
    sig_hash = (lo_hash_dword << (int )(16U - n___11)) ^ sig_hash;
  } else {

  }
#line 1490
  if ((353178624 >> (int )(n___11 + 16U)) & 1) {
#line 1490
    common_hash = (hi_hash_dword >> (int )n___11) ^ common_hash;
  } else
#line 1490
  if ((1034753250 >> (int )(n___11 + 16U)) & 1) {
#line 1490
    bucket_hash = (hi_hash_dword >> (int )n___11) ^ bucket_hash;
  } else
#line 1490
  if ((390936084 >> (int )(n___11 + 16U)) & 1) {
#line 1490
    sig_hash = (hi_hash_dword << (int )(16U - n___11)) ^ sig_hash;
  } else {

  }
#line 1491
  n___12 = 13U;
#line 1491
  if ((353178624 >> (int )n___12) & 1) {
#line 1491
    common_hash = (lo_hash_dword >> (int )n___12) ^ common_hash;
  } else
#line 1491
  if ((1034753250 >> (int )n___12) & 1) {
#line 1491
    bucket_hash = (lo_hash_dword >> (int )n___12) ^ bucket_hash;
  } else
#line 1491
  if ((390936084 >> (int )n___12) & 1) {
#line 1491
    sig_hash = (lo_hash_dword << (int )(16U - n___12)) ^ sig_hash;
  } else {

  }
#line 1491
  if ((353178624 >> (int )(n___12 + 16U)) & 1) {
#line 1491
    common_hash = (hi_hash_dword >> (int )n___12) ^ common_hash;
  } else
#line 1491
  if ((1034753250 >> (int )(n___12 + 16U)) & 1) {
#line 1491
    bucket_hash = (hi_hash_dword >> (int )n___12) ^ bucket_hash;
  } else
#line 1491
  if ((390936084 >> (int )(n___12 + 16U)) & 1) {
#line 1491
    sig_hash = (hi_hash_dword << (int )(16U - n___12)) ^ sig_hash;
  } else {

  }
#line 1492
  n___13 = 14U;
#line 1492
  if ((353178624 >> (int )n___13) & 1) {
#line 1492
    common_hash = (lo_hash_dword >> (int )n___13) ^ common_hash;
  } else
#line 1492
  if ((1034753250 >> (int )n___13) & 1) {
#line 1492
    bucket_hash = (lo_hash_dword >> (int )n___13) ^ bucket_hash;
  } else
#line 1492
  if ((390936084 >> (int )n___13) & 1) {
#line 1492
    sig_hash = (lo_hash_dword << (int )(16U - n___13)) ^ sig_hash;
  } else {

  }
#line 1492
  if ((353178624 >> (int )(n___13 + 16U)) & 1) {
#line 1492
    common_hash = (hi_hash_dword >> (int )n___13) ^ common_hash;
  } else
#line 1492
  if ((1034753250 >> (int )(n___13 + 16U)) & 1) {
#line 1492
    bucket_hash = (hi_hash_dword >> (int )n___13) ^ bucket_hash;
  } else
#line 1492
  if ((390936084 >> (int )(n___13 + 16U)) & 1) {
#line 1492
    sig_hash = (hi_hash_dword << (int )(16U - n___13)) ^ sig_hash;
  } else {

  }
#line 1493
  n___14 = 15U;
#line 1493
  if ((353178624 >> (int )n___14) & 1) {
#line 1493
    common_hash = (lo_hash_dword >> (int )n___14) ^ common_hash;
  } else
#line 1493
  if ((1034753250 >> (int )n___14) & 1) {
#line 1493
    bucket_hash = (lo_hash_dword >> (int )n___14) ^ bucket_hash;
  } else
#line 1493
  if ((390936084 >> (int )n___14) & 1) {
#line 1493
    sig_hash = (lo_hash_dword << (int )(16U - n___14)) ^ sig_hash;
  } else {

  }
#line 1493
  if ((353178624 >> (int )(n___14 + 16U)) & 1) {
#line 1493
    common_hash = (hi_hash_dword >> (int )n___14) ^ common_hash;
  } else
#line 1493
  if ((1034753250 >> (int )(n___14 + 16U)) & 1) {
#line 1493
    bucket_hash = (hi_hash_dword >> (int )n___14) ^ bucket_hash;
  } else
#line 1493
  if ((390936084 >> (int )(n___14 + 16U)) & 1) {
#line 1493
    sig_hash = (hi_hash_dword << (int )(16U - n___14)) ^ sig_hash;
  } else {

  }
#line 1496
  bucket_hash = bucket_hash ^ common_hash;
#line 1497
  bucket_hash = bucket_hash & 32767U;
#line 1499
  sig_hash = (common_hash << 16) ^ sig_hash;
#line 1500
  sig_hash = sig_hash & 2147418112U;
#line 1503
  return (sig_hash ^ bucket_hash);
}
}
#line 1513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw , union ixgbe_atr_hash_dword input ,
                                          union ixgbe_atr_hash_dword common , u8 queue ) 
{ 
  u64 fdirhashcmd ;
  u32 fdircmd ;
  struct _ddebug descriptor ;
  long tmp ;
  u32 tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;

  {
#line 1525
  switch ((int )input.formatted.flow_type) {
  case 2: ;
  case 1: ;
  case 3: ;
  case 6: ;
  case 5: ;
  case 7: ;
#line 1532
  goto ldv_54735;
  default: 
#line 1534
  descriptor.modname = "ixgbe";
#line 1534
  descriptor.function = "ixgbe_fdir_add_signature_filter_82599";
#line 1534
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1534
  descriptor.format = " Error on flow type input\n";
#line 1534
  descriptor.lineno = 1534U;
#line 1534
  descriptor.flags = 0U;
#line 1534
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1534
  if (tmp != 0L) {
#line 1534
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Error on flow type input\n");
  } else {

  }
#line 1535
  return (-4);
  }
  ldv_54735: 
#line 1539
  fdircmd = 34825U;
#line 1541
  fdircmd = (u32 )((int )input.formatted.flow_type << 5) | fdircmd;
#line 1542
  fdircmd = ((unsigned int )queue << 16) | fdircmd;
#line 1548
  fdirhashcmd = (unsigned long long )fdircmd << 32;
#line 1549
  tmp___0 = ixgbe_atr_compute_sig_hash_82599(input, common);
#line 1549
  fdirhashcmd = (u64 )tmp___0 | fdirhashcmd;
#line 1550
  ixgbe_write_reg64(hw, 60968U, fdirhashcmd);
#line 1552
  descriptor___0.modname = "ixgbe";
#line 1552
  descriptor___0.function = "ixgbe_fdir_add_signature_filter_82599";
#line 1552
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1552
  descriptor___0.format = "Tx Queue=%x hash=%x\n";
#line 1552
  descriptor___0.lineno = 1552U;
#line 1552
  descriptor___0.flags = 0U;
#line 1552
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 1552
  if (tmp___1 != 0L) {
#line 1552
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Tx Queue=%x hash=%x\n", (int )queue, (unsigned int )fdirhashcmd);
  } else {

  }
#line 1554
  return (0);
}
}
#line 1577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input , union ixgbe_atr_input *input_mask ) 
{ 
  u32 hi_hash_dword ;
  u32 lo_hash_dword ;
  u32 flow_vm_vlan ;
  u32 bucket_hash ;
  u32 hi_dword ;
  int i ;
  __u32 tmp ;
  __u32 tmp___0 ;
  u32 n ;
  u32 n___0 ;

  {
#line 1582
  bucket_hash = 0U;
#line 1582
  hi_dword = 0U;
#line 1586
  i = 0;
#line 1586
  goto ldv_54751;
  ldv_54750: 
#line 1587
  input->dword_stream[i] = input->dword_stream[i] & input_mask->dword_stream[i];
#line 1586
  i = i + 1;
  ldv_54751: ;
#line 1586
  if (i <= 10) {
#line 1588
    goto ldv_54750;
  } else {

  }
#line 1590
  tmp = __fswab32(input->dword_stream[0]);
#line 1590
  flow_vm_vlan = tmp;
#line 1593
  i = 1;
#line 1593
  goto ldv_54754;
  ldv_54753: 
#line 1594
  hi_dword = input->dword_stream[i] ^ hi_dword;
#line 1593
  i = i + 1;
  ldv_54754: ;
#line 1593
  if (i <= 10) {
#line 1595
    goto ldv_54753;
  } else {

  }
#line 1595
  tmp___0 = __fswab32(hi_dword);
#line 1595
  hi_hash_dword = tmp___0;
#line 1598
  lo_hash_dword = (hi_hash_dword << 16) | (hi_hash_dword >> (8UL * sizeof(hi_hash_dword) - 16UL));
#line 1601
  hi_hash_dword = ((flow_vm_vlan >> 16) ^ flow_vm_vlan) ^ hi_hash_dword;
#line 1604
  n = 0U;
#line 1604
  if ((1034753250 >> (int )n) & 1) {
#line 1604
    bucket_hash = (lo_hash_dword >> (int )n) ^ bucket_hash;
  } else {

  }
#line 1604
  if ((1034753250 >> (int )(n + 16U)) & 1) {
#line 1604
    bucket_hash = (hi_hash_dword >> (int )n) ^ bucket_hash;
  } else {

  }
#line 1611
  lo_hash_dword = ((flow_vm_vlan << 16) ^ flow_vm_vlan) ^ lo_hash_dword;
#line 1614
  i = 1;
#line 1614
  goto ldv_54759;
  ldv_54758: 
#line 1615
  n___0 = (u32 )i;
#line 1615
  if ((1034753250 >> (int )n___0) & 1) {
#line 1615
    bucket_hash = (lo_hash_dword >> (int )n___0) ^ bucket_hash;
  } else {

  }
#line 1615
  if ((1034753250 >> (int )(n___0 + 16U)) & 1) {
#line 1615
    bucket_hash = (hi_hash_dword >> (int )n___0) ^ bucket_hash;
  } else {

  }
#line 1614
  i = i + 1;
  ldv_54759: ;
#line 1614
  if (i <= 15) {
#line 1616
    goto ldv_54758;
  } else {

  }
#line 1621
  input->formatted.bkt_hash = (unsigned int )((__be16 )bucket_hash) & 8191U;
#line 1622
  return;
}
}
#line 1633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static u32 ixgbe_get_fdirtcpm_82599(union ixgbe_atr_input *input_mask ) 
{ 
  u32 mask ;
  __u16 tmp ;
  __u16 tmp___0 ;

  {
#line 1635
  tmp = __fswab16((int )input_mask->formatted.dst_port);
#line 1635
  mask = (u32 )tmp;
#line 1637
  mask = mask << 16;
#line 1638
  tmp___0 = __fswab16((int )input_mask->formatted.src_port);
#line 1638
  mask = (u32 )tmp___0 | mask;
#line 1639
  mask = ((mask & 1431655765U) << 1) | ((mask & 2863311530U) >> 1);
#line 1640
  mask = ((mask & 858993459U) << 2) | ((mask & 3435973836U) >> 2);
#line 1641
  mask = ((mask & 252645135U) << 4) | ((mask & 4042322160U) >> 4);
#line 1642
  return (((mask & 16711935U) << 8) | ((mask & 4278255360U) >> 8));
}
}
#line 1662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw , union ixgbe_atr_input *input_mask ) 
{ 
  u32 fdirm ;
  u32 fdirtcpm ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  __u16 tmp___3 ;
  struct _ddebug descriptor___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___4 ;
  long tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;

  {
#line 1666
  fdirm = 32U;
#line 1680
  if ((unsigned int )input_mask->formatted.bkt_hash != 0U) {
#line 1681
    descriptor.modname = "ixgbe";
#line 1681
    descriptor.function = "ixgbe_fdir_set_input_mask_82599";
#line 1681
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1681
    descriptor.format = " bucket hash should always be 0 in mask\n";
#line 1681
    descriptor.lineno = 1681U;
#line 1681
    descriptor.flags = 0U;
#line 1681
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1681
    if (tmp != 0L) {
#line 1681
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           " bucket hash should always be 0 in mask\n");
    } else {

    }
  } else {

  }
#line 1684
  switch ((int )input_mask->formatted.vm_pool & 127) {
  case 0: 
#line 1686
  fdirm = fdirm | 4U;
  case 127: ;
#line 1688
  goto ldv_54775;
  default: 
#line 1690
  descriptor___0.modname = "ixgbe";
#line 1690
  descriptor___0.function = "ixgbe_fdir_set_input_mask_82599";
#line 1690
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1690
  descriptor___0.format = " Error on vm pool mask\n";
#line 1690
  descriptor___0.lineno = 1690U;
#line 1690
  descriptor___0.flags = 0U;
#line 1690
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 1690
  if (tmp___0 != 0L) {
#line 1690
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Error on vm pool mask\n");
  } else {

  }
#line 1691
  return (-4);
  }
  ldv_54775: ;
#line 1694
  switch ((int )input_mask->formatted.flow_type & 3) {
  case 0: 
#line 1696
  fdirm = fdirm | 8U;
#line 1697
  if ((unsigned int )input_mask->formatted.dst_port != 0U || (unsigned int )input_mask->formatted.src_port != 0U) {
#line 1699
    descriptor___1.modname = "ixgbe";
#line 1699
    descriptor___1.function = "ixgbe_fdir_set_input_mask_82599";
#line 1699
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1699
    descriptor___1.format = " Error on src/dst port mask\n";
#line 1699
    descriptor___1.lineno = 1699U;
#line 1699
    descriptor___1.flags = 0U;
#line 1699
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 1699
    if (tmp___1 != 0L) {
#line 1699
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           " Error on src/dst port mask\n");
    } else {

    }
#line 1700
    return (-4);
  } else {

  }
  case 3: ;
#line 1703
  goto ldv_54781;
  default: 
#line 1705
  descriptor___2.modname = "ixgbe";
#line 1705
  descriptor___2.function = "ixgbe_fdir_set_input_mask_82599";
#line 1705
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1705
  descriptor___2.format = " Error on flow type mask\n";
#line 1705
  descriptor___2.lineno = 1705U;
#line 1705
  descriptor___2.flags = 0U;
#line 1705
  tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 1705
  if (tmp___2 != 0L) {
#line 1705
    __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Error on flow type mask\n");
  } else {

  }
#line 1706
  return (-4);
  }
  ldv_54781: 
#line 1709
  tmp___3 = __fswab16((int )input_mask->formatted.vlan_id);
#line 1709
  switch ((int )tmp___3 & 61439) {
  case 0: 
#line 1712
  fdirm = fdirm | 1U;
  case 4095: 
#line 1715
  fdirm = fdirm | 2U;
#line 1716
  goto ldv_54786;
  case 57344: 
#line 1719
  fdirm = fdirm | 1U;
  case 61439: ;
#line 1722
  goto ldv_54786;
  default: 
#line 1724
  descriptor___3.modname = "ixgbe";
#line 1724
  descriptor___3.function = "ixgbe_fdir_set_input_mask_82599";
#line 1724
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1724
  descriptor___3.format = " Error on VLAN mask\n";
#line 1724
  descriptor___3.lineno = 1724U;
#line 1724
  descriptor___3.flags = 0U;
#line 1724
  tmp___4 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
#line 1724
  if (tmp___4 != 0L) {
#line 1724
    __dynamic_netdev_dbg(& descriptor___3, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Error on VLAN mask\n");
  } else {

  }
#line 1725
  return (-4);
  }
  ldv_54786: ;
#line 1728
  switch ((int )input_mask->formatted.flex_bytes) {
  case 0: 
#line 1731
  fdirm = fdirm | 16U;
  case 65535: ;
#line 1733
  goto ldv_54793;
  default: 
#line 1735
  descriptor___4.modname = "ixgbe";
#line 1735
  descriptor___4.function = "ixgbe_fdir_set_input_mask_82599";
#line 1735
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1735
  descriptor___4.format = " Error on flexible byte mask\n";
#line 1735
  descriptor___4.lineno = 1735U;
#line 1735
  descriptor___4.flags = 0U;
#line 1735
  tmp___5 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
#line 1735
  if (tmp___5 != 0L) {
#line 1735
    __dynamic_netdev_dbg(& descriptor___4, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Error on flexible byte mask\n");
  } else {

  }
#line 1736
  return (-4);
  }
  ldv_54793: 
#line 1740
  ixgbe_write_reg(hw, 61040U, fdirm);
#line 1743
  fdirtcpm = ixgbe_get_fdirtcpm_82599(input_mask);
#line 1746
  ixgbe_write_reg(hw, 60996U, ~ fdirtcpm);
#line 1747
  ixgbe_write_reg(hw, 61000U, ~ fdirtcpm);
#line 1750
  tmp___6 = __fswab32(~ input_mask->formatted.src_ip[0]);
#line 1750
  tmp___7 = __fswab32(~ input_mask->formatted.src_ip[0]);
#line 1750
  tmp___8 = __fswab32(~ input_mask->formatted.src_ip[0]);
#line 1750
  tmp___9 = __fswab32(~ input_mask->formatted.src_ip[0]);
#line 1750
  ixgbe_write_reg(hw, 60992U, (((tmp___6 >> 24) | ((tmp___7 & 16711680U) >> 8)) | ((tmp___8 & 65280U) << 8)) | (tmp___9 << 24));
#line 1752
  tmp___10 = __fswab32(~ input_mask->formatted.dst_ip[0]);
#line 1752
  tmp___11 = __fswab32(~ input_mask->formatted.dst_ip[0]);
#line 1752
  tmp___12 = __fswab32(~ input_mask->formatted.dst_ip[0]);
#line 1752
  tmp___13 = __fswab32(~ input_mask->formatted.dst_ip[0]);
#line 1752
  ixgbe_write_reg(hw, 60988U, (((tmp___10 >> 24) | ((tmp___11 & 16711680U) >> 8)) | ((tmp___12 & 65280U) << 8)) | (tmp___13 << 24));
#line 1755
  return (0);
}
}
#line 1758 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw , union ixgbe_atr_input *input ,
                                          u16 soft_id , u8 queue ) 
{ 
  u32 fdirport ;
  u32 fdirvlan ;
  u32 fdirhash ;
  u32 fdircmd ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;
  __u32 tmp___15 ;
  __u32 tmp___16 ;
  __u32 tmp___17 ;
  __u32 tmp___18 ;
  __u16 tmp___19 ;
  __u16 tmp___20 ;
  __u16 tmp___21 ;
  __u16 tmp___22 ;

  {
#line 1765
  tmp = __fswab32(input->formatted.src_ip[0]);
#line 1765
  tmp___0 = __fswab32(input->formatted.src_ip[0]);
#line 1765
  tmp___1 = __fswab32(input->formatted.src_ip[0]);
#line 1765
  tmp___2 = __fswab32(input->formatted.src_ip[0]);
#line 1765
  ixgbe_write_reg(hw, 60940U, (((tmp >> 24) | ((tmp___0 & 16711680U) >> 8)) | ((tmp___1 & 65280U) << 8)) | (tmp___2 << 24));
#line 1767
  tmp___3 = __fswab32(input->formatted.src_ip[1]);
#line 1767
  tmp___4 = __fswab32(input->formatted.src_ip[1]);
#line 1767
  tmp___5 = __fswab32(input->formatted.src_ip[1]);
#line 1767
  tmp___6 = __fswab32(input->formatted.src_ip[1]);
#line 1767
  ixgbe_write_reg(hw, 60944U, (((tmp___3 >> 24) | ((tmp___4 & 16711680U) >> 8)) | ((tmp___5 & 65280U) << 8)) | (tmp___6 << 24));
#line 1769
  tmp___7 = __fswab32(input->formatted.src_ip[2]);
#line 1769
  tmp___8 = __fswab32(input->formatted.src_ip[2]);
#line 1769
  tmp___9 = __fswab32(input->formatted.src_ip[2]);
#line 1769
  tmp___10 = __fswab32(input->formatted.src_ip[2]);
#line 1769
  ixgbe_write_reg(hw, 60948U, (((tmp___7 >> 24) | ((tmp___8 & 16711680U) >> 8)) | ((tmp___9 & 65280U) << 8)) | (tmp___10 << 24));
#line 1773
  tmp___11 = __fswab32(input->formatted.src_ip[0]);
#line 1773
  tmp___12 = __fswab32(input->formatted.src_ip[0]);
#line 1773
  tmp___13 = __fswab32(input->formatted.src_ip[0]);
#line 1773
  tmp___14 = __fswab32(input->formatted.src_ip[0]);
#line 1773
  ixgbe_write_reg(hw, 60952U, (((tmp___11 >> 24) | ((tmp___12 & 16711680U) >> 8)) | ((tmp___13 & 65280U) << 8)) | (tmp___14 << 24));
#line 1776
  tmp___15 = __fswab32(input->formatted.dst_ip[0]);
#line 1776
  tmp___16 = __fswab32(input->formatted.dst_ip[0]);
#line 1776
  tmp___17 = __fswab32(input->formatted.dst_ip[0]);
#line 1776
  tmp___18 = __fswab32(input->formatted.dst_ip[0]);
#line 1776
  ixgbe_write_reg(hw, 60956U, (((tmp___15 >> 24) | ((tmp___16 & 16711680U) >> 8)) | ((tmp___17 & 65280U) << 8)) | (tmp___18 << 24));
#line 1779
  tmp___19 = __fswab16((int )input->formatted.dst_port);
#line 1779
  fdirport = (u32 )tmp___19;
#line 1780
  fdirport = fdirport << 16;
#line 1781
  tmp___20 = __fswab16((int )input->formatted.src_port);
#line 1781
  fdirport = (u32 )tmp___20 | fdirport;
#line 1782
  ixgbe_write_reg(hw, 60960U, fdirport);
#line 1785
  tmp___21 = __fswab16((int )((unsigned short )((int )((short )((int )input->formatted.flex_bytes >> 8)) | (int )((short )((int )input->formatted.flex_bytes << 8)))));
#line 1785
  fdirvlan = (u32 )tmp___21;
#line 1786
  fdirvlan = fdirvlan << 16;
#line 1787
  tmp___22 = __fswab16((int )input->formatted.vlan_id);
#line 1787
  fdirvlan = (u32 )tmp___22 | fdirvlan;
#line 1788
  ixgbe_write_reg(hw, 60964U, fdirvlan);
#line 1791
  fdirhash = (u32 )input->formatted.bkt_hash;
#line 1792
  fdirhash = (u32 )((int )soft_id << 16) | fdirhash;
#line 1793
  ixgbe_write_reg(hw, 60968U, fdirhash);
#line 1799
  ixgbe_read_reg(hw, 8U);
#line 1802
  fdircmd = 34825U;
#line 1804
  if ((unsigned int )queue == 127U) {
#line 1805
    fdircmd = fdircmd | 512U;
  } else {

  }
#line 1806
  fdircmd = (u32 )((int )input->formatted.flow_type << 5) | fdircmd;
#line 1807
  fdircmd = ((unsigned int )queue << 16) | fdircmd;
#line 1808
  fdircmd = ((unsigned int )input->formatted.vm_pool << 24) | fdircmd;
#line 1810
  ixgbe_write_reg(hw, 60972U, fdircmd);
#line 1812
  return (0);
}
}
#line 1815 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw , union ixgbe_atr_input *input ,
                                          u16 soft_id ) 
{ 
  u32 fdirhash ;
  u32 fdircmd ;
  u32 retry_count ;
  s32 err ;

  {
#line 1820
  fdircmd = 0U;
#line 1822
  err = 0;
#line 1825
  fdirhash = (u32 )input->formatted.bkt_hash;
#line 1826
  fdirhash = (u32 )((int )soft_id << 16) | fdirhash;
#line 1827
  ixgbe_write_reg(hw, 60968U, fdirhash);
#line 1830
  ixgbe_read_reg(hw, 8U);
#line 1833
  ixgbe_write_reg(hw, 60972U, 3U);
#line 1835
  retry_count = 10U;
#line 1835
  goto ldv_54817;
  ldv_54816: 
#line 1837
  __const_udelay(42950UL);
#line 1839
  fdircmd = ixgbe_read_reg(hw, 60972U);
#line 1840
  if ((fdircmd & 3U) == 0U) {
#line 1841
    goto ldv_54815;
  } else {

  }
#line 1835
  retry_count = retry_count - 1U;
  ldv_54817: ;
#line 1835
  if (retry_count != 0U) {
#line 1837
    goto ldv_54816;
  } else {

  }
  ldv_54815: ;
#line 1844
  if (retry_count == 0U) {
#line 1845
    err = -23;
  } else {

  }
#line 1848
  if ((fdircmd & 4U) != 0U) {
#line 1849
    ixgbe_write_reg(hw, 60968U, fdirhash);
#line 1850
    ixgbe_read_reg(hw, 8U);
#line 1851
    ixgbe_write_reg(hw, 60972U, 2U);
  } else {

  }
#line 1855
  return (err);
}
}
#line 1866 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw , u32 reg , u8 *val ) 
{ 
  u32 core_ctl ;

  {
#line 1870
  ixgbe_write_reg(hw, 85760U, (reg << 8) | 65536U);
#line 1872
  ixgbe_read_reg(hw, 8U);
#line 1873
  __const_udelay(42950UL);
#line 1874
  core_ctl = ixgbe_read_reg(hw, 85760U);
#line 1875
  *val = (unsigned char )core_ctl;
#line 1877
  return (0);
}
}
#line 1888 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw , u32 reg , u8 val ) 
{ 
  u32 core_ctl ;

  {
#line 1892
  core_ctl = (reg << 8) | (u32 )val;
#line 1893
  ixgbe_write_reg(hw, 85760U, core_ctl);
#line 1894
  ixgbe_read_reg(hw, 8U);
#line 1895
  __const_udelay(42950UL);
#line 1897
  return (0);
}
}
#line 1908 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_start_hw_82599(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;
  s32 tmp ;

  {
#line 1910
  ret_val = 0;
#line 1912
  ret_val = ixgbe_start_hw_generic(hw);
#line 1913
  if (ret_val != 0) {
#line 1914
    return (ret_val);
  } else {

  }
#line 1916
  ret_val = ixgbe_start_hw_gen2(hw);
#line 1917
  if (ret_val != 0) {
#line 1918
    return (ret_val);
  } else {

  }
#line 1921
  hw->mac.autotry_restart = 1;
#line 1923
  if (ret_val != 0) {
#line 1924
    return (ret_val);
  } else {

  }
#line 1926
  tmp = ixgbe_verify_fw_version_82599(hw);
#line 1926
  return (tmp);
}
}
#line 1937 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_identify_phy_82599(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  enum ixgbe_media_type tmp ;

  {
#line 1942
  status = ixgbe_identify_phy_generic(hw);
#line 1943
  if (status != 0) {
#line 1945
    tmp = (*(hw->mac.ops.get_media_type))(hw);
#line 1945
    if ((unsigned int )tmp == 4U) {
#line 1946
      return (status);
    } else {

    }
#line 1947
    status = ixgbe_identify_module_generic(hw);
  } else {

  }
#line 1951
  if ((unsigned int )hw->phy.type == 0U) {
#line 1952
    hw->phy.type = 1;
#line 1953
    status = 0;
  } else {

  }
#line 1957
  if ((unsigned int )hw->phy.type == 23U) {
#line 1958
    return (-19);
  } else {

  }
#line 1960
  return (status);
}
}
#line 1970 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_enable_rx_dma_82599(struct ixgbe_hw *hw , u32 regval ) 
{ 


  {
#line 1978
  (*(hw->mac.ops.disable_rx_buff))(hw);
#line 1980
  if ((int )regval & 1) {
#line 1981
    (*(hw->mac.ops.enable_rx))(hw);
  } else {
#line 1983
    (*(hw->mac.ops.disable_rx))(hw);
  }
#line 1985
  (*(hw->mac.ops.enable_rx_buff))(hw);
#line 1987
  return (0);
}
}
#line 2000 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 fw_offset ;
  u16 fw_ptp_cfg_offset ;
  u16 offset ;
  u16 fw_version ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;

  {
#line 2002
  status = -24;
#line 2005
  fw_version = 0U;
#line 2008
  if ((unsigned int )hw->phy.media_type != 1U) {
#line 2009
    return (0);
  } else {

  }
#line 2012
  offset = 15U;
#line 2013
  tmp = (*(hw->eeprom.ops.read))(hw, (int )offset, & fw_offset);
#line 2013
  if (tmp != 0) {
#line 2014
    goto fw_version_err;
  } else {

  }
#line 2016
  if ((unsigned int )fw_offset == 0U || (unsigned int )fw_offset == 65535U) {
#line 2017
    return (-24);
  } else {

  }
#line 2020
  offset = (unsigned int )fw_offset + 4U;
#line 2021
  tmp___0 = (*(hw->eeprom.ops.read))(hw, (int )offset, & fw_ptp_cfg_offset);
#line 2021
  if (tmp___0 != 0) {
#line 2022
    goto fw_version_err;
  } else {

  }
#line 2024
  if ((unsigned int )fw_ptp_cfg_offset == 0U || (unsigned int )fw_ptp_cfg_offset == 65535U) {
#line 2025
    return (-24);
  } else {

  }
#line 2028
  offset = (unsigned int )fw_ptp_cfg_offset + 7U;
#line 2029
  tmp___1 = (*(hw->eeprom.ops.read))(hw, (int )offset, & fw_version);
#line 2029
  if (tmp___1 != 0) {
#line 2030
    goto fw_version_err;
  } else {

  }
#line 2032
  if ((unsigned int )fw_version > 5U) {
#line 2033
    status = 0;
  } else {

  }
#line 2035
  return (status);
  fw_version_err: 
#line 2038
  netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
             "eeprom read at offset %d failed\n", (int )offset);
#line 2039
  return (-24);
}
}
#line 2049 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw ) 
{ 
  u16 fw_offset ;
  u16 fw_lesm_param_offset ;
  u16 fw_lesm_state ;
  s32 status ;

  {
#line 2055
  status = (*(hw->eeprom.ops.read))(hw, 15, & fw_offset);
#line 2057
  if ((status != 0 || (unsigned int )fw_offset == 0U) || (unsigned int )fw_offset == 65535U) {
#line 2058
    return (0);
  } else {

  }
#line 2061
  status = (*(hw->eeprom.ops.read))(hw, (int )((unsigned int )fw_offset + 2U), & fw_lesm_param_offset);
#line 2065
  if ((status != 0 || (unsigned int )fw_lesm_param_offset == 0U) || (unsigned int )fw_lesm_param_offset == 65535U) {
#line 2067
    return (0);
  } else {

  }
#line 2070
  status = (*(hw->eeprom.ops.read))(hw, (int )((unsigned int )fw_lesm_param_offset + 1U),
                                    & fw_lesm_state);
#line 2074
  if (status == 0 && (int )((short )fw_lesm_state) < 0) {
#line 2075
    return (1);
  } else {

  }
#line 2077
  return (0);
}
}
#line 2091 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_read_eeprom_buffer_82599(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                          u16 *data ) 
{ 
  struct ixgbe_eeprom_info *eeprom ;
  s32 tmp ;
  s32 tmp___0 ;

  {
#line 2094
  eeprom = & hw->eeprom;
#line 2099
  if ((unsigned int )eeprom->type == 1U && (int )offset + ((int )words + -1) <= 16383) {
#line 2101
    tmp = ixgbe_read_eerd_buffer_generic(hw, (int )offset, (int )words, data);
#line 2101
    return (tmp);
  } else {

  }
#line 2103
  tmp___0 = ixgbe_read_eeprom_buffer_bit_bang_generic(hw, (int )offset, (int )words,
                                                      data);
#line 2103
  return (tmp___0);
}
}
#line 2117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_read_eeprom_82599(struct ixgbe_hw *hw , u16 offset , u16 *data ) 
{ 
  struct ixgbe_eeprom_info *eeprom ;
  s32 tmp ;
  s32 tmp___0 ;

  {
#line 2120
  eeprom = & hw->eeprom;
#line 2126
  if ((unsigned int )eeprom->type == 1U && (unsigned int )offset <= 16383U) {
#line 2127
    tmp = ixgbe_read_eerd_generic(hw, (int )offset, data);
#line 2127
    return (tmp);
  } else {

  }
#line 2129
  tmp___0 = ixgbe_read_eeprom_bit_bang_generic(hw, (int )offset, data);
#line 2129
  return (tmp___0);
}
}
#line 2141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;
  u32 anlp1_reg ;
  u32 i ;
  u32 autoc_reg ;
  u32 autoc2_reg ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 2144
  anlp1_reg = 0U;
#line 2148
  autoc2_reg = ixgbe_read_reg(hw, 17064U);
#line 2149
  if ((autoc2_reg & 1879048192U) != 0U) {
#line 2150
    autoc2_reg = autoc2_reg & 2415919103U;
#line 2151
    ixgbe_write_reg(hw, 17064U, autoc2_reg);
#line 2152
    ixgbe_read_reg(hw, 8U);
  } else {

  }
#line 2155
  autoc_reg = ixgbe_read_reg(hw, 17056U);
#line 2156
  autoc_reg = autoc_reg | 4096U;
#line 2159
  ixgbe_write_reg(hw, 17056U, autoc_reg ^ 32768U);
#line 2163
  i = 0U;
#line 2163
  goto ldv_54881;
  ldv_54880: 
#line 2164
  usleep_range(4000UL, 8000UL);
#line 2165
  anlp1_reg = ixgbe_read_reg(hw, 17072U);
#line 2166
  if ((anlp1_reg & 983040U) != 0U) {
#line 2167
    goto ldv_54879;
  } else {

  }
#line 2163
  i = i + 1U;
  ldv_54881: ;
#line 2163
  if (i <= 9U) {
#line 2165
    goto ldv_54880;
  } else {

  }
  ldv_54879: ;
#line 2170
  if ((anlp1_reg & 983040U) == 0U) {
#line 2171
    descriptor.modname = "ixgbe";
#line 2171
    descriptor.function = "ixgbe_reset_pipeline_82599";
#line 2171
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 2171
    descriptor.format = "auto negotiation not completed\n";
#line 2171
    descriptor.lineno = 2171U;
#line 2171
    descriptor.flags = 0U;
#line 2171
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2171
    if (tmp != 0L) {
#line 2171
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "auto negotiation not completed\n");
    } else {

    }
#line 2172
    ret_val = -15;
#line 2173
    goto reset_pipeline_out;
  } else {

  }
#line 2176
  ret_val = 0;
  reset_pipeline_out: 
#line 2180
  ixgbe_write_reg(hw, 17056U, autoc_reg);
#line 2181
  ixgbe_read_reg(hw, 8U);
#line 2183
  return (ret_val);
}
}
#line 2195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                     u8 *data ) 
{ 
  u32 esdp ;
  s32 status ;
  s32 timeout ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 2200
  timeout = 200;
#line 2202
  if ((int )hw->phy.qsfp_shared_i2c_bus) {
#line 2204
    esdp = ixgbe_read_reg(hw, 32U);
#line 2205
    esdp = esdp | 1U;
#line 2206
    ixgbe_write_reg(hw, 32U, esdp);
#line 2207
    ixgbe_read_reg(hw, 8U);
#line 2209
    goto ldv_54896;
    ldv_54895: 
#line 2210
    esdp = ixgbe_read_reg(hw, 32U);
#line 2211
    if ((esdp & 2U) != 0U) {
#line 2212
      goto ldv_54894;
    } else {

    }
#line 2214
    usleep_range(5000UL, 10000UL);
#line 2215
    timeout = timeout - 1;
    ldv_54896: ;
#line 2209
    if (timeout != 0) {
#line 2211
      goto ldv_54895;
    } else {

    }
    ldv_54894: ;
#line 2218
    if (timeout == 0) {
#line 2219
      descriptor.modname = "ixgbe";
#line 2219
      descriptor.function = "ixgbe_read_i2c_byte_82599";
#line 2219
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 2219
      descriptor.format = "Driver can\'t access resource, acquiring I2C bus timeout.\n";
#line 2219
      descriptor.lineno = 2219U;
#line 2219
      descriptor.flags = 0U;
#line 2219
      tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2219
      if (tmp != 0L) {
#line 2219
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Driver can\'t access resource, acquiring I2C bus timeout.\n");
      } else {

      }
#line 2220
      status = -18;
#line 2221
      goto release_i2c_access;
    } else {

    }
  } else {

  }
#line 2225
  status = ixgbe_read_i2c_byte_generic(hw, (int )byte_offset, (int )dev_addr, data);
  release_i2c_access: ;
#line 2228
  if ((int )hw->phy.qsfp_shared_i2c_bus) {
#line 2230
    esdp = ixgbe_read_reg(hw, 32U);
#line 2231
    esdp = esdp & 4294967294U;
#line 2232
    ixgbe_write_reg(hw, 32U, esdp);
#line 2233
    ixgbe_read_reg(hw, 8U);
  } else {

  }
#line 2236
  return (status);
}
}
#line 2248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                      u8 data ) 
{ 
  u32 esdp ;
  s32 status ;
  s32 timeout ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 2253
  timeout = 200;
#line 2255
  if ((int )hw->phy.qsfp_shared_i2c_bus) {
#line 2257
    esdp = ixgbe_read_reg(hw, 32U);
#line 2258
    esdp = esdp | 1U;
#line 2259
    ixgbe_write_reg(hw, 32U, esdp);
#line 2260
    ixgbe_read_reg(hw, 8U);
#line 2262
    goto ldv_54911;
    ldv_54910: 
#line 2263
    esdp = ixgbe_read_reg(hw, 32U);
#line 2264
    if ((esdp & 2U) != 0U) {
#line 2265
      goto ldv_54909;
    } else {

    }
#line 2267
    usleep_range(5000UL, 10000UL);
#line 2268
    timeout = timeout - 1;
    ldv_54911: ;
#line 2262
    if (timeout != 0) {
#line 2264
      goto ldv_54910;
    } else {

    }
    ldv_54909: ;
#line 2271
    if (timeout == 0) {
#line 2272
      descriptor.modname = "ixgbe";
#line 2272
      descriptor.function = "ixgbe_write_i2c_byte_82599";
#line 2272
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 2272
      descriptor.format = "Driver can\'t access resource, acquiring I2C bus timeout.\n";
#line 2272
      descriptor.lineno = 2272U;
#line 2272
      descriptor.flags = 0U;
#line 2272
      tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2272
      if (tmp != 0L) {
#line 2272
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Driver can\'t access resource, acquiring I2C bus timeout.\n");
      } else {

      }
#line 2273
      status = -18;
#line 2274
      goto release_i2c_access;
    } else {

    }
  } else {

  }
#line 2278
  status = ixgbe_write_i2c_byte_generic(hw, (int )byte_offset, (int )dev_addr, (int )data);
  release_i2c_access: ;
#line 2281
  if ((int )hw->phy.qsfp_shared_i2c_bus) {
#line 2283
    esdp = ixgbe_read_reg(hw, 32U);
#line 2284
    esdp = esdp & 4294967294U;
#line 2285
    ixgbe_write_reg(hw, 32U, esdp);
#line 2286
    ixgbe_read_reg(hw, 8U);
  } else {

  }
#line 2289
  return (status);
}
}
#line 2292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static struct ixgbe_mac_operations mac_ops_82599  = 
#line 2292
     {& ixgbe_init_hw_generic, & ixgbe_reset_hw_82599, & ixgbe_start_hw_82599, & ixgbe_clear_hw_cntrs_generic,
    & ixgbe_get_media_type_82599, & ixgbe_get_mac_addr_generic, & ixgbe_get_san_mac_addr_generic,
    & ixgbe_get_device_caps_generic, & ixgbe_get_wwn_prefix_generic, & ixgbe_stop_adapter_generic,
    & ixgbe_get_bus_info_generic, & ixgbe_set_lan_id_multi_port_pcie, & ixgbe_read_analog_reg8_82599,
    & ixgbe_write_analog_reg8_82599, & ixgbe_setup_sfp_modules_82599, & ixgbe_disable_rx_buff_generic,
    & ixgbe_enable_rx_buff_generic, & ixgbe_enable_rx_dma_82599, & ixgbe_acquire_swfw_sync,
    & ixgbe_release_swfw_sync, & prot_autoc_read_82599, & prot_autoc_write_82599,
    0, 0, 0, & ixgbe_stop_mac_link_on_d3_82599, & ixgbe_setup_mac_link_82599, & ixgbe_check_mac_link_generic,
    & ixgbe_get_link_capabilities_82599, & ixgbe_set_rxpba_generic, & ixgbe_led_on_generic,
    & ixgbe_led_off_generic, & ixgbe_blink_led_start_generic, & ixgbe_blink_led_stop_generic,
    & ixgbe_set_rar_generic, & ixgbe_clear_rar_generic, & ixgbe_set_vmdq_generic,
    & ixgbe_set_vmdq_san_mac_generic, & ixgbe_clear_vmdq_generic, & ixgbe_init_rx_addrs_generic,
    & ixgbe_update_mc_addr_list_generic, & ixgbe_enable_mc_generic, & ixgbe_disable_mc_generic,
    & ixgbe_clear_vfta_generic, & ixgbe_set_vfta_generic, & ixgbe_init_uta_tables_generic,
    & ixgbe_set_mac_anti_spoofing, & ixgbe_set_vlan_anti_spoofing, & ixgbe_fc_enable_generic,
    & ixgbe_set_fw_drv_ver_generic, & ixgbe_get_thermal_sensor_data_generic, & ixgbe_init_thermal_sensor_thresh_generic,
    & ixgbe_disable_rx_generic, & ixgbe_enable_rx_generic, 0, 0, 0, 0, 0};
#line 2346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static struct ixgbe_eeprom_operations eeprom_ops_82599  = 
#line 2346
     {& ixgbe_init_eeprom_params_generic, & ixgbe_read_eeprom_82599, & ixgbe_read_eeprom_buffer_82599,
    & ixgbe_write_eeprom_generic, & ixgbe_write_eeprom_buffer_bit_bang_generic, & ixgbe_validate_eeprom_checksum_generic,
    & ixgbe_update_eeprom_checksum_generic, & ixgbe_calc_eeprom_checksum_generic};
#line 2357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static struct ixgbe_phy_operations phy_ops_82599  = 
#line 2357
     {& ixgbe_identify_phy_82599, & ixgbe_identify_module_generic, & ixgbe_init_phy_ops_82599,
    & ixgbe_reset_phy_generic, & ixgbe_read_phy_reg_generic, & ixgbe_write_phy_reg_generic,
    0, 0, & ixgbe_setup_phy_link_generic, 0, & ixgbe_setup_phy_link_speed_generic,
    0, 0, & ixgbe_read_i2c_byte_generic, & ixgbe_write_i2c_byte_generic, & ixgbe_read_i2c_sff8472_generic,
    & ixgbe_read_i2c_eeprom_generic, & ixgbe_write_i2c_eeprom_generic, 0, 0, & ixgbe_tn_check_overtemp,
    0, 0};
#line 2374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
struct ixgbe_info ixgbe_82599_info  =    {2, & ixgbe_get_invariants_82599, & mac_ops_82599, & eeprom_ops_82599, & phy_ops_82599,
    & mbx_ops_generic, (u32 const   *)(& ixgbe_mvals_8259X)};
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
extern int ldv_release_33(void) ;
#line 332
extern int ldv_setup_32(void) ;
#line 333
extern int ldv_release_34(void) ;
#line 334
extern int ldv_probe_33(void) ;
#line 335
extern int ldv_release_32(void) ;
#line 336
extern int ldv_probe_34(void) ;
#line 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_initialize_ixgbe_mac_operations_34(void) 
{ 
  void *tmp ;

  {
#line 340
  tmp = ldv_init_zalloc(1696UL);
#line 340
  mac_ops_82599_group0 = (struct ixgbe_hw *)tmp;
#line 341
  return;
}
}
#line 343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_initialize_ixgbe_phy_operations_32(void) 
{ 
  void *tmp ;

  {
#line 344
  tmp = ldv_init_zalloc(1696UL);
#line 344
  phy_ops_82599_group0 = (struct ixgbe_hw *)tmp;
#line 345
  return;
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_initialize_ixgbe_eeprom_operations_33(void) 
{ 
  void *tmp ;

  {
#line 348
  tmp = ldv_init_zalloc(1696UL);
#line 348
  eeprom_ops_82599_group0 = (struct ixgbe_hw *)tmp;
#line 349
  return;
}
}
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_main_exported_33(void) 
{ 
  u16 ldvarg2 ;
  u16 ldvarg9 ;
  u16 ldvarg10 ;
  u16 ldvarg4 ;
  u16 *ldvarg1 ;
  void *tmp ;
  u16 *ldvarg8 ;
  void *tmp___0 ;
  u16 ldvarg6 ;
  u16 *ldvarg5 ;
  void *tmp___1 ;
  u16 *ldvarg0 ;
  void *tmp___2 ;
  u16 ldvarg3 ;
  u16 ldvarg7 ;
  int tmp___3 ;

  {
#line 356
  tmp = ldv_init_zalloc(2UL);
#line 356
  ldvarg1 = (u16 *)tmp;
#line 357
  tmp___0 = ldv_init_zalloc(2UL);
#line 357
  ldvarg8 = (u16 *)tmp___0;
#line 359
  tmp___1 = ldv_init_zalloc(2UL);
#line 359
  ldvarg5 = (u16 *)tmp___1;
#line 360
  tmp___2 = ldv_init_zalloc(2UL);
#line 360
  ldvarg0 = (u16 *)tmp___2;
#line 352
  ldv_memset((void *)(& ldvarg2), 0, 2UL);
#line 353
  ldv_memset((void *)(& ldvarg9), 0, 2UL);
#line 354
  ldv_memset((void *)(& ldvarg10), 0, 2UL);
#line 355
  ldv_memset((void *)(& ldvarg4), 0, 2UL);
#line 358
  ldv_memset((void *)(& ldvarg6), 0, 2UL);
#line 361
  ldv_memset((void *)(& ldvarg3), 0, 2UL);
#line 362
  ldv_memset((void *)(& ldvarg7), 0, 2UL);
#line 364
  tmp___3 = __VERIFIER_nondet_int();
#line 364
  switch (tmp___3) {
  case 0: ;
#line 367
  if (ldv_state_variable_33 == 2) {
#line 369
    ixgbe_write_eeprom_buffer_bit_bang_generic(eeprom_ops_82599_group0, (int )ldvarg10,
                                               (int )ldvarg9, ldvarg8);
#line 371
    ldv_state_variable_33 = 2;
  } else {

  }
#line 374
  goto ldv_54955;
  case 1: ;
#line 377
  if (ldv_state_variable_33 == 2) {
#line 379
    ixgbe_read_eeprom_buffer_82599(eeprom_ops_82599_group0, (int )ldvarg7, (int )ldvarg6,
                                   ldvarg5);
#line 381
    ldv_state_variable_33 = 2;
  } else {

  }
#line 384
  goto ldv_54955;
  case 2: ;
#line 387
  if (ldv_state_variable_33 == 1) {
#line 389
    ixgbe_update_eeprom_checksum_generic(eeprom_ops_82599_group0);
#line 391
    ldv_state_variable_33 = 1;
  } else {

  }
#line 394
  if (ldv_state_variable_33 == 2) {
#line 396
    ixgbe_update_eeprom_checksum_generic(eeprom_ops_82599_group0);
#line 398
    ldv_state_variable_33 = 2;
  } else {

  }
#line 401
  goto ldv_54955;
  case 3: ;
#line 404
  if (ldv_state_variable_33 == 1) {
#line 406
    ixgbe_calc_eeprom_checksum_generic(eeprom_ops_82599_group0);
#line 408
    ldv_state_variable_33 = 1;
  } else {

  }
#line 411
  if (ldv_state_variable_33 == 2) {
#line 413
    ixgbe_calc_eeprom_checksum_generic(eeprom_ops_82599_group0);
#line 415
    ldv_state_variable_33 = 2;
  } else {

  }
#line 418
  goto ldv_54955;
  case 4: ;
#line 421
  if (ldv_state_variable_33 == 1) {
#line 423
    ixgbe_write_eeprom_generic(eeprom_ops_82599_group0, (int )ldvarg4, (int )ldvarg3);
#line 425
    ldv_state_variable_33 = 1;
  } else {

  }
#line 428
  if (ldv_state_variable_33 == 2) {
#line 430
    ixgbe_write_eeprom_generic(eeprom_ops_82599_group0, (int )ldvarg4, (int )ldvarg3);
#line 432
    ldv_state_variable_33 = 2;
  } else {

  }
#line 435
  goto ldv_54955;
  case 5: ;
#line 438
  if (ldv_state_variable_33 == 1) {
#line 440
    ixgbe_read_eeprom_82599(eeprom_ops_82599_group0, (int )ldvarg2, ldvarg1);
#line 442
    ldv_state_variable_33 = 1;
  } else {

  }
#line 445
  if (ldv_state_variable_33 == 2) {
#line 447
    ixgbe_read_eeprom_82599(eeprom_ops_82599_group0, (int )ldvarg2, ldvarg1);
#line 449
    ldv_state_variable_33 = 2;
  } else {

  }
#line 452
  goto ldv_54955;
  case 6: ;
#line 455
  if (ldv_state_variable_33 == 1) {
#line 457
    ixgbe_init_eeprom_params_generic(eeprom_ops_82599_group0);
#line 459
    ldv_state_variable_33 = 1;
  } else {

  }
#line 462
  if (ldv_state_variable_33 == 2) {
#line 464
    ixgbe_init_eeprom_params_generic(eeprom_ops_82599_group0);
#line 466
    ldv_state_variable_33 = 2;
  } else {

  }
#line 469
  goto ldv_54955;
  case 7: ;
#line 472
  if (ldv_state_variable_33 == 1) {
#line 474
    ixgbe_validate_eeprom_checksum_generic(eeprom_ops_82599_group0, ldvarg0);
#line 476
    ldv_state_variable_33 = 1;
  } else {

  }
#line 479
  if (ldv_state_variable_33 == 2) {
#line 481
    ixgbe_validate_eeprom_checksum_generic(eeprom_ops_82599_group0, ldvarg0);
#line 483
    ldv_state_variable_33 = 2;
  } else {

  }
#line 486
  goto ldv_54955;
  case 8: ;
#line 489
  if (ldv_state_variable_33 == 2) {
#line 491
    ldv_release_33();
#line 493
    ldv_state_variable_33 = 1;
#line 494
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 497
  goto ldv_54955;
  case 9: ;
#line 500
  if (ldv_state_variable_33 == 1) {
#line 502
    ldv_probe_33();
#line 504
    ldv_state_variable_33 = 2;
#line 505
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 508
  goto ldv_54955;
  default: 
#line 509
  ldv_stop();
  }
  ldv_54955: ;
#line 513
  return;
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_main_exported_32(void) 
{ 
  u8 ldvarg28 ;
  u32 ldvarg19 ;
  u8 ldvarg22 ;
  u8 ldvarg25 ;
  u16 *ldvarg14 ;
  void *tmp ;
  u16 ldvarg17 ;
  ixgbe_link_speed ldvarg21 ;
  u32 ldvarg16 ;
  u32 ldvarg15 ;
  u8 ldvarg30 ;
  u8 ldvarg26 ;
  u8 *ldvarg27 ;
  void *tmp___0 ;
  u8 ldvarg24 ;
  u8 *ldvarg29 ;
  void *tmp___1 ;
  u8 ldvarg13 ;
  u8 ldvarg12 ;
  u8 ldvarg23 ;
  bool ldvarg20 ;
  u8 *ldvarg11 ;
  void *tmp___2 ;
  u32 ldvarg18 ;
  int tmp___3 ;

  {
#line 520
  tmp = ldv_init_zalloc(2UL);
#line 520
  ldvarg14 = (u16 *)tmp;
#line 527
  tmp___0 = ldv_init_zalloc(1UL);
#line 527
  ldvarg27 = (u8 *)tmp___0;
#line 529
  tmp___1 = ldv_init_zalloc(1UL);
#line 529
  ldvarg29 = (u8 *)tmp___1;
#line 534
  tmp___2 = ldv_init_zalloc(1UL);
#line 534
  ldvarg11 = (u8 *)tmp___2;
#line 516
  ldv_memset((void *)(& ldvarg28), 0, 1UL);
#line 517
  ldv_memset((void *)(& ldvarg19), 0, 4UL);
#line 518
  ldv_memset((void *)(& ldvarg22), 0, 1UL);
#line 519
  ldv_memset((void *)(& ldvarg25), 0, 1UL);
#line 521
  ldv_memset((void *)(& ldvarg17), 0, 2UL);
#line 522
  ldv_memset((void *)(& ldvarg21), 0, 4UL);
#line 523
  ldv_memset((void *)(& ldvarg16), 0, 4UL);
#line 524
  ldv_memset((void *)(& ldvarg15), 0, 4UL);
#line 525
  ldv_memset((void *)(& ldvarg30), 0, 1UL);
#line 526
  ldv_memset((void *)(& ldvarg26), 0, 1UL);
#line 528
  ldv_memset((void *)(& ldvarg24), 0, 1UL);
#line 530
  ldv_memset((void *)(& ldvarg13), 0, 1UL);
#line 531
  ldv_memset((void *)(& ldvarg12), 0, 1UL);
#line 532
  ldv_memset((void *)(& ldvarg23), 0, 1UL);
#line 533
  ldv_memset((void *)(& ldvarg20), 0, 1UL);
#line 535
  ldv_memset((void *)(& ldvarg18), 0, 4UL);
#line 537
  tmp___3 = __VERIFIER_nondet_int();
#line 537
  switch (tmp___3) {
  case 0: ;
#line 540
  if (ldv_state_variable_32 == 1) {
#line 542
    ixgbe_reset_phy_generic(phy_ops_82599_group0);
#line 544
    ldv_state_variable_32 = 1;
  } else {

  }
#line 547
  if (ldv_state_variable_32 == 3) {
#line 549
    ixgbe_reset_phy_generic(phy_ops_82599_group0);
#line 551
    ldv_state_variable_32 = 3;
  } else {

  }
#line 554
  if (ldv_state_variable_32 == 2) {
#line 556
    ixgbe_reset_phy_generic(phy_ops_82599_group0);
#line 558
    ldv_state_variable_32 = 2;
  } else {

  }
#line 561
  goto ldv_54990;
  case 1: ;
#line 564
  if (ldv_state_variable_32 == 3) {
#line 566
    ixgbe_read_i2c_eeprom_generic(phy_ops_82599_group0, (int )ldvarg30, ldvarg29);
#line 568
    ldv_state_variable_32 = 3;
  } else {

  }
#line 571
  goto ldv_54990;
  case 2: ;
#line 574
  if (ldv_state_variable_32 == 1) {
#line 576
    ixgbe_read_i2c_sff8472_generic(phy_ops_82599_group0, (int )ldvarg28, ldvarg27);
#line 578
    ldv_state_variable_32 = 1;
  } else {

  }
#line 581
  if (ldv_state_variable_32 == 3) {
#line 583
    ixgbe_read_i2c_sff8472_generic(phy_ops_82599_group0, (int )ldvarg28, ldvarg27);
#line 585
    ldv_state_variable_32 = 3;
  } else {

  }
#line 588
  if (ldv_state_variable_32 == 2) {
#line 590
    ixgbe_read_i2c_sff8472_generic(phy_ops_82599_group0, (int )ldvarg28, ldvarg27);
#line 592
    ldv_state_variable_32 = 2;
  } else {

  }
#line 595
  goto ldv_54990;
  case 3: ;
#line 598
  if (ldv_state_variable_32 == 3) {
#line 600
    ixgbe_write_i2c_byte_generic(phy_ops_82599_group0, (int )ldvarg26, (int )ldvarg25,
                                 (int )ldvarg24);
#line 602
    ldv_state_variable_32 = 3;
  } else {

  }
#line 605
  goto ldv_54990;
  case 4: ;
#line 608
  if (ldv_state_variable_32 == 1) {
#line 610
    ixgbe_identify_phy_82599(phy_ops_82599_group0);
#line 612
    ldv_state_variable_32 = 1;
  } else {

  }
#line 615
  if (ldv_state_variable_32 == 3) {
#line 617
    ixgbe_identify_phy_82599(phy_ops_82599_group0);
#line 619
    ldv_state_variable_32 = 3;
  } else {

  }
#line 622
  if (ldv_state_variable_32 == 2) {
#line 624
    ixgbe_identify_phy_82599(phy_ops_82599_group0);
#line 626
    ldv_state_variable_32 = 2;
  } else {

  }
#line 629
  goto ldv_54990;
  case 5: ;
#line 632
  if (ldv_state_variable_32 == 1) {
#line 634
    ixgbe_setup_phy_link_generic(phy_ops_82599_group0);
#line 636
    ldv_state_variable_32 = 1;
  } else {

  }
#line 639
  if (ldv_state_variable_32 == 3) {
#line 641
    ixgbe_setup_phy_link_generic(phy_ops_82599_group0);
#line 643
    ldv_state_variable_32 = 3;
  } else {

  }
#line 646
  if (ldv_state_variable_32 == 2) {
#line 648
    ixgbe_setup_phy_link_generic(phy_ops_82599_group0);
#line 650
    ldv_state_variable_32 = 2;
  } else {

  }
#line 653
  goto ldv_54990;
  case 6: ;
#line 656
  if (ldv_state_variable_32 == 1) {
#line 658
    ixgbe_write_i2c_eeprom_generic(phy_ops_82599_group0, (int )ldvarg23, (int )ldvarg22);
#line 660
    ldv_state_variable_32 = 1;
  } else {

  }
#line 663
  if (ldv_state_variable_32 == 3) {
#line 665
    ixgbe_write_i2c_eeprom_generic(phy_ops_82599_group0, (int )ldvarg23, (int )ldvarg22);
#line 667
    ldv_state_variable_32 = 3;
  } else {

  }
#line 670
  if (ldv_state_variable_32 == 2) {
#line 672
    ixgbe_write_i2c_eeprom_generic(phy_ops_82599_group0, (int )ldvarg23, (int )ldvarg22);
#line 674
    ldv_state_variable_32 = 2;
  } else {

  }
#line 677
  goto ldv_54990;
  case 7: ;
#line 680
  if (ldv_state_variable_32 == 1) {
#line 682
    ixgbe_setup_phy_link_speed_generic(phy_ops_82599_group0, ldvarg21, (int )ldvarg20);
#line 684
    ldv_state_variable_32 = 1;
  } else {

  }
#line 687
  if (ldv_state_variable_32 == 3) {
#line 689
    ixgbe_setup_phy_link_speed_generic(phy_ops_82599_group0, ldvarg21, (int )ldvarg20);
#line 691
    ldv_state_variable_32 = 3;
  } else {

  }
#line 694
  if (ldv_state_variable_32 == 2) {
#line 696
    ixgbe_setup_phy_link_speed_generic(phy_ops_82599_group0, ldvarg21, (int )ldvarg20);
#line 698
    ldv_state_variable_32 = 2;
  } else {

  }
#line 701
  goto ldv_54990;
  case 8: ;
#line 704
  if (ldv_state_variable_32 == 1) {
#line 706
    ixgbe_write_phy_reg_generic(phy_ops_82599_group0, ldvarg19, ldvarg18, (int )ldvarg17);
#line 708
    ldv_state_variable_32 = 1;
  } else {

  }
#line 711
  if (ldv_state_variable_32 == 3) {
#line 713
    ixgbe_write_phy_reg_generic(phy_ops_82599_group0, ldvarg19, ldvarg18, (int )ldvarg17);
#line 715
    ldv_state_variable_32 = 3;
  } else {

  }
#line 718
  if (ldv_state_variable_32 == 2) {
#line 720
    ixgbe_write_phy_reg_generic(phy_ops_82599_group0, ldvarg19, ldvarg18, (int )ldvarg17);
#line 722
    ldv_state_variable_32 = 2;
  } else {

  }
#line 725
  goto ldv_54990;
  case 9: ;
#line 728
  if (ldv_state_variable_32 == 1) {
#line 730
    ixgbe_identify_module_generic(phy_ops_82599_group0);
#line 732
    ldv_state_variable_32 = 1;
  } else {

  }
#line 735
  if (ldv_state_variable_32 == 3) {
#line 737
    ixgbe_identify_module_generic(phy_ops_82599_group0);
#line 739
    ldv_state_variable_32 = 3;
  } else {

  }
#line 742
  if (ldv_state_variable_32 == 2) {
#line 744
    ixgbe_identify_module_generic(phy_ops_82599_group0);
#line 746
    ldv_state_variable_32 = 2;
  } else {

  }
#line 749
  goto ldv_54990;
  case 10: ;
#line 752
  if (ldv_state_variable_32 == 1) {
#line 754
    ixgbe_read_phy_reg_generic(phy_ops_82599_group0, ldvarg16, ldvarg15, ldvarg14);
#line 756
    ldv_state_variable_32 = 1;
  } else {

  }
#line 759
  if (ldv_state_variable_32 == 3) {
#line 761
    ixgbe_read_phy_reg_generic(phy_ops_82599_group0, ldvarg16, ldvarg15, ldvarg14);
#line 763
    ldv_state_variable_32 = 3;
  } else {

  }
#line 766
  if (ldv_state_variable_32 == 2) {
#line 768
    ixgbe_read_phy_reg_generic(phy_ops_82599_group0, ldvarg16, ldvarg15, ldvarg14);
#line 770
    ldv_state_variable_32 = 2;
  } else {

  }
#line 773
  goto ldv_54990;
  case 11: ;
#line 776
  if (ldv_state_variable_32 == 1) {
#line 778
    ixgbe_tn_check_overtemp(phy_ops_82599_group0);
#line 780
    ldv_state_variable_32 = 1;
  } else {

  }
#line 783
  if (ldv_state_variable_32 == 3) {
#line 785
    ixgbe_tn_check_overtemp(phy_ops_82599_group0);
#line 787
    ldv_state_variable_32 = 3;
  } else {

  }
#line 790
  if (ldv_state_variable_32 == 2) {
#line 792
    ixgbe_tn_check_overtemp(phy_ops_82599_group0);
#line 794
    ldv_state_variable_32 = 2;
  } else {

  }
#line 797
  goto ldv_54990;
  case 12: ;
#line 800
  if (ldv_state_variable_32 == 1) {
#line 802
    ixgbe_read_i2c_byte_generic(phy_ops_82599_group0, (int )ldvarg13, (int )ldvarg12,
                                ldvarg11);
#line 804
    ldv_state_variable_32 = 1;
  } else {

  }
#line 807
  if (ldv_state_variable_32 == 3) {
#line 809
    ixgbe_read_i2c_byte_generic(phy_ops_82599_group0, (int )ldvarg13, (int )ldvarg12,
                                ldvarg11);
#line 811
    ldv_state_variable_32 = 3;
  } else {

  }
#line 814
  if (ldv_state_variable_32 == 2) {
#line 816
    ixgbe_read_i2c_byte_generic(phy_ops_82599_group0, (int )ldvarg13, (int )ldvarg12,
                                ldvarg11);
#line 818
    ldv_state_variable_32 = 2;
  } else {

  }
#line 821
  goto ldv_54990;
  case 13: ;
#line 824
  if (ldv_state_variable_32 == 2) {
#line 826
    ixgbe_init_phy_ops_82599(phy_ops_82599_group0);
#line 828
    ldv_state_variable_32 = 3;
  } else {

  }
#line 831
  goto ldv_54990;
  case 14: ;
#line 834
  if (ldv_state_variable_32 == 1) {
#line 836
    ldv_setup_32();
#line 838
    ldv_state_variable_32 = 2;
#line 839
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 842
  goto ldv_54990;
  case 15: ;
#line 845
  if (ldv_state_variable_32 == 3) {
#line 847
    ldv_release_32();
#line 849
    ldv_state_variable_32 = 1;
#line 850
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 853
  if (ldv_state_variable_32 == 2) {
#line 855
    ldv_release_32();
#line 857
    ldv_state_variable_32 = 1;
#line 858
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 861
  goto ldv_54990;
  default: 
#line 862
  ldv_stop();
  }
  ldv_54990: ;
#line 866
  return;
}
}
#line 868 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_main_exported_34(void) 
{ 
  u32 ldvarg505 ;
  int ldvarg537 ;
  u32 ldvarg513 ;
  bool *ldvarg511 ;
  void *tmp ;
  bool ldvarg538 ;
  u32 ldvarg551 ;
  u8 *ldvarg503 ;
  void *tmp___0 ;
  int ldvarg532 ;
  u32 ldvarg528 ;
  u32 *ldvarg545 ;
  void *tmp___1 ;
  bool ldvarg548 ;
  u32 ldvarg530 ;
  u16 *ldvarg525 ;
  void *tmp___2 ;
  u16 *ldvarg526 ;
  void *tmp___3 ;
  u32 ldvarg531 ;
  bool ldvarg523 ;
  u8 *ldvarg517 ;
  void *tmp___4 ;
  struct net_device *ldvarg527 ;
  void *tmp___5 ;
  u32 ldvarg544 ;
  u32 ldvarg549 ;
  bool ldvarg510 ;
  u8 *ldvarg521 ;
  void *tmp___6 ;
  u32 ldvarg502 ;
  u8 ldvarg508 ;
  bool ldvarg533 ;
  u32 ldvarg519 ;
  ixgbe_link_speed *ldvarg516 ;
  void *tmp___7 ;
  bool *ldvarg546 ;
  void *tmp___8 ;
  u32 ldvarg547 ;
  u32 ldvarg529 ;
  u32 ldvarg504 ;
  u8 ldvarg507 ;
  u32 ldvarg552 ;
  u32 ldvarg520 ;
  u32 ldvarg542 ;
  u8 *ldvarg514 ;
  void *tmp___9 ;
  u32 ldvarg550 ;
  u8 ldvarg509 ;
  int ldvarg534 ;
  bool *ldvarg515 ;
  void *tmp___10 ;
  u8 ldvarg506 ;
  u16 *ldvarg501 ;
  void *tmp___11 ;
  u32 ldvarg540 ;
  ixgbe_link_speed ldvarg524 ;
  ixgbe_link_speed *ldvarg512 ;
  void *tmp___12 ;
  u32 ldvarg541 ;
  u8 ldvarg518 ;
  bool ldvarg543 ;
  u32 ldvarg522 ;
  u32 ldvarg535 ;
  int ldvarg536 ;
  u32 ldvarg539 ;
  int tmp___13 ;

  {
#line 872
  tmp = ldv_init_zalloc(1UL);
#line 872
  ldvarg511 = (bool *)tmp;
#line 875
  tmp___0 = ldv_init_zalloc(1UL);
#line 875
  ldvarg503 = (u8 *)tmp___0;
#line 878
  tmp___1 = ldv_init_zalloc(4UL);
#line 878
  ldvarg545 = (u32 *)tmp___1;
#line 881
  tmp___2 = ldv_init_zalloc(2UL);
#line 881
  ldvarg525 = (u16 *)tmp___2;
#line 882
  tmp___3 = ldv_init_zalloc(2UL);
#line 882
  ldvarg526 = (u16 *)tmp___3;
#line 885
  tmp___4 = ldv_init_zalloc(1UL);
#line 885
  ldvarg517 = (u8 *)tmp___4;
#line 886
  tmp___5 = ldv_init_zalloc(3008UL);
#line 886
  ldvarg527 = (struct net_device *)tmp___5;
#line 890
  tmp___6 = ldv_init_zalloc(1UL);
#line 890
  ldvarg521 = (u8 *)tmp___6;
#line 895
  tmp___7 = ldv_init_zalloc(4UL);
#line 895
  ldvarg516 = (ixgbe_link_speed *)tmp___7;
#line 896
  tmp___8 = ldv_init_zalloc(1UL);
#line 896
  ldvarg546 = (bool *)tmp___8;
#line 904
  tmp___9 = ldv_init_zalloc(1UL);
#line 904
  ldvarg514 = (u8 *)tmp___9;
#line 908
  tmp___10 = ldv_init_zalloc(1UL);
#line 908
  ldvarg515 = (bool *)tmp___10;
#line 910
  tmp___11 = ldv_init_zalloc(2UL);
#line 910
  ldvarg501 = (u16 *)tmp___11;
#line 913
  tmp___12 = ldv_init_zalloc(4UL);
#line 913
  ldvarg512 = (ixgbe_link_speed *)tmp___12;
#line 869
  ldv_memset((void *)(& ldvarg505), 0, 4UL);
#line 870
  ldv_memset((void *)(& ldvarg537), 0, 4UL);
#line 871
  ldv_memset((void *)(& ldvarg513), 0, 4UL);
#line 873
  ldv_memset((void *)(& ldvarg538), 0, 1UL);
#line 874
  ldv_memset((void *)(& ldvarg551), 0, 4UL);
#line 876
  ldv_memset((void *)(& ldvarg532), 0, 4UL);
#line 877
  ldv_memset((void *)(& ldvarg528), 0, 4UL);
#line 879
  ldv_memset((void *)(& ldvarg548), 0, 1UL);
#line 880
  ldv_memset((void *)(& ldvarg530), 0, 4UL);
#line 883
  ldv_memset((void *)(& ldvarg531), 0, 4UL);
#line 884
  ldv_memset((void *)(& ldvarg523), 0, 1UL);
#line 887
  ldv_memset((void *)(& ldvarg544), 0, 4UL);
#line 888
  ldv_memset((void *)(& ldvarg549), 0, 4UL);
#line 889
  ldv_memset((void *)(& ldvarg510), 0, 1UL);
#line 891
  ldv_memset((void *)(& ldvarg502), 0, 4UL);
#line 892
  ldv_memset((void *)(& ldvarg508), 0, 1UL);
#line 893
  ldv_memset((void *)(& ldvarg533), 0, 1UL);
#line 894
  ldv_memset((void *)(& ldvarg519), 0, 4UL);
#line 897
  ldv_memset((void *)(& ldvarg547), 0, 4UL);
#line 898
  ldv_memset((void *)(& ldvarg529), 0, 4UL);
#line 899
  ldv_memset((void *)(& ldvarg504), 0, 4UL);
#line 900
  ldv_memset((void *)(& ldvarg507), 0, 1UL);
#line 901
  ldv_memset((void *)(& ldvarg552), 0, 4UL);
#line 902
  ldv_memset((void *)(& ldvarg520), 0, 4UL);
#line 903
  ldv_memset((void *)(& ldvarg542), 0, 4UL);
#line 905
  ldv_memset((void *)(& ldvarg550), 0, 4UL);
#line 906
  ldv_memset((void *)(& ldvarg509), 0, 1UL);
#line 907
  ldv_memset((void *)(& ldvarg534), 0, 4UL);
#line 909
  ldv_memset((void *)(& ldvarg506), 0, 1UL);
#line 911
  ldv_memset((void *)(& ldvarg540), 0, 4UL);
#line 912
  ldv_memset((void *)(& ldvarg524), 0, 4UL);
#line 914
  ldv_memset((void *)(& ldvarg541), 0, 4UL);
#line 915
  ldv_memset((void *)(& ldvarg518), 0, 1UL);
#line 916
  ldv_memset((void *)(& ldvarg543), 0, 1UL);
#line 917
  ldv_memset((void *)(& ldvarg522), 0, 4UL);
#line 918
  ldv_memset((void *)(& ldvarg535), 0, 4UL);
#line 919
  ldv_memset((void *)(& ldvarg536), 0, 4UL);
#line 920
  ldv_memset((void *)(& ldvarg539), 0, 4UL);
#line 922
  tmp___13 = __VERIFIER_nondet_int();
#line 922
  switch (tmp___13) {
  case 0: ;
#line 925
  if (ldv_state_variable_34 == 1) {
#line 927
    ixgbe_stop_adapter_generic(mac_ops_82599_group0);
#line 929
    ldv_state_variable_34 = 1;
  } else {

  }
#line 932
  if (ldv_state_variable_34 == 2) {
#line 934
    ixgbe_stop_adapter_generic(mac_ops_82599_group0);
#line 936
    ldv_state_variable_34 = 2;
  } else {

  }
#line 939
  goto ldv_55063;
  case 1: ;
#line 942
  if (ldv_state_variable_34 == 1) {
#line 944
    ixgbe_set_vmdq_san_mac_generic(mac_ops_82599_group0, ldvarg552);
#line 946
    ldv_state_variable_34 = 1;
  } else {

  }
#line 949
  if (ldv_state_variable_34 == 2) {
#line 951
    ixgbe_set_vmdq_san_mac_generic(mac_ops_82599_group0, ldvarg552);
#line 953
    ldv_state_variable_34 = 2;
  } else {

  }
#line 956
  goto ldv_55063;
  case 2: ;
#line 959
  if (ldv_state_variable_34 == 1) {
#line 961
    ixgbe_led_off_generic(mac_ops_82599_group0, ldvarg551);
#line 963
    ldv_state_variable_34 = 1;
  } else {

  }
#line 966
  if (ldv_state_variable_34 == 2) {
#line 968
    ixgbe_led_off_generic(mac_ops_82599_group0, ldvarg551);
#line 970
    ldv_state_variable_34 = 2;
  } else {

  }
#line 973
  goto ldv_55063;
  case 3: ;
#line 976
  if (ldv_state_variable_34 == 1) {
#line 978
    ixgbe_set_vfta_generic(mac_ops_82599_group0, ldvarg550, ldvarg549, (int )ldvarg548);
#line 980
    ldv_state_variable_34 = 1;
  } else {

  }
#line 983
  if (ldv_state_variable_34 == 2) {
#line 985
    ixgbe_set_vfta_generic(mac_ops_82599_group0, ldvarg550, ldvarg549, (int )ldvarg548);
#line 987
    ldv_state_variable_34 = 2;
  } else {

  }
#line 990
  goto ldv_55063;
  case 4: ;
#line 993
  if (ldv_state_variable_34 == 1) {
#line 995
    ixgbe_stop_mac_link_on_d3_82599(mac_ops_82599_group0);
#line 997
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1000
  if (ldv_state_variable_34 == 2) {
#line 1002
    ixgbe_stop_mac_link_on_d3_82599(mac_ops_82599_group0);
#line 1004
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1007
  goto ldv_55063;
  case 5: ;
#line 1010
  if (ldv_state_variable_34 == 1) {
#line 1012
    ixgbe_enable_rx_dma_82599(mac_ops_82599_group0, ldvarg547);
#line 1014
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1017
  if (ldv_state_variable_34 == 2) {
#line 1019
    ixgbe_enable_rx_dma_82599(mac_ops_82599_group0, ldvarg547);
#line 1021
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1024
  goto ldv_55063;
  case 6: ;
#line 1027
  if (ldv_state_variable_34 == 2) {
#line 1029
    prot_autoc_read_82599(mac_ops_82599_group0, ldvarg546, ldvarg545);
#line 1031
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1034
  goto ldv_55063;
  case 7: ;
#line 1037
  if (ldv_state_variable_34 == 1) {
#line 1039
    ixgbe_enable_rx_buff_generic(mac_ops_82599_group0);
#line 1041
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1044
  if (ldv_state_variable_34 == 2) {
#line 1046
    ixgbe_enable_rx_buff_generic(mac_ops_82599_group0);
#line 1048
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1051
  goto ldv_55063;
  case 8: ;
#line 1054
  if (ldv_state_variable_34 == 2) {
#line 1056
    prot_autoc_write_82599(mac_ops_82599_group0, ldvarg544, (int )ldvarg543);
#line 1058
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1061
  goto ldv_55063;
  case 9: ;
#line 1064
  if (ldv_state_variable_34 == 1) {
#line 1066
    ixgbe_led_on_generic(mac_ops_82599_group0, ldvarg542);
#line 1068
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1071
  if (ldv_state_variable_34 == 2) {
#line 1073
    ixgbe_led_on_generic(mac_ops_82599_group0, ldvarg542);
#line 1075
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1078
  goto ldv_55063;
  case 10: ;
#line 1081
  if (ldv_state_variable_34 == 1) {
#line 1083
    ixgbe_clear_rar_generic(mac_ops_82599_group0, ldvarg541);
#line 1085
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1088
  if (ldv_state_variable_34 == 2) {
#line 1090
    ixgbe_clear_rar_generic(mac_ops_82599_group0, ldvarg541);
#line 1092
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1095
  goto ldv_55063;
  case 11: ;
#line 1098
  if (ldv_state_variable_34 == 1) {
#line 1100
    ixgbe_blink_led_stop_generic(mac_ops_82599_group0, ldvarg540);
#line 1102
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1105
  if (ldv_state_variable_34 == 2) {
#line 1107
    ixgbe_blink_led_stop_generic(mac_ops_82599_group0, ldvarg540);
#line 1109
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1112
  goto ldv_55063;
  case 12: ;
#line 1115
  if (ldv_state_variable_34 == 1) {
#line 1117
    ixgbe_enable_rx_generic(mac_ops_82599_group0);
#line 1119
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1122
  if (ldv_state_variable_34 == 2) {
#line 1124
    ixgbe_enable_rx_generic(mac_ops_82599_group0);
#line 1126
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1129
  goto ldv_55063;
  case 13: ;
#line 1132
  if (ldv_state_variable_34 == 1) {
#line 1134
    ixgbe_get_bus_info_generic(mac_ops_82599_group0);
#line 1136
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1139
  if (ldv_state_variable_34 == 2) {
#line 1141
    ixgbe_get_bus_info_generic(mac_ops_82599_group0);
#line 1143
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1146
  goto ldv_55063;
  case 14: ;
#line 1149
  if (ldv_state_variable_34 == 1) {
#line 1151
    ixgbe_blink_led_start_generic(mac_ops_82599_group0, ldvarg539);
#line 1153
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1156
  if (ldv_state_variable_34 == 2) {
#line 1158
    ixgbe_blink_led_start_generic(mac_ops_82599_group0, ldvarg539);
#line 1160
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1163
  goto ldv_55063;
  case 15: ;
#line 1166
  if (ldv_state_variable_34 == 1) {
#line 1168
    ixgbe_disable_mc_generic(mac_ops_82599_group0);
#line 1170
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1173
  if (ldv_state_variable_34 == 2) {
#line 1175
    ixgbe_disable_mc_generic(mac_ops_82599_group0);
#line 1177
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1180
  goto ldv_55063;
  case 16: ;
#line 1183
  if (ldv_state_variable_34 == 1) {
#line 1185
    ixgbe_set_vlan_anti_spoofing(mac_ops_82599_group0, (int )ldvarg538, ldvarg537);
#line 1187
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1190
  if (ldv_state_variable_34 == 2) {
#line 1192
    ixgbe_set_vlan_anti_spoofing(mac_ops_82599_group0, (int )ldvarg538, ldvarg537);
#line 1194
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1197
  goto ldv_55063;
  case 17: ;
#line 1200
  if (ldv_state_variable_34 == 1) {
#line 1202
    ixgbe_set_rxpba_generic(mac_ops_82599_group0, ldvarg536, ldvarg535, ldvarg534);
#line 1204
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1207
  if (ldv_state_variable_34 == 2) {
#line 1209
    ixgbe_set_rxpba_generic(mac_ops_82599_group0, ldvarg536, ldvarg535, ldvarg534);
#line 1211
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1214
  goto ldv_55063;
  case 18: ;
#line 1217
  if (ldv_state_variable_34 == 1) {
#line 1219
    ixgbe_init_uta_tables_generic(mac_ops_82599_group0);
#line 1221
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1224
  if (ldv_state_variable_34 == 2) {
#line 1226
    ixgbe_init_uta_tables_generic(mac_ops_82599_group0);
#line 1228
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1231
  goto ldv_55063;
  case 19: ;
#line 1234
  if (ldv_state_variable_34 == 1) {
#line 1236
    ixgbe_set_mac_anti_spoofing(mac_ops_82599_group0, (int )ldvarg533, ldvarg532);
#line 1238
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1241
  if (ldv_state_variable_34 == 2) {
#line 1243
    ixgbe_set_mac_anti_spoofing(mac_ops_82599_group0, (int )ldvarg533, ldvarg532);
#line 1245
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1248
  goto ldv_55063;
  case 20: ;
#line 1251
  if (ldv_state_variable_34 == 1) {
#line 1253
    ixgbe_clear_vmdq_generic(mac_ops_82599_group0, ldvarg531, ldvarg530);
#line 1255
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1258
  if (ldv_state_variable_34 == 2) {
#line 1260
    ixgbe_clear_vmdq_generic(mac_ops_82599_group0, ldvarg531, ldvarg530);
#line 1262
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1265
  goto ldv_55063;
  case 21: ;
#line 1268
  if (ldv_state_variable_34 == 1) {
#line 1270
    ixgbe_set_vmdq_generic(mac_ops_82599_group0, ldvarg529, ldvarg528);
#line 1272
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1275
  if (ldv_state_variable_34 == 2) {
#line 1277
    ixgbe_set_vmdq_generic(mac_ops_82599_group0, ldvarg529, ldvarg528);
#line 1279
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1282
  goto ldv_55063;
  case 22: ;
#line 1285
  if (ldv_state_variable_34 == 1) {
#line 1287
    ixgbe_clear_vfta_generic(mac_ops_82599_group0);
#line 1289
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1292
  if (ldv_state_variable_34 == 2) {
#line 1294
    ixgbe_clear_vfta_generic(mac_ops_82599_group0);
#line 1296
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1299
  goto ldv_55063;
  case 23: ;
#line 1302
  if (ldv_state_variable_34 == 1) {
#line 1304
    ixgbe_get_media_type_82599(mac_ops_82599_group0);
#line 1306
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1309
  if (ldv_state_variable_34 == 2) {
#line 1311
    ixgbe_get_media_type_82599(mac_ops_82599_group0);
#line 1313
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1316
  goto ldv_55063;
  case 24: ;
#line 1319
  if (ldv_state_variable_34 == 1) {
#line 1321
    ixgbe_update_mc_addr_list_generic(mac_ops_82599_group0, ldvarg527);
#line 1323
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1326
  if (ldv_state_variable_34 == 2) {
#line 1328
    ixgbe_update_mc_addr_list_generic(mac_ops_82599_group0, ldvarg527);
#line 1330
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1333
  goto ldv_55063;
  case 25: ;
#line 1336
  if (ldv_state_variable_34 == 1) {
#line 1338
    ixgbe_get_thermal_sensor_data_generic(mac_ops_82599_group0);
#line 1340
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1343
  if (ldv_state_variable_34 == 2) {
#line 1345
    ixgbe_get_thermal_sensor_data_generic(mac_ops_82599_group0);
#line 1347
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1350
  goto ldv_55063;
  case 26: ;
#line 1353
  if (ldv_state_variable_34 == 1) {
#line 1355
    ixgbe_init_rx_addrs_generic(mac_ops_82599_group0);
#line 1357
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1360
  if (ldv_state_variable_34 == 2) {
#line 1362
    ixgbe_init_rx_addrs_generic(mac_ops_82599_group0);
#line 1364
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1367
  goto ldv_55063;
  case 27: ;
#line 1370
  if (ldv_state_variable_34 == 1) {
#line 1372
    ixgbe_fc_enable_generic(mac_ops_82599_group0);
#line 1374
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1377
  if (ldv_state_variable_34 == 2) {
#line 1379
    ixgbe_fc_enable_generic(mac_ops_82599_group0);
#line 1381
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1384
  goto ldv_55063;
  case 28: ;
#line 1387
  if (ldv_state_variable_34 == 1) {
#line 1389
    ixgbe_get_wwn_prefix_generic(mac_ops_82599_group0, ldvarg526, ldvarg525);
#line 1391
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1394
  if (ldv_state_variable_34 == 2) {
#line 1396
    ixgbe_get_wwn_prefix_generic(mac_ops_82599_group0, ldvarg526, ldvarg525);
#line 1398
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1401
  goto ldv_55063;
  case 29: ;
#line 1404
  if (ldv_state_variable_34 == 1) {
#line 1406
    ixgbe_clear_hw_cntrs_generic(mac_ops_82599_group0);
#line 1408
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1411
  if (ldv_state_variable_34 == 2) {
#line 1413
    ixgbe_clear_hw_cntrs_generic(mac_ops_82599_group0);
#line 1415
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1418
  goto ldv_55063;
  case 30: ;
#line 1421
  if (ldv_state_variable_34 == 1) {
#line 1423
    ixgbe_setup_mac_link_82599(mac_ops_82599_group0, ldvarg524, (int )ldvarg523);
#line 1425
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1428
  if (ldv_state_variable_34 == 2) {
#line 1430
    ixgbe_setup_mac_link_82599(mac_ops_82599_group0, ldvarg524, (int )ldvarg523);
#line 1432
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1435
  goto ldv_55063;
  case 31: ;
#line 1438
  if (ldv_state_variable_34 == 1) {
#line 1440
    ixgbe_read_analog_reg8_82599(mac_ops_82599_group0, ldvarg522, ldvarg521);
#line 1442
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1445
  if (ldv_state_variable_34 == 2) {
#line 1447
    ixgbe_read_analog_reg8_82599(mac_ops_82599_group0, ldvarg522, ldvarg521);
#line 1449
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1452
  goto ldv_55063;
  case 32: ;
#line 1455
  if (ldv_state_variable_34 == 1) {
#line 1457
    ixgbe_disable_rx_generic(mac_ops_82599_group0);
#line 1459
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1462
  if (ldv_state_variable_34 == 2) {
#line 1464
    ixgbe_disable_rx_generic(mac_ops_82599_group0);
#line 1466
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1469
  goto ldv_55063;
  case 33: ;
#line 1472
  if (ldv_state_variable_34 == 1) {
#line 1474
    ixgbe_acquire_swfw_sync(mac_ops_82599_group0, ldvarg520);
#line 1476
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1479
  if (ldv_state_variable_34 == 2) {
#line 1481
    ixgbe_acquire_swfw_sync(mac_ops_82599_group0, ldvarg520);
#line 1483
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1486
  goto ldv_55063;
  case 34: ;
#line 1489
  if (ldv_state_variable_34 == 1) {
#line 1491
    ixgbe_set_lan_id_multi_port_pcie(mac_ops_82599_group0);
#line 1493
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1496
  if (ldv_state_variable_34 == 2) {
#line 1498
    ixgbe_set_lan_id_multi_port_pcie(mac_ops_82599_group0);
#line 1500
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1503
  goto ldv_55063;
  case 35: ;
#line 1506
  if (ldv_state_variable_34 == 1) {
#line 1508
    ixgbe_start_hw_82599(mac_ops_82599_group0);
#line 1510
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1513
  if (ldv_state_variable_34 == 2) {
#line 1515
    ixgbe_start_hw_82599(mac_ops_82599_group0);
#line 1517
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1520
  goto ldv_55063;
  case 36: ;
#line 1523
  if (ldv_state_variable_34 == 1) {
#line 1525
    ixgbe_write_analog_reg8_82599(mac_ops_82599_group0, ldvarg519, (int )ldvarg518);
#line 1527
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1530
  if (ldv_state_variable_34 == 2) {
#line 1532
    ixgbe_write_analog_reg8_82599(mac_ops_82599_group0, ldvarg519, (int )ldvarg518);
#line 1534
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1537
  goto ldv_55063;
  case 37: ;
#line 1540
  if (ldv_state_variable_34 == 1) {
#line 1542
    ixgbe_enable_mc_generic(mac_ops_82599_group0);
#line 1544
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1547
  if (ldv_state_variable_34 == 2) {
#line 1549
    ixgbe_enable_mc_generic(mac_ops_82599_group0);
#line 1551
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1554
  goto ldv_55063;
  case 38: ;
#line 1557
  if (ldv_state_variable_34 == 1) {
#line 1559
    ixgbe_get_mac_addr_generic(mac_ops_82599_group0, ldvarg517);
#line 1561
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1564
  if (ldv_state_variable_34 == 2) {
#line 1566
    ixgbe_get_mac_addr_generic(mac_ops_82599_group0, ldvarg517);
#line 1568
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1571
  goto ldv_55063;
  case 39: ;
#line 1574
  if (ldv_state_variable_34 == 1) {
#line 1576
    ixgbe_get_link_capabilities_82599(mac_ops_82599_group0, ldvarg516, ldvarg515);
#line 1578
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1581
  if (ldv_state_variable_34 == 2) {
#line 1583
    ixgbe_get_link_capabilities_82599(mac_ops_82599_group0, ldvarg516, ldvarg515);
#line 1585
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1588
  goto ldv_55063;
  case 40: ;
#line 1591
  if (ldv_state_variable_34 == 1) {
#line 1593
    ixgbe_get_san_mac_addr_generic(mac_ops_82599_group0, ldvarg514);
#line 1595
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1598
  if (ldv_state_variable_34 == 2) {
#line 1600
    ixgbe_get_san_mac_addr_generic(mac_ops_82599_group0, ldvarg514);
#line 1602
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1605
  goto ldv_55063;
  case 41: ;
#line 1608
  if (ldv_state_variable_34 == 1) {
#line 1610
    ixgbe_init_thermal_sensor_thresh_generic(mac_ops_82599_group0);
#line 1612
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1615
  if (ldv_state_variable_34 == 2) {
#line 1617
    ixgbe_init_thermal_sensor_thresh_generic(mac_ops_82599_group0);
#line 1619
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1622
  goto ldv_55063;
  case 42: ;
#line 1625
  if (ldv_state_variable_34 == 1) {
#line 1627
    ixgbe_init_hw_generic(mac_ops_82599_group0);
#line 1629
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1632
  if (ldv_state_variable_34 == 2) {
#line 1634
    ixgbe_init_hw_generic(mac_ops_82599_group0);
#line 1636
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1639
  goto ldv_55063;
  case 43: ;
#line 1642
  if (ldv_state_variable_34 == 1) {
#line 1644
    ixgbe_reset_hw_82599(mac_ops_82599_group0);
#line 1646
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1649
  if (ldv_state_variable_34 == 2) {
#line 1651
    ixgbe_reset_hw_82599(mac_ops_82599_group0);
#line 1653
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1656
  goto ldv_55063;
  case 44: ;
#line 1659
  if (ldv_state_variable_34 == 1) {
#line 1661
    ixgbe_release_swfw_sync(mac_ops_82599_group0, ldvarg513);
#line 1663
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1666
  if (ldv_state_variable_34 == 2) {
#line 1668
    ixgbe_release_swfw_sync(mac_ops_82599_group0, ldvarg513);
#line 1670
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1673
  goto ldv_55063;
  case 45: ;
#line 1676
  if (ldv_state_variable_34 == 1) {
#line 1678
    ixgbe_check_mac_link_generic(mac_ops_82599_group0, ldvarg512, ldvarg511, (int )ldvarg510);
#line 1680
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1683
  if (ldv_state_variable_34 == 2) {
#line 1685
    ixgbe_check_mac_link_generic(mac_ops_82599_group0, ldvarg512, ldvarg511, (int )ldvarg510);
#line 1687
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1690
  goto ldv_55063;
  case 46: ;
#line 1693
  if (ldv_state_variable_34 == 1) {
#line 1695
    ixgbe_set_fw_drv_ver_generic(mac_ops_82599_group0, (int )ldvarg508, (int )ldvarg507,
                                 (int )ldvarg506, (int )ldvarg509);
#line 1697
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1700
  if (ldv_state_variable_34 == 2) {
#line 1702
    ixgbe_set_fw_drv_ver_generic(mac_ops_82599_group0, (int )ldvarg508, (int )ldvarg507,
                                 (int )ldvarg506, (int )ldvarg509);
#line 1704
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1707
  goto ldv_55063;
  case 47: ;
#line 1710
  if (ldv_state_variable_34 == 1) {
#line 1712
    ixgbe_set_rar_generic(mac_ops_82599_group0, ldvarg504, ldvarg503, ldvarg502, ldvarg505);
#line 1714
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1717
  if (ldv_state_variable_34 == 2) {
#line 1719
    ixgbe_set_rar_generic(mac_ops_82599_group0, ldvarg504, ldvarg503, ldvarg502, ldvarg505);
#line 1721
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1724
  goto ldv_55063;
  case 48: ;
#line 1727
  if (ldv_state_variable_34 == 1) {
#line 1729
    ixgbe_setup_sfp_modules_82599(mac_ops_82599_group0);
#line 1731
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1734
  if (ldv_state_variable_34 == 2) {
#line 1736
    ixgbe_setup_sfp_modules_82599(mac_ops_82599_group0);
#line 1738
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1741
  goto ldv_55063;
  case 49: ;
#line 1744
  if (ldv_state_variable_34 == 1) {
#line 1746
    ixgbe_get_device_caps_generic(mac_ops_82599_group0, ldvarg501);
#line 1748
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1751
  if (ldv_state_variable_34 == 2) {
#line 1753
    ixgbe_get_device_caps_generic(mac_ops_82599_group0, ldvarg501);
#line 1755
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1758
  goto ldv_55063;
  case 50: ;
#line 1761
  if (ldv_state_variable_34 == 1) {
#line 1763
    ixgbe_disable_rx_buff_generic(mac_ops_82599_group0);
#line 1765
    ldv_state_variable_34 = 1;
  } else {

  }
#line 1768
  if (ldv_state_variable_34 == 2) {
#line 1770
    ixgbe_disable_rx_buff_generic(mac_ops_82599_group0);
#line 1772
    ldv_state_variable_34 = 2;
  } else {

  }
#line 1775
  goto ldv_55063;
  case 51: ;
#line 1778
  if (ldv_state_variable_34 == 2) {
#line 1780
    ldv_release_34();
#line 1782
    ldv_state_variable_34 = 1;
#line 1783
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1786
  goto ldv_55063;
  case 52: ;
#line 1789
  if (ldv_state_variable_34 == 1) {
#line 1791
    ldv_probe_34();
#line 1793
    ldv_state_variable_34 = 2;
#line 1794
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1797
  goto ldv_55063;
  default: 
#line 1798
  ldv_stop();
  }
  ldv_55063: ;
#line 1802
  return;
}
}
#line 1804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_main_exported_31(void) 
{ 
  struct ixgbe_hw *ldvarg324 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1805
  tmp = ldv_init_zalloc(1696UL);
#line 1805
  ldvarg324 = (struct ixgbe_hw *)tmp;
#line 1807
  tmp___0 = __VERIFIER_nondet_int();
#line 1807
  switch (tmp___0) {
  case 0: ;
#line 1810
  if (ldv_state_variable_31 == 1) {
#line 1812
    ixgbe_get_invariants_82599(ldvarg324);
#line 1814
    ldv_state_variable_31 = 1;
  } else {

  }
#line 1817
  goto ldv_55122;
  default: 
#line 1818
  ldv_stop();
  }
  ldv_55122: ;
#line 1822
  return;
}
}
#line 1847 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
bool ldv_queue_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1851
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1851
  ldv_func_res = tmp;
#line 1853
  activate_work_9(ldv_func_arg3, 2);
#line 1855
  return (ldv_func_res);
}
}
#line 1858 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
bool ldv_queue_delayed_work_on_136(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1862
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1862
  ldv_func_res = tmp;
#line 1864
  activate_work_9(& ldv_func_arg3->work, 2);
#line 1866
  return (ldv_func_res);
}
}
#line 1869 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
bool ldv_queue_work_on_137(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1873
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1873
  ldv_func_res = tmp;
#line 1875
  activate_work_9(ldv_func_arg3, 2);
#line 1877
  return (ldv_func_res);
}
}
#line 1880 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_flush_workqueue_138(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1883
  flush_workqueue(ldv_func_arg1);
#line 1885
  call_and_disable_all_9(2);
#line 1886
  return;
}
}
#line 1888 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
bool ldv_queue_delayed_work_on_139(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1892
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1892
  ldv_func_res = tmp;
#line 1894
  activate_work_9(& ldv_func_arg3->work, 2);
#line 1896
  return (ldv_func_res);
}
}
#line 1899 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_mutex_lock_140(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1902
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1904
  mutex_lock(ldv_func_arg1);
#line 1905
  return;
}
}
#line 1907 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_mutex_unlock_141(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1910
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1912
  mutex_unlock(ldv_func_arg1);
#line 1913
  return;
}
}
#line 1915 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_mutex_lock_142(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1918
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1920
  mutex_lock(ldv_func_arg1);
#line 1921
  return;
}
}
#line 1923 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
int ldv_mutex_trylock_143(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1927
  tmp = mutex_trylock(ldv_func_arg1);
#line 1927
  ldv_func_res = tmp;
#line 1929
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1929
  return (tmp___0);
#line 1931
  return (ldv_func_res);
}
}
#line 1934 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_mutex_unlock_144(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1937
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1939
  mutex_unlock(ldv_func_arg1);
#line 1940
  return;
}
}
#line 1942 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1945
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 1947
  mutex_unlock(ldv_func_arg1);
#line 1948
  return;
}
}
#line 1950 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.o.c.prepared"
void ldv_mutex_lock_146(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1953
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 1955
  mutex_lock(ldv_func_arg1);
#line 1956
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_171(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_169(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_172(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_173(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_mutex_lock_168(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_170(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_174(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_163(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_164(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_167(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_166(struct workqueue_struct *ldv_func_arg1 ) ;
#line 124 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h"
s32 ixgbe_read_phy_reg_mdi(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                           u16 *phy_data ) ;
#line 126
s32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                            u16 phy_data ) ;
#line 147
s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw ) ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                         bool autoneg_wait_to_complete ) ;
#line 46
static s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw , u8 byte_offset , u8 *eeprom_data ) ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static void ixgbe_set_pcie_completion_timeout(struct ixgbe_hw *hw ) 
{ 
  u32 gcr ;
  u32 tmp ;
  u16 pcie_devctl2 ;
  bool tmp___0 ;

  {
#line 61
  tmp = ixgbe_read_reg(hw, 69632U);
#line 61
  gcr = tmp;
#line 64
  tmp___0 = ixgbe_removed((void *)hw->hw_addr);
#line 64
  if ((int )tmp___0) {
#line 65
    return;
  } else {

  }
#line 68
  if ((gcr & 61440U) != 0U) {
#line 69
    goto out;
  } else {

  }
#line 75
  if ((gcr & 262144U) == 0U) {
#line 76
    gcr = gcr | 4096U;
#line 77
    goto out;
  } else {

  }
#line 85
  pcie_devctl2 = ixgbe_read_pci_cfg_word(hw, 200U);
#line 86
  pcie_devctl2 = (u16 )((unsigned int )pcie_devctl2 | 5U);
#line 87
  ixgbe_write_pci_cfg_word(hw, 200U, (int )pcie_devctl2);
  out: 
#line 90
  gcr = gcr & 4294901759U;
#line 91
  ixgbe_write_reg(hw, 69632U, gcr);
#line 92
  return;
}
}
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_get_invariants_82598(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mac_info *mac ;

  {
#line 96
  mac = & hw->mac;
#line 99
  ixgbe_identify_phy_generic(hw);
#line 101
  mac->mcft_size = 128U;
#line 102
  mac->vft_size = 128U;
#line 103
  mac->num_rar_entries = 16U;
#line 104
  mac->rx_pb_size = 512U;
#line 105
  mac->max_rx_queues = 64U;
#line 106
  mac->max_tx_queues = 32U;
#line 107
  mac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);
#line 109
  return (0);
}
}
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_init_phy_ops_82598(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mac_info *mac ;
  struct ixgbe_phy_info *phy ;
  s32 ret_val ;
  u16 list_offset ;
  u16 data_offset ;
  enum ixgbe_media_type tmp ;

  {
#line 123
  mac = & hw->mac;
#line 124
  phy = & hw->phy;
#line 129
  (*(phy->ops.identify))(hw);
#line 132
  tmp = (*(mac->ops.get_media_type))(hw);
#line 132
  if ((unsigned int )tmp == 4U) {
#line 133
    mac->ops.setup_link = & ixgbe_setup_copper_link_82598;
#line 134
    mac->ops.get_link_capabilities = & ixgbe_get_copper_link_capabilities_generic;
  } else {

  }
#line 138
  switch ((unsigned int )hw->phy.type) {
  case 2U: 
#line 140
  phy->ops.setup_link = & ixgbe_setup_phy_link_tnx;
#line 141
  phy->ops.check_link = & ixgbe_check_phy_link_tnx;
#line 142
  phy->ops.get_firmware_version = & ixgbe_get_phy_firmware_version_tnx;
#line 144
  goto ldv_54422;
  case 10U: 
#line 146
  phy->ops.reset = & ixgbe_reset_phy_nl;
#line 149
  ret_val = (*(phy->ops.identify_sfp))(hw);
#line 150
  if (ret_val != 0) {
#line 151
    return (ret_val);
  } else {

  }
#line 152
  if ((unsigned int )hw->phy.sfp_type == 65535U) {
#line 153
    return (-19);
  } else {

  }
#line 156
  ret_val = ixgbe_get_sfp_init_sequence_offsets(hw, & list_offset, & data_offset);
#line 159
  if (ret_val != 0) {
#line 160
    return (-19);
  } else {

  }
#line 161
  goto ldv_54422;
  default: ;
#line 163
  goto ldv_54422;
  }
  ldv_54422: ;
#line 166
  return (0);
}
}
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_start_hw_82598(struct ixgbe_hw *hw ) 
{ 
  u32 regval ;
  u32 i ;
  s32 ret_val ;

  {
#line 186
  ret_val = ixgbe_start_hw_generic(hw);
#line 190
  i = 0U;
#line 190
  goto ldv_54432;
  ldv_54431: 
#line 192
  regval = ixgbe_read_reg(hw, (i + 7296U) * 4U);
#line 193
  regval = regval & 4294965247U;
#line 194
  ixgbe_write_reg(hw, (i + 7296U) * 4U, regval);
#line 191
  i = i + 1U;
  ldv_54432: ;
#line 190
  if (hw->mac.max_tx_queues > i && i <= 15U) {
#line 193
    goto ldv_54431;
  } else {

  }
#line 197
  i = 0U;
#line 197
  goto ldv_54435;
  ldv_54434: 
#line 199
  regval = ixgbe_read_reg(hw, i <= 15U ? (i + 2176U) * 4U : (i <= 63U ? i * 64U + 4108U : (i + 67108800U) * 64U + 53260U));
#line 200
  regval = regval & 4294926335U;
#line 202
  ixgbe_write_reg(hw, i <= 15U ? (i + 2176U) * 4U : (i <= 63U ? i * 64U + 4108U : (i + 67108800U) * 64U + 53260U),
                  regval);
#line 198
  i = i + 1U;
  ldv_54435: ;
#line 197
  if (hw->mac.max_rx_queues > i && i <= 15U) {
#line 200
    goto ldv_54434;
  } else {

  }

#line 205
  if (ret_val != 0) {
#line 206
    return (ret_val);
  } else {

  }
#line 209
  ixgbe_set_pcie_completion_timeout(hw);
#line 211
  return (0);
}
}
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw , ixgbe_link_speed *speed ,
                                             bool *autoneg ) 
{ 
  u32 autoc ;

  {
#line 226
  autoc = 0U;
#line 233
  if ((int )hw->mac.orig_link_settings_stored) {
#line 234
    autoc = hw->mac.orig_autoc;
  } else {
#line 236
    autoc = ixgbe_read_reg(hw, 17056U);
  }
#line 238
  switch (autoc & 57344U) {
  case 0U: 
#line 240
  *speed = 32U;
#line 241
  *autoneg = 0;
#line 242
  goto ldv_54444;
  case 8192U: 
#line 245
  *speed = 128U;
#line 246
  *autoneg = 0;
#line 247
  goto ldv_54444;
  case 16384U: 
#line 250
  *speed = 32U;
#line 251
  *autoneg = 1;
#line 252
  goto ldv_54444;
  case 32768U: ;
  case 49152U: 
#line 256
  *speed = 0U;
#line 257
  if ((int )autoc < 0) {
#line 258
    *speed = *speed | 128U;
  } else {

  }
#line 259
  if ((autoc & 1073741824U) != 0U) {
#line 260
    *speed = *speed | 32U;
  } else {

  }
#line 261
  *autoneg = 1;
#line 262
  goto ldv_54444;
  default: ;
#line 265
  return (-8);
  }
  ldv_54444: ;
#line 268
  return (0);
}
}
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static enum ixgbe_media_type ixgbe_get_media_type_82598(struct ixgbe_hw *hw ) 
{ 


  {
#line 280
  switch ((unsigned int )hw->phy.type) {
  case 7U: ;
  case 2U: ;
#line 283
  return (4);
  default: ;
#line 286
  goto ldv_54456;
  }
  ldv_54456: ;
#line 290
  switch ((int )hw->device_id) {
  case 4278: ;
  case 5384: ;
#line 294
  return (5);
  case 4294: ;
  case 4295: ;
  case 4337: ;
  case 4321: ;
  case 4340: ;
  case 4315: ;
#line 302
  return (1);
  case 4317: ;
  case 4332: ;
#line 306
  return (6);
  case 4296: ;
  case 5387: ;
#line 310
  return (4);
  default: ;
#line 313
  return (0);
  }
}
}
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw ) 
{ 
  u32 fctrl_reg ;
  u32 rmcs_reg ;
  u32 reg ;
  u32 fcrtl ;
  u32 fcrth ;
  u32 link_speed ;
  int i ;
  bool link_up ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
#line 329
  link_speed = 0U;
#line 334
  if ((unsigned int )hw->fc.pause_time == 0U) {
#line 335
    return (-13);
  } else {

  }
#line 338
  i = 0;
#line 338
  goto ldv_54484;
  ldv_54483: ;
#line 339
  if (((unsigned int )hw->fc.current_mode & 2U) != 0U && hw->fc.high_water[i] != 0U) {
#line 341
    if (hw->fc.low_water[i] == 0U || hw->fc.low_water[i] >= hw->fc.high_water[i]) {
#line 343
      descriptor.modname = "ixgbe";
#line 343
      descriptor.function = "ixgbe_fc_enable_82598";
#line 343
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 343
      descriptor.format = "Invalid water mark configuration\n";
#line 343
      descriptor.lineno = 343U;
#line 343
      descriptor.flags = 0U;
#line 343
      tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 343
      if (tmp != 0L) {
#line 343
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Invalid water mark configuration\n");
      } else {

      }
#line 344
      return (-13);
    } else {

    }
  } else {

  }
#line 338
  i = i + 1;
  ldv_54484: ;
#line 338
  if (i <= 7) {
#line 340
    goto ldv_54483;
  } else {

  }
#line 354
  (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
#line 355
  if ((int )link_up && link_speed == 32U) {
#line 356
    switch ((unsigned int )hw->fc.requested_mode) {
    case 3U: 
#line 358
    hw->fc.requested_mode = 2;
#line 359
    goto ldv_54487;
    case 1U: 
#line 361
    hw->fc.requested_mode = 0;
#line 362
    goto ldv_54487;
    default: ;
#line 365
    goto ldv_54487;
    }
    ldv_54487: ;
  } else {

  }
#line 370
  ixgbe_fc_autoneg(hw);
#line 373
  fctrl_reg = ixgbe_read_reg(hw, 20608U);
#line 374
  fctrl_reg = fctrl_reg & 4294918143U;
#line 376
  rmcs_reg = ixgbe_read_reg(hw, 15616U);
#line 377
  rmcs_reg = rmcs_reg & 4294967271U;
#line 389
  switch ((unsigned int )hw->fc.current_mode) {
  case 0U: ;
#line 395
  goto ldv_54491;
  case 1U: 
#line 405
  fctrl_reg = fctrl_reg | 32768U;
#line 406
  goto ldv_54491;
  case 2U: 
#line 412
  rmcs_reg = rmcs_reg | 8U;
#line 413
  goto ldv_54491;
  case 3U: 
#line 416
  fctrl_reg = fctrl_reg | 32768U;
#line 417
  rmcs_reg = rmcs_reg | 8U;
#line 418
  goto ldv_54491;
  default: 
#line 420
  descriptor___0.modname = "ixgbe";
#line 420
  descriptor___0.function = "ixgbe_fc_enable_82598";
#line 420
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 420
  descriptor___0.format = "Flow control param set incorrectly\n";
#line 420
  descriptor___0.lineno = 420U;
#line 420
  descriptor___0.flags = 0U;
#line 420
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 420
  if (tmp___0 != 0L) {
#line 420
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Flow control param set incorrectly\n");
  } else {

  }
#line 421
  return (-4);
  }
  ldv_54491: 
#line 425
  fctrl_reg = fctrl_reg | 8192U;
#line 426
  ixgbe_write_reg(hw, 20608U, fctrl_reg);
#line 427
  ixgbe_write_reg(hw, 15616U, rmcs_reg);
#line 430
  i = 0;
#line 430
  goto ldv_54498;
  ldv_54497: ;
#line 431
  if (((unsigned int )hw->fc.current_mode & 2U) != 0U && hw->fc.high_water[i] != 0U) {
#line 433
    fcrtl = (hw->fc.low_water[i] << 10) | 2147483648U;
#line 434
    fcrth = (hw->fc.high_water[i] << 10) | 2147483648U;
#line 435
    ixgbe_write_reg(hw, (u32 )((i + 1604) * 8), fcrtl);
#line 436
    ixgbe_write_reg(hw, (u32 )((i + 1612) * 8), fcrth);
  } else {
#line 438
    ixgbe_write_reg(hw, (u32 )((i + 1604) * 8), 0U);
#line 439
    ixgbe_write_reg(hw, (u32 )((i + 1612) * 8), 0U);
  }
#line 430
  i = i + 1;
  ldv_54498: ;
#line 430
  if (i <= 7) {
#line 432
    goto ldv_54497;
  } else {

  }
#line 445
  reg = (u32 )((int )hw->fc.pause_time * 65537);
#line 446
  i = 0;
#line 446
  goto ldv_54501;
  ldv_54500: 
#line 447
  ixgbe_write_reg(hw, (u32 )((i + 3200) * 4), reg);
#line 446
  i = i + 1;
  ldv_54501: ;
#line 446
  if (i <= 3) {
#line 448
    goto ldv_54500;
  } else {

  }
#line 450
  ixgbe_write_reg(hw, 12960U, (unsigned int )hw->fc.pause_time / 2U);
#line 452
  return (0);
}
}
#line 462 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_start_mac_link_82598(struct ixgbe_hw *hw , bool autoneg_wait_to_complete ) 
{ 
  u32 autoc_reg ;
  u32 links_reg ;
  u32 i ;
  s32 status ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 468
  status = 0;
#line 471
  autoc_reg = ixgbe_read_reg(hw, 17056U);
#line 472
  autoc_reg = autoc_reg | 4096U;
#line 473
  ixgbe_write_reg(hw, 17056U, autoc_reg);
#line 476
  if ((int )autoneg_wait_to_complete) {
#line 477
    if ((autoc_reg & 57344U) == 32768U || (autoc_reg & 57344U) == 49152U) {
#line 481
      links_reg = 0U;
#line 482
      i = 0U;
#line 482
      goto ldv_54513;
      ldv_54512: 
#line 483
      links_reg = ixgbe_read_reg(hw, 17060U);
#line 484
      if ((int )links_reg < 0) {
#line 485
        goto ldv_54511;
      } else {

      }
#line 486
      msleep(100U);
#line 482
      i = i + 1U;
      ldv_54513: ;
#line 482
      if (i <= 44U) {
#line 484
        goto ldv_54512;
      } else {

      }
      ldv_54511: ;
#line 488
      if ((int )links_reg >= 0) {
#line 489
        status = -14;
#line 490
        descriptor.modname = "ixgbe";
#line 490
        descriptor.function = "ixgbe_start_mac_link_82598";
#line 490
        descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 490
        descriptor.format = "Autonegotiation did not complete.\n";
#line 490
        descriptor.lineno = 490U;
#line 490
        descriptor.flags = 0U;
#line 490
        tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 490
        if (tmp != 0L) {
#line 490
          __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                               "Autonegotiation did not complete.\n");
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 496
  msleep(50U);
#line 498
  return (status);
}
}
#line 508 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_validate_link_ready(struct ixgbe_hw *hw ) 
{ 
  u32 timeout ;
  u16 an_reg ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 513
  if ((unsigned int )hw->device_id != 5387U) {
#line 514
    return (0);
  } else {

  }
#line 516
  timeout = 0U;
#line 516
  goto ldv_54523;
  ldv_54522: 
#line 518
  (*(hw->phy.ops.read_reg))(hw, 1U, 7U, & an_reg);
#line 520
  if (((int )an_reg & 32) != 0 && ((int )an_reg & 4) != 0) {
#line 522
    goto ldv_54521;
  } else {

  }
#line 524
  msleep(100U);
#line 517
  timeout = timeout + 1U;
  ldv_54523: ;
#line 516
  if (timeout <= 49U) {
#line 519
    goto ldv_54522;
  } else {

  }
  ldv_54521: ;
#line 527
  if (timeout == 50U) {
#line 528
    descriptor.modname = "ixgbe";
#line 528
    descriptor.function = "ixgbe_validate_link_ready";
#line 528
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 528
    descriptor.format = "Link was indicated but link is down\n";
#line 528
    descriptor.lineno = 528U;
#line 528
    descriptor.flags = 0U;
#line 528
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 528
    if (tmp != 0L) {
#line 528
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Link was indicated but link is down\n");
    } else {

    }
#line 529
    return (-8);
  } else {

  }
#line 532
  return (0);
}
}
#line 544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw , ixgbe_link_speed *speed ,
                                      bool *link_up , bool link_up_wait_to_complete ) 
{ 
  u32 links_reg ;
  u32 i ;
  u16 link_reg ;
  u16 adapt_comp_reg ;
  s32 tmp ;

  {
#line 558
  if ((unsigned int )hw->phy.type == 10U) {
#line 559
    (*(hw->phy.ops.read_reg))(hw, 51103U, 1U, & link_reg);
#line 560
    (*(hw->phy.ops.read_reg))(hw, 51103U, 1U, & link_reg);
#line 561
    (*(hw->phy.ops.read_reg))(hw, 49164U, 1U, & adapt_comp_reg);
#line 563
    if ((int )link_up_wait_to_complete) {
#line 564
      i = 0U;
#line 564
      goto ldv_54538;
      ldv_54537: ;
#line 565
      if ((int )link_reg & 1 && ((int )adapt_comp_reg & 1) == 0) {
#line 567
        *link_up = 1;
#line 568
        goto ldv_54536;
      } else {
#line 570
        *link_up = 0;
      }
#line 572
      msleep(100U);
#line 573
      (*(hw->phy.ops.read_reg))(hw, 51103U, 1U, & link_reg);
#line 576
      (*(hw->phy.ops.read_reg))(hw, 49164U, 1U, & adapt_comp_reg);
#line 564
      i = i + 1U;
      ldv_54538: ;
#line 564
      if (i <= 89U) {
#line 566
        goto ldv_54537;
      } else {

      }
      ldv_54536: ;
    } else
#line 581
    if ((int )link_reg & 1 && ((int )adapt_comp_reg & 1) == 0) {
#line 582
      *link_up = 1;
    } else {
#line 584
      *link_up = 0;
    }
#line 587
    if (! *link_up) {
#line 588
      return (0);
    } else {

    }
  } else {

  }
#line 591
  links_reg = ixgbe_read_reg(hw, 17060U);
#line 592
  if ((int )link_up_wait_to_complete) {
#line 593
    i = 0U;
#line 593
    goto ldv_54541;
    ldv_54540: ;
#line 594
    if ((links_reg & 1073741824U) != 0U) {
#line 595
      *link_up = 1;
#line 596
      goto ldv_54539;
    } else {
#line 598
      *link_up = 0;
    }
#line 600
    msleep(100U);
#line 601
    links_reg = ixgbe_read_reg(hw, 17060U);
#line 593
    i = i + 1U;
    ldv_54541: ;
#line 593
    if (i <= 89U) {
#line 595
      goto ldv_54540;
    } else {

    }
    ldv_54539: ;
  } else
#line 604
  if ((links_reg & 1073741824U) != 0U) {
#line 605
    *link_up = 1;
  } else {
#line 607
    *link_up = 0;
  }
#line 610
  if ((links_reg & 536870912U) != 0U) {
#line 611
    *speed = 128U;
  } else {
#line 613
    *speed = 32U;
  }
#line 615
  if ((unsigned int )hw->device_id == 5387U && (int )*link_up) {
#line 615
    tmp = ixgbe_validate_link_ready(hw);
#line 615
    if (tmp != 0) {
#line 617
      *link_up = 0;
    } else {

    }
  } else {

  }
#line 619
  return (0);
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                      bool autoneg_wait_to_complete ) 
{ 
  bool autoneg ;
  ixgbe_link_speed link_capabilities ;
  u32 curr_autoc ;
  u32 tmp ;
  u32 autoc ;
  u32 link_mode ;
  s32 tmp___0 ;

  {
#line 634
  autoneg = 0;
#line 635
  link_capabilities = 0U;
#line 636
  tmp = ixgbe_read_reg(hw, 17056U);
#line 636
  curr_autoc = tmp;
#line 637
  autoc = curr_autoc;
#line 638
  link_mode = autoc & 57344U;
#line 641
  ixgbe_get_link_capabilities_82598(hw, & link_capabilities, & autoneg);
#line 642
  speed = speed & link_capabilities;
#line 644
  if (speed == 0U) {
#line 645
    return (-8);
  } else
#line 648
  if (link_mode == 32768U || link_mode == 49152U) {
#line 650
    autoc = autoc & 1073741823U;
#line 651
    if ((speed & 128U) != 0U) {
#line 652
      autoc = autoc | 2147483648U;
    } else {

    }
#line 653
    if ((speed & 32U) != 0U) {
#line 654
      autoc = autoc | 1073741824U;
    } else {

    }
#line 655
    if (autoc != curr_autoc) {
#line 656
      ixgbe_write_reg(hw, 17056U, autoc);
    } else {

    }
  } else {

  }
#line 663
  tmp___0 = ixgbe_start_mac_link_82598(hw, (int )autoneg_wait_to_complete);
#line 663
  return (tmp___0);
}
}
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                         bool autoneg_wait_to_complete ) 
{ 
  s32 status ;

  {
#line 682
  status = (*(hw->phy.ops.setup_link_speed))(hw, speed, (int )autoneg_wait_to_complete);
#line 685
  ixgbe_start_mac_link_82598(hw, (int )autoneg_wait_to_complete);
#line 687
  return (status);
}
}
#line 698 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  s32 phy_status ;
  u32 ctrl ;
  u32 gheccr ;
  u32 i ;
  u32 autoc ;
  u8 analog_val ;
  u32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
#line 701
  phy_status = 0;
#line 709
  status = (*(hw->mac.ops.stop_adapter))(hw);
#line 710
  if (status != 0) {
#line 711
    return (status);
  } else {

  }
#line 718
  (*(hw->mac.ops.read_analog_reg8))(hw, 36U, & analog_val);
#line 719
  if (((int )analog_val & 16) != 0) {
#line 721
    (*(hw->mac.ops.read_analog_reg8))(hw, 36U, & analog_val);
#line 723
    analog_val = (unsigned int )analog_val & 239U;
#line 724
    (*(hw->mac.ops.write_analog_reg8))(hw, 36U, (int )analog_val);
#line 727
    (*(hw->mac.ops.read_analog_reg8))(hw, 11U, & analog_val);
#line 729
    analog_val = (unsigned int )analog_val & 15U;
#line 730
    (*(hw->mac.ops.write_analog_reg8))(hw, 11U, (int )analog_val);
#line 733
    (*(hw->mac.ops.read_analog_reg8))(hw, 12U, & analog_val);
#line 735
    analog_val = (unsigned int )analog_val & 15U;
#line 736
    (*(hw->mac.ops.write_analog_reg8))(hw, 12U, (int )analog_val);
#line 739
    (*(hw->mac.ops.read_analog_reg8))(hw, 13U, & analog_val);
#line 741
    analog_val = (unsigned int )analog_val & 15U;
#line 742
    (*(hw->mac.ops.write_analog_reg8))(hw, 13U, (int )analog_val);
  } else {

  }
#line 747
  if (! hw->phy.reset_disable) {
#line 751
    phy_status = (*(hw->phy.ops.init))(hw);
#line 752
    if (phy_status == -19) {
#line 753
      return (phy_status);
    } else {

    }
#line 754
    if (phy_status == -20) {
#line 755
      goto mac_reset_top;
    } else {

    }
#line 757
    (*(hw->phy.ops.reset))(hw);
  } else {

  }
  mac_reset_top: 
#line 765
  tmp = ixgbe_read_reg(hw, 0U);
#line 765
  ctrl = tmp | 67108864U;
#line 766
  ixgbe_write_reg(hw, 0U, ctrl);
#line 767
  ixgbe_read_reg(hw, 8U);
#line 770
  i = 0U;
#line 770
  goto ldv_54571;
  ldv_54570: 
#line 771
  __const_udelay(4295UL);
#line 772
  ctrl = ixgbe_read_reg(hw, 0U);
#line 773
  if ((ctrl & 67108864U) == 0U) {
#line 774
    goto ldv_54569;
  } else {

  }
#line 770
  i = i + 1U;
  ldv_54571: ;
#line 770
  if (i <= 9U) {
#line 772
    goto ldv_54570;
  } else {

  }
  ldv_54569: ;
#line 776
  if ((ctrl & 67108864U) != 0U) {
#line 777
    status = -15;
#line 778
    descriptor.modname = "ixgbe";
#line 778
    descriptor.function = "ixgbe_reset_hw_82598";
#line 778
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 778
    descriptor.format = "Reset polling failed to complete.\n";
#line 778
    descriptor.lineno = 778U;
#line 778
    descriptor.flags = 0U;
#line 778
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 778
    if (tmp___0 != 0L) {
#line 778
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Reset polling failed to complete.\n");
    } else {

    }
  } else {

  }
#line 781
  msleep(50U);
#line 788
  if ((int )hw->mac.flags & 1) {
#line 789
    hw->mac.flags = (unsigned int )hw->mac.flags & 254U;
#line 790
    goto mac_reset_top;
  } else {

  }
#line 793
  gheccr = ixgbe_read_reg(hw, 69808U);
#line 794
  gheccr = gheccr & 4292607423U;
#line 795
  ixgbe_write_reg(hw, 69808U, gheccr);
#line 802
  autoc = ixgbe_read_reg(hw, 17056U);
#line 803
  if (! hw->mac.orig_link_settings_stored) {
#line 804
    hw->mac.orig_autoc = autoc;
#line 805
    hw->mac.orig_link_settings_stored = 1;
  } else
#line 806
  if (hw->mac.orig_autoc != autoc) {
#line 807
    ixgbe_write_reg(hw, 17056U, hw->mac.orig_autoc);
  } else {

  }
#line 811
  (*(hw->mac.ops.get_mac_addr))(hw, (u8 *)(& hw->mac.perm_addr));
#line 817
  (*(hw->mac.ops.init_rx_addrs))(hw);
#line 819
  if (phy_status != 0) {
#line 820
    status = phy_status;
  } else {

  }
#line 822
  return (status);
}
}
#line 831 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_set_vmdq_82598(struct ixgbe_hw *hw , u32 rar , u32 vmdq ) 
{ 
  u32 rar_high ;
  u32 rar_entries ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 834
  rar_entries = hw->mac.num_rar_entries;
#line 837
  if (rar >= rar_entries) {
#line 838
    descriptor.modname = "ixgbe";
#line 838
    descriptor.function = "ixgbe_set_vmdq_82598";
#line 838
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 838
    descriptor.format = "RAR index %d is out of range.\n";
#line 838
    descriptor.lineno = 838U;
#line 838
    descriptor.flags = 0U;
#line 838
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 838
    if (tmp != 0L) {
#line 838
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "RAR index %d is out of range.\n", rar);
    } else {

    }
#line 839
    return (-32);
  } else {

  }
#line 842
  rar_high = ixgbe_read_reg(hw, rar <= 15U ? rar * 8U + 21508U : rar * 8U + 41476U);
#line 843
  rar_high = rar_high & 4291035135U;
#line 844
  rar_high = ((vmdq << 18) & 3932160U) | rar_high;
#line 845
  ixgbe_write_reg(hw, rar <= 15U ? rar * 8U + 21508U : rar * 8U + 41476U, rar_high);
#line 846
  return (0);
}
}
#line 855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_clear_vmdq_82598(struct ixgbe_hw *hw , u32 rar , u32 vmdq ) 
{ 
  u32 rar_high ;
  u32 rar_entries ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 858
  rar_entries = hw->mac.num_rar_entries;
#line 862
  if (rar >= rar_entries) {
#line 863
    descriptor.modname = "ixgbe";
#line 863
    descriptor.function = "ixgbe_clear_vmdq_82598";
#line 863
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 863
    descriptor.format = "RAR index %d is out of range.\n";
#line 863
    descriptor.lineno = 863U;
#line 863
    descriptor.flags = 0U;
#line 863
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 863
    if (tmp != 0L) {
#line 863
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "RAR index %d is out of range.\n", rar);
    } else {

    }
#line 864
    return (-32);
  } else {

  }
#line 867
  rar_high = ixgbe_read_reg(hw, rar <= 15U ? rar * 8U + 21508U : rar * 8U + 41476U);
#line 868
  if ((rar_high & 3932160U) != 0U) {
#line 869
    rar_high = rar_high & 4291035135U;
#line 870
    ixgbe_write_reg(hw, rar <= 15U ? rar * 8U + 21508U : rar * 8U + 41476U, rar_high);
  } else {

  }
#line 873
  return (0);
}
}
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_set_vfta_82598(struct ixgbe_hw *hw , u32 vlan , u32 vind , bool vlan_on ) 
{ 
  u32 regindex ;
  u32 bitindex ;
  u32 bits ;
  u32 vftabyte ;

  {
#line 893
  if (vlan > 4095U) {
#line 894
    return (-5);
  } else {

  }
#line 897
  regindex = (vlan >> 5) & 127U;
#line 900
  vftabyte = (vlan >> 3) & 3U;
#line 901
  bitindex = (vlan & 7U) << 2;
#line 904
  bits = ixgbe_read_reg(hw, ((vftabyte + 81U) * 128U + regindex) * 4U);
#line 905
  bits = (u32 )(~ (15 << (int )bitindex)) & bits;
#line 906
  bits = (vind << (int )bitindex) | bits;
#line 907
  ixgbe_write_reg(hw, ((vftabyte + 81U) * 128U + regindex) * 4U, bits);
#line 910
  bitindex = vlan & 31U;
#line 912
  bits = ixgbe_read_reg(hw, (regindex + 10240U) * 4U);
#line 913
  if ((int )vlan_on) {
#line 915
    bits = (u32 )(1 << (int )bitindex) | bits;
  } else {
#line 918
    bits = (u32 )(~ (1 << (int )bitindex)) & bits;
  }
#line 919
  ixgbe_write_reg(hw, (regindex + 10240U) * 4U, bits);
#line 921
  return (0);
}
}
#line 930 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_clear_vfta_82598(struct ixgbe_hw *hw ) 
{ 
  u32 offset ;
  u32 vlanbyte ;

  {
#line 935
  offset = 0U;
#line 935
  goto ldv_54608;
  ldv_54607: 
#line 936
  ixgbe_write_reg(hw, (offset + 10240U) * 4U, 0U);
#line 935
  offset = offset + 1U;
  ldv_54608: ;
#line 935
  if (hw->mac.vft_size > offset) {
#line 937
    goto ldv_54607;
  } else {

  }
#line 938
  vlanbyte = 0U;
#line 938
  goto ldv_54614;
  ldv_54613: 
#line 939
  offset = 0U;
#line 939
  goto ldv_54611;
  ldv_54610: 
#line 940
  ixgbe_write_reg(hw, ((vlanbyte + 81U) * 128U + offset) * 4U, 0U);
#line 939
  offset = offset + 1U;
  ldv_54611: ;
#line 939
  if (hw->mac.vft_size > offset) {
#line 941
    goto ldv_54610;
  } else {

  }
#line 938
  vlanbyte = vlanbyte + 1U;
  ldv_54614: ;
#line 938
  if (vlanbyte <= 3U) {
#line 940
    goto ldv_54613;
  } else {

  }

#line 943
  return (0);
}
}
#line 954 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_read_analog_reg8_82598(struct ixgbe_hw *hw , u32 reg , u8 *val ) 
{ 
  u32 atlas_ctl ;

  {
#line 958
  ixgbe_write_reg(hw, 18432U, (reg << 8) | 65536U);
#line 960
  ixgbe_read_reg(hw, 8U);
#line 961
  __const_udelay(42950UL);
#line 962
  atlas_ctl = ixgbe_read_reg(hw, 18432U);
#line 963
  *val = (unsigned char )atlas_ctl;
#line 965
  return (0);
}
}
#line 976 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_write_analog_reg8_82598(struct ixgbe_hw *hw , u32 reg , u8 val ) 
{ 
  u32 atlas_ctl ;

  {
#line 980
  atlas_ctl = (reg << 8) | (u32 )val;
#line 981
  ixgbe_write_reg(hw, 18432U, atlas_ctl);
#line 982
  ixgbe_read_reg(hw, 8U);
#line 983
  __const_udelay(42950UL);
#line 985
  return (0);
}
}
#line 997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_read_i2c_phy_82598(struct ixgbe_hw *hw , u8 dev_addr , u8 byte_offset ,
                                    u8 *eeprom_data ) 
{ 
  s32 status ;
  u16 sfp_addr ;
  u16 sfp_data ;
  u16 sfp_stat ;
  u16 gssr ;
  u32 i ;
  u32 tmp ;
  s32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
#line 1000
  status = 0;
#line 1001
  sfp_addr = 0U;
#line 1002
  sfp_data = 0U;
#line 1003
  sfp_stat = 0U;
#line 1007
  tmp = ixgbe_read_reg(hw, 8U);
#line 1007
  if ((tmp & 4U) != 0U) {
#line 1008
    gssr = 4U;
  } else {
#line 1010
    gssr = 2U;
  }
#line 1012
  tmp___0 = (*(hw->mac.ops.acquire_swfw_sync))(hw, (u32 )gssr);
#line 1012
  if (tmp___0 != 0) {
#line 1013
    return (-16);
  } else {

  }
#line 1015
  if ((unsigned int )hw->phy.type == 10U) {
#line 1021
    sfp_addr = ((int )((u16 )dev_addr) << 8U) + (int )((u16 )byte_offset);
#line 1022
    sfp_addr = (u16 )((unsigned int )sfp_addr | 256U);
#line 1023
    (*(hw->phy.ops.write_reg_mdi))(hw, 49930U, 1U, (int )sfp_addr);
#line 1029
    i = 0U;
#line 1029
    goto ldv_54642;
    ldv_54641: 
#line 1030
    (*(hw->phy.ops.read_reg_mdi))(hw, 49932U, 1U, & sfp_stat);
#line 1034
    sfp_stat = (unsigned int )sfp_stat & 3U;
#line 1035
    if ((unsigned int )sfp_stat != 3U) {
#line 1036
      goto ldv_54640;
    } else {

    }
#line 1037
    usleep_range(10000UL, 20000UL);
#line 1029
    i = i + 1U;
    ldv_54642: ;
#line 1029
    if (i <= 99U) {
#line 1031
      goto ldv_54641;
    } else {

    }
    ldv_54640: ;
#line 1040
    if ((unsigned int )sfp_stat != 1U) {
#line 1041
      descriptor.modname = "ixgbe";
#line 1041
      descriptor.function = "ixgbe_read_i2c_phy_82598";
#line 1041
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 1041
      descriptor.format = "EEPROM read did not pass.\n";
#line 1041
      descriptor.lineno = 1041U;
#line 1041
      descriptor.flags = 0U;
#line 1041
      tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1041
      if (tmp___1 != 0L) {
#line 1041
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "EEPROM read did not pass.\n");
      } else {

      }
#line 1042
      status = -20;
#line 1043
      goto out;
    } else {

    }
#line 1047
    (*(hw->phy.ops.read_reg_mdi))(hw, 49931U, 1U, & sfp_data);
#line 1050
    *eeprom_data = (unsigned char )((int )sfp_data >> 8);
  } else {
#line 1052
    status = -3;
  }
  out: 
#line 1056
  (*(hw->mac.ops.release_swfw_sync))(hw, (u32 )gssr);
#line 1057
  return (status);
}
}
#line 1068 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw , u8 byte_offset , u8 *eeprom_data ) 
{ 
  s32 tmp ;

  {
#line 1071
  tmp = ixgbe_read_i2c_phy_82598(hw, 160, (int )byte_offset, eeprom_data);
#line 1071
  return (tmp);
}
}
#line 1083 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_read_i2c_sff8472_82598(struct ixgbe_hw *hw , u8 byte_offset , u8 *sff8472_data ) 
{ 
  s32 tmp ;

  {
#line 1086
  tmp = ixgbe_read_i2c_phy_82598(hw, 162, (int )byte_offset, sff8472_data);
#line 1086
  return (tmp);
}
}
#line 1098 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static void ixgbe_set_lan_id_multi_port_pcie_82598(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_bus_info *bus ;
  u16 pci_gen ;
  u16 pci_ctrl2 ;

  {
#line 1100
  bus = & hw->bus;
#line 1101
  pci_gen = 0U;
#line 1102
  pci_ctrl2 = 0U;
#line 1104
  ixgbe_set_lan_id_multi_port_pcie(hw);
#line 1107
  (*(hw->eeprom.ops.read))(hw, 6, & pci_gen);
#line 1108
  if ((unsigned int )pci_gen != 0U && (unsigned int )pci_gen != 65535U) {
#line 1110
    (*(hw->eeprom.ops.read))(hw, (int )((unsigned int )pci_gen + 5U), & pci_ctrl2);
#line 1113
    if ((((int )pci_ctrl2 & 2) != 0 && ((int )pci_ctrl2 & 1) == 0) && ((int )pci_ctrl2 & 8) == 0) {
#line 1117
      bus->func = 0U;
    } else {

    }
  } else {

  }
#line 1119
  return;
}
}
#line 1129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static void ixgbe_set_rxpba_82598(struct ixgbe_hw *hw , int num_pb , u32 headroom ,
                                  int strategy ) 
{ 
  u32 rxpktsize ;
  u8 i ;

  {
#line 1132
  rxpktsize = 65536U;
#line 1133
  i = 0U;
#line 1135
  if (num_pb == 0) {
#line 1136
    return;
  } else {

  }
#line 1139
  switch (strategy) {
  case 1: 
#line 1142
  rxpktsize = 81920U;
#line 1143
  goto ldv_54672;
  ldv_54671: 
#line 1144
  ixgbe_write_reg(hw, (u32 )(((int )i + 3840) * 4), rxpktsize);
#line 1143
  i = (u8 )((int )i + 1);
  ldv_54672: ;
#line 1143
  if ((unsigned int )i <= 3U) {
#line 1145
    goto ldv_54671;
  } else {

  }
#line 1146
  rxpktsize = 49152U;
  case 0: ;
  default: ;
#line 1151
  goto ldv_54677;
  ldv_54676: 
#line 1152
  ixgbe_write_reg(hw, (u32 )(((int )i + 3840) * 4), rxpktsize);
#line 1151
  i = (u8 )((int )i + 1);
  ldv_54677: ;
#line 1151
  if ((unsigned int )i <= 7U) {
#line 1153
    goto ldv_54676;
  } else {

  }

#line 1153
  goto ldv_54679;
  }
  ldv_54679: 
#line 1157
  i = 0U;
#line 1157
  goto ldv_54681;
  ldv_54680: 
#line 1158
  ixgbe_write_reg(hw, (u32 )(((int )i + 13056) * 4), 40960U);
#line 1157
  i = (u8 )((int )i + 1);
  ldv_54681: ;
#line 1157
  if ((unsigned int )i <= 7U) {
#line 1159
    goto ldv_54680;
  } else {

  }

#line 1164
  return;
}
}
#line 1161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static struct ixgbe_mac_operations mac_ops_82598  = 
#line 1161
     {& ixgbe_init_hw_generic, & ixgbe_reset_hw_82598, & ixgbe_start_hw_82598, & ixgbe_clear_hw_cntrs_generic,
    & ixgbe_get_media_type_82598, & ixgbe_get_mac_addr_generic, 0, 0, 0, & ixgbe_stop_adapter_generic,
    & ixgbe_get_bus_info_generic, & ixgbe_set_lan_id_multi_port_pcie_82598, & ixgbe_read_analog_reg8_82598,
    & ixgbe_write_analog_reg8_82598, 0, 0, 0, & ixgbe_enable_rx_dma_generic, & ixgbe_acquire_swfw_sync,
    & ixgbe_release_swfw_sync, & prot_autoc_read_generic, & prot_autoc_write_generic,
    0, 0, 0, 0, & ixgbe_setup_mac_link_82598, & ixgbe_check_mac_link_82598, & ixgbe_get_link_capabilities_82598,
    & ixgbe_set_rxpba_82598, & ixgbe_led_on_generic, & ixgbe_led_off_generic, & ixgbe_blink_led_start_generic,
    & ixgbe_blink_led_stop_generic, & ixgbe_set_rar_generic, & ixgbe_clear_rar_generic,
    & ixgbe_set_vmdq_82598, 0, & ixgbe_clear_vmdq_82598, & ixgbe_init_rx_addrs_generic,
    & ixgbe_update_mc_addr_list_generic, & ixgbe_enable_mc_generic, & ixgbe_disable_mc_generic,
    & ixgbe_clear_vfta_82598, & ixgbe_set_vfta_82598, 0, 0, 0, & ixgbe_fc_enable_82598,
    (s32 (*)(struct ixgbe_hw * , u8  , u8  , u8  , u8  ))0, (s32 (*)(struct ixgbe_hw * ))0,
    (s32 (*)(struct ixgbe_hw * ))0, & ixgbe_disable_rx_generic, & ixgbe_enable_rx_generic,
    0, 0, 0, 0, 0};
#line 1204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static struct ixgbe_eeprom_operations eeprom_ops_82598  = 
#line 1204
     {& ixgbe_init_eeprom_params_generic, & ixgbe_read_eerd_generic, & ixgbe_read_eerd_buffer_generic,
    & ixgbe_write_eeprom_generic, & ixgbe_write_eeprom_buffer_bit_bang_generic, & ixgbe_validate_eeprom_checksum_generic,
    & ixgbe_update_eeprom_checksum_generic, & ixgbe_calc_eeprom_checksum_generic};
#line 1215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static struct ixgbe_phy_operations phy_ops_82598  = 
#line 1215
     {& ixgbe_identify_phy_generic, & ixgbe_identify_module_generic, & ixgbe_init_phy_ops_82598,
    & ixgbe_reset_phy_generic, & ixgbe_read_phy_reg_generic, & ixgbe_write_phy_reg_generic,
    & ixgbe_read_phy_reg_mdi, & ixgbe_write_phy_reg_mdi, & ixgbe_setup_phy_link_generic,
    0, & ixgbe_setup_phy_link_speed_generic, 0, 0, 0, 0, & ixgbe_read_i2c_sff8472_82598,
    & ixgbe_read_i2c_eeprom_82598, 0, 0, 0, & ixgbe_tn_check_overtemp, 0, 0};
#line 1231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
struct ixgbe_info ixgbe_82598_info  =    {1, & ixgbe_get_invariants_82598, & mac_ops_82598, & eeprom_ops_82598, & phy_ops_82598,
    0, (u32 const   *)(& ixgbe_mvals_8259X)};
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
extern int ldv_release_29(void) ;
#line 332
extern int ldv_probe_29(void) ;
#line 333
extern int ldv_release_30(void) ;
#line 334
extern int ldv_probe_30(void) ;
#line 335
extern int ldv_setup_28(void) ;
#line 336
extern int ldv_release_28(void) ;
#line 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_initialize_ixgbe_phy_operations_28(void) 
{ 
  void *tmp ;

  {
#line 340
  tmp = ldv_init_zalloc(1696UL);
#line 340
  phy_ops_82598_group0 = (struct ixgbe_hw *)tmp;
#line 341
  return;
}
}
#line 343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_initialize_ixgbe_mac_operations_30(void) 
{ 
  void *tmp ;

  {
#line 344
  tmp = ldv_init_zalloc(1696UL);
#line 344
  mac_ops_82598_group0 = (struct ixgbe_hw *)tmp;
#line 345
  return;
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_initialize_ixgbe_eeprom_operations_29(void) 
{ 
  void *tmp ;

  {
#line 348
  tmp = ldv_init_zalloc(1696UL);
#line 348
  eeprom_ops_82598_group0 = (struct ixgbe_hw *)tmp;
#line 349
  return;
}
}
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_main_exported_27(void) 
{ 
  struct ixgbe_hw *ldvarg198 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 352
  tmp = ldv_init_zalloc(1696UL);
#line 352
  ldvarg198 = (struct ixgbe_hw *)tmp;
#line 354
  tmp___0 = __VERIFIER_nondet_int();
#line 354
  switch (tmp___0) {
  case 0: ;
#line 357
  if (ldv_state_variable_27 == 1) {
#line 359
    ixgbe_get_invariants_82598(ldvarg198);
#line 361
    ldv_state_variable_27 = 1;
  } else {

  }
#line 364
  goto ldv_54713;
  default: 
#line 365
  ldv_stop();
  }
  ldv_54713: ;
#line 369
  return;
}
}
#line 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_main_exported_28(void) 
{ 
  u32 ldvarg260 ;
  u8 *ldvarg255 ;
  void *tmp ;
  u8 ldvarg258 ;
  bool ldvarg253 ;
  u16 ldvarg262 ;
  u32 ldvarg249 ;
  u16 ldvarg250 ;
  u32 ldvarg251 ;
  u8 *ldvarg257 ;
  void *tmp___0 ;
  u32 ldvarg252 ;
  u32 ldvarg264 ;
  u8 ldvarg256 ;
  u32 ldvarg261 ;
  u32 ldvarg248 ;
  ixgbe_link_speed ldvarg254 ;
  u32 ldvarg263 ;
  u16 *ldvarg259 ;
  void *tmp___1 ;
  u16 *ldvarg247 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 373
  tmp = ldv_init_zalloc(1UL);
#line 373
  ldvarg255 = (u8 *)tmp;
#line 380
  tmp___0 = ldv_init_zalloc(1UL);
#line 380
  ldvarg257 = (u8 *)tmp___0;
#line 388
  tmp___1 = ldv_init_zalloc(2UL);
#line 388
  ldvarg259 = (u16 *)tmp___1;
#line 389
  tmp___2 = ldv_init_zalloc(2UL);
#line 389
  ldvarg247 = (u16 *)tmp___2;
#line 372
  ldv_memset((void *)(& ldvarg260), 0, 4UL);
#line 374
  ldv_memset((void *)(& ldvarg258), 0, 1UL);
#line 375
  ldv_memset((void *)(& ldvarg253), 0, 1UL);
#line 376
  ldv_memset((void *)(& ldvarg262), 0, 2UL);
#line 377
  ldv_memset((void *)(& ldvarg249), 0, 4UL);
#line 378
  ldv_memset((void *)(& ldvarg250), 0, 2UL);
#line 379
  ldv_memset((void *)(& ldvarg251), 0, 4UL);
#line 381
  ldv_memset((void *)(& ldvarg252), 0, 4UL);
#line 382
  ldv_memset((void *)(& ldvarg264), 0, 4UL);
#line 383
  ldv_memset((void *)(& ldvarg256), 0, 1UL);
#line 384
  ldv_memset((void *)(& ldvarg261), 0, 4UL);
#line 385
  ldv_memset((void *)(& ldvarg248), 0, 4UL);
#line 386
  ldv_memset((void *)(& ldvarg254), 0, 4UL);
#line 387
  ldv_memset((void *)(& ldvarg263), 0, 4UL);
#line 391
  tmp___3 = __VERIFIER_nondet_int();
#line 391
  switch (tmp___3) {
  case 0: ;
#line 394
  if (ldv_state_variable_28 == 3) {
#line 396
    ixgbe_write_phy_reg_mdi(phy_ops_82598_group0, ldvarg264, ldvarg263, (int )ldvarg262);
#line 398
    ldv_state_variable_28 = 3;
  } else {

  }
#line 401
  goto ldv_54737;
  case 1: ;
#line 404
  if (ldv_state_variable_28 == 1) {
#line 406
    ixgbe_reset_phy_generic(phy_ops_82598_group0);
#line 408
    ldv_state_variable_28 = 1;
  } else {

  }
#line 411
  if (ldv_state_variable_28 == 3) {
#line 413
    ixgbe_reset_phy_generic(phy_ops_82598_group0);
#line 415
    ldv_state_variable_28 = 3;
  } else {

  }
#line 418
  if (ldv_state_variable_28 == 2) {
#line 420
    ixgbe_reset_phy_generic(phy_ops_82598_group0);
#line 422
    ldv_state_variable_28 = 2;
  } else {

  }
#line 425
  goto ldv_54737;
  case 2: ;
#line 428
  if (ldv_state_variable_28 == 3) {
#line 430
    ixgbe_read_phy_reg_mdi(phy_ops_82598_group0, ldvarg261, ldvarg260, ldvarg259);
#line 432
    ldv_state_variable_28 = 3;
  } else {

  }
#line 435
  goto ldv_54737;
  case 3: ;
#line 438
  if (ldv_state_variable_28 == 1) {
#line 440
    ixgbe_read_i2c_eeprom_82598(phy_ops_82598_group0, (int )ldvarg258, ldvarg257);
#line 442
    ldv_state_variable_28 = 1;
  } else {

  }
#line 445
  if (ldv_state_variable_28 == 3) {
#line 447
    ixgbe_read_i2c_eeprom_82598(phy_ops_82598_group0, (int )ldvarg258, ldvarg257);
#line 449
    ldv_state_variable_28 = 3;
  } else {

  }
#line 452
  if (ldv_state_variable_28 == 2) {
#line 454
    ixgbe_read_i2c_eeprom_82598(phy_ops_82598_group0, (int )ldvarg258, ldvarg257);
#line 456
    ldv_state_variable_28 = 2;
  } else {

  }
#line 459
  goto ldv_54737;
  case 4: ;
#line 462
  if (ldv_state_variable_28 == 1) {
#line 464
    ixgbe_read_i2c_sff8472_82598(phy_ops_82598_group0, (int )ldvarg256, ldvarg255);
#line 466
    ldv_state_variable_28 = 1;
  } else {

  }
#line 469
  if (ldv_state_variable_28 == 3) {
#line 471
    ixgbe_read_i2c_sff8472_82598(phy_ops_82598_group0, (int )ldvarg256, ldvarg255);
#line 473
    ldv_state_variable_28 = 3;
  } else {

  }
#line 476
  if (ldv_state_variable_28 == 2) {
#line 478
    ixgbe_read_i2c_sff8472_82598(phy_ops_82598_group0, (int )ldvarg256, ldvarg255);
#line 480
    ldv_state_variable_28 = 2;
  } else {

  }
#line 483
  goto ldv_54737;
  case 5: ;
#line 486
  if (ldv_state_variable_28 == 1) {
#line 488
    ixgbe_setup_phy_link_generic(phy_ops_82598_group0);
#line 490
    ldv_state_variable_28 = 1;
  } else {

  }
#line 493
  if (ldv_state_variable_28 == 3) {
#line 495
    ixgbe_setup_phy_link_generic(phy_ops_82598_group0);
#line 497
    ldv_state_variable_28 = 3;
  } else {

  }
#line 500
  if (ldv_state_variable_28 == 2) {
#line 502
    ixgbe_setup_phy_link_generic(phy_ops_82598_group0);
#line 504
    ldv_state_variable_28 = 2;
  } else {

  }
#line 507
  goto ldv_54737;
  case 6: ;
#line 510
  if (ldv_state_variable_28 == 1) {
#line 512
    ixgbe_identify_phy_generic(phy_ops_82598_group0);
#line 514
    ldv_state_variable_28 = 1;
  } else {

  }
#line 517
  if (ldv_state_variable_28 == 3) {
#line 519
    ixgbe_identify_phy_generic(phy_ops_82598_group0);
#line 521
    ldv_state_variable_28 = 3;
  } else {

  }
#line 524
  if (ldv_state_variable_28 == 2) {
#line 526
    ixgbe_identify_phy_generic(phy_ops_82598_group0);
#line 528
    ldv_state_variable_28 = 2;
  } else {

  }
#line 531
  goto ldv_54737;
  case 7: ;
#line 534
  if (ldv_state_variable_28 == 1) {
#line 536
    ixgbe_setup_phy_link_speed_generic(phy_ops_82598_group0, ldvarg254, (int )ldvarg253);
#line 538
    ldv_state_variable_28 = 1;
  } else {

  }
#line 541
  if (ldv_state_variable_28 == 3) {
#line 543
    ixgbe_setup_phy_link_speed_generic(phy_ops_82598_group0, ldvarg254, (int )ldvarg253);
#line 545
    ldv_state_variable_28 = 3;
  } else {

  }
#line 548
  if (ldv_state_variable_28 == 2) {
#line 550
    ixgbe_setup_phy_link_speed_generic(phy_ops_82598_group0, ldvarg254, (int )ldvarg253);
#line 552
    ldv_state_variable_28 = 2;
  } else {

  }
#line 555
  goto ldv_54737;
  case 8: ;
#line 558
  if (ldv_state_variable_28 == 1) {
#line 560
    ixgbe_write_phy_reg_generic(phy_ops_82598_group0, ldvarg252, ldvarg251, (int )ldvarg250);
#line 562
    ldv_state_variable_28 = 1;
  } else {

  }
#line 565
  if (ldv_state_variable_28 == 3) {
#line 567
    ixgbe_write_phy_reg_generic(phy_ops_82598_group0, ldvarg252, ldvarg251, (int )ldvarg250);
#line 569
    ldv_state_variable_28 = 3;
  } else {

  }
#line 572
  if (ldv_state_variable_28 == 2) {
#line 574
    ixgbe_write_phy_reg_generic(phy_ops_82598_group0, ldvarg252, ldvarg251, (int )ldvarg250);
#line 576
    ldv_state_variable_28 = 2;
  } else {

  }
#line 579
  goto ldv_54737;
  case 9: ;
#line 582
  if (ldv_state_variable_28 == 1) {
#line 584
    ixgbe_identify_module_generic(phy_ops_82598_group0);
#line 586
    ldv_state_variable_28 = 1;
  } else {

  }
#line 589
  if (ldv_state_variable_28 == 3) {
#line 591
    ixgbe_identify_module_generic(phy_ops_82598_group0);
#line 593
    ldv_state_variable_28 = 3;
  } else {

  }
#line 596
  if (ldv_state_variable_28 == 2) {
#line 598
    ixgbe_identify_module_generic(phy_ops_82598_group0);
#line 600
    ldv_state_variable_28 = 2;
  } else {

  }
#line 603
  goto ldv_54737;
  case 10: ;
#line 606
  if (ldv_state_variable_28 == 1) {
#line 608
    ixgbe_read_phy_reg_generic(phy_ops_82598_group0, ldvarg249, ldvarg248, ldvarg247);
#line 610
    ldv_state_variable_28 = 1;
  } else {

  }
#line 613
  if (ldv_state_variable_28 == 3) {
#line 615
    ixgbe_read_phy_reg_generic(phy_ops_82598_group0, ldvarg249, ldvarg248, ldvarg247);
#line 617
    ldv_state_variable_28 = 3;
  } else {

  }
#line 620
  if (ldv_state_variable_28 == 2) {
#line 622
    ixgbe_read_phy_reg_generic(phy_ops_82598_group0, ldvarg249, ldvarg248, ldvarg247);
#line 624
    ldv_state_variable_28 = 2;
  } else {

  }
#line 627
  goto ldv_54737;
  case 11: ;
#line 630
  if (ldv_state_variable_28 == 1) {
#line 632
    ixgbe_tn_check_overtemp(phy_ops_82598_group0);
#line 634
    ldv_state_variable_28 = 1;
  } else {

  }
#line 637
  if (ldv_state_variable_28 == 3) {
#line 639
    ixgbe_tn_check_overtemp(phy_ops_82598_group0);
#line 641
    ldv_state_variable_28 = 3;
  } else {

  }
#line 644
  if (ldv_state_variable_28 == 2) {
#line 646
    ixgbe_tn_check_overtemp(phy_ops_82598_group0);
#line 648
    ldv_state_variable_28 = 2;
  } else {

  }
#line 651
  goto ldv_54737;
  case 12: ;
#line 654
  if (ldv_state_variable_28 == 2) {
#line 656
    ixgbe_init_phy_ops_82598(phy_ops_82598_group0);
#line 658
    ldv_state_variable_28 = 3;
  } else {

  }
#line 661
  goto ldv_54737;
  case 13: ;
#line 664
  if (ldv_state_variable_28 == 1) {
#line 666
    ldv_setup_28();
#line 668
    ldv_state_variable_28 = 2;
#line 669
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 672
  goto ldv_54737;
  case 14: ;
#line 675
  if (ldv_state_variable_28 == 3) {
#line 677
    ldv_release_28();
#line 679
    ldv_state_variable_28 = 1;
#line 680
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 683
  if (ldv_state_variable_28 == 2) {
#line 685
    ldv_release_28();
#line 687
    ldv_state_variable_28 = 1;
#line 688
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 691
  goto ldv_54737;
  default: 
#line 692
  ldv_stop();
  }
  ldv_54737: ;
#line 696
  return;
}
}
#line 698 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_main_exported_30(void) 
{ 
  u8 ldvarg148 ;
  int ldvarg162 ;
  u32 ldvarg139 ;
  u32 ldvarg159 ;
  ixgbe_link_speed *ldvarg143 ;
  void *tmp ;
  bool *ldvarg171 ;
  void *tmp___0 ;
  u32 ldvarg150 ;
  u32 ldvarg173 ;
  u32 ldvarg164 ;
  u8 *ldvarg147 ;
  void *tmp___1 ;
  u32 ldvarg166 ;
  u32 ldvarg156 ;
  bool ldvarg153 ;
  bool ldvarg172 ;
  u32 ldvarg144 ;
  u32 ldvarg137 ;
  ixgbe_link_speed ldvarg154 ;
  u8 *ldvarg151 ;
  void *tmp___2 ;
  u32 ldvarg175 ;
  u32 ldvarg158 ;
  int ldvarg160 ;
  bool *ldvarg142 ;
  void *tmp___3 ;
  u32 ldvarg161 ;
  u32 ldvarg149 ;
  u32 ldvarg169 ;
  u32 ldvarg163 ;
  u8 *ldvarg138 ;
  void *tmp___4 ;
  u32 *ldvarg170 ;
  void *tmp___5 ;
  u32 ldvarg152 ;
  bool *ldvarg145 ;
  void *tmp___6 ;
  u32 ldvarg140 ;
  bool ldvarg167 ;
  struct net_device *ldvarg155 ;
  void *tmp___7 ;
  u32 ldvarg165 ;
  u32 ldvarg168 ;
  u32 ldvarg174 ;
  bool ldvarg141 ;
  u32 ldvarg157 ;
  ixgbe_link_speed *ldvarg146 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
#line 703
  tmp = ldv_init_zalloc(4UL);
#line 703
  ldvarg143 = (ixgbe_link_speed *)tmp;
#line 704
  tmp___0 = ldv_init_zalloc(1UL);
#line 704
  ldvarg171 = (bool *)tmp___0;
#line 708
  tmp___1 = ldv_init_zalloc(1UL);
#line 708
  ldvarg147 = (u8 *)tmp___1;
#line 716
  tmp___2 = ldv_init_zalloc(1UL);
#line 716
  ldvarg151 = (u8 *)tmp___2;
#line 720
  tmp___3 = ldv_init_zalloc(1UL);
#line 720
  ldvarg142 = (bool *)tmp___3;
#line 725
  tmp___4 = ldv_init_zalloc(1UL);
#line 725
  ldvarg138 = (u8 *)tmp___4;
#line 726
  tmp___5 = ldv_init_zalloc(4UL);
#line 726
  ldvarg170 = (u32 *)tmp___5;
#line 728
  tmp___6 = ldv_init_zalloc(1UL);
#line 728
  ldvarg145 = (bool *)tmp___6;
#line 731
  tmp___7 = ldv_init_zalloc(3008UL);
#line 731
  ldvarg155 = (struct net_device *)tmp___7;
#line 737
  tmp___8 = ldv_init_zalloc(4UL);
#line 737
  ldvarg146 = (ixgbe_link_speed *)tmp___8;
#line 699
  ldv_memset((void *)(& ldvarg148), 0, 1UL);
#line 700
  ldv_memset((void *)(& ldvarg162), 0, 4UL);
#line 701
  ldv_memset((void *)(& ldvarg139), 0, 4UL);
#line 702
  ldv_memset((void *)(& ldvarg159), 0, 4UL);
#line 705
  ldv_memset((void *)(& ldvarg150), 0, 4UL);
#line 706
  ldv_memset((void *)(& ldvarg173), 0, 4UL);
#line 707
  ldv_memset((void *)(& ldvarg164), 0, 4UL);
#line 709
  ldv_memset((void *)(& ldvarg166), 0, 4UL);
#line 710
  ldv_memset((void *)(& ldvarg156), 0, 4UL);
#line 711
  ldv_memset((void *)(& ldvarg153), 0, 1UL);
#line 712
  ldv_memset((void *)(& ldvarg172), 0, 1UL);
#line 713
  ldv_memset((void *)(& ldvarg144), 0, 4UL);
#line 714
  ldv_memset((void *)(& ldvarg137), 0, 4UL);
#line 715
  ldv_memset((void *)(& ldvarg154), 0, 4UL);
#line 717
  ldv_memset((void *)(& ldvarg175), 0, 4UL);
#line 718
  ldv_memset((void *)(& ldvarg158), 0, 4UL);
#line 719
  ldv_memset((void *)(& ldvarg160), 0, 4UL);
#line 721
  ldv_memset((void *)(& ldvarg161), 0, 4UL);
#line 722
  ldv_memset((void *)(& ldvarg149), 0, 4UL);
#line 723
  ldv_memset((void *)(& ldvarg169), 0, 4UL);
#line 724
  ldv_memset((void *)(& ldvarg163), 0, 4UL);
#line 727
  ldv_memset((void *)(& ldvarg152), 0, 4UL);
#line 729
  ldv_memset((void *)(& ldvarg140), 0, 4UL);
#line 730
  ldv_memset((void *)(& ldvarg167), 0, 1UL);
#line 732
  ldv_memset((void *)(& ldvarg165), 0, 4UL);
#line 733
  ldv_memset((void *)(& ldvarg168), 0, 4UL);
#line 734
  ldv_memset((void *)(& ldvarg174), 0, 4UL);
#line 735
  ldv_memset((void *)(& ldvarg141), 0, 1UL);
#line 736
  ldv_memset((void *)(& ldvarg157), 0, 4UL);
#line 739
  tmp___9 = __VERIFIER_nondet_int();
#line 739
  switch (tmp___9) {
  case 0: ;
#line 742
  if (ldv_state_variable_30 == 1) {
#line 744
    ixgbe_stop_adapter_generic(mac_ops_82598_group0);
#line 746
    ldv_state_variable_30 = 1;
  } else {

  }
#line 749
  if (ldv_state_variable_30 == 2) {
#line 751
    ixgbe_stop_adapter_generic(mac_ops_82598_group0);
#line 753
    ldv_state_variable_30 = 2;
  } else {

  }
#line 756
  goto ldv_54796;
  case 1: ;
#line 759
  if (ldv_state_variable_30 == 1) {
#line 761
    ixgbe_led_off_generic(mac_ops_82598_group0, ldvarg175);
#line 763
    ldv_state_variable_30 = 1;
  } else {

  }
#line 766
  if (ldv_state_variable_30 == 2) {
#line 768
    ixgbe_led_off_generic(mac_ops_82598_group0, ldvarg175);
#line 770
    ldv_state_variable_30 = 2;
  } else {

  }
#line 773
  goto ldv_54796;
  case 2: ;
#line 776
  if (ldv_state_variable_30 == 1) {
#line 778
    ixgbe_set_vfta_82598(mac_ops_82598_group0, ldvarg174, ldvarg173, (int )ldvarg172);
#line 780
    ldv_state_variable_30 = 1;
  } else {

  }
#line 783
  if (ldv_state_variable_30 == 2) {
#line 785
    ixgbe_set_vfta_82598(mac_ops_82598_group0, ldvarg174, ldvarg173, (int )ldvarg172);
#line 787
    ldv_state_variable_30 = 2;
  } else {

  }
#line 790
  goto ldv_54796;
  case 3: ;
#line 793
  if (ldv_state_variable_30 == 2) {
#line 795
    prot_autoc_read_generic(mac_ops_82598_group0, ldvarg171, ldvarg170);
#line 797
    ldv_state_variable_30 = 2;
  } else {

  }
#line 800
  goto ldv_54796;
  case 4: ;
#line 803
  if (ldv_state_variable_30 == 1) {
#line 805
    ixgbe_enable_rx_dma_generic(mac_ops_82598_group0, ldvarg169);
#line 807
    ldv_state_variable_30 = 1;
  } else {

  }
#line 810
  if (ldv_state_variable_30 == 2) {
#line 812
    ixgbe_enable_rx_dma_generic(mac_ops_82598_group0, ldvarg169);
#line 814
    ldv_state_variable_30 = 2;
  } else {

  }
#line 817
  goto ldv_54796;
  case 5: ;
#line 820
  if (ldv_state_variable_30 == 2) {
#line 822
    prot_autoc_write_generic(mac_ops_82598_group0, ldvarg168, (int )ldvarg167);
#line 824
    ldv_state_variable_30 = 2;
  } else {

  }
#line 827
  goto ldv_54796;
  case 6: ;
#line 830
  if (ldv_state_variable_30 == 1) {
#line 832
    ixgbe_led_on_generic(mac_ops_82598_group0, ldvarg166);
#line 834
    ldv_state_variable_30 = 1;
  } else {

  }
#line 837
  if (ldv_state_variable_30 == 2) {
#line 839
    ixgbe_led_on_generic(mac_ops_82598_group0, ldvarg166);
#line 841
    ldv_state_variable_30 = 2;
  } else {

  }
#line 844
  goto ldv_54796;
  case 7: ;
#line 847
  if (ldv_state_variable_30 == 1) {
#line 849
    ixgbe_blink_led_stop_generic(mac_ops_82598_group0, ldvarg165);
#line 851
    ldv_state_variable_30 = 1;
  } else {

  }
#line 854
  if (ldv_state_variable_30 == 2) {
#line 856
    ixgbe_blink_led_stop_generic(mac_ops_82598_group0, ldvarg165);
#line 858
    ldv_state_variable_30 = 2;
  } else {

  }
#line 861
  goto ldv_54796;
  case 8: ;
#line 864
  if (ldv_state_variable_30 == 1) {
#line 866
    ixgbe_clear_rar_generic(mac_ops_82598_group0, ldvarg164);
#line 868
    ldv_state_variable_30 = 1;
  } else {

  }
#line 871
  if (ldv_state_variable_30 == 2) {
#line 873
    ixgbe_clear_rar_generic(mac_ops_82598_group0, ldvarg164);
#line 875
    ldv_state_variable_30 = 2;
  } else {

  }
#line 878
  goto ldv_54796;
  case 9: ;
#line 881
  if (ldv_state_variable_30 == 1) {
#line 883
    ixgbe_enable_rx_generic(mac_ops_82598_group0);
#line 885
    ldv_state_variable_30 = 1;
  } else {

  }
#line 888
  if (ldv_state_variable_30 == 2) {
#line 890
    ixgbe_enable_rx_generic(mac_ops_82598_group0);
#line 892
    ldv_state_variable_30 = 2;
  } else {

  }
#line 895
  goto ldv_54796;
  case 10: ;
#line 898
  if (ldv_state_variable_30 == 1) {
#line 900
    ixgbe_get_bus_info_generic(mac_ops_82598_group0);
#line 902
    ldv_state_variable_30 = 1;
  } else {

  }
#line 905
  if (ldv_state_variable_30 == 2) {
#line 907
    ixgbe_get_bus_info_generic(mac_ops_82598_group0);
#line 909
    ldv_state_variable_30 = 2;
  } else {

  }
#line 912
  goto ldv_54796;
  case 11: ;
#line 915
  if (ldv_state_variable_30 == 1) {
#line 917
    ixgbe_blink_led_start_generic(mac_ops_82598_group0, ldvarg163);
#line 919
    ldv_state_variable_30 = 1;
  } else {

  }
#line 922
  if (ldv_state_variable_30 == 2) {
#line 924
    ixgbe_blink_led_start_generic(mac_ops_82598_group0, ldvarg163);
#line 926
    ldv_state_variable_30 = 2;
  } else {

  }
#line 929
  goto ldv_54796;
  case 12: ;
#line 932
  if (ldv_state_variable_30 == 1) {
#line 934
    ixgbe_disable_mc_generic(mac_ops_82598_group0);
#line 936
    ldv_state_variable_30 = 1;
  } else {

  }
#line 939
  if (ldv_state_variable_30 == 2) {
#line 941
    ixgbe_disable_mc_generic(mac_ops_82598_group0);
#line 943
    ldv_state_variable_30 = 2;
  } else {

  }
#line 946
  goto ldv_54796;
  case 13: ;
#line 949
  if (ldv_state_variable_30 == 1) {
#line 951
    ixgbe_set_rxpba_82598(mac_ops_82598_group0, ldvarg162, ldvarg161, ldvarg160);
#line 953
    ldv_state_variable_30 = 1;
  } else {

  }
#line 956
  if (ldv_state_variable_30 == 2) {
#line 958
    ixgbe_set_rxpba_82598(mac_ops_82598_group0, ldvarg162, ldvarg161, ldvarg160);
#line 960
    ldv_state_variable_30 = 2;
  } else {

  }
#line 963
  goto ldv_54796;
  case 14: ;
#line 966
  if (ldv_state_variable_30 == 1) {
#line 968
    ixgbe_set_vmdq_82598(mac_ops_82598_group0, ldvarg159, ldvarg158);
#line 970
    ldv_state_variable_30 = 1;
  } else {

  }
#line 973
  if (ldv_state_variable_30 == 2) {
#line 975
    ixgbe_set_vmdq_82598(mac_ops_82598_group0, ldvarg159, ldvarg158);
#line 977
    ldv_state_variable_30 = 2;
  } else {

  }
#line 980
  goto ldv_54796;
  case 15: ;
#line 983
  if (ldv_state_variable_30 == 1) {
#line 985
    ixgbe_clear_vmdq_82598(mac_ops_82598_group0, ldvarg157, ldvarg156);
#line 987
    ldv_state_variable_30 = 1;
  } else {

  }
#line 990
  if (ldv_state_variable_30 == 2) {
#line 992
    ixgbe_clear_vmdq_82598(mac_ops_82598_group0, ldvarg157, ldvarg156);
#line 994
    ldv_state_variable_30 = 2;
  } else {

  }
#line 997
  goto ldv_54796;
  case 16: ;
#line 1000
  if (ldv_state_variable_30 == 1) {
#line 1002
    ixgbe_clear_vfta_82598(mac_ops_82598_group0);
#line 1004
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1007
  if (ldv_state_variable_30 == 2) {
#line 1009
    ixgbe_clear_vfta_82598(mac_ops_82598_group0);
#line 1011
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1014
  goto ldv_54796;
  case 17: ;
#line 1017
  if (ldv_state_variable_30 == 1) {
#line 1019
    ixgbe_get_media_type_82598(mac_ops_82598_group0);
#line 1021
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1024
  if (ldv_state_variable_30 == 2) {
#line 1026
    ixgbe_get_media_type_82598(mac_ops_82598_group0);
#line 1028
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1031
  goto ldv_54796;
  case 18: ;
#line 1034
  if (ldv_state_variable_30 == 1) {
#line 1036
    ixgbe_update_mc_addr_list_generic(mac_ops_82598_group0, ldvarg155);
#line 1038
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1041
  if (ldv_state_variable_30 == 2) {
#line 1043
    ixgbe_update_mc_addr_list_generic(mac_ops_82598_group0, ldvarg155);
#line 1045
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1048
  goto ldv_54796;
  case 19: ;
#line 1051
  if (ldv_state_variable_30 == 1) {
#line 1053
    ixgbe_init_rx_addrs_generic(mac_ops_82598_group0);
#line 1055
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1058
  if (ldv_state_variable_30 == 2) {
#line 1060
    ixgbe_init_rx_addrs_generic(mac_ops_82598_group0);
#line 1062
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1065
  goto ldv_54796;
  case 20: ;
#line 1068
  if (ldv_state_variable_30 == 1) {
#line 1070
    ixgbe_fc_enable_82598(mac_ops_82598_group0);
#line 1072
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1075
  if (ldv_state_variable_30 == 2) {
#line 1077
    ixgbe_fc_enable_82598(mac_ops_82598_group0);
#line 1079
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1082
  goto ldv_54796;
  case 21: ;
#line 1085
  if (ldv_state_variable_30 == 1) {
#line 1087
    ixgbe_clear_hw_cntrs_generic(mac_ops_82598_group0);
#line 1089
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1092
  if (ldv_state_variable_30 == 2) {
#line 1094
    ixgbe_clear_hw_cntrs_generic(mac_ops_82598_group0);
#line 1096
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1099
  goto ldv_54796;
  case 22: ;
#line 1102
  if (ldv_state_variable_30 == 1) {
#line 1104
    ixgbe_setup_mac_link_82598(mac_ops_82598_group0, ldvarg154, (int )ldvarg153);
#line 1106
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1109
  if (ldv_state_variable_30 == 2) {
#line 1111
    ixgbe_setup_mac_link_82598(mac_ops_82598_group0, ldvarg154, (int )ldvarg153);
#line 1113
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1116
  goto ldv_54796;
  case 23: ;
#line 1119
  if (ldv_state_variable_30 == 1) {
#line 1121
    ixgbe_read_analog_reg8_82598(mac_ops_82598_group0, ldvarg152, ldvarg151);
#line 1123
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1126
  if (ldv_state_variable_30 == 2) {
#line 1128
    ixgbe_read_analog_reg8_82598(mac_ops_82598_group0, ldvarg152, ldvarg151);
#line 1130
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1133
  goto ldv_54796;
  case 24: ;
#line 1136
  if (ldv_state_variable_30 == 1) {
#line 1138
    ixgbe_disable_rx_generic(mac_ops_82598_group0);
#line 1140
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1143
  if (ldv_state_variable_30 == 2) {
#line 1145
    ixgbe_disable_rx_generic(mac_ops_82598_group0);
#line 1147
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1150
  goto ldv_54796;
  case 25: ;
#line 1153
  if (ldv_state_variable_30 == 1) {
#line 1155
    ixgbe_set_lan_id_multi_port_pcie_82598(mac_ops_82598_group0);
#line 1157
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1160
  if (ldv_state_variable_30 == 2) {
#line 1162
    ixgbe_set_lan_id_multi_port_pcie_82598(mac_ops_82598_group0);
#line 1164
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1167
  goto ldv_54796;
  case 26: ;
#line 1170
  if (ldv_state_variable_30 == 1) {
#line 1172
    ixgbe_acquire_swfw_sync(mac_ops_82598_group0, ldvarg150);
#line 1174
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1177
  if (ldv_state_variable_30 == 2) {
#line 1179
    ixgbe_acquire_swfw_sync(mac_ops_82598_group0, ldvarg150);
#line 1181
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1184
  goto ldv_54796;
  case 27: ;
#line 1187
  if (ldv_state_variable_30 == 1) {
#line 1189
    ixgbe_start_hw_82598(mac_ops_82598_group0);
#line 1191
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1194
  if (ldv_state_variable_30 == 2) {
#line 1196
    ixgbe_start_hw_82598(mac_ops_82598_group0);
#line 1198
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1201
  goto ldv_54796;
  case 28: ;
#line 1204
  if (ldv_state_variable_30 == 1) {
#line 1206
    ixgbe_write_analog_reg8_82598(mac_ops_82598_group0, ldvarg149, (int )ldvarg148);
#line 1208
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1211
  if (ldv_state_variable_30 == 2) {
#line 1213
    ixgbe_write_analog_reg8_82598(mac_ops_82598_group0, ldvarg149, (int )ldvarg148);
#line 1215
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1218
  goto ldv_54796;
  case 29: ;
#line 1221
  if (ldv_state_variable_30 == 1) {
#line 1223
    ixgbe_enable_mc_generic(mac_ops_82598_group0);
#line 1225
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1228
  if (ldv_state_variable_30 == 2) {
#line 1230
    ixgbe_enable_mc_generic(mac_ops_82598_group0);
#line 1232
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1235
  goto ldv_54796;
  case 30: ;
#line 1238
  if (ldv_state_variable_30 == 1) {
#line 1240
    ixgbe_get_mac_addr_generic(mac_ops_82598_group0, ldvarg147);
#line 1242
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1245
  if (ldv_state_variable_30 == 2) {
#line 1247
    ixgbe_get_mac_addr_generic(mac_ops_82598_group0, ldvarg147);
#line 1249
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1252
  goto ldv_54796;
  case 31: ;
#line 1255
  if (ldv_state_variable_30 == 1) {
#line 1257
    ixgbe_get_link_capabilities_82598(mac_ops_82598_group0, ldvarg146, ldvarg145);
#line 1259
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1262
  if (ldv_state_variable_30 == 2) {
#line 1264
    ixgbe_get_link_capabilities_82598(mac_ops_82598_group0, ldvarg146, ldvarg145);
#line 1266
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1269
  goto ldv_54796;
  case 32: ;
#line 1272
  if (ldv_state_variable_30 == 1) {
#line 1274
    ixgbe_init_hw_generic(mac_ops_82598_group0);
#line 1276
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1279
  if (ldv_state_variable_30 == 2) {
#line 1281
    ixgbe_init_hw_generic(mac_ops_82598_group0);
#line 1283
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1286
  goto ldv_54796;
  case 33: ;
#line 1289
  if (ldv_state_variable_30 == 1) {
#line 1291
    ixgbe_reset_hw_82598(mac_ops_82598_group0);
#line 1293
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1296
  if (ldv_state_variable_30 == 2) {
#line 1298
    ixgbe_reset_hw_82598(mac_ops_82598_group0);
#line 1300
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1303
  goto ldv_54796;
  case 34: ;
#line 1306
  if (ldv_state_variable_30 == 1) {
#line 1308
    ixgbe_release_swfw_sync(mac_ops_82598_group0, ldvarg144);
#line 1310
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1313
  if (ldv_state_variable_30 == 2) {
#line 1315
    ixgbe_release_swfw_sync(mac_ops_82598_group0, ldvarg144);
#line 1317
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1320
  goto ldv_54796;
  case 35: ;
#line 1323
  if (ldv_state_variable_30 == 1) {
#line 1325
    ixgbe_check_mac_link_82598(mac_ops_82598_group0, ldvarg143, ldvarg142, (int )ldvarg141);
#line 1327
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1330
  if (ldv_state_variable_30 == 2) {
#line 1332
    ixgbe_check_mac_link_82598(mac_ops_82598_group0, ldvarg143, ldvarg142, (int )ldvarg141);
#line 1334
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1337
  goto ldv_54796;
  case 36: ;
#line 1340
  if (ldv_state_variable_30 == 1) {
#line 1342
    ixgbe_set_rar_generic(mac_ops_82598_group0, ldvarg139, ldvarg138, ldvarg137, ldvarg140);
#line 1344
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1347
  if (ldv_state_variable_30 == 2) {
#line 1349
    ixgbe_set_rar_generic(mac_ops_82598_group0, ldvarg139, ldvarg138, ldvarg137, ldvarg140);
#line 1351
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1354
  goto ldv_54796;
  case 37: ;
#line 1357
  if (ldv_state_variable_30 == 2) {
#line 1359
    ldv_release_30();
#line 1361
    ldv_state_variable_30 = 1;
#line 1362
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1365
  goto ldv_54796;
  case 38: ;
#line 1368
  if (ldv_state_variable_30 == 1) {
#line 1370
    ldv_probe_30();
#line 1372
    ldv_state_variable_30 = 2;
#line 1373
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1376
  goto ldv_54796;
  default: 
#line 1377
  ldv_stop();
  }
  ldv_54796: ;
#line 1381
  return;
}
}
#line 1383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_main_exported_29(void) 
{ 
  u16 ldvarg423 ;
  u16 *ldvarg420 ;
  void *tmp ;
  u16 *ldvarg419 ;
  void *tmp___0 ;
  u16 *ldvarg427 ;
  void *tmp___1 ;
  u16 ldvarg425 ;
  u16 *ldvarg424 ;
  void *tmp___2 ;
  u16 ldvarg426 ;
  u16 ldvarg429 ;
  u16 ldvarg428 ;
  u16 ldvarg421 ;
  u16 ldvarg422 ;
  int tmp___3 ;

  {
#line 1385
  tmp = ldv_init_zalloc(2UL);
#line 1385
  ldvarg420 = (u16 *)tmp;
#line 1386
  tmp___0 = ldv_init_zalloc(2UL);
#line 1386
  ldvarg419 = (u16 *)tmp___0;
#line 1387
  tmp___1 = ldv_init_zalloc(2UL);
#line 1387
  ldvarg427 = (u16 *)tmp___1;
#line 1389
  tmp___2 = ldv_init_zalloc(2UL);
#line 1389
  ldvarg424 = (u16 *)tmp___2;
#line 1384
  ldv_memset((void *)(& ldvarg423), 0, 2UL);
#line 1388
  ldv_memset((void *)(& ldvarg425), 0, 2UL);
#line 1390
  ldv_memset((void *)(& ldvarg426), 0, 2UL);
#line 1391
  ldv_memset((void *)(& ldvarg429), 0, 2UL);
#line 1392
  ldv_memset((void *)(& ldvarg428), 0, 2UL);
#line 1393
  ldv_memset((void *)(& ldvarg421), 0, 2UL);
#line 1394
  ldv_memset((void *)(& ldvarg422), 0, 2UL);
#line 1396
  tmp___3 = __VERIFIER_nondet_int();
#line 1396
  switch (tmp___3) {
  case 0: ;
#line 1399
  if (ldv_state_variable_29 == 2) {
#line 1401
    ixgbe_write_eeprom_buffer_bit_bang_generic(eeprom_ops_82598_group0, (int )ldvarg429,
                                               (int )ldvarg428, ldvarg427);
#line 1403
    ldv_state_variable_29 = 2;
  } else {

  }
#line 1406
  goto ldv_54851;
  case 1: ;
#line 1409
  if (ldv_state_variable_29 == 2) {
#line 1411
    ixgbe_read_eerd_buffer_generic(eeprom_ops_82598_group0, (int )ldvarg426, (int )ldvarg425,
                                   ldvarg424);
#line 1413
    ldv_state_variable_29 = 2;
  } else {

  }
#line 1416
  goto ldv_54851;
  case 2: ;
#line 1419
  if (ldv_state_variable_29 == 1) {
#line 1421
    ixgbe_update_eeprom_checksum_generic(eeprom_ops_82598_group0);
#line 1423
    ldv_state_variable_29 = 1;
  } else {

  }
#line 1426
  if (ldv_state_variable_29 == 2) {
#line 1428
    ixgbe_update_eeprom_checksum_generic(eeprom_ops_82598_group0);
#line 1430
    ldv_state_variable_29 = 2;
  } else {

  }
#line 1433
  goto ldv_54851;
  case 3: ;
#line 1436
  if (ldv_state_variable_29 == 1) {
#line 1438
    ixgbe_calc_eeprom_checksum_generic(eeprom_ops_82598_group0);
#line 1440
    ldv_state_variable_29 = 1;
  } else {

  }
#line 1443
  if (ldv_state_variable_29 == 2) {
#line 1445
    ixgbe_calc_eeprom_checksum_generic(eeprom_ops_82598_group0);
#line 1447
    ldv_state_variable_29 = 2;
  } else {

  }
#line 1450
  goto ldv_54851;
  case 4: ;
#line 1453
  if (ldv_state_variable_29 == 1) {
#line 1455
    ixgbe_write_eeprom_generic(eeprom_ops_82598_group0, (int )ldvarg423, (int )ldvarg422);
#line 1457
    ldv_state_variable_29 = 1;
  } else {

  }
#line 1460
  if (ldv_state_variable_29 == 2) {
#line 1462
    ixgbe_write_eeprom_generic(eeprom_ops_82598_group0, (int )ldvarg423, (int )ldvarg422);
#line 1464
    ldv_state_variable_29 = 2;
  } else {

  }
#line 1467
  goto ldv_54851;
  case 5: ;
#line 1470
  if (ldv_state_variable_29 == 1) {
#line 1472
    ixgbe_read_eerd_generic(eeprom_ops_82598_group0, (int )ldvarg421, ldvarg420);
#line 1474
    ldv_state_variable_29 = 1;
  } else {

  }
#line 1477
  if (ldv_state_variable_29 == 2) {
#line 1479
    ixgbe_read_eerd_generic(eeprom_ops_82598_group0, (int )ldvarg421, ldvarg420);
#line 1481
    ldv_state_variable_29 = 2;
  } else {

  }
#line 1484
  goto ldv_54851;
  case 6: ;
#line 1487
  if (ldv_state_variable_29 == 1) {
#line 1489
    ixgbe_init_eeprom_params_generic(eeprom_ops_82598_group0);
#line 1491
    ldv_state_variable_29 = 1;
  } else {

  }
#line 1494
  if (ldv_state_variable_29 == 2) {
#line 1496
    ixgbe_init_eeprom_params_generic(eeprom_ops_82598_group0);
#line 1498
    ldv_state_variable_29 = 2;
  } else {

  }
#line 1501
  goto ldv_54851;
  case 7: ;
#line 1504
  if (ldv_state_variable_29 == 1) {
#line 1506
    ixgbe_validate_eeprom_checksum_generic(eeprom_ops_82598_group0, ldvarg419);
#line 1508
    ldv_state_variable_29 = 1;
  } else {

  }
#line 1511
  if (ldv_state_variable_29 == 2) {
#line 1513
    ixgbe_validate_eeprom_checksum_generic(eeprom_ops_82598_group0, ldvarg419);
#line 1515
    ldv_state_variable_29 = 2;
  } else {

  }
#line 1518
  goto ldv_54851;
  case 8: ;
#line 1521
  if (ldv_state_variable_29 == 2) {
#line 1523
    ldv_release_29();
#line 1525
    ldv_state_variable_29 = 1;
#line 1526
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1529
  goto ldv_54851;
  case 9: ;
#line 1532
  if (ldv_state_variable_29 == 1) {
#line 1534
    ldv_probe_29();
#line 1536
    ldv_state_variable_29 = 2;
#line 1537
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1540
  goto ldv_54851;
  default: 
#line 1541
  ldv_stop();
  }
  ldv_54851: ;
#line 1545
  return;
}
}
#line 1570 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
bool ldv_queue_work_on_163(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1574
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1574
  ldv_func_res = tmp;
#line 1576
  activate_work_9(ldv_func_arg3, 2);
#line 1578
  return (ldv_func_res);
}
}
#line 1581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
bool ldv_queue_delayed_work_on_164(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1585
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1585
  ldv_func_res = tmp;
#line 1587
  activate_work_9(& ldv_func_arg3->work, 2);
#line 1589
  return (ldv_func_res);
}
}
#line 1592 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
bool ldv_queue_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1596
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1596
  ldv_func_res = tmp;
#line 1598
  activate_work_9(ldv_func_arg3, 2);
#line 1600
  return (ldv_func_res);
}
}
#line 1603 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_flush_workqueue_166(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1606
  flush_workqueue(ldv_func_arg1);
#line 1608
  call_and_disable_all_9(2);
#line 1609
  return;
}
}
#line 1611 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
bool ldv_queue_delayed_work_on_167(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1615
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1615
  ldv_func_res = tmp;
#line 1617
  activate_work_9(& ldv_func_arg3->work, 2);
#line 1619
  return (ldv_func_res);
}
}
#line 1622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_mutex_lock_168(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1625
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1627
  mutex_lock(ldv_func_arg1);
#line 1628
  return;
}
}
#line 1630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_mutex_unlock_169(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1633
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1635
  mutex_unlock(ldv_func_arg1);
#line 1636
  return;
}
}
#line 1638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_mutex_lock_170(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1641
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1643
  mutex_lock(ldv_func_arg1);
#line 1644
  return;
}
}
#line 1646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
int ldv_mutex_trylock_171(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1650
  tmp = mutex_trylock(ldv_func_arg1);
#line 1650
  ldv_func_res = tmp;
#line 1652
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1652
  return (tmp___0);
#line 1654
  return (ldv_func_res);
}
}
#line 1657 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_mutex_unlock_172(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1660
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1662
  mutex_unlock(ldv_func_arg1);
#line 1663
  return;
}
}
#line 1665 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_mutex_unlock_173(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1668
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 1670
  mutex_unlock(ldv_func_arg1);
#line 1671
  return;
}
}
#line 1673 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.o.c.prepared"
void ldv_mutex_lock_174(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1676
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 1678
  mutex_lock(ldv_func_arg1);
#line 1679
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_199(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_197(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_200(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.o.c.prepared"
void ldv_mutex_lock_196(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_198(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_202(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_191(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_193(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_192(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_195(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_194(struct workqueue_struct *ldv_func_arg1 ) ;
#line 64 "include/linux/mdio.h"
extern int mdio45_probe(struct mdio_if_info * , int  ) ;
#line 144 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h"
s32 ixgbe_get_phy_firmware_version_generic(struct ixgbe_hw *hw , u16 *firmware_version ) ;
#line 148
s32 ixgbe_set_copper_phy_power(struct ixgbe_hw *hw , bool on ) ;
#line 150
s32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw ) ;
#line 165
s32 ixgbe_read_i2c_combined_generic(struct ixgbe_hw *hw , u8 addr , u16 reg , u16 *val ) ;
#line 167
s32 ixgbe_write_i2c_combined_generic(struct ixgbe_hw *hw , u8 addr , u16 reg , u16 val ) ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_i2c_start(struct ixgbe_hw *hw ) ;
#line 37
static void ixgbe_i2c_stop(struct ixgbe_hw *hw ) ;
#line 38
static s32 ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw , u8 *data ) ;
#line 39
static s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw , u8 data ) ;
#line 40
static s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw ) ;
#line 41
static s32 ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw , bool *data ) ;
#line 42
static s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw , bool data ) ;
#line 43
static void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw , u32 *i2cctl ) ;
#line 44
static void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw , u32 *i2cctl ) ;
#line 45
static s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw , u32 *i2cctl , bool data ) ;
#line 46
static bool ixgbe_get_i2c_data(struct ixgbe_hw *hw , u32 *i2cctl ) ;
#line 47
static void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw ) ;
#line 48
static enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id ) ;
#line 49
static s32 ixgbe_get_phy_id(struct ixgbe_hw *hw ) ;
#line 50
static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw ) ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_out_i2c_byte_ack(struct ixgbe_hw *hw , u8 byte ) 
{ 
  s32 status ;
  s32 tmp ;

  {
#line 63
  status = ixgbe_clock_out_i2c_byte(hw, (int )byte);
#line 64
  if (status != 0) {
#line 65
    return (status);
  } else {

  }
#line 66
  tmp = ixgbe_get_i2c_ack(hw);
#line 66
  return (tmp);
}
}
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_in_i2c_byte_ack(struct ixgbe_hw *hw , u8 *byte ) 
{ 
  s32 status ;
  s32 tmp ;

  {
#line 80
  status = ixgbe_clock_in_i2c_byte(hw, byte);
#line 81
  if (status != 0) {
#line 82
    return (status);
  } else {

  }
#line 84
  tmp = ixgbe_clock_out_i2c_bit(hw, 0);
#line 84
  return (tmp);
}
}
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static u8 ixgbe_ones_comp_byte_add(u8 add1 , u8 add2 ) 
{ 
  u16 sum ;

  {
#line 96
  sum = (int )((u16 )add1) + (int )((u16 )add2);
#line 98
  sum = ((unsigned int )sum & 255U) + (unsigned int )((u16 )((int )sum >> 8));
#line 99
  return ((u8 )sum);
}
}
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_i2c_combined_generic(struct ixgbe_hw *hw , u8 addr , u16 reg , u16 *val ) 
{ 
  u32 swfw_mask ;
  int max_retry ;
  int retry ;
  u8 csum_byte ;
  u8 high_bits ;
  u8 low_bits ;
  u8 reg_high ;
  u8 csum ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;
  s32 tmp___3 ;
  s32 tmp___4 ;
  s32 tmp___5 ;
  s32 tmp___6 ;
  s32 tmp___7 ;
  s32 tmp___8 ;
  struct _ddebug descriptor ;
  long tmp___9 ;
  struct _ddebug descriptor___0 ;
  long tmp___10 ;

  {
#line 114
  swfw_mask = hw->phy.phy_semaphore_mask;
#line 115
  max_retry = 10;
#line 116
  retry = 0;
#line 123
  reg_high = (u8 )((int )((signed char )((int )reg >> 7)) | 1);
#line 124
  csum = ixgbe_ones_comp_byte_add((int )reg_high, (int )((u8 )reg));
#line 125
  csum = ~ ((int )csum);
  ldv_54467: 
#line 127
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, swfw_mask);
#line 127
  if (tmp != 0) {
#line 128
    return (-16);
  } else {

  }
#line 129
  ixgbe_i2c_start(hw);
#line 131
  tmp___0 = ixgbe_out_i2c_byte_ack(hw, (int )addr);
#line 131
  if (tmp___0 != 0) {
#line 132
    goto fail;
  } else {

  }
#line 134
  tmp___1 = ixgbe_out_i2c_byte_ack(hw, (int )reg_high);
#line 134
  if (tmp___1 != 0) {
#line 135
    goto fail;
  } else {

  }
#line 137
  tmp___2 = ixgbe_out_i2c_byte_ack(hw, (int )((u8 )reg));
#line 137
  if (tmp___2 != 0) {
#line 138
    goto fail;
  } else {

  }
#line 140
  tmp___3 = ixgbe_out_i2c_byte_ack(hw, (int )csum);
#line 140
  if (tmp___3 != 0) {
#line 141
    goto fail;
  } else {

  }
#line 143
  ixgbe_i2c_start(hw);
#line 145
  tmp___4 = ixgbe_out_i2c_byte_ack(hw, (int )((unsigned int )addr | 1U));
#line 145
  if (tmp___4 != 0) {
#line 146
    goto fail;
  } else {

  }
#line 148
  tmp___5 = ixgbe_in_i2c_byte_ack(hw, & high_bits);
#line 148
  if (tmp___5 != 0) {
#line 149
    goto fail;
  } else {

  }
#line 151
  tmp___6 = ixgbe_in_i2c_byte_ack(hw, & low_bits);
#line 151
  if (tmp___6 != 0) {
#line 152
    goto fail;
  } else {

  }
#line 154
  tmp___7 = ixgbe_clock_in_i2c_byte(hw, & csum_byte);
#line 154
  if (tmp___7 != 0) {
#line 155
    goto fail;
  } else {

  }
#line 157
  tmp___8 = ixgbe_clock_out_i2c_bit(hw, 0);
#line 157
  if (tmp___8 != 0) {
#line 158
    goto fail;
  } else {

  }
#line 159
  ixgbe_i2c_stop(hw);
#line 160
  (*(hw->mac.ops.release_swfw_sync))(hw, swfw_mask);
#line 161
  *val = (u16 )((int )((short )((int )high_bits << 8)) | (int )((short )low_bits));
#line 162
  return (0);
  fail: 
#line 165
  ixgbe_i2c_bus_clear(hw);
#line 166
  (*(hw->mac.ops.release_swfw_sync))(hw, swfw_mask);
#line 167
  retry = retry + 1;
#line 168
  if (retry < max_retry) {
#line 169
    descriptor.modname = "ixgbe";
#line 169
    descriptor.function = "ixgbe_read_i2c_combined_generic";
#line 169
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 169
    descriptor.format = "I2C byte read combined error - Retry.\n";
#line 169
    descriptor.lineno = 169U;
#line 169
    descriptor.flags = 0U;
#line 169
    tmp___9 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 169
    if (tmp___9 != 0L) {
#line 169
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C byte read combined error - Retry.\n");
    } else {

    }
  } else {
#line 171
    descriptor___0.modname = "ixgbe";
#line 171
    descriptor___0.function = "ixgbe_read_i2c_combined_generic";
#line 171
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 171
    descriptor___0.format = "I2C byte read combined error.\n";
#line 171
    descriptor___0.lineno = 171U;
#line 171
    descriptor___0.flags = 0U;
#line 171
    tmp___10 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 171
    if (tmp___10 != 0L) {
#line 171
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C byte read combined error.\n");
    } else {

    }
  }
#line 172
  if (retry < max_retry) {
#line 174
    goto ldv_54467;
  } else {

  }

#line 174
  return (-18);
}
}
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_i2c_combined_generic(struct ixgbe_hw *hw , u8 addr , u16 reg , u16 val ) 
{ 
  int max_retry ;
  int retry ;
  u8 reg_high ;
  u8 csum ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;
  s32 tmp___3 ;
  s32 tmp___4 ;
  struct _ddebug descriptor ;
  long tmp___5 ;
  struct _ddebug descriptor___0 ;
  long tmp___6 ;

  {
#line 189
  max_retry = 1;
#line 190
  retry = 0;
#line 194
  reg_high = (unsigned int )((u8 )((int )reg >> 7)) & 254U;
#line 195
  csum = ixgbe_ones_comp_byte_add((int )reg_high, (int )((u8 )reg));
#line 196
  csum = ixgbe_ones_comp_byte_add((int )csum, (int )((u8 )((int )val >> 8)));
#line 197
  csum = ixgbe_ones_comp_byte_add((int )csum, (int )((u8 )val));
#line 198
  csum = ~ ((int )csum);
  ldv_54483: 
#line 200
  ixgbe_i2c_start(hw);
#line 202
  tmp = ixgbe_out_i2c_byte_ack(hw, (int )addr);
#line 202
  if (tmp != 0) {
#line 203
    goto fail;
  } else {

  }
#line 205
  tmp___0 = ixgbe_out_i2c_byte_ack(hw, (int )reg_high);
#line 205
  if (tmp___0 != 0) {
#line 206
    goto fail;
  } else {

  }
#line 208
  tmp___1 = ixgbe_out_i2c_byte_ack(hw, (int )((u8 )reg));
#line 208
  if (tmp___1 != 0) {
#line 209
    goto fail;
  } else {

  }
#line 211
  tmp___2 = ixgbe_out_i2c_byte_ack(hw, (int )((u8 )((int )val >> 8)));
#line 211
  if (tmp___2 != 0) {
#line 212
    goto fail;
  } else {

  }
#line 214
  tmp___3 = ixgbe_out_i2c_byte_ack(hw, (int )((u8 )val));
#line 214
  if (tmp___3 != 0) {
#line 215
    goto fail;
  } else {

  }
#line 217
  tmp___4 = ixgbe_out_i2c_byte_ack(hw, (int )csum);
#line 217
  if (tmp___4 != 0) {
#line 218
    goto fail;
  } else {

  }
#line 219
  ixgbe_i2c_stop(hw);
#line 220
  return (0);
  fail: 
#line 223
  ixgbe_i2c_bus_clear(hw);
#line 224
  retry = retry + 1;
#line 225
  if (retry < max_retry) {
#line 226
    descriptor.modname = "ixgbe";
#line 226
    descriptor.function = "ixgbe_write_i2c_combined_generic";
#line 226
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 226
    descriptor.format = "I2C byte write combined error - Retry.\n";
#line 226
    descriptor.lineno = 226U;
#line 226
    descriptor.flags = 0U;
#line 226
    tmp___5 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 226
    if (tmp___5 != 0L) {
#line 226
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C byte write combined error - Retry.\n");
    } else {

    }
  } else {
#line 228
    descriptor___0.modname = "ixgbe";
#line 228
    descriptor___0.function = "ixgbe_write_i2c_combined_generic";
#line 228
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 228
    descriptor___0.format = "I2C byte write combined error.\n";
#line 228
    descriptor___0.lineno = 228U;
#line 228
    descriptor___0.flags = 0U;
#line 228
    tmp___6 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 228
    if (tmp___6 != 0L) {
#line 228
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C byte write combined error.\n");
    } else {

    }
  }
#line 229
  if (retry < max_retry) {
#line 231
    goto ldv_54483;
  } else {

  }

#line 231
  return (-18);
}
}
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw ) 
{ 
  u32 phy_addr ;
  u16 ext_ability ;
  u32 tmp ;
  int tmp___0 ;

  {
#line 243
  ext_ability = 0U;
#line 245
  if (hw->phy.phy_semaphore_mask == 0U) {
#line 246
    tmp = ixgbe_read_reg(hw, 8U);
#line 246
    hw->phy.lan_id = (unsigned int )((u8 )tmp) & 4U;
#line 248
    if ((unsigned int )hw->phy.lan_id != 0U) {
#line 249
      hw->phy.phy_semaphore_mask = 4U;
    } else {
#line 251
      hw->phy.phy_semaphore_mask = 2U;
    }
  } else {

  }
#line 254
  if ((unsigned int )hw->phy.type == 0U) {
#line 255
    phy_addr = 0U;
#line 255
    goto ldv_54491;
    ldv_54490: 
#line 256
    hw->phy.mdio.prtad = (int )phy_addr;
#line 257
    tmp___0 = mdio45_probe(& hw->phy.mdio, (int )phy_addr);
#line 257
    if (tmp___0 == 0) {
#line 258
      ixgbe_get_phy_id(hw);
#line 259
      hw->phy.type = ixgbe_get_phy_type_from_id(hw->phy.id);
#line 262
      if ((unsigned int )hw->phy.type == 0U) {
#line 263
        (*(hw->phy.ops.read_reg))(hw, 11U, 1U, & ext_ability);
#line 267
        if (((int )ext_ability & 36) != 0) {
#line 270
          hw->phy.type = 7;
        } else {
#line 273
          hw->phy.type = 24;
        }
      } else {

      }
#line 277
      return (0);
    } else {

    }
#line 255
    phy_addr = phy_addr + 1U;
    ldv_54491: ;
#line 255
    if (phy_addr <= 31U) {
#line 257
      goto ldv_54490;
    } else {

    }
#line 281
    hw->phy.mdio.prtad = 0;
#line 282
    return (-17);
  } else {

  }
#line 284
  return (0);
}
}
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
bool ixgbe_check_reset_blocked(struct ixgbe_hw *hw ) 
{ 
  u32 mmngc ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 301
  if ((unsigned int )hw->mac.type == 1U) {
#line 302
    return (0);
  } else {

  }
#line 304
  mmngc = ixgbe_read_reg(hw, 17104U);
#line 305
  if ((int )mmngc & 1) {
#line 306
    descriptor.modname = "ixgbe";
#line 306
    descriptor.function = "ixgbe_check_reset_blocked";
#line 306
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 306
    descriptor.format = "MNG_VETO bit detected.\n";
#line 306
    descriptor.lineno = 306U;
#line 306
    descriptor.flags = 0U;
#line 306
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 306
    if (tmp != 0L) {
#line 306
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "MNG_VETO bit detected.\n");
    } else {

    }
#line 307
    return (1);
  } else {

  }
#line 310
  return (0);
}
}
#line 318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_get_phy_id(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 phy_id_high ;
  u16 phy_id_low ;

  {
#line 321
  phy_id_high = 0U;
#line 322
  phy_id_low = 0U;
#line 324
  status = (*(hw->phy.ops.read_reg))(hw, 2U, 1U, & phy_id_high);
#line 327
  if (status == 0) {
#line 328
    hw->phy.id = (unsigned int )((int )phy_id_high << 16);
#line 329
    status = (*(hw->phy.ops.read_reg))(hw, 3U, 1U, & phy_id_low);
#line 331
    hw->phy.id = hw->phy.id | ((u32 )phy_id_low & 4294967280U);
#line 332
    hw->phy.revision = (unsigned int )phy_id_low & 15U;
  } else {

  }
#line 334
  return (status);
}
}
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id ) 
{ 
  enum ixgbe_phy_type phy_type ;

  {
#line 346
  switch (phy_id) {
  case 10589200U: 
#line 348
  phy_type = 2;
#line 349
  goto ldv_54510;
  case 22282784U: ;
  case 22282752U: 
#line 352
  phy_type = 3;
#line 353
  goto ldv_54510;
  case 4432896U: 
#line 355
  phy_type = 8;
#line 356
  goto ldv_54510;
  case 54693968U: 
#line 358
  phy_type = 10;
#line 359
  goto ldv_54510;
  case 22282816U: 
#line 361
  phy_type = 6;
#line 362
  goto ldv_54510;
  default: 
#line 364
  phy_type = 0;
#line 365
  goto ldv_54510;
  }
  ldv_54510: ;
#line 368
  return (phy_type);
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw ) 
{ 
  u32 i ;
  u16 ctrl ;
  s32 status ;
  s32 tmp ;
  bool tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
#line 378
  ctrl = 0U;
#line 379
  status = 0;
#line 381
  if ((unsigned int )hw->phy.type == 0U) {
#line 382
    status = ixgbe_identify_phy_generic(hw);
  } else {

  }
#line 384
  if (status != 0 || (unsigned int )hw->phy.type == 1U) {
#line 385
    return (status);
  } else {

  }
#line 388
  if (! hw->phy.reset_if_overtemp) {
#line 388
    tmp = (*(hw->phy.ops.check_overtemp))(hw);
#line 388
    if (tmp == -26) {
#line 390
      return (0);
    } else {

    }
  } else {

  }
#line 393
  tmp___0 = ixgbe_check_reset_blocked(hw);
#line 393
  if ((int )tmp___0) {
#line 394
    return (0);
  } else {

  }
#line 400
  (*(hw->phy.ops.write_reg))(hw, 0U, 4U, 32768);
#line 409
  i = 0U;
#line 409
  goto ldv_54525;
  ldv_54524: 
#line 410
  msleep(100U);
#line 411
  (*(hw->phy.ops.read_reg))(hw, 0U, 4U, & ctrl);
#line 413
  if ((int )((short )ctrl) >= 0) {
#line 414
    __const_udelay(8590UL);
#line 415
    goto ldv_54523;
  } else {

  }
#line 409
  i = i + 1U;
  ldv_54525: ;
#line 409
  if (i <= 29U) {
#line 411
    goto ldv_54524;
  } else {

  }
  ldv_54523: ;
#line 419
  if ((int )((short )ctrl) < 0) {
#line 420
    descriptor.modname = "ixgbe";
#line 420
    descriptor.function = "ixgbe_reset_phy_generic";
#line 420
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 420
    descriptor.format = "PHY reset polling failed to complete.\n";
#line 420
    descriptor.lineno = 420U;
#line 420
    descriptor.flags = 0U;
#line 420
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 420
    if (tmp___1 != 0L) {
#line 420
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PHY reset polling failed to complete.\n");
    } else {

    }
#line 421
    return (-15);
  } else {

  }
#line 424
  return (0);
}
}
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_phy_reg_mdi(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                           u16 *phy_data ) 
{ 
  u32 i ;
  u32 data ;
  u32 command ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
#line 440
  command = (((device_type << 16) | reg_addr) | (u32 )(hw->phy.mdio.prtad << 21)) | 1073741824U;
#line 445
  ixgbe_write_reg(hw, 16988U, command);
#line 451
  i = 0U;
#line 451
  goto ldv_54539;
  ldv_54538: 
#line 452
  __const_udelay(42950UL);
#line 454
  command = ixgbe_read_reg(hw, 16988U);
#line 455
  if ((command & 1073741824U) == 0U) {
#line 456
    goto ldv_54537;
  } else {

  }
#line 451
  i = i + 1U;
  ldv_54539: ;
#line 451
  if (i <= 99U) {
#line 453
    goto ldv_54538;
  } else {

  }
  ldv_54537: ;
#line 460
  if ((command & 1073741824U) != 0U) {
#line 461
    descriptor.modname = "ixgbe";
#line 461
    descriptor.function = "ixgbe_read_phy_reg_mdi";
#line 461
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 461
    descriptor.format = "PHY address command did not complete.\n";
#line 461
    descriptor.lineno = 461U;
#line 461
    descriptor.flags = 0U;
#line 461
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 461
    if (tmp != 0L) {
#line 461
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PHY address command did not complete.\n");
    } else {

    }
#line 462
    return (-3);
  } else {

  }
#line 468
  command = (((device_type << 16) | reg_addr) | (u32 )(hw->phy.mdio.prtad << 21)) | 1275068416U;
#line 473
  ixgbe_write_reg(hw, 16988U, command);
#line 479
  i = 0U;
#line 479
  goto ldv_54544;
  ldv_54543: 
#line 480
  __const_udelay(42950UL);
#line 482
  command = ixgbe_read_reg(hw, 16988U);
#line 483
  if ((command & 1073741824U) == 0U) {
#line 484
    goto ldv_54542;
  } else {

  }
#line 479
  i = i + 1U;
  ldv_54544: ;
#line 479
  if (i <= 99U) {
#line 481
    goto ldv_54543;
  } else {

  }
  ldv_54542: ;
#line 487
  if ((command & 1073741824U) != 0U) {
#line 488
    descriptor___0.modname = "ixgbe";
#line 488
    descriptor___0.function = "ixgbe_read_phy_reg_mdi";
#line 488
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 488
    descriptor___0.format = "PHY read command didn\'t complete\n";
#line 488
    descriptor___0.lineno = 488U;
#line 488
    descriptor___0.flags = 0U;
#line 488
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 488
    if (tmp___0 != 0L) {
#line 488
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PHY read command didn\'t complete\n");
    } else {

    }
#line 489
    return (-3);
  } else {

  }
#line 495
  data = ixgbe_read_reg(hw, 16992U);
#line 496
  data = data >> 16;
#line 497
  *phy_data = (unsigned short )data;
#line 499
  return (0);
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                               u16 *phy_data ) 
{ 
  s32 status ;
  u32 gssr ;
  s32 tmp ;

  {
#line 513
  gssr = hw->phy.phy_semaphore_mask;
#line 515
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, gssr);
#line 515
  if (tmp == 0) {
#line 516
    status = ixgbe_read_phy_reg_mdi(hw, reg_addr, device_type, phy_data);
#line 518
    (*(hw->mac.ops.release_swfw_sync))(hw, gssr);
  } else {
#line 520
    return (-16);
  }
#line 523
  return (status);
}
}
#line 534 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                            u16 phy_data ) 
{ 
  u32 i ;
  u32 command ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
#line 540
  ixgbe_write_reg(hw, 16992U, (unsigned int )phy_data);
#line 543
  command = (((device_type << 16) | reg_addr) | (u32 )(hw->phy.mdio.prtad << 21)) | 1073741824U;
#line 548
  ixgbe_write_reg(hw, 16988U, command);
#line 555
  i = 0U;
#line 555
  goto ldv_54564;
  ldv_54563: 
#line 556
  __const_udelay(42950UL);
#line 558
  command = ixgbe_read_reg(hw, 16988U);
#line 559
  if ((command & 1073741824U) == 0U) {
#line 560
    goto ldv_54562;
  } else {

  }
#line 555
  i = i + 1U;
  ldv_54564: ;
#line 555
  if (i <= 99U) {
#line 557
    goto ldv_54563;
  } else {

  }
  ldv_54562: ;
#line 563
  if ((command & 1073741824U) != 0U) {
#line 564
    descriptor.modname = "ixgbe";
#line 564
    descriptor.function = "ixgbe_write_phy_reg_mdi";
#line 564
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 564
    descriptor.format = "PHY address cmd didn\'t complete\n";
#line 564
    descriptor.lineno = 564U;
#line 564
    descriptor.flags = 0U;
#line 564
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 564
    if (tmp != 0L) {
#line 564
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PHY address cmd didn\'t complete\n");
    } else {

    }
#line 565
    return (-3);
  } else {

  }
#line 572
  command = (((device_type << 16) | reg_addr) | (u32 )(hw->phy.mdio.prtad << 21)) | 1140850688U;
#line 577
  ixgbe_write_reg(hw, 16988U, command);
#line 583
  i = 0U;
#line 583
  goto ldv_54569;
  ldv_54568: 
#line 584
  __const_udelay(42950UL);
#line 586
  command = ixgbe_read_reg(hw, 16988U);
#line 587
  if ((command & 1073741824U) == 0U) {
#line 588
    goto ldv_54567;
  } else {

  }
#line 583
  i = i + 1U;
  ldv_54569: ;
#line 583
  if (i <= 99U) {
#line 585
    goto ldv_54568;
  } else {

  }
  ldv_54567: ;
#line 591
  if ((command & 1073741824U) != 0U) {
#line 592
    descriptor___0.modname = "ixgbe";
#line 592
    descriptor___0.function = "ixgbe_write_phy_reg_mdi";
#line 592
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 592
    descriptor___0.format = "PHY write cmd didn\'t complete\n";
#line 592
    descriptor___0.lineno = 592U;
#line 592
    descriptor___0.flags = 0U;
#line 592
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 592
    if (tmp___0 != 0L) {
#line 592
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PHY write cmd didn\'t complete\n");
    } else {

    }
#line 593
    return (-3);
  } else {

  }
#line 596
  return (0);
}
}
#line 607 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                                u16 phy_data ) 
{ 
  s32 status ;
  u32 gssr ;
  u32 tmp ;
  s32 tmp___0 ;

  {
#line 613
  tmp = ixgbe_read_reg(hw, 8U);
#line 613
  if ((tmp & 4U) != 0U) {
#line 614
    gssr = 4U;
  } else {
#line 616
    gssr = 2U;
  }
#line 618
  tmp___0 = (*(hw->mac.ops.acquire_swfw_sync))(hw, gssr);
#line 618
  if (tmp___0 == 0) {
#line 619
    status = ixgbe_write_phy_reg_mdi(hw, reg_addr, device_type, (int )phy_data);
#line 621
    (*(hw->mac.ops.release_swfw_sync))(hw, gssr);
  } else {
#line 623
    return (-16);
  }
#line 626
  return (status);
}
}
#line 635 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 autoneg_reg ;
  bool autoneg ;
  ixgbe_link_speed speed ;
  bool tmp ;

  {
#line 637
  status = 0;
#line 638
  autoneg_reg = 0U;
#line 639
  autoneg = 0;
#line 642
  ixgbe_get_copper_link_capabilities_generic(hw, & speed, & autoneg);
#line 644
  if ((speed & 128U) != 0U) {
#line 646
    (*(hw->phy.ops.read_reg))(hw, 32U, 7U, & autoneg_reg);
#line 650
    autoneg_reg = (unsigned int )autoneg_reg & 61439U;
#line 651
    if ((hw->phy.autoneg_advertised & 128U) != 0U) {
#line 652
      autoneg_reg = (u16 )((unsigned int )autoneg_reg | 4096U);
    } else {

    }
#line 654
    (*(hw->phy.ops.write_reg))(hw, 32U, 7U, (int )autoneg_reg);
  } else {

  }
#line 659
  if ((speed & 32U) != 0U) {
#line 661
    (*(hw->phy.ops.read_reg))(hw, 50176U, 7U, & autoneg_reg);
#line 666
    autoneg_reg = (unsigned int )autoneg_reg & 32767U;
#line 667
    if ((hw->phy.autoneg_advertised & 32U) != 0U) {
#line 668
      autoneg_reg = (u16 )((unsigned int )autoneg_reg | 32768U);
    } else {

    }
#line 670
    (*(hw->phy.ops.write_reg))(hw, 50176U, 7U, (int )autoneg_reg);
  } else {

  }
#line 676
  if ((speed & 8U) != 0U) {
#line 678
    (*(hw->phy.ops.read_reg))(hw, 16U, 7U, & autoneg_reg);
#line 682
    autoneg_reg = (unsigned int )autoneg_reg & 65151U;
#line 684
    if ((hw->phy.autoneg_advertised & 8U) != 0U) {
#line 685
      autoneg_reg = (u16 )((unsigned int )autoneg_reg | 256U);
    } else {

    }
#line 687
    (*(hw->phy.ops.write_reg))(hw, 16U, 7U, (int )autoneg_reg);
  } else {

  }
#line 693
  tmp = ixgbe_check_reset_blocked(hw);
#line 693
  if ((int )tmp) {
#line 694
    return (0);
  } else {

  }
#line 697
  (*(hw->phy.ops.read_reg))(hw, 0U, 7U, & autoneg_reg);
#line 700
  autoneg_reg = (u16 )((unsigned int )autoneg_reg | 512U);
#line 702
  (*(hw->phy.ops.write_reg))(hw, 0U, 7U, (int )autoneg_reg);
#line 705
  return (status);
}
}
#line 713 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                       bool autoneg_wait_to_complete ) 
{ 


  {
#line 722
  hw->phy.autoneg_advertised = 0U;
#line 724
  if ((speed & 128U) != 0U) {
#line 725
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 128U;
  } else {

  }
#line 727
  if ((speed & 32U) != 0U) {
#line 728
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 32U;
  } else {

  }
#line 730
  if ((speed & 8U) != 0U) {
#line 731
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 8U;
  } else {

  }
#line 734
  (*(hw->phy.ops.setup_link))(hw);
#line 736
  return (0);
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw , ixgbe_link_speed *speed ,
                                               bool *autoneg ) 
{ 
  s32 status ;
  u16 speed_ability ;

  {
#line 754
  *speed = 0U;
#line 755
  *autoneg = 1;
#line 757
  status = (*(hw->phy.ops.read_reg))(hw, 4U, 1U, & speed_ability);
#line 760
  if (status == 0) {
#line 761
    if ((int )speed_ability & 1) {
#line 762
      *speed = *speed | 128U;
    } else {

    }
#line 763
    if (((int )speed_ability & 16) != 0) {
#line 764
      *speed = *speed | 32U;
    } else {

    }
#line 765
    if (((int )speed_ability & 32) != 0) {
#line 766
      *speed = *speed | 8U;
    } else {

    }
  } else {

  }
#line 770
  if ((unsigned int )hw->mac.type == 5U) {
#line 771
    *speed = *speed & 4294967287U;
  } else {

  }
#line 773
  return (status);
}
}
#line 783 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw , ixgbe_link_speed *speed , bool *link_up ) 
{ 
  s32 status ;
  u32 time_out ;
  u32 max_time_out ;
  u16 phy_link ;
  u16 phy_speed ;
  u16 phy_data ;

  {
#line 788
  max_time_out = 10U;
#line 789
  phy_link = 0U;
#line 790
  phy_speed = 0U;
#line 791
  phy_data = 0U;
#line 794
  *link_up = 0;
#line 795
  *speed = 128U;
#line 802
  time_out = 0U;
#line 802
  goto ldv_54611;
  ldv_54610: 
#line 803
  __const_udelay(42950UL);
#line 804
  status = (*(hw->phy.ops.read_reg))(hw, 1U, 30U, & phy_data);
#line 808
  phy_link = (unsigned int )phy_data & 8U;
#line 810
  phy_speed = (unsigned int )phy_data & 16U;
#line 812
  if ((unsigned int )phy_link == 8U) {
#line 813
    *link_up = 1;
#line 814
    if ((unsigned int )phy_speed == 16U) {
#line 816
      *speed = 32U;
    } else {

    }
#line 817
    goto ldv_54609;
  } else {

  }
#line 802
  time_out = time_out + 1U;
  ldv_54611: ;
#line 802
  if (time_out < max_time_out) {
#line 804
    goto ldv_54610;
  } else {

  }
  ldv_54609: ;
#line 821
  return (status);
}
}
#line 833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw ) 
{ 
  u16 autoneg_reg ;
  bool autoneg ;
  ixgbe_link_speed speed ;
  bool tmp ;

  {
#line 835
  autoneg_reg = 0U;
#line 836
  autoneg = 0;
#line 839
  ixgbe_get_copper_link_capabilities_generic(hw, & speed, & autoneg);
#line 841
  if ((speed & 128U) != 0U) {
#line 843
    (*(hw->phy.ops.read_reg))(hw, 32U, 7U, & autoneg_reg);
#line 847
    autoneg_reg = (unsigned int )autoneg_reg & 61439U;
#line 848
    if ((hw->phy.autoneg_advertised & 128U) != 0U) {
#line 849
      autoneg_reg = (u16 )((unsigned int )autoneg_reg | 4096U);
    } else {

    }
#line 851
    (*(hw->phy.ops.write_reg))(hw, 32U, 7U, (int )autoneg_reg);
  } else {

  }
#line 856
  if ((speed & 32U) != 0U) {
#line 858
    (*(hw->phy.ops.read_reg))(hw, 23U, 7U, & autoneg_reg);
#line 862
    autoneg_reg = (unsigned int )autoneg_reg & 49151U;
#line 863
    if ((hw->phy.autoneg_advertised & 32U) != 0U) {
#line 864
      autoneg_reg = (u16 )((unsigned int )autoneg_reg | 16384U);
    } else {

    }
#line 866
    (*(hw->phy.ops.write_reg))(hw, 23U, 7U, (int )autoneg_reg);
  } else {

  }
#line 871
  if ((speed & 8U) != 0U) {
#line 873
    (*(hw->phy.ops.read_reg))(hw, 16U, 7U, & autoneg_reg);
#line 877
    autoneg_reg = (unsigned int )autoneg_reg & 65151U;
#line 879
    if ((hw->phy.autoneg_advertised & 8U) != 0U) {
#line 880
      autoneg_reg = (u16 )((unsigned int )autoneg_reg | 256U);
    } else {

    }
#line 882
    (*(hw->phy.ops.write_reg))(hw, 16U, 7U, (int )autoneg_reg);
  } else {

  }
#line 888
  tmp = ixgbe_check_reset_blocked(hw);
#line 888
  if ((int )tmp) {
#line 889
    return (0);
  } else {

  }
#line 892
  (*(hw->phy.ops.read_reg))(hw, 0U, 7U, & autoneg_reg);
#line 895
  autoneg_reg = (u16 )((unsigned int )autoneg_reg | 512U);
#line 897
  (*(hw->phy.ops.write_reg))(hw, 0U, 7U, (int )autoneg_reg);
#line 899
  return (0);
}
}
#line 907 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_get_phy_firmware_version_tnx(struct ixgbe_hw *hw , u16 *firmware_version ) 
{ 
  s32 status ;

  {
#line 912
  status = (*(hw->phy.ops.read_reg))(hw, 11U, 30U, firmware_version);
#line 916
  return (status);
}
}
#line 924 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_get_phy_firmware_version_generic(struct ixgbe_hw *hw , u16 *firmware_version ) 
{ 
  s32 status ;

  {
#line 929
  status = (*(hw->phy.ops.read_reg))(hw, 32U, 30U, firmware_version);
#line 933
  return (status);
}
}
#line 940 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw ) 
{ 
  u16 phy_offset ;
  u16 control ;
  u16 eword ;
  u16 edata ;
  u16 block_crc ;
  bool end_data ;
  u16 list_offset ;
  u16 data_offset ;
  u16 phy_data ;
  s32 ret_val ;
  u32 i ;
  bool tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  u16 tmp___3 ;
  struct _ddebug descriptor___2 ;
  long tmp___4 ;
  struct _ddebug descriptor___3 ;
  long tmp___5 ;
  struct _ddebug descriptor___4 ;
  long tmp___6 ;
  struct _ddebug descriptor___5 ;
  long tmp___7 ;
  struct _ddebug descriptor___6 ;
  long tmp___8 ;
  struct _ddebug descriptor___7 ;
  long tmp___9 ;

  {
#line 943
  end_data = 0;
#line 945
  phy_data = 0U;
#line 950
  tmp = ixgbe_check_reset_blocked(hw);
#line 950
  if ((int )tmp) {
#line 951
    return (0);
  } else {

  }
#line 953
  (*(hw->phy.ops.read_reg))(hw, 0U, 4U, & phy_data);
#line 956
  (*(hw->phy.ops.write_reg))(hw, 0U, 4U, (int )((unsigned int )phy_data | 32768U));
#line 959
  i = 0U;
#line 959
  goto ldv_54644;
  ldv_54643: 
#line 960
  (*(hw->phy.ops.read_reg))(hw, 0U, 4U, & phy_data);
#line 962
  if ((int )((short )phy_data) >= 0) {
#line 963
    goto ldv_54642;
  } else {

  }
#line 964
  usleep_range(10000UL, 20000UL);
#line 959
  i = i + 1U;
  ldv_54644: ;
#line 959
  if (i <= 99U) {
#line 961
    goto ldv_54643;
  } else {

  }
  ldv_54642: ;
#line 967
  if ((int )((short )phy_data) < 0) {
#line 968
    descriptor.modname = "ixgbe";
#line 968
    descriptor.function = "ixgbe_reset_phy_nl";
#line 968
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 968
    descriptor.format = "PHY reset did not complete.\n";
#line 968
    descriptor.lineno = 968U;
#line 968
    descriptor.flags = 0U;
#line 968
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 968
    if (tmp___0 != 0L) {
#line 968
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PHY reset did not complete.\n");
    } else {

    }
#line 969
    return (-3);
  } else {

  }
#line 973
  ret_val = ixgbe_get_sfp_init_sequence_offsets(hw, & list_offset, & data_offset);
#line 975
  if (ret_val != 0) {
#line 976
    return (ret_val);
  } else {

  }
#line 978
  ret_val = (*(hw->eeprom.ops.read))(hw, (int )data_offset, & block_crc);
#line 979
  data_offset = (u16 )((int )data_offset + 1);
#line 980
  goto ldv_54665;
  ldv_54664: 
#line 984
  ret_val = (*(hw->eeprom.ops.read))(hw, (int )data_offset, & eword);
#line 985
  if (ret_val != 0) {
#line 986
    goto err_eeprom;
  } else {

  }
#line 987
  control = (int )eword >> 12;
#line 989
  edata = (unsigned int )eword & 4095U;
#line 990
  switch ((int )control) {
  case 0: 
#line 992
  data_offset = (u16 )((int )data_offset + 1);
#line 993
  descriptor___0.modname = "ixgbe";
#line 993
  descriptor___0.function = "ixgbe_reset_phy_nl";
#line 993
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 993
  descriptor___0.format = "DELAY: %d MS\n";
#line 993
  descriptor___0.lineno = 993U;
#line 993
  descriptor___0.flags = 0U;
#line 993
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 993
  if (tmp___1 != 0L) {
#line 993
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "DELAY: %d MS\n", (int )edata);
  } else {

  }
#line 994
  usleep_range((unsigned long )((int )edata * 1000), (unsigned long )((int )edata * 2000));
#line 995
  goto ldv_54650;
  case 1: 
#line 997
  descriptor___1.modname = "ixgbe";
#line 997
  descriptor___1.function = "ixgbe_reset_phy_nl";
#line 997
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 997
  descriptor___1.format = "DATA:\n";
#line 997
  descriptor___1.lineno = 997U;
#line 997
  descriptor___1.flags = 0U;
#line 997
  tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 997
  if (tmp___2 != 0L) {
#line 997
    __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "DATA:\n");
  } else {

  }
#line 998
  data_offset = (u16 )((int )data_offset + 1);
#line 999
  tmp___3 = data_offset;
#line 999
  data_offset = (u16 )((int )data_offset + 1);
#line 999
  ret_val = (*(hw->eeprom.ops.read))(hw, (int )tmp___3, & phy_offset);
#line 1001
  if (ret_val != 0) {
#line 1002
    goto err_eeprom;
  } else {

  }
#line 1003
  i = 0U;
#line 1003
  goto ldv_54655;
  ldv_54654: 
#line 1004
  ret_val = (*(hw->eeprom.ops.read))(hw, (int )data_offset, & eword);
#line 1006
  if (ret_val != 0) {
#line 1007
    goto err_eeprom;
  } else {

  }
#line 1008
  (*(hw->phy.ops.write_reg))(hw, (u32 )phy_offset, 1U, (int )eword);
#line 1010
  descriptor___2.modname = "ixgbe";
#line 1010
  descriptor___2.function = "ixgbe_reset_phy_nl";
#line 1010
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1010
  descriptor___2.format = "Wrote %4.4x to %4.4x\n";
#line 1010
  descriptor___2.lineno = 1011U;
#line 1010
  descriptor___2.flags = 0U;
#line 1010
  tmp___4 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 1010
  if (tmp___4 != 0L) {
#line 1010
    __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Wrote %4.4x to %4.4x\n", (int )eword, (int )phy_offset);
  } else {

  }
#line 1012
  data_offset = (u16 )((int )data_offset + 1);
#line 1013
  phy_offset = (u16 )((int )phy_offset + 1);
#line 1003
  i = i + 1U;
  ldv_54655: ;
#line 1003
  if ((u32 )edata > i) {
#line 1005
    goto ldv_54654;
  } else {

  }

#line 1015
  goto ldv_54650;
  case 15: 
#line 1017
  data_offset = (u16 )((int )data_offset + 1);
#line 1018
  descriptor___3.modname = "ixgbe";
#line 1018
  descriptor___3.function = "ixgbe_reset_phy_nl";
#line 1018
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1018
  descriptor___3.format = "CONTROL:\n";
#line 1018
  descriptor___3.lineno = 1018U;
#line 1018
  descriptor___3.flags = 0U;
#line 1018
  tmp___5 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
#line 1018
  if (tmp___5 != 0L) {
#line 1018
    __dynamic_netdev_dbg(& descriptor___3, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "CONTROL:\n");
  } else {

  }
#line 1019
  if ((unsigned int )edata == 4095U) {
#line 1020
    descriptor___4.modname = "ixgbe";
#line 1020
    descriptor___4.function = "ixgbe_reset_phy_nl";
#line 1020
    descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1020
    descriptor___4.format = "EOL\n";
#line 1020
    descriptor___4.lineno = 1020U;
#line 1020
    descriptor___4.flags = 0U;
#line 1020
    tmp___6 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
#line 1020
    if (tmp___6 != 0L) {
#line 1020
      __dynamic_netdev_dbg(& descriptor___4, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EOL\n");
    } else {

    }
#line 1021
    end_data = 1;
  } else
#line 1022
  if ((unsigned int )edata == 0U) {
#line 1023
    descriptor___5.modname = "ixgbe";
#line 1023
    descriptor___5.function = "ixgbe_reset_phy_nl";
#line 1023
    descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1023
    descriptor___5.format = "SOL\n";
#line 1023
    descriptor___5.lineno = 1023U;
#line 1023
    descriptor___5.flags = 0U;
#line 1023
    tmp___7 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
#line 1023
    if (tmp___7 != 0L) {
#line 1023
      __dynamic_netdev_dbg(& descriptor___5, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "SOL\n");
    } else {

    }
  } else {
#line 1025
    descriptor___6.modname = "ixgbe";
#line 1025
    descriptor___6.function = "ixgbe_reset_phy_nl";
#line 1025
    descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1025
    descriptor___6.format = "Bad control value\n";
#line 1025
    descriptor___6.lineno = 1025U;
#line 1025
    descriptor___6.flags = 0U;
#line 1025
    tmp___8 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
#line 1025
    if (tmp___8 != 0L) {
#line 1025
      __dynamic_netdev_dbg(& descriptor___6, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Bad control value\n");
    } else {

    }
#line 1026
    return (-3);
  }
#line 1028
  goto ldv_54650;
  default: 
#line 1030
  descriptor___7.modname = "ixgbe";
#line 1030
  descriptor___7.function = "ixgbe_reset_phy_nl";
#line 1030
  descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1030
  descriptor___7.format = "Bad control type\n";
#line 1030
  descriptor___7.lineno = 1030U;
#line 1030
  descriptor___7.flags = 0U;
#line 1030
  tmp___9 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
#line 1030
  if (tmp___9 != 0L) {
#line 1030
    __dynamic_netdev_dbg(& descriptor___7, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Bad control type\n");
  } else {

  }
#line 1031
  return (-3);
  }
  ldv_54650: ;
  ldv_54665: ;
#line 980
  if (! end_data) {
#line 982
    goto ldv_54664;
  } else {

  }

#line 1035
  return (ret_val);
  err_eeprom: 
#line 1038
  netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
             "eeprom read at offset %d failed\n", (int )data_offset);
#line 1039
  return (-3);
}
}
#line 1048 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_identify_module_generic(struct ixgbe_hw *hw ) 
{ 
  enum ixgbe_media_type tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;

  {
#line 1050
  tmp = (*(hw->mac.ops.get_media_type))(hw);
#line 1050
  switch ((unsigned int )tmp) {
  case 1U: 
#line 1052
  tmp___0 = ixgbe_identify_sfp_module_generic(hw);
#line 1052
  return (tmp___0);
  case 2U: 
#line 1054
  tmp___1 = ixgbe_identify_qsfp_module_generic(hw);
#line 1054
  return (tmp___1);
  default: 
#line 1056
  hw->phy.sfp_type = 65534;
#line 1057
  return (-20);
  }
#line 1060
  return (-20);
}
}
#line 1069 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_adapter *adapter ;
  s32 status ;
  u32 vendor_oui ;
  enum ixgbe_sfp_type stored_sfp_type ;
  u8 identifier ;
  u8 comp_codes_1g ;
  u8 comp_codes_10g ;
  u8 oui_bytes[3U] ;
  u8 cable_tech ;
  u8 cable_spec ;
  u16 enforce_sfp ;
  enum ixgbe_media_type tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
#line 1071
  adapter = (struct ixgbe_adapter *)hw->back;
#line 1073
  vendor_oui = 0U;
#line 1074
  stored_sfp_type = hw->phy.sfp_type;
#line 1075
  identifier = 0U;
#line 1076
  comp_codes_1g = 0U;
#line 1077
  comp_codes_10g = 0U;
#line 1078
  oui_bytes[0] = 0U;
#line 1078
  oui_bytes[1] = 0U;
#line 1078
  oui_bytes[2] = 0U;
#line 1079
  cable_tech = 0U;
#line 1080
  cable_spec = 0U;
#line 1081
  enforce_sfp = 0U;
#line 1083
  tmp = (*(hw->mac.ops.get_media_type))(hw);
#line 1083
  if ((unsigned int )tmp != 1U) {
#line 1084
    hw->phy.sfp_type = 65534;
#line 1085
    return (-20);
  } else {

  }
#line 1088
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 0, & identifier);
#line 1092
  if (status != 0) {
#line 1093
    goto err_read_i2c_eeprom;
  } else {

  }
#line 1096
  (*(hw->mac.ops.set_lan_id))(hw);
#line 1098
  if ((unsigned int )identifier != 3U) {
#line 1099
    hw->phy.type = 23;
#line 1100
    return (-19);
  } else {

  }
#line 1102
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 6, & comp_codes_1g);
#line 1106
  if (status != 0) {
#line 1107
    goto err_read_i2c_eeprom;
  } else {

  }
#line 1109
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 3, & comp_codes_10g);
#line 1113
  if (status != 0) {
#line 1114
    goto err_read_i2c_eeprom;
  } else {

  }
#line 1115
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 8, & cable_tech);
#line 1119
  if (status != 0) {
#line 1120
    goto err_read_i2c_eeprom;
  } else {

  }
#line 1138
  if ((unsigned int )hw->mac.type == 1U) {
#line 1139
    if (((int )cable_tech & 4) != 0) {
#line 1140
      hw->phy.sfp_type = 0;
    } else
#line 1141
    if (((int )comp_codes_10g & 16) != 0) {
#line 1142
      hw->phy.sfp_type = 1;
    } else
#line 1143
    if (((int )comp_codes_10g & 32) != 0) {
#line 1144
      hw->phy.sfp_type = 2;
    } else {
#line 1146
      hw->phy.sfp_type = 65535;
    }
  } else
#line 1147
  if ((unsigned int )hw->mac.type == 2U) {
#line 1148
    if (((int )cable_tech & 4) != 0) {
#line 1149
      if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1150
        hw->phy.sfp_type = 3;
      } else {
#line 1153
        hw->phy.sfp_type = 4;
      }
    } else
#line 1155
    if (((int )cable_tech & 8) != 0) {
#line 1156
      (*(hw->phy.ops.read_i2c_eeprom))(hw, 60, & cable_spec);
#line 1159
      if (((int )cable_spec & 4) != 0) {
#line 1161
        if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1162
          hw->phy.sfp_type = 7;
        } else {
#line 1165
          hw->phy.sfp_type = 8;
        }
      } else {
#line 1168
        hw->phy.sfp_type = 65535;
      }
    } else
#line 1171
    if (((int )comp_codes_10g & 48) != 0) {
#line 1174
      if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1175
        hw->phy.sfp_type = 5;
      } else {
#line 1178
        hw->phy.sfp_type = 6;
      }
    } else
#line 1180
    if (((int )comp_codes_1g & 8) != 0) {
#line 1181
      if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1182
        hw->phy.sfp_type = 9;
      } else {
#line 1185
        hw->phy.sfp_type = 10;
      }
    } else
#line 1187
    if ((int )comp_codes_1g & 1) {
#line 1188
      if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1189
        hw->phy.sfp_type = 11;
      } else {
#line 1192
        hw->phy.sfp_type = 12;
      }
    } else
#line 1194
    if (((int )comp_codes_1g & 2) != 0) {
#line 1195
      if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1196
        hw->phy.sfp_type = 13;
      } else {
#line 1199
        hw->phy.sfp_type = 14;
      }
    } else {
#line 1202
      hw->phy.sfp_type = 65535;
    }
  } else {

  }
#line 1206
  if ((unsigned int )hw->phy.sfp_type != (unsigned int )stored_sfp_type) {
#line 1207
    hw->phy.sfp_setup_needed = 1;
  } else {

  }
#line 1210
  hw->phy.multispeed_fiber = 0;
#line 1211
  if (((int )comp_codes_1g & 1 && ((int )comp_codes_10g & 16) != 0) || (((int )comp_codes_1g & 2) != 0 && ((int )comp_codes_10g & 32) != 0)) {
#line 1215
    hw->phy.multispeed_fiber = 1;
  } else {

  }
#line 1218
  if ((unsigned int )hw->phy.type != 10U) {
#line 1219
    hw->phy.id = (u32 )identifier;
#line 1220
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 37, (u8 *)(& oui_bytes));
#line 1224
    if (status != 0) {
#line 1225
      goto err_read_i2c_eeprom;
    } else {

    }
#line 1227
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 38, (u8 *)(& oui_bytes) + 1UL);
#line 1231
    if (status != 0) {
#line 1232
      goto err_read_i2c_eeprom;
    } else {

    }
#line 1234
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 39, (u8 *)(& oui_bytes) + 2UL);
#line 1238
    if (status != 0) {
#line 1239
      goto err_read_i2c_eeprom;
    } else {

    }
#line 1241
    vendor_oui = (u32 )((((int )oui_bytes[0] << 24) | ((int )oui_bytes[1] << 16)) | ((int )oui_bytes[2] << 8));
#line 1246
    switch (vendor_oui) {
    case 4224512U: ;
#line 1248
    if (((int )cable_tech & 4) != 0) {
#line 1249
      hw->phy.type = 11;
    } else {

    }
#line 1251
    goto ldv_54689;
    case 9463040U: ;
#line 1253
    if (((int )cable_tech & 8) != 0) {
#line 1254
      hw->phy.type = 16;
    } else {
#line 1256
      hw->phy.type = 15;
    }
#line 1257
    goto ldv_54689;
    case 1534464U: 
#line 1259
    hw->phy.type = 14;
#line 1260
    goto ldv_54689;
    case 1777920U: 
#line 1262
    hw->phy.type = 18;
#line 1263
    goto ldv_54689;
    default: ;
#line 1265
    if (((int )cable_tech & 4) != 0) {
#line 1266
      hw->phy.type = 12;
    } else
#line 1268
    if (((int )cable_tech & 8) != 0) {
#line 1269
      hw->phy.type = 13;
    } else {
#line 1272
      hw->phy.type = 17;
    }
#line 1273
    goto ldv_54689;
    }
    ldv_54689: ;
  } else {

  }
#line 1278
  if (((int )cable_tech & 12) != 0) {
#line 1280
    return (0);
  } else {

  }
#line 1283
  if ((unsigned int )comp_codes_10g == 0U && ((((((unsigned int )hw->phy.sfp_type != 10U && (unsigned int )hw->phy.sfp_type != 9U) && (unsigned int )hw->phy.sfp_type != 13U) && (unsigned int )hw->phy.sfp_type != 14U) && (unsigned int )hw->phy.sfp_type != 11U) && (unsigned int )hw->phy.sfp_type != 12U)) {
#line 1290
    hw->phy.type = 23;
#line 1291
    return (-19);
  } else {

  }
#line 1295
  if ((unsigned int )hw->mac.type == 1U) {
#line 1296
    return (0);
  } else {

  }
#line 1298
  (*(hw->mac.ops.get_device_caps))(hw, & enforce_sfp);
#line 1299
  if (((int )enforce_sfp & 1) == 0 && ((((((unsigned int )hw->phy.sfp_type != 9U && (unsigned int )hw->phy.sfp_type != 10U) && (unsigned int )hw->phy.sfp_type != 13U) && (unsigned int )hw->phy.sfp_type != 14U) && (unsigned int )hw->phy.sfp_type != 11U) && (unsigned int )hw->phy.sfp_type != 12U)) {
#line 1307
    if ((unsigned int )hw->phy.type == 18U) {
#line 1308
      return (0);
    } else {

    }
#line 1309
    if ((int )hw->allow_unsupported_sfp) {
#line 1310
      if ((int )adapter->msg_enable & 1) {
#line 1310
        netdev_warn((struct net_device  const  *)adapter->netdev, "WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics.  Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter.  Intel Corporation is not responsible for any harm caused by using untested modules.\n");
      } else {

      }
#line 1311
      return (0);
    } else {

    }
#line 1313
    descriptor.modname = "ixgbe";
#line 1313
    descriptor.function = "ixgbe_identify_sfp_module_generic";
#line 1313
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1313
    descriptor.format = "SFP+ module not supported\n";
#line 1313
    descriptor.lineno = 1313U;
#line 1313
    descriptor.flags = 0U;
#line 1313
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1313
    if (tmp___0 != 0L) {
#line 1313
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "SFP+ module not supported\n");
    } else {

    }
#line 1314
    hw->phy.type = 23;
#line 1315
    return (-19);
  } else {

  }
#line 1317
  return (0);
  err_read_i2c_eeprom: 
#line 1320
  hw->phy.sfp_type = 65534;
#line 1321
  if ((unsigned int )hw->phy.type != 10U) {
#line 1322
    hw->phy.id = 0U;
#line 1323
    hw->phy.type = 0;
  } else {

  }
#line 1325
  return (-20);
}
}
#line 1334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_adapter *adapter ;
  s32 status ;
  u32 vendor_oui ;
  enum ixgbe_sfp_type stored_sfp_type ;
  u8 identifier ;
  u8 comp_codes_1g ;
  u8 comp_codes_10g ;
  u8 oui_bytes[3U] ;
  u16 enforce_sfp ;
  u8 connector ;
  u8 cable_length ;
  u8 device_tech ;
  bool active_cable ;
  enum ixgbe_media_type tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
#line 1336
  adapter = (struct ixgbe_adapter *)hw->back;
#line 1338
  vendor_oui = 0U;
#line 1339
  stored_sfp_type = hw->phy.sfp_type;
#line 1340
  identifier = 0U;
#line 1341
  comp_codes_1g = 0U;
#line 1342
  comp_codes_10g = 0U;
#line 1343
  oui_bytes[0] = 0U;
#line 1343
  oui_bytes[1] = 0U;
#line 1343
  oui_bytes[2] = 0U;
#line 1344
  enforce_sfp = 0U;
#line 1345
  connector = 0U;
#line 1346
  cable_length = 0U;
#line 1347
  device_tech = 0U;
#line 1348
  active_cable = 0;
#line 1350
  tmp = (*(hw->mac.ops.get_media_type))(hw);
#line 1350
  if ((unsigned int )tmp != 2U) {
#line 1351
    hw->phy.sfp_type = 65534;
#line 1352
    return (-20);
  } else {

  }
#line 1356
  (*(hw->mac.ops.set_lan_id))(hw);
#line 1358
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 0, & identifier);
#line 1361
  if (status != 0) {
#line 1362
    goto err_read_i2c_eeprom;
  } else {

  }
#line 1364
  if ((unsigned int )identifier != 13U) {
#line 1365
    hw->phy.type = 23;
#line 1366
    return (-19);
  } else {

  }
#line 1369
  hw->phy.id = (u32 )identifier;
#line 1371
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 131, & comp_codes_10g);
#line 1374
  if (status != 0) {
#line 1375
    goto err_read_i2c_eeprom;
  } else {

  }
#line 1377
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 134, & comp_codes_1g);
#line 1380
  if (status != 0) {
#line 1381
    goto err_read_i2c_eeprom;
  } else {

  }
#line 1383
  if (((int )comp_codes_10g & 8) != 0) {
#line 1384
    hw->phy.type = 19;
#line 1385
    if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1386
      hw->phy.sfp_type = 3;
    } else {
#line 1388
      hw->phy.sfp_type = 4;
    }
  } else
#line 1389
  if (((int )comp_codes_10g & 48) != 0) {
#line 1391
    if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1392
      hw->phy.sfp_type = 5;
    } else {
#line 1394
      hw->phy.sfp_type = 6;
    }
  } else {
#line 1396
    if ((int )comp_codes_10g & 1) {
#line 1397
      active_cable = 1;
    } else {

    }
#line 1399
    if (! active_cable) {
#line 1403
      (*(hw->phy.ops.read_i2c_eeprom))(hw, 130, & connector);
#line 1407
      (*(hw->phy.ops.read_i2c_eeprom))(hw, 146, & cable_length);
#line 1411
      (*(hw->phy.ops.read_i2c_eeprom))(hw, 147, & device_tech);
#line 1415
      if (((unsigned int )connector == 35U && (unsigned int )cable_length != 0U) && (unsigned int )((int )device_tech >> 4) == 0U) {
#line 1420
        active_cable = 1;
      } else {

      }
    } else {

    }
#line 1423
    if ((int )active_cable) {
#line 1424
      hw->phy.type = 20;
#line 1425
      if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1426
        hw->phy.sfp_type = 7;
      } else {
#line 1429
        hw->phy.sfp_type = 8;
      }
    } else {
#line 1433
      hw->phy.type = 23;
#line 1434
      return (-19);
    }
  }
#line 1438
  if ((unsigned int )hw->phy.sfp_type != (unsigned int )stored_sfp_type) {
#line 1439
    hw->phy.sfp_setup_needed = 1;
  } else {

  }
#line 1442
  hw->phy.multispeed_fiber = 0;
#line 1443
  if (((int )comp_codes_1g & 1 && ((int )comp_codes_10g & 16) != 0) || (((int )comp_codes_1g & 2) != 0 && ((int )comp_codes_10g & 32) != 0)) {
#line 1447
    hw->phy.multispeed_fiber = 1;
  } else {

  }
#line 1450
  if (((int )comp_codes_10g & 48) != 0) {
#line 1452
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 165, (u8 *)(& oui_bytes));
#line 1456
    if (status != 0) {
#line 1457
      goto err_read_i2c_eeprom;
    } else {

    }
#line 1459
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 166, (u8 *)(& oui_bytes) + 1UL);
#line 1463
    if (status != 0) {
#line 1464
      goto err_read_i2c_eeprom;
    } else {

    }
#line 1466
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 167, (u8 *)(& oui_bytes) + 2UL);
#line 1470
    if (status != 0) {
#line 1471
      goto err_read_i2c_eeprom;
    } else {

    }
#line 1473
    vendor_oui = (u32 )((((int )oui_bytes[0] << 24) | ((int )oui_bytes[1] << 16)) | ((int )oui_bytes[2] << 8));
#line 1478
    if (vendor_oui == 1777920U) {
#line 1479
      hw->phy.type = 21;
    } else {
#line 1481
      hw->phy.type = 22;
    }
#line 1483
    (*(hw->mac.ops.get_device_caps))(hw, & enforce_sfp);
#line 1484
    if (((int )enforce_sfp & 1) == 0) {
#line 1486
      if ((unsigned int )hw->phy.type == 21U) {
#line 1487
        return (0);
      } else {

      }
#line 1488
      if ((int )hw->allow_unsupported_sfp) {
#line 1489
        if ((int )adapter->msg_enable & 1) {
#line 1489
          netdev_warn((struct net_device  const  *)adapter->netdev, "WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics. Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter. Intel Corporation is not responsible for any harm caused by using untested modules.\n");
        } else {

        }
#line 1490
        return (0);
      } else {

      }
#line 1492
      descriptor.modname = "ixgbe";
#line 1492
      descriptor.function = "ixgbe_identify_qsfp_module_generic";
#line 1492
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1492
      descriptor.format = "QSFP module not supported\n";
#line 1492
      descriptor.lineno = 1492U;
#line 1492
      descriptor.flags = 0U;
#line 1492
      tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1492
      if (tmp___0 != 0L) {
#line 1492
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "QSFP module not supported\n");
      } else {

      }
#line 1493
      hw->phy.type = 23;
#line 1494
      return (-19);
    } else {

    }
#line 1496
    return (0);
  } else {

  }
#line 1498
  return (0);
  err_read_i2c_eeprom: 
#line 1501
  hw->phy.sfp_type = 65534;
#line 1502
  hw->phy.id = 0U;
#line 1503
  hw->phy.type = 0;
#line 1505
  return (-20);
}
}
#line 1517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw , u16 *list_offset , u16 *data_offset ) 
{ 
  u16 sfp_id ;
  u16 sfp_type ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  struct _ddebug descriptor ;
  long tmp___2 ;
  s32 tmp___3 ;
  struct _ddebug descriptor___0 ;
  long tmp___4 ;

  {
#line 1522
  sfp_type = (u16 )hw->phy.sfp_type;
#line 1524
  if ((unsigned int )hw->phy.sfp_type == 65535U) {
#line 1525
    return (-19);
  } else {

  }
#line 1527
  if ((unsigned int )hw->phy.sfp_type == 65534U) {
#line 1528
    return (-20);
  } else {

  }
#line 1530
  if ((unsigned int )hw->device_id == 4321U && (unsigned int )hw->phy.sfp_type == 0U) {
#line 1532
    return (-19);
  } else {

  }
#line 1538
  if ((((unsigned int )sfp_type == 7U || (unsigned int )sfp_type == 13U) || (unsigned int )sfp_type == 9U) || (unsigned int )sfp_type == 11U) {
#line 1542
    sfp_type = 5U;
  } else
#line 1543
  if ((((unsigned int )sfp_type == 8U || (unsigned int )sfp_type == 14U) || (unsigned int )sfp_type == 10U) || (unsigned int )sfp_type == 12U) {
#line 1547
    sfp_type = 6U;
  } else {

  }
#line 1550
  tmp = (*(hw->eeprom.ops.read))(hw, 43, list_offset);
#line 1550
  if (tmp != 0) {
#line 1551
    netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
               "eeprom read at %d failed\n", 43);
#line 1553
    return (-21);
  } else {

  }
#line 1556
  if ((unsigned int )*list_offset == 0U || (unsigned int )*list_offset == 65535U) {
#line 1557
    return (-21);
  } else {

  }
#line 1560
  *list_offset = (u16 )((int )*list_offset + 1);
#line 1566
  tmp___0 = (*(hw->eeprom.ops.read))(hw, (int )*list_offset, & sfp_id);
#line 1566
  if (tmp___0 != 0) {
#line 1567
    goto err_phy;
  } else {

  }
#line 1569
  goto ldv_54727;
  ldv_54726: ;
#line 1570
  if ((int )sfp_id == (int )sfp_type) {
#line 1571
    *list_offset = (u16 )((int )*list_offset + 1);
#line 1572
    tmp___1 = (*(hw->eeprom.ops.read))(hw, (int )*list_offset, data_offset);
#line 1572
    if (tmp___1 != 0) {
#line 1573
      goto err_phy;
    } else {

    }
#line 1574
    if ((unsigned int )*data_offset == 0U || (unsigned int )*data_offset == 65535U) {
#line 1575
      descriptor.modname = "ixgbe";
#line 1575
      descriptor.function = "ixgbe_get_sfp_init_sequence_offsets";
#line 1575
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1575
      descriptor.format = "SFP+ module not supported\n";
#line 1575
      descriptor.lineno = 1575U;
#line 1575
      descriptor.flags = 0U;
#line 1575
      tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1575
      if (tmp___2 != 0L) {
#line 1575
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "SFP+ module not supported\n");
      } else {

      }
#line 1576
      return (-19);
    } else {
#line 1578
      goto ldv_54725;
    }
  } else {
#line 1581
    *list_offset = (unsigned int )*list_offset + 2U;
#line 1582
    tmp___3 = (*(hw->eeprom.ops.read))(hw, (int )*list_offset, & sfp_id);
#line 1582
    if (tmp___3 != 0) {
#line 1583
      goto err_phy;
    } else {

    }
  }
  ldv_54727: ;
#line 1569
  if ((unsigned int )sfp_id != 65535U) {
#line 1571
    goto ldv_54726;
  } else {

  }
  ldv_54725: ;
#line 1587
  if ((unsigned int )sfp_id == 65535U) {
#line 1588
    descriptor___0.modname = "ixgbe";
#line 1588
    descriptor___0.function = "ixgbe_get_sfp_init_sequence_offsets";
#line 1588
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1588
    descriptor___0.format = "No matching SFP+ module found\n";
#line 1588
    descriptor___0.lineno = 1588U;
#line 1588
    descriptor___0.flags = 0U;
#line 1588
    tmp___4 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 1588
    if (tmp___4 != 0L) {
#line 1588
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "No matching SFP+ module found\n");
    } else {

    }
#line 1589
    return (-19);
  } else {

  }
#line 1592
  return (0);
  err_phy: 
#line 1595
  netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
             "eeprom read at offset %d failed\n", (int )*list_offset);
#line 1596
  return (-3);
}
}
#line 1607 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_i2c_eeprom_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 *eeprom_data ) 
{ 
  s32 tmp ;

  {
#line 1610
  tmp = (*(hw->phy.ops.read_i2c_byte))(hw, (int )byte_offset, 160, eeprom_data);
#line 1610
  return (tmp);
}
}
#line 1623 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_i2c_sff8472_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 *sff8472_data ) 
{ 
  s32 tmp ;

  {
#line 1626
  tmp = (*(hw->phy.ops.read_i2c_byte))(hw, (int )byte_offset, 162, sff8472_data);
#line 1626
  return (tmp);
}
}
#line 1639 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_i2c_eeprom_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 eeprom_data ) 
{ 
  s32 tmp ;

  {
#line 1642
  tmp = (*(hw->phy.ops.write_i2c_byte))(hw, (int )byte_offset, 160, (int )eeprom_data);
#line 1642
  return (tmp);
}
}
#line 1656 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_i2c_byte_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                u8 *data ) 
{ 
  s32 status ;
  u32 max_retry ;
  u32 retry ;
  u32 swfw_mask ;
  bool nack ;
  s32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;

  {
#line 1660
  max_retry = 10U;
#line 1661
  retry = 0U;
#line 1662
  swfw_mask = hw->phy.phy_semaphore_mask;
#line 1663
  nack = 1;
#line 1664
  *data = 0U;
  ldv_54760: 
#line 1667
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, swfw_mask);
#line 1667
  if (tmp != 0) {
#line 1668
    return (-16);
  } else {

  }
#line 1670
  ixgbe_i2c_start(hw);
#line 1673
  status = ixgbe_clock_out_i2c_byte(hw, (int )dev_addr);
#line 1674
  if (status != 0) {
#line 1675
    goto fail;
  } else {

  }
#line 1677
  status = ixgbe_get_i2c_ack(hw);
#line 1678
  if (status != 0) {
#line 1679
    goto fail;
  } else {

  }
#line 1681
  status = ixgbe_clock_out_i2c_byte(hw, (int )byte_offset);
#line 1682
  if (status != 0) {
#line 1683
    goto fail;
  } else {

  }
#line 1685
  status = ixgbe_get_i2c_ack(hw);
#line 1686
  if (status != 0) {
#line 1687
    goto fail;
  } else {

  }
#line 1689
  ixgbe_i2c_start(hw);
#line 1692
  status = ixgbe_clock_out_i2c_byte(hw, (int )((unsigned int )dev_addr | 1U));
#line 1693
  if (status != 0) {
#line 1694
    goto fail;
  } else {

  }
#line 1696
  status = ixgbe_get_i2c_ack(hw);
#line 1697
  if (status != 0) {
#line 1698
    goto fail;
  } else {

  }
#line 1700
  status = ixgbe_clock_in_i2c_byte(hw, data);
#line 1701
  if (status != 0) {
#line 1702
    goto fail;
  } else {

  }
#line 1704
  status = ixgbe_clock_out_i2c_bit(hw, (int )nack);
#line 1705
  if (status != 0) {
#line 1706
    goto fail;
  } else {

  }
#line 1708
  ixgbe_i2c_stop(hw);
#line 1709
  goto ldv_54756;
  fail: 
#line 1712
  ixgbe_i2c_bus_clear(hw);
#line 1713
  (*(hw->mac.ops.release_swfw_sync))(hw, swfw_mask);
#line 1714
  msleep(100U);
#line 1715
  retry = retry + 1U;
#line 1716
  if (retry < max_retry) {
#line 1717
    descriptor.modname = "ixgbe";
#line 1717
    descriptor.function = "ixgbe_read_i2c_byte_generic";
#line 1717
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1717
    descriptor.format = "I2C byte read error - Retrying.\n";
#line 1717
    descriptor.lineno = 1717U;
#line 1717
    descriptor.flags = 0U;
#line 1717
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1717
    if (tmp___0 != 0L) {
#line 1717
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C byte read error - Retrying.\n");
    } else {

    }
  } else {
#line 1719
    descriptor___0.modname = "ixgbe";
#line 1719
    descriptor___0.function = "ixgbe_read_i2c_byte_generic";
#line 1719
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1719
    descriptor___0.format = "I2C byte read error.\n";
#line 1719
    descriptor___0.lineno = 1719U;
#line 1719
    descriptor___0.flags = 0U;
#line 1719
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 1719
    if (tmp___1 != 0L) {
#line 1719
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C byte read error.\n");
    } else {

    }
  }
#line 1721
  if (retry < max_retry) {
#line 1723
    goto ldv_54760;
  } else {

  }
  ldv_54756: 
#line 1723
  (*(hw->mac.ops.release_swfw_sync))(hw, swfw_mask);
#line 1725
  return (status);
}
}
#line 1737 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_i2c_byte_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                 u8 data ) 
{ 
  s32 status ;
  u32 max_retry ;
  u32 retry ;
  u32 swfw_mask ;
  s32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;

  {
#line 1741
  max_retry = 1U;
#line 1742
  retry = 0U;
#line 1743
  swfw_mask = hw->phy.phy_semaphore_mask;
#line 1745
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, swfw_mask);
#line 1745
  if (tmp != 0) {
#line 1746
    return (-16);
  } else {

  }
  ldv_54776: 
#line 1749
  ixgbe_i2c_start(hw);
#line 1751
  status = ixgbe_clock_out_i2c_byte(hw, (int )dev_addr);
#line 1752
  if (status != 0) {
#line 1753
    goto fail;
  } else {

  }
#line 1755
  status = ixgbe_get_i2c_ack(hw);
#line 1756
  if (status != 0) {
#line 1757
    goto fail;
  } else {

  }
#line 1759
  status = ixgbe_clock_out_i2c_byte(hw, (int )byte_offset);
#line 1760
  if (status != 0) {
#line 1761
    goto fail;
  } else {

  }
#line 1763
  status = ixgbe_get_i2c_ack(hw);
#line 1764
  if (status != 0) {
#line 1765
    goto fail;
  } else {

  }
#line 1767
  status = ixgbe_clock_out_i2c_byte(hw, (int )data);
#line 1768
  if (status != 0) {
#line 1769
    goto fail;
  } else {

  }
#line 1771
  status = ixgbe_get_i2c_ack(hw);
#line 1772
  if (status != 0) {
#line 1773
    goto fail;
  } else {

  }
#line 1775
  ixgbe_i2c_stop(hw);
#line 1776
  goto ldv_54772;
  fail: 
#line 1779
  ixgbe_i2c_bus_clear(hw);
#line 1780
  retry = retry + 1U;
#line 1781
  if (retry < max_retry) {
#line 1782
    descriptor.modname = "ixgbe";
#line 1782
    descriptor.function = "ixgbe_write_i2c_byte_generic";
#line 1782
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1782
    descriptor.format = "I2C byte write error - Retrying.\n";
#line 1782
    descriptor.lineno = 1782U;
#line 1782
    descriptor.flags = 0U;
#line 1782
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1782
    if (tmp___0 != 0L) {
#line 1782
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C byte write error - Retrying.\n");
    } else {

    }
  } else {
#line 1784
    descriptor___0.modname = "ixgbe";
#line 1784
    descriptor___0.function = "ixgbe_write_i2c_byte_generic";
#line 1784
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1784
    descriptor___0.format = "I2C byte write error.\n";
#line 1784
    descriptor___0.lineno = 1784U;
#line 1784
    descriptor___0.flags = 0U;
#line 1784
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 1784
    if (tmp___1 != 0L) {
#line 1784
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C byte write error.\n");
    } else {

    }
  }
#line 1785
  if (retry < max_retry) {
#line 1787
    goto ldv_54776;
  } else {

  }
  ldv_54772: 
#line 1787
  (*(hw->mac.ops.release_swfw_sync))(hw, swfw_mask);
#line 1789
  return (status);
}
}
#line 1798 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_i2c_start(struct ixgbe_hw *hw ) 
{ 
  u32 i2cctl ;
  u32 tmp ;

  {
#line 1800
  tmp = ixgbe_read_reg(hw, *(hw->mvals + 23UL));
#line 1800
  i2cctl = tmp;
#line 1803
  ixgbe_set_i2c_data(hw, & i2cctl, 1);
#line 1804
  ixgbe_raise_i2c_clk(hw, & i2cctl);
#line 1807
  __const_udelay(21475UL);
#line 1809
  ixgbe_set_i2c_data(hw, & i2cctl, 0);
#line 1812
  __const_udelay(17180UL);
#line 1814
  ixgbe_lower_i2c_clk(hw, & i2cctl);
#line 1817
  __const_udelay(21475UL);
#line 1819
  return;
}
}
#line 1827 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_i2c_stop(struct ixgbe_hw *hw ) 
{ 
  u32 i2cctl ;
  u32 tmp ;

  {
#line 1829
  tmp = ixgbe_read_reg(hw, *(hw->mvals + 23UL));
#line 1829
  i2cctl = tmp;
#line 1832
  ixgbe_set_i2c_data(hw, & i2cctl, 0);
#line 1833
  ixgbe_raise_i2c_clk(hw, & i2cctl);
#line 1836
  __const_udelay(17180UL);
#line 1838
  ixgbe_set_i2c_data(hw, & i2cctl, 1);
#line 1841
  __const_udelay(21475UL);
#line 1843
  return;
}
}
#line 1851 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw , u8 *data ) 
{ 
  s32 i ;
  bool bit ;

  {
#line 1854
  bit = 0;
#line 1856
  i = 7;
#line 1856
  goto ldv_54792;
  ldv_54791: 
#line 1857
  ixgbe_clock_in_i2c_bit(hw, & bit);
#line 1858
  *data = (u8 )((int )((signed char )*data) | (int )((signed char )((int )bit << i)));
#line 1856
  i = i - 1;
  ldv_54792: ;
#line 1856
  if (i >= 0) {
#line 1858
    goto ldv_54791;
  } else {

  }

#line 1861
  return (0);
}
}
#line 1871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw , u8 data ) 
{ 
  s32 status ;
  s32 i ;
  u32 i2cctl ;
  bool bit ;

  {
#line 1876
  bit = 0;
#line 1878
  i = 7;
#line 1878
  goto ldv_54804;
  ldv_54803: 
#line 1879
  bit = (((int )data >> i) & 1) != 0;
#line 1880
  status = ixgbe_clock_out_i2c_bit(hw, (int )bit);
#line 1882
  if (status != 0) {
#line 1883
    goto ldv_54802;
  } else {

  }
#line 1878
  i = i - 1;
  ldv_54804: ;
#line 1878
  if (i >= 0) {
#line 1880
    goto ldv_54803;
  } else {

  }
  ldv_54802: 
#line 1887
  i2cctl = ixgbe_read_reg(hw, *(hw->mvals + 23UL));
#line 1888
  i2cctl = (u32 )*(hw->mvals + 19UL) | i2cctl;
#line 1889
  ixgbe_write_reg(hw, *(hw->mvals + 23UL), i2cctl);
#line 1890
  ixgbe_read_reg(hw, 8U);
#line 1892
  return (status);
}
}
#line 1901 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u32 i ;
  u32 i2cctl ;
  u32 tmp ;
  u32 timeout ;
  bool ack ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
#line 1903
  status = 0;
#line 1904
  i = 0U;
#line 1905
  tmp = ixgbe_read_reg(hw, *(hw->mvals + 23UL));
#line 1905
  i2cctl = tmp;
#line 1906
  timeout = 10U;
#line 1907
  ack = 1;
#line 1909
  ixgbe_raise_i2c_clk(hw, & i2cctl);
#line 1913
  __const_udelay(17180UL);
#line 1917
  i = 0U;
#line 1917
  goto ldv_54815;
  ldv_54814: 
#line 1918
  i2cctl = ixgbe_read_reg(hw, *(hw->mvals + 23UL));
#line 1919
  ack = ixgbe_get_i2c_data(hw, & i2cctl);
#line 1921
  __const_udelay(4295UL);
#line 1922
  if (! ack) {
#line 1923
    goto ldv_54813;
  } else {

  }
#line 1917
  i = i + 1U;
  ldv_54815: ;
#line 1917
  if (i < timeout) {
#line 1919
    goto ldv_54814;
  } else {

  }
  ldv_54813: ;
#line 1926
  if ((int )ack) {
#line 1927
    descriptor.modname = "ixgbe";
#line 1927
    descriptor.function = "ixgbe_get_i2c_ack";
#line 1927
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1927
    descriptor.format = "I2C ack was not received.\n";
#line 1927
    descriptor.lineno = 1927U;
#line 1927
    descriptor.flags = 0U;
#line 1927
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1927
    if (tmp___0 != 0L) {
#line 1927
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C ack was not received.\n");
    } else {

    }
#line 1928
    status = -18;
  } else {

  }
#line 1931
  ixgbe_lower_i2c_clk(hw, & i2cctl);
#line 1934
  __const_udelay(21475UL);
#line 1936
  return (status);
}
}
#line 1946 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw , bool *data ) 
{ 
  u32 i2cctl ;
  u32 tmp ;

  {
#line 1948
  tmp = ixgbe_read_reg(hw, *(hw->mvals + 23UL));
#line 1948
  i2cctl = tmp;
#line 1950
  ixgbe_raise_i2c_clk(hw, & i2cctl);
#line 1953
  __const_udelay(17180UL);
#line 1955
  i2cctl = ixgbe_read_reg(hw, *(hw->mvals + 23UL));
#line 1956
  *data = ixgbe_get_i2c_data(hw, & i2cctl);
#line 1958
  ixgbe_lower_i2c_clk(hw, & i2cctl);
#line 1961
  __const_udelay(21475UL);
#line 1963
  return (0);
}
}
#line 1973 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw , bool data ) 
{ 
  s32 status ;
  u32 i2cctl ;
  u32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
#line 1976
  tmp = ixgbe_read_reg(hw, *(hw->mvals + 23UL));
#line 1976
  i2cctl = tmp;
#line 1978
  status = ixgbe_set_i2c_data(hw, & i2cctl, (int )data);
#line 1979
  if (status == 0) {
#line 1980
    ixgbe_raise_i2c_clk(hw, & i2cctl);
#line 1983
    __const_udelay(17180UL);
#line 1985
    ixgbe_lower_i2c_clk(hw, & i2cctl);
#line 1990
    __const_udelay(21475UL);
  } else {
#line 1992
    descriptor.modname = "ixgbe";
#line 1992
    descriptor.function = "ixgbe_clock_out_i2c_bit";
#line 1992
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1992
    descriptor.format = "I2C data was not set to %X\n";
#line 1992
    descriptor.lineno = 1992U;
#line 1992
    descriptor.flags = 0U;
#line 1992
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1992
    if (tmp___0 != 0L) {
#line 1992
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C data was not set to %X\n", (int )data);
    } else {

    }
#line 1993
    return (-18);
  }
#line 1996
  return (0);
}
}
#line 2005 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw , u32 *i2cctl ) 
{ 
  u32 i ;
  u32 timeout ;
  u32 i2cctl_r ;

  {
#line 2007
  i = 0U;
#line 2008
  timeout = 500U;
#line 2009
  i2cctl_r = 0U;
#line 2011
  i = 0U;
#line 2011
  goto ldv_54840;
  ldv_54839: 
#line 2012
  *i2cctl = *i2cctl | (u32 )*(hw->mvals + 17UL);
#line 2013
  ixgbe_write_reg(hw, *(hw->mvals + 23UL), *i2cctl);
#line 2014
  ixgbe_read_reg(hw, 8U);
#line 2016
  __const_udelay(4295UL);
#line 2018
  i2cctl_r = ixgbe_read_reg(hw, *(hw->mvals + 23UL));
#line 2019
  if (((u32 )*(hw->mvals + 16UL) & i2cctl_r) != 0U) {
#line 2020
    goto ldv_54838;
  } else {

  }
#line 2011
  i = i + 1U;
  ldv_54840: ;
#line 2011
  if (i < timeout) {
#line 2013
    goto ldv_54839;
  } else {

  }
  ldv_54838: ;
#line 2018
  return;
}
}
#line 2031 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw , u32 *i2cctl ) 
{ 


  {
#line 2034
  *i2cctl = *i2cctl & (u32 )(~ *(hw->mvals + 17UL));
#line 2036
  ixgbe_write_reg(hw, *(hw->mvals + 23UL), *i2cctl);
#line 2037
  ixgbe_read_reg(hw, 8U);
#line 2040
  __const_udelay(4295UL);
#line 2042
  return;
}
}
#line 2051 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw , u32 *i2cctl , bool data ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;

  {
#line 2053
  if ((int )data) {
#line 2054
    *i2cctl = *i2cctl | (u32 )*(hw->mvals + 19UL);
  } else {
#line 2056
    *i2cctl = *i2cctl & (u32 )(~ *(hw->mvals + 19UL));
  }
#line 2058
  ixgbe_write_reg(hw, *(hw->mvals + 23UL), *i2cctl);
#line 2059
  ixgbe_read_reg(hw, 8U);
#line 2062
  __const_udelay(12885UL);
#line 2065
  *i2cctl = ixgbe_read_reg(hw, *(hw->mvals + 23UL));
#line 2066
  tmp___0 = ixgbe_get_i2c_data(hw, i2cctl);
#line 2066
  if ((int )tmp___0 != (int )data) {
#line 2067
    descriptor.modname = "ixgbe";
#line 2067
    descriptor.function = "ixgbe_set_i2c_data";
#line 2067
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 2067
    descriptor.format = "Error - I2C data was not set to %X.\n";
#line 2067
    descriptor.lineno = 2067U;
#line 2067
    descriptor.flags = 0U;
#line 2067
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2067
    if (tmp != 0L) {
#line 2067
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Error - I2C data was not set to %X.\n", (int )data);
    } else {

    }
#line 2068
    return (-18);
  } else {

  }
#line 2071
  return (0);
}
}
#line 2081 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static bool ixgbe_get_i2c_data(struct ixgbe_hw *hw , u32 *i2cctl ) 
{ 


  {
#line 2083
  if ((*i2cctl & (u32 )*(hw->mvals + 18UL)) != 0U) {
#line 2084
    return (1);
  } else {

  }
#line 2085
  return (0);
}
}
#line 2095 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw ) 
{ 
  u32 i2cctl ;
  u32 tmp ;
  u32 i ;

  {
#line 2097
  tmp = ixgbe_read_reg(hw, *(hw->mvals + 23UL));
#line 2097
  i2cctl = tmp;
#line 2100
  ixgbe_i2c_start(hw);
#line 2102
  ixgbe_set_i2c_data(hw, & i2cctl, 1);
#line 2104
  i = 0U;
#line 2104
  goto ldv_54862;
  ldv_54861: 
#line 2105
  ixgbe_raise_i2c_clk(hw, & i2cctl);
#line 2108
  __const_udelay(17180UL);
#line 2110
  ixgbe_lower_i2c_clk(hw, & i2cctl);
#line 2113
  __const_udelay(21475UL);
#line 2104
  i = i + 1U;
  ldv_54862: ;
#line 2104
  if (i <= 8U) {
#line 2106
    goto ldv_54861;
  } else {

  }
#line 2116
  ixgbe_i2c_start(hw);
#line 2119
  ixgbe_i2c_stop(hw);
#line 2120
  return;
}
}
#line 2128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_tn_check_overtemp(struct ixgbe_hw *hw ) 
{ 
  u16 phy_data ;

  {
#line 2130
  phy_data = 0U;
#line 2132
  if ((unsigned int )hw->device_id != 5404U) {
#line 2133
    return (0);
  } else {

  }
#line 2136
  (*(hw->phy.ops.read_reg))(hw, 36869U, 1U, & phy_data);
#line 2139
  if (((int )phy_data & 8) == 0) {
#line 2140
    return (0);
  } else {

  }
#line 2142
  return (-26);
}
}
#line 2149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_set_copper_phy_power(struct ixgbe_hw *hw , bool on ) 
{ 
  u32 status ;
  u16 reg ;
  enum ixgbe_media_type tmp ;
  s32 tmp___0 ;
  bool tmp___1 ;
  s32 tmp___2 ;

  {
#line 2155
  tmp = (*(hw->mac.ops.get_media_type))(hw);
#line 2155
  if ((unsigned int )tmp != 4U) {
#line 2156
    return (0);
  } else {

  }
#line 2158
  tmp___0 = (*(hw->phy.ops.read_reg))(hw, 0U, 30U, & reg);
#line 2158
  status = (u32 )tmp___0;
#line 2161
  if (status != 0U) {
#line 2162
    return ((s32 )status);
  } else {

  }
#line 2164
  if ((int )on) {
#line 2165
    reg = (unsigned int )reg & 63487U;
  } else {
#line 2167
    tmp___1 = ixgbe_check_reset_blocked(hw);
#line 2167
    if ((int )tmp___1) {
#line 2168
      return (0);
    } else {

    }
#line 2169
    reg = (u16 )((unsigned int )reg | 2048U);
  }
#line 2172
  tmp___2 = (*(hw->phy.ops.write_reg))(hw, 0U, 30U, (int )reg);
#line 2172
  status = (u32 )tmp___2;
#line 2175
  return ((s32 )status);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.o.c.prepared"
bool ldv_queue_work_on_191(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 359
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 359
  ldv_func_res = tmp;
#line 361
  activate_work_9(ldv_func_arg3, 2);
#line 363
  return (ldv_func_res);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.o.c.prepared"
bool ldv_queue_delayed_work_on_192(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 370
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 370
  ldv_func_res = tmp;
#line 372
  activate_work_9(& ldv_func_arg3->work, 2);
#line 374
  return (ldv_func_res);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.o.c.prepared"
bool ldv_queue_work_on_193(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 381
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 381
  ldv_func_res = tmp;
#line 383
  activate_work_9(ldv_func_arg3, 2);
#line 385
  return (ldv_func_res);
}
}
#line 388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.o.c.prepared"
void ldv_flush_workqueue_194(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 391
  flush_workqueue(ldv_func_arg1);
#line 393
  call_and_disable_all_9(2);
#line 394
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.o.c.prepared"
bool ldv_queue_delayed_work_on_195(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 400
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 400
  ldv_func_res = tmp;
#line 402
  activate_work_9(& ldv_func_arg3->work, 2);
#line 404
  return (ldv_func_res);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.o.c.prepared"
void ldv_mutex_lock_196(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 410
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 412
  mutex_lock(ldv_func_arg1);
#line 413
  return;
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.o.c.prepared"
void ldv_mutex_unlock_197(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 418
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 420
  mutex_unlock(ldv_func_arg1);
#line 421
  return;
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.o.c.prepared"
void ldv_mutex_lock_198(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 426
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 428
  mutex_lock(ldv_func_arg1);
#line 429
  return;
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.o.c.prepared"
int ldv_mutex_trylock_199(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 435
  tmp = mutex_trylock(ldv_func_arg1);
#line 435
  ldv_func_res = tmp;
#line 437
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 437
  return (tmp___0);
#line 439
  return (ldv_func_res);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.o.c.prepared"
void ldv_mutex_unlock_200(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 445
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 447
  mutex_unlock(ldv_func_arg1);
#line 448
  return;
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.o.c.prepared"
void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 453
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 455
  mutex_unlock(ldv_func_arg1);
#line 456
  return;
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.o.c.prepared"
void ldv_mutex_lock_202(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 461
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 463
  mutex_lock(ldv_func_arg1);
#line 464
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 48 "include/linux/list.h"
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 61 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 63
  __list_add(new, head, head->next);
#line 64
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_227(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_225(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_228(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_229(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.o.c.prepared"
void ldv_mutex_lock_224(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_226(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_230(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_219(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_221(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_220(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_223(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_222(struct workqueue_struct *ldv_func_arg1 ) ;
#line 1669 "include/linux/pci.h"
extern int pci_enable_sriov(struct pci_dev * , int  ) ;
#line 1670
extern void pci_disable_sriov(struct pci_dev * ) ;
#line 1671
extern int pci_num_vf(struct pci_dev * ) ;
#line 1672
extern int pci_vfs_assigned(struct pci_dev * ) ;
#line 115 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
s32 ixgbe_read_mbx(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 mbx_id ) ;
#line 116
s32 ixgbe_write_mbx(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 mbx_id ) ;
#line 117
s32 ixgbe_check_for_msg(struct ixgbe_hw *hw , u16 mbx_id ) ;
#line 118
s32 ixgbe_check_for_ack(struct ixgbe_hw *hw , u16 mbx_id ) ;
#line 119
s32 ixgbe_check_for_rst(struct ixgbe_hw *hw , u16 mbx_id ) ;
#line 61 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h"
__inline static void ixgbe_set_vmvir(struct ixgbe_adapter *adapter , u16 vid , u16 qos ,
                                     u32 vf ) 
{ 
  struct ixgbe_hw *hw ;
  u32 vmvir ;

  {
#line 64
  hw = & adapter->hw;
#line 65
  vmvir = (u32 )(((int )vid | ((int )qos << 13)) | 1073741824);
#line 67
  ixgbe_write_reg(hw, (vf + 8192U) * 4U, vmvir);
#line 68
  return;
}
}
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int __ixgbe_enable_sriov(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int num_vf_macvlans ;
  int i ;
  struct vf_macvlans *mv_list ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 51
  hw = & adapter->hw;
#line 55
  adapter->flags = adapter->flags | 8388608U;
#line 56
  if (((int )adapter->msg_enable & 2) != 0) {
#line 56
    netdev_info((struct net_device  const  *)adapter->netdev, "SR-IOV enabled with %d VFs\n",
                adapter->num_vfs);
  } else {

  }
#line 59
  adapter->flags = adapter->flags | 16384U;
#line 60
  if ((unsigned int )adapter->ring_feature[1].limit == 0U) {
#line 61
    adapter->ring_feature[1].limit = 1U;
  } else {

  }
#line 62
  adapter->ring_feature[1].offset = (u16 )adapter->num_vfs;
#line 64
  num_vf_macvlans = (int )((hw->mac.num_rar_entries - adapter->num_vfs) - 16U);
#line 67
  tmp = kcalloc((size_t )num_vf_macvlans, 32UL, 208U);
#line 67
  mv_list = (struct vf_macvlans *)tmp;
#line 67
  adapter->mv_list = mv_list;
#line 70
  if ((unsigned long )mv_list != (unsigned long )((struct vf_macvlans *)0)) {
#line 72
    INIT_LIST_HEAD(& adapter->vf_mvs.l);
#line 73
    i = 0;
#line 73
    goto ldv_55521;
    ldv_55520: 
#line 74
    mv_list->vf = -1;
#line 75
    mv_list->free = 1;
#line 76
    list_add(& mv_list->l, & adapter->vf_mvs.l);
#line 77
    mv_list = mv_list + 1;
#line 73
    i = i + 1;
    ldv_55521: ;
#line 73
    if (i < num_vf_macvlans) {
#line 75
      goto ldv_55520;
    } else {

    }

  } else {

  }
#line 82
  ixgbe_write_reg(hw, 33312U, 1U);
#line 83
  adapter->bridge_mode = 0U;
#line 88
  tmp___0 = kcalloc((size_t )adapter->num_vfs, 88UL, 208U);
#line 88
  adapter->vfinfo = (struct vf_data_storage *)tmp___0;
#line 91
  if ((unsigned long )adapter->vfinfo != (unsigned long )((struct vf_data_storage *)0)) {
#line 93
    if ((unsigned int )adapter->hw.mac.type == 2U && adapter->num_vfs <= 15U) {
#line 95
      adapter->dcb_cfg.num_tcs.pg_tcs = 8U;
#line 96
      adapter->dcb_cfg.num_tcs.pfc_tcs = 8U;
    } else
#line 97
    if (adapter->num_vfs <= 31U) {
#line 98
      adapter->dcb_cfg.num_tcs.pg_tcs = 4U;
#line 99
      adapter->dcb_cfg.num_tcs.pfc_tcs = 4U;
    } else {
#line 101
      adapter->dcb_cfg.num_tcs.pg_tcs = 1U;
#line 102
      adapter->dcb_cfg.num_tcs.pfc_tcs = 1U;
    }
#line 106
    adapter->flags2 = adapter->flags2 & 4294967292U;
#line 109
    i = 0;
#line 109
    goto ldv_55524;
    ldv_55523: 
#line 111
    (adapter->vfinfo + (unsigned long )i)->spoofchk_enabled = 1U;
#line 118
    (adapter->vfinfo + (unsigned long )i)->rss_query_enabled = 0;
#line 109
    i = i + 1;
    ldv_55524: ;
#line 109
    if ((unsigned int )i < adapter->num_vfs) {
#line 111
      goto ldv_55523;
    } else {

    }

#line 121
    return (0);
  } else {

  }
#line 124
  return (-12);
}
}
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_enable_sriov(struct ixgbe_adapter *adapter ) 
{ 
  int pre_existing_vfs ;
  int err ;
  unsigned int __min1 ;
  unsigned int __min2 ;
  int tmp ;

  {
#line 132
  pre_existing_vfs = 0;
#line 134
  pre_existing_vfs = pci_num_vf(adapter->pdev);
#line 135
  if (pre_existing_vfs == 0 && adapter->num_vfs == 0U) {
#line 136
    return;
  } else {

  }
#line 144
  if (pre_existing_vfs != 0) {
#line 145
    adapter->num_vfs = (unsigned int )pre_existing_vfs;
#line 146
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Virtual Functions already enabled for this device - Please reload all VF drivers to avoid spoofed packet errors\n");
  } else {
#line 157
    __min1 = adapter->num_vfs;
#line 157
    __min2 = 63U;
#line 157
    adapter->num_vfs = __min1 < __min2 ? __min1 : __min2;
#line 159
    err = pci_enable_sriov(adapter->pdev, (int )adapter->num_vfs);
#line 160
    if (err != 0) {
#line 161
      if (((int )adapter->msg_enable & 2) != 0) {
#line 161
        netdev_err((struct net_device  const  *)adapter->netdev, "Failed to enable PCI sriov: %d\n",
                   err);
      } else {

      }
#line 162
      adapter->num_vfs = 0U;
#line 163
      return;
    } else {

    }
  }
#line 167
  tmp = __ixgbe_enable_sriov(adapter);
#line 167
  if (tmp == 0) {
#line 168
    return;
  } else {

  }
#line 173
  if (((int )adapter->msg_enable & 2) != 0) {
#line 174
    netdev_err((struct net_device  const  *)adapter->netdev, "Unable to allocate memory for VF Data Storage - SRIOV disabled\n");
  } else {

  }
#line 175
  ixgbe_disable_sriov(adapter);
#line 176
  return;
}
}
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_disable_sriov(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 gpie ;
  u32 vmdctl ;
  int rss ;
  int tmp ;
  int __min1 ;
  u8 tmp___0 ;
  int __min2 ;
  unsigned int tmp___1 ;
  int __min1___0 ;
  int __min2___0 ;
  unsigned int tmp___2 ;

  {
#line 181
  hw = & adapter->hw;
#line 187
  adapter->num_vfs = 0U;
#line 190
  kfree((void const   *)adapter->vfinfo);
#line 191
  adapter->vfinfo = (struct vf_data_storage *)0;
#line 194
  kfree((void const   *)adapter->mv_list);
#line 195
  adapter->mv_list = (struct vf_macvlans *)0;
#line 198
  if ((adapter->flags & 8388608U) == 0U) {
#line 199
    return (0);
  } else {

  }
#line 207
  tmp = pci_vfs_assigned(adapter->pdev);
#line 207
  if (tmp != 0) {
#line 208
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Unloading driver while VFs are assigned - VFs will not be deallocated\n");
#line 209
    return (-1);
  } else {

  }
#line 212
  pci_disable_sriov(adapter->pdev);
#line 216
  ixgbe_write_reg(hw, 69712U, 0U);
#line 217
  gpie = ixgbe_read_reg(hw, 2200U);
#line 218
  gpie = gpie & 4294918143U;
#line 219
  ixgbe_write_reg(hw, 2200U, gpie);
#line 222
  vmdctl = ixgbe_read_reg(hw, 20912U);
#line 223
  vmdctl = vmdctl & 4294959231U;
#line 224
  ixgbe_write_reg(hw, 20912U, vmdctl);
#line 225
  ixgbe_read_reg(hw, 8U);
#line 228
  if ((unsigned int )adapter->ring_feature[1].limit == 1U) {
#line 229
    adapter->flags = adapter->flags & 4294950911U;
#line 230
    adapter->flags = adapter->flags & 4286578687U;
#line 231
    tmp___0 = ixgbe_max_rss_indices(adapter);
#line 231
    __min1 = (int )tmp___0;
#line 231
    tmp___1 = cpumask_weight(cpu_online_mask);
#line 231
    __min2 = (int )tmp___1;
#line 231
    rss = __min1 < __min2 ? __min1 : __min2;
  } else {
#line 234
    __min1___0 = 4;
#line 234
    tmp___2 = cpumask_weight(cpu_online_mask);
#line 234
    __min2___0 = (int )tmp___2;
#line 234
    rss = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
  }
#line 237
  adapter->ring_feature[1].offset = 0U;
#line 238
  adapter->ring_feature[2].limit = (u16 )rss;
#line 241
  msleep(100U);
#line 242
  return (0);
}
}
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_pci_sriov_enable(struct pci_dev *dev , int num_vfs ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int err ;
  int i ;
  int pre_existing_vfs ;
  int tmp___0 ;

  {
#line 248
  tmp = pci_get_drvdata(dev);
#line 248
  adapter = (struct ixgbe_adapter *)tmp;
#line 249
  err = 0;
#line 251
  tmp___0 = pci_num_vf(dev);
#line 251
  pre_existing_vfs = tmp___0;
#line 253
  if (pre_existing_vfs != 0 && pre_existing_vfs != num_vfs) {
#line 254
    err = ixgbe_disable_sriov(adapter);
  } else
#line 255
  if (pre_existing_vfs != 0 && pre_existing_vfs == num_vfs) {
#line 256
    return (num_vfs);
  } else {

  }
#line 258
  if (err != 0) {
#line 259
    return (err);
  } else {

  }
#line 269
  if (adapter->num_rx_pools + num_vfs > 64) {
#line 270
    return (-1);
  } else {

  }
#line 272
  adapter->num_vfs = (unsigned int )num_vfs;
#line 274
  err = __ixgbe_enable_sriov(adapter);
#line 275
  if (err != 0) {
#line 276
    return (err);
  } else {

  }
#line 278
  i = 0;
#line 278
  goto ldv_55556;
  ldv_55555: 
#line 279
  ixgbe_vf_configuration(dev, (unsigned int )(i | 268435456));
#line 278
  i = i + 1;
  ldv_55556: ;
#line 278
  if ((unsigned int )i < adapter->num_vfs) {
#line 280
    goto ldv_55555;
  } else {

  }
#line 281
  err = pci_enable_sriov(dev, num_vfs);
#line 282
  if (err != 0) {
#line 283
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Failed to enable PCI sriov: %d\n",
             err);
#line 284
    return (err);
  } else {

  }
#line 286
  ixgbe_sriov_reinit(adapter);
#line 288
  return (num_vfs);
}
}
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_pci_sriov_disable(struct pci_dev *dev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int err ;
  u32 current_flags ;

  {
#line 296
  tmp = pci_get_drvdata(dev);
#line 296
  adapter = (struct ixgbe_adapter *)tmp;
#line 299
  current_flags = adapter->flags;
#line 302
  err = ixgbe_disable_sriov(adapter);
#line 306
  if (err == 0 && adapter->flags != current_flags) {
#line 307
    ixgbe_sriov_reinit(adapter);
  } else {

  }
#line 310
  return (err);
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_pci_sriov_configure(struct pci_dev *dev , int num_vfs ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 315
  if (num_vfs == 0) {
#line 316
    tmp = ixgbe_pci_sriov_disable(dev);
#line 316
    return (tmp);
  } else {
#line 318
    tmp___0 = ixgbe_pci_sriov_enable(dev, num_vfs);
#line 318
    return (tmp___0);
  }
}
}
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_multicasts(struct ixgbe_adapter *adapter , u32 *msgbuf , u32 vf ) 
{ 
  int entries ;
  u16 *hash_list ;
  struct vf_data_storage *vfinfo ;
  struct ixgbe_hw *hw ;
  int i ;
  u32 vector_bit ;
  u32 vector_reg ;
  u32 mta_reg ;
  u32 vmolr ;
  u32 tmp ;
  int _min1 ;
  int _min2 ;

  {
#line 324
  entries = (int )((*msgbuf & 16711680U) >> 16);
#line 326
  hash_list = (u16 *)msgbuf + 1U;
#line 327
  vfinfo = adapter->vfinfo + (unsigned long )vf;
#line 328
  hw = & adapter->hw;
#line 333
  tmp = ixgbe_read_reg(hw, (vf + 15360U) * 4U);
#line 333
  vmolr = tmp;
#line 336
  _min1 = entries;
#line 336
  _min2 = 30;
#line 336
  entries = _min1 < _min2 ? _min1 : _min2;
#line 343
  vfinfo->num_vf_mc_hashes = (u16 )entries;
#line 349
  i = 0;
#line 349
  goto ldv_55586;
  ldv_55585: 
#line 350
  vfinfo->vf_mc_hashes[i] = *(hash_list + (unsigned long )i);
#line 349
  i = i + 1;
  ldv_55586: ;
#line 349
  if (i < entries) {
#line 351
    goto ldv_55585;
  } else {

  }
#line 353
  i = 0;
#line 353
  goto ldv_55589;
  ldv_55588: 
#line 354
  vector_reg = (u32 )((int )vfinfo->vf_mc_hashes[i] >> 5) & 127U;
#line 355
  vector_bit = (u32 )vfinfo->vf_mc_hashes[i] & 31U;
#line 356
  mta_reg = ixgbe_read_reg(hw, (vector_reg + 5248U) * 4U);
#line 357
  mta_reg = (u32 )(1 << (int )vector_bit) | mta_reg;
#line 358
  ixgbe_write_reg(hw, (vector_reg + 5248U) * 4U, mta_reg);
#line 353
  i = i + 1;
  ldv_55589: ;
#line 353
  if ((int )vfinfo->num_vf_mc_hashes > i) {
#line 355
    goto ldv_55588;
  } else {

  }
#line 360
  vmolr = vmolr | 33554432U;
#line 361
  ixgbe_write_reg(hw, (vf + 15360U) * 4U, vmolr);
#line 363
  return (0);
}
}
#line 367 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_restore_vf_multicasts(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct vf_data_storage *vfinfo ;
  int i ;
  int j ;
  u32 vector_bit ;
  u32 vector_reg ;
  u32 mta_reg ;
  u32 vmolr ;
  u32 tmp ;

  {
#line 369
  hw = & adapter->hw;
#line 376
  i = 0;
#line 376
  goto ldv_55606;
  ldv_55605: 
#line 377
  tmp = ixgbe_read_reg(hw, (u32 )((i + 15360) * 4));
#line 377
  vmolr = tmp;
#line 378
  vfinfo = adapter->vfinfo + (unsigned long )i;
#line 379
  j = 0;
#line 379
  goto ldv_55603;
  ldv_55602: 
#line 380
  hw->addr_ctrl.mta_in_use = hw->addr_ctrl.mta_in_use + 1U;
#line 381
  vector_reg = (u32 )((int )vfinfo->vf_mc_hashes[j] >> 5) & 127U;
#line 382
  vector_bit = (u32 )vfinfo->vf_mc_hashes[j] & 31U;
#line 383
  mta_reg = ixgbe_read_reg(hw, (vector_reg + 5248U) * 4U);
#line 384
  mta_reg = (u32 )(1 << (int )vector_bit) | mta_reg;
#line 385
  ixgbe_write_reg(hw, (vector_reg + 5248U) * 4U, mta_reg);
#line 379
  j = j + 1;
  ldv_55603: ;
#line 379
  if ((int )vfinfo->num_vf_mc_hashes > j) {
#line 381
    goto ldv_55602;
  } else {

  }

#line 388
  if ((unsigned int )vfinfo->num_vf_mc_hashes != 0U) {
#line 389
    vmolr = vmolr | 33554432U;
  } else {
#line 391
    vmolr = vmolr & 4261412863U;
  }
#line 392
  ixgbe_write_reg(hw, (u32 )((i + 15360) * 4), vmolr);
#line 376
  i = i + 1;
  ldv_55606: ;
#line 376
  if ((unsigned int )i < adapter->num_vfs) {
#line 378
    goto ldv_55605;
  } else {

  }
#line 396
  ixgbe_full_sync_mac_table(adapter);
#line 397
  return;
}
}
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_vlan(struct ixgbe_adapter *adapter , int add , int vid , u32 vf ) 
{ 
  s32 tmp ;

  {
#line 404
  if (vid == 0 && add == 0) {
#line 405
    return (0);
  } else {

  }
#line 407
  tmp = (*(adapter->hw.mac.ops.set_vfta))(& adapter->hw, (u32 )vid, vf, add != 0);
#line 407
  return (tmp);
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static s32 ixgbe_set_vf_lpe(struct ixgbe_adapter *adapter , u32 *msgbuf , u32 vf ) 
{ 
  struct ixgbe_hw *hw ;
  int max_frame ;
  u32 max_frs ;
  struct net_device *dev ;
  int pf_max_frame ;
  u32 reg_offset ;
  u32 vf_shift ;
  u32 vfre ;
  s32 err ;

  {
#line 412
  hw = & adapter->hw;
#line 413
  max_frame = (int )*(msgbuf + 1UL);
#line 423
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 424
    dev = adapter->netdev;
#line 425
    pf_max_frame = (int )(dev->mtu + 14U);
#line 427
    err = 0;
#line 435
    switch ((adapter->vfinfo + (unsigned long )vf)->vf_api) {
    case 2U: ;
    case 3U: ;
#line 443
    if (pf_max_frame > 1514) {
#line 444
      goto ldv_55630;
    } else {

    }
    default: ;
#line 451
    if (pf_max_frame > 1514 || max_frame > 1518) {
#line 453
      err = -22;
    } else {

    }
#line 454
    goto ldv_55630;
    }
    ldv_55630: 
#line 458
    vf_shift = vf & 31U;
#line 459
    reg_offset = vf / 32U;
#line 462
    vfre = ixgbe_read_reg(hw, (reg_offset + 5240U) * 4U);
#line 463
    if (err != 0) {
#line 464
      vfre = (u32 )(~ (1 << (int )vf_shift)) & vfre;
    } else {
#line 466
      vfre = (u32 )(1 << (int )vf_shift) | vfre;
    }
#line 467
    ixgbe_write_reg(hw, (reg_offset + 5240U) * 4U, vfre);
#line 469
    if (err != 0) {
#line 470
      if ((int )adapter->msg_enable & 1) {
#line 470
        netdev_err((struct net_device  const  *)adapter->netdev, "VF max_frame %d out of range\n",
                   max_frame);
      } else {

      }
#line 471
      return (err);
    } else {

    }
  } else {

  }
#line 476
  if (max_frame > 9728) {
#line 477
    if ((int )adapter->msg_enable & 1) {
#line 477
      netdev_err((struct net_device  const  *)adapter->netdev, "VF max_frame %d out of range\n",
                 max_frame);
    } else {

    }
#line 478
    return (-22);
  } else {

  }
#line 482
  max_frs = ixgbe_read_reg(hw, 17000U);
#line 483
  max_frs = max_frs & 4294901760U;
#line 484
  max_frs = max_frs >> 16;
#line 486
  if ((u32 )max_frame > max_frs) {
#line 487
    max_frs = (u32 )(max_frame << 16);
#line 488
    ixgbe_write_reg(hw, 17000U, max_frs);
  } else {

  }
#line 491
  if (((int )adapter->msg_enable & 8192) != 0) {
#line 491
    netdev_info((struct net_device  const  *)adapter->netdev, "VF requests change max MTU to %d\n",
                max_frame);
  } else {

  }
#line 493
  return (0);
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_set_vmolr(struct ixgbe_hw *hw , u32 vf , bool aupe ) 
{ 
  u32 vmolr ;
  u32 tmp ;

  {
#line 498
  tmp = ixgbe_read_reg(hw, (vf + 15360U) * 4U);
#line 498
  vmolr = tmp;
#line 499
  vmolr = vmolr | 134217728U;
#line 500
  if ((int )aupe) {
#line 501
    vmolr = vmolr | 16777216U;
  } else {
#line 503
    vmolr = vmolr & 4278190079U;
  }
#line 504
  ixgbe_write_reg(hw, (vf + 15360U) * 4U, vmolr);
#line 505
  return;
}
}
#line 507 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_clear_vmvir(struct ixgbe_adapter *adapter , u32 vf ) 
{ 
  struct ixgbe_hw *hw ;

  {
#line 509
  hw = & adapter->hw;
#line 511
  ixgbe_write_reg(hw, (vf + 8192U) * 4U, 0U);
#line 512
  return;
}
}
#line 513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
__inline static void ixgbe_vf_reset_event(struct ixgbe_adapter *adapter , u32 vf ) 
{ 
  struct ixgbe_hw *hw ;
  struct vf_data_storage *vfinfo ;
  u8 num_tcs ;
  int tmp ;

  {
#line 515
  hw = & adapter->hw;
#line 516
  vfinfo = adapter->vfinfo + (unsigned long )vf;
#line 517
  tmp = netdev_get_num_tc(adapter->netdev);
#line 517
  num_tcs = (u8 )tmp;
#line 520
  ixgbe_set_vf_vlan(adapter, 1, (int )vfinfo->pf_vlan, vf);
#line 523
  ixgbe_set_vmolr(hw, vf, (unsigned int )vfinfo->pf_vlan == 0U);
#line 526
  if (((unsigned int )vfinfo->pf_vlan == 0U && (unsigned int )vfinfo->pf_qos == 0U) && (unsigned int )num_tcs == 0U) {
#line 527
    ixgbe_clear_vmvir(adapter, vf);
  } else {
#line 529
    if ((unsigned int )vfinfo->pf_qos != 0U || (unsigned int )num_tcs == 0U) {
#line 530
      ixgbe_set_vmvir(adapter, (int )vfinfo->pf_vlan, (int )vfinfo->pf_qos, vf);
    } else {
#line 533
      ixgbe_set_vmvir(adapter, (int )vfinfo->pf_vlan, (int )adapter->default_up, vf);
    }
#line 536
    if ((unsigned int )vfinfo->spoofchk_enabled != 0U) {
#line 537
      (*(hw->mac.ops.set_vlan_anti_spoofing))(hw, 1, (int )vf);
    } else {

    }
  }
#line 541
  (adapter->vfinfo + (unsigned long )vf)->num_vf_mc_hashes = 0U;
#line 544
  ixgbe_set_rx_mode(adapter->netdev);
#line 546
  ixgbe_del_mac_filter(adapter, (u8 *)(& (adapter->vfinfo + (unsigned long )vf)->vf_mac_addresses),
                       (int )((u16 )vf));
#line 549
  (adapter->vfinfo + (unsigned long )vf)->vf_api = 0U;
#line 550
  return;
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_mac(struct ixgbe_adapter *adapter , int vf , unsigned char *mac_addr ) 
{ 


  {
#line 555
  ixgbe_del_mac_filter(adapter, (u8 *)(& (adapter->vfinfo + (unsigned long )vf)->vf_mac_addresses),
                       (int )((u16 )vf));
#line 556
  memcpy((void *)(& (adapter->vfinfo + (unsigned long )vf)->vf_mac_addresses), (void const   *)mac_addr,
           6UL);
#line 557
  ixgbe_add_mac_filter(adapter, (u8 *)(& (adapter->vfinfo + (unsigned long )vf)->vf_mac_addresses),
                       (int )((u16 )vf));
#line 559
  return (0);
}
}
#line 562 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_macvlan(struct ixgbe_adapter *adapter , int vf , int index ,
                                unsigned char *mac_addr ) 
{ 
  struct list_head *pos ;
  struct vf_macvlans *entry ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 568
  if (index <= 1) {
#line 569
    pos = adapter->vf_mvs.l.next;
#line 569
    goto ldv_55666;
    ldv_55665: 
#line 570
    __mptr = (struct list_head  const  *)pos;
#line 570
    entry = (struct vf_macvlans *)__mptr;
#line 571
    if (entry->vf == vf) {
#line 572
      entry->vf = -1;
#line 573
      entry->free = 1;
#line 574
      entry->is_macvlan = 0;
#line 575
      ixgbe_del_mac_filter(adapter, (u8 *)(& entry->vf_macvlan), (int )((u16 )vf));
    } else {

    }
#line 569
    pos = pos->next;
    ldv_55666: ;
#line 569
    if ((unsigned long )(& adapter->vf_mvs.l) != (unsigned long )pos) {
#line 571
      goto ldv_55665;
    } else {

    }

  } else {

  }
#line 585
  if (index == 0) {
#line 586
    return (0);
  } else {

  }
#line 588
  entry = (struct vf_macvlans *)0;
#line 590
  pos = adapter->vf_mvs.l.next;
#line 590
  goto ldv_55672;
  ldv_55671: 
#line 591
  __mptr___0 = (struct list_head  const  *)pos;
#line 591
  entry = (struct vf_macvlans *)__mptr___0;
#line 592
  if ((int )entry->free) {
#line 593
    goto ldv_55670;
  } else {

  }
#line 590
  pos = pos->next;
  ldv_55672: ;
#line 590
  if ((unsigned long )(& adapter->vf_mvs.l) != (unsigned long )pos) {
#line 592
    goto ldv_55671;
  } else {

  }
  ldv_55670: ;
#line 604
  if ((unsigned long )entry == (unsigned long )((struct vf_macvlans *)0) || ! entry->free) {
#line 605
    return (-28);
  } else {

  }
#line 607
  entry->free = 0;
#line 608
  entry->is_macvlan = 1;
#line 609
  entry->vf = vf;
#line 610
  memcpy((void *)(& entry->vf_macvlan), (void const   *)mac_addr, 6UL);
#line 612
  ixgbe_add_mac_filter(adapter, mac_addr, (int )((u16 )vf));
#line 614
  return (0);
}
}
#line 617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_vf_configuration(struct pci_dev *pdev , unsigned int event_mask ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  unsigned int vfn ;
  bool enable ;

  {
#line 619
  tmp = pci_get_drvdata(pdev);
#line 619
  adapter = (struct ixgbe_adapter *)tmp;
#line 620
  vfn = event_mask & 63U;
#line 622
  enable = (event_mask & 268435456U) != 0U;
#line 624
  if ((int )enable) {
#line 625
    eth_zero_addr((u8 *)(& (adapter->vfinfo + (unsigned long )vfn)->vf_mac_addresses));
  } else {

  }
#line 627
  return (0);
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
__inline static void ixgbe_write_qde(struct ixgbe_adapter *adapter , u32 vf , u32 qde ) 
{ 
  struct ixgbe_hw *hw ;
  struct ixgbe_ring_feature *vmdq ;
  u32 q_per_pool ;
  int i ;
  u32 reg ;

  {
#line 633
  hw = & adapter->hw;
#line 634
  vmdq = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 1UL;
#line 635
  q_per_pool = (u32 )(- ((int )vmdq->mask) & (int )vmdq->mask);
#line 638
  i = (int )(vf * q_per_pool);
#line 638
  goto ldv_55691;
  ldv_55690: 
#line 642
  ixgbe_read_reg(hw, 8U);
#line 645
  reg = 65537U;
#line 646
  reg = (u32 )(i << 8) | reg;
#line 647
  ixgbe_write_reg(hw, 12036U, reg);
#line 638
  i = i + 1;
  ldv_55691: ;
#line 638
  if ((u32 )i < (vf + 1U) * q_per_pool) {
#line 640
    goto ldv_55690;
  } else {

  }

#line 645
  return;
}
}
#line 651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_vf_reset_msg(struct ixgbe_adapter *adapter , u32 vf ) 
{ 
  struct ixgbe_ring_feature *vmdq ;
  struct ixgbe_hw *hw ;
  unsigned char *vf_mac ;
  u32 reg ;
  u32 reg_offset ;
  u32 vf_shift ;
  u32 msgbuf[4U] ;
  u8 *addr ;
  u32 q_per_pool ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  struct net_device *dev ;
  int pf_max_frame ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 653
  vmdq = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 1UL;
#line 654
  hw = & adapter->hw;
#line 655
  vf_mac = (unsigned char *)(& (adapter->vfinfo + (unsigned long )vf)->vf_mac_addresses);
#line 657
  msgbuf[0] = 0U;
#line 657
  msgbuf[1] = 0U;
#line 657
  msgbuf[2] = 0U;
#line 657
  msgbuf[3] = 0U;
#line 658
  addr = (u8 *)(& msgbuf) + 1U;
#line 659
  q_per_pool = (u32 )(- ((int )vmdq->mask) & (int )vmdq->mask);
#line 662
  if (((int )adapter->msg_enable & 2) != 0) {
#line 662
    netdev_info((struct net_device  const  *)adapter->netdev, "VF Reset msg received from vf %d\n",
                vf);
  } else {

  }
#line 665
  ixgbe_vf_reset_event(adapter, vf);
#line 668
  tmp = is_zero_ether_addr((u8 const   *)vf_mac);
#line 668
  if (tmp) {
#line 668
    tmp___0 = 0;
  } else {
#line 668
    tmp___0 = 1;
  }
#line 668
  if (tmp___0) {
#line 669
    ixgbe_set_vf_mac(adapter, (int )vf, vf_mac);
  } else {

  }
#line 671
  vf_shift = vf & 31U;
#line 672
  reg_offset = vf / 32U;
#line 675
  reg = ixgbe_read_reg(hw, (reg_offset + 8260U) * 4U);
#line 676
  reg = (u32 )(1 << (int )vf_shift) | reg;
#line 677
  ixgbe_write_reg(hw, (reg_offset + 8260U) * 4U, reg);
#line 680
  ixgbe_write_qde(adapter, vf, 1U);
#line 683
  reg = ixgbe_read_reg(hw, (reg_offset + 5240U) * 4U);
#line 684
  reg = (u32 )(1 << (int )vf_shift) | reg;
#line 689
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 690
    dev = adapter->netdev;
#line 691
    pf_max_frame = (int )(dev->mtu + 14U);
#line 699
    if (pf_max_frame > 1514) {
#line 700
      reg = (u32 )(~ (1 << (int )vf_shift)) & reg;
    } else {

    }
  } else {

  }
#line 702
  ixgbe_write_reg(hw, (reg_offset + 5240U) * 4U, reg);
#line 705
  (adapter->vfinfo + (unsigned long )vf)->clear_to_send = 1;
#line 708
  reg = ixgbe_read_reg(hw, (reg_offset + 8676U) * 4U);
#line 709
  reg = (u32 )(1 << (int )vf_shift) | reg;
#line 710
  ixgbe_write_reg(hw, (reg_offset + 8676U) * 4U, reg);
#line 716
  i = 0;
#line 716
  goto ldv_55710;
  ldv_55709: 
#line 717
  ixgbe_write_reg(hw, (q_per_pool * vf + (u32 )i) * 64U + 24636U, 0U);
#line 718
  ixgbe_write_reg(hw, (q_per_pool * vf + (u32 )i) * 64U + 24632U, 0U);
#line 716
  i = i + 1;
  ldv_55710: ;
#line 716
  if ((u32 )i < q_per_pool) {
#line 718
    goto ldv_55709;
  } else {

  }
#line 722
  msgbuf[0] = 1U;
#line 723
  tmp___1 = is_zero_ether_addr((u8 const   *)vf_mac);
#line 723
  if (tmp___1) {
#line 723
    tmp___2 = 0;
  } else {
#line 723
    tmp___2 = 1;
  }
#line 723
  if (tmp___2) {
#line 724
    msgbuf[0] = msgbuf[0] | 2147483648U;
#line 725
    memcpy((void *)addr, (void const   *)vf_mac, 6UL);
  } else {
#line 727
    msgbuf[0] = msgbuf[0] | 1073741824U;
#line 728
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "VF %d has no MAC address assigned, you may have to assign one manually\n",
             vf);
  }
#line 737
  msgbuf[3] = (u32 )hw->mac.mc_filter_type;
#line 738
  ixgbe_write_mbx(hw, (u32 *)(& msgbuf), 4, (int )((u16 )vf));
#line 740
  return (0);
}
}
#line 743 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_mac_addr(struct ixgbe_adapter *adapter , u32 *msgbuf , u32 vf ) 
{ 
  u8 *new_mac ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 746
  new_mac = (u8 *)msgbuf + 1U;
#line 748
  tmp = is_valid_ether_addr((u8 const   *)new_mac);
#line 748
  if (tmp) {
#line 748
    tmp___0 = 0;
  } else {
#line 748
    tmp___0 = 1;
  }
#line 748
  if (tmp___0) {
#line 749
    if ((int )adapter->msg_enable & 1) {
#line 749
      netdev_warn((struct net_device  const  *)adapter->netdev, "VF %d attempted to set invalid mac\n",
                  vf);
    } else {

    }
#line 750
    return (-1);
  } else {

  }
#line 753
  if ((int )(adapter->vfinfo + (unsigned long )vf)->pf_set_mac) {
#line 753
    tmp___1 = ether_addr_equal((u8 const   *)(& (adapter->vfinfo + (unsigned long )vf)->vf_mac_addresses),
                               (u8 const   *)new_mac);
#line 753
    if (tmp___1) {
#line 753
      tmp___2 = 0;
    } else {
#line 753
      tmp___2 = 1;
    }
#line 753
    if (tmp___2) {
#line 755
      if ((int )adapter->msg_enable & 1) {
#line 758
        netdev_warn((struct net_device  const  *)adapter->netdev, "VF %d attempted to override administratively set MAC address\nReload the VF driver to resume operations\n",
                    vf);
      } else {

      }
#line 759
      return (-1);
    } else {

    }
  } else {

  }
#line 762
  tmp___3 = ixgbe_set_vf_mac(adapter, (int )vf, new_mac);
#line 762
  return (tmp___3 < 0);
}
}
#line 765 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_find_vlvf_entry(struct ixgbe_hw *hw , u32 vlan ) 
{ 
  u32 vlvf ;
  s32 regindex ;

  {
#line 771
  if (vlan == 0U) {
#line 772
    return (0);
  } else {

  }
#line 775
  regindex = 1;
#line 775
  goto ldv_55726;
  ldv_55725: 
#line 776
  vlvf = ixgbe_read_reg(hw, (u32 )((regindex + 15424) * 4));
#line 777
  if ((vlvf & 4095U) == vlan) {
#line 778
    goto ldv_55724;
  } else {

  }
#line 775
  regindex = regindex + 1;
  ldv_55726: ;
#line 775
  if (regindex <= 63) {
#line 777
    goto ldv_55725;
  } else {

  }
  ldv_55724: ;
#line 782
  if (regindex > 63) {
#line 783
    regindex = -1;
  } else {

  }
#line 785
  return (regindex);
}
}
#line 788 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_vlan_msg(struct ixgbe_adapter *adapter , u32 *msgbuf , u32 vf ) 
{ 
  struct ixgbe_hw *hw ;
  int add ;
  int vid ;
  int err ;
  s32 reg_ndx ;
  u32 vlvf ;
  u32 bits ;
  u8 tcs ;
  int tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  int tmp___2 ;

  {
#line 791
  hw = & adapter->hw;
#line 792
  add = (int )((*msgbuf & 16711680U) >> 16);
#line 793
  vid = (int )*(msgbuf + 1UL) & 4095;
#line 798
  tmp = netdev_get_num_tc(adapter->netdev);
#line 798
  tcs = (u8 )tmp;
#line 800
  if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->pf_vlan != 0U || (unsigned int )tcs != 0U) {
#line 801
    if ((int )adapter->msg_enable & 1) {
#line 804
      netdev_warn((struct net_device  const  *)adapter->netdev, "VF %d attempted to override administratively set VLAN configuration\nReload the VF driver to resume operations\n",
                  vf);
    } else {

    }
#line 805
    return (-1);
  } else {

  }
#line 808
  if (add != 0) {
#line 809
    (adapter->vfinfo + (unsigned long )vf)->vlan_count = (u16 )((int )(adapter->vfinfo + (unsigned long )vf)->vlan_count + 1);
  } else
#line 810
  if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->vlan_count != 0U) {
#line 811
    (adapter->vfinfo + (unsigned long )vf)->vlan_count = (u16 )((int )(adapter->vfinfo + (unsigned long )vf)->vlan_count - 1);
  } else {

  }
#line 816
  if (add != 0 && ((adapter->netdev)->flags & 256U) != 0U) {
#line 817
    err = ixgbe_set_vf_vlan(adapter, add, vid, (u32 )adapter->ring_feature[1].offset);
  } else {

  }
#line 819
  err = ixgbe_set_vf_vlan(adapter, add, vid, vf);
#line 820
  if (err == 0 && (unsigned int )(adapter->vfinfo + (unsigned long )vf)->spoofchk_enabled != 0U) {
#line 821
    (*(hw->mac.ops.set_vlan_anti_spoofing))(hw, 1, (int )vf);
  } else {

  }
#line 826
  if (add == 0 && ((adapter->netdev)->flags & 256U) != 0U) {
#line 827
    reg_ndx = ixgbe_find_vlvf_entry(hw, (u32 )vid);
#line 828
    if (reg_ndx < 0) {
#line 829
      return (err);
    } else {

    }
#line 830
    vlvf = ixgbe_read_reg(hw, (u32 )((reg_ndx + 15424) * 4));
#line 834
    if ((int )adapter->ring_feature[1].offset <= 31) {
#line 835
      bits = ixgbe_read_reg(hw, (u32 )((reg_ndx + 7744) * 8));
#line 836
      bits = (u32 )(~ (1 << (int )adapter->ring_feature[1].offset)) & bits;
#line 837
      tmp___0 = ixgbe_read_reg(hw, (u32 )((reg_ndx + 7744) * 8 + 1));
#line 837
      bits = tmp___0 | bits;
    } else {
#line 840
      bits = ixgbe_read_reg(hw, (u32 )((reg_ndx + 7744) * 8 + 1));
#line 842
      bits = (u32 )(~ (1 << ((int )adapter->ring_feature[1].offset + -32))) & bits;
#line 843
      tmp___1 = ixgbe_read_reg(hw, (u32 )((reg_ndx + 7744) * 8));
#line 843
      bits = tmp___1 | bits;
    }
#line 850
    if ((vlvf & 4095U) == (u32 )vid) {
#line 850
      tmp___2 = variable_test_bit((long )vid, (unsigned long const volatile   *)(& adapter->active_vlans));
#line 850
      if (tmp___2 == 0) {
#line 850
        if (bits == 0U) {
#line 852
          ixgbe_set_vf_vlan(adapter, add, vid, (u32 )adapter->ring_feature[1].offset);
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 855
  return (err);
}
}
#line 858 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_macvlan_msg(struct ixgbe_adapter *adapter , u32 *msgbuf ,
                                    u32 vf ) 
{ 
  u8 *new_mac ;
  int index ;
  int err ;
  bool tmp ;
  int tmp___0 ;

  {
#line 861
  new_mac = (u8 *)msgbuf + 1U;
#line 862
  index = (int )((*msgbuf & 16711680U) >> 16);
#line 866
  if ((int )(adapter->vfinfo + (unsigned long )vf)->pf_set_mac && index > 0) {
#line 867
    if ((int )adapter->msg_enable & 1) {
#line 869
      netdev_warn((struct net_device  const  *)adapter->netdev, "VF %d requested MACVLAN filter but is administratively denied\n",
                  vf);
    } else {

    }
#line 870
    return (-1);
  } else {

  }
#line 874
  if (index != 0) {
#line 875
    tmp = is_valid_ether_addr((u8 const   *)new_mac);
#line 875
    if (tmp) {
#line 875
      tmp___0 = 0;
    } else {
#line 875
      tmp___0 = 1;
    }
#line 875
    if (tmp___0) {
#line 876
      if ((int )adapter->msg_enable & 1) {
#line 876
        netdev_warn((struct net_device  const  *)adapter->netdev, "VF %d attempted to set invalid mac\n",
                    vf);
      } else {

      }
#line 877
      return (-1);
    } else {

    }
#line 884
    if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->spoofchk_enabled != 0U) {
#line 885
      ixgbe_ndo_set_vf_spoofchk(adapter->netdev, (int )vf, 0);
    } else {

    }
  } else {

  }
#line 888
  err = ixgbe_set_vf_macvlan(adapter, (int )vf, index, new_mac);
#line 889
  if (err == -28) {
#line 890
    if ((int )adapter->msg_enable & 1) {
#line 892
      netdev_warn((struct net_device  const  *)adapter->netdev, "VF %d has requested a MACVLAN filter but there is no space for it\n",
                  vf);
    } else {

    }
  } else {

  }
#line 894
  return (err < 0);
}
}
#line 897 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_negotiate_vf_api(struct ixgbe_adapter *adapter , u32 *msgbuf , u32 vf ) 
{ 
  int api ;

  {
#line 900
  api = (int )*(msgbuf + 1UL);
#line 902
  switch (api) {
  case 0: ;
  case 2: ;
  case 3: 
#line 906
  (adapter->vfinfo + (unsigned long )vf)->vf_api = (unsigned int )api;
#line 907
  return (0);
  default: ;
#line 909
  goto ldv_55758;
  }
  ldv_55758: ;
#line 912
  if ((int )adapter->msg_enable & 1) {
#line 912
    netdev_info((struct net_device  const  *)adapter->netdev, "VF %d requested invalid api version %u\n",
                vf, api);
  } else {

  }
#line 914
  return (-1);
}
}
#line 917 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_get_vf_queues(struct ixgbe_adapter *adapter , u32 *msgbuf , u32 vf ) 
{ 
  struct net_device *dev ;
  struct ixgbe_ring_feature *vmdq ;
  unsigned int default_tc ;
  u8 num_tcs ;
  int tmp ;
  int tmp___0 ;

  {
#line 920
  dev = adapter->netdev;
#line 921
  vmdq = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 1UL;
#line 922
  default_tc = 0U;
#line 923
  tmp = netdev_get_num_tc(dev);
#line 923
  num_tcs = (u8 )tmp;
#line 926
  switch ((adapter->vfinfo + (unsigned long )vf)->vf_api) {
  case 1U: ;
  case 2U: ;
  case 3U: ;
#line 930
  goto ldv_55771;
  default: ;
#line 932
  return (-1);
  }
  ldv_55771: 
#line 936
  *(msgbuf + 1UL) = (u32 )(- ((int )vmdq->mask) & (int )vmdq->mask);
#line 937
  *(msgbuf + 2UL) = (u32 )(- ((int )vmdq->mask) & (int )vmdq->mask);
#line 940
  if ((unsigned int )num_tcs > 1U) {
#line 941
    tmp___0 = netdev_get_prio_tc_map((struct net_device  const  *)dev, (u32 )adapter->default_up);
#line 941
    default_tc = (unsigned int )tmp___0;
  } else {

  }
#line 944
  if ((unsigned int )num_tcs != 0U) {
#line 945
    *(msgbuf + 3UL) = (u32 )num_tcs;
  } else
#line 946
  if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->pf_vlan != 0U || (unsigned int )(adapter->vfinfo + (unsigned long )vf)->pf_qos != 0U) {
#line 947
    *(msgbuf + 3UL) = 1U;
  } else {
#line 949
    *(msgbuf + 3UL) = 0U;
  }
#line 952
  *(msgbuf + 4UL) = default_tc;
#line 954
  return (0);
}
}
#line 957 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_get_vf_reta(struct ixgbe_adapter *adapter , u32 *msgbuf , u32 vf ) 
{ 
  u32 i ;
  u32 j ;
  u32 *out_buf ;
  u8 const   *reta ;
  u32 reta_size ;
  u32 tmp ;

  {
#line 960
  out_buf = msgbuf + 1UL;
#line 961
  reta = (u8 const   *)(& adapter->rss_indir_tbl);
#line 962
  tmp = ixgbe_rss_indir_tbl_entries(adapter);
#line 962
  reta_size = tmp;
#line 965
  if (! (adapter->vfinfo + (unsigned long )vf)->rss_query_enabled) {
#line 966
    return (-1);
  } else {

  }
#line 969
  if ((adapter->vfinfo + (unsigned long )vf)->vf_api != 3U) {
#line 970
    return (-95);
  } else {

  }
#line 977
  i = 0U;
#line 977
  goto ldv_55787;
  ldv_55786: 
#line 978
  *(out_buf + (unsigned long )i) = 0U;
#line 979
  j = 0U;
#line 979
  goto ldv_55784;
  ldv_55783: 
#line 980
  *(out_buf + (unsigned long )i) = *(out_buf + (unsigned long )i) | (((unsigned int )*(reta + (unsigned long )(i * 16U + j)) & 3U) << (int )(j * 2U));
#line 979
  j = j + 1U;
  ldv_55784: ;
#line 979
  if (j <= 15U) {
#line 981
    goto ldv_55783;
  } else {

  }
#line 977
  i = i + 1U;
  ldv_55787: ;
#line 977
  if (reta_size / 16U > i) {
#line 979
    goto ldv_55786;
  } else {

  }

#line 983
  return (0);
}
}
#line 986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_get_vf_rss_key(struct ixgbe_adapter *adapter , u32 *msgbuf , u32 vf ) 
{ 
  u32 *rss_key ;

  {
#line 989
  rss_key = msgbuf + 1UL;
#line 992
  if (! (adapter->vfinfo + (unsigned long )vf)->rss_query_enabled) {
#line 993
    return (-1);
  } else {

  }
#line 996
  if ((adapter->vfinfo + (unsigned long )vf)->vf_api != 3U) {
#line 997
    return (-95);
  } else {

  }
#line 999
  memcpy((void *)rss_key, (void const   *)(& adapter->rss_key), 40UL);
#line 1001
  return (0);
}
}
#line 1004 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_rcv_msg_from_vf(struct ixgbe_adapter *adapter , u32 vf ) 
{ 
  u32 mbx_size ;
  u32 msgbuf[16U] ;
  struct ixgbe_hw *hw ;
  s32 retval ;
  int tmp ;

  {
#line 1006
  mbx_size = 16U;
#line 1008
  hw = & adapter->hw;
#line 1011
  retval = ixgbe_read_mbx(hw, (u32 *)(& msgbuf), (int )((u16 )mbx_size), (int )((u16 )vf));
#line 1013
  if (retval != 0) {
#line 1014
    printk("\vixgbe: Error receiving message from VF\n");
#line 1015
    return (retval);
  } else {

  }
#line 1019
  if ((msgbuf[0] & 3221225472U) != 0U) {
#line 1020
    return (0);
  } else {

  }
#line 1023
  ixgbe_read_reg(hw, 8U);
#line 1025
  if (msgbuf[0] == 1U) {
#line 1026
    tmp = ixgbe_vf_reset_msg(adapter, vf);
#line 1026
    return (tmp);
  } else {

  }
#line 1032
  if (! (adapter->vfinfo + (unsigned long )vf)->clear_to_send) {
#line 1033
    msgbuf[0] = msgbuf[0] | 1073741824U;
#line 1034
    ixgbe_write_mbx(hw, (u32 *)(& msgbuf), 1, (int )((u16 )vf));
#line 1035
    return (0);
  } else {

  }
#line 1038
  switch (msgbuf[0] & 65535U) {
  case 2U: 
#line 1040
  retval = ixgbe_set_vf_mac_addr(adapter, (u32 *)(& msgbuf), vf);
#line 1041
  goto ldv_55804;
  case 3U: 
#line 1043
  retval = ixgbe_set_vf_multicasts(adapter, (u32 *)(& msgbuf), vf);
#line 1044
  goto ldv_55804;
  case 4U: 
#line 1046
  retval = ixgbe_set_vf_vlan_msg(adapter, (u32 *)(& msgbuf), vf);
#line 1047
  goto ldv_55804;
  case 5U: 
#line 1049
  retval = ixgbe_set_vf_lpe(adapter, (u32 *)(& msgbuf), vf);
#line 1050
  goto ldv_55804;
  case 6U: 
#line 1052
  retval = ixgbe_set_vf_macvlan_msg(adapter, (u32 *)(& msgbuf), vf);
#line 1053
  goto ldv_55804;
  case 8U: 
#line 1055
  retval = ixgbe_negotiate_vf_api(adapter, (u32 *)(& msgbuf), vf);
#line 1056
  goto ldv_55804;
  case 9U: 
#line 1058
  retval = ixgbe_get_vf_queues(adapter, (u32 *)(& msgbuf), vf);
#line 1059
  goto ldv_55804;
  case 10U: 
#line 1061
  retval = ixgbe_get_vf_reta(adapter, (u32 *)(& msgbuf), vf);
#line 1062
  goto ldv_55804;
  case 11U: 
#line 1064
  retval = ixgbe_get_vf_rss_key(adapter, (u32 *)(& msgbuf), vf);
#line 1065
  goto ldv_55804;
  default: ;
#line 1067
  if ((int )adapter->msg_enable & 1) {
#line 1067
    netdev_err((struct net_device  const  *)adapter->netdev, "Unhandled Msg %8.8x\n",
               msgbuf[0]);
  } else {

  }
#line 1068
  retval = -100;
#line 1069
  goto ldv_55804;
  }
  ldv_55804: ;
#line 1073
  if (retval != 0) {
#line 1074
    msgbuf[0] = msgbuf[0] | 1073741824U;
  } else {
#line 1076
    msgbuf[0] = msgbuf[0] | 2147483648U;
  }
#line 1078
  msgbuf[0] = msgbuf[0] | 536870912U;
#line 1080
  ixgbe_write_mbx(hw, (u32 *)(& msgbuf), (int )((u16 )mbx_size), (int )((u16 )vf));
#line 1082
  return (retval);
}
}
#line 1085 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_rcv_ack_from_vf(struct ixgbe_adapter *adapter , u32 vf ) 
{ 
  struct ixgbe_hw *hw ;
  u32 msg ;

  {
#line 1087
  hw = & adapter->hw;
#line 1088
  msg = 1073741824U;
#line 1091
  if (! (adapter->vfinfo + (unsigned long )vf)->clear_to_send) {
#line 1092
    ixgbe_write_mbx(hw, & msg, 1, (int )((u16 )vf));
  } else {

  }
#line 1093
  return;
}
}
#line 1095 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_msg_task(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 vf ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;

  {
#line 1097
  hw = & adapter->hw;
#line 1100
  vf = 0U;
#line 1100
  goto ldv_55826;
  ldv_55825: 
#line 1102
  tmp = ixgbe_check_for_rst(hw, (int )((u16 )vf));
#line 1102
  if (tmp == 0) {
#line 1103
    ixgbe_vf_reset_event(adapter, vf);
  } else {

  }
#line 1106
  tmp___0 = ixgbe_check_for_msg(hw, (int )((u16 )vf));
#line 1106
  if (tmp___0 == 0) {
#line 1107
    ixgbe_rcv_msg_from_vf(adapter, vf);
  } else {

  }
#line 1110
  tmp___1 = ixgbe_check_for_ack(hw, (int )((u16 )vf));
#line 1110
  if (tmp___1 == 0) {
#line 1111
    ixgbe_rcv_ack_from_vf(adapter, vf);
  } else {

  }
#line 1100
  vf = vf + 1U;
  ldv_55826: ;
#line 1100
  if (adapter->num_vfs > vf) {
#line 1102
    goto ldv_55825;
  } else {

  }

#line 1107
  return;
}
}
#line 1115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_disable_tx_rx(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;

  {
#line 1117
  hw = & adapter->hw;
#line 1120
  ixgbe_write_reg(hw, 33040U, 0U);
#line 1121
  ixgbe_write_reg(hw, 33044U, 0U);
#line 1123
  ixgbe_write_reg(hw, 20960U, 0U);
#line 1124
  ixgbe_write_reg(hw, 20964U, 0U);
#line 1125
  return;
}
}
#line 1127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_ping_all_vfs(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 ping ;
  int i ;

  {
#line 1129
  hw = & adapter->hw;
#line 1133
  i = 0;
#line 1133
  goto ldv_55839;
  ldv_55838: 
#line 1134
  ping = 256U;
#line 1135
  if ((int )(adapter->vfinfo + (unsigned long )i)->clear_to_send) {
#line 1136
    ping = ping | 536870912U;
  } else {

  }
#line 1137
  ixgbe_write_mbx(hw, & ping, 1, (int )((u16 )i));
#line 1133
  i = i + 1;
  ldv_55839: ;
#line 1133
  if ((unsigned int )i < adapter->num_vfs) {
#line 1135
    goto ldv_55838;
  } else {

  }

#line 1140
  return;
}
}
#line 1141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_mac(struct net_device *netdev , int vf , u8 *mac ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1143
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1143
  adapter = (struct ixgbe_adapter *)tmp;
#line 1144
  tmp___0 = is_valid_ether_addr((u8 const   *)mac);
#line 1144
  if (tmp___0) {
#line 1144
    tmp___1 = 0;
  } else {
#line 1144
    tmp___1 = 1;
  }
#line 1144
  if (tmp___1 || (unsigned int )vf >= adapter->num_vfs) {
#line 1145
    return (-22);
  } else {

  }
#line 1146
  (adapter->vfinfo + (unsigned long )vf)->pf_set_mac = 1;
#line 1147
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "setting MAC %pM on VF %d\n",
            mac, vf);
#line 1148
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Reload the VF driver to make this change effective.");
#line 1150
  tmp___2 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 1150
  if (tmp___2 != 0) {
#line 1151
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "The VF MAC address has been set, but the PF device is not up.\n");
#line 1153
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Bring the PF device up before attempting to use the VF device.\n");
  } else {

  }
#line 1156
  tmp___3 = ixgbe_set_vf_mac(adapter, vf, mac);
#line 1156
  return (tmp___3);
}
}
#line 1159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_enable_port_vlan(struct ixgbe_adapter *adapter , int vf , u16 vlan ,
                                  u8 qos ) 
{ 
  struct ixgbe_hw *hw ;
  int err ;
  int tmp ;

  {
#line 1162
  hw = & adapter->hw;
#line 1165
  err = ixgbe_set_vf_vlan(adapter, 1, (int )vlan, (u32 )vf);
#line 1166
  if (err != 0) {
#line 1167
    goto out;
  } else {

  }
#line 1169
  ixgbe_set_vmvir(adapter, (int )vlan, (int )qos, (u32 )vf);
#line 1170
  ixgbe_set_vmolr(hw, (u32 )vf, 0);
#line 1171
  if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->spoofchk_enabled != 0U) {
#line 1172
    (*(hw->mac.ops.set_vlan_anti_spoofing))(hw, 1, vf);
  } else {

  }
#line 1173
  (adapter->vfinfo + (unsigned long )vf)->vlan_count = (u16 )((int )(adapter->vfinfo + (unsigned long )vf)->vlan_count + 1);
#line 1176
  if ((unsigned int )hw->mac.type > 3U) {
#line 1177
    ixgbe_write_qde(adapter, (u32 )vf, 3U);
  } else {

  }
#line 1180
  (adapter->vfinfo + (unsigned long )vf)->pf_vlan = vlan;
#line 1181
  (adapter->vfinfo + (unsigned long )vf)->pf_qos = (u16 )qos;
#line 1182
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Setting VLAN %d, QOS 0x%x on VF %d\n",
            (int )vlan, (int )qos, vf);
#line 1184
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 1184
  if (tmp != 0) {
#line 1185
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "The VF VLAN has been set, but the PF device is not up.\n");
#line 1187
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Bring the PF device up before attempting to use the VF device.\n");
  } else {

  }
  out: ;
#line 1192
  return (err);
}
}
#line 1195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_disable_port_vlan(struct ixgbe_adapter *adapter , int vf ) 
{ 
  struct ixgbe_hw *hw ;
  int err ;

  {
#line 1197
  hw = & adapter->hw;
#line 1200
  err = ixgbe_set_vf_vlan(adapter, 0, (int )(adapter->vfinfo + (unsigned long )vf)->pf_vlan,
                          (u32 )vf);
#line 1202
  ixgbe_clear_vmvir(adapter, (u32 )vf);
#line 1203
  ixgbe_set_vmolr(hw, (u32 )vf, 1);
#line 1204
  (*(hw->mac.ops.set_vlan_anti_spoofing))(hw, 0, vf);
#line 1205
  if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->vlan_count != 0U) {
#line 1206
    (adapter->vfinfo + (unsigned long )vf)->vlan_count = (u16 )((int )(adapter->vfinfo + (unsigned long )vf)->vlan_count - 1);
  } else {

  }
#line 1209
  if ((unsigned int )hw->mac.type > 3U) {
#line 1210
    ixgbe_write_qde(adapter, (u32 )vf, 1U);
  } else {

  }
#line 1212
  (adapter->vfinfo + (unsigned long )vf)->pf_vlan = 0U;
#line 1213
  (adapter->vfinfo + (unsigned long )vf)->pf_qos = 0U;
#line 1215
  return (err);
}
}
#line 1218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_vlan(struct net_device *netdev , int vf , u16 vlan , u8 qos ) 
{ 
  int err ;
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 1220
  err = 0;
#line 1221
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1221
  adapter = (struct ixgbe_adapter *)tmp;
#line 1223
  if (((unsigned int )vf >= adapter->num_vfs || (unsigned int )vlan > 4095U) || (unsigned int )qos > 7U) {
#line 1224
    return (-22);
  } else {

  }
#line 1225
  if ((unsigned int )vlan != 0U || (unsigned int )qos != 0U) {
#line 1233
    if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->pf_vlan != 0U) {
#line 1234
      err = ixgbe_disable_port_vlan(adapter, vf);
    } else {

    }
#line 1235
    if (err != 0) {
#line 1236
      goto out;
    } else {

    }
#line 1237
    err = ixgbe_enable_port_vlan(adapter, vf, (int )vlan, (int )qos);
  } else {
#line 1239
    err = ixgbe_disable_port_vlan(adapter, vf);
  }
  out: ;
#line 1243
  return (err);
}
}
#line 1246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_link_mbps(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 1248
  switch (adapter->link_speed) {
  case 8U: ;
#line 1250
  return (100);
  case 32U: ;
#line 1252
  return (1000);
  case 128U: ;
#line 1254
  return (10000);
  default: ;
#line 1256
  return (0);
  }
}
}
#line 1260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_set_vf_rate_limit(struct ixgbe_adapter *adapter , int vf ) 
{ 
  struct ixgbe_ring_feature *vmdq ;
  struct ixgbe_hw *hw ;
  u32 bcnrc_val ;
  u16 queue ;
  u16 queues_per_pool ;
  u16 tx_rate ;
  unsigned int reg_idx ;

  {
#line 1262
  vmdq = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 1UL;
#line 1263
  hw = & adapter->hw;
#line 1264
  bcnrc_val = 0U;
#line 1266
  tx_rate = (adapter->vfinfo + (unsigned long )vf)->tx_rate;
#line 1268
  if ((unsigned int )tx_rate != 0U) {
#line 1270
    bcnrc_val = (u32 )adapter->vf_rate_link_speed;
#line 1273
    bcnrc_val = bcnrc_val << 14;
#line 1274
    bcnrc_val = bcnrc_val / (u32 )tx_rate;
#line 1277
    bcnrc_val = bcnrc_val & 268435455U;
#line 1281
    bcnrc_val = bcnrc_val | 2147483648U;
  } else {

  }
#line 1289
  switch ((unsigned int )hw->mac.type) {
  case 2U: 
#line 1291
  ixgbe_write_reg(hw, 18816U, 4U);
#line 1292
  goto ldv_55889;
  case 3U: 
#line 1294
  ixgbe_write_reg(hw, 18816U, 20U);
#line 1295
  goto ldv_55889;
  default: ;
#line 1297
  goto ldv_55889;
  }
  ldv_55889: 
#line 1301
  queues_per_pool = (u16 )((int )((short )(- ((int )vmdq->mask))) & (int )((short )vmdq->mask));
#line 1304
  queue = 0U;
#line 1304
  goto ldv_55894;
  ldv_55893: 
#line 1305
  reg_idx = (unsigned int )((int )queues_per_pool * vf + (int )queue);
#line 1307
  ixgbe_write_reg(hw, 18692U, reg_idx);
#line 1308
  ixgbe_write_reg(hw, 18820U, bcnrc_val);
#line 1304
  queue = (u16 )((int )queue + 1);
  ldv_55894: ;
#line 1304
  if ((int )queue < (int )queues_per_pool) {
#line 1306
    goto ldv_55893;
  } else {

  }

#line 1311
  return;
}
}
#line 1312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_check_vf_rate_limit(struct ixgbe_adapter *adapter ) 
{ 
  int i ;
  int tmp ;

  {
#line 1317
  if (adapter->vf_rate_link_speed == 0) {
#line 1318
    return;
  } else {

  }
#line 1320
  tmp = ixgbe_link_mbps(adapter);
#line 1320
  if (tmp != adapter->vf_rate_link_speed) {
#line 1321
    adapter->vf_rate_link_speed = 0;
#line 1322
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Link speed has been changed. VF Transmit rate is disabled\n");
  } else {

  }
#line 1326
  i = 0;
#line 1326
  goto ldv_55901;
  ldv_55900: ;
#line 1327
  if (adapter->vf_rate_link_speed == 0) {
#line 1328
    (adapter->vfinfo + (unsigned long )i)->tx_rate = 0U;
  } else {

  }
#line 1330
  ixgbe_set_vf_rate_limit(adapter, i);
#line 1326
  i = i + 1;
  ldv_55901: ;
#line 1326
  if ((unsigned int )i < adapter->num_vfs) {
#line 1328
    goto ldv_55900;
  } else {

  }

#line 1333
  return;
}
}
#line 1334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_bw(struct net_device *netdev , int vf , int min_tx_rate , int max_tx_rate ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int link_speed ;

  {
#line 1337
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1337
  adapter = (struct ixgbe_adapter *)tmp;
#line 1341
  if ((unsigned int )vf >= adapter->num_vfs) {
#line 1342
    return (-22);
  } else {

  }
#line 1345
  if (! adapter->link_up) {
#line 1346
    return (-22);
  } else {

  }
#line 1349
  link_speed = ixgbe_link_mbps(adapter);
#line 1350
  if (link_speed != 10000) {
#line 1351
    return (-22);
  } else {

  }
#line 1353
  if (min_tx_rate != 0) {
#line 1354
    return (-22);
  } else {

  }
#line 1357
  if (max_tx_rate != 0 && (max_tx_rate <= 10 || max_tx_rate > link_speed)) {
#line 1358
    return (-22);
  } else {

  }
#line 1361
  adapter->vf_rate_link_speed = link_speed;
#line 1362
  (adapter->vfinfo + (unsigned long )vf)->tx_rate = (u16 )max_tx_rate;
#line 1365
  ixgbe_set_vf_rate_limit(adapter, vf);
#line 1367
  return (0);
}
}
#line 1370 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev , int vf , bool setting ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int vf_target_reg ;
  int vf_target_shift ;
  struct ixgbe_hw *hw ;
  u32 regval ;

  {
#line 1372
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1372
  adapter = (struct ixgbe_adapter *)tmp;
#line 1373
  vf_target_reg = vf >> 3;
#line 1374
  vf_target_shift = vf % 8;
#line 1375
  hw = & adapter->hw;
#line 1378
  if ((unsigned int )vf >= adapter->num_vfs) {
#line 1379
    return (-22);
  } else {

  }
#line 1381
  (adapter->vfinfo + (unsigned long )vf)->spoofchk_enabled = (u8 )setting;
#line 1383
  regval = ixgbe_read_reg(hw, (u32 )((vf_target_reg + 8320) * 4));
#line 1384
  regval = (u32 )(~ (1 << vf_target_shift)) & regval;
#line 1385
  regval = (u32 )((int )setting << vf_target_shift) | regval;
#line 1386
  ixgbe_write_reg(hw, (u32 )((vf_target_reg + 8320) * 4), regval);
#line 1388
  if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->vlan_count != 0U) {
#line 1389
    vf_target_shift = vf_target_shift + 8;
#line 1390
    regval = ixgbe_read_reg(hw, (u32 )((vf_target_reg + 8320) * 4));
#line 1391
    regval = (u32 )(~ (1 << vf_target_shift)) & regval;
#line 1392
    regval = (u32 )((int )setting << vf_target_shift) | regval;
#line 1393
    ixgbe_write_reg(hw, (u32 )((vf_target_reg + 8320) * 4), regval);
  } else {

  }
#line 1396
  return (0);
}
}
#line 1399 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_rss_query_en(struct net_device *netdev , int vf , bool setting ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 1402
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1402
  adapter = (struct ixgbe_adapter *)tmp;
#line 1407
  if ((unsigned int )adapter->hw.mac.type <= 1U || (unsigned int )adapter->hw.mac.type > 3U) {
#line 1409
    return (-95);
  } else {

  }
#line 1411
  if ((unsigned int )vf >= adapter->num_vfs) {
#line 1412
    return (-22);
  } else {

  }
#line 1414
  (adapter->vfinfo + (unsigned long )vf)->rss_query_enabled = setting;
#line 1416
  return (0);
}
}
#line 1419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_get_vf_config(struct net_device *netdev , int vf , struct ifla_vf_info *ivi ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 1422
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1422
  adapter = (struct ixgbe_adapter *)tmp;
#line 1423
  if ((unsigned int )vf >= adapter->num_vfs) {
#line 1424
    return (-22);
  } else {

  }
#line 1425
  ivi->vf = (__u32 )vf;
#line 1426
  memcpy((void *)(& ivi->mac), (void const   *)(& (adapter->vfinfo + (unsigned long )vf)->vf_mac_addresses),
           6UL);
#line 1427
  ivi->max_tx_rate = (__u32 )(adapter->vfinfo + (unsigned long )vf)->tx_rate;
#line 1428
  ivi->min_tx_rate = 0U;
#line 1429
  ivi->vlan = (__u32 )(adapter->vfinfo + (unsigned long )vf)->pf_vlan;
#line 1430
  ivi->qos = (__u32 )(adapter->vfinfo + (unsigned long )vf)->pf_qos;
#line 1431
  ivi->spoofchk = (__u32 )(adapter->vfinfo + (unsigned long )vf)->spoofchk_enabled;
#line 1432
  ivi->rss_query_en = (__u32 )(adapter->vfinfo + (unsigned long )vf)->rss_query_enabled;
#line 1433
  return (0);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.o.c.prepared"
bool ldv_queue_work_on_219(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 359
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 359
  ldv_func_res = tmp;
#line 361
  activate_work_9(ldv_func_arg3, 2);
#line 363
  return (ldv_func_res);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.o.c.prepared"
bool ldv_queue_delayed_work_on_220(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 370
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 370
  ldv_func_res = tmp;
#line 372
  activate_work_9(& ldv_func_arg3->work, 2);
#line 374
  return (ldv_func_res);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.o.c.prepared"
bool ldv_queue_work_on_221(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 381
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 381
  ldv_func_res = tmp;
#line 383
  activate_work_9(ldv_func_arg3, 2);
#line 385
  return (ldv_func_res);
}
}
#line 388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.o.c.prepared"
void ldv_flush_workqueue_222(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 391
  flush_workqueue(ldv_func_arg1);
#line 393
  call_and_disable_all_9(2);
#line 394
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.o.c.prepared"
bool ldv_queue_delayed_work_on_223(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 400
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 400
  ldv_func_res = tmp;
#line 402
  activate_work_9(& ldv_func_arg3->work, 2);
#line 404
  return (ldv_func_res);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.o.c.prepared"
void ldv_mutex_lock_224(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 410
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 412
  mutex_lock(ldv_func_arg1);
#line 413
  return;
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.o.c.prepared"
void ldv_mutex_unlock_225(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 418
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 420
  mutex_unlock(ldv_func_arg1);
#line 421
  return;
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.o.c.prepared"
void ldv_mutex_lock_226(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 426
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 428
  mutex_lock(ldv_func_arg1);
#line 429
  return;
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.o.c.prepared"
int ldv_mutex_trylock_227(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 435
  tmp = mutex_trylock(ldv_func_arg1);
#line 435
  ldv_func_res = tmp;
#line 437
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 437
  return (tmp___0);
#line 439
  return (ldv_func_res);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.o.c.prepared"
void ldv_mutex_unlock_228(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 445
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 447
  mutex_unlock(ldv_func_arg1);
#line 448
  return;
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.o.c.prepared"
void ldv_mutex_unlock_229(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 453
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 455
  mutex_unlock(ldv_func_arg1);
#line 456
  return;
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.o.c.prepared"
void ldv_mutex_lock_230(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 461
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 463
  mutex_lock(ldv_func_arg1);
#line 464
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_255(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_253(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_256(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_257(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
void ldv_mutex_lock_252(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_254(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_258(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_247(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_249(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_248(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_251(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_250(struct workqueue_struct *ldv_func_arg1 ) ;
#line 8 "include/asm-generic/delay.h"
extern void __udelay(unsigned long  ) ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_read_mbx(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  s32 tmp ;

  {
#line 45
  mbx = & hw->mbx;
#line 48
  if ((int )mbx->size < (int )size) {
#line 49
    size = mbx->size;
  } else {

  }
#line 51
  if ((unsigned long )mbx->ops.read == (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                 u32 * , u16  , u16  ))0)) {
#line 52
    return (-100);
  } else {

  }
#line 54
  tmp = (*(mbx->ops.read))(hw, msg, (int )size, (int )mbx_id);
#line 54
  return (tmp);
}
}
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_write_mbx(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  s32 tmp ;

  {
#line 68
  mbx = & hw->mbx;
#line 70
  if ((int )mbx->size < (int )size) {
#line 71
    return (-100);
  } else {

  }
#line 73
  if ((unsigned long )mbx->ops.write == (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                  u32 * , u16  , u16  ))0)) {
#line 74
    return (-100);
  } else {

  }
#line 76
  tmp = (*(mbx->ops.write))(hw, msg, (int )size, (int )mbx_id);
#line 76
  return (tmp);
}
}
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_check_for_msg(struct ixgbe_hw *hw , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  s32 tmp ;

  {
#line 88
  mbx = & hw->mbx;
#line 90
  if ((unsigned long )mbx->ops.check_for_msg == (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                          u16  ))0)) {
#line 91
    return (-100);
  } else {

  }
#line 93
  tmp = (*(mbx->ops.check_for_msg))(hw, (int )mbx_id);
#line 93
  return (tmp);
}
}
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_check_for_ack(struct ixgbe_hw *hw , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  s32 tmp ;

  {
#line 105
  mbx = & hw->mbx;
#line 107
  if ((unsigned long )mbx->ops.check_for_ack == (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                          u16  ))0)) {
#line 108
    return (-100);
  } else {

  }
#line 110
  tmp = (*(mbx->ops.check_for_ack))(hw, (int )mbx_id);
#line 110
  return (tmp);
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_check_for_rst(struct ixgbe_hw *hw , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  s32 tmp ;

  {
#line 122
  mbx = & hw->mbx;
#line 124
  if ((unsigned long )mbx->ops.check_for_rst == (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                          u16  ))0)) {
#line 125
    return (-100);
  } else {

  }
#line 127
  tmp = (*(mbx->ops.check_for_rst))(hw, (int )mbx_id);
#line 127
  return (tmp);
}
}
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_poll_for_msg(struct ixgbe_hw *hw , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  int countdown ;
  s32 tmp ;

  {
#line 139
  mbx = & hw->mbx;
#line 140
  countdown = (int )mbx->timeout;
#line 142
  if (countdown == 0 || (unsigned long )mbx->ops.check_for_msg == (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                                            u16  ))0)) {
#line 143
    return (-100);
  } else {

  }
#line 145
  goto ldv_54336;
  ldv_54335: 
#line 146
  countdown = countdown - 1;
#line 147
  if (countdown == 0) {
#line 148
    return (-100);
  } else {

  }
#line 149
  __udelay((unsigned long )mbx->usec_delay);
  ldv_54336: 
#line 145
  tmp = (*(mbx->ops.check_for_msg))(hw, (int )mbx_id);
#line 145
  if (tmp != 0) {
#line 147
    goto ldv_54335;
  } else {

  }

#line 152
  return (0);
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_poll_for_ack(struct ixgbe_hw *hw , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  int countdown ;
  s32 tmp ;

  {
#line 164
  mbx = & hw->mbx;
#line 165
  countdown = (int )mbx->timeout;
#line 167
  if (countdown == 0 || (unsigned long )mbx->ops.check_for_ack == (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                                            u16  ))0)) {
#line 168
    return (-100);
  } else {

  }
#line 170
  goto ldv_54345;
  ldv_54344: 
#line 171
  countdown = countdown - 1;
#line 172
  if (countdown == 0) {
#line 173
    return (-100);
  } else {

  }
#line 174
  __udelay((unsigned long )mbx->usec_delay);
  ldv_54345: 
#line 170
  tmp = (*(mbx->ops.check_for_ack))(hw, (int )mbx_id);
#line 170
  if (tmp != 0) {
#line 172
    goto ldv_54344;
  } else {

  }

#line 177
  return (0);
}
}
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_read_posted_mbx(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  s32 ret_val ;
  s32 tmp ;

  {
#line 193
  mbx = & hw->mbx;
#line 196
  if ((unsigned long )mbx->ops.read == (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                 u32 * , u16  , u16  ))0)) {
#line 197
    return (-100);
  } else {

  }
#line 199
  ret_val = ixgbe_poll_for_msg(hw, (int )mbx_id);
#line 200
  if (ret_val != 0) {
#line 201
    return (ret_val);
  } else {

  }
#line 204
  tmp = (*(mbx->ops.read))(hw, msg, (int )size, (int )mbx_id);
#line 204
  return (tmp);
}
}
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_write_posted_mbx(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  s32 ret_val ;
  s32 tmp ;

  {
#line 220
  mbx = & hw->mbx;
#line 224
  if ((unsigned long )mbx->ops.write == (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                  u32 * , u16  , u16  ))0) || mbx->timeout == 0U) {
#line 225
    return (-100);
  } else {

  }
#line 228
  ret_val = (*(mbx->ops.write))(hw, msg, (int )size, (int )mbx_id);
#line 229
  if (ret_val != 0) {
#line 230
    return (ret_val);
  } else {

  }
#line 233
  tmp = ixgbe_poll_for_ack(hw, (int )mbx_id);
#line 233
  return (tmp);
}
}
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_check_for_bit_pf(struct ixgbe_hw *hw , u32 mask , s32 index ) 
{ 
  u32 mbvficr ;
  u32 tmp ;

  {
#line 238
  tmp = ixgbe_read_reg(hw, (u32 )((index + 452) * 4));
#line 238
  mbvficr = tmp;
#line 240
  if ((mbvficr & mask) != 0U) {
#line 241
    ixgbe_write_reg(hw, (u32 )((index + 452) * 4), mask);
#line 242
    return (0);
  } else {

  }
#line 245
  return (-100);
}
}
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_check_for_msg_pf(struct ixgbe_hw *hw , u16 vf_number ) 
{ 
  s32 index ;
  u32 vf_bit ;
  s32 tmp ;

  {
#line 257
  index = (int )vf_number >> 4;
#line 258
  vf_bit = (u32 )vf_number & 15U;
#line 260
  tmp = ixgbe_check_for_bit_pf(hw, (u32 )(1 << (int )vf_bit), index);
#line 260
  if (tmp == 0) {
#line 262
    hw->mbx.stats.reqs = hw->mbx.stats.reqs + 1U;
#line 263
    return (0);
  } else {

  }
#line 266
  return (-100);
}
}
#line 276 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_check_for_ack_pf(struct ixgbe_hw *hw , u16 vf_number ) 
{ 
  s32 index ;
  u32 vf_bit ;
  s32 tmp ;

  {
#line 278
  index = (int )vf_number >> 4;
#line 279
  vf_bit = (u32 )vf_number & 15U;
#line 281
  tmp = ixgbe_check_for_bit_pf(hw, (u32 )(65536 << (int )vf_bit), index);
#line 281
  if (tmp == 0) {
#line 283
    hw->mbx.stats.acks = hw->mbx.stats.acks + 1U;
#line 284
    return (0);
  } else {

  }
#line 287
  return (-100);
}
}
#line 297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_check_for_rst_pf(struct ixgbe_hw *hw , u16 vf_number ) 
{ 
  u32 reg_offset ;
  u32 vf_shift ;
  u32 vflre ;

  {
#line 299
  reg_offset = (unsigned int )vf_number > 31U;
#line 300
  vf_shift = (u32 )vf_number & 31U;
#line 301
  vflre = 0U;
#line 303
  switch ((unsigned int )hw->mac.type) {
  case 2U: 
#line 305
  vflre = ixgbe_read_reg(hw, (int )reg_offset & 1 ? 448U : 1536U);
#line 306
  goto ldv_54389;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 310
  vflre = ixgbe_read_reg(hw, (reg_offset + 448U) * 4U);
#line 311
  goto ldv_54389;
  default: ;
#line 313
  goto ldv_54389;
  }
  ldv_54389: ;
#line 316
  if (((u32 )(1 << (int )vf_shift) & vflre) != 0U) {
#line 317
    ixgbe_write_reg(hw, (reg_offset + 448U) * 4U, (u32 )(1 << (int )vf_shift));
#line 318
    hw->mbx.stats.rsts = hw->mbx.stats.rsts + 1U;
#line 319
    return (0);
  } else {

  }
#line 322
  return (-100);
}
}
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_obtain_mbx_lock_pf(struct ixgbe_hw *hw , u16 vf_number ) 
{ 
  u32 p2v_mailbox ;

  {
#line 337
  ixgbe_write_reg(hw, (u32 )(((int )vf_number + 4800) * 4), 8U);
#line 340
  p2v_mailbox = ixgbe_read_reg(hw, (u32 )(((int )vf_number + 4800) * 4));
#line 341
  if ((p2v_mailbox & 8U) != 0U) {
#line 342
    return (0);
  } else {

  }
#line 344
  return (-100);
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_write_mbx_pf(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 vf_number ) 
{ 
  s32 ret_val ;
  u16 i ;

  {
#line 363
  ret_val = ixgbe_obtain_mbx_lock_pf(hw, (int )vf_number);
#line 364
  if (ret_val != 0) {
#line 365
    return (ret_val);
  } else {

  }
#line 368
  ixgbe_check_for_msg_pf(hw, (int )vf_number);
#line 369
  ixgbe_check_for_ack_pf(hw, (int )vf_number);
#line 372
  i = 0U;
#line 372
  goto ldv_54408;
  ldv_54407: 
#line 373
  ixgbe_write_reg(hw, (u32 )(((int )vf_number + 1216) * 64 + ((int )i << 2)), *(msg + (unsigned long )i));
#line 372
  i = (u16 )((int )i + 1);
  ldv_54408: ;
#line 372
  if ((int )i < (int )size) {
#line 374
    goto ldv_54407;
  } else {

  }
#line 376
  ixgbe_write_reg(hw, (u32 )(((int )vf_number + 4800) * 4), 1U);
#line 379
  hw->mbx.stats.msgs_tx = hw->mbx.stats.msgs_tx + 1U;
#line 381
  return (0);
}
}
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_read_mbx_pf(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 vf_number ) 
{ 
  s32 ret_val ;
  u16 i ;

  {
#line 402
  ret_val = ixgbe_obtain_mbx_lock_pf(hw, (int )vf_number);
#line 403
  if (ret_val != 0) {
#line 404
    return (ret_val);
  } else {

  }
#line 407
  i = 0U;
#line 407
  goto ldv_54419;
  ldv_54418: 
#line 408
  *(msg + (unsigned long )i) = ixgbe_read_reg(hw, (u32 )(((int )vf_number + 1216) * 64 + ((int )i << 2)));
#line 407
  i = (u16 )((int )i + 1);
  ldv_54419: ;
#line 407
  if ((int )i < (int )size) {
#line 409
    goto ldv_54418;
  } else {

  }
#line 411
  ixgbe_write_reg(hw, (u32 )(((int )vf_number + 4800) * 4), 2U);
#line 414
  hw->mbx.stats.msgs_rx = hw->mbx.stats.msgs_rx + 1U;
#line 416
  return (0);
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
void ixgbe_init_mbx_params_pf(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mbx_info *mbx ;

  {
#line 428
  mbx = & hw->mbx;
#line 430
  if ((((unsigned int )hw->mac.type != 2U && (unsigned int )hw->mac.type != 4U) && (unsigned int )hw->mac.type != 5U) && (unsigned int )hw->mac.type != 3U) {
#line 434
    return;
  } else {

  }
#line 436
  mbx->timeout = 0U;
#line 437
  mbx->usec_delay = 0U;
#line 439
  mbx->stats.msgs_tx = 0U;
#line 440
  mbx->stats.msgs_rx = 0U;
#line 441
  mbx->stats.reqs = 0U;
#line 442
  mbx->stats.acks = 0U;
#line 443
  mbx->stats.rsts = 0U;
#line 445
  mbx->size = 16U;
#line 446
  return;
}
}
#line 449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
struct ixgbe_mbx_operations mbx_ops_generic  = 
#line 449
     {0, & ixgbe_read_mbx_pf, & ixgbe_write_mbx_pf, & ixgbe_read_posted_mbx, & ixgbe_write_posted_mbx,
    & ixgbe_check_for_msg_pf, & ixgbe_check_for_ack_pf, & ixgbe_check_for_rst_pf};
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
extern int ldv_release_26(void) ;
#line 332
extern int ldv_probe_26(void) ;
#line 335 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
void ldv_initialize_ixgbe_mbx_operations_26(void) 
{ 
  void *tmp ;

  {
#line 336
  tmp = ldv_init_zalloc(1696UL);
#line 336
  mbx_ops_generic_group0 = (struct ixgbe_hw *)tmp;
#line 337
  return;
}
}
#line 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
void ldv_main_exported_26(void) 
{ 
  u16 ldvarg83 ;
  u32 *ldvarg96 ;
  void *tmp ;
  u16 ldvarg89 ;
  u16 ldvarg92 ;
  u16 ldvarg97 ;
  u32 *ldvarg93 ;
  void *tmp___0 ;
  u16 ldvarg86 ;
  u32 *ldvarg87 ;
  void *tmp___1 ;
  u32 *ldvarg90 ;
  void *tmp___2 ;
  u16 ldvarg88 ;
  u16 ldvarg91 ;
  u16 ldvarg94 ;
  u16 ldvarg84 ;
  u16 ldvarg85 ;
  u16 ldvarg95 ;
  int tmp___3 ;

  {
#line 341
  tmp = ldv_init_zalloc(4UL);
#line 341
  ldvarg96 = (u32 *)tmp;
#line 345
  tmp___0 = ldv_init_zalloc(4UL);
#line 345
  ldvarg93 = (u32 *)tmp___0;
#line 347
  tmp___1 = ldv_init_zalloc(4UL);
#line 347
  ldvarg87 = (u32 *)tmp___1;
#line 348
  tmp___2 = ldv_init_zalloc(4UL);
#line 348
  ldvarg90 = (u32 *)tmp___2;
#line 340
  ldv_memset((void *)(& ldvarg83), 0, 2UL);
#line 342
  ldv_memset((void *)(& ldvarg89), 0, 2UL);
#line 343
  ldv_memset((void *)(& ldvarg92), 0, 2UL);
#line 344
  ldv_memset((void *)(& ldvarg97), 0, 2UL);
#line 346
  ldv_memset((void *)(& ldvarg86), 0, 2UL);
#line 349
  ldv_memset((void *)(& ldvarg88), 0, 2UL);
#line 350
  ldv_memset((void *)(& ldvarg91), 0, 2UL);
#line 351
  ldv_memset((void *)(& ldvarg94), 0, 2UL);
#line 352
  ldv_memset((void *)(& ldvarg84), 0, 2UL);
#line 353
  ldv_memset((void *)(& ldvarg85), 0, 2UL);
#line 354
  ldv_memset((void *)(& ldvarg95), 0, 2UL);
#line 356
  tmp___3 = __VERIFIER_nondet_int();
#line 356
  switch (tmp___3) {
  case 0: ;
#line 359
  if (ldv_state_variable_26 == 1) {
#line 361
    ixgbe_check_for_msg_pf(mbx_ops_generic_group0, (int )ldvarg97);
#line 363
    ldv_state_variable_26 = 1;
  } else {

  }
#line 366
  if (ldv_state_variable_26 == 2) {
#line 368
    ixgbe_check_for_msg_pf(mbx_ops_generic_group0, (int )ldvarg97);
#line 370
    ldv_state_variable_26 = 2;
  } else {

  }
#line 373
  goto ldv_54452;
  case 1: ;
#line 376
  if (ldv_state_variable_26 == 2) {
#line 378
    ixgbe_write_posted_mbx(mbx_ops_generic_group0, ldvarg96, (int )ldvarg95, (int )ldvarg94);
#line 380
    ldv_state_variable_26 = 2;
  } else {

  }
#line 383
  goto ldv_54452;
  case 2: ;
#line 386
  if (ldv_state_variable_26 == 2) {
#line 388
    ixgbe_read_posted_mbx(mbx_ops_generic_group0, ldvarg93, (int )ldvarg92, (int )ldvarg91);
#line 390
    ldv_state_variable_26 = 2;
  } else {

  }
#line 393
  goto ldv_54452;
  case 3: ;
#line 396
  if (ldv_state_variable_26 == 1) {
#line 398
    ixgbe_write_mbx_pf(mbx_ops_generic_group0, ldvarg90, (int )ldvarg89, (int )ldvarg88);
#line 400
    ldv_state_variable_26 = 1;
  } else {

  }
#line 403
  if (ldv_state_variable_26 == 2) {
#line 405
    ixgbe_write_mbx_pf(mbx_ops_generic_group0, ldvarg90, (int )ldvarg89, (int )ldvarg88);
#line 407
    ldv_state_variable_26 = 2;
  } else {

  }
#line 410
  goto ldv_54452;
  case 4: ;
#line 413
  if (ldv_state_variable_26 == 1) {
#line 415
    ixgbe_read_mbx_pf(mbx_ops_generic_group0, ldvarg87, (int )ldvarg86, (int )ldvarg85);
#line 417
    ldv_state_variable_26 = 1;
  } else {

  }
#line 420
  if (ldv_state_variable_26 == 2) {
#line 422
    ixgbe_read_mbx_pf(mbx_ops_generic_group0, ldvarg87, (int )ldvarg86, (int )ldvarg85);
#line 424
    ldv_state_variable_26 = 2;
  } else {

  }
#line 427
  goto ldv_54452;
  case 5: ;
#line 430
  if (ldv_state_variable_26 == 1) {
#line 432
    ixgbe_check_for_rst_pf(mbx_ops_generic_group0, (int )ldvarg84);
#line 434
    ldv_state_variable_26 = 1;
  } else {

  }
#line 437
  if (ldv_state_variable_26 == 2) {
#line 439
    ixgbe_check_for_rst_pf(mbx_ops_generic_group0, (int )ldvarg84);
#line 441
    ldv_state_variable_26 = 2;
  } else {

  }
#line 444
  goto ldv_54452;
  case 6: ;
#line 447
  if (ldv_state_variable_26 == 1) {
#line 449
    ixgbe_check_for_ack_pf(mbx_ops_generic_group0, (int )ldvarg83);
#line 451
    ldv_state_variable_26 = 1;
  } else {

  }
#line 454
  if (ldv_state_variable_26 == 2) {
#line 456
    ixgbe_check_for_ack_pf(mbx_ops_generic_group0, (int )ldvarg83);
#line 458
    ldv_state_variable_26 = 2;
  } else {

  }
#line 461
  goto ldv_54452;
  case 7: ;
#line 464
  if (ldv_state_variable_26 == 2) {
#line 466
    ldv_release_26();
#line 468
    ldv_state_variable_26 = 1;
#line 469
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 472
  goto ldv_54452;
  case 8: ;
#line 475
  if (ldv_state_variable_26 == 1) {
#line 477
    ldv_probe_26();
#line 479
    ldv_state_variable_26 = 2;
#line 480
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 483
  goto ldv_54452;
  default: 
#line 484
  ldv_stop();
  }
  ldv_54452: ;
#line 488
  return;
}
}
#line 513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
bool ldv_queue_work_on_247(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 517
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 517
  ldv_func_res = tmp;
#line 519
  activate_work_9(ldv_func_arg3, 2);
#line 521
  return (ldv_func_res);
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
bool ldv_queue_delayed_work_on_248(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 528
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 528
  ldv_func_res = tmp;
#line 530
  activate_work_9(& ldv_func_arg3->work, 2);
#line 532
  return (ldv_func_res);
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
bool ldv_queue_work_on_249(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 539
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 539
  ldv_func_res = tmp;
#line 541
  activate_work_9(ldv_func_arg3, 2);
#line 543
  return (ldv_func_res);
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
void ldv_flush_workqueue_250(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 549
  flush_workqueue(ldv_func_arg1);
#line 551
  call_and_disable_all_9(2);
#line 552
  return;
}
}
#line 554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
bool ldv_queue_delayed_work_on_251(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 558
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 558
  ldv_func_res = tmp;
#line 560
  activate_work_9(& ldv_func_arg3->work, 2);
#line 562
  return (ldv_func_res);
}
}
#line 565 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
void ldv_mutex_lock_252(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 568
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 570
  mutex_lock(ldv_func_arg1);
#line 571
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
void ldv_mutex_unlock_253(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 576
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 578
  mutex_unlock(ldv_func_arg1);
#line 579
  return;
}
}
#line 581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
void ldv_mutex_lock_254(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 584
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 586
  mutex_lock(ldv_func_arg1);
#line 587
  return;
}
}
#line 589 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
int ldv_mutex_trylock_255(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 593
  tmp = mutex_trylock(ldv_func_arg1);
#line 593
  ldv_func_res = tmp;
#line 595
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 595
  return (tmp___0);
#line 597
  return (ldv_func_res);
}
}
#line 600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
void ldv_mutex_unlock_256(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 603
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 605
  mutex_unlock(ldv_func_arg1);
#line 606
  return;
}
}
#line 608 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
void ldv_mutex_unlock_257(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 611
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 613
  mutex_unlock(ldv_func_arg1);
#line 614
  return;
}
}
#line 616 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.o.c.prepared"
void ldv_mutex_lock_258(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 619
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 621
  mutex_lock(ldv_func_arg1);
#line 622
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_283(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_281(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_284(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_285(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_mutex_lock_280(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_282(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_286(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_275(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_277(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_276(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_279(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_278(struct workqueue_struct *ldv_func_arg1 ) ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.h"
s32 ixgbe_get_invariants_X540(struct ixgbe_hw *hw ) ;
#line 28
s32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw , ixgbe_link_speed speed , bool autoneg_wait_to_complete ) ;
#line 30
s32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw ) ;
#line 31
s32 ixgbe_start_hw_X540(struct ixgbe_hw *hw ) ;
#line 32
enum ixgbe_media_type ixgbe_get_media_type_X540(struct ixgbe_hw *hw ) ;
#line 35
s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw , u32 index ) ;
#line 36
s32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw , u32 index ) ;
#line 37
s32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw , u32 mask ) ;
#line 38
void ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw , u32 mask ) ;
#line 39
s32 ixgbe_init_eeprom_params_X540(struct ixgbe_hw *hw ) ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw ) ;
#line 45
static s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw ) ;
#line 46
static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw ) ;
#line 47
static void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw ) ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
enum ixgbe_media_type ixgbe_get_media_type_X540(struct ixgbe_hw *hw ) 
{ 


  {
#line 51
  return (4);
}
}
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_get_invariants_X540(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mac_info *mac ;

  {
#line 56
  mac = & hw->mac;
#line 58
  mac->mcft_size = 128U;
#line 59
  mac->vft_size = 128U;
#line 60
  mac->num_rar_entries = 128U;
#line 61
  mac->rx_pb_size = 384U;
#line 62
  mac->max_rx_queues = 128U;
#line 63
  mac->max_tx_queues = 128U;
#line 64
  mac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);
#line 66
  return (0);
}
}
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw , ixgbe_link_speed speed , bool autoneg_wait_to_complete ) 
{ 
  s32 tmp ;

  {
#line 78
  tmp = (*(hw->phy.ops.setup_link_speed))(hw, speed, (int )autoneg_wait_to_complete);
#line 78
  return (tmp);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u32 ctrl ;
  u32 i ;
  u32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  bool tmp___1 ;

  {
#line 96
  status = (*(hw->mac.ops.stop_adapter))(hw);
#line 97
  if (status != 0) {
#line 98
    return (status);
  } else {

  }
#line 101
  ixgbe_clear_tx_pending(hw);
  mac_reset_top: 
#line 104
  ctrl = 67108864U;
#line 105
  tmp = ixgbe_read_reg(hw, 0U);
#line 105
  ctrl = tmp | ctrl;
#line 106
  ixgbe_write_reg(hw, 0U, ctrl);
#line 107
  ixgbe_read_reg(hw, 8U);
#line 110
  i = 0U;
#line 110
  goto ldv_54454;
  ldv_54453: 
#line 111
  __const_udelay(4295UL);
#line 112
  ctrl = ixgbe_read_reg(hw, 0U);
#line 113
  if ((ctrl & 67108872U) == 0U) {
#line 114
    goto ldv_54452;
  } else {

  }
#line 110
  i = i + 1U;
  ldv_54454: ;
#line 110
  if (i <= 9U) {
#line 112
    goto ldv_54453;
  } else {

  }
  ldv_54452: ;
#line 117
  if ((ctrl & 67108872U) != 0U) {
#line 118
    status = -15;
#line 119
    descriptor.modname = "ixgbe";
#line 119
    descriptor.function = "ixgbe_reset_hw_X540";
#line 119
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 119
    descriptor.format = "Reset polling failed to complete.\n";
#line 119
    descriptor.lineno = 119U;
#line 119
    descriptor.flags = 0U;
#line 119
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 119
    if (tmp___0 != 0L) {
#line 119
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Reset polling failed to complete.\n");
    } else {

    }
  } else {

  }
#line 121
  msleep(100U);
#line 128
  if ((int )hw->mac.flags & 1) {
#line 129
    hw->mac.flags = (unsigned int )hw->mac.flags & 254U;
#line 130
    goto mac_reset_top;
  } else {

  }
#line 134
  ixgbe_write_reg(hw, 15360U, 393216U);
#line 137
  (*(hw->mac.ops.get_mac_addr))(hw, (u8 *)(& hw->mac.perm_addr));
#line 144
  hw->mac.num_rar_entries = 128U;
#line 145
  (*(hw->mac.ops.init_rx_addrs))(hw);
#line 148
  (*(hw->mac.ops.get_san_mac_addr))(hw, (u8 *)(& hw->mac.san_addr));
#line 151
  tmp___1 = is_valid_ether_addr((u8 const   *)(& hw->mac.san_addr));
#line 151
  if ((int )tmp___1) {
#line 152
    (*(hw->mac.ops.set_rar))(hw, hw->mac.num_rar_entries - 1U, (u8 *)(& hw->mac.san_addr),
                             0U, 2147483648U);
#line 156
    hw->mac.san_mac_rar_index = (unsigned int )((u8 )hw->mac.num_rar_entries) - 1U;
#line 159
    hw->mac.num_rar_entries = hw->mac.num_rar_entries - 1U;
  } else {

  }
#line 163
  (*(hw->mac.ops.get_wwn_prefix))(hw, & hw->mac.wwnn_prefix, & hw->mac.wwpn_prefix);
#line 166
  return (status);
}
}
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_start_hw_X540(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;
  s32 tmp ;

  {
#line 181
  ret_val = ixgbe_start_hw_generic(hw);
#line 182
  if (ret_val != 0) {
#line 183
    return (ret_val);
  } else {

  }
#line 185
  tmp = ixgbe_start_hw_gen2(hw);
#line 185
  return (tmp);
}
}
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_init_eeprom_params_X540(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_eeprom_info *eeprom ;
  u32 eec ;
  u16 eeprom_size ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 197
  eeprom = & hw->eeprom;
#line 201
  if ((unsigned int )eeprom->type == 0U) {
#line 202
    eeprom->semaphore_delay = 10U;
#line 203
    eeprom->type = 2;
#line 205
    eec = ixgbe_read_reg(hw, *(hw->mvals));
#line 206
    eeprom_size = (unsigned short )((eec & 30720U) >> 11);
#line 208
    eeprom->word_size = (u16 )(1 << ((int )eeprom_size + 6));
#line 211
    descriptor.modname = "ixgbe";
#line 211
    descriptor.function = "ixgbe_init_eeprom_params_X540";
#line 211
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 211
    descriptor.format = "Eeprom params: type = %d, size = %d\n";
#line 211
    descriptor.lineno = 212U;
#line 211
    descriptor.flags = 0U;
#line 211
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 211
    if (tmp != 0L) {
#line 211
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Eeprom params: type = %d, size = %d\n", (unsigned int )eeprom->type,
                           (int )eeprom->word_size);
    } else {

    }
  } else {

  }
#line 215
  return (0);
}
}
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_read_eerd_X540(struct ixgbe_hw *hw , u16 offset , u16 *data ) 
{ 
  s32 status ;
  s32 tmp ;

  {
#line 230
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1U);
#line 230
  if (tmp != 0) {
#line 231
    return (-16);
  } else {

  }
#line 233
  status = ixgbe_read_eerd_generic(hw, (int )offset, data);
#line 235
  (*(hw->mac.ops.release_swfw_sync))(hw, 1U);
#line 236
  return (status);
}
}
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_read_eerd_buffer_X540(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                       u16 *data ) 
{ 
  s32 status ;
  s32 tmp ;

  {
#line 253
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1U);
#line 253
  if (tmp != 0) {
#line 254
    return (-16);
  } else {

  }
#line 256
  status = ixgbe_read_eerd_buffer_generic(hw, (int )offset, (int )words, data);
#line 258
  (*(hw->mac.ops.release_swfw_sync))(hw, 1U);
#line 259
  return (status);
}
}
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_write_eewr_X540(struct ixgbe_hw *hw , u16 offset , u16 data ) 
{ 
  s32 status ;
  s32 tmp ;

  {
#line 274
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1U);
#line 274
  if (tmp != 0) {
#line 275
    return (-16);
  } else {

  }
#line 277
  status = ixgbe_write_eewr_generic(hw, (int )offset, (int )data);
#line 279
  (*(hw->mac.ops.release_swfw_sync))(hw, 1U);
#line 280
  return (status);
}
}
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_write_eewr_buffer_X540(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                        u16 *data ) 
{ 
  s32 status ;
  s32 tmp ;

  {
#line 297
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1U);
#line 297
  if (tmp != 0) {
#line 298
    return (-16);
  } else {

  }
#line 300
  status = ixgbe_write_eewr_buffer_generic(hw, (int )offset, (int )words, data);
#line 302
  (*(hw->mac.ops.release_swfw_sync))(hw, 1U);
#line 303
  return (status);
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_calc_eeprom_checksum_X540(struct ixgbe_hw *hw ) 
{ 
  u16 i ;
  u16 j ;
  u16 checksum ;
  u16 length ;
  u16 pointer ;
  u16 word ;
  u16 checksum_last_word ;
  u16 ptr_start ;
  struct _ddebug descriptor ;
  long tmp ;
  s32 tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  s32 tmp___2 ;
  struct _ddebug descriptor___1 ;
  long tmp___3 ;
  s32 tmp___4 ;
  struct _ddebug descriptor___2 ;
  long tmp___5 ;
  s32 tmp___6 ;

  {
#line 318
  checksum = 0U;
#line 319
  length = 0U;
#line 320
  pointer = 0U;
#line 321
  word = 0U;
#line 322
  checksum_last_word = 63U;
#line 323
  ptr_start = 3U;
#line 332
  i = 0U;
#line 332
  goto ldv_54509;
  ldv_54508: 
#line 333
  tmp___0 = ixgbe_read_eerd_generic(hw, (int )i, & word);
#line 333
  if (tmp___0 != 0) {
#line 334
    descriptor.modname = "ixgbe";
#line 334
    descriptor.function = "ixgbe_calc_eeprom_checksum_X540";
#line 334
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 334
    descriptor.format = "EEPROM read failed\n";
#line 334
    descriptor.lineno = 334U;
#line 334
    descriptor.flags = 0U;
#line 334
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 334
    if (tmp != 0L) {
#line 334
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 335
    return (-1);
  } else {

  }
#line 337
  checksum = (int )checksum + (int )word;
#line 332
  i = (u16 )((int )i + 1);
  ldv_54509: ;
#line 332
  if ((int )i < (int )checksum_last_word) {
#line 334
    goto ldv_54508;
  } else {

  }
#line 344
  i = ptr_start;
#line 344
  goto ldv_54520;
  ldv_54519: ;
#line 345
  if ((unsigned int )i == 4U || (unsigned int )i == 5U) {
#line 346
    goto ldv_54511;
  } else {

  }
#line 348
  tmp___2 = ixgbe_read_eerd_generic(hw, (int )i, & pointer);
#line 348
  if (tmp___2 != 0) {
#line 349
    descriptor___0.modname = "ixgbe";
#line 349
    descriptor___0.function = "ixgbe_calc_eeprom_checksum_X540";
#line 349
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 349
    descriptor___0.format = "EEPROM read failed\n";
#line 349
    descriptor___0.lineno = 349U;
#line 349
    descriptor___0.flags = 0U;
#line 349
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 349
    if (tmp___1 != 0L) {
#line 349
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 350
    goto ldv_54513;
  } else {

  }
#line 354
  if (((unsigned int )pointer == 65535U || (unsigned int )pointer == 0U) || (int )hw->eeprom.word_size <= (int )pointer) {
#line 356
    goto ldv_54511;
  } else {

  }
#line 358
  tmp___4 = ixgbe_read_eerd_generic(hw, (int )pointer, & length);
#line 358
  if (tmp___4 != 0) {
#line 359
    descriptor___1.modname = "ixgbe";
#line 359
    descriptor___1.function = "ixgbe_calc_eeprom_checksum_X540";
#line 359
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 359
    descriptor___1.format = "EEPROM read failed\n";
#line 359
    descriptor___1.lineno = 359U;
#line 359
    descriptor___1.flags = 0U;
#line 359
    tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 359
    if (tmp___3 != 0L) {
#line 359
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 360
    return (-1);
  } else {

  }
#line 365
  if (((unsigned int )length == 65535U || (unsigned int )length == 0U) || (int )pointer + (int )length >= (int )hw->eeprom.word_size) {
#line 367
    goto ldv_54511;
  } else {

  }
#line 369
  j = (unsigned int )pointer + 1U;
#line 369
  goto ldv_54517;
  ldv_54516: 
#line 370
  tmp___6 = ixgbe_read_eerd_generic(hw, (int )j, & word);
#line 370
  if (tmp___6 != 0) {
#line 371
    descriptor___2.modname = "ixgbe";
#line 371
    descriptor___2.function = "ixgbe_calc_eeprom_checksum_X540";
#line 371
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 371
    descriptor___2.format = "EEPROM read failed\n";
#line 371
    descriptor___2.lineno = 371U;
#line 371
    descriptor___2.flags = 0U;
#line 371
    tmp___5 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 371
    if (tmp___5 != 0L) {
#line 371
      __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 372
    return (-1);
  } else {

  }
#line 374
  checksum = (int )checksum + (int )word;
#line 369
  j = (u16 )((int )j + 1);
  ldv_54517: ;
#line 369
  if ((int )j <= (int )pointer + (int )length) {
#line 371
    goto ldv_54516;
  } else {

  }

  ldv_54511: 
#line 344
  i = (u16 )((int )i + 1);
  ldv_54520: ;
#line 344
  if ((unsigned int )i <= 14U) {
#line 346
    goto ldv_54519;
  } else {

  }
  ldv_54513: 
#line 378
  checksum = 47802U - (unsigned int )checksum;
#line 380
  return ((s32 )checksum);
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_validate_eeprom_checksum_X540(struct ixgbe_hw *hw , u16 *checksum_val ) 
{ 
  s32 status ;
  u16 checksum ;
  u16 read_checksum ;
  struct _ddebug descriptor ;
  long tmp ;
  s32 tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;

  {
#line 396
  read_checksum = 0U;
#line 402
  status = (*(hw->eeprom.ops.read))(hw, 0, & checksum);
#line 403
  if (status != 0) {
#line 404
    descriptor.modname = "ixgbe";
#line 404
    descriptor.function = "ixgbe_validate_eeprom_checksum_X540";
#line 404
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 404
    descriptor.format = "EEPROM read failed\n";
#line 404
    descriptor.lineno = 404U;
#line 404
    descriptor.flags = 0U;
#line 404
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 404
    if (tmp != 0L) {
#line 404
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 405
    return (status);
  } else {

  }
#line 408
  tmp___0 = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1U);
#line 408
  if (tmp___0 != 0) {
#line 409
    return (-16);
  } else {

  }
#line 411
  status = (*(hw->eeprom.ops.calc_checksum))(hw);
#line 412
  if (status < 0) {
#line 413
    goto out;
  } else {

  }
#line 415
  checksum = (unsigned short )status;
#line 420
  status = ixgbe_read_eerd_generic(hw, 63, & read_checksum);
#line 422
  if (status != 0) {
#line 423
    goto out;
  } else {

  }
#line 428
  if ((int )read_checksum != (int )checksum) {
#line 429
    descriptor___0.modname = "ixgbe";
#line 429
    descriptor___0.function = "ixgbe_validate_eeprom_checksum_X540";
#line 429
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 429
    descriptor___0.format = "Invalid EEPROM checksum";
#line 429
    descriptor___0.lineno = 429U;
#line 429
    descriptor___0.flags = 0U;
#line 429
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 429
    if (tmp___1 != 0L) {
#line 429
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Invalid EEPROM checksum");
    } else {

    }
#line 430
    status = -2;
  } else {

  }
#line 434
  if ((unsigned long )checksum_val != (unsigned long )((u16 *)0U)) {
#line 435
    *checksum_val = checksum;
  } else {

  }
  out: 
#line 438
  (*(hw->mac.ops.release_swfw_sync))(hw, 1U);
#line 440
  return (status);
}
}
#line 451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_update_eeprom_checksum_X540(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 checksum ;
  struct _ddebug descriptor ;
  long tmp ;
  s32 tmp___0 ;

  {
#line 460
  status = (*(hw->eeprom.ops.read))(hw, 0, & checksum);
#line 461
  if (status != 0) {
#line 462
    descriptor.modname = "ixgbe";
#line 462
    descriptor.function = "ixgbe_update_eeprom_checksum_X540";
#line 462
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 462
    descriptor.format = "EEPROM read failed\n";
#line 462
    descriptor.lineno = 462U;
#line 462
    descriptor.flags = 0U;
#line 462
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 462
    if (tmp != 0L) {
#line 462
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 463
    return (status);
  } else {

  }
#line 466
  tmp___0 = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1U);
#line 466
  if (tmp___0 != 0) {
#line 467
    return (-16);
  } else {

  }
#line 469
  status = (*(hw->eeprom.ops.calc_checksum))(hw);
#line 470
  if (status < 0) {
#line 471
    goto out;
  } else {

  }
#line 473
  checksum = (unsigned short )status;
#line 478
  status = ixgbe_write_eewr_generic(hw, 63, (int )checksum);
#line 479
  if (status != 0) {
#line 480
    goto out;
  } else {

  }
#line 482
  status = ixgbe_update_flash_X540(hw);
  out: 
#line 485
  (*(hw->mac.ops.release_swfw_sync))(hw, 1U);
#line 486
  return (status);
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw ) 
{ 
  u32 flup ;
  s32 status ;
  struct _ddebug descriptor ;
  long tmp ;
  u32 tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___3 ;
  long tmp___4 ;

  {
#line 501
  status = ixgbe_poll_flash_update_done_X540(hw);
#line 502
  if (status == -1) {
#line 503
    descriptor.modname = "ixgbe";
#line 503
    descriptor.function = "ixgbe_update_flash_X540";
#line 503
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 503
    descriptor.format = "Flash update time out\n";
#line 503
    descriptor.lineno = 503U;
#line 503
    descriptor.flags = 0U;
#line 503
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 503
    if (tmp != 0L) {
#line 503
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flash update time out\n");
    } else {

    }
#line 504
    return (status);
  } else {

  }
#line 507
  tmp___0 = ixgbe_read_reg(hw, *(hw->mvals));
#line 507
  flup = tmp___0 | 8388608U;
#line 508
  ixgbe_write_reg(hw, *(hw->mvals), flup);
#line 510
  status = ixgbe_poll_flash_update_done_X540(hw);
#line 511
  if (status == 0) {
#line 512
    descriptor___0.modname = "ixgbe";
#line 512
    descriptor___0.function = "ixgbe_update_flash_X540";
#line 512
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 512
    descriptor___0.format = "Flash update complete\n";
#line 512
    descriptor___0.lineno = 512U;
#line 512
    descriptor___0.flags = 0U;
#line 512
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 512
    if (tmp___1 != 0L) {
#line 512
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flash update complete\n");
    } else {

    }
  } else {
#line 514
    descriptor___1.modname = "ixgbe";
#line 514
    descriptor___1.function = "ixgbe_update_flash_X540";
#line 514
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 514
    descriptor___1.format = "Flash update time out\n";
#line 514
    descriptor___1.lineno = 514U;
#line 514
    descriptor___1.flags = 0U;
#line 514
    tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 514
    if (tmp___2 != 0L) {
#line 514
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flash update time out\n");
    } else {

    }
  }
#line 516
  if ((unsigned int )hw->revision_id == 0U) {
#line 517
    flup = ixgbe_read_reg(hw, *(hw->mvals));
#line 519
    if ((flup & 33554432U) != 0U) {
#line 520
      flup = flup | 8388608U;
#line 521
      ixgbe_write_reg(hw, *(hw->mvals), flup);
    } else {

    }
#line 524
    status = ixgbe_poll_flash_update_done_X540(hw);
#line 525
    if (status == 0) {
#line 526
      descriptor___2.modname = "ixgbe";
#line 526
      descriptor___2.function = "ixgbe_update_flash_X540";
#line 526
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 526
      descriptor___2.format = "Flash update complete\n";
#line 526
      descriptor___2.lineno = 526U;
#line 526
      descriptor___2.flags = 0U;
#line 526
      tmp___3 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 526
      if (tmp___3 != 0L) {
#line 526
        __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Flash update complete\n");
      } else {

      }
    } else {
#line 528
      descriptor___3.modname = "ixgbe";
#line 528
      descriptor___3.function = "ixgbe_update_flash_X540";
#line 528
      descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 528
      descriptor___3.format = "Flash update time out\n";
#line 528
      descriptor___3.lineno = 528U;
#line 528
      descriptor___3.flags = 0U;
#line 528
      tmp___4 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
#line 528
      if (tmp___4 != 0L) {
#line 528
        __dynamic_netdev_dbg(& descriptor___3, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Flash update time out\n");
      } else {

      }
    }
  } else {

  }
#line 531
  return (status);
}
}
#line 541 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw ) 
{ 
  u32 i ;
  u32 reg ;

  {
#line 546
  i = 0U;
#line 546
  goto ldv_54557;
  ldv_54556: 
#line 547
  reg = ixgbe_read_reg(hw, *(hw->mvals));
#line 548
  if ((reg & 67108864U) != 0U) {
#line 549
    return (0);
  } else {

  }
#line 550
  __const_udelay(21475UL);
#line 546
  i = i + 1U;
  ldv_54557: ;
#line 546
  if (i <= 19999U) {
#line 548
    goto ldv_54556;
  } else {

  }

#line 552
  return (-1);
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw , u32 mask ) 
{ 
  u32 swfw_sync ;
  u32 swmask ;
  u32 fwmask ;
  u32 hwmask ;
  u32 timeout ;
  u32 i ;
  s32 tmp ;
  s32 tmp___0 ;

  {
#line 566
  swmask = mask;
#line 567
  fwmask = mask << 5;
#line 568
  hwmask = 0U;
#line 569
  timeout = 200U;
#line 572
  if (swmask == 1U) {
#line 573
    hwmask = 16U;
  } else {

  }
#line 575
  i = 0U;
#line 575
  goto ldv_54571;
  ldv_54570: 
#line 580
  tmp = ixgbe_get_swfw_sync_semaphore(hw);
#line 580
  if (tmp != 0) {
#line 581
    return (-16);
  } else {

  }
#line 583
  swfw_sync = ixgbe_read_reg(hw, *(hw->mvals + 6UL));
#line 584
  if ((((fwmask | swmask) | hwmask) & swfw_sync) == 0U) {
#line 585
    swfw_sync = swfw_sync | swmask;
#line 586
    ixgbe_write_reg(hw, *(hw->mvals + 6UL), swfw_sync);
#line 587
    ixgbe_release_swfw_sync_semaphore(hw);
#line 588
    goto ldv_54569;
  } else {
#line 596
    ixgbe_release_swfw_sync_semaphore(hw);
#line 597
    usleep_range(5000UL, 10000UL);
  }
#line 575
  i = i + 1U;
  ldv_54571: ;
#line 575
  if (i < timeout) {
#line 577
    goto ldv_54570;
  } else {

  }
  ldv_54569: ;
#line 607
  if (i >= timeout) {
#line 608
    swfw_sync = ixgbe_read_reg(hw, *(hw->mvals + 6UL));
#line 609
    if (((fwmask | hwmask) & swfw_sync) != 0U) {
#line 610
      tmp___0 = ixgbe_get_swfw_sync_semaphore(hw);
#line 610
      if (tmp___0 != 0) {
#line 611
        return (-16);
      } else {

      }
#line 613
      swfw_sync = swfw_sync | swmask;
#line 614
      ixgbe_write_reg(hw, *(hw->mvals + 6UL), swfw_sync);
#line 615
      ixgbe_release_swfw_sync_semaphore(hw);
    } else {

    }
  } else {

  }
#line 619
  usleep_range(5000UL, 10000UL);
#line 620
  return (0);
}
}
#line 631 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
void ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw , u32 mask ) 
{ 
  u32 swfw_sync ;
  u32 swmask ;

  {
#line 634
  swmask = mask;
#line 636
  ixgbe_get_swfw_sync_semaphore(hw);
#line 638
  swfw_sync = ixgbe_read_reg(hw, *(hw->mvals + 6UL));
#line 639
  swfw_sync = ~ swmask & swfw_sync;
#line 640
  ixgbe_write_reg(hw, *(hw->mvals + 6UL), swfw_sync);
#line 642
  ixgbe_release_swfw_sync_semaphore(hw);
#line 643
  usleep_range(5000UL, 10000UL);
#line 644
  return;
}
}
#line 652 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw ) 
{ 
  u32 timeout ;
  u32 i ;
  u32 swsm ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 654
  timeout = 2000U;
#line 659
  i = 0U;
#line 659
  goto ldv_54586;
  ldv_54585: 
#line 663
  swsm = ixgbe_read_reg(hw, *(hw->mvals + 5UL));
#line 664
  if ((swsm & 1U) == 0U) {
#line 665
    goto ldv_54584;
  } else {

  }
#line 666
  usleep_range(50UL, 100UL);
#line 659
  i = i + 1U;
  ldv_54586: ;
#line 659
  if (i < timeout) {
#line 661
    goto ldv_54585;
  } else {

  }
  ldv_54584: ;
#line 669
  if (i == timeout) {
#line 670
    descriptor.modname = "ixgbe";
#line 670
    descriptor.function = "ixgbe_get_swfw_sync_semaphore";
#line 670
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 670
    descriptor.format = "Software semaphore SMBI between device drivers not granted.\n";
#line 670
    descriptor.lineno = 671U;
#line 670
    descriptor.flags = 0U;
#line 670
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 670
    if (tmp != 0L) {
#line 670
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Software semaphore SMBI between device drivers not granted.\n");
    } else {

    }
#line 672
    return (-1);
  } else {

  }
#line 676
  i = 0U;
#line 676
  goto ldv_54590;
  ldv_54589: 
#line 677
  swsm = ixgbe_read_reg(hw, *(hw->mvals + 6UL));
#line 678
  if ((int )swsm >= 0) {
#line 679
    return (0);
  } else {

  }
#line 681
  usleep_range(50UL, 100UL);
#line 676
  i = i + 1U;
  ldv_54590: ;
#line 676
  if (i < timeout) {
#line 678
    goto ldv_54589;
  } else {

  }

#line 684
  return (-1);
}
}
#line 693 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw ) 
{ 
  u32 swsm ;

  {
#line 699
  swsm = ixgbe_read_reg(hw, *(hw->mvals + 6UL));
#line 700
  swsm = swsm & 2147483647U;
#line 701
  ixgbe_write_reg(hw, *(hw->mvals + 6UL), swsm);
#line 703
  swsm = ixgbe_read_reg(hw, *(hw->mvals + 5UL));
#line 704
  swsm = swsm & 4294967294U;
#line 705
  ixgbe_write_reg(hw, *(hw->mvals + 5UL), swsm);
#line 707
  ixgbe_read_reg(hw, 8U);
#line 708
  return;
}
}
#line 718 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw , u32 index ) 
{ 
  u32 macc_reg ;
  u32 ledctl_reg ;
  ixgbe_link_speed speed ;
  bool link_up ;

  {
#line 730
  (*(hw->mac.ops.check_link))(hw, & speed, & link_up, 0);
#line 731
  if (! link_up) {
#line 732
    macc_reg = ixgbe_read_reg(hw, 17200U);
#line 733
    macc_reg = macc_reg | 458753U;
#line 734
    ixgbe_write_reg(hw, 17200U, macc_reg);
  } else {

  }
#line 737
  ledctl_reg = ixgbe_read_reg(hw, 512U);
#line 738
  ledctl_reg = (u32 )(~ (15 << (int )(index * 8U))) & ledctl_reg;
#line 739
  ledctl_reg = (u32 )(128 << (int )(index * 8U)) | ledctl_reg;
#line 740
  ixgbe_write_reg(hw, 512U, ledctl_reg);
#line 741
  ixgbe_read_reg(hw, 8U);
#line 743
  return (0);
}
}
#line 754 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw , u32 index ) 
{ 
  u32 macc_reg ;
  u32 ledctl_reg ;

  {
#line 760
  ledctl_reg = ixgbe_read_reg(hw, 512U);
#line 761
  ledctl_reg = (u32 )(~ (15 << (int )(index * 8U))) & ledctl_reg;
#line 762
  ledctl_reg = (u32 )(4 << (int )(index * 8U)) | ledctl_reg;
#line 763
  ledctl_reg = (u32 )(~ (128 << (int )(index * 8U))) & ledctl_reg;
#line 764
  ixgbe_write_reg(hw, 512U, ledctl_reg);
#line 767
  macc_reg = ixgbe_read_reg(hw, 17200U);
#line 768
  macc_reg = macc_reg & 4294508542U;
#line 769
  ixgbe_write_reg(hw, 17200U, macc_reg);
#line 770
  ixgbe_read_reg(hw, 8U);
#line 772
  return (0);
}
}
#line 774 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static struct ixgbe_mac_operations mac_ops_X540  = 
#line 774
     {& ixgbe_init_hw_generic, & ixgbe_reset_hw_X540, & ixgbe_start_hw_X540, & ixgbe_clear_hw_cntrs_generic,
    & ixgbe_get_media_type_X540, & ixgbe_get_mac_addr_generic, & ixgbe_get_san_mac_addr_generic,
    & ixgbe_get_device_caps_generic, & ixgbe_get_wwn_prefix_generic, & ixgbe_stop_adapter_generic,
    & ixgbe_get_bus_info_generic, & ixgbe_set_lan_id_multi_port_pcie, (s32 (*)(struct ixgbe_hw * ,
                                                                               u32  ,
                                                                               u8 * ))0,
    (s32 (*)(struct ixgbe_hw * , u32  , u8  ))0, (s32 (*)(struct ixgbe_hw * ))0, & ixgbe_disable_rx_buff_generic,
    & ixgbe_enable_rx_buff_generic, & ixgbe_enable_rx_dma_generic, & ixgbe_acquire_swfw_sync_X540,
    & ixgbe_release_swfw_sync_X540, & prot_autoc_read_generic, & prot_autoc_write_generic,
    0, 0, 0, 0, & ixgbe_setup_mac_link_X540, & ixgbe_check_mac_link_generic, & ixgbe_get_copper_link_capabilities_generic,
    & ixgbe_set_rxpba_generic, & ixgbe_led_on_generic, & ixgbe_led_off_generic, & ixgbe_blink_led_start_X540,
    & ixgbe_blink_led_stop_X540, & ixgbe_set_rar_generic, & ixgbe_clear_rar_generic,
    & ixgbe_set_vmdq_generic, & ixgbe_set_vmdq_san_mac_generic, & ixgbe_clear_vmdq_generic,
    & ixgbe_init_rx_addrs_generic, & ixgbe_update_mc_addr_list_generic, & ixgbe_enable_mc_generic,
    & ixgbe_disable_mc_generic, & ixgbe_clear_vfta_generic, & ixgbe_set_vfta_generic,
    & ixgbe_init_uta_tables_generic, & ixgbe_set_mac_anti_spoofing, & ixgbe_set_vlan_anti_spoofing,
    & ixgbe_fc_enable_generic, & ixgbe_set_fw_drv_ver_generic, (s32 (*)(struct ixgbe_hw * ))0,
    (s32 (*)(struct ixgbe_hw * ))0, & ixgbe_disable_rx_generic, & ixgbe_enable_rx_generic,
    0, 0, 0, 0, 0};
#line 827 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static struct ixgbe_eeprom_operations eeprom_ops_X540  = 
#line 827
     {& ixgbe_init_eeprom_params_X540, & ixgbe_read_eerd_X540, & ixgbe_read_eerd_buffer_X540,
    & ixgbe_write_eewr_X540, & ixgbe_write_eewr_buffer_X540, & ixgbe_validate_eeprom_checksum_X540,
    & ixgbe_update_eeprom_checksum_X540, & ixgbe_calc_eeprom_checksum_X540};
#line 838 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static struct ixgbe_phy_operations phy_ops_X540  = 
#line 838
     {& ixgbe_identify_phy_generic, & ixgbe_identify_sfp_module_generic, (s32 (*)(struct ixgbe_hw * ))0,
    (s32 (*)(struct ixgbe_hw * ))0, & ixgbe_read_phy_reg_generic, & ixgbe_write_phy_reg_generic,
    0, 0, & ixgbe_setup_phy_link_generic, 0, & ixgbe_setup_phy_link_speed_generic,
    0, & ixgbe_get_phy_firmware_version_generic, & ixgbe_read_i2c_byte_generic, & ixgbe_write_i2c_byte_generic,
    & ixgbe_read_i2c_sff8472_generic, & ixgbe_read_i2c_eeprom_generic, & ixgbe_write_i2c_eeprom_generic,
    0, 0, & ixgbe_tn_check_overtemp, & ixgbe_set_copper_phy_power, 0};
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static u32 const   ixgbe_mvals_X540[24U]  = 
#line 857
  {      65552U,      65564U,      66048U,      66064U, 
        65872U,      65856U,      65888U,      65864U, 
        2U,      4U,      8U,      33554432U, 
        67108864U,      134217728U,      69768U,      69772U, 
        1U,      2U,      4U,      8U, 
        0U,      0U,      0U,      40U};
#line 861 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
struct ixgbe_info ixgbe_X540_info  =    {3, & ixgbe_get_invariants_X540, & mac_ops_X540, & eeprom_ops_X540, & phy_ops_X540,
    & mbx_ops_generic, (u32 const   *)(& ixgbe_mvals_X540)};
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
extern int ldv_probe_25(void) ;
#line 332
extern int ldv_release_25(void) ;
#line 333
extern int ldv_release_24(void) ;
#line 334
extern int ldv_probe_24(void) ;
#line 335
extern int ldv_probe_23(void) ;
#line 336
extern int ldv_release_23(void) ;
#line 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_initialize_ixgbe_eeprom_operations_24(void) 
{ 
  void *tmp ;

  {
#line 340
  tmp = ldv_init_zalloc(1696UL);
#line 340
  eeprom_ops_X540_group0 = (struct ixgbe_hw *)tmp;
#line 341
  return;
}
}
#line 343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_initialize_ixgbe_phy_operations_23(void) 
{ 
  void *tmp ;

  {
#line 344
  tmp = ldv_init_zalloc(1696UL);
#line 344
  phy_ops_X540_group0 = (struct ixgbe_hw *)tmp;
#line 345
  return;
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_initialize_ixgbe_mac_operations_25(void) 
{ 
  void *tmp ;

  {
#line 348
  tmp = ldv_init_zalloc(1696UL);
#line 348
  mac_ops_X540_group0 = (struct ixgbe_hw *)tmp;
#line 349
  return;
}
}
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_main_exported_25(void) 
{ 
  u8 ldvarg205 ;
  u32 *ldvarg239 ;
  void *tmp ;
  u16 *ldvarg220 ;
  void *tmp___0 ;
  bool ldvarg227 ;
  u32 ldvarg229 ;
  bool ldvarg217 ;
  u32 ldvarg200 ;
  u32 ldvarg235 ;
  u32 ldvarg245 ;
  u32 ldvarg223 ;
  u32 ldvarg224 ;
  bool *ldvarg209 ;
  void *tmp___1 ;
  u32 ldvarg238 ;
  int ldvarg231 ;
  u32 ldvarg246 ;
  u8 ldvarg207 ;
  u32 ldvarg241 ;
  bool *ldvarg240 ;
  void *tmp___2 ;
  int ldvarg230 ;
  bool *ldvarg213 ;
  void *tmp___3 ;
  u8 ldvarg204 ;
  bool ldvarg232 ;
  u8 *ldvarg201 ;
  void *tmp___4 ;
  u8 ldvarg206 ;
  u32 ldvarg222 ;
  u16 *ldvarg199 ;
  void *tmp___5 ;
  u32 ldvarg211 ;
  struct net_device *ldvarg221 ;
  void *tmp___6 ;
  int ldvarg226 ;
  ixgbe_link_speed *ldvarg214 ;
  void *tmp___7 ;
  int ldvarg228 ;
  u32 ldvarg244 ;
  bool ldvarg208 ;
  u32 ldvarg234 ;
  ixgbe_link_speed *ldvarg210 ;
  void *tmp___8 ;
  u32 ldvarg216 ;
  u32 ldvarg243 ;
  u32 ldvarg236 ;
  u32 ldvarg233 ;
  ixgbe_link_speed ldvarg218 ;
  u8 *ldvarg215 ;
  void *tmp___9 ;
  u16 *ldvarg219 ;
  void *tmp___10 ;
  u32 ldvarg202 ;
  u8 *ldvarg212 ;
  void *tmp___11 ;
  u32 ldvarg225 ;
  u32 ldvarg203 ;
  bool ldvarg237 ;
  bool ldvarg242 ;
  int tmp___12 ;

  {
#line 353
  tmp = ldv_init_zalloc(4UL);
#line 353
  ldvarg239 = (u32 *)tmp;
#line 354
  tmp___0 = ldv_init_zalloc(2UL);
#line 354
  ldvarg220 = (u16 *)tmp___0;
#line 363
  tmp___1 = ldv_init_zalloc(1UL);
#line 363
  ldvarg209 = (bool *)tmp___1;
#line 369
  tmp___2 = ldv_init_zalloc(1UL);
#line 369
  ldvarg240 = (bool *)tmp___2;
#line 371
  tmp___3 = ldv_init_zalloc(1UL);
#line 371
  ldvarg213 = (bool *)tmp___3;
#line 374
  tmp___4 = ldv_init_zalloc(1UL);
#line 374
  ldvarg201 = (u8 *)tmp___4;
#line 377
  tmp___5 = ldv_init_zalloc(2UL);
#line 377
  ldvarg199 = (u16 *)tmp___5;
#line 379
  tmp___6 = ldv_init_zalloc(3008UL);
#line 379
  ldvarg221 = (struct net_device *)tmp___6;
#line 381
  tmp___7 = ldv_init_zalloc(4UL);
#line 381
  ldvarg214 = (ixgbe_link_speed *)tmp___7;
#line 386
  tmp___8 = ldv_init_zalloc(4UL);
#line 386
  ldvarg210 = (ixgbe_link_speed *)tmp___8;
#line 392
  tmp___9 = ldv_init_zalloc(1UL);
#line 392
  ldvarg215 = (u8 *)tmp___9;
#line 393
  tmp___10 = ldv_init_zalloc(2UL);
#line 393
  ldvarg219 = (u16 *)tmp___10;
#line 395
  tmp___11 = ldv_init_zalloc(1UL);
#line 395
  ldvarg212 = (u8 *)tmp___11;
#line 352
  ldv_memset((void *)(& ldvarg205), 0, 1UL);
#line 355
  ldv_memset((void *)(& ldvarg227), 0, 1UL);
#line 356
  ldv_memset((void *)(& ldvarg229), 0, 4UL);
#line 357
  ldv_memset((void *)(& ldvarg217), 0, 1UL);
#line 358
  ldv_memset((void *)(& ldvarg200), 0, 4UL);
#line 359
  ldv_memset((void *)(& ldvarg235), 0, 4UL);
#line 360
  ldv_memset((void *)(& ldvarg245), 0, 4UL);
#line 361
  ldv_memset((void *)(& ldvarg223), 0, 4UL);
#line 362
  ldv_memset((void *)(& ldvarg224), 0, 4UL);
#line 364
  ldv_memset((void *)(& ldvarg238), 0, 4UL);
#line 365
  ldv_memset((void *)(& ldvarg231), 0, 4UL);
#line 366
  ldv_memset((void *)(& ldvarg246), 0, 4UL);
#line 367
  ldv_memset((void *)(& ldvarg207), 0, 1UL);
#line 368
  ldv_memset((void *)(& ldvarg241), 0, 4UL);
#line 370
  ldv_memset((void *)(& ldvarg230), 0, 4UL);
#line 372
  ldv_memset((void *)(& ldvarg204), 0, 1UL);
#line 373
  ldv_memset((void *)(& ldvarg232), 0, 1UL);
#line 375
  ldv_memset((void *)(& ldvarg206), 0, 1UL);
#line 376
  ldv_memset((void *)(& ldvarg222), 0, 4UL);
#line 378
  ldv_memset((void *)(& ldvarg211), 0, 4UL);
#line 380
  ldv_memset((void *)(& ldvarg226), 0, 4UL);
#line 382
  ldv_memset((void *)(& ldvarg228), 0, 4UL);
#line 383
  ldv_memset((void *)(& ldvarg244), 0, 4UL);
#line 384
  ldv_memset((void *)(& ldvarg208), 0, 1UL);
#line 385
  ldv_memset((void *)(& ldvarg234), 0, 4UL);
#line 387
  ldv_memset((void *)(& ldvarg216), 0, 4UL);
#line 388
  ldv_memset((void *)(& ldvarg243), 0, 4UL);
#line 389
  ldv_memset((void *)(& ldvarg236), 0, 4UL);
#line 390
  ldv_memset((void *)(& ldvarg233), 0, 4UL);
#line 391
  ldv_memset((void *)(& ldvarg218), 0, 4UL);
#line 394
  ldv_memset((void *)(& ldvarg202), 0, 4UL);
#line 396
  ldv_memset((void *)(& ldvarg225), 0, 4UL);
#line 397
  ldv_memset((void *)(& ldvarg203), 0, 4UL);
#line 398
  ldv_memset((void *)(& ldvarg237), 0, 1UL);
#line 399
  ldv_memset((void *)(& ldvarg242), 0, 1UL);
#line 401
  tmp___12 = __VERIFIER_nondet_int();
#line 401
  switch (tmp___12) {
  case 0: ;
#line 404
  if (ldv_state_variable_25 == 1) {
#line 406
    ixgbe_stop_adapter_generic(mac_ops_X540_group0);
#line 408
    ldv_state_variable_25 = 1;
  } else {

  }
#line 411
  if (ldv_state_variable_25 == 2) {
#line 413
    ixgbe_stop_adapter_generic(mac_ops_X540_group0);
#line 415
    ldv_state_variable_25 = 2;
  } else {

  }
#line 418
  goto ldv_54688;
  case 1: ;
#line 421
  if (ldv_state_variable_25 == 1) {
#line 423
    ixgbe_set_vmdq_san_mac_generic(mac_ops_X540_group0, ldvarg246);
#line 425
    ldv_state_variable_25 = 1;
  } else {

  }
#line 428
  if (ldv_state_variable_25 == 2) {
#line 430
    ixgbe_set_vmdq_san_mac_generic(mac_ops_X540_group0, ldvarg246);
#line 432
    ldv_state_variable_25 = 2;
  } else {

  }
#line 435
  goto ldv_54688;
  case 2: ;
#line 438
  if (ldv_state_variable_25 == 1) {
#line 440
    ixgbe_led_off_generic(mac_ops_X540_group0, ldvarg245);
#line 442
    ldv_state_variable_25 = 1;
  } else {

  }
#line 445
  if (ldv_state_variable_25 == 2) {
#line 447
    ixgbe_led_off_generic(mac_ops_X540_group0, ldvarg245);
#line 449
    ldv_state_variable_25 = 2;
  } else {

  }
#line 452
  goto ldv_54688;
  case 3: ;
#line 455
  if (ldv_state_variable_25 == 1) {
#line 457
    ixgbe_set_vfta_generic(mac_ops_X540_group0, ldvarg244, ldvarg243, (int )ldvarg242);
#line 459
    ldv_state_variable_25 = 1;
  } else {

  }
#line 462
  if (ldv_state_variable_25 == 2) {
#line 464
    ixgbe_set_vfta_generic(mac_ops_X540_group0, ldvarg244, ldvarg243, (int )ldvarg242);
#line 466
    ldv_state_variable_25 = 2;
  } else {

  }
#line 469
  goto ldv_54688;
  case 4: ;
#line 472
  if (ldv_state_variable_25 == 1) {
#line 474
    ixgbe_enable_rx_dma_generic(mac_ops_X540_group0, ldvarg241);
#line 476
    ldv_state_variable_25 = 1;
  } else {

  }
#line 479
  if (ldv_state_variable_25 == 2) {
#line 481
    ixgbe_enable_rx_dma_generic(mac_ops_X540_group0, ldvarg241);
#line 483
    ldv_state_variable_25 = 2;
  } else {

  }
#line 486
  goto ldv_54688;
  case 5: ;
#line 489
  if (ldv_state_variable_25 == 2) {
#line 491
    prot_autoc_read_generic(mac_ops_X540_group0, ldvarg240, ldvarg239);
#line 493
    ldv_state_variable_25 = 2;
  } else {

  }
#line 496
  goto ldv_54688;
  case 6: ;
#line 499
  if (ldv_state_variable_25 == 1) {
#line 501
    ixgbe_enable_rx_buff_generic(mac_ops_X540_group0);
#line 503
    ldv_state_variable_25 = 1;
  } else {

  }
#line 506
  if (ldv_state_variable_25 == 2) {
#line 508
    ixgbe_enable_rx_buff_generic(mac_ops_X540_group0);
#line 510
    ldv_state_variable_25 = 2;
  } else {

  }
#line 513
  goto ldv_54688;
  case 7: ;
#line 516
  if (ldv_state_variable_25 == 2) {
#line 518
    prot_autoc_write_generic(mac_ops_X540_group0, ldvarg238, (int )ldvarg237);
#line 520
    ldv_state_variable_25 = 2;
  } else {

  }
#line 523
  goto ldv_54688;
  case 8: ;
#line 526
  if (ldv_state_variable_25 == 1) {
#line 528
    ixgbe_led_on_generic(mac_ops_X540_group0, ldvarg236);
#line 530
    ldv_state_variable_25 = 1;
  } else {

  }
#line 533
  if (ldv_state_variable_25 == 2) {
#line 535
    ixgbe_led_on_generic(mac_ops_X540_group0, ldvarg236);
#line 537
    ldv_state_variable_25 = 2;
  } else {

  }
#line 540
  goto ldv_54688;
  case 9: ;
#line 543
  if (ldv_state_variable_25 == 1) {
#line 545
    ixgbe_blink_led_stop_X540(mac_ops_X540_group0, ldvarg235);
#line 547
    ldv_state_variable_25 = 1;
  } else {

  }
#line 550
  if (ldv_state_variable_25 == 2) {
#line 552
    ixgbe_blink_led_stop_X540(mac_ops_X540_group0, ldvarg235);
#line 554
    ldv_state_variable_25 = 2;
  } else {

  }
#line 557
  goto ldv_54688;
  case 10: ;
#line 560
  if (ldv_state_variable_25 == 1) {
#line 562
    ixgbe_clear_rar_generic(mac_ops_X540_group0, ldvarg234);
#line 564
    ldv_state_variable_25 = 1;
  } else {

  }
#line 567
  if (ldv_state_variable_25 == 2) {
#line 569
    ixgbe_clear_rar_generic(mac_ops_X540_group0, ldvarg234);
#line 571
    ldv_state_variable_25 = 2;
  } else {

  }
#line 574
  goto ldv_54688;
  case 11: ;
#line 577
  if (ldv_state_variable_25 == 1) {
#line 579
    ixgbe_enable_rx_generic(mac_ops_X540_group0);
#line 581
    ldv_state_variable_25 = 1;
  } else {

  }
#line 584
  if (ldv_state_variable_25 == 2) {
#line 586
    ixgbe_enable_rx_generic(mac_ops_X540_group0);
#line 588
    ldv_state_variable_25 = 2;
  } else {

  }
#line 591
  goto ldv_54688;
  case 12: ;
#line 594
  if (ldv_state_variable_25 == 1) {
#line 596
    ixgbe_get_bus_info_generic(mac_ops_X540_group0);
#line 598
    ldv_state_variable_25 = 1;
  } else {

  }
#line 601
  if (ldv_state_variable_25 == 2) {
#line 603
    ixgbe_get_bus_info_generic(mac_ops_X540_group0);
#line 605
    ldv_state_variable_25 = 2;
  } else {

  }
#line 608
  goto ldv_54688;
  case 13: ;
#line 611
  if (ldv_state_variable_25 == 1) {
#line 613
    ixgbe_blink_led_start_X540(mac_ops_X540_group0, ldvarg233);
#line 615
    ldv_state_variable_25 = 1;
  } else {

  }
#line 618
  if (ldv_state_variable_25 == 2) {
#line 620
    ixgbe_blink_led_start_X540(mac_ops_X540_group0, ldvarg233);
#line 622
    ldv_state_variable_25 = 2;
  } else {

  }
#line 625
  goto ldv_54688;
  case 14: ;
#line 628
  if (ldv_state_variable_25 == 1) {
#line 630
    ixgbe_disable_mc_generic(mac_ops_X540_group0);
#line 632
    ldv_state_variable_25 = 1;
  } else {

  }
#line 635
  if (ldv_state_variable_25 == 2) {
#line 637
    ixgbe_disable_mc_generic(mac_ops_X540_group0);
#line 639
    ldv_state_variable_25 = 2;
  } else {

  }
#line 642
  goto ldv_54688;
  case 15: ;
#line 645
  if (ldv_state_variable_25 == 1) {
#line 647
    ixgbe_set_vlan_anti_spoofing(mac_ops_X540_group0, (int )ldvarg232, ldvarg231);
#line 649
    ldv_state_variable_25 = 1;
  } else {

  }
#line 652
  if (ldv_state_variable_25 == 2) {
#line 654
    ixgbe_set_vlan_anti_spoofing(mac_ops_X540_group0, (int )ldvarg232, ldvarg231);
#line 656
    ldv_state_variable_25 = 2;
  } else {

  }
#line 659
  goto ldv_54688;
  case 16: ;
#line 662
  if (ldv_state_variable_25 == 1) {
#line 664
    ixgbe_set_rxpba_generic(mac_ops_X540_group0, ldvarg230, ldvarg229, ldvarg228);
#line 666
    ldv_state_variable_25 = 1;
  } else {

  }
#line 669
  if (ldv_state_variable_25 == 2) {
#line 671
    ixgbe_set_rxpba_generic(mac_ops_X540_group0, ldvarg230, ldvarg229, ldvarg228);
#line 673
    ldv_state_variable_25 = 2;
  } else {

  }
#line 676
  goto ldv_54688;
  case 17: ;
#line 679
  if (ldv_state_variable_25 == 1) {
#line 681
    ixgbe_init_uta_tables_generic(mac_ops_X540_group0);
#line 683
    ldv_state_variable_25 = 1;
  } else {

  }
#line 686
  if (ldv_state_variable_25 == 2) {
#line 688
    ixgbe_init_uta_tables_generic(mac_ops_X540_group0);
#line 690
    ldv_state_variable_25 = 2;
  } else {

  }
#line 693
  goto ldv_54688;
  case 18: ;
#line 696
  if (ldv_state_variable_25 == 1) {
#line 698
    ixgbe_set_mac_anti_spoofing(mac_ops_X540_group0, (int )ldvarg227, ldvarg226);
#line 700
    ldv_state_variable_25 = 1;
  } else {

  }
#line 703
  if (ldv_state_variable_25 == 2) {
#line 705
    ixgbe_set_mac_anti_spoofing(mac_ops_X540_group0, (int )ldvarg227, ldvarg226);
#line 707
    ldv_state_variable_25 = 2;
  } else {

  }
#line 710
  goto ldv_54688;
  case 19: ;
#line 713
  if (ldv_state_variable_25 == 1) {
#line 715
    ixgbe_set_vmdq_generic(mac_ops_X540_group0, ldvarg225, ldvarg224);
#line 717
    ldv_state_variable_25 = 1;
  } else {

  }
#line 720
  if (ldv_state_variable_25 == 2) {
#line 722
    ixgbe_set_vmdq_generic(mac_ops_X540_group0, ldvarg225, ldvarg224);
#line 724
    ldv_state_variable_25 = 2;
  } else {

  }
#line 727
  goto ldv_54688;
  case 20: ;
#line 730
  if (ldv_state_variable_25 == 1) {
#line 732
    ixgbe_clear_vmdq_generic(mac_ops_X540_group0, ldvarg223, ldvarg222);
#line 734
    ldv_state_variable_25 = 1;
  } else {

  }
#line 737
  if (ldv_state_variable_25 == 2) {
#line 739
    ixgbe_clear_vmdq_generic(mac_ops_X540_group0, ldvarg223, ldvarg222);
#line 741
    ldv_state_variable_25 = 2;
  } else {

  }
#line 744
  goto ldv_54688;
  case 21: ;
#line 747
  if (ldv_state_variable_25 == 1) {
#line 749
    ixgbe_clear_vfta_generic(mac_ops_X540_group0);
#line 751
    ldv_state_variable_25 = 1;
  } else {

  }
#line 754
  if (ldv_state_variable_25 == 2) {
#line 756
    ixgbe_clear_vfta_generic(mac_ops_X540_group0);
#line 758
    ldv_state_variable_25 = 2;
  } else {

  }
#line 761
  goto ldv_54688;
  case 22: ;
#line 764
  if (ldv_state_variable_25 == 1) {
#line 766
    ixgbe_get_media_type_X540(mac_ops_X540_group0);
#line 768
    ldv_state_variable_25 = 1;
  } else {

  }
#line 771
  if (ldv_state_variable_25 == 2) {
#line 773
    ixgbe_get_media_type_X540(mac_ops_X540_group0);
#line 775
    ldv_state_variable_25 = 2;
  } else {

  }
#line 778
  goto ldv_54688;
  case 23: ;
#line 781
  if (ldv_state_variable_25 == 1) {
#line 783
    ixgbe_update_mc_addr_list_generic(mac_ops_X540_group0, ldvarg221);
#line 785
    ldv_state_variable_25 = 1;
  } else {

  }
#line 788
  if (ldv_state_variable_25 == 2) {
#line 790
    ixgbe_update_mc_addr_list_generic(mac_ops_X540_group0, ldvarg221);
#line 792
    ldv_state_variable_25 = 2;
  } else {

  }
#line 795
  goto ldv_54688;
  case 24: ;
#line 798
  if (ldv_state_variable_25 == 1) {
#line 800
    ixgbe_init_rx_addrs_generic(mac_ops_X540_group0);
#line 802
    ldv_state_variable_25 = 1;
  } else {

  }
#line 805
  if (ldv_state_variable_25 == 2) {
#line 807
    ixgbe_init_rx_addrs_generic(mac_ops_X540_group0);
#line 809
    ldv_state_variable_25 = 2;
  } else {

  }
#line 812
  goto ldv_54688;
  case 25: ;
#line 815
  if (ldv_state_variable_25 == 1) {
#line 817
    ixgbe_fc_enable_generic(mac_ops_X540_group0);
#line 819
    ldv_state_variable_25 = 1;
  } else {

  }
#line 822
  if (ldv_state_variable_25 == 2) {
#line 824
    ixgbe_fc_enable_generic(mac_ops_X540_group0);
#line 826
    ldv_state_variable_25 = 2;
  } else {

  }
#line 829
  goto ldv_54688;
  case 26: ;
#line 832
  if (ldv_state_variable_25 == 1) {
#line 834
    ixgbe_get_wwn_prefix_generic(mac_ops_X540_group0, ldvarg220, ldvarg219);
#line 836
    ldv_state_variable_25 = 1;
  } else {

  }
#line 839
  if (ldv_state_variable_25 == 2) {
#line 841
    ixgbe_get_wwn_prefix_generic(mac_ops_X540_group0, ldvarg220, ldvarg219);
#line 843
    ldv_state_variable_25 = 2;
  } else {

  }
#line 846
  goto ldv_54688;
  case 27: ;
#line 849
  if (ldv_state_variable_25 == 1) {
#line 851
    ixgbe_clear_hw_cntrs_generic(mac_ops_X540_group0);
#line 853
    ldv_state_variable_25 = 1;
  } else {

  }
#line 856
  if (ldv_state_variable_25 == 2) {
#line 858
    ixgbe_clear_hw_cntrs_generic(mac_ops_X540_group0);
#line 860
    ldv_state_variable_25 = 2;
  } else {

  }
#line 863
  goto ldv_54688;
  case 28: ;
#line 866
  if (ldv_state_variable_25 == 1) {
#line 868
    ixgbe_setup_mac_link_X540(mac_ops_X540_group0, ldvarg218, (int )ldvarg217);
#line 870
    ldv_state_variable_25 = 1;
  } else {

  }
#line 873
  if (ldv_state_variable_25 == 2) {
#line 875
    ixgbe_setup_mac_link_X540(mac_ops_X540_group0, ldvarg218, (int )ldvarg217);
#line 877
    ldv_state_variable_25 = 2;
  } else {

  }
#line 880
  goto ldv_54688;
  case 29: ;
#line 883
  if (ldv_state_variable_25 == 1) {
#line 885
    ixgbe_disable_rx_generic(mac_ops_X540_group0);
#line 887
    ldv_state_variable_25 = 1;
  } else {

  }
#line 890
  if (ldv_state_variable_25 == 2) {
#line 892
    ixgbe_disable_rx_generic(mac_ops_X540_group0);
#line 894
    ldv_state_variable_25 = 2;
  } else {

  }
#line 897
  goto ldv_54688;
  case 30: ;
#line 900
  if (ldv_state_variable_25 == 1) {
#line 902
    ixgbe_set_lan_id_multi_port_pcie(mac_ops_X540_group0);
#line 904
    ldv_state_variable_25 = 1;
  } else {

  }
#line 907
  if (ldv_state_variable_25 == 2) {
#line 909
    ixgbe_set_lan_id_multi_port_pcie(mac_ops_X540_group0);
#line 911
    ldv_state_variable_25 = 2;
  } else {

  }
#line 914
  goto ldv_54688;
  case 31: ;
#line 917
  if (ldv_state_variable_25 == 1) {
#line 919
    ixgbe_acquire_swfw_sync_X540(mac_ops_X540_group0, ldvarg216);
#line 921
    ldv_state_variable_25 = 1;
  } else {

  }
#line 924
  if (ldv_state_variable_25 == 2) {
#line 926
    ixgbe_acquire_swfw_sync_X540(mac_ops_X540_group0, ldvarg216);
#line 928
    ldv_state_variable_25 = 2;
  } else {

  }
#line 931
  goto ldv_54688;
  case 32: ;
#line 934
  if (ldv_state_variable_25 == 1) {
#line 936
    ixgbe_start_hw_X540(mac_ops_X540_group0);
#line 938
    ldv_state_variable_25 = 1;
  } else {

  }
#line 941
  if (ldv_state_variable_25 == 2) {
#line 943
    ixgbe_start_hw_X540(mac_ops_X540_group0);
#line 945
    ldv_state_variable_25 = 2;
  } else {

  }
#line 948
  goto ldv_54688;
  case 33: ;
#line 951
  if (ldv_state_variable_25 == 1) {
#line 953
    ixgbe_enable_mc_generic(mac_ops_X540_group0);
#line 955
    ldv_state_variable_25 = 1;
  } else {

  }
#line 958
  if (ldv_state_variable_25 == 2) {
#line 960
    ixgbe_enable_mc_generic(mac_ops_X540_group0);
#line 962
    ldv_state_variable_25 = 2;
  } else {

  }
#line 965
  goto ldv_54688;
  case 34: ;
#line 968
  if (ldv_state_variable_25 == 1) {
#line 970
    ixgbe_get_mac_addr_generic(mac_ops_X540_group0, ldvarg215);
#line 972
    ldv_state_variable_25 = 1;
  } else {

  }
#line 975
  if (ldv_state_variable_25 == 2) {
#line 977
    ixgbe_get_mac_addr_generic(mac_ops_X540_group0, ldvarg215);
#line 979
    ldv_state_variable_25 = 2;
  } else {

  }
#line 982
  goto ldv_54688;
  case 35: ;
#line 985
  if (ldv_state_variable_25 == 1) {
#line 987
    ixgbe_get_copper_link_capabilities_generic(mac_ops_X540_group0, ldvarg214, ldvarg213);
#line 989
    ldv_state_variable_25 = 1;
  } else {

  }
#line 992
  if (ldv_state_variable_25 == 2) {
#line 994
    ixgbe_get_copper_link_capabilities_generic(mac_ops_X540_group0, ldvarg214, ldvarg213);
#line 996
    ldv_state_variable_25 = 2;
  } else {

  }
#line 999
  goto ldv_54688;
  case 36: ;
#line 1002
  if (ldv_state_variable_25 == 1) {
#line 1004
    ixgbe_get_san_mac_addr_generic(mac_ops_X540_group0, ldvarg212);
#line 1006
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1009
  if (ldv_state_variable_25 == 2) {
#line 1011
    ixgbe_get_san_mac_addr_generic(mac_ops_X540_group0, ldvarg212);
#line 1013
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1016
  goto ldv_54688;
  case 37: ;
#line 1019
  if (ldv_state_variable_25 == 1) {
#line 1021
    ixgbe_init_hw_generic(mac_ops_X540_group0);
#line 1023
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1026
  if (ldv_state_variable_25 == 2) {
#line 1028
    ixgbe_init_hw_generic(mac_ops_X540_group0);
#line 1030
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1033
  goto ldv_54688;
  case 38: ;
#line 1036
  if (ldv_state_variable_25 == 1) {
#line 1038
    ixgbe_reset_hw_X540(mac_ops_X540_group0);
#line 1040
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1043
  if (ldv_state_variable_25 == 2) {
#line 1045
    ixgbe_reset_hw_X540(mac_ops_X540_group0);
#line 1047
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1050
  goto ldv_54688;
  case 39: ;
#line 1053
  if (ldv_state_variable_25 == 1) {
#line 1055
    ixgbe_release_swfw_sync_X540(mac_ops_X540_group0, ldvarg211);
#line 1057
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1060
  if (ldv_state_variable_25 == 2) {
#line 1062
    ixgbe_release_swfw_sync_X540(mac_ops_X540_group0, ldvarg211);
#line 1064
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1067
  goto ldv_54688;
  case 40: ;
#line 1070
  if (ldv_state_variable_25 == 1) {
#line 1072
    ixgbe_check_mac_link_generic(mac_ops_X540_group0, ldvarg210, ldvarg209, (int )ldvarg208);
#line 1074
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1077
  if (ldv_state_variable_25 == 2) {
#line 1079
    ixgbe_check_mac_link_generic(mac_ops_X540_group0, ldvarg210, ldvarg209, (int )ldvarg208);
#line 1081
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1084
  goto ldv_54688;
  case 41: ;
#line 1087
  if (ldv_state_variable_25 == 1) {
#line 1089
    ixgbe_set_fw_drv_ver_generic(mac_ops_X540_group0, (int )ldvarg206, (int )ldvarg205,
                                 (int )ldvarg204, (int )ldvarg207);
#line 1091
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1094
  if (ldv_state_variable_25 == 2) {
#line 1096
    ixgbe_set_fw_drv_ver_generic(mac_ops_X540_group0, (int )ldvarg206, (int )ldvarg205,
                                 (int )ldvarg204, (int )ldvarg207);
#line 1098
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1101
  goto ldv_54688;
  case 42: ;
#line 1104
  if (ldv_state_variable_25 == 1) {
#line 1106
    ixgbe_set_rar_generic(mac_ops_X540_group0, ldvarg202, ldvarg201, ldvarg200, ldvarg203);
#line 1108
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1111
  if (ldv_state_variable_25 == 2) {
#line 1113
    ixgbe_set_rar_generic(mac_ops_X540_group0, ldvarg202, ldvarg201, ldvarg200, ldvarg203);
#line 1115
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1118
  goto ldv_54688;
  case 43: ;
#line 1121
  if (ldv_state_variable_25 == 1) {
#line 1123
    ixgbe_get_device_caps_generic(mac_ops_X540_group0, ldvarg199);
#line 1125
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1128
  if (ldv_state_variable_25 == 2) {
#line 1130
    ixgbe_get_device_caps_generic(mac_ops_X540_group0, ldvarg199);
#line 1132
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1135
  goto ldv_54688;
  case 44: ;
#line 1138
  if (ldv_state_variable_25 == 1) {
#line 1140
    ixgbe_disable_rx_buff_generic(mac_ops_X540_group0);
#line 1142
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1145
  if (ldv_state_variable_25 == 2) {
#line 1147
    ixgbe_disable_rx_buff_generic(mac_ops_X540_group0);
#line 1149
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1152
  goto ldv_54688;
  case 45: ;
#line 1155
  if (ldv_state_variable_25 == 2) {
#line 1157
    ldv_release_25();
#line 1159
    ldv_state_variable_25 = 1;
#line 1160
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1163
  goto ldv_54688;
  case 46: ;
#line 1166
  if (ldv_state_variable_25 == 1) {
#line 1168
    ldv_probe_25();
#line 1170
    ldv_state_variable_25 = 2;
#line 1171
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1174
  goto ldv_54688;
  default: 
#line 1175
  ldv_stop();
  }
  ldv_54688: ;
#line 1179
  return;
}
}
#line 1181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_main_exported_22(void) 
{ 
  struct ixgbe_hw *ldvarg352 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1182
  tmp = ldv_init_zalloc(1696UL);
#line 1182
  ldvarg352 = (struct ixgbe_hw *)tmp;
#line 1184
  tmp___0 = __VERIFIER_nondet_int();
#line 1184
  switch (tmp___0) {
  case 0: ;
#line 1187
  if (ldv_state_variable_22 == 1) {
#line 1189
    ixgbe_get_invariants_X540(ldvarg352);
#line 1191
    ldv_state_variable_22 = 1;
  } else {

  }
#line 1194
  goto ldv_54741;
  default: 
#line 1195
  ldv_stop();
  }
  ldv_54741: ;
#line 1199
  return;
}
}
#line 1201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_main_exported_24(void) 
{ 
  u16 ldvarg316 ;
  u16 ldvarg317 ;
  u16 *ldvarg321 ;
  void *tmp ;
  u16 ldvarg320 ;
  u16 *ldvarg313 ;
  void *tmp___0 ;
  u16 *ldvarg318 ;
  void *tmp___1 ;
  u16 ldvarg315 ;
  u16 ldvarg323 ;
  u16 ldvarg319 ;
  u16 *ldvarg314 ;
  void *tmp___2 ;
  u16 ldvarg322 ;
  int tmp___3 ;

  {
#line 1204
  tmp = ldv_init_zalloc(2UL);
#line 1204
  ldvarg321 = (u16 *)tmp;
#line 1206
  tmp___0 = ldv_init_zalloc(2UL);
#line 1206
  ldvarg313 = (u16 *)tmp___0;
#line 1207
  tmp___1 = ldv_init_zalloc(2UL);
#line 1207
  ldvarg318 = (u16 *)tmp___1;
#line 1211
  tmp___2 = ldv_init_zalloc(2UL);
#line 1211
  ldvarg314 = (u16 *)tmp___2;
#line 1202
  ldv_memset((void *)(& ldvarg316), 0, 2UL);
#line 1203
  ldv_memset((void *)(& ldvarg317), 0, 2UL);
#line 1205
  ldv_memset((void *)(& ldvarg320), 0, 2UL);
#line 1208
  ldv_memset((void *)(& ldvarg315), 0, 2UL);
#line 1209
  ldv_memset((void *)(& ldvarg323), 0, 2UL);
#line 1210
  ldv_memset((void *)(& ldvarg319), 0, 2UL);
#line 1212
  ldv_memset((void *)(& ldvarg322), 0, 2UL);
#line 1214
  tmp___3 = __VERIFIER_nondet_int();
#line 1214
  switch (tmp___3) {
  case 0: ;
#line 1217
  if (ldv_state_variable_24 == 2) {
#line 1219
    ixgbe_write_eewr_buffer_X540(eeprom_ops_X540_group0, (int )ldvarg323, (int )ldvarg322,
                                 ldvarg321);
#line 1221
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1224
  goto ldv_54758;
  case 1: ;
#line 1227
  if (ldv_state_variable_24 == 2) {
#line 1229
    ixgbe_read_eerd_buffer_X540(eeprom_ops_X540_group0, (int )ldvarg320, (int )ldvarg319,
                                ldvarg318);
#line 1231
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1234
  goto ldv_54758;
  case 2: ;
#line 1237
  if (ldv_state_variable_24 == 1) {
#line 1239
    ixgbe_update_eeprom_checksum_X540(eeprom_ops_X540_group0);
#line 1241
    ldv_state_variable_24 = 1;
  } else {

  }
#line 1244
  if (ldv_state_variable_24 == 2) {
#line 1246
    ixgbe_update_eeprom_checksum_X540(eeprom_ops_X540_group0);
#line 1248
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1251
  goto ldv_54758;
  case 3: ;
#line 1254
  if (ldv_state_variable_24 == 1) {
#line 1256
    ixgbe_calc_eeprom_checksum_X540(eeprom_ops_X540_group0);
#line 1258
    ldv_state_variable_24 = 1;
  } else {

  }
#line 1261
  if (ldv_state_variable_24 == 2) {
#line 1263
    ixgbe_calc_eeprom_checksum_X540(eeprom_ops_X540_group0);
#line 1265
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1268
  goto ldv_54758;
  case 4: ;
#line 1271
  if (ldv_state_variable_24 == 1) {
#line 1273
    ixgbe_write_eewr_X540(eeprom_ops_X540_group0, (int )ldvarg317, (int )ldvarg316);
#line 1275
    ldv_state_variable_24 = 1;
  } else {

  }
#line 1278
  if (ldv_state_variable_24 == 2) {
#line 1280
    ixgbe_write_eewr_X540(eeprom_ops_X540_group0, (int )ldvarg317, (int )ldvarg316);
#line 1282
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1285
  goto ldv_54758;
  case 5: ;
#line 1288
  if (ldv_state_variable_24 == 1) {
#line 1290
    ixgbe_read_eerd_X540(eeprom_ops_X540_group0, (int )ldvarg315, ldvarg314);
#line 1292
    ldv_state_variable_24 = 1;
  } else {

  }
#line 1295
  if (ldv_state_variable_24 == 2) {
#line 1297
    ixgbe_read_eerd_X540(eeprom_ops_X540_group0, (int )ldvarg315, ldvarg314);
#line 1299
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1302
  goto ldv_54758;
  case 6: ;
#line 1305
  if (ldv_state_variable_24 == 1) {
#line 1307
    ixgbe_init_eeprom_params_X540(eeprom_ops_X540_group0);
#line 1309
    ldv_state_variable_24 = 1;
  } else {

  }
#line 1312
  if (ldv_state_variable_24 == 2) {
#line 1314
    ixgbe_init_eeprom_params_X540(eeprom_ops_X540_group0);
#line 1316
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1319
  goto ldv_54758;
  case 7: ;
#line 1322
  if (ldv_state_variable_24 == 1) {
#line 1324
    ixgbe_validate_eeprom_checksum_X540(eeprom_ops_X540_group0, ldvarg313);
#line 1326
    ldv_state_variable_24 = 1;
  } else {

  }
#line 1329
  if (ldv_state_variable_24 == 2) {
#line 1331
    ixgbe_validate_eeprom_checksum_X540(eeprom_ops_X540_group0, ldvarg313);
#line 1333
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1336
  goto ldv_54758;
  case 8: ;
#line 1339
  if (ldv_state_variable_24 == 2) {
#line 1341
    ldv_release_24();
#line 1343
    ldv_state_variable_24 = 1;
#line 1344
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1347
  goto ldv_54758;
  case 9: ;
#line 1350
  if (ldv_state_variable_24 == 1) {
#line 1352
    ldv_probe_24();
#line 1354
    ldv_state_variable_24 = 2;
#line 1355
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1358
  goto ldv_54758;
  default: 
#line 1359
  ldv_stop();
  }
  ldv_54758: ;
#line 1363
  return;
}
}
#line 1365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_main_exported_23(void) 
{ 
  u8 ldvarg411 ;
  u8 ldvarg414 ;
  u8 *ldvarg413 ;
  void *tmp ;
  bool ldvarg406 ;
  u8 ldvarg399 ;
  u8 ldvarg409 ;
  u32 ldvarg405 ;
  u16 *ldvarg400 ;
  void *tmp___0 ;
  ixgbe_link_speed ldvarg407 ;
  bool ldvarg418 ;
  u32 ldvarg402 ;
  u8 *ldvarg415 ;
  void *tmp___1 ;
  u8 ldvarg398 ;
  u8 ldvarg410 ;
  u8 ldvarg416 ;
  u16 ldvarg403 ;
  u8 ldvarg408 ;
  u16 *ldvarg417 ;
  void *tmp___2 ;
  u8 *ldvarg397 ;
  void *tmp___3 ;
  u8 ldvarg412 ;
  u32 ldvarg404 ;
  u32 ldvarg401 ;
  int tmp___4 ;

  {
#line 1368
  tmp = ldv_init_zalloc(1UL);
#line 1368
  ldvarg413 = (u8 *)tmp;
#line 1373
  tmp___0 = ldv_init_zalloc(2UL);
#line 1373
  ldvarg400 = (u16 *)tmp___0;
#line 1377
  tmp___1 = ldv_init_zalloc(1UL);
#line 1377
  ldvarg415 = (u8 *)tmp___1;
#line 1383
  tmp___2 = ldv_init_zalloc(2UL);
#line 1383
  ldvarg417 = (u16 *)tmp___2;
#line 1384
  tmp___3 = ldv_init_zalloc(1UL);
#line 1384
  ldvarg397 = (u8 *)tmp___3;
#line 1366
  ldv_memset((void *)(& ldvarg411), 0, 1UL);
#line 1367
  ldv_memset((void *)(& ldvarg414), 0, 1UL);
#line 1369
  ldv_memset((void *)(& ldvarg406), 0, 1UL);
#line 1370
  ldv_memset((void *)(& ldvarg399), 0, 1UL);
#line 1371
  ldv_memset((void *)(& ldvarg409), 0, 1UL);
#line 1372
  ldv_memset((void *)(& ldvarg405), 0, 4UL);
#line 1374
  ldv_memset((void *)(& ldvarg407), 0, 4UL);
#line 1375
  ldv_memset((void *)(& ldvarg418), 0, 1UL);
#line 1376
  ldv_memset((void *)(& ldvarg402), 0, 4UL);
#line 1378
  ldv_memset((void *)(& ldvarg398), 0, 1UL);
#line 1379
  ldv_memset((void *)(& ldvarg410), 0, 1UL);
#line 1380
  ldv_memset((void *)(& ldvarg416), 0, 1UL);
#line 1381
  ldv_memset((void *)(& ldvarg403), 0, 2UL);
#line 1382
  ldv_memset((void *)(& ldvarg408), 0, 1UL);
#line 1385
  ldv_memset((void *)(& ldvarg412), 0, 1UL);
#line 1386
  ldv_memset((void *)(& ldvarg404), 0, 4UL);
#line 1387
  ldv_memset((void *)(& ldvarg401), 0, 4UL);
#line 1389
  tmp___4 = __VERIFIER_nondet_int();
#line 1389
  switch (tmp___4) {
  case 0: ;
#line 1392
  if (ldv_state_variable_23 == 1) {
#line 1394
    ixgbe_set_copper_phy_power(phy_ops_X540_group0, (int )ldvarg418);
#line 1396
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1399
  if (ldv_state_variable_23 == 2) {
#line 1401
    ixgbe_set_copper_phy_power(phy_ops_X540_group0, (int )ldvarg418);
#line 1403
    ldv_state_variable_23 = 2;
  } else {

  }
#line 1406
  goto ldv_54795;
  case 1: ;
#line 1409
  if (ldv_state_variable_23 == 1) {
#line 1411
    ixgbe_get_phy_firmware_version_generic(phy_ops_X540_group0, ldvarg417);
#line 1413
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1416
  if (ldv_state_variable_23 == 2) {
#line 1418
    ixgbe_get_phy_firmware_version_generic(phy_ops_X540_group0, ldvarg417);
#line 1420
    ldv_state_variable_23 = 2;
  } else {

  }
#line 1423
  goto ldv_54795;
  case 2: ;
#line 1426
  if (ldv_state_variable_23 == 2) {
#line 1428
    ixgbe_read_i2c_eeprom_generic(phy_ops_X540_group0, (int )ldvarg416, ldvarg415);
#line 1430
    ldv_state_variable_23 = 2;
  } else {

  }
#line 1433
  goto ldv_54795;
  case 3: ;
#line 1436
  if (ldv_state_variable_23 == 1) {
#line 1438
    ixgbe_read_i2c_sff8472_generic(phy_ops_X540_group0, (int )ldvarg414, ldvarg413);
#line 1440
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1443
  if (ldv_state_variable_23 == 2) {
#line 1445
    ixgbe_read_i2c_sff8472_generic(phy_ops_X540_group0, (int )ldvarg414, ldvarg413);
#line 1447
    ldv_state_variable_23 = 2;
  } else {

  }
#line 1450
  goto ldv_54795;
  case 4: ;
#line 1453
  if (ldv_state_variable_23 == 2) {
#line 1455
    ixgbe_write_i2c_byte_generic(phy_ops_X540_group0, (int )ldvarg412, (int )ldvarg411,
                                 (int )ldvarg410);
#line 1457
    ldv_state_variable_23 = 2;
  } else {

  }
#line 1460
  goto ldv_54795;
  case 5: ;
#line 1463
  if (ldv_state_variable_23 == 1) {
#line 1465
    ixgbe_identify_phy_generic(phy_ops_X540_group0);
#line 1467
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1470
  if (ldv_state_variable_23 == 2) {
#line 1472
    ixgbe_identify_phy_generic(phy_ops_X540_group0);
#line 1474
    ldv_state_variable_23 = 2;
  } else {

  }
#line 1477
  goto ldv_54795;
  case 6: ;
#line 1480
  if (ldv_state_variable_23 == 1) {
#line 1482
    ixgbe_setup_phy_link_generic(phy_ops_X540_group0);
#line 1484
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1487
  if (ldv_state_variable_23 == 2) {
#line 1489
    ixgbe_setup_phy_link_generic(phy_ops_X540_group0);
#line 1491
    ldv_state_variable_23 = 2;
  } else {

  }
#line 1494
  goto ldv_54795;
  case 7: ;
#line 1497
  if (ldv_state_variable_23 == 1) {
#line 1499
    ixgbe_write_i2c_eeprom_generic(phy_ops_X540_group0, (int )ldvarg409, (int )ldvarg408);
#line 1501
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1504
  if (ldv_state_variable_23 == 2) {
#line 1506
    ixgbe_write_i2c_eeprom_generic(phy_ops_X540_group0, (int )ldvarg409, (int )ldvarg408);
#line 1508
    ldv_state_variable_23 = 2;
  } else {

  }
#line 1511
  goto ldv_54795;
  case 8: ;
#line 1514
  if (ldv_state_variable_23 == 1) {
#line 1516
    ixgbe_setup_phy_link_speed_generic(phy_ops_X540_group0, ldvarg407, (int )ldvarg406);
#line 1518
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1521
  if (ldv_state_variable_23 == 2) {
#line 1523
    ixgbe_setup_phy_link_speed_generic(phy_ops_X540_group0, ldvarg407, (int )ldvarg406);
#line 1525
    ldv_state_variable_23 = 2;
  } else {

  }
#line 1528
  goto ldv_54795;
  case 9: ;
#line 1531
  if (ldv_state_variable_23 == 1) {
#line 1533
    ixgbe_write_phy_reg_generic(phy_ops_X540_group0, ldvarg405, ldvarg404, (int )ldvarg403);
#line 1535
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1538
  if (ldv_state_variable_23 == 2) {
#line 1540
    ixgbe_write_phy_reg_generic(phy_ops_X540_group0, ldvarg405, ldvarg404, (int )ldvarg403);
#line 1542
    ldv_state_variable_23 = 2;
  } else {

  }
#line 1545
  goto ldv_54795;
  case 10: ;
#line 1548
  if (ldv_state_variable_23 == 1) {
#line 1550
    ixgbe_identify_sfp_module_generic(phy_ops_X540_group0);
#line 1552
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1555
  if (ldv_state_variable_23 == 2) {
#line 1557
    ixgbe_identify_sfp_module_generic(phy_ops_X540_group0);
#line 1559
    ldv_state_variable_23 = 2;
  } else {

  }
#line 1562
  goto ldv_54795;
  case 11: ;
#line 1565
  if (ldv_state_variable_23 == 1) {
#line 1567
    ixgbe_read_phy_reg_generic(phy_ops_X540_group0, ldvarg402, ldvarg401, ldvarg400);
#line 1569
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1572
  if (ldv_state_variable_23 == 2) {
#line 1574
    ixgbe_read_phy_reg_generic(phy_ops_X540_group0, ldvarg402, ldvarg401, ldvarg400);
#line 1576
    ldv_state_variable_23 = 2;
  } else {

  }
#line 1579
  goto ldv_54795;
  case 12: ;
#line 1582
  if (ldv_state_variable_23 == 1) {
#line 1584
    ixgbe_tn_check_overtemp(phy_ops_X540_group0);
#line 1586
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1589
  if (ldv_state_variable_23 == 2) {
#line 1591
    ixgbe_tn_check_overtemp(phy_ops_X540_group0);
#line 1593
    ldv_state_variable_23 = 2;
  } else {

  }
#line 1596
  goto ldv_54795;
  case 13: ;
#line 1599
  if (ldv_state_variable_23 == 1) {
#line 1601
    ixgbe_read_i2c_byte_generic(phy_ops_X540_group0, (int )ldvarg399, (int )ldvarg398,
                                ldvarg397);
#line 1603
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1606
  if (ldv_state_variable_23 == 2) {
#line 1608
    ixgbe_read_i2c_byte_generic(phy_ops_X540_group0, (int )ldvarg399, (int )ldvarg398,
                                ldvarg397);
#line 1610
    ldv_state_variable_23 = 2;
  } else {

  }
#line 1613
  goto ldv_54795;
  case 14: ;
#line 1616
  if (ldv_state_variable_23 == 2) {
#line 1618
    ldv_release_23();
#line 1620
    ldv_state_variable_23 = 1;
#line 1621
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1624
  goto ldv_54795;
  case 15: ;
#line 1627
  if (ldv_state_variable_23 == 1) {
#line 1629
    ldv_probe_23();
#line 1631
    ldv_state_variable_23 = 2;
#line 1632
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1635
  goto ldv_54795;
  default: 
#line 1636
  ldv_stop();
  }
  ldv_54795: ;
#line 1640
  return;
}
}
#line 1665 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
bool ldv_queue_work_on_275(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1669
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1669
  ldv_func_res = tmp;
#line 1671
  activate_work_9(ldv_func_arg3, 2);
#line 1673
  return (ldv_func_res);
}
}
#line 1676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
bool ldv_queue_delayed_work_on_276(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1680
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1680
  ldv_func_res = tmp;
#line 1682
  activate_work_9(& ldv_func_arg3->work, 2);
#line 1684
  return (ldv_func_res);
}
}
#line 1687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
bool ldv_queue_work_on_277(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1691
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1691
  ldv_func_res = tmp;
#line 1693
  activate_work_9(ldv_func_arg3, 2);
#line 1695
  return (ldv_func_res);
}
}
#line 1698 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_flush_workqueue_278(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1701
  flush_workqueue(ldv_func_arg1);
#line 1703
  call_and_disable_all_9(2);
#line 1704
  return;
}
}
#line 1706 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
bool ldv_queue_delayed_work_on_279(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1710
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1710
  ldv_func_res = tmp;
#line 1712
  activate_work_9(& ldv_func_arg3->work, 2);
#line 1714
  return (ldv_func_res);
}
}
#line 1717 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_mutex_lock_280(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1720
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1722
  mutex_lock(ldv_func_arg1);
#line 1723
  return;
}
}
#line 1725 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_mutex_unlock_281(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1728
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1730
  mutex_unlock(ldv_func_arg1);
#line 1731
  return;
}
}
#line 1733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_mutex_lock_282(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1736
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1738
  mutex_lock(ldv_func_arg1);
#line 1739
  return;
}
}
#line 1741 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
int ldv_mutex_trylock_283(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1745
  tmp = mutex_trylock(ldv_func_arg1);
#line 1745
  ldv_func_res = tmp;
#line 1747
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1747
  return (tmp___0);
#line 1749
  return (ldv_func_res);
}
}
#line 1752 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_mutex_unlock_284(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1755
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1757
  mutex_unlock(ldv_func_arg1);
#line 1758
  return;
}
}
#line 1760 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_mutex_unlock_285(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1763
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 1765
  mutex_unlock(ldv_func_arg1);
#line 1766
  return;
}
}
#line 1768 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.o.c.prepared"
void ldv_mutex_lock_286(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1771
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 1773
  mutex_lock(ldv_func_arg1);
#line 1774
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_313(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_308(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_311(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_314(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_mutex_lock_309(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_310(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_312(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_303(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_305(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_304(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_307(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_306(struct workqueue_struct *ldv_func_arg1 ) ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_setup_mux_ctl(struct ixgbe_hw *hw ) 
{ 
  u32 esdp ;
  u32 tmp ;

  {
#line 34
  tmp = ixgbe_read_reg(hw, 32U);
#line 34
  esdp = tmp;
#line 36
  if ((unsigned int )hw->bus.lan_id != 0U) {
#line 37
    esdp = esdp & 4294836221U;
#line 38
    esdp = esdp | 512U;
  } else {

  }
#line 40
  esdp = esdp & 4294901503U;
#line 41
  ixgbe_write_reg(hw, 32U, esdp);
#line 42
  ixgbe_read_reg(hw, 8U);
#line 43
  return;
}
}
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_identify_phy_x550em(struct ixgbe_hw *hw ) 
{ 
  s32 tmp ;
  s32 tmp___0 ;

  {
#line 52
  switch ((int )hw->device_id) {
  case 5548: 
#line 55
  hw->phy.phy_semaphore_mask = 6150U;
#line 56
  ixgbe_setup_mux_ctl(hw);
#line 58
  tmp = ixgbe_identify_module_generic(hw);
#line 58
  return (tmp);
  case 5546: 
#line 60
  hw->phy.type = 5;
#line 61
  goto ldv_54434;
  case 5547: 
#line 63
  hw->phy.type = 4;
#line 64
  goto ldv_54434;
  case 5550: ;
  case 5549: 
#line 67
  tmp___0 = ixgbe_identify_phy_generic(hw);
#line 67
  return (tmp___0);
  default: ;
#line 69
  goto ldv_54434;
  }
  ldv_54434: ;
#line 71
  return (0);
}
}
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_phy_reg_x550em(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                                     u16 *phy_data ) 
{ 


  {
#line 77
  return (2147483647);
}
}
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_phy_reg_x550em(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                                      u16 phy_data ) 
{ 


  {
#line 83
  return (2147483647);
}
}
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_init_eeprom_params_X550(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_eeprom_info *eeprom ;
  u32 eec ;
  u16 eeprom_size ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 94
  eeprom = & hw->eeprom;
#line 98
  if ((unsigned int )eeprom->type == 0U) {
#line 99
    eeprom->semaphore_delay = 10U;
#line 100
    eeprom->type = 2;
#line 102
    eec = ixgbe_read_reg(hw, *(hw->mvals));
#line 103
    eeprom_size = (unsigned short )((eec & 30720U) >> 11);
#line 105
    eeprom->word_size = (u16 )(1 << ((int )eeprom_size + 6));
#line 108
    descriptor.modname = "ixgbe";
#line 108
    descriptor.function = "ixgbe_init_eeprom_params_X550";
#line 108
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 108
    descriptor.format = "Eeprom params: type = %d, size = %d\n";
#line 108
    descriptor.lineno = 109U;
#line 108
    descriptor.flags = 0U;
#line 108
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 108
    if (tmp != 0L) {
#line 108
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Eeprom params: type = %d, size = %d\n", (unsigned int )eeprom->type,
                           (int )eeprom->word_size);
    } else {

    }
  } else {

  }
#line 112
  return (0);
}
}
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_iosf_wait(struct ixgbe_hw *hw , u32 *ctrl ) 
{ 
  u32 i ;
  u32 command ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 132
  i = 0U;
#line 132
  goto ldv_54467;
  ldv_54466: 
#line 133
  command = ixgbe_read_reg(hw, 69956U);
#line 134
  if ((int )command >= 0) {
#line 135
    goto ldv_54465;
  } else {

  }
#line 136
  usleep_range(10UL, 20UL);
#line 132
  i = i + 1U;
  ldv_54467: ;
#line 132
  if (i <= 99U) {
#line 134
    goto ldv_54466;
  } else {

  }
  ldv_54465: ;
#line 138
  if ((unsigned long )ctrl != (unsigned long )((u32 *)0U)) {
#line 139
    *ctrl = command;
  } else {

  }
#line 140
  if (i == 100U) {
#line 141
    descriptor.modname = "ixgbe";
#line 141
    descriptor.function = "ixgbe_iosf_wait";
#line 141
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 141
    descriptor.format = "IOSF wait timed out\n";
#line 141
    descriptor.lineno = 141U;
#line 141
    descriptor.flags = 0U;
#line 141
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 141
    if (tmp != 0L) {
#line 141
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "IOSF wait timed out\n");
    } else {

    }
#line 142
    return (-3);
  } else {

  }
#line 145
  return (0);
}
}
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_iosf_sb_reg_x550(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                                       u32 *data ) 
{ 
  u32 gssr ;
  u32 command ;
  u32 error ;
  s32 ret ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 158
  gssr = 6U;
#line 162
  ret = (*(hw->mac.ops.acquire_swfw_sync))(hw, gssr);
#line 163
  if (ret != 0) {
#line 164
    return (ret);
  } else {

  }
#line 166
  ret = ixgbe_iosf_wait(hw, (u32 *)0U);
#line 167
  if (ret != 0) {
#line 168
    goto out;
  } else {

  }
#line 170
  command = (device_type << 28) | reg_addr;
#line 174
  ixgbe_write_reg(hw, 69956U, command);
#line 176
  ret = ixgbe_iosf_wait(hw, & command);
#line 178
  if ((command & 786432U) != 0U) {
#line 179
    error = (command & 267386880U) >> 20;
#line 181
    descriptor.modname = "ixgbe";
#line 181
    descriptor.function = "ixgbe_read_iosf_sb_reg_x550";
#line 181
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 181
    descriptor.format = "Failed to read, error %x\n";
#line 181
    descriptor.lineno = 181U;
#line 181
    descriptor.flags = 0U;
#line 181
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 181
    if (tmp != 0L) {
#line 181
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Failed to read, error %x\n", error);
    } else {

    }
#line 182
    return (-3);
  } else {

  }
#line 185
  if (ret == 0) {
#line 186
    *data = ixgbe_read_reg(hw, 69960U);
  } else {

  }
  out: 
#line 189
  (*(hw->mac.ops.release_swfw_sync))(hw, gssr);
#line 190
  return (ret);
}
}
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_ee_hostif_data_X550(struct ixgbe_hw *hw , u16 offset , u16 *data ) 
{ 
  s32 status ;
  struct ixgbe_hic_read_shadow_ram buffer ;
  __u32 tmp ;
  u32 tmp___0 ;

  {
#line 207
  buffer.hdr.req.cmd = 49U;
#line 208
  buffer.hdr.req.buf_lenh = 0U;
#line 209
  buffer.hdr.req.buf_lenl = 6U;
#line 210
  buffer.hdr.req.checksum = 255U;
#line 213
  tmp = __fswab32((__u32 )((int )offset * 2));
#line 213
  buffer.address = tmp;
#line 215
  buffer.length = 512U;
#line 217
  status = ixgbe_host_interface_command(hw, (u32 *)(& buffer), 16U, 500U, 0);
#line 220
  if (status != 0) {
#line 221
    return (status);
  } else {

  }
#line 223
  tmp___0 = ixgbe_read_reg(hw, 88076U);
#line 223
  *data = (unsigned short )tmp___0;
#line 226
  return (0);
}
}
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_ee_hostif_buffer_X550(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                            u16 *data ) 
{ 
  struct ixgbe_hic_read_shadow_ram buffer ;
  u32 current_word ;
  u16 words_to_read ;
  s32 status ;
  u32 i ;
  struct _ddebug descriptor ;
  long tmp ;
  __u32 tmp___0 ;
  __u16 tmp___1 ;
  struct _ddebug descriptor___0 ;
  long tmp___2 ;
  u32 reg ;
  u32 value ;
  u32 tmp___3 ;

  {
#line 241
  current_word = 0U;
#line 247
  status = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1U);
#line 248
  if (status != 0) {
#line 249
    descriptor.modname = "ixgbe";
#line 249
    descriptor.function = "ixgbe_read_ee_hostif_buffer_X550";
#line 249
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 249
    descriptor.format = "EEPROM read buffer - semaphore failed\n";
#line 249
    descriptor.lineno = 249U;
#line 249
    descriptor.flags = 0U;
#line 249
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 249
    if (tmp != 0L) {
#line 249
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read buffer - semaphore failed\n");
    } else {

    }
#line 250
    return (status);
  } else {

  }
#line 253
  goto ldv_54511;
  ldv_54510: ;
#line 254
  if ((unsigned int )words > 512U) {
#line 255
    words_to_read = 512U;
  } else {
#line 257
    words_to_read = words;
  }
#line 259
  buffer.hdr.req.cmd = 49U;
#line 260
  buffer.hdr.req.buf_lenh = 0U;
#line 261
  buffer.hdr.req.buf_lenl = 6U;
#line 262
  buffer.hdr.req.checksum = 255U;
#line 265
  tmp___0 = __fswab32(((u32 )offset + current_word) * 2U);
#line 265
  buffer.address = tmp___0;
#line 266
  tmp___1 = __fswab16((int )((unsigned int )words_to_read * 2U));
#line 266
  buffer.length = tmp___1;
#line 268
  status = ixgbe_host_interface_command(hw, (u32 *)(& buffer), 16U, 500U, 0);
#line 272
  if (status != 0) {
#line 273
    descriptor___0.modname = "ixgbe";
#line 273
    descriptor___0.function = "ixgbe_read_ee_hostif_buffer_X550";
#line 273
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 273
    descriptor___0.format = "Host interface command failed\n";
#line 273
    descriptor___0.lineno = 273U;
#line 273
    descriptor___0.flags = 0U;
#line 273
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 273
    if (tmp___2 != 0L) {
#line 273
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Host interface command failed\n");
    } else {

    }
#line 274
    goto out;
  } else {

  }
#line 277
  i = 0U;
#line 277
  goto ldv_54508;
  ldv_54507: 
#line 278
  reg = (i + 44038U) * 2U;
#line 280
  tmp___3 = ixgbe_read_reg(hw, reg);
#line 280
  value = tmp___3;
#line 282
  *(data + (unsigned long )current_word) = (unsigned short )value;
#line 283
  current_word = current_word + 1U;
#line 284
  i = i + 1U;
#line 285
  if ((u32 )words_to_read > i) {
#line 286
    value = value >> 16;
#line 287
    *(data + (unsigned long )current_word) = (unsigned short )value;
#line 288
    current_word = current_word + 1U;
  } else {

  }
#line 277
  i = i + 1U;
  ldv_54508: ;
#line 277
  if ((u32 )words_to_read > i) {
#line 279
    goto ldv_54507;
  } else {

  }
#line 291
  words = (int )words - (int )words_to_read;
  ldv_54511: ;
#line 253
  if ((unsigned int )words != 0U) {
#line 255
    goto ldv_54510;
  } else {

  }

  out: 
#line 295
  (*(hw->mac.ops.release_swfw_sync))(hw, 1U);
#line 296
  return (status);
}
}
#line 307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_checksum_ptr_x550(struct ixgbe_hw *hw , u16 ptr , u16 size , u16 *csum ,
                                   u16 *buffer , u32 buffer_size ) 
{ 
  u16 buf[256U] ;
  s32 status ;
  u16 length ;
  u16 bufsz ;
  u16 i ;
  u16 start ;
  u16 *local_buffer ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
#line 316
  bufsz = 256U;
#line 319
  if ((unsigned long )buffer == (unsigned long )((u16 *)0U)) {
#line 320
    status = ixgbe_read_ee_hostif_buffer_X550(hw, (int )ptr, (int )bufsz, (u16 *)(& buf));
#line 321
    if (status != 0) {
#line 322
      descriptor.modname = "ixgbe";
#line 322
      descriptor.function = "ixgbe_checksum_ptr_x550";
#line 322
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 322
      descriptor.format = "Failed to read EEPROM image\n";
#line 322
      descriptor.lineno = 322U;
#line 322
      descriptor.flags = 0U;
#line 322
      tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 322
      if (tmp != 0L) {
#line 322
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Failed to read EEPROM image\n");
      } else {

      }
#line 323
      return (status);
    } else {

    }
#line 325
    local_buffer = (u16 *)(& buf);
  } else {
#line 327
    if ((u32 )ptr > buffer_size) {
#line 328
      return (-5);
    } else {

    }
#line 329
    local_buffer = buffer + (unsigned long )ptr;
  }
#line 332
  if ((unsigned int )size != 0U) {
#line 333
    start = 0U;
#line 334
    length = size;
  } else {
#line 336
    start = 1U;
#line 337
    length = *local_buffer;
#line 340
    if (((unsigned int )length == 65535U || (unsigned int )length == 0U) || (int )ptr + (int )length >= (int )hw->eeprom.word_size) {
#line 342
      return (0);
    } else {

    }
  }
#line 345
  if ((unsigned long )buffer != (unsigned long )((u16 *)0U) && (unsigned int )start + (unsigned int )length > buffer_size) {
#line 346
    return (-5);
  } else {

  }
#line 348
  i = start;
#line 348
  goto ldv_54532;
  ldv_54531: ;
#line 349
  if ((int )i == (int )bufsz && (unsigned long )buffer == (unsigned long )((u16 *)0U)) {
#line 350
    ptr = (int )ptr + (int )bufsz;
#line 351
    i = 0U;
#line 352
    if ((int )length < (int )bufsz) {
#line 353
      bufsz = length;
    } else {

    }
#line 356
    status = ixgbe_read_ee_hostif_buffer_X550(hw, (int )ptr, (int )bufsz, (u16 *)(& buf));
#line 358
    if (status != 0) {
#line 359
      descriptor___0.modname = "ixgbe";
#line 359
      descriptor___0.function = "ixgbe_checksum_ptr_x550";
#line 359
      descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 359
      descriptor___0.format = "Failed to read EEPROM image\n";
#line 359
      descriptor___0.lineno = 359U;
#line 359
      descriptor___0.flags = 0U;
#line 359
      tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 359
      if (tmp___0 != 0L) {
#line 359
        __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Failed to read EEPROM image\n");
      } else {

      }
#line 360
      return (status);
    } else {

    }
  } else {

  }
#line 363
  *csum = (int )*csum + (int )*(local_buffer + (unsigned long )i);
#line 348
  i = (u16 )((int )i + 1);
#line 348
  length = (u16 )((int )length - 1);
  ldv_54532: ;
#line 348
  if ((unsigned int )length != 0U) {
#line 350
    goto ldv_54531;
  } else {

  }

#line 365
  return (0);
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_calc_checksum_X550(struct ixgbe_hw *hw , u16 *buffer , u32 buffer_size ) 
{ 
  u16 eeprom_ptrs[66U] ;
  u16 *local_buffer ;
  s32 status ;
  u16 checksum ;
  u16 pointer ;
  u16 i ;
  u16 size ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 381
  checksum = 0U;
#line 384
  (*(hw->eeprom.ops.init_params))(hw);
#line 386
  if ((unsigned long )buffer == (unsigned long )((u16 *)0U)) {
#line 388
    status = ixgbe_read_ee_hostif_buffer_X550(hw, 0, 66, (u16 *)(& eeprom_ptrs));
#line 391
    if (status != 0) {
#line 392
      descriptor.modname = "ixgbe";
#line 392
      descriptor.function = "ixgbe_calc_checksum_X550";
#line 392
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 392
      descriptor.format = "Failed to read EEPROM image\n";
#line 392
      descriptor.lineno = 392U;
#line 392
      descriptor.flags = 0U;
#line 392
      tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 392
      if (tmp != 0L) {
#line 392
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Failed to read EEPROM image\n");
      } else {

      }
#line 393
      return (status);
    } else {

    }
#line 395
    local_buffer = (u16 *)(& eeprom_ptrs);
  } else {
#line 397
    if (buffer_size <= 64U) {
#line 398
      return (-5);
    } else {

    }
#line 399
    local_buffer = buffer;
  }
#line 405
  i = 0U;
#line 405
  goto ldv_54549;
  ldv_54548: ;
#line 406
  if ((unsigned int )i != 63U) {
#line 407
    checksum = (int )*(local_buffer + (unsigned long )i) + (int )checksum;
  } else {

  }
#line 405
  i = (u16 )((int )i + 1);
  ldv_54549: ;
#line 405
  if ((unsigned int )i <= 65U) {
#line 407
    goto ldv_54548;
  } else {

  }
#line 412
  i = 2U;
#line 412
  goto ldv_54558;
  ldv_54557: ;
#line 413
  if ((unsigned int )i == 4U || (unsigned int )i == 5U) {
#line 414
    goto ldv_54551;
  } else {

  }
#line 416
  pointer = *(local_buffer + (unsigned long )i);
#line 419
  if (((unsigned int )pointer == 65535U || (unsigned int )pointer == 0U) || (int )hw->eeprom.word_size <= (int )pointer) {
#line 421
    goto ldv_54551;
  } else {

  }
#line 423
  switch ((int )i) {
  case 6: 
#line 425
  size = 36U;
#line 426
  goto ldv_54553;
  case 7: ;
  case 8: 
#line 429
  size = 8U;
#line 430
  goto ldv_54553;
  default: 
#line 432
  size = 0U;
#line 433
  goto ldv_54553;
  }
  ldv_54553: 
#line 436
  status = ixgbe_checksum_ptr_x550(hw, (int )pointer, (int )size, & checksum, buffer,
                                   buffer_size);
#line 438
  if (status != 0) {
#line 439
    return (status);
  } else {

  }
  ldv_54551: 
#line 412
  i = (u16 )((int )i + 1);
  ldv_54558: ;
#line 412
  if ((unsigned int )i <= 14U) {
#line 414
    goto ldv_54557;
  } else {

  }
#line 442
  checksum = 47802U - (unsigned int )checksum;
#line 444
  return ((s32 )checksum);
}
}
#line 452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_calc_eeprom_checksum_X550(struct ixgbe_hw *hw ) 
{ 
  s32 tmp ;

  {
#line 454
  tmp = ixgbe_calc_checksum_X550(hw, (u16 *)0U, 0U);
#line 454
  return (tmp);
}
}
#line 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_ee_hostif_X550(struct ixgbe_hw *hw , u16 offset , u16 *data ) 
{ 
  s32 status ;
  s32 tmp ;

  {
#line 466
  status = 0;
#line 468
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1U);
#line 468
  if (tmp == 0) {
#line 469
    status = ixgbe_read_ee_hostif_data_X550(hw, (int )offset, data);
#line 470
    (*(hw->mac.ops.release_swfw_sync))(hw, 1U);
  } else {
#line 472
    status = -16;
  }
#line 475
  return (status);
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_validate_eeprom_checksum_X550(struct ixgbe_hw *hw , u16 *checksum_val ) 
{ 
  s32 status ;
  u16 checksum ;
  u16 read_checksum ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
#line 490
  read_checksum = 0U;
#line 496
  status = (*(hw->eeprom.ops.read))(hw, 0, & checksum);
#line 497
  if (status != 0) {
#line 498
    descriptor.modname = "ixgbe";
#line 498
    descriptor.function = "ixgbe_validate_eeprom_checksum_X550";
#line 498
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 498
    descriptor.format = "EEPROM read failed\n";
#line 498
    descriptor.lineno = 498U;
#line 498
    descriptor.flags = 0U;
#line 498
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 498
    if (tmp != 0L) {
#line 498
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 499
    return (status);
  } else {

  }
#line 502
  status = (*(hw->eeprom.ops.calc_checksum))(hw);
#line 503
  if (status < 0) {
#line 504
    return (status);
  } else {

  }
#line 506
  checksum = (unsigned short )status;
#line 508
  status = ixgbe_read_ee_hostif_X550(hw, 63, & read_checksum);
#line 510
  if (status != 0) {
#line 511
    return (status);
  } else {

  }
#line 516
  if ((int )read_checksum != (int )checksum) {
#line 517
    status = -2;
#line 518
    descriptor___0.modname = "ixgbe";
#line 518
    descriptor___0.function = "ixgbe_validate_eeprom_checksum_X550";
#line 518
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 518
    descriptor___0.format = "Invalid EEPROM checksum";
#line 518
    descriptor___0.lineno = 518U;
#line 518
    descriptor___0.flags = 0U;
#line 518
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 518
    if (tmp___0 != 0L) {
#line 518
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Invalid EEPROM checksum");
    } else {

    }
  } else {

  }
#line 522
  if ((unsigned long )checksum_val != (unsigned long )((u16 *)0U)) {
#line 523
    *checksum_val = checksum;
  } else {

  }
#line 525
  return (status);
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_ee_hostif_data_X550(struct ixgbe_hw *hw , u16 offset , u16 data ) 
{ 
  s32 status ;
  struct ixgbe_hic_write_shadow_ram buffer ;
  __u32 tmp ;

  {
#line 541
  buffer.hdr.req.cmd = 51U;
#line 542
  buffer.hdr.req.buf_lenh = 0U;
#line 543
  buffer.hdr.req.buf_lenl = 10U;
#line 544
  buffer.hdr.req.checksum = 255U;
#line 547
  buffer.length = 512U;
#line 548
  buffer.data = data;
#line 549
  tmp = __fswab32((__u32 )((int )offset * 2));
#line 549
  buffer.address = tmp;
#line 551
  status = ixgbe_host_interface_command(hw, (u32 *)(& buffer), 16U, 500U, 0);
#line 554
  return (status);
}
}
#line 564 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_ee_hostif_X550(struct ixgbe_hw *hw , u16 offset , u16 data ) 
{ 
  s32 status ;
  struct _ddebug descriptor ;
  long tmp ;
  s32 tmp___0 ;

  {
#line 566
  status = 0;
#line 568
  tmp___0 = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1U);
#line 568
  if (tmp___0 == 0) {
#line 569
    status = ixgbe_write_ee_hostif_data_X550(hw, (int )offset, (int )data);
#line 570
    (*(hw->mac.ops.release_swfw_sync))(hw, 1U);
  } else {
#line 572
    descriptor.modname = "ixgbe";
#line 572
    descriptor.function = "ixgbe_write_ee_hostif_X550";
#line 572
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 572
    descriptor.format = "write ee hostif failed to get semaphore";
#line 572
    descriptor.lineno = 572U;
#line 572
    descriptor.flags = 0U;
#line 572
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 572
    if (tmp != 0L) {
#line 572
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "write ee hostif failed to get semaphore");
    } else {

    }
#line 573
    status = -16;
  }
#line 576
  return (status);
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_update_flash_X550(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  union ixgbe_hic_hdr2 buffer ;

  {
#line 586
  status = 0;
#line 589
  buffer.req.cmd = 54U;
#line 590
  buffer.req.buf_lenh = 0U;
#line 591
  buffer.req.buf_lenl = 0U;
#line 592
  buffer.req.checksum = 255U;
#line 594
  status = ixgbe_host_interface_command(hw, (u32 *)(& buffer), 4U, 500U, 0);
#line 597
  return (status);
}
}
#line 604 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_disable_rx_x550(struct ixgbe_hw *hw ) 
{ 
  u32 rxctrl ;
  u32 pfdtxgswc ;
  s32 status ;
  struct ixgbe_hic_disable_rxen fw_cmd ;

  {
#line 610
  rxctrl = ixgbe_read_reg(hw, 12288U);
#line 611
  if ((int )rxctrl & 1) {
#line 612
    pfdtxgswc = ixgbe_read_reg(hw, 33312U);
#line 613
    if ((int )pfdtxgswc & 1) {
#line 614
      pfdtxgswc = pfdtxgswc & 4294967294U;
#line 615
      ixgbe_write_reg(hw, 33312U, pfdtxgswc);
#line 616
      hw->mac.set_lben = 1;
    } else {
#line 618
      hw->mac.set_lben = 0;
    }
#line 621
    fw_cmd.hdr.cmd = 222U;
#line 622
    fw_cmd.hdr.buf_len = 1U;
#line 623
    fw_cmd.hdr.checksum = 255U;
#line 624
    fw_cmd.port_number = (unsigned char )hw->bus.lan_id;
#line 626
    status = ixgbe_host_interface_command(hw, (u32 *)(& fw_cmd), 8U, 500U, 1);
#line 631
    if (status != 0) {
#line 632
      rxctrl = ixgbe_read_reg(hw, 12288U);
#line 633
      if ((int )rxctrl & 1) {
#line 634
        rxctrl = rxctrl & 4294967294U;
#line 635
        ixgbe_write_reg(hw, 12288U, rxctrl);
      } else {

      }
    } else {

    }
  } else {

  }
#line 639
  return;
}
}
#line 648 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_update_eeprom_checksum_X550(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 checksum ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 651
  checksum = 0U;
#line 657
  status = ixgbe_read_ee_hostif_X550(hw, 0, & checksum);
#line 658
  if (status != 0) {
#line 659
    descriptor.modname = "ixgbe";
#line 659
    descriptor.function = "ixgbe_update_eeprom_checksum_X550";
#line 659
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 659
    descriptor.format = "EEPROM read failed\n";
#line 659
    descriptor.lineno = 659U;
#line 659
    descriptor.flags = 0U;
#line 659
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 659
    if (tmp != 0L) {
#line 659
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
    } else {

    }
#line 660
    return (status);
  } else {

  }
#line 663
  status = ixgbe_calc_eeprom_checksum_X550(hw);
#line 664
  if (status < 0) {
#line 665
    return (status);
  } else {

  }
#line 667
  checksum = (unsigned short )status;
#line 669
  status = ixgbe_write_ee_hostif_X550(hw, 63, (int )checksum);
#line 671
  if (status != 0) {
#line 672
    return (status);
  } else {

  }
#line 674
  status = ixgbe_update_flash_X550(hw);
#line 676
  return (status);
}
}
#line 688 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_ee_hostif_buffer_X550(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                             u16 *data ) 
{ 
  s32 status ;
  u32 i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
#line 692
  status = 0;
#line 693
  i = 0U;
#line 696
  status = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1U);
#line 697
  if (status != 0) {
#line 698
    descriptor.modname = "ixgbe";
#line 698
    descriptor.function = "ixgbe_write_ee_hostif_buffer_X550";
#line 698
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 698
    descriptor.format = "EEPROM write buffer - semaphore failed\n";
#line 698
    descriptor.lineno = 698U;
#line 698
    descriptor.flags = 0U;
#line 698
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 698
    if (tmp != 0L) {
#line 698
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM write buffer - semaphore failed\n");
    } else {

    }
#line 699
    return (status);
  } else {

  }
#line 702
  i = 0U;
#line 702
  goto ldv_54626;
  ldv_54625: 
#line 703
  status = ixgbe_write_ee_hostif_data_X550(hw, (int )((u16 )i) + (int )offset, (int )*(data + (unsigned long )i));
#line 705
  if (status != 0) {
#line 706
    descriptor___0.modname = "ixgbe";
#line 706
    descriptor___0.function = "ixgbe_write_ee_hostif_buffer_X550";
#line 706
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 706
    descriptor___0.format = "Eeprom buffered write failed\n";
#line 706
    descriptor___0.lineno = 706U;
#line 706
    descriptor___0.flags = 0U;
#line 706
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 706
    if (tmp___0 != 0L) {
#line 706
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Eeprom buffered write failed\n");
    } else {

    }
#line 707
    goto ldv_54624;
  } else {

  }
#line 702
  i = i + 1U;
  ldv_54626: ;
#line 702
  if ((u32 )words > i) {
#line 704
    goto ldv_54625;
  } else {

  }
  ldv_54624: 
#line 711
  (*(hw->mac.ops.release_swfw_sync))(hw, 1U);
#line 713
  return (status);
}
}
#line 724 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_iosf_sb_reg_x550(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                                        u32 data ) 
{ 
  u32 gssr ;
  u32 command ;
  u32 error ;
  s32 ret ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 727
  gssr = 6U;
#line 731
  ret = (*(hw->mac.ops.acquire_swfw_sync))(hw, gssr);
#line 732
  if (ret != 0) {
#line 733
    return (ret);
  } else {

  }
#line 735
  ret = ixgbe_iosf_wait(hw, (u32 *)0U);
#line 736
  if (ret != 0) {
#line 737
    goto out;
  } else {

  }
#line 739
  command = (device_type << 28) | reg_addr;
#line 743
  ixgbe_write_reg(hw, 69956U, command);
#line 746
  ixgbe_write_reg(hw, 69960U, data);
#line 748
  ret = ixgbe_iosf_wait(hw, & command);
#line 750
  if ((command & 786432U) != 0U) {
#line 751
    error = (command & 267386880U) >> 20;
#line 753
    descriptor.modname = "ixgbe";
#line 753
    descriptor.function = "ixgbe_write_iosf_sb_reg_x550";
#line 753
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 753
    descriptor.format = "Failed to write, error %x\n";
#line 753
    descriptor.lineno = 753U;
#line 753
    descriptor.flags = 0U;
#line 753
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 753
    if (tmp != 0L) {
#line 753
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Failed to write, error %x\n", error);
    } else {

    }
#line 754
    return (-3);
  } else {

  }
  out: 
#line 758
  (*(hw->mac.ops.release_swfw_sync))(hw, gssr);
#line 759
  return (ret);
}
}
#line 769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_ixfi_x550em(struct ixgbe_hw *hw , ixgbe_link_speed *speed ) 
{ 
  s32 status ;
  u32 reg_val ;

  {
#line 775
  status = ixgbe_read_iosf_sb_reg_x550(hw, (unsigned int )hw->bus.lan_id == 0U ? 16908U : 33292U,
                                       0U, & reg_val);
#line 778
  if (status != 0) {
#line 779
    return (status);
  } else {

  }
#line 781
  reg_val = reg_val & 3758096383U;
#line 782
  reg_val = reg_val & 4294965503U;
#line 785
  switch (*speed) {
  case 128U: 
#line 787
  reg_val = reg_val | 1024U;
#line 788
  goto ldv_54647;
  case 32U: 
#line 790
  reg_val = reg_val | 512U;
#line 791
  goto ldv_54647;
  default: ;
#line 794
  return (-8);
  }
  ldv_54647: 
#line 797
  status = ixgbe_write_iosf_sb_reg_x550(hw, (unsigned int )hw->bus.lan_id == 0U ? 16908U : 33292U,
                                        0U, reg_val);
#line 800
  if (status != 0) {
#line 801
    return (status);
  } else {

  }
#line 804
  status = ixgbe_read_iosf_sb_reg_x550(hw, (unsigned int )hw->bus.lan_id == 0U ? 19200U : 35584U,
                                       0U, & reg_val);
#line 807
  if (status != 0) {
#line 808
    return (status);
  } else {

  }
#line 810
  reg_val = reg_val | 16U;
#line 811
  status = ixgbe_write_iosf_sb_reg_x550(hw, (unsigned int )hw->bus.lan_id == 0U ? 19200U : 35584U,
                                        0U, reg_val);
#line 814
  if (status != 0) {
#line 815
    return (status);
  } else {

  }
#line 818
  status = ixgbe_read_iosf_sb_reg_x550(hw, (unsigned int )hw->bus.lan_id == 0U ? 17972U : 34356U,
                                       0U, & reg_val);
#line 821
  if (status != 0) {
#line 822
    return (status);
  } else {

  }
#line 824
  reg_val = reg_val & 4294967231U;
#line 825
  reg_val = reg_val & 4294934527U;
#line 826
  reg_val = reg_val & 4294901759U;
#line 827
  status = ixgbe_write_iosf_sb_reg_x550(hw, (unsigned int )hw->bus.lan_id == 0U ? 17972U : 34356U,
                                        0U, reg_val);
#line 830
  if (status != 0) {
#line 831
    return (status);
  } else {

  }
#line 833
  status = ixgbe_read_iosf_sb_reg_x550(hw, (unsigned int )hw->bus.lan_id == 0U ? 17976U : 34360U,
                                       0U, & reg_val);
#line 836
  if (status != 0) {
#line 837
    return (status);
  } else {

  }
#line 839
  reg_val = reg_val & 4294967231U;
#line 840
  reg_val = reg_val & 4294934527U;
#line 841
  reg_val = reg_val & 4294901759U;
#line 842
  status = ixgbe_write_iosf_sb_reg_x550(hw, (unsigned int )hw->bus.lan_id == 0U ? 17976U : 34360U,
                                        0U, reg_val);
#line 845
  if (status != 0) {
#line 846
    return (status);
  } else {

  }
#line 849
  status = ixgbe_read_iosf_sb_reg_x550(hw, (unsigned int )hw->bus.lan_id == 0U ? 21792U : 38176U,
                                       0U, & reg_val);
#line 852
  if (status != 0) {
#line 853
    return (status);
  } else {

  }
#line 855
  reg_val = reg_val | 2147483648U;
#line 856
  reg_val = reg_val | 8U;
#line 857
  reg_val = reg_val | 4U;
#line 858
  reg_val = reg_val | 2U;
#line 859
  status = ixgbe_write_iosf_sb_reg_x550(hw, (unsigned int )hw->bus.lan_id == 0U ? 21792U : 38176U,
                                        0U, reg_val);
#line 862
  if (status != 0) {
#line 863
    return (status);
  } else {

  }
#line 866
  status = ixgbe_read_iosf_sb_reg_x550(hw, (unsigned int )hw->bus.lan_id == 0U ? 16908U : 33292U,
                                       0U, & reg_val);
#line 869
  if (status != 0) {
#line 870
    return (status);
  } else {

  }
#line 872
  reg_val = reg_val | 2147483648U;
#line 873
  status = ixgbe_write_iosf_sb_reg_x550(hw, (unsigned int )hw->bus.lan_id == 0U ? 16908U : 33292U,
                                        0U, reg_val);
#line 877
  return (status);
}
}
#line 891 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_mac_link_t_X550em(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                         bool autoneg_wait ) 
{ 
  s32 status ;
  ixgbe_link_speed force_speed ;
  s32 tmp ;

  {
#line 901
  if ((speed & 128U) != 0U) {
#line 902
    force_speed = 128U;
  } else {
#line 904
    force_speed = 32U;
  }
#line 907
  if (((unsigned long )hw->phy.nw_mng_if_sel & 16777216UL) == 0UL) {
#line 908
    status = ixgbe_setup_ixfi_x550em(hw, & force_speed);
#line 910
    if (status != 0) {
#line 911
      return (status);
    } else {

    }
  } else {

  }
#line 914
  tmp = (*(hw->phy.ops.setup_link_speed))(hw, speed, (int )autoneg_wait);
#line 914
  return (tmp);
}
}
#line 925 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_check_link_t_X550em(struct ixgbe_hw *hw , ixgbe_link_speed *speed ,
                                     bool *link_up , bool link_up_wait_to_complete ) 
{ 
  u32 status ;
  u16 autoneg_status ;
  enum ixgbe_media_type tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;

  {
#line 933
  tmp = (*(hw->mac.ops.get_media_type))(hw);
#line 933
  if ((unsigned int )tmp != 4U) {
#line 934
    return (-4);
  } else {

  }
#line 936
  tmp___0 = ixgbe_check_mac_link_generic(hw, speed, link_up, (int )link_up_wait_to_complete);
#line 936
  status = (u32 )tmp___0;
#line 940
  if (status != 0U || ! *link_up) {
#line 941
    return ((s32 )status);
  } else {

  }
#line 946
  tmp___1 = (*(hw->phy.ops.read_reg))(hw, 1U, 7U, & autoneg_status);
#line 946
  status = (u32 )tmp___1;
#line 949
  if (status != 0U) {
#line 950
    return ((s32 )status);
  } else {

  }
#line 953
  if (((int )autoneg_status & 4) == 0) {
#line 954
    *link_up = 0;
  } else {

  }
#line 956
  return (0);
}
}
#line 962 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_init_mac_link_ops_X550em(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mac_info *mac ;
  enum ixgbe_media_type tmp ;

  {
#line 964
  mac = & hw->mac;
#line 966
  tmp = (*(mac->ops.get_media_type))(hw);
#line 966
  switch ((unsigned int )tmp) {
  case 1U: 
#line 971
  mac->ops.disable_tx_laser = (void (*)(struct ixgbe_hw * ))0;
#line 972
  mac->ops.enable_tx_laser = (void (*)(struct ixgbe_hw * ))0;
#line 973
  mac->ops.flap_tx_laser = (void (*)(struct ixgbe_hw * ))0;
#line 974
  goto ldv_54670;
  case 4U: 
#line 976
  mac->ops.setup_link = & ixgbe_setup_mac_link_t_X550em;
#line 977
  mac->ops.check_link = & ixgbe_check_link_t_X550em;
#line 978
  goto ldv_54670;
  default: ;
#line 980
  goto ldv_54670;
  }
  ldv_54670: ;
#line 983
  return;
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_sfp_modules_X550em(struct ixgbe_hw *hw ) 
{ 
  bool setup_linear ;
  u16 reg_slice ;
  u16 edc_mode ;
  s32 ret_val ;

  {
#line 993
  switch ((unsigned int )hw->phy.sfp_type) {
  case 65535U: ;
#line 995
  return (0);
  case 65534U: ;
#line 997
  return (-20);
  case 3U: ;
  case 4U: 
#line 1000
  setup_linear = 1;
#line 1001
  goto ldv_54684;
  case 5U: ;
  case 6U: ;
  case 7U: ;
  case 8U: ;
  case 11U: ;
  case 12U: 
#line 1008
  setup_linear = 0;
#line 1009
  goto ldv_54684;
  default: ;
#line 1011
  return (-19);
  }
  ldv_54684: 
#line 1014
  ixgbe_init_mac_link_ops_X550em(hw);
#line 1015
  hw->phy.ops.reset = (s32 (*)(struct ixgbe_hw * ))0;
#line 1020
  reg_slice = (unsigned int )((int )hw->bus.lan_id << 12U) + 4784U;
#line 1022
  if ((int )setup_linear) {
#line 1023
    edc_mode = 5U;
  } else {
#line 1025
    edc_mode = 9U;
  }
#line 1028
  ret_val = (*(hw->phy.ops.write_i2c_combined))(hw, 190, (int )reg_slice, (int )edc_mode);
#line 1031
  if (ret_val != 0) {
#line 1032
    ret_val = (*(hw->phy.ops.write_i2c_combined))(hw, 128, (int )reg_slice, (int )edc_mode);
  } else {

  }
#line 1035
  return (ret_val);
}
}
#line 1043 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_get_link_capabilities_X550em(struct ixgbe_hw *hw , ixgbe_link_speed *speed ,
                                              bool *autoneg ) 
{ 


  {
#line 1048
  if ((unsigned int )hw->phy.media_type == 1U) {
#line 1050
    *autoneg = 0;
#line 1052
    if ((unsigned int )hw->phy.sfp_type == 11U || (unsigned int )hw->phy.sfp_type == 12U) {
#line 1054
      *speed = 32U;
#line 1055
      return (0);
    } else {

    }
#line 1059
    if ((int )hw->phy.multispeed_fiber) {
#line 1060
      *speed = 160U;
    } else {
#line 1063
      *speed = 128U;
    }
  } else {
#line 1065
    *speed = 160U;
#line 1067
    *autoneg = 1;
  }
#line 1069
  return (0);
}
}
#line 1084 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_get_lasi_ext_t_x550em(struct ixgbe_hw *hw , bool *lsc ) 
{ 
  u32 status ;
  u16 reg ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;
  s32 tmp___3 ;

  {
#line 1089
  *lsc = 0;
#line 1092
  tmp = (*(hw->phy.ops.read_reg))(hw, 64512U, 30U, & reg);
#line 1092
  status = (u32 )tmp;
#line 1096
  if (status != 0U || ((int )reg & 1) == 0) {
#line 1097
    return ((s32 )status);
  } else {

  }
#line 1100
  tmp___0 = (*(hw->phy.ops.read_reg))(hw, 64513U, 30U, & reg);
#line 1100
  status = (u32 )tmp___0;
#line 1104
  if (status != 0U || ((int )reg & 4100) == 0) {
#line 1106
    return ((s32 )status);
  } else {

  }
#line 1109
  tmp___1 = (*(hw->phy.ops.read_reg))(hw, 52224U, 30U, & reg);
#line 1109
  status = (u32 )tmp___1;
#line 1113
  if (status != 0U) {
#line 1114
    return ((s32 )status);
  } else {

  }
#line 1117
  if (((int )reg & 16384) != 0) {
#line 1119
    ixgbe_set_copper_phy_power(hw, 0);
#line 1120
    return (-26);
  } else {

  }
#line 1124
  tmp___2 = (*(hw->phy.ops.read_reg))(hw, 64512U, 7U, & reg);
#line 1124
  status = (u32 )tmp___2;
#line 1127
  if (status != 0U || ((int )reg & 512) == 0) {
#line 1128
    return ((s32 )status);
  } else {

  }
#line 1131
  tmp___3 = (*(hw->phy.ops.read_reg))(hw, 52225U, 7U, & reg);
#line 1131
  status = (u32 )tmp___3;
#line 1134
  if (status != 0U) {
#line 1135
    return ((s32 )status);
  } else {

  }
#line 1138
  if ((int )reg & 1) {
#line 1139
    *lsc = 1;
  } else {

  }
#line 1141
  return (0);
}
}
#line 1153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_enable_lasi_ext_t_x550em(struct ixgbe_hw *hw ) 
{ 
  u32 status ;
  u16 reg ;
  bool lsc ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;
  s32 tmp___3 ;
  s32 tmp___4 ;
  s32 tmp___5 ;
  s32 tmp___6 ;
  s32 tmp___7 ;

  {
#line 1160
  tmp = ixgbe_get_lasi_ext_t_x550em(hw, & lsc);
#line 1160
  status = (u32 )tmp;
#line 1163
  tmp___0 = (*(hw->phy.ops.read_reg))(hw, 54273U, 7U, & reg);
#line 1163
  status = (u32 )tmp___0;
#line 1165
  if (status != 0U) {
#line 1166
    return ((s32 )status);
  } else {

  }
#line 1168
  reg = (u16 )((unsigned int )reg | 1U);
#line 1170
  tmp___1 = (*(hw->phy.ops.write_reg))(hw, 54273U, 7U, (int )reg);
#line 1170
  status = (u32 )tmp___1;
#line 1172
  if (status != 0U) {
#line 1173
    return ((s32 )status);
  } else {

  }
#line 1176
  tmp___2 = (*(hw->phy.ops.read_reg))(hw, 54272U, 30U, & reg);
#line 1176
  status = (u32 )tmp___2;
#line 1179
  if (status != 0U) {
#line 1180
    return ((s32 )status);
  } else {

  }
#line 1182
  reg = (u16 )((unsigned int )reg | 16384U);
#line 1184
  tmp___3 = (*(hw->phy.ops.write_reg))(hw, 54272U, 30U, (int )reg);
#line 1184
  status = (u32 )tmp___3;
#line 1187
  if (status != 0U) {
#line 1188
    return ((s32 )status);
  } else {

  }
#line 1191
  tmp___4 = (*(hw->phy.ops.read_reg))(hw, 65281U, 30U, & reg);
#line 1191
  status = (u32 )tmp___4;
#line 1194
  if (status != 0U) {
#line 1195
    return ((s32 )status);
  } else {

  }
#line 1197
  reg = (u16 )((unsigned int )reg | 4100U);
#line 1200
  tmp___5 = (*(hw->phy.ops.write_reg))(hw, 65281U, 30U, (int )reg);
#line 1200
  status = (u32 )tmp___5;
#line 1203
  if (status != 0U) {
#line 1204
    return ((s32 )status);
  } else {

  }
#line 1207
  tmp___6 = (*(hw->phy.ops.read_reg))(hw, 65280U, 30U, & reg);
#line 1207
  status = (u32 )tmp___6;
#line 1210
  if (status != 0U) {
#line 1211
    return ((s32 )status);
  } else {

  }
#line 1213
  reg = (u16 )((unsigned int )reg | 1U);
#line 1215
  tmp___7 = (*(hw->phy.ops.write_reg))(hw, 65280U, 30U, (int )reg);
#line 1215
  status = (u32 )tmp___7;
#line 1219
  return ((s32 )status);
}
}
#line 1233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_handle_lasi_ext_t_x550em(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_phy_info *phy ;
  bool lsc ;
  u32 status ;
  s32 tmp ;
  s32 tmp___0 ;

  {
#line 1235
  phy = & hw->phy;
#line 1239
  tmp = ixgbe_get_lasi_ext_t_x550em(hw, & lsc);
#line 1239
  status = (u32 )tmp;
#line 1240
  if (status != 0U) {
#line 1241
    return ((s32 )status);
  } else {

  }
#line 1243
  if ((int )lsc) {
#line 1244
    tmp___0 = (*(phy->ops.setup_internal_link))(hw);
#line 1244
    return (tmp___0);
  } else {

  }
#line 1246
  return (0);
}
}
#line 1256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_kr_speed_x550em(struct ixgbe_hw *hw , ixgbe_link_speed speed ) 
{ 
  s32 status ;
  u32 reg_val ;

  {
#line 1262
  status = ixgbe_read_iosf_sb_reg_x550(hw, (unsigned int )hw->bus.lan_id == 0U ? 16908U : 33292U,
                                       0U, & reg_val);
#line 1265
  if (status != 0) {
#line 1266
    return (status);
  } else {

  }
#line 1268
  reg_val = reg_val | 536870912U;
#line 1269
  reg_val = reg_val & 4294918143U;
#line 1271
  reg_val = reg_val & 4294639615U;
#line 1275
  if ((speed & 128U) != 0U) {
#line 1276
    reg_val = reg_val | 262144U;
  } else {

  }
#line 1279
  if ((speed & 32U) != 0U) {
#line 1280
    reg_val = reg_val | 65536U;
  } else {

  }
#line 1283
  reg_val = reg_val | 2147483648U;
#line 1284
  status = ixgbe_write_iosf_sb_reg_x550(hw, (unsigned int )hw->bus.lan_id == 0U ? 16908U : 33292U,
                                        0U, reg_val);
#line 1288
  return (status);
}
}
#line 1296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_kx4_x550em(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u32 reg_val ;

  {
#line 1301
  status = ixgbe_read_iosf_sb_reg_x550(hw, 76U, (u32 )((int )hw->bus.lan_id + 2),
                                       & reg_val);
#line 1304
  if (status != 0) {
#line 1305
    return (status);
  } else {

  }
#line 1307
  reg_val = reg_val & 4294770687U;
#line 1310
  reg_val = reg_val | 536870912U;
#line 1313
  if ((hw->phy.autoneg_advertised & 128U) != 0U) {
#line 1314
    reg_val = reg_val | 131072U;
  } else {

  }
#line 1317
  if ((hw->phy.autoneg_advertised & 32U) != 0U) {
#line 1318
    reg_val = reg_val | 65536U;
  } else {

  }
#line 1321
  reg_val = reg_val | 2147483648U;
#line 1322
  status = ixgbe_write_iosf_sb_reg_x550(hw, 76U, (u32 )((int )hw->bus.lan_id + 2),
                                        reg_val);
#line 1326
  return (status);
}
}
#line 1334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_kr_x550em(struct ixgbe_hw *hw ) 
{ 
  s32 tmp ;

  {
#line 1336
  tmp = ixgbe_setup_kr_speed_x550em(hw, hw->phy.autoneg_advertised);
#line 1336
  return (tmp);
}
}
#line 1345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_ext_phy_t_x550em_get_link(struct ixgbe_hw *hw , bool *link_up ) 
{ 
  u32 ret ;
  u16 autoneg_status ;
  s32 tmp ;
  s32 tmp___0 ;

  {
#line 1350
  *link_up = 0;
#line 1353
  tmp = (*(hw->phy.ops.read_reg))(hw, 1U, 7U, & autoneg_status);
#line 1353
  ret = (u32 )tmp;
#line 1356
  if (ret != 0U) {
#line 1357
    return ((s32 )ret);
  } else {

  }
#line 1359
  tmp___0 = (*(hw->phy.ops.read_reg))(hw, 1U, 7U, & autoneg_status);
#line 1359
  ret = (u32 )tmp___0;
#line 1362
  if (ret != 0U) {
#line 1363
    return ((s32 )ret);
  } else {

  }
#line 1365
  *link_up = ((int )autoneg_status & 4) != 0;
#line 1367
  return (0);
}
}
#line 1381 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_internal_phy_t_x550em(struct ixgbe_hw *hw ) 
{ 
  ixgbe_link_speed force_speed ;
  bool link_up ;
  u32 status ;
  u16 speed ;
  enum ixgbe_media_type tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;
  s32 tmp___3 ;

  {
#line 1388
  tmp = (*(hw->mac.ops.get_media_type))(hw);
#line 1388
  if ((unsigned int )tmp != 4U) {
#line 1389
    return (-4);
  } else {

  }
#line 1392
  tmp___0 = ixgbe_ext_phy_t_x550em_get_link(hw, & link_up);
#line 1392
  status = (u32 )tmp___0;
#line 1393
  if (status != 0U) {
#line 1394
    return ((s32 )status);
  } else {

  }
#line 1396
  if (! link_up) {
#line 1397
    return (0);
  } else {

  }
#line 1399
  tmp___1 = (*(hw->phy.ops.read_reg))(hw, 51200U, 7U, & speed);
#line 1399
  status = (u32 )tmp___1;
#line 1402
  if (status != 0U) {
#line 1403
    return ((s32 )status);
  } else {

  }
#line 1406
  tmp___2 = ixgbe_ext_phy_t_x550em_get_link(hw, & link_up);
#line 1406
  status = (u32 )tmp___2;
#line 1407
  if (status != 0U) {
#line 1408
    return ((s32 )status);
  } else {

  }
#line 1410
  if (! link_up) {
#line 1411
    return (0);
  } else {

  }
#line 1414
  speed = (unsigned int )speed & 7U;
#line 1416
  switch ((int )speed) {
  case 7: 
#line 1418
  force_speed = 128U;
#line 1419
  goto ldv_54743;
  case 5: 
#line 1421
  force_speed = 32U;
#line 1422
  goto ldv_54743;
  default: ;
#line 1425
  return (-13);
  }
  ldv_54743: 
#line 1428
  tmp___3 = ixgbe_setup_ixfi_x550em(hw, & force_speed);
#line 1428
  return (tmp___3);
}
}
#line 1434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_reset_phy_t_X550em(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  s32 tmp ;

  {
#line 1438
  status = ixgbe_reset_phy_generic(hw);
#line 1440
  if (status != 0) {
#line 1441
    return (status);
  } else {

  }
#line 1444
  tmp = ixgbe_enable_lasi_ext_t_x550em(hw);
#line 1444
  return (tmp);
}
}
#line 1454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_init_phy_ops_X550em(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_phy_info *phy ;
  ixgbe_link_speed speed ;
  s32 ret_val ;
  enum ixgbe_media_type tmp ;

  {
#line 1456
  phy = & hw->phy;
#line 1460
  (*(hw->mac.ops.set_lan_id))(hw);
#line 1462
  tmp = (*(hw->mac.ops.get_media_type))(hw);
#line 1462
  if ((unsigned int )tmp == 1U) {
#line 1463
    phy->phy_semaphore_mask = 6150U;
#line 1464
    ixgbe_setup_mux_ctl(hw);
#line 1469
    phy->nw_mng_if_sel = ixgbe_read_reg(hw, 70008U);
#line 1472
    if (((unsigned long )phy->nw_mng_if_sel & 16777216UL) != 0UL) {
#line 1473
      speed = 160U;
#line 1475
      ret_val = ixgbe_setup_kr_speed_x550em(hw, speed);
    } else {

    }
  } else {

  }
#line 1480
  ret_val = (*(phy->ops.identify))(hw);
#line 1483
  ixgbe_init_mac_link_ops_X550em(hw);
#line 1484
  if ((unsigned int )phy->sfp_type != 65535U) {
#line 1485
    phy->ops.reset = (s32 (*)(struct ixgbe_hw * ))0;
  } else {

  }
#line 1488
  switch ((unsigned int )hw->phy.type) {
  case 5U: 
#line 1490
  phy->ops.setup_link = & ixgbe_setup_kx4_x550em;
#line 1491
  phy->ops.read_reg = & ixgbe_read_phy_reg_x550em;
#line 1492
  phy->ops.write_reg = & ixgbe_write_phy_reg_x550em;
#line 1493
  goto ldv_54757;
  case 4U: 
#line 1495
  phy->ops.setup_link = & ixgbe_setup_kr_x550em;
#line 1496
  phy->ops.read_reg = & ixgbe_read_phy_reg_x550em;
#line 1497
  phy->ops.write_reg = & ixgbe_write_phy_reg_x550em;
#line 1498
  goto ldv_54757;
  case 6U: 
#line 1503
  phy->nw_mng_if_sel = ixgbe_read_reg(hw, 70008U);
#line 1508
  if (((unsigned long )phy->nw_mng_if_sel & 16777216UL) == 0UL) {
#line 1509
    phy->ops.setup_internal_link = & ixgbe_setup_internal_phy_t_x550em;
  } else {
#line 1512
    speed = 160U;
#line 1514
    ret_val = ixgbe_setup_kr_speed_x550em(hw, speed);
  }
#line 1517
  phy->ops.handle_lasi = & ixgbe_handle_lasi_ext_t_x550em;
#line 1518
  phy->ops.reset = & ixgbe_reset_phy_t_X550em;
#line 1519
  goto ldv_54757;
  default: ;
#line 1521
  goto ldv_54757;
  }
  ldv_54757: ;
#line 1524
  return (ret_val);
}
}
#line 1533 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static enum ixgbe_media_type ixgbe_get_media_type_X550em(struct ixgbe_hw *hw ) 
{ 
  enum ixgbe_media_type media_type ;

  {
#line 1538
  switch ((int )hw->device_id) {
  case 5547: ;
  case 5546: 
#line 1541
  media_type = 5;
#line 1542
  goto ldv_54767;
  case 5548: 
#line 1544
  media_type = 1;
#line 1545
  goto ldv_54767;
  case 5550: ;
  case 5549: 
#line 1548
  media_type = 4;
#line 1549
  goto ldv_54767;
  default: 
#line 1551
  media_type = 0;
#line 1552
  goto ldv_54767;
  }
  ldv_54767: ;
#line 1554
  return (media_type);
}
}
#line 1560 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_init_ext_t_x550em(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 reg ;

  {
#line 1565
  status = (*(hw->phy.ops.read_reg))(hw, 52226U, 1U, & reg);
#line 1569
  if (status != 0) {
#line 1570
    return (status);
  } else {

  }
#line 1575
  if (((int )reg & 3) != 0) {
#line 1576
    status = (*(hw->phy.ops.read_reg))(hw, 50297U, 30U, & reg);
#line 1580
    if (status != 0) {
#line 1581
      return (status);
    } else {

    }
#line 1583
    reg = (unsigned int )reg & 32767U;
#line 1585
    status = (*(hw->phy.ops.write_reg))(hw, 50297U, 30U, (int )reg);
#line 1589
    if (status != 0) {
#line 1590
      return (status);
    } else {

    }
  } else {

  }
#line 1593
  return (status);
}
}
#line 1603 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_reset_hw_X550em(struct ixgbe_hw *hw ) 
{ 
  ixgbe_link_speed link_speed ;
  s32 status ;
  u32 ctrl ;
  u32 i ;
  u32 hlreg0 ;
  bool link_up ;
  u32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
#line 1607
  ctrl = 0U;
#line 1610
  link_up = 0;
#line 1613
  status = (*(hw->mac.ops.stop_adapter))(hw);
#line 1614
  if (status != 0) {
#line 1615
    return (status);
  } else {

  }
#line 1618
  ixgbe_clear_tx_pending(hw);
#line 1623
  status = (*(hw->phy.ops.init))(hw);
#line 1626
  if ((unsigned int )hw->phy.type == 6U) {
#line 1627
    status = ixgbe_init_ext_t_x550em(hw);
#line 1628
    if (status != 0) {
#line 1629
      return (status);
    } else {

    }
  } else {

  }
#line 1633
  if ((int )hw->phy.sfp_setup_needed) {
#line 1634
    status = (*(hw->mac.ops.setup_sfp))(hw);
#line 1635
    hw->phy.sfp_setup_needed = 0;
  } else {

  }
#line 1639
  if (! hw->phy.reset_disable && (unsigned long )hw->phy.ops.reset != (unsigned long )((s32 (*)(struct ixgbe_hw * ))0)) {
#line 1640
    (*(hw->phy.ops.reset))(hw);
  } else {

  }
  mac_reset_top: 
#line 1648
  ctrl = 8U;
#line 1650
  if (! hw->force_full_reset) {
#line 1651
    (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
#line 1652
    if ((int )link_up) {
#line 1653
      ctrl = 67108864U;
    } else {

    }
  } else {

  }
#line 1656
  tmp = ixgbe_read_reg(hw, 0U);
#line 1656
  ctrl = tmp | ctrl;
#line 1657
  ixgbe_write_reg(hw, 0U, ctrl);
#line 1658
  ixgbe_read_reg(hw, 8U);
#line 1661
  i = 0U;
#line 1661
  goto ldv_54789;
  ldv_54788: 
#line 1662
  __const_udelay(4295UL);
#line 1663
  ctrl = ixgbe_read_reg(hw, 0U);
#line 1664
  if ((ctrl & 67108872U) == 0U) {
#line 1665
    goto ldv_54787;
  } else {

  }
#line 1661
  i = i + 1U;
  ldv_54789: ;
#line 1661
  if (i <= 9U) {
#line 1663
    goto ldv_54788;
  } else {

  }
  ldv_54787: ;
#line 1668
  if ((ctrl & 67108872U) != 0U) {
#line 1669
    status = -15;
#line 1670
    descriptor.modname = "ixgbe";
#line 1670
    descriptor.function = "ixgbe_reset_hw_X550em";
#line 1670
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c";
#line 1670
    descriptor.format = "Reset polling failed to complete.\n";
#line 1670
    descriptor.lineno = 1670U;
#line 1670
    descriptor.flags = 0U;
#line 1670
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1670
    if (tmp___0 != 0L) {
#line 1670
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Reset polling failed to complete.\n");
    } else {

    }
  } else {

  }
#line 1673
  msleep(50U);
#line 1679
  if ((int )hw->mac.flags & 1) {
#line 1680
    hw->mac.flags = (unsigned int )hw->mac.flags & 254U;
#line 1681
    goto mac_reset_top;
  } else {

  }
#line 1685
  (*(hw->mac.ops.get_mac_addr))(hw, (u8 *)(& hw->mac.perm_addr));
#line 1691
  hw->mac.num_rar_entries = 128U;
#line 1692
  (*(hw->mac.ops.init_rx_addrs))(hw);
#line 1694
  if ((unsigned int )hw->device_id == 5549U) {
#line 1695
    hlreg0 = ixgbe_read_reg(hw, 16960U);
#line 1696
    hlreg0 = hlreg0 & 4294901759U;
#line 1697
    ixgbe_write_reg(hw, 16960U, hlreg0);
  } else {

  }
#line 1700
  if ((unsigned int )hw->device_id == 5548U) {
#line 1701
    ixgbe_setup_mux_ctl(hw);
  } else {

  }
#line 1703
  return (status);
}
}
#line 1712 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_set_ethertype_anti_spoofing_X550(struct ixgbe_hw *hw , bool enable ,
                                                   int vf ) 
{ 
  int vf_target_reg ;
  int vf_target_shift ;
  u32 pfvfspoof ;

  {
#line 1715
  vf_target_reg = vf >> 3;
#line 1716
  vf_target_shift = vf % 8 + 16;
#line 1719
  pfvfspoof = ixgbe_read_reg(hw, (u32 )((vf_target_reg + 8320) * 4));
#line 1720
  if ((int )enable) {
#line 1721
    pfvfspoof = (u32 )(1 << vf_target_shift) | pfvfspoof;
  } else {
#line 1723
    pfvfspoof = (u32 )(~ (1 << vf_target_shift)) & pfvfspoof;
  }
#line 1725
  ixgbe_write_reg(hw, (u32 )((vf_target_reg + 8320) * 4), pfvfspoof);
#line 1726
  return;
}
}
#line 1733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_set_source_address_pruning_X550(struct ixgbe_hw *hw , bool enable ,
                                                  unsigned int pool ) 
{ 
  u64 pfflp ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 1740
  if (pool > 63U) {
#line 1741
    return;
  } else {

  }
#line 1743
  tmp = ixgbe_read_reg(hw, 20656U);
#line 1743
  pfflp = (unsigned long long )tmp;
#line 1744
  tmp___0 = ixgbe_read_reg(hw, 20660U);
#line 1744
  pfflp = ((unsigned long long )tmp___0 << 32) | pfflp;
#line 1746
  if ((int )enable) {
#line 1747
    pfflp = (1ULL << (int )pool) | pfflp;
  } else {
#line 1749
    pfflp = ~ (1ULL << (int )pool) & pfflp;
  }
#line 1751
  ixgbe_write_reg(hw, 20656U, (unsigned int )pfflp);
#line 1752
  ixgbe_write_reg(hw, 20660U, (unsigned int )(pfflp >> 32));
#line 1753
  return;
}
}
#line 1804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_mac_operations mac_ops_X550  = 
#line 1804
     {& ixgbe_init_hw_generic, & ixgbe_reset_hw_X540, & ixgbe_start_hw_X540, & ixgbe_clear_hw_cntrs_generic,
    & ixgbe_get_media_type_X540, & ixgbe_get_mac_addr_generic, & ixgbe_get_san_mac_addr_generic,
    & ixgbe_get_device_caps_generic, & ixgbe_get_wwn_prefix_generic, & ixgbe_stop_adapter_generic,
    & ixgbe_get_bus_info_generic, & ixgbe_set_lan_id_multi_port_pcie, (s32 (*)(struct ixgbe_hw * ,
                                                                               u32  ,
                                                                               u8 * ))0,
    (s32 (*)(struct ixgbe_hw * , u32  , u8  ))0, (s32 (*)(struct ixgbe_hw * ))0, & ixgbe_disable_rx_buff_generic,
    & ixgbe_enable_rx_buff_generic, & ixgbe_enable_rx_dma_generic, & ixgbe_acquire_swfw_sync_X540,
    & ixgbe_release_swfw_sync_X540, & prot_autoc_read_generic, & prot_autoc_write_generic,
    0, 0, 0, 0, & ixgbe_setup_mac_link_X540, & ixgbe_check_mac_link_generic, & ixgbe_get_copper_link_capabilities_generic,
    & ixgbe_set_rxpba_generic, & ixgbe_led_on_generic, & ixgbe_led_off_generic, & ixgbe_blink_led_start_X540,
    & ixgbe_blink_led_stop_X540, & ixgbe_set_rar_generic, & ixgbe_clear_rar_generic,
    & ixgbe_set_vmdq_generic, & ixgbe_set_vmdq_san_mac_generic, & ixgbe_clear_vmdq_generic,
    & ixgbe_init_rx_addrs_generic, & ixgbe_update_mc_addr_list_generic, & ixgbe_enable_mc_generic,
    & ixgbe_disable_mc_generic, & ixgbe_clear_vfta_generic, & ixgbe_set_vfta_generic,
    & ixgbe_init_uta_tables_generic, & ixgbe_set_mac_anti_spoofing, & ixgbe_set_vlan_anti_spoofing,
    & ixgbe_fc_enable_generic, & ixgbe_set_fw_drv_ver_generic, (s32 (*)(struct ixgbe_hw * ))0,
    (s32 (*)(struct ixgbe_hw * ))0, & ixgbe_disable_rx_x550, & ixgbe_enable_rx_generic,
    & ixgbe_set_source_address_pruning_X550, & ixgbe_set_ethertype_anti_spoofing_X550,
    0, 0, 0};
#line 1815 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_mac_operations mac_ops_X550EM_x  = 
#line 1815
     {& ixgbe_init_hw_generic, & ixgbe_reset_hw_X550em, & ixgbe_start_hw_X540, & ixgbe_clear_hw_cntrs_generic,
    & ixgbe_get_media_type_X550em, & ixgbe_get_mac_addr_generic, (s32 (*)(struct ixgbe_hw * ,
                                                                          u8 * ))0,
    & ixgbe_get_device_caps_generic, (s32 (*)(struct ixgbe_hw * , u16 * , u16 * ))0,
    & ixgbe_stop_adapter_generic, & ixgbe_get_bus_info_generic, & ixgbe_set_lan_id_multi_port_pcie,
    (s32 (*)(struct ixgbe_hw * , u32  , u8 * ))0, (s32 (*)(struct ixgbe_hw * , u32  ,
                                                           u8  ))0, & ixgbe_setup_sfp_modules_X550em,
    & ixgbe_disable_rx_buff_generic, & ixgbe_enable_rx_buff_generic, & ixgbe_enable_rx_dma_generic,
    & ixgbe_acquire_swfw_sync_X540, & ixgbe_release_swfw_sync_X540, & prot_autoc_read_generic,
    & prot_autoc_write_generic, 0, 0, 0, 0, (s32 (*)(struct ixgbe_hw * , ixgbe_link_speed  ,
                                                     bool  ))0, & ixgbe_check_mac_link_generic,
    & ixgbe_get_link_capabilities_X550em, & ixgbe_set_rxpba_generic, & ixgbe_led_on_generic,
    & ixgbe_led_off_generic, & ixgbe_blink_led_start_X540, & ixgbe_blink_led_stop_X540,
    & ixgbe_set_rar_generic, & ixgbe_clear_rar_generic, & ixgbe_set_vmdq_generic,
    & ixgbe_set_vmdq_san_mac_generic, & ixgbe_clear_vmdq_generic, & ixgbe_init_rx_addrs_generic,
    & ixgbe_update_mc_addr_list_generic, & ixgbe_enable_mc_generic, & ixgbe_disable_mc_generic,
    & ixgbe_clear_vfta_generic, & ixgbe_set_vfta_generic, & ixgbe_init_uta_tables_generic,
    & ixgbe_set_mac_anti_spoofing, & ixgbe_set_vlan_anti_spoofing, & ixgbe_fc_enable_generic,
    & ixgbe_set_fw_drv_ver_generic, (s32 (*)(struct ixgbe_hw * ))0, (s32 (*)(struct ixgbe_hw * ))0,
    & ixgbe_disable_rx_x550, & ixgbe_enable_rx_generic, & ixgbe_set_source_address_pruning_X550,
    & ixgbe_set_ethertype_anti_spoofing_X550, 0, 0, 0};
#line 1836 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_eeprom_operations eeprom_ops_X550  = 
#line 1836
     {& ixgbe_init_eeprom_params_X550, & ixgbe_read_ee_hostif_X550, & ixgbe_read_ee_hostif_buffer_X550,
    & ixgbe_write_ee_hostif_X550, & ixgbe_write_ee_hostif_buffer_X550, & ixgbe_validate_eeprom_checksum_X550,
    & ixgbe_update_eeprom_checksum_X550, & ixgbe_calc_eeprom_checksum_X550};
#line 1841 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_eeprom_operations eeprom_ops_X550EM_x  = 
#line 1841
     {& ixgbe_init_eeprom_params_X540, & ixgbe_read_ee_hostif_X550, & ixgbe_read_ee_hostif_buffer_X550,
    & ixgbe_write_ee_hostif_X550, & ixgbe_write_ee_hostif_buffer_X550, & ixgbe_validate_eeprom_checksum_X550,
    & ixgbe_update_eeprom_checksum_X550, & ixgbe_calc_eeprom_checksum_X550};
#line 1862 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_phy_operations phy_ops_X550  = 
#line 1862
     {& ixgbe_identify_phy_generic, & ixgbe_identify_module_generic, (s32 (*)(struct ixgbe_hw * ))0,
    (s32 (*)(struct ixgbe_hw * ))0, & ixgbe_read_phy_reg_generic, & ixgbe_write_phy_reg_generic,
    0, 0, & ixgbe_setup_phy_link_generic, 0, & ixgbe_setup_phy_link_speed_generic,
    0, & ixgbe_get_phy_firmware_version_generic, & ixgbe_read_i2c_byte_generic, & ixgbe_write_i2c_byte_generic,
    & ixgbe_read_i2c_sff8472_generic, & ixgbe_read_i2c_eeprom_generic, & ixgbe_write_i2c_eeprom_generic,
    & ixgbe_read_i2c_combined_generic, & ixgbe_write_i2c_combined_generic, & ixgbe_tn_check_overtemp,
    & ixgbe_set_copper_phy_power, 0};
#line 1870 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_phy_operations phy_ops_X550EM_x  = 
#line 1870
     {& ixgbe_identify_phy_x550em, & ixgbe_identify_module_generic, & ixgbe_init_phy_ops_X550em,
    (s32 (*)(struct ixgbe_hw * ))0, & ixgbe_read_phy_reg_generic, & ixgbe_write_phy_reg_generic,
    0, 0, & ixgbe_setup_phy_link_generic, 0, & ixgbe_setup_phy_link_speed_generic,
    0, & ixgbe_get_phy_firmware_version_generic, & ixgbe_read_i2c_byte_generic, & ixgbe_write_i2c_byte_generic,
    & ixgbe_read_i2c_sff8472_generic, & ixgbe_read_i2c_eeprom_generic, & ixgbe_write_i2c_eeprom_generic,
    0, 0, & ixgbe_tn_check_overtemp, & ixgbe_set_copper_phy_power, 0};
#line 1876 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static u32 const   ixgbe_mvals_X550[24U]  = 
#line 1876
  {      65552U,      65564U,      66048U,      66064U, 
        65872U,      65856U,      65888U,      65864U, 
        2U,      4U,      8U,      33554432U, 
        67108864U,      134217728U,      70920U,      70928U, 
        16384U,      512U,      4096U,      1024U, 
        2048U,      256U,      8192U,      89948U};
#line 1880 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static u32 const   ixgbe_mvals_X550EM_x[24U]  = 
#line 1880
  {      65552U,      65564U,      66048U,      66064U, 
        65872U,      65856U,      65888U,      65864U, 
        2U,      4U,      8U,      33554432U, 
        67108864U,      134217728U,      70920U,      70928U, 
        16384U,      512U,      4096U,      1024U, 
        2048U,      256U,      8192U,      89948U};
#line 1884 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
struct ixgbe_info ixgbe_X550_info  =    {4, & ixgbe_get_invariants_X540, & mac_ops_X550, & eeprom_ops_X550, & phy_ops_X550,
    & mbx_ops_generic, (u32 const   *)(& ixgbe_mvals_X550)};
#line 1894 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
struct ixgbe_info ixgbe_X550EM_x_info  =    {5, & ixgbe_get_invariants_X540, & mac_ops_X550EM_x, & eeprom_ops_X550EM_x, & phy_ops_X550EM_x,
    & mbx_ops_generic, (u32 const   *)(& ixgbe_mvals_X550EM_x)};
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
extern int ldv_release_19(void) ;
#line 332
extern int ldv_probe_19(void) ;
#line 333
extern int ldv_release_20(void) ;
#line 334
extern int ldv_probe_20(void) ;
#line 335
extern int ldv_probe_17(void) ;
#line 336
extern int ldv_release_17(void) ;
#line 337
extern int ldv_probe_21(void) ;
#line 338
extern int ldv_release_21(void) ;
#line 339
extern int ldv_setup_16(void) ;
#line 340
extern int ldv_release_16(void) ;
#line 341
extern int ldv_release_18(void) ;
#line 342
extern int ldv_probe_18(void) ;
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_initialize_ixgbe_phy_operations_16(void) 
{ 
  void *tmp ;

  {
#line 346
  tmp = ldv_init_zalloc(1696UL);
#line 346
  phy_ops_X550EM_x_group0 = (struct ixgbe_hw *)tmp;
#line 347
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_initialize_ixgbe_eeprom_operations_18(void) 
{ 
  void *tmp ;

  {
#line 350
  tmp = ldv_init_zalloc(1696UL);
#line 350
  eeprom_ops_X550EM_x_group0 = (struct ixgbe_hw *)tmp;
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_initialize_ixgbe_eeprom_operations_19(void) 
{ 
  void *tmp ;

  {
#line 354
  tmp = ldv_init_zalloc(1696UL);
#line 354
  eeprom_ops_X550_group0 = (struct ixgbe_hw *)tmp;
#line 355
  return;
}
}
#line 357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_initialize_ixgbe_phy_operations_17(void) 
{ 
  void *tmp ;

  {
#line 358
  tmp = ldv_init_zalloc(1696UL);
#line 358
  phy_ops_X550_group0 = (struct ixgbe_hw *)tmp;
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_initialize_ixgbe_mac_operations_21(void) 
{ 
  void *tmp ;

  {
#line 362
  tmp = ldv_init_zalloc(1696UL);
#line 362
  mac_ops_X550_group0 = (struct ixgbe_hw *)tmp;
#line 363
  return;
}
}
#line 365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_initialize_ixgbe_mac_operations_20(void) 
{ 
  void *tmp ;

  {
#line 366
  tmp = ldv_init_zalloc(1696UL);
#line 366
  mac_ops_X550EM_x_group0 = (struct ixgbe_hw *)tmp;
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_main_exported_21(void) 
{ 
  u32 *ldvarg75 ;
  void *tmp ;
  ixgbe_link_speed ldvarg52 ;
  u32 ldvarg74 ;
  bool *ldvarg76 ;
  void *tmp___0 ;
  u32 ldvarg82 ;
  bool ldvarg61 ;
  u16 *ldvarg54 ;
  void *tmp___1 ;
  bool ldvarg68 ;
  bool ldvarg78 ;
  u32 ldvarg70 ;
  bool ldvarg73 ;
  u32 ldvarg63 ;
  bool *ldvarg45 ;
  void *tmp___2 ;
  u32 ldvarg81 ;
  bool ldvarg40 ;
  struct net_device *ldvarg55 ;
  void *tmp___3 ;
  u8 ldvarg36 ;
  bool ldvarg66 ;
  u32 ldvarg79 ;
  u32 ldvarg57 ;
  int ldvarg65 ;
  int ldvarg62 ;
  unsigned int ldvarg49 ;
  u32 ldvarg59 ;
  u32 ldvarg80 ;
  int ldvarg60 ;
  bool *ldvarg41 ;
  void *tmp___4 ;
  u16 *ldvarg31 ;
  void *tmp___5 ;
  u8 ldvarg39 ;
  u8 *ldvarg47 ;
  void *tmp___6 ;
  u32 ldvarg34 ;
  u32 ldvarg48 ;
  u8 *ldvarg33 ;
  void *tmp___7 ;
  u32 ldvarg69 ;
  u8 ldvarg38 ;
  u32 ldvarg35 ;
  u8 *ldvarg44 ;
  void *tmp___8 ;
  int ldvarg64 ;
  u16 *ldvarg53 ;
  void *tmp___9 ;
  u8 ldvarg37 ;
  u32 ldvarg58 ;
  ixgbe_link_speed *ldvarg46 ;
  void *tmp___10 ;
  bool ldvarg50 ;
  u32 ldvarg56 ;
  u32 ldvarg72 ;
  u32 ldvarg71 ;
  ixgbe_link_speed *ldvarg42 ;
  void *tmp___11 ;
  u32 ldvarg43 ;
  int ldvarg67 ;
  u32 ldvarg32 ;
  bool ldvarg51 ;
  u32 ldvarg77 ;
  int tmp___12 ;

  {
#line 370
  tmp = ldv_init_zalloc(4UL);
#line 370
  ldvarg75 = (u32 *)tmp;
#line 373
  tmp___0 = ldv_init_zalloc(1UL);
#line 373
  ldvarg76 = (bool *)tmp___0;
#line 376
  tmp___1 = ldv_init_zalloc(2UL);
#line 376
  ldvarg54 = (u16 *)tmp___1;
#line 382
  tmp___2 = ldv_init_zalloc(1UL);
#line 382
  ldvarg45 = (bool *)tmp___2;
#line 385
  tmp___3 = ldv_init_zalloc(3008UL);
#line 385
  ldvarg55 = (struct net_device *)tmp___3;
#line 396
  tmp___4 = ldv_init_zalloc(1UL);
#line 396
  ldvarg41 = (bool *)tmp___4;
#line 397
  tmp___5 = ldv_init_zalloc(2UL);
#line 397
  ldvarg31 = (u16 *)tmp___5;
#line 399
  tmp___6 = ldv_init_zalloc(1UL);
#line 399
  ldvarg47 = (u8 *)tmp___6;
#line 402
  tmp___7 = ldv_init_zalloc(1UL);
#line 402
  ldvarg33 = (u8 *)tmp___7;
#line 406
  tmp___8 = ldv_init_zalloc(1UL);
#line 406
  ldvarg44 = (u8 *)tmp___8;
#line 408
  tmp___9 = ldv_init_zalloc(2UL);
#line 408
  ldvarg53 = (u16 *)tmp___9;
#line 411
  tmp___10 = ldv_init_zalloc(4UL);
#line 411
  ldvarg46 = (ixgbe_link_speed *)tmp___10;
#line 416
  tmp___11 = ldv_init_zalloc(4UL);
#line 416
  ldvarg42 = (ixgbe_link_speed *)tmp___11;
#line 371
  ldv_memset((void *)(& ldvarg52), 0, 4UL);
#line 372
  ldv_memset((void *)(& ldvarg74), 0, 4UL);
#line 374
  ldv_memset((void *)(& ldvarg82), 0, 4UL);
#line 375
  ldv_memset((void *)(& ldvarg61), 0, 1UL);
#line 377
  ldv_memset((void *)(& ldvarg68), 0, 1UL);
#line 378
  ldv_memset((void *)(& ldvarg78), 0, 1UL);
#line 379
  ldv_memset((void *)(& ldvarg70), 0, 4UL);
#line 380
  ldv_memset((void *)(& ldvarg73), 0, 1UL);
#line 381
  ldv_memset((void *)(& ldvarg63), 0, 4UL);
#line 383
  ldv_memset((void *)(& ldvarg81), 0, 4UL);
#line 384
  ldv_memset((void *)(& ldvarg40), 0, 1UL);
#line 386
  ldv_memset((void *)(& ldvarg36), 0, 1UL);
#line 387
  ldv_memset((void *)(& ldvarg66), 0, 1UL);
#line 388
  ldv_memset((void *)(& ldvarg79), 0, 4UL);
#line 389
  ldv_memset((void *)(& ldvarg57), 0, 4UL);
#line 390
  ldv_memset((void *)(& ldvarg65), 0, 4UL);
#line 391
  ldv_memset((void *)(& ldvarg62), 0, 4UL);
#line 392
  ldv_memset((void *)(& ldvarg49), 0, 4UL);
#line 393
  ldv_memset((void *)(& ldvarg59), 0, 4UL);
#line 394
  ldv_memset((void *)(& ldvarg80), 0, 4UL);
#line 395
  ldv_memset((void *)(& ldvarg60), 0, 4UL);
#line 398
  ldv_memset((void *)(& ldvarg39), 0, 1UL);
#line 400
  ldv_memset((void *)(& ldvarg34), 0, 4UL);
#line 401
  ldv_memset((void *)(& ldvarg48), 0, 4UL);
#line 403
  ldv_memset((void *)(& ldvarg69), 0, 4UL);
#line 404
  ldv_memset((void *)(& ldvarg38), 0, 1UL);
#line 405
  ldv_memset((void *)(& ldvarg35), 0, 4UL);
#line 407
  ldv_memset((void *)(& ldvarg64), 0, 4UL);
#line 409
  ldv_memset((void *)(& ldvarg37), 0, 1UL);
#line 410
  ldv_memset((void *)(& ldvarg58), 0, 4UL);
#line 412
  ldv_memset((void *)(& ldvarg50), 0, 1UL);
#line 413
  ldv_memset((void *)(& ldvarg56), 0, 4UL);
#line 414
  ldv_memset((void *)(& ldvarg72), 0, 4UL);
#line 415
  ldv_memset((void *)(& ldvarg71), 0, 4UL);
#line 417
  ldv_memset((void *)(& ldvarg43), 0, 4UL);
#line 418
  ldv_memset((void *)(& ldvarg67), 0, 4UL);
#line 419
  ldv_memset((void *)(& ldvarg32), 0, 4UL);
#line 420
  ldv_memset((void *)(& ldvarg51), 0, 1UL);
#line 421
  ldv_memset((void *)(& ldvarg77), 0, 4UL);
#line 423
  tmp___12 = __VERIFIER_nondet_int();
#line 423
  switch (tmp___12) {
  case 0: ;
#line 426
  if (ldv_state_variable_21 == 1) {
#line 428
    ixgbe_stop_adapter_generic(mac_ops_X550_group0);
#line 430
    ldv_state_variable_21 = 1;
  } else {

  }
#line 433
  if (ldv_state_variable_21 == 2) {
#line 435
    ixgbe_stop_adapter_generic(mac_ops_X550_group0);
#line 437
    ldv_state_variable_21 = 2;
  } else {

  }
#line 440
  goto ldv_54914;
  case 1: ;
#line 443
  if (ldv_state_variable_21 == 1) {
#line 445
    ixgbe_set_vmdq_san_mac_generic(mac_ops_X550_group0, ldvarg82);
#line 447
    ldv_state_variable_21 = 1;
  } else {

  }
#line 450
  if (ldv_state_variable_21 == 2) {
#line 452
    ixgbe_set_vmdq_san_mac_generic(mac_ops_X550_group0, ldvarg82);
#line 454
    ldv_state_variable_21 = 2;
  } else {

  }
#line 457
  goto ldv_54914;
  case 2: ;
#line 460
  if (ldv_state_variable_21 == 1) {
#line 462
    ixgbe_led_off_generic(mac_ops_X550_group0, ldvarg81);
#line 464
    ldv_state_variable_21 = 1;
  } else {

  }
#line 467
  if (ldv_state_variable_21 == 2) {
#line 469
    ixgbe_led_off_generic(mac_ops_X550_group0, ldvarg81);
#line 471
    ldv_state_variable_21 = 2;
  } else {

  }
#line 474
  goto ldv_54914;
  case 3: ;
#line 477
  if (ldv_state_variable_21 == 1) {
#line 479
    ixgbe_set_vfta_generic(mac_ops_X550_group0, ldvarg80, ldvarg79, (int )ldvarg78);
#line 481
    ldv_state_variable_21 = 1;
  } else {

  }
#line 484
  if (ldv_state_variable_21 == 2) {
#line 486
    ixgbe_set_vfta_generic(mac_ops_X550_group0, ldvarg80, ldvarg79, (int )ldvarg78);
#line 488
    ldv_state_variable_21 = 2;
  } else {

  }
#line 491
  goto ldv_54914;
  case 4: ;
#line 494
  if (ldv_state_variable_21 == 1) {
#line 496
    ixgbe_enable_rx_dma_generic(mac_ops_X550_group0, ldvarg77);
#line 498
    ldv_state_variable_21 = 1;
  } else {

  }
#line 501
  if (ldv_state_variable_21 == 2) {
#line 503
    ixgbe_enable_rx_dma_generic(mac_ops_X550_group0, ldvarg77);
#line 505
    ldv_state_variable_21 = 2;
  } else {

  }
#line 508
  goto ldv_54914;
  case 5: ;
#line 511
  if (ldv_state_variable_21 == 2) {
#line 513
    prot_autoc_read_generic(mac_ops_X550_group0, ldvarg76, ldvarg75);
#line 515
    ldv_state_variable_21 = 2;
  } else {

  }
#line 518
  goto ldv_54914;
  case 6: ;
#line 521
  if (ldv_state_variable_21 == 1) {
#line 523
    ixgbe_enable_rx_buff_generic(mac_ops_X550_group0);
#line 525
    ldv_state_variable_21 = 1;
  } else {

  }
#line 528
  if (ldv_state_variable_21 == 2) {
#line 530
    ixgbe_enable_rx_buff_generic(mac_ops_X550_group0);
#line 532
    ldv_state_variable_21 = 2;
  } else {

  }
#line 535
  goto ldv_54914;
  case 7: ;
#line 538
  if (ldv_state_variable_21 == 2) {
#line 540
    prot_autoc_write_generic(mac_ops_X550_group0, ldvarg74, (int )ldvarg73);
#line 542
    ldv_state_variable_21 = 2;
  } else {

  }
#line 545
  goto ldv_54914;
  case 8: ;
#line 548
  if (ldv_state_variable_21 == 1) {
#line 550
    ixgbe_led_on_generic(mac_ops_X550_group0, ldvarg72);
#line 552
    ldv_state_variable_21 = 1;
  } else {

  }
#line 555
  if (ldv_state_variable_21 == 2) {
#line 557
    ixgbe_led_on_generic(mac_ops_X550_group0, ldvarg72);
#line 559
    ldv_state_variable_21 = 2;
  } else {

  }
#line 562
  goto ldv_54914;
  case 9: ;
#line 565
  if (ldv_state_variable_21 == 1) {
#line 567
    ixgbe_blink_led_stop_X540(mac_ops_X550_group0, ldvarg71);
#line 569
    ldv_state_variable_21 = 1;
  } else {

  }
#line 572
  if (ldv_state_variable_21 == 2) {
#line 574
    ixgbe_blink_led_stop_X540(mac_ops_X550_group0, ldvarg71);
#line 576
    ldv_state_variable_21 = 2;
  } else {

  }
#line 579
  goto ldv_54914;
  case 10: ;
#line 582
  if (ldv_state_variable_21 == 1) {
#line 584
    ixgbe_clear_rar_generic(mac_ops_X550_group0, ldvarg70);
#line 586
    ldv_state_variable_21 = 1;
  } else {

  }
#line 589
  if (ldv_state_variable_21 == 2) {
#line 591
    ixgbe_clear_rar_generic(mac_ops_X550_group0, ldvarg70);
#line 593
    ldv_state_variable_21 = 2;
  } else {

  }
#line 596
  goto ldv_54914;
  case 11: ;
#line 599
  if (ldv_state_variable_21 == 1) {
#line 601
    ixgbe_enable_rx_generic(mac_ops_X550_group0);
#line 603
    ldv_state_variable_21 = 1;
  } else {

  }
#line 606
  if (ldv_state_variable_21 == 2) {
#line 608
    ixgbe_enable_rx_generic(mac_ops_X550_group0);
#line 610
    ldv_state_variable_21 = 2;
  } else {

  }
#line 613
  goto ldv_54914;
  case 12: ;
#line 616
  if (ldv_state_variable_21 == 1) {
#line 618
    ixgbe_get_bus_info_generic(mac_ops_X550_group0);
#line 620
    ldv_state_variable_21 = 1;
  } else {

  }
#line 623
  if (ldv_state_variable_21 == 2) {
#line 625
    ixgbe_get_bus_info_generic(mac_ops_X550_group0);
#line 627
    ldv_state_variable_21 = 2;
  } else {

  }
#line 630
  goto ldv_54914;
  case 13: ;
#line 633
  if (ldv_state_variable_21 == 1) {
#line 635
    ixgbe_blink_led_start_X540(mac_ops_X550_group0, ldvarg69);
#line 637
    ldv_state_variable_21 = 1;
  } else {

  }
#line 640
  if (ldv_state_variable_21 == 2) {
#line 642
    ixgbe_blink_led_start_X540(mac_ops_X550_group0, ldvarg69);
#line 644
    ldv_state_variable_21 = 2;
  } else {

  }
#line 647
  goto ldv_54914;
  case 14: ;
#line 650
  if (ldv_state_variable_21 == 1) {
#line 652
    ixgbe_set_ethertype_anti_spoofing_X550(mac_ops_X550_group0, (int )ldvarg68, ldvarg67);
#line 654
    ldv_state_variable_21 = 1;
  } else {

  }
#line 657
  if (ldv_state_variable_21 == 2) {
#line 659
    ixgbe_set_ethertype_anti_spoofing_X550(mac_ops_X550_group0, (int )ldvarg68, ldvarg67);
#line 661
    ldv_state_variable_21 = 2;
  } else {

  }
#line 664
  goto ldv_54914;
  case 15: ;
#line 667
  if (ldv_state_variable_21 == 1) {
#line 669
    ixgbe_disable_mc_generic(mac_ops_X550_group0);
#line 671
    ldv_state_variable_21 = 1;
  } else {

  }
#line 674
  if (ldv_state_variable_21 == 2) {
#line 676
    ixgbe_disable_mc_generic(mac_ops_X550_group0);
#line 678
    ldv_state_variable_21 = 2;
  } else {

  }
#line 681
  goto ldv_54914;
  case 16: ;
#line 684
  if (ldv_state_variable_21 == 1) {
#line 686
    ixgbe_set_vlan_anti_spoofing(mac_ops_X550_group0, (int )ldvarg66, ldvarg65);
#line 688
    ldv_state_variable_21 = 1;
  } else {

  }
#line 691
  if (ldv_state_variable_21 == 2) {
#line 693
    ixgbe_set_vlan_anti_spoofing(mac_ops_X550_group0, (int )ldvarg66, ldvarg65);
#line 695
    ldv_state_variable_21 = 2;
  } else {

  }
#line 698
  goto ldv_54914;
  case 17: ;
#line 701
  if (ldv_state_variable_21 == 1) {
#line 703
    ixgbe_set_rxpba_generic(mac_ops_X550_group0, ldvarg64, ldvarg63, ldvarg62);
#line 705
    ldv_state_variable_21 = 1;
  } else {

  }
#line 708
  if (ldv_state_variable_21 == 2) {
#line 710
    ixgbe_set_rxpba_generic(mac_ops_X550_group0, ldvarg64, ldvarg63, ldvarg62);
#line 712
    ldv_state_variable_21 = 2;
  } else {

  }
#line 715
  goto ldv_54914;
  case 18: ;
#line 718
  if (ldv_state_variable_21 == 1) {
#line 720
    ixgbe_init_uta_tables_generic(mac_ops_X550_group0);
#line 722
    ldv_state_variable_21 = 1;
  } else {

  }
#line 725
  if (ldv_state_variable_21 == 2) {
#line 727
    ixgbe_init_uta_tables_generic(mac_ops_X550_group0);
#line 729
    ldv_state_variable_21 = 2;
  } else {

  }
#line 732
  goto ldv_54914;
  case 19: ;
#line 735
  if (ldv_state_variable_21 == 1) {
#line 737
    ixgbe_set_mac_anti_spoofing(mac_ops_X550_group0, (int )ldvarg61, ldvarg60);
#line 739
    ldv_state_variable_21 = 1;
  } else {

  }
#line 742
  if (ldv_state_variable_21 == 2) {
#line 744
    ixgbe_set_mac_anti_spoofing(mac_ops_X550_group0, (int )ldvarg61, ldvarg60);
#line 746
    ldv_state_variable_21 = 2;
  } else {

  }
#line 749
  goto ldv_54914;
  case 20: ;
#line 752
  if (ldv_state_variable_21 == 1) {
#line 754
    ixgbe_set_vmdq_generic(mac_ops_X550_group0, ldvarg59, ldvarg58);
#line 756
    ldv_state_variable_21 = 1;
  } else {

  }
#line 759
  if (ldv_state_variable_21 == 2) {
#line 761
    ixgbe_set_vmdq_generic(mac_ops_X550_group0, ldvarg59, ldvarg58);
#line 763
    ldv_state_variable_21 = 2;
  } else {

  }
#line 766
  goto ldv_54914;
  case 21: ;
#line 769
  if (ldv_state_variable_21 == 1) {
#line 771
    ixgbe_clear_vmdq_generic(mac_ops_X550_group0, ldvarg57, ldvarg56);
#line 773
    ldv_state_variable_21 = 1;
  } else {

  }
#line 776
  if (ldv_state_variable_21 == 2) {
#line 778
    ixgbe_clear_vmdq_generic(mac_ops_X550_group0, ldvarg57, ldvarg56);
#line 780
    ldv_state_variable_21 = 2;
  } else {

  }
#line 783
  goto ldv_54914;
  case 22: ;
#line 786
  if (ldv_state_variable_21 == 1) {
#line 788
    ixgbe_clear_vfta_generic(mac_ops_X550_group0);
#line 790
    ldv_state_variable_21 = 1;
  } else {

  }
#line 793
  if (ldv_state_variable_21 == 2) {
#line 795
    ixgbe_clear_vfta_generic(mac_ops_X550_group0);
#line 797
    ldv_state_variable_21 = 2;
  } else {

  }
#line 800
  goto ldv_54914;
  case 23: ;
#line 803
  if (ldv_state_variable_21 == 1) {
#line 805
    ixgbe_get_media_type_X540(mac_ops_X550_group0);
#line 807
    ldv_state_variable_21 = 1;
  } else {

  }
#line 810
  if (ldv_state_variable_21 == 2) {
#line 812
    ixgbe_get_media_type_X540(mac_ops_X550_group0);
#line 814
    ldv_state_variable_21 = 2;
  } else {

  }
#line 817
  goto ldv_54914;
  case 24: ;
#line 820
  if (ldv_state_variable_21 == 1) {
#line 822
    ixgbe_update_mc_addr_list_generic(mac_ops_X550_group0, ldvarg55);
#line 824
    ldv_state_variable_21 = 1;
  } else {

  }
#line 827
  if (ldv_state_variable_21 == 2) {
#line 829
    ixgbe_update_mc_addr_list_generic(mac_ops_X550_group0, ldvarg55);
#line 831
    ldv_state_variable_21 = 2;
  } else {

  }
#line 834
  goto ldv_54914;
  case 25: ;
#line 837
  if (ldv_state_variable_21 == 1) {
#line 839
    ixgbe_init_rx_addrs_generic(mac_ops_X550_group0);
#line 841
    ldv_state_variable_21 = 1;
  } else {

  }
#line 844
  if (ldv_state_variable_21 == 2) {
#line 846
    ixgbe_init_rx_addrs_generic(mac_ops_X550_group0);
#line 848
    ldv_state_variable_21 = 2;
  } else {

  }
#line 851
  goto ldv_54914;
  case 26: ;
#line 854
  if (ldv_state_variable_21 == 1) {
#line 856
    ixgbe_fc_enable_generic(mac_ops_X550_group0);
#line 858
    ldv_state_variable_21 = 1;
  } else {

  }
#line 861
  if (ldv_state_variable_21 == 2) {
#line 863
    ixgbe_fc_enable_generic(mac_ops_X550_group0);
#line 865
    ldv_state_variable_21 = 2;
  } else {

  }
#line 868
  goto ldv_54914;
  case 27: ;
#line 871
  if (ldv_state_variable_21 == 1) {
#line 873
    ixgbe_get_wwn_prefix_generic(mac_ops_X550_group0, ldvarg54, ldvarg53);
#line 875
    ldv_state_variable_21 = 1;
  } else {

  }
#line 878
  if (ldv_state_variable_21 == 2) {
#line 880
    ixgbe_get_wwn_prefix_generic(mac_ops_X550_group0, ldvarg54, ldvarg53);
#line 882
    ldv_state_variable_21 = 2;
  } else {

  }
#line 885
  goto ldv_54914;
  case 28: ;
#line 888
  if (ldv_state_variable_21 == 1) {
#line 890
    ixgbe_clear_hw_cntrs_generic(mac_ops_X550_group0);
#line 892
    ldv_state_variable_21 = 1;
  } else {

  }
#line 895
  if (ldv_state_variable_21 == 2) {
#line 897
    ixgbe_clear_hw_cntrs_generic(mac_ops_X550_group0);
#line 899
    ldv_state_variable_21 = 2;
  } else {

  }
#line 902
  goto ldv_54914;
  case 29: ;
#line 905
  if (ldv_state_variable_21 == 1) {
#line 907
    ixgbe_setup_mac_link_X540(mac_ops_X550_group0, ldvarg52, (int )ldvarg51);
#line 909
    ldv_state_variable_21 = 1;
  } else {

  }
#line 912
  if (ldv_state_variable_21 == 2) {
#line 914
    ixgbe_setup_mac_link_X540(mac_ops_X550_group0, ldvarg52, (int )ldvarg51);
#line 916
    ldv_state_variable_21 = 2;
  } else {

  }
#line 919
  goto ldv_54914;
  case 30: ;
#line 922
  if (ldv_state_variable_21 == 1) {
#line 924
    ixgbe_disable_rx_x550(mac_ops_X550_group0);
#line 926
    ldv_state_variable_21 = 1;
  } else {

  }
#line 929
  if (ldv_state_variable_21 == 2) {
#line 931
    ixgbe_disable_rx_x550(mac_ops_X550_group0);
#line 933
    ldv_state_variable_21 = 2;
  } else {

  }
#line 936
  goto ldv_54914;
  case 31: ;
#line 939
  if (ldv_state_variable_21 == 1) {
#line 941
    ixgbe_set_source_address_pruning_X550(mac_ops_X550_group0, (int )ldvarg50, ldvarg49);
#line 943
    ldv_state_variable_21 = 1;
  } else {

  }
#line 946
  if (ldv_state_variable_21 == 2) {
#line 948
    ixgbe_set_source_address_pruning_X550(mac_ops_X550_group0, (int )ldvarg50, ldvarg49);
#line 950
    ldv_state_variable_21 = 2;
  } else {

  }
#line 953
  goto ldv_54914;
  case 32: ;
#line 956
  if (ldv_state_variable_21 == 1) {
#line 958
    ixgbe_set_lan_id_multi_port_pcie(mac_ops_X550_group0);
#line 960
    ldv_state_variable_21 = 1;
  } else {

  }
#line 963
  if (ldv_state_variable_21 == 2) {
#line 965
    ixgbe_set_lan_id_multi_port_pcie(mac_ops_X550_group0);
#line 967
    ldv_state_variable_21 = 2;
  } else {

  }
#line 970
  goto ldv_54914;
  case 33: ;
#line 973
  if (ldv_state_variable_21 == 1) {
#line 975
    ixgbe_acquire_swfw_sync_X540(mac_ops_X550_group0, ldvarg48);
#line 977
    ldv_state_variable_21 = 1;
  } else {

  }
#line 980
  if (ldv_state_variable_21 == 2) {
#line 982
    ixgbe_acquire_swfw_sync_X540(mac_ops_X550_group0, ldvarg48);
#line 984
    ldv_state_variable_21 = 2;
  } else {

  }
#line 987
  goto ldv_54914;
  case 34: ;
#line 990
  if (ldv_state_variable_21 == 1) {
#line 992
    ixgbe_start_hw_X540(mac_ops_X550_group0);
#line 994
    ldv_state_variable_21 = 1;
  } else {

  }
#line 997
  if (ldv_state_variable_21 == 2) {
#line 999
    ixgbe_start_hw_X540(mac_ops_X550_group0);
#line 1001
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1004
  goto ldv_54914;
  case 35: ;
#line 1007
  if (ldv_state_variable_21 == 1) {
#line 1009
    ixgbe_enable_mc_generic(mac_ops_X550_group0);
#line 1011
    ldv_state_variable_21 = 1;
  } else {

  }
#line 1014
  if (ldv_state_variable_21 == 2) {
#line 1016
    ixgbe_enable_mc_generic(mac_ops_X550_group0);
#line 1018
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1021
  goto ldv_54914;
  case 36: ;
#line 1024
  if (ldv_state_variable_21 == 1) {
#line 1026
    ixgbe_get_mac_addr_generic(mac_ops_X550_group0, ldvarg47);
#line 1028
    ldv_state_variable_21 = 1;
  } else {

  }
#line 1031
  if (ldv_state_variable_21 == 2) {
#line 1033
    ixgbe_get_mac_addr_generic(mac_ops_X550_group0, ldvarg47);
#line 1035
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1038
  goto ldv_54914;
  case 37: ;
#line 1041
  if (ldv_state_variable_21 == 1) {
#line 1043
    ixgbe_get_copper_link_capabilities_generic(mac_ops_X550_group0, ldvarg46, ldvarg45);
#line 1045
    ldv_state_variable_21 = 1;
  } else {

  }
#line 1048
  if (ldv_state_variable_21 == 2) {
#line 1050
    ixgbe_get_copper_link_capabilities_generic(mac_ops_X550_group0, ldvarg46, ldvarg45);
#line 1052
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1055
  goto ldv_54914;
  case 38: ;
#line 1058
  if (ldv_state_variable_21 == 1) {
#line 1060
    ixgbe_get_san_mac_addr_generic(mac_ops_X550_group0, ldvarg44);
#line 1062
    ldv_state_variable_21 = 1;
  } else {

  }
#line 1065
  if (ldv_state_variable_21 == 2) {
#line 1067
    ixgbe_get_san_mac_addr_generic(mac_ops_X550_group0, ldvarg44);
#line 1069
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1072
  goto ldv_54914;
  case 39: ;
#line 1075
  if (ldv_state_variable_21 == 1) {
#line 1077
    ixgbe_init_hw_generic(mac_ops_X550_group0);
#line 1079
    ldv_state_variable_21 = 1;
  } else {

  }
#line 1082
  if (ldv_state_variable_21 == 2) {
#line 1084
    ixgbe_init_hw_generic(mac_ops_X550_group0);
#line 1086
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1089
  goto ldv_54914;
  case 40: ;
#line 1092
  if (ldv_state_variable_21 == 1) {
#line 1094
    ixgbe_reset_hw_X540(mac_ops_X550_group0);
#line 1096
    ldv_state_variable_21 = 1;
  } else {

  }
#line 1099
  if (ldv_state_variable_21 == 2) {
#line 1101
    ixgbe_reset_hw_X540(mac_ops_X550_group0);
#line 1103
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1106
  goto ldv_54914;
  case 41: ;
#line 1109
  if (ldv_state_variable_21 == 1) {
#line 1111
    ixgbe_release_swfw_sync_X540(mac_ops_X550_group0, ldvarg43);
#line 1113
    ldv_state_variable_21 = 1;
  } else {

  }
#line 1116
  if (ldv_state_variable_21 == 2) {
#line 1118
    ixgbe_release_swfw_sync_X540(mac_ops_X550_group0, ldvarg43);
#line 1120
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1123
  goto ldv_54914;
  case 42: ;
#line 1126
  if (ldv_state_variable_21 == 1) {
#line 1128
    ixgbe_check_mac_link_generic(mac_ops_X550_group0, ldvarg42, ldvarg41, (int )ldvarg40);
#line 1130
    ldv_state_variable_21 = 1;
  } else {

  }
#line 1133
  if (ldv_state_variable_21 == 2) {
#line 1135
    ixgbe_check_mac_link_generic(mac_ops_X550_group0, ldvarg42, ldvarg41, (int )ldvarg40);
#line 1137
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1140
  goto ldv_54914;
  case 43: ;
#line 1143
  if (ldv_state_variable_21 == 1) {
#line 1145
    ixgbe_set_fw_drv_ver_generic(mac_ops_X550_group0, (int )ldvarg38, (int )ldvarg37,
                                 (int )ldvarg36, (int )ldvarg39);
#line 1147
    ldv_state_variable_21 = 1;
  } else {

  }
#line 1150
  if (ldv_state_variable_21 == 2) {
#line 1152
    ixgbe_set_fw_drv_ver_generic(mac_ops_X550_group0, (int )ldvarg38, (int )ldvarg37,
                                 (int )ldvarg36, (int )ldvarg39);
#line 1154
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1157
  goto ldv_54914;
  case 44: ;
#line 1160
  if (ldv_state_variable_21 == 1) {
#line 1162
    ixgbe_set_rar_generic(mac_ops_X550_group0, ldvarg34, ldvarg33, ldvarg32, ldvarg35);
#line 1164
    ldv_state_variable_21 = 1;
  } else {

  }
#line 1167
  if (ldv_state_variable_21 == 2) {
#line 1169
    ixgbe_set_rar_generic(mac_ops_X550_group0, ldvarg34, ldvarg33, ldvarg32, ldvarg35);
#line 1171
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1174
  goto ldv_54914;
  case 45: ;
#line 1177
  if (ldv_state_variable_21 == 1) {
#line 1179
    ixgbe_get_device_caps_generic(mac_ops_X550_group0, ldvarg31);
#line 1181
    ldv_state_variable_21 = 1;
  } else {

  }
#line 1184
  if (ldv_state_variable_21 == 2) {
#line 1186
    ixgbe_get_device_caps_generic(mac_ops_X550_group0, ldvarg31);
#line 1188
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1191
  goto ldv_54914;
  case 46: ;
#line 1194
  if (ldv_state_variable_21 == 1) {
#line 1196
    ixgbe_disable_rx_buff_generic(mac_ops_X550_group0);
#line 1198
    ldv_state_variable_21 = 1;
  } else {

  }
#line 1201
  if (ldv_state_variable_21 == 2) {
#line 1203
    ixgbe_disable_rx_buff_generic(mac_ops_X550_group0);
#line 1205
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1208
  goto ldv_54914;
  case 47: ;
#line 1211
  if (ldv_state_variable_21 == 2) {
#line 1213
    ldv_release_21();
#line 1215
    ldv_state_variable_21 = 1;
#line 1216
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1219
  goto ldv_54914;
  case 48: ;
#line 1222
  if (ldv_state_variable_21 == 1) {
#line 1224
    ldv_probe_21();
#line 1226
    ldv_state_variable_21 = 2;
#line 1227
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1230
  goto ldv_54914;
  default: 
#line 1231
  ldv_stop();
  }
  ldv_54914: ;
#line 1235
  return;
}
}
#line 1237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_main_exported_17(void) 
{ 
  bool ldvarg107 ;
  u8 ldvarg117 ;
  u8 ldvarg110 ;
  ixgbe_link_speed ldvarg108 ;
  u32 ldvarg105 ;
  u16 ldvarg124 ;
  u8 *ldvarg116 ;
  void *tmp ;
  u32 ldvarg103 ;
  u8 ldvarg99 ;
  u8 *ldvarg114 ;
  void *tmp___0 ;
  bool ldvarg119 ;
  u8 ldvarg125 ;
  u8 ldvarg113 ;
  u16 *ldvarg120 ;
  void *tmp___1 ;
  u8 ldvarg112 ;
  u32 ldvarg102 ;
  u8 *ldvarg98 ;
  void *tmp___2 ;
  u8 ldvarg111 ;
  u16 ldvarg123 ;
  u8 ldvarg109 ;
  u8 ldvarg115 ;
  u16 *ldvarg118 ;
  void *tmp___3 ;
  u8 ldvarg100 ;
  u8 ldvarg122 ;
  u16 *ldvarg101 ;
  void *tmp___4 ;
  u32 ldvarg106 ;
  u16 ldvarg104 ;
  u16 ldvarg121 ;
  int tmp___5 ;

  {
#line 1244
  tmp = ldv_init_zalloc(1UL);
#line 1244
  ldvarg116 = (u8 *)tmp;
#line 1247
  tmp___0 = ldv_init_zalloc(1UL);
#line 1247
  ldvarg114 = (u8 *)tmp___0;
#line 1251
  tmp___1 = ldv_init_zalloc(2UL);
#line 1251
  ldvarg120 = (u16 *)tmp___1;
#line 1254
  tmp___2 = ldv_init_zalloc(1UL);
#line 1254
  ldvarg98 = (u8 *)tmp___2;
#line 1259
  tmp___3 = ldv_init_zalloc(2UL);
#line 1259
  ldvarg118 = (u16 *)tmp___3;
#line 1262
  tmp___4 = ldv_init_zalloc(2UL);
#line 1262
  ldvarg101 = (u16 *)tmp___4;
#line 1238
  ldv_memset((void *)(& ldvarg107), 0, 1UL);
#line 1239
  ldv_memset((void *)(& ldvarg117), 0, 1UL);
#line 1240
  ldv_memset((void *)(& ldvarg110), 0, 1UL);
#line 1241
  ldv_memset((void *)(& ldvarg108), 0, 4UL);
#line 1242
  ldv_memset((void *)(& ldvarg105), 0, 4UL);
#line 1243
  ldv_memset((void *)(& ldvarg124), 0, 2UL);
#line 1245
  ldv_memset((void *)(& ldvarg103), 0, 4UL);
#line 1246
  ldv_memset((void *)(& ldvarg99), 0, 1UL);
#line 1248
  ldv_memset((void *)(& ldvarg119), 0, 1UL);
#line 1249
  ldv_memset((void *)(& ldvarg125), 0, 1UL);
#line 1250
  ldv_memset((void *)(& ldvarg113), 0, 1UL);
#line 1252
  ldv_memset((void *)(& ldvarg112), 0, 1UL);
#line 1253
  ldv_memset((void *)(& ldvarg102), 0, 4UL);
#line 1255
  ldv_memset((void *)(& ldvarg111), 0, 1UL);
#line 1256
  ldv_memset((void *)(& ldvarg123), 0, 2UL);
#line 1257
  ldv_memset((void *)(& ldvarg109), 0, 1UL);
#line 1258
  ldv_memset((void *)(& ldvarg115), 0, 1UL);
#line 1260
  ldv_memset((void *)(& ldvarg100), 0, 1UL);
#line 1261
  ldv_memset((void *)(& ldvarg122), 0, 1UL);
#line 1263
  ldv_memset((void *)(& ldvarg106), 0, 4UL);
#line 1264
  ldv_memset((void *)(& ldvarg104), 0, 2UL);
#line 1265
  ldv_memset((void *)(& ldvarg121), 0, 2UL);
#line 1267
  tmp___5 = __VERIFIER_nondet_int();
#line 1267
  switch (tmp___5) {
  case 0: ;
#line 1270
  if (ldv_state_variable_17 == 2) {
#line 1272
    ixgbe_write_i2c_combined_generic(phy_ops_X550_group0, (int )ldvarg125, (int )ldvarg124,
                                     (int )ldvarg123);
#line 1274
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1277
  goto ldv_54996;
  case 1: ;
#line 1280
  if (ldv_state_variable_17 == 2) {
#line 1282
    ixgbe_read_i2c_combined_generic(phy_ops_X550_group0, (int )ldvarg122, (int )ldvarg121,
                                    ldvarg120);
#line 1284
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1287
  goto ldv_54996;
  case 2: ;
#line 1290
  if (ldv_state_variable_17 == 1) {
#line 1292
    ixgbe_set_copper_phy_power(phy_ops_X550_group0, (int )ldvarg119);
#line 1294
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1297
  if (ldv_state_variable_17 == 2) {
#line 1299
    ixgbe_set_copper_phy_power(phy_ops_X550_group0, (int )ldvarg119);
#line 1301
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1304
  goto ldv_54996;
  case 3: ;
#line 1307
  if (ldv_state_variable_17 == 1) {
#line 1309
    ixgbe_get_phy_firmware_version_generic(phy_ops_X550_group0, ldvarg118);
#line 1311
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1314
  if (ldv_state_variable_17 == 2) {
#line 1316
    ixgbe_get_phy_firmware_version_generic(phy_ops_X550_group0, ldvarg118);
#line 1318
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1321
  goto ldv_54996;
  case 4: ;
#line 1324
  if (ldv_state_variable_17 == 1) {
#line 1326
    ixgbe_read_i2c_eeprom_generic(phy_ops_X550_group0, (int )ldvarg117, ldvarg116);
#line 1328
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1331
  if (ldv_state_variable_17 == 2) {
#line 1333
    ixgbe_read_i2c_eeprom_generic(phy_ops_X550_group0, (int )ldvarg117, ldvarg116);
#line 1335
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1338
  goto ldv_54996;
  case 5: ;
#line 1341
  if (ldv_state_variable_17 == 1) {
#line 1343
    ixgbe_read_i2c_sff8472_generic(phy_ops_X550_group0, (int )ldvarg115, ldvarg114);
#line 1345
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1348
  if (ldv_state_variable_17 == 2) {
#line 1350
    ixgbe_read_i2c_sff8472_generic(phy_ops_X550_group0, (int )ldvarg115, ldvarg114);
#line 1352
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1355
  goto ldv_54996;
  case 6: ;
#line 1358
  if (ldv_state_variable_17 == 1) {
#line 1360
    ixgbe_write_i2c_byte_generic(phy_ops_X550_group0, (int )ldvarg113, (int )ldvarg112,
                                 (int )ldvarg111);
#line 1362
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1365
  if (ldv_state_variable_17 == 2) {
#line 1367
    ixgbe_write_i2c_byte_generic(phy_ops_X550_group0, (int )ldvarg113, (int )ldvarg112,
                                 (int )ldvarg111);
#line 1369
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1372
  goto ldv_54996;
  case 7: ;
#line 1375
  if (ldv_state_variable_17 == 1) {
#line 1377
    ixgbe_setup_phy_link_generic(phy_ops_X550_group0);
#line 1379
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1382
  if (ldv_state_variable_17 == 2) {
#line 1384
    ixgbe_setup_phy_link_generic(phy_ops_X550_group0);
#line 1386
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1389
  goto ldv_54996;
  case 8: ;
#line 1392
  if (ldv_state_variable_17 == 1) {
#line 1394
    ixgbe_identify_phy_generic(phy_ops_X550_group0);
#line 1396
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1399
  if (ldv_state_variable_17 == 2) {
#line 1401
    ixgbe_identify_phy_generic(phy_ops_X550_group0);
#line 1403
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1406
  goto ldv_54996;
  case 9: ;
#line 1409
  if (ldv_state_variable_17 == 1) {
#line 1411
    ixgbe_write_i2c_eeprom_generic(phy_ops_X550_group0, (int )ldvarg110, (int )ldvarg109);
#line 1413
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1416
  if (ldv_state_variable_17 == 2) {
#line 1418
    ixgbe_write_i2c_eeprom_generic(phy_ops_X550_group0, (int )ldvarg110, (int )ldvarg109);
#line 1420
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1423
  goto ldv_54996;
  case 10: ;
#line 1426
  if (ldv_state_variable_17 == 1) {
#line 1428
    ixgbe_setup_phy_link_speed_generic(phy_ops_X550_group0, ldvarg108, (int )ldvarg107);
#line 1430
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1433
  if (ldv_state_variable_17 == 2) {
#line 1435
    ixgbe_setup_phy_link_speed_generic(phy_ops_X550_group0, ldvarg108, (int )ldvarg107);
#line 1437
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1440
  goto ldv_54996;
  case 11: ;
#line 1443
  if (ldv_state_variable_17 == 1) {
#line 1445
    ixgbe_write_phy_reg_generic(phy_ops_X550_group0, ldvarg106, ldvarg105, (int )ldvarg104);
#line 1447
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1450
  if (ldv_state_variable_17 == 2) {
#line 1452
    ixgbe_write_phy_reg_generic(phy_ops_X550_group0, ldvarg106, ldvarg105, (int )ldvarg104);
#line 1454
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1457
  goto ldv_54996;
  case 12: ;
#line 1460
  if (ldv_state_variable_17 == 1) {
#line 1462
    ixgbe_identify_module_generic(phy_ops_X550_group0);
#line 1464
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1467
  if (ldv_state_variable_17 == 2) {
#line 1469
    ixgbe_identify_module_generic(phy_ops_X550_group0);
#line 1471
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1474
  goto ldv_54996;
  case 13: ;
#line 1477
  if (ldv_state_variable_17 == 1) {
#line 1479
    ixgbe_read_phy_reg_generic(phy_ops_X550_group0, ldvarg103, ldvarg102, ldvarg101);
#line 1481
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1484
  if (ldv_state_variable_17 == 2) {
#line 1486
    ixgbe_read_phy_reg_generic(phy_ops_X550_group0, ldvarg103, ldvarg102, ldvarg101);
#line 1488
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1491
  goto ldv_54996;
  case 14: ;
#line 1494
  if (ldv_state_variable_17 == 1) {
#line 1496
    ixgbe_tn_check_overtemp(phy_ops_X550_group0);
#line 1498
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1501
  if (ldv_state_variable_17 == 2) {
#line 1503
    ixgbe_tn_check_overtemp(phy_ops_X550_group0);
#line 1505
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1508
  goto ldv_54996;
  case 15: ;
#line 1511
  if (ldv_state_variable_17 == 1) {
#line 1513
    ixgbe_read_i2c_byte_generic(phy_ops_X550_group0, (int )ldvarg100, (int )ldvarg99,
                                ldvarg98);
#line 1515
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1518
  if (ldv_state_variable_17 == 2) {
#line 1520
    ixgbe_read_i2c_byte_generic(phy_ops_X550_group0, (int )ldvarg100, (int )ldvarg99,
                                ldvarg98);
#line 1522
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1525
  goto ldv_54996;
  case 16: ;
#line 1528
  if (ldv_state_variable_17 == 2) {
#line 1530
    ldv_release_17();
#line 1532
    ldv_state_variable_17 = 1;
#line 1533
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1536
  goto ldv_54996;
  case 17: ;
#line 1539
  if (ldv_state_variable_17 == 1) {
#line 1541
    ldv_probe_17();
#line 1543
    ldv_state_variable_17 = 2;
#line 1544
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1547
  goto ldv_54996;
  default: 
#line 1548
  ldv_stop();
  }
  ldv_54996: ;
#line 1552
  return;
}
}
#line 1554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_main_exported_20(void) 
{ 
  int ldvarg294 ;
  u32 ldvarg292 ;
  bool ldvarg283 ;
  u8 ldvarg273 ;
  ixgbe_link_speed *ldvarg279 ;
  void *tmp ;
  u32 ldvarg298 ;
  u8 *ldvarg267 ;
  void *tmp___0 ;
  bool ldvarg297 ;
  u16 *ldvarg265 ;
  void *tmp___1 ;
  ixgbe_link_speed *ldvarg276 ;
  void *tmp___2 ;
  u32 ldvarg287 ;
  u32 ldvarg286 ;
  u8 ldvarg270 ;
  u32 ldvarg301 ;
  unsigned int ldvarg282 ;
  u32 ldvarg306 ;
  int ldvarg289 ;
  int ldvarg291 ;
  u32 ldvarg288 ;
  u32 ldvarg277 ;
  bool *ldvarg275 ;
  void *tmp___3 ;
  int ldvarg293 ;
  u8 ldvarg272 ;
  bool ldvarg274 ;
  u32 *ldvarg304 ;
  void *tmp___4 ;
  u8 *ldvarg280 ;
  void *tmp___5 ;
  struct net_device *ldvarg284 ;
  void *tmp___6 ;
  bool ldvarg302 ;
  u32 ldvarg303 ;
  u8 ldvarg271 ;
  u32 ldvarg281 ;
  int ldvarg296 ;
  bool ldvarg295 ;
  u32 ldvarg310 ;
  u32 ldvarg300 ;
  u32 ldvarg285 ;
  u32 ldvarg309 ;
  u32 ldvarg311 ;
  u32 ldvarg266 ;
  bool *ldvarg278 ;
  void *tmp___7 ;
  u32 ldvarg299 ;
  bool ldvarg307 ;
  bool *ldvarg305 ;
  void *tmp___8 ;
  u32 ldvarg268 ;
  u32 ldvarg308 ;
  u32 ldvarg269 ;
  bool ldvarg290 ;
  int tmp___9 ;

  {
#line 1559
  tmp = ldv_init_zalloc(4UL);
#line 1559
  ldvarg279 = (ixgbe_link_speed *)tmp;
#line 1561
  tmp___0 = ldv_init_zalloc(1UL);
#line 1561
  ldvarg267 = (u8 *)tmp___0;
#line 1563
  tmp___1 = ldv_init_zalloc(2UL);
#line 1563
  ldvarg265 = (u16 *)tmp___1;
#line 1564
  tmp___2 = ldv_init_zalloc(4UL);
#line 1564
  ldvarg276 = (ixgbe_link_speed *)tmp___2;
#line 1575
  tmp___3 = ldv_init_zalloc(1UL);
#line 1575
  ldvarg275 = (bool *)tmp___3;
#line 1579
  tmp___4 = ldv_init_zalloc(4UL);
#line 1579
  ldvarg304 = (u32 *)tmp___4;
#line 1580
  tmp___5 = ldv_init_zalloc(1UL);
#line 1580
  ldvarg280 = (u8 *)tmp___5;
#line 1581
  tmp___6 = ldv_init_zalloc(3008UL);
#line 1581
  ldvarg284 = (struct net_device *)tmp___6;
#line 1594
  tmp___7 = ldv_init_zalloc(1UL);
#line 1594
  ldvarg278 = (bool *)tmp___7;
#line 1597
  tmp___8 = ldv_init_zalloc(1UL);
#line 1597
  ldvarg305 = (bool *)tmp___8;
#line 1555
  ldv_memset((void *)(& ldvarg294), 0, 4UL);
#line 1556
  ldv_memset((void *)(& ldvarg292), 0, 4UL);
#line 1557
  ldv_memset((void *)(& ldvarg283), 0, 1UL);
#line 1558
  ldv_memset((void *)(& ldvarg273), 0, 1UL);
#line 1560
  ldv_memset((void *)(& ldvarg298), 0, 4UL);
#line 1562
  ldv_memset((void *)(& ldvarg297), 0, 1UL);
#line 1565
  ldv_memset((void *)(& ldvarg287), 0, 4UL);
#line 1566
  ldv_memset((void *)(& ldvarg286), 0, 4UL);
#line 1567
  ldv_memset((void *)(& ldvarg270), 0, 1UL);
#line 1568
  ldv_memset((void *)(& ldvarg301), 0, 4UL);
#line 1569
  ldv_memset((void *)(& ldvarg282), 0, 4UL);
#line 1570
  ldv_memset((void *)(& ldvarg306), 0, 4UL);
#line 1571
  ldv_memset((void *)(& ldvarg289), 0, 4UL);
#line 1572
  ldv_memset((void *)(& ldvarg291), 0, 4UL);
#line 1573
  ldv_memset((void *)(& ldvarg288), 0, 4UL);
#line 1574
  ldv_memset((void *)(& ldvarg277), 0, 4UL);
#line 1576
  ldv_memset((void *)(& ldvarg293), 0, 4UL);
#line 1577
  ldv_memset((void *)(& ldvarg272), 0, 1UL);
#line 1578
  ldv_memset((void *)(& ldvarg274), 0, 1UL);
#line 1582
  ldv_memset((void *)(& ldvarg302), 0, 1UL);
#line 1583
  ldv_memset((void *)(& ldvarg303), 0, 4UL);
#line 1584
  ldv_memset((void *)(& ldvarg271), 0, 1UL);
#line 1585
  ldv_memset((void *)(& ldvarg281), 0, 4UL);
#line 1586
  ldv_memset((void *)(& ldvarg296), 0, 4UL);
#line 1587
  ldv_memset((void *)(& ldvarg295), 0, 1UL);
#line 1588
  ldv_memset((void *)(& ldvarg310), 0, 4UL);
#line 1589
  ldv_memset((void *)(& ldvarg300), 0, 4UL);
#line 1590
  ldv_memset((void *)(& ldvarg285), 0, 4UL);
#line 1591
  ldv_memset((void *)(& ldvarg309), 0, 4UL);
#line 1592
  ldv_memset((void *)(& ldvarg311), 0, 4UL);
#line 1593
  ldv_memset((void *)(& ldvarg266), 0, 4UL);
#line 1595
  ldv_memset((void *)(& ldvarg299), 0, 4UL);
#line 1596
  ldv_memset((void *)(& ldvarg307), 0, 1UL);
#line 1598
  ldv_memset((void *)(& ldvarg268), 0, 4UL);
#line 1599
  ldv_memset((void *)(& ldvarg308), 0, 4UL);
#line 1600
  ldv_memset((void *)(& ldvarg269), 0, 4UL);
#line 1601
  ldv_memset((void *)(& ldvarg290), 0, 1UL);
#line 1603
  tmp___9 = __VERIFIER_nondet_int();
#line 1603
  switch (tmp___9) {
  case 0: ;
#line 1606
  if (ldv_state_variable_20 == 1) {
#line 1608
    ixgbe_stop_adapter_generic(mac_ops_X550EM_x_group0);
#line 1610
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1613
  if (ldv_state_variable_20 == 2) {
#line 1615
    ixgbe_stop_adapter_generic(mac_ops_X550EM_x_group0);
#line 1617
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1620
  goto ldv_55066;
  case 1: ;
#line 1623
  if (ldv_state_variable_20 == 1) {
#line 1625
    ixgbe_set_vmdq_san_mac_generic(mac_ops_X550EM_x_group0, ldvarg311);
#line 1627
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1630
  if (ldv_state_variable_20 == 2) {
#line 1632
    ixgbe_set_vmdq_san_mac_generic(mac_ops_X550EM_x_group0, ldvarg311);
#line 1634
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1637
  goto ldv_55066;
  case 2: ;
#line 1640
  if (ldv_state_variable_20 == 1) {
#line 1642
    ixgbe_led_off_generic(mac_ops_X550EM_x_group0, ldvarg310);
#line 1644
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1647
  if (ldv_state_variable_20 == 2) {
#line 1649
    ixgbe_led_off_generic(mac_ops_X550EM_x_group0, ldvarg310);
#line 1651
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1654
  goto ldv_55066;
  case 3: ;
#line 1657
  if (ldv_state_variable_20 == 1) {
#line 1659
    ixgbe_set_vfta_generic(mac_ops_X550EM_x_group0, ldvarg309, ldvarg308, (int )ldvarg307);
#line 1661
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1664
  if (ldv_state_variable_20 == 2) {
#line 1666
    ixgbe_set_vfta_generic(mac_ops_X550EM_x_group0, ldvarg309, ldvarg308, (int )ldvarg307);
#line 1668
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1671
  goto ldv_55066;
  case 4: ;
#line 1674
  if (ldv_state_variable_20 == 1) {
#line 1676
    ixgbe_enable_rx_dma_generic(mac_ops_X550EM_x_group0, ldvarg306);
#line 1678
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1681
  if (ldv_state_variable_20 == 2) {
#line 1683
    ixgbe_enable_rx_dma_generic(mac_ops_X550EM_x_group0, ldvarg306);
#line 1685
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1688
  goto ldv_55066;
  case 5: ;
#line 1691
  if (ldv_state_variable_20 == 2) {
#line 1693
    prot_autoc_read_generic(mac_ops_X550EM_x_group0, ldvarg305, ldvarg304);
#line 1695
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1698
  goto ldv_55066;
  case 6: ;
#line 1701
  if (ldv_state_variable_20 == 1) {
#line 1703
    ixgbe_enable_rx_buff_generic(mac_ops_X550EM_x_group0);
#line 1705
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1708
  if (ldv_state_variable_20 == 2) {
#line 1710
    ixgbe_enable_rx_buff_generic(mac_ops_X550EM_x_group0);
#line 1712
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1715
  goto ldv_55066;
  case 7: ;
#line 1718
  if (ldv_state_variable_20 == 2) {
#line 1720
    prot_autoc_write_generic(mac_ops_X550EM_x_group0, ldvarg303, (int )ldvarg302);
#line 1722
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1725
  goto ldv_55066;
  case 8: ;
#line 1728
  if (ldv_state_variable_20 == 1) {
#line 1730
    ixgbe_led_on_generic(mac_ops_X550EM_x_group0, ldvarg301);
#line 1732
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1735
  if (ldv_state_variable_20 == 2) {
#line 1737
    ixgbe_led_on_generic(mac_ops_X550EM_x_group0, ldvarg301);
#line 1739
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1742
  goto ldv_55066;
  case 9: ;
#line 1745
  if (ldv_state_variable_20 == 1) {
#line 1747
    ixgbe_blink_led_stop_X540(mac_ops_X550EM_x_group0, ldvarg300);
#line 1749
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1752
  if (ldv_state_variable_20 == 2) {
#line 1754
    ixgbe_blink_led_stop_X540(mac_ops_X550EM_x_group0, ldvarg300);
#line 1756
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1759
  goto ldv_55066;
  case 10: ;
#line 1762
  if (ldv_state_variable_20 == 1) {
#line 1764
    ixgbe_clear_rar_generic(mac_ops_X550EM_x_group0, ldvarg299);
#line 1766
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1769
  if (ldv_state_variable_20 == 2) {
#line 1771
    ixgbe_clear_rar_generic(mac_ops_X550EM_x_group0, ldvarg299);
#line 1773
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1776
  goto ldv_55066;
  case 11: ;
#line 1779
  if (ldv_state_variable_20 == 1) {
#line 1781
    ixgbe_enable_rx_generic(mac_ops_X550EM_x_group0);
#line 1783
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1786
  if (ldv_state_variable_20 == 2) {
#line 1788
    ixgbe_enable_rx_generic(mac_ops_X550EM_x_group0);
#line 1790
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1793
  goto ldv_55066;
  case 12: ;
#line 1796
  if (ldv_state_variable_20 == 1) {
#line 1798
    ixgbe_get_bus_info_generic(mac_ops_X550EM_x_group0);
#line 1800
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1803
  if (ldv_state_variable_20 == 2) {
#line 1805
    ixgbe_get_bus_info_generic(mac_ops_X550EM_x_group0);
#line 1807
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1810
  goto ldv_55066;
  case 13: ;
#line 1813
  if (ldv_state_variable_20 == 1) {
#line 1815
    ixgbe_blink_led_start_X540(mac_ops_X550EM_x_group0, ldvarg298);
#line 1817
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1820
  if (ldv_state_variable_20 == 2) {
#line 1822
    ixgbe_blink_led_start_X540(mac_ops_X550EM_x_group0, ldvarg298);
#line 1824
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1827
  goto ldv_55066;
  case 14: ;
#line 1830
  if (ldv_state_variable_20 == 1) {
#line 1832
    ixgbe_set_ethertype_anti_spoofing_X550(mac_ops_X550EM_x_group0, (int )ldvarg297,
                                           ldvarg296);
#line 1834
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1837
  if (ldv_state_variable_20 == 2) {
#line 1839
    ixgbe_set_ethertype_anti_spoofing_X550(mac_ops_X550EM_x_group0, (int )ldvarg297,
                                           ldvarg296);
#line 1841
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1844
  goto ldv_55066;
  case 15: ;
#line 1847
  if (ldv_state_variable_20 == 1) {
#line 1849
    ixgbe_disable_mc_generic(mac_ops_X550EM_x_group0);
#line 1851
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1854
  if (ldv_state_variable_20 == 2) {
#line 1856
    ixgbe_disable_mc_generic(mac_ops_X550EM_x_group0);
#line 1858
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1861
  goto ldv_55066;
  case 16: ;
#line 1864
  if (ldv_state_variable_20 == 1) {
#line 1866
    ixgbe_set_vlan_anti_spoofing(mac_ops_X550EM_x_group0, (int )ldvarg295, ldvarg294);
#line 1868
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1871
  if (ldv_state_variable_20 == 2) {
#line 1873
    ixgbe_set_vlan_anti_spoofing(mac_ops_X550EM_x_group0, (int )ldvarg295, ldvarg294);
#line 1875
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1878
  goto ldv_55066;
  case 17: ;
#line 1881
  if (ldv_state_variable_20 == 1) {
#line 1883
    ixgbe_set_rxpba_generic(mac_ops_X550EM_x_group0, ldvarg293, ldvarg292, ldvarg291);
#line 1885
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1888
  if (ldv_state_variable_20 == 2) {
#line 1890
    ixgbe_set_rxpba_generic(mac_ops_X550EM_x_group0, ldvarg293, ldvarg292, ldvarg291);
#line 1892
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1895
  goto ldv_55066;
  case 18: ;
#line 1898
  if (ldv_state_variable_20 == 1) {
#line 1900
    ixgbe_init_uta_tables_generic(mac_ops_X550EM_x_group0);
#line 1902
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1905
  if (ldv_state_variable_20 == 2) {
#line 1907
    ixgbe_init_uta_tables_generic(mac_ops_X550EM_x_group0);
#line 1909
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1912
  goto ldv_55066;
  case 19: ;
#line 1915
  if (ldv_state_variable_20 == 1) {
#line 1917
    ixgbe_set_mac_anti_spoofing(mac_ops_X550EM_x_group0, (int )ldvarg290, ldvarg289);
#line 1919
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1922
  if (ldv_state_variable_20 == 2) {
#line 1924
    ixgbe_set_mac_anti_spoofing(mac_ops_X550EM_x_group0, (int )ldvarg290, ldvarg289);
#line 1926
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1929
  goto ldv_55066;
  case 20: ;
#line 1932
  if (ldv_state_variable_20 == 1) {
#line 1934
    ixgbe_set_vmdq_generic(mac_ops_X550EM_x_group0, ldvarg288, ldvarg287);
#line 1936
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1939
  if (ldv_state_variable_20 == 2) {
#line 1941
    ixgbe_set_vmdq_generic(mac_ops_X550EM_x_group0, ldvarg288, ldvarg287);
#line 1943
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1946
  goto ldv_55066;
  case 21: ;
#line 1949
  if (ldv_state_variable_20 == 1) {
#line 1951
    ixgbe_clear_vmdq_generic(mac_ops_X550EM_x_group0, ldvarg286, ldvarg285);
#line 1953
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1956
  if (ldv_state_variable_20 == 2) {
#line 1958
    ixgbe_clear_vmdq_generic(mac_ops_X550EM_x_group0, ldvarg286, ldvarg285);
#line 1960
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1963
  goto ldv_55066;
  case 22: ;
#line 1966
  if (ldv_state_variable_20 == 1) {
#line 1968
    ixgbe_clear_vfta_generic(mac_ops_X550EM_x_group0);
#line 1970
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1973
  if (ldv_state_variable_20 == 2) {
#line 1975
    ixgbe_clear_vfta_generic(mac_ops_X550EM_x_group0);
#line 1977
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1980
  goto ldv_55066;
  case 23: ;
#line 1983
  if (ldv_state_variable_20 == 1) {
#line 1985
    ixgbe_get_media_type_X550em(mac_ops_X550EM_x_group0);
#line 1987
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1990
  if (ldv_state_variable_20 == 2) {
#line 1992
    ixgbe_get_media_type_X550em(mac_ops_X550EM_x_group0);
#line 1994
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1997
  goto ldv_55066;
  case 24: ;
#line 2000
  if (ldv_state_variable_20 == 1) {
#line 2002
    ixgbe_update_mc_addr_list_generic(mac_ops_X550EM_x_group0, ldvarg284);
#line 2004
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2007
  if (ldv_state_variable_20 == 2) {
#line 2009
    ixgbe_update_mc_addr_list_generic(mac_ops_X550EM_x_group0, ldvarg284);
#line 2011
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2014
  goto ldv_55066;
  case 25: ;
#line 2017
  if (ldv_state_variable_20 == 1) {
#line 2019
    ixgbe_init_rx_addrs_generic(mac_ops_X550EM_x_group0);
#line 2021
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2024
  if (ldv_state_variable_20 == 2) {
#line 2026
    ixgbe_init_rx_addrs_generic(mac_ops_X550EM_x_group0);
#line 2028
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2031
  goto ldv_55066;
  case 26: ;
#line 2034
  if (ldv_state_variable_20 == 1) {
#line 2036
    ixgbe_fc_enable_generic(mac_ops_X550EM_x_group0);
#line 2038
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2041
  if (ldv_state_variable_20 == 2) {
#line 2043
    ixgbe_fc_enable_generic(mac_ops_X550EM_x_group0);
#line 2045
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2048
  goto ldv_55066;
  case 27: ;
#line 2051
  if (ldv_state_variable_20 == 1) {
#line 2053
    ixgbe_clear_hw_cntrs_generic(mac_ops_X550EM_x_group0);
#line 2055
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2058
  if (ldv_state_variable_20 == 2) {
#line 2060
    ixgbe_clear_hw_cntrs_generic(mac_ops_X550EM_x_group0);
#line 2062
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2065
  goto ldv_55066;
  case 28: ;
#line 2068
  if (ldv_state_variable_20 == 1) {
#line 2070
    ixgbe_disable_rx_x550(mac_ops_X550EM_x_group0);
#line 2072
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2075
  if (ldv_state_variable_20 == 2) {
#line 2077
    ixgbe_disable_rx_x550(mac_ops_X550EM_x_group0);
#line 2079
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2082
  goto ldv_55066;
  case 29: ;
#line 2085
  if (ldv_state_variable_20 == 1) {
#line 2087
    ixgbe_set_source_address_pruning_X550(mac_ops_X550EM_x_group0, (int )ldvarg283,
                                          ldvarg282);
#line 2089
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2092
  if (ldv_state_variable_20 == 2) {
#line 2094
    ixgbe_set_source_address_pruning_X550(mac_ops_X550EM_x_group0, (int )ldvarg283,
                                          ldvarg282);
#line 2096
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2099
  goto ldv_55066;
  case 30: ;
#line 2102
  if (ldv_state_variable_20 == 1) {
#line 2104
    ixgbe_set_lan_id_multi_port_pcie(mac_ops_X550EM_x_group0);
#line 2106
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2109
  if (ldv_state_variable_20 == 2) {
#line 2111
    ixgbe_set_lan_id_multi_port_pcie(mac_ops_X550EM_x_group0);
#line 2113
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2116
  goto ldv_55066;
  case 31: ;
#line 2119
  if (ldv_state_variable_20 == 1) {
#line 2121
    ixgbe_acquire_swfw_sync_X540(mac_ops_X550EM_x_group0, ldvarg281);
#line 2123
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2126
  if (ldv_state_variable_20 == 2) {
#line 2128
    ixgbe_acquire_swfw_sync_X540(mac_ops_X550EM_x_group0, ldvarg281);
#line 2130
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2133
  goto ldv_55066;
  case 32: ;
#line 2136
  if (ldv_state_variable_20 == 1) {
#line 2138
    ixgbe_start_hw_X540(mac_ops_X550EM_x_group0);
#line 2140
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2143
  if (ldv_state_variable_20 == 2) {
#line 2145
    ixgbe_start_hw_X540(mac_ops_X550EM_x_group0);
#line 2147
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2150
  goto ldv_55066;
  case 33: ;
#line 2153
  if (ldv_state_variable_20 == 1) {
#line 2155
    ixgbe_enable_mc_generic(mac_ops_X550EM_x_group0);
#line 2157
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2160
  if (ldv_state_variable_20 == 2) {
#line 2162
    ixgbe_enable_mc_generic(mac_ops_X550EM_x_group0);
#line 2164
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2167
  goto ldv_55066;
  case 34: ;
#line 2170
  if (ldv_state_variable_20 == 1) {
#line 2172
    ixgbe_get_mac_addr_generic(mac_ops_X550EM_x_group0, ldvarg280);
#line 2174
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2177
  if (ldv_state_variable_20 == 2) {
#line 2179
    ixgbe_get_mac_addr_generic(mac_ops_X550EM_x_group0, ldvarg280);
#line 2181
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2184
  goto ldv_55066;
  case 35: ;
#line 2187
  if (ldv_state_variable_20 == 1) {
#line 2189
    ixgbe_get_link_capabilities_X550em(mac_ops_X550EM_x_group0, ldvarg279, ldvarg278);
#line 2191
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2194
  if (ldv_state_variable_20 == 2) {
#line 2196
    ixgbe_get_link_capabilities_X550em(mac_ops_X550EM_x_group0, ldvarg279, ldvarg278);
#line 2198
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2201
  goto ldv_55066;
  case 36: ;
#line 2204
  if (ldv_state_variable_20 == 1) {
#line 2206
    ixgbe_init_hw_generic(mac_ops_X550EM_x_group0);
#line 2208
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2211
  if (ldv_state_variable_20 == 2) {
#line 2213
    ixgbe_init_hw_generic(mac_ops_X550EM_x_group0);
#line 2215
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2218
  goto ldv_55066;
  case 37: ;
#line 2221
  if (ldv_state_variable_20 == 1) {
#line 2223
    ixgbe_reset_hw_X550em(mac_ops_X550EM_x_group0);
#line 2225
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2228
  if (ldv_state_variable_20 == 2) {
#line 2230
    ixgbe_reset_hw_X550em(mac_ops_X550EM_x_group0);
#line 2232
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2235
  goto ldv_55066;
  case 38: ;
#line 2238
  if (ldv_state_variable_20 == 1) {
#line 2240
    ixgbe_release_swfw_sync_X540(mac_ops_X550EM_x_group0, ldvarg277);
#line 2242
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2245
  if (ldv_state_variable_20 == 2) {
#line 2247
    ixgbe_release_swfw_sync_X540(mac_ops_X550EM_x_group0, ldvarg277);
#line 2249
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2252
  goto ldv_55066;
  case 39: ;
#line 2255
  if (ldv_state_variable_20 == 1) {
#line 2257
    ixgbe_check_mac_link_generic(mac_ops_X550EM_x_group0, ldvarg276, ldvarg275, (int )ldvarg274);
#line 2259
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2262
  if (ldv_state_variable_20 == 2) {
#line 2264
    ixgbe_check_mac_link_generic(mac_ops_X550EM_x_group0, ldvarg276, ldvarg275, (int )ldvarg274);
#line 2266
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2269
  goto ldv_55066;
  case 40: ;
#line 2272
  if (ldv_state_variable_20 == 1) {
#line 2274
    ixgbe_set_fw_drv_ver_generic(mac_ops_X550EM_x_group0, (int )ldvarg272, (int )ldvarg271,
                                 (int )ldvarg270, (int )ldvarg273);
#line 2276
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2279
  if (ldv_state_variable_20 == 2) {
#line 2281
    ixgbe_set_fw_drv_ver_generic(mac_ops_X550EM_x_group0, (int )ldvarg272, (int )ldvarg271,
                                 (int )ldvarg270, (int )ldvarg273);
#line 2283
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2286
  goto ldv_55066;
  case 41: ;
#line 2289
  if (ldv_state_variable_20 == 1) {
#line 2291
    ixgbe_set_rar_generic(mac_ops_X550EM_x_group0, ldvarg268, ldvarg267, ldvarg266,
                          ldvarg269);
#line 2293
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2296
  if (ldv_state_variable_20 == 2) {
#line 2298
    ixgbe_set_rar_generic(mac_ops_X550EM_x_group0, ldvarg268, ldvarg267, ldvarg266,
                          ldvarg269);
#line 2300
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2303
  goto ldv_55066;
  case 42: ;
#line 2306
  if (ldv_state_variable_20 == 1) {
#line 2308
    ixgbe_setup_sfp_modules_X550em(mac_ops_X550EM_x_group0);
#line 2310
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2313
  if (ldv_state_variable_20 == 2) {
#line 2315
    ixgbe_setup_sfp_modules_X550em(mac_ops_X550EM_x_group0);
#line 2317
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2320
  goto ldv_55066;
  case 43: ;
#line 2323
  if (ldv_state_variable_20 == 1) {
#line 2325
    ixgbe_get_device_caps_generic(mac_ops_X550EM_x_group0, ldvarg265);
#line 2327
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2330
  if (ldv_state_variable_20 == 2) {
#line 2332
    ixgbe_get_device_caps_generic(mac_ops_X550EM_x_group0, ldvarg265);
#line 2334
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2337
  goto ldv_55066;
  case 44: ;
#line 2340
  if (ldv_state_variable_20 == 1) {
#line 2342
    ixgbe_disable_rx_buff_generic(mac_ops_X550EM_x_group0);
#line 2344
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2347
  if (ldv_state_variable_20 == 2) {
#line 2349
    ixgbe_disable_rx_buff_generic(mac_ops_X550EM_x_group0);
#line 2351
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2354
  goto ldv_55066;
  case 45: ;
#line 2357
  if (ldv_state_variable_20 == 2) {
#line 2359
    ldv_release_20();
#line 2361
    ldv_state_variable_20 = 1;
#line 2362
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2365
  goto ldv_55066;
  case 46: ;
#line 2368
  if (ldv_state_variable_20 == 1) {
#line 2370
    ldv_probe_20();
#line 2372
    ldv_state_variable_20 = 2;
#line 2373
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 2376
  goto ldv_55066;
  default: 
#line 2377
  ldv_stop();
  }
  ldv_55066: ;
#line 2381
  return;
}
}
#line 2383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_main_exported_15(void) 
{ 
  struct ixgbe_hw *ldvarg442 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2384
  tmp = ldv_init_zalloc(1696UL);
#line 2384
  ldvarg442 = (struct ixgbe_hw *)tmp;
#line 2386
  tmp___0 = __VERIFIER_nondet_int();
#line 2386
  switch (tmp___0) {
  case 0: ;
#line 2389
  if (ldv_state_variable_15 == 1) {
#line 2391
    ixgbe_get_invariants_X540(ldvarg442);
#line 2393
    ldv_state_variable_15 = 1;
  } else {

  }
#line 2396
  goto ldv_55119;
  default: 
#line 2397
  ldv_stop();
  }
  ldv_55119: ;
#line 2401
  return;
}
}
#line 2403 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_main_exported_14(void) 
{ 
  struct ixgbe_hw *ldvarg312 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2404
  tmp = ldv_init_zalloc(1696UL);
#line 2404
  ldvarg312 = (struct ixgbe_hw *)tmp;
#line 2406
  tmp___0 = __VERIFIER_nondet_int();
#line 2406
  switch (tmp___0) {
  case 0: ;
#line 2409
  if (ldv_state_variable_14 == 1) {
#line 2411
    ixgbe_get_invariants_X540(ldvarg312);
#line 2413
    ldv_state_variable_14 = 1;
  } else {

  }
#line 2416
  goto ldv_55126;
  default: 
#line 2417
  ldv_stop();
  }
  ldv_55126: ;
#line 2421
  return;
}
}
#line 2423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_main_exported_18(void) 
{ 
  u16 ldvarg130 ;
  u16 ldvarg135 ;
  u16 ldvarg129 ;
  u16 ldvarg136 ;
  u16 *ldvarg126 ;
  void *tmp ;
  u16 ldvarg132 ;
  u16 ldvarg128 ;
  u16 ldvarg133 ;
  u16 *ldvarg134 ;
  void *tmp___0 ;
  u16 *ldvarg127 ;
  void *tmp___1 ;
  u16 *ldvarg131 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 2428
  tmp = ldv_init_zalloc(2UL);
#line 2428
  ldvarg126 = (u16 *)tmp;
#line 2432
  tmp___0 = ldv_init_zalloc(2UL);
#line 2432
  ldvarg134 = (u16 *)tmp___0;
#line 2433
  tmp___1 = ldv_init_zalloc(2UL);
#line 2433
  ldvarg127 = (u16 *)tmp___1;
#line 2434
  tmp___2 = ldv_init_zalloc(2UL);
#line 2434
  ldvarg131 = (u16 *)tmp___2;
#line 2424
  ldv_memset((void *)(& ldvarg130), 0, 2UL);
#line 2425
  ldv_memset((void *)(& ldvarg135), 0, 2UL);
#line 2426
  ldv_memset((void *)(& ldvarg129), 0, 2UL);
#line 2427
  ldv_memset((void *)(& ldvarg136), 0, 2UL);
#line 2429
  ldv_memset((void *)(& ldvarg132), 0, 2UL);
#line 2430
  ldv_memset((void *)(& ldvarg128), 0, 2UL);
#line 2431
  ldv_memset((void *)(& ldvarg133), 0, 2UL);
#line 2436
  tmp___3 = __VERIFIER_nondet_int();
#line 2436
  switch (tmp___3) {
  case 0: ;
#line 2439
  if (ldv_state_variable_18 == 2) {
#line 2441
    ixgbe_write_ee_hostif_buffer_X550(eeprom_ops_X550EM_x_group0, (int )ldvarg136,
                                      (int )ldvarg135, ldvarg134);
#line 2443
    ldv_state_variable_18 = 2;
  } else {

  }
#line 2446
  goto ldv_55143;
  case 1: ;
#line 2449
  if (ldv_state_variable_18 == 2) {
#line 2451
    ixgbe_read_ee_hostif_buffer_X550(eeprom_ops_X550EM_x_group0, (int )ldvarg133,
                                     (int )ldvarg132, ldvarg131);
#line 2453
    ldv_state_variable_18 = 2;
  } else {

  }
#line 2456
  goto ldv_55143;
  case 2: ;
#line 2459
  if (ldv_state_variable_18 == 1) {
#line 2461
    ixgbe_update_eeprom_checksum_X550(eeprom_ops_X550EM_x_group0);
#line 2463
    ldv_state_variable_18 = 1;
  } else {

  }
#line 2466
  if (ldv_state_variable_18 == 2) {
#line 2468
    ixgbe_update_eeprom_checksum_X550(eeprom_ops_X550EM_x_group0);
#line 2470
    ldv_state_variable_18 = 2;
  } else {

  }
#line 2473
  goto ldv_55143;
  case 3: ;
#line 2476
  if (ldv_state_variable_18 == 1) {
#line 2478
    ixgbe_calc_eeprom_checksum_X550(eeprom_ops_X550EM_x_group0);
#line 2480
    ldv_state_variable_18 = 1;
  } else {

  }
#line 2483
  if (ldv_state_variable_18 == 2) {
#line 2485
    ixgbe_calc_eeprom_checksum_X550(eeprom_ops_X550EM_x_group0);
#line 2487
    ldv_state_variable_18 = 2;
  } else {

  }
#line 2490
  goto ldv_55143;
  case 4: ;
#line 2493
  if (ldv_state_variable_18 == 1) {
#line 2495
    ixgbe_write_ee_hostif_X550(eeprom_ops_X550EM_x_group0, (int )ldvarg130, (int )ldvarg129);
#line 2497
    ldv_state_variable_18 = 1;
  } else {

  }
#line 2500
  if (ldv_state_variable_18 == 2) {
#line 2502
    ixgbe_write_ee_hostif_X550(eeprom_ops_X550EM_x_group0, (int )ldvarg130, (int )ldvarg129);
#line 2504
    ldv_state_variable_18 = 2;
  } else {

  }
#line 2507
  goto ldv_55143;
  case 5: ;
#line 2510
  if (ldv_state_variable_18 == 1) {
#line 2512
    ixgbe_read_ee_hostif_X550(eeprom_ops_X550EM_x_group0, (int )ldvarg128, ldvarg127);
#line 2514
    ldv_state_variable_18 = 1;
  } else {

  }
#line 2517
  if (ldv_state_variable_18 == 2) {
#line 2519
    ixgbe_read_ee_hostif_X550(eeprom_ops_X550EM_x_group0, (int )ldvarg128, ldvarg127);
#line 2521
    ldv_state_variable_18 = 2;
  } else {

  }
#line 2524
  goto ldv_55143;
  case 6: ;
#line 2527
  if (ldv_state_variable_18 == 1) {
#line 2529
    ixgbe_init_eeprom_params_X540(eeprom_ops_X550EM_x_group0);
#line 2531
    ldv_state_variable_18 = 1;
  } else {

  }
#line 2534
  if (ldv_state_variable_18 == 2) {
#line 2536
    ixgbe_init_eeprom_params_X540(eeprom_ops_X550EM_x_group0);
#line 2538
    ldv_state_variable_18 = 2;
  } else {

  }
#line 2541
  goto ldv_55143;
  case 7: ;
#line 2544
  if (ldv_state_variable_18 == 1) {
#line 2546
    ixgbe_validate_eeprom_checksum_X550(eeprom_ops_X550EM_x_group0, ldvarg126);
#line 2548
    ldv_state_variable_18 = 1;
  } else {

  }
#line 2551
  if (ldv_state_variable_18 == 2) {
#line 2553
    ixgbe_validate_eeprom_checksum_X550(eeprom_ops_X550EM_x_group0, ldvarg126);
#line 2555
    ldv_state_variable_18 = 2;
  } else {

  }
#line 2558
  goto ldv_55143;
  case 8: ;
#line 2561
  if (ldv_state_variable_18 == 2) {
#line 2563
    ldv_release_18();
#line 2565
    ldv_state_variable_18 = 1;
#line 2566
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2569
  goto ldv_55143;
  case 9: ;
#line 2572
  if (ldv_state_variable_18 == 1) {
#line 2574
    ldv_probe_18();
#line 2576
    ldv_state_variable_18 = 2;
#line 2577
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 2580
  goto ldv_55143;
  default: 
#line 2581
  ldv_stop();
  }
  ldv_55143: ;
#line 2585
  return;
}
}
#line 2587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_main_exported_16(void) 
{ 
  u8 ldvarg189 ;
  u16 ldvarg182 ;
  u32 ldvarg180 ;
  bool ldvarg197 ;
  u16 *ldvarg179 ;
  void *tmp ;
  u8 *ldvarg194 ;
  void *tmp___0 ;
  u16 *ldvarg196 ;
  void *tmp___1 ;
  u8 *ldvarg176 ;
  void *tmp___2 ;
  u32 ldvarg183 ;
  u8 ldvarg191 ;
  u8 *ldvarg192 ;
  void *tmp___3 ;
  bool ldvarg185 ;
  u8 ldvarg188 ;
  u8 ldvarg193 ;
  u32 ldvarg181 ;
  u8 ldvarg177 ;
  u8 ldvarg190 ;
  u32 ldvarg184 ;
  ixgbe_link_speed ldvarg186 ;
  u8 ldvarg178 ;
  u8 ldvarg187 ;
  u8 ldvarg195 ;
  int tmp___4 ;

  {
#line 2592
  tmp = ldv_init_zalloc(2UL);
#line 2592
  ldvarg179 = (u16 *)tmp;
#line 2593
  tmp___0 = ldv_init_zalloc(1UL);
#line 2593
  ldvarg194 = (u8 *)tmp___0;
#line 2594
  tmp___1 = ldv_init_zalloc(2UL);
#line 2594
  ldvarg196 = (u16 *)tmp___1;
#line 2595
  tmp___2 = ldv_init_zalloc(1UL);
#line 2595
  ldvarg176 = (u8 *)tmp___2;
#line 2598
  tmp___3 = ldv_init_zalloc(1UL);
#line 2598
  ldvarg192 = (u8 *)tmp___3;
#line 2588
  ldv_memset((void *)(& ldvarg189), 0, 1UL);
#line 2589
  ldv_memset((void *)(& ldvarg182), 0, 2UL);
#line 2590
  ldv_memset((void *)(& ldvarg180), 0, 4UL);
#line 2591
  ldv_memset((void *)(& ldvarg197), 0, 1UL);
#line 2596
  ldv_memset((void *)(& ldvarg183), 0, 4UL);
#line 2597
  ldv_memset((void *)(& ldvarg191), 0, 1UL);
#line 2599
  ldv_memset((void *)(& ldvarg185), 0, 1UL);
#line 2600
  ldv_memset((void *)(& ldvarg188), 0, 1UL);
#line 2601
  ldv_memset((void *)(& ldvarg193), 0, 1UL);
#line 2602
  ldv_memset((void *)(& ldvarg181), 0, 4UL);
#line 2603
  ldv_memset((void *)(& ldvarg177), 0, 1UL);
#line 2604
  ldv_memset((void *)(& ldvarg190), 0, 1UL);
#line 2605
  ldv_memset((void *)(& ldvarg184), 0, 4UL);
#line 2606
  ldv_memset((void *)(& ldvarg186), 0, 4UL);
#line 2607
  ldv_memset((void *)(& ldvarg178), 0, 1UL);
#line 2608
  ldv_memset((void *)(& ldvarg187), 0, 1UL);
#line 2609
  ldv_memset((void *)(& ldvarg195), 0, 1UL);
#line 2611
  tmp___4 = __VERIFIER_nondet_int();
#line 2611
  switch (tmp___4) {
  case 0: ;
#line 2614
  if (ldv_state_variable_16 == 1) {
#line 2616
    ixgbe_set_copper_phy_power(phy_ops_X550EM_x_group0, (int )ldvarg197);
#line 2618
    ldv_state_variable_16 = 1;
  } else {

  }
#line 2621
  if (ldv_state_variable_16 == 3) {
#line 2623
    ixgbe_set_copper_phy_power(phy_ops_X550EM_x_group0, (int )ldvarg197);
#line 2625
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2628
  if (ldv_state_variable_16 == 2) {
#line 2630
    ixgbe_set_copper_phy_power(phy_ops_X550EM_x_group0, (int )ldvarg197);
#line 2632
    ldv_state_variable_16 = 2;
  } else {

  }
#line 2635
  goto ldv_55180;
  case 1: ;
#line 2638
  if (ldv_state_variable_16 == 1) {
#line 2640
    ixgbe_get_phy_firmware_version_generic(phy_ops_X550EM_x_group0, ldvarg196);
#line 2642
    ldv_state_variable_16 = 1;
  } else {

  }
#line 2645
  if (ldv_state_variable_16 == 3) {
#line 2647
    ixgbe_get_phy_firmware_version_generic(phy_ops_X550EM_x_group0, ldvarg196);
#line 2649
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2652
  if (ldv_state_variable_16 == 2) {
#line 2654
    ixgbe_get_phy_firmware_version_generic(phy_ops_X550EM_x_group0, ldvarg196);
#line 2656
    ldv_state_variable_16 = 2;
  } else {

  }
#line 2659
  goto ldv_55180;
  case 2: ;
#line 2662
  if (ldv_state_variable_16 == 3) {
#line 2664
    ixgbe_read_i2c_eeprom_generic(phy_ops_X550EM_x_group0, (int )ldvarg195, ldvarg194);
#line 2666
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2669
  goto ldv_55180;
  case 3: ;
#line 2672
  if (ldv_state_variable_16 == 1) {
#line 2674
    ixgbe_read_i2c_sff8472_generic(phy_ops_X550EM_x_group0, (int )ldvarg193, ldvarg192);
#line 2676
    ldv_state_variable_16 = 1;
  } else {

  }
#line 2679
  if (ldv_state_variable_16 == 3) {
#line 2681
    ixgbe_read_i2c_sff8472_generic(phy_ops_X550EM_x_group0, (int )ldvarg193, ldvarg192);
#line 2683
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2686
  if (ldv_state_variable_16 == 2) {
#line 2688
    ixgbe_read_i2c_sff8472_generic(phy_ops_X550EM_x_group0, (int )ldvarg193, ldvarg192);
#line 2690
    ldv_state_variable_16 = 2;
  } else {

  }
#line 2693
  goto ldv_55180;
  case 4: ;
#line 2696
  if (ldv_state_variable_16 == 3) {
#line 2698
    ixgbe_write_i2c_byte_generic(phy_ops_X550EM_x_group0, (int )ldvarg191, (int )ldvarg190,
                                 (int )ldvarg189);
#line 2700
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2703
  goto ldv_55180;
  case 5: ;
#line 2706
  if (ldv_state_variable_16 == 1) {
#line 2708
    ixgbe_identify_phy_x550em(phy_ops_X550EM_x_group0);
#line 2710
    ldv_state_variable_16 = 1;
  } else {

  }
#line 2713
  if (ldv_state_variable_16 == 3) {
#line 2715
    ixgbe_identify_phy_x550em(phy_ops_X550EM_x_group0);
#line 2717
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2720
  if (ldv_state_variable_16 == 2) {
#line 2722
    ixgbe_identify_phy_x550em(phy_ops_X550EM_x_group0);
#line 2724
    ldv_state_variable_16 = 2;
  } else {

  }
#line 2727
  goto ldv_55180;
  case 6: ;
#line 2730
  if (ldv_state_variable_16 == 1) {
#line 2732
    ixgbe_setup_phy_link_generic(phy_ops_X550EM_x_group0);
#line 2734
    ldv_state_variable_16 = 1;
  } else {

  }
#line 2737
  if (ldv_state_variable_16 == 3) {
#line 2739
    ixgbe_setup_phy_link_generic(phy_ops_X550EM_x_group0);
#line 2741
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2744
  if (ldv_state_variable_16 == 2) {
#line 2746
    ixgbe_setup_phy_link_generic(phy_ops_X550EM_x_group0);
#line 2748
    ldv_state_variable_16 = 2;
  } else {

  }
#line 2751
  goto ldv_55180;
  case 7: ;
#line 2754
  if (ldv_state_variable_16 == 1) {
#line 2756
    ixgbe_write_i2c_eeprom_generic(phy_ops_X550EM_x_group0, (int )ldvarg188, (int )ldvarg187);
#line 2758
    ldv_state_variable_16 = 1;
  } else {

  }
#line 2761
  if (ldv_state_variable_16 == 3) {
#line 2763
    ixgbe_write_i2c_eeprom_generic(phy_ops_X550EM_x_group0, (int )ldvarg188, (int )ldvarg187);
#line 2765
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2768
  if (ldv_state_variable_16 == 2) {
#line 2770
    ixgbe_write_i2c_eeprom_generic(phy_ops_X550EM_x_group0, (int )ldvarg188, (int )ldvarg187);
#line 2772
    ldv_state_variable_16 = 2;
  } else {

  }
#line 2775
  goto ldv_55180;
  case 8: ;
#line 2778
  if (ldv_state_variable_16 == 1) {
#line 2780
    ixgbe_setup_phy_link_speed_generic(phy_ops_X550EM_x_group0, ldvarg186, (int )ldvarg185);
#line 2782
    ldv_state_variable_16 = 1;
  } else {

  }
#line 2785
  if (ldv_state_variable_16 == 3) {
#line 2787
    ixgbe_setup_phy_link_speed_generic(phy_ops_X550EM_x_group0, ldvarg186, (int )ldvarg185);
#line 2789
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2792
  if (ldv_state_variable_16 == 2) {
#line 2794
    ixgbe_setup_phy_link_speed_generic(phy_ops_X550EM_x_group0, ldvarg186, (int )ldvarg185);
#line 2796
    ldv_state_variable_16 = 2;
  } else {

  }
#line 2799
  goto ldv_55180;
  case 9: ;
#line 2802
  if (ldv_state_variable_16 == 1) {
#line 2804
    ixgbe_write_phy_reg_generic(phy_ops_X550EM_x_group0, ldvarg184, ldvarg183, (int )ldvarg182);
#line 2806
    ldv_state_variable_16 = 1;
  } else {

  }
#line 2809
  if (ldv_state_variable_16 == 3) {
#line 2811
    ixgbe_write_phy_reg_generic(phy_ops_X550EM_x_group0, ldvarg184, ldvarg183, (int )ldvarg182);
#line 2813
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2816
  if (ldv_state_variable_16 == 2) {
#line 2818
    ixgbe_write_phy_reg_generic(phy_ops_X550EM_x_group0, ldvarg184, ldvarg183, (int )ldvarg182);
#line 2820
    ldv_state_variable_16 = 2;
  } else {

  }
#line 2823
  goto ldv_55180;
  case 10: ;
#line 2826
  if (ldv_state_variable_16 == 1) {
#line 2828
    ixgbe_identify_module_generic(phy_ops_X550EM_x_group0);
#line 2830
    ldv_state_variable_16 = 1;
  } else {

  }
#line 2833
  if (ldv_state_variable_16 == 3) {
#line 2835
    ixgbe_identify_module_generic(phy_ops_X550EM_x_group0);
#line 2837
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2840
  if (ldv_state_variable_16 == 2) {
#line 2842
    ixgbe_identify_module_generic(phy_ops_X550EM_x_group0);
#line 2844
    ldv_state_variable_16 = 2;
  } else {

  }
#line 2847
  goto ldv_55180;
  case 11: ;
#line 2850
  if (ldv_state_variable_16 == 1) {
#line 2852
    ixgbe_read_phy_reg_generic(phy_ops_X550EM_x_group0, ldvarg181, ldvarg180, ldvarg179);
#line 2854
    ldv_state_variable_16 = 1;
  } else {

  }
#line 2857
  if (ldv_state_variable_16 == 3) {
#line 2859
    ixgbe_read_phy_reg_generic(phy_ops_X550EM_x_group0, ldvarg181, ldvarg180, ldvarg179);
#line 2861
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2864
  if (ldv_state_variable_16 == 2) {
#line 2866
    ixgbe_read_phy_reg_generic(phy_ops_X550EM_x_group0, ldvarg181, ldvarg180, ldvarg179);
#line 2868
    ldv_state_variable_16 = 2;
  } else {

  }
#line 2871
  goto ldv_55180;
  case 12: ;
#line 2874
  if (ldv_state_variable_16 == 1) {
#line 2876
    ixgbe_tn_check_overtemp(phy_ops_X550EM_x_group0);
#line 2878
    ldv_state_variable_16 = 1;
  } else {

  }
#line 2881
  if (ldv_state_variable_16 == 3) {
#line 2883
    ixgbe_tn_check_overtemp(phy_ops_X550EM_x_group0);
#line 2885
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2888
  if (ldv_state_variable_16 == 2) {
#line 2890
    ixgbe_tn_check_overtemp(phy_ops_X550EM_x_group0);
#line 2892
    ldv_state_variable_16 = 2;
  } else {

  }
#line 2895
  goto ldv_55180;
  case 13: ;
#line 2898
  if (ldv_state_variable_16 == 1) {
#line 2900
    ixgbe_read_i2c_byte_generic(phy_ops_X550EM_x_group0, (int )ldvarg178, (int )ldvarg177,
                                ldvarg176);
#line 2902
    ldv_state_variable_16 = 1;
  } else {

  }
#line 2905
  if (ldv_state_variable_16 == 3) {
#line 2907
    ixgbe_read_i2c_byte_generic(phy_ops_X550EM_x_group0, (int )ldvarg178, (int )ldvarg177,
                                ldvarg176);
#line 2909
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2912
  if (ldv_state_variable_16 == 2) {
#line 2914
    ixgbe_read_i2c_byte_generic(phy_ops_X550EM_x_group0, (int )ldvarg178, (int )ldvarg177,
                                ldvarg176);
#line 2916
    ldv_state_variable_16 = 2;
  } else {

  }
#line 2919
  goto ldv_55180;
  case 14: ;
#line 2922
  if (ldv_state_variable_16 == 2) {
#line 2924
    ixgbe_init_phy_ops_X550em(phy_ops_X550EM_x_group0);
#line 2926
    ldv_state_variable_16 = 3;
  } else {

  }
#line 2929
  goto ldv_55180;
  case 15: ;
#line 2932
  if (ldv_state_variable_16 == 1) {
#line 2934
    ldv_setup_16();
#line 2936
    ldv_state_variable_16 = 2;
#line 2937
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 2940
  goto ldv_55180;
  case 16: ;
#line 2943
  if (ldv_state_variable_16 == 3) {
#line 2945
    ldv_release_16();
#line 2947
    ldv_state_variable_16 = 1;
#line 2948
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2951
  if (ldv_state_variable_16 == 2) {
#line 2953
    ldv_release_16();
#line 2955
    ldv_state_variable_16 = 1;
#line 2956
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2959
  goto ldv_55180;
  default: 
#line 2960
  ldv_stop();
  }
  ldv_55180: ;
#line 2964
  return;
}
}
#line 2966 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_main_exported_19(void) 
{ 
  u16 ldvarg558 ;
  u16 *ldvarg562 ;
  void *tmp ;
  u16 ldvarg561 ;
  u16 *ldvarg554 ;
  void *tmp___0 ;
  u16 ldvarg557 ;
  u16 ldvarg563 ;
  u16 ldvarg564 ;
  u16 ldvarg560 ;
  u16 ldvarg556 ;
  u16 *ldvarg559 ;
  void *tmp___1 ;
  u16 *ldvarg555 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 2968
  tmp = ldv_init_zalloc(2UL);
#line 2968
  ldvarg562 = (u16 *)tmp;
#line 2970
  tmp___0 = ldv_init_zalloc(2UL);
#line 2970
  ldvarg554 = (u16 *)tmp___0;
#line 2976
  tmp___1 = ldv_init_zalloc(2UL);
#line 2976
  ldvarg559 = (u16 *)tmp___1;
#line 2977
  tmp___2 = ldv_init_zalloc(2UL);
#line 2977
  ldvarg555 = (u16 *)tmp___2;
#line 2967
  ldv_memset((void *)(& ldvarg558), 0, 2UL);
#line 2969
  ldv_memset((void *)(& ldvarg561), 0, 2UL);
#line 2971
  ldv_memset((void *)(& ldvarg557), 0, 2UL);
#line 2972
  ldv_memset((void *)(& ldvarg563), 0, 2UL);
#line 2973
  ldv_memset((void *)(& ldvarg564), 0, 2UL);
#line 2974
  ldv_memset((void *)(& ldvarg560), 0, 2UL);
#line 2975
  ldv_memset((void *)(& ldvarg556), 0, 2UL);
#line 2979
  tmp___3 = __VERIFIER_nondet_int();
#line 2979
  switch (tmp___3) {
  case 0: ;
#line 2982
  if (ldv_state_variable_19 == 2) {
#line 2984
    ixgbe_write_ee_hostif_buffer_X550(eeprom_ops_X550_group0, (int )ldvarg564, (int )ldvarg563,
                                      ldvarg562);
#line 2986
    ldv_state_variable_19 = 2;
  } else {

  }
#line 2989
  goto ldv_55213;
  case 1: ;
#line 2992
  if (ldv_state_variable_19 == 2) {
#line 2994
    ixgbe_read_ee_hostif_buffer_X550(eeprom_ops_X550_group0, (int )ldvarg561, (int )ldvarg560,
                                     ldvarg559);
#line 2996
    ldv_state_variable_19 = 2;
  } else {

  }
#line 2999
  goto ldv_55213;
  case 2: ;
#line 3002
  if (ldv_state_variable_19 == 1) {
#line 3004
    ixgbe_update_eeprom_checksum_X550(eeprom_ops_X550_group0);
#line 3006
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3009
  if (ldv_state_variable_19 == 2) {
#line 3011
    ixgbe_update_eeprom_checksum_X550(eeprom_ops_X550_group0);
#line 3013
    ldv_state_variable_19 = 2;
  } else {

  }
#line 3016
  goto ldv_55213;
  case 3: ;
#line 3019
  if (ldv_state_variable_19 == 1) {
#line 3021
    ixgbe_calc_eeprom_checksum_X550(eeprom_ops_X550_group0);
#line 3023
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3026
  if (ldv_state_variable_19 == 2) {
#line 3028
    ixgbe_calc_eeprom_checksum_X550(eeprom_ops_X550_group0);
#line 3030
    ldv_state_variable_19 = 2;
  } else {

  }
#line 3033
  goto ldv_55213;
  case 4: ;
#line 3036
  if (ldv_state_variable_19 == 1) {
#line 3038
    ixgbe_write_ee_hostif_X550(eeprom_ops_X550_group0, (int )ldvarg558, (int )ldvarg557);
#line 3040
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3043
  if (ldv_state_variable_19 == 2) {
#line 3045
    ixgbe_write_ee_hostif_X550(eeprom_ops_X550_group0, (int )ldvarg558, (int )ldvarg557);
#line 3047
    ldv_state_variable_19 = 2;
  } else {

  }
#line 3050
  goto ldv_55213;
  case 5: ;
#line 3053
  if (ldv_state_variable_19 == 1) {
#line 3055
    ixgbe_read_ee_hostif_X550(eeprom_ops_X550_group0, (int )ldvarg556, ldvarg555);
#line 3057
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3060
  if (ldv_state_variable_19 == 2) {
#line 3062
    ixgbe_read_ee_hostif_X550(eeprom_ops_X550_group0, (int )ldvarg556, ldvarg555);
#line 3064
    ldv_state_variable_19 = 2;
  } else {

  }
#line 3067
  goto ldv_55213;
  case 6: ;
#line 3070
  if (ldv_state_variable_19 == 1) {
#line 3072
    ixgbe_init_eeprom_params_X550(eeprom_ops_X550_group0);
#line 3074
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3077
  if (ldv_state_variable_19 == 2) {
#line 3079
    ixgbe_init_eeprom_params_X550(eeprom_ops_X550_group0);
#line 3081
    ldv_state_variable_19 = 2;
  } else {

  }
#line 3084
  goto ldv_55213;
  case 7: ;
#line 3087
  if (ldv_state_variable_19 == 1) {
#line 3089
    ixgbe_validate_eeprom_checksum_X550(eeprom_ops_X550_group0, ldvarg554);
#line 3091
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3094
  if (ldv_state_variable_19 == 2) {
#line 3096
    ixgbe_validate_eeprom_checksum_X550(eeprom_ops_X550_group0, ldvarg554);
#line 3098
    ldv_state_variable_19 = 2;
  } else {

  }
#line 3101
  goto ldv_55213;
  case 8: ;
#line 3104
  if (ldv_state_variable_19 == 2) {
#line 3106
    ldv_release_19();
#line 3108
    ldv_state_variable_19 = 1;
#line 3109
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 3112
  goto ldv_55213;
  case 9: ;
#line 3115
  if (ldv_state_variable_19 == 1) {
#line 3117
    ldv_probe_19();
#line 3119
    ldv_state_variable_19 = 2;
#line 3120
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 3123
  goto ldv_55213;
  default: 
#line 3124
  ldv_stop();
  }
  ldv_55213: ;
#line 3128
  return;
}
}
#line 3153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
bool ldv_queue_work_on_303(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 3157
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 3157
  ldv_func_res = tmp;
#line 3159
  activate_work_9(ldv_func_arg3, 2);
#line 3161
  return (ldv_func_res);
}
}
#line 3164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
bool ldv_queue_delayed_work_on_304(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 3168
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 3168
  ldv_func_res = tmp;
#line 3170
  activate_work_9(& ldv_func_arg3->work, 2);
#line 3172
  return (ldv_func_res);
}
}
#line 3175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
bool ldv_queue_work_on_305(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 3179
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 3179
  ldv_func_res = tmp;
#line 3181
  activate_work_9(ldv_func_arg3, 2);
#line 3183
  return (ldv_func_res);
}
}
#line 3186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_flush_workqueue_306(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 3189
  flush_workqueue(ldv_func_arg1);
#line 3191
  call_and_disable_all_9(2);
#line 3192
  return;
}
}
#line 3194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
bool ldv_queue_delayed_work_on_307(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 3198
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 3198
  ldv_func_res = tmp;
#line 3200
  activate_work_9(& ldv_func_arg3->work, 2);
#line 3202
  return (ldv_func_res);
}
}
#line 3205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_mutex_unlock_308(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3208
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 3210
  mutex_unlock(ldv_func_arg1);
#line 3211
  return;
}
}
#line 3213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_mutex_lock_309(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3216
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 3218
  mutex_lock(ldv_func_arg1);
#line 3219
  return;
}
}
#line 3221 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_mutex_lock_310(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3224
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 3226
  mutex_lock(ldv_func_arg1);
#line 3227
  return;
}
}
#line 3229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_mutex_unlock_311(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3232
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 3234
  mutex_unlock(ldv_func_arg1);
#line 3235
  return;
}
}
#line 3237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_mutex_lock_312(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3240
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 3242
  mutex_lock(ldv_func_arg1);
#line 3243
  return;
}
}
#line 3245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
int ldv_mutex_trylock_313(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3249
  tmp = mutex_trylock(ldv_func_arg1);
#line 3249
  ldv_func_res = tmp;
#line 3251
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 3251
  return (tmp___0);
#line 3253
  return (ldv_func_res);
}
}
#line 3256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.o.c.prepared"
void ldv_mutex_unlock_314(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3259
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 3261
  mutex_unlock(ldv_func_arg1);
#line 3262
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 114 "include/linux/cpumask.h"
__inline static unsigned int cpumask_check___0(unsigned int cpu ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 117
  __ret_warn_once = (unsigned int )nr_cpu_ids <= cpu;
#line 117
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 117
  if (tmp___1 != 0L) {
#line 117
    __ret_warn_on = ! __warned;
#line 117
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp != 0L) {
#line 117
      warn_slowpath_null("include/linux/cpumask.h", 117);
    } else {

    }
#line 117
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp___0 != 0L) {
#line 117
      __warned = 1;
    } else {

    }
  } else {

  }
#line 117
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 119
  return (cpu);
}
}
#line 270 "include/linux/cpumask.h"
__inline static void cpumask_set_cpu(unsigned int cpu , struct cpumask *dstp ) 
{ 
  unsigned int tmp ;

  {
#line 272
  tmp = cpumask_check___0(cpu);
#line 272
  set_bit((long )tmp, (unsigned long volatile   *)(& dstp->bits));
#line 273
  return;
}
}
#line 292 "include/linux/cpumask.h"
__inline static int cpumask_test_cpu(int cpu , struct cpumask  const  *cpumask ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 294
  tmp = cpumask_check___0((unsigned int )cpu);
#line 294
  tmp___0 = variable_test_bit((long )tmp, (unsigned long const volatile   *)(& cpumask->bits));
#line 294
  return (tmp___0);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_339(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_337(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_340(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_341(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.o.c.prepared"
void ldv_mutex_lock_336(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_338(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_342(struct mutex *ldv_func_arg1 ) ;
#line 51 "include/linux/rcutree.h"
extern void kfree_call_rcu(struct callback_head * , void (*)(struct callback_head * ) ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_331(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_333(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_332(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_335(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_334(struct workqueue_struct *ldv_func_arg1 ) ;
#line 57 "./arch/x86/include/asm/topology.h"
extern int __cpu_to_node(int  ) ;
#line 294 "include/linux/slab.h"
extern void *__kmalloc_node(size_t  , gfp_t  , int  ) ;
#line 458 "include/linux/slab.h"
__inline static void *kmalloc_node(size_t size , gfp_t flags , int node ) 
{ 
  void *tmp___1 ;

  {
#line 472
  tmp___1 = __kmalloc_node(size, flags, node);
#line 472
  return (tmp___1);
}
}
#line 592 "include/linux/slab.h"
__inline static void *kzalloc_node(size_t size , gfp_t flags , int node ) 
{ 
  void *tmp ;

  {
#line 594
  tmp = kmalloc_node(size, flags | 32768U, node);
#line 594
  return (tmp);
}
}
#line 1209 "include/linux/pci.h"
extern void pci_disable_msi(struct pci_dev * ) ;
#line 1216
extern int pci_enable_msi_range(struct pci_dev * , int  , int  ) ;
#line 1217 "include/linux/pci.h"
__inline static int pci_enable_msi_exact(struct pci_dev *dev , int nvec ) 
{ 
  int rc ;
  int tmp ;

  {
#line 1219
  tmp = pci_enable_msi_range(dev, nvec, nvec);
#line 1219
  rc = tmp;
#line 1220
  if (rc < 0) {
#line 1221
    return (rc);
  } else {

  }
#line 1222
  return (0);
}
}
#line 1224
extern int pci_enable_msix_range(struct pci_dev * , struct msix_entry * , int  , int  ) ;
#line 478 "include/linux/netdevice.h"
extern void napi_hash_add(struct napi_struct * ) ;
#line 487
extern void napi_hash_del(struct napi_struct * ) ;
#line 1795 "include/linux/netdevice.h"
__inline static int netdev_set_tc_queue(struct net_device *dev , u8 tc , u16 count ,
                                        u16 offset ) 
{ 


  {
#line 1797
  if ((int )dev->num_tc <= (int )tc) {
#line 1798
    return (-22);
  } else {

  }
#line 1800
  dev->tc_to_txq[(int )tc].count = count;
#line 1801
  dev->tc_to_txq[(int )tc].offset = offset;
#line 1802
  return (0);
}
}
#line 1911
extern void netif_napi_add(struct net_device * , struct napi_struct * , int (*)(struct napi_struct * ,
                                                                                int  ) ,
                           int  ) ;
#line 1920
extern void netif_napi_del(struct napi_struct * ) ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_cache_ring_dcb_sriov(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_ring_feature *fcoe ;
  struct ixgbe_ring_feature *vmdq ;
  int i ;
  u16 reg_idx ;
  u8 tcs ;
  int tmp ;
  u16 queues_per_pool ;
  u8 fcoe_tc ;
  u8 tmp___0 ;

  {
#line 45
  fcoe = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 47
  vmdq = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 1UL;
#line 50
  tmp = netdev_get_num_tc(adapter->netdev);
#line 50
  tcs = (u8 )tmp;
#line 53
  if ((unsigned int )tcs <= 1U) {
#line 54
    return (0);
  } else {

  }
#line 57
  if ((adapter->flags & 8388608U) == 0U) {
#line 58
    return (0);
  } else {

  }
#line 61
  reg_idx = (int )vmdq->offset * (int )((u16 )(- ((int )vmdq->mask) & (int )vmdq->mask));
#line 62
  i = 0;
#line 62
  goto ldv_54363;
  ldv_54362: ;
#line 64
  if (((int )reg_idx & ~ ((int )vmdq->mask)) >= (int )tcs) {
#line 65
    reg_idx = (u16 )((int )((short )(~ ((int )vmdq->mask) + (int )reg_idx)) & (int )((short )vmdq->mask));
  } else {

  }
#line 66
  (adapter->rx_ring[i])->reg_idx = (u8 )reg_idx;
#line 62
  i = i + 1;
#line 62
  reg_idx = (u16 )((int )reg_idx + 1);
  ldv_54363: ;
#line 62
  if (adapter->num_rx_queues > i) {
#line 64
    goto ldv_54362;
  } else {

  }
#line 69
  reg_idx = (int )vmdq->offset * (int )((u16 )(- ((int )vmdq->mask) & (int )vmdq->mask));
#line 70
  i = 0;
#line 70
  goto ldv_54366;
  ldv_54365: ;
#line 72
  if (((int )reg_idx & ~ ((int )vmdq->mask)) >= (int )tcs) {
#line 73
    reg_idx = (u16 )((int )((short )(~ ((int )vmdq->mask) + (int )reg_idx)) & (int )((short )vmdq->mask));
  } else {

  }
#line 74
  (adapter->tx_ring[i])->reg_idx = (u8 )reg_idx;
#line 70
  i = i + 1;
#line 70
  reg_idx = (u16 )((int )reg_idx + 1);
  ldv_54366: ;
#line 70
  if (adapter->num_tx_queues > i) {
#line 72
    goto ldv_54365;
  } else {

  }

#line 79
  if ((adapter->flags & 2097152U) == 0U) {
#line 80
    return (1);
  } else {

  }
#line 83
  if ((int )fcoe->offset < (int )((unsigned short )tcs)) {
#line 84
    return (1);
  } else {

  }
#line 87
  if ((unsigned int )fcoe->indices != 0U) {
#line 88
    queues_per_pool = (u16 )((int )((short )(- ((int )vmdq->mask))) & (int )((short )vmdq->mask));
#line 89
    tmp___0 = ixgbe_fcoe_get_tc(adapter);
#line 89
    fcoe_tc = tmp___0;
#line 91
    reg_idx = (int )((u16 )((int )vmdq->offset + (int )vmdq->indices)) * (int )queues_per_pool;
#line 92
    i = (int )fcoe->offset;
#line 92
    goto ldv_54371;
    ldv_54370: 
#line 93
    reg_idx = (int )((u16 )((int )((short )(~ ((int )vmdq->mask) + (int )reg_idx)) & (int )((short )vmdq->mask))) + (int )((u16 )fcoe_tc);
#line 94
    (adapter->rx_ring[i])->reg_idx = (u8 )reg_idx;
#line 95
    reg_idx = (u16 )((int )reg_idx + 1);
#line 92
    i = i + 1;
    ldv_54371: ;
#line 92
    if (adapter->num_rx_queues > i) {
#line 94
      goto ldv_54370;
    } else {

    }
#line 98
    reg_idx = (int )((u16 )((int )vmdq->offset + (int )vmdq->indices)) * (int )queues_per_pool;
#line 99
    i = (int )fcoe->offset;
#line 99
    goto ldv_54374;
    ldv_54373: 
#line 100
    reg_idx = (int )((u16 )((int )((short )(~ ((int )vmdq->mask) + (int )reg_idx)) & (int )((short )vmdq->mask))) + (int )((u16 )fcoe_tc);
#line 101
    (adapter->tx_ring[i])->reg_idx = (u8 )reg_idx;
#line 102
    reg_idx = (u16 )((int )reg_idx + 1);
#line 99
    i = i + 1;
    ldv_54374: ;
#line 99
    if (adapter->num_tx_queues > i) {
#line 101
      goto ldv_54373;
    } else {

    }

  } else {

  }
#line 107
  return (1);
}
}
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_get_first_reg_idx(struct ixgbe_adapter *adapter , u8 tc , unsigned int *tx ,
                                    unsigned int *rx ) 
{ 
  struct net_device *dev ;
  struct ixgbe_hw *hw ;
  u8 num_tcs ;
  int tmp ;

  {
#line 114
  dev = adapter->netdev;
#line 115
  hw = & adapter->hw;
#line 116
  tmp = netdev_get_num_tc(dev);
#line 116
  num_tcs = (u8 )tmp;
#line 118
  *tx = 0U;
#line 119
  *rx = 0U;
#line 121
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 124
  *tx = (unsigned int )((int )tc << 2);
#line 125
  *rx = (unsigned int )((int )tc << 3);
#line 126
  goto ldv_54386;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: ;
#line 131
  if ((unsigned int )num_tcs > 4U) {
#line 137
    *rx = (unsigned int )((int )tc << 4);
#line 138
    if ((unsigned int )tc <= 2U) {
#line 139
      *tx = (unsigned int )((int )tc << 5);
    } else
#line 140
    if ((unsigned int )tc <= 4U) {
#line 141
      *tx = (unsigned int )(((int )tc + 2) << 4);
    } else {
#line 143
      *tx = (unsigned int )(((int )tc + 8) << 3);
    }
  } else {
#line 150
    *rx = (unsigned int )((int )tc << 5);
#line 151
    if ((unsigned int )tc <= 1U) {
#line 152
      *tx = (unsigned int )((int )tc << 6);
    } else {
#line 154
      *tx = (unsigned int )(((int )tc + 4) << 4);
    }
  }
  default: ;
#line 157
  goto ldv_54386;
  }
  ldv_54386: ;
#line 160
  return;
}
}
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_cache_ring_dcb(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *dev ;
  unsigned int tx_idx ;
  unsigned int rx_idx ;
  int tc ;
  int offset ;
  int rss_i ;
  int i ;
  u8 num_tcs ;
  int tmp ;

  {
#line 170
  dev = adapter->netdev;
#line 173
  tmp = netdev_get_num_tc(dev);
#line 173
  num_tcs = (u8 )tmp;
#line 176
  if ((unsigned int )num_tcs <= 1U) {
#line 177
    return (0);
  } else {

  }
#line 179
  rss_i = (int )adapter->ring_feature[2].indices;
#line 181
  tc = 0;
#line 181
  offset = 0;
#line 181
  goto ldv_54407;
  ldv_54406: 
#line 182
  ixgbe_get_first_reg_idx(adapter, (int )((u8 )tc), & tx_idx, & rx_idx);
#line 183
  i = 0;
#line 183
  goto ldv_54404;
  ldv_54403: 
#line 184
  (adapter->tx_ring[offset + i])->reg_idx = (u8 )tx_idx;
#line 185
  (adapter->rx_ring[offset + i])->reg_idx = (u8 )rx_idx;
#line 186
  (adapter->tx_ring[offset + i])->dcb_tc = (u8 )tc;
#line 187
  (adapter->rx_ring[offset + i])->dcb_tc = (u8 )tc;
#line 183
  i = i + 1;
#line 183
  tx_idx = tx_idx + 1U;
#line 183
  rx_idx = rx_idx + 1U;
  ldv_54404: ;
#line 183
  if (i < rss_i) {
#line 185
    goto ldv_54403;
  } else {

  }
#line 181
  tc = tc + 1;
#line 181
  offset = offset + rss_i;
  ldv_54407: ;
#line 181
  if ((int )num_tcs > tc) {
#line 183
    goto ldv_54406;
  } else {

  }

#line 191
  return (1);
}
}
#line 203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_cache_ring_sriov(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_ring_feature *fcoe ;
  struct ixgbe_ring_feature *vmdq ;
  struct ixgbe_ring_feature *rss ;
  int i ;
  u16 reg_idx ;

  {
#line 206
  fcoe = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 208
  vmdq = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 1UL;
#line 209
  rss = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 2UL;
#line 214
  if ((adapter->flags & 16384U) == 0U) {
#line 215
    return (0);
  } else {

  }
#line 218
  reg_idx = (int )vmdq->offset * (int )((u16 )(- ((int )vmdq->mask) & (int )vmdq->mask));
#line 219
  i = 0;
#line 219
  goto ldv_54419;
  ldv_54418: ;
#line 222
  if ((unsigned int )fcoe->offset != 0U && (int )fcoe->offset < i) {
#line 223
    goto ldv_54417;
  } else {

  }
#line 226
  if (((int )reg_idx & ~ ((int )vmdq->mask)) >= (int )rss->indices) {
#line 227
    reg_idx = (u16 )((int )((short )(~ ((int )vmdq->mask) + (int )reg_idx)) & (int )((short )vmdq->mask));
  } else {

  }
#line 228
  (adapter->rx_ring[i])->reg_idx = (u8 )reg_idx;
#line 219
  i = i + 1;
#line 219
  reg_idx = (u16 )((int )reg_idx + 1);
  ldv_54419: ;
#line 219
  if (adapter->num_rx_queues > i) {
#line 221
    goto ldv_54418;
  } else {

  }
  ldv_54417: ;
#line 233
  goto ldv_54421;
  ldv_54420: 
#line 234
  (adapter->rx_ring[i])->reg_idx = (u8 )reg_idx;
#line 233
  i = i + 1;
#line 233
  reg_idx = (u16 )((int )reg_idx + 1);
  ldv_54421: ;
#line 233
  if (adapter->num_rx_queues > i) {
#line 235
    goto ldv_54420;
  } else {

  }
#line 237
  reg_idx = (int )vmdq->offset * (int )((u16 )(- ((int )vmdq->mask) & (int )vmdq->mask));
#line 238
  i = 0;
#line 238
  goto ldv_54425;
  ldv_54424: ;
#line 241
  if ((unsigned int )fcoe->offset != 0U && (int )fcoe->offset < i) {
#line 242
    goto ldv_54423;
  } else {

  }
#line 245
  if (((int )rss->mask & (int )reg_idx) >= (int )rss->indices) {
#line 246
    reg_idx = (u16 )((int )((short )(~ ((int )vmdq->mask) + (int )reg_idx)) & (int )((short )vmdq->mask));
  } else {

  }
#line 247
  (adapter->tx_ring[i])->reg_idx = (u8 )reg_idx;
#line 238
  i = i + 1;
#line 238
  reg_idx = (u16 )((int )reg_idx + 1);
  ldv_54425: ;
#line 238
  if (adapter->num_tx_queues > i) {
#line 240
    goto ldv_54424;
  } else {

  }
  ldv_54423: ;
#line 252
  goto ldv_54427;
  ldv_54426: 
#line 253
  (adapter->tx_ring[i])->reg_idx = (u8 )reg_idx;
#line 252
  i = i + 1;
#line 252
  reg_idx = (u16 )((int )reg_idx + 1);
  ldv_54427: ;
#line 252
  if (adapter->num_tx_queues > i) {
#line 254
    goto ldv_54426;
  } else {

  }

#line 257
  return (1);
}
}
#line 267 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_cache_ring_rss(struct ixgbe_adapter *adapter ) 
{ 
  int i ;

  {
#line 271
  i = 0;
#line 271
  goto ldv_54434;
  ldv_54433: 
#line 272
  (adapter->rx_ring[i])->reg_idx = (u8 )i;
#line 271
  i = i + 1;
  ldv_54434: ;
#line 271
  if (adapter->num_rx_queues > i) {
#line 273
    goto ldv_54433;
  } else {

  }
#line 273
  i = 0;
#line 273
  goto ldv_54437;
  ldv_54436: 
#line 274
  (adapter->tx_ring[i])->reg_idx = (u8 )i;
#line 273
  i = i + 1;
  ldv_54437: ;
#line 273
  if (adapter->num_tx_queues > i) {
#line 275
    goto ldv_54436;
  } else {

  }

#line 276
  return (1);
}
}
#line 290 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_cache_ring_register(struct ixgbe_adapter *adapter ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 293
  (adapter->rx_ring[0])->reg_idx = 0U;
#line 294
  (adapter->tx_ring[0])->reg_idx = 0U;
#line 297
  tmp = ixgbe_cache_ring_dcb_sriov(adapter);
#line 297
  if ((int )tmp) {
#line 298
    return;
  } else {

  }
#line 300
  tmp___0 = ixgbe_cache_ring_dcb(adapter);
#line 300
  if ((int )tmp___0) {
#line 301
    return;
  } else {

  }
#line 304
  tmp___1 = ixgbe_cache_ring_sriov(adapter);
#line 304
  if ((int )tmp___1) {
#line 305
    return;
  } else {

  }
#line 307
  ixgbe_cache_ring_rss(adapter);
#line 308
  return;
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_set_dcb_sriov_queues(struct ixgbe_adapter *adapter ) 
{ 
  int i ;
  u16 vmdq_i ;
  u16 vmdq_m ;
  u16 fcoe_i ;
  u8 tcs ;
  int tmp ;
  u16 __min1 ;
  u16 __min2 ;
  u16 __min1___0 ;
  u16 __min2___0 ;
  struct ixgbe_ring_feature *fcoe ;
  u16 __min1___1 ;
  u16 __min2___1 ;
  u8 tmp___0 ;

  {
#line 329
  vmdq_i = adapter->ring_feature[1].limit;
#line 330
  vmdq_m = 0U;
#line 332
  fcoe_i = 0U;
#line 334
  tmp = netdev_get_num_tc(adapter->netdev);
#line 334
  tcs = (u8 )tmp;
#line 337
  if ((unsigned int )tcs <= 1U) {
#line 338
    return (0);
  } else {

  }
#line 341
  if ((adapter->flags & 8388608U) == 0U) {
#line 342
    return (0);
  } else {

  }
#line 345
  vmdq_i = (int )adapter->ring_feature[1].offset + (int )vmdq_i;
#line 348
  if ((unsigned int )tcs > 4U) {
#line 349
    __min1 = vmdq_i;
#line 349
    __min2 = 16U;
#line 349
    vmdq_i = (u16 )((int )__min1 < (int )__min2 ? __min1 : __min2);
#line 350
    vmdq_m = 120U;
  } else {
#line 353
    __min1___0 = vmdq_i;
#line 353
    __min2___0 = 32U;
#line 353
    vmdq_i = (u16 )((int )__min1___0 < (int )__min2___0 ? __min1___0 : __min2___0);
#line 354
    vmdq_m = 124U;
  }
#line 359
  fcoe_i = (int )((u16 )(128 / (- ((int )vmdq_m) & (int )vmdq_m))) - (int )vmdq_i;
#line 363
  vmdq_i = (int )vmdq_i - (int )adapter->ring_feature[1].offset;
#line 366
  adapter->ring_feature[1].indices = vmdq_i;
#line 367
  adapter->ring_feature[1].mask = vmdq_m;
#line 373
  adapter->ring_feature[2].indices = 1U;
#line 374
  adapter->ring_feature[2].mask = 0U;
#line 377
  adapter->flags = adapter->flags & 4294705151U;
#line 379
  adapter->num_rx_pools = (int )vmdq_i;
#line 380
  adapter->num_rx_queues_per_pool = (int )tcs;
#line 382
  adapter->num_tx_queues = (int )vmdq_i * (int )tcs;
#line 383
  adapter->num_rx_queues = (int )vmdq_i * (int )tcs;
#line 386
  if ((adapter->flags & 2097152U) != 0U) {
#line 389
    fcoe = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 392
    __min1___1 = fcoe_i;
#line 392
    __min2___1 = fcoe->limit;
#line 392
    fcoe_i = (u16 )((int )__min1___1 < (int )__min2___1 ? __min1___1 : __min2___1);
#line 394
    if ((unsigned int )fcoe_i != 0U) {
#line 396
      fcoe->indices = fcoe_i;
#line 397
      fcoe->offset = (int )((u16 )tcs) * (int )vmdq_i;
#line 400
      adapter->num_tx_queues = adapter->num_tx_queues + (int )fcoe_i;
#line 401
      adapter->num_rx_queues = adapter->num_rx_queues + (int )fcoe_i;
    } else
#line 402
    if ((unsigned int )tcs > 1U) {
#line 404
      fcoe->indices = 1U;
#line 405
      tmp___0 = ixgbe_fcoe_get_tc(adapter);
#line 405
      fcoe->offset = (u16 )tmp___0;
    } else {
#line 407
      adapter->flags = adapter->flags & 4292870143U;
#line 409
      fcoe->indices = 0U;
#line 410
      fcoe->offset = 0U;
    }
  } else {

  }
#line 416
  i = 0;
#line 416
  goto ldv_54461;
  ldv_54460: 
#line 417
  netdev_set_tc_queue(adapter->netdev, (int )((u8 )i), 1, (int )((u16 )i));
#line 416
  i = i + 1;
  ldv_54461: ;
#line 416
  if ((int )tcs > i) {
#line 418
    goto ldv_54460;
  } else {

  }

#line 419
  return (1);
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_set_dcb_queues(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *dev ;
  struct ixgbe_ring_feature *f ;
  int rss_i ;
  int rss_m ;
  int i ;
  int tcs ;
  u16 __min1 ;
  u16 __min2 ;
  u16 __min1___0 ;
  u16 __min2___0 ;
  u16 __min1___1 ;
  u16 __min2___1 ;
  int __min1___2 ;
  int __min2___2 ;
  u8 tc ;
  u8 tmp ;
  u16 __min1___3 ;
  u16 __min2___3 ;

  {
#line 424
  dev = adapter->netdev;
#line 430
  tcs = netdev_get_num_tc(dev);
#line 433
  if (tcs <= 1) {
#line 434
    return (0);
  } else {

  }
#line 437
  rss_i = (int )(dev->num_tx_queues / (unsigned int )tcs);
#line 438
  if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 440
    __min1 = (u16 )rss_i;
#line 440
    __min2 = 4U;
#line 440
    rss_i = (int )__min1 < (int )__min2 ? __min1 : __min2;
#line 441
    rss_m = 3;
  } else
#line 442
  if (tcs > 4) {
#line 444
    __min1___0 = (u16 )rss_i;
#line 444
    __min2___0 = 8U;
#line 444
    rss_i = (int )__min1___0 < (int )__min2___0 ? __min1___0 : __min2___0;
#line 445
    rss_m = 7;
  } else {
#line 448
    __min1___1 = (u16 )rss_i;
#line 448
    __min2___1 = 16U;
#line 448
    rss_i = (int )__min1___1 < (int )__min2___1 ? __min1___1 : __min2___1;
#line 449
    rss_m = 15;
  }
#line 453
  f = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 2UL;
#line 454
  __min1___2 = rss_i;
#line 454
  __min2___2 = (int )f->limit;
#line 454
  rss_i = __min1___2 < __min2___2 ? __min1___2 : __min2___2;
#line 455
  f->indices = (u16 )rss_i;
#line 456
  f->mask = (u16 )rss_m;
#line 459
  adapter->flags = adapter->flags & 4294705151U;
#line 467
  if ((adapter->flags & 2097152U) != 0U) {
#line 468
    tmp = ixgbe_fcoe_get_tc(adapter);
#line 468
    tc = tmp;
#line 470
    f = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 471
    __min1___3 = (u16 )rss_i;
#line 471
    __min2___3 = f->limit;
#line 471
    f->indices = (u16 )((int )__min1___3 < (int )__min2___3 ? __min1___3 : __min2___3);
#line 472
    f->offset = (int )((u16 )tc) * (int )((u16 )rss_i);
  } else {

  }
#line 476
  i = 0;
#line 476
  goto ldv_54489;
  ldv_54488: 
#line 477
  netdev_set_tc_queue(dev, (int )((u8 )i), (int )((u16 )rss_i), (int )((u16 )rss_i) * (int )((u16 )i));
#line 476
  i = i + 1;
  ldv_54489: ;
#line 476
  if (i < tcs) {
#line 478
    goto ldv_54488;
  } else {

  }
#line 479
  adapter->num_tx_queues = rss_i * tcs;
#line 480
  adapter->num_rx_queues = rss_i * tcs;
#line 482
  return (1);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_set_sriov_queues(struct ixgbe_adapter *adapter ) 
{ 
  u16 vmdq_i ;
  u16 vmdq_m ;
  u16 rss_i ;
  u16 rss_m ;
  u16 fcoe_i ;
  bool pools ;
  unsigned long tmp ;
  u16 __min1 ;
  u16 __min2 ;
  u16 __min1___0 ;
  u16 __min2___0 ;
  struct ixgbe_ring_feature *fcoe ;
  u16 __min1___1 ;
  u16 __min2___1 ;
  u16 __min1___2 ;
  u16 __min2___2 ;
  unsigned int tmp___0 ;
  u16 __min1___3 ;
  u16 __min2___3 ;

  {
#line 497
  vmdq_i = adapter->ring_feature[1].limit;
#line 498
  vmdq_m = 0U;
#line 499
  rss_i = adapter->ring_feature[2].limit;
#line 500
  rss_m = 0U;
#line 502
  fcoe_i = 0U;
#line 504
  tmp = find_first_zero_bit((unsigned long const   *)(& adapter->fwd_bitmask), 32UL);
#line 504
  pools = tmp > 1UL;
#line 507
  if ((adapter->flags & 8388608U) == 0U) {
#line 508
    return (0);
  } else {

  }
#line 511
  vmdq_i = (int )adapter->ring_feature[1].offset + (int )vmdq_i;
#line 514
  __min1 = 64U;
#line 514
  __min2 = vmdq_i;
#line 514
  vmdq_i = (u16 )((int )__min1 < (int )__min2 ? __min1 : __min2);
#line 517
  if (((unsigned int )vmdq_i > 32U || (unsigned int )rss_i <= 3U) || ((unsigned int )vmdq_i > 16U && (int )pools)) {
#line 518
    vmdq_m = 126U;
#line 519
    rss_m = 1U;
#line 520
    __min1___0 = rss_i;
#line 520
    __min2___0 = 2U;
#line 520
    rss_i = (u16 )((int )__min1___0 < (int )__min2___0 ? __min1___0 : __min2___0);
  } else {
#line 523
    vmdq_m = 124U;
#line 524
    rss_m = 3U;
#line 525
    rss_i = 4U;
  }
#line 530
  fcoe_i = 128U - (unsigned int )((int )((u16 )(- ((int )vmdq_m) & (int )vmdq_m)) * (int )vmdq_i);
#line 534
  vmdq_i = (int )vmdq_i - (int )adapter->ring_feature[1].offset;
#line 537
  adapter->ring_feature[1].indices = vmdq_i;
#line 538
  adapter->ring_feature[1].mask = vmdq_m;
#line 541
  adapter->ring_feature[2].indices = rss_i;
#line 542
  adapter->ring_feature[2].mask = rss_m;
#line 544
  adapter->num_rx_pools = (int )vmdq_i;
#line 545
  adapter->num_rx_queues_per_pool = (int )rss_i;
#line 547
  adapter->num_rx_queues = (int )vmdq_i * (int )rss_i;
#line 548
  adapter->num_tx_queues = (int )vmdq_i * (int )rss_i;
#line 551
  adapter->flags = adapter->flags & 4294705151U;
#line 559
  if ((adapter->flags & 2097152U) != 0U) {
#line 562
    fcoe = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 565
    __min1___1 = fcoe_i;
#line 565
    __min2___1 = fcoe->limit;
#line 565
    fcoe_i = (u16 )((int )__min1___1 < (int )__min2___1 ? __min1___1 : __min2___1);
#line 567
    if ((unsigned int )vmdq_i > 1U && (unsigned int )fcoe_i != 0U) {
#line 569
      fcoe->indices = fcoe_i;
#line 570
      fcoe->offset = (int )vmdq_i * (int )rss_i;
    } else {
#line 573
      __min1___2 = (int )fcoe_i + (int )rss_i;
#line 573
      tmp___0 = cpumask_weight(cpu_online_mask);
#line 573
      __min2___2 = (u16 )tmp___0;
#line 573
      fcoe_i = (u16 )((int )__min1___2 < (int )__min2___2 ? __min1___2 : __min2___2);
#line 576
      if ((adapter->flags & 8U) == 0U) {
#line 577
        fcoe_i = rss_i;
      } else {

      }
#line 580
      __min1___3 = fcoe_i;
#line 580
      __min2___3 = fcoe->limit;
#line 580
      fcoe->indices = (u16 )((int )__min1___3 < (int )__min2___3 ? __min1___3 : __min2___3);
#line 581
      fcoe->offset = (int )fcoe_i - (int )fcoe->indices;
#line 583
      fcoe_i = (int )fcoe_i - (int )rss_i;
    }
#line 587
    adapter->num_tx_queues = adapter->num_tx_queues + (int )fcoe_i;
#line 588
    adapter->num_rx_queues = adapter->num_rx_queues + (int )fcoe_i;
  } else {

  }
#line 592
  return (1);
}
}
#line 603 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_set_rss_queues(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_ring_feature *f ;
  u16 rss_i ;
  u16 tmp ;
  struct net_device *dev ;
  u16 fcoe_i ;
  u16 __min1 ;
  u16 __min2 ;
  unsigned int tmp___0 ;
  u16 __min1___0 ;
  u16 __min2___0 ;
  u16 __min1___1 ;
  u16 __min2___1 ;
  u16 __max1 ;
  u16 __max2 ;

  {
#line 609
  f = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 2UL;
#line 610
  rss_i = f->limit;
#line 612
  f->indices = rss_i;
#line 613
  f->mask = 15U;
#line 616
  adapter->flags = adapter->flags & 4294705151U;
#line 623
  if ((unsigned int )rss_i > 1U && adapter->atr_sample_rate != 0U) {
#line 624
    f = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 3UL;
#line 626
    tmp = f->limit;
#line 626
    f->indices = tmp;
#line 626
    rss_i = tmp;
#line 628
    if ((adapter->flags & 524288U) == 0U) {
#line 629
      adapter->flags = adapter->flags | 262144U;
    } else {

    }
  } else {

  }
#line 641
  if ((adapter->flags & 2097152U) != 0U) {
#line 642
    dev = adapter->netdev;
#line 645
    f = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 648
    __min1 = (int )f->limit + (int )rss_i;
#line 648
    tmp___0 = cpumask_weight(cpu_online_mask);
#line 648
    __min2 = (u16 )tmp___0;
#line 648
    fcoe_i = (u16 )((int )__min1 < (int )__min2 ? __min1 : __min2);
#line 649
    __min1___0 = fcoe_i;
#line 649
    __min2___0 = (u16 )dev->num_tx_queues;
#line 649
    fcoe_i = (u16 )((int )__min1___0 < (int )__min2___0 ? __min1___0 : __min2___0);
#line 652
    if ((adapter->flags & 8U) == 0U) {
#line 653
      fcoe_i = rss_i;
    } else {

    }
#line 656
    __min1___1 = fcoe_i;
#line 656
    __min2___1 = f->limit;
#line 656
    f->indices = (u16 )((int )__min1___1 < (int )__min2___1 ? __min1___1 : __min2___1);
#line 657
    f->offset = (int )fcoe_i - (int )f->indices;
#line 658
    __max1 = fcoe_i;
#line 658
    __max2 = rss_i;
#line 658
    rss_i = (u16 )((int )__max1 > (int )__max2 ? __max1 : __max2);
  } else {

  }
#line 662
  adapter->num_rx_queues = (int )rss_i;
#line 663
  adapter->num_tx_queues = (int )rss_i;
#line 665
  return (1);
}
}
#line 679 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_set_num_queues(struct ixgbe_adapter *adapter ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 682
  adapter->num_rx_queues = 1;
#line 683
  adapter->num_tx_queues = 1;
#line 684
  adapter->num_rx_pools = adapter->num_rx_queues;
#line 685
  adapter->num_rx_queues_per_pool = 1;
#line 688
  tmp = ixgbe_set_dcb_sriov_queues(adapter);
#line 688
  if ((int )tmp) {
#line 689
    return;
  } else {

  }
#line 691
  tmp___0 = ixgbe_set_dcb_queues(adapter);
#line 691
  if ((int )tmp___0) {
#line 692
    return;
  } else {

  }
#line 695
  tmp___1 = ixgbe_set_sriov_queues(adapter);
#line 695
  if ((int )tmp___1) {
#line 696
    return;
  } else {

  }
#line 698
  ixgbe_set_rss_queues(adapter);
#line 699
  return;
}
}
#line 709 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static int ixgbe_acquire_msix_vectors(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int i ;
  int vectors ;
  int vector_threshold ;
  int _max1 ;
  int _max2 ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp ;
  int __min1___0 ;
  int __min2___0 ;
  void *tmp___0 ;
  int __min1___1 ;
  int __min2___1 ;

  {
#line 711
  hw = & adapter->hw;
#line 715
  _max1 = adapter->num_rx_queues;
#line 715
  _max2 = adapter->num_tx_queues;
#line 715
  vectors = _max1 > _max2 ? _max1 : _max2;
#line 722
  __min1 = vectors;
#line 722
  tmp = cpumask_weight(cpu_online_mask);
#line 722
  __min2 = (int )tmp;
#line 722
  vectors = __min1 < __min2 ? __min1 : __min2;
#line 725
  vectors = vectors + 1;
#line 733
  __min1___0 = vectors;
#line 733
  __min2___0 = (int )hw->mac.max_msix_vectors;
#line 733
  vectors = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
#line 738
  vector_threshold = 2;
#line 740
  tmp___0 = kcalloc((size_t )vectors, 8UL, 208U);
#line 740
  adapter->msix_entries = (struct msix_entry *)tmp___0;
#line 743
  if ((unsigned long )adapter->msix_entries == (unsigned long )((struct msix_entry *)0)) {
#line 744
    return (-12);
  } else {

  }
#line 746
  i = 0;
#line 746
  goto ldv_54555;
  ldv_54554: 
#line 747
  (adapter->msix_entries + (unsigned long )i)->entry = (u16 )i;
#line 746
  i = i + 1;
  ldv_54555: ;
#line 746
  if (i < vectors) {
#line 748
    goto ldv_54554;
  } else {

  }
#line 749
  vectors = pci_enable_msix_range(adapter->pdev, adapter->msix_entries, vector_threshold,
                                  vectors);
#line 752
  if (vectors < 0) {
#line 756
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Failed to allocate MSI-X interrupts. Err: %d\n",
             vectors);
#line 759
    adapter->flags = adapter->flags & 4294967287U;
#line 760
    kfree((void const   *)adapter->msix_entries);
#line 761
    adapter->msix_entries = (struct msix_entry *)0;
#line 763
    return (vectors);
  } else {

  }
#line 769
  adapter->flags = adapter->flags | 8U;
#line 774
  vectors = vectors + -1;
#line 775
  __min1___1 = vectors;
#line 775
  __min2___1 = adapter->max_q_vectors;
#line 775
  adapter->num_q_vectors = __min1___1 < __min2___1 ? __min1___1 : __min2___1;
#line 777
  return (0);
}
}
#line 780 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_add_ring(struct ixgbe_ring *ring , struct ixgbe_ring_container *head ) 
{ 


  {
#line 783
  ring->next = head->ring;
#line 784
  head->ring = ring;
#line 785
  head->count = (u8 )((int )head->count + 1);
#line 786
  return;
}
}
#line 800 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static int ixgbe_alloc_q_vector(struct ixgbe_adapter *adapter , int v_count , int v_idx ,
                                int txr_count , int txr_idx , int rxr_count , int rxr_idx ) 
{ 
  struct ixgbe_q_vector *q_vector ;
  struct ixgbe_ring *ring ;
  int node ;
  int cpu ;
  int ring_count ;
  int size ;
  u8 tcs ;
  int tmp ;
  u16 rss_i ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct ixgbe_ring_feature *f ;

  {
#line 807
  node = -1;
#line 808
  cpu = -1;
#line 810
  tmp = netdev_get_num_tc(adapter->netdev);
#line 810
  tcs = (u8 )tmp;
#line 812
  ring_count = txr_count + rxr_count;
#line 813
  size = (int )((unsigned int )((unsigned long )ring_count + 1UL) * 4096U);
#line 817
  if ((unsigned int )tcs <= 1U && (adapter->flags & 8388608U) == 0U) {
#line 818
    rss_i = adapter->ring_feature[2].indices;
#line 819
    if ((unsigned int )rss_i > 1U && adapter->atr_sample_rate != 0U) {
#line 820
      tmp___0 = cpumask_test_cpu(v_idx, cpu_online_mask);
#line 820
      if (tmp___0 != 0) {
#line 821
        cpu = v_idx;
#line 822
        node = __cpu_to_node(cpu);
      } else {

      }
    } else {

    }
  } else {

  }
#line 828
  tmp___1 = kzalloc_node((size_t )size, 208U, node);
#line 828
  q_vector = (struct ixgbe_q_vector *)tmp___1;
#line 829
  if ((unsigned long )q_vector == (unsigned long )((struct ixgbe_q_vector *)0)) {
#line 830
    tmp___2 = kzalloc((size_t )size, 208U);
#line 830
    q_vector = (struct ixgbe_q_vector *)tmp___2;
  } else {

  }
#line 831
  if ((unsigned long )q_vector == (unsigned long )((struct ixgbe_q_vector *)0)) {
#line 832
    return (-12);
  } else {

  }
#line 835
  if (cpu != -1) {
#line 836
    cpumask_set_cpu((unsigned int )cpu, & q_vector->affinity_mask);
  } else {

  }
#line 837
  q_vector->numa_node = node;
#line 841
  q_vector->cpu = -1;
#line 845
  netif_napi_add(adapter->netdev, & q_vector->napi, & ixgbe_poll, 64);
#line 847
  napi_hash_add(& q_vector->napi);
#line 851
  atomic_set(& q_vector->state, 3);
#line 855
  adapter->q_vector[v_idx] = q_vector;
#line 856
  q_vector->adapter = adapter;
#line 857
  q_vector->v_idx = (u16 )v_idx;
#line 860
  q_vector->tx.work_limit = adapter->tx_work_limit;
#line 863
  ring = (struct ixgbe_ring *)(& q_vector->ring);
#line 866
  if (txr_count != 0 && rxr_count == 0) {
#line 868
    if ((unsigned int )adapter->tx_itr_setting == 1U) {
#line 869
      q_vector->itr = 400U;
    } else {
#line 871
      q_vector->itr = adapter->tx_itr_setting;
    }
  } else
#line 874
  if ((unsigned int )adapter->rx_itr_setting == 1U) {
#line 875
    q_vector->itr = 200U;
  } else {
#line 877
    q_vector->itr = adapter->rx_itr_setting;
  }
#line 880
  goto ldv_54582;
  ldv_54581: 
#line 882
  ring->dev = & (adapter->pdev)->dev;
#line 883
  ring->netdev = adapter->netdev;
#line 886
  ring->q_vector = q_vector;
#line 889
  ixgbe_add_ring(ring, & q_vector->tx);
#line 892
  ring->count = (u16 )adapter->tx_ring_count;
#line 893
  if (adapter->num_rx_pools > 1) {
#line 894
    ring->queue_index = (u8 )(txr_idx % adapter->num_rx_queues_per_pool);
  } else {
#line 897
    ring->queue_index = (u8 )txr_idx;
  }
#line 900
  adapter->tx_ring[txr_idx] = ring;
#line 903
  txr_count = txr_count - 1;
#line 904
  txr_idx = txr_idx + v_count;
#line 907
  ring = ring + 1;
  ldv_54582: ;
#line 880
  if (txr_count != 0) {
#line 882
    goto ldv_54581;
  } else {

  }

#line 910
  goto ldv_54586;
  ldv_54585: 
#line 912
  ring->dev = & (adapter->pdev)->dev;
#line 913
  ring->netdev = adapter->netdev;
#line 916
  ring->q_vector = q_vector;
#line 919
  ixgbe_add_ring(ring, & q_vector->rx);
#line 925
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 926
    set_bit(5L, (unsigned long volatile   *)(& ring->state));
  } else {

  }
#line 929
  if (((adapter->netdev)->features & 2147483648ULL) != 0ULL) {
#line 931
    f = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 932
    if ((int )f->offset <= rxr_idx && (int )f->offset + (int )f->indices > rxr_idx) {
#line 934
      set_bit(6L, (unsigned long volatile   *)(& ring->state));
    } else {

    }
  } else {

  }
#line 939
  ring->count = (u16 )adapter->rx_ring_count;
#line 940
  if (adapter->num_rx_pools > 1) {
#line 941
    ring->queue_index = (u8 )(rxr_idx % adapter->num_rx_queues_per_pool);
  } else {
#line 944
    ring->queue_index = (u8 )rxr_idx;
  }
#line 947
  adapter->rx_ring[rxr_idx] = ring;
#line 950
  rxr_count = rxr_count - 1;
#line 951
  rxr_idx = rxr_idx + v_count;
#line 954
  ring = ring + 1;
  ldv_54586: ;
#line 910
  if (rxr_count != 0) {
#line 912
    goto ldv_54585;
  } else {

  }

#line 957
  return (0);
}
}
#line 969 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_free_q_vector(struct ixgbe_adapter *adapter , int v_idx ) 
{ 
  struct ixgbe_q_vector *q_vector ;
  struct ixgbe_ring *ring ;

  {
#line 971
  q_vector = adapter->q_vector[v_idx];
#line 974
  ring = q_vector->tx.ring;
#line 974
  goto ldv_54595;
  ldv_54594: 
#line 975
  adapter->tx_ring[(int )ring->queue_index] = (struct ixgbe_ring *)0;
#line 974
  ring = ring->next;
  ldv_54595: ;
#line 974
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 976
    goto ldv_54594;
  } else {

  }
#line 977
  ring = q_vector->rx.ring;
#line 977
  goto ldv_54598;
  ldv_54597: 
#line 978
  adapter->rx_ring[(int )ring->queue_index] = (struct ixgbe_ring *)0;
#line 977
  ring = ring->next;
  ldv_54598: ;
#line 977
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 979
    goto ldv_54597;
  } else {

  }
#line 980
  adapter->q_vector[v_idx] = (struct ixgbe_q_vector *)0;
#line 981
  napi_hash_del(& q_vector->napi);
#line 982
  netif_napi_del(& q_vector->napi);
#line 988
  kfree_call_rcu(& q_vector->rcu, (void (*)(struct callback_head * ))1376);
#line 989
  return;
}
}
#line 998 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static int ixgbe_alloc_q_vectors(struct ixgbe_adapter *adapter ) 
{ 
  int q_vectors ;
  int rxr_remaining ;
  int txr_remaining ;
  int rxr_idx ;
  int txr_idx ;
  int v_idx ;
  int err ;
  int rqpv ;
  int tqpv ;
  int tmp ;

  {
#line 1000
  q_vectors = adapter->num_q_vectors;
#line 1001
  rxr_remaining = adapter->num_rx_queues;
#line 1002
  txr_remaining = adapter->num_tx_queues;
#line 1003
  rxr_idx = 0;
#line 1003
  txr_idx = 0;
#line 1003
  v_idx = 0;
#line 1007
  if ((adapter->flags & 8U) == 0U) {
#line 1008
    q_vectors = 1;
  } else {

  }
#line 1010
  if (rxr_remaining + txr_remaining <= q_vectors) {
#line 1011
    goto ldv_54613;
    ldv_54612: 
#line 1012
    err = ixgbe_alloc_q_vector(adapter, q_vectors, v_idx, 0, 0, 1, rxr_idx);
#line 1015
    if (err != 0) {
#line 1016
      goto err_out;
    } else {

    }
#line 1019
    rxr_remaining = rxr_remaining - 1;
#line 1020
    rxr_idx = rxr_idx + 1;
#line 1011
    v_idx = v_idx + 1;
    ldv_54613: ;
#line 1011
    if (rxr_remaining != 0) {
#line 1013
      goto ldv_54612;
    } else {

    }

  } else {

  }
#line 1024
  goto ldv_54618;
  ldv_54617: 
#line 1025
  rqpv = (((q_vectors - v_idx) + rxr_remaining) + -1) / (q_vectors - v_idx);
#line 1026
  tqpv = (((q_vectors - v_idx) + txr_remaining) + -1) / (q_vectors - v_idx);
#line 1027
  err = ixgbe_alloc_q_vector(adapter, q_vectors, v_idx, tqpv, txr_idx, rqpv, rxr_idx);
#line 1031
  if (err != 0) {
#line 1032
    goto err_out;
  } else {

  }
#line 1035
  rxr_remaining = rxr_remaining - rqpv;
#line 1036
  txr_remaining = txr_remaining - tqpv;
#line 1037
  rxr_idx = rxr_idx + 1;
#line 1038
  txr_idx = txr_idx + 1;
#line 1024
  v_idx = v_idx + 1;
  ldv_54618: ;
#line 1024
  if (v_idx < q_vectors) {
#line 1026
    goto ldv_54617;
  } else {

  }

#line 1041
  return (0);
  err_out: 
#line 1044
  adapter->num_tx_queues = 0;
#line 1045
  adapter->num_rx_queues = 0;
#line 1046
  adapter->num_q_vectors = 0;
#line 1048
  goto ldv_54621;
  ldv_54620: 
#line 1049
  ixgbe_free_q_vector(adapter, v_idx);
  ldv_54621: 
#line 1048
  tmp = v_idx;
#line 1048
  v_idx = v_idx - 1;
#line 1048
  if (tmp != 0) {
#line 1050
    goto ldv_54620;
  } else {

  }

#line 1051
  return (-12);
}
}
#line 1062 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_free_q_vectors(struct ixgbe_adapter *adapter ) 
{ 
  int v_idx ;
  int tmp ;

  {
#line 1064
  v_idx = adapter->num_q_vectors;
#line 1066
  adapter->num_tx_queues = 0;
#line 1067
  adapter->num_rx_queues = 0;
#line 1068
  adapter->num_q_vectors = 0;
#line 1070
  goto ldv_54628;
  ldv_54627: 
#line 1071
  ixgbe_free_q_vector(adapter, v_idx);
  ldv_54628: 
#line 1070
  tmp = v_idx;
#line 1070
  v_idx = v_idx - 1;
#line 1070
  if (tmp != 0) {
#line 1072
    goto ldv_54627;
  } else {

  }

#line 1077
  return;
}
}
#line 1074 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_reset_interrupt_capability(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 1076
  if ((adapter->flags & 8U) != 0U) {
#line 1077
    adapter->flags = adapter->flags & 4294967287U;
#line 1078
    pci_disable_msix(adapter->pdev);
#line 1079
    kfree((void const   *)adapter->msix_entries);
#line 1080
    adapter->msix_entries = (struct msix_entry *)0;
  } else
#line 1081
  if ((adapter->flags & 2U) != 0U) {
#line 1082
    adapter->flags = adapter->flags & 4294967293U;
#line 1083
    pci_disable_msi(adapter->pdev);
  } else {

  }
#line 1085
  return;
}
}
#line 1094 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_set_interrupt_capability(struct ixgbe_adapter *adapter ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;

  {
#line 1099
  tmp = ixgbe_acquire_msix_vectors(adapter);
#line 1099
  if (tmp == 0) {
#line 1100
    return;
  } else {

  }
#line 1108
  tmp___0 = netdev_get_num_tc(adapter->netdev);
#line 1108
  if (tmp___0 > 1) {
#line 1109
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Number of DCB TCs exceeds number of available queues. Disabling DCB support.\n");
#line 1110
    netdev_reset_tc(adapter->netdev);
#line 1112
    if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 1113
      adapter->hw.fc.requested_mode = adapter->last_lfc_mode;
    } else {

    }
#line 1115
    adapter->flags = adapter->flags & 4294963199U;
#line 1116
    adapter->temp_dcb_cfg.pfc_mode_enable = 0;
#line 1117
    adapter->dcb_cfg.pfc_mode_enable = 0;
  } else {

  }
#line 1120
  adapter->dcb_cfg.num_tcs.pg_tcs = 1U;
#line 1121
  adapter->dcb_cfg.num_tcs.pfc_tcs = 1U;
#line 1124
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Disabling SR-IOV support\n");
#line 1125
  ixgbe_disable_sriov(adapter);
#line 1128
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Disabling RSS support\n");
#line 1129
  adapter->ring_feature[2].limit = 1U;
#line 1134
  ixgbe_set_num_queues(adapter);
#line 1135
  adapter->num_q_vectors = 1;
#line 1137
  err = pci_enable_msi_exact(adapter->pdev, 1);
#line 1138
  if (err != 0) {
#line 1139
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Failed to allocate MSI interrupt, falling back to legacy. Error: %d\n",
             err);
  } else {
#line 1142
    adapter->flags = adapter->flags | 2U;
  }
#line 1143
  return;
}
}
#line 1155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
int ixgbe_init_interrupt_scheme(struct ixgbe_adapter *adapter ) 
{ 
  int err ;

  {
#line 1160
  ixgbe_set_num_queues(adapter);
#line 1163
  ixgbe_set_interrupt_capability(adapter);
#line 1165
  err = ixgbe_alloc_q_vectors(adapter);
#line 1166
  if (err != 0) {
#line 1167
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Unable to allocate memory for queue vectors\n");
#line 1168
    goto err_alloc_q_vectors;
  } else {

  }
#line 1171
  ixgbe_cache_ring_register(adapter);
#line 1173
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Multiqueue %s: Rx Queue count = %u, Tx Queue count = %u\n",
            adapter->num_rx_queues > 1 ? (char *)"Enabled" : (char *)"Disabled", adapter->num_rx_queues,
            adapter->num_tx_queues);
#line 1177
  set_bit(2L, (unsigned long volatile   *)(& adapter->state));
#line 1179
  return (0);
  err_alloc_q_vectors: 
#line 1182
  ixgbe_reset_interrupt_capability(adapter);
#line 1183
  return (err);
}
}
#line 1193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
void ixgbe_clear_interrupt_scheme(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 1195
  adapter->num_tx_queues = 0;
#line 1196
  adapter->num_rx_queues = 0;
#line 1198
  ixgbe_free_q_vectors(adapter);
#line 1199
  ixgbe_reset_interrupt_capability(adapter);
#line 1200
  return;
}
}
#line 1202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
void ixgbe_tx_ctxtdesc(struct ixgbe_ring *tx_ring , u32 vlan_macip_lens , u32 fcoe_sof_eof ,
                       u32 type_tucmd , u32 mss_l4len_idx ) 
{ 
  struct ixgbe_adv_tx_context_desc *context_desc ;
  u16 i ;

  {
#line 1206
  i = tx_ring->next_to_use;
#line 1208
  context_desc = (struct ixgbe_adv_tx_context_desc *)tx_ring->desc + (unsigned long )i;
#line 1210
  i = (u16 )((int )i + 1);
#line 1211
  tx_ring->next_to_use = (int )tx_ring->count > (int )i ? i : 0U;
#line 1214
  type_tucmd = type_tucmd | 538968064U;
#line 1216
  context_desc->vlan_macip_lens = vlan_macip_lens;
#line 1217
  context_desc->seqnum_seed = fcoe_sof_eof;
#line 1218
  context_desc->type_tucmd_mlhl = type_tucmd;
#line 1219
  context_desc->mss_l4len_idx = mss_l4len_idx;
#line 1220
  return;
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.o.c.prepared"
bool ldv_queue_work_on_331(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 359
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 359
  ldv_func_res = tmp;
#line 361
  activate_work_9(ldv_func_arg3, 2);
#line 363
  return (ldv_func_res);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.o.c.prepared"
bool ldv_queue_delayed_work_on_332(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 370
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 370
  ldv_func_res = tmp;
#line 372
  activate_work_9(& ldv_func_arg3->work, 2);
#line 374
  return (ldv_func_res);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.o.c.prepared"
bool ldv_queue_work_on_333(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 381
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 381
  ldv_func_res = tmp;
#line 383
  activate_work_9(ldv_func_arg3, 2);
#line 385
  return (ldv_func_res);
}
}
#line 388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.o.c.prepared"
void ldv_flush_workqueue_334(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 391
  flush_workqueue(ldv_func_arg1);
#line 393
  call_and_disable_all_9(2);
#line 394
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.o.c.prepared"
bool ldv_queue_delayed_work_on_335(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 400
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 400
  ldv_func_res = tmp;
#line 402
  activate_work_9(& ldv_func_arg3->work, 2);
#line 404
  return (ldv_func_res);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.o.c.prepared"
void ldv_mutex_lock_336(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 410
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 412
  mutex_lock(ldv_func_arg1);
#line 413
  return;
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.o.c.prepared"
void ldv_mutex_unlock_337(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 418
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 420
  mutex_unlock(ldv_func_arg1);
#line 421
  return;
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.o.c.prepared"
void ldv_mutex_lock_338(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 426
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 428
  mutex_lock(ldv_func_arg1);
#line 429
  return;
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.o.c.prepared"
int ldv_mutex_trylock_339(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 435
  tmp = mutex_trylock(ldv_func_arg1);
#line 435
  ldv_func_res = tmp;
#line 437
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 437
  return (tmp___0);
#line 439
  return (ldv_func_res);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.o.c.prepared"
void ldv_mutex_unlock_340(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 445
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 447
  mutex_unlock(ldv_func_arg1);
#line 448
  return;
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.o.c.prepared"
void ldv_mutex_unlock_341(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 453
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 455
  mutex_unlock(ldv_func_arg1);
#line 456
  return;
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.o.c.prepared"
void ldv_mutex_lock_342(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 461
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 463
  mutex_lock(ldv_func_arg1);
#line 464
  return;
}
}
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 131 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit_unlock(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 133
  __asm__  volatile   ("": : : "memory");
#line 134
  clear_bit(nr, addr);
#line 135
  return;
}
}
#line 248 "include/linux/kernel.h"
extern void __might_fault(char const   * , int  ) ;
#line 3 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
bool ldv_is_err(void const   *ptr ) ;
#line 4
bool ldv_is_err_or_null(void const   *ptr ) ;
#line 6
long ldv_ptr_err(void const   *ptr ) ;
#line 18 "include/linux/math64.h"
__inline static u64 div_u64_rem(u64 dividend , u32 divisor , u32 *remainder ) 
{ 


  {
#line 20
  *remainder = (u32 )(dividend % (u64 )divisor);
#line 21
  return (dividend / (u64 )divisor);
}
}
#line 97 "include/linux/math64.h"
__inline static u64 div_u64(u64 dividend , u32 divisor ) 
{ 
  u32 remainder ;
  u64 tmp ;

  {
#line 100
  tmp = div_u64_rem(dividend, divisor, & remainder);
#line 100
  return (tmp);
}
}
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 50
__inline static bool IS_ERR_OR_NULL(void const   *ptr ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_367(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_365(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_368(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_369(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void ldv_mutex_lock_364(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_366(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_370(struct mutex *ldv_func_arg1 ) ;
#line 34 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 45
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 370 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 372
  _raw_spin_unlock_irqrestore(& lock->__annonCompField17.rlock, flags);
#line 373
  return;
}
}
#line 191 "include/linux/time.h"
__inline static s64 timespec_to_ns(struct timespec  const  *ts ) 
{ 


  {
#line 193
  return ((long long )ts->tv_sec * 1000000000LL + (long long )ts->tv_nsec);
}
}
#line 215
extern struct timespec ns_to_timespec(s64 const    ) ;
#line 283 "include/linux/ktime.h"
__inline static ktime_t ns_to_ktime(u64 ns ) 
{ 
  ktime_t ktime_zero ;
  ktime_t __constr_expr_0 ;

  {
#line 285
  ktime_zero.tv64 = 0LL;
#line 287
  __constr_expr_0.tv64 = (long long )((unsigned long long )ktime_zero.tv64 + ns);
#line 287
  return (__constr_expr_0);
}
}
#line 163 "include/linux/timekeeping.h"
extern ktime_t ktime_get_with_offset(enum tk_offsets  ) ;
#line 171 "include/linux/timekeeping.h"
__inline static ktime_t ktime_get_real(void) 
{ 
  ktime_t tmp ;

  {
#line 173
  tmp = ktime_get_with_offset(0);
#line 173
  return (tmp);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_359(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_361(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_360(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_363(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_362(struct workqueue_struct *ldv_func_arg1 ) ;
#line 467
bool ldv_cancel_work_sync_371(struct work_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___0(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_359(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 528 "include/linux/workqueue.h"
__inline static bool schedule_work___0(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 530
  tmp = queue_work___0(system_wq, work);
#line 530
  return (tmp);
}
}
#line 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void invoke_work_9(void) ;
#line 301
void call_and_disable_work_9(struct work_struct *work ) ;
#line 650 "./arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 652
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 672
extern void __copy_from_user_overflow(void) ;
#line 677
extern void __copy_to_user_overflow(void) ;
#line 693 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 695
  tmp = __builtin_object_size((void const   *)to, 0);
#line 695
  sz = (int )tmp;
#line 697
  __might_fault("./arch/x86/include/asm/uaccess.h", 697);
#line 717
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
#line 717
  if (tmp___0 != 0L) {
#line 718
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
#line 722
    __copy_from_user_overflow();
  }
#line 724
  return (n);
}
}
#line 728 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 730
  tmp = __builtin_object_size(from, 0);
#line 730
  sz = (int )tmp;
#line 732
  __might_fault("./arch/x86/include/asm/uaccess.h", 732);
#line 735
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
#line 735
  if (tmp___0 != 0L) {
#line 736
    n = _copy_to_user(to, from, (unsigned int )n);
  } else {
#line 740
    __copy_to_user_overflow();
  }
#line 742
  return (n);
}
}
#line 1000 "include/linux/skbuff.h"
__inline static struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 1002
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1002
  return (& ((struct skb_shared_info *)tmp)->hwtstamps);
}
}
#line 93 "include/linux/timecounter.h"
__inline static void timecounter_adjtime(struct timecounter *tc , s64 delta ) 
{ 


  {
#line 95
  tc->nsec = tc->nsec + (unsigned long long )delta;
#line 96
  return;
}
}
#line 108
extern void timecounter_init(struct timecounter * , struct cyclecounter  const  * ,
                             u64  ) ;
#line 120
extern u64 timecounter_read(struct timecounter * ) ;
#line 136
extern u64 timecounter_cyc2time(struct timecounter * , cycle_t  ) ;
#line 124 "include/linux/ptp_clock_kernel.h"
extern struct ptp_clock *ptp_clock_register(struct ptp_clock_info * , struct device * ) ;
#line 133
extern int ptp_clock_unregister(struct ptp_clock * ) ;
#line 168
extern void ptp_clock_event(struct ptp_clock * , struct ptp_clock_event * ) ;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static void ixgbe_ptp_setup_sdp(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int shift ;
  u32 esdp ;
  u32 tsauxc ;
  u32 clktiml ;
  u32 clktimh ;
  u32 trgttiml ;
  u32 trgttimh ;
  u32 rem ;
  u64 ns ;
  u64 clock_edge ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 121
  hw = & adapter->hw;
#line 122
  shift = (int )adapter->cc.shift;
#line 124
  ns = 0ULL;
#line 124
  clock_edge = 0ULL;
#line 126
  if ((adapter->flags2 & 1024U) != 0U && (unsigned int )hw->mac.type == 3U) {
#line 130
    ixgbe_write_reg(hw, 35872U, 0U);
#line 131
    ixgbe_read_reg(hw, 8U);
#line 133
    esdp = ixgbe_read_reg(hw, 32U);
#line 139
    esdp = esdp | 65792U;
#line 146
    tsauxc = 76U;
#line 151
    clktiml = (unsigned int )(500000000ULL << shift);
#line 152
    clktimh = (unsigned int )((500000000ULL << shift) >> 32);
#line 159
    tmp = ixgbe_read_reg(hw, 35852U);
#line 159
    clock_edge = (unsigned long long )tmp | clock_edge;
#line 160
    tmp___0 = ixgbe_read_reg(hw, 35856U);
#line 160
    clock_edge = ((unsigned long long )tmp___0 << 32) | clock_edge;
#line 161
    ns = timecounter_cyc2time(& adapter->tc, clock_edge);
#line 163
    div_u64_rem(ns, 500000000U, & rem);
#line 164
    clock_edge = ((500000000ULL - (unsigned long long )rem) << shift) + clock_edge;
#line 167
    trgttiml = (unsigned int )clock_edge;
#line 168
    trgttimh = (unsigned int )(clock_edge >> 32);
#line 170
    ixgbe_write_reg(hw, 35892U, clktiml);
#line 171
    ixgbe_write_reg(hw, 35896U, clktimh);
#line 172
    ixgbe_write_reg(hw, 35876U, trgttiml);
#line 173
    ixgbe_write_reg(hw, 35880U, trgttimh);
#line 175
    ixgbe_write_reg(hw, 32U, esdp);
#line 176
    ixgbe_write_reg(hw, 35872U, tsauxc);
  } else {
#line 178
    ixgbe_write_reg(hw, 35872U, 0U);
  }
#line 181
  ixgbe_read_reg(hw, 8U);
#line 182
  return;
}
}
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static cycle_t ixgbe_ptp_read(struct cyclecounter  const  *cc ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct cyclecounter  const  *__mptr ;
  struct ixgbe_hw *hw ;
  u64 stamp ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 195
  __mptr = cc;
#line 195
  adapter = (struct ixgbe_adapter *)__mptr + 0xfffffffffffddf18UL;
#line 196
  hw = & adapter->hw;
#line 197
  stamp = 0ULL;
#line 199
  tmp = ixgbe_read_reg(hw, 35852U);
#line 199
  stamp = (unsigned long long )tmp | stamp;
#line 200
  tmp___0 = ixgbe_read_reg(hw, 35856U);
#line 200
  stamp = ((unsigned long long )tmp___0 << 32) | stamp;
#line 202
  return (stamp);
}
}
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_adjfreq(struct ptp_clock_info *ptp , s32 ppb ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ptp_clock_info  const  *__mptr ;
  struct ixgbe_hw *hw ;
  u64 freq ;
  u32 diff ;
  u32 incval ;
  int neg_adj ;
  u32 __var ;
  u64 tmp ;

  {
#line 216
  __mptr = (struct ptp_clock_info  const  *)ptp;
#line 216
  adapter = (struct ixgbe_adapter *)__mptr + 0xfffffffffffde050UL;
#line 217
  hw = & adapter->hw;
#line 220
  neg_adj = 0;
#line 222
  if (ppb < 0) {
#line 223
    neg_adj = 1;
#line 224
    ppb = - ppb;
  } else {

  }
#line 227
  __asm__  volatile   ("mfence": : : "memory");
#line 228
  __var = 0U;
#line 228
  incval = *((u32 volatile   *)(& adapter->base_incval));
#line 230
  freq = (u64 )incval;
#line 231
  freq = (u64 )ppb * freq;
#line 232
  tmp = div_u64(freq, 1000000000U);
#line 232
  diff = (u32 )tmp;
#line 234
  incval = neg_adj != 0 ? incval - diff : incval + diff;
#line 236
  switch ((unsigned int )hw->mac.type) {
  case 3U: 
#line 238
  ixgbe_write_reg(hw, 35860U, incval);
#line 239
  goto ldv_54345;
  case 2U: 
#line 241
  ixgbe_write_reg(hw, 35860U, incval | 16777216U);
#line 244
  goto ldv_54345;
  default: ;
#line 246
  goto ldv_54345;
  }
  ldv_54345: ;
#line 249
  return (0);
}
}
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_adjtime(struct ptp_clock_info *ptp , s64 delta ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ptp_clock_info  const  *__mptr ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 262
  __mptr = (struct ptp_clock_info  const  *)ptp;
#line 262
  adapter = (struct ixgbe_adapter *)__mptr + 0xfffffffffffde050UL;
#line 265
  tmp = spinlock_check(& adapter->tmreg_lock);
#line 265
  flags = _raw_spin_lock_irqsave(tmp);
#line 266
  timecounter_adjtime(& adapter->tc, delta);
#line 267
  spin_unlock_irqrestore(& adapter->tmreg_lock, flags);
#line 269
  ixgbe_ptp_setup_sdp(adapter);
#line 271
  return (0);
}
}
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_gettime(struct ptp_clock_info *ptp , struct timespec *ts ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ptp_clock_info  const  *__mptr ;
  u64 ns ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 285
  __mptr = (struct ptp_clock_info  const  *)ptp;
#line 285
  adapter = (struct ixgbe_adapter *)__mptr + 0xfffffffffffde050UL;
#line 289
  tmp = spinlock_check(& adapter->tmreg_lock);
#line 289
  flags = _raw_spin_lock_irqsave(tmp);
#line 290
  ns = timecounter_read(& adapter->tc);
#line 291
  spin_unlock_irqrestore(& adapter->tmreg_lock, flags);
#line 293
  *ts = ns_to_timespec((s64 const   )ns);
#line 295
  return (0);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_settime(struct ptp_clock_info *ptp , struct timespec  const  *ts ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ptp_clock_info  const  *__mptr ;
  u64 ns ;
  unsigned long flags ;
  s64 tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 310
  __mptr = (struct ptp_clock_info  const  *)ptp;
#line 310
  adapter = (struct ixgbe_adapter *)__mptr + 0xfffffffffffde050UL;
#line 314
  tmp = timespec_to_ns(ts);
#line 314
  ns = (u64 )tmp;
#line 317
  tmp___0 = spinlock_check(& adapter->tmreg_lock);
#line 317
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 318
  timecounter_init(& adapter->tc, (struct cyclecounter  const  *)(& adapter->cc),
                   ns);
#line 319
  spin_unlock_irqrestore(& adapter->tmreg_lock, flags);
#line 321
  ixgbe_ptp_setup_sdp(adapter);
#line 322
  return (0);
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_feature_enable(struct ptp_clock_info *ptp , struct ptp_clock_request *rq ,
                                    int on ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ptp_clock_info  const  *__mptr ;

  {
#line 338
  __mptr = (struct ptp_clock_info  const  *)ptp;
#line 338
  adapter = (struct ixgbe_adapter *)__mptr + 0xfffffffffffde050UL;
#line 346
  if ((unsigned int )rq->type == 2U) {
#line 347
    switch ((unsigned int )adapter->hw.mac.type) {
    case 3U: ;
#line 349
    if (on != 0) {
#line 350
      adapter->flags2 = adapter->flags2 | 1024U;
    } else {
#line 352
      adapter->flags2 = adapter->flags2 & 4294966271U;
    }
#line 354
    ixgbe_ptp_setup_sdp(adapter);
#line 355
    return (0);
    default: ;
#line 357
    goto ldv_54393;
    }
    ldv_54393: ;
  } else {

  }
#line 361
  return (-524);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_check_pps_event(struct ixgbe_adapter *adapter , u32 eicr ) 
{ 
  struct ixgbe_hw *hw ;
  struct ptp_clock_event event ;

  {
#line 374
  hw = & adapter->hw;
#line 377
  event.type = 2;
#line 383
  if ((unsigned long )adapter->ptp_clock == (unsigned long )((struct ptp_clock *)0)) {
#line 384
    return;
  } else {

  }
#line 386
  switch ((unsigned int )hw->mac.type) {
  case 3U: 
#line 388
  ptp_clock_event(adapter->ptp_clock, & event);
#line 389
  goto ldv_54401;
  default: ;
#line 391
  goto ldv_54401;
  }
  ldv_54401: ;
#line 394
  return;
}
}
#line 403 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_overflow_check(struct ixgbe_adapter *adapter ) 
{ 
  bool timeout ;
  struct timespec ts ;

  {
#line 405
  timeout = (bool )((long )((adapter->last_overflow_check - (unsigned long )jiffies) + 7500UL) < 0L);
#line 409
  if ((int )timeout) {
#line 410
    ixgbe_ptp_gettime(& adapter->ptp_caps, & ts);
#line 411
    adapter->last_overflow_check = jiffies;
  } else {

  }
#line 413
  return;
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_rx_hang(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 tsyncrxctl ;
  u32 tmp ;
  unsigned long rx_event ;

  {
#line 426
  hw = & adapter->hw;
#line 427
  tmp = ixgbe_read_reg(hw, 20872U);
#line 427
  tsyncrxctl = tmp;
#line 433
  if ((tsyncrxctl & 1U) == 0U) {
#line 434
    adapter->last_rx_ptp_check = jiffies;
#line 435
    return;
  } else {

  }
#line 439
  rx_event = adapter->last_rx_ptp_check;
#line 440
  if ((long )(rx_event - adapter->last_rx_timestamp) < 0L) {
#line 441
    rx_event = adapter->last_rx_timestamp;
  } else {

  }
#line 444
  if ((long )((rx_event - (unsigned long )jiffies) + 1250UL) < 0L) {
#line 445
    ixgbe_read_reg(hw, 20900U);
#line 446
    adapter->last_rx_ptp_check = jiffies;
#line 448
    if ((int )adapter->msg_enable & 1) {
#line 448
      netdev_warn((struct net_device  const  *)adapter->netdev, "clearing RX Timestamp hang\n");
    } else {

    }
  } else {

  }
#line 450
  return;
}
}
#line 460 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static void ixgbe_ptp_tx_hwtstamp(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct skb_shared_hwtstamps shhwtstamps ;
  u64 regval ;
  u64 ns ;
  unsigned long flags ;
  u32 tmp ;
  u32 tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 462
  hw = & adapter->hw;
#line 464
  regval = 0ULL;
#line 467
  tmp = ixgbe_read_reg(hw, 35844U);
#line 467
  regval = (unsigned long long )tmp | regval;
#line 468
  tmp___0 = ixgbe_read_reg(hw, 35848U);
#line 468
  regval = ((unsigned long long )tmp___0 << 32) | regval;
#line 470
  tmp___1 = spinlock_check(& adapter->tmreg_lock);
#line 470
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 471
  ns = timecounter_cyc2time(& adapter->tc, regval);
#line 472
  spin_unlock_irqrestore(& adapter->tmreg_lock, flags);
#line 474
  memset((void *)(& shhwtstamps), 0, 8UL);
#line 475
  shhwtstamps.hwtstamp = ns_to_ktime(ns);
#line 476
  skb_tstamp_tx(adapter->ptp_tx_skb, & shhwtstamps);
#line 478
  dev_kfree_skb_any(adapter->ptp_tx_skb);
#line 479
  adapter->ptp_tx_skb = (struct sk_buff *)0;
#line 480
  clear_bit_unlock(9L, (unsigned long volatile   *)(& adapter->state));
#line 481
  return;
}
}
#line 491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static void ixgbe_ptp_tx_hwtstamp_work(struct work_struct *work ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  struct ixgbe_hw *hw ;
  bool timeout ;
  u32 tsynctxctl ;

  {
#line 493
  __mptr = (struct work_struct  const  *)work;
#line 493
  adapter = (struct ixgbe_adapter *)__mptr + 0xfffffffffffddfe8UL;
#line 495
  hw = & adapter->hw;
#line 496
  timeout = (bool )((long )((adapter->ptp_tx_start - (unsigned long )jiffies) + 3750UL) < 0L);
#line 500
  if ((int )timeout) {
#line 501
    dev_kfree_skb_any(adapter->ptp_tx_skb);
#line 502
    adapter->ptp_tx_skb = (struct sk_buff *)0;
#line 503
    clear_bit_unlock(9L, (unsigned long volatile   *)(& adapter->state));
#line 504
    if ((int )adapter->msg_enable & 1) {
#line 504
      netdev_warn((struct net_device  const  *)adapter->netdev, "clearing Tx Timestamp hang\n");
    } else {

    }
#line 505
    return;
  } else {

  }
#line 508
  tsynctxctl = ixgbe_read_reg(hw, 35840U);
#line 509
  if ((int )tsynctxctl & 1) {
#line 510
    ixgbe_ptp_tx_hwtstamp(adapter);
  } else {
#line 513
    schedule_work___0(& adapter->ptp_tx_work);
  }
#line 514
  return;
}
}
#line 525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_rx_hwtstamp(struct ixgbe_adapter *adapter , struct sk_buff *skb ) 
{ 
  struct ixgbe_hw *hw ;
  struct skb_shared_hwtstamps *shhwtstamps ;
  u64 regval ;
  u64 ns ;
  u32 tsyncrxctl ;
  unsigned long flags ;
  u32 tmp ;
  u32 tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 527
  hw = & adapter->hw;
#line 529
  regval = 0ULL;
#line 533
  tsyncrxctl = ixgbe_read_reg(hw, 20872U);
#line 534
  if ((tsyncrxctl & 1U) == 0U) {
#line 535
    return;
  } else {

  }
#line 537
  tmp = ixgbe_read_reg(hw, 20968U);
#line 537
  regval = (unsigned long long )tmp | regval;
#line 538
  tmp___0 = ixgbe_read_reg(hw, 20900U);
#line 538
  regval = ((unsigned long long )tmp___0 << 32) | regval;
#line 540
  tmp___1 = spinlock_check(& adapter->tmreg_lock);
#line 540
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 541
  ns = timecounter_cyc2time(& adapter->tc, regval);
#line 542
  spin_unlock_irqrestore(& adapter->tmreg_lock, flags);
#line 544
  shhwtstamps = skb_hwtstamps(skb);
#line 545
  shhwtstamps->hwtstamp = ns_to_ktime(ns);
#line 550
  adapter->last_rx_timestamp = jiffies;
#line 551
  return;
}
}
#line 553 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
int ixgbe_ptp_get_ts_config(struct ixgbe_adapter *adapter , struct ifreq *ifr ) 
{ 
  struct hwtstamp_config *config ;
  unsigned long tmp ;

  {
#line 555
  config = & adapter->tstamp_config;
#line 557
  tmp = copy_to_user(ifr->ifr_ifru.ifru_data, (void const   *)config, 12UL);
#line 557
  return (tmp != 0UL ? -14 : 0);
}
}
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_set_timestamp_mode(struct ixgbe_adapter *adapter , struct hwtstamp_config *config ) 
{ 
  struct ixgbe_hw *hw ;
  u32 tsync_tx_ctl ;
  u32 tsync_rx_ctl ;
  u32 tsync_rx_mtrl ;
  bool is_l2 ;
  u32 regval ;

  {
#line 589
  hw = & adapter->hw;
#line 590
  tsync_tx_ctl = 16U;
#line 591
  tsync_rx_ctl = 16U;
#line 592
  tsync_rx_mtrl = 20905984U;
#line 593
  is_l2 = 0;
#line 597
  if (config->flags != 0) {
#line 598
    return (-22);
  } else {

  }
#line 600
  switch (config->tx_type) {
  case 0: 
#line 602
  tsync_tx_ctl = 0U;
  case 1: ;
#line 604
  goto ldv_54488;
  default: ;
#line 606
  return (-34);
  }
  ldv_54488: ;
#line 609
  switch (config->rx_filter) {
  case 0: 
#line 611
  tsync_rx_ctl = 0U;
#line 612
  tsync_rx_mtrl = 0U;
#line 613
  goto ldv_54491;
  case 4: 
#line 615
  tsync_rx_ctl = tsync_rx_ctl | 2U;
#line 616
  tsync_rx_mtrl = tsync_rx_mtrl;
#line 617
  goto ldv_54491;
  case 5: 
#line 619
  tsync_rx_ctl = tsync_rx_ctl | 2U;
#line 620
  tsync_rx_mtrl = tsync_rx_mtrl | 1U;
#line 621
  goto ldv_54491;
  case 12: ;
  case 9: ;
  case 6: ;
  case 13: ;
  case 10: ;
  case 7: ;
  case 14: ;
  case 11: ;
  case 8: 
#line 631
  tsync_rx_ctl = tsync_rx_ctl | 10U;
#line 632
  is_l2 = 1;
#line 633
  config->rx_filter = 12;
#line 634
  goto ldv_54491;
  case 3: ;
  case 1: ;
  default: 
#line 644
  config->rx_filter = 0;
#line 645
  return (-34);
  }
  ldv_54491: ;
#line 648
  if ((unsigned int )hw->mac.type == 1U) {
#line 649
    if ((tsync_rx_ctl | tsync_tx_ctl) != 0U) {
#line 650
      return (-34);
    } else {

    }
#line 651
    return (0);
  } else {

  }
#line 655
  if ((int )is_l2) {
#line 656
    ixgbe_write_reg(hw, 20788U, 3221260535U);
  } else {
#line 661
    ixgbe_write_reg(hw, 20788U, 0U);
  }
#line 664
  regval = ixgbe_read_reg(hw, 35840U);
#line 665
  regval = regval & 4294967279U;
#line 666
  regval = regval | tsync_tx_ctl;
#line 667
  ixgbe_write_reg(hw, 35840U, regval);
#line 670
  regval = ixgbe_read_reg(hw, 20872U);
#line 671
  regval = regval & 4294967265U;
#line 672
  regval = regval | tsync_rx_ctl;
#line 673
  ixgbe_write_reg(hw, 20872U, regval);
#line 676
  ixgbe_write_reg(hw, 20768U, tsync_rx_mtrl);
#line 678
  ixgbe_read_reg(hw, 8U);
#line 681
  regval = ixgbe_read_reg(hw, 35848U);
#line 682
  regval = ixgbe_read_reg(hw, 20900U);
#line 684
  return (0);
}
}
#line 695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
int ixgbe_ptp_set_ts_config(struct ixgbe_adapter *adapter , struct ifreq *ifr ) 
{ 
  struct hwtstamp_config config ;
  int err ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 700
  tmp = copy_from_user((void *)(& config), (void const   *)ifr->ifr_ifru.ifru_data,
                       12UL);
#line 700
  if (tmp != 0UL) {
#line 701
    return (-14);
  } else {

  }
#line 703
  err = ixgbe_ptp_set_timestamp_mode(adapter, & config);
#line 704
  if (err != 0) {
#line 705
    return (err);
  } else {

  }
#line 708
  memcpy((void *)(& adapter->tstamp_config), (void const   *)(& config), 12UL);
#line 711
  tmp___0 = copy_to_user(ifr->ifr_ifru.ifru_data, (void const   *)(& config), 12UL);
#line 711
  return (tmp___0 != 0UL ? -14 : 0);
}
}
#line 725 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_start_cyclecounter(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 incval ;
  u32 shift ;
  unsigned long flags ;
  u32 __var ;
  raw_spinlock_t *tmp ;

  {
#line 727
  hw = & adapter->hw;
#line 728
  incval = 0U;
#line 729
  shift = 0U;
#line 746
  switch (adapter->link_speed) {
  case 8U: 
#line 748
  incval = 1342177280U;
#line 749
  shift = 21U;
#line 750
  goto ldv_54520;
  case 32U: 
#line 752
  incval = 1073741824U;
#line 753
  shift = 24U;
#line 754
  goto ldv_54520;
  case 128U: ;
  default: 
#line 757
  incval = 1717986918U;
#line 758
  shift = 28U;
#line 759
  goto ldv_54520;
  }
  ldv_54520: ;
#line 768
  switch ((unsigned int )hw->mac.type) {
  case 3U: 
#line 770
  ixgbe_write_reg(hw, 35860U, incval);
#line 771
  goto ldv_54525;
  case 2U: 
#line 773
  incval = incval >> 7;
#line 774
  shift = shift - 7U;
#line 775
  ixgbe_write_reg(hw, 35860U, incval | 16777216U);
#line 778
  goto ldv_54525;
  default: ;
#line 781
  return;
  }
  ldv_54525: 
#line 785
  __var = 0U;
#line 785
  *((u32 volatile   *)(& adapter->base_incval)) = incval;
#line 786
  __asm__  volatile   ("mfence": : : "memory");
#line 789
  tmp = spinlock_check(& adapter->tmreg_lock);
#line 789
  flags = _raw_spin_lock_irqsave(tmp);
#line 791
  memset((void *)(& adapter->cc), 0, 24UL);
#line 792
  adapter->cc.read = & ixgbe_ptp_read;
#line 793
  adapter->cc.mask = 0xffffffffffffffffULL;
#line 794
  adapter->cc.shift = shift;
#line 795
  adapter->cc.mult = 1U;
#line 797
  spin_unlock_irqrestore(& adapter->tmreg_lock, flags);
#line 798
  return;
}
}
#line 812 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_reset(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  ktime_t tmp___0 ;

  {
#line 814
  hw = & adapter->hw;
#line 818
  ixgbe_write_reg(hw, 35852U, 0U);
#line 819
  ixgbe_write_reg(hw, 35856U, 0U);
#line 820
  ixgbe_read_reg(hw, 8U);
#line 823
  ixgbe_ptp_set_timestamp_mode(adapter, & adapter->tstamp_config);
#line 825
  ixgbe_ptp_start_cyclecounter(adapter);
#line 827
  tmp = spinlock_check(& adapter->tmreg_lock);
#line 827
  flags = _raw_spin_lock_irqsave(tmp);
#line 830
  tmp___0 = ktime_get_real();
#line 830
  timecounter_init(& adapter->tc, (struct cyclecounter  const  *)(& adapter->cc),
                   (u64 )tmp___0.tv64);
#line 833
  spin_unlock_irqrestore(& adapter->tmreg_lock, flags);
#line 839
  ixgbe_ptp_setup_sdp(adapter);
#line 840
  return;
}
}
#line 852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_create_clock(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  long err ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 854
  netdev = adapter->netdev;
#line 858
  tmp = IS_ERR_OR_NULL((void const   *)adapter->ptp_clock);
#line 858
  if (tmp) {
#line 858
    tmp___0 = 0;
  } else {
#line 858
    tmp___0 = 1;
  }
#line 858
  if (tmp___0) {
#line 859
    return (0);
  } else {

  }
#line 861
  switch ((unsigned int )adapter->hw.mac.type) {
  case 3U: 
#line 863
  snprintf((char *)(& adapter->ptp_caps.name), 16UL, "%s", (char *)(& netdev->name));
#line 866
  adapter->ptp_caps.owner = & __this_module;
#line 867
  adapter->ptp_caps.max_adj = 250000000;
#line 868
  adapter->ptp_caps.n_alarm = 0;
#line 869
  adapter->ptp_caps.n_ext_ts = 0;
#line 870
  adapter->ptp_caps.n_per_out = 0;
#line 871
  adapter->ptp_caps.pps = 1;
#line 872
  adapter->ptp_caps.adjfreq = & ixgbe_ptp_adjfreq;
#line 873
  adapter->ptp_caps.adjtime = & ixgbe_ptp_adjtime;
#line 874
  adapter->ptp_caps.gettime64 = & ixgbe_ptp_gettime;
#line 875
  adapter->ptp_caps.settime64 = & ixgbe_ptp_settime;
#line 876
  adapter->ptp_caps.enable = & ixgbe_ptp_feature_enable;
#line 877
  goto ldv_54547;
  case 2U: 
#line 879
  snprintf((char *)(& adapter->ptp_caps.name), 16UL, "%s", (char *)(& netdev->name));
#line 882
  adapter->ptp_caps.owner = & __this_module;
#line 883
  adapter->ptp_caps.max_adj = 250000000;
#line 884
  adapter->ptp_caps.n_alarm = 0;
#line 885
  adapter->ptp_caps.n_ext_ts = 0;
#line 886
  adapter->ptp_caps.n_per_out = 0;
#line 887
  adapter->ptp_caps.pps = 0;
#line 888
  adapter->ptp_caps.adjfreq = & ixgbe_ptp_adjfreq;
#line 889
  adapter->ptp_caps.adjtime = & ixgbe_ptp_adjtime;
#line 890
  adapter->ptp_caps.gettime64 = & ixgbe_ptp_gettime;
#line 891
  adapter->ptp_caps.settime64 = & ixgbe_ptp_settime;
#line 892
  adapter->ptp_caps.enable = & ixgbe_ptp_feature_enable;
#line 893
  goto ldv_54547;
  default: 
#line 895
  adapter->ptp_clock = (struct ptp_clock *)0;
#line 896
  return (-95);
  }
  ldv_54547: 
#line 899
  adapter->ptp_clock = ptp_clock_register(& adapter->ptp_caps, & (adapter->pdev)->dev);
#line 901
  tmp___1 = IS_ERR((void const   *)adapter->ptp_clock);
#line 901
  if ((int )tmp___1) {
#line 902
    err = PTR_ERR((void const   *)adapter->ptp_clock);
#line 903
    adapter->ptp_clock = (struct ptp_clock *)0;
#line 904
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "ptp_clock_register failed\n");
#line 905
    return ((int )err);
  } else {
#line 907
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "registered PHC device on %s\n",
              (char *)(& netdev->name));
  }
#line 913
  adapter->tstamp_config.rx_filter = 0;
#line 914
  adapter->tstamp_config.tx_type = 0;
#line 916
  return (0);
}
}
#line 927 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_init(struct ixgbe_adapter *adapter ) 
{ 
  struct lock_class_key __key ;
  int tmp ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;

  {
#line 933
  spinlock_check(& adapter->tmreg_lock);
#line 933
  __raw_spin_lock_init(& adapter->tmreg_lock.__annonCompField17.rlock, "&(&adapter->tmreg_lock)->rlock",
                       & __key);
#line 936
  tmp = ixgbe_ptp_create_clock(adapter);
#line 936
  if (tmp != 0) {
#line 937
    return;
  } else {

  }
#line 940
  __init_work(& adapter->ptp_tx_work, 0);
#line 940
  __constr_expr_0.counter = 137438953408L;
#line 940
  adapter->ptp_tx_work.data = __constr_expr_0;
#line 940
  lockdep_init_map(& adapter->ptp_tx_work.lockdep_map, "(&adapter->ptp_tx_work)",
                   & __key___0, 0);
#line 940
  INIT_LIST_HEAD(& adapter->ptp_tx_work.entry);
#line 940
  adapter->ptp_tx_work.func = & ixgbe_ptp_tx_hwtstamp_work;
#line 943
  ixgbe_ptp_reset(adapter);
#line 946
  set_bit(8L, (unsigned long volatile   *)(& adapter->state));
#line 948
  return;
}
}
#line 958 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_suspend(struct ixgbe_adapter *adapter ) 
{ 
  int tmp ;

  {
#line 961
  tmp = test_and_clear_bit(8L, (unsigned long volatile   *)(& adapter->state));
#line 961
  if (tmp == 0) {
#line 962
    return;
  } else {

  }
#line 967
  ixgbe_write_reg(& adapter->hw, 35872U, 0U);
#line 970
  ldv_cancel_work_sync_371(& adapter->ptp_tx_work);
#line 971
  if ((unsigned long )adapter->ptp_tx_skb != (unsigned long )((struct sk_buff *)0)) {
#line 972
    dev_kfree_skb_any(adapter->ptp_tx_skb);
#line 973
    adapter->ptp_tx_skb = (struct sk_buff *)0;
#line 974
    clear_bit_unlock(9L, (unsigned long volatile   *)(& adapter->state));
  } else {

  }
#line 976
  return;
}
}
#line 985 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_stop(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 988
  ixgbe_ptp_suspend(adapter);
#line 991
  if ((unsigned long )adapter->ptp_clock != (unsigned long )((struct ptp_clock *)0)) {
#line 992
    ptp_clock_unregister(adapter->ptp_clock);
#line 993
    adapter->ptp_clock = (struct ptp_clock *)0;
#line 994
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "removed PHC on %s\n",
              (char *)(& (adapter->netdev)->name));
  } else {

  }
#line 996
  return;
}
}
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void work_init_9(void) 
{ 


  {
#line 333
  ldv_work_9_0 = 0;
#line 334
  ldv_work_9_1 = 0;
#line 335
  ldv_work_9_2 = 0;
#line 336
  ldv_work_9_3 = 0;
#line 337
  return;
}
}
#line 340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void call_and_disable_all_9(int state ) 
{ 


  {
#line 342
  if (ldv_work_9_0 == state) {
#line 343
    call_and_disable_work_9(ldv_work_struct_9_0);
  } else {

  }
#line 344
  if (ldv_work_9_1 == state) {
#line 345
    call_and_disable_work_9(ldv_work_struct_9_1);
  } else {

  }
#line 346
  if (ldv_work_9_2 == state) {
#line 347
    call_and_disable_work_9(ldv_work_struct_9_2);
  } else {

  }
#line 348
  if (ldv_work_9_3 == state) {
#line 349
    call_and_disable_work_9(ldv_work_struct_9_3);
  } else {

  }
#line 350
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void invoke_work_9(void) 
{ 
  int tmp ;

  {
#line 355
  tmp = __VERIFIER_nondet_int();
#line 355
  switch (tmp) {
  case 0: ;
#line 357
  if (ldv_work_9_0 == 2 || ldv_work_9_0 == 3) {
#line 358
    ldv_work_9_0 = 4;
#line 359
    ixgbe_ptp_tx_hwtstamp_work(ldv_work_struct_9_0);
#line 360
    ldv_work_9_0 = 1;
  } else {

  }
#line 363
  goto ldv_54574;
  case 1: ;
#line 365
  if (ldv_work_9_1 == 2 || ldv_work_9_1 == 3) {
#line 366
    ldv_work_9_1 = 4;
#line 367
    ixgbe_ptp_tx_hwtstamp_work(ldv_work_struct_9_0);
#line 368
    ldv_work_9_1 = 1;
  } else {

  }
#line 371
  goto ldv_54574;
  case 2: ;
#line 373
  if (ldv_work_9_2 == 2 || ldv_work_9_2 == 3) {
#line 374
    ldv_work_9_2 = 4;
#line 375
    ixgbe_ptp_tx_hwtstamp_work(ldv_work_struct_9_0);
#line 376
    ldv_work_9_2 = 1;
  } else {

  }
#line 379
  goto ldv_54574;
  case 3: ;
#line 381
  if (ldv_work_9_3 == 2 || ldv_work_9_3 == 3) {
#line 382
    ldv_work_9_3 = 4;
#line 383
    ixgbe_ptp_tx_hwtstamp_work(ldv_work_struct_9_0);
#line 384
    ldv_work_9_3 = 1;
  } else {

  }
#line 387
  goto ldv_54574;
  default: 
#line 388
  ldv_stop();
  }
  ldv_54574: ;
#line 390
  return;
}
}
#line 394 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void activate_work_9(struct work_struct *work , int state ) 
{ 


  {
#line 395
  if (ldv_work_9_0 == 0) {
#line 396
    ldv_work_struct_9_0 = work;
#line 397
    ldv_work_9_0 = state;
#line 398
    return;
  } else {

  }
#line 401
  if (ldv_work_9_1 == 0) {
#line 402
    ldv_work_struct_9_1 = work;
#line 403
    ldv_work_9_1 = state;
#line 404
    return;
  } else {

  }
#line 407
  if (ldv_work_9_2 == 0) {
#line 408
    ldv_work_struct_9_2 = work;
#line 409
    ldv_work_9_2 = state;
#line 410
    return;
  } else {

  }
#line 413
  if (ldv_work_9_3 == 0) {
#line 414
    ldv_work_struct_9_3 = work;
#line 415
    ldv_work_9_3 = state;
#line 416
    return;
  } else {

  }
#line 418
  return;
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void call_and_disable_work_9(struct work_struct *work ) 
{ 


  {
#line 424
  if ((ldv_work_9_0 == 2 || ldv_work_9_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_0) {
#line 426
    ixgbe_ptp_tx_hwtstamp_work(work);
#line 427
    ldv_work_9_0 = 1;
#line 428
    return;
  } else {

  }
#line 430
  if ((ldv_work_9_1 == 2 || ldv_work_9_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_1) {
#line 432
    ixgbe_ptp_tx_hwtstamp_work(work);
#line 433
    ldv_work_9_1 = 1;
#line 434
    return;
  } else {

  }
#line 436
  if ((ldv_work_9_2 == 2 || ldv_work_9_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_2) {
#line 438
    ixgbe_ptp_tx_hwtstamp_work(work);
#line 439
    ldv_work_9_2 = 1;
#line 440
    return;
  } else {

  }
#line 442
  if ((ldv_work_9_3 == 2 || ldv_work_9_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_3) {
#line 444
    ixgbe_ptp_tx_hwtstamp_work(work);
#line 445
    ldv_work_9_3 = 1;
#line 446
    return;
  } else {

  }
#line 448
  return;
}
}
#line 451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void disable_work_9(struct work_struct *work ) 
{ 


  {
#line 453
  if ((ldv_work_9_0 == 3 || ldv_work_9_0 == 2) && (unsigned long )ldv_work_struct_9_0 == (unsigned long )work) {
#line 455
    ldv_work_9_0 = 1;
  } else {

  }
#line 457
  if ((ldv_work_9_1 == 3 || ldv_work_9_1 == 2) && (unsigned long )ldv_work_struct_9_1 == (unsigned long )work) {
#line 459
    ldv_work_9_1 = 1;
  } else {

  }
#line 461
  if ((ldv_work_9_2 == 3 || ldv_work_9_2 == 2) && (unsigned long )ldv_work_struct_9_2 == (unsigned long )work) {
#line 463
    ldv_work_9_2 = 1;
  } else {

  }
#line 465
  if ((ldv_work_9_3 == 3 || ldv_work_9_3 == 2) && (unsigned long )ldv_work_struct_9_3 == (unsigned long )work) {
#line 467
    ldv_work_9_3 = 1;
  } else {

  }
#line 468
  return;
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 480
  tmp = ldv_ptr_err(ptr);
#line 480
  return (tmp);
}
}
#line 483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 486
  tmp = ldv_is_err(ptr);
#line 486
  return (tmp);
}
}
#line 489 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
__inline static bool IS_ERR_OR_NULL(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 492
  tmp = ldv_is_err_or_null(ptr);
#line 492
  return (tmp);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
bool ldv_queue_work_on_359(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 499
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 499
  ldv_func_res = tmp;
#line 501
  activate_work_9(ldv_func_arg3, 2);
#line 503
  return (ldv_func_res);
}
}
#line 506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
bool ldv_queue_delayed_work_on_360(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 510
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 510
  ldv_func_res = tmp;
#line 512
  activate_work_9(& ldv_func_arg3->work, 2);
#line 514
  return (ldv_func_res);
}
}
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
bool ldv_queue_work_on_361(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 521
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 521
  ldv_func_res = tmp;
#line 523
  activate_work_9(ldv_func_arg3, 2);
#line 525
  return (ldv_func_res);
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void ldv_flush_workqueue_362(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 531
  flush_workqueue(ldv_func_arg1);
#line 533
  call_and_disable_all_9(2);
#line 534
  return;
}
}
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
bool ldv_queue_delayed_work_on_363(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 540
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 540
  ldv_func_res = tmp;
#line 542
  activate_work_9(& ldv_func_arg3->work, 2);
#line 544
  return (ldv_func_res);
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void ldv_mutex_lock_364(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 550
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 552
  mutex_lock(ldv_func_arg1);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void ldv_mutex_unlock_365(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 558
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void ldv_mutex_lock_366(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
int ldv_mutex_trylock_367(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 575
  tmp = mutex_trylock(ldv_func_arg1);
#line 575
  ldv_func_res = tmp;
#line 577
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 577
  return (tmp___0);
#line 579
  return (ldv_func_res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void ldv_mutex_unlock_368(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 585
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 587
  mutex_unlock(ldv_func_arg1);
#line 588
  return;
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void ldv_mutex_unlock_369(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 593
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 595
  mutex_unlock(ldv_func_arg1);
#line 596
  return;
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
void ldv_mutex_lock_370(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 601
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 603
  mutex_lock(ldv_func_arg1);
#line 604
  return;
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.o.c.prepared"
bool ldv_cancel_work_sync_371(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  bool tmp ;

  {
#line 610
  tmp = cancel_work_sync(ldv_func_arg1);
#line 610
  ldv_func_res = tmp;
#line 612
  disable_work_9(ldv_func_arg1);
#line 614
  return (ldv_func_res);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_397(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_395(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_398(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_399(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.o.c.prepared"
void ldv_mutex_lock_394(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_396(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_400(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_389(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_391(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_390(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_393(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_392(struct workqueue_struct *ldv_func_arg1 ) ;
#line 143 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
void ixgbe_dcb_unpack_pfc(struct ixgbe_dcb_config *cfg , u8 *pfc_en ) ;
#line 144
void ixgbe_dcb_unpack_refill(struct ixgbe_dcb_config *cfg , int direction , u16 *refill ) ;
#line 145
void ixgbe_dcb_unpack_max(struct ixgbe_dcb_config *cfg , u16 *max ) ;
#line 146
void ixgbe_dcb_unpack_bwgid(struct ixgbe_dcb_config *cfg , int direction , u8 *bwgid ) ;
#line 147
void ixgbe_dcb_unpack_prio(struct ixgbe_dcb_config *cfg , int direction , u8 *ptype ) ;
#line 148
void ixgbe_dcb_unpack_map(struct ixgbe_dcb_config *cfg , int direction , u8 *map ) ;
#line 157
s32 ixgbe_dcb_hw_ets_config(struct ixgbe_hw *hw , u16 *refill , u16 *max , u8 *bwg_id ,
                            u8 *prio_type , u8 *prio_tc ) ;
#line 162
void ixgbe_dcb_read_rtrup2tc(struct ixgbe_hw *hw , u8 *map ) ;
#line 74 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.h"
s32 ixgbe_dcb_config_pfc_82598(struct ixgbe_hw *hw , u8 pfc_en ) ;
#line 77
s32 ixgbe_dcb_config_rx_arbiter_82598(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                      u8 *prio_type ) ;
#line 82
s32 ixgbe_dcb_config_tx_desc_arbiter_82598(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type ) ;
#line 88
s32 ixgbe_dcb_config_tx_data_arbiter_82598(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type ) ;
#line 94
s32 ixgbe_dcb_hw_config_82598(struct ixgbe_hw *hw , u8 pfc_en , u16 *refill , u16 *max ,
                              u8 *bwg_id , u8 *prio_type ) ;
#line 98 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.h"
s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *hw , u8 pfc_en , u8 *prio_tc ) ;
#line 101
s32 ixgbe_dcb_config_rx_arbiter_82599(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                      u8 *bwg_id , u8 *prio_type , u8 *prio_tc ) ;
#line 108
s32 ixgbe_dcb_config_tx_desc_arbiter_82599(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type ) ;
#line 114
s32 ixgbe_dcb_config_tx_data_arbiter_82599(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type , u8 *prio_tc ) ;
#line 121
s32 ixgbe_dcb_hw_config_82599(struct ixgbe_hw *hw , u8 pfc_en , u16 *refill , u16 *max ,
                              u8 *bwg_id , u8 *prio_type , u8 *prio_tc ) ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
static s32 ixgbe_ieee_credits(__u8 *bw , __u16 *refill , __u16 *max , int max_frame ) 
{ 
  int min_percent ;
  int min_credit ;
  int multiplier ;
  int i ;
  int val ;
  int _min1 ;
  int _min2 ;

  {
#line 46
  min_percent = 100;
#line 50
  min_credit = (max_frame / 2 + 63) / 64;
#line 53
  i = 0;
#line 53
  goto ldv_54370;
  ldv_54369: ;
#line 54
  if ((int )*(bw + (unsigned long )i) < min_percent && (unsigned int )*(bw + (unsigned long )i) != 0U) {
#line 55
    min_percent = (int )*(bw + (unsigned long )i);
  } else {

  }
#line 53
  i = i + 1;
  ldv_54370: ;
#line 53
  if (i <= 7) {
#line 55
    goto ldv_54369;
  } else {

  }
#line 58
  multiplier = min_credit / min_percent + 1;
#line 61
  i = 0;
#line 61
  goto ldv_54377;
  ldv_54376: 
#line 62
  _min1 = (int )*(bw + (unsigned long )i) * multiplier;
#line 62
  _min2 = 511;
#line 62
  val = _min1 < _min2 ? _min1 : _min2;
#line 64
  if (val < min_credit) {
#line 65
    val = min_credit;
  } else {

  }
#line 66
  *(refill + (unsigned long )i) = (__u16 )val;
#line 68
  *(max + (unsigned long )i) = (unsigned int )*(bw + (unsigned long )i) != 0U ? (__u16 )(((int )*(bw + (unsigned long )i) * 4095) / 100) : (__u16 )min_credit;
#line 61
  i = i + 1;
  ldv_54377: ;
#line 61
  if (i <= 7) {
#line 63
    goto ldv_54376;
  } else {

  }

#line 70
  return (0);
}
}
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_calculate_tc_credits(struct ixgbe_hw *hw , struct ixgbe_dcb_config *dcb_config ,
                                   int max_frame , u8 direction ) 
{ 
  struct tc_bw_alloc *p ;
  int min_credit ;
  int min_multiplier ;
  int min_percent ;
  u32 credit_refill ;
  u32 credit_max ;
  u16 link_percentage ;
  u8 bw_percent ;
  u8 i ;
  int _min1 ;
  int _min2 ;

  {
#line 89
  min_percent = 100;
#line 91
  credit_refill = 0U;
#line 92
  credit_max = 0U;
#line 93
  link_percentage = 0U;
#line 94
  bw_percent = 0U;
#line 97
  if ((unsigned long )dcb_config == (unsigned long )((struct ixgbe_dcb_config *)0)) {
#line 98
    return (-1);
  } else {

  }
#line 100
  min_credit = (max_frame / 2 + 63) / 64;
#line 104
  i = 0U;
#line 104
  goto ldv_54395;
  ldv_54394: 
#line 105
  p = (struct tc_bw_alloc *)(& dcb_config->tc_config[(int )i].path) + (unsigned long )direction;
#line 106
  bw_percent = dcb_config->bw_percentage[(int )direction][(int )p->bwg_id];
#line 107
  link_percentage = (u16 )p->bwg_percent;
#line 109
  link_percentage = (u16 )(((int )link_percentage * (int )bw_percent) / 100);
#line 111
  if ((unsigned int )link_percentage != 0U && (int )link_percentage < min_percent) {
#line 112
    min_percent = (int )link_percentage;
  } else {

  }
#line 104
  i = (u8 )((int )i + 1);
  ldv_54395: ;
#line 104
  if ((unsigned int )i <= 7U) {
#line 106
    goto ldv_54394;
  } else {

  }
#line 123
  min_multiplier = min_credit / min_percent + 1;
#line 126
  i = 0U;
#line 126
  goto ldv_54401;
  ldv_54400: 
#line 127
  p = (struct tc_bw_alloc *)(& dcb_config->tc_config[(int )i].path) + (unsigned long )direction;
#line 128
  bw_percent = dcb_config->bw_percentage[(int )direction][(int )p->bwg_id];
#line 130
  link_percentage = (u16 )p->bwg_percent;
#line 132
  link_percentage = (u16 )(((int )link_percentage * (int )bw_percent) / 100);
#line 133
  if ((unsigned int )p->bwg_percent != 0U && (unsigned int )link_percentage == 0U) {
#line 134
    link_percentage = 1U;
  } else {

  }
#line 137
  p->link_percent = (unsigned char )link_percentage;
#line 140
  _min1 = (int )link_percentage * min_multiplier;
#line 140
  _min2 = 511;
#line 140
  credit_refill = (u32 )(_min1 < _min2 ? _min1 : _min2);
#line 142
  p->data_credits_refill = (unsigned short )credit_refill;
#line 145
  credit_max = (u32 )(((int )link_percentage * 4095) / 100);
#line 152
  if (credit_max != 0U && (u32 )min_credit > credit_max) {
#line 153
    credit_max = (u32 )min_credit;
  } else {

  }
#line 155
  if ((unsigned int )direction == 0U) {
#line 162
    if (((unsigned int )hw->mac.type == 1U && credit_max != 0U) && credit_max <= 512U) {
#line 165
      credit_max = 513U;
    } else {

    }
#line 167
    dcb_config->tc_config[(int )i].desc_credits_max = (unsigned short )credit_max;
  } else {

  }
#line 171
  p->data_credits_max = (unsigned short )credit_max;
#line 126
  i = (u8 )((int )i + 1);
  ldv_54401: ;
#line 126
  if ((unsigned int )i <= 7U) {
#line 128
    goto ldv_54400;
  } else {

  }

#line 174
  return (0);
}
}
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_pfc(struct ixgbe_dcb_config *cfg , u8 *pfc_en ) 
{ 
  struct tc_configuration *tc_config ;
  int tc ;

  {
#line 179
  tc_config = (struct tc_configuration *)(& cfg->tc_config);
#line 182
  *pfc_en = 0U;
#line 182
  tc = 0;
#line 182
  goto ldv_54410;
  ldv_54409: ;
#line 183
  if ((unsigned int )(tc_config + (unsigned long )tc)->dcb_pfc != 0U) {
#line 184
    *pfc_en = (u8 )((int )((signed char )*pfc_en) | (int )((signed char )(1 << tc)));
  } else {

  }
#line 182
  tc = tc + 1;
  ldv_54410: ;
#line 182
  if (tc <= 7) {
#line 184
    goto ldv_54409;
  } else {

  }

#line 189
  return;
}
}
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_refill(struct ixgbe_dcb_config *cfg , int direction , u16 *refill ) 
{ 
  struct tc_configuration *tc_config ;
  int tc ;

  {
#line 191
  tc_config = (struct tc_configuration *)(& cfg->tc_config);
#line 194
  tc = 0;
#line 194
  goto ldv_54420;
  ldv_54419: 
#line 195
  *(refill + (unsigned long )tc) = (tc_config + (unsigned long )tc)->path[direction].data_credits_refill;
#line 194
  tc = tc + 1;
  ldv_54420: ;
#line 194
  if (tc <= 7) {
#line 196
    goto ldv_54419;
  } else {

  }

#line 201
  return;
}
}
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_max(struct ixgbe_dcb_config *cfg , u16 *max ) 
{ 
  struct tc_configuration *tc_config ;
  int tc ;

  {
#line 200
  tc_config = (struct tc_configuration *)(& cfg->tc_config);
#line 203
  tc = 0;
#line 203
  goto ldv_54429;
  ldv_54428: 
#line 204
  *(max + (unsigned long )tc) = (tc_config + (unsigned long )tc)->desc_credits_max;
#line 203
  tc = tc + 1;
  ldv_54429: ;
#line 203
  if (tc <= 7) {
#line 205
    goto ldv_54428;
  } else {

  }

#line 210
  return;
}
}
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_bwgid(struct ixgbe_dcb_config *cfg , int direction , u8 *bwgid ) 
{ 
  struct tc_configuration *tc_config ;
  int tc ;

  {
#line 210
  tc_config = (struct tc_configuration *)(& cfg->tc_config);
#line 213
  tc = 0;
#line 213
  goto ldv_54439;
  ldv_54438: 
#line 214
  *(bwgid + (unsigned long )tc) = (tc_config + (unsigned long )tc)->path[direction].bwg_id;
#line 213
  tc = tc + 1;
  ldv_54439: ;
#line 213
  if (tc <= 7) {
#line 215
    goto ldv_54438;
  } else {

  }

#line 220
  return;
}
}
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_prio(struct ixgbe_dcb_config *cfg , int direction , u8 *ptype ) 
{ 
  struct tc_configuration *tc_config ;
  int tc ;

  {
#line 220
  tc_config = (struct tc_configuration *)(& cfg->tc_config);
#line 223
  tc = 0;
#line 223
  goto ldv_54449;
  ldv_54448: 
#line 224
  *(ptype + (unsigned long )tc) = (u8 )(tc_config + (unsigned long )tc)->path[direction].prio_type;
#line 223
  tc = tc + 1;
  ldv_54449: ;
#line 223
  if (tc <= 7) {
#line 225
    goto ldv_54448;
  } else {

  }

#line 230
  return;
}
}
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
u8 ixgbe_dcb_get_tc_from_up(struct ixgbe_dcb_config *cfg , int direction , u8 up___0 ) 
{ 
  struct tc_configuration *tc_config ;
  u8 prio_mask ;
  u8 tc ;

  {
#line 229
  tc_config = (struct tc_configuration *)(& cfg->tc_config);
#line 230
  prio_mask = (u8 )(1 << (int )up___0);
#line 231
  tc = cfg->num_tcs.pg_tcs;
#line 234
  if ((unsigned int )tc == 0U) {
#line 235
    return (0U);
  } else {

  }
#line 242
  tc = (u8 )((int )tc - 1);
#line 242
  goto ldv_54461;
  ldv_54460: ;
#line 243
  if ((unsigned int )((int )(tc_config + (unsigned long )tc)->path[direction].up_to_tc_bitmap & (int )prio_mask) != 0U) {
#line 244
    goto ldv_54459;
  } else {

  }
#line 242
  tc = (u8 )((int )tc - 1);
  ldv_54461: ;
#line 242
  if ((unsigned int )tc != 0U) {
#line 244
    goto ldv_54460;
  } else {

  }
  ldv_54459: ;
#line 247
  return (tc);
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_map(struct ixgbe_dcb_config *cfg , int direction , u8 *map ) 
{ 
  u8 up___0 ;

  {
#line 254
  up___0 = 0U;
#line 254
  goto ldv_54469;
  ldv_54468: 
#line 255
  *(map + (unsigned long )up___0) = ixgbe_dcb_get_tc_from_up(cfg, direction, (int )up___0);
#line 254
  up___0 = (u8 )((int )up___0 + 1);
  ldv_54469: ;
#line 254
  if ((unsigned int )up___0 <= 7U) {
#line 256
    goto ldv_54468;
  } else {

  }

#line 261
  return;
}
}
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_hw_config(struct ixgbe_hw *hw , struct ixgbe_dcb_config *dcb_config ) 
{ 
  u8 pfc_en ;
  u8 ptype[8U] ;
  u8 bwgid[8U] ;
  u8 prio_tc[8U] ;
  u16 refill[8U] ;
  u16 max[8U] ;
  s32 tmp ;
  s32 tmp___0 ;

  {
#line 276
  ixgbe_dcb_unpack_pfc(dcb_config, & pfc_en);
#line 277
  ixgbe_dcb_unpack_refill(dcb_config, 0, (u16 *)(& refill));
#line 278
  ixgbe_dcb_unpack_max(dcb_config, (u16 *)(& max));
#line 279
  ixgbe_dcb_unpack_bwgid(dcb_config, 0, (u8 *)(& bwgid));
#line 280
  ixgbe_dcb_unpack_prio(dcb_config, 0, (u8 *)(& ptype));
#line 281
  ixgbe_dcb_unpack_map(dcb_config, 0, (u8 *)(& prio_tc));
#line 283
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 285
  tmp = ixgbe_dcb_hw_config_82598(hw, (int )pfc_en, (u16 *)(& refill), (u16 *)(& max),
                                  (u8 *)(& bwgid), (u8 *)(& ptype));
#line 285
  return (tmp);
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 291
  tmp___0 = ixgbe_dcb_hw_config_82599(hw, (int )pfc_en, (u16 *)(& refill), (u16 *)(& max),
                                      (u8 *)(& bwgid), (u8 *)(& ptype), (u8 *)(& prio_tc));
#line 291
  return (tmp___0);
  default: ;
#line 294
  goto ldv_54487;
  }
  ldv_54487: ;
#line 296
  return (0);
}
}
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_hw_pfc_config(struct ixgbe_hw *hw , u8 pfc_en , u8 *prio_tc ) 
{ 
  s32 tmp ;
  s32 tmp___0 ;

  {
#line 302
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 304
  tmp = ixgbe_dcb_config_pfc_82598(hw, (int )pfc_en);
#line 304
  return (tmp);
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 309
  tmp___0 = ixgbe_dcb_config_pfc_82599(hw, (int )pfc_en, prio_tc);
#line 309
  return (tmp___0);
  default: ;
#line 311
  goto ldv_54499;
  }
  ldv_54499: ;
#line 313
  return (-22);
}
}
#line 316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_hw_ets(struct ixgbe_hw *hw , struct ieee_ets *ets , int max_frame ) 
{ 
  __u16 refill[8U] ;
  __u16 max[8U] ;
  __u8 prio_type[8U] ;
  int i ;
  __u8 bwg_id[8U] ;
  s32 tmp ;

  {
#line 323
  bwg_id[0] = 0U;
#line 323
  bwg_id[1] = 1U;
#line 323
  bwg_id[2] = 2U;
#line 323
  bwg_id[3] = 3U;
#line 323
  bwg_id[4] = 4U;
#line 323
  bwg_id[5] = 5U;
#line 323
  bwg_id[6] = 6U;
#line 323
  bwg_id[7] = 7U;
#line 326
  i = 0;
#line 326
  goto ldv_54515;
  ldv_54514: ;
#line 327
  switch ((int )ets->tc_tsa[i]) {
  case 0: 
#line 329
  prio_type[i] = 2U;
#line 330
  goto ldv_54511;
  case 2: 
#line 332
  prio_type[i] = 0U;
#line 333
  goto ldv_54511;
  default: ;
#line 340
  return (-22);
  }
  ldv_54511: 
#line 326
  i = i + 1;
  ldv_54515: ;
#line 326
  if (i <= 7) {
#line 328
    goto ldv_54514;
  } else {

  }
#line 344
  ixgbe_ieee_credits((__u8 *)(& ets->tc_tx_bw), (__u16 *)(& refill), (__u16 *)(& max),
                     max_frame);
#line 345
  tmp = ixgbe_dcb_hw_ets_config(hw, (u16 *)(& refill), (u16 *)(& max), (u8 *)(& bwg_id),
                                (u8 *)(& prio_type), (u8 *)(& ets->prio_tc));
#line 345
  return (tmp);
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_hw_ets_config(struct ixgbe_hw *hw , u16 *refill , u16 *max , u8 *bwg_id ,
                            u8 *prio_type , u8 *prio_tc ) 
{ 


  {
#line 353
  switch ((unsigned int )hw->mac.type) {
  case 1U: 
#line 355
  ixgbe_dcb_config_rx_arbiter_82598(hw, refill, max, prio_type);
#line 357
  ixgbe_dcb_config_tx_desc_arbiter_82598(hw, refill, max, bwg_id, prio_type);
#line 359
  ixgbe_dcb_config_tx_data_arbiter_82598(hw, refill, max, bwg_id, prio_type);
#line 361
  goto ldv_54526;
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 366
  ixgbe_dcb_config_rx_arbiter_82599(hw, refill, max, bwg_id, prio_type, prio_tc);
#line 368
  ixgbe_dcb_config_tx_desc_arbiter_82599(hw, refill, max, bwg_id, prio_type);
#line 370
  ixgbe_dcb_config_tx_data_arbiter_82599(hw, refill, max, bwg_id, prio_type, prio_tc);
#line 372
  goto ldv_54526;
  default: ;
#line 374
  goto ldv_54526;
  }
  ldv_54526: ;
#line 376
  return (0);
}
}
#line 379 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
static void ixgbe_dcb_read_rtrup2tc_82599(struct ixgbe_hw *hw , u8 *map ) 
{ 
  u32 reg ;
  u32 i ;

  {
#line 383
  reg = ixgbe_read_reg(hw, 12320U);
#line 384
  i = 0U;
#line 384
  goto ldv_54539;
  ldv_54538: 
#line 385
  *(map + (unsigned long )i) = (unsigned int )((u8 )(reg >> (int )(i * 3U))) & 7U;
#line 384
  i = i + 1U;
  ldv_54539: ;
#line 384
  if (i <= 7U) {
#line 386
    goto ldv_54538;
  } else {

  }

#line 391
  return;
}
}
#line 389 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_read_rtrup2tc(struct ixgbe_hw *hw , u8 *map ) 
{ 


  {
#line 391
  switch ((unsigned int )hw->mac.type) {
  case 2U: ;
  case 3U: ;
  case 4U: ;
  case 5U: 
#line 396
  ixgbe_dcb_read_rtrup2tc_82599(hw, map);
#line 397
  goto ldv_54549;
  default: ;
#line 399
  goto ldv_54549;
  }
  ldv_54549: ;
#line 402
  return;
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.o.c.prepared"
bool ldv_queue_work_on_389(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 359
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 359
  ldv_func_res = tmp;
#line 361
  activate_work_9(ldv_func_arg3, 2);
#line 363
  return (ldv_func_res);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.o.c.prepared"
bool ldv_queue_delayed_work_on_390(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 370
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 370
  ldv_func_res = tmp;
#line 372
  activate_work_9(& ldv_func_arg3->work, 2);
#line 374
  return (ldv_func_res);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.o.c.prepared"
bool ldv_queue_work_on_391(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 381
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 381
  ldv_func_res = tmp;
#line 383
  activate_work_9(ldv_func_arg3, 2);
#line 385
  return (ldv_func_res);
}
}
#line 388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.o.c.prepared"
void ldv_flush_workqueue_392(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 391
  flush_workqueue(ldv_func_arg1);
#line 393
  call_and_disable_all_9(2);
#line 394
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.o.c.prepared"
bool ldv_queue_delayed_work_on_393(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 400
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 400
  ldv_func_res = tmp;
#line 402
  activate_work_9(& ldv_func_arg3->work, 2);
#line 404
  return (ldv_func_res);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.o.c.prepared"
void ldv_mutex_lock_394(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 410
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 412
  mutex_lock(ldv_func_arg1);
#line 413
  return;
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.o.c.prepared"
void ldv_mutex_unlock_395(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 418
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 420
  mutex_unlock(ldv_func_arg1);
#line 421
  return;
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.o.c.prepared"
void ldv_mutex_lock_396(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 426
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 428
  mutex_lock(ldv_func_arg1);
#line 429
  return;
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.o.c.prepared"
int ldv_mutex_trylock_397(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 435
  tmp = mutex_trylock(ldv_func_arg1);
#line 435
  ldv_func_res = tmp;
#line 437
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 437
  return (tmp___0);
#line 439
  return (ldv_func_res);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.o.c.prepared"
void ldv_mutex_unlock_398(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 445
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 447
  mutex_unlock(ldv_func_arg1);
#line 448
  return;
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.o.c.prepared"
void ldv_mutex_unlock_399(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 453
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 455
  mutex_unlock(ldv_func_arg1);
#line 456
  return;
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.o.c.prepared"
void ldv_mutex_lock_400(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 461
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 463
  mutex_lock(ldv_func_arg1);
#line 464
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_425(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_423(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_426(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_427(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.o.c.prepared"
void ldv_mutex_lock_422(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_424(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_428(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_417(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_419(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_418(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_421(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_420(struct workqueue_struct *ldv_func_arg1 ) ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_rx_arbiter_82598(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                      u8 *prio_type ) 
{ 
  u32 reg ;
  u32 credit_refill ;
  u32 credit_max ;
  u8 i ;
  u32 tmp ;

  {
#line 46
  reg = 0U;
#line 47
  credit_refill = 0U;
#line 48
  credit_max = 0U;
#line 49
  i = 0U;
#line 51
  tmp = ixgbe_read_reg(hw, 20640U);
#line 51
  reg = tmp | 2147483648U;
#line 52
  ixgbe_write_reg(hw, 20640U, reg);
#line 54
  reg = ixgbe_read_reg(hw, 15616U);
#line 56
  reg = reg & 4294967231U;
#line 58
  reg = reg | 2U;
#line 60
  reg = reg | 4U;
#line 62
  ixgbe_write_reg(hw, 15616U, reg);
#line 65
  i = 0U;
#line 65
  goto ldv_54338;
  ldv_54337: 
#line 66
  credit_refill = (u32 )*(refill + (unsigned long )i);
#line 67
  credit_max = (u32 )*(max + (unsigned long )i);
#line 69
  reg = (credit_max << 12) | credit_refill;
#line 71
  if ((unsigned int )*(prio_type + (unsigned long )i) == 2U) {
#line 72
    reg = reg | 2147483648U;
  } else {

  }
#line 74
  ixgbe_write_reg(hw, (u32 )(((int )i + 3848) * 4), reg);
#line 65
  i = (u8 )((int )i + 1);
  ldv_54338: ;
#line 65
  if ((unsigned int )i <= 7U) {
#line 67
    goto ldv_54337;
  } else {

  }
#line 77
  reg = ixgbe_read_reg(hw, 12032U);
#line 78
  reg = reg;
#line 79
  reg = reg | 16U;
#line 80
  reg = reg | 64U;
#line 81
  ixgbe_write_reg(hw, 12032U, reg);
#line 83
  reg = ixgbe_read_reg(hw, 12288U);
#line 85
  reg = reg & 4294967293U;
#line 86
  ixgbe_write_reg(hw, 12288U, reg);
#line 88
  return (0);
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_tx_desc_arbiter_82598(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type ) 
{ 
  u32 reg ;
  u32 max_credits ;
  u8 i ;

  {
#line 107
  reg = ixgbe_read_reg(hw, 32576U);
#line 110
  reg = reg & 4294967231U;
#line 111
  reg = reg | 524288U;
#line 114
  reg = reg | 262144U;
#line 116
  ixgbe_write_reg(hw, 32576U, reg);
#line 119
  i = 0U;
#line 119
  goto ldv_54351;
  ldv_54350: 
#line 120
  max_credits = (u32 )*(max + (unsigned long )i);
#line 121
  reg = max_credits << 12;
#line 122
  reg = (u32 )*(refill + (unsigned long )i) | reg;
#line 123
  reg = ((unsigned int )*(bwg_id + (unsigned long )i) << 9) | reg;
#line 125
  if ((unsigned int )*(prio_type + (unsigned long )i) == 1U) {
#line 126
    reg = reg | 1073741824U;
  } else {

  }
#line 128
  if ((unsigned int )*(prio_type + (unsigned long )i) == 2U) {
#line 129
    reg = reg | 2147483648U;
  } else {

  }
#line 131
  ixgbe_write_reg(hw, (u32 )((int )i * 64 + 24620), reg);
#line 119
  i = (u8 )((int )i + 1);
  ldv_54351: ;
#line 119
  if ((unsigned int )i <= 7U) {
#line 121
    goto ldv_54350;
  } else {

  }

#line 134
  return (0);
}
}
#line 144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_tx_data_arbiter_82598(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type ) 
{ 
  u32 reg ;
  u8 i ;

  {
#line 153
  reg = ixgbe_read_reg(hw, 52480U);
#line 155
  reg = reg & 4294967231U;
#line 157
  reg = reg | 288U;
#line 159
  ixgbe_write_reg(hw, 52480U, reg);
#line 162
  i = 0U;
#line 162
  goto ldv_54363;
  ldv_54362: 
#line 163
  reg = (u32 )*(refill + (unsigned long )i);
#line 164
  reg = ((unsigned int )*(max + (unsigned long )i) << 12) | reg;
#line 165
  reg = ((unsigned int )*(bwg_id + (unsigned long )i) << 9) | reg;
#line 167
  if ((unsigned int )*(prio_type + (unsigned long )i) == 1U) {
#line 168
    reg = reg | 1073741824U;
  } else {

  }
#line 170
  if ((unsigned int )*(prio_type + (unsigned long )i) == 2U) {
#line 171
    reg = reg | 2147483648U;
  } else {

  }
#line 173
  ixgbe_write_reg(hw, (u32 )(((int )i + 13128) * 4), reg);
#line 162
  i = (u8 )((int )i + 1);
  ldv_54363: ;
#line 162
  if ((unsigned int )i <= 7U) {
#line 164
    goto ldv_54362;
  } else {

  }
#line 177
  reg = ixgbe_read_reg(hw, 32256U);
#line 178
  reg = reg | 4U;
#line 179
  ixgbe_write_reg(hw, 32256U, reg);
#line 181
  return (0);
}
}
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_pfc_82598(struct ixgbe_hw *hw , u8 pfc_en ) 
{ 
  u32 fcrtl ;
  u32 reg ;
  u8 i ;

  {
#line 197
  reg = ixgbe_read_reg(hw, 15616U);
#line 198
  reg = reg & 4294967287U;
#line 199
  reg = reg | 16U;
#line 200
  ixgbe_write_reg(hw, 15616U, reg);
#line 203
  reg = ixgbe_read_reg(hw, 20608U);
#line 204
  reg = reg & 4294918143U;
#line 206
  if ((unsigned int )pfc_en != 0U) {
#line 207
    reg = reg | 16384U;
  } else {

  }
#line 209
  ixgbe_write_reg(hw, 20608U, reg);
#line 212
  i = 0U;
#line 212
  goto ldv_54374;
  ldv_54373: ;
#line 213
  if ((((int )pfc_en >> (int )i) & 1) == 0) {
#line 214
    ixgbe_write_reg(hw, (u32 )(((int )i + 1604) * 8), 0U);
#line 215
    ixgbe_write_reg(hw, (u32 )(((int )i + 1612) * 8), 0U);
#line 216
    goto ldv_54372;
  } else {

  }
#line 219
  fcrtl = (hw->fc.low_water[(int )i] << 10) | 2147483648U;
#line 220
  reg = (hw->fc.high_water[(int )i] << 10) | 2147483648U;
#line 221
  ixgbe_write_reg(hw, (u32 )(((int )i + 1604) * 8), fcrtl);
#line 222
  ixgbe_write_reg(hw, (u32 )(((int )i + 1612) * 8), reg);
  ldv_54372: 
#line 212
  i = (u8 )((int )i + 1);
  ldv_54374: ;
#line 212
  if ((unsigned int )i <= 7U) {
#line 214
    goto ldv_54373;
  } else {

  }
#line 226
  reg = (u32 )((int )hw->fc.pause_time * 65537);
#line 227
  i = 0U;
#line 227
  goto ldv_54377;
  ldv_54376: 
#line 228
  ixgbe_write_reg(hw, (u32 )(((int )i + 3200) * 4), reg);
#line 227
  i = (u8 )((int )i + 1);
  ldv_54377: ;
#line 227
  if ((unsigned int )i <= 3U) {
#line 229
    goto ldv_54376;
  } else {

  }
#line 231
  ixgbe_write_reg(hw, 12960U, (unsigned int )hw->fc.pause_time / 2U);
#line 234
  return (0);
}
}
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
static s32 ixgbe_dcb_config_tc_stats_82598(struct ixgbe_hw *hw ) 
{ 
  u32 reg ;
  u8 i ;
  u8 j ;

  {
#line 246
  reg = 0U;
#line 247
  i = 0U;
#line 248
  j = 0U;
#line 251
  i = 0U;
#line 251
  j = 0U;
#line 251
  goto ldv_54386;
  ldv_54385: 
#line 252
  reg = ixgbe_read_reg(hw, (u32 )(((int )i + 2240) * 4));
#line 253
  reg = (u32 )((int )j * 16843009) | reg;
#line 254
  ixgbe_write_reg(hw, (u32 )(((int )i + 2240) * 4), reg);
#line 255
  reg = ixgbe_read_reg(hw, (u32 )(((int )i + 2241) * 4));
#line 256
  reg = (u32 )((int )j * 16843009) | reg;
#line 257
  ixgbe_write_reg(hw, (u32 )(((int )i + 2241) * 4), reg);
#line 251
  i = (unsigned int )i + 2U;
#line 251
  j = (u8 )((int )j + 1);
  ldv_54386: ;
#line 251
  if ((unsigned int )i <= 14U && (unsigned int )j <= 7U) {
#line 253
    goto ldv_54385;
  } else {

  }
#line 260
  i = 0U;
#line 260
  goto ldv_54389;
  ldv_54388: 
#line 261
  reg = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 7U ? ((int )i + 7360) * 4 : ((int )i + 8576) * 4));
#line 262
  reg = (u32 )((int )i * 16843009) | reg;
#line 263
  ixgbe_write_reg(hw, (u32 )((unsigned int )i <= 7U ? ((int )i + 7360) * 4 : ((int )i + 8576) * 4),
                  reg);
#line 260
  i = (u8 )((int )i + 1);
  ldv_54389: ;
#line 260
  if ((unsigned int )i <= 7U) {
#line 262
    goto ldv_54388;
  } else {

  }

#line 266
  return (0);
}
}
#line 276 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_hw_config_82598(struct ixgbe_hw *hw , u8 pfc_en , u16 *refill , u16 *max ,
                              u8 *bwg_id , u8 *prio_type ) 
{ 


  {
#line 279
  ixgbe_dcb_config_rx_arbiter_82598(hw, refill, max, prio_type);
#line 280
  ixgbe_dcb_config_tx_desc_arbiter_82598(hw, refill, max, bwg_id, prio_type);
#line 282
  ixgbe_dcb_config_tx_data_arbiter_82598(hw, refill, max, bwg_id, prio_type);
#line 284
  ixgbe_dcb_config_pfc_82598(hw, (int )pfc_en);
#line 285
  ixgbe_dcb_config_tc_stats_82598(hw);
#line 287
  return (0);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.o.c.prepared"
bool ldv_queue_work_on_417(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 359
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 359
  ldv_func_res = tmp;
#line 361
  activate_work_9(ldv_func_arg3, 2);
#line 363
  return (ldv_func_res);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.o.c.prepared"
bool ldv_queue_delayed_work_on_418(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 370
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 370
  ldv_func_res = tmp;
#line 372
  activate_work_9(& ldv_func_arg3->work, 2);
#line 374
  return (ldv_func_res);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.o.c.prepared"
bool ldv_queue_work_on_419(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 381
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 381
  ldv_func_res = tmp;
#line 383
  activate_work_9(ldv_func_arg3, 2);
#line 385
  return (ldv_func_res);
}
}
#line 388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.o.c.prepared"
void ldv_flush_workqueue_420(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 391
  flush_workqueue(ldv_func_arg1);
#line 393
  call_and_disable_all_9(2);
#line 394
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.o.c.prepared"
bool ldv_queue_delayed_work_on_421(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 400
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 400
  ldv_func_res = tmp;
#line 402
  activate_work_9(& ldv_func_arg3->work, 2);
#line 404
  return (ldv_func_res);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.o.c.prepared"
void ldv_mutex_lock_422(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 410
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 412
  mutex_lock(ldv_func_arg1);
#line 413
  return;
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.o.c.prepared"
void ldv_mutex_unlock_423(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 418
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 420
  mutex_unlock(ldv_func_arg1);
#line 421
  return;
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.o.c.prepared"
void ldv_mutex_lock_424(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 426
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 428
  mutex_lock(ldv_func_arg1);
#line 429
  return;
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.o.c.prepared"
int ldv_mutex_trylock_425(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 435
  tmp = mutex_trylock(ldv_func_arg1);
#line 435
  ldv_func_res = tmp;
#line 437
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 437
  return (tmp___0);
#line 439
  return (ldv_func_res);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.o.c.prepared"
void ldv_mutex_unlock_426(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 445
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 447
  mutex_unlock(ldv_func_arg1);
#line 448
  return;
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.o.c.prepared"
void ldv_mutex_unlock_427(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 453
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 455
  mutex_unlock(ldv_func_arg1);
#line 456
  return;
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.o.c.prepared"
void ldv_mutex_lock_428(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 461
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 463
  mutex_lock(ldv_func_arg1);
#line 464
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_453(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_451(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_454(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_455(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.o.c.prepared"
void ldv_mutex_lock_450(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_452(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_456(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_445(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_447(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_446(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_449(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_448(struct workqueue_struct *ldv_func_arg1 ) ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_rx_arbiter_82599(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                      u8 *bwg_id , u8 *prio_type , u8 *prio_tc ) 
{ 
  u32 reg ;
  u32 credit_refill ;
  u32 credit_max ;
  u8 i ;

  {
#line 51
  reg = 0U;
#line 52
  credit_refill = 0U;
#line 53
  credit_max = 0U;
#line 54
  i = 0U;
#line 60
  reg = 70U;
#line 61
  ixgbe_write_reg(hw, 9264U, reg);
#line 64
  reg = 0U;
#line 65
  i = 0U;
#line 65
  goto ldv_54345;
  ldv_54344: 
#line 66
  reg = (u32 )((int )*(prio_tc + (unsigned long )i) << (int )i * 3) | reg;
#line 65
  i = (u8 )((int )i + 1);
  ldv_54345: ;
#line 65
  if ((unsigned int )i <= 7U) {
#line 67
    goto ldv_54344;
  } else {

  }
#line 67
  ixgbe_write_reg(hw, 12320U, reg);
#line 70
  i = 0U;
#line 70
  goto ldv_54348;
  ldv_54347: 
#line 71
  credit_refill = (u32 )*(refill + (unsigned long )i);
#line 72
  credit_max = (u32 )*(max + (unsigned long )i);
#line 73
  reg = (credit_max << 12) | credit_refill;
#line 75
  reg = ((unsigned int )*(bwg_id + (unsigned long )i) << 9) | reg;
#line 77
  if ((unsigned int )*(prio_type + (unsigned long )i) == 2U) {
#line 78
    reg = reg | 2147483648U;
  } else {

  }
#line 80
  ixgbe_write_reg(hw, (u32 )(((int )i + 2128) * 4), reg);
#line 70
  i = (u8 )((int )i + 1);
  ldv_54348: ;
#line 70
  if ((unsigned int )i <= 7U) {
#line 72
    goto ldv_54347;
  } else {

  }
#line 87
  reg = 6U;
#line 88
  ixgbe_write_reg(hw, 9264U, reg);
#line 90
  return (0);
}
}
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_tx_desc_arbiter_82599(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type ) 
{ 
  u32 reg ;
  u32 max_credits ;
  u8 i ;

  {
#line 113
  i = 0U;
#line 113
  goto ldv_54361;
  ldv_54360: 
#line 114
  ixgbe_write_reg(hw, 18692U, (u32 )i);
#line 115
  ixgbe_write_reg(hw, 18696U, 0U);
#line 113
  i = (u8 )((int )i + 1);
  ldv_54361: ;
#line 113
  if ((int )((signed char )i) >= 0) {
#line 115
    goto ldv_54360;
  } else {

  }
#line 119
  i = 0U;
#line 119
  goto ldv_54364;
  ldv_54363: 
#line 120
  max_credits = (u32 )*(max + (unsigned long )i);
#line 121
  reg = max_credits << 12;
#line 122
  reg = (u32 )*(refill + (unsigned long )i) | reg;
#line 123
  reg = ((unsigned int )*(bwg_id + (unsigned long )i) << 9) | reg;
#line 125
  if ((unsigned int )*(prio_type + (unsigned long )i) == 1U) {
#line 126
    reg = reg | 1073741824U;
  } else {

  }
#line 128
  if ((unsigned int )*(prio_type + (unsigned long )i) == 2U) {
#line 129
    reg = reg | 2147483648U;
  } else {

  }
#line 131
  ixgbe_write_reg(hw, (u32 )(((int )i + 4676) * 4), reg);
#line 119
  i = (u8 )((int )i + 1);
  ldv_54364: ;
#line 119
  if ((unsigned int )i <= 7U) {
#line 121
    goto ldv_54363;
  } else {

  }
#line 138
  reg = 17U;
#line 139
  ixgbe_write_reg(hw, 18688U, reg);
#line 141
  return (0);
}
}
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_tx_data_arbiter_82599(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type , u8 *prio_tc ) 
{ 
  u32 reg ;
  u8 i ;

  {
#line 168
  reg = 16777568U;
#line 171
  ixgbe_write_reg(hw, 52480U, reg);
#line 174
  reg = 0U;
#line 175
  i = 0U;
#line 175
  goto ldv_54377;
  ldv_54376: 
#line 176
  reg = (u32 )((int )*(prio_tc + (unsigned long )i) << (int )i * 3) | reg;
#line 175
  i = (u8 )((int )i + 1);
  ldv_54377: ;
#line 175
  if ((unsigned int )i <= 7U) {
#line 177
    goto ldv_54376;
  } else {

  }
#line 177
  ixgbe_write_reg(hw, 51200U, reg);
#line 180
  i = 0U;
#line 180
  goto ldv_54380;
  ldv_54379: 
#line 181
  reg = (u32 )*(refill + (unsigned long )i);
#line 182
  reg = ((unsigned int )*(max + (unsigned long )i) << 12) | reg;
#line 183
  reg = ((unsigned int )*(bwg_id + (unsigned long )i) << 9) | reg;
#line 185
  if ((unsigned int )*(prio_type + (unsigned long )i) == 1U) {
#line 186
    reg = reg | 1073741824U;
  } else {

  }
#line 188
  if ((unsigned int )*(prio_type + (unsigned long )i) == 2U) {
#line 189
    reg = reg | 2147483648U;
  } else {

  }
#line 191
  ixgbe_write_reg(hw, (u32 )(((int )i + 13128) * 4), reg);
#line 180
  i = (u8 )((int )i + 1);
  ldv_54380: ;
#line 180
  if ((unsigned int )i <= 7U) {
#line 182
    goto ldv_54379;
  } else {

  }
#line 198
  reg = 16777504U;
#line 200
  ixgbe_write_reg(hw, 52480U, reg);
#line 202
  return (0);
}
}
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *hw , u8 pfc_en , u8 *prio_tc ) 
{ 
  u32 i ;
  u32 j ;
  u32 fcrtl ;
  u32 reg ;
  u8 max_tc ;
  int enabled ;
  u32 tmp ;

  {
#line 216
  max_tc = 0U;
#line 219
  ixgbe_write_reg(hw, 15616U, 16U);
#line 222
  reg = ixgbe_read_reg(hw, 17044U);
#line 223
  reg = reg | 2U;
#line 230
  reg = reg & 4294963203U;
#line 232
  if ((unsigned int )hw->mac.type == 3U) {
#line 233
    reg = (u32 )((int )pfc_en << 4) | reg;
  } else {

  }
#line 235
  if ((unsigned int )pfc_en != 0U) {
#line 236
    reg = reg | 4U;
  } else {

  }
#line 238
  ixgbe_write_reg(hw, 17044U, reg);
#line 240
  i = 0U;
#line 240
  goto ldv_54393;
  ldv_54392: ;
#line 241
  if ((int )*(prio_tc + (unsigned long )i) > (int )max_tc) {
#line 242
    max_tc = *(prio_tc + (unsigned long )i);
  } else {

  }
#line 240
  i = i + 1U;
  ldv_54393: ;
#line 240
  if (i <= 7U) {
#line 242
    goto ldv_54392;
  } else {

  }
#line 247
  i = 0U;
#line 247
  goto ldv_54400;
  ldv_54399: 
#line 248
  enabled = 0;
#line 250
  j = 0U;
#line 250
  goto ldv_54398;
  ldv_54397: ;
#line 251
  if ((u32 )*(prio_tc + (unsigned long )j) == i && ((int )pfc_en >> (int )j) & 1) {
#line 252
    enabled = 1;
#line 253
    goto ldv_54396;
  } else {

  }
#line 250
  j = j + 1U;
  ldv_54398: ;
#line 250
  if (j <= 7U) {
#line 252
    goto ldv_54397;
  } else {

  }
  ldv_54396: ;
#line 257
  if (enabled != 0) {
#line 258
    reg = (hw->fc.high_water[i] << 10) | 2147483648U;
#line 259
    fcrtl = (hw->fc.low_water[i] << 10) | 2147483648U;
#line 260
    ixgbe_write_reg(hw, (i + 3208U) * 4U, fcrtl);
  } else {
#line 262
    tmp = ixgbe_read_reg(hw, (i + 3840U) * 4U);
#line 262
    reg = tmp - 32U;
#line 263
    ixgbe_write_reg(hw, (i + 3208U) * 4U, 0U);
  }
#line 266
  ixgbe_write_reg(hw, (i + 3224U) * 4U, reg);
#line 247
  i = i + 1U;
  ldv_54400: ;
#line 247
  if ((u32 )max_tc >= i) {
#line 249
    goto ldv_54399;
  } else {

  }

#line 269
  goto ldv_54403;
  ldv_54402: 
#line 270
  ixgbe_write_reg(hw, (i + 3208U) * 4U, 0U);
#line 271
  ixgbe_write_reg(hw, (i + 3224U) * 4U, 0U);
#line 269
  i = i + 1U;
  ldv_54403: ;
#line 269
  if (i <= 7U) {
#line 271
    goto ldv_54402;
  } else {

  }
#line 275
  reg = (u32 )((int )hw->fc.pause_time * 65537);
#line 276
  i = 0U;
#line 276
  goto ldv_54406;
  ldv_54405: 
#line 277
  ixgbe_write_reg(hw, (i + 3200U) * 4U, reg);
#line 276
  i = i + 1U;
  ldv_54406: ;
#line 276
  if (i <= 3U) {
#line 278
    goto ldv_54405;
  } else {

  }
#line 280
  ixgbe_write_reg(hw, 12960U, (unsigned int )hw->fc.pause_time / 2U);
#line 282
  return (0);
}
}
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
static s32 ixgbe_dcb_config_tc_stats_82599(struct ixgbe_hw *hw ) 
{ 
  u32 reg ;
  u8 i ;

  {
#line 294
  reg = 0U;
#line 295
  i = 0U;
#line 303
  i = 0U;
#line 303
  goto ldv_54414;
  ldv_54413: 
#line 304
  reg = (u32 )((int )((unsigned int )i / 4U) * 16843009);
#line 305
  ixgbe_write_reg(hw, (u32 )(((int )i + 2240) * 4), reg);
#line 303
  i = (u8 )((int )i + 1);
  ldv_54414: ;
#line 303
  if ((unsigned int )i <= 31U) {
#line 305
    goto ldv_54413;
  } else {

  }
#line 315
  i = 0U;
#line 315
  goto ldv_54417;
  ldv_54416: ;
#line 316
  if ((unsigned int )i <= 7U) {
#line 317
    reg = 0U;
  } else
#line 318
  if ((unsigned int )i <= 15U) {
#line 319
    reg = 16843009U;
  } else
#line 320
  if ((unsigned int )i <= 19U) {
#line 321
    reg = 33686018U;
  } else
#line 322
  if ((unsigned int )i <= 23U) {
#line 323
    reg = 50529027U;
  } else
#line 324
  if ((unsigned int )i <= 25U) {
#line 325
    reg = 67372036U;
  } else
#line 326
  if ((unsigned int )i <= 27U) {
#line 327
    reg = 84215045U;
  } else
#line 328
  if ((unsigned int )i <= 29U) {
#line 329
    reg = 101058054U;
  } else {
#line 331
    reg = 117901063U;
  }
#line 332
  ixgbe_write_reg(hw, (u32 )(((int )i + 8576) * 4), reg);
#line 315
  i = (u8 )((int )i + 1);
  ldv_54417: ;
#line 315
  if ((unsigned int )i <= 31U) {
#line 317
    goto ldv_54416;
  } else {

  }

#line 335
  return (0);
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_hw_config_82599(struct ixgbe_hw *hw , u8 pfc_en , u16 *refill , u16 *max ,
                              u8 *bwg_id , u8 *prio_type , u8 *prio_tc ) 
{ 


  {
#line 352
  ixgbe_dcb_config_rx_arbiter_82599(hw, refill, max, bwg_id, prio_type, prio_tc);
#line 354
  ixgbe_dcb_config_tx_desc_arbiter_82599(hw, refill, max, bwg_id, prio_type);
#line 356
  ixgbe_dcb_config_tx_data_arbiter_82599(hw, refill, max, bwg_id, prio_type, prio_tc);
#line 358
  ixgbe_dcb_config_pfc_82599(hw, (int )pfc_en, prio_tc);
#line 359
  ixgbe_dcb_config_tc_stats_82599(hw);
#line 361
  return (0);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.o.c.prepared"
bool ldv_queue_work_on_445(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 359
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 359
  ldv_func_res = tmp;
#line 361
  activate_work_9(ldv_func_arg3, 2);
#line 363
  return (ldv_func_res);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.o.c.prepared"
bool ldv_queue_delayed_work_on_446(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 370
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 370
  ldv_func_res = tmp;
#line 372
  activate_work_9(& ldv_func_arg3->work, 2);
#line 374
  return (ldv_func_res);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.o.c.prepared"
bool ldv_queue_work_on_447(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 381
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 381
  ldv_func_res = tmp;
#line 383
  activate_work_9(ldv_func_arg3, 2);
#line 385
  return (ldv_func_res);
}
}
#line 388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.o.c.prepared"
void ldv_flush_workqueue_448(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 391
  flush_workqueue(ldv_func_arg1);
#line 393
  call_and_disable_all_9(2);
#line 394
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.o.c.prepared"
bool ldv_queue_delayed_work_on_449(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 400
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 400
  ldv_func_res = tmp;
#line 402
  activate_work_9(& ldv_func_arg3->work, 2);
#line 404
  return (ldv_func_res);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.o.c.prepared"
void ldv_mutex_lock_450(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 410
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 412
  mutex_lock(ldv_func_arg1);
#line 413
  return;
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.o.c.prepared"
void ldv_mutex_unlock_451(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 418
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 420
  mutex_unlock(ldv_func_arg1);
#line 421
  return;
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.o.c.prepared"
void ldv_mutex_lock_452(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 426
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 428
  mutex_lock(ldv_func_arg1);
#line 429
  return;
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.o.c.prepared"
int ldv_mutex_trylock_453(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 435
  tmp = mutex_trylock(ldv_func_arg1);
#line 435
  ldv_func_res = tmp;
#line 437
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 437
  return (tmp___0);
#line 439
  return (ldv_func_res);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.o.c.prepared"
void ldv_mutex_unlock_454(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 445
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 447
  mutex_unlock(ldv_func_arg1);
#line 448
  return;
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.o.c.prepared"
void ldv_mutex_unlock_455(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 453
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 455
  mutex_unlock(ldv_func_arg1);
#line 456
  return;
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.o.c.prepared"
void ldv_mutex_lock_456(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 461
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 463
  mutex_lock(ldv_func_arg1);
#line 464
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_481(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_479(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_482(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_483(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
void ldv_mutex_lock_478(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_480(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_484(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_473(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_475(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_474(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_477(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_476(struct workqueue_struct *ldv_func_arg1 ) ;
#line 32 "include/net/dcbnl.h"
extern u8 dcb_getapp(struct net_device * , struct dcb_app * ) ;
#line 33
extern int dcb_ieee_setapp(struct net_device * , struct dcb_app * ) ;
#line 34
extern int dcb_ieee_delapp(struct net_device * , struct dcb_app * ) ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_copy_dcb_cfg(struct ixgbe_adapter *adapter , int tc_max ) 
{ 
  struct ixgbe_dcb_config *scfg ;
  struct ixgbe_dcb_config *dcfg ;
  struct tc_configuration *src ;
  struct tc_configuration *dst ;
  int i ;
  int j ;
  int tx ;
  int rx ;
  int changes ;
  struct dcb_app app ;
  u8 up___0 ;
  u8 tmp ;

  {
#line 50
  scfg = & adapter->temp_dcb_cfg;
#line 51
  dcfg = & adapter->dcb_cfg;
#line 52
  src = (struct tc_configuration *)0;
#line 53
  dst = (struct tc_configuration *)0;
#line 55
  tx = 0;
#line 56
  rx = 1;
#line 57
  changes = 0;
#line 59
  app.selector = 0U;
#line 59
  app.priority = (unsigned char)0;
#line 59
  app.protocol = 35078U;
#line 63
  tmp = dcb_getapp(adapter->netdev, & app);
#line 63
  up___0 = tmp;
#line 65
  if ((unsigned int )up___0 != 0U && (((int )up___0 >> (int )adapter->fcoe.up) & 1) == 0) {
#line 66
    changes = changes | 16;
  } else {

  }
#line 69
  i = 1;
#line 69
  goto ldv_54429;
  ldv_54428: 
#line 70
  src = (struct tc_configuration *)(& scfg->tc_config) + ((unsigned long )i + 0xffffffffffffffffUL);
#line 71
  dst = (struct tc_configuration *)(& dcfg->tc_config) + ((unsigned long )i + 0xffffffffffffffffUL);
#line 73
  if ((unsigned int )dst->path[tx].prio_type != (unsigned int )src->path[tx].prio_type) {
#line 74
    dst->path[tx].prio_type = src->path[tx].prio_type;
#line 75
    changes = changes | 8;
  } else {

  }
#line 78
  if ((int )dst->path[tx].bwg_id != (int )src->path[tx].bwg_id) {
#line 79
    dst->path[tx].bwg_id = src->path[tx].bwg_id;
#line 80
    changes = changes | 8;
  } else {

  }
#line 83
  if ((int )dst->path[tx].bwg_percent != (int )src->path[tx].bwg_percent) {
#line 84
    dst->path[tx].bwg_percent = src->path[tx].bwg_percent;
#line 85
    changes = changes | 8;
  } else {

  }
#line 88
  if ((int )dst->path[tx].up_to_tc_bitmap != (int )src->path[tx].up_to_tc_bitmap) {
#line 90
    dst->path[tx].up_to_tc_bitmap = src->path[tx].up_to_tc_bitmap;
#line 92
    changes = changes | 26;
  } else {

  }
#line 95
  if ((unsigned int )dst->path[rx].prio_type != (unsigned int )src->path[rx].prio_type) {
#line 96
    dst->path[rx].prio_type = src->path[rx].prio_type;
#line 97
    changes = changes | 4;
  } else {

  }
#line 100
  if ((int )dst->path[rx].bwg_id != (int )src->path[rx].bwg_id) {
#line 101
    dst->path[rx].bwg_id = src->path[rx].bwg_id;
#line 102
    changes = changes | 4;
  } else {

  }
#line 105
  if ((int )dst->path[rx].bwg_percent != (int )src->path[rx].bwg_percent) {
#line 106
    dst->path[rx].bwg_percent = src->path[rx].bwg_percent;
#line 107
    changes = changes | 4;
  } else {

  }
#line 110
  if ((int )dst->path[rx].up_to_tc_bitmap != (int )src->path[rx].up_to_tc_bitmap) {
#line 112
    dst->path[rx].up_to_tc_bitmap = src->path[rx].up_to_tc_bitmap;
#line 114
    changes = changes | 22;
  } else {

  }
#line 69
  i = i + 1;
  ldv_54429: ;
#line 69
  if (tc_max + 1 > i) {
#line 71
    goto ldv_54428;
  } else {

  }
#line 118
  i = 11;
#line 118
  goto ldv_54432;
  ldv_54431: 
#line 119
  j = i + -11;
#line 120
  if ((int )dcfg->bw_percentage[tx][j] != (int )scfg->bw_percentage[tx][j]) {
#line 121
    dcfg->bw_percentage[tx][j] = scfg->bw_percentage[tx][j];
#line 122
    changes = changes | 8;
  } else {

  }
#line 124
  if ((int )dcfg->bw_percentage[rx][j] != (int )scfg->bw_percentage[rx][j]) {
#line 125
    dcfg->bw_percentage[rx][j] = scfg->bw_percentage[rx][j];
#line 126
    changes = changes | 4;
  } else {

  }
#line 118
  i = i + 1;
  ldv_54432: ;
#line 118
  if (i <= 18) {
#line 120
    goto ldv_54431;
  } else {

  }
#line 130
  i = 1;
#line 130
  goto ldv_54435;
  ldv_54434: 
#line 131
  j = i + -1;
#line 132
  if ((unsigned int )dcfg->tc_config[j].dcb_pfc != (unsigned int )scfg->tc_config[j].dcb_pfc) {
#line 133
    dcfg->tc_config[j].dcb_pfc = scfg->tc_config[j].dcb_pfc;
#line 134
    changes = changes | 2;
  } else {

  }
#line 130
  i = i + 1;
  ldv_54435: ;
#line 130
  if (i <= 8) {
#line 132
    goto ldv_54434;
  } else {

  }

#line 138
  if ((int )dcfg->pfc_mode_enable != (int )scfg->pfc_mode_enable) {
#line 139
    dcfg->pfc_mode_enable = scfg->pfc_mode_enable;
#line 140
    changes = changes | 2;
  } else {

  }
#line 143
  return (changes);
}
}
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_get_state(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 148
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 148
  adapter = (struct ixgbe_adapter *)tmp;
#line 150
  return ((adapter->flags & 4096U) != 0U);
}
}
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_set_state(struct net_device *netdev , u8 state ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;

  {
#line 155
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 155
  adapter = (struct ixgbe_adapter *)tmp;
#line 158
  if (((int )adapter->dcbx_cap & 4) == 0) {
#line 159
    return (1U);
  } else {

  }
#line 162
  if (((unsigned int )state != 0U) ^ ((adapter->flags & 4096U) == 0U)) {
#line 163
    return (0U);
  } else {

  }
#line 165
  tmp___0 = ixgbe_setup_tc(netdev, (unsigned int )state != 0U ? (int )adapter->dcb_cfg.num_tcs.pg_tcs : 0);
#line 165
  return (tmp___0 != 0);
}
}
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_perm_hw_addr(struct net_device *netdev , u8 *perm_addr ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int i ;
  int j ;

  {
#line 172
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 172
  adapter = (struct ixgbe_adapter *)tmp;
#line 175
  memset((void *)perm_addr, 255, 32UL);
#line 177
  i = 0;
#line 177
  goto ldv_54454;
  ldv_54453: 
#line 178
  *(perm_addr + (unsigned long )i) = adapter->hw.mac.perm_addr[i];
#line 177
  i = i + 1;
  ldv_54454: ;
#line 177
  if ((int )netdev->addr_len > i) {
#line 179
    goto ldv_54453;
  } else {

  }

#line 180
  switch ((unsigned int )adapter->hw.mac.type) {
  case 2U: ;
  case 3U: ;
  case 4U: 
#line 184
  j = 0;
#line 184
  goto ldv_54460;
  ldv_54459: 
#line 185
  *(perm_addr + (unsigned long )i) = adapter->hw.mac.san_addr[j];
#line 184
  j = j + 1;
#line 184
  i = i + 1;
  ldv_54460: ;
#line 184
  if ((int )netdev->addr_len > j) {
#line 186
    goto ldv_54459;
  } else {

  }

#line 186
  goto ldv_54462;
  default: ;
#line 188
  goto ldv_54462;
  }
  ldv_54462: ;
#line 191
  return;
}
}
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pg_tc_cfg_tx(struct net_device *netdev , int tc , u8 prio ,
                                         u8 bwg_id , u8 bw_pct , u8 up_map ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 196
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 196
  adapter = (struct ixgbe_adapter *)tmp;
#line 198
  if ((unsigned int )prio != 255U) {
#line 199
    adapter->temp_dcb_cfg.tc_config[tc].path[0].prio_type = (enum strict_prio_type )prio;
  } else {

  }
#line 200
  if ((unsigned int )bwg_id != 255U) {
#line 201
    adapter->temp_dcb_cfg.tc_config[tc].path[0].bwg_id = bwg_id;
  } else {

  }
#line 202
  if ((unsigned int )bw_pct != 255U) {
#line 203
    adapter->temp_dcb_cfg.tc_config[tc].path[0].bwg_percent = bw_pct;
  } else {

  }
#line 205
  if ((unsigned int )up_map != 255U) {
#line 206
    adapter->temp_dcb_cfg.tc_config[tc].path[0].up_to_tc_bitmap = up_map;
  } else {

  }
#line 207
  return;
}
}
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pg_bwg_cfg_tx(struct net_device *netdev , int bwg_id ,
                                          u8 bw_pct ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 213
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 213
  adapter = (struct ixgbe_adapter *)tmp;
#line 215
  adapter->temp_dcb_cfg.bw_percentage[0][bwg_id] = bw_pct;
#line 216
  return;
}
}
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pg_tc_cfg_rx(struct net_device *netdev , int tc , u8 prio ,
                                         u8 bwg_id , u8 bw_pct , u8 up_map ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 222
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 222
  adapter = (struct ixgbe_adapter *)tmp;
#line 224
  if ((unsigned int )prio != 255U) {
#line 225
    adapter->temp_dcb_cfg.tc_config[tc].path[1].prio_type = (enum strict_prio_type )prio;
  } else {

  }
#line 226
  if ((unsigned int )bwg_id != 255U) {
#line 227
    adapter->temp_dcb_cfg.tc_config[tc].path[1].bwg_id = bwg_id;
  } else {

  }
#line 228
  if ((unsigned int )bw_pct != 255U) {
#line 229
    adapter->temp_dcb_cfg.tc_config[tc].path[1].bwg_percent = bw_pct;
  } else {

  }
#line 231
  if ((unsigned int )up_map != 255U) {
#line 232
    adapter->temp_dcb_cfg.tc_config[tc].path[1].up_to_tc_bitmap = up_map;
  } else {

  }
#line 233
  return;
}
}
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pg_bwg_cfg_rx(struct net_device *netdev , int bwg_id ,
                                          u8 bw_pct ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 239
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 239
  adapter = (struct ixgbe_adapter *)tmp;
#line 241
  adapter->temp_dcb_cfg.bw_percentage[1][bwg_id] = bw_pct;
#line 242
  return;
}
}
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pg_tc_cfg_tx(struct net_device *netdev , int tc , u8 *prio ,
                                         u8 *bwg_id , u8 *bw_pct , u8 *up_map ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 248
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 248
  adapter = (struct ixgbe_adapter *)tmp;
#line 250
  *prio = (u8 )adapter->dcb_cfg.tc_config[tc].path[0].prio_type;
#line 251
  *bwg_id = adapter->dcb_cfg.tc_config[tc].path[0].bwg_id;
#line 252
  *bw_pct = adapter->dcb_cfg.tc_config[tc].path[0].bwg_percent;
#line 253
  *up_map = adapter->dcb_cfg.tc_config[tc].path[0].up_to_tc_bitmap;
#line 254
  return;
}
}
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pg_bwg_cfg_tx(struct net_device *netdev , int bwg_id ,
                                          u8 *bw_pct ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 259
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 259
  adapter = (struct ixgbe_adapter *)tmp;
#line 261
  *bw_pct = adapter->dcb_cfg.bw_percentage[0][bwg_id];
#line 262
  return;
}
}
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pg_tc_cfg_rx(struct net_device *netdev , int tc , u8 *prio ,
                                         u8 *bwg_id , u8 *bw_pct , u8 *up_map ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 268
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 268
  adapter = (struct ixgbe_adapter *)tmp;
#line 270
  *prio = (u8 )adapter->dcb_cfg.tc_config[tc].path[1].prio_type;
#line 271
  *bwg_id = adapter->dcb_cfg.tc_config[tc].path[1].bwg_id;
#line 272
  *bw_pct = adapter->dcb_cfg.tc_config[tc].path[1].bwg_percent;
#line 273
  *up_map = adapter->dcb_cfg.tc_config[tc].path[1].up_to_tc_bitmap;
#line 274
  return;
}
}
#line 276 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pg_bwg_cfg_rx(struct net_device *netdev , int bwg_id ,
                                          u8 *bw_pct ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 279
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 279
  adapter = (struct ixgbe_adapter *)tmp;
#line 281
  *bw_pct = adapter->dcb_cfg.bw_percentage[1][bwg_id];
#line 282
  return;
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pfc_cfg(struct net_device *netdev , int priority , u8 setting ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 287
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 287
  adapter = (struct ixgbe_adapter *)tmp;
#line 289
  adapter->temp_dcb_cfg.tc_config[priority].dcb_pfc = (enum dcb_pfc_type )setting;
#line 290
  if ((unsigned int )adapter->temp_dcb_cfg.tc_config[priority].dcb_pfc != (unsigned int )adapter->dcb_cfg.tc_config[priority].dcb_pfc) {
#line 292
    adapter->temp_dcb_cfg.pfc_mode_enable = 1;
  } else {

  }
#line 293
  return;
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pfc_cfg(struct net_device *netdev , int priority , u8 *setting ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 298
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 298
  adapter = (struct ixgbe_adapter *)tmp;
#line 300
  *setting = (u8 )adapter->dcb_cfg.tc_config[priority].dcb_pfc;
#line 301
  return;
}
}
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_devreset(struct net_device *dev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
#line 305
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 305
  adapter = (struct ixgbe_adapter *)tmp;
#line 307
  goto ldv_54541;
  ldv_54540: 
#line 308
  usleep_range(1000UL, 2000UL);
  ldv_54541: 
#line 307
  tmp___0 = test_and_set_bit(1L, (unsigned long volatile   *)(& adapter->state));
#line 307
  if (tmp___0 != 0) {
#line 309
    goto ldv_54540;
  } else {

  }
#line 310
  tmp___1 = netif_running((struct net_device  const  *)dev);
#line 310
  if ((int )tmp___1) {
#line 311
    (*((dev->netdev_ops)->ndo_stop))(dev);
  } else {

  }
#line 313
  ixgbe_clear_interrupt_scheme(adapter);
#line 314
  ixgbe_init_interrupt_scheme(adapter);
#line 316
  tmp___2 = netif_running((struct net_device  const  *)dev);
#line 316
  if ((int )tmp___2) {
#line 317
    (*((dev->netdev_ops)->ndo_open))(dev);
  } else {

  }
#line 319
  clear_bit(1L, (unsigned long volatile   *)(& adapter->state));
#line 320
  return;
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_set_all(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_dcb_config *dcb_cfg ;
  struct ixgbe_hw *hw ;
  int ret ;
  int i ;
  int tmp___0 ;
  u16 refill[8U] ;
  u16 max[8U] ;
  u8 bwg_id[8U] ;
  u8 prio_type[8U] ;
  u8 prio_tc[8U] ;
  int max_frame ;
  int _max1 ;
  int _max2 ;
  u8 pfc_en ;
  u8 prio_tc___0[8U] ;
  struct dcb_app app ;
  u8 up___0 ;
  u8 tmp___1 ;
  int tmp___2 ;

  {
#line 324
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 324
  adapter = (struct ixgbe_adapter *)tmp;
#line 325
  dcb_cfg = & adapter->dcb_cfg;
#line 326
  hw = & adapter->hw;
#line 327
  ret = 1;
#line 331
  if (((int )adapter->dcbx_cap & 4) == 0) {
#line 332
    return (1U);
  } else {

  }
#line 334
  tmp___0 = ixgbe_copy_dcb_cfg(adapter, 8);
#line 334
  adapter->dcb_set_bitmap = (u8 )((int )((signed char )adapter->dcb_set_bitmap) | (int )((signed char )tmp___0));
#line 336
  if ((unsigned int )adapter->dcb_set_bitmap == 0U) {
#line 337
    return (1U);
  } else {

  }
#line 339
  if (((int )adapter->dcb_set_bitmap & 12) != 0) {
#line 344
    max_frame = (int )((adapter->netdev)->mtu + 18U);
#line 347
    if (((adapter->netdev)->features & 2147483648ULL) != 0ULL) {
#line 348
      _max1 = max_frame;
#line 348
      _max2 = 3072;
#line 348
      max_frame = _max1 > _max2 ? _max1 : _max2;
    } else {

    }
#line 351
    ixgbe_dcb_calculate_tc_credits(hw, dcb_cfg, max_frame, 0);
#line 353
    ixgbe_dcb_calculate_tc_credits(hw, dcb_cfg, max_frame, 1);
#line 356
    ixgbe_dcb_unpack_refill(dcb_cfg, 0, (u16 *)(& refill));
#line 357
    ixgbe_dcb_unpack_max(dcb_cfg, (u16 *)(& max));
#line 358
    ixgbe_dcb_unpack_bwgid(dcb_cfg, 0, (u8 *)(& bwg_id));
#line 359
    ixgbe_dcb_unpack_prio(dcb_cfg, 0, (u8 *)(& prio_type));
#line 360
    ixgbe_dcb_unpack_map(dcb_cfg, 0, (u8 *)(& prio_tc));
#line 362
    ixgbe_dcb_hw_ets_config(hw, (u16 *)(& refill), (u16 *)(& max), (u8 *)(& bwg_id),
                            (u8 *)(& prio_type), (u8 *)(& prio_tc));
#line 365
    i = 0;
#line 365
    goto ldv_54561;
    ldv_54560: 
#line 366
    netdev_set_prio_tc_map(netdev, (int )((u8 )i), (int )prio_tc[i]);
#line 365
    i = i + 1;
    ldv_54561: ;
#line 365
    if (i <= 7) {
#line 367
      goto ldv_54560;
    } else {

    }
#line 368
    ret = 0;
  } else {

  }
#line 371
  if (((int )adapter->dcb_set_bitmap & 2) != 0) {
#line 372
    if ((int )dcb_cfg->pfc_mode_enable) {
#line 376
      ixgbe_dcb_unpack_map(dcb_cfg, 0, (u8 *)(& prio_tc___0));
#line 377
      ixgbe_dcb_unpack_pfc(dcb_cfg, & pfc_en);
#line 378
      ixgbe_dcb_hw_pfc_config(hw, (int )pfc_en, (u8 *)(& prio_tc___0));
    } else {
#line 380
      (*(hw->mac.ops.fc_enable))(hw);
    }
#line 383
    ixgbe_set_rx_drop_en(adapter);
#line 385
    ret = 2;
  } else {

  }
#line 393
  if (((int )adapter->dcb_set_bitmap & 16) != 0) {
#line 394
    app.selector = 0U;
#line 394
    app.priority = (unsigned char)0;
#line 394
    app.protocol = 35078U;
#line 398
    tmp___1 = dcb_getapp(netdev, & app);
#line 398
    up___0 = tmp___1;
#line 400
    tmp___2 = ffs((int )up___0);
#line 400
    adapter->fcoe.up = (unsigned int )((u8 )tmp___2) + 255U;
#line 401
    ixgbe_dcbnl_devreset(netdev);
#line 402
    ret = 0;
  } else {

  }
#line 406
  adapter->dcb_set_bitmap = 0U;
#line 407
  return ((u8 )ret);
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_getcap(struct net_device *netdev , int capid , u8 *cap ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 412
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 412
  adapter = (struct ixgbe_adapter *)tmp;
#line 414
  switch (capid) {
  case 2: 
#line 416
  *cap = 1U;
#line 417
  goto ldv_54574;
  case 3: 
#line 419
  *cap = 1U;
#line 420
  goto ldv_54574;
  case 4: 
#line 422
  *cap = 0U;
#line 423
  goto ldv_54574;
  case 5: 
#line 425
  *cap = 128U;
#line 426
  goto ldv_54574;
  case 6: 
#line 428
  *cap = 128U;
#line 429
  goto ldv_54574;
  case 7: 
#line 431
  *cap = 1U;
#line 432
  goto ldv_54574;
  case 8: 
#line 434
  *cap = 0U;
#line 435
  goto ldv_54574;
  case 9: 
#line 437
  *cap = adapter->dcbx_cap;
#line 438
  goto ldv_54574;
  default: 
#line 440
  *cap = 0U;
#line 441
  goto ldv_54574;
  }
  ldv_54574: ;
#line 444
  return (0U);
}
}
#line 447 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_getnumtcs(struct net_device *netdev , int tcid , u8 *num ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 449
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 449
  adapter = (struct ixgbe_adapter *)tmp;
#line 451
  if ((adapter->flags & 4096U) != 0U) {
#line 452
    switch (tcid) {
    case 2: 
#line 454
    *num = adapter->dcb_cfg.num_tcs.pg_tcs;
#line 455
    goto ldv_54590;
    case 3: 
#line 457
    *num = adapter->dcb_cfg.num_tcs.pfc_tcs;
#line 458
    goto ldv_54590;
    default: ;
#line 460
    return (-22);
    }
    ldv_54590: ;
  } else {
#line 463
    return (-22);
  }
#line 466
  return (0);
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_setnumtcs(struct net_device *netdev , int tcid , u8 num ) 
{ 


  {
#line 471
  return (-22);
}
}
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_getpfcstate(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 476
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 476
  adapter = (struct ixgbe_adapter *)tmp;
#line 478
  return ((u8 )adapter->dcb_cfg.pfc_mode_enable);
}
}
#line 481 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_setpfcstate(struct net_device *netdev , u8 state ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 483
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 483
  adapter = (struct ixgbe_adapter *)tmp;
#line 485
  adapter->temp_dcb_cfg.pfc_mode_enable = (unsigned int )state != 0U;
#line 486
  return;
}
}
#line 498 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_getapp(struct net_device *netdev , u8 idtype , u16 id ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct dcb_app app ;
  u8 tmp___0 ;

  {
#line 500
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 500
  adapter = (struct ixgbe_adapter *)tmp;
#line 501
  app.selector = idtype;
#line 501
  app.priority = (unsigned char)0;
#line 501
  app.protocol = id;
#line 506
  if (((int )adapter->dcbx_cap & 4) == 0) {
#line 507
    return (-22);
  } else {

  }
#line 509
  tmp___0 = dcb_getapp(netdev, & app);
#line 509
  return ((int )tmp___0);
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_getets(struct net_device *dev , struct ieee_ets *ets ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ieee_ets *my_ets ;

  {
#line 515
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 515
  adapter = (struct ixgbe_adapter *)tmp;
#line 516
  my_ets = adapter->ixgbe_ieee_ets;
#line 518
  ets->ets_cap = adapter->dcb_cfg.num_tcs.pg_tcs;
#line 521
  if ((unsigned long )my_ets == (unsigned long )((struct ieee_ets *)0)) {
#line 522
    return (0);
  } else {

  }
#line 524
  ets->cbs = my_ets->cbs;
#line 525
  memcpy((void *)(& ets->tc_tx_bw), (void const   *)(& my_ets->tc_tx_bw), 8UL);
#line 526
  memcpy((void *)(& ets->tc_rx_bw), (void const   *)(& my_ets->tc_rx_bw), 8UL);
#line 527
  memcpy((void *)(& ets->tc_tsa), (void const   *)(& my_ets->tc_tsa), 8UL);
#line 528
  memcpy((void *)(& ets->prio_tc), (void const   *)(& my_ets->prio_tc), 8UL);
#line 529
  return (0);
}
}
#line 532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_setets(struct net_device *dev , struct ieee_ets *ets ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int max_frame ;
  int i ;
  int err ;
  __u8 max_tc ;
  __u8 map_chg ;
  void *tmp___0 ;
  int tmp___1 ;
  s32 tmp___2 ;

  {
#line 535
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 535
  adapter = (struct ixgbe_adapter *)tmp;
#line 536
  max_frame = (int )(dev->mtu + 18U);
#line 538
  max_tc = 0U;
#line 539
  map_chg = 0U;
#line 541
  if (((int )adapter->dcbx_cap & 8) == 0) {
#line 542
    return (-22);
  } else {

  }
#line 544
  if ((unsigned long )adapter->ixgbe_ieee_ets == (unsigned long )((struct ieee_ets *)0)) {
#line 545
    tmp___0 = kmalloc(59UL, 208U);
#line 545
    adapter->ixgbe_ieee_ets = (struct ieee_ets *)tmp___0;
#line 547
    if ((unsigned long )adapter->ixgbe_ieee_ets == (unsigned long )((struct ieee_ets *)0)) {
#line 548
      return (-12);
    } else {

    }
#line 551
    i = 0;
#line 551
    goto ldv_54631;
    ldv_54630: 
#line 552
    (adapter->ixgbe_ieee_ets)->prio_tc[i] = 8U;
#line 551
    i = i + 1;
    ldv_54631: ;
#line 551
    if (i <= 7) {
#line 553
      goto ldv_54630;
    } else {

    }
#line 555
    ixgbe_dcb_read_rtrup2tc(& adapter->hw, (u8 *)(& (adapter->ixgbe_ieee_ets)->prio_tc));
  } else {

  }
#line 559
  i = 0;
#line 559
  goto ldv_54634;
  ldv_54633: ;
#line 560
  if ((int )ets->prio_tc[i] > (int )max_tc) {
#line 561
    max_tc = ets->prio_tc[i];
  } else {

  }
#line 562
  if ((int )ets->prio_tc[i] != (int )(adapter->ixgbe_ieee_ets)->prio_tc[i]) {
#line 563
    map_chg = 1U;
  } else {

  }
#line 559
  i = i + 1;
  ldv_54634: ;
#line 559
  if (i <= 7) {
#line 561
    goto ldv_54633;
  } else {

  }
#line 566
  memcpy((void *)adapter->ixgbe_ieee_ets, (void const   *)ets, 59UL);
#line 568
  if ((unsigned int )max_tc != 0U) {
#line 569
    max_tc = (__u8 )((int )max_tc + 1);
  } else {

  }
#line 571
  if ((int )adapter->dcb_cfg.num_tcs.pg_tcs < (int )max_tc) {
#line 572
    return (-22);
  } else {

  }
#line 574
  tmp___1 = netdev_get_num_tc(dev);
#line 574
  if ((int )max_tc != tmp___1) {
#line 575
    err = ixgbe_setup_tc(dev, (int )max_tc);
#line 576
    if (err != 0) {
#line 577
      return (err);
    } else {

    }
  } else
#line 578
  if ((unsigned int )map_chg != 0U) {
#line 579
    ixgbe_dcbnl_devreset(dev);
  } else {

  }
#line 582
  tmp___2 = ixgbe_dcb_hw_ets(& adapter->hw, ets, max_frame);
#line 582
  return (tmp___2);
}
}
#line 585 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_getpfc(struct net_device *dev , struct ieee_pfc *pfc ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ieee_pfc *my_pfc ;
  int i ;

  {
#line 588
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 588
  adapter = (struct ixgbe_adapter *)tmp;
#line 589
  my_pfc = adapter->ixgbe_ieee_pfc;
#line 592
  pfc->pfc_cap = adapter->dcb_cfg.num_tcs.pfc_tcs;
#line 595
  if ((unsigned long )my_pfc == (unsigned long )((struct ieee_pfc *)0)) {
#line 596
    return (0);
  } else {

  }
#line 598
  pfc->pfc_en = my_pfc->pfc_en;
#line 599
  pfc->mbc = my_pfc->mbc;
#line 600
  pfc->delay = my_pfc->delay;
#line 602
  i = 0;
#line 602
  goto ldv_54644;
  ldv_54643: 
#line 603
  pfc->requests[i] = adapter->stats.pxoffrxc[i];
#line 604
  pfc->indications[i] = adapter->stats.pxofftxc[i];
#line 602
  i = i + 1;
  ldv_54644: ;
#line 602
  if (i <= 7) {
#line 604
    goto ldv_54643;
  } else {

  }

#line 607
  return (0);
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_setpfc(struct net_device *dev , struct ieee_pfc *pfc ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u8 *prio_tc ;
  int err ;
  void *tmp___0 ;

  {
#line 613
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 613
  adapter = (struct ixgbe_adapter *)tmp;
#line 614
  hw = & adapter->hw;
#line 618
  if (((int )adapter->dcbx_cap & 8) == 0) {
#line 619
    return (-22);
  } else {

  }
#line 621
  if ((unsigned long )adapter->ixgbe_ieee_pfc == (unsigned long )((struct ieee_pfc *)0)) {
#line 622
    tmp___0 = kmalloc(136UL, 208U);
#line 622
    adapter->ixgbe_ieee_pfc = (struct ieee_pfc *)tmp___0;
#line 624
    if ((unsigned long )adapter->ixgbe_ieee_pfc == (unsigned long )((struct ieee_pfc *)0)) {
#line 625
      return (-12);
    } else {

    }
  } else {

  }
#line 628
  prio_tc = (u8 *)(& (adapter->ixgbe_ieee_ets)->prio_tc);
#line 629
  memcpy((void *)adapter->ixgbe_ieee_pfc, (void const   *)pfc, 136UL);
#line 632
  if ((unsigned int )pfc->pfc_en != 0U) {
#line 633
    err = ixgbe_dcb_hw_pfc_config(hw, (int )pfc->pfc_en, prio_tc);
  } else {
#line 635
    err = (*(hw->mac.ops.fc_enable))(hw);
  }
#line 637
  ixgbe_set_rx_drop_en(adapter);
#line 639
  return (err);
}
}
#line 642 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_setapp(struct net_device *dev , struct dcb_app *app ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int err ;
  u8 app_mask ;
  u8 tmp___0 ;
  int vf ;
  struct vf_data_storage *vfinfo ;

  {
#line 645
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 645
  adapter = (struct ixgbe_adapter *)tmp;
#line 648
  if (((int )adapter->dcbx_cap & 8) == 0) {
#line 649
    return (-22);
  } else {

  }
#line 651
  err = dcb_ieee_setapp(dev, app);
#line 652
  if (err != 0) {
#line 653
    return (err);
  } else {

  }
#line 656
  if ((unsigned int )app->selector == 1U && (unsigned int )app->protocol == 35078U) {
#line 658
    tmp___0 = dcb_ieee_getapp_mask(dev, app);
#line 658
    app_mask = tmp___0;
#line 660
    if (((int )app_mask >> (int )adapter->fcoe.up) & 1) {
#line 661
      return (0);
    } else {

    }
#line 663
    adapter->fcoe.up = app->priority;
#line 664
    ixgbe_dcbnl_devreset(dev);
  } else {

  }
#line 669
  if ((unsigned int )app->selector == 1U && (unsigned int )app->protocol == 0U) {
#line 673
    adapter->default_up = app->priority;
#line 675
    vf = 0;
#line 675
    goto ldv_54664;
    ldv_54663: 
#line 676
    vfinfo = adapter->vfinfo + (unsigned long )vf;
#line 678
    if ((unsigned int )vfinfo->pf_qos == 0U) {
#line 679
      ixgbe_set_vmvir(adapter, (int )vfinfo->pf_vlan, (int )app->priority, (u32 )vf);
    } else {

    }
#line 675
    vf = vf + 1;
    ldv_54664: ;
#line 675
    if ((unsigned int )vf < adapter->num_vfs) {
#line 677
      goto ldv_54663;
    } else {

    }

  } else {

  }
#line 684
  return (0);
}
}
#line 687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_delapp(struct net_device *dev , struct dcb_app *app ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int err ;
  u8 app_mask ;
  u8 tmp___0 ;
  int tmp___1 ;
  int vf ;
  unsigned long app_mask___0 ;
  u8 tmp___2 ;
  int qos ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  struct vf_data_storage *vfinfo ;

  {
#line 690
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 690
  adapter = (struct ixgbe_adapter *)tmp;
#line 693
  if (((int )adapter->dcbx_cap & 8) == 0) {
#line 694
    return (-22);
  } else {

  }
#line 696
  err = dcb_ieee_delapp(dev, app);
#line 699
  if ((err == 0 && (unsigned int )app->selector == 1U) && (unsigned int )app->protocol == 35078U) {
#line 701
    tmp___0 = dcb_ieee_getapp_mask(dev, app);
#line 701
    app_mask = tmp___0;
#line 703
    if (((int )app_mask >> (int )adapter->fcoe.up) & 1) {
#line 704
      return (0);
    } else {

    }
#line 706
    if ((unsigned int )app_mask != 0U) {
#line 706
      tmp___1 = ffs((int )app_mask);
#line 706
      adapter->fcoe.up = (unsigned int )((u8 )tmp___1) + 255U;
    } else {
#line 706
      adapter->fcoe.up = 3U;
    }
#line 708
    ixgbe_dcbnl_devreset(dev);
  } else {

  }
#line 712
  if (((unsigned int )app->selector == 1U && (unsigned int )app->protocol == 0U) && (int )adapter->default_up == (int )app->priority) {
#line 715
    tmp___2 = dcb_ieee_getapp_mask(dev, app);
#line 715
    app_mask___0 = (unsigned long )tmp___2;
#line 716
    if (app_mask___0 != 0UL) {
#line 716
      tmp___3 = find_first_bit((unsigned long const   *)(& app_mask___0), 8UL);
#line 716
      tmp___4 = (int )tmp___3;
    } else {
#line 716
      tmp___4 = 0;
    }
#line 716
    qos = tmp___4;
#line 718
    adapter->default_up = (u8 )qos;
#line 720
    vf = 0;
#line 720
    goto ldv_54678;
    ldv_54677: 
#line 721
    vfinfo = adapter->vfinfo + (unsigned long )vf;
#line 723
    if ((unsigned int )vfinfo->pf_qos == 0U) {
#line 724
      ixgbe_set_vmvir(adapter, (int )vfinfo->pf_vlan, (int )((u16 )qos), (u32 )vf);
    } else {

    }
#line 720
    vf = vf + 1;
    ldv_54678: ;
#line 720
    if ((unsigned int )vf < adapter->num_vfs) {
#line 722
      goto ldv_54677;
    } else {

    }

  } else {

  }
#line 729
  return (err);
}
}
#line 732 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_getdcbx(struct net_device *dev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
#line 734
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 734
  adapter = (struct ixgbe_adapter *)tmp;
#line 735
  return (adapter->dcbx_cap);
}
}
#line 738 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_setdcbx(struct net_device *dev , u8 mode ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ieee_ets ets ;
  struct ieee_pfc pfc ;
  int err ;
  u8 mask ;

  {
#line 740
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 740
  adapter = (struct ixgbe_adapter *)tmp;
#line 741
  ets.willing = 0U;
#line 741
  ets.ets_cap = (unsigned char)0;
#line 741
  ets.cbs = (unsigned char)0;
#line 741
  ets.tc_tx_bw[0] = (unsigned char)0;
#line 741
  ets.tc_tx_bw[1] = (unsigned char)0;
#line 741
  ets.tc_tx_bw[2] = (unsigned char)0;
#line 741
  ets.tc_tx_bw[3] = (unsigned char)0;
#line 741
  ets.tc_tx_bw[4] = (unsigned char)0;
#line 741
  ets.tc_tx_bw[5] = (unsigned char)0;
#line 741
  ets.tc_tx_bw[6] = (unsigned char)0;
#line 741
  ets.tc_tx_bw[7] = (unsigned char)0;
#line 741
  ets.tc_rx_bw[0] = (unsigned char)0;
#line 741
  ets.tc_rx_bw[1] = (unsigned char)0;
#line 741
  ets.tc_rx_bw[2] = (unsigned char)0;
#line 741
  ets.tc_rx_bw[3] = (unsigned char)0;
#line 741
  ets.tc_rx_bw[4] = (unsigned char)0;
#line 741
  ets.tc_rx_bw[5] = (unsigned char)0;
#line 741
  ets.tc_rx_bw[6] = (unsigned char)0;
#line 741
  ets.tc_rx_bw[7] = (unsigned char)0;
#line 741
  ets.tc_tsa[0] = (unsigned char)0;
#line 741
  ets.tc_tsa[1] = (unsigned char)0;
#line 741
  ets.tc_tsa[2] = (unsigned char)0;
#line 741
  ets.tc_tsa[3] = (unsigned char)0;
#line 741
  ets.tc_tsa[4] = (unsigned char)0;
#line 741
  ets.tc_tsa[5] = (unsigned char)0;
#line 741
  ets.tc_tsa[6] = (unsigned char)0;
#line 741
  ets.tc_tsa[7] = (unsigned char)0;
#line 741
  ets.prio_tc[0] = (unsigned char)0;
#line 741
  ets.prio_tc[1] = (unsigned char)0;
#line 741
  ets.prio_tc[2] = (unsigned char)0;
#line 741
  ets.prio_tc[3] = (unsigned char)0;
#line 741
  ets.prio_tc[4] = (unsigned char)0;
#line 741
  ets.prio_tc[5] = (unsigned char)0;
#line 741
  ets.prio_tc[6] = (unsigned char)0;
#line 741
  ets.prio_tc[7] = (unsigned char)0;
#line 741
  ets.tc_reco_bw[0] = (unsigned char)0;
#line 741
  ets.tc_reco_bw[1] = (unsigned char)0;
#line 741
  ets.tc_reco_bw[2] = (unsigned char)0;
#line 741
  ets.tc_reco_bw[3] = (unsigned char)0;
#line 741
  ets.tc_reco_bw[4] = (unsigned char)0;
#line 741
  ets.tc_reco_bw[5] = (unsigned char)0;
#line 741
  ets.tc_reco_bw[6] = (unsigned char)0;
#line 741
  ets.tc_reco_bw[7] = (unsigned char)0;
#line 741
  ets.tc_reco_tsa[0] = (unsigned char)0;
#line 741
  ets.tc_reco_tsa[1] = (unsigned char)0;
#line 741
  ets.tc_reco_tsa[2] = (unsigned char)0;
#line 741
  ets.tc_reco_tsa[3] = (unsigned char)0;
#line 741
  ets.tc_reco_tsa[4] = (unsigned char)0;
#line 741
  ets.tc_reco_tsa[5] = (unsigned char)0;
#line 741
  ets.tc_reco_tsa[6] = (unsigned char)0;
#line 741
  ets.tc_reco_tsa[7] = (unsigned char)0;
#line 741
  ets.reco_prio_tc[0] = (unsigned char)0;
#line 741
  ets.reco_prio_tc[1] = (unsigned char)0;
#line 741
  ets.reco_prio_tc[2] = (unsigned char)0;
#line 741
  ets.reco_prio_tc[3] = (unsigned char)0;
#line 741
  ets.reco_prio_tc[4] = (unsigned char)0;
#line 741
  ets.reco_prio_tc[5] = (unsigned char)0;
#line 741
  ets.reco_prio_tc[6] = (unsigned char)0;
#line 741
  ets.reco_prio_tc[7] = (unsigned char)0;
#line 742
  pfc.pfc_cap = 0U;
#line 742
  pfc.pfc_en = (unsigned char)0;
#line 742
  pfc.mbc = (unsigned char)0;
#line 742
  pfc.delay = (unsigned short)0;
#line 742
  pfc.requests[0] = 0ULL;
#line 742
  pfc.requests[1] = 0ULL;
#line 742
  pfc.requests[2] = 0ULL;
#line 742
  pfc.requests[3] = 0ULL;
#line 742
  pfc.requests[4] = 0ULL;
#line 742
  pfc.requests[5] = 0ULL;
#line 742
  pfc.requests[6] = 0ULL;
#line 742
  pfc.requests[7] = 0ULL;
#line 742
  pfc.indications[0] = 0ULL;
#line 742
  pfc.indications[1] = 0ULL;
#line 742
  pfc.indications[2] = 0ULL;
#line 742
  pfc.indications[3] = 0ULL;
#line 742
  pfc.indications[4] = 0ULL;
#line 742
  pfc.indications[5] = 0ULL;
#line 742
  pfc.indications[6] = 0ULL;
#line 742
  pfc.indications[7] = 0ULL;
#line 743
  err = 0;
#line 746
  if ((((int )mode & 2) != 0 || (((int )mode & 8) != 0 && ((int )mode & 4) != 0)) || ((int )mode & 1) == 0) {
#line 749
    return (1U);
  } else {

  }
#line 751
  if ((int )adapter->dcbx_cap == (int )mode) {
#line 752
    return (0U);
  } else {

  }
#line 754
  adapter->dcbx_cap = mode;
#line 757
  ets.ets_cap = 8U;
#line 758
  pfc.pfc_cap = 8U;
#line 760
  if (((int )mode & 8) != 0) {
#line 761
    ixgbe_dcbnl_ieee_setets(dev, & ets);
#line 762
    ixgbe_dcbnl_ieee_setpfc(dev, & pfc);
  } else
#line 763
  if (((int )mode & 4) != 0) {
#line 764
    mask = 30U;
#line 766
    adapter->dcb_set_bitmap = (u8 )((int )adapter->dcb_set_bitmap | (int )mask);
#line 767
    ixgbe_dcbnl_set_all(dev);
  } else {
#line 772
    ixgbe_dcbnl_ieee_setets(dev, & ets);
#line 773
    ixgbe_dcbnl_ieee_setpfc(dev, & pfc);
#line 774
    err = ixgbe_setup_tc(dev, 0);
  }
#line 777
  return (err != 0);
}
}
#line 780 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
struct dcbnl_rtnl_ops  const  dcbnl_ops  = 
#line 780
     {& ixgbe_dcbnl_ieee_getets, & ixgbe_dcbnl_ieee_setets, 0, 0, 0, 0, 0, & ixgbe_dcbnl_ieee_getpfc,
    & ixgbe_dcbnl_ieee_setpfc, 0, & ixgbe_dcbnl_ieee_setapp, & ixgbe_dcbnl_ieee_delapp,
    0, 0, & ixgbe_dcbnl_get_state, & ixgbe_dcbnl_set_state, & ixgbe_dcbnl_get_perm_hw_addr,
    & ixgbe_dcbnl_set_pg_tc_cfg_tx, & ixgbe_dcbnl_set_pg_bwg_cfg_tx, & ixgbe_dcbnl_set_pg_tc_cfg_rx,
    & ixgbe_dcbnl_set_pg_bwg_cfg_rx, & ixgbe_dcbnl_get_pg_tc_cfg_tx, & ixgbe_dcbnl_get_pg_bwg_cfg_tx,
    & ixgbe_dcbnl_get_pg_tc_cfg_rx, & ixgbe_dcbnl_get_pg_bwg_cfg_rx, & ixgbe_dcbnl_set_pfc_cfg,
    & ixgbe_dcbnl_get_pfc_cfg, & ixgbe_dcbnl_set_all, & ixgbe_dcbnl_getcap, & ixgbe_dcbnl_getnumtcs,
    & ixgbe_dcbnl_setnumtcs, & ixgbe_dcbnl_getpfcstate, & ixgbe_dcbnl_setpfcstate,
    0, 0, 0, 0, 0, & ixgbe_dcbnl_getapp, 0, 0, & ixgbe_dcbnl_getdcbx, & ixgbe_dcbnl_setdcbx,
    0, 0, 0, 0};
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
void ldv_initialize_dcbnl_rtnl_ops_13(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 333
  tmp = ldv_init_zalloc(3008UL);
#line 333
  dcbnl_ops_group0 = (struct net_device *)tmp;
#line 334
  tmp___0 = ldv_init_zalloc(4UL);
#line 334
  dcbnl_ops_group1 = (struct dcb_app *)tmp___0;
#line 335
  tmp___1 = ldv_init_zalloc(136UL);
#line 335
  dcbnl_ops_group2 = (struct ieee_pfc *)tmp___1;
#line 336
  tmp___2 = ldv_init_zalloc(59UL);
#line 336
  dcbnl_ops_group3 = (struct ieee_ets *)tmp___2;
#line 337
  return;
}
}
#line 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
void ldv_main_exported_13(void) 
{ 
  u8 *ldvarg356 ;
  void *tmp ;
  u8 *ldvarg355 ;
  void *tmp___0 ;
  u8 ldvarg366 ;
  int ldvarg371 ;
  int ldvarg385 ;
  u8 ldvarg388 ;
  int ldvarg373 ;
  u8 ldvarg353 ;
  int ldvarg368 ;
  int ldvarg391 ;
  u8 *ldvarg359 ;
  void *tmp___1 ;
  u8 *ldvarg382 ;
  void *tmp___2 ;
  u8 *ldvarg378 ;
  void *tmp___3 ;
  u8 ldvarg367 ;
  u8 *ldvarg384 ;
  void *tmp___4 ;
  int ldvarg358 ;
  int ldvarg375 ;
  int ldvarg354 ;
  u8 ldvarg361 ;
  u8 *ldvarg370 ;
  void *tmp___5 ;
  u8 ldvarg374 ;
  u8 *ldvarg386 ;
  void *tmp___6 ;
  u8 *ldvarg387 ;
  void *tmp___7 ;
  int ldvarg377 ;
  u8 *ldvarg376 ;
  void *tmp___8 ;
  int ldvarg364 ;
  u8 ldvarg360 ;
  u8 ldvarg365 ;
  u8 ldvarg392 ;
  int ldvarg379 ;
  u8 ldvarg362 ;
  u8 *ldvarg383 ;
  void *tmp___9 ;
  u8 ldvarg369 ;
  u8 *ldvarg363 ;
  void *tmp___10 ;
  u8 ldvarg380 ;
  u8 ldvarg393 ;
  int ldvarg381 ;
  u8 *ldvarg357 ;
  void *tmp___11 ;
  u16 ldvarg395 ;
  u8 ldvarg389 ;
  u8 ldvarg390 ;
  int ldvarg394 ;
  u8 ldvarg396 ;
  u8 *ldvarg372 ;
  void *tmp___12 ;
  int tmp___13 ;

  {
#line 340
  tmp = ldv_init_zalloc(1UL);
#line 340
  ldvarg356 = (u8 *)tmp;
#line 341
  tmp___0 = ldv_init_zalloc(1UL);
#line 341
  ldvarg355 = (u8 *)tmp___0;
#line 350
  tmp___1 = ldv_init_zalloc(1UL);
#line 350
  ldvarg359 = (u8 *)tmp___1;
#line 351
  tmp___2 = ldv_init_zalloc(1UL);
#line 351
  ldvarg382 = (u8 *)tmp___2;
#line 352
  tmp___3 = ldv_init_zalloc(1UL);
#line 352
  ldvarg378 = (u8 *)tmp___3;
#line 354
  tmp___4 = ldv_init_zalloc(1UL);
#line 354
  ldvarg384 = (u8 *)tmp___4;
#line 359
  tmp___5 = ldv_init_zalloc(1UL);
#line 359
  ldvarg370 = (u8 *)tmp___5;
#line 361
  tmp___6 = ldv_init_zalloc(1UL);
#line 361
  ldvarg386 = (u8 *)tmp___6;
#line 362
  tmp___7 = ldv_init_zalloc(1UL);
#line 362
  ldvarg387 = (u8 *)tmp___7;
#line 364
  tmp___8 = ldv_init_zalloc(1UL);
#line 364
  ldvarg376 = (u8 *)tmp___8;
#line 371
  tmp___9 = ldv_init_zalloc(1UL);
#line 371
  ldvarg383 = (u8 *)tmp___9;
#line 373
  tmp___10 = ldv_init_zalloc(1UL);
#line 373
  ldvarg363 = (u8 *)tmp___10;
#line 377
  tmp___11 = ldv_init_zalloc(1UL);
#line 377
  ldvarg357 = (u8 *)tmp___11;
#line 383
  tmp___12 = ldv_init_zalloc(1UL);
#line 383
  ldvarg372 = (u8 *)tmp___12;
#line 342
  ldv_memset((void *)(& ldvarg366), 0, 1UL);
#line 343
  ldv_memset((void *)(& ldvarg371), 0, 4UL);
#line 344
  ldv_memset((void *)(& ldvarg385), 0, 4UL);
#line 345
  ldv_memset((void *)(& ldvarg388), 0, 1UL);
#line 346
  ldv_memset((void *)(& ldvarg373), 0, 4UL);
#line 347
  ldv_memset((void *)(& ldvarg353), 0, 1UL);
#line 348
  ldv_memset((void *)(& ldvarg368), 0, 4UL);
#line 349
  ldv_memset((void *)(& ldvarg391), 0, 4UL);
#line 353
  ldv_memset((void *)(& ldvarg367), 0, 1UL);
#line 355
  ldv_memset((void *)(& ldvarg358), 0, 4UL);
#line 356
  ldv_memset((void *)(& ldvarg375), 0, 4UL);
#line 357
  ldv_memset((void *)(& ldvarg354), 0, 4UL);
#line 358
  ldv_memset((void *)(& ldvarg361), 0, 1UL);
#line 360
  ldv_memset((void *)(& ldvarg374), 0, 1UL);
#line 363
  ldv_memset((void *)(& ldvarg377), 0, 4UL);
#line 365
  ldv_memset((void *)(& ldvarg364), 0, 4UL);
#line 366
  ldv_memset((void *)(& ldvarg360), 0, 1UL);
#line 367
  ldv_memset((void *)(& ldvarg365), 0, 1UL);
#line 368
  ldv_memset((void *)(& ldvarg392), 0, 1UL);
#line 369
  ldv_memset((void *)(& ldvarg379), 0, 4UL);
#line 370
  ldv_memset((void *)(& ldvarg362), 0, 1UL);
#line 372
  ldv_memset((void *)(& ldvarg369), 0, 1UL);
#line 374
  ldv_memset((void *)(& ldvarg380), 0, 1UL);
#line 375
  ldv_memset((void *)(& ldvarg393), 0, 1UL);
#line 376
  ldv_memset((void *)(& ldvarg381), 0, 4UL);
#line 378
  ldv_memset((void *)(& ldvarg395), 0, 2UL);
#line 379
  ldv_memset((void *)(& ldvarg389), 0, 1UL);
#line 380
  ldv_memset((void *)(& ldvarg390), 0, 1UL);
#line 381
  ldv_memset((void *)(& ldvarg394), 0, 4UL);
#line 382
  ldv_memset((void *)(& ldvarg396), 0, 1UL);
#line 385
  tmp___13 = __VERIFIER_nondet_int();
#line 385
  switch (tmp___13) {
  case 0: ;
#line 388
  if (ldv_state_variable_13 == 1) {
#line 390
    ixgbe_dcbnl_getapp(dcbnl_ops_group0, (int )ldvarg396, (int )ldvarg395);
#line 392
    ldv_state_variable_13 = 1;
  } else {

  }
#line 395
  goto ldv_54745;
  case 1: ;
#line 398
  if (ldv_state_variable_13 == 1) {
#line 400
    ixgbe_dcbnl_ieee_getets(dcbnl_ops_group0, dcbnl_ops_group3);
#line 402
    ldv_state_variable_13 = 1;
  } else {

  }
#line 405
  goto ldv_54745;
  case 2: ;
#line 408
  if (ldv_state_variable_13 == 1) {
#line 410
    ixgbe_dcbnl_ieee_setets(dcbnl_ops_group0, dcbnl_ops_group3);
#line 412
    ldv_state_variable_13 = 1;
  } else {

  }
#line 415
  goto ldv_54745;
  case 3: ;
#line 418
  if (ldv_state_variable_13 == 1) {
#line 420
    ixgbe_dcbnl_set_pfc_cfg(dcbnl_ops_group0, ldvarg394, (int )ldvarg393);
#line 422
    ldv_state_variable_13 = 1;
  } else {

  }
#line 425
  goto ldv_54745;
  case 4: ;
#line 428
  if (ldv_state_variable_13 == 1) {
#line 430
    ixgbe_dcbnl_set_pg_tc_cfg_rx(dcbnl_ops_group0, ldvarg391, (int )ldvarg390, (int )ldvarg389,
                                 (int )ldvarg392, (int )ldvarg388);
#line 432
    ldv_state_variable_13 = 1;
  } else {

  }
#line 435
  goto ldv_54745;
  case 5: ;
#line 438
  if (ldv_state_variable_13 == 1) {
#line 440
    ixgbe_dcbnl_get_perm_hw_addr(dcbnl_ops_group0, ldvarg387);
#line 442
    ldv_state_variable_13 = 1;
  } else {

  }
#line 445
  goto ldv_54745;
  case 6: ;
#line 448
  if (ldv_state_variable_13 == 1) {
#line 450
    ixgbe_dcbnl_get_pg_tc_cfg_tx(dcbnl_ops_group0, ldvarg385, ldvarg384, ldvarg383,
                                 ldvarg386, ldvarg382);
#line 452
    ldv_state_variable_13 = 1;
  } else {

  }
#line 455
  goto ldv_54745;
  case 7: ;
#line 458
  if (ldv_state_variable_13 == 1) {
#line 460
    ixgbe_dcbnl_set_pg_bwg_cfg_tx(dcbnl_ops_group0, ldvarg381, (int )ldvarg380);
#line 462
    ldv_state_variable_13 = 1;
  } else {

  }
#line 465
  goto ldv_54745;
  case 8: ;
#line 468
  if (ldv_state_variable_13 == 1) {
#line 470
    ixgbe_dcbnl_getpfcstate(dcbnl_ops_group0);
#line 472
    ldv_state_variable_13 = 1;
  } else {

  }
#line 475
  goto ldv_54745;
  case 9: ;
#line 478
  if (ldv_state_variable_13 == 1) {
#line 480
    ixgbe_dcbnl_get_pfc_cfg(dcbnl_ops_group0, ldvarg379, ldvarg378);
#line 482
    ldv_state_variable_13 = 1;
  } else {

  }
#line 485
  goto ldv_54745;
  case 10: ;
#line 488
  if (ldv_state_variable_13 == 1) {
#line 490
    ixgbe_dcbnl_get_pg_bwg_cfg_tx(dcbnl_ops_group0, ldvarg377, ldvarg376);
#line 492
    ldv_state_variable_13 = 1;
  } else {

  }
#line 495
  goto ldv_54745;
  case 11: ;
#line 498
  if (ldv_state_variable_13 == 1) {
#line 500
    ixgbe_dcbnl_getdcbx(dcbnl_ops_group0);
#line 502
    ldv_state_variable_13 = 1;
  } else {

  }
#line 505
  goto ldv_54745;
  case 12: ;
#line 508
  if (ldv_state_variable_13 == 1) {
#line 510
    ixgbe_dcbnl_setnumtcs(dcbnl_ops_group0, ldvarg375, (int )ldvarg374);
#line 512
    ldv_state_variable_13 = 1;
  } else {

  }
#line 515
  goto ldv_54745;
  case 13: ;
#line 518
  if (ldv_state_variable_13 == 1) {
#line 520
    ixgbe_dcbnl_get_pg_bwg_cfg_rx(dcbnl_ops_group0, ldvarg373, ldvarg372);
#line 522
    ldv_state_variable_13 = 1;
  } else {

  }
#line 525
  goto ldv_54745;
  case 14: ;
#line 528
  if (ldv_state_variable_13 == 1) {
#line 530
    ixgbe_dcbnl_ieee_delapp(dcbnl_ops_group0, dcbnl_ops_group1);
#line 532
    ldv_state_variable_13 = 1;
  } else {

  }
#line 535
  goto ldv_54745;
  case 15: ;
#line 538
  if (ldv_state_variable_13 == 1) {
#line 540
    ixgbe_dcbnl_getnumtcs(dcbnl_ops_group0, ldvarg371, ldvarg370);
#line 542
    ldv_state_variable_13 = 1;
  } else {

  }
#line 545
  goto ldv_54745;
  case 16: ;
#line 548
  if (ldv_state_variable_13 == 1) {
#line 550
    ixgbe_dcbnl_ieee_setapp(dcbnl_ops_group0, dcbnl_ops_group1);
#line 552
    ldv_state_variable_13 = 1;
  } else {

  }
#line 555
  goto ldv_54745;
  case 17: ;
#line 558
  if (ldv_state_variable_13 == 1) {
#line 560
    ixgbe_dcbnl_get_state(dcbnl_ops_group0);
#line 562
    ldv_state_variable_13 = 1;
  } else {

  }
#line 565
  goto ldv_54745;
  case 18: ;
#line 568
  if (ldv_state_variable_13 == 1) {
#line 570
    ixgbe_dcbnl_set_pg_tc_cfg_tx(dcbnl_ops_group0, ldvarg368, (int )ldvarg367, (int )ldvarg366,
                                 (int )ldvarg369, (int )ldvarg365);
#line 572
    ldv_state_variable_13 = 1;
  } else {

  }
#line 575
  goto ldv_54745;
  case 19: ;
#line 578
  if (ldv_state_variable_13 == 1) {
#line 580
    ixgbe_dcbnl_ieee_setpfc(dcbnl_ops_group0, dcbnl_ops_group2);
#line 582
    ldv_state_variable_13 = 1;
  } else {

  }
#line 585
  goto ldv_54745;
  case 20: ;
#line 588
  if (ldv_state_variable_13 == 1) {
#line 590
    ixgbe_dcbnl_ieee_getpfc(dcbnl_ops_group0, dcbnl_ops_group2);
#line 592
    ldv_state_variable_13 = 1;
  } else {

  }
#line 595
  goto ldv_54745;
  case 21: ;
#line 598
  if (ldv_state_variable_13 == 1) {
#line 600
    ixgbe_dcbnl_getcap(dcbnl_ops_group0, ldvarg364, ldvarg363);
#line 602
    ldv_state_variable_13 = 1;
  } else {

  }
#line 605
  goto ldv_54745;
  case 22: ;
#line 608
  if (ldv_state_variable_13 == 1) {
#line 610
    ixgbe_dcbnl_setpfcstate(dcbnl_ops_group0, (int )ldvarg362);
#line 612
    ldv_state_variable_13 = 1;
  } else {

  }
#line 615
  goto ldv_54745;
  case 23: ;
#line 618
  if (ldv_state_variable_13 == 1) {
#line 620
    ixgbe_dcbnl_set_all(dcbnl_ops_group0);
#line 622
    ldv_state_variable_13 = 1;
  } else {

  }
#line 625
  goto ldv_54745;
  case 24: ;
#line 628
  if (ldv_state_variable_13 == 1) {
#line 630
    ixgbe_dcbnl_set_state(dcbnl_ops_group0, (int )ldvarg361);
#line 632
    ldv_state_variable_13 = 1;
  } else {

  }
#line 635
  goto ldv_54745;
  case 25: ;
#line 638
  if (ldv_state_variable_13 == 1) {
#line 640
    ixgbe_dcbnl_setdcbx(dcbnl_ops_group0, (int )ldvarg360);
#line 642
    ldv_state_variable_13 = 1;
  } else {

  }
#line 645
  goto ldv_54745;
  case 26: ;
#line 648
  if (ldv_state_variable_13 == 1) {
#line 650
    ixgbe_dcbnl_get_pg_tc_cfg_rx(dcbnl_ops_group0, ldvarg358, ldvarg357, ldvarg356,
                                 ldvarg359, ldvarg355);
#line 652
    ldv_state_variable_13 = 1;
  } else {

  }
#line 655
  goto ldv_54745;
  case 27: ;
#line 658
  if (ldv_state_variable_13 == 1) {
#line 660
    ixgbe_dcbnl_set_pg_bwg_cfg_rx(dcbnl_ops_group0, ldvarg354, (int )ldvarg353);
#line 662
    ldv_state_variable_13 = 1;
  } else {

  }
#line 665
  goto ldv_54745;
  default: 
#line 666
  ldv_stop();
  }
  ldv_54745: ;
#line 670
  return;
}
}
#line 695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
bool ldv_queue_work_on_473(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 699
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 699
  ldv_func_res = tmp;
#line 701
  activate_work_9(ldv_func_arg3, 2);
#line 703
  return (ldv_func_res);
}
}
#line 706 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
bool ldv_queue_delayed_work_on_474(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 710
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 710
  ldv_func_res = tmp;
#line 712
  activate_work_9(& ldv_func_arg3->work, 2);
#line 714
  return (ldv_func_res);
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
bool ldv_queue_work_on_475(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 721
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 721
  ldv_func_res = tmp;
#line 723
  activate_work_9(ldv_func_arg3, 2);
#line 725
  return (ldv_func_res);
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
void ldv_flush_workqueue_476(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 731
  flush_workqueue(ldv_func_arg1);
#line 733
  call_and_disable_all_9(2);
#line 734
  return;
}
}
#line 736 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
bool ldv_queue_delayed_work_on_477(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 740
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 740
  ldv_func_res = tmp;
#line 742
  activate_work_9(& ldv_func_arg3->work, 2);
#line 744
  return (ldv_func_res);
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
void ldv_mutex_lock_478(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 750
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 752
  mutex_lock(ldv_func_arg1);
#line 753
  return;
}
}
#line 755 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
void ldv_mutex_unlock_479(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 758
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 760
  mutex_unlock(ldv_func_arg1);
#line 761
  return;
}
}
#line 763 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
void ldv_mutex_lock_480(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 766
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 768
  mutex_lock(ldv_func_arg1);
#line 769
  return;
}
}
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
int ldv_mutex_trylock_481(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 775
  tmp = mutex_trylock(ldv_func_arg1);
#line 775
  ldv_func_res = tmp;
#line 777
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 777
  return (tmp___0);
#line 779
  return (ldv_func_res);
}
}
#line 782 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
void ldv_mutex_unlock_482(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 785
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 787
  mutex_unlock(ldv_func_arg1);
#line 788
  return;
}
}
#line 790 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
void ldv_mutex_unlock_483(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 793
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 795
  mutex_unlock(ldv_func_arg1);
#line 796
  return;
}
}
#line 798 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.o.c.prepared"
void ldv_mutex_lock_484(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 801
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 803
  mutex_lock(ldv_func_arg1);
#line 804
  return;
}
}
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_509(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_507(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_510(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_511(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.o.c.prepared"
void ldv_mutex_lock_506(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_508(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_512(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_501(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_503(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_502(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_505(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_504(struct workqueue_struct *ldv_func_arg1 ) ;
#line 639 "include/linux/device.h"
extern void *devm_kmalloc(struct device * , size_t  , gfp_t  ) ;
#line 644 "include/linux/device.h"
__inline static void *devm_kzalloc(struct device *dev , size_t size , gfp_t gfp ) 
{ 
  void *tmp ;

  {
#line 646
  tmp = devm_kmalloc(dev, size, gfp | 32768U);
#line 646
  return (tmp);
}
}
#line 26 "include/linux/hwmon.h"
extern struct device *devm_hwmon_device_register_with_groups(struct device * , char const   * ,
                                                             void * , struct attribute_group  const  ** ) ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static ssize_t ixgbe_hwmon_show_location(struct device *dev , struct device_attribute *attr ,
                                         char *buf ) 
{ 
  struct hwmon_attr *ixgbe_attr ;
  struct device_attribute  const  *__mptr ;
  int tmp ;

  {
#line 46
  __mptr = (struct device_attribute  const  *)attr;
#line 46
  ixgbe_attr = (struct hwmon_attr *)__mptr;
#line 48
  tmp = sprintf(buf, "loc%u\n", (int )(ixgbe_attr->sensor)->location);
#line 48
  return ((ssize_t )tmp);
}
}
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static ssize_t ixgbe_hwmon_show_temp(struct device *dev , struct device_attribute *attr ,
                                     char *buf ) 
{ 
  struct hwmon_attr *ixgbe_attr ;
  struct device_attribute  const  *__mptr ;
  unsigned int value ;
  int tmp ;

  {
#line 56
  __mptr = (struct device_attribute  const  *)attr;
#line 56
  ixgbe_attr = (struct hwmon_attr *)__mptr;
#line 61
  (*((ixgbe_attr->hw)->mac.ops.get_thermal_sensor_data))(ixgbe_attr->hw);
#line 63
  value = (unsigned int )(ixgbe_attr->sensor)->temp;
#line 66
  value = value * 1000U;
#line 68
  tmp = sprintf(buf, "%u\n", value);
#line 68
  return ((ssize_t )tmp);
}
}
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static ssize_t ixgbe_hwmon_show_cautionthresh(struct device *dev , struct device_attribute *attr ,
                                              char *buf ) 
{ 
  struct hwmon_attr *ixgbe_attr ;
  struct device_attribute  const  *__mptr ;
  unsigned int value ;
  int tmp ;

  {
#line 75
  __mptr = (struct device_attribute  const  *)attr;
#line 75
  ixgbe_attr = (struct hwmon_attr *)__mptr;
#line 77
  value = (unsigned int )(ixgbe_attr->sensor)->caution_thresh;
#line 80
  value = value * 1000U;
#line 82
  tmp = sprintf(buf, "%u\n", value);
#line 82
  return ((ssize_t )tmp);
}
}
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static ssize_t ixgbe_hwmon_show_maxopthresh(struct device *dev , struct device_attribute *attr ,
                                            char *buf ) 
{ 
  struct hwmon_attr *ixgbe_attr ;
  struct device_attribute  const  *__mptr ;
  unsigned int value ;
  int tmp ;

  {
#line 89
  __mptr = (struct device_attribute  const  *)attr;
#line 89
  ixgbe_attr = (struct hwmon_attr *)__mptr;
#line 91
  value = (unsigned int )(ixgbe_attr->sensor)->max_op_thresh;
#line 94
  value = value * 1000U;
#line 96
  tmp = sprintf(buf, "%u\n", value);
#line 96
  return ((ssize_t )tmp);
}
}
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static int ixgbe_add_hwmon_attr(struct ixgbe_adapter *adapter , unsigned int offset ,
                                int type ) 
{ 
  int rc ;
  unsigned int n_attr ;
  struct hwmon_attr *ixgbe_attr ;
  struct lock_class_key __key ;

  {
#line 115
  n_attr = (adapter->ixgbe_hwmon_buff)->n_hwmon;
#line 116
  ixgbe_attr = (struct hwmon_attr *)(& (adapter->ixgbe_hwmon_buff)->hwmon_list) + (unsigned long )n_attr;
#line 118
  switch (type) {
  case 0: 
#line 120
  ixgbe_attr->dev_attr.show = & ixgbe_hwmon_show_location;
#line 121
  snprintf((char *)(& ixgbe_attr->name), 12UL, "temp%u_label", offset + 1U);
#line 123
  goto ldv_55255;
  case 1: 
#line 125
  ixgbe_attr->dev_attr.show = & ixgbe_hwmon_show_temp;
#line 126
  snprintf((char *)(& ixgbe_attr->name), 12UL, "temp%u_input", offset + 1U);
#line 128
  goto ldv_55255;
  case 2: 
#line 130
  ixgbe_attr->dev_attr.show = & ixgbe_hwmon_show_cautionthresh;
#line 131
  snprintf((char *)(& ixgbe_attr->name), 12UL, "temp%u_max", offset + 1U);
#line 133
  goto ldv_55255;
  case 3: 
#line 135
  ixgbe_attr->dev_attr.show = & ixgbe_hwmon_show_maxopthresh;
#line 136
  snprintf((char *)(& ixgbe_attr->name), 12UL, "temp%u_crit", offset + 1U);
#line 138
  goto ldv_55255;
  default: 
#line 140
  rc = -1;
#line 141
  return (rc);
  }
  ldv_55255: 
#line 145
  ixgbe_attr->sensor = (struct ixgbe_thermal_diode_data *)(& adapter->hw.mac.thermal_sensor_data.sensor) + (unsigned long )offset;
#line 147
  ixgbe_attr->hw = & adapter->hw;
#line 148
  ixgbe_attr->dev_attr.store = (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0;
#line 149
  ixgbe_attr->dev_attr.attr.mode = 292U;
#line 150
  ixgbe_attr->dev_attr.attr.name = (char const   *)(& ixgbe_attr->name);
#line 151
  ixgbe_attr->dev_attr.attr.key = & __key;
#line 153
  (adapter->ixgbe_hwmon_buff)->attrs[n_attr] = & ixgbe_attr->dev_attr.attr;
#line 155
  (adapter->ixgbe_hwmon_buff)->n_hwmon = (adapter->ixgbe_hwmon_buff)->n_hwmon + 1U;
#line 157
  return (0);
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static void ixgbe_sysfs_del_adapter(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 162
  return;
}
}
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
void ixgbe_sysfs_exit(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 167
  ixgbe_sysfs_del_adapter(adapter);
#line 168
  return;
}
}
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
int ixgbe_sysfs_init(struct ixgbe_adapter *adapter ) 
{ 
  struct hwmon_buff *ixgbe_hwmon ;
  struct device *hwmon_dev ;
  unsigned int i ;
  int rc ;
  s32 tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;

  {
#line 176
  rc = 0;
#line 179
  if ((unsigned long )adapter->hw.mac.ops.init_thermal_sensor_thresh == (unsigned long )((s32 (*)(struct ixgbe_hw * ))0)) {
#line 180
    goto exit;
  } else {

  }
#line 184
  tmp = (*(adapter->hw.mac.ops.init_thermal_sensor_thresh))(& adapter->hw);
#line 184
  if (tmp != 0) {
#line 185
    goto exit;
  } else {

  }
#line 187
  tmp___0 = devm_kzalloc(& (adapter->pdev)->dev, 1120UL, 208U);
#line 187
  ixgbe_hwmon = (struct hwmon_buff *)tmp___0;
#line 189
  if ((unsigned long )ixgbe_hwmon == (unsigned long )((struct hwmon_buff *)0)) {
#line 190
    rc = -12;
#line 191
    goto exit;
  } else {

  }
#line 193
  adapter->ixgbe_hwmon_buff = ixgbe_hwmon;
#line 195
  i = 0U;
#line 195
  goto ldv_55277;
  ldv_55276: ;
#line 200
  if ((unsigned int )adapter->hw.mac.thermal_sensor_data.sensor[i].location == 0U) {
#line 201
    goto ldv_55275;
  } else {

  }
#line 204
  rc = ixgbe_add_hwmon_attr(adapter, i, 2);
#line 205
  if (rc != 0) {
#line 206
    goto exit;
  } else {

  }
#line 207
  rc = ixgbe_add_hwmon_attr(adapter, i, 0);
#line 208
  if (rc != 0) {
#line 209
    goto exit;
  } else {

  }
#line 210
  rc = ixgbe_add_hwmon_attr(adapter, i, 1);
#line 211
  if (rc != 0) {
#line 212
    goto exit;
  } else {

  }
#line 213
  rc = ixgbe_add_hwmon_attr(adapter, i, 3);
#line 214
  if (rc != 0) {
#line 215
    goto exit;
  } else {

  }
  ldv_55275: 
#line 195
  i = i + 1U;
  ldv_55277: ;
#line 195
  if (i <= 2U) {
#line 197
    goto ldv_55276;
  } else {

  }
#line 218
  ixgbe_hwmon->groups[0] = (struct attribute_group  const  *)(& ixgbe_hwmon->group);
#line 219
  ixgbe_hwmon->group.attrs = (struct attribute **)(& ixgbe_hwmon->attrs);
#line 221
  hwmon_dev = devm_hwmon_device_register_with_groups(& (adapter->pdev)->dev, "ixgbe",
                                                     (void *)ixgbe_hwmon, (struct attribute_group  const  **)(& ixgbe_hwmon->groups));
#line 225
  tmp___2 = IS_ERR((void const   *)hwmon_dev);
#line 225
  if ((int )tmp___2) {
#line 226
    tmp___1 = PTR_ERR((void const   *)hwmon_dev);
#line 226
    rc = (int )tmp___1;
  } else {

  }
  exit: ;
#line 228
  return (rc);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.o.c.prepared"
bool ldv_queue_work_on_501(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 359
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 359
  ldv_func_res = tmp;
#line 361
  activate_work_9(ldv_func_arg3, 2);
#line 363
  return (ldv_func_res);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.o.c.prepared"
bool ldv_queue_delayed_work_on_502(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 370
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 370
  ldv_func_res = tmp;
#line 372
  activate_work_9(& ldv_func_arg3->work, 2);
#line 374
  return (ldv_func_res);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.o.c.prepared"
bool ldv_queue_work_on_503(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 381
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 381
  ldv_func_res = tmp;
#line 383
  activate_work_9(ldv_func_arg3, 2);
#line 385
  return (ldv_func_res);
}
}
#line 388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.o.c.prepared"
void ldv_flush_workqueue_504(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 391
  flush_workqueue(ldv_func_arg1);
#line 393
  call_and_disable_all_9(2);
#line 394
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.o.c.prepared"
bool ldv_queue_delayed_work_on_505(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 400
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 400
  ldv_func_res = tmp;
#line 402
  activate_work_9(& ldv_func_arg3->work, 2);
#line 404
  return (ldv_func_res);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.o.c.prepared"
void ldv_mutex_lock_506(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 410
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 412
  mutex_lock(ldv_func_arg1);
#line 413
  return;
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.o.c.prepared"
void ldv_mutex_unlock_507(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 418
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 420
  mutex_unlock(ldv_func_arg1);
#line 421
  return;
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.o.c.prepared"
void ldv_mutex_lock_508(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 426
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 428
  mutex_lock(ldv_func_arg1);
#line 429
  return;
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.o.c.prepared"
int ldv_mutex_trylock_509(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 435
  tmp = mutex_trylock(ldv_func_arg1);
#line 435
  ldv_func_res = tmp;
#line 437
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 437
  return (tmp___0);
#line 439
  return (ldv_func_res);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.o.c.prepared"
void ldv_mutex_unlock_510(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 445
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 447
  mutex_unlock(ldv_func_arg1);
#line 448
  return;
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.o.c.prepared"
void ldv_mutex_unlock_511(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 453
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 455
  mutex_unlock(ldv_func_arg1);
#line 456
  return;
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.o.c.prepared"
void ldv_mutex_lock_512(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 461
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 463
  mutex_lock(ldv_func_arg1);
#line 464
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 413 "include/linux/kernel.h"
extern char *kasprintf(gfp_t  , char const   *  , ...) ;
#line 417
extern int sscanf(char const   * , char const   *  , ...) ;
#line 64 "./arch/x86/include/asm/string_64.h"
extern size_t strlen(char const   * ) ;
#line 41 "include/linux/string.h"
extern int strncmp(char const   * , char const   * , __kernel_size_t  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_539(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_534(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_537(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_540(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
void ldv_mutex_lock_535(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_536(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_538(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_529(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_531(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_530(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_533(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_532(struct workqueue_struct *ldv_func_arg1 ) ;
#line 2801 "include/linux/fs.h"
extern int simple_open(struct inode * , struct file * ) ;
#line 2832
extern ssize_t simple_read_from_buffer(void * , size_t  , loff_t * , void const   * ,
                                       size_t  ) ;
#line 2834
extern ssize_t simple_write_to_buffer(void * , size_t  , loff_t * , void const   * ,
                                      size_t  ) ;
#line 49 "include/linux/debugfs.h"
extern struct dentry *debugfs_create_file(char const   * , umode_t  , struct dentry * ,
                                          void * , struct file_operations  const  * ) ;
#line 58
extern struct dentry *debugfs_create_dir(char const   * , struct dentry * ) ;
#line 69
extern void debugfs_remove_recursive(struct dentry * ) ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static struct dentry *ixgbe_dbg_root  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static char ixgbe_dbg_reg_ops_buf[256U]  = {      '\000'};
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static ssize_t ixgbe_dbg_reg_ops_read(struct file *filp , char *buffer , size_t count ,
                                      loff_t *ppos ) 
{ 
  struct ixgbe_adapter *adapter ;
  char *buf ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 47
  adapter = (struct ixgbe_adapter *)filp->private_data;
#line 52
  if (*ppos != 0LL) {
#line 53
    return (0L);
  } else {

  }
#line 55
  buf = kasprintf(208U, "%s: %s\n", (char *)(& (adapter->netdev)->name), (char *)(& ixgbe_dbg_reg_ops_buf));
#line 58
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 59
    return (-12L);
  } else {

  }
#line 61
  tmp = strlen((char const   *)buf);
#line 61
  if (tmp > count) {
#line 62
    kfree((void const   *)buf);
#line 63
    return (-28L);
  } else {

  }
#line 66
  tmp___0 = strlen((char const   *)buf);
#line 66
  tmp___1 = simple_read_from_buffer((void *)buffer, count, ppos, (void const   *)buf,
                                    tmp___0);
#line 66
  len = (int )tmp___1;
#line 68
  kfree((void const   *)buf);
#line 69
  return ((ssize_t )len);
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static ssize_t ixgbe_dbg_reg_ops_write(struct file *filp , char const   *buffer ,
                                       size_t count , loff_t *ppos ) 
{ 
  struct ixgbe_adapter *adapter ;
  int len ;
  ssize_t tmp ;
  u32 reg ;
  u32 value ;
  int cnt ;
  u32 reg___0 ;
  u32 value___0 ;
  int cnt___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 83
  adapter = (struct ixgbe_adapter *)filp->private_data;
#line 87
  if (*ppos != 0LL) {
#line 88
    return (0L);
  } else {

  }
#line 89
  if (count > 255UL) {
#line 90
    return (-28L);
  } else {

  }
#line 92
  tmp = simple_write_to_buffer((void *)(& ixgbe_dbg_reg_ops_buf), 255UL, ppos, (void const   *)buffer,
                               count);
#line 92
  len = (int )tmp;
#line 97
  if (len < 0) {
#line 98
    return ((ssize_t )len);
  } else {

  }
#line 100
  ixgbe_dbg_reg_ops_buf[len] = 0;
#line 102
  tmp___1 = strncmp((char const   *)(& ixgbe_dbg_reg_ops_buf), "write", 5UL);
#line 102
  if (tmp___1 == 0) {
#line 105
    cnt = sscanf((char const   *)(& ixgbe_dbg_reg_ops_buf) + 5U, "%x %x", & reg, & value);
#line 106
    if (cnt == 2) {
#line 107
      ixgbe_write_reg(& adapter->hw, reg, value);
#line 108
      value = ixgbe_read_reg(& adapter->hw, reg);
#line 109
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "write: 0x%08x = 0x%08x\n",
                reg, value);
    } else {
#line 111
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "write <reg> <value>\n");
    }
  } else {
#line 113
    tmp___0 = strncmp((char const   *)(& ixgbe_dbg_reg_ops_buf), "read", 4UL);
#line 113
    if (tmp___0 == 0) {
#line 116
      cnt___0 = sscanf((char const   *)(& ixgbe_dbg_reg_ops_buf) + 4U, "%x", & reg___0);
#line 117
      if (cnt___0 == 1) {
#line 118
        value___0 = ixgbe_read_reg(& adapter->hw, reg___0);
#line 119
        _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "read 0x%08x = 0x%08x\n",
                  reg___0, value___0);
      } else {
#line 121
        _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "read <reg>\n");
      }
    } else {
#line 124
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Unknown command %s\n",
                (char *)(& ixgbe_dbg_reg_ops_buf));
#line 125
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Available commands:\n");
#line 126
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "   read <reg>\n");
#line 127
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "   write <reg> <value>\n");
    }
  }
#line 129
  return ((ssize_t )count);
}
}
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static struct file_operations  const  ixgbe_dbg_reg_ops_fops  = 
#line 132
     {& __this_module, 0, & ixgbe_dbg_reg_ops_read, & ixgbe_dbg_reg_ops_write, 0, 0,
    0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static char ixgbe_dbg_netdev_ops_buf[256U]  = {      '\000'};
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static ssize_t ixgbe_dbg_netdev_ops_read(struct file *filp , char *buffer , size_t count ,
                                         loff_t *ppos ) 
{ 
  struct ixgbe_adapter *adapter ;
  char *buf ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 152
  adapter = (struct ixgbe_adapter *)filp->private_data;
#line 157
  if (*ppos != 0LL) {
#line 158
    return (0L);
  } else {

  }
#line 160
  buf = kasprintf(208U, "%s: %s\n", (char *)(& (adapter->netdev)->name), (char *)(& ixgbe_dbg_netdev_ops_buf));
#line 163
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 164
    return (-12L);
  } else {

  }
#line 166
  tmp = strlen((char const   *)buf);
#line 166
  if (tmp > count) {
#line 167
    kfree((void const   *)buf);
#line 168
    return (-28L);
  } else {

  }
#line 171
  tmp___0 = strlen((char const   *)buf);
#line 171
  tmp___1 = simple_read_from_buffer((void *)buffer, count, ppos, (void const   *)buf,
                                    tmp___0);
#line 171
  len = (int )tmp___1;
#line 173
  kfree((void const   *)buf);
#line 174
  return ((ssize_t )len);
}
}
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static ssize_t ixgbe_dbg_netdev_ops_write(struct file *filp , char const   *buffer ,
                                          size_t count , loff_t *ppos ) 
{ 
  struct ixgbe_adapter *adapter ;
  int len ;
  ssize_t tmp ;
  int tmp___0 ;

  {
#line 188
  adapter = (struct ixgbe_adapter *)filp->private_data;
#line 192
  if (*ppos != 0LL) {
#line 193
    return (0L);
  } else {

  }
#line 194
  if (count > 255UL) {
#line 195
    return (-28L);
  } else {

  }
#line 197
  tmp = simple_write_to_buffer((void *)(& ixgbe_dbg_netdev_ops_buf), 255UL, ppos,
                               (void const   *)buffer, count);
#line 197
  len = (int )tmp;
#line 202
  if (len < 0) {
#line 203
    return ((ssize_t )len);
  } else {

  }
#line 205
  ixgbe_dbg_netdev_ops_buf[len] = 0;
#line 207
  tmp___0 = strncmp((char const   *)(& ixgbe_dbg_netdev_ops_buf), "tx_timeout", 10UL);
#line 207
  if (tmp___0 == 0) {
#line 208
    (*(((adapter->netdev)->netdev_ops)->ndo_tx_timeout))(adapter->netdev);
#line 209
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "tx_timeout called\n");
  } else {
#line 211
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Unknown command: %s\n",
              (char *)(& ixgbe_dbg_netdev_ops_buf));
#line 212
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Available commands:\n");
#line 213
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "    tx_timeout\n");
  }
#line 215
  return ((ssize_t )count);
}
}
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static struct file_operations  const  ixgbe_dbg_netdev_ops_fops  = 
#line 218
     {& __this_module, 0, & ixgbe_dbg_netdev_ops_read, & ixgbe_dbg_netdev_ops_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
void ixgbe_dbg_adapter_init(struct ixgbe_adapter *adapter ) 
{ 
  char const   *name ;
  char const   *tmp ;
  struct dentry *pfile ;

  {
#line 231
  tmp = pci_name((struct pci_dev  const  *)adapter->pdev);
#line 231
  name = tmp;
#line 233
  adapter->ixgbe_dbg_adapter = debugfs_create_dir(name, ixgbe_dbg_root);
#line 234
  if ((unsigned long )adapter->ixgbe_dbg_adapter != (unsigned long )((struct dentry *)0)) {
#line 235
    pfile = debugfs_create_file("reg_ops", 384, adapter->ixgbe_dbg_adapter, (void *)adapter,
                                & ixgbe_dbg_reg_ops_fops);
#line 238
    if ((unsigned long )pfile == (unsigned long )((struct dentry *)0)) {
#line 239
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "debugfs reg_ops for %s failed\n",
              name);
    } else {

    }
#line 240
    pfile = debugfs_create_file("netdev_ops", 384, adapter->ixgbe_dbg_adapter, (void *)adapter,
                                & ixgbe_dbg_netdev_ops_fops);
#line 243
    if ((unsigned long )pfile == (unsigned long )((struct dentry *)0)) {
#line 244
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "debugfs netdev_ops for %s failed\n",
              name);
    } else {

    }
  } else {
#line 246
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "debugfs entry for %s failed\n",
            name);
  }
#line 247
  return;
}
}
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
void ixgbe_dbg_adapter_exit(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 256
  debugfs_remove_recursive(adapter->ixgbe_dbg_adapter);
#line 257
  adapter->ixgbe_dbg_adapter = (struct dentry *)0;
#line 258
  return;
}
}
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
void ixgbe_dbg_init(void) 
{ 


  {
#line 265
  ixgbe_dbg_root = debugfs_create_dir((char const   *)(& ixgbe_driver_name), (struct dentry *)0);
#line 266
  if ((unsigned long )ixgbe_dbg_root == (unsigned long )((struct dentry *)0)) {
#line 267
    printk("\vixgbe: init of debugfs failed\n");
  } else {

  }
#line 268
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
void ixgbe_dbg_exit(void) 
{ 


  {
#line 275
  debugfs_remove_recursive(ixgbe_dbg_root);
#line 276
  return;
}
}
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
int ldv_retval_0  ;
#line 332
extern int ldv_release_12(void) ;
#line 333
extern int ldv_release_11(void) ;
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
int ldv_retval_7  ;
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
void ldv_file_operations_12(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 338
  tmp = ldv_init_zalloc(1000UL);
#line 338
  ixgbe_dbg_reg_ops_fops_group1 = (struct inode *)tmp;
#line 339
  tmp___0 = ldv_init_zalloc(504UL);
#line 339
  ixgbe_dbg_reg_ops_fops_group2 = (struct file *)tmp___0;
#line 340
  return;
}
}
#line 343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
void ldv_file_operations_11(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 344
  tmp = ldv_init_zalloc(1000UL);
#line 344
  ixgbe_dbg_netdev_ops_fops_group1 = (struct inode *)tmp;
#line 345
  tmp___0 = ldv_init_zalloc(504UL);
#line 345
  ixgbe_dbg_netdev_ops_fops_group2 = (struct file *)tmp___0;
#line 346
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
void ldv_main_exported_11(void) 
{ 
  size_t ldvarg347 ;
  size_t ldvarg350 ;
  char *ldvarg348 ;
  void *tmp ;
  char *ldvarg351 ;
  void *tmp___0 ;
  loff_t *ldvarg346 ;
  void *tmp___1 ;
  loff_t *ldvarg349 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 352
  tmp = ldv_init_zalloc(1UL);
#line 352
  ldvarg348 = (char *)tmp;
#line 353
  tmp___0 = ldv_init_zalloc(1UL);
#line 353
  ldvarg351 = (char *)tmp___0;
#line 354
  tmp___1 = ldv_init_zalloc(8UL);
#line 354
  ldvarg346 = (loff_t *)tmp___1;
#line 355
  tmp___2 = ldv_init_zalloc(8UL);
#line 355
  ldvarg349 = (loff_t *)tmp___2;
#line 350
  ldv_memset((void *)(& ldvarg347), 0, 8UL);
#line 351
  ldv_memset((void *)(& ldvarg350), 0, 8UL);
#line 357
  tmp___3 = __VERIFIER_nondet_int();
#line 357
  switch (tmp___3) {
  case 0: ;
#line 360
  if (ldv_state_variable_11 == 1) {
#line 362
    ldv_retval_0 = simple_open(ixgbe_dbg_netdev_ops_fops_group1, ixgbe_dbg_netdev_ops_fops_group2);
#line 363
    if (ldv_retval_0 == 0) {
#line 364
      ldv_state_variable_11 = 2;
#line 365
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 369
  goto ldv_55409;
  case 1: ;
#line 372
  if (ldv_state_variable_11 == 1) {
#line 374
    ixgbe_dbg_netdev_ops_write(ixgbe_dbg_netdev_ops_fops_group2, (char const   *)ldvarg351,
                               ldvarg350, ldvarg349);
#line 376
    ldv_state_variable_11 = 1;
  } else {

  }
#line 379
  if (ldv_state_variable_11 == 2) {
#line 381
    ixgbe_dbg_netdev_ops_write(ixgbe_dbg_netdev_ops_fops_group2, (char const   *)ldvarg351,
                               ldvarg350, ldvarg349);
#line 383
    ldv_state_variable_11 = 2;
  } else {

  }
#line 386
  goto ldv_55409;
  case 2: ;
#line 389
  if (ldv_state_variable_11 == 2) {
#line 391
    ixgbe_dbg_netdev_ops_read(ixgbe_dbg_netdev_ops_fops_group2, ldvarg348, ldvarg347,
                              ldvarg346);
#line 393
    ldv_state_variable_11 = 2;
  } else {

  }
#line 396
  goto ldv_55409;
  case 3: ;
#line 399
  if (ldv_state_variable_11 == 2) {
#line 401
    ldv_release_11();
#line 402
    ldv_state_variable_11 = 1;
#line 403
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 406
  goto ldv_55409;
  default: 
#line 407
  ldv_stop();
  }
  ldv_55409: ;
#line 411
  return;
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
void ldv_main_exported_12(void) 
{ 
  size_t ldvarg437 ;
  loff_t *ldvarg436 ;
  void *tmp ;
  size_t ldvarg440 ;
  char *ldvarg438 ;
  void *tmp___0 ;
  loff_t *ldvarg439 ;
  void *tmp___1 ;
  char *ldvarg441 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 415
  tmp = ldv_init_zalloc(8UL);
#line 415
  ldvarg436 = (loff_t *)tmp;
#line 417
  tmp___0 = ldv_init_zalloc(1UL);
#line 417
  ldvarg438 = (char *)tmp___0;
#line 418
  tmp___1 = ldv_init_zalloc(8UL);
#line 418
  ldvarg439 = (loff_t *)tmp___1;
#line 419
  tmp___2 = ldv_init_zalloc(1UL);
#line 419
  ldvarg441 = (char *)tmp___2;
#line 414
  ldv_memset((void *)(& ldvarg437), 0, 8UL);
#line 416
  ldv_memset((void *)(& ldvarg440), 0, 8UL);
#line 421
  tmp___3 = __VERIFIER_nondet_int();
#line 421
  switch (tmp___3) {
  case 0: ;
#line 424
  if (ldv_state_variable_12 == 1) {
#line 426
    ldv_retval_7 = simple_open(ixgbe_dbg_reg_ops_fops_group1, ixgbe_dbg_reg_ops_fops_group2);
#line 427
    if (ldv_retval_7 == 0) {
#line 428
      ldv_state_variable_12 = 2;
#line 429
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 433
  goto ldv_55424;
  case 1: ;
#line 436
  if (ldv_state_variable_12 == 1) {
#line 438
    ixgbe_dbg_reg_ops_write(ixgbe_dbg_reg_ops_fops_group2, (char const   *)ldvarg441,
                            ldvarg440, ldvarg439);
#line 440
    ldv_state_variable_12 = 1;
  } else {

  }
#line 443
  if (ldv_state_variable_12 == 2) {
#line 445
    ixgbe_dbg_reg_ops_write(ixgbe_dbg_reg_ops_fops_group2, (char const   *)ldvarg441,
                            ldvarg440, ldvarg439);
#line 447
    ldv_state_variable_12 = 2;
  } else {

  }
#line 450
  goto ldv_55424;
  case 2: ;
#line 453
  if (ldv_state_variable_12 == 2) {
#line 455
    ixgbe_dbg_reg_ops_read(ixgbe_dbg_reg_ops_fops_group2, ldvarg438, ldvarg437, ldvarg436);
#line 457
    ldv_state_variable_12 = 2;
  } else {

  }
#line 460
  goto ldv_55424;
  case 3: ;
#line 463
  if (ldv_state_variable_12 == 2) {
#line 465
    ldv_release_12();
#line 466
    ldv_state_variable_12 = 1;
#line 467
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 470
  goto ldv_55424;
  default: 
#line 471
  ldv_stop();
  }
  ldv_55424: ;
#line 475
  return;
}
}
#line 500 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
bool ldv_queue_work_on_529(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 504
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 504
  ldv_func_res = tmp;
#line 506
  activate_work_9(ldv_func_arg3, 2);
#line 508
  return (ldv_func_res);
}
}
#line 511 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
bool ldv_queue_delayed_work_on_530(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 515
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 515
  ldv_func_res = tmp;
#line 517
  activate_work_9(& ldv_func_arg3->work, 2);
#line 519
  return (ldv_func_res);
}
}
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
bool ldv_queue_work_on_531(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 526
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 526
  ldv_func_res = tmp;
#line 528
  activate_work_9(ldv_func_arg3, 2);
#line 530
  return (ldv_func_res);
}
}
#line 533 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
void ldv_flush_workqueue_532(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 536
  flush_workqueue(ldv_func_arg1);
#line 538
  call_and_disable_all_9(2);
#line 539
  return;
}
}
#line 541 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
bool ldv_queue_delayed_work_on_533(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 545
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 545
  ldv_func_res = tmp;
#line 547
  activate_work_9(& ldv_func_arg3->work, 2);
#line 549
  return (ldv_func_res);
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
void ldv_mutex_unlock_534(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 555
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 557
  mutex_unlock(ldv_func_arg1);
#line 558
  return;
}
}
#line 560 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
void ldv_mutex_lock_535(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 563
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 565
  mutex_lock(ldv_func_arg1);
#line 566
  return;
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
void ldv_mutex_lock_536(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 571
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 573
  mutex_lock(ldv_func_arg1);
#line 574
  return;
}
}
#line 576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
void ldv_mutex_unlock_537(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 579
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 581
  mutex_unlock(ldv_func_arg1);
#line 582
  return;
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
void ldv_mutex_lock_538(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 587
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 589
  mutex_lock(ldv_func_arg1);
#line 590
  return;
}
}
#line 592 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
int ldv_mutex_trylock_539(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 596
  tmp = mutex_trylock(ldv_func_arg1);
#line 596
  ldv_func_res = tmp;
#line 598
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 598
  return (tmp___0);
#line 600
  return (ldv_func_res);
}
}
#line 603 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.o.c.prepared"
void ldv_mutex_unlock_540(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 606
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 608
  mutex_unlock(ldv_func_arg1);
#line 609
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 114 "include/linux/cpumask.h"
__inline static unsigned int cpumask_check___1(unsigned int cpu ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 117
  __ret_warn_once = (unsigned int )nr_cpu_ids <= cpu;
#line 117
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 117
  if (tmp___1 != 0L) {
#line 117
    __ret_warn_on = ! __warned;
#line 117
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp != 0L) {
#line 117
      warn_slowpath_null("include/linux/cpumask.h", 117);
    } else {

    }
#line 117
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp___0 != 0L) {
#line 117
      __warned = 1;
    } else {

    }
  } else {

  }
#line 117
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 119
  return (cpu);
}
}
#line 184 "include/linux/cpumask.h"
__inline static unsigned int cpumask_next___0(int n , struct cpumask  const  *srcp ) 
{ 
  unsigned long tmp ;

  {
#line 187
  if (n != -1) {
#line 188
    cpumask_check___1((unsigned int )n);
  } else {

  }
#line 189
  tmp = find_next_bit((unsigned long const   *)(& srcp->bits), (unsigned long )nr_cpu_ids,
                      (unsigned long )(n + 1));
#line 189
  return ((unsigned int )tmp);
}
}
#line 116 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ 
  char c ;

  {
#line 118
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0; sete %1": "+m" (v->counter),
                       "=qm" (c): : "memory");
#line 118
  return ((int )((signed char )c) != 0);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_565(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_563(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_566(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_567(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.o.c.prepared"
void ldv_mutex_lock_562(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_564(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_568(struct mutex *ldv_func_arg1 ) ;
#line 30 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
#line 42
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
#line 315 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
#line 317
  _raw_spin_lock_bh(& lock->__annonCompField17.rlock);
#line 318
  return;
}
}
#line 360 "include/linux/spinlock.h"
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
#line 362
  _raw_spin_unlock_bh(& lock->__annonCompField17.rlock);
#line 363
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_557(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_559(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_558(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_561(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_560(struct workqueue_struct *ldv_func_arg1 ) ;
#line 127 "include/linux/percpu.h"
extern void *__alloc_percpu(size_t  , size_t  ) ;
#line 128
extern void free_percpu(void * ) ;
#line 857 "include/linux/pci.h"
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int  , int  , u8 * ) ;
#line 881 "include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ 
  int tmp ;

  {
#line 883
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
#line 883
  return (tmp);
}
}
#line 120 "include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 123
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 123
  if (tmp != 0L) {
#line 123
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (123), "i" (12UL));
    ldv_25091: ;
#line 123
    goto ldv_25091;
  } else {

  }
#line 124
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 124
  if (tmp___0 != 0L) {
#line 124
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (124), "i" (12UL));
    ldv_25092: ;
#line 124
    goto ldv_25092;
  } else {

  }
#line 126
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 243 "include/linux/scatterlist.h"
__inline static void *sg_virt(struct scatterlist *sg ) 
{ 
  struct page *tmp ;
  void *tmp___0 ;

  {
#line 245
  tmp = sg_page(sg);
#line 245
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
#line 245
  return (tmp___0 + (unsigned long )sg->offset);
}
}
#line 250
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 19 "include/linux/dmapool.h"
extern struct dma_pool *dma_pool_create(char const   * , struct device * , size_t  ,
                                        size_t  , size_t  ) ;
#line 22
extern void dma_pool_destroy(struct dma_pool * ) ;
#line 24
extern void *dma_pool_alloc(struct dma_pool * , gfp_t  , dma_addr_t * ) ;
#line 27
extern void dma_pool_free(struct dma_pool * , void * , dma_addr_t  ) ;
#line 47 "include/linux/dma-debug.h"
extern void debug_dma_map_sg(struct device * , struct scatterlist * , int  , int  ,
                             int  ) ;
#line 50
extern void debug_dma_unmap_sg(struct device * , struct scatterlist * , int  , int  ) ;
#line 10 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs___0(struct device *dev , void *ptr ,
                                                    size_t size , enum dma_data_direction dir ,
                                                    struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 19
  if (tmp___1 != 0L) {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_25861: ;
#line 19
    goto ldv_25861;
  } else {

  }
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
#line 26
  return (addr);
}
}
#line 29 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs___0(struct device *dev , dma_addr_t addr ,
                                                size_t size , enum dma_data_direction dir ,
                                                struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 36
  if (tmp___1 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_25870: ;
#line 36
    goto ldv_25870;
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
#line 40
  return;
}
}
#line 46 "include/asm-generic/dma-mapping-common.h"
__inline static int dma_map_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                     int nents , enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int i ;
  int ents ;
  struct scatterlist *s ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 50
  tmp = get_dma_ops(dev);
#line 50
  ops = tmp;
#line 54
  i = 0;
#line 54
  s = sg;
#line 54
  goto ldv_25883;
  ldv_25882: 
#line 55
  tmp___0 = sg_virt(s);
#line 55
  kmemcheck_mark_initialized(tmp___0, s->length);
#line 54
  i = i + 1;
#line 54
  s = sg_next(s);
  ldv_25883: ;
#line 54
  if (i < nents) {
#line 56
    goto ldv_25882;
  } else {

  }
#line 56
  tmp___1 = valid_dma_direction((int )dir);
#line 56
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 56
  if (tmp___2 != 0L) {
#line 56
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (56), "i" (12UL));
    ldv_25885: ;
#line 56
    goto ldv_25885;
  } else {

  }
#line 57
  ents = (*(ops->map_sg))(dev, sg, nents, dir, attrs);
#line 58
  tmp___3 = ldv__builtin_expect(ents < 0, 0L);
#line 58
  if (tmp___3 != 0L) {
#line 58
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (58), "i" (12UL));
    ldv_25886: ;
#line 58
    goto ldv_25886;
  } else {

  }
#line 59
  debug_dma_map_sg(dev, sg, nents, ents, (int )dir);
#line 61
  return (ents);
}
}
#line 64 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                        int nents , enum dma_data_direction dir ,
                                        struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 68
  tmp = get_dma_ops(dev);
#line 68
  ops = tmp;
#line 70
  tmp___0 = valid_dma_direction((int )dir);
#line 70
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 70
  if (tmp___1 != 0L) {
#line 70
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (70), "i" (12UL));
    ldv_25895: ;
#line 70
    goto ldv_25895;
  } else {

  }
#line 71
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
#line 72
  if ((unsigned long )ops->unmap_sg != (unsigned long )((void (*)(struct device * ,
                                                                  struct scatterlist * ,
                                                                  int  , enum dma_data_direction  ,
                                                                  struct dma_attrs * ))0)) {
#line 73
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
  } else {

  }
#line 74
  return;
}
}
#line 1889 "include/linux/skbuff.h"
__inline static void skb_reset_transport_header(struct sk_buff *skb ) 
{ 


  {
#line 1891
  skb->transport_header = (int )((__u16 )((long )skb->data)) - (int )((__u16 )((long )skb->head));
#line 1892
  return;
}
}
#line 1894 "include/linux/skbuff.h"
__inline static void skb_set_transport_header(struct sk_buff *skb , int const   offset ) 
{ 


  {
#line 1897
  skb_reset_transport_header(skb);
#line 1898
  skb->transport_header = (int )skb->transport_header + (int )((__u16 )offset);
#line 1899
  return;
}
}
#line 1906 "include/linux/skbuff.h"
__inline static void skb_reset_network_header(struct sk_buff *skb ) 
{ 


  {
#line 1908
  skb->network_header = (int )((__u16 )((long )skb->data)) - (int )((__u16 )((long )skb->head));
#line 1909
  return;
}
}
#line 1911 "include/linux/skbuff.h"
__inline static void skb_set_network_header(struct sk_buff *skb , int const   offset ) 
{ 


  {
#line 1913
  skb_reset_network_header(skb);
#line 1914
  skb->network_header = (int )skb->network_header + (int )((__u16 )offset);
#line 1915
  return;
}
}
#line 1917 "include/linux/skbuff.h"
__inline static unsigned char *skb_mac_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1919
  return ((unsigned char *)skb->head + (unsigned long )skb->mac_header);
}
}
#line 2549 "include/linux/skbuff.h"
__inline static int __skb_linearize(struct sk_buff *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 2551
  tmp = __pskb_pull_tail(skb, (int )skb->data_len);
#line 2551
  return ((unsigned long )tmp != (unsigned long )((unsigned char *)0U) ? 0 : -12);
}
}
#line 2561 "include/linux/skbuff.h"
__inline static int skb_linearize(struct sk_buff *skb ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;

  {
#line 2563
  tmp___2 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 2563
  if ((int )tmp___2) {
#line 2563
    tmp___0 = __skb_linearize(skb);
#line 2563
    tmp___1 = tmp___0;
  } else {
#line 2563
    tmp___1 = 0;
  }
#line 2563
  return (tmp___1);
}
}
#line 26 "include/linux/if_ether.h"
__inline static struct ethhdr *eth_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 28
  tmp = skb_mac_header(skb);
#line 28
  return ((struct ethhdr *)tmp);
}
}
#line 3472 "include/linux/netdevice.h"
extern void netdev_features_change(struct net_device * ) ;
#line 38 "include/scsi/fc_frame.h"
__inline static u32 ntoh24(u8 const   *p ) 
{ 


  {
#line 40
  return ((u32 )((((int )*p << 16) | ((int )*(p + 1UL) << 8)) | (int )*(p + 2UL)));
}
}
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
__inline static void ixgbe_fcoe_clear_ddp(struct ixgbe_fcoe_ddp *ddp ) 
{ 


  {
#line 49
  ddp->len = 0;
#line 50
  ddp->err = 1U;
#line 51
  ddp->udl = (u64 *)0ULL;
#line 52
  ddp->udp = 0ULL;
#line 53
  ddp->sgl = (struct scatterlist *)0;
#line 54
  ddp->sgc = 0U;
#line 55
  return;
}
}
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_ddp_put(struct net_device *netdev , u16 xid ) 
{ 
  int len ;
  struct ixgbe_fcoe *fcoe ;
  struct ixgbe_adapter *adapter ;
  struct ixgbe_fcoe_ddp *ddp ;
  struct ixgbe_hw *hw ;
  u32 fcbuff ;
  void *tmp ;

  {
#line 77
  if ((unsigned long )netdev == (unsigned long )((struct net_device *)0)) {
#line 78
    return (0);
  } else {

  }
#line 80
  if ((unsigned int )xid > 511U) {
#line 81
    return (0);
  } else {

  }
#line 83
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 83
  adapter = (struct ixgbe_adapter *)tmp;
#line 84
  fcoe = & adapter->fcoe;
#line 85
  ddp = (struct ixgbe_fcoe_ddp *)(& fcoe->ddp) + (unsigned long )xid;
#line 86
  if ((unsigned long )ddp->udl == (unsigned long )((u64 *)0ULL)) {
#line 87
    return (0);
  } else {

  }
#line 89
  hw = & adapter->hw;
#line 90
  len = ddp->len;
#line 92
  if (ddp->err == 0U) {
#line 93
    goto skip_ddpinv;
  } else {

  }
#line 95
  if ((unsigned int )hw->mac.type == 4U) {
#line 98
    ixgbe_write_reg(hw, (u32 )(((int )xid + 10240) * 16), 0U);
#line 99
    ixgbe_write_reg(hw, (u32 )((int )xid * 16 + 163852), (unsigned int )xid | 16384U);
#line 103
    ixgbe_write_reg(hw, (u32 )((int )xid * 16 + 131080), 0U);
#line 106
    ixgbe_write_reg(hw, (u32 )((int )xid * 16 + 131084), (unsigned int )xid | 16384U);
#line 110
    ixgbe_write_reg(hw, (u32 )((int )xid * 16 + 131084), (unsigned int )xid | 32768U);
#line 112
    fcbuff = ixgbe_read_reg(hw, (u32 )((int )xid * 16 + 131080));
  } else {
#line 115
    spin_lock_bh(& fcoe->lock);
#line 116
    ixgbe_write_reg(hw, 20744U, 0U);
#line 117
    ixgbe_write_reg(hw, 20752U, (unsigned int )xid | 16384U);
#line 119
    ixgbe_write_reg(hw, 9240U, 0U);
#line 120
    ixgbe_write_reg(hw, 9248U, (unsigned int )xid | 16384U);
#line 124
    ixgbe_write_reg(hw, 9248U, (unsigned int )xid | 32768U);
#line 126
    fcbuff = ixgbe_read_reg(hw, 9240U);
#line 127
    spin_unlock_bh(& fcoe->lock);
  }
#line 130
  if ((int )fcbuff & 1) {
#line 131
    usleep_range(100UL, 150UL);
  } else {

  }
  skip_ddpinv: ;
#line 134
  if ((unsigned long )ddp->sgl != (unsigned long )((struct scatterlist *)0)) {
#line 135
    dma_unmap_sg_attrs(& (adapter->pdev)->dev, ddp->sgl, (int )ddp->sgc, 2, (struct dma_attrs *)0);
  } else {

  }
#line 137
  if ((unsigned long )ddp->pool != (unsigned long )((struct dma_pool *)0)) {
#line 138
    dma_pool_free(ddp->pool, (void *)ddp->udl, ddp->udp);
#line 139
    ddp->pool = (struct dma_pool *)0;
  } else {

  }
#line 142
  ixgbe_fcoe_clear_ddp(ddp);
#line 144
  return (len);
}
}
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static int ixgbe_fcoe_ddp_setup(struct net_device *netdev , u16 xid , struct scatterlist *sgl ,
                                unsigned int sgc , int target_mode ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_hw *hw ;
  struct ixgbe_fcoe *fcoe ;
  struct ixgbe_fcoe_ddp *ddp ;
  struct ixgbe_fcoe_ddp_pool *ddp_pool ;
  struct scatterlist *sg ;
  unsigned int i ;
  unsigned int j ;
  unsigned int dmacount ;
  unsigned int len ;
  unsigned int bufflen ;
  unsigned int firstoff ;
  unsigned int lastsize ;
  unsigned int thisoff ;
  unsigned int thislen ;
  u32 fcbuff ;
  u32 fcdmarw ;
  u32 fcfltrw ;
  u32 fcrxctl ;
  dma_addr_t addr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify___0 ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___2 ;
  void *tmp___3 ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  int tmp___4 ;

  {
#line 168
  bufflen = 4096U;
#line 169
  firstoff = 0U;
#line 171
  thisoff = 0U;
#line 172
  thislen = 0U;
#line 174
  addr = 0ULL;
#line 176
  if ((unsigned long )netdev == (unsigned long )((struct net_device *)0) || (unsigned long )sgl == (unsigned long )((struct scatterlist *)0)) {
#line 177
    return (0);
  } else {

  }
#line 179
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 179
  adapter = (struct ixgbe_adapter *)tmp;
#line 180
  if ((unsigned int )xid > 511U) {
#line 181
    if ((int )adapter->msg_enable & 1) {
#line 181
      netdev_warn((struct net_device  const  *)adapter->netdev, "xid=0x%x out-of-range\n",
                  (int )xid);
    } else {

    }
#line 182
    return (0);
  } else {

  }
#line 186
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
#line 186
  if (tmp___0 != 0) {
#line 188
    return (0);
  } else {
#line 186
    tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& adapter->state));
#line 186
    if (tmp___1 != 0) {
#line 188
      return (0);
    } else {

    }
  }
#line 190
  fcoe = & adapter->fcoe;
#line 191
  ddp = (struct ixgbe_fcoe_ddp *)(& fcoe->ddp) + (unsigned long )xid;
#line 192
  if ((unsigned long )ddp->sgl != (unsigned long )((struct scatterlist *)0)) {
#line 193
    if ((int )adapter->msg_enable & 1) {
#line 194
      netdev_err((struct net_device  const  *)adapter->netdev, "xid 0x%x w/ non-null sgl=%p nents=%d\n",
                 (int )xid, ddp->sgl, ddp->sgc);
    } else {

    }
#line 195
    return (0);
  } else {

  }
#line 197
  ixgbe_fcoe_clear_ddp(ddp);
#line 200
  if ((unsigned long )fcoe->ddp_pool == (unsigned long )((struct ixgbe_fcoe_ddp_pool *)0)) {
#line 201
    if ((int )adapter->msg_enable & 1) {
#line 201
      netdev_warn((struct net_device  const  *)adapter->netdev, "No ddp_pool resources allocated\n");
    } else {

    }
#line 202
    return (0);
  } else {

  }
#line 205
  __vpp_verify = (void const   *)0;
#line 205
  __asm__  ("": "=r" (__ptr): "0" (fcoe->ddp_pool));
#line 205
  __preempt_count_add(1);
#line 205
  __asm__  volatile   ("": : : "memory");
#line 205
  __vpp_verify___0 = (void const   *)0;
#line 205
  switch (4UL) {
  case 1UL: ;
#line 205
  switch (4UL) {
  case 1UL: 
#line 205
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 205
  goto ldv_60719;
  case 2UL: 
#line 205
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 205
  goto ldv_60719;
  case 4UL: 
#line 205
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 205
  goto ldv_60719;
  case 8UL: 
#line 205
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 205
  goto ldv_60719;
  default: 
#line 205
  __bad_percpu_size();
  }
  ldv_60719: 
#line 205
  pscr_ret__ = pfo_ret__;
#line 205
  goto ldv_60725;
  case 2UL: ;
#line 205
  switch (4UL) {
  case 1UL: 
#line 205
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 205
  goto ldv_60729;
  case 2UL: 
#line 205
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 205
  goto ldv_60729;
  case 4UL: 
#line 205
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 205
  goto ldv_60729;
  case 8UL: 
#line 205
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 205
  goto ldv_60729;
  default: 
#line 205
  __bad_percpu_size();
  }
  ldv_60729: 
#line 205
  pscr_ret__ = pfo_ret_____0;
#line 205
  goto ldv_60725;
  case 4UL: ;
#line 205
  switch (4UL) {
  case 1UL: 
#line 205
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 205
  goto ldv_60738;
  case 2UL: 
#line 205
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 205
  goto ldv_60738;
  case 4UL: 
#line 205
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 205
  goto ldv_60738;
  case 8UL: 
#line 205
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 205
  goto ldv_60738;
  default: 
#line 205
  __bad_percpu_size();
  }
  ldv_60738: 
#line 205
  pscr_ret__ = pfo_ret_____1;
#line 205
  goto ldv_60725;
  case 8UL: ;
#line 205
  switch (4UL) {
  case 1UL: 
#line 205
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 205
  goto ldv_60747;
  case 2UL: 
#line 205
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 205
  goto ldv_60747;
  case 4UL: 
#line 205
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 205
  goto ldv_60747;
  case 8UL: 
#line 205
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 205
  goto ldv_60747;
  default: 
#line 205
  __bad_percpu_size();
  }
  ldv_60747: 
#line 205
  pscr_ret__ = pfo_ret_____2;
#line 205
  goto ldv_60725;
  default: 
#line 205
  __bad_size_call_parameter();
#line 205
  goto ldv_60725;
  }
  ldv_60725: 
#line 205
  ddp_pool = (struct ixgbe_fcoe_ddp_pool *)(__per_cpu_offset[pscr_ret__] + __ptr);
#line 206
  if ((unsigned long )ddp_pool->pool == (unsigned long )((struct dma_pool *)0)) {
#line 207
    if ((int )adapter->msg_enable & 1) {
#line 207
      netdev_warn((struct net_device  const  *)adapter->netdev, "xid=0x%x no ddp pool for fcoe\n",
                  (int )xid);
    } else {

    }
#line 208
    goto out_noddp;
  } else {

  }
#line 212
  tmp___2 = dma_map_sg_attrs(& (adapter->pdev)->dev, sgl, (int )sgc, 2, (struct dma_attrs *)0);
#line 212
  dmacount = (unsigned int )tmp___2;
#line 213
  if (dmacount == 0U) {
#line 214
    if ((int )adapter->msg_enable & 1) {
#line 214
      netdev_err((struct net_device  const  *)adapter->netdev, "xid 0x%x DMA map error\n",
                 (int )xid);
    } else {

    }
#line 215
    goto out_noddp;
  } else {

  }
#line 219
  tmp___3 = dma_pool_alloc(ddp_pool->pool, 32U, & ddp->udp);
#line 219
  ddp->udl = (u64 *)tmp___3;
#line 220
  if ((unsigned long )ddp->udl == (unsigned long )((u64 *)0ULL)) {
#line 221
    if ((int )adapter->msg_enable & 1) {
#line 221
      netdev_err((struct net_device  const  *)adapter->netdev, "failed allocated ddp context\n");
    } else {

    }
#line 222
    goto out_noddp_unmap;
  } else {

  }
#line 224
  ddp->pool = ddp_pool->pool;
#line 225
  ddp->sgl = sgl;
#line 226
  ddp->sgc = sgc;
#line 228
  j = 0U;
#line 229
  i = 0U;
#line 229
  sg = sgl;
#line 229
  goto ldv_60768;
  ldv_60767: 
#line 230
  addr = sg->dma_address;
#line 231
  len = sg->dma_length;
#line 232
  goto ldv_60765;
  ldv_60764: ;
#line 234
  if (j > 255U) {
#line 235
    ddp_pool->noddp = ddp_pool->noddp + 1ULL;
#line 236
    goto out_noddp_free;
  } else {

  }
#line 240
  thisoff = (bufflen - 1U) & (unsigned int )addr;
#line 241
  _min1 = bufflen - thisoff;
#line 241
  _min2 = len;
#line 241
  thislen = _min1 < _min2 ? _min1 : _min2;
#line 246
  if (j != 0U && thisoff != 0U) {
#line 247
    goto out_noddp_free;
  } else {

  }
#line 253
  if ((dmacount - 1U != i || thislen != len) && thislen + thisoff != bufflen) {
#line 255
    goto out_noddp_free;
  } else {

  }
#line 257
  *(ddp->udl + (unsigned long )j) = addr - (dma_addr_t )thisoff;
#line 259
  if (j == 0U) {
#line 260
    firstoff = thisoff;
  } else {

  }
#line 261
  len = len - thislen;
#line 262
  addr = (dma_addr_t )thislen + addr;
#line 263
  j = j + 1U;
  ldv_60765: ;
#line 232
  if (len != 0U) {
#line 234
    goto ldv_60764;
  } else {

  }
#line 229
  i = i + 1U;
#line 229
  sg = sg_next(sg);
  ldv_60768: ;
#line 229
  if (i < dmacount) {
#line 231
    goto ldv_60767;
  } else {

  }
#line 267
  lastsize = thisoff + thislen;
#line 273
  if (lastsize == bufflen) {
#line 274
    if (j > 255U) {
#line 275
      ddp_pool->noddp_ext_buff = ddp_pool->noddp_ext_buff + 1ULL;
#line 276
      goto out_noddp_free;
    } else {

    }
#line 279
    *(ddp->udl + (unsigned long )j) = fcoe->extra_ddp_buffer_dma;
#line 280
    j = j + 1U;
#line 281
    lastsize = 1U;
  } else {

  }
#line 283
  __asm__  volatile   ("": : : "memory");
#line 283
  __preempt_count_sub(1);
#line 285
  fcbuff = 0U;
#line 286
  fcbuff = ((j << 8) & 65535U) | fcbuff;
#line 287
  fcbuff = (firstoff << 16) | fcbuff;
#line 289
  if (target_mode != 0) {
#line 290
    fcbuff = fcbuff | 128U;
  } else {

  }
#line 291
  fcbuff = fcbuff | 1U;
#line 293
  fcdmarw = (u32 )xid;
#line 294
  fcdmarw = fcdmarw | 16384U;
#line 295
  fcdmarw = (lastsize << 16) | fcdmarw;
#line 297
  fcfltrw = (u32 )xid;
#line 298
  fcfltrw = fcfltrw | 16384U;
#line 301
  hw = & adapter->hw;
#line 305
  if (target_mode != 0) {
#line 305
    tmp___4 = constant_test_bit(1L, (unsigned long const volatile   *)(& fcoe->mode));
#line 305
    if (tmp___4 == 0) {
#line 306
      set_bit(1L, (unsigned long volatile   *)(& fcoe->mode));
#line 307
      fcrxctl = ixgbe_read_reg(hw, 20736U);
#line 308
      fcrxctl = fcrxctl | 8U;
#line 309
      ixgbe_write_reg(hw, 20736U, fcrxctl);
    } else {

    }
  } else {

  }
#line 312
  if ((unsigned int )hw->mac.type == 4U) {
#line 315
    ixgbe_write_reg(hw, (u32 )(((int )xid + 8192) * 16), (u32 )ddp->udp);
#line 317
    ixgbe_write_reg(hw, (u32 )((int )xid * 16 + 131076), (u32 )(ddp->udp >> 32));
#line 318
    ixgbe_write_reg(hw, (u32 )((int )xid * 16 + 131080), fcbuff);
#line 319
    ixgbe_write_reg(hw, (u32 )((int )xid * 16 + 131084), fcdmarw);
#line 321
    ixgbe_write_reg(hw, (u32 )(((int )xid + 10240) * 16), 1U);
#line 322
    ixgbe_write_reg(hw, (u32 )((int )xid * 16 + 163844), 0U);
#line 323
    ixgbe_write_reg(hw, (u32 )((int )xid * 16 + 163852), fcfltrw);
  } else {
#line 326
    spin_lock_bh(& fcoe->lock);
#line 328
    ixgbe_write_reg(hw, 9232U, (u32 )ddp->udp);
#line 329
    ixgbe_write_reg(hw, 9236U, (u32 )(ddp->udp >> 32));
#line 330
    ixgbe_write_reg(hw, 9240U, fcbuff);
#line 331
    ixgbe_write_reg(hw, 9248U, fcdmarw);
#line 333
    ixgbe_write_reg(hw, 20952U, 0U);
#line 334
    ixgbe_write_reg(hw, 20744U, 1U);
#line 335
    ixgbe_write_reg(hw, 20752U, fcfltrw);
#line 337
    spin_unlock_bh(& fcoe->lock);
  }
#line 340
  return (1);
  out_noddp_free: 
#line 343
  dma_pool_free(ddp->pool, (void *)ddp->udl, ddp->udp);
#line 344
  ixgbe_fcoe_clear_ddp(ddp);
  out_noddp_unmap: 
#line 347
  dma_unmap_sg_attrs(& (adapter->pdev)->dev, sgl, (int )sgc, 2, (struct dma_attrs *)0);
  out_noddp: 
#line 349
  __asm__  volatile   ("": : : "memory");
#line 349
  __preempt_count_sub(1);
#line 350
  return (0);
}
}
#line 367 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_ddp_get(struct net_device *netdev , u16 xid , struct scatterlist *sgl ,
                       unsigned int sgc ) 
{ 
  int tmp ;

  {
#line 370
  tmp = ixgbe_fcoe_ddp_setup(netdev, (int )xid, sgl, sgc, 0);
#line 370
  return (tmp);
}
}
#line 388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_ddp_target(struct net_device *netdev , u16 xid , struct scatterlist *sgl ,
                          unsigned int sgc ) 
{ 
  int tmp ;

  {
#line 391
  tmp = ixgbe_fcoe_ddp_setup(netdev, (int )xid, sgl, sgc, 1);
#line 391
  return (tmp);
}
}
#line 406 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter , union ixgbe_adv_rx_desc *rx_desc ,
                   struct sk_buff *skb ) 
{ 
  int rc ;
  struct ixgbe_fcoe *fcoe ;
  struct ixgbe_fcoe_ddp *ddp ;
  struct fc_frame_header *fh ;
  struct fcoe_crc_eof *crc ;
  __le32 fcerr ;
  __le32 tmp ;
  __le32 ddp_err ;
  int ddp_max ;
  u32 fctl ;
  u16 xid ;
  struct ethhdr *tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  __le32 tmp___3 ;
  unsigned char *tmp___4 ;

  {
#line 410
  rc = -22;
#line 415
  tmp = ixgbe_test_staterr(rx_desc, 7340032U);
#line 415
  fcerr = tmp;
#line 421
  if (fcerr == 1048576U) {
#line 422
    skb->ip_summed = 0U;
  } else {
#line 424
    skb->ip_summed = 1U;
  }
#line 426
  tmp___0 = eth_hdr((struct sk_buff  const  *)skb);
#line 426
  if ((unsigned int )tmp___0->h_proto == 129U) {
#line 427
    fh = (struct fc_frame_header *)skb->data + 18U;
  } else {
#line 430
    fh = (struct fc_frame_header *)skb->data + 14U;
  }
#line 433
  fctl = ntoh24((u8 const   *)(& fh->fh_f_ctl));
#line 434
  if ((fctl & 8388608U) != 0U) {
#line 435
    tmp___1 = __fswab16((int )fh->fh_ox_id);
#line 435
    xid = tmp___1;
  } else {
#line 437
    tmp___2 = __fswab16((int )fh->fh_rx_id);
#line 437
    xid = tmp___2;
  }
#line 439
  ddp_max = 512;
#line 441
  if ((unsigned int )adapter->hw.mac.type == 4U) {
#line 442
    ddp_max = 2048;
  } else {

  }
#line 443
  if ((int )xid >= ddp_max) {
#line 444
    return (-22);
  } else {

  }
#line 446
  fcoe = & adapter->fcoe;
#line 447
  ddp = (struct ixgbe_fcoe_ddp *)(& fcoe->ddp) + (unsigned long )xid;
#line 448
  if ((unsigned long )ddp->udl == (unsigned long )((u64 *)0ULL)) {
#line 449
    return (-22);
  } else {

  }
#line 451
  ddp_err = ixgbe_test_staterr(rx_desc, 2154823680U);
#line 453
  if (ddp_err != 0U) {
#line 454
    return (-22);
  } else {

  }
#line 456
  tmp___3 = ixgbe_test_staterr(rx_desc, 48U);
#line 456
  switch (tmp___3) {
  case 48U: 
#line 460
  ddp->len = (int )rx_desc->wb.lower.hi_dword.rss;
#line 461
  rc = 0;
#line 462
  goto ldv_60798;
  case 32U: 
#line 465
  dma_unmap_sg_attrs(& (adapter->pdev)->dev, ddp->sgl, (int )ddp->sgc, 2, (struct dma_attrs *)0);
#line 467
  ddp->err = ddp_err;
#line 468
  ddp->sgl = (struct scatterlist *)0;
#line 469
  ddp->sgc = 0U;
  case 16U: 
#line 474
  ddp->len = (int )rx_desc->wb.lower.hi_dword.rss;
#line 475
  if (ddp->len != 0) {
#line 476
    rc = ddp->len;
  } else {

  }
#line 477
  goto ldv_60798;
  case 0U: ;
  default: ;
#line 481
  goto ldv_60798;
  }
  ldv_60798: ;
#line 491
  if ((unsigned int )fh->fh_r_ctl == 1U && (fctl & 524288U) != 0U) {
#line 493
    skb_linearize(skb);
#line 494
    tmp___4 = skb_put(skb, 8U);
#line 494
    crc = (struct fcoe_crc_eof *)tmp___4;
#line 495
    crc->fcoe_eof = 66U;
  } else {

  }
#line 498
  return (rc);
}
}
#line 511 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fso(struct ixgbe_ring *tx_ring , struct ixgbe_tx_buffer *first , u8 *hdr_len ) 
{ 
  struct sk_buff *skb ;
  struct fc_frame_header *fh ;
  u32 vlan_macip_lens ;
  u32 fcoe_sof_eof ;
  u32 mss_l4len_idx ;
  u8 sof ;
  u8 eof ;
  unsigned char *tmp ;
  bool tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  bool tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  bool tmp___8 ;
  unsigned char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 515
  skb = first->skb;
#line 518
  fcoe_sof_eof = 0U;
#line 522
  tmp___0 = skb_is_gso((struct sk_buff  const  *)skb);
#line 522
  if ((int )tmp___0) {
#line 522
    tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 522
    if ((unsigned int )((struct skb_shared_info *)tmp___1)->gso_type != 32U) {
#line 523
      tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 523
      dev_err((struct device  const  *)tx_ring->dev, "Wrong gso type %d:expecting SKB_GSO_FCOE\n",
              (int )((struct skb_shared_info *)tmp)->gso_type);
#line 525
      return (-22);
    } else {

    }
  } else {

  }
#line 529
  skb_set_network_header(skb, (int const   )skb->mac_len);
#line 530
  skb_set_transport_header(skb, (int const   )((unsigned int )skb->mac_len + 14U));
#line 534
  tmp___2 = skb_network_header((struct sk_buff  const  *)skb);
#line 534
  sof = ((struct fcoe_hdr *)tmp___2)->fcoe_sof;
#line 535
  switch ((int )sof) {
  case 45: 
#line 537
  fcoe_sof_eof = 32768U;
#line 538
  goto ldv_60816;
  case 46: 
#line 540
  fcoe_sof_eof = 36864U;
#line 542
  goto ldv_60816;
  case 53: ;
#line 544
  goto ldv_60816;
  case 54: 
#line 546
  fcoe_sof_eof = 4096U;
#line 547
  goto ldv_60816;
  default: 
#line 549
  dev_warn((struct device  const  *)tx_ring->dev, "unknown sof = 0x%x\n", (int )sof);
#line 550
  return (-22);
  }
  ldv_60816: 
#line 554
  skb_copy_bits((struct sk_buff  const  *)skb, (int )(skb->len - 4U), (void *)(& eof),
                1);
#line 556
  switch ((int )eof) {
  case 65: 
#line 558
  fcoe_sof_eof = fcoe_sof_eof;
#line 559
  goto ldv_60822;
  case 66: 
#line 562
  tmp___3 = skb_is_gso((struct sk_buff  const  *)skb);
#line 562
  if ((int )tmp___3) {
#line 563
    fcoe_sof_eof = fcoe_sof_eof | 16384U;
  } else {
#line 566
    fcoe_sof_eof = fcoe_sof_eof | 1024U;
  }
#line 567
  goto ldv_60822;
  case 73: 
#line 569
  fcoe_sof_eof = fcoe_sof_eof | 2048U;
#line 570
  goto ldv_60822;
  case 80: 
#line 572
  fcoe_sof_eof = fcoe_sof_eof | 3072U;
#line 573
  goto ldv_60822;
  default: 
#line 575
  dev_warn((struct device  const  *)tx_ring->dev, "unknown eof = 0x%x\n", (int )eof);
#line 576
  return (-22);
  }
  ldv_60822: 
#line 580
  tmp___4 = skb_transport_header((struct sk_buff  const  *)skb);
#line 580
  fh = (struct fc_frame_header *)tmp___4;
#line 581
  if (((int )fh->fh_f_ctl[2] & 8) != 0) {
#line 582
    fcoe_sof_eof = fcoe_sof_eof | 8192U;
  } else {

  }
#line 585
  *hdr_len = 8U;
#line 588
  tmp___8 = skb_is_gso((struct sk_buff  const  *)skb);
#line 588
  if ((int )tmp___8) {
#line 589
    tmp___5 = skb_transport_offset((struct sk_buff  const  *)skb);
#line 589
    *hdr_len = (unsigned int )((int )*hdr_len + (int )((u8 )tmp___5)) + 24U;
#line 592
    tmp___6 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 592
    tmp___7 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 592
    first->gso_segs = (unsigned short )((((skb->len - (unsigned int )*hdr_len) + (unsigned int )((struct skb_shared_info *)tmp___6)->gso_size) - 1U) / (unsigned int )((struct skb_shared_info *)tmp___7)->gso_size);
#line 594
    first->bytecount = first->bytecount + (unsigned int )(((int )first->gso_segs + -1) * (int )*hdr_len);
#line 595
    first->tx_flags = first->tx_flags | 2U;
  } else {

  }
#line 599
  first->tx_flags = first->tx_flags | 136U;
#line 602
  tmp___9 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 602
  mss_l4len_idx = (u32 )((int )((struct skb_shared_info *)tmp___9)->gso_size << 16);
#line 605
  tmp___10 = skb_transport_offset((struct sk_buff  const  *)skb);
#line 605
  vlan_macip_lens = (u32 )tmp___10 + 24U;
#line 607
  tmp___11 = skb_transport_offset((struct sk_buff  const  *)skb);
#line 607
  vlan_macip_lens = (u32 )((tmp___11 + -4) << 9) | vlan_macip_lens;
#line 609
  vlan_macip_lens = (first->tx_flags & 4294901760U) | vlan_macip_lens;
#line 612
  ixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, fcoe_sof_eof, 32768U, mss_l4len_idx);
#line 615
  return (0);
}
}
#line 618 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static void ixgbe_fcoe_dma_pool_free(struct ixgbe_fcoe *fcoe , unsigned int cpu ) 
{ 
  struct ixgbe_fcoe_ddp_pool *ddp_pool ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;

  {
#line 622
  __vpp_verify = (void const   *)0;
#line 622
  __asm__  ("": "=r" (__ptr): "0" (fcoe->ddp_pool));
#line 622
  ddp_pool = (struct ixgbe_fcoe_ddp_pool *)(__per_cpu_offset[cpu] + __ptr);
#line 623
  if ((unsigned long )ddp_pool->pool != (unsigned long )((struct dma_pool *)0)) {
#line 624
    dma_pool_destroy(ddp_pool->pool);
  } else {

  }
#line 625
  ddp_pool->pool = (struct dma_pool *)0;
#line 626
  return;
}
}
#line 628 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static int ixgbe_fcoe_dma_pool_alloc(struct ixgbe_fcoe *fcoe , struct device *dev ,
                                     unsigned int cpu ) 
{ 
  struct ixgbe_fcoe_ddp_pool *ddp_pool ;
  struct dma_pool *pool ;
  char pool_name[32U] ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;

  {
#line 636
  snprintf((char *)(& pool_name), 32UL, "ixgbe_fcoe_ddp_%u", cpu);
#line 638
  pool = dma_pool_create((char const   *)(& pool_name), dev, 2048UL, 16UL, 4096UL);
#line 640
  if ((unsigned long )pool == (unsigned long )((struct dma_pool *)0)) {
#line 641
    return (-12);
  } else {

  }
#line 643
  __vpp_verify = (void const   *)0;
#line 643
  __asm__  ("": "=r" (__ptr): "0" (fcoe->ddp_pool));
#line 643
  ddp_pool = (struct ixgbe_fcoe_ddp_pool *)(__per_cpu_offset[cpu] + __ptr);
#line 644
  ddp_pool->pool = pool;
#line 645
  ddp_pool->noddp = 0ULL;
#line 646
  ddp_pool->noddp_ext_buff = 0ULL;
#line 648
  return (0);
}
}
#line 659 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
void ixgbe_configure_fcoe(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_ring_feature *fcoe ;
  struct ixgbe_hw *hw ;
  int i ;
  int fcoe_q ;
  int fcoe_i ;
  int fcoe_q_h ;
  int fcreta_size ;
  u32 etqf ;
  int fcoe_i_h ;

  {
#line 661
  fcoe = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 662
  hw = & adapter->hw;
#line 663
  fcoe_q_h = 0;
#line 668
  if (((adapter->netdev)->features & 536870912ULL) == 0ULL) {
#line 669
    return;
  } else {

  }
#line 672
  etqf = 2281736454U;
#line 673
  if ((adapter->flags & 8388608U) != 0U) {
#line 674
    etqf = etqf | 67108864U;
#line 675
    etqf = (u32 )((int )adapter->ring_feature[1].offset << 20) | etqf;
  } else {

  }
#line 677
  ixgbe_write_reg(hw, 20784U, etqf);
#line 678
  ixgbe_write_reg(hw, 60424U, 0U);
#line 681
  if ((adapter->flags & 2097152U) == 0U) {
#line 682
    return;
  } else {

  }
#line 685
  fcreta_size = 8;
#line 686
  if ((unsigned int )adapter->hw.mac.type == 4U) {
#line 687
    fcreta_size = 32;
  } else {

  }
#line 689
  i = 0;
#line 689
  goto ldv_60861;
  ldv_60860: ;
#line 690
  if ((unsigned int )adapter->hw.mac.type == 4U) {
#line 691
    fcoe_i_h = (int )fcoe->offset + (i + fcreta_size) % (int )fcoe->indices;
#line 693
    fcoe_q_h = (int )(adapter->rx_ring[fcoe_i_h])->reg_idx;
#line 694
    fcoe_q_h = (fcoe_q_h << 16) & 8323072;
  } else {

  }
#line 698
  fcoe_i = (int )fcoe->offset + i % (int )fcoe->indices;
#line 699
  fcoe_i = fcoe_i & 127;
#line 700
  fcoe_q = (int )(adapter->rx_ring[fcoe_i])->reg_idx;
#line 701
  fcoe_q = fcoe_q | fcoe_q_h;
#line 702
  ixgbe_write_reg(hw, (u32 )((i + 15172) * 4), (u32 )fcoe_q);
#line 689
  i = i + 1;
  ldv_60861: ;
#line 689
  if (i < fcreta_size) {
#line 691
    goto ldv_60860;
  } else {

  }
#line 704
  ixgbe_write_reg(hw, 60672U, 1U);
#line 707
  etqf = 2147518740U;
#line 708
  if ((adapter->flags & 8388608U) != 0U) {
#line 709
    etqf = etqf | 67108864U;
#line 710
    etqf = (u32 )((int )adapter->ring_feature[1].offset << 20) | etqf;
  } else {

  }
#line 712
  ixgbe_write_reg(hw, 20792U, etqf);
#line 715
  fcoe_q = (int )(adapter->rx_ring[(int )fcoe->offset])->reg_idx;
#line 716
  ixgbe_write_reg(hw, 60432U, (unsigned int )(fcoe_q << 16) | 2147483648U);
#line 721
  ixgbe_write_reg(hw, 20736U, 128U);
#line 722
  return;
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
void ixgbe_free_fcoe_ddp_resources(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_fcoe *fcoe ;
  int cpu ;
  int i ;
  int ddp_max ;
  unsigned int tmp ;

  {
#line 736
  fcoe = & adapter->fcoe;
#line 740
  if ((unsigned long )fcoe->ddp_pool == (unsigned long )((struct ixgbe_fcoe_ddp_pool *)0)) {
#line 741
    return;
  } else {

  }
#line 743
  ddp_max = 512;
#line 745
  if ((unsigned int )adapter->hw.mac.type == 4U) {
#line 746
    ddp_max = 2048;
  } else {

  }
#line 748
  i = 0;
#line 748
  goto ldv_60871;
  ldv_60870: 
#line 749
  ixgbe_fcoe_ddp_put(adapter->netdev, (int )((u16 )i));
#line 748
  i = i + 1;
  ldv_60871: ;
#line 748
  if (i < ddp_max) {
#line 750
    goto ldv_60870;
  } else {

  }
#line 751
  cpu = -1;
#line 751
  goto ldv_60874;
  ldv_60873: 
#line 752
  ixgbe_fcoe_dma_pool_free(fcoe, (unsigned int )cpu);
  ldv_60874: 
#line 751
  tmp = cpumask_next___0(cpu, cpu_possible_mask);
#line 751
  cpu = (int )tmp;
#line 751
  if (cpu < nr_cpu_ids) {
#line 753
    goto ldv_60873;
  } else {

  }
#line 754
  dma_unmap_single_attrs___0(& (adapter->pdev)->dev, fcoe->extra_ddp_buffer_dma, 4096UL,
                             2, (struct dma_attrs *)0);
#line 758
  kfree((void const   *)fcoe->extra_ddp_buffer);
#line 760
  fcoe->extra_ddp_buffer = (void *)0;
#line 761
  fcoe->extra_ddp_buffer_dma = 0ULL;
#line 762
  return;
}
}
#line 772 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_setup_fcoe_ddp_resources(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_fcoe *fcoe ;
  struct device *dev ;
  void *buffer ;
  dma_addr_t dma ;
  unsigned int cpu ;
  int tmp ;
  int err ;
  int tmp___0 ;

  {
#line 774
  fcoe = & adapter->fcoe;
#line 775
  dev = & (adapter->pdev)->dev;
#line 781
  if ((unsigned long )fcoe->ddp_pool == (unsigned long )((struct ixgbe_fcoe_ddp_pool *)0)) {
#line 782
    return (0);
  } else {

  }
#line 785
  buffer = kmalloc(4096UL, 32U);
#line 786
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 787
    return (-12);
  } else {

  }
#line 789
  dma = dma_map_single_attrs___0(dev, buffer, 4096UL, 2, (struct dma_attrs *)0);
#line 790
  tmp = dma_mapping_error(dev, dma);
#line 790
  if (tmp != 0) {
#line 791
    if ((int )adapter->msg_enable & 1) {
#line 791
      netdev_err((struct net_device  const  *)adapter->netdev, "failed to map extra DDP buffer\n");
    } else {

    }
#line 792
    kfree((void const   *)buffer);
#line 793
    return (-12);
  } else {

  }
#line 796
  fcoe->extra_ddp_buffer = buffer;
#line 797
  fcoe->extra_ddp_buffer_dma = dma;
#line 800
  cpu = 4294967295U;
#line 800
  goto ldv_60885;
  ldv_60886: 
#line 801
  tmp___0 = ixgbe_fcoe_dma_pool_alloc(fcoe, dev, cpu);
#line 801
  err = tmp___0;
#line 802
  if (err == 0) {
#line 803
    goto ldv_60885;
  } else {

  }
#line 805
  if ((int )adapter->msg_enable & 1) {
#line 805
    netdev_err((struct net_device  const  *)adapter->netdev, "failed to alloc DDP pool on cpu:%d\n",
               cpu);
  } else {

  }
#line 806
  ixgbe_free_fcoe_ddp_resources(adapter);
#line 807
  return (-12);
  ldv_60885: 
#line 800
  cpu = cpumask_next___0((int )cpu, cpu_possible_mask);
#line 800
  if ((unsigned int )nr_cpu_ids > cpu) {
#line 802
    goto ldv_60886;
  } else {

  }

#line 810
  return (0);
}
}
#line 813 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static int ixgbe_fcoe_ddp_enable(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_fcoe *fcoe ;
  void *tmp ;

  {
#line 815
  fcoe = & adapter->fcoe;
#line 817
  if ((adapter->flags & 1048576U) == 0U) {
#line 818
    return (-22);
  } else {

  }
#line 820
  tmp = __alloc_percpu(24UL, 8UL);
#line 820
  fcoe->ddp_pool = (struct ixgbe_fcoe_ddp_pool *)tmp;
#line 822
  if ((unsigned long )fcoe->ddp_pool == (unsigned long )((struct ixgbe_fcoe_ddp_pool *)0)) {
#line 823
    if ((int )adapter->msg_enable & 1) {
#line 823
      netdev_err((struct net_device  const  *)adapter->netdev, "failed to allocate percpu DDP resources\n");
    } else {

    }
#line 824
    return (-12);
  } else {

  }
#line 827
  (adapter->netdev)->fcoe_ddp_xid = 511U;
#line 829
  if ((unsigned int )adapter->hw.mac.type == 4U) {
#line 830
    (adapter->netdev)->fcoe_ddp_xid = 2047U;
  } else {

  }
#line 832
  return (0);
}
}
#line 835 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static void ixgbe_fcoe_ddp_disable(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_fcoe *fcoe ;

  {
#line 837
  fcoe = & adapter->fcoe;
#line 839
  (adapter->netdev)->fcoe_ddp_xid = 0U;
#line 841
  if ((unsigned long )fcoe->ddp_pool == (unsigned long )((struct ixgbe_fcoe_ddp_pool *)0)) {
#line 842
    return;
  } else {

  }
#line 844
  free_percpu((void *)fcoe->ddp_pool);
#line 845
  fcoe->ddp_pool = (struct ixgbe_fcoe_ddp_pool *)0;
#line 846
  return;
}
}
#line 856 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_enable(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_fcoe *fcoe ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 858
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 858
  adapter = (struct ixgbe_adapter *)tmp;
#line 859
  fcoe = & adapter->fcoe;
#line 861
  atomic_inc(& fcoe->refcnt);
#line 863
  if ((adapter->flags & 1048576U) == 0U) {
#line 864
    return (-22);
  } else {

  }
#line 866
  if ((adapter->flags & 2097152U) != 0U) {
#line 867
    return (-22);
  } else {

  }
#line 869
  if ((int )adapter->msg_enable & 1) {
#line 869
    netdev_info((struct net_device  const  *)adapter->netdev, "Enabling FCoE offload features.\n");
  } else {

  }
#line 871
  if ((adapter->flags & 8388608U) != 0U) {
#line 872
    if (((int )adapter->msg_enable & 2) != 0) {
#line 872
      netdev_warn((struct net_device  const  *)adapter->netdev, "Enabling FCoE on PF will disable legacy VFs\n");
    } else {

    }
  } else {

  }
#line 874
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 874
  if ((int )tmp___0) {
#line 875
    (*((netdev->netdev_ops)->ndo_stop))(netdev);
  } else {

  }
#line 878
  ixgbe_fcoe_ddp_enable(adapter);
#line 881
  adapter->flags = adapter->flags | 2097152U;
#line 882
  netdev->features = netdev->features | 2147483648ULL;
#line 883
  netdev_features_change(netdev);
#line 886
  ixgbe_clear_interrupt_scheme(adapter);
#line 887
  ixgbe_init_interrupt_scheme(adapter);
#line 889
  tmp___1 = netif_running((struct net_device  const  *)netdev);
#line 889
  if ((int )tmp___1) {
#line 890
    (*((netdev->netdev_ops)->ndo_open))(netdev);
  } else {

  }
#line 892
  return (0);
}
}
#line 903 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_disable(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
#line 905
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 905
  adapter = (struct ixgbe_adapter *)tmp;
#line 907
  tmp___0 = atomic_dec_and_test(& adapter->fcoe.refcnt);
#line 907
  if (tmp___0 == 0) {
#line 908
    return (-22);
  } else {

  }
#line 910
  if ((adapter->flags & 2097152U) == 0U) {
#line 911
    return (-22);
  } else {

  }
#line 913
  if ((int )adapter->msg_enable & 1) {
#line 913
    netdev_info((struct net_device  const  *)adapter->netdev, "Disabling FCoE offload features.\n");
  } else {

  }
#line 914
  tmp___1 = netif_running((struct net_device  const  *)netdev);
#line 914
  if ((int )tmp___1) {
#line 915
    (*((netdev->netdev_ops)->ndo_stop))(netdev);
  } else {

  }
#line 918
  ixgbe_fcoe_ddp_disable(adapter);
#line 921
  adapter->flags = adapter->flags & 4292870143U;
#line 922
  netdev->features = netdev->features & 0xffffffff7fffffffULL;
#line 924
  netdev_features_change(netdev);
#line 927
  ixgbe_clear_interrupt_scheme(adapter);
#line 928
  ixgbe_init_interrupt_scheme(adapter);
#line 930
  tmp___2 = netif_running((struct net_device  const  *)netdev);
#line 930
  if ((int )tmp___2) {
#line 931
    (*((netdev->netdev_ops)->ndo_open))(netdev);
  } else {

  }
#line 933
  return (0);
}
}
#line 948 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_get_wwn(struct net_device *netdev , u64 *wwn , int type ) 
{ 
  u16 prefix ;
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_mac_info *mac ;
  bool tmp___0 ;

  {
#line 950
  prefix = 65535U;
#line 951
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 951
  adapter = (struct ixgbe_adapter *)tmp;
#line 952
  mac = & adapter->hw.mac;
#line 954
  switch (type) {
  case 0: 
#line 956
  prefix = mac->wwnn_prefix;
#line 957
  goto ldv_60914;
  case 1: 
#line 959
  prefix = mac->wwpn_prefix;
#line 960
  goto ldv_60914;
  default: ;
#line 962
  goto ldv_60914;
  }
  ldv_60914: ;
#line 965
  if ((unsigned int )prefix != 65535U) {
#line 965
    tmp___0 = is_valid_ether_addr((u8 const   *)(& mac->san_addr));
#line 965
    if ((int )tmp___0) {
#line 967
      *wwn = (((((((unsigned long long )prefix << 48) | ((unsigned long long )mac->san_addr[0] << 40)) | ((unsigned long long )mac->san_addr[1] << 32)) | ((unsigned long long )mac->san_addr[2] << 24)) | ((unsigned long long )mac->san_addr[3] << 16)) | ((unsigned long long )mac->san_addr[4] << 8)) | (unsigned long long )mac->san_addr[5];
#line 974
      return (0);
    } else {

    }
  } else {

  }
#line 976
  return (-22);
}
}
#line 988 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_get_hbainfo(struct net_device *netdev , struct netdev_fcoe_hbainfo *info ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  int i ;
  int pos ;
  u8 buf[8U] ;

  {
#line 991
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 991
  adapter = (struct ixgbe_adapter *)tmp;
#line 992
  hw = & adapter->hw;
#line 996
  if ((unsigned long )info == (unsigned long )((struct netdev_fcoe_hbainfo *)0)) {
#line 997
    return (-22);
  } else {

  }
#line 1000
  if ((unsigned int )hw->mac.type != 2U && (unsigned int )hw->mac.type != 3U) {
#line 1002
    return (-22);
  } else {

  }
#line 1005
  snprintf((char *)(& info->manufacturer), 64UL, "Intel Corporation");
#line 1011
  pos = pci_find_ext_capability(adapter->pdev, 3);
#line 1012
  if (pos != 0) {
#line 1013
    pos = pos + 4;
#line 1014
    i = 0;
#line 1014
    goto ldv_60927;
    ldv_60926: 
#line 1015
    pci_read_config_byte((struct pci_dev  const  *)adapter->pdev, pos + i, (u8 *)(& buf) + (unsigned long )i);
#line 1014
    i = i + 1;
    ldv_60927: ;
#line 1014
    if (i <= 7) {
#line 1016
      goto ldv_60926;
    } else {

    }
#line 1017
    snprintf((char *)(& info->serial_number), 64UL, "%02X%02X%02X%02X%02X%02X%02X%02X",
             (int )buf[7], (int )buf[6], (int )buf[5], (int )buf[4], (int )buf[3],
             (int )buf[2], (int )buf[1], (int )buf[0]);
  } else {
#line 1022
    snprintf((char *)(& info->serial_number), 64UL, "Unknown");
  }
#line 1026
  snprintf((char *)(& info->hardware_version), 64UL, "Rev %d", (int )hw->revision_id);
#line 1030
  snprintf((char *)(& info->driver_version), 64UL, "%s v%s", (char *)(& ixgbe_driver_name),
           (char const   *)(& ixgbe_driver_version));
#line 1036
  snprintf((char *)(& info->firmware_version), 64UL, "0x%08x", ((int )adapter->eeprom_verh << 16) | (int )adapter->eeprom_verl);
#line 1043
  if ((unsigned int )hw->mac.type == 2U) {
#line 1044
    snprintf((char *)(& info->model), 256UL, "Intel 82599");
  } else {
#line 1048
    snprintf((char *)(& info->model), 256UL, "Intel X540");
  }
#line 1054
  snprintf((char *)(& info->model_description), 256UL, "%s", (char *)(& ixgbe_default_device_descr));
#line 1059
  return (0);
}
}
#line 1068 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
u8 ixgbe_fcoe_get_tc(struct ixgbe_adapter *adapter ) 
{ 
  int tmp ;

  {
#line 1071
  tmp = netdev_get_prio_tc_map((struct net_device  const  *)adapter->netdev, (u32 )adapter->fcoe.up);
#line 1071
  return ((u8 )tmp);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.o.c.prepared"
bool ldv_queue_work_on_557(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 359
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 359
  ldv_func_res = tmp;
#line 361
  activate_work_9(ldv_func_arg3, 2);
#line 363
  return (ldv_func_res);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.o.c.prepared"
bool ldv_queue_delayed_work_on_558(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 370
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 370
  ldv_func_res = tmp;
#line 372
  activate_work_9(& ldv_func_arg3->work, 2);
#line 374
  return (ldv_func_res);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.o.c.prepared"
bool ldv_queue_work_on_559(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 381
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 381
  ldv_func_res = tmp;
#line 383
  activate_work_9(ldv_func_arg3, 2);
#line 385
  return (ldv_func_res);
}
}
#line 388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.o.c.prepared"
void ldv_flush_workqueue_560(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 391
  flush_workqueue(ldv_func_arg1);
#line 393
  call_and_disable_all_9(2);
#line 394
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.o.c.prepared"
bool ldv_queue_delayed_work_on_561(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 400
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 400
  ldv_func_res = tmp;
#line 402
  activate_work_9(& ldv_func_arg3->work, 2);
#line 404
  return (ldv_func_res);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.o.c.prepared"
void ldv_mutex_lock_562(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 410
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 412
  mutex_lock(ldv_func_arg1);
#line 413
  return;
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.o.c.prepared"
void ldv_mutex_unlock_563(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 418
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 420
  mutex_unlock(ldv_func_arg1);
#line 421
  return;
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.o.c.prepared"
void ldv_mutex_lock_564(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 426
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 428
  mutex_lock(ldv_func_arg1);
#line 429
  return;
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.o.c.prepared"
int ldv_mutex_trylock_565(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 435
  tmp = mutex_trylock(ldv_func_arg1);
#line 435
  ldv_func_res = tmp;
#line 437
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 437
  return (tmp___0);
#line 439
  return (ldv_func_res);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.o.c.prepared"
void ldv_mutex_unlock_566(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 445
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 447
  mutex_unlock(ldv_func_arg1);
#line 448
  return;
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.o.c.prepared"
void ldv_mutex_unlock_567(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 453
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 455
  mutex_unlock(ldv_func_arg1);
#line 456
  return;
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.o.c.prepared"
void ldv_mutex_lock_568(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 461
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 463
  mutex_lock(ldv_func_arg1);
#line 464
  return;
}
}
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
#line 34
  tmp = ldv_undef_int();
#line 34
  ret = tmp;
#line 36
  if (ret >= 0) {
#line 36
    ldv_stop();
  } else {

  }
#line 38
  return (ret);
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 8 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_i_mutex_of_inode  =    1;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 16
    ldv_error();
  } else {

  }
#line 19
  nondetermined = ldv_undef_int();
#line 22
  if (nondetermined != 0) {
#line 25
    ldv_mutex_i_mutex_of_inode = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 42
    ldv_error();
  } else {

  }
#line 45
  nondetermined = ldv_undef_int();
#line 48
  if (nondetermined != 0) {
#line 51
    ldv_mutex_i_mutex_of_inode = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 66
    ldv_error();
  } else {

  }
#line 68
  ldv_mutex_i_mutex_of_inode = 2;
#line 69
  return;
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 77
    ldv_error();
  } else {

  }
#line 80
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 83
  if (is_mutex_held_by_another_thread != 0) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_i_mutex_of_inode = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 103
    ldv_error();
  } else {

  }
#line 106
  atomic_value_after_dec = ldv_undef_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_i_mutex_of_inode = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_i_mutex_of_inode == 1) {
#line 130
    nondetermined = ldv_undef_int();
#line 133
    if (nondetermined != 0) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_i_mutex_of_inode != 2) {
#line 155
    ldv_error();
  } else {

  }
#line 157
  ldv_mutex_i_mutex_of_inode = 1;
#line 158
  return;
}
}
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_i_mutex_of_inode(void) 
{ 


  {
#line 166
  ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 167
  return;
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_i_mutex_of_inode(void) 
{ 
  int tmp ;

  {
#line 172
  tmp = ldv_mutex_trylock_i_mutex_of_inode((struct mutex *)0);
#line 172
  return (tmp);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_i_mutex_of_inode(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 178
  tmp___0 = ldv_undef_int();
#line 178
  if (tmp___0 != 0) {
#line 180
    ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 182
    return (0);
  } else {
#line 185
    tmp = ldv_undef_int_negative();
#line 185
    return (tmp);
  }
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_i_mutex_of_inode(void) 
{ 


  {
#line 191
  ldv_mutex_unlock_i_mutex_of_inode((struct mutex *)0);
#line 192
  return;
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  =    1;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 202
  if (ldv_mutex_lock != 1) {
#line 202
    ldv_error();
  } else {

  }
#line 205
  nondetermined = ldv_undef_int();
#line 208
  if (nondetermined != 0) {
#line 211
    ldv_mutex_lock = 2;
#line 213
    return (0);
  } else {
#line 218
    return (-4);
  }
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 228
  if (ldv_mutex_lock != 1) {
#line 228
    ldv_error();
  } else {

  }
#line 231
  nondetermined = ldv_undef_int();
#line 234
  if (nondetermined != 0) {
#line 237
    ldv_mutex_lock = 2;
#line 239
    return (0);
  } else {
#line 244
    return (-4);
  }
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 252
  if (ldv_mutex_lock != 1) {
#line 252
    ldv_error();
  } else {

  }
#line 254
  ldv_mutex_lock = 2;
#line 255
  return;
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 263
  if (ldv_mutex_lock != 1) {
#line 263
    ldv_error();
  } else {

  }
#line 266
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 269
  if (is_mutex_held_by_another_thread != 0) {
#line 272
    return (0);
  } else {
#line 277
    ldv_mutex_lock = 2;
#line 279
    return (1);
  }
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 289
  if (ldv_mutex_lock != 1) {
#line 289
    ldv_error();
  } else {

  }
#line 292
  atomic_value_after_dec = ldv_undef_int();
#line 295
  if (atomic_value_after_dec == 0) {
#line 298
    ldv_mutex_lock = 2;
#line 300
    return (1);
  } else {

  }
#line 304
  return (0);
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 313
  if (ldv_mutex_lock == 1) {
#line 316
    nondetermined = ldv_undef_int();
#line 319
    if (nondetermined != 0) {
#line 322
      return (0);
    } else {
#line 327
      return (1);
    }
  } else {
#line 333
    return (1);
  }
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 341
  if (ldv_mutex_lock != 2) {
#line 341
    ldv_error();
  } else {

  }
#line 343
  ldv_mutex_lock = 1;
#line 344
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_lock(void) 
{ 


  {
#line 352
  ldv_mutex_lock_lock((struct mutex *)0);
#line 353
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_lock(void) 
{ 
  int tmp ;

  {
#line 358
  tmp = ldv_mutex_trylock_lock((struct mutex *)0);
#line 358
  return (tmp);
}
}
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_lock(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 364
  tmp___0 = ldv_undef_int();
#line 364
  if (tmp___0 != 0) {
#line 366
    ldv_mutex_lock_lock((struct mutex *)0);
#line 368
    return (0);
  } else {
#line 371
    tmp = ldv_undef_int_negative();
#line 371
    return (tmp);
  }
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_lock(void) 
{ 


  {
#line 377
  ldv_mutex_unlock_lock((struct mutex *)0);
#line 378
  return;
}
}
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_device  =    1;
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 388
  if (ldv_mutex_mutex_of_device != 1) {
#line 388
    ldv_error();
  } else {

  }
#line 391
  nondetermined = ldv_undef_int();
#line 394
  if (nondetermined != 0) {
#line 397
    ldv_mutex_mutex_of_device = 2;
#line 399
    return (0);
  } else {
#line 404
    return (-4);
  }
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 414
  if (ldv_mutex_mutex_of_device != 1) {
#line 414
    ldv_error();
  } else {

  }
#line 417
  nondetermined = ldv_undef_int();
#line 420
  if (nondetermined != 0) {
#line 423
    ldv_mutex_mutex_of_device = 2;
#line 425
    return (0);
  } else {
#line 430
    return (-4);
  }
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 438
  if (ldv_mutex_mutex_of_device != 1) {
#line 438
    ldv_error();
  } else {

  }
#line 440
  ldv_mutex_mutex_of_device = 2;
#line 441
  return;
}
}
#line 444 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 449
  if (ldv_mutex_mutex_of_device != 1) {
#line 449
    ldv_error();
  } else {

  }
#line 452
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 455
  if (is_mutex_held_by_another_thread != 0) {
#line 458
    return (0);
  } else {
#line 463
    ldv_mutex_mutex_of_device = 2;
#line 465
    return (1);
  }
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 475
  if (ldv_mutex_mutex_of_device != 1) {
#line 475
    ldv_error();
  } else {

  }
#line 478
  atomic_value_after_dec = ldv_undef_int();
#line 481
  if (atomic_value_after_dec == 0) {
#line 484
    ldv_mutex_mutex_of_device = 2;
#line 486
    return (1);
  } else {

  }
#line 490
  return (0);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 499
  if (ldv_mutex_mutex_of_device == 1) {
#line 502
    nondetermined = ldv_undef_int();
#line 505
    if (nondetermined != 0) {
#line 508
      return (0);
    } else {
#line 513
      return (1);
    }
  } else {
#line 519
    return (1);
  }
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 527
  if (ldv_mutex_mutex_of_device != 2) {
#line 527
    ldv_error();
  } else {

  }
#line 529
  ldv_mutex_mutex_of_device = 1;
#line 530
  return;
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_mutex_of_device(void) 
{ 


  {
#line 538
  ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 539
  return;
}
}
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_mutex_of_device(void) 
{ 
  int tmp ;

  {
#line 544
  tmp = ldv_mutex_trylock_mutex_of_device((struct mutex *)0);
#line 544
  return (tmp);
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_mutex_of_device(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 550
  tmp___0 = ldv_undef_int();
#line 550
  if (tmp___0 != 0) {
#line 552
    ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 554
    return (0);
  } else {
#line 557
    tmp = ldv_undef_int_negative();
#line 557
    return (tmp);
  }
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_mutex_of_device(void) 
{ 


  {
#line 563
  ldv_mutex_unlock_mutex_of_device((struct mutex *)0);
#line 564
  return;
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11328/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 571
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 571
    ldv_error();
  } else {

  }
#line 573
  if (ldv_mutex_lock != 1) {
#line 573
    ldv_error();
  } else {

  }
#line 575
  if (ldv_mutex_mutex_of_device != 1) {
#line 575
    ldv_error();
  } else {

  }
#line 579
  return;
}
}
