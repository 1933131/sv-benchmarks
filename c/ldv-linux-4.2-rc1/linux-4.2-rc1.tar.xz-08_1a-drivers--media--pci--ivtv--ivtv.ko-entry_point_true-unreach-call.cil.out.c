extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 40 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 555 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 103
struct compat_timespec;
#line 104 "include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 104 "include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 104
struct pollfd;
#line 104 "include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 104 "include/linux/bug.h"
union __anonunion____missing_field_name_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};
#line 104 "include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_19 __annonCompField8 ;
};
#line 328 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_29 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField12 ;
   struct __anonstruct____missing_field_name_30 __annonCompField13 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_31 __annonCompField15 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 33 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField17 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField18 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 13 "include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_46 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_47 kgid_t;
#line 139 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct vm_area_struct;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 177
struct rw_semaphore;
#line 178 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 172 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 1121 "include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 238 "include/linux/timer.h"
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 240 "include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 838 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 64 "./arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 172 "./arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 133 "./arch/x86/include/asm/topology.h"
struct pci_bus;
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 19 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField33 ;
   struct __anonstruct____missing_field_name_149 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_152 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_156 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_154 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_151 {
   union __anonunion____missing_field_name_152 __annonCompField37 ;
   union __anonunion____missing_field_name_153 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_157 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_158 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_159 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32
struct kmem_cache;
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_160 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct __anonstruct____missing_field_name_151 __annonCompField42 ;
   union __anonunion____missing_field_name_157 __annonCompField45 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
union __anonunion____missing_field_name_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 53 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_166 __annonCompField47 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_172 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_172 __annonCompField49 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_180 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_181 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 20 "include/linux/rtmutex.h"
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct rb_root waiters ;
   struct rb_node *waiters_leftmost ;
   struct task_struct *owner ;
   int save_state ;
   char const   *name ;
   char const   *file ;
   int line ;
   void *magic ;
};
#line 40
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_197 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_199 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_199 __annonCompField52 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_198 __annonCompField53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion____missing_field_name_201 __annonCompField54 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 72 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769
struct ftrace_ret_stack;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
struct v4l2_audioout;
#line 35
struct v4l2_subdev;
#line 36
struct cx2341x_handler;
#line 38
struct i2c_adapter;
#line 54
struct v4l2_decoder_cmd;
#line 56
struct v4l2_audio;
#line 59
struct v4l2_fh;
#line 63
struct v4l2_ctrl;
#line 65
struct v4l2_ext_controls;
#line 68
struct v4l2_control;
#line 69
struct v4l2_encoder_cmd;
#line 71
struct v4l2_selection;
#line 75
struct v4l2_format;
#line 77
struct v4l2_fmtdesc;
#line 81
struct v4l2_event_subscription;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_220 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_219 {
   struct __anonstruct____missing_field_name_220 __annonCompField58 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_219 __annonCompField59 ;
};
#line 50 "include/linux/lockref.h"
struct path;
#line 51
struct vfsmount;
#line 52 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_222 {
   u32 hash ;
   u32 len ;
};
#line 52 "include/linux/lockref.h"
union __anonunion____missing_field_name_221 {
   struct __anonstruct____missing_field_name_222 __annonCompField60 ;
   u64 hash_len ;
};
#line 52 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_221 __annonCompField61 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_223 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_223 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 19 "include/linux/path.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 80 "include/linux/shrinker.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_227 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_226 {
   struct __anonstruct____missing_field_name_227 __annonCompField62 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_226 __annonCompField63 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 47
struct block_device;
#line 60 "include/uapi/linux/fs.h"
struct bdi_writeback;
#line 61
struct export_operations;
#line 64
struct kiocb;
#line 65
struct poll_table_struct;
#line 66
struct kstatfs;
#line 67
struct swap_info_struct;
#line 68
struct iov_iter;
#line 69
struct vm_fault;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_231 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_231 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_232 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_232 __annonCompField65 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526
struct writeback_control;
#line 527 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_235 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_236 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_237 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_235 __annonCompField66 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_236 __annonCompField67 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_237 __annonCompField68 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_238 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_238 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_240 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_239 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_240 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_239 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 261 "include/linux/mod_devicetable.h"
struct input_device_id {
   kernel_ulong_t flags ;
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
   kernel_ulong_t evbit[1U] ;
   kernel_ulong_t keybit[12U] ;
   kernel_ulong_t relbit[1U] ;
   kernel_ulong_t absbit[1U] ;
   kernel_ulong_t mscbit[1U] ;
   kernel_ulong_t ledbit[1U] ;
   kernel_ulong_t sndbit[1U] ;
   kernel_ulong_t ffbit[2U] ;
   kernel_ulong_t swbit[1U] ;
   kernel_ulong_t driver_info ;
};
#line 650
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 70 "include/linux/resource_ext.h"
struct hotplug_slot;
#line 70 "include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "include/linux/pci.h"
typedef int pci_power_t;
#line 137 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 190 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 247
struct pcie_link_state;
#line 248
struct pci_vpd;
#line 249
struct pci_sriov;
#line 250
struct pci_ats;
#line 251
struct proc_dir_entry;
#line 251
struct pci_driver;
#line 251 "include/linux/pci.h"
union __anonunion____missing_field_name_244 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 251 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned char ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char no_64bit_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   unsigned char irq_managed : 1 ;
   unsigned char has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_244 __annonCompField69 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 440
struct pci_ops;
#line 440
struct msi_controller;
#line 440 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 563 "include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus * , unsigned int  , int  ) ;
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 591 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 605 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 615 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 648 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 34 "./arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 672 "include/linux/interrupt.h"
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
#line 679 "include/linux/interrupt.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
#line 32 "include/linux/of.h"
typedef u32 phandle;
#line 34 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 44 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 1084 "include/linux/of.h"
struct i2c_msg {
   __u16 addr ;
   __u16 flags ;
   __u16 len ;
   __u8 *buf ;
};
#line 82 "include/uapi/linux/i2c.h"
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34U] ;
};
#line 39 "include/linux/i2c.h"
struct i2c_algorithm;
#line 40
struct i2c_client;
#line 43
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 196 "include/linux/i2c.h"
struct i2c_client {
   unsigned short flags ;
   unsigned short addr ;
   char name[20U] ;
   struct i2c_adapter *adapter ;
   struct device dev ;
   int irq ;
   struct list_head detected ;
   int (*slave_cb)(struct i2c_client * , enum i2c_slave_event  , u8 * ) ;
};
#line 251
enum i2c_slave_event {
    I2C_SLAVE_READ_REQUESTED = 0,
    I2C_SLAVE_WRITE_REQUESTED = 1,
    I2C_SLAVE_READ_PROCESSED = 2,
    I2C_SLAVE_WRITE_RECEIVED = 3,
    I2C_SLAVE_STOP = 4
} ;
#line 359 "include/linux/i2c.h"
struct i2c_algorithm {
   int (*master_xfer)(struct i2c_adapter * , struct i2c_msg * , int  ) ;
   int (*smbus_xfer)(struct i2c_adapter * , u16  , unsigned short  , char  , u8  ,
                     int  , union i2c_smbus_data * ) ;
   u32 (*functionality)(struct i2c_adapter * ) ;
   int (*reg_slave)(struct i2c_client * ) ;
   int (*unreg_slave)(struct i2c_client * ) ;
};
#line 411 "include/linux/i2c.h"
struct i2c_bus_recovery_info {
   int (*recover_bus)(struct i2c_adapter * ) ;
   int (*get_scl)(struct i2c_adapter * ) ;
   void (*set_scl)(struct i2c_adapter * , int  ) ;
   int (*get_sda)(struct i2c_adapter * ) ;
   void (*prepare_recovery)(struct i2c_adapter * ) ;
   void (*unprepare_recovery)(struct i2c_adapter * ) ;
   int scl_gpio ;
   int sda_gpio ;
};
#line 451 "include/linux/i2c.h"
struct i2c_adapter_quirks {
   u64 flags ;
   int max_num_msgs ;
   u16 max_write_len ;
   u16 max_read_len ;
   u16 max_comb_1st_msg_len ;
   u16 max_comb_2nd_msg_len ;
};
#line 481 "include/linux/i2c.h"
struct i2c_adapter {
   struct module *owner ;
   unsigned int class ;
   struct i2c_algorithm  const  *algo ;
   void *algo_data ;
   struct rt_mutex bus_lock ;
   int timeout ;
   int retries ;
   struct device dev ;
   int nr ;
   char name[48U] ;
   struct completion dev_released ;
   struct mutex userspace_clients_lock ;
   struct list_head userspace_clients ;
   struct i2c_bus_recovery_info *bus_recovery_info ;
   struct i2c_adapter_quirks  const  *quirks ;
};
#line 640 "include/linux/i2c.h"
struct i2c_algo_bit_data {
   void *data ;
   void (*setsda)(void * , int  ) ;
   void (*setscl)(void * , int  ) ;
   int (*getsda)(void * ) ;
   int (*getscl)(void * ) ;
   int (*pre_xfer)(struct i2c_adapter * ) ;
   void (*post_xfer)(struct i2c_adapter * ) ;
   int udelay ;
   int timeout ;
};
#line 54 "include/linux/kthread.h"
struct kthread_work;
#line 65 "include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};
#line 72 "include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work * ) ;
   struct kthread_worker *worker ;
};
#line 80 "./include/uapi/linux/dvb/audio.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 163 "include/linux/poll.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 32 "include/linux/cdev.h"
struct v4l2_edid {
   __u32 pad ;
   __u32 start_block ;
   __u32 blocks ;
   __u32 reserved[5U] ;
   __u8 *edid ;
};
#line 571 "./include/uapi/linux/v4l2-common.h"
enum v4l2_buf_type {
    V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
    V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
    V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
    V4L2_BUF_TYPE_VBI_CAPTURE = 4,
    V4L2_BUF_TYPE_VBI_OUTPUT = 5,
    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
    V4L2_BUF_TYPE_SDR_CAPTURE = 11,
    V4L2_BUF_TYPE_PRIVATE = 128
} ;
#line 643
enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
    V4L2_PRIORITY_DEFAULT = 2
} ;
#line 651 "./include/uapi/linux/v4l2-common.h"
struct v4l2_rect {
   __s32 left ;
   __s32 top ;
   __u32 width ;
   __u32 height ;
};
#line 370 "include/uapi/linux/videodev2.h"
struct v4l2_fract {
   __u32 numerator ;
   __u32 denominator ;
};
#line 375 "include/uapi/linux/videodev2.h"
struct v4l2_capability {
   __u8 driver[16U] ;
   __u8 card[32U] ;
   __u8 bus_info[32U] ;
   __u32 version ;
   __u32 capabilities ;
   __u32 device_caps ;
   __u32 reserved[3U] ;
};
#line 396 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
   __u32 flags ;
   __u32 ycbcr_enc ;
   __u32 quantization ;
   __u32 xfer_func ;
};
#line 450 "include/uapi/linux/videodev2.h"
struct v4l2_fmtdesc {
   __u32 index ;
   __u32 type ;
   __u32 flags ;
   __u8 description[32U] ;
   __u32 pixelformat ;
   __u32 reserved[4U] ;
};
#line 640 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_discrete {
   __u32 width ;
   __u32 height ;
};
#line 653 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_stepwise {
   __u32 min_width ;
   __u32 max_width ;
   __u32 step_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 step_height ;
};
#line 662 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_261 {
   struct v4l2_frmsize_discrete discrete ;
   struct v4l2_frmsize_stepwise stepwise ;
};
#line 662 "include/uapi/linux/videodev2.h"
struct v4l2_frmsizeenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 type ;
   union __anonunion____missing_field_name_261 __annonCompField78 ;
   __u32 reserved[2U] ;
};
#line 681 "include/uapi/linux/videodev2.h"
struct v4l2_frmival_stepwise {
   struct v4l2_fract min ;
   struct v4l2_fract max ;
   struct v4l2_fract step ;
};
#line 690 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_262 {
   struct v4l2_fract discrete ;
   struct v4l2_frmival_stepwise stepwise ;
};
#line 690 "include/uapi/linux/videodev2.h"
struct v4l2_frmivalenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 width ;
   __u32 height ;
   __u32 type ;
   union __anonunion____missing_field_name_262 __annonCompField79 ;
   __u32 reserved[2U] ;
};
#line 705 "include/uapi/linux/videodev2.h"
struct v4l2_timecode {
   __u32 type ;
   __u32 flags ;
   __u8 frames ;
   __u8 seconds ;
   __u8 minutes ;
   __u8 hours ;
   __u8 userbits[4U] ;
};
#line 719 "include/uapi/linux/videodev2.h"
struct v4l2_jpegcompression {
   int quality ;
   int APPn ;
   int APP_len ;
   char APP_data[60U] ;
   int COM_len ;
   char COM_data[60U] ;
   __u32 jpeg_markers ;
};
#line 748 "include/uapi/linux/videodev2.h"
struct v4l2_requestbuffers {
   __u32 count ;
   __u32 type ;
   __u32 memory ;
   __u32 reserved[2U] ;
};
#line 773 "include/uapi/linux/videodev2.h"
union __anonunion_m_263 {
   __u32 mem_offset ;
   unsigned long userptr ;
   __s32 fd ;
};
#line 773 "include/uapi/linux/videodev2.h"
struct v4l2_plane {
   __u32 bytesused ;
   __u32 length ;
   union __anonunion_m_263 m ;
   __u32 data_offset ;
   __u32 reserved[11U] ;
};
#line 805 "include/uapi/linux/videodev2.h"
union __anonunion_m_264 {
   __u32 offset ;
   unsigned long userptr ;
   struct v4l2_plane *planes ;
   __s32 fd ;
};
#line 805 "include/uapi/linux/videodev2.h"
struct v4l2_buffer {
   __u32 index ;
   __u32 type ;
   __u32 bytesused ;
   __u32 flags ;
   __u32 field ;
   struct timeval timestamp ;
   struct v4l2_timecode timecode ;
   __u32 sequence ;
   __u32 memory ;
   union __anonunion_m_264 m ;
   __u32 length ;
   __u32 reserved2 ;
   __u32 reserved ;
};
#line 858 "include/uapi/linux/videodev2.h"
struct v4l2_exportbuffer {
   __u32 type ;
   __u32 index ;
   __u32 plane ;
   __u32 flags ;
   __s32 fd ;
   __u32 reserved[11U] ;
};
#line 919 "include/uapi/linux/videodev2.h"
struct __anonstruct_fmt_265 {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
};
#line 919 "include/uapi/linux/videodev2.h"
struct v4l2_framebuffer {
   __u32 capability ;
   __u32 flags ;
   void *base ;
   struct __anonstruct_fmt_265 fmt ;
};
#line 940 "include/uapi/linux/videodev2.h"
struct v4l2_clip {
   struct v4l2_rect c ;
   struct v4l2_clip *next ;
};
#line 962 "include/uapi/linux/videodev2.h"
struct v4l2_window {
   struct v4l2_rect w ;
   __u32 field ;
   __u32 chromakey ;
   struct v4l2_clip *clips ;
   __u32 clipcount ;
   void *bitmap ;
   __u8 global_alpha ;
};
#line 972 "include/uapi/linux/videodev2.h"
struct v4l2_captureparm {
   __u32 capability ;
   __u32 capturemode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 readbuffers ;
   __u32 reserved[4U] ;
};
#line 984 "include/uapi/linux/videodev2.h"
struct v4l2_outputparm {
   __u32 capability ;
   __u32 outputmode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 writebuffers ;
   __u32 reserved[4U] ;
};
#line 997 "include/uapi/linux/videodev2.h"
struct v4l2_cropcap {
   __u32 type ;
   struct v4l2_rect bounds ;
   struct v4l2_rect defrect ;
   struct v4l2_fract pixelaspect ;
};
#line 1007 "include/uapi/linux/videodev2.h"
struct v4l2_crop {
   __u32 type ;
   struct v4l2_rect c ;
};
#line 1012 "include/uapi/linux/videodev2.h"
struct v4l2_selection {
   __u32 type ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[9U] ;
};
#line 1039 "include/uapi/linux/videodev2.h"
typedef __u64 v4l2_std_id;
#line 1175 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings {
   __u32 width ;
   __u32 height ;
   __u32 interlaced ;
   __u32 polarities ;
   __u64 pixelclock ;
   __u32 hfrontporch ;
   __u32 hsync ;
   __u32 hbackporch ;
   __u32 vfrontporch ;
   __u32 vsync ;
   __u32 vbackporch ;
   __u32 il_vfrontporch ;
   __u32 il_vsync ;
   __u32 il_vbackporch ;
   __u32 standards ;
   __u32 flags ;
   __u32 reserved[14U] ;
};
#line 1231 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_266 {
   struct v4l2_bt_timings bt ;
   __u32 reserved[32U] ;
};
#line 1231 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings {
   __u32 type ;
   union __anonunion____missing_field_name_266 __annonCompField80 ;
};
#line 1299 "include/uapi/linux/videodev2.h"
struct v4l2_enum_dv_timings {
   __u32 index ;
   __u32 pad ;
   __u32 reserved[2U] ;
   struct v4l2_dv_timings timings ;
};
#line 1317 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings_cap {
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u64 min_pixelclock ;
   __u64 max_pixelclock ;
   __u32 standards ;
   __u32 capabilities ;
   __u32 reserved[16U] ;
};
#line 1340 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_267 {
   struct v4l2_bt_timings_cap bt ;
   __u32 raw_data[32U] ;
};
#line 1340 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings_cap {
   __u32 type ;
   __u32 pad ;
   __u32 reserved[2U] ;
   union __anonunion____missing_field_name_267 __annonCompField81 ;
};
#line 1365 "include/uapi/linux/videodev2.h"
struct v4l2_input {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 tuner ;
   v4l2_std_id std ;
   __u32 status ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1381 "include/uapi/linux/videodev2.h"
struct v4l2_output {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 modulator ;
   v4l2_std_id std ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1429 "include/uapi/linux/videodev2.h"
struct v4l2_control {
   __u32 id ;
   __s32 value ;
};
#line 1447 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_268 {
   __s32 value ;
   __s64 value64 ;
   char *string ;
   __u8 *p_u8 ;
   __u16 *p_u16 ;
   __u32 *p_u32 ;
   void *ptr ;
};
#line 1447 "include/uapi/linux/videodev2.h"
struct v4l2_ext_control {
   __u32 id ;
   __u32 size ;
   __u32 reserved2[1U] ;
   union __anonunion____missing_field_name_268 __annonCompField82 ;
};
#line 1462 "include/uapi/linux/videodev2.h"
struct v4l2_ext_controls {
   __u32 ctrl_class ;
   __u32 count ;
   __u32 error_idx ;
   __u32 reserved[2U] ;
   struct v4l2_ext_control *controls ;
};
#line 1470
enum v4l2_ctrl_type {
    V4L2_CTRL_TYPE_INTEGER = 1,
    V4L2_CTRL_TYPE_BOOLEAN = 2,
    V4L2_CTRL_TYPE_MENU = 3,
    V4L2_CTRL_TYPE_BUTTON = 4,
    V4L2_CTRL_TYPE_INTEGER64 = 5,
    V4L2_CTRL_TYPE_CTRL_CLASS = 6,
    V4L2_CTRL_TYPE_STRING = 7,
    V4L2_CTRL_TYPE_BITMASK = 8,
    V4L2_CTRL_TYPE_INTEGER_MENU = 9,
    V4L2_CTRL_COMPOUND_TYPES = 256,
    V4L2_CTRL_TYPE_U8 = 256,
    V4L2_CTRL_TYPE_U16 = 257,
    V4L2_CTRL_TYPE_U32 = 258
} ;
#line 1486 "include/uapi/linux/videodev2.h"
struct v4l2_queryctrl {
   __u32 id ;
   __u32 type ;
   __u8 name[32U] ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 step ;
   __s32 default_value ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1506 "include/uapi/linux/videodev2.h"
struct v4l2_query_ext_ctrl {
   __u32 id ;
   __u32 type ;
   char name[32U] ;
   __s64 minimum ;
   __s64 maximum ;
   __u64 step ;
   __s64 default_value ;
   __u32 flags ;
   __u32 elem_size ;
   __u32 elems ;
   __u32 nr_of_dims ;
   __u32 dims[4U] ;
   __u32 reserved[32U] ;
};
#line 1523 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_269 {
   __u8 name[32U] ;
   __s64 value ;
};
#line 1523 "include/uapi/linux/videodev2.h"
struct v4l2_querymenu {
   __u32 id ;
   __u32 index ;
   union __anonunion____missing_field_name_269 __annonCompField83 ;
   __u32 reserved ;
};
#line 1534 "include/uapi/linux/videodev2.h"
struct v4l2_tuner {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 rxsubchans ;
   __u32 audmode ;
   __s32 signal ;
   __s32 afc ;
   __u32 reserved[4U] ;
};
#line 1573 "include/uapi/linux/videodev2.h"
struct v4l2_modulator {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 txsubchans ;
   __u32 reserved[4U] ;
};
#line 1583 "include/uapi/linux/videodev2.h"
struct v4l2_frequency {
   __u32 tuner ;
   __u32 type ;
   __u32 frequency ;
   __u32 reserved[8U] ;
};
#line 1622 "include/uapi/linux/videodev2.h"
struct v4l2_frequency_band {
   __u32 tuner ;
   __u32 type ;
   __u32 index ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 modulation ;
   __u32 reserved[9U] ;
};
#line 1637 "include/uapi/linux/videodev2.h"
struct v4l2_hw_freq_seek {
   __u32 tuner ;
   __u32 type ;
   __u32 seek_upward ;
   __u32 wrap_around ;
   __u32 spacing ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 reserved[5U] ;
};
#line 1658 "include/uapi/linux/videodev2.h"
struct v4l2_audio {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1680 "include/uapi/linux/videodev2.h"
struct v4l2_audioout {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1695 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx_entry {
   __u64 offset ;
   __u64 pts ;
   __u32 length ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1714 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx {
   __u32 entries ;
   __u32 entries_cap ;
   __u32 reserved[4U] ;
   struct v4l2_enc_idx_entry entry[64U] ;
};
#line 1722 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_271 {
   __u32 data[8U] ;
};
#line 1722 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_270 {
   struct __anonstruct_raw_271 raw ;
};
#line 1722 "include/uapi/linux/videodev2.h"
struct v4l2_encoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion____missing_field_name_270 __annonCompField84 ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_stop_273 {
   __u64 pts ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_start_274 {
   __s32 speed ;
   __u32 format ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_275 {
   __u32 data[16U] ;
};
#line 1741 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_272 {
   struct __anonstruct_stop_273 stop ;
   struct __anonstruct_start_274 start ;
   struct __anonstruct_raw_275 raw ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct v4l2_decoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion____missing_field_name_272 __annonCompField85 ;
};
#line 1790 "include/uapi/linux/videodev2.h"
struct v4l2_vbi_format {
   __u32 sampling_rate ;
   __u32 offset ;
   __u32 samples_per_line ;
   __u32 sample_format ;
   __s32 start[2U] ;
   __u32 count[2U] ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1810 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_format {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 io_size ;
   __u32 reserved[2U] ;
};
#line 1838 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_cap {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 1862 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_data {
   __u32 id ;
   __u32 field ;
   __u32 line ;
   __u32 reserved ;
   __u8 data[48U] ;
};
#line 1917 "include/uapi/linux/videodev2.h"
struct v4l2_plane_pix_format {
   __u32 sizeimage ;
   __u32 bytesperline ;
   __u16 reserved[6U] ;
};
#line 1934 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format_mplane {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 colorspace ;
   struct v4l2_plane_pix_format plane_fmt[8U] ;
   __u8 num_planes ;
   __u8 flags ;
   __u8 ycbcr_enc ;
   __u8 quantization ;
   __u8 xfer_func ;
   __u8 reserved[7U] ;
};
#line 1964 "include/uapi/linux/videodev2.h"
struct v4l2_sdr_format {
   __u32 pixelformat ;
   __u32 buffersize ;
   __u8 reserved[24U] ;
};
#line 1975 "include/uapi/linux/videodev2.h"
union __anonunion_fmt_277 {
   struct v4l2_pix_format pix ;
   struct v4l2_pix_format_mplane pix_mp ;
   struct v4l2_window win ;
   struct v4l2_vbi_format vbi ;
   struct v4l2_sliced_vbi_format sliced ;
   struct v4l2_sdr_format sdr ;
   __u8 raw_data[200U] ;
};
#line 1975 "include/uapi/linux/videodev2.h"
struct v4l2_format {
   __u32 type ;
   union __anonunion_fmt_277 fmt ;
};
#line 1998 "include/uapi/linux/videodev2.h"
union __anonunion_parm_278 {
   struct v4l2_captureparm capture ;
   struct v4l2_outputparm output ;
   __u8 raw_data[200U] ;
};
#line 1998 "include/uapi/linux/videodev2.h"
struct v4l2_streamparm {
   __u32 type ;
   union __anonunion_parm_278 parm ;
};
#line 2089 "include/uapi/linux/videodev2.h"
struct v4l2_event_subscription {
   __u32 type ;
   __u32 id ;
   __u32 flags ;
   __u32 reserved[5U] ;
};
#line 2099 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_281 {
   __u32 addr ;
   char name[32U] ;
};
#line 2099 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_match {
   __u32 type ;
   union __anonunion____missing_field_name_281 __annonCompField88 ;
};
#line 2125 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_register {
   struct v4l2_dbg_match match ;
   __u32 size ;
   __u64 reg ;
   __u64 val ;
};
#line 2132 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_chip_info {
   struct v4l2_dbg_match match ;
   char name[32U] ;
   __u32 flags ;
   __u32 reserved[32U] ;
};
#line 2143 "include/uapi/linux/videodev2.h"
struct v4l2_create_buffers {
   __u32 index ;
   __u32 count ;
   __u32 memory ;
   struct v4l2_format format ;
   __u32 reserved[8U] ;
};
#line 169 "./include/uapi/linux/media.h"
struct media_pipeline {

};
#line 172
struct media_pad;
#line 172 "./include/uapi/linux/media.h"
struct media_link {
   struct media_pad *source ;
   struct media_pad *sink ;
   struct media_link *reverse ;
   unsigned long flags ;
};
#line 40 "include/media/media-entity.h"
struct media_entity;
#line 40 "include/media/media-entity.h"
struct media_pad {
   struct media_entity *entity ;
   u16 index ;
   unsigned long flags ;
};
#line 46 "include/media/media-entity.h"
struct media_entity_operations {
   int (*link_setup)(struct media_entity * , struct media_pad  const  * , struct media_pad  const  * ,
                     u32  ) ;
   int (*link_validate)(struct media_link * ) ;
};
#line 62
struct media_device;
#line 62 "include/media/media-entity.h"
struct __anonstruct_dev_288 {
   u32 major ;
   u32 minor ;
};
#line 62 "include/media/media-entity.h"
union __anonunion_info_287 {
   struct __anonstruct_dev_288 dev ;
};
#line 62 "include/media/media-entity.h"
struct media_entity {
   struct list_head list ;
   struct media_device *parent ;
   u32 id ;
   char const   *name ;
   u32 type ;
   u32 revision ;
   unsigned long flags ;
   u32 group_id ;
   u16 num_pads ;
   u16 num_links ;
   u16 num_backlinks ;
   u16 max_links ;
   struct media_pad *pads ;
   struct media_link *links ;
   struct media_entity_operations  const  *ops ;
   int stream_count ;
   int use_count ;
   struct media_pipeline *pipe ;
   union __anonunion_info_287 info ;
};
#line 155
struct video_device;
#line 156
struct v4l2_device;
#line 157
struct v4l2_ctrl_handler;
#line 158 "include/media/media-entity.h"
struct v4l2_prio_state {
   atomic_t prios[4U] ;
};
#line 61 "include/media/v4l2-dev.h"
struct v4l2_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl32)(struct file * , unsigned int  , unsigned long  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 78
struct vb2_queue;
#line 78
struct v4l2_ioctl_ops;
#line 78 "include/media/v4l2-dev.h"
struct video_device {
   struct media_entity entity ;
   struct v4l2_file_operations  const  *fops ;
   struct device dev ;
   struct cdev *cdev ;
   struct v4l2_device *v4l2_dev ;
   struct device *dev_parent ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct vb2_queue *queue ;
   struct v4l2_prio_state *prio ;
   char name[32U] ;
   int vfl_type ;
   int vfl_dir ;
   int minor ;
   u16 num ;
   unsigned long flags ;
   int index ;
   spinlock_t fh_lock ;
   struct list_head fh_list ;
   int dev_debug ;
   v4l2_std_id tvnorms ;
   void (*release)(struct video_device * ) ;
   struct v4l2_ioctl_ops  const  *ioctl_ops ;
   unsigned long valid_ioctls[3U] ;
   unsigned long disable_locking[3U] ;
   struct mutex *lock ;
};
#line 86 "include/media/v4l2-common.h"
struct v4l2_subdev_ops;
#line 147 "include/media/v4l2-common.h"
struct v4l2_priv_tun_config {
   int tuner ;
   void *priv ;
};
#line 191 "include/media/v4l2-common.h"
struct v4l2_ioctl_ops {
   int (*vidioc_querycap)(struct file * , void * , struct v4l2_capability * ) ;
   int (*vidioc_enum_fmt_vid_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_overlay)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_sdr_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_g_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_reqbufs)(struct file * , void * , struct v4l2_requestbuffers * ) ;
   int (*vidioc_querybuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_qbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_expbuf)(struct file * , void * , struct v4l2_exportbuffer * ) ;
   int (*vidioc_dqbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_create_bufs)(struct file * , void * , struct v4l2_create_buffers * ) ;
   int (*vidioc_prepare_buf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_overlay)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_g_fbuf)(struct file * , void * , struct v4l2_framebuffer * ) ;
   int (*vidioc_s_fbuf)(struct file * , void * , struct v4l2_framebuffer  const  * ) ;
   int (*vidioc_streamon)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_streamoff)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_g_std)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_s_std)(struct file * , void * , v4l2_std_id  ) ;
   int (*vidioc_querystd)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_enum_input)(struct file * , void * , struct v4l2_input * ) ;
   int (*vidioc_g_input)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_input)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_enum_output)(struct file * , void * , struct v4l2_output * ) ;
   int (*vidioc_g_output)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_output)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_queryctrl)(struct file * , void * , struct v4l2_queryctrl * ) ;
   int (*vidioc_query_ext_ctrl)(struct file * , void * , struct v4l2_query_ext_ctrl * ) ;
   int (*vidioc_g_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_s_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_g_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_s_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_try_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_querymenu)(struct file * , void * , struct v4l2_querymenu * ) ;
   int (*vidioc_enumaudio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_g_audio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_s_audio)(struct file * , void * , struct v4l2_audio  const  * ) ;
   int (*vidioc_enumaudout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_g_audout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_s_audout)(struct file * , void * , struct v4l2_audioout  const  * ) ;
   int (*vidioc_g_modulator)(struct file * , void * , struct v4l2_modulator * ) ;
   int (*vidioc_s_modulator)(struct file * , void * , struct v4l2_modulator  const  * ) ;
   int (*vidioc_cropcap)(struct file * , void * , struct v4l2_cropcap * ) ;
   int (*vidioc_g_crop)(struct file * , void * , struct v4l2_crop * ) ;
   int (*vidioc_s_crop)(struct file * , void * , struct v4l2_crop  const  * ) ;
   int (*vidioc_g_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_s_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_g_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression * ) ;
   int (*vidioc_s_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression  const  * ) ;
   int (*vidioc_g_enc_index)(struct file * , void * , struct v4l2_enc_idx * ) ;
   int (*vidioc_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_try_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_try_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_g_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_s_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_g_tuner)(struct file * , void * , struct v4l2_tuner * ) ;
   int (*vidioc_s_tuner)(struct file * , void * , struct v4l2_tuner  const  * ) ;
   int (*vidioc_g_frequency)(struct file * , void * , struct v4l2_frequency * ) ;
   int (*vidioc_s_frequency)(struct file * , void * , struct v4l2_frequency  const  * ) ;
   int (*vidioc_enum_freq_bands)(struct file * , void * , struct v4l2_frequency_band * ) ;
   int (*vidioc_g_sliced_vbi_cap)(struct file * , void * , struct v4l2_sliced_vbi_cap * ) ;
   int (*vidioc_log_status)(struct file * , void * ) ;
   int (*vidioc_s_hw_freq_seek)(struct file * , void * , struct v4l2_hw_freq_seek  const  * ) ;
   int (*vidioc_g_register)(struct file * , void * , struct v4l2_dbg_register * ) ;
   int (*vidioc_s_register)(struct file * , void * , struct v4l2_dbg_register  const  * ) ;
   int (*vidioc_g_chip_info)(struct file * , void * , struct v4l2_dbg_chip_info * ) ;
   int (*vidioc_enum_framesizes)(struct file * , void * , struct v4l2_frmsizeenum * ) ;
   int (*vidioc_enum_frameintervals)(struct file * , void * , struct v4l2_frmivalenum * ) ;
   int (*vidioc_s_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_g_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_query_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_enum_dv_timings)(struct file * , void * , struct v4l2_enum_dv_timings * ) ;
   int (*vidioc_dv_timings_cap)(struct file * , void * , struct v4l2_dv_timings_cap * ) ;
   int (*vidioc_g_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_s_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_subscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   int (*vidioc_unsubscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   long (*vidioc_default)(struct file * , void * , bool  , unsigned int  , void * ) ;
};
#line 334 "include/media/v4l2-ioctl.h"
struct v4l2_ctrl_helper;
#line 336 "include/media/v4l2-ioctl.h"
union v4l2_ctrl_ptr {
   s32 *p_s32 ;
   s64 *p_s64 ;
   u8 *p_u8 ;
   u16 *p_u16 ;
   u32 *p_u32 ;
   char *p_char ;
   void *p ;
};
#line 57 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_ops {
   int (*g_volatile_ctrl)(struct v4l2_ctrl * ) ;
   int (*try_ctrl)(struct v4l2_ctrl * ) ;
   int (*s_ctrl)(struct v4l2_ctrl * ) ;
};
#line 75 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_type_ops {
   bool (*equal)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  , union v4l2_ctrl_ptr  ) ;
   void (*init)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  ) ;
   void (*log)(struct v4l2_ctrl  const  * ) ;
   int (*validate)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  ) ;
};
#line 94 "include/media/v4l2-ctrls.h"
union __anonunion____missing_field_name_290 {
   u64 step ;
   u64 menu_skip_mask ;
};
#line 94 "include/media/v4l2-ctrls.h"
union __anonunion____missing_field_name_291 {
   char const   * const  *qmenu ;
   s64 const   *qmenu_int ;
};
#line 94 "include/media/v4l2-ctrls.h"
struct __anonstruct_cur_292 {
   s32 val ;
};
#line 94 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl {
   struct list_head node ;
   struct list_head ev_subs ;
   struct v4l2_ctrl_handler *handler ;
   struct v4l2_ctrl **cluster ;
   unsigned int ncontrols ;
   unsigned char done : 1 ;
   unsigned char is_new : 1 ;
   unsigned char has_changed : 1 ;
   unsigned char is_private : 1 ;
   unsigned char is_auto : 1 ;
   unsigned char is_int : 1 ;
   unsigned char is_string : 1 ;
   unsigned char is_ptr : 1 ;
   unsigned char is_array : 1 ;
   unsigned char has_volatiles : 1 ;
   unsigned char call_notify : 1 ;
   unsigned char manual_mode_value ;
   struct v4l2_ctrl_ops  const  *ops ;
   struct v4l2_ctrl_type_ops  const  *type_ops ;
   u32 id ;
   char const   *name ;
   enum v4l2_ctrl_type type ;
   s64 minimum ;
   s64 maximum ;
   s64 default_value ;
   u32 elems ;
   u32 elem_size ;
   u32 dims[4U] ;
   u32 nr_of_dims ;
   union __anonunion____missing_field_name_290 __annonCompField90 ;
   union __anonunion____missing_field_name_291 __annonCompField91 ;
   unsigned long flags ;
   void *priv ;
   s32 val ;
   struct __anonstruct_cur_292 cur ;
   union v4l2_ctrl_ptr p_new ;
   union v4l2_ctrl_ptr p_cur ;
};
#line 212 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_ref {
   struct list_head node ;
   struct v4l2_ctrl_ref *next ;
   struct v4l2_ctrl *ctrl ;
   struct v4l2_ctrl_helper *helper ;
};
#line 229 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_handler {
   struct mutex _lock ;
   struct mutex *lock ;
   struct list_head ctrls ;
   struct list_head ctrl_refs ;
   struct v4l2_ctrl_ref *cached ;
   struct v4l2_ctrl_ref **buckets ;
   void (*notify)(struct v4l2_ctrl * , void * ) ;
   void *notify_priv ;
   u16 nr_of_buckets ;
   int error ;
};
#line 837 "include/media/v4l2-ctrls.h"
struct media_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 53 "include/media/media-devnode.h"
struct media_devnode {
   struct media_file_operations  const  *fops ;
   struct device dev ;
   struct cdev cdev ;
   struct device *parent ;
   int minor ;
   unsigned long flags ;
   void (*release)(struct media_devnode * ) ;
};
#line 98 "include/media/media-devnode.h"
struct media_device {
   struct device *dev ;
   struct media_devnode devnode ;
   char model[32U] ;
   char serial[40U] ;
   char bus_info[32U] ;
   u32 hw_revision ;
   u32 driver_version ;
   u32 entity_id ;
   struct list_head entities ;
   spinlock_t lock ;
   struct mutex graph_mutex ;
   int (*link_notify)(struct media_link * , u32  , unsigned int  ) ;
};
#line 98 "include/media/media-device.h"
struct v4l2_mbus_framefmt {
   __u32 width ;
   __u32 height ;
   __u32 code ;
   __u32 field ;
   __u32 colorspace ;
   __u16 ycbcr_enc ;
   __u16 quantization ;
   __u16 xfer_func ;
   __u16 reserved[11U] ;
};
#line 45 "./include/uapi/linux/v4l2-mediabus.h"
struct v4l2_subdev_format {
   __u32 which ;
   __u32 pad ;
   struct v4l2_mbus_framefmt format ;
   __u32 reserved[8U] ;
};
#line 66 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_mbus_code_enum {
   __u32 pad ;
   __u32 index ;
   __u32 code ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 81 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_size_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 100 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval {
   __u32 pad ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 111 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 width ;
   __u32 height ;
   struct v4l2_fract interval ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 132 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_selection {
   __u32 which ;
   __u32 pad ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[8U] ;
};
#line 156
struct v4l2_async_notifier;
#line 157
enum v4l2_async_match_type {
    V4L2_ASYNC_MATCH_CUSTOM = 0,
    V4L2_ASYNC_MATCH_DEVNAME = 1,
    V4L2_ASYNC_MATCH_I2C = 2,
    V4L2_ASYNC_MATCH_OF = 3
} ;
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_of_294 {
   struct device_node  const  *node ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_device_name_295 {
   char const   *name ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_i2c_296 {
   int adapter_id ;
   unsigned short address ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_custom_297 {
   bool (*match)(struct device * , struct v4l2_async_subdev * ) ;
   void *priv ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
union __anonunion_match_293 {
   struct __anonstruct_of_294 of ;
   struct __anonstruct_device_name_295 device_name ;
   struct __anonstruct_i2c_296 i2c ;
   struct __anonstruct_custom_297 custom ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_async_subdev {
   enum v4l2_async_match_type match_type ;
   union __anonunion_match_293 match ;
   struct list_head list ;
};
#line 63 "include/media/v4l2-async.h"
struct v4l2_async_notifier {
   unsigned int num_subdevs ;
   struct v4l2_async_subdev **subdevs ;
   struct v4l2_device *v4l2_dev ;
   struct list_head waiting ;
   struct list_head done ;
   struct list_head list ;
   int (*bound)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
   int (*complete)(struct v4l2_async_notifier * ) ;
   void (*unbind)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
};
#line 97
struct v4l2_m2m_ctx;
#line 97 "include/media/v4l2-async.h"
struct v4l2_fh {
   struct list_head list ;
   struct video_device *vdev ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   enum v4l2_priority prio ;
   wait_queue_head_t wait ;
   struct list_head subscribed ;
   struct list_head available ;
   unsigned int navailable ;
   u32 sequence ;
   struct v4l2_m2m_ctx *m2m_ctx ;
};
#line 106 "include/media/v4l2-fh.h"
enum v4l2_mbus_type {
    V4L2_MBUS_PARALLEL = 0,
    V4L2_MBUS_BT656 = 1,
    V4L2_MBUS_CSI2 = 2
} ;
#line 112 "include/media/v4l2-fh.h"
struct v4l2_mbus_config {
   enum v4l2_mbus_type type ;
   unsigned int flags ;
};
#line 115 "include/media/v4l2-mediabus.h"
struct v4l2_subdev_fh;
#line 116
struct tuner_setup;
#line 117
struct v4l2_mbus_frame_desc;
#line 118 "include/media/v4l2-mediabus.h"
struct v4l2_decode_vbi_line {
   u32 is_second_field ;
   u8 *p ;
   u32 line ;
   u32 type ;
};
#line 63 "include/media/v4l2-subdev.h"
struct v4l2_subdev_io_pin_config {
   u32 flags ;
   u8 pin ;
   u8 function ;
   u8 value ;
   u8 strength ;
};
#line 119 "include/media/v4l2-subdev.h"
struct v4l2_subdev_core_ops {
   int (*log_status)(struct v4l2_subdev * ) ;
   int (*s_io_pin_config)(struct v4l2_subdev * , size_t  , struct v4l2_subdev_io_pin_config * ) ;
   int (*init)(struct v4l2_subdev * , u32  ) ;
   int (*load_fw)(struct v4l2_subdev * ) ;
   int (*reset)(struct v4l2_subdev * , u32  ) ;
   int (*s_gpio)(struct v4l2_subdev * , u32  ) ;
   int (*queryctrl)(struct v4l2_subdev * , struct v4l2_queryctrl * ) ;
   int (*g_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*s_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*g_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*s_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*try_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*querymenu)(struct v4l2_subdev * , struct v4l2_querymenu * ) ;
   long (*ioctl)(struct v4l2_subdev * , unsigned int  , void * ) ;
   long (*compat_ioctl32)(struct v4l2_subdev * , unsigned int  , unsigned long  ) ;
   int (*g_register)(struct v4l2_subdev * , struct v4l2_dbg_register * ) ;
   int (*s_register)(struct v4l2_subdev * , struct v4l2_dbg_register  const  * ) ;
   int (*s_power)(struct v4l2_subdev * , int  ) ;
   int (*interrupt_service_routine)(struct v4l2_subdev * , u32  , bool * ) ;
   int (*subscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
   int (*unsubscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
};
#line 180 "include/media/v4l2-subdev.h"
struct v4l2_subdev_tuner_ops {
   int (*s_radio)(struct v4l2_subdev * ) ;
   int (*s_frequency)(struct v4l2_subdev * , struct v4l2_frequency  const  * ) ;
   int (*g_frequency)(struct v4l2_subdev * , struct v4l2_frequency * ) ;
   int (*enum_freq_bands)(struct v4l2_subdev * , struct v4l2_frequency_band * ) ;
   int (*g_tuner)(struct v4l2_subdev * , struct v4l2_tuner * ) ;
   int (*s_tuner)(struct v4l2_subdev * , struct v4l2_tuner  const  * ) ;
   int (*g_modulator)(struct v4l2_subdev * , struct v4l2_modulator * ) ;
   int (*s_modulator)(struct v4l2_subdev * , struct v4l2_modulator  const  * ) ;
   int (*s_type_addr)(struct v4l2_subdev * , struct tuner_setup * ) ;
   int (*s_config)(struct v4l2_subdev * , struct v4l2_priv_tun_config  const  * ) ;
};
#line 207 "include/media/v4l2-subdev.h"
struct v4l2_subdev_audio_ops {
   int (*s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_i2s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
};
#line 234 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc_entry {
   u16 flags ;
   u32 pixelcode ;
   u32 length ;
};
#line 255 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc {
   struct v4l2_mbus_frame_desc_entry entry[4U] ;
   unsigned short num_entries ;
};
#line 267 "include/media/v4l2-subdev.h"
struct v4l2_subdev_video_ops {
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_crystal_freq)(struct v4l2_subdev * , u32  , u32  ) ;
   int (*g_std)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*s_std)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*s_std_output)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*g_std_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*querystd)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_input_status)(struct v4l2_subdev * , u32 * ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
   int (*cropcap)(struct v4l2_subdev * , struct v4l2_cropcap * ) ;
   int (*g_crop)(struct v4l2_subdev * , struct v4l2_crop * ) ;
   int (*s_crop)(struct v4l2_subdev * , struct v4l2_crop  const  * ) ;
   int (*g_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*s_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*g_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*query_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config * ) ;
   int (*s_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config  const  * ) ;
   int (*s_rx_buffer)(struct v4l2_subdev * , void * , unsigned int * ) ;
};
#line 341 "include/media/v4l2-subdev.h"
struct v4l2_subdev_vbi_ops {
   int (*decode_vbi_line)(struct v4l2_subdev * , struct v4l2_decode_vbi_line * ) ;
   int (*s_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data  const  * ) ;
   int (*g_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data * ) ;
   int (*g_sliced_vbi_cap)(struct v4l2_subdev * , struct v4l2_sliced_vbi_cap * ) ;
   int (*s_raw_fmt)(struct v4l2_subdev * , struct v4l2_vbi_format * ) ;
   int (*g_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
   int (*s_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
};
#line 381 "include/media/v4l2-subdev.h"
struct v4l2_subdev_sensor_ops {
   int (*g_skip_top_lines)(struct v4l2_subdev * , u32 * ) ;
   int (*g_skip_frames)(struct v4l2_subdev * , u32 * ) ;
};
#line 396
enum v4l2_subdev_ir_mode {
    V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0
} ;
#line 400 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_parameters {
   unsigned int bytes_per_data_element ;
   enum v4l2_subdev_ir_mode mode ;
   bool enable ;
   bool interrupt_enable ;
   bool shutdown ;
   bool modulation ;
   u32 max_pulse_width ;
   unsigned int carrier_freq ;
   unsigned int duty_cycle ;
   bool invert_level ;
   bool invert_carrier_sense ;
   u32 noise_filter_min_width ;
   unsigned int carrier_range_lower ;
   unsigned int carrier_range_upper ;
   u32 resolution ;
};
#line 448 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_ops {
   int (*rx_read)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*rx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*rx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_write)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*tx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
};
#line 467 "include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_config {
   struct v4l2_mbus_framefmt try_fmt ;
   struct v4l2_rect try_crop ;
   struct v4l2_rect try_compose ;
};
#line 480 "include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_ops {
   int (*enum_mbus_code)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                         struct v4l2_subdev_mbus_code_enum * ) ;
   int (*enum_frame_size)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                          struct v4l2_subdev_frame_size_enum * ) ;
   int (*enum_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                              struct v4l2_subdev_frame_interval_enum * ) ;
   int (*get_fmt)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_format * ) ;
   int (*set_fmt)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_format * ) ;
   int (*get_selection)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_selection * ) ;
   int (*set_selection)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_selection * ) ;
   int (*get_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*set_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*dv_timings_cap)(struct v4l2_subdev * , struct v4l2_dv_timings_cap * ) ;
   int (*enum_dv_timings)(struct v4l2_subdev * , struct v4l2_enum_dv_timings * ) ;
   int (*link_validate)(struct v4l2_subdev * , struct media_link * , struct v4l2_subdev_format * ,
                        struct v4l2_subdev_format * ) ;
   int (*get_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
   int (*set_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
};
#line 524 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ops {
   struct v4l2_subdev_core_ops  const  *core ;
   struct v4l2_subdev_tuner_ops  const  *tuner ;
   struct v4l2_subdev_audio_ops  const  *audio ;
   struct v4l2_subdev_video_ops  const  *video ;
   struct v4l2_subdev_vbi_ops  const  *vbi ;
   struct v4l2_subdev_ir_ops  const  *ir ;
   struct v4l2_subdev_sensor_ops  const  *sensor ;
   struct v4l2_subdev_pad_ops  const  *pad ;
};
#line 536 "include/media/v4l2-subdev.h"
struct v4l2_subdev_internal_ops {
   int (*registered)(struct v4l2_subdev * ) ;
   void (*unregistered)(struct v4l2_subdev * ) ;
   int (*open)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
   int (*close)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
};
#line 557
struct regulator_bulk_data;
#line 558 "include/media/v4l2-subdev.h"
struct v4l2_subdev_platform_data {
   struct regulator_bulk_data *regulators ;
   int num_regulators ;
   void *host_priv ;
};
#line 579 "include/media/v4l2-subdev.h"
struct v4l2_subdev {
   struct media_entity entity ;
   struct list_head list ;
   struct module *owner ;
   bool owner_v4l2_dev ;
   u32 flags ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev_ops  const  *ops ;
   struct v4l2_subdev_internal_ops  const  *internal_ops ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   char name[32U] ;
   u32 grp_id ;
   void *dev_priv ;
   void *host_priv ;
   struct video_device *devnode ;
   struct device *dev ;
   struct device_node *of_node ;
   struct list_head async_list ;
   struct v4l2_async_subdev *asd ;
   struct v4l2_async_notifier *notifier ;
   struct v4l2_subdev_platform_data *pdata ;
};
#line 619 "include/media/v4l2-subdev.h"
struct v4l2_subdev_fh {
   struct v4l2_fh vfh ;
   struct v4l2_subdev_pad_config *pad ;
};
#line 684 "include/media/v4l2-subdev.h"
struct v4l2_device {
   struct device *dev ;
   struct media_device *mdev ;
   struct list_head subdevs ;
   spinlock_t lock ;
   char name[36U] ;
   void (*notify)(struct v4l2_subdev * , unsigned int  , void * ) ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct v4l2_prio_state prio ;
   struct kref ref ;
   void (*release)(struct v4l2_device * ) ;
};
#line 133 "include/media/v4l2-device.h"
struct tuner_setup {
   unsigned short addr ;
   unsigned int type ;
   unsigned int mode_mask ;
   void *config ;
   int (*tuner_callback)(void * , int  , int  , int  ) ;
};
#line 198 "include/media/tuner.h"
enum cx2341x_port {
    CX2341X_PORT_MEMORY = 0,
    CX2341X_PORT_STREAMING = 1,
    CX2341X_PORT_SERIAL = 2
} ;
#line 103 "include/media/cx2341x.h"
struct cx2341x_handler_ops {
   int (*s_audio_sampling_freq)(struct cx2341x_handler * , u32  ) ;
   int (*s_audio_mode)(struct cx2341x_handler * , u32  ) ;
   int (*s_video_encoding)(struct cx2341x_handler * , u32  ) ;
   int (*s_stream_vbi_fmt)(struct cx2341x_handler * , u32  ) ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_298 {
   struct v4l2_ctrl *audio_sampling_freq ;
   struct v4l2_ctrl *audio_encoding ;
   struct v4l2_ctrl *audio_l2_bitrate ;
   struct v4l2_ctrl *audio_mode ;
   struct v4l2_ctrl *audio_mode_extension ;
   struct v4l2_ctrl *audio_emphasis ;
   struct v4l2_ctrl *audio_crc ;
   struct v4l2_ctrl *audio_ac3_bitrate ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_299 {
   struct v4l2_ctrl *video_b_frames ;
   struct v4l2_ctrl *video_gop_size ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_300 {
   struct v4l2_ctrl *stream_type ;
   struct v4l2_ctrl *video_encoding ;
   struct v4l2_ctrl *video_bitrate_mode ;
   struct v4l2_ctrl *video_bitrate ;
   struct v4l2_ctrl *video_bitrate_peak ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_301 {
   struct v4l2_ctrl *video_mute ;
   struct v4l2_ctrl *video_mute_yuv ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_302 {
   struct v4l2_ctrl *video_spatial_filter_mode ;
   struct v4l2_ctrl *video_temporal_filter_mode ;
   struct v4l2_ctrl *video_median_filter_type ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_303 {
   struct v4l2_ctrl *video_luma_spatial_filter_type ;
   struct v4l2_ctrl *video_chroma_spatial_filter_type ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_304 {
   struct v4l2_ctrl *video_spatial_filter ;
   struct v4l2_ctrl *video_temporal_filter ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_305 {
   struct v4l2_ctrl *video_luma_median_filter_top ;
   struct v4l2_ctrl *video_luma_median_filter_bottom ;
   struct v4l2_ctrl *video_chroma_median_filter_top ;
   struct v4l2_ctrl *video_chroma_median_filter_bottom ;
};
#line 116 "include/media/cx2341x.h"
struct cx2341x_handler {
   u32 capabilities ;
   enum cx2341x_port port ;
   u16 width ;
   u16 height ;
   u16 is_50hz ;
   u32 audio_properties ;
   struct v4l2_ctrl_handler hdl ;
   void *priv ;
   int (*func)(void * , u32  , int  , int  , u32 * ) ;
   struct cx2341x_handler_ops  const  *ops ;
   struct v4l2_ctrl *stream_vbi_fmt ;
   struct __anonstruct____missing_field_name_298 __annonCompField92 ;
   struct __anonstruct____missing_field_name_299 __annonCompField93 ;
   struct __anonstruct____missing_field_name_300 __annonCompField94 ;
   struct __anonstruct____missing_field_name_301 __annonCompField95 ;
   struct __anonstruct____missing_field_name_302 __annonCompField96 ;
   struct __anonstruct____missing_field_name_303 __annonCompField97 ;
   struct __anonstruct____missing_field_name_304 __annonCompField98 ;
   struct __anonstruct____missing_field_name_305 __annonCompField99 ;
};
#line 30 "include/uapi/linux/input.h"
struct input_id {
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
};
#line 47 "include/uapi/linux/input.h"
struct input_absinfo {
   __s32 value ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 fuzz ;
   __s32 flat ;
   __s32 resolution ;
};
#line 75 "include/uapi/linux/input.h"
struct input_keymap_entry {
   __u8 flags ;
   __u8 len ;
   __u16 index ;
   __u32 keycode ;
   __u8 scancode[32U] ;
};
#line 99 "include/uapi/linux/input.h"
struct ff_replay {
   __u16 length ;
   __u16 delay ;
};
#line 1010 "include/uapi/linux/input.h"
struct ff_trigger {
   __u16 button ;
   __u16 interval ;
};
#line 1020 "include/uapi/linux/input.h"
struct ff_envelope {
   __u16 attack_length ;
   __u16 attack_level ;
   __u16 fade_length ;
   __u16 fade_level ;
};
#line 1039 "include/uapi/linux/input.h"
struct ff_constant_effect {
   __s16 level ;
   struct ff_envelope envelope ;
};
#line 1049 "include/uapi/linux/input.h"
struct ff_ramp_effect {
   __s16 start_level ;
   __s16 end_level ;
   struct ff_envelope envelope ;
};
#line 1061 "include/uapi/linux/input.h"
struct ff_condition_effect {
   __u16 right_saturation ;
   __u16 left_saturation ;
   __s16 right_coeff ;
   __s16 left_coeff ;
   __u16 deadband ;
   __s16 center ;
};
#line 1082 "include/uapi/linux/input.h"
struct ff_periodic_effect {
   __u16 waveform ;
   __u16 period ;
   __s16 magnitude ;
   __s16 offset ;
   __u16 phase ;
   struct ff_envelope envelope ;
   __u32 custom_len ;
   __s16 *custom_data ;
};
#line 1113 "include/uapi/linux/input.h"
struct ff_rumble_effect {
   __u16 strong_magnitude ;
   __u16 weak_magnitude ;
};
#line 1126 "include/uapi/linux/input.h"
union __anonunion_u_309 {
   struct ff_constant_effect constant ;
   struct ff_ramp_effect ramp ;
   struct ff_periodic_effect periodic ;
   struct ff_condition_effect condition[2U] ;
   struct ff_rumble_effect rumble ;
};
#line 1126 "include/uapi/linux/input.h"
struct ff_effect {
   __u16 type ;
   __s16 id ;
   __u16 direction ;
   struct ff_trigger trigger ;
   struct ff_replay replay ;
   union __anonunion_u_309 u ;
};
#line 1165 "include/uapi/linux/input.h"
struct input_value {
   __u16 type ;
   __u16 code ;
   __s32 value ;
};
#line 38 "include/linux/input.h"
struct ff_device;
#line 38
struct input_mt;
#line 38
struct input_handle;
#line 38 "include/linux/input.h"
struct input_dev {
   char const   *name ;
   char const   *phys ;
   char const   *uniq ;
   struct input_id id ;
   unsigned long propbit[1U] ;
   unsigned long evbit[1U] ;
   unsigned long keybit[12U] ;
   unsigned long relbit[1U] ;
   unsigned long absbit[1U] ;
   unsigned long mscbit[1U] ;
   unsigned long ledbit[1U] ;
   unsigned long sndbit[1U] ;
   unsigned long ffbit[2U] ;
   unsigned long swbit[1U] ;
   unsigned int hint_events_per_packet ;
   unsigned int keycodemax ;
   unsigned int keycodesize ;
   void *keycode ;
   int (*setkeycode)(struct input_dev * , struct input_keymap_entry  const  * , unsigned int * ) ;
   int (*getkeycode)(struct input_dev * , struct input_keymap_entry * ) ;
   struct ff_device *ff ;
   unsigned int repeat_key ;
   struct timer_list timer ;
   int rep[2U] ;
   struct input_mt *mt ;
   struct input_absinfo *absinfo ;
   unsigned long key[12U] ;
   unsigned long led[1U] ;
   unsigned long snd[1U] ;
   unsigned long sw[1U] ;
   int (*open)(struct input_dev * ) ;
   void (*close)(struct input_dev * ) ;
   int (*flush)(struct input_dev * , struct file * ) ;
   int (*event)(struct input_dev * , unsigned int  , unsigned int  , int  ) ;
   struct input_handle *grab ;
   spinlock_t event_lock ;
   struct mutex mutex ;
   unsigned int users ;
   bool going_away ;
   struct device dev ;
   struct list_head h_list ;
   struct list_head node ;
   unsigned int num_vals ;
   unsigned int max_vals ;
   struct input_value *vals ;
   bool devres_managed ;
};
#line 191 "include/linux/input.h"
struct input_handler {
   void *private ;
   void (*event)(struct input_handle * , unsigned int  , unsigned int  , int  ) ;
   void (*events)(struct input_handle * , struct input_value  const  * , unsigned int  ) ;
   bool (*filter)(struct input_handle * , unsigned int  , unsigned int  , int  ) ;
   bool (*match)(struct input_handler * , struct input_dev * ) ;
   int (*connect)(struct input_handler * , struct input_dev * , struct input_device_id  const  * ) ;
   void (*disconnect)(struct input_handle * ) ;
   void (*start)(struct input_handle * ) ;
   bool legacy_minors ;
   int minor ;
   char const   *name ;
   struct input_device_id  const  *id_table ;
   struct list_head h_list ;
   struct list_head node ;
};
#line 306 "include/linux/input.h"
struct input_handle {
   void *private ;
   int open ;
   char const   *name ;
   struct input_dev *dev ;
   struct input_handler *handler ;
   struct list_head d_node ;
   struct list_head h_node ;
};
#line 473 "include/linux/input.h"
struct ff_device {
   int (*upload)(struct input_dev * , struct ff_effect * , struct ff_effect * ) ;
   int (*erase)(struct input_dev * , int  ) ;
   int (*playback)(struct input_dev * , int  , int  ) ;
   void (*set_gain)(struct input_dev * , u16  ) ;
   void (*set_autocenter)(struct input_dev * , u16  ) ;
   void (*destroy)(struct ff_device * ) ;
   void *private ;
   unsigned long ffbit[2U] ;
   struct mutex mutex ;
   int max_effects ;
   struct ff_effect *effects ;
   struct file *effect_owners[] ;
};
#line 532
enum rc_type {
    RC_TYPE_UNKNOWN = 0,
    RC_TYPE_OTHER = 1,
    RC_TYPE_LIRC = 2,
    RC_TYPE_RC5 = 3,
    RC_TYPE_RC5X = 4,
    RC_TYPE_RC5_SZ = 5,
    RC_TYPE_JVC = 6,
    RC_TYPE_SONY12 = 7,
    RC_TYPE_SONY15 = 8,
    RC_TYPE_SONY20 = 9,
    RC_TYPE_NEC = 10,
    RC_TYPE_SANYO = 11,
    RC_TYPE_MCE_KBD = 12,
    RC_TYPE_RC6_0 = 13,
    RC_TYPE_RC6_6A_20 = 14,
    RC_TYPE_RC6_6A_24 = 15,
    RC_TYPE_RC6_6A_32 = 16,
    RC_TYPE_RC6_MCE = 17,
    RC_TYPE_SHARP = 18,
    RC_TYPE_XMP = 19
} ;
#line 555 "include/linux/input.h"
struct rc_map_table {
   u32 scancode ;
   u32 keycode ;
};
#line 83 "include/media/rc-map.h"
struct rc_map {
   struct rc_map_table *scan ;
   unsigned int size ;
   unsigned int len ;
   unsigned int alloc ;
   enum rc_type rc_type ;
   char const   *name ;
   spinlock_t lock ;
};
#line 26 "include/media/rc-core.h"
enum rc_driver_type {
    RC_DRIVER_SCANCODE = 0,
    RC_DRIVER_IR_RAW = 1
} ;
#line 31 "include/media/rc-core.h"
struct rc_scancode_filter {
   u32 data ;
   u32 mask ;
};
#line 52
struct ir_raw_event_ctrl;
#line 52 "include/media/rc-core.h"
struct rc_dev {
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[5U] ;
   char const   *input_name ;
   char const   *input_phys ;
   struct input_id input_id ;
   char *driver_name ;
   char const   *map_name ;
   struct rc_map rc_map ;
   struct mutex lock ;
   unsigned long devno ;
   struct ir_raw_event_ctrl *raw ;
   struct input_dev *input_dev ;
   enum rc_driver_type driver_type ;
   bool idle ;
   bool encode_wakeup ;
   u64 allowed_protocols ;
   u64 enabled_protocols ;
   u64 allowed_wakeup_protocols ;
   u64 enabled_wakeup_protocols ;
   struct rc_scancode_filter scancode_filter ;
   struct rc_scancode_filter scancode_wakeup_filter ;
   u32 scancode_mask ;
   u32 users ;
   void *priv ;
   spinlock_t keylock ;
   bool keypressed ;
   unsigned long keyup_jiffies ;
   struct timer_list timer_keyup ;
   u32 last_keycode ;
   enum rc_type last_protocol ;
   u32 last_scancode ;
   u8 last_toggle ;
   u32 timeout ;
   u32 min_timeout ;
   u32 max_timeout ;
   u32 rx_resolution ;
   u32 tx_resolution ;
   int (*change_protocol)(struct rc_dev * , u64 * ) ;
   int (*change_wakeup_protocol)(struct rc_dev * , u64 * ) ;
   int (*open)(struct rc_dev * ) ;
   void (*close)(struct rc_dev * ) ;
   int (*s_tx_mask)(struct rc_dev * , u32  ) ;
   int (*s_tx_carrier)(struct rc_dev * , u32  ) ;
   int (*s_tx_duty_cycle)(struct rc_dev * , u32  ) ;
   int (*s_rx_carrier_range)(struct rc_dev * , u32  , u32  ) ;
   int (*tx_ir)(struct rc_dev * , unsigned int * , unsigned int  ) ;
   void (*s_idle)(struct rc_dev * , bool  ) ;
   int (*s_learning_mode)(struct rc_dev * , int  ) ;
   int (*s_carrier_report)(struct rc_dev * , int  ) ;
   int (*s_filter)(struct rc_dev * , struct rc_scancode_filter * ) ;
   int (*s_wakeup_filter)(struct rc_dev * , struct rc_scancode_filter * ) ;
};
#line 286
struct IR_i2c;
#line 287 "include/media/rc-core.h"
struct IR_i2c {
   char *ir_codes ;
   struct i2c_client *c ;
   struct rc_dev *rc ;
   unsigned char old ;
   u32 polling_interval ;
   struct delayed_work work ;
   char name[32U] ;
   char phys[32U] ;
   int (*get_key)(struct IR_i2c * , enum rc_type * , u32 * , u8 * ) ;
};
#line 25 "include/media/ir-kbd-i2c.h"
enum ir_kbd_get_key_fn {
    IR_KBD_GET_KEY_CUSTOM = 0,
    IR_KBD_GET_KEY_PIXELVIEW = 1,
    IR_KBD_GET_KEY_HAUP = 2,
    IR_KBD_GET_KEY_KNC1 = 3,
    IR_KBD_GET_KEY_FUSIONHDTV = 4,
    IR_KBD_GET_KEY_HAUP_XVR = 5,
    IR_KBD_GET_KEY_AVERMEDIA_CARDBUS = 6
} ;
#line 35 "include/media/ir-kbd-i2c.h"
struct IR_i2c_init_data {
   char *ir_codes ;
   char const   *name ;
   u64 type ;
   u32 polling_interval ;
   int (*get_key)(struct IR_i2c * , enum rc_type * , u32 * , u8 * ) ;
   enum ir_kbd_get_key_fn internal_get_key_func ;
   struct rc_dev *rc_dev ;
};
#line 126 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct ivtv_options {
   int kilobytes[9U] ;
   int cardtype ;
   int tuner ;
   int radio ;
   int newi2c ;
   int i2c_clock_period ;
};
#line 198 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct ivtv_mailbox {
   u32 flags ;
   u32 cmd ;
   u32 retval ;
   u32 timeout ;
   u32 data[16U] ;
};
#line 207 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct ivtv_api_cache {
   unsigned long last_jiffies ;
   u32 data[16U] ;
};
#line 212 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct ivtv_mailbox_data {
   struct ivtv_mailbox  volatile  *mbox ;
   unsigned long busy ;
   u8 max_mbox ;
};
#line 220 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct ivtv_sg_element {
   __le32 src ;
   __le32 dst ;
   __le32 size ;
};
#line 276 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct ivtv_sg_host_element {
   u32 src ;
   u32 dst ;
   u32 size ;
};
#line 282 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct ivtv_user_dma {
   struct mutex lock ;
   int page_count ;
   struct page *map[704U] ;
   struct page *bouncemap[704U] ;
   struct ivtv_sg_element SGarray[704U] ;
   dma_addr_t SG_handle ;
   int SG_length ;
   struct scatterlist SGlist[704U] ;
};
#line 307 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct ivtv_buffer {
   struct list_head list ;
   dma_addr_t dma_handle ;
   unsigned short b_flags ;
   unsigned short dma_xfer_cnt ;
   char *buf ;
   u32 bytesused ;
   u32 readpos ;
};
#line 317 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct ivtv_queue {
   struct list_head list ;
   u32 buffers ;
   u32 length ;
   u32 bytesused ;
};
#line 324
struct ivtv;
#line 325 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct ivtv_stream {
   struct video_device vdev ;
   struct ivtv *itv ;
   char const   *name ;
   int type ;
   u32 caps ;
   struct v4l2_fh *fh ;
   spinlock_t qlock ;
   unsigned long s_flags ;
   int dma ;
   u32 pending_offset ;
   u32 pending_backup ;
   u64 pending_pts ;
   u32 dma_offset ;
   u32 dma_backup ;
   u64 dma_pts ;
   int subtype ;
   wait_queue_head_t waitq ;
   u32 dma_last_offset ;
   u32 buffers ;
   u32 buf_size ;
   u32 buffers_stolen ;
   struct ivtv_queue q_free ;
   struct ivtv_queue q_full ;
   struct ivtv_queue q_io ;
   struct ivtv_queue q_dma ;
   struct ivtv_queue q_predma ;
   u16 dma_xfer_cnt ;
   struct ivtv_sg_host_element *sg_pending ;
   struct ivtv_sg_host_element *sg_processing ;
   struct ivtv_sg_element *sg_dma ;
   dma_addr_t sg_handle ;
   int sg_pending_size ;
   int sg_processing_size ;
   int sg_processed ;
   struct scatterlist *SGlist ;
};
#line 393 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct yuv_frame_info {
   u32 update ;
   s32 src_x ;
   s32 src_y ;
   u32 src_w ;
   u32 src_h ;
   s32 dst_x ;
   s32 dst_y ;
   u32 dst_w ;
   u32 dst_h ;
   s32 pan_x ;
   s32 pan_y ;
   u32 vis_w ;
   u32 vis_h ;
   u32 interlaced_y ;
   u32 interlaced_uv ;
   s32 tru_x ;
   u32 tru_w ;
   u32 tru_h ;
   u32 offset_y ;
   s32 lace_mode ;
   u32 sync_field ;
   u32 delay ;
   u32 interlaced ;
};
#line 419 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct yuv_playback_info {
   u32 reg_2834 ;
   u32 reg_2838 ;
   u32 reg_283c ;
   u32 reg_2840 ;
   u32 reg_2844 ;
   u32 reg_2848 ;
   u32 reg_2854 ;
   u32 reg_285c ;
   u32 reg_2864 ;
   u32 reg_2870 ;
   u32 reg_2874 ;
   u32 reg_2890 ;
   u32 reg_2898 ;
   u32 reg_289c ;
   u32 reg_2918 ;
   u32 reg_291c ;
   u32 reg_2920 ;
   u32 reg_2924 ;
   u32 reg_2928 ;
   u32 reg_292c ;
   u32 reg_2930 ;
   u32 reg_2934 ;
   u32 reg_2938 ;
   u32 reg_293c ;
   u32 reg_2940 ;
   u32 reg_2944 ;
   u32 reg_2948 ;
   u32 reg_294c ;
   u32 reg_2950 ;
   u32 reg_2954 ;
   u32 reg_2958 ;
   u32 reg_295c ;
   u32 reg_2960 ;
   u32 reg_2964 ;
   u32 reg_2968 ;
   u32 reg_296c ;
   u32 reg_2970 ;
   int v_filter_1 ;
   int v_filter_2 ;
   int h_filter ;
   u8 track_osd ;
   u32 osd_x_offset ;
   u32 osd_y_offset ;
   u32 osd_x_pan ;
   u32 osd_y_pan ;
   u32 osd_vis_w ;
   u32 osd_vis_h ;
   u32 osd_full_w ;
   u32 osd_full_h ;
   int decode_height ;
   int lace_mode ;
   int lace_threshold ;
   int lace_sync_field ;
   atomic_t next_dma_frame ;
   atomic_t next_fill_frame ;
   u32 yuv_forced_update ;
   int update_frame ;
   u8 fields_lapsed ;
   struct yuv_frame_info new_frame_info[8U] ;
   struct yuv_frame_info old_frame_info ;
   struct yuv_frame_info old_frame_info_args ;
   void *blanking_ptr ;
   dma_addr_t blanking_dmaptr ;
   int stream_size ;
   u8 draw_frame ;
   u8 max_frames_buffered ;
   struct v4l2_rect main_rect ;
   u32 v4l2_src_w ;
   u32 v4l2_src_h ;
   u8 running ;
};
#line 526 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct vbi_cc {
   u8 odd[2U] ;
   u8 even[2U] ;
};
#line 534 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct vbi_vps {
   u8 data[5U] ;
};
#line 538 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct vbi_info {
   u32 raw_decoder_line_size ;
   u8 raw_decoder_sav_odd_field ;
   u8 raw_decoder_sav_even_field ;
   u32 sliced_decoder_line_size ;
   u8 sliced_decoder_sav_odd_field ;
   u8 sliced_decoder_sav_even_field ;
   u32 start[2U] ;
   u32 count ;
   u32 raw_size ;
   u32 sliced_size ;
   u32 dec_start ;
   u32 enc_start ;
   u32 enc_size ;
   int fpi ;
   struct v4l2_format in ;
   struct v4l2_sliced_vbi_format *sliced_in ;
   int insert_mpeg ;
   u32 frame ;
   struct vbi_cc cc_payload[256U] ;
   int cc_payload_idx ;
   u8 cc_missing_cnt ;
   int wss_payload ;
   u8 wss_missing_cnt ;
   struct vbi_vps vps_payload ;
   struct v4l2_sliced_vbi_data sliced_data[36U] ;
   struct v4l2_sliced_vbi_data sliced_dec_data[36U] ;
   u8 *sliced_mpeg_data[32U] ;
   u32 sliced_mpeg_size[32U] ;
   struct ivtv_buffer sliced_mpeg_buf ;
   u32 inserted_frame ;
};
#line 604
struct ivtv_card;
#line 605
struct ivtv_card_tuner_i2c;
#line 605 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct __anonstruct____missing_field_name_312 {
   struct v4l2_ctrl *ctrl_pts ;
   struct v4l2_ctrl *ctrl_frame ;
};
#line 605 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct __anonstruct____missing_field_name_313 {
   struct v4l2_ctrl *ctrl_audio_playback ;
   struct v4l2_ctrl *ctrl_audio_multilingual_playback ;
};
#line 605
struct snd_ivtv_card;
#line 605
struct osd_info;
#line 605 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct ivtv {
   struct pci_dev *pdev ;
   struct ivtv_card  const  *card ;
   char const   *card_name ;
   struct ivtv_card_tuner_i2c  const  *card_i2c ;
   u8 has_cx23415 ;
   u8 pvr150_workaround ;
   u8 nof_inputs ;
   u8 nof_audio_inputs ;
   u32 v4l2_cap ;
   u32 hw_flags ;
   v4l2_std_id tuner_std ;
   struct v4l2_subdev *sd_video ;
   struct v4l2_subdev *sd_audio ;
   struct v4l2_subdev *sd_muxer ;
   resource_size_t base_addr ;
   void volatile   *enc_mem ;
   void volatile   *dec_mem ;
   void volatile   *reg_mem ;
   struct ivtv_options options ;
   struct v4l2_device v4l2_dev ;
   struct cx2341x_handler cxhdl ;
   struct __anonstruct____missing_field_name_312 __annonCompField105 ;
   struct __anonstruct____missing_field_name_313 __annonCompField106 ;
   struct v4l2_ctrl_handler hdl_gpio ;
   struct v4l2_subdev sd_gpio ;
   u16 instance ;
   unsigned long i_flags ;
   u8 is_50hz ;
   u8 is_60hz ;
   u8 is_out_50hz ;
   u8 is_out_60hz ;
   int output_mode ;
   u32 audio_input ;
   u32 active_input ;
   u32 active_output ;
   v4l2_std_id std ;
   v4l2_std_id std_out ;
   u8 audio_stereo_mode ;
   u8 audio_bilingual_mode ;
   spinlock_t lock ;
   struct mutex serialize_lock ;
   int stream_buf_size[9U] ;
   struct ivtv_stream streams[9U] ;
   atomic_t capturing ;
   atomic_t decoding ;
   struct snd_ivtv_card *alsa ;
   void (*pcm_announce_callback)(struct snd_ivtv_card * , u8 * , size_t  ) ;
   struct work_struct request_module_wk ;
   u32 irqmask ;
   u32 irq_rr_idx ;
   struct kthread_worker irq_worker ;
   struct task_struct *irq_worker_task ;
   struct kthread_work irq_work ;
   spinlock_t dma_reg_lock ;
   int cur_dma_stream ;
   int cur_pio_stream ;
   u32 dma_data_req_offset ;
   u32 dma_data_req_size ;
   int dma_retries ;
   struct ivtv_user_dma udma ;
   struct timer_list dma_timer ;
   u32 last_vsync_field ;
   wait_queue_head_t dma_waitq ;
   wait_queue_head_t eos_waitq ;
   wait_queue_head_t event_waitq ;
   wait_queue_head_t vsync_waitq ;
   struct ivtv_mailbox_data enc_mbox ;
   struct ivtv_mailbox_data dec_mbox ;
   struct ivtv_api_cache api_cache[256U] ;
   struct i2c_adapter i2c_adap ;
   struct i2c_algo_bit_data i2c_algo ;
   struct i2c_client i2c_client ;
   int i2c_state ;
   struct mutex i2c_bus_lock ;
   struct IR_i2c_init_data ir_i2c_init_data ;
   u32 pgm_info_offset ;
   u32 pgm_info_num ;
   u32 pgm_info_write_idx ;
   u32 pgm_info_read_idx ;
   struct v4l2_enc_idx_entry pgm_info[400U] ;
   u32 open_id ;
   int search_pack_header ;
   int speed ;
   u8 speed_mute_audio ;
   u64 mpg_data_received ;
   u64 vbi_data_inserted ;
   u32 last_dec_timing[3U] ;
   unsigned long dualwatch_jiffies ;
   u32 dualwatch_stereo_mode ;
   struct vbi_info vbi ;
   struct yuv_playback_info yuv_info ;
   unsigned long osd_video_pbase ;
   int osd_global_alpha_state ;
   int osd_local_alpha_state ;
   int osd_chroma_key_state ;
   u8 osd_global_alpha ;
   u32 osd_chroma_key ;
   struct v4l2_rect osd_rect ;
   struct v4l2_rect main_rect ;
   struct osd_info *osd_info ;
   void (*ivtvfb_restore)(struct ivtv * ) ;
};
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-i2c.h"
struct ivtv_card_video_input {
   u8 video_type ;
   u8 audio_index ;
   u16 video_input ;
};
#line 187 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
struct ivtv_card_audio_input {
   u8 audio_type ;
   u32 audio_input ;
   u16 muxer_input ;
};
#line 193 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
struct ivtv_card_output {
   u8 name[32U] ;
   u16 video_output ;
};
#line 199 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
struct ivtv_card_pci_info {
   u16 device ;
   u16 subsystem_vendor ;
   u16 subsystem_device ;
};
#line 205 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
struct ivtv_gpio_init {
   u16 direction ;
   u16 initial_value ;
};
#line 214 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
struct ivtv_gpio_video_input {
   u16 mask ;
   u16 tuner ;
   u16 composite ;
   u16 svideo ;
};
#line 221 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
struct ivtv_gpio_audio_input {
   u16 mask ;
   u16 tuner ;
   u16 linein ;
   u16 radio ;
};
#line 228 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
struct ivtv_gpio_audio_mute {
   u16 mask ;
   u16 mute ;
};
#line 233 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
struct ivtv_gpio_audio_mode {
   u16 mask ;
   u16 mono ;
   u16 stereo ;
   u16 lang1 ;
   u16 lang2 ;
   u16 both ;
};
#line 242 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
struct ivtv_gpio_audio_freq {
   u16 mask ;
   u16 f32000 ;
   u16 f44100 ;
   u16 f48000 ;
};
#line 249 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
struct ivtv_gpio_audio_detect {
   u16 mask ;
   u16 stereo ;
};
#line 254 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
struct ivtv_card_tuner {
   v4l2_std_id std ;
   int tuner ;
};
#line 260 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
struct ivtv_card_tuner_i2c {
   unsigned short radio[2U] ;
   unsigned short demod[2U] ;
   unsigned short tv[4U] ;
};
#line 266 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
struct ivtv_card {
   int type ;
   char *name ;
   char *comment ;
   u32 v4l2_capabilities ;
   u32 hw_video ;
   u32 hw_audio ;
   u32 hw_audio_ctrl ;
   u32 hw_muxer ;
   u32 hw_all ;
   struct ivtv_card_video_input video_inputs[6U] ;
   struct ivtv_card_audio_input audio_inputs[3U] ;
   struct ivtv_card_audio_input radio_input ;
   int nof_outputs ;
   struct ivtv_card_output  const  *video_outputs ;
   u8 gr_config ;
   u8 xceive_pin ;
   struct ivtv_gpio_init gpio_init ;
   struct ivtv_gpio_video_input gpio_video_input ;
   struct ivtv_gpio_audio_input gpio_audio_input ;
   struct ivtv_gpio_audio_mute gpio_audio_mute ;
   struct ivtv_gpio_audio_mode gpio_audio_mode ;
   struct ivtv_gpio_audio_freq gpio_audio_freq ;
   struct ivtv_gpio_audio_detect gpio_audio_detect ;
   struct ivtv_card_tuner tuners[3U] ;
   struct ivtv_card_tuner_i2c *i2c ;
   struct ivtv_card_pci_info  const  *pci_list ;
};
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
typedef bool ldv_func_ret_type;
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
typedef bool ldv_func_ret_type___0;
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
typedef bool ldv_func_ret_type___1;
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 489 "./arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_33 {
   unsigned long seg ;
};
#line 489 "./arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_33 mm_segment_t;
#line 131 "include/asm-generic/atomic-long.h"
struct thread_info {
   struct task_struct *task ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int saved_preempt_count ;
   mm_segment_t addr_limit ;
   void *sysenter_return ;
   unsigned char sig_on_uaccess_error : 1 ;
   unsigned char uaccess_err : 1 ;
};
#line 12 "include/linux/wait.h"
struct __wait_queue;
#line 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 243 "include/linux/timer.h"
enum hrtimer_restart;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 59 "include/linux/sched/prio.h"
struct sched_param {
   int sched_priority ;
};
#line 599 "include/linux/slab.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 63 "include/uapi/linux/fs.h"
struct iovec;
#line 1200 "include/linux/mm.h"
struct kvec;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 380 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct ivtv_open_id {
   struct v4l2_fh fh ;
   int type ;
   int yuv_frames ;
   struct ivtv *itv ;
};
#line 786
struct tveeprom;
#line 35 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-gpio.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion____missing_field_name_314 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_314 __annonCompField107 ;
   unsigned long nr_segs ;
};
#line 218 "include/net/flow_dissector.h"
struct pipe_buf_operations;
#line 218 "include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 27 "include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
#line 61 "include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
#line 34 "include/linux/if_ether.h"
struct tveeprom {
   u32 has_radio ;
   u32 has_ir ;
   u32 has_MAC_address ;
   u32 tuner_type ;
   u32 tuner_formats ;
   u32 tuner_hauppauge_model ;
   u32 tuner2_type ;
   u32 tuner2_formats ;
   u32 tuner2_hauppauge_model ;
   u32 digitizer ;
   u32 digitizer_formats ;
   u32 audio_processor ;
   u32 decoder_processor ;
   u32 model ;
   u32 revision ;
   u32 serial_number ;
   char rev_str[5U] ;
   u8 MAC_address[6U] ;
};
#line 451 "./drivers/media/dvb-core/dvb_frontend.h"
struct xc2028_ctrl {
   char *fname ;
   int max_len ;
   int msleep ;
   unsigned int scode_table ;
   unsigned char mts : 1 ;
   unsigned char input1 : 1 ;
   unsigned char vhfbw7 : 1 ;
   unsigned char uhfbw8 : 1 ;
   unsigned char disable_power_mgmt : 1 ;
   unsigned char read_not_reliable : 1 ;
   unsigned int demod ;
   unsigned char type : 2 ;
};
#line 770 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
typedef bool ldv_func_ret_type___3;
#line 781 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
typedef int ldv_func_ret_type___4;
#line 802 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
typedef int ldv_func_ret_type___5;
#line 821 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
typedef int ldv_func_ret_type___6;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 40 "include/linux/poll.h"
typedef struct poll_table_struct poll_table;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 308 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 42 "include/linux/i2c.h"
struct i2c_board_info;
#line 43
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 271 "include/linux/i2c.h"
struct i2c_board_info {
   char type[20U] ;
   unsigned short flags ;
   unsigned short addr ;
   void *platform_data ;
   struct dev_archdata *archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   int irq ;
};
#line 160 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-i2c.h"
struct cx25840_platform_data {
   int pvr150_workaround ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 130 "include/linux/kthread.h"
enum ldv_26429 {
    VIDEO_FORMAT_4_3 = 0,
    VIDEO_FORMAT_16_9 = 1,
    VIDEO_FORMAT_221_1 = 2
} ;
#line 37 "./include/uapi/linux/dvb/video.h"
typedef enum ldv_26429 video_format_t;
#line 62 "./include/uapi/linux/dvb/video.h"
struct __anonstruct_video_size_t_254 {
   int w ;
   int h ;
   video_format_t aspect_ratio ;
};
#line 62 "./include/uapi/linux/dvb/video.h"
typedef struct __anonstruct_video_size_t_254 video_size_t;
#line 123 "./include/uapi/linux/dvb/video.h"
union __anonunion_u_259 {
   video_size_t size ;
   unsigned int frame_rate ;
   unsigned char vsync_field ;
};
#line 123 "./include/uapi/linux/dvb/video.h"
struct video_event {
   __s32 type ;
   __kernel_time_t timestamp ;
   union __anonunion_u_259 u ;
};
#line 2009 "include/uapi/linux/videodev2.h"
struct v4l2_event_vsync {
   __u8 field ;
};
#line 2028 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_279 {
   __s32 value ;
   __s64 value64 ;
};
#line 2028 "include/uapi/linux/videodev2.h"
struct v4l2_event_ctrl {
   __u32 changes ;
   __u32 type ;
   union __anonunion____missing_field_name_279 __annonCompField87 ;
   __u32 flags ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 step ;
   __s32 default_value ;
};
#line 2047 "include/uapi/linux/videodev2.h"
struct v4l2_event_frame_sync {
   __u32 frame_sequence ;
};
#line 2051 "include/uapi/linux/videodev2.h"
struct v4l2_event_src_change {
   __u32 changes ;
};
#line 2057 "include/uapi/linux/videodev2.h"
struct v4l2_event_motion_det {
   __u32 flags ;
   __u32 frame_sequence ;
   __u32 region_mask ;
};
#line 2072 "include/uapi/linux/videodev2.h"
union __anonunion_u_280 {
   struct v4l2_event_vsync vsync ;
   struct v4l2_event_ctrl ctrl ;
   struct v4l2_event_frame_sync frame_sync ;
   struct v4l2_event_src_change src_change ;
   struct v4l2_event_motion_det motion_det ;
   __u8 data[64U] ;
};
#line 2072 "include/uapi/linux/videodev2.h"
struct v4l2_event {
   __u32 type ;
   union __anonunion_u_280 u ;
   __u32 pending ;
   __u32 sequence ;
   struct timespec timestamp ;
   __u32 id ;
   __u32 reserved[8U] ;
};
#line 335 "include/media/v4l2-ioctl.h"
struct v4l2_subscribed_event;
#line 792 "include/media/v4l2-ctrls.h"
struct v4l2_subscribed_event_ops;
#line 54 "include/media/ir-kbd-i2c.h"
struct ivtv_dma_frame {
   enum v4l2_buf_type type ;
   __u32 pixelformat ;
   void *y_source ;
   void *uv_source ;
   struct v4l2_rect src ;
   struct v4l2_rect dst ;
   __u32 src_width ;
   __u32 src_height ;
};
#line 52 "include/media/tveeprom.h"
struct v4l2_kevent {
   struct list_head list ;
   struct v4l2_subscribed_event *sev ;
   struct v4l2_event event ;
};
#line 81 "include/media/v4l2-event.h"
struct v4l2_subscribed_event_ops {
   int (*add)(struct v4l2_subscribed_event * , unsigned int  ) ;
   void (*del)(struct v4l2_subscribed_event * ) ;
   void (*replace)(struct v4l2_event * , struct v4l2_event  const  * ) ;
   void (*merge)(struct v4l2_event  const  * , struct v4l2_event * ) ;
};
#line 94 "include/media/v4l2-event.h"
struct v4l2_subscribed_event {
   struct list_head list ;
   u32 type ;
   u32 id ;
   u32 flags ;
   struct v4l2_fh *fh ;
   struct list_head node ;
   struct v4l2_subscribed_event_ops  const  *ops ;
   unsigned int elems ;
   unsigned int first ;
   unsigned int in_use ;
   struct v4l2_kevent events[] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.o.c.prepared"
typedef int ldv_func_ret_type___7;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.o.c"
struct va_list;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.o.c"

#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 34 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-mailbox.h"
struct ivtv_api_info {
   int flags ;
   char const   *name ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
struct __anonstruct_ivtv_stream_info_314 {
   char const   *name ;
   int vfl_type ;
   int num_offset ;
   int dma ;
   int pio ;
   u32 v4l2_caps ;
   struct v4l2_file_operations  const  *fops ;
};
#line 428 "./arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 197 "./arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 72 "./arch/x86/include/asm/preempt.h"
typedef int pao_T__;
#line 77 "./arch/x86/include/asm/preempt.h"
typedef int pao_T_____0;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 298 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
struct ivtv_dma_page_info {
   unsigned long uaddr ;
   unsigned long first ;
   unsigned long last ;
   unsigned int offset ;
   unsigned int tail ;
   int page_count ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 57 "./arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 429 "include/linux/workqueue.h"
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 433
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 439
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 443
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 452
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 455
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
int ldv_timer_state_3  =    0;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
int ldv_irq_1_3  =    0;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
int ldv_irq_1_0  =    0;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
int ldv_irq_1_2  =    0;
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
int ldv_irq_1_1  =    0;
#line 92
void call_and_disable_all_2(int state ) ;
#line 95
void activate_work_2(struct work_struct *work , int state ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-routing.h"
void ivtv_audio_set_io(struct ivtv *itv ) ;
#line 25
void ivtv_video_set_io(struct ivtv *itv ) ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.c"
void ivtv_audio_set_io(struct ivtv *itv ) 
{ 
  struct ivtv_card_audio_input  const  *in ;
  u32 input ;
  u32 output ;
  int tmp ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 37
  output = 0U;
#line 40
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& itv->i_flags));
#line 40
  if (tmp != 0) {
#line 41
    in = & (itv->card)->radio_input;
  } else {
#line 43
    in = (struct ivtv_card_audio_input  const  *)(& (itv->card)->audio_inputs) + (unsigned long )itv->audio_input;
  }
#line 46
  input = (u32 )in->muxer_input;
#line 47
  if (((unsigned int )(itv->card)->hw_muxer & 16384U) != 0U) {
#line 48
    output = 49344U;
  } else {

  }
#line 49
  if ((unsigned long )itv->sd_muxer != (unsigned long )((struct v4l2_subdev *)0)) {
#line 49
    if ((unsigned long )((itv->sd_muxer)->ops)->audio != (unsigned long )((struct v4l2_subdev_audio_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_muxer)->ops)->audio)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                        u32  ,
                                                                                                                                                                                                                                        u32  ,
                                                                                                                                                                                                                                        u32  ))0)) {
#line 49
      (*((((itv->sd_muxer)->ops)->audio)->s_routing))(itv->sd_muxer, input, output,
                                                      0U);
    } else {

    }
  } else {

  }
#line 52
  input = in->audio_input;
#line 53
  output = 0U;
#line 54
  if (((unsigned int )(itv->card)->hw_audio & 8U) != 0U) {
#line 55
    output = 68U;
  } else {

  }
#line 56
  __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 56
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 56
  goto ldv_39012;
  ldv_39011: ;
#line 56
  if ((((unsigned int )(itv->card)->hw_audio == 0U || (__sd->grp_id & (u32 )(itv->card)->hw_audio) != 0U) && (unsigned long )(__sd->ops)->audio != (unsigned long )((struct v4l2_subdev_audio_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->audio)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                                                                                        u32  ,
                                                                                                                                                                                                                                                                                                                        u32  ,
                                                                                                                                                                                                                                                                                                                        u32  ))0)) {
#line 56
    (*(((__sd->ops)->audio)->s_routing))(__sd, input, output, 0U);
  } else {

  }
#line 56
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 56
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_39012: ;
#line 56
  if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 58
    goto ldv_39011;
  } else {

  }

#line 64
  return;
}
}
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.c"
void ivtv_video_set_io(struct ivtv *itv ) 
{ 
  int inp ;
  u32 input ;
  u32 type ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct v4l2_subdev *__sd___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct v4l2_subdev *__sd___1 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;

  {
#line 64
  inp = (int )itv->active_input;
#line 68
  if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 68
    if ((unsigned long )((itv->sd_video)->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->video)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                        u32  ,
                                                                                                                                                                                                                                        u32  ,
                                                                                                                                                                                                                                        u32  ))0)) {
#line 68
      (*((((itv->sd_video)->ops)->video)->s_routing))(itv->sd_video, (u32 )(itv->card)->video_inputs[inp].video_input,
                                                      0U, 0U);
    } else {

    }
  } else {

  }
#line 71
  type = (u32 )(itv->card)->video_inputs[inp].video_type;
#line 73
  if (type == 1U) {
#line 74
    input = 0U;
  } else
#line 75
  if (type <= 3U) {
#line 76
    input = 2U;
  } else {
#line 78
    input = 1U;
  }
#line 81
  if (((unsigned int )(itv->card)->hw_video & 32768U) != 0U) {
#line 82
    __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 82
    __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 82
    goto ldv_39026;
    ldv_39025: ;
#line 82
    if (((__sd->grp_id & 32768U) != 0U && (unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->video)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                     u32  ,
                                                                                                                                                                                                                                                     u32  ,
                                                                                                                                                                                                                                                     u32  ))0)) {
#line 82
      (*(((__sd->ops)->video)->s_routing))(__sd, input, 0U, 0U);
    } else {

    }
#line 82
    __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 82
    __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
    ldv_39026: ;
#line 82
    if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 84
      goto ldv_39025;
    } else {

    }

  } else {

  }
#line 85
  if (((unsigned int )(itv->card)->hw_video & 512U) != 0U) {
#line 86
    if (type == 1U || type > 3U) {
#line 89
      input = 8U;
    } else {
#line 92
      input = 1U;
    }
#line 94
    input = (u32 )(itv->card)->gr_config | input;
#line 96
    __mptr___1 = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 96
    __sd___0 = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff88UL;
#line 96
    goto ldv_39034;
    ldv_39033: ;
#line 96
    if (((__sd___0->grp_id & 512U) != 0U && (unsigned long )(__sd___0->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0)) && (unsigned long )((__sd___0->ops)->video)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                               u32  ,
                                                                                                                                                                                                                                                               u32  ,
                                                                                                                                                                                                                                                               u32  ))0)) {
#line 96
      (*(((__sd___0->ops)->video)->s_routing))(__sd___0, input, 0U, 0U);
    } else {

    }
#line 96
    __mptr___2 = (struct list_head  const  *)__sd___0->list.next;
#line 96
    __sd___0 = (struct v4l2_subdev *)__mptr___2 + 0xffffffffffffff88UL;
    ldv_39034: ;
#line 96
    if ((unsigned long )(& __sd___0->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 98
      goto ldv_39033;
    } else {

    }

  } else {

  }
#line 100
  if (((unsigned int )(itv->card)->hw_video & 1024U) != 0U) {
#line 101
    input = 0U;
#line 102
    if (type > 1U && type <= 3U) {
#line 106
      input = input | 3U;
    } else
#line 108
    if (((unsigned int )(itv->card)->hw_video & 512U) != 0U) {
#line 111
      if (type == 1U || (int )(itv->card)->type == 11) {
#line 113
        input = input | 4U;
      } else {

      }
    } else {

    }
#line 116
    __mptr___3 = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 116
    __sd___1 = (struct v4l2_subdev *)__mptr___3 + 0xffffffffffffff88UL;
#line 116
    goto ldv_39042;
    ldv_39041: ;
#line 116
    if (((__sd___1->grp_id & 1024U) != 0U && (unsigned long )(__sd___1->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0)) && (unsigned long )((__sd___1->ops)->video)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                                u32  ,
                                                                                                                                                                                                                                                                u32  ,
                                                                                                                                                                                                                                                                u32  ))0)) {
#line 116
      (*(((__sd___1->ops)->video)->s_routing))(__sd___1, input, 0U, 0U);
    } else {

    }
#line 116
    __mptr___4 = (struct list_head  const  *)__sd___1->list.next;
#line 116
    __sd___1 = (struct v4l2_subdev *)__mptr___4 + 0xffffffffffffff88UL;
    ldv_39042: ;
#line 116
    if ((unsigned long )(& __sd___1->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 118
      goto ldv_39041;
    } else {

    }

  } else {

  }
#line 125
  return;
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 142
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 142
  ldv_func_res = tmp;
#line 144
  activate_work_2(ldv_func_arg3, 2);
#line 146
  return (ldv_func_res);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 153
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 153
  ldv_func_res = tmp;
#line 155
  activate_work_2(& ldv_func_arg3->work, 2);
#line 157
  return (ldv_func_res);
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 164
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 164
  ldv_func_res = tmp;
#line 166
  activate_work_2(ldv_func_arg3, 2);
#line 168
  return (ldv_func_res);
}
}
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 174
  flush_workqueue(ldv_func_arg1);
#line 176
  call_and_disable_all_2(2);
#line 177
  return;
}
}
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-routing.o.c.prepared"
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 183
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 183
  ldv_func_res = tmp;
#line 185
  activate_work_2(& ldv_func_arg3->work, 2);
#line 187
  return (ldv_func_res);
}
}
#line 26 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_19(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_21(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_20(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_23(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_22(struct workqueue_struct *ldv_func_arg1 ) ;
#line 303 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-cards.h"
int ivtv_get_input(struct ivtv *itv , u16 index , struct v4l2_input *input ) ;
#line 304
int ivtv_get_output(struct ivtv *itv , u16 index , struct v4l2_output *output ) ;
#line 305
int ivtv_get_audio_input(struct ivtv *itv , u16 index , struct v4l2_audio *audio ) ;
#line 306
int ivtv_get_audio_output(struct ivtv *itv , u16 index , struct v4l2_audioout *aud_output ) ;
#line 307
struct ivtv_card  const  *ivtv_get_card(u16 index ) ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_tuner_i2c ivtv_i2c_std  =    {{65534U}, {67U, 65534U}, {97U, 96U, 65534U}};
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_tuner_i2c ivtv_i2c_radio  =    {{96U, 65534U}, {67U, 65534U}, {97U, 65534U}};
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_tuner_i2c ivtv_i2c_tda8290  =    {{65534U}, {65534U}, {75U, 65534U}};
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_pvr250  = 
#line 76
     {0, (char *)"Hauppauge WinTV PVR-250", 0, 16973905U, 2U, 8U, 8U, 0U, 154U, {{1U,
                                                                                0U,
                                                                                4U},
                                                                               {2U,
                                                                                1U,
                                                                                6U},
                                                                               {4U,
                                                                                1U,
                                                                                0U},
                                                                               {3U,
                                                                                2U,
                                                                                7U},
                                                                               {5U,
                                                                                2U,
                                                                                1U},
                                                                               {6U,
                                                                                1U,
                                                                                5U}},
    {{1U, 0U, (unsigned short)0}, {2U, 2236960U, (unsigned short)0}, {3U, 2236962U,
                                                                      (unsigned short)0}},
    {1U, 2236961U, (unsigned short)0}, 0, 0, (unsigned char)0, (unsigned char)0, {(unsigned short)0,
                                                                                  (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{0ULL, 0}, {0ULL, 0}, {0ULL, 0}}, & ivtv_i2c_std,
    0};
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_output ivtv_pvr350_outputs[6U]  = {      {{'S', '-', 'V', 'i', 'd', 'e', 'o', ' ', '+', ' ', 'C', 'o', 'm', 'p', 'o',
       's', 'i', 't', 'e', '\000'}, 0U}, 
        {{'C', 'o', 'm', 'p', 'o', 's', 'i', 't', 'e', '\000'}, 1U}, 
        {{'S', '-', 'V', 'i', 'd', 'e', 'o', '\000'}, 2U}, 
        {{'R', 'G', 'B', '\000'}, 3U}, 
        {{'Y', 'U', 'V', ' ', 'C', '\000'}, 4U}, 
        {{'Y', 'U', 'V', ' ', 'V', '\000'}, 5U}};
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_pvr350  = 
#line 129
     {1, (char *)"Hauppauge WinTV PVR-350", 0, 16974547U, 2U, 8U, 8U, 0U, 393374U, {{1U,
                                                                                   0U,
                                                                                   4U},
                                                                                  {2U,
                                                                                   1U,
                                                                                   6U},
                                                                                  {4U,
                                                                                   1U,
                                                                                   0U},
                                                                                  {3U,
                                                                                   2U,
                                                                                   7U},
                                                                                  {5U,
                                                                                   2U,
                                                                                   1U},
                                                                                  {6U,
                                                                                   1U,
                                                                                   5U}},
    {{1U, 0U, (unsigned short)0}, {2U, 2236960U, (unsigned short)0}, {3U, 2236962U,
                                                                      (unsigned short)0}},
    {1U, 2236961U, (unsigned short)0}, 6, (struct ivtv_card_output  const  *)(& ivtv_pvr350_outputs),
    (unsigned char)0, (unsigned char)0, {(unsigned short)0, (unsigned short)0}, {(unsigned short)0,
                                                                                 (unsigned short)0,
                                                                                 (unsigned short)0,
                                                                                 (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{0ULL, 0}, {0ULL, 0}, {0ULL, 0}}, & ivtv_i2c_std,
    0};
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_pvr350_v1  = 
#line 162
     {28, (char *)"Hauppauge WinTV PVR-350 (V1)", 0, 16974547U, 256U, 8U, 8U, 0U, 412U,
    {{1U, 0U, 4U}, {2U, 1U, 6U}, {4U, 1U, 0U}, {3U, 2U, 7U}, {5U, 2U, 1U}, {6U, 1U,
                                                                            5U}},
    {{1U, 2236966U, (unsigned short)0}, {2U, 2236960U, (unsigned short)0}, {3U, 2236962U,
                                                                            (unsigned short)0}},
    {1U, 2236961U, (unsigned short)0}, 6, (struct ivtv_card_output  const  *)(& ivtv_pvr350_outputs),
    (unsigned char)0, (unsigned char)0, {(unsigned short)0, (unsigned short)0}, {(unsigned short)0,
                                                                                 (unsigned short)0,
                                                                                 (unsigned short)0,
                                                                                 (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{0ULL, 0}, {0ULL, 0}, {0ULL, 0}}, & ivtv_i2c_std,
    0};
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_pvr150  = 
#line 194
     {2, (char *)"Hauppauge WinTV PVR-150", 0, 16973905U, 1U, 1U, 1U, 32U, 1966257U,
    {{1U, 0U, 7U}, {2U, 1U, 1296U}, {4U, 1U, 3U}, {3U, 2U, 1568U}, {5U, 2U, 4U}},
    {{1U, 8U, 2U}, {2U, 0U, 2U}, {3U, 0U, 4U}}, {1U, 0U, 8U}, 0, 0, (unsigned char)0,
    (unsigned char)0, {7937U, 9971U}, {(unsigned short)0, (unsigned short)0, (unsigned short)0,
                                       (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                                            (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{0ULL, 0}, {0ULL, 0}, {0ULL, 0}}, & ivtv_i2c_std,
    0};
#line 232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_m179[3U]  = {      {2051U, 5217U, 41935U}, 
        {2051U, 5217U, 41934U}, 
        {0U, 0U, 0U}};
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_m179  = 
#line 238
     {3, (char *)"AVerMedia M179", 0, 16973905U, 256U, 32768U, 32768U, 0U, 33040U, {{1U,
                                                                                   0U,
                                                                                   4U},
                                                                                  {2U,
                                                                                   1U,
                                                                                   6U},
                                                                                  {4U,
                                                                                   1U,
                                                                                   3U}},
    {{1U, 0U, (unsigned short)0}, {2U, 1U, (unsigned short)0}}, {(unsigned char)0,
                                                                 0U, (unsigned short)0},
    0, 0, (unsigned char)0, (unsigned char)0, {58240U, 33424U}, {(unsigned short)0,
                                                                 (unsigned short)0,
                                                                 (unsigned short)0,
                                                                 (unsigned short)0},
    {32832U, 32768U, 0U, (unsigned short)0}, {8192U, 8192U}, {17152U, 16384U, 512U,
                                                              512U, 256U, 0U}, {24U,
                                                                                0U,
                                                                                8U,
                                                                                16U},
    {16384U, 0U}, {{16777215ULL, 2}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_m179)};
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_mpg600[3U]  = {      {22U, 4779U, 65523U}, 
        {22U, 4779U, 65535U}, 
        {0U, 0U, 0U}};
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_mpg600  = 
#line 281
     {4, (char *)"Yuan MPG600, Kuroutoshikou ITVC16-STVLP", 0, 16973905U, 2U, 32768U,
    32768U, 0U, 32786U, {{1U, 0U, 4U}, {2U, 1U, 6U}, {4U, 1U, 3U}}, {{1U, 0U, (unsigned short)0},
                                                                     {2U, 1U, (unsigned short)0}},
    {(unsigned char)0, 0U, (unsigned short)0}, 0, 0, (unsigned char)0, (unsigned char)0,
    {12416U, 4U}, {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {12288U, 0U, 8192U, (unsigned short)0}, {1U, 1U}, {14U, 6U, 4U, 4U, 0U, 8U}, {(unsigned short)0,
                                                                                  (unsigned short)0,
                                                                                  (unsigned short)0,
                                                                                  (unsigned short)0},
    {2304U, 256U}, {{16711935ULL, 24}, {16777215ULL, 53}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_mpg600)};
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_mpg160[3U]  = {      {2051U, 4779U, 0U}, 
        {2051U, 4348U, 16544U}, 
        {0U, 0U, 0U}};
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_mpg160  = 
#line 323
     {5, (char *)"YUAN MPG160, Kuroutoshikou ITVC15-STVLP, I/O Data GV-M2TV/PCI", 0,
    16973905U, 256U, 32768U, 32768U, 0U, 33040U, {{1U, 0U, 4U}, {2U, 1U, 6U}, {4U,
                                                                               1U,
                                                                               3U}},
    {{1U, 0U, (unsigned short)0}, {2U, 1U, (unsigned short)0}}, {(unsigned char)0,
                                                                 0U, (unsigned short)0},
    0, 0, (unsigned char)0, (unsigned char)0, {28800U, 16396U}, {(unsigned short)0,
                                                                 (unsigned short)0,
                                                                 (unsigned short)0,
                                                                 (unsigned short)0},
    {12288U, 0U, 8192U, (unsigned short)0}, {1U, 1U}, {14U, 6U, 4U, 4U, 0U, 8U}, {(unsigned short)0,
                                                                                  (unsigned short)0,
                                                                                  (unsigned short)0,
                                                                                  (unsigned short)0},
    {2304U, 256U}, {{16711935ULL, 24}, {16777215ULL, 53}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_mpg160)};
#line 358 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_pg600[3U]  = {      {22U, 65426U, 112U}, 
        {22U, 65451U, 1536U}, 
        {0U, 0U, 0U}};
#line 364 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_pg600  = 
#line 364
     {6, (char *)"Yuan PG600, Diamond PVR-550", 0, 16973905U, 1U, 1U, 1U, 0U, 17U, {{1U,
                                                                                   0U,
                                                                                   2U},
                                                                                  {2U,
                                                                                   1U,
                                                                                   1072U},
                                                                                  {4U,
                                                                                   1U,
                                                                                   1U}},
    {{1U, 5U, (unsigned short)0}, {2U, 0U, (unsigned short)0}}, {(unsigned char)0,
                                                                 0U, (unsigned short)0},
    0, 0, (unsigned char)0, (unsigned char)0, {(unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{16711935ULL, 24}, {16777215ULL, 53}},
    & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_pg600)};
#line 394 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_avc2410[2U]  = {      {22U, 36869U, 147U}, 
        {0U, 0U, 0U}};
#line 399 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_avc2410  = 
#line 399
     {7, (char *)"Adaptec VideOh! AVC-2410", 0, 16973905U, 2U, 8U, 8U, 64U, 2097242U,
    {{1U, 0U, 4U}, {2U, 1U, 6U}, {4U, 1U, 3U}}, {{1U, 0U, 0U}, {2U, 2236960U, 2U}},
    {(unsigned char)0, 0U, (unsigned short)0}, 0, 0, (unsigned char)0, (unsigned char)0,
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{16711935ULL, 38}, {16769023ULL, 43},
                                             {8192ULL, 53}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_avc2410)};
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_avc2010[2U]  = {      {22U, 36869U, 146U}, 
        {0U, 0U, 0U}};
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_avc2010  = 
#line 443
     {8, (char *)"Adaptec VideOh! AVC-2010", 0, 16973905U, 2U, 64U, 64U, 0U, 66U, {{2U,
                                                                                  0U,
                                                                                  6U},
                                                                                 {4U,
                                                                                  0U,
                                                                                  3U}},
    {{2U, 2U, (unsigned short)0}}, {(unsigned char)0, 0U, (unsigned short)0}, 0, 0,
    (unsigned char)0, (unsigned char)0, {(unsigned short)0, (unsigned short)0}, {(unsigned short)0,
                                                                                 (unsigned short)0,
                                                                                 (unsigned short)0,
                                                                                 (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{0ULL, 0}, {0ULL, 0}, {0ULL, 0}}, 0,
    (struct ivtv_card_pci_info  const  *)(& ivtv_pci_avc2010)};
#line 466 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_tg5000tv[2U]  = {      {22U, 5217U, 49151U}, 
        {0U, 0U, 0U}};
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_tg5000tv  = 
#line 471
     {9, (char *)"Nagase Transgear 5000TV", 0, 16973905U, 34560U, 32768U, 32768U, 0U,
    34576U, {{1U, 0U, 6U}, {2U, 1U, 8U}, {4U, 1U, 8U}}, {{1U, 0U, (unsigned short)0},
                                                         {2U, 1U, (unsigned short)0}},
    {(unsigned char)0, 0U, (unsigned short)0}, 0, 0, 32U, (unsigned char)0, {57472U,
                                                                             32768U},
    {48U, 0U, 16U, 32U}, {32896U, 32768U, 128U, (unsigned short)0}, {24576U, 24576U},
    {17152U, 16384U, 512U, 768U, 0U, 512U}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{46848ULL, 53}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_tg5000tv)};
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_va2000[2U]  = {      {22U, 0U, 65375U}, 
        {0U, 0U, 0U}};
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_va2000  = 
#line 514
     {10, (char *)"AOpen VA2000MAX-SNT6", 0, 16973905U, 1026U, 8U, 8U, 0U, 1050U, {{1U,
                                                                                  0U,
                                                                                  6U}},
    {{1U, 0U, (unsigned short)0}}, {(unsigned char)0, 0U, (unsigned short)0}, 0, 0,
    (unsigned char)0, (unsigned char)0, {(unsigned short)0, (unsigned short)0}, {(unsigned short)0,
                                                                                 (unsigned short)0,
                                                                                 (unsigned short)0,
                                                                                 (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{46848ULL, 53}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_va2000)};
#line 540 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_cx23416gyc[4U]  = {      {22U, 4779U, 1536U}, 
        {22U, 64427U, 1536U}, 
        {22U, 4436U, 1315U}, 
        {0U, 0U, 0U}};
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_cx23416gyc  = 
#line 547
     {11, (char *)"Yuan MPG600GR, Kuroutoshikou CX23416GYC-STVLP", 0, 16973905U, 36352U,
    2048U, 2048U, 0U, 36368U, {{1U, 0U, 137U}, {2U, 1U, 6U}, {4U, 1U, 9U}}, {{1U,
                                                                              2U,
                                                                              (unsigned short)0},
                                                                             {2U,
                                                                              0U,
                                                                              (unsigned short)0}},
    {(unsigned char)0, 0U, (unsigned short)0}, 0, 0, 32U, (unsigned char)0, {63616U,
                                                                             34816U},
    {32U, 0U, 32U, 32U}, {(unsigned short)0, (unsigned short)0, (unsigned short)0,
                          (unsigned short)0}, {(unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0}, {49152U, 0U, 16384U, 32768U}, {(unsigned short)0, (unsigned short)0},
    {{16711935ULL, 38}, {16777215ULL, 43}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_cx23416gyc)};
#line 581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_cx23416gyc_nogr  = 
#line 581
     {29, (char *)"Yuan MPG600GR, Kuroutoshikou CX23416GYC-STVLP (no GR)", 0, 16973905U,
    35840U, 2048U, 2048U, 0U, 35856U, {{1U, 0U, 132U}, {2U, 1U, 6U}, {4U, 1U, 0U}},
    {{1U, 2U, (unsigned short)0}, {2U, 0U, (unsigned short)0}}, {(unsigned char)0,
                                                                 0U, (unsigned short)0},
    0, 0, (unsigned char)0, (unsigned char)0, {63616U, 34816U}, {32U, 0U, 32U, 32U},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {49152U, 0U, 16384U, 32768U}, {(unsigned short)0, (unsigned short)0}, {{16711935ULL,
                                                                            38}, {16777215ULL,
                                                                                  43}},
    & ivtv_i2c_std, 0};
#line 612 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_cx23416gyc_nogrycs  = 
#line 612
     {30, (char *)"Yuan MPG600GR, Kuroutoshikou CX23416GYC-STVLP (no GR/YCS)", 0, 16973905U,
    34816U, 2048U, 2048U, 0U, 34832U, {{1U, 0U, 132U}, {2U, 1U, 6U}, {4U, 1U, 0U}},
    {{1U, 2U, (unsigned short)0}, {2U, 0U, (unsigned short)0}}, {(unsigned char)0,
                                                                 0U, (unsigned short)0},
    0, 0, (unsigned char)0, (unsigned char)0, {63616U, 34816U}, {32U, 0U, 32U, 32U},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {49152U, 0U, 16384U, 32768U}, {(unsigned short)0, (unsigned short)0}, {{16711935ULL,
                                                                            38}, {16777215ULL,
                                                                                  43}},
    & ivtv_i2c_std, 0};
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_gv_mvprx[4U]  = {      {22U, 4348U, 53278U}, 
        {22U, 4348U, 53304U}, 
        {22U, 4348U, 53305U}, 
        {0U, 0U, 0U}};
#line 653 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_gv_mvprx  = 
#line 653
     {12, (char *)"I/O Data GV-MVP/RX, GV-MVP/RX2W (dual tuner)", 0, 16973905U, 1538U,
    32768U, 4096U, 0U, 46610U, {{1U, 0U, 6U}, {2U, 1U, 7U}, {4U, 1U, 8U}}, {{1U, 0U,
                                                                             (unsigned short)0},
                                                                            {2U, 1U,
                                                                             (unsigned short)0}},
    {(unsigned char)0, 0U, (unsigned short)0}, 0, 0, (unsigned char)0, (unsigned char)0,
    {49921U, 512U}, {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {65535U, 512U, 768U, (unsigned short)0}, {(unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0}, {(unsigned short)0, (unsigned short)0, (unsigned short)0,
                          (unsigned short)0}, {(unsigned short)0, (unsigned short)0},
    {{46848ULL, 46}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_gv_mvprx)};
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_gv_mvprx2e[2U]  = {      {22U, 4348U, 53285U}, 
        {0U, 0U, 0U}};
#line 691 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_gv_mvprx2e  = 
#line 691
     {13, (char *)"I/O Data GV-MVP/RX2E", 0, 16973905U, 2U, 32768U, 4096U, 0U, 45074U,
    {{1U, 0U, 4U}, {2U, 1U, 6U}, {4U, 1U, 3U}}, {{1U, 0U, (unsigned short)0}, {2U,
                                                                               1U,
                                                                               (unsigned short)0}},
    {(unsigned char)0, 0U, (unsigned short)0}, 0, 0, (unsigned char)0, (unsigned char)0,
    {49921U, 512U}, {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {65535U, 512U, 768U, (unsigned short)0}, {(unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0}, {(unsigned short)0, (unsigned short)0, (unsigned short)0,
                          (unsigned short)0}, {(unsigned short)0, (unsigned short)0},
    {{46848ULL, 46}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_gv_mvprx2e)};
#line 723 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_gotview_pci_dvd[2U]  = {      {22U, 4779U, 1536U}, 
        {0U, 0U, 0U}};
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_gotview_pci_dvd  = 
#line 728
     {14, (char *)"GotView PCI DVD", 0, 16973905U, 2048U, 2048U, 2048U, 0U, 2064U, {{1U,
                                                                                   0U,
                                                                                   1U},
                                                                                  {2U,
                                                                                   1U,
                                                                                   6U},
                                                                                  {4U,
                                                                                   1U,
                                                                                   3U}},
    {{1U, 0U, (unsigned short)0}, {2U, 2U, (unsigned short)0}}, {(unsigned char)0,
                                                                 0U, (unsigned short)0},
    0, 0, (unsigned char)0, (unsigned char)0, {61440U, 40960U}, {(unsigned short)0,
                                                                 (unsigned short)0,
                                                                 (unsigned short)0,
                                                                 (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{16711935ULL, 38}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_gotview_pci_dvd)};
#line 758 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_gotview_pci_dvd2[2U]  = {      {22U, 65452U, 1536U}, 
        {0U, 0U, 0U}};
#line 763 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_gotview_pci_dvd2  = 
#line 763
     {15, (char *)"GotView PCI DVD2 Deluxe", 0, 16973905U, 1U, 1U, 1U, 32768U, 17U,
    {{1U, 0U, 2U}, {2U, 1U, 1072U}, {4U, 1U, 1U}}, {{1U, 5U, 0U}, {2U, 0U, 1U}}, {1U,
                                                                                  0U,
                                                                                  2U},
    0, 0, (unsigned char)0, (unsigned char)0, {2048U, 0U}, {(unsigned short)0, (unsigned short)0,
                                                            (unsigned short)0, (unsigned short)0},
    {2048U, 0U, 0U, 2048U}, {(unsigned short)0, (unsigned short)0}, {(unsigned short)0,
                                                                     (unsigned short)0,
                                                                     (unsigned short)0,
                                                                     (unsigned short)0,
                                                                     (unsigned short)0,
                                                                     (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{16711935ULL, 38}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_gotview_pci_dvd2)};
#line 797 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_yuan_mpc622[2U]  = {      {22U, 65281U, 55704U}, 
        {0U, 0U, 0U}};
#line 802 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_yuan_mpc622  = 
#line 802
     {16, (char *)"Yuan MPC622", 0, 16973905U, 1U, 1U, 1U, 0U, 17U, {{1U, 0U, 2U}, {2U,
                                                                                  1U,
                                                                                  1072U},
                                                                   {4U, 1U, 1U}},
    {{1U, 5U, (unsigned short)0}, {2U, 0U, (unsigned short)0}}, {(unsigned char)0,
                                                                 0U, (unsigned short)0},
    0, 0, (unsigned char)0, (unsigned char)0, {255U, 2U}, {(unsigned short)0, (unsigned short)0,
                                                           (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{16777215ULL, 54}}, & ivtv_i2c_tda8290,
    (struct ivtv_card_pci_info  const  *)(& ivtv_pci_yuan_mpc622)};
#line 833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_dctmvtvp1[2U]  = {      {22U, 5217U, 49151U}, 
        {0U, 0U, 0U}};
#line 838 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_dctmvtvp1  = 
#line 838
     {17, (char *)"Digital Cowboy DCT-MTVP1", 0, 16973905U, 34306U, 32768U, 32768U,
    0U, 34322U, {{1U, 0U, 6U}, {2U, 1U, 8U}, {4U, 1U, 8U}}, {{1U, 0U, (unsigned short)0},
                                                             {2U, 1U, (unsigned short)0}},
    {(unsigned char)0, 0U, (unsigned short)0}, 0, 0, (unsigned char)0, (unsigned char)0,
    {57472U, 32768U}, {48U, 0U, 16U, 32U}, {32896U, 32768U, 128U, (unsigned short)0},
    {24576U, 24576U}, {17152U, 16384U, 512U, 768U, 0U, 512U}, {(unsigned short)0,
                                                               (unsigned short)0,
                                                               (unsigned short)0,
                                                               (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{46848ULL, 53}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_dctmvtvp1)};
#line 875 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_pg600v2[3U]  = {      {22U, 65451U, 1536U}, 
        {22U, 65453U, 1536U}, 
        {0U, 0U, 0U}};
#line 881 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_pg600v2  = 
#line 881
     {18, (char *)"Yuan PG600-2, GotView PCI DVD Lite", 0, 16973905U, 1U, 1U, 1U, 0U,
    17U, {{1U, 0U, 2U}, {2U, 1U, 1072U}, {4U, 1U, 1U}}, {{1U, 5U, (unsigned short)0},
                                                         {2U, 0U, (unsigned short)0}},
    {1U, 5U, (unsigned short)0}, 0, 0, (unsigned char)0, 12U, {(unsigned short)0,
                                                               (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{16777215ULL, 71}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_pg600v2)};
#line 914 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_club3d[2U]  = {      {22U, 65451U, 1536U}, 
        {0U, 0U, 0U}};
#line 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_club3d  = 
#line 919
     {19, (char *)"Club3D ZAP-TV1x01", 0, 16973905U, 1U, 1U, 1U, 0U, 17U, {{1U, 0U,
                                                                          2U}, {2U,
                                                                                1U,
                                                                                1072U},
                                                                         {4U, 1U,
                                                                          3U}}, {{1U,
                                                                                  5U,
                                                                                  (unsigned short)0},
                                                                                 {2U,
                                                                                  0U,
                                                                                  (unsigned short)0}},
    {1U, 5U, (unsigned short)0}, 0, 0, (unsigned char)0, 12U, {(unsigned short)0,
                                                               (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{16777215ULL, 71}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_club3d)};
#line 950 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_avertv_mce116[2U]  = {      {22U, 5217U, 50233U}, 
        {0U, 0U, 0U}};
#line 955 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_avertv_mce116  = 
#line 955
     {20, (char *)"AVerTV MCE 116 Plus", 0, 16973905U, 1U, 1U, 1U, 0U, 69649U, {{1U,
                                                                               0U,
                                                                               2U},
                                                                              {2U,
                                                                               1U,
                                                                               1840U},
                                                                              {4U,
                                                                               1U,
                                                                               1U}},
    {{1U, 5U, (unsigned short)0}, {2U, 0U, 1U}}, {1U, 5U, (unsigned short)0}, 0, 0,
    (unsigned char)0, 10U, {57344U, 16384U}, {(unsigned short)0, (unsigned short)0,
                                              (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{16777215ULL, 71}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_avertv_mce116)};
#line 988 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_aver_pvr150[3U]  = {      {22U, 5217U, 49204U}, 
        {22U, 5217U, 49205U}, 
        {0U, 0U, 0U}};
#line 994 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_aver_pvr150  = 
#line 994
     {22, (char *)"AVerMedia PVR-150 Plus / AVerTV M113 Partsnic (Daewoo) Tuner", 0,
    16973905U, 1U, 1U, 1U, 32768U, 36881U, {{1U, 0U, 2U}, {2U, 1U, 1840U}, {4U, 1U,
                                                                            1U}},
    {{1U, 5U, 0U}, {2U, 0U, 1U}}, {1U, 0U, 2U}, 0, 0, (unsigned char)0, (unsigned char)0,
    {49152U, 0U}, {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {49152U, 0U, 16384U, 32768U}, {(unsigned short)0, (unsigned short)0}, {(unsigned short)0,
                                                                           (unsigned short)0,
                                                                           (unsigned short)0,
                                                                           (unsigned short)0,
                                                                           (unsigned short)0,
                                                                           (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{46848ULL, 81}}, & ivtv_i2c_radio, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_aver_pvr150)};
#line 1033 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_aver_ultra1500mce[3U]  = {      {22U, 5217U, 49177U}, 
        {22U, 5217U, 49179U}, 
        {0U, 0U, 0U}};
#line 1039 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_aver_ultra1500mce  = 
#line 1039
     {26, (char *)"AVerMedia UltraTV 1500 MCE / AVerTV M113 Philips Tuner", (char *)"For non-NTSC tuners, use the pal= or secam= module options",
    16973905U, 1U, 1U, 1U, 32768U, 36881U, {{1U, 0U, 2U}, {2U, 1U, 1840U}, {4U, 1U,
                                                                            1U}},
    {{1U, 5U, 0U}, {2U, 0U, 1U}}, {1U, 0U, 2U}, 0, 0, (unsigned char)0, (unsigned char)0,
    {49152U, 0U}, {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {49152U, 0U, 16384U, 32768U}, {(unsigned short)0, (unsigned short)0}, {(unsigned short)0,
                                                                           (unsigned short)0,
                                                                           (unsigned short)0,
                                                                           (unsigned short)0,
                                                                           (unsigned short)0,
                                                                           (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{46848ULL, 43}, {16711935ULL, 79}}, & ivtv_i2c_std,
    (struct ivtv_card_pci_info  const  *)(& ivtv_pci_aver_ultra1500mce)};
#line 1079 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_aver_ezmaker[2U]  = {      {22U, 5217U, 49215U}, 
        {0U, 0U, 0U}};
#line 1084 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_aver_ezmaker  = 
#line 1084
     {23, (char *)"AVerMedia EZMaker PCI Deluxe", 0, 16973905U, 1U, 1U, 1U, 0U, 4097U,
    {{2U, 0U, 1840U}, {4U, 0U, 1U}}, {{2U, 0U, 0U}}, {(unsigned char)0, 0U, (unsigned short)0},
    0, 0, (unsigned char)0, (unsigned char)0, {16384U, 16384U}, {(unsigned short)0,
                                                                 (unsigned short)0,
                                                                 (unsigned short)0,
                                                                 (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{0ULL, 0}, {0ULL, 0}, {0ULL, 0}}, 0,
    (struct ivtv_card_pci_info  const  *)(& ivtv_pci_aver_ezmaker)};
#line 1108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_asus_falcon2[4U]  = {      {22U, 4163U, 19302U}, 
        {22U, 4163U, 17966U}, 
        {22U, 4163U, 19246U}, 
        {0U, 0U, 0U}};
#line 1115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_asus_falcon2  = 
#line 1115
     {21, (char *)"ASUS Falcon2", 0, 16973905U, 1U, 1U, 1U, 16384U, 16401U, {{1U, 0U,
                                                                            2U}, {2U,
                                                                                  1U,
                                                                                  1840U},
                                                                           {4U, 2U,
                                                                            2U}},
    {{1U, 5U, 0U}, {2U, 0U, 1285U}, {2U, 0U, 257U}}, {1U, 0U, 0U}, 0, 0, (unsigned char)0,
    (unsigned char)0, {(unsigned short)0, (unsigned short)0}, {(unsigned short)0,
                                                               (unsigned short)0,
                                                               (unsigned short)0,
                                                               (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{46848ULL, 43}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_asus_falcon2)};
#line 1147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_aver_m104[2U]  = {      {22U, 5217U, 49462U}, 
        {0U, 0U, 0U}};
#line 1152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_aver_m104  = 
#line 1152
     {24, (char *)"AVerMedia M104", (char *)"Not yet supported!\n", 0U, 1U, 1U, 1U,
    0U, 4113U, {{2U, 0U, 1840U}, {4U, 0U, 1U}}, {{2U, 0U, 1U}}, {1U, 0U, 2U}, 0, 0,
    (unsigned char)0, 10U, {57344U, 16384U}, {(unsigned short)0, (unsigned short)0,
                                              (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{16777215ULL, 71}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_aver_m104)};
#line 1183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_buffalo[2U]  = {      {22U, 4436U, 1323U}, 
        {0U, 0U, 0U}};
#line 1188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_buffalo  = 
#line 1188
     {25, (char *)"Buffalo PC-MV5L/PCI", 0, 16973905U, 1U, 1U, 1U, 0U, 17U, {{1U, 0U,
                                                                            2U}, {2U,
                                                                                  1U,
                                                                                  1072U},
                                                                           {4U, 1U,
                                                                            1U}},
    {{1U, 5U, (unsigned short)0}, {2U, 0U, (unsigned short)0}}, {(unsigned char)0,
                                                                 0U, (unsigned short)0},
    0, 0, (unsigned char)0, 12U, {(unsigned short)0, (unsigned short)0}, {(unsigned short)0,
                                                                          (unsigned short)0,
                                                                          (unsigned short)0,
                                                                          (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {(unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0,
                                             (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{16777215ULL, 71}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_buffalo)};
#line 1217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card_pci_info  const  ivtv_pci_kikyou[2U]  = {      {22U, 4173U, 33085U}, 
        {0U, 0U, 0U}};
#line 1222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  ivtv_card_kikyou  = 
#line 1222
     {27, (char *)"Sony VAIO Giga Pocket (ENX Kikyou)", 0, 16973905U, 2U, 32768U, 32768U,
    0U, 32786U, {{1U, 0U, 1U}, {4U, 1U, 1U}, {2U, 1U, 7U}}, {{1U, 0U, (unsigned short)0},
                                                             {2U, 1U, (unsigned short)0},
                                                             {3U, 1U, (unsigned short)0}},
    {(unsigned char)0, 0U, (unsigned short)0}, 0, 0, (unsigned char)0, (unsigned char)0,
    {993U, 800U}, {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0},
    {96U, 32U, 0U, 96U}, {0U, 0U}, {128U, 0U, 0U, 128U, 0U, 128U}, {(unsigned short)0,
                                                                    (unsigned short)0,
                                                                    (unsigned short)0,
                                                                    (unsigned short)0},
    {(unsigned short)0, (unsigned short)0}, {{16777215ULL, 84}}, & ivtv_i2c_std, (struct ivtv_card_pci_info  const  *)(& ivtv_pci_kikyou)};
#line 1261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
static struct ivtv_card  const  *ivtv_card_list[31U]  = 
#line 1261
  {      & ivtv_card_pvr250,      & ivtv_card_pvr350,      & ivtv_card_pvr150,      & ivtv_card_m179, 
        & ivtv_card_mpg600,      & ivtv_card_mpg160,      & ivtv_card_pg600,      & ivtv_card_avc2410, 
        & ivtv_card_avc2010,      & ivtv_card_tg5000tv,      & ivtv_card_va2000,      & ivtv_card_cx23416gyc, 
        & ivtv_card_gv_mvprx,      & ivtv_card_gv_mvprx2e,      & ivtv_card_gotview_pci_dvd,      & ivtv_card_gotview_pci_dvd2, 
        & ivtv_card_yuan_mpc622,      & ivtv_card_dctmvtvp1,      & ivtv_card_pg600v2,      & ivtv_card_club3d, 
        & ivtv_card_avertv_mce116,      & ivtv_card_asus_falcon2,      & ivtv_card_aver_pvr150,      & ivtv_card_aver_ezmaker, 
        & ivtv_card_aver_m104,      & ivtv_card_buffalo,      & ivtv_card_aver_ultra1500mce,      & ivtv_card_kikyou, 
        & ivtv_card_pvr350_v1,      & ivtv_card_cx23416gyc_nogr,      & ivtv_card_cx23416gyc_nogrycs};
#line 1298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
struct ivtv_card  const  *ivtv_get_card(u16 index ) 
{ 


  {
#line 1300
  if ((unsigned int )index > 30U) {
#line 1301
    return ((struct ivtv_card  const  *)0);
  } else {

  }
#line 1302
  return (ivtv_card_list[(int )index]);
}
}
#line 1305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
int ivtv_get_input(struct ivtv *itv , u16 index , struct v4l2_input *input ) 
{ 
  struct ivtv_card_video_input  const  *card_input ;
  char const   *input_strs[6U] ;

  {
#line 1307
  card_input = (struct ivtv_card_video_input  const  *)(& (itv->card)->video_inputs) + (unsigned long )index;
#line 1308
  input_strs[0] = "Tuner 1";
#line 1308
  input_strs[1] = "S-Video 1";
#line 1308
  input_strs[2] = "S-Video 2";
#line 1308
  input_strs[3] = "Composite 1";
#line 1308
  input_strs[4] = "Composite 2";
#line 1308
  input_strs[5] = "Composite 3";
#line 1317
  if ((int )((unsigned short )itv->nof_inputs) <= (int )index) {
#line 1318
    return (-22);
  } else {

  }
#line 1319
  input->index = (__u32 )index;
#line 1320
  strlcpy((char *)(& input->name), input_strs[(int )card_input->video_type + -1],
          32UL);
#line 1322
  input->type = (unsigned int )((unsigned char )card_input->video_type) == 1U ? 1U : 2U;
#line 1324
  input->audioset = (__u32 )((1 << (int )itv->nof_audio_inputs) + -1);
#line 1325
  input->std = input->type == 1U ? itv->tuner_std : 16777215ULL;
#line 1327
  return (0);
}
}
#line 1330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
int ivtv_get_output(struct ivtv *itv , u16 index , struct v4l2_output *output ) 
{ 
  struct ivtv_card_output  const  *card_output ;

  {
#line 1332
  card_output = (itv->card)->video_outputs + (unsigned long )index;
#line 1334
  if ((int )index >= (int )(itv->card)->nof_outputs) {
#line 1335
    return (-22);
  } else {

  }
#line 1336
  output->index = (__u32 )index;
#line 1337
  strlcpy((char *)(& output->name), (char const   *)(& card_output->name), 32UL);
#line 1338
  output->type = 2U;
#line 1339
  output->audioset = 1U;
#line 1340
  output->std = 16777215ULL;
#line 1341
  return (0);
}
}
#line 1344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
int ivtv_get_audio_input(struct ivtv *itv , u16 index , struct v4l2_audio *audio ) 
{ 
  struct ivtv_card_audio_input  const  *aud_input ;
  char const   *input_strs[3U] ;

  {
#line 1346
  aud_input = (struct ivtv_card_audio_input  const  *)(& (itv->card)->audio_inputs) + (unsigned long )index;
#line 1347
  input_strs[0] = "Tuner 1";
#line 1347
  input_strs[1] = "Line In 1";
#line 1347
  input_strs[2] = "Line In 2";
#line 1353
  memset((void *)audio, 0, 52UL);
#line 1354
  if ((int )((unsigned short )itv->nof_audio_inputs) <= (int )index) {
#line 1355
    return (-22);
  } else {

  }
#line 1356
  strlcpy((char *)(& audio->name), input_strs[(int )aud_input->audio_type + -1], 32UL);
#line 1358
  audio->index = (__u32 )index;
#line 1359
  audio->capability = 1U;
#line 1360
  return (0);
}
}
#line 1363 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.c"
int ivtv_get_audio_output(struct ivtv *itv , u16 index , struct v4l2_audioout *aud_output ) 
{ 


  {
#line 1365
  memset((void *)aud_output, 0, 52UL);
#line 1366
  if ((unsigned long )(itv->card)->video_outputs == (unsigned long )((struct ivtv_card_output  const  */* const  */)0) || (unsigned int )index != 0U) {
#line 1367
    return (-22);
  } else {

  }
#line 1368
  strlcpy((char *)(& aud_output->name), "A/V Audio Out", 32UL);
#line 1369
  return (0);
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.o.c.prepared"
bool ldv_queue_work_on_19(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 142
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 142
  ldv_func_res = tmp;
#line 144
  activate_work_2(ldv_func_arg3, 2);
#line 146
  return (ldv_func_res);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.o.c.prepared"
bool ldv_queue_delayed_work_on_20(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 153
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 153
  ldv_func_res = tmp;
#line 155
  activate_work_2(& ldv_func_arg3->work, 2);
#line 157
  return (ldv_func_res);
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.o.c.prepared"
bool ldv_queue_work_on_21(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 164
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 164
  ldv_func_res = tmp;
#line 166
  activate_work_2(ldv_func_arg3, 2);
#line 168
  return (ldv_func_res);
}
}
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.o.c.prepared"
void ldv_flush_workqueue_22(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 174
  flush_workqueue(ldv_func_arg1);
#line 176
  call_and_disable_all_2(2);
#line 177
  return;
}
}
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-cards.o.c.prepared"
bool ldv_queue_delayed_work_on_23(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 183
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 183
  ldv_func_res = tmp;
#line 185
  activate_work_2(& ldv_func_arg3->work, 2);
#line 187
  return (ldv_func_res);
}
}
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_33(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_35(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_34(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_37(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_36(struct workqueue_struct *ldv_func_arg1 ) ;
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 289
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.o.c.prepared"
int ldv_state_variable_17 ;
#line 36
struct cx2341x_handler *ivtv_cxhdl_ops_group0 ;
#line 60
int ldv_state_variable_16 ;
#line 63
struct v4l2_ctrl *ivtv_hdl_out_ops_group0 ;
#line 86
void ldv_initialize_v4l2_ctrl_ops_16(void) ;
#line 96
void ldv_initialize_cx2341x_handler_ops_17(void) ;
#line 123 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
int ivtv_debug ;
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-ioctl.h"
void ivtv_expand_service_set(struct v4l2_sliced_vbi_format *fmt , int is_pal ) ;
#line 26
u16 ivtv_get_service_set(struct v4l2_sliced_vbi_format *fmt ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-controls.h"
struct cx2341x_handler_ops ivtv_cxhdl_ops ;
#line 25
struct v4l2_ctrl_ops  const  ivtv_hdl_out_ops ;
#line 26
int ivtv_g_pts_frame(struct ivtv *itv , s64 *pts , s64 *frame ) ;
#line 29 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-mailbox.h"
int ivtv_api(struct ivtv *itv , int cmd , int args , u32 *data ) ;
#line 31
int ivtv_vapi(struct ivtv *itv , int cmd , int args  , ...) ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.c"
static int ivtv_s_stream_vbi_fmt(struct cx2341x_handler *cxhdl , u32 fmt ) 
{ 
  struct ivtv *itv ;
  struct cx2341x_handler  const  *__mptr ;
  int i ;
  void *tmp ;
  u16 tmp___0 ;

  {
#line 28
  __mptr = (struct cx2341x_handler  const  *)cxhdl;
#line 28
  itv = (struct ivtv *)__mptr + 0xfffffffffffffe98UL;
#line 31
  if (fmt != 0U && (unsigned long )itv->vbi.sliced_mpeg_data[0] == (unsigned long )((u8 *)0U)) {
#line 34
    i = 0;
#line 34
    goto ldv_38952;
    ldv_38951: 
#line 36
    tmp = kmalloc(2049UL, 208U);
#line 36
    itv->vbi.sliced_mpeg_data[i] = (u8 *)tmp;
#line 37
    if ((unsigned long )itv->vbi.sliced_mpeg_data[i] == (unsigned long )((u8 *)0U)) {
#line 38
      goto ldv_38949;
      ldv_38948: 
#line 39
      kfree((void const   *)itv->vbi.sliced_mpeg_data[i]);
#line 40
      itv->vbi.sliced_mpeg_data[i] = (u8 *)0U;
      ldv_38949: 
#line 38
      i = i - 1;
#line 38
      if (i >= 0) {
#line 40
        goto ldv_38948;
      } else {

      }

#line 42
      return (-12);
    } else {

    }
#line 34
    i = i + 1;
    ldv_38952: ;
#line 34
    if (i <= 31) {
#line 36
      goto ldv_38951;
    } else {

    }

  } else {

  }
#line 47
  itv->vbi.insert_mpeg = (int )fmt;
#line 49
  if (itv->vbi.insert_mpeg == 0) {
#line 50
    return (0);
  } else {

  }
#line 53
  tmp___0 = ivtv_get_service_set(itv->vbi.sliced_in);
#line 53
  if ((unsigned int )tmp___0 == 0U) {
#line 54
    if ((unsigned int )itv->is_60hz != 0U) {
#line 55
      (itv->vbi.sliced_in)->service_set = 4096U;
    } else {
#line 57
      (itv->vbi.sliced_in)->service_set = 16384U;
    }
#line 58
    ivtv_expand_service_set(itv->vbi.sliced_in, (int )itv->is_50hz);
  } else {

  }
#line 60
  return (0);
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.c"
static int ivtv_s_video_encoding(struct cx2341x_handler *cxhdl , u32 val ) 
{ 
  struct ivtv *itv ;
  struct cx2341x_handler  const  *__mptr ;
  int is_mpeg1 ;
  struct v4l2_subdev_format format ;

  {
#line 65
  __mptr = (struct cx2341x_handler  const  *)cxhdl;
#line 65
  itv = (struct ivtv *)__mptr + 0xfffffffffffffe98UL;
#line 66
  is_mpeg1 = val == 0U;
#line 67
  format.which = 1U;
#line 67
  format.pad = 0U;
#line 67
  format.format.width = 0U;
#line 67
  format.format.height = 0U;
#line 67
  format.format.code = 0U;
#line 67
  format.format.field = 0U;
#line 67
  format.format.colorspace = 0U;
#line 67
  format.format.ycbcr_enc = (unsigned short)0;
#line 67
  format.format.quantization = (unsigned short)0;
#line 67
  format.format.xfer_func = (unsigned short)0;
#line 67
  format.format.reserved[0] = (unsigned short)0;
#line 67
  format.format.reserved[1] = (unsigned short)0;
#line 67
  format.format.reserved[2] = (unsigned short)0;
#line 67
  format.format.reserved[3] = (unsigned short)0;
#line 67
  format.format.reserved[4] = (unsigned short)0;
#line 67
  format.format.reserved[5] = (unsigned short)0;
#line 67
  format.format.reserved[6] = (unsigned short)0;
#line 67
  format.format.reserved[7] = (unsigned short)0;
#line 67
  format.format.reserved[8] = (unsigned short)0;
#line 67
  format.format.reserved[9] = (unsigned short)0;
#line 67
  format.format.reserved[10] = (unsigned short)0;
#line 67
  format.reserved[0] = 0U;
#line 67
  format.reserved[1] = 0U;
#line 67
  format.reserved[2] = 0U;
#line 67
  format.reserved[3] = 0U;
#line 67
  format.reserved[4] = 0U;
#line 67
  format.reserved[5] = 0U;
#line 67
  format.reserved[6] = 0U;
#line 67
  format.reserved[7] = 0U;
#line 72
  format.format.width = (__u32 )((int )cxhdl->width / (is_mpeg1 != 0 ? 2 : 1));
#line 73
  format.format.height = (__u32 )cxhdl->height;
#line 74
  format.format.code = 1U;
#line 75
  if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 75
    if ((unsigned long )((itv->sd_video)->ops)->pad != (unsigned long )((struct v4l2_subdev_pad_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->pad)->set_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                struct v4l2_subdev_pad_config * ,
                                                                                                                                                                                                                                struct v4l2_subdev_format * ))0)) {
#line 75
      (*((((itv->sd_video)->ops)->pad)->set_fmt))(itv->sd_video, (struct v4l2_subdev_pad_config *)0,
                                                  & format);
    } else {

    }
  } else {

  }
#line 76
  return (0);
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.c"
static int ivtv_s_audio_sampling_freq(struct cx2341x_handler *cxhdl , u32 idx ) 
{ 
  u32 freqs[3U] ;
  struct ivtv *itv ;
  struct cx2341x_handler  const  *__mptr ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 81
  freqs[0] = 44100U;
#line 81
  freqs[1] = 48000U;
#line 81
  freqs[2] = 32000U;
#line 82
  __mptr = (struct cx2341x_handler  const  *)cxhdl;
#line 82
  itv = (struct ivtv *)__mptr + 0xfffffffffffffe98UL;
#line 86
  if (idx <= 2U) {
#line 87
    __mptr___0 = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 87
    __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
#line 87
    goto ldv_38979;
    ldv_38978: ;
#line 87
    if ((unsigned long )(__sd->ops)->audio != (unsigned long )((struct v4l2_subdev_audio_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->audio)->s_clock_freq != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                     u32  ))0)) {
#line 87
      (*(((__sd->ops)->audio)->s_clock_freq))(__sd, freqs[idx]);
    } else {

    }
#line 87
    __mptr___1 = (struct list_head  const  *)__sd->list.next;
#line 87
    __sd = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff88UL;
    ldv_38979: ;
#line 87
    if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 89
      goto ldv_38978;
    } else {

    }

  } else {

  }
#line 88
  return (0);
}
}
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.c"
static int ivtv_s_audio_mode(struct cx2341x_handler *cxhdl , u32 val ) 
{ 
  struct ivtv *itv ;
  struct cx2341x_handler  const  *__mptr ;

  {
#line 93
  __mptr = (struct cx2341x_handler  const  *)cxhdl;
#line 93
  itv = (struct ivtv *)__mptr + 0xfffffffffffffe98UL;
#line 95
  itv->dualwatch_stereo_mode = val;
#line 96
  return (0);
}
}
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.c"
struct cx2341x_handler_ops ivtv_cxhdl_ops  =    {& ivtv_s_audio_sampling_freq, & ivtv_s_audio_mode, & ivtv_s_video_encoding, & ivtv_s_stream_vbi_fmt};
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.c"
int ivtv_g_pts_frame(struct ivtv *itv , s64 *pts , s64 *frame ) 
{ 
  u32 data[16U] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 110
  tmp = constant_test_bit(14L, (unsigned long const volatile   *)(& itv->i_flags));
#line 110
  if (tmp != 0) {
#line 111
    *pts = (s64 )(((unsigned long long )itv->last_dec_timing[2] << 32) | (unsigned long long )itv->last_dec_timing[1]);
#line 113
    *frame = (s64 )itv->last_dec_timing[0];
#line 114
    return (0);
  } else {

  }
#line 116
  *pts = 0LL;
#line 117
  *frame = 0LL;
#line 118
  tmp___1 = atomic_read((atomic_t const   *)(& itv->decoding));
#line 118
  if (tmp___1 != 0) {
#line 119
    tmp___0 = ivtv_api(itv, 21, 5, (u32 *)(& data));
#line 119
    if (tmp___0 != 0) {
#line 120
      if (ivtv_debug & 1) {
#line 120
        printk("\016%s:  warn: GET_TIMING: couldn\'t read clock\n", (char *)(& itv->v4l2_dev.name));
      } else {

      }
#line 121
      return (-5);
    } else {

    }
#line 123
    memcpy((void *)(& itv->last_dec_timing), (void const   *)(& data), 12UL);
#line 124
    set_bit(14L, (unsigned long volatile   *)(& itv->i_flags));
#line 125
    *pts = (s64 )(((unsigned long long )data[2] << 32) | (unsigned long long )data[1]);
#line 126
    *frame = (s64 )data[0];
  } else {

  }
#line 129
  return (0);
}
}
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.c"
static int ivtv_g_volatile_ctrl(struct v4l2_ctrl *ctrl ) 
{ 
  struct ivtv *itv ;
  struct v4l2_ctrl_handler  const  *__mptr ;
  int tmp ;

  {
#line 134
  __mptr = (struct v4l2_ctrl_handler  const  *)ctrl->handler;
#line 134
  itv = (struct ivtv *)__mptr + 0xfffffffffffffe80UL;
#line 136
  switch (ctrl->id) {
  case 10029535U: 
#line 140
  tmp = ivtv_g_pts_frame(itv, (itv->__annonCompField105.ctrl_pts)->p_new.p_s64, (itv->__annonCompField105.ctrl_frame)->p_new.p_s64);
#line 140
  return (tmp);
  }
#line 143
  return (0);
}
}
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.c"
static int ivtv_s_ctrl(struct v4l2_ctrl *ctrl ) 
{ 
  struct ivtv *itv ;
  struct v4l2_ctrl_handler  const  *__mptr ;

  {
#line 148
  __mptr = (struct v4l2_ctrl_handler  const  *)ctrl->handler;
#line 148
  itv = (struct ivtv *)__mptr + 0xfffffffffffffe80UL;
#line 150
  switch (ctrl->id) {
  case 10029424U: 
#line 154
  itv->audio_stereo_mode = (unsigned int )((u8 )(itv->__annonCompField106.ctrl_audio_playback)->val) + 255U;
#line 155
  itv->audio_bilingual_mode = (unsigned int )((u8 )(itv->__annonCompField106.ctrl_audio_multilingual_playback)->val) + 255U;
#line 156
  ivtv_vapi(itv, 22, 2, (int )itv->audio_bilingual_mode, (int )itv->audio_stereo_mode);
#line 157
  goto ldv_39009;
  }
  ldv_39009: ;
#line 159
  return (0);
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.c"
struct v4l2_ctrl_ops  const  ivtv_hdl_out_ops  =    {& ivtv_g_volatile_ctrl, 0, & ivtv_s_ctrl};
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.o.c.prepared"
void ldv_initialize_v4l2_ctrl_ops_16(void) 
{ 
  void *tmp ;

  {
#line 116
  tmp = ldv_init_zalloc(208UL);
#line 116
  ivtv_hdl_out_ops_group0 = (struct v4l2_ctrl *)tmp;
#line 117
  return;
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.o.c.prepared"
void ldv_initialize_cx2341x_handler_ops_17(void) 
{ 
  void *tmp ;

  {
#line 120
  tmp = ldv_init_zalloc(520UL);
#line 120
  ivtv_cxhdl_ops_group0 = (struct cx2341x_handler *)tmp;
#line 121
  return;
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.o.c.prepared"
void ldv_main_exported_16(void) 
{ 
  int tmp ;

  {
#line 125
  tmp = __VERIFIER_nondet_int();
#line 125
  switch (tmp) {
  case 0: ;
#line 128
  if (ldv_state_variable_16 == 1) {
#line 130
    ivtv_s_ctrl(ivtv_hdl_out_ops_group0);
#line 132
    ldv_state_variable_16 = 1;
  } else {

  }
#line 135
  goto ldv_39021;
  case 1: ;
#line 138
  if (ldv_state_variable_16 == 1) {
#line 140
    ivtv_g_volatile_ctrl(ivtv_hdl_out_ops_group0);
#line 142
    ldv_state_variable_16 = 1;
  } else {

  }
#line 145
  goto ldv_39021;
  default: 
#line 146
  ldv_stop();
  }
  ldv_39021: ;
#line 150
  return;
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.o.c.prepared"
void ldv_main_exported_17(void) 
{ 
  u32 ldvarg86 ;
  u32 ldvarg87 ;
  u32 ldvarg88 ;
  u32 ldvarg85 ;
  int tmp ;

  {
#line 153
  ldv_memset((void *)(& ldvarg86), 0, 4UL);
#line 154
  ldv_memset((void *)(& ldvarg87), 0, 4UL);
#line 155
  ldv_memset((void *)(& ldvarg88), 0, 4UL);
#line 156
  ldv_memset((void *)(& ldvarg85), 0, 4UL);
#line 158
  tmp = __VERIFIER_nondet_int();
#line 158
  switch (tmp) {
  case 0: ;
#line 161
  if (ldv_state_variable_17 == 1) {
#line 163
    ivtv_s_stream_vbi_fmt(ivtv_cxhdl_ops_group0, ldvarg88);
#line 165
    ldv_state_variable_17 = 1;
  } else {

  }
#line 168
  goto ldv_39032;
  case 1: ;
#line 171
  if (ldv_state_variable_17 == 1) {
#line 173
    ivtv_s_video_encoding(ivtv_cxhdl_ops_group0, ldvarg87);
#line 175
    ldv_state_variable_17 = 1;
  } else {

  }
#line 178
  goto ldv_39032;
  case 2: ;
#line 181
  if (ldv_state_variable_17 == 1) {
#line 183
    ivtv_s_audio_sampling_freq(ivtv_cxhdl_ops_group0, ldvarg86);
#line 185
    ldv_state_variable_17 = 1;
  } else {

  }
#line 188
  goto ldv_39032;
  case 3: ;
#line 191
  if (ldv_state_variable_17 == 1) {
#line 193
    ivtv_s_audio_mode(ivtv_cxhdl_ops_group0, ldvarg85);
#line 195
    ldv_state_variable_17 = 1;
  } else {

  }
#line 198
  goto ldv_39032;
  default: 
#line 199
  ldv_stop();
  }
  ldv_39032: ;
#line 203
  return;
}
}
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.o.c.prepared"
bool ldv_queue_work_on_33(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 232
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 232
  ldv_func_res = tmp;
#line 234
  activate_work_2(ldv_func_arg3, 2);
#line 236
  return (ldv_func_res);
}
}
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.o.c.prepared"
bool ldv_queue_delayed_work_on_34(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 243
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 243
  ldv_func_res = tmp;
#line 245
  activate_work_2(& ldv_func_arg3->work, 2);
#line 247
  return (ldv_func_res);
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.o.c.prepared"
bool ldv_queue_work_on_35(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 254
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 254
  ldv_func_res = tmp;
#line 256
  activate_work_2(ldv_func_arg3, 2);
#line 258
  return (ldv_func_res);
}
}
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.o.c.prepared"
void ldv_flush_workqueue_36(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 264
  flush_workqueue(ldv_func_arg1);
#line 266
  call_and_disable_all_2(2);
#line 267
  return;
}
}
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-controls.o.c.prepared"
bool ldv_queue_delayed_work_on_37(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 273
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 273
  ldv_func_res = tmp;
#line 275
  activate_work_2(& ldv_func_arg3->work, 2);
#line 277
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 314 "./arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 3 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
bool ldv_is_err(void const   *ptr ) ;
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_3129: ;
#line 14
  return (pfo_ret__);
}
}
#line 71 "include/linux/string.h"
extern char *strstr(char const   * , char const   * ) ;
#line 41 "include/linux/err.h"
__inline static bool IS_ERR(void const   *ptr ) ;
#line 11 "./arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 89 "include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 
  int tmp ;

  {
#line 91
  tmp = variable_test_bit((long )flag, (unsigned long const volatile   *)(& ti->flags));
#line 91
  return (tmp);
}
}
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField18.rlock);
#line 313
  return;
}
}
#line 355 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 357
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
#line 358
  return;
}
}
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 924
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 927
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 931
extern int autoremove_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 292 "include/linux/jiffies.h"
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
#line 354 "include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
#line 361
  tmp___0 = __msecs_to_jiffies(m);
#line 361
  return (tmp___0);
}
}
#line 229 "include/linux/timer.h"
extern int del_timer_sync(struct timer_list * ) ;
#line 232
int ldv_del_timer_sync_55(struct timer_list *ldv_func_arg1 ) ;
#line 181 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 352
extern struct workqueue_struct *system_wq ;
#line 433
bool ldv_queue_work_on_47(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_49(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_48(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_50(struct workqueue_struct *ldv_func_arg1 ) ;
#line 463
extern bool flush_work(struct work_struct * ) ;
#line 466
bool ldv_flush_work_52(struct work_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_47(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 528 "include/linux/workqueue.h"
__inline static bool schedule_work(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 530
  tmp = queue_work(system_wq, work);
#line 530
  return (tmp);
}
}
#line 139 "include/linux/ioport.h"
extern struct resource iomem_resource ;
#line 192
extern struct resource *__request_region(struct resource * , resource_size_t  , resource_size_t  ,
                                         char const   * , int  ) ;
#line 201
extern void __release_region(struct resource * , resource_size_t  , resource_size_t  ) ;
#line 58 "./arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 58
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 58
  return (ret);
}
}
#line 66 "./arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 66
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 67
  return;
}
}
#line 181
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 195
extern void iounmap(void volatile   * ) ;
#line 36 "include/linux/kmod.h"
extern int __request_module(bool  , char const   *  , ...) ;
#line 421 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 425
extern void schedule(void) ;
#line 2337
extern int sched_setscheduler(struct task_struct * , int  , struct sched_param  const  * ) ;
#line 2410
extern int wake_up_process(struct task_struct * ) ;
#line 2821 "include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 
  int tmp ;

  {
#line 2823
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
#line 2823
  return (tmp);
}
}
#line 2847 "include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 2849
  tmp = test_tsk_thread_flag(p, 2);
#line 2849
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2849
  return ((int )tmp___0);
}
}
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct file *ivtv_v4l2_dec_fops_group0  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_8  ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_15  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int pci_counter  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct timer_list *ldv_timer_list_3  ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_0  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_5  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_audioout *ivtv_ioctl_ops_group7  ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_13  ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_12  ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_14  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_17  ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct work_struct *ldv_work_struct_2_3  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_subdev *subdev_tuner_ops_group0  ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct cx2341x_handler *ivtv_cxhdl_ops_group0  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct work_struct *ldv_work_struct_2_0  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct i2c_adapter *ivtv_algo_group0  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_9  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct file *ivtv_v4l2_radio_fops_group0  ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct file *ivtv_ioctl_ops_group3  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct work_struct *ldv_work_struct_2_2  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_subdev *subdev_audio_ops_group0  ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ref_cnt  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_irq_line_1_1  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_1  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_7  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_irq_line_1_2  ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void *ldv_irq_data_1_1  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_subdev *subdev_core_ops_group1  ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_10  ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_decoder_cmd *ivtv_ioctl_ops_group5  ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct work_struct *ldv_work_struct_2_1  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_audio *ivtv_ioctl_ops_group2  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void *ldv_irq_data_1_0  ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_6  ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_fh *ivtv_ioctl_ops_group4  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_16  ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void *ldv_irq_data_1_3  ;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_2  ;
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_ctrl *ivtv_hdl_out_ops_group0  ;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_work_2_0  ;
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_ext_controls *subdev_core_ops_group0  ;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void *ldv_irq_data_1_2  ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct file *ivtv_v4l2_enc_fops_group0  ;
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_control *subdev_core_ops_group2  ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_encoder_cmd *ivtv_ioctl_ops_group8  ;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_11  ;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_selection *ivtv_ioctl_ops_group9  ;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_format *ivtv_ioctl_ops_group6  ;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_irq_line_1_3  ;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_fmtdesc *ivtv_ioctl_ops_group0  ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_work_2_2  ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_3  ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_irq_line_1_0  ;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct v4l2_event_subscription  const  *ivtv_ioctl_ops_group1  ;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
struct pci_dev *ivtv_pci_driver_group1  ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_work_2_3  ;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_state_variable_4  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_work_2_1  ;
#line 88
void ldv_initialize_v4l2_subdev_audio_ops_11(void) ;
#line 89
void ldv_initialize_v4l2_subdev_tuner_ops_12(void) ;
#line 90
void work_init_2(void) ;
#line 91
void choose_timer_3(struct timer_list *timer ) ;
#line 92
void ldv_initialize_v4l2_file_operations_6(void) ;
#line 94
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) ;
#line 95
void ldv_pci_driver_15(void) ;
#line 98
void ldv_initialize_v4l2_ioctl_ops_7(void) ;
#line 99
void choose_interrupt_1(void) ;
#line 100
void disable_suitable_timer_3(struct timer_list *timer ) ;
#line 101
void ldv_initialize_v4l2_subdev_core_ops_13(void) ;
#line 102
void ldv_initialize_i2c_algorithm_9(void) ;
#line 103
void disable_work_2(struct work_struct *work ) ;
#line 104
void disable_suitable_irq_1(int line , void *data ) ;
#line 105
int ldv_irq_1(int state , int line , void *data ) ;
#line 106
void activate_suitable_irq_1(int line , void *data ) ;
#line 107
void activate_pending_timer_3(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 109
void ldv_initialize_v4l2_file_operations_5(void) ;
#line 110
int reg_timer_3(struct timer_list *timer ) ;
#line 111
void call_and_disable_work_2(struct work_struct *work ) ;
#line 112
void ldv_initialize_v4l2_file_operations_4(void) ;
#line 113
void invoke_work_2(void) ;
#line 863 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 865
  return ((void *)dev->driver_data);
}
}
#line 857 "include/linux/pci.h"
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int  , int  , u8 * ) ;
#line 859
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
#line 863
extern int pci_bus_write_config_byte(struct pci_bus * , unsigned int  , int  , u8  ) ;
#line 867
extern int pci_bus_write_config_dword(struct pci_bus * , unsigned int  , int  , u32  ) ;
#line 881 "include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ 
  int tmp ;

  {
#line 883
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
#line 883
  return (tmp);
}
}
#line 885 "include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ 
  int tmp ;

  {
#line 887
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
#line 887
  return (tmp);
}
}
#line 894 "include/linux/pci.h"
__inline static int pci_write_config_byte(struct pci_dev  const  *dev , int where ,
                                          u8 val ) 
{ 
  int tmp ;

  {
#line 896
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, (int )val);
#line 896
  return (tmp);
}
}
#line 902 "include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val ) 
{ 
  int tmp ;

  {
#line 905
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
#line 905
  return (tmp);
}
}
#line 949
extern int pci_enable_device(struct pci_dev * ) ;
#line 966
extern void pci_disable_device(struct pci_dev * ) ;
#line 969
extern void pci_set_master(struct pci_dev * ) ;
#line 1140
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1144
int ldv___pci_register_driver_57(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) ;
#line 1153
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1156
void ldv_pci_unregister_driver_58(struct pci_driver *ldv_func_arg1 ) ;
#line 252 "include/linux/scatterlist.h"
extern void sg_init_table(struct scatterlist * , unsigned int  ) ;
#line 61 "./arch/x86/include/asm/dma-mapping.h"
extern int dma_set_mask(struct device * , u64  ) ;
#line 113 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 115
  tmp = dma_set_mask(& dev->dev, mask);
#line 115
  return (tmp);
}
}
#line 127 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 132 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 135
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 135
  return (tmp);
}
}
#line 141
__inline static int ldv_request_irq_53(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 150
extern void free_irq(unsigned int  , void * ) ;
#line 153
void ldv_free_irq_54(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 157
void ldv_free_irq_56(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 8 "include/linux/kthread.h"
extern struct task_struct *kthread_create_on_node(int (*)(void * ) , void * , int  ,
                                                  char const   *  , ...) ;
#line 41
extern int kthread_stop(struct task_struct * ) ;
#line 108
extern void __init_kthread_worker(struct kthread_worker * , char const   * , struct lock_class_key * ) ;
#line 124
extern int kthread_worker_fn(void * ) ;
#line 129
extern void flush_kthread_worker(struct kthread_worker * ) ;
#line 370 "include/media/v4l2-ctrls.h"
extern void v4l2_ctrl_handler_free(struct v4l2_ctrl_handler * ) ;
#line 443
extern struct v4l2_ctrl *v4l2_ctrl_new_std(struct v4l2_ctrl_handler * , struct v4l2_ctrl_ops  const  * ,
                                           u32  , s64  , s64  , u64  , s64  ) ;
#line 465
extern struct v4l2_ctrl *v4l2_ctrl_new_std_menu(struct v4l2_ctrl_handler * , struct v4l2_ctrl_ops  const  * ,
                                                u32  , u8  , u64  , u8  ) ;
#line 552
extern void v4l2_ctrl_cluster(unsigned int  , struct v4l2_ctrl ** ) ;
#line 77 "include/media/v4l2-device.h"
extern int v4l2_device_register(struct device * , struct v4l2_device * ) ;
#line 95
extern int v4l2_device_set_name(struct v4l2_device * , char const   * , atomic_t * ) ;
#line 104
extern void v4l2_device_unregister(struct v4l2_device * ) ;
#line 193 "include/media/cx2341x.h"
extern int cx2341x_handler_init(struct cx2341x_handler * , unsigned int  ) ;
#line 195
extern void cx2341x_handler_set_50hz(struct cx2341x_handler * , int  ) ;
#line 196
extern int cx2341x_handler_setup(struct cx2341x_handler * ) ;
#line 123 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
int ivtv_debug  ;
#line 125 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
int ivtv_fw_debug  ;
#line 758 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
__inline static struct ivtv *to_ivtv(struct v4l2_device *v4l2_dev ) 
{ 
  struct v4l2_device  const  *__mptr ;

  {
#line 760
  __mptr = (struct v4l2_device  const  *)v4l2_dev;
#line 760
  return ((struct ivtv *)__mptr + 0xffffffffffffff58UL);
}
}
#line 764 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
int (*ivtv_ext_init)(struct ivtv * )  ;
#line 767 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
int ivtv_first_minor  ;
#line 772
void ivtv_set_irq_mask(struct ivtv *itv , u32 mask ) ;
#line 773
void ivtv_clear_irq_mask(struct ivtv *itv , u32 mask ) ;
#line 776
int ivtv_set_output_mode(struct ivtv *itv , int mode ) ;
#line 779
struct ivtv_stream *ivtv_get_output_stream(struct ivtv *itv ) ;
#line 782
int ivtv_msleep_timeout(unsigned int msecs , int intr ) ;
#line 785
int ivtv_waitq(wait_queue_head_t *waitq ) ;
#line 789
void ivtv_read_eeprom(struct ivtv *itv , struct tveeprom *tv ) ;
#line 792
int ivtv_init_on_first_open(struct ivtv *itv ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-i2c.h"
struct i2c_client *ivtv_i2c_new_ir_legacy(struct ivtv *itv ) ;
#line 25
int ivtv_i2c_register(struct ivtv *itv , unsigned int idx ) ;
#line 26
struct v4l2_subdev *ivtv_find_hw(struct ivtv *itv , u32 hw ) ;
#line 29
int init_ivtv_i2c(struct ivtv *itv ) ;
#line 30
void exit_ivtv_i2c(struct ivtv *itv ) ;
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-firmware.h"
int ivtv_firmware_init(struct ivtv *itv ) ;
#line 26
void ivtv_firmware_versions(struct ivtv *itv ) ;
#line 27
void ivtv_halt_firmware(struct ivtv *itv ) ;
#line 28
void ivtv_init_mpeg_decoder(struct ivtv *itv ) ;
#line 29
int ivtv_firmware_check(struct ivtv *itv , char *where ) ;
#line 28 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-udma.h"
int ivtv_udma_setup(struct ivtv *itv , unsigned long ivtv_dest_addr , void *userbuf ,
                    int size_in_bytes ) ;
#line 30
void ivtv_udma_unmap(struct ivtv *itv ) ;
#line 31
void ivtv_udma_free(struct ivtv *itv ) ;
#line 32
void ivtv_udma_alloc(struct ivtv *itv ) ;
#line 33
void ivtv_udma_prepare(struct ivtv *itv ) ;
#line 47 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-irq.h"
irqreturn_t ivtv_irq_handler(int irq , void *dev_id ) ;
#line 49
void ivtv_irq_work_handler(struct kthread_work *work ) ;
#line 51
void ivtv_unfinished_dma(unsigned long arg ) ;
#line 30 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-mailbox.h"
int ivtv_vapi_result(struct ivtv *itv , u32 *data , int cmd , int args  , ...) ;
#line 32
int ivtv_api_func(void *priv , u32 cmd , int in , int out , u32 *data ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-streams.h"
int ivtv_streams_setup(struct ivtv *itv ) ;
#line 25
int ivtv_streams_register(struct ivtv *itv ) ;
#line 26
void ivtv_streams_cleanup(struct ivtv *itv ) ;
#line 32
int ivtv_stop_v4l2_decode_stream(struct ivtv_stream *s , int flags , u64 pts ) ;
#line 34
void ivtv_stop_all_captures(struct ivtv *itv ) ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-ioctl.h"
void ivtv_set_osd_alpha(struct ivtv *itv ) ;
#line 30
void ivtv_s_std_enc(struct ivtv *itv , v4l2_std_id std ) ;
#line 31
void ivtv_s_std_dec(struct ivtv *itv , v4l2_std_id std ) ;
#line 32
int ivtv_s_frequency(struct file *file , void *fh , struct v4l2_frequency  const  *vf ) ;
#line 33
int ivtv_s_input(struct file *file , void *fh , unsigned int inp ) ;
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-gpio.h"
int ivtv_gpio_init(struct ivtv *itv ) ;
#line 26
void ivtv_reset_ir_gpio(struct ivtv *itv ) ;
#line 27
int ivtv_reset_tuner_gpio(void *dev , int component , int cmd , int value ) ;
#line 48 "include/media/tveeprom.h"
extern void tveeprom_hauppauge_analog(struct i2c_client * , struct tveeprom * , unsigned char * ) ;
#line 51
extern int tveeprom_read(struct i2c_client * , unsigned char * , int  ) ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_ext_init[14U]  = 
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
  {      'i',      'v',      't',      'v', 
        '_',      'e',      'x',      't', 
        '_',      'i',      'n',      'i', 
        't',      '\000'};
#line 72
struct kernel_symbol  const  __ksymtab_ivtv_ext_init ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_ext_init  =    {(unsigned long )(& ivtv_ext_init), (char const   *)(& __kstrtab_ivtv_ext_init)};
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static struct pci_device_id ivtv_pci_tbl[3U]  = {      {17476U, 2051U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {17476U, 22U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct pci_device_id  const  __mod_pci__ivtv_pci_tbl_device_table[3U]  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static atomic_t ivtv_instance  =    {0};
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int cardtype[32U]  ;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int tuner[32U]  = 
#line 90
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int radio[32U]  = 
#line 94
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int i2c_clock_period[32U]  = 
#line 98
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char pal[4U]  = {      '-',      '-',      '-',      '\000'};
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char secam[3U]  = {      '-',      '-',      '\000'};
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char ntsc[2U]  = {      '-',      '\000'};
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int enc_mpg_buffers  =    4;
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int enc_yuv_buffers  =    2;
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int enc_vbi_buffers  =    1;
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int enc_pcm_buffers  =    320;
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int dec_mpg_buffers  =    1;
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int dec_yuv_buffers  =    1;
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int dec_vbi_buffers  =    64;
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int ivtv_yuv_mode  ;
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int ivtv_yuv_threshold  =    -1;
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int ivtv_pci_latency  =    1;
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int tunertype  =    -1;
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int newi2c  =    -1;
#line 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static void request_module_async(struct work_struct *work ) 
{ 
  struct ivtv *dev ;
  struct work_struct  const  *__mptr ;

  {
#line 288
  __mptr = (struct work_struct  const  *)work;
#line 288
  dev = (struct ivtv *)__mptr + 0xffffffffffffa758UL;
#line 291
  __request_module(1, "ivtv-alsa");
#line 294
  if ((unsigned long )ivtv_ext_init != (unsigned long )((int (*)(struct ivtv * ))0)) {
#line 295
    (*ivtv_ext_init)(dev);
  } else {

  }
#line 296
  return;
}
}
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static void request_modules(struct ivtv *dev ) 
{ 
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 300
  __init_work(& dev->request_module_wk, 0);
#line 300
  __constr_expr_0.counter = 137438953408L;
#line 300
  dev->request_module_wk.data = __constr_expr_0;
#line 300
  lockdep_init_map(& dev->request_module_wk.lockdep_map, "(&dev->request_module_wk)",
                   & __key, 0);
#line 300
  INIT_LIST_HEAD(& dev->request_module_wk.entry);
#line 300
  dev->request_module_wk.func = & request_module_async;
#line 301
  schedule_work(& dev->request_module_wk);
#line 302
  return;
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static void flush_request_modules(struct ivtv *dev ) 
{ 


  {
#line 306
  ldv_flush_work_52(& dev->request_module_wk);
#line 307
  return;
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
void ivtv_clear_irq_mask(struct ivtv *itv , u32 mask ) 
{ 


  {
#line 315
  itv->irqmask = itv->irqmask & ~ mask;
#line 316
  writel(itv->irqmask, itv->reg_mem + 72UL);
#line 316
  readl((void const volatile   *)itv->reg_mem + 72U);
#line 317
  return;
}
}
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
void ivtv_set_irq_mask(struct ivtv *itv , u32 mask ) 
{ 


  {
#line 321
  itv->irqmask = itv->irqmask | mask;
#line 322
  writel(itv->irqmask, itv->reg_mem + 72UL);
#line 322
  readl((void const volatile   *)itv->reg_mem + 72U);
#line 323
  return;
}
}
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
int ivtv_set_output_mode(struct ivtv *itv , int mode ) 
{ 
  int old_mode ;

  {
#line 329
  spin_lock(& itv->lock);
#line 330
  old_mode = itv->output_mode;
#line 331
  if (old_mode == 0) {
#line 332
    old_mode = mode;
#line 332
    itv->output_mode = old_mode;
  } else {

  }
#line 333
  spin_unlock(& itv->lock);
#line 334
  return (old_mode);
}
}
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct ivtv_stream *ivtv_get_output_stream(struct ivtv *itv ) 
{ 


  {
#line 339
  switch (itv->output_mode) {
  case 1: ;
#line 341
  return ((struct ivtv_stream *)(& itv->streams) + 5UL);
  case 2: ;
#line 343
  return ((struct ivtv_stream *)(& itv->streams) + 8UL);
  default: ;
#line 345
  return ((struct ivtv_stream *)0);
  }
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
int ivtv_waitq(wait_queue_head_t *waitq ) 
{ 
  wait_queue_t wait ;
  struct task_struct *tmp ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;

  {
#line 351
  tmp = get_current();
#line 351
  wait.flags = 0U;
#line 351
  wait.private = (void *)tmp;
#line 351
  wait.func = & autoremove_wake_function;
#line 351
  wait.task_list.next = & wait.task_list;
#line 351
  wait.task_list.prev = & wait.task_list;
#line 353
  prepare_to_wait(waitq, & wait, 1);
#line 354
  schedule();
#line 355
  finish_wait(waitq, & wait);
#line 356
  tmp___0 = get_current();
#line 356
  tmp___1 = signal_pending(tmp___0);
#line 356
  return (tmp___1 != 0 ? -4 : 0);
}
}
#line 360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
int ivtv_msleep_timeout(unsigned int msecs , int intr ) 
{ 
  int timeout ;
  unsigned long tmp ;
  struct task_struct *tmp___0 ;
  long volatile   __ret ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  long tmp___5 ;
  int ret ;
  struct task_struct *tmp___6 ;
  int tmp___7 ;

  {
#line 362
  tmp = msecs_to_jiffies(msecs);
#line 362
  timeout = (int )tmp;
  ldv_43192: 
#line 365
  tmp___0 = get_current();
#line 365
  tmp___0->task_state_change = 0UL;
#line 365
  __ret = intr != 0 ? 1L : 2L;
#line 365
  switch (8UL) {
  case 1UL: 
#line 365
  tmp___1 = get_current();
#line 365
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
#line 365
  goto ldv_43185;
  case 2UL: 
#line 365
  tmp___2 = get_current();
#line 365
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 365
  goto ldv_43185;
  case 4UL: 
#line 365
  tmp___3 = get_current();
#line 365
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
#line 365
  goto ldv_43185;
  case 8UL: 
#line 365
  tmp___4 = get_current();
#line 365
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                       "cc");
#line 365
  goto ldv_43185;
  default: 
#line 365
  __xchg_wrong_size();
  }
  ldv_43185: 
#line 366
  tmp___5 = schedule_timeout((long )timeout);
#line 366
  timeout = (int )tmp___5;
#line 367
  if (intr != 0) {
#line 368
    tmp___6 = get_current();
#line 368
    tmp___7 = signal_pending(tmp___6);
#line 368
    ret = tmp___7;
#line 370
    if (ret != 0) {
#line 371
      return (ret);
    } else {

    }
  } else {

  }
#line 373
  if (timeout != 0) {
#line 375
    goto ldv_43192;
  } else {

  }

#line 374
  return (0);
}
}
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static void ivtv_iounmap(struct ivtv *itv ) 
{ 


  {
#line 380
  if ((unsigned long )itv == (unsigned long )((struct ivtv *)0)) {
#line 381
    return;
  } else {

  }
#line 384
  if ((unsigned long )itv->reg_mem != (unsigned long )((void volatile   *)0)) {
#line 385
    if ((ivtv_debug & 2) != 0) {
#line 385
      printk("\016%s:  info: releasing reg_mem\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 386
    iounmap(itv->reg_mem);
#line 387
    itv->reg_mem = (void volatile   *)0;
  } else {

  }
#line 390
  if ((unsigned int )itv->has_cx23415 != 0U && (unsigned long )itv->dec_mem != (unsigned long )((void volatile   *)0)) {
#line 391
    if ((ivtv_debug & 2) != 0) {
#line 391
      printk("\016%s:  info: releasing dec_mem\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 392
    iounmap(itv->dec_mem);
  } else {

  }
#line 394
  itv->dec_mem = (void volatile   *)0;
#line 397
  if ((unsigned long )itv->enc_mem != (unsigned long )((void volatile   *)0)) {
#line 398
    if ((ivtv_debug & 2) != 0) {
#line 398
      printk("\016%s:  info: releasing enc_mem\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 399
    iounmap(itv->enc_mem);
#line 400
    itv->enc_mem = (void volatile   *)0;
  } else {

  }
#line 402
  return;
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
void ivtv_read_eeprom(struct ivtv *itv , struct tveeprom *tv ) 
{ 
  u8 eedata[256U] ;

  {
#line 409
  itv->i2c_client.addr = 80U;
#line 410
  tveeprom_read(& itv->i2c_client, (unsigned char *)(& eedata), 256);
#line 411
  tveeprom_hauppauge_analog(& itv->i2c_client, tv, (unsigned char *)(& eedata));
#line 412
  return;
}
}
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static void ivtv_process_eeprom(struct ivtv *itv ) 
{ 
  struct tveeprom tv ;
  int pci_slot ;
  struct ivtv_card_tuner_i2c ivtv_i2c_radio___0 ;
  unsigned int tmp ;
  int is_first ;

  {
#line 417
  pci_slot = (int )((itv->pdev)->devfn >> 3) & 31;
#line 419
  ivtv_read_eeprom(itv, & tv);
#line 423
  switch (tv.model) {
  case 30039U: 
  case 30038U: 
  case 30037U: 
  case 30036U: 
  case 30035U: 
  case 30034U: 
  case 30033U: 
  case 30032U: 
  case 30031U: 
  case 30030U: 
  case 30029U: 
  case 30028U: 
  case 30027U: 
  case 30026U: 
  case 30025U: 
  case 30024U: 
  case 30023U: 
  case 30022U: 
  case 30021U: 
  case 30020U: 
  case 30019U: 
  case 30018U: 
  case 30017U: 
  case 30016U: 
  case 30015U: 
  case 30014U: 
  case 30013U: 
  case 30012U: ;
  case 32999U: 
  case 32998U: 
  case 32997U: 
  case 32996U: 
  case 32995U: 
  case 32994U: 
  case 32993U: 
  case 32992U: 
  case 32991U: 
  case 32990U: 
  case 32989U: 
  case 32988U: 
  case 32987U: 
  case 32986U: 
  case 32985U: 
  case 32984U: 
  case 32983U: 
  case 32982U: 
  case 32981U: 
  case 32980U: 
  case 32979U: 
  case 32978U: 
  case 32977U: 
  case 32976U: 
  case 32975U: 
  case 32974U: 
  case 32973U: 
  case 32972U: 
  case 32971U: 
  case 32970U: 
  case 32969U: 
  case 32968U: 
  case 32967U: 
  case 32966U: 
  case 32965U: 
  case 32964U: 
  case 32963U: 
  case 32962U: 
  case 32961U: 
  case 32960U: 
  case 32959U: 
  case 32958U: 
  case 32957U: 
  case 32956U: 
  case 32955U: 
  case 32954U: 
  case 32953U: 
  case 32952U: 
  case 32951U: 
  case 32950U: 
  case 32949U: 
  case 32948U: 
  case 32947U: 
  case 32946U: 
  case 32945U: 
  case 32944U: 
  case 32943U: 
  case 32942U: 
  case 32941U: 
  case 32940U: 
  case 32939U: 
  case 32938U: 
  case 32937U: 
  case 32936U: 
  case 32935U: 
  case 32934U: 
  case 32933U: 
  case 32932U: 
  case 32931U: 
  case 32930U: 
  case 32929U: 
  case 32928U: 
  case 32927U: 
  case 32926U: 
  case 32925U: 
  case 32924U: 
  case 32923U: 
  case 32922U: 
  case 32921U: 
  case 32920U: 
  case 32919U: 
  case 32918U: 
  case 32917U: 
  case 32916U: 
  case 32915U: 
  case 32914U: 
  case 32913U: 
  case 32912U: 
  case 32911U: 
  case 32910U: 
  case 32909U: 
  case 32908U: 
  case 32907U: 
  case 32906U: 
  case 32905U: 
  case 32904U: 
  case 32903U: 
  case 32902U: 
  case 32901U: 
  case 32900U: 
  case 32899U: 
  case 32898U: 
  case 32897U: 
  case 32896U: 
  case 32895U: 
  case 32894U: 
  case 32893U: 
  case 32892U: 
  case 32891U: 
  case 32890U: 
  case 32889U: 
  case 32888U: 
  case 32887U: 
  case 32886U: 
  case 32885U: 
  case 32884U: 
  case 32883U: 
  case 32882U: 
  case 32881U: 
  case 32880U: 
  case 32879U: 
  case 32878U: 
  case 32877U: 
  case 32876U: 
  case 32875U: 
  case 32874U: 
  case 32873U: 
  case 32872U: 
  case 32871U: 
  case 32870U: 
  case 32869U: 
  case 32868U: 
  case 32867U: 
  case 32866U: 
  case 32865U: 
  case 32864U: 
  case 32863U: 
  case 32862U: 
  case 32861U: 
  case 32860U: 
  case 32859U: 
  case 32858U: 
  case 32857U: 
  case 32856U: 
  case 32855U: 
  case 32854U: 
  case 32853U: 
  case 32852U: 
  case 32851U: 
  case 32850U: 
  case 32849U: 
  case 32848U: 
  case 32847U: 
  case 32846U: 
  case 32845U: 
  case 32844U: 
  case 32843U: 
  case 32842U: 
  case 32841U: 
  case 32840U: 
  case 32839U: 
  case 32838U: 
  case 32837U: 
  case 32836U: 
  case 32835U: 
  case 32834U: 
  case 32833U: 
  case 32832U: 
  case 32831U: 
  case 32830U: 
  case 32829U: 
  case 32828U: 
  case 32827U: 
  case 32826U: 
  case 32825U: 
  case 32824U: 
  case 32823U: 
  case 32822U: 
  case 32821U: 
  case 32820U: 
  case 32819U: 
  case 32818U: 
  case 32817U: 
  case 32816U: 
  case 32815U: 
  case 32814U: 
  case 32813U: 
  case 32812U: 
  case 32811U: 
  case 32810U: 
  case 32809U: 
  case 32808U: 
  case 32807U: 
  case 32806U: 
  case 32805U: 
  case 32804U: 
  case 32803U: 
  case 32802U: 
  case 32801U: 
  case 32800U: 
  case 32799U: 
  case 32798U: 
  case 32797U: 
  case 32796U: 
  case 32795U: 
  case 32794U: 
  case 32793U: 
  case 32792U: 
  case 32791U: 
  case 32790U: 
  case 32789U: 
  case 32788U: 
  case 32787U: 
  case 32786U: 
  case 32785U: 
  case 32784U: 
  case 32783U: 
  case 32782U: 
  case 32781U: 
  case 32780U: 
  case 32779U: 
  case 32778U: 
  case 32777U: 
  case 32776U: 
  case 32775U: 
  case 32774U: 
  case 32773U: 
  case 32772U: 
  case 32771U: 
  case 32770U: 
  case 32769U: 
  case 32768U: 
  case 32767U: 
  case 32766U: 
  case 32765U: 
  case 32764U: 
  case 32763U: 
  case 32762U: 
  case 32761U: 
  case 32760U: 
  case 32759U: 
  case 32758U: 
  case 32757U: 
  case 32756U: 
  case 32755U: 
  case 32754U: 
  case 32753U: 
  case 32752U: 
  case 32751U: 
  case 32750U: 
  case 32749U: 
  case 32748U: 
  case 32747U: 
  case 32746U: 
  case 32745U: 
  case 32744U: 
  case 32743U: 
  case 32742U: 
  case 32741U: 
  case 32740U: 
  case 32739U: 
  case 32738U: 
  case 32737U: 
  case 32736U: 
  case 32735U: 
  case 32734U: 
  case 32733U: 
  case 32732U: 
  case 32731U: 
  case 32730U: 
  case 32729U: 
  case 32728U: 
  case 32727U: 
  case 32726U: 
  case 32725U: 
  case 32724U: 
  case 32723U: 
  case 32722U: 
  case 32721U: 
  case 32720U: 
  case 32719U: 
  case 32718U: 
  case 32717U: 
  case 32716U: 
  case 32715U: 
  case 32714U: 
  case 32713U: 
  case 32712U: 
  case 32711U: 
  case 32710U: 
  case 32709U: 
  case 32708U: 
  case 32707U: 
  case 32706U: 
  case 32705U: 
  case 32704U: 
  case 32703U: 
  case 32702U: 
  case 32701U: 
  case 32700U: 
  case 32699U: 
  case 32698U: 
  case 32697U: 
  case 32696U: 
  case 32695U: 
  case 32694U: 
  case 32693U: 
  case 32692U: 
  case 32691U: 
  case 32690U: 
  case 32689U: 
  case 32688U: 
  case 32687U: 
  case 32686U: 
  case 32685U: 
  case 32684U: 
  case 32683U: 
  case 32682U: 
  case 32681U: 
  case 32680U: 
  case 32679U: 
  case 32678U: 
  case 32677U: 
  case 32676U: 
  case 32675U: 
  case 32674U: 
  case 32673U: 
  case 32672U: 
  case 32671U: 
  case 32670U: 
  case 32669U: 
  case 32668U: 
  case 32667U: 
  case 32666U: 
  case 32665U: 
  case 32664U: 
  case 32663U: 
  case 32662U: 
  case 32661U: 
  case 32660U: 
  case 32659U: 
  case 32658U: 
  case 32657U: 
  case 32656U: 
  case 32655U: 
  case 32654U: 
  case 32653U: 
  case 32652U: 
  case 32651U: 
  case 32650U: 
  case 32649U: 
  case 32648U: 
  case 32647U: 
  case 32646U: 
  case 32645U: 
  case 32644U: 
  case 32643U: 
  case 32642U: 
  case 32641U: 
  case 32640U: 
  case 32639U: 
  case 32638U: 
  case 32637U: 
  case 32636U: 
  case 32635U: 
  case 32634U: 
  case 32633U: 
  case 32632U: 
  case 32631U: 
  case 32630U: 
  case 32629U: 
  case 32628U: 
  case 32627U: 
  case 32626U: 
  case 32625U: 
  case 32624U: 
  case 32623U: 
  case 32622U: 
  case 32621U: 
  case 32620U: 
  case 32619U: 
  case 32618U: 
  case 32617U: 
  case 32616U: 
  case 32615U: 
  case 32614U: 
  case 32613U: 
  case 32612U: 
  case 32611U: 
  case 32610U: 
  case 32609U: 
  case 32608U: 
  case 32607U: 
  case 32606U: 
  case 32605U: 
  case 32604U: 
  case 32603U: 
  case 32602U: 
  case 32601U: 
  case 32600U: 
  case 32599U: 
  case 32598U: 
  case 32597U: 
  case 32596U: 
  case 32595U: 
  case 32594U: 
  case 32593U: 
  case 32592U: 
  case 32591U: 
  case 32590U: 
  case 32589U: 
  case 32588U: 
  case 32587U: 
  case 32586U: 
  case 32585U: 
  case 32584U: 
  case 32583U: 
  case 32582U: 
  case 32581U: 
  case 32580U: 
  case 32579U: 
  case 32578U: 
  case 32577U: 
  case 32576U: 
  case 32575U: 
  case 32574U: 
  case 32573U: 
  case 32572U: 
  case 32571U: 
  case 32570U: 
  case 32569U: 
  case 32568U: 
  case 32567U: 
  case 32566U: 
  case 32565U: 
  case 32564U: 
  case 32563U: 
  case 32562U: 
  case 32561U: 
  case 32560U: 
  case 32559U: 
  case 32558U: 
  case 32557U: 
  case 32556U: 
  case 32555U: 
  case 32554U: 
  case 32553U: 
  case 32552U: 
  case 32551U: 
  case 32550U: 
  case 32549U: 
  case 32548U: 
  case 32547U: 
  case 32546U: 
  case 32545U: 
  case 32544U: 
  case 32543U: 
  case 32542U: 
  case 32541U: 
  case 32540U: 
  case 32539U: 
  case 32538U: 
  case 32537U: 
  case 32536U: 
  case 32535U: 
  case 32534U: 
  case 32533U: 
  case 32532U: 
  case 32531U: 
  case 32530U: 
  case 32529U: 
  case 32528U: 
  case 32527U: 
  case 32526U: 
  case 32525U: 
  case 32524U: 
  case 32523U: 
  case 32522U: 
  case 32521U: 
  case 32520U: 
  case 32519U: 
  case 32518U: 
  case 32517U: 
  case 32516U: 
  case 32515U: 
  case 32514U: 
  case 32513U: 
  case 32512U: 
  case 32511U: 
  case 32510U: 
  case 32509U: 
  case 32508U: 
  case 32507U: 
  case 32506U: 
  case 32505U: 
  case 32504U: 
  case 32503U: 
  case 32502U: 
  case 32501U: 
  case 32500U: 
  case 32499U: 
  case 32498U: 
  case 32497U: 
  case 32496U: 
  case 32495U: 
  case 32494U: 
  case 32493U: 
  case 32492U: 
  case 32491U: 
  case 32490U: 
  case 32489U: 
  case 32488U: 
  case 32487U: 
  case 32486U: 
  case 32485U: 
  case 32484U: 
  case 32483U: 
  case 32482U: 
  case 32481U: 
  case 32480U: 
  case 32479U: 
  case 32478U: 
  case 32477U: 
  case 32476U: 
  case 32475U: 
  case 32474U: 
  case 32473U: 
  case 32472U: 
  case 32471U: 
  case 32470U: 
  case 32469U: 
  case 32468U: 
  case 32467U: 
  case 32466U: 
  case 32465U: 
  case 32464U: 
  case 32463U: 
  case 32462U: 
  case 32461U: 
  case 32460U: 
  case 32459U: 
  case 32458U: 
  case 32457U: 
  case 32456U: 
  case 32455U: 
  case 32454U: 
  case 32453U: 
  case 32452U: 
  case 32451U: 
  case 32450U: 
  case 32449U: 
  case 32448U: 
  case 32447U: 
  case 32446U: 
  case 32445U: 
  case 32444U: 
  case 32443U: 
  case 32442U: 
  case 32441U: 
  case 32440U: 
  case 32439U: 
  case 32438U: 
  case 32437U: 
  case 32436U: 
  case 32435U: 
  case 32434U: 
  case 32433U: 
  case 32432U: 
  case 32431U: 
  case 32430U: 
  case 32429U: 
  case 32428U: 
  case 32427U: 
  case 32426U: 
  case 32425U: 
  case 32424U: 
  case 32423U: 
  case 32422U: 
  case 32421U: 
  case 32420U: 
  case 32419U: 
  case 32418U: 
  case 32417U: 
  case 32416U: 
  case 32415U: 
  case 32414U: 
  case 32413U: 
  case 32412U: 
  case 32411U: 
  case 32410U: 
  case 32409U: 
  case 32408U: 
  case 32407U: 
  case 32406U: 
  case 32405U: 
  case 32404U: 
  case 32403U: 
  case 32402U: 
  case 32401U: 
  case 32400U: 
  case 32399U: 
  case 32398U: 
  case 32397U: 
  case 32396U: 
  case 32395U: 
  case 32394U: 
  case 32393U: 
  case 32392U: 
  case 32391U: 
  case 32390U: 
  case 32389U: 
  case 32388U: 
  case 32387U: 
  case 32386U: 
  case 32385U: 
  case 32384U: 
  case 32383U: 
  case 32382U: 
  case 32381U: 
  case 32380U: 
  case 32379U: 
  case 32378U: 
  case 32377U: 
  case 32376U: 
  case 32375U: 
  case 32374U: 
  case 32373U: 
  case 32372U: 
  case 32371U: 
  case 32370U: 
  case 32369U: 
  case 32368U: 
  case 32367U: 
  case 32366U: 
  case 32365U: 
  case 32364U: 
  case 32363U: 
  case 32362U: 
  case 32361U: 
  case 32360U: 
  case 32359U: 
  case 32358U: 
  case 32357U: 
  case 32356U: 
  case 32355U: 
  case 32354U: 
  case 32353U: 
  case 32352U: 
  case 32351U: 
  case 32350U: 
  case 32349U: 
  case 32348U: 
  case 32347U: 
  case 32346U: 
  case 32345U: 
  case 32344U: 
  case 32343U: 
  case 32342U: 
  case 32341U: 
  case 32340U: 
  case 32339U: 
  case 32338U: 
  case 32337U: 
  case 32336U: 
  case 32335U: 
  case 32334U: 
  case 32333U: 
  case 32332U: 
  case 32331U: 
  case 32330U: 
  case 32329U: 
  case 32328U: 
  case 32327U: 
  case 32326U: 
  case 32325U: 
  case 32324U: 
  case 32323U: 
  case 32322U: 
  case 32321U: 
  case 32320U: 
  case 32319U: 
  case 32318U: 
  case 32317U: 
  case 32316U: 
  case 32315U: 
  case 32314U: 
  case 32313U: 
  case 32312U: 
  case 32311U: 
  case 32310U: 
  case 32309U: 
  case 32308U: 
  case 32307U: 
  case 32306U: 
  case 32305U: 
  case 32304U: 
  case 32303U: 
  case 32302U: 
  case 32301U: 
  case 32300U: 
  case 32299U: 
  case 32298U: 
  case 32297U: 
  case 32296U: 
  case 32295U: 
  case 32294U: 
  case 32293U: 
  case 32292U: 
  case 32291U: 
  case 32290U: 
  case 32289U: 
  case 32288U: 
  case 32287U: 
  case 32286U: 
  case 32285U: 
  case 32284U: 
  case 32283U: 
  case 32282U: 
  case 32281U: 
  case 32280U: 
  case 32279U: 
  case 32278U: 
  case 32277U: 
  case 32276U: 
  case 32275U: 
  case 32274U: 
  case 32273U: 
  case 32272U: 
  case 32271U: 
  case 32270U: 
  case 32269U: 
  case 32268U: 
  case 32267U: 
  case 32266U: 
  case 32265U: 
  case 32264U: 
  case 32263U: 
  case 32262U: 
  case 32261U: 
  case 32260U: 
  case 32259U: 
  case 32258U: 
  case 32257U: 
  case 32256U: 
  case 32255U: 
  case 32254U: 
  case 32253U: 
  case 32252U: 
  case 32251U: 
  case 32250U: 
  case 32249U: 
  case 32248U: 
  case 32247U: 
  case 32246U: 
  case 32245U: 
  case 32244U: 
  case 32243U: 
  case 32242U: 
  case 32241U: 
  case 32240U: 
  case 32239U: 
  case 32238U: 
  case 32237U: 
  case 32236U: 
  case 32235U: 
  case 32234U: 
  case 32233U: 
  case 32232U: 
  case 32231U: 
  case 32230U: 
  case 32229U: 
  case 32228U: 
  case 32227U: 
  case 32226U: 
  case 32225U: 
  case 32224U: 
  case 32223U: 
  case 32222U: 
  case 32221U: 
  case 32220U: 
  case 32219U: 
  case 32218U: 
  case 32217U: 
  case 32216U: 
  case 32215U: 
  case 32214U: 
  case 32213U: 
  case 32212U: 
  case 32211U: 
  case 32210U: 
  case 32209U: 
  case 32208U: 
  case 32207U: 
  case 32206U: 
  case 32205U: 
  case 32204U: 
  case 32203U: 
  case 32202U: 
  case 32201U: 
  case 32200U: 
  case 32199U: 
  case 32198U: 
  case 32197U: 
  case 32196U: 
  case 32195U: 
  case 32194U: 
  case 32193U: 
  case 32192U: 
  case 32191U: 
  case 32190U: 
  case 32189U: 
  case 32188U: 
  case 32187U: 
  case 32186U: 
  case 32185U: 
  case 32184U: 
  case 32183U: 
  case 32182U: 
  case 32181U: 
  case 32180U: 
  case 32179U: 
  case 32178U: 
  case 32177U: 
  case 32176U: 
  case 32175U: 
  case 32174U: 
  case 32173U: 
  case 32172U: 
  case 32171U: 
  case 32170U: 
  case 32169U: 
  case 32168U: 
  case 32167U: 
  case 32166U: 
  case 32165U: 
  case 32164U: 
  case 32163U: 
  case 32162U: 
  case 32161U: 
  case 32160U: 
  case 32159U: 
  case 32158U: 
  case 32157U: 
  case 32156U: 
  case 32155U: 
  case 32154U: 
  case 32153U: 
  case 32152U: 
  case 32151U: 
  case 32150U: 
  case 32149U: 
  case 32148U: 
  case 32147U: 
  case 32146U: 
  case 32145U: 
  case 32144U: 
  case 32143U: 
  case 32142U: 
  case 32141U: 
  case 32140U: 
  case 32139U: 
  case 32138U: 
  case 32137U: 
  case 32136U: 
  case 32135U: 
  case 32134U: 
  case 32133U: 
  case 32132U: 
  case 32131U: 
  case 32130U: 
  case 32129U: 
  case 32128U: 
  case 32127U: 
  case 32126U: 
  case 32125U: 
  case 32124U: 
  case 32123U: 
  case 32122U: 
  case 32121U: 
  case 32120U: 
  case 32119U: 
  case 32118U: 
  case 32117U: 
  case 32116U: 
  case 32115U: 
  case 32114U: 
  case 32113U: 
  case 32112U: 
  case 32111U: 
  case 32110U: 
  case 32109U: 
  case 32108U: 
  case 32107U: 
  case 32106U: 
  case 32105U: 
  case 32104U: 
  case 32103U: 
  case 32102U: 
  case 32101U: 
  case 32100U: 
  case 32099U: 
  case 32098U: 
  case 32097U: 
  case 32096U: 
  case 32095U: 
  case 32094U: 
  case 32093U: 
  case 32092U: 
  case 32091U: 
  case 32090U: 
  case 32089U: 
  case 32088U: 
  case 32087U: 
  case 32086U: 
  case 32085U: 
  case 32084U: 
  case 32083U: 
  case 32082U: 
  case 32081U: 
  case 32080U: 
  case 32079U: 
  case 32078U: 
  case 32077U: 
  case 32076U: 
  case 32075U: 
  case 32074U: 
  case 32073U: 
  case 32072U: 
  case 32071U: 
  case 32070U: 
  case 32069U: 
  case 32068U: 
  case 32067U: 
  case 32066U: 
  case 32065U: 
  case 32064U: 
  case 32063U: 
  case 32062U: 
  case 32061U: 
  case 32060U: 
  case 32059U: 
  case 32058U: 
  case 32057U: 
  case 32056U: 
  case 32055U: 
  case 32054U: 
  case 32053U: 
  case 32052U: 
  case 32051U: 
  case 32050U: 
  case 32049U: 
  case 32048U: 
  case 32047U: 
  case 32046U: 
  case 32045U: 
  case 32044U: 
  case 32043U: 
  case 32042U: 
  case 32041U: 
  case 32040U: 
  case 32039U: 
  case 32038U: 
  case 32037U: 
  case 32036U: 
  case 32035U: 
  case 32034U: 
  case 32033U: 
  case 32032U: 
  case 32031U: 
  case 32030U: 
  case 32029U: 
  case 32028U: 
  case 32027U: 
  case 32026U: 
  case 32025U: 
  case 32024U: 
  case 32023U: 
  case 32022U: 
  case 32021U: 
  case 32020U: 
  case 32019U: 
  case 32018U: 
  case 32017U: 
  case 32016U: 
  case 32015U: 
  case 32014U: 
  case 32013U: 
  case 32012U: 
  case 32011U: 
  case 32010U: 
  case 32009U: 
  case 32008U: 
  case 32007U: 
  case 32006U: 
  case 32005U: 
  case 32004U: 
  case 32003U: 
  case 32002U: 
  case 32001U: 
  case 32000U: ;
  case 48099U: 
  case 48098U: 
  case 48097U: 
  case 48096U: 
  case 48095U: 
  case 48094U: 
  case 48093U: 
  case 48092U: 
  case 48091U: 
  case 48090U: 
  case 48089U: 
  case 48088U: 
  case 48087U: 
  case 48086U: 
  case 48085U: 
  case 48084U: 
  case 48083U: 
  case 48082U: 
  case 48081U: 
  case 48080U: 
  case 48079U: 
  case 48078U: 
  case 48077U: 
  case 48076U: 
  case 48075U: 
  case 48074U: 
  case 48073U: 
  case 48072U: 
  case 48071U: 
  case 48070U: 
  case 48069U: 
  case 48068U: 
  case 48067U: 
  case 48066U: 
  case 48065U: 
  case 48064U: 
  case 48063U: 
  case 48062U: 
  case 48061U: 
  case 48060U: 
  case 48059U: 
  case 48058U: 
  case 48057U: 
  case 48056U: 
  case 48055U: 
  case 48054U: 
  case 48053U: 
  case 48052U: 
  case 48051U: 
  case 48050U: 
  case 48049U: 
  case 48048U: 
  case 48047U: 
  case 48046U: 
  case 48045U: 
  case 48044U: 
  case 48043U: 
  case 48042U: 
  case 48041U: 
  case 48040U: 
  case 48039U: 
  case 48038U: 
  case 48037U: 
  case 48036U: 
  case 48035U: 
  case 48034U: 
  case 48033U: 
  case 48032U: 
  case 48031U: 
  case 48030U: 
  case 48029U: 
  case 48028U: 
  case 48027U: 
  case 48026U: 
  case 48025U: 
  case 48024U: 
  case 48023U: 
  case 48022U: 
  case 48021U: 
  case 48020U: 
  case 48019U: 
  case 48018U: 
  case 48017U: 
  case 48016U: 
  case 48015U: 
  case 48014U: 
  case 48013U: 
  case 48012U: 
  case 48011U: 
  case 48010U: 
  case 48009U: 
  case 48008U: 
  case 48007U: 
  case 48006U: 
  case 48005U: 
  case 48004U: 
  case 48003U: 
  case 48002U: 
  case 48001U: 
  case 48000U: ;
  case 48599U: 
  case 48598U: 
  case 48597U: 
  case 48596U: 
  case 48595U: 
  case 48594U: 
  case 48593U: 
  case 48592U: 
  case 48591U: 
  case 48590U: 
  case 48589U: 
  case 48588U: 
  case 48587U: 
  case 48586U: 
  case 48585U: 
  case 48584U: 
  case 48583U: 
  case 48582U: 
  case 48581U: 
  case 48580U: 
  case 48579U: 
  case 48578U: 
  case 48577U: 
  case 48576U: 
  case 48575U: 
  case 48574U: 
  case 48573U: 
  case 48572U: 
  case 48571U: 
  case 48570U: 
  case 48569U: 
  case 48568U: 
  case 48567U: 
  case 48566U: 
  case 48565U: 
  case 48564U: 
  case 48563U: 
  case 48562U: 
  case 48561U: 
  case 48560U: 
  case 48559U: 
  case 48558U: 
  case 48557U: 
  case 48556U: 
  case 48555U: 
  case 48554U: 
  case 48553U: 
  case 48552U: 
  case 48551U: 
  case 48550U: 
  case 48549U: 
  case 48548U: 
  case 48547U: 
  case 48546U: 
  case 48545U: 
  case 48544U: 
  case 48543U: 
  case 48542U: 
  case 48541U: 
  case 48540U: 
  case 48539U: 
  case 48538U: 
  case 48537U: 
  case 48536U: 
  case 48535U: 
  case 48534U: 
  case 48533U: 
  case 48532U: 
  case 48531U: 
  case 48530U: 
  case 48529U: 
  case 48528U: 
  case 48527U: 
  case 48526U: 
  case 48525U: 
  case 48524U: 
  case 48523U: 
  case 48522U: 
  case 48521U: 
  case 48520U: 
  case 48519U: 
  case 48518U: 
  case 48517U: 
  case 48516U: 
  case 48515U: 
  case 48514U: 
  case 48513U: 
  case 48512U: 
  case 48511U: 
  case 48510U: 
  case 48509U: 
  case 48508U: 
  case 48507U: 
  case 48506U: 
  case 48505U: 
  case 48504U: 
  case 48503U: 
  case 48502U: 
  case 48501U: 
  case 48500U: 
  case 48499U: 
  case 48498U: 
  case 48497U: 
  case 48496U: 
  case 48495U: 
  case 48494U: 
  case 48493U: 
  case 48492U: 
  case 48491U: 
  case 48490U: 
  case 48489U: 
  case 48488U: 
  case 48487U: 
  case 48486U: 
  case 48485U: 
  case 48484U: 
  case 48483U: 
  case 48482U: 
  case 48481U: 
  case 48480U: 
  case 48479U: 
  case 48478U: 
  case 48477U: 
  case 48476U: 
  case 48475U: 
  case 48474U: 
  case 48473U: 
  case 48472U: 
  case 48471U: 
  case 48470U: 
  case 48469U: 
  case 48468U: 
  case 48467U: 
  case 48466U: 
  case 48465U: 
  case 48464U: 
  case 48463U: 
  case 48462U: 
  case 48461U: 
  case 48460U: 
  case 48459U: 
  case 48458U: 
  case 48457U: 
  case 48456U: 
  case 48455U: 
  case 48454U: 
  case 48453U: 
  case 48452U: 
  case 48451U: 
  case 48450U: 
  case 48449U: 
  case 48448U: 
  case 48447U: 
  case 48446U: 
  case 48445U: 
  case 48444U: 
  case 48443U: 
  case 48442U: 
  case 48441U: 
  case 48440U: 
  case 48439U: 
  case 48438U: 
  case 48437U: 
  case 48436U: 
  case 48435U: 
  case 48434U: 
  case 48433U: 
  case 48432U: 
  case 48431U: 
  case 48430U: 
  case 48429U: 
  case 48428U: 
  case 48427U: 
  case 48426U: 
  case 48425U: 
  case 48424U: 
  case 48423U: 
  case 48422U: 
  case 48421U: 
  case 48420U: 
  case 48419U: 
  case 48418U: 
  case 48417U: 
  case 48416U: 
  case 48415U: 
  case 48414U: 
  case 48413U: 
  case 48412U: 
  case 48411U: 
  case 48410U: 
  case 48409U: 
  case 48408U: 
  case 48407U: 
  case 48406U: 
  case 48405U: 
  case 48404U: 
  case 48403U: 
  case 48402U: 
  case 48401U: 
  case 48400U: 
#line 431
  itv->card = ivtv_get_card(0);
#line 432
  goto ldv_43211;
  case 48399U: 
  case 48398U: 
  case 48397U: 
  case 48396U: 
  case 48395U: 
  case 48394U: 
  case 48393U: 
  case 48392U: 
  case 48391U: 
  case 48390U: 
  case 48389U: 
  case 48388U: 
  case 48387U: 
  case 48386U: 
  case 48385U: 
  case 48384U: 
  case 48383U: 
  case 48382U: 
  case 48381U: 
  case 48380U: 
  case 48379U: 
  case 48378U: 
  case 48377U: 
  case 48376U: 
  case 48375U: 
  case 48374U: 
  case 48373U: 
  case 48372U: 
  case 48371U: 
  case 48370U: 
  case 48369U: 
  case 48368U: 
  case 48367U: 
  case 48366U: 
  case 48365U: 
  case 48364U: 
  case 48363U: 
  case 48362U: 
  case 48361U: 
  case 48360U: 
  case 48359U: 
  case 48358U: 
  case 48357U: 
  case 48356U: 
  case 48355U: 
  case 48354U: 
  case 48353U: 
  case 48352U: 
  case 48351U: 
  case 48350U: 
  case 48349U: 
  case 48348U: 
  case 48347U: 
  case 48346U: 
  case 48345U: 
  case 48344U: 
  case 48343U: 
  case 48342U: 
  case 48341U: 
  case 48340U: 
  case 48339U: 
  case 48338U: 
  case 48337U: 
  case 48336U: 
  case 48335U: 
  case 48334U: 
  case 48333U: 
  case 48332U: 
  case 48331U: 
  case 48330U: 
  case 48329U: 
  case 48328U: 
  case 48327U: 
  case 48326U: 
  case 48325U: 
  case 48324U: 
  case 48323U: 
  case 48322U: 
  case 48321U: 
  case 48320U: 
  case 48319U: 
  case 48318U: 
  case 48317U: 
  case 48316U: 
  case 48315U: 
  case 48314U: 
  case 48313U: 
  case 48312U: 
  case 48311U: 
  case 48310U: 
  case 48309U: 
  case 48308U: 
  case 48307U: 
  case 48306U: 
  case 48305U: 
  case 48304U: 
  case 48303U: 
  case 48302U: 
  case 48301U: 
  case 48300U: 
  case 48299U: 
  case 48298U: 
  case 48297U: 
  case 48296U: 
  case 48295U: 
  case 48294U: 
  case 48293U: 
  case 48292U: 
  case 48291U: 
  case 48290U: 
  case 48289U: 
  case 48288U: 
  case 48287U: 
  case 48286U: 
  case 48285U: 
  case 48284U: 
  case 48283U: 
  case 48282U: 
  case 48281U: 
  case 48280U: 
  case 48279U: 
  case 48278U: 
  case 48277U: 
  case 48276U: 
  case 48275U: 
  case 48274U: 
  case 48273U: 
  case 48272U: 
  case 48271U: 
  case 48270U: 
  case 48269U: 
  case 48268U: 
  case 48267U: 
  case 48266U: 
  case 48265U: 
  case 48264U: 
  case 48263U: 
  case 48262U: 
  case 48261U: 
  case 48260U: 
  case 48259U: 
  case 48258U: 
  case 48257U: 
  case 48256U: 
  case 48255U: 
  case 48254U: 
  case 48253U: 
  case 48252U: 
  case 48251U: 
  case 48250U: 
  case 48249U: 
  case 48248U: 
  case 48247U: 
  case 48246U: 
  case 48245U: 
  case 48244U: 
  case 48243U: 
  case 48242U: 
  case 48241U: 
  case 48240U: 
  case 48239U: 
  case 48238U: 
  case 48237U: 
  case 48236U: 
  case 48235U: 
  case 48234U: 
  case 48233U: 
  case 48232U: 
  case 48231U: 
  case 48230U: 
  case 48229U: 
  case 48228U: 
  case 48227U: 
  case 48226U: 
  case 48225U: 
  case 48224U: 
  case 48223U: 
  case 48222U: 
  case 48221U: 
  case 48220U: 
  case 48219U: 
  case 48218U: 
  case 48217U: 
  case 48216U: 
  case 48215U: 
  case 48214U: 
  case 48213U: 
  case 48212U: 
  case 48211U: 
  case 48210U: 
  case 48209U: 
  case 48208U: 
  case 48207U: 
  case 48206U: 
  case 48205U: 
  case 48204U: 
  case 48203U: 
  case 48202U: 
  case 48201U: 
  case 48200U: 
  case 48199U: 
  case 48198U: 
  case 48197U: 
  case 48196U: 
  case 48195U: 
  case 48194U: 
  case 48193U: 
  case 48192U: 
  case 48191U: 
  case 48190U: 
  case 48189U: 
  case 48188U: 
  case 48187U: 
  case 48186U: 
  case 48185U: 
  case 48184U: 
  case 48183U: 
  case 48182U: 
  case 48181U: 
  case 48180U: 
  case 48179U: 
  case 48178U: 
  case 48177U: 
  case 48176U: 
  case 48175U: 
  case 48174U: 
  case 48173U: 
  case 48172U: 
  case 48171U: 
  case 48170U: 
  case 48169U: 
  case 48168U: 
  case 48167U: 
  case 48166U: 
  case 48165U: 
  case 48164U: 
  case 48163U: 
  case 48162U: 
  case 48161U: 
  case 48160U: 
  case 48159U: 
  case 48158U: 
  case 48157U: 
  case 48156U: 
  case 48155U: 
  case 48154U: 
  case 48153U: 
  case 48152U: 
  case 48151U: 
  case 48150U: 
  case 48149U: 
  case 48148U: 
  case 48147U: 
  case 48146U: 
  case 48145U: 
  case 48144U: 
  case 48143U: 
  case 48142U: 
  case 48141U: 
  case 48140U: 
  case 48139U: 
  case 48138U: 
  case 48137U: 
  case 48136U: 
  case 48135U: 
  case 48134U: 
  case 48133U: 
  case 48132U: 
  case 48131U: 
  case 48130U: 
  case 48129U: 
  case 48128U: 
  case 48127U: 
  case 48126U: 
  case 48125U: 
  case 48124U: 
  case 48123U: 
  case 48122U: 
  case 48121U: 
  case 48120U: 
  case 48119U: 
  case 48118U: 
  case 48117U: 
  case 48116U: 
  case 48115U: 
  case 48114U: 
  case 48113U: 
  case 48112U: 
  case 48111U: 
  case 48110U: 
  case 48109U: 
  case 48108U: 
  case 48107U: 
  case 48106U: 
  case 48105U: 
  case 48104U: 
  case 48103U: 
  case 48102U: 
  case 48101U: 
  case 48100U: ;
  case 48999U: 
  case 48998U: 
  case 48997U: 
  case 48996U: 
  case 48995U: 
  case 48994U: 
  case 48993U: 
  case 48992U: 
  case 48991U: 
  case 48990U: 
  case 48989U: 
  case 48988U: 
  case 48987U: 
  case 48986U: 
  case 48985U: 
  case 48984U: 
  case 48983U: 
  case 48982U: 
  case 48981U: 
  case 48980U: 
  case 48979U: 
  case 48978U: 
  case 48977U: 
  case 48976U: 
  case 48975U: 
  case 48974U: 
  case 48973U: 
  case 48972U: 
  case 48971U: 
  case 48970U: 
  case 48969U: 
  case 48968U: 
  case 48967U: 
  case 48966U: 
  case 48965U: 
  case 48964U: 
  case 48963U: 
  case 48962U: 
  case 48961U: 
  case 48960U: 
  case 48959U: 
  case 48958U: 
  case 48957U: 
  case 48956U: 
  case 48955U: 
  case 48954U: 
  case 48953U: 
  case 48952U: 
  case 48951U: 
  case 48950U: 
  case 48949U: 
  case 48948U: 
  case 48947U: 
  case 48946U: 
  case 48945U: 
  case 48944U: 
  case 48943U: 
  case 48942U: 
  case 48941U: 
  case 48940U: 
  case 48939U: 
  case 48938U: 
  case 48937U: 
  case 48936U: 
  case 48935U: 
  case 48934U: 
  case 48933U: 
  case 48932U: 
  case 48931U: 
  case 48930U: 
  case 48929U: 
  case 48928U: 
  case 48927U: 
  case 48926U: 
  case 48925U: 
  case 48924U: 
  case 48923U: 
  case 48922U: 
  case 48921U: 
  case 48920U: 
  case 48919U: 
  case 48918U: 
  case 48917U: 
  case 48916U: 
  case 48915U: 
  case 48914U: 
  case 48913U: 
  case 48912U: 
  case 48911U: 
  case 48910U: 
  case 48909U: 
  case 48908U: 
  case 48907U: 
  case 48906U: 
  case 48905U: 
  case 48904U: 
  case 48903U: 
  case 48902U: 
  case 48901U: 
  case 48900U: 
  case 48899U: 
  case 48898U: 
  case 48897U: 
  case 48896U: 
  case 48895U: 
  case 48894U: 
  case 48893U: 
  case 48892U: 
  case 48891U: 
  case 48890U: 
  case 48889U: 
  case 48888U: 
  case 48887U: 
  case 48886U: 
  case 48885U: 
  case 48884U: 
  case 48883U: 
  case 48882U: 
  case 48881U: 
  case 48880U: 
  case 48879U: 
  case 48878U: 
  case 48877U: 
  case 48876U: 
  case 48875U: 
  case 48874U: 
  case 48873U: 
  case 48872U: 
  case 48871U: 
  case 48870U: 
  case 48869U: 
  case 48868U: 
  case 48867U: 
  case 48866U: 
  case 48865U: 
  case 48864U: 
  case 48863U: 
  case 48862U: 
  case 48861U: 
  case 48860U: 
  case 48859U: 
  case 48858U: 
  case 48857U: 
  case 48856U: 
  case 48855U: 
  case 48854U: 
  case 48853U: 
  case 48852U: 
  case 48851U: 
  case 48850U: 
  case 48849U: 
  case 48848U: 
  case 48847U: 
  case 48846U: 
  case 48845U: 
  case 48844U: 
  case 48843U: 
  case 48842U: 
  case 48841U: 
  case 48840U: 
  case 48839U: 
  case 48838U: 
  case 48837U: 
  case 48836U: 
  case 48835U: 
  case 48834U: 
  case 48833U: 
  case 48832U: 
  case 48831U: 
  case 48830U: 
  case 48829U: 
  case 48828U: 
  case 48827U: 
  case 48826U: 
  case 48825U: 
  case 48824U: 
  case 48823U: 
  case 48822U: 
  case 48821U: 
  case 48820U: 
  case 48819U: 
  case 48818U: 
  case 48817U: 
  case 48816U: 
  case 48815U: 
  case 48814U: 
  case 48813U: 
  case 48812U: 
  case 48811U: 
  case 48810U: 
  case 48809U: 
  case 48808U: 
  case 48807U: 
  case 48806U: 
  case 48805U: 
  case 48804U: 
  case 48803U: 
  case 48802U: 
  case 48801U: 
  case 48800U: 
  case 48799U: 
  case 48798U: 
  case 48797U: 
  case 48796U: 
  case 48795U: 
  case 48794U: 
  case 48793U: 
  case 48792U: 
  case 48791U: 
  case 48790U: 
  case 48789U: 
  case 48788U: 
  case 48787U: 
  case 48786U: 
  case 48785U: 
  case 48784U: 
  case 48783U: 
  case 48782U: 
  case 48781U: 
  case 48780U: 
  case 48779U: 
  case 48778U: 
  case 48777U: 
  case 48776U: 
  case 48775U: 
  case 48774U: 
  case 48773U: 
  case 48772U: 
  case 48771U: 
  case 48770U: 
  case 48769U: 
  case 48768U: 
  case 48767U: 
  case 48766U: 
  case 48765U: 
  case 48764U: 
  case 48763U: 
  case 48762U: 
  case 48761U: 
  case 48760U: 
  case 48759U: 
  case 48758U: 
  case 48757U: 
  case 48756U: 
  case 48755U: 
  case 48754U: 
  case 48753U: 
  case 48752U: 
  case 48751U: 
  case 48750U: 
  case 48749U: 
  case 48748U: 
  case 48747U: 
  case 48746U: 
  case 48745U: 
  case 48744U: 
  case 48743U: 
  case 48742U: 
  case 48741U: 
  case 48740U: 
  case 48739U: 
  case 48738U: 
  case 48737U: 
  case 48736U: 
  case 48735U: 
  case 48734U: 
  case 48733U: 
  case 48732U: 
  case 48731U: 
  case 48730U: 
  case 48729U: 
  case 48728U: 
  case 48727U: 
  case 48726U: 
  case 48725U: 
  case 48724U: 
  case 48723U: 
  case 48722U: 
  case 48721U: 
  case 48720U: 
  case 48719U: 
  case 48718U: 
  case 48717U: 
  case 48716U: 
  case 48715U: 
  case 48714U: 
  case 48713U: 
  case 48712U: 
  case 48711U: 
  case 48710U: 
  case 48709U: 
  case 48708U: 
  case 48707U: 
  case 48706U: 
  case 48705U: 
  case 48704U: 
  case 48703U: 
  case 48702U: 
  case 48701U: 
  case 48700U: 
  case 48699U: 
  case 48698U: 
  case 48697U: 
  case 48696U: 
  case 48695U: 
  case 48694U: 
  case 48693U: 
  case 48692U: 
  case 48691U: 
  case 48690U: 
  case 48689U: 
  case 48688U: 
  case 48687U: 
  case 48686U: 
  case 48685U: 
  case 48684U: 
  case 48683U: 
  case 48682U: 
  case 48681U: 
  case 48680U: 
  case 48679U: 
  case 48678U: 
  case 48677U: 
  case 48676U: 
  case 48675U: 
  case 48674U: 
  case 48673U: 
  case 48672U: 
  case 48671U: 
  case 48670U: 
  case 48669U: 
  case 48668U: 
  case 48667U: 
  case 48666U: 
  case 48665U: 
  case 48664U: 
  case 48663U: 
  case 48662U: 
  case 48661U: 
  case 48660U: 
  case 48659U: 
  case 48658U: 
  case 48657U: 
  case 48656U: 
  case 48655U: 
  case 48654U: 
  case 48653U: 
  case 48652U: 
  case 48651U: 
  case 48650U: 
  case 48649U: 
  case 48648U: 
  case 48647U: 
  case 48646U: 
  case 48645U: 
  case 48644U: 
  case 48643U: 
  case 48642U: 
  case 48641U: 
  case 48640U: 
  case 48639U: 
  case 48638U: 
  case 48637U: 
  case 48636U: 
  case 48635U: 
  case 48634U: 
  case 48633U: 
  case 48632U: 
  case 48631U: 
  case 48630U: 
  case 48629U: 
  case 48628U: 
  case 48627U: 
  case 48626U: 
  case 48625U: 
  case 48624U: 
  case 48623U: 
  case 48622U: 
  case 48621U: 
  case 48620U: 
  case 48619U: 
  case 48618U: 
  case 48617U: 
  case 48616U: 
  case 48615U: 
  case 48614U: 
  case 48613U: 
  case 48612U: 
  case 48611U: 
  case 48610U: 
  case 48609U: 
  case 48608U: 
  case 48607U: 
  case 48606U: 
  case 48605U: 
  case 48604U: 
  case 48603U: 
  case 48602U: 
  case 48601U: 
  case 48600U: 
#line 435
  itv->card = ivtv_get_card(1);
#line 436
  goto ldv_43211;
  case 23999U: 
  case 23998U: 
  case 23997U: 
  case 23996U: 
  case 23995U: 
  case 23994U: 
  case 23993U: 
  case 23992U: 
  case 23991U: 
  case 23990U: 
  case 23989U: 
  case 23988U: 
  case 23987U: 
  case 23986U: 
  case 23985U: 
  case 23984U: 
  case 23983U: 
  case 23982U: 
  case 23981U: 
  case 23980U: 
  case 23979U: 
  case 23978U: 
  case 23977U: 
  case 23976U: 
  case 23975U: 
  case 23974U: 
  case 23973U: 
  case 23972U: 
  case 23971U: 
  case 23970U: 
  case 23969U: 
  case 23968U: 
  case 23967U: 
  case 23966U: 
  case 23965U: 
  case 23964U: 
  case 23963U: 
  case 23962U: 
  case 23961U: 
  case 23960U: 
  case 23959U: 
  case 23958U: 
  case 23957U: 
  case 23956U: 
  case 23955U: 
  case 23954U: 
  case 23953U: 
  case 23952U: 
  case 23951U: 
  case 23950U: 
  case 23949U: 
  case 23948U: 
  case 23947U: 
  case 23946U: 
  case 23945U: 
  case 23944U: 
  case 23943U: 
  case 23942U: 
  case 23941U: 
  case 23940U: 
  case 23939U: 
  case 23938U: 
  case 23937U: 
  case 23936U: 
  case 23935U: 
  case 23934U: 
  case 23933U: 
  case 23932U: 
  case 23931U: 
  case 23930U: 
  case 23929U: 
  case 23928U: 
  case 23927U: 
  case 23926U: 
  case 23925U: 
  case 23924U: 
  case 23923U: 
  case 23922U: 
  case 23921U: 
  case 23920U: 
  case 23919U: 
  case 23918U: 
  case 23917U: 
  case 23916U: 
  case 23915U: 
  case 23914U: 
  case 23913U: 
  case 23912U: 
  case 23911U: 
  case 23910U: 
  case 23909U: 
  case 23908U: 
  case 23907U: 
  case 23906U: 
  case 23905U: 
  case 23904U: 
  case 23903U: 
  case 23902U: 
  case 23901U: 
  case 23900U: 
  case 23899U: 
  case 23898U: 
  case 23897U: 
  case 23896U: 
  case 23895U: 
  case 23894U: 
  case 23893U: 
  case 23892U: 
  case 23891U: 
  case 23890U: 
  case 23889U: 
  case 23888U: 
  case 23887U: 
  case 23886U: 
  case 23885U: 
  case 23884U: 
  case 23883U: 
  case 23882U: 
  case 23881U: 
  case 23880U: 
  case 23879U: 
  case 23878U: 
  case 23877U: 
  case 23876U: 
  case 23875U: 
  case 23874U: 
  case 23873U: 
  case 23872U: 
  case 23871U: 
  case 23870U: 
  case 23869U: 
  case 23868U: 
  case 23867U: 
  case 23866U: 
  case 23865U: 
  case 23864U: 
  case 23863U: 
  case 23862U: 
  case 23861U: 
  case 23860U: 
  case 23859U: 
  case 23858U: 
  case 23857U: 
  case 23856U: 
  case 23855U: 
  case 23854U: 
  case 23853U: 
  case 23852U: 
  case 23851U: 
  case 23850U: 
  case 23849U: 
  case 23848U: 
  case 23847U: 
  case 23846U: 
  case 23845U: 
  case 23844U: 
  case 23843U: 
  case 23842U: 
  case 23841U: 
  case 23840U: 
  case 23839U: 
  case 23838U: 
  case 23837U: 
  case 23836U: 
  case 23835U: 
  case 23834U: 
  case 23833U: 
  case 23832U: 
  case 23831U: 
  case 23830U: 
  case 23829U: 
  case 23828U: 
  case 23827U: 
  case 23826U: 
  case 23825U: 
  case 23824U: 
  case 23823U: 
  case 23822U: 
  case 23821U: 
  case 23820U: 
  case 23819U: 
  case 23818U: 
  case 23817U: 
  case 23816U: 
  case 23815U: 
  case 23814U: 
  case 23813U: 
  case 23812U: 
  case 23811U: 
  case 23810U: 
  case 23809U: 
  case 23808U: 
  case 23807U: 
  case 23806U: 
  case 23805U: 
  case 23804U: 
  case 23803U: 
  case 23802U: 
  case 23801U: 
  case 23800U: 
  case 23799U: 
  case 23798U: 
  case 23797U: 
  case 23796U: 
  case 23795U: 
  case 23794U: 
  case 23793U: 
  case 23792U: 
  case 23791U: 
  case 23790U: 
  case 23789U: 
  case 23788U: 
  case 23787U: 
  case 23786U: 
  case 23785U: 
  case 23784U: 
  case 23783U: 
  case 23782U: 
  case 23781U: 
  case 23780U: 
  case 23779U: 
  case 23778U: 
  case 23777U: 
  case 23776U: 
  case 23775U: 
  case 23774U: 
  case 23773U: 
  case 23772U: 
  case 23771U: 
  case 23770U: 
  case 23769U: 
  case 23768U: 
  case 23767U: 
  case 23766U: 
  case 23765U: 
  case 23764U: 
  case 23763U: 
  case 23762U: 
  case 23761U: 
  case 23760U: 
  case 23759U: 
  case 23758U: 
  case 23757U: 
  case 23756U: 
  case 23755U: 
  case 23754U: 
  case 23753U: 
  case 23752U: 
  case 23751U: 
  case 23750U: 
  case 23749U: 
  case 23748U: 
  case 23747U: 
  case 23746U: 
  case 23745U: 
  case 23744U: 
  case 23743U: 
  case 23742U: 
  case 23741U: 
  case 23740U: 
  case 23739U: 
  case 23738U: 
  case 23737U: 
  case 23736U: 
  case 23735U: 
  case 23734U: 
  case 23733U: 
  case 23732U: 
  case 23731U: 
  case 23730U: 
  case 23729U: 
  case 23728U: 
  case 23727U: 
  case 23726U: 
  case 23725U: 
  case 23724U: 
  case 23723U: 
  case 23722U: 
  case 23721U: 
  case 23720U: 
  case 23719U: 
  case 23718U: 
  case 23717U: 
  case 23716U: 
  case 23715U: 
  case 23714U: 
  case 23713U: 
  case 23712U: 
  case 23711U: 
  case 23710U: 
  case 23709U: 
  case 23708U: 
  case 23707U: 
  case 23706U: 
  case 23705U: 
  case 23704U: 
  case 23703U: 
  case 23702U: 
  case 23701U: 
  case 23700U: 
  case 23699U: 
  case 23698U: 
  case 23697U: 
  case 23696U: 
  case 23695U: 
  case 23694U: 
  case 23693U: 
  case 23692U: 
  case 23691U: 
  case 23690U: 
  case 23689U: 
  case 23688U: 
  case 23687U: 
  case 23686U: 
  case 23685U: 
  case 23684U: 
  case 23683U: 
  case 23682U: 
  case 23681U: 
  case 23680U: 
  case 23679U: 
  case 23678U: 
  case 23677U: 
  case 23676U: 
  case 23675U: 
  case 23674U: 
  case 23673U: 
  case 23672U: 
  case 23671U: 
  case 23670U: 
  case 23669U: 
  case 23668U: 
  case 23667U: 
  case 23666U: 
  case 23665U: 
  case 23664U: 
  case 23663U: 
  case 23662U: 
  case 23661U: 
  case 23660U: 
  case 23659U: 
  case 23658U: 
  case 23657U: 
  case 23656U: 
  case 23655U: 
  case 23654U: 
  case 23653U: 
  case 23652U: 
  case 23651U: 
  case 23650U: 
  case 23649U: 
  case 23648U: 
  case 23647U: 
  case 23646U: 
  case 23645U: 
  case 23644U: 
  case 23643U: 
  case 23642U: 
  case 23641U: 
  case 23640U: 
  case 23639U: 
  case 23638U: 
  case 23637U: 
  case 23636U: 
  case 23635U: 
  case 23634U: 
  case 23633U: 
  case 23632U: 
  case 23631U: 
  case 23630U: 
  case 23629U: 
  case 23628U: 
  case 23627U: 
  case 23626U: 
  case 23625U: 
  case 23624U: 
  case 23623U: 
  case 23622U: 
  case 23621U: 
  case 23620U: 
  case 23619U: 
  case 23618U: 
  case 23617U: 
  case 23616U: 
  case 23615U: 
  case 23614U: 
  case 23613U: 
  case 23612U: 
  case 23611U: 
  case 23610U: 
  case 23609U: 
  case 23608U: 
  case 23607U: 
  case 23606U: 
  case 23605U: 
  case 23604U: 
  case 23603U: 
  case 23602U: 
  case 23601U: 
  case 23600U: 
  case 23599U: 
  case 23598U: 
  case 23597U: 
  case 23596U: 
  case 23595U: 
  case 23594U: 
  case 23593U: 
  case 23592U: 
  case 23591U: 
  case 23590U: 
  case 23589U: 
  case 23588U: 
  case 23587U: 
  case 23586U: 
  case 23585U: 
  case 23584U: 
  case 23583U: 
  case 23582U: 
  case 23581U: 
  case 23580U: 
  case 23579U: 
  case 23578U: 
  case 23577U: 
  case 23576U: 
  case 23575U: 
  case 23574U: 
  case 23573U: 
  case 23572U: 
  case 23571U: 
  case 23570U: 
  case 23569U: 
  case 23568U: 
  case 23567U: 
  case 23566U: 
  case 23565U: 
  case 23564U: 
  case 23563U: 
  case 23562U: 
  case 23561U: 
  case 23560U: 
  case 23559U: 
  case 23558U: 
  case 23557U: 
  case 23556U: 
  case 23555U: 
  case 23554U: 
  case 23553U: 
  case 23552U: 
  case 23551U: 
  case 23550U: 
  case 23549U: 
  case 23548U: 
  case 23547U: 
  case 23546U: 
  case 23545U: 
  case 23544U: 
  case 23543U: 
  case 23542U: 
  case 23541U: 
  case 23540U: 
  case 23539U: 
  case 23538U: 
  case 23537U: 
  case 23536U: 
  case 23535U: 
  case 23534U: 
  case 23533U: 
  case 23532U: 
  case 23531U: 
  case 23530U: 
  case 23529U: 
  case 23528U: 
  case 23527U: 
  case 23526U: 
  case 23525U: 
  case 23524U: 
  case 23523U: 
  case 23522U: 
  case 23521U: 
  case 23520U: 
  case 23519U: 
  case 23518U: 
  case 23517U: 
  case 23516U: 
  case 23515U: 
  case 23514U: 
  case 23513U: 
  case 23512U: 
  case 23511U: 
  case 23510U: 
  case 23509U: 
  case 23508U: 
  case 23507U: 
  case 23506U: 
  case 23505U: 
  case 23504U: 
  case 23503U: 
  case 23502U: 
  case 23501U: 
  case 23500U: 
  case 23499U: 
  case 23498U: 
  case 23497U: 
  case 23496U: 
  case 23495U: 
  case 23494U: 
  case 23493U: 
  case 23492U: 
  case 23491U: 
  case 23490U: 
  case 23489U: 
  case 23488U: 
  case 23487U: 
  case 23486U: 
  case 23485U: 
  case 23484U: 
  case 23483U: 
  case 23482U: 
  case 23481U: 
  case 23480U: 
  case 23479U: 
  case 23478U: 
  case 23477U: 
  case 23476U: 
  case 23475U: 
  case 23474U: 
  case 23473U: 
  case 23472U: 
  case 23471U: 
  case 23470U: 
  case 23469U: 
  case 23468U: 
  case 23467U: 
  case 23466U: 
  case 23465U: 
  case 23464U: 
  case 23463U: 
  case 23462U: 
  case 23461U: 
  case 23460U: 
  case 23459U: 
  case 23458U: 
  case 23457U: 
  case 23456U: 
  case 23455U: 
  case 23454U: 
  case 23453U: 
  case 23452U: 
  case 23451U: 
  case 23450U: 
  case 23449U: 
  case 23448U: 
  case 23447U: 
  case 23446U: 
  case 23445U: 
  case 23444U: 
  case 23443U: 
  case 23442U: 
  case 23441U: 
  case 23440U: 
  case 23439U: 
  case 23438U: 
  case 23437U: 
  case 23436U: 
  case 23435U: 
  case 23434U: 
  case 23433U: 
  case 23432U: 
  case 23431U: 
  case 23430U: 
  case 23429U: 
  case 23428U: 
  case 23427U: 
  case 23426U: 
  case 23425U: 
  case 23424U: 
  case 23423U: 
  case 23422U: 
  case 23421U: 
  case 23420U: 
  case 23419U: 
  case 23418U: 
  case 23417U: 
  case 23416U: 
  case 23415U: 
  case 23414U: 
  case 23413U: 
  case 23412U: 
  case 23411U: 
  case 23410U: 
  case 23409U: 
  case 23408U: 
  case 23407U: 
  case 23406U: 
  case 23405U: 
  case 23404U: 
  case 23403U: 
  case 23402U: 
  case 23401U: 
  case 23400U: 
  case 23399U: 
  case 23398U: 
  case 23397U: 
  case 23396U: 
  case 23395U: 
  case 23394U: 
  case 23393U: 
  case 23392U: 
  case 23391U: 
  case 23390U: 
  case 23389U: 
  case 23388U: 
  case 23387U: 
  case 23386U: 
  case 23385U: 
  case 23384U: 
  case 23383U: 
  case 23382U: 
  case 23381U: 
  case 23380U: 
  case 23379U: 
  case 23378U: 
  case 23377U: 
  case 23376U: 
  case 23375U: 
  case 23374U: 
  case 23373U: 
  case 23372U: 
  case 23371U: 
  case 23370U: 
  case 23369U: 
  case 23368U: 
  case 23367U: 
  case 23366U: 
  case 23365U: 
  case 23364U: 
  case 23363U: 
  case 23362U: 
  case 23361U: 
  case 23360U: 
  case 23359U: 
  case 23358U: 
  case 23357U: 
  case 23356U: 
  case 23355U: 
  case 23354U: 
  case 23353U: 
  case 23352U: 
  case 23351U: 
  case 23350U: 
  case 23349U: 
  case 23348U: 
  case 23347U: 
  case 23346U: 
  case 23345U: 
  case 23344U: 
  case 23343U: 
  case 23342U: 
  case 23341U: 
  case 23340U: 
  case 23339U: 
  case 23338U: 
  case 23337U: 
  case 23336U: 
  case 23335U: 
  case 23334U: 
  case 23333U: 
  case 23332U: 
  case 23331U: 
  case 23330U: 
  case 23329U: 
  case 23328U: 
  case 23327U: 
  case 23326U: 
  case 23325U: 
  case 23324U: 
  case 23323U: 
  case 23322U: 
  case 23321U: 
  case 23320U: 
  case 23319U: 
  case 23318U: 
  case 23317U: 
  case 23316U: 
  case 23315U: 
  case 23314U: 
  case 23313U: 
  case 23312U: 
  case 23311U: 
  case 23310U: 
  case 23309U: 
  case 23308U: 
  case 23307U: 
  case 23306U: 
  case 23305U: 
  case 23304U: 
  case 23303U: 
  case 23302U: 
  case 23301U: 
  case 23300U: 
  case 23299U: 
  case 23298U: 
  case 23297U: 
  case 23296U: 
  case 23295U: 
  case 23294U: 
  case 23293U: 
  case 23292U: 
  case 23291U: 
  case 23290U: 
  case 23289U: 
  case 23288U: 
  case 23287U: 
  case 23286U: 
  case 23285U: 
  case 23284U: 
  case 23283U: 
  case 23282U: 
  case 23281U: 
  case 23280U: 
  case 23279U: 
  case 23278U: 
  case 23277U: 
  case 23276U: 
  case 23275U: 
  case 23274U: 
  case 23273U: 
  case 23272U: 
  case 23271U: 
  case 23270U: 
  case 23269U: 
  case 23268U: 
  case 23267U: 
  case 23266U: 
  case 23265U: 
  case 23264U: 
  case 23263U: 
  case 23262U: 
  case 23261U: 
  case 23260U: 
  case 23259U: 
  case 23258U: 
  case 23257U: 
  case 23256U: 
  case 23255U: 
  case 23254U: 
  case 23253U: 
  case 23252U: 
  case 23251U: 
  case 23250U: 
  case 23249U: 
  case 23248U: 
  case 23247U: 
  case 23246U: 
  case 23245U: 
  case 23244U: 
  case 23243U: 
  case 23242U: 
  case 23241U: 
  case 23240U: 
  case 23239U: 
  case 23238U: 
  case 23237U: 
  case 23236U: 
  case 23235U: 
  case 23234U: 
  case 23233U: 
  case 23232U: 
  case 23231U: 
  case 23230U: 
  case 23229U: 
  case 23228U: 
  case 23227U: 
  case 23226U: 
  case 23225U: 
  case 23224U: 
  case 23223U: 
  case 23222U: 
  case 23221U: 
  case 23220U: 
  case 23219U: 
  case 23218U: 
  case 23217U: 
  case 23216U: 
  case 23215U: 
  case 23214U: 
  case 23213U: 
  case 23212U: 
  case 23211U: 
  case 23210U: 
  case 23209U: 
  case 23208U: 
  case 23207U: 
  case 23206U: 
  case 23205U: 
  case 23204U: 
  case 23203U: 
  case 23202U: 
  case 23201U: 
  case 23200U: 
  case 23199U: 
  case 23198U: 
  case 23197U: 
  case 23196U: 
  case 23195U: 
  case 23194U: 
  case 23193U: 
  case 23192U: 
  case 23191U: 
  case 23190U: 
  case 23189U: 
  case 23188U: 
  case 23187U: 
  case 23186U: 
  case 23185U: 
  case 23184U: 
  case 23183U: 
  case 23182U: 
  case 23181U: 
  case 23180U: 
  case 23179U: 
  case 23178U: 
  case 23177U: 
  case 23176U: 
  case 23175U: 
  case 23174U: 
  case 23173U: 
  case 23172U: 
  case 23171U: 
  case 23170U: 
  case 23169U: 
  case 23168U: 
  case 23167U: 
  case 23166U: 
  case 23165U: 
  case 23164U: 
  case 23163U: 
  case 23162U: 
  case 23161U: 
  case 23160U: 
  case 23159U: 
  case 23158U: 
  case 23157U: 
  case 23156U: 
  case 23155U: 
  case 23154U: 
  case 23153U: 
  case 23152U: 
  case 23151U: 
  case 23150U: 
  case 23149U: 
  case 23148U: 
  case 23147U: 
  case 23146U: 
  case 23145U: 
  case 23144U: 
  case 23143U: 
  case 23142U: 
  case 23141U: 
  case 23140U: 
  case 23139U: 
  case 23138U: 
  case 23137U: 
  case 23136U: 
  case 23135U: 
  case 23134U: 
  case 23133U: 
  case 23132U: 
  case 23131U: 
  case 23130U: 
  case 23129U: 
  case 23128U: 
  case 23127U: 
  case 23126U: 
  case 23125U: 
  case 23124U: 
  case 23123U: 
  case 23122U: 
  case 23121U: 
  case 23120U: 
  case 23119U: 
  case 23118U: 
  case 23117U: 
  case 23116U: 
  case 23115U: 
  case 23114U: 
  case 23113U: 
  case 23112U: 
  case 23111U: 
  case 23110U: 
  case 23109U: 
  case 23108U: 
  case 23107U: 
  case 23106U: 
  case 23105U: 
  case 23104U: 
  case 23103U: 
  case 23102U: 
  case 23101U: 
  case 23100U: 
  case 23099U: 
  case 23098U: 
  case 23097U: 
  case 23096U: 
  case 23095U: 
  case 23094U: 
  case 23093U: 
  case 23092U: 
  case 23091U: 
  case 23090U: 
  case 23089U: 
  case 23088U: 
  case 23087U: 
  case 23086U: 
  case 23085U: 
  case 23084U: 
  case 23083U: 
  case 23082U: 
  case 23081U: 
  case 23080U: 
  case 23079U: 
  case 23078U: 
  case 23077U: 
  case 23076U: 
  case 23075U: 
  case 23074U: 
  case 23073U: 
  case 23072U: 
  case 23071U: 
  case 23070U: 
  case 23069U: 
  case 23068U: 
  case 23067U: 
  case 23066U: 
  case 23065U: 
  case 23064U: 
  case 23063U: 
  case 23062U: 
  case 23061U: 
  case 23060U: 
  case 23059U: 
  case 23058U: 
  case 23057U: 
  case 23056U: 
  case 23055U: 
  case 23054U: 
  case 23053U: 
  case 23052U: 
  case 23051U: 
  case 23050U: 
  case 23049U: 
  case 23048U: 
  case 23047U: 
  case 23046U: 
  case 23045U: 
  case 23044U: 
  case 23043U: 
  case 23042U: 
  case 23041U: 
  case 23040U: 
  case 23039U: 
  case 23038U: 
  case 23037U: 
  case 23036U: 
  case 23035U: 
  case 23034U: 
  case 23033U: 
  case 23032U: 
  case 23031U: 
  case 23030U: 
  case 23029U: 
  case 23028U: 
  case 23027U: 
  case 23026U: 
  case 23025U: 
  case 23024U: 
  case 23023U: 
  case 23022U: 
  case 23021U: 
  case 23020U: 
  case 23019U: 
  case 23018U: 
  case 23017U: 
  case 23016U: 
  case 23015U: 
  case 23014U: 
  case 23013U: 
  case 23012U: 
  case 23011U: 
  case 23010U: 
  case 23009U: 
  case 23008U: 
  case 23007U: 
  case 23006U: 
  case 23005U: 
  case 23004U: 
  case 23003U: 
  case 23002U: 
  case 23001U: 
  case 23000U: ;
  case 25999U: 
  case 25998U: 
  case 25997U: 
  case 25996U: 
  case 25995U: 
  case 25994U: 
  case 25993U: 
  case 25992U: 
  case 25991U: 
  case 25990U: 
  case 25989U: 
  case 25988U: 
  case 25987U: 
  case 25986U: 
  case 25985U: 
  case 25984U: 
  case 25983U: 
  case 25982U: 
  case 25981U: 
  case 25980U: 
  case 25979U: 
  case 25978U: 
  case 25977U: 
  case 25976U: 
  case 25975U: 
  case 25974U: 
  case 25973U: 
  case 25972U: 
  case 25971U: 
  case 25970U: 
  case 25969U: 
  case 25968U: 
  case 25967U: 
  case 25966U: 
  case 25965U: 
  case 25964U: 
  case 25963U: 
  case 25962U: 
  case 25961U: 
  case 25960U: 
  case 25959U: 
  case 25958U: 
  case 25957U: 
  case 25956U: 
  case 25955U: 
  case 25954U: 
  case 25953U: 
  case 25952U: 
  case 25951U: 
  case 25950U: 
  case 25949U: 
  case 25948U: 
  case 25947U: 
  case 25946U: 
  case 25945U: 
  case 25944U: 
  case 25943U: 
  case 25942U: 
  case 25941U: 
  case 25940U: 
  case 25939U: 
  case 25938U: 
  case 25937U: 
  case 25936U: 
  case 25935U: 
  case 25934U: 
  case 25933U: 
  case 25932U: 
  case 25931U: 
  case 25930U: 
  case 25929U: 
  case 25928U: 
  case 25927U: 
  case 25926U: 
  case 25925U: 
  case 25924U: 
  case 25923U: 
  case 25922U: 
  case 25921U: 
  case 25920U: 
  case 25919U: 
  case 25918U: 
  case 25917U: 
  case 25916U: 
  case 25915U: 
  case 25914U: 
  case 25913U: 
  case 25912U: 
  case 25911U: 
  case 25910U: 
  case 25909U: 
  case 25908U: 
  case 25907U: 
  case 25906U: 
  case 25905U: 
  case 25904U: 
  case 25903U: 
  case 25902U: 
  case 25901U: 
  case 25900U: 
  case 25899U: 
  case 25898U: 
  case 25897U: 
  case 25896U: 
  case 25895U: 
  case 25894U: 
  case 25893U: 
  case 25892U: 
  case 25891U: 
  case 25890U: 
  case 25889U: 
  case 25888U: 
  case 25887U: 
  case 25886U: 
  case 25885U: 
  case 25884U: 
  case 25883U: 
  case 25882U: 
  case 25881U: 
  case 25880U: 
  case 25879U: 
  case 25878U: 
  case 25877U: 
  case 25876U: 
  case 25875U: 
  case 25874U: 
  case 25873U: 
  case 25872U: 
  case 25871U: 
  case 25870U: 
  case 25869U: 
  case 25868U: 
  case 25867U: 
  case 25866U: 
  case 25865U: 
  case 25864U: 
  case 25863U: 
  case 25862U: 
  case 25861U: 
  case 25860U: 
  case 25859U: 
  case 25858U: 
  case 25857U: 
  case 25856U: 
  case 25855U: 
  case 25854U: 
  case 25853U: 
  case 25852U: 
  case 25851U: 
  case 25850U: 
  case 25849U: 
  case 25848U: 
  case 25847U: 
  case 25846U: 
  case 25845U: 
  case 25844U: 
  case 25843U: 
  case 25842U: 
  case 25841U: 
  case 25840U: 
  case 25839U: 
  case 25838U: 
  case 25837U: 
  case 25836U: 
  case 25835U: 
  case 25834U: 
  case 25833U: 
  case 25832U: 
  case 25831U: 
  case 25830U: 
  case 25829U: 
  case 25828U: 
  case 25827U: 
  case 25826U: 
  case 25825U: 
  case 25824U: 
  case 25823U: 
  case 25822U: 
  case 25821U: 
  case 25820U: 
  case 25819U: 
  case 25818U: 
  case 25817U: 
  case 25816U: 
  case 25815U: 
  case 25814U: 
  case 25813U: 
  case 25812U: 
  case 25811U: 
  case 25810U: 
  case 25809U: 
  case 25808U: 
  case 25807U: 
  case 25806U: 
  case 25805U: 
  case 25804U: 
  case 25803U: 
  case 25802U: 
  case 25801U: 
  case 25800U: 
  case 25799U: 
  case 25798U: 
  case 25797U: 
  case 25796U: 
  case 25795U: 
  case 25794U: 
  case 25793U: 
  case 25792U: 
  case 25791U: 
  case 25790U: 
  case 25789U: 
  case 25788U: 
  case 25787U: 
  case 25786U: 
  case 25785U: 
  case 25784U: 
  case 25783U: 
  case 25782U: 
  case 25781U: 
  case 25780U: 
  case 25779U: 
  case 25778U: 
  case 25777U: 
  case 25776U: 
  case 25775U: 
  case 25774U: 
  case 25773U: 
  case 25772U: 
  case 25771U: 
  case 25770U: 
  case 25769U: 
  case 25768U: 
  case 25767U: 
  case 25766U: 
  case 25765U: 
  case 25764U: 
  case 25763U: 
  case 25762U: 
  case 25761U: 
  case 25760U: 
  case 25759U: 
  case 25758U: 
  case 25757U: 
  case 25756U: 
  case 25755U: 
  case 25754U: 
  case 25753U: 
  case 25752U: 
  case 25751U: 
  case 25750U: 
  case 25749U: 
  case 25748U: 
  case 25747U: 
  case 25746U: 
  case 25745U: 
  case 25744U: 
  case 25743U: 
  case 25742U: 
  case 25741U: 
  case 25740U: 
  case 25739U: 
  case 25738U: 
  case 25737U: 
  case 25736U: 
  case 25735U: 
  case 25734U: 
  case 25733U: 
  case 25732U: 
  case 25731U: 
  case 25730U: 
  case 25729U: 
  case 25728U: 
  case 25727U: 
  case 25726U: 
  case 25725U: 
  case 25724U: 
  case 25723U: 
  case 25722U: 
  case 25721U: 
  case 25720U: 
  case 25719U: 
  case 25718U: 
  case 25717U: 
  case 25716U: 
  case 25715U: 
  case 25714U: 
  case 25713U: 
  case 25712U: 
  case 25711U: 
  case 25710U: 
  case 25709U: 
  case 25708U: 
  case 25707U: 
  case 25706U: 
  case 25705U: 
  case 25704U: 
  case 25703U: 
  case 25702U: 
  case 25701U: 
  case 25700U: 
  case 25699U: 
  case 25698U: 
  case 25697U: 
  case 25696U: 
  case 25695U: 
  case 25694U: 
  case 25693U: 
  case 25692U: 
  case 25691U: 
  case 25690U: 
  case 25689U: 
  case 25688U: 
  case 25687U: 
  case 25686U: 
  case 25685U: 
  case 25684U: 
  case 25683U: 
  case 25682U: 
  case 25681U: 
  case 25680U: 
  case 25679U: 
  case 25678U: 
  case 25677U: 
  case 25676U: 
  case 25675U: 
  case 25674U: 
  case 25673U: 
  case 25672U: 
  case 25671U: 
  case 25670U: 
  case 25669U: 
  case 25668U: 
  case 25667U: 
  case 25666U: 
  case 25665U: 
  case 25664U: 
  case 25663U: 
  case 25662U: 
  case 25661U: 
  case 25660U: 
  case 25659U: 
  case 25658U: 
  case 25657U: 
  case 25656U: 
  case 25655U: 
  case 25654U: 
  case 25653U: 
  case 25652U: 
  case 25651U: 
  case 25650U: 
  case 25649U: 
  case 25648U: 
  case 25647U: 
  case 25646U: 
  case 25645U: 
  case 25644U: 
  case 25643U: 
  case 25642U: 
  case 25641U: 
  case 25640U: 
  case 25639U: 
  case 25638U: 
  case 25637U: 
  case 25636U: 
  case 25635U: 
  case 25634U: 
  case 25633U: 
  case 25632U: 
  case 25631U: 
  case 25630U: 
  case 25629U: 
  case 25628U: 
  case 25627U: 
  case 25626U: 
  case 25625U: 
  case 25624U: 
  case 25623U: 
  case 25622U: 
  case 25621U: 
  case 25620U: 
  case 25619U: 
  case 25618U: 
  case 25617U: 
  case 25616U: 
  case 25615U: 
  case 25614U: 
  case 25613U: 
  case 25612U: 
  case 25611U: 
  case 25610U: 
  case 25609U: 
  case 25608U: 
  case 25607U: 
  case 25606U: 
  case 25605U: 
  case 25604U: 
  case 25603U: 
  case 25602U: 
  case 25601U: 
  case 25600U: 
  case 25599U: 
  case 25598U: 
  case 25597U: 
  case 25596U: 
  case 25595U: 
  case 25594U: 
  case 25593U: 
  case 25592U: 
  case 25591U: 
  case 25590U: 
  case 25589U: 
  case 25588U: 
  case 25587U: 
  case 25586U: 
  case 25585U: 
  case 25584U: 
  case 25583U: 
  case 25582U: 
  case 25581U: 
  case 25580U: 
  case 25579U: 
  case 25578U: 
  case 25577U: 
  case 25576U: 
  case 25575U: 
  case 25574U: 
  case 25573U: 
  case 25572U: 
  case 25571U: 
  case 25570U: 
  case 25569U: 
  case 25568U: 
  case 25567U: 
  case 25566U: 
  case 25565U: 
  case 25564U: 
  case 25563U: 
  case 25562U: 
  case 25561U: 
  case 25560U: 
  case 25559U: 
  case 25558U: 
  case 25557U: 
  case 25556U: 
  case 25555U: 
  case 25554U: 
  case 25553U: 
  case 25552U: 
  case 25551U: 
  case 25550U: 
  case 25549U: 
  case 25548U: 
  case 25547U: 
  case 25546U: 
  case 25545U: 
  case 25544U: 
  case 25543U: 
  case 25542U: 
  case 25541U: 
  case 25540U: 
  case 25539U: 
  case 25538U: 
  case 25537U: 
  case 25536U: 
  case 25535U: 
  case 25534U: 
  case 25533U: 
  case 25532U: 
  case 25531U: 
  case 25530U: 
  case 25529U: 
  case 25528U: 
  case 25527U: 
  case 25526U: 
  case 25525U: 
  case 25524U: 
  case 25523U: 
  case 25522U: 
  case 25521U: 
  case 25520U: 
  case 25519U: 
  case 25518U: 
  case 25517U: 
  case 25516U: 
  case 25515U: 
  case 25514U: 
  case 25513U: 
  case 25512U: 
  case 25511U: 
  case 25510U: 
  case 25509U: 
  case 25508U: 
  case 25507U: 
  case 25506U: 
  case 25505U: 
  case 25504U: 
  case 25503U: 
  case 25502U: 
  case 25501U: 
  case 25500U: 
  case 25499U: 
  case 25498U: 
  case 25497U: 
  case 25496U: 
  case 25495U: 
  case 25494U: 
  case 25493U: 
  case 25492U: 
  case 25491U: 
  case 25490U: 
  case 25489U: 
  case 25488U: 
  case 25487U: 
  case 25486U: 
  case 25485U: 
  case 25484U: 
  case 25483U: 
  case 25482U: 
  case 25481U: 
  case 25480U: 
  case 25479U: 
  case 25478U: 
  case 25477U: 
  case 25476U: 
  case 25475U: 
  case 25474U: 
  case 25473U: 
  case 25472U: 
  case 25471U: 
  case 25470U: 
  case 25469U: 
  case 25468U: 
  case 25467U: 
  case 25466U: 
  case 25465U: 
  case 25464U: 
  case 25463U: 
  case 25462U: 
  case 25461U: 
  case 25460U: 
  case 25459U: 
  case 25458U: 
  case 25457U: 
  case 25456U: 
  case 25455U: 
  case 25454U: 
  case 25453U: 
  case 25452U: 
  case 25451U: 
  case 25450U: 
  case 25449U: 
  case 25448U: 
  case 25447U: 
  case 25446U: 
  case 25445U: 
  case 25444U: 
  case 25443U: 
  case 25442U: 
  case 25441U: 
  case 25440U: 
  case 25439U: 
  case 25438U: 
  case 25437U: 
  case 25436U: 
  case 25435U: 
  case 25434U: 
  case 25433U: 
  case 25432U: 
  case 25431U: 
  case 25430U: 
  case 25429U: 
  case 25428U: 
  case 25427U: 
  case 25426U: 
  case 25425U: 
  case 25424U: 
  case 25423U: 
  case 25422U: 
  case 25421U: 
  case 25420U: 
  case 25419U: 
  case 25418U: 
  case 25417U: 
  case 25416U: 
  case 25415U: 
  case 25414U: 
  case 25413U: 
  case 25412U: 
  case 25411U: 
  case 25410U: 
  case 25409U: 
  case 25408U: 
  case 25407U: 
  case 25406U: 
  case 25405U: 
  case 25404U: 
  case 25403U: 
  case 25402U: 
  case 25401U: 
  case 25400U: 
  case 25399U: 
  case 25398U: 
  case 25397U: 
  case 25396U: 
  case 25395U: 
  case 25394U: 
  case 25393U: 
  case 25392U: 
  case 25391U: 
  case 25390U: 
  case 25389U: 
  case 25388U: 
  case 25387U: 
  case 25386U: 
  case 25385U: 
  case 25384U: 
  case 25383U: 
  case 25382U: 
  case 25381U: 
  case 25380U: 
  case 25379U: 
  case 25378U: 
  case 25377U: 
  case 25376U: 
  case 25375U: 
  case 25374U: 
  case 25373U: 
  case 25372U: 
  case 25371U: 
  case 25370U: 
  case 25369U: 
  case 25368U: 
  case 25367U: 
  case 25366U: 
  case 25365U: 
  case 25364U: 
  case 25363U: 
  case 25362U: 
  case 25361U: 
  case 25360U: 
  case 25359U: 
  case 25358U: 
  case 25357U: 
  case 25356U: 
  case 25355U: 
  case 25354U: 
  case 25353U: 
  case 25352U: 
  case 25351U: 
  case 25350U: 
  case 25349U: 
  case 25348U: 
  case 25347U: 
  case 25346U: 
  case 25345U: 
  case 25344U: 
  case 25343U: 
  case 25342U: 
  case 25341U: 
  case 25340U: 
  case 25339U: 
  case 25338U: 
  case 25337U: 
  case 25336U: 
  case 25335U: 
  case 25334U: 
  case 25333U: 
  case 25332U: 
  case 25331U: 
  case 25330U: 
  case 25329U: 
  case 25328U: 
  case 25327U: 
  case 25326U: 
  case 25325U: 
  case 25324U: 
  case 25323U: 
  case 25322U: 
  case 25321U: 
  case 25320U: 
  case 25319U: 
  case 25318U: 
  case 25317U: 
  case 25316U: 
  case 25315U: 
  case 25314U: 
  case 25313U: 
  case 25312U: 
  case 25311U: 
  case 25310U: 
  case 25309U: 
  case 25308U: 
  case 25307U: 
  case 25306U: 
  case 25305U: 
  case 25304U: 
  case 25303U: 
  case 25302U: 
  case 25301U: 
  case 25300U: 
  case 25299U: 
  case 25298U: 
  case 25297U: 
  case 25296U: 
  case 25295U: 
  case 25294U: 
  case 25293U: 
  case 25292U: 
  case 25291U: 
  case 25290U: 
  case 25289U: 
  case 25288U: 
  case 25287U: 
  case 25286U: 
  case 25285U: 
  case 25284U: 
  case 25283U: 
  case 25282U: 
  case 25281U: 
  case 25280U: 
  case 25279U: 
  case 25278U: 
  case 25277U: 
  case 25276U: 
  case 25275U: 
  case 25274U: 
  case 25273U: 
  case 25272U: 
  case 25271U: 
  case 25270U: 
  case 25269U: 
  case 25268U: 
  case 25267U: 
  case 25266U: 
  case 25265U: 
  case 25264U: 
  case 25263U: 
  case 25262U: 
  case 25261U: 
  case 25260U: 
  case 25259U: 
  case 25258U: 
  case 25257U: 
  case 25256U: 
  case 25255U: 
  case 25254U: 
  case 25253U: 
  case 25252U: 
  case 25251U: 
  case 25250U: 
  case 25249U: 
  case 25248U: 
  case 25247U: 
  case 25246U: 
  case 25245U: 
  case 25244U: 
  case 25243U: 
  case 25242U: 
  case 25241U: 
  case 25240U: 
  case 25239U: 
  case 25238U: 
  case 25237U: 
  case 25236U: 
  case 25235U: 
  case 25234U: 
  case 25233U: 
  case 25232U: 
  case 25231U: 
  case 25230U: 
  case 25229U: 
  case 25228U: 
  case 25227U: 
  case 25226U: 
  case 25225U: 
  case 25224U: 
  case 25223U: 
  case 25222U: 
  case 25221U: 
  case 25220U: 
  case 25219U: 
  case 25218U: 
  case 25217U: 
  case 25216U: 
  case 25215U: 
  case 25214U: 
  case 25213U: 
  case 25212U: 
  case 25211U: 
  case 25210U: 
  case 25209U: 
  case 25208U: 
  case 25207U: 
  case 25206U: 
  case 25205U: 
  case 25204U: 
  case 25203U: 
  case 25202U: 
  case 25201U: 
  case 25200U: 
  case 25199U: 
  case 25198U: 
  case 25197U: 
  case 25196U: 
  case 25195U: 
  case 25194U: 
  case 25193U: 
  case 25192U: 
  case 25191U: 
  case 25190U: 
  case 25189U: 
  case 25188U: 
  case 25187U: 
  case 25186U: 
  case 25185U: 
  case 25184U: 
  case 25183U: 
  case 25182U: 
  case 25181U: 
  case 25180U: 
  case 25179U: 
  case 25178U: 
  case 25177U: 
  case 25176U: 
  case 25175U: 
  case 25174U: 
  case 25173U: 
  case 25172U: 
  case 25171U: 
  case 25170U: 
  case 25169U: 
  case 25168U: 
  case 25167U: 
  case 25166U: 
  case 25165U: 
  case 25164U: 
  case 25163U: 
  case 25162U: 
  case 25161U: 
  case 25160U: 
  case 25159U: 
  case 25158U: 
  case 25157U: 
  case 25156U: 
  case 25155U: 
  case 25154U: 
  case 25153U: 
  case 25152U: 
  case 25151U: 
  case 25150U: 
  case 25149U: 
  case 25148U: 
  case 25147U: 
  case 25146U: 
  case 25145U: 
  case 25144U: 
  case 25143U: 
  case 25142U: 
  case 25141U: 
  case 25140U: 
  case 25139U: 
  case 25138U: 
  case 25137U: 
  case 25136U: 
  case 25135U: 
  case 25134U: 
  case 25133U: 
  case 25132U: 
  case 25131U: 
  case 25130U: 
  case 25129U: 
  case 25128U: 
  case 25127U: 
  case 25126U: 
  case 25125U: 
  case 25124U: 
  case 25123U: 
  case 25122U: 
  case 25121U: 
  case 25120U: 
  case 25119U: 
  case 25118U: 
  case 25117U: 
  case 25116U: 
  case 25115U: 
  case 25114U: 
  case 25113U: 
  case 25112U: 
  case 25111U: 
  case 25110U: 
  case 25109U: 
  case 25108U: 
  case 25107U: 
  case 25106U: 
  case 25105U: 
  case 25104U: 
  case 25103U: 
  case 25102U: 
  case 25101U: 
  case 25100U: 
  case 25099U: 
  case 25098U: 
  case 25097U: 
  case 25096U: 
  case 25095U: 
  case 25094U: 
  case 25093U: 
  case 25092U: 
  case 25091U: 
  case 25090U: 
  case 25089U: 
  case 25088U: 
  case 25087U: 
  case 25086U: 
  case 25085U: 
  case 25084U: 
  case 25083U: 
  case 25082U: 
  case 25081U: 
  case 25080U: 
  case 25079U: 
  case 25078U: 
  case 25077U: 
  case 25076U: 
  case 25075U: 
  case 25074U: 
  case 25073U: 
  case 25072U: 
  case 25071U: 
  case 25070U: 
  case 25069U: 
  case 25068U: 
  case 25067U: 
  case 25066U: 
  case 25065U: 
  case 25064U: 
  case 25063U: 
  case 25062U: 
  case 25061U: 
  case 25060U: 
  case 25059U: 
  case 25058U: 
  case 25057U: 
  case 25056U: 
  case 25055U: 
  case 25054U: 
  case 25053U: 
  case 25052U: 
  case 25051U: 
  case 25050U: 
  case 25049U: 
  case 25048U: 
  case 25047U: 
  case 25046U: 
  case 25045U: 
  case 25044U: 
  case 25043U: 
  case 25042U: 
  case 25041U: 
  case 25040U: 
  case 25039U: 
  case 25038U: 
  case 25037U: 
  case 25036U: 
  case 25035U: 
  case 25034U: 
  case 25033U: 
  case 25032U: 
  case 25031U: 
  case 25030U: 
  case 25029U: 
  case 25028U: 
  case 25027U: 
  case 25026U: 
  case 25025U: 
  case 25024U: 
  case 25023U: 
  case 25022U: 
  case 25021U: 
  case 25020U: 
  case 25019U: 
  case 25018U: 
  case 25017U: 
  case 25016U: 
  case 25015U: 
  case 25014U: 
  case 25013U: 
  case 25012U: 
  case 25011U: 
  case 25010U: 
  case 25009U: 
  case 25008U: 
  case 25007U: 
  case 25006U: 
  case 25005U: 
  case 25004U: 
  case 25003U: 
  case 25002U: 
  case 25001U: 
  case 25000U: ;
  case 26999U: 
  case 26998U: 
  case 26997U: 
  case 26996U: 
  case 26995U: 
  case 26994U: 
  case 26993U: 
  case 26992U: 
  case 26991U: 
  case 26990U: 
  case 26989U: 
  case 26988U: 
  case 26987U: 
  case 26986U: 
  case 26985U: 
  case 26984U: 
  case 26983U: 
  case 26982U: 
  case 26981U: 
  case 26980U: 
  case 26979U: 
  case 26978U: 
  case 26977U: 
  case 26976U: 
  case 26975U: 
  case 26974U: 
  case 26973U: 
  case 26972U: 
  case 26971U: 
  case 26970U: 
  case 26969U: 
  case 26968U: 
  case 26967U: 
  case 26966U: 
  case 26965U: 
  case 26964U: 
  case 26963U: 
  case 26962U: 
  case 26961U: 
  case 26960U: 
  case 26959U: 
  case 26958U: 
  case 26957U: 
  case 26956U: 
  case 26955U: 
  case 26954U: 
  case 26953U: 
  case 26952U: 
  case 26951U: 
  case 26950U: 
  case 26949U: 
  case 26948U: 
  case 26947U: 
  case 26946U: 
  case 26945U: 
  case 26944U: 
  case 26943U: 
  case 26942U: 
  case 26941U: 
  case 26940U: 
  case 26939U: 
  case 26938U: 
  case 26937U: 
  case 26936U: 
  case 26935U: 
  case 26934U: 
  case 26933U: 
  case 26932U: 
  case 26931U: 
  case 26930U: 
  case 26929U: 
  case 26928U: 
  case 26927U: 
  case 26926U: 
  case 26925U: 
  case 26924U: 
  case 26923U: 
  case 26922U: 
  case 26921U: 
  case 26920U: 
  case 26919U: 
  case 26918U: 
  case 26917U: 
  case 26916U: 
  case 26915U: 
  case 26914U: 
  case 26913U: 
  case 26912U: 
  case 26911U: 
  case 26910U: 
  case 26909U: 
  case 26908U: 
  case 26907U: 
  case 26906U: 
  case 26905U: 
  case 26904U: 
  case 26903U: 
  case 26902U: 
  case 26901U: 
  case 26900U: 
  case 26899U: 
  case 26898U: 
  case 26897U: 
  case 26896U: 
  case 26895U: 
  case 26894U: 
  case 26893U: 
  case 26892U: 
  case 26891U: 
  case 26890U: 
  case 26889U: 
  case 26888U: 
  case 26887U: 
  case 26886U: 
  case 26885U: 
  case 26884U: 
  case 26883U: 
  case 26882U: 
  case 26881U: 
  case 26880U: 
  case 26879U: 
  case 26878U: 
  case 26877U: 
  case 26876U: 
  case 26875U: 
  case 26874U: 
  case 26873U: 
  case 26872U: 
  case 26871U: 
  case 26870U: 
  case 26869U: 
  case 26868U: 
  case 26867U: 
  case 26866U: 
  case 26865U: 
  case 26864U: 
  case 26863U: 
  case 26862U: 
  case 26861U: 
  case 26860U: 
  case 26859U: 
  case 26858U: 
  case 26857U: 
  case 26856U: 
  case 26855U: 
  case 26854U: 
  case 26853U: 
  case 26852U: 
  case 26851U: 
  case 26850U: 
  case 26849U: 
  case 26848U: 
  case 26847U: 
  case 26846U: 
  case 26845U: 
  case 26844U: 
  case 26843U: 
  case 26842U: 
  case 26841U: 
  case 26840U: 
  case 26839U: 
  case 26838U: 
  case 26837U: 
  case 26836U: 
  case 26835U: 
  case 26834U: 
  case 26833U: 
  case 26832U: 
  case 26831U: 
  case 26830U: 
  case 26829U: 
  case 26828U: 
  case 26827U: 
  case 26826U: 
  case 26825U: 
  case 26824U: 
  case 26823U: 
  case 26822U: 
  case 26821U: 
  case 26820U: 
  case 26819U: 
  case 26818U: 
  case 26817U: 
  case 26816U: 
  case 26815U: 
  case 26814U: 
  case 26813U: 
  case 26812U: 
  case 26811U: 
  case 26810U: 
  case 26809U: 
  case 26808U: 
  case 26807U: 
  case 26806U: 
  case 26805U: 
  case 26804U: 
  case 26803U: 
  case 26802U: 
  case 26801U: 
  case 26800U: 
  case 26799U: 
  case 26798U: 
  case 26797U: 
  case 26796U: 
  case 26795U: 
  case 26794U: 
  case 26793U: 
  case 26792U: 
  case 26791U: 
  case 26790U: 
  case 26789U: 
  case 26788U: 
  case 26787U: 
  case 26786U: 
  case 26785U: 
  case 26784U: 
  case 26783U: 
  case 26782U: 
  case 26781U: 
  case 26780U: 
  case 26779U: 
  case 26778U: 
  case 26777U: 
  case 26776U: 
  case 26775U: 
  case 26774U: 
  case 26773U: 
  case 26772U: 
  case 26771U: 
  case 26770U: 
  case 26769U: 
  case 26768U: 
  case 26767U: 
  case 26766U: 
  case 26765U: 
  case 26764U: 
  case 26763U: 
  case 26762U: 
  case 26761U: 
  case 26760U: 
  case 26759U: 
  case 26758U: 
  case 26757U: 
  case 26756U: 
  case 26755U: 
  case 26754U: 
  case 26753U: 
  case 26752U: 
  case 26751U: 
  case 26750U: 
  case 26749U: 
  case 26748U: 
  case 26747U: 
  case 26746U: 
  case 26745U: 
  case 26744U: 
  case 26743U: 
  case 26742U: 
  case 26741U: 
  case 26740U: 
  case 26739U: 
  case 26738U: 
  case 26737U: 
  case 26736U: 
  case 26735U: 
  case 26734U: 
  case 26733U: 
  case 26732U: 
  case 26731U: 
  case 26730U: 
  case 26729U: 
  case 26728U: 
  case 26727U: 
  case 26726U: 
  case 26725U: 
  case 26724U: 
  case 26723U: 
  case 26722U: 
  case 26721U: 
  case 26720U: 
  case 26719U: 
  case 26718U: 
  case 26717U: 
  case 26716U: 
  case 26715U: 
  case 26714U: 
  case 26713U: 
  case 26712U: 
  case 26711U: 
  case 26710U: 
  case 26709U: 
  case 26708U: 
  case 26707U: 
  case 26706U: 
  case 26705U: 
  case 26704U: 
  case 26703U: 
  case 26702U: 
  case 26701U: 
  case 26700U: 
  case 26699U: 
  case 26698U: 
  case 26697U: 
  case 26696U: 
  case 26695U: 
  case 26694U: 
  case 26693U: 
  case 26692U: 
  case 26691U: 
  case 26690U: 
  case 26689U: 
  case 26688U: 
  case 26687U: 
  case 26686U: 
  case 26685U: 
  case 26684U: 
  case 26683U: 
  case 26682U: 
  case 26681U: 
  case 26680U: 
  case 26679U: 
  case 26678U: 
  case 26677U: 
  case 26676U: 
  case 26675U: 
  case 26674U: 
  case 26673U: 
  case 26672U: 
  case 26671U: 
  case 26670U: 
  case 26669U: 
  case 26668U: 
  case 26667U: 
  case 26666U: 
  case 26665U: 
  case 26664U: 
  case 26663U: 
  case 26662U: 
  case 26661U: 
  case 26660U: 
  case 26659U: 
  case 26658U: 
  case 26657U: 
  case 26656U: 
  case 26655U: 
  case 26654U: 
  case 26653U: 
  case 26652U: 
  case 26651U: 
  case 26650U: 
  case 26649U: 
  case 26648U: 
  case 26647U: 
  case 26646U: 
  case 26645U: 
  case 26644U: 
  case 26643U: 
  case 26642U: 
  case 26641U: 
  case 26640U: 
  case 26639U: 
  case 26638U: 
  case 26637U: 
  case 26636U: 
  case 26635U: 
  case 26634U: 
  case 26633U: 
  case 26632U: 
  case 26631U: 
  case 26630U: 
  case 26629U: 
  case 26628U: 
  case 26627U: 
  case 26626U: 
  case 26625U: 
  case 26624U: 
  case 26623U: 
  case 26622U: 
  case 26621U: 
  case 26620U: 
  case 26619U: 
  case 26618U: 
  case 26617U: 
  case 26616U: 
  case 26615U: 
  case 26614U: 
  case 26613U: 
  case 26612U: 
  case 26611U: 
  case 26610U: 
  case 26609U: 
  case 26608U: 
  case 26607U: 
  case 26606U: 
  case 26605U: 
  case 26604U: 
  case 26603U: 
  case 26602U: 
  case 26601U: 
  case 26600U: 
  case 26599U: 
  case 26598U: 
  case 26597U: 
  case 26596U: 
  case 26595U: 
  case 26594U: 
  case 26593U: 
  case 26592U: 
  case 26591U: 
  case 26590U: 
  case 26589U: 
  case 26588U: 
  case 26587U: 
  case 26586U: 
  case 26585U: 
  case 26584U: 
  case 26583U: 
  case 26582U: 
  case 26581U: 
  case 26580U: 
  case 26579U: 
  case 26578U: 
  case 26577U: 
  case 26576U: 
  case 26575U: 
  case 26574U: 
  case 26573U: 
  case 26572U: 
  case 26571U: 
  case 26570U: 
  case 26569U: 
  case 26568U: 
  case 26567U: 
  case 26566U: 
  case 26565U: 
  case 26564U: 
  case 26563U: 
  case 26562U: 
  case 26561U: 
  case 26560U: 
  case 26559U: 
  case 26558U: 
  case 26557U: 
  case 26556U: 
  case 26555U: 
  case 26554U: 
  case 26553U: 
  case 26552U: 
  case 26551U: 
  case 26550U: 
  case 26549U: 
  case 26548U: 
  case 26547U: 
  case 26546U: 
  case 26545U: 
  case 26544U: 
  case 26543U: 
  case 26542U: 
  case 26541U: 
  case 26540U: 
  case 26539U: 
  case 26538U: 
  case 26537U: 
  case 26536U: 
  case 26535U: 
  case 26534U: 
  case 26533U: 
  case 26532U: 
  case 26531U: 
  case 26530U: 
  case 26529U: 
  case 26528U: 
  case 26527U: 
  case 26526U: 
  case 26525U: 
  case 26524U: 
  case 26523U: 
  case 26522U: 
  case 26521U: 
  case 26520U: 
  case 26519U: 
  case 26518U: 
  case 26517U: 
  case 26516U: 
  case 26515U: 
  case 26514U: 
  case 26513U: 
  case 26512U: 
  case 26511U: 
  case 26510U: 
  case 26509U: 
  case 26508U: 
  case 26507U: 
  case 26506U: 
  case 26505U: 
  case 26504U: 
  case 26503U: 
  case 26502U: 
  case 26501U: 
  case 26500U: 
  case 26499U: 
  case 26498U: 
  case 26497U: 
  case 26496U: 
  case 26495U: 
  case 26494U: 
  case 26493U: 
  case 26492U: 
  case 26491U: 
  case 26490U: 
  case 26489U: 
  case 26488U: 
  case 26487U: 
  case 26486U: 
  case 26485U: 
  case 26484U: 
  case 26483U: 
  case 26482U: 
  case 26481U: 
  case 26480U: 
  case 26479U: 
  case 26478U: 
  case 26477U: 
  case 26476U: 
  case 26475U: 
  case 26474U: 
  case 26473U: 
  case 26472U: 
  case 26471U: 
  case 26470U: 
  case 26469U: 
  case 26468U: 
  case 26467U: 
  case 26466U: 
  case 26465U: 
  case 26464U: 
  case 26463U: 
  case 26462U: 
  case 26461U: 
  case 26460U: 
  case 26459U: 
  case 26458U: 
  case 26457U: 
  case 26456U: 
  case 26455U: 
  case 26454U: 
  case 26453U: 
  case 26452U: 
  case 26451U: 
  case 26450U: 
  case 26449U: 
  case 26448U: 
  case 26447U: 
  case 26446U: 
  case 26445U: 
  case 26444U: 
  case 26443U: 
  case 26442U: 
  case 26441U: 
  case 26440U: 
  case 26439U: 
  case 26438U: 
  case 26437U: 
  case 26436U: 
  case 26435U: 
  case 26434U: 
  case 26433U: 
  case 26432U: 
  case 26431U: 
  case 26430U: 
  case 26429U: 
  case 26428U: 
  case 26427U: 
  case 26426U: 
  case 26425U: 
  case 26424U: 
  case 26423U: 
  case 26422U: 
  case 26421U: 
  case 26420U: 
  case 26419U: 
  case 26418U: 
  case 26417U: 
  case 26416U: 
  case 26415U: 
  case 26414U: 
  case 26413U: 
  case 26412U: 
  case 26411U: 
  case 26410U: 
  case 26409U: 
  case 26408U: 
  case 26407U: 
  case 26406U: 
  case 26405U: 
  case 26404U: 
  case 26403U: 
  case 26402U: 
  case 26401U: 
  case 26400U: 
  case 26399U: 
  case 26398U: 
  case 26397U: 
  case 26396U: 
  case 26395U: 
  case 26394U: 
  case 26393U: 
  case 26392U: 
  case 26391U: 
  case 26390U: 
  case 26389U: 
  case 26388U: 
  case 26387U: 
  case 26386U: 
  case 26385U: 
  case 26384U: 
  case 26383U: 
  case 26382U: 
  case 26381U: 
  case 26380U: 
  case 26379U: 
  case 26378U: 
  case 26377U: 
  case 26376U: 
  case 26375U: 
  case 26374U: 
  case 26373U: 
  case 26372U: 
  case 26371U: 
  case 26370U: 
  case 26369U: 
  case 26368U: 
  case 26367U: 
  case 26366U: 
  case 26365U: 
  case 26364U: 
  case 26363U: 
  case 26362U: 
  case 26361U: 
  case 26360U: 
  case 26359U: 
  case 26358U: 
  case 26357U: 
  case 26356U: 
  case 26355U: 
  case 26354U: 
  case 26353U: 
  case 26352U: 
  case 26351U: 
  case 26350U: 
  case 26349U: 
  case 26348U: 
  case 26347U: 
  case 26346U: 
  case 26345U: 
  case 26344U: 
  case 26343U: 
  case 26342U: 
  case 26341U: 
  case 26340U: 
  case 26339U: 
  case 26338U: 
  case 26337U: 
  case 26336U: 
  case 26335U: 
  case 26334U: 
  case 26333U: 
  case 26332U: 
  case 26331U: 
  case 26330U: 
  case 26329U: 
  case 26328U: 
  case 26327U: 
  case 26326U: 
  case 26325U: 
  case 26324U: 
  case 26323U: 
  case 26322U: 
  case 26321U: 
  case 26320U: 
  case 26319U: 
  case 26318U: 
  case 26317U: 
  case 26316U: 
  case 26315U: 
  case 26314U: 
  case 26313U: 
  case 26312U: 
  case 26311U: 
  case 26310U: 
  case 26309U: 
  case 26308U: 
  case 26307U: 
  case 26306U: 
  case 26305U: 
  case 26304U: 
  case 26303U: 
  case 26302U: 
  case 26301U: 
  case 26300U: 
  case 26299U: 
  case 26298U: 
  case 26297U: 
  case 26296U: 
  case 26295U: 
  case 26294U: 
  case 26293U: 
  case 26292U: 
  case 26291U: 
  case 26290U: 
  case 26289U: 
  case 26288U: 
  case 26287U: 
  case 26286U: 
  case 26285U: 
  case 26284U: 
  case 26283U: 
  case 26282U: 
  case 26281U: 
  case 26280U: 
  case 26279U: 
  case 26278U: 
  case 26277U: 
  case 26276U: 
  case 26275U: 
  case 26274U: 
  case 26273U: 
  case 26272U: 
  case 26271U: 
  case 26270U: 
  case 26269U: 
  case 26268U: 
  case 26267U: 
  case 26266U: 
  case 26265U: 
  case 26264U: 
  case 26263U: 
  case 26262U: 
  case 26261U: 
  case 26260U: 
  case 26259U: 
  case 26258U: 
  case 26257U: 
  case 26256U: 
  case 26255U: 
  case 26254U: 
  case 26253U: 
  case 26252U: 
  case 26251U: 
  case 26250U: 
  case 26249U: 
  case 26248U: 
  case 26247U: 
  case 26246U: 
  case 26245U: 
  case 26244U: 
  case 26243U: 
  case 26242U: 
  case 26241U: 
  case 26240U: 
  case 26239U: 
  case 26238U: 
  case 26237U: 
  case 26236U: 
  case 26235U: 
  case 26234U: 
  case 26233U: 
  case 26232U: 
  case 26231U: 
  case 26230U: 
  case 26229U: 
  case 26228U: 
  case 26227U: 
  case 26226U: 
  case 26225U: 
  case 26224U: 
  case 26223U: 
  case 26222U: 
  case 26221U: 
  case 26220U: 
  case 26219U: 
  case 26218U: 
  case 26217U: 
  case 26216U: 
  case 26215U: 
  case 26214U: 
  case 26213U: 
  case 26212U: 
  case 26211U: 
  case 26210U: 
  case 26209U: 
  case 26208U: 
  case 26207U: 
  case 26206U: 
  case 26205U: 
  case 26204U: 
  case 26203U: 
  case 26202U: 
  case 26201U: 
  case 26200U: 
  case 26199U: 
  case 26198U: 
  case 26197U: 
  case 26196U: 
  case 26195U: 
  case 26194U: 
  case 26193U: 
  case 26192U: 
  case 26191U: 
  case 26190U: 
  case 26189U: 
  case 26188U: 
  case 26187U: 
  case 26186U: 
  case 26185U: 
  case 26184U: 
  case 26183U: 
  case 26182U: 
  case 26181U: 
  case 26180U: 
  case 26179U: 
  case 26178U: 
  case 26177U: 
  case 26176U: 
  case 26175U: 
  case 26174U: 
  case 26173U: 
  case 26172U: 
  case 26171U: 
  case 26170U: 
  case 26169U: 
  case 26168U: 
  case 26167U: 
  case 26166U: 
  case 26165U: 
  case 26164U: 
  case 26163U: 
  case 26162U: 
  case 26161U: 
  case 26160U: 
  case 26159U: 
  case 26158U: 
  case 26157U: 
  case 26156U: 
  case 26155U: 
  case 26154U: 
  case 26153U: 
  case 26152U: 
  case 26151U: 
  case 26150U: 
  case 26149U: 
  case 26148U: 
  case 26147U: 
  case 26146U: 
  case 26145U: 
  case 26144U: 
  case 26143U: 
  case 26142U: 
  case 26141U: 
  case 26140U: 
  case 26139U: 
  case 26138U: 
  case 26137U: 
  case 26136U: 
  case 26135U: 
  case 26134U: 
  case 26133U: 
  case 26132U: 
  case 26131U: 
  case 26130U: 
  case 26129U: 
  case 26128U: 
  case 26127U: 
  case 26126U: 
  case 26125U: 
  case 26124U: 
  case 26123U: 
  case 26122U: 
  case 26121U: 
  case 26120U: 
  case 26119U: 
  case 26118U: 
  case 26117U: 
  case 26116U: 
  case 26115U: 
  case 26114U: 
  case 26113U: 
  case 26112U: 
  case 26111U: 
  case 26110U: 
  case 26109U: 
  case 26108U: 
  case 26107U: 
  case 26106U: 
  case 26105U: 
  case 26104U: 
  case 26103U: 
  case 26102U: 
  case 26101U: 
  case 26100U: 
  case 26099U: 
  case 26098U: 
  case 26097U: 
  case 26096U: 
  case 26095U: 
  case 26094U: 
  case 26093U: 
  case 26092U: 
  case 26091U: 
  case 26090U: 
  case 26089U: 
  case 26088U: 
  case 26087U: 
  case 26086U: 
  case 26085U: 
  case 26084U: 
  case 26083U: 
  case 26082U: 
  case 26081U: 
  case 26080U: 
  case 26079U: 
  case 26078U: 
  case 26077U: 
  case 26076U: 
  case 26075U: 
  case 26074U: 
  case 26073U: 
  case 26072U: 
  case 26071U: 
  case 26070U: 
  case 26069U: 
  case 26068U: 
  case 26067U: 
  case 26066U: 
  case 26065U: 
  case 26064U: 
  case 26063U: 
  case 26062U: 
  case 26061U: 
  case 26060U: 
  case 26059U: 
  case 26058U: 
  case 26057U: 
  case 26056U: 
  case 26055U: 
  case 26054U: 
  case 26053U: 
  case 26052U: 
  case 26051U: 
  case 26050U: 
  case 26049U: 
  case 26048U: 
  case 26047U: 
  case 26046U: 
  case 26045U: 
  case 26044U: 
  case 26043U: 
  case 26042U: 
  case 26041U: 
  case 26040U: 
  case 26039U: 
  case 26038U: 
  case 26037U: 
  case 26036U: 
  case 26035U: 
  case 26034U: 
  case 26033U: 
  case 26032U: 
  case 26031U: 
  case 26030U: 
  case 26029U: 
  case 26028U: 
  case 26027U: 
  case 26026U: 
  case 26025U: 
  case 26024U: 
  case 26023U: 
  case 26022U: 
  case 26021U: 
  case 26020U: 
  case 26019U: 
  case 26018U: 
  case 26017U: 
  case 26016U: 
  case 26015U: 
  case 26014U: 
  case 26013U: 
  case 26012U: 
  case 26011U: 
  case 26010U: 
  case 26009U: 
  case 26008U: 
  case 26007U: 
  case 26006U: 
  case 26005U: 
  case 26004U: 
  case 26003U: 
  case 26002U: 
  case 26001U: 
  case 26000U: 
#line 440
  itv->card = ivtv_get_card(2);
#line 441
  goto ldv_43211;
  case 0U: 
#line 443
  printk("\v%s: Invalid EEPROM\n", (char *)(& itv->v4l2_dev.name));
#line 444
  return;
  default: 
#line 446
  printk("\v%s: Unknown model %d, defaulting to PVR-150\n", (char *)(& itv->v4l2_dev.name),
         tv.model);
#line 447
  itv->card = ivtv_get_card(2);
#line 448
  goto ldv_43211;
  }
  ldv_43211: ;
#line 451
  switch (tv.model) {
  case 48254U: 
#line 455
  itv->card = ivtv_get_card(28);
#line 456
  goto ldv_43220;
  default: ;
#line 458
  goto ldv_43220;
  }
  ldv_43220: 
#line 461
  itv->v4l2_cap = (itv->card)->v4l2_capabilities;
#line 462
  itv->card_name = (char const   *)(itv->card)->name;
#line 463
  itv->card_i2c = (struct ivtv_card_tuner_i2c  const  *)(itv->card)->i2c;
#line 480
  if (tv.model - 23000U <= 999U) {
#line 481
    ivtv_i2c_radio___0.radio[0] = 96U;
#line 481
    ivtv_i2c_radio___0.radio[1] = 65534U;
#line 481
    ivtv_i2c_radio___0.demod[0] = 67U;
#line 481
    ivtv_i2c_radio___0.demod[1] = 65534U;
#line 481
    ivtv_i2c_radio___0.tv[0] = 97U;
#line 481
    ivtv_i2c_radio___0.tv[1] = 65534U;
#line 481
    tmp = 2U;
#line 481
    while (1) {
#line 481
      if (tmp >= 4U) {
#line 481
        break;
      } else {

      }
#line 481
      ivtv_i2c_radio___0.tv[tmp] = (unsigned short)0;
#line 481
      tmp = tmp + 1U;
    }
#line 487
    itv->card_name = "WinTV PVR 500";
#line 488
    itv->card_i2c = & ivtv_i2c_radio___0;
#line 489
    if (pci_slot == 8 || pci_slot == 9) {
#line 490
      is_first = (pci_slot & 1) == 0;
#line 492
      itv->card_name = is_first != 0 ? "WinTV PVR 500 (unit #1)" : "WinTV PVR 500 (unit #2)";
#line 494
      if (is_first == 0) {
#line 495
        printk("\016%s: Correcting tveeprom data: no radio present on second unit\n",
               (char *)(& itv->v4l2_dev.name));
#line 496
        tv.has_radio = 0U;
      } else {

      }
    } else {

    }
  } else {

  }
#line 500
  printk("\016%s: Autodetected %s\n", (char *)(& itv->v4l2_dev.name), itv->card_name);
#line 502
  switch (tv.tuner_hauppauge_model) {
  case 85U: ;
  case 99U: ;
  case 112U: 
#line 506
  itv->pvr150_workaround = 1U;
#line 507
  goto ldv_43227;
  default: ;
#line 509
  goto ldv_43227;
  }
  ldv_43227: ;
#line 511
  if (tv.tuner_type == 4U) {
#line 512
    printk("\v%s: tveeprom cannot autodetect tuner!\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 514
  if (itv->options.tuner == -1) {
#line 515
    itv->options.tuner = (int )tv.tuner_type;
  } else {

  }
#line 516
  if (itv->options.radio == -1) {
#line 517
    itv->options.radio = tv.has_radio != 0U;
  } else {

  }
#line 519
  if (itv->options.newi2c == -1 && tv.has_ir != 0U) {
#line 520
    itv->options.newi2c = (tv.has_ir & 4U) != 0U;
#line 521
    if (itv->options.newi2c != 0) {
#line 522
      printk("\016%s: Reopen i2c bus for IR-blaster support\n", (char *)(& itv->v4l2_dev.name));
#line 523
      exit_ivtv_i2c(itv);
#line 524
      init_ivtv_i2c(itv);
    } else {

    }
  } else {

  }
#line 528
  if (itv->std != 0ULL) {
#line 530
    return;
  } else {

  }
#line 533
  if (((unsigned long long )tv.tuner_formats & 255ULL) != 0ULL) {
#line 534
    if ((ivtv_debug & 2) != 0) {
#line 534
      printk("\016%s:  info: PAL tuner detected\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 535
    itv->std = itv->std | 15ULL;
  } else
#line 536
  if (((unsigned long long )tv.tuner_formats & 45056ULL) != 0ULL) {
#line 537
    if ((ivtv_debug & 2) != 0) {
#line 537
      printk("\016%s:  info: NTSC tuner detected\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 538
    itv->std = itv->std | 4096ULL;
  } else
#line 539
  if (((unsigned long long )tv.tuner_formats & 16711680ULL) != 0ULL) {
#line 540
    if ((ivtv_debug & 2) != 0) {
#line 540
      printk("\016%s:  info: SECAM tuner detected\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 541
    itv->std = itv->std | 4194304ULL;
  } else {
#line 543
    printk("\016%s: No tuner detected, default to NTSC-M\n", (char *)(& itv->v4l2_dev.name));
#line 544
    itv->std = itv->std | 4096ULL;
  }
#line 546
  return;
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static v4l2_std_id ivtv_parse_std(struct ivtv *itv ) 
{ 


  {
#line 550
  switch ((int )pal[0]) {
  case 54: 
#line 552
  tunertype = 0;
#line 553
  return (2048ULL);
  case 98: ;
  case 66: ;
  case 103: ;
  case 71: ;
  case 104: ;
  case 72: 
#line 560
  tunertype = 0;
#line 561
  return (15ULL);
  case 110: ;
  case 78: 
#line 564
  tunertype = 1;
#line 565
  if ((int )((signed char )pal[1]) == 99 || (int )((signed char )pal[1]) == 67) {
#line 566
    return (1024ULL);
  } else {

  }
#line 567
  return (512ULL);
  case 105: ;
  case 73: 
#line 570
  tunertype = 0;
#line 571
  return (16ULL);
  case 100: ;
  case 68: ;
  case 107: ;
  case 75: 
#line 576
  tunertype = 0;
#line 577
  return (224ULL);
  case 77: ;
  case 109: 
#line 580
  tunertype = 1;
#line 581
  return (256ULL);
  case 45: ;
#line 583
  goto ldv_43250;
  default: 
#line 585
  printk("\f%s: pal= argument not recognised\n", (char *)(& itv->v4l2_dev.name));
#line 586
  return (0ULL);
  }
  ldv_43250: ;
#line 589
  switch ((int )secam[0]) {
  case 98: ;
  case 66: ;
  case 103: ;
  case 71: ;
  case 104: ;
  case 72: 
#line 596
  tunertype = 0;
#line 597
  return (851968ULL);
  case 100: ;
  case 68: ;
  case 107: ;
  case 75: 
#line 602
  tunertype = 0;
#line 603
  return (3276800ULL);
  case 108: ;
  case 76: 
#line 606
  tunertype = 0;
#line 607
  if ((int )((signed char )secam[1]) == 67 || (int )((signed char )secam[1]) == 99) {
#line 608
    return (8388608ULL);
  } else {

  }
#line 609
  return (4194304ULL);
  case 45: ;
#line 611
  goto ldv_43265;
  default: 
#line 613
  printk("\f%s: secam= argument not recognised\n", (char *)(& itv->v4l2_dev.name));
#line 614
  return (0ULL);
  }
  ldv_43265: ;
#line 617
  switch ((int )ntsc[0]) {
  case 109: ;
  case 77: 
#line 620
  tunertype = 1;
#line 621
  return (4096ULL);
  case 106: ;
  case 74: 
#line 624
  tunertype = 1;
#line 625
  return (8192ULL);
  case 107: ;
  case 75: 
#line 628
  tunertype = 1;
#line 629
  return (32768ULL);
  case 45: ;
#line 631
  goto ldv_43274;
  default: 
#line 633
  printk("\f%s: ntsc= argument not recognised\n", (char *)(& itv->v4l2_dev.name));
#line 634
  return (0ULL);
  }
  ldv_43274: ;
#line 638
  return (0ULL);
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static void ivtv_process_options(struct ivtv *itv ) 
{ 
  char const   *chipname ;
  int i ;
  int j ;
  struct ivtv_card  const  *tmp ;
  struct ivtv_card  const  *tmp___0 ;

  {
#line 646
  itv->options.kilobytes[0] = enc_mpg_buffers * 1024;
#line 647
  itv->options.kilobytes[1] = enc_yuv_buffers * 1024;
#line 648
  itv->options.kilobytes[2] = enc_vbi_buffers * 1024;
#line 649
  itv->options.kilobytes[3] = enc_pcm_buffers;
#line 650
  itv->options.kilobytes[5] = dec_mpg_buffers * 1024;
#line 651
  itv->options.kilobytes[8] = dec_yuv_buffers * 1024;
#line 652
  itv->options.kilobytes[6] = dec_vbi_buffers;
#line 653
  itv->options.cardtype = cardtype[(int )itv->instance];
#line 654
  itv->options.tuner = tuner[(int )itv->instance];
#line 655
  itv->options.radio = radio[(int )itv->instance];
#line 657
  itv->options.i2c_clock_period = i2c_clock_period[(int )itv->instance];
#line 658
  if (itv->options.i2c_clock_period == -1) {
#line 659
    itv->options.i2c_clock_period = 20;
  } else
#line 660
  if (itv->options.i2c_clock_period <= 9) {
#line 661
    itv->options.i2c_clock_period = 10;
  } else
#line 662
  if (itv->options.i2c_clock_period > 4500) {
#line 663
    itv->options.i2c_clock_period = 4500;
  } else {

  }
#line 665
  itv->options.newi2c = newi2c;
#line 666
  if (tunertype < -1 || tunertype > 1) {
#line 667
    printk("\f%s: Invalid tunertype argument, will autodetect instead\n", (char *)(& itv->v4l2_dev.name));
#line 668
    tunertype = -1;
  } else {

  }
#line 670
  itv->std = ivtv_parse_std(itv);
#line 671
  if (itv->std == 0ULL && tunertype >= 0) {
#line 672
    itv->std = tunertype != 0 ? 46848ULL : 16730367ULL;
  } else {

  }
#line 673
  itv->has_cx23415 = (unsigned int )(itv->pdev)->device == 2051U;
#line 674
  chipname = (unsigned int )itv->has_cx23415 != 0U ? "cx23415" : "cx23416";
#line 675
  if (itv->options.cardtype == -1) {
#line 676
    printk("\016%s: Ignore card (detected %s based chip)\n", (char *)(& itv->v4l2_dev.name),
           chipname);
#line 677
    return;
  } else {

  }
#line 679
  tmp = ivtv_get_card((int )((unsigned int )((u16 )itv->options.cardtype) + 65535U));
#line 679
  itv->card = tmp;
#line 679
  if ((unsigned long )tmp != (unsigned long )((struct ivtv_card  const  *)0)) {
#line 680
    printk("\016%s: User specified %s card (detected %s based chip)\n", (char *)(& itv->v4l2_dev.name),
           (itv->card)->name, chipname);
  } else
#line 682
  if (itv->options.cardtype != 0) {
#line 683
    printk("\v%s: Unknown user specified type, trying to autodetect card\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 685
  if ((unsigned long )itv->card == (unsigned long )((struct ivtv_card  const  *)0)) {
#line 686
    if (((unsigned int )(itv->pdev)->subsystem_vendor == 112U || (unsigned int )(itv->pdev)->subsystem_vendor == 624U) || (unsigned int )(itv->pdev)->subsystem_vendor == 16496U) {
#line 689
      itv->card = ivtv_get_card((unsigned int )itv->has_cx23415 != 0U ? 1 : 2);
#line 690
      printk("\016%s: Autodetected Hauppauge card (%s based)\n", (char *)(& itv->v4l2_dev.name),
             chipname);
    } else {

    }
  } else {

  }
#line 694
  if ((unsigned long )itv->card == (unsigned long )((struct ivtv_card  const  *)0)) {
#line 695
    i = 0;
#line 695
    goto ldv_43289;
    ldv_43288: ;
#line 696
    if ((unsigned long )(itv->card)->pci_list == (unsigned long )((struct ivtv_card_pci_info  const  */* const  */)0)) {
#line 697
      goto ldv_43282;
    } else {

    }
#line 698
    j = 0;
#line 698
    goto ldv_43286;
    ldv_43285: ;
#line 699
    if ((int )(itv->pdev)->device != (int )((unsigned short )((itv->card)->pci_list + (unsigned long )j)->device)) {
#line 701
      goto ldv_43283;
    } else {

    }
#line 702
    if ((int )(itv->pdev)->subsystem_vendor != (int )((unsigned short )((itv->card)->pci_list + (unsigned long )j)->subsystem_vendor)) {
#line 704
      goto ldv_43283;
    } else {

    }
#line 705
    if ((int )(itv->pdev)->subsystem_device != (int )((unsigned short )((itv->card)->pci_list + (unsigned long )j)->subsystem_device)) {
#line 707
      goto ldv_43283;
    } else {

    }
#line 708
    printk("\016%s: Autodetected %s card (%s based)\n", (char *)(& itv->v4l2_dev.name),
           (itv->card)->name, chipname);
#line 710
    goto done;
    ldv_43283: 
#line 698
    j = j + 1;
    ldv_43286: ;
#line 698
    if ((unsigned int )((unsigned short )((itv->card)->pci_list + (unsigned long )j)->device) != 0U) {
#line 700
      goto ldv_43285;
    } else {

    }

    ldv_43282: 
#line 695
    i = i + 1;
    ldv_43289: 
#line 695
    tmp___0 = ivtv_get_card((int )((u16 )i));
#line 695
    itv->card = tmp___0;
#line 695
    if ((unsigned long )tmp___0 != (unsigned long )((struct ivtv_card  const  *)0)) {
#line 697
      goto ldv_43288;
    } else {

    }

  } else {

  }
  done: ;
#line 716
  if ((unsigned long )itv->card == (unsigned long )((struct ivtv_card  const  *)0)) {
#line 717
    itv->card = ivtv_get_card(2);
#line 718
    printk("\v%s: Unknown card: vendor/device: [%04x:%04x]\n", (char *)(& itv->v4l2_dev.name),
           (int )(itv->pdev)->vendor, (int )(itv->pdev)->device);
#line 720
    printk("\v%s:               subsystem vendor/device: [%04x:%04x]\n", (char *)(& itv->v4l2_dev.name),
           (int )(itv->pdev)->subsystem_vendor, (int )(itv->pdev)->subsystem_device);
#line 722
    printk("\v%s:               %s based\n", (char *)(& itv->v4l2_dev.name), chipname);
#line 723
    printk("\v%s: Defaulting to %s card\n", (char *)(& itv->v4l2_dev.name), (itv->card)->name);
#line 724
    printk("\v%s: Please mail the vendor/device and subsystem vendor/device IDs and what kind of\n",
           (char *)(& itv->v4l2_dev.name));
#line 725
    printk("\v%s: card you have to the ivtv-devel mailinglist (www.ivtvdriver.org)\n",
           (char *)(& itv->v4l2_dev.name));
#line 726
    printk("\v%s: Prefix your subject line with [UNKNOWN IVTV CARD].\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 728
  itv->v4l2_cap = (itv->card)->v4l2_capabilities;
#line 729
  itv->card_name = (char const   *)(itv->card)->name;
#line 730
  itv->card_i2c = (struct ivtv_card_tuner_i2c  const  *)(itv->card)->i2c;
#line 731
  return;
}
}
#line 738 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int ivtv_init_struct1(struct ivtv *itv ) 
{ 
  struct sched_param param ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  struct task_struct *__k ;
  struct task_struct *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  struct lock_class_key __key___5 ;
  struct lock_class_key __key___6 ;
  struct lock_class_key __key___7 ;
  struct lock_class_key __key___8 ;

  {
#line 740
  param.sched_priority = 99;
#line 742
  itv->base_addr = (itv->pdev)->resource[0].start;
#line 743
  itv->enc_mbox.max_mbox = 2U;
#line 744
  itv->dec_mbox.max_mbox = 1U;
#line 746
  __mutex_init(& itv->serialize_lock, "&itv->serialize_lock", & __key);
#line 747
  __mutex_init(& itv->i2c_bus_lock, "&itv->i2c_bus_lock", & __key___0);
#line 748
  __mutex_init(& itv->udma.lock, "&itv->udma.lock", & __key___1);
#line 750
  spinlock_check(& itv->lock);
#line 750
  __raw_spin_lock_init(& itv->lock.__annonCompField18.rlock, "&(&itv->lock)->rlock",
                       & __key___2);
#line 751
  spinlock_check(& itv->dma_reg_lock);
#line 751
  __raw_spin_lock_init(& itv->dma_reg_lock.__annonCompField18.rlock, "&(&itv->dma_reg_lock)->rlock",
                       & __key___3);
#line 753
  __init_kthread_worker(& itv->irq_worker, "(&itv->irq_worker)->lock", & __key___4);
#line 754
  tmp = kthread_create_on_node(& kthread_worker_fn, (void *)(& itv->irq_worker), -1,
                               "%s", (char *)(& itv->v4l2_dev.name));
#line 754
  __k = tmp;
#line 754
  tmp___0 = IS_ERR((void const   *)__k);
#line 754
  if (tmp___0) {
#line 754
    tmp___1 = 0;
  } else {
#line 754
    tmp___1 = 1;
  }
#line 754
  if (tmp___1) {
#line 754
    wake_up_process(__k);
  } else {

  }
#line 754
  itv->irq_worker_task = __k;
#line 756
  tmp___2 = IS_ERR((void const   *)itv->irq_worker_task);
#line 756
  if ((int )tmp___2) {
#line 757
    printk("\v%s: Could not create ivtv task\n", (char *)(& itv->v4l2_dev.name));
#line 758
    return (-1);
  } else {

  }
#line 761
  sched_setscheduler(itv->irq_worker_task, 1, (struct sched_param  const  *)(& param));
#line 763
  memset((void *)(& itv->irq_work), 0, 32UL);
#line 763
  INIT_LIST_HEAD(& itv->irq_work.node);
#line 763
  itv->irq_work.func = & ivtv_irq_work_handler;
#line 766
  itv->cxhdl.port = 0;
#line 767
  itv->cxhdl.capabilities = 1U;
#line 768
  __init_waitqueue_head(& itv->eos_waitq, "&itv->eos_waitq", & __key___5);
#line 769
  __init_waitqueue_head(& itv->event_waitq, "&itv->event_waitq", & __key___6);
#line 770
  __init_waitqueue_head(& itv->vsync_waitq, "&itv->vsync_waitq", & __key___7);
#line 771
  __init_waitqueue_head(& itv->dma_waitq, "&itv->dma_waitq", & __key___8);
#line 772
  reg_timer_3(& itv->dma_timer);
#line 773
  itv->dma_timer.function = & ivtv_unfinished_dma;
#line 774
  itv->dma_timer.data = (unsigned long )itv;
#line 776
  itv->cur_dma_stream = -1;
#line 777
  itv->cur_pio_stream = -1;
#line 780
  itv->speed = 1000;
#line 783
  itv->vbi.in.type = 4U;
#line 784
  itv->vbi.sliced_in = & itv->vbi.in.fmt.sliced;
#line 787
  sg_init_table((struct scatterlist *)(& itv->udma.SGlist), 704U);
#line 790
  itv->osd_global_alpha_state = 1;
#line 791
  itv->osd_global_alpha = 255U;
#line 794
  atomic_set(& itv->yuv_info.next_dma_frame, -1);
#line 795
  itv->yuv_info.lace_mode = ivtv_yuv_mode;
#line 796
  itv->yuv_info.lace_threshold = ivtv_yuv_threshold;
#line 797
  itv->yuv_info.max_frames_buffered = 3U;
#line 798
  itv->yuv_info.track_osd = 1U;
#line 799
  return (0);
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static void ivtv_init_struct2(struct ivtv *itv ) 
{ 
  int i ;

  {
#line 808
  i = 0;
#line 808
  goto ldv_43313;
  ldv_43312: ;
#line 809
  if ((unsigned int )((unsigned char )(itv->card)->video_inputs[i].video_type) == 0U) {
#line 810
    goto ldv_43311;
  } else {

  }
#line 808
  i = i + 1;
  ldv_43313: ;
#line 808
  if (i <= 4) {
#line 810
    goto ldv_43312;
  } else {

  }
  ldv_43311: 
#line 811
  itv->nof_inputs = (u8 )i;
#line 812
  i = 0;
#line 812
  goto ldv_43316;
  ldv_43315: ;
#line 813
  if ((unsigned int )((unsigned char )(itv->card)->audio_inputs[i].audio_type) == 0U) {
#line 814
    goto ldv_43314;
  } else {

  }
#line 812
  i = i + 1;
  ldv_43316: ;
#line 812
  if (i <= 1) {
#line 814
    goto ldv_43315;
  } else {

  }
  ldv_43314: 
#line 815
  itv->nof_audio_inputs = (u8 )i;
#line 817
  if ((int )(itv->card)->hw_all & 1) {
#line 818
    itv->vbi.sliced_size = 288U;
  } else {
#line 820
    itv->vbi.sliced_size = 64U;
  }
#line 824
  i = 0;
#line 824
  goto ldv_43319;
  ldv_43318: ;
#line 825
  if ((unsigned int )((unsigned char )(itv->card)->video_inputs[i].video_type) == 1U) {
#line 827
    goto ldv_43317;
  } else {

  }
#line 824
  i = i + 1;
  ldv_43319: ;
#line 824
  if ((int )itv->nof_inputs > i) {
#line 826
    goto ldv_43318;
  } else {

  }
  ldv_43317: ;
#line 829
  if ((int )itv->nof_inputs == i) {
#line 830
    i = 0;
  } else {

  }
#line 831
  itv->active_input = (u32 )i;
#line 832
  itv->audio_input = (u32 )(itv->card)->video_inputs[i].audio_index;
#line 833
  return;
}
}
#line 835 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int ivtv_setup_pci(struct ivtv *itv , struct pci_dev *pdev , struct pci_device_id  const  *pci_id ) 
{ 
  u16 cmd ;
  unsigned char pci_latency ;
  int tmp ;
  int tmp___0 ;
  struct resource *tmp___1 ;
  struct resource *tmp___2 ;
  struct resource *tmp___3 ;

  {
#line 841
  if ((ivtv_debug & 2) != 0) {
#line 841
    printk("\016%s:  info: Enabling pci device\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 843
  tmp = pci_enable_device(pdev);
#line 843
  if (tmp != 0) {
#line 844
    printk("\v%s: Can\'t enable device!\n", (char *)(& itv->v4l2_dev.name));
#line 845
    return (-5);
  } else {

  }
#line 847
  tmp___0 = pci_set_dma_mask(pdev, 4294967295ULL);
#line 847
  if (tmp___0 != 0) {
#line 848
    printk("\v%s: No suitable DMA available.\n", (char *)(& itv->v4l2_dev.name));
#line 849
    return (-5);
  } else {

  }
#line 851
  tmp___1 = __request_region(& iomem_resource, itv->base_addr, 8388608ULL, "ivtv encoder",
                             0);
#line 851
  if ((unsigned long )tmp___1 == (unsigned long )((struct resource *)0)) {
#line 852
    printk("\v%s: Cannot request encoder memory region.\n", (char *)(& itv->v4l2_dev.name));
#line 853
    return (-5);
  } else {

  }
#line 856
  tmp___2 = __request_region(& iomem_resource, itv->base_addr + 33554432ULL, 65536ULL,
                             "ivtv registers", 0);
#line 856
  if ((unsigned long )tmp___2 == (unsigned long )((struct resource *)0)) {
#line 858
    printk("\v%s: Cannot request register memory region.\n", (char *)(& itv->v4l2_dev.name));
#line 859
    __release_region(& iomem_resource, itv->base_addr, 8388608ULL);
#line 860
    return (-5);
  } else {

  }
#line 863
  if ((unsigned int )itv->has_cx23415 != 0U) {
#line 863
    tmp___3 = __request_region(& iomem_resource, itv->base_addr + 16777216ULL, 8388608ULL,
                               "ivtv decoder", 0);
#line 863
    if ((unsigned long )tmp___3 == (unsigned long )((struct resource *)0)) {
#line 866
      printk("\v%s: Cannot request decoder memory region.\n", (char *)(& itv->v4l2_dev.name));
#line 867
      __release_region(& iomem_resource, itv->base_addr, 8388608ULL);
#line 868
      __release_region(& iomem_resource, itv->base_addr + 33554432ULL, 65536ULL);
#line 869
      return (-5);
    } else {

    }
  } else {

  }
#line 873
  pci_read_config_word((struct pci_dev  const  *)pdev, 4, & cmd);
#line 874
  if (((int )cmd & 4) == 0) {
#line 875
    if ((ivtv_debug & 2) != 0) {
#line 875
      printk("\016%s:  info: Attempting to enable Bus Mastering\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 876
    pci_set_master(pdev);
#line 877
    pci_read_config_word((struct pci_dev  const  *)pdev, 4, & cmd);
#line 878
    if (((int )cmd & 4) == 0) {
#line 879
      printk("\v%s: Bus Mastering is not enabled\n", (char *)(& itv->v4l2_dev.name));
#line 880
      return (-6);
    } else {

    }
  } else {

  }
#line 883
  if ((ivtv_debug & 2) != 0) {
#line 883
    printk("\016%s:  info: Bus Mastering Enabled.\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 885
  pci_read_config_byte((struct pci_dev  const  *)pdev, 13, & pci_latency);
#line 887
  if ((unsigned int )pci_latency <= 63U && ivtv_pci_latency != 0) {
#line 888
    printk("\016%s: Unreasonably low latency timer, setting to 64 (was %d)\n", (char *)(& itv->v4l2_dev.name),
           (int )pci_latency);
#line 890
    pci_write_config_byte((struct pci_dev  const  *)pdev, 13, 64);
#line 891
    pci_read_config_byte((struct pci_dev  const  *)pdev, 13, & pci_latency);
  } else {

  }
#line 897
  pci_write_config_dword((struct pci_dev  const  *)pdev, 64, 65535U);
#line 899
  if ((ivtv_debug & 2) != 0) {
#line 899
    printk("\016%s:  info: %d (rev %d) at %02x:%02x.%x, irq: %d, latency: %d, memory: 0x%llx\n",
           (char *)(& itv->v4l2_dev.name), (int )pdev->device, (int )pdev->revision,
           (int )(pdev->bus)->number, (pdev->devfn >> 3) & 31U, pdev->devfn & 7U,
           pdev->irq, (int )pci_latency, itv->base_addr);
  } else {

  }
#line 905
  return (0);
}
}
#line 908 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static void ivtv_load_and_init_modules(struct ivtv *itv ) 
{ 
  u32 hw ;
  unsigned int i ;
  u32 device ;
  int tmp ;
  char *tmp___0 ;

  {
#line 910
  hw = (itv->card)->hw_all;
#line 914
  i = 0U;
#line 914
  goto ldv_43335;
  ldv_43334: 
#line 915
  device = (u32 )(1 << (int )i);
#line 917
  if ((device & hw) == 0U) {
#line 918
    goto ldv_43333;
  } else {

  }
#line 919
  if (device == 32768U || device == 128U) {
#line 921
    itv->hw_flags = itv->hw_flags | device;
#line 922
    goto ldv_43333;
  } else {

  }
#line 924
  tmp = ivtv_i2c_register(itv, i);
#line 924
  if (tmp == 0) {
#line 925
    itv->hw_flags = itv->hw_flags | device;
  } else {

  }
  ldv_43333: 
#line 914
  i = i + 1U;
  ldv_43335: ;
#line 914
  if (i <= 31U) {
#line 916
    goto ldv_43334;
  } else {

  }

#line 929
  if ((itv->hw_flags & 4128768U) == 0U) {
#line 930
    ivtv_i2c_new_ir_legacy(itv);
  } else {

  }
#line 932
  if ((int )(itv->card)->hw_all & 1) {
#line 933
    itv->sd_video = ivtv_find_hw(itv, 1U);
  } else
#line 934
  if (((unsigned int )(itv->card)->hw_all & 2048U) != 0U) {
#line 935
    itv->sd_video = ivtv_find_hw(itv, 2048U);
  } else
#line 936
  if (((unsigned int )(itv->card)->hw_all & 256U) != 0U) {
#line 937
    itv->sd_video = ivtv_find_hw(itv, 256U);
  } else {
#line 939
    itv->sd_video = ivtv_find_hw(itv, 2U);
  }
#line 940
  itv->sd_audio = ivtv_find_hw(itv, (itv->card)->hw_audio_ctrl);
#line 941
  itv->sd_muxer = ivtv_find_hw(itv, (itv->card)->hw_muxer);
#line 943
  hw = itv->hw_flags;
#line 945
  if ((int )(itv->card)->type == 11) {
#line 948
    if ((hw & 1536U) == 0U) {
#line 949
      itv->card = ivtv_get_card(30);
    } else
#line 950
    if ((hw & 512U) == 0U) {
#line 951
      itv->card = ivtv_get_card(29);
    } else {

    }
  } else
#line 953
  if ((int )(itv->card)->type == 12 || (int )(itv->card)->type == 13) {
#line 956
    if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 956
      if ((unsigned long )((itv->sd_video)->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->video)->s_crystal_freq != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                               u32  ,
                                                                                                                                                                                                                                               u32  ))0)) {
#line 956
        (*((((itv->sd_video)->ops)->video)->s_crystal_freq))(itv->sd_video, 24576000U,
                                                             1U);
      } else {

      }
    } else {

    }
  } else {

  }
#line 960
  if ((int )hw & 1) {
#line 961
    itv->vbi.raw_decoder_line_size = 1444U;
#line 962
    itv->vbi.raw_decoder_sav_odd_field = 32U;
#line 963
    itv->vbi.raw_decoder_sav_even_field = 96U;
#line 964
    itv->vbi.sliced_decoder_line_size = 272U;
#line 965
    itv->vbi.sliced_decoder_sav_odd_field = 176U;
#line 966
    itv->vbi.sliced_decoder_sav_even_field = 240U;
  } else {

  }
#line 969
  if ((hw & 258U) != 0U) {
#line 971
    itv->hw_flags = itv->hw_flags & 4294967037U;
#line 973
    tmp___0 = strstr((char const   *)(& (itv->sd_video)->name), "saa7114");
#line 973
    if ((unsigned long )tmp___0 != (unsigned long )((char *)0)) {
#line 974
      itv->hw_flags = itv->hw_flags | 256U;
#line 976
      itv->v4l2_cap = itv->v4l2_cap & 4294967215U;
    } else {
#line 978
      itv->hw_flags = itv->hw_flags | 2U;
    }
#line 980
    itv->vbi.raw_decoder_line_size = 1443U;
#line 981
    itv->vbi.raw_decoder_sav_odd_field = 37U;
#line 982
    itv->vbi.raw_decoder_sav_even_field = 98U;
#line 983
    itv->vbi.sliced_decoder_line_size = 51U;
#line 984
    itv->vbi.sliced_decoder_sav_odd_field = 171U;
#line 985
    itv->vbi.sliced_decoder_sav_even_field = 236U;
  } else {

  }
#line 988
  if ((hw & 2048U) != 0U) {
#line 989
    itv->vbi.raw_decoder_line_size = 1443U;
#line 990
    itv->vbi.raw_decoder_sav_odd_field = 37U;
#line 991
    itv->vbi.raw_decoder_sav_even_field = 98U;
#line 992
    itv->vbi.sliced_decoder_line_size = 51U;
#line 993
    itv->vbi.sliced_decoder_sav_odd_field = 171U;
#line 994
    itv->vbi.sliced_decoder_sav_even_field = 236U;
  } else {

  }
#line 996
  return;
}
}
#line 998 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int ivtv_probe(struct pci_dev *pdev , struct pci_device_id  const  *pci_id ) 
{ 
  int retval ;
  int vbi_buf_size ;
  struct ivtv *itv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int i ;
  struct tuner_setup setup ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct xc2028_ctrl ctrl ;
  struct v4l2_priv_tun_config cfg ;
  struct v4l2_subdev *__sd___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct v4l2_ctrl_handler *hdl ;
  struct v4l2_subdev *__sd___1 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  struct v4l2_subdev *__sd___2 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;

  {
#line 1000
  retval = 0;
#line 1004
  tmp = kzalloc(114296UL, 32U);
#line 1004
  itv = (struct ivtv *)tmp;
#line 1005
  if ((unsigned long )itv == (unsigned long )((struct ivtv *)0)) {
#line 1006
    return (-12);
  } else {

  }
#line 1007
  itv->pdev = pdev;
#line 1008
  tmp___0 = v4l2_device_set_name(& itv->v4l2_dev, "ivtv", & ivtv_instance);
#line 1008
  itv->instance = (u16 )tmp___0;
#line 1011
  retval = v4l2_device_register(& pdev->dev, & itv->v4l2_dev);
#line 1012
  if (retval != 0) {
#line 1013
    kfree((void const   *)itv);
#line 1014
    return (retval);
  } else {

  }
#line 1016
  printk("\016%s: Initializing card %d\n", (char *)(& itv->v4l2_dev.name), (int )itv->instance);
#line 1018
  ivtv_process_options(itv);
#line 1019
  if (itv->options.cardtype == -1) {
#line 1020
    retval = -19;
#line 1021
    goto err;
  } else {

  }
#line 1023
  tmp___1 = ivtv_init_struct1(itv);
#line 1023
  if (tmp___1 != 0) {
#line 1024
    retval = -12;
#line 1025
    goto err;
  } else {

  }
#line 1027
  retval = cx2341x_handler_init(& itv->cxhdl, 50U);
#line 1028
  if (retval != 0) {
#line 1029
    goto err;
  } else {

  }
#line 1030
  itv->v4l2_dev.ctrl_handler = & itv->cxhdl.hdl;
#line 1031
  itv->cxhdl.ops = (struct cx2341x_handler_ops  const  *)(& ivtv_cxhdl_ops);
#line 1032
  itv->cxhdl.priv = (void *)itv;
#line 1033
  itv->cxhdl.func = & ivtv_api_func;
#line 1035
  if ((ivtv_debug & 2) != 0) {
#line 1035
    printk("\016%s:  info: base addr: 0x%llx\n", (char *)(& itv->v4l2_dev.name), itv->base_addr);
  } else {

  }
#line 1038
  retval = ivtv_setup_pci(itv, pdev, pci_id);
#line 1039
  if (retval == -5) {
#line 1040
    goto free_worker;
  } else {

  }
#line 1041
  if (retval == -6) {
#line 1042
    goto free_mem;
  } else {

  }
#line 1045
  if ((ivtv_debug & 2) != 0) {
#line 1045
    printk("\016%s:  info: attempting ioremap at 0x%llx len 0x%08x\n", (char *)(& itv->v4l2_dev.name),
           itv->base_addr, 8388608);
  } else {

  }
#line 1047
  tmp___2 = ioremap_nocache(itv->base_addr, 8388608UL);
#line 1047
  itv->enc_mem = (void volatile   *)tmp___2;
#line 1049
  if ((unsigned long )itv->enc_mem == (unsigned long )((void volatile   *)0)) {
#line 1050
    printk("\v%s: ioremap failed. Can\'t get a window into CX23415/6 encoder memory\n",
           (char *)(& itv->v4l2_dev.name));
#line 1052
    printk("\v%s: Each capture card with a CX23415/6 needs 8 MB of vmalloc address space for this window\n",
           (char *)(& itv->v4l2_dev.name));
#line 1054
    printk("\v%s: Check the output of \'grep Vmalloc /proc/meminfo\'\n", (char *)(& itv->v4l2_dev.name));
#line 1055
    printk("\v%s: Use the vmalloc= kernel command line option to set VmallocTotal to a larger value\n",
           (char *)(& itv->v4l2_dev.name));
#line 1057
    retval = -12;
#line 1058
    goto free_mem;
  } else {

  }
#line 1061
  if ((unsigned int )itv->has_cx23415 != 0U) {
#line 1062
    if ((ivtv_debug & 2) != 0) {
#line 1062
      printk("\016%s:  info: attempting ioremap at 0x%llx len 0x%08x\n", (char *)(& itv->v4l2_dev.name),
             itv->base_addr + 16777216ULL, 8388608);
    } else {

    }
#line 1064
    tmp___3 = ioremap_nocache(itv->base_addr + 16777216ULL, 8388608UL);
#line 1064
    itv->dec_mem = (void volatile   *)tmp___3;
#line 1066
    if ((unsigned long )itv->dec_mem == (unsigned long )((void volatile   *)0)) {
#line 1067
      printk("\v%s: ioremap failed. Can\'t get a window into CX23415 decoder memory\n",
             (char *)(& itv->v4l2_dev.name));
#line 1069
      printk("\v%s: Each capture card with a CX23415 needs 8 MB of vmalloc address space for this window\n",
             (char *)(& itv->v4l2_dev.name));
#line 1071
      printk("\v%s: Check the output of \'grep Vmalloc /proc/meminfo\'\n", (char *)(& itv->v4l2_dev.name));
#line 1073
      printk("\v%s: Use the vmalloc= kernel command line option to set VmallocTotal to a larger value\n",
             (char *)(& itv->v4l2_dev.name));
#line 1075
      retval = -12;
#line 1076
      goto free_mem;
    } else {

    }
  } else {
#line 1080
    itv->dec_mem = itv->enc_mem;
  }
#line 1084
  if ((ivtv_debug & 2) != 0) {
#line 1084
    printk("\016%s:  info: attempting ioremap at 0x%llx len 0x%08x\n", (char *)(& itv->v4l2_dev.name),
           itv->base_addr + 33554432ULL, 65536);
  } else {

  }
#line 1086
  tmp___4 = ioremap_nocache(itv->base_addr + 33554432ULL, 65536UL);
#line 1086
  itv->reg_mem = (void volatile   *)tmp___4;
#line 1088
  if ((unsigned long )itv->reg_mem == (unsigned long )((void volatile   *)0)) {
#line 1089
    printk("\v%s: ioremap failed. Can\'t get a window into CX23415/6 register space\n",
           (char *)(& itv->v4l2_dev.name));
#line 1091
    printk("\v%s: Each capture card with a CX23415/6 needs 64 kB of vmalloc address space for this window\n",
           (char *)(& itv->v4l2_dev.name));
#line 1093
    printk("\v%s: Check the output of \'grep Vmalloc /proc/meminfo\'\n", (char *)(& itv->v4l2_dev.name));
#line 1094
    printk("\v%s: Use the vmalloc= kernel command line option to set VmallocTotal to a larger value\n",
           (char *)(& itv->v4l2_dev.name));
#line 1096
    retval = -12;
#line 1097
    goto free_io;
  } else {

  }
#line 1100
  retval = ivtv_gpio_init(itv);
#line 1101
  if (retval != 0) {
#line 1102
    goto free_io;
  } else {

  }
#line 1105
  if ((ivtv_debug & 2) != 0) {
#line 1105
    printk("\016%s:  info: activating i2c...\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1106
  tmp___5 = init_ivtv_i2c(itv);
#line 1106
  if (tmp___5 != 0) {
#line 1107
    printk("\v%s: Could not initialize i2c\n", (char *)(& itv->v4l2_dev.name));
#line 1108
    goto free_io;
  } else {

  }
#line 1111
  if (((unsigned int )(itv->card)->hw_all & 128U) != 0U) {
#line 1114
    ivtv_process_eeprom(itv);
  } else {

  }
#line 1116
  if ((unsigned long )(itv->card)->comment != (unsigned long )((char */* const  */)0)) {
#line 1117
    printk("\016%s: %s", (char *)(& itv->v4l2_dev.name), (itv->card)->comment);
  } else {

  }
#line 1118
  if ((unsigned int )(itv->card)->v4l2_capabilities == 0U) {
#line 1120
    retval = -19;
#line 1121
    goto free_i2c;
  } else {

  }
#line 1124
  if (itv->std == 0ULL) {
#line 1125
    itv->std = 4096ULL;
  } else {

  }
#line 1128
  if (itv->options.tuner == -1) {
#line 1131
    i = 0;
#line 1131
    goto ldv_43353;
    ldv_43352: ;
#line 1132
    if ((itv->std & (unsigned long long )(itv->card)->tuners[i].std) == 0ULL) {
#line 1133
      goto ldv_43350;
    } else {

    }
#line 1134
    itv->options.tuner = (itv->card)->tuners[i].tuner;
#line 1135
    goto ldv_43351;
    ldv_43350: 
#line 1131
    i = i + 1;
    ldv_43353: ;
#line 1131
    if (i <= 2) {
#line 1133
      goto ldv_43352;
    } else {

    }
    ldv_43351: ;
  } else {

  }
#line 1139
  if (itv->options.tuner == -1 && (unsigned long long )(itv->card)->tuners[0].std != 0ULL) {
#line 1140
    itv->std = (itv->card)->tuners[0].std;
#line 1141
    if ((itv->std & 255ULL) != 0ULL) {
#line 1142
      itv->std = 15ULL;
    } else
#line 1143
    if ((itv->std & 45056ULL) != 0ULL) {
#line 1144
      itv->std = 4096ULL;
    } else
#line 1145
    if ((itv->std & 16711680ULL) != 0ULL) {
#line 1146
      itv->std = 4194304ULL;
    } else {

    }
#line 1147
    itv->options.tuner = (itv->card)->tuners[0].tuner;
  } else {

  }
#line 1149
  if (itv->options.radio == -1) {
#line 1150
    itv->options.radio = (unsigned int )((unsigned char )(itv->card)->radio_input.audio_type) != 0U;
  } else {

  }
#line 1154
  ivtv_init_struct2(itv);
#line 1156
  ivtv_load_and_init_modules(itv);
#line 1158
  if ((itv->std & 63744ULL) != 0ULL) {
#line 1159
    itv->is_60hz = 1U;
#line 1160
    itv->is_out_60hz = 1U;
  } else {
#line 1162
    itv->is_50hz = 1U;
#line 1163
    itv->is_out_50hz = 1U;
  }
#line 1166
  itv->yuv_info.osd_full_w = 720U;
#line 1167
  itv->yuv_info.osd_full_h = (unsigned int )itv->is_out_50hz != 0U ? 576U : 480U;
#line 1168
  itv->yuv_info.v4l2_src_w = itv->yuv_info.osd_full_w;
#line 1169
  itv->yuv_info.v4l2_src_h = itv->yuv_info.osd_full_h;
#line 1171
  cx2341x_handler_set_50hz(& itv->cxhdl, (int )itv->is_50hz);
#line 1173
  itv->stream_buf_size[0] = 32768;
#line 1174
  itv->stream_buf_size[3] = 4608;
#line 1175
  itv->stream_buf_size[5] = 65536;
#line 1176
  itv->stream_buf_size[8] = 65536;
#line 1177
  itv->stream_buf_size[1] = 32768;
#line 1183
  itv->vbi.raw_size = 1456U;
#line 1190
  vbi_buf_size = (int )((itv->vbi.raw_size * ((unsigned int )itv->is_60hz != 0U ? 24U : 36U)) / 2U);
#line 1191
  itv->stream_buf_size[2] = vbi_buf_size;
#line 1192
  itv->stream_buf_size[6] = 2304;
#line 1194
  if (itv->options.radio > 0) {
#line 1195
    itv->v4l2_cap = itv->v4l2_cap | 262144U;
  } else {

  }
#line 1197
  if (itv->options.tuner >= 0) {
#line 1200
    setup.addr = 255U;
#line 1201
    setup.type = (unsigned int )itv->options.tuner;
#line 1202
    setup.mode_mask = 4U;
#line 1203
    if (itv->options.radio > 0) {
#line 1204
      setup.mode_mask = setup.mode_mask | 2U;
    } else {

    }
#line 1205
    setup.tuner_callback = setup.type == 71U ? & ivtv_reset_tuner_gpio : (int (*)(void * ,
                                                                                  int  ,
                                                                                  int  ,
                                                                                  int  ))0;
#line 1207
    __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1207
    __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1207
    goto ldv_43361;
    ldv_43360: ;
#line 1207
    if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->s_type_addr != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                    struct tuner_setup * ))0)) {
#line 1207
      (*(((__sd->ops)->tuner)->s_type_addr))(__sd, & setup);
    } else {

    }
#line 1207
    __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1207
    __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
    ldv_43361: ;
#line 1207
    if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1209
      goto ldv_43360;
    } else {

    }

#line 1208
    if (setup.type == 71U) {
#line 1209
      ctrl.fname = (char *)"xc3028-v27.fw";
#line 1209
      ctrl.max_len = 64;
#line 1209
      ctrl.msleep = 0;
#line 1209
      ctrl.scode_table = 0U;
#line 1209
      ctrl.mts = (unsigned char)0;
#line 1209
      ctrl.input1 = (unsigned char)0;
#line 1209
      ctrl.vhfbw7 = (unsigned char)0;
#line 1209
      ctrl.uhfbw8 = (unsigned char)0;
#line 1209
      ctrl.disable_power_mgmt = (unsigned char)0;
#line 1209
      ctrl.read_not_reliable = (unsigned char)0;
#line 1209
      ctrl.demod = 0U;
#line 1209
      ctrl.type = (unsigned char)0;
#line 1213
      cfg.tuner = itv->options.tuner;
#line 1213
      cfg.priv = (void *)(& ctrl);
#line 1217
      __mptr___1 = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1217
      __sd___0 = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff88UL;
#line 1217
      goto ldv_43371;
      ldv_43370: ;
#line 1217
      if ((unsigned long )(__sd___0->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd___0->ops)->tuner)->s_config != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                           struct v4l2_priv_tun_config  const  * ))0)) {
#line 1217
        (*(((__sd___0->ops)->tuner)->s_config))(__sd___0, (struct v4l2_priv_tun_config  const  *)(& cfg));
      } else {

      }
#line 1217
      __mptr___2 = (struct list_head  const  *)__sd___0->list.next;
#line 1217
      __sd___0 = (struct v4l2_subdev *)__mptr___2 + 0xffffffffffffff88UL;
      ldv_43371: ;
#line 1217
      if ((unsigned long )(& __sd___0->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1219
        goto ldv_43370;
      } else {

      }

    } else {

    }
  } else {

  }
#line 1223
  itv->tuner_std = itv->std;
#line 1225
  if ((itv->v4l2_cap & 2U) != 0U) {
#line 1226
    hdl = itv->v4l2_dev.ctrl_handler;
#line 1228
    itv->__annonCompField105.ctrl_pts = v4l2_ctrl_new_std(hdl, & ivtv_hdl_out_ops,
                                                          10029535U, 0LL, 0LL, 0ULL,
                                                          0LL);
#line 1230
    itv->__annonCompField105.ctrl_frame = v4l2_ctrl_new_std(hdl, & ivtv_hdl_out_ops,
                                                            10029536U, 0LL, 0LL, 0ULL,
                                                            0LL);
#line 1234
    itv->__annonCompField106.ctrl_audio_playback = v4l2_ctrl_new_std_menu(hdl, & ivtv_hdl_out_ops,
                                                                          10029424U,
                                                                          5, 1ULL,
                                                                          1);
#line 1240
    itv->__annonCompField106.ctrl_audio_multilingual_playback = v4l2_ctrl_new_std_menu(hdl,
                                                                                       & ivtv_hdl_out_ops,
                                                                                       10029425U,
                                                                                       5,
                                                                                       1ULL,
                                                                                       2);
#line 1246
    if (hdl->error != 0) {
#line 1247
      retval = hdl->error;
#line 1248
      goto free_i2c;
    } else {

    }
#line 1250
    v4l2_ctrl_cluster(2U, & itv->__annonCompField105.ctrl_pts);
#line 1251
    v4l2_ctrl_cluster(2U, & itv->__annonCompField106.ctrl_audio_playback);
#line 1252
    __mptr___3 = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1252
    __sd___1 = (struct v4l2_subdev *)__mptr___3 + 0xffffffffffffff88UL;
#line 1252
    goto ldv_43380;
    ldv_43379: ;
#line 1252
    if ((unsigned long )(__sd___1->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd___1->ops)->video)->s_std_output != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                             v4l2_std_id  ))0)) {
#line 1252
      (*(((__sd___1->ops)->video)->s_std_output))(__sd___1, itv->std);
    } else {

    }
#line 1252
    __mptr___4 = (struct list_head  const  *)__sd___1->list.next;
#line 1252
    __sd___1 = (struct v4l2_subdev *)__mptr___4 + 0xffffffffffffff88UL;
    ldv_43380: ;
#line 1252
    if ((unsigned long )(& __sd___1->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1254
      goto ldv_43379;
    } else {

    }
#line 1256
    __mptr___5 = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1256
    __sd___2 = (struct v4l2_subdev *)__mptr___5 + 0xffffffffffffff88UL;
#line 1256
    goto ldv_43388;
    ldv_43387: ;
#line 1256
    if (((__sd___2->grp_id & 4U) != 0U && (unsigned long )(__sd___2->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0)) && (unsigned long )((__sd___2->ops)->video)->s_stream != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                            int  ))0)) {
#line 1256
      (*(((__sd___2->ops)->video)->s_stream))(__sd___2, 0);
    } else {

    }
#line 1256
    __mptr___6 = (struct list_head  const  *)__sd___2->list.next;
#line 1256
    __sd___2 = (struct v4l2_subdev *)__mptr___6 + 0xffffffffffffff88UL;
    ldv_43388: ;
#line 1256
    if ((unsigned long )(& __sd___2->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1258
      goto ldv_43387;
    } else {

    }

  } else {

  }
#line 1260
  ivtv_set_irq_mask(itv, 4294967295U);
#line 1263
  retval = ldv_request_irq_53((itv->pdev)->irq, & ivtv_irq_handler, 128UL, (char const   *)(& itv->v4l2_dev.name),
                              (void *)itv);
#line 1265
  if (retval != 0) {
#line 1266
    printk("\v%s: Failed to register irq %d\n", (char *)(& itv->v4l2_dev.name), retval);
#line 1267
    goto free_i2c;
  } else {

  }
#line 1270
  retval = ivtv_streams_setup(itv);
#line 1271
  if (retval != 0) {
#line 1272
    printk("\v%s: Error %d setting up streams\n", (char *)(& itv->v4l2_dev.name),
           retval);
#line 1273
    goto free_irq;
  } else {

  }
#line 1275
  retval = ivtv_streams_register(itv);
#line 1276
  if (retval != 0) {
#line 1277
    printk("\v%s: Error %d registering devices\n", (char *)(& itv->v4l2_dev.name),
           retval);
#line 1278
    goto free_streams;
  } else {

  }
#line 1280
  printk("\016%s: Initialized card: %s\n", (char *)(& itv->v4l2_dev.name), itv->card_name);
#line 1283
  request_modules(itv);
#line 1284
  return (0);
  free_streams: 
#line 1287
  ivtv_streams_cleanup(itv);
  free_irq: 
#line 1289
  ldv_free_irq_54((itv->pdev)->irq, (void *)itv);
  free_i2c: 
#line 1291
  v4l2_ctrl_handler_free(& itv->cxhdl.hdl);
#line 1292
  exit_ivtv_i2c(itv);
  free_io: 
#line 1294
  ivtv_iounmap(itv);
  free_mem: 
#line 1296
  __release_region(& iomem_resource, itv->base_addr, 8388608ULL);
#line 1297
  __release_region(& iomem_resource, itv->base_addr + 33554432ULL, 65536ULL);
#line 1298
  if ((unsigned int )itv->has_cx23415 != 0U) {
#line 1299
    __release_region(& iomem_resource, itv->base_addr + 16777216ULL, 8388608ULL);
  } else {

  }
  free_worker: 
#line 1301
  kthread_stop(itv->irq_worker_task);
  err: ;
#line 1303
  if (retval == 0) {
#line 1304
    retval = -19;
  } else {

  }
#line 1305
  printk("\v%s: Error %d on initialization\n", (char *)(& itv->v4l2_dev.name), retval);
#line 1307
  v4l2_device_unregister(& itv->v4l2_dev);
#line 1308
  kfree((void const   *)itv);
#line 1309
  return (retval);
}
}
#line 1312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
int ivtv_init_on_first_open(struct ivtv *itv ) 
{ 
  struct v4l2_frequency vf ;
  struct ivtv_open_id fh ;
  int fw_retry_count ;
  int video_input ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1317
  fw_retry_count = 3;
#line 1320
  fh.itv = itv;
#line 1321
  fh.type = 0;
#line 1323
  tmp = constant_test_bit(22L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1323
  if (tmp != 0) {
#line 1324
    return (-6);
  } else {

  }
#line 1326
  tmp___0 = test_and_set_bit(21L, (unsigned long volatile   *)(& itv->i_flags));
#line 1326
  if (tmp___0 != 0) {
#line 1327
    return (0);
  } else {

  }
#line 1329
  goto ldv_43401;
  ldv_43400: 
#line 1331
  tmp___1 = ivtv_firmware_init(itv);
#line 1331
  if (tmp___1 == 0) {
#line 1332
    goto ldv_43399;
  } else {

  }
#line 1333
  if (fw_retry_count > 1) {
#line 1334
    printk("\f%s: Retry loading firmware\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
  ldv_43401: 
#line 1329
  fw_retry_count = fw_retry_count - 1;
#line 1329
  if (fw_retry_count > 0) {
#line 1331
    goto ldv_43400;
  } else {

  }
  ldv_43399: ;
#line 1337
  if (fw_retry_count == 0) {
#line 1338
    set_bit(22L, (unsigned long volatile   *)(& itv->i_flags));
#line 1339
    return (-6);
  } else {

  }
#line 1343
  if ((ivtv_debug & 2) != 0) {
#line 1343
    printk("\016%s:  info: Getting firmware version..\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1344
  ivtv_firmware_versions(itv);
#line 1346
  if ((int )(itv->card)->hw_all & 1) {
#line 1347
    if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 1347
      if ((unsigned long )((itv->sd_video)->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->core)->load_fw != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 1347
        (*((((itv->sd_video)->ops)->core)->load_fw))(itv->sd_video);
      } else {

      }
    } else {

    }
  } else {

  }
#line 1349
  vf.tuner = 0U;
#line 1350
  vf.type = 2U;
#line 1351
  vf.frequency = 6400U;
#line 1355
  if (itv->std == 8192ULL) {
#line 1356
    vf.frequency = 1460U;
  } else
#line 1358
  if ((itv->std & 4096ULL) != 0ULL) {
#line 1359
    vf.frequency = 1076U;
  } else {

  }
#line 1362
  video_input = (int )itv->active_input;
#line 1363
  itv->active_input = itv->active_input + 1U;
#line 1364
  ivtv_s_input((struct file *)0, (void *)(& fh), (unsigned int )video_input);
#line 1368
  itv->std = itv->std + 1ULL;
#line 1369
  itv->std_out = itv->std;
#line 1370
  ivtv_s_frequency((struct file *)0, (void *)(& fh), (struct v4l2_frequency  const  *)(& vf));
#line 1372
  if (((unsigned int )(itv->card)->v4l2_capabilities & 2U) != 0U) {
#line 1376
    __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1376
    __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1376
    goto ldv_43408;
    ldv_43407: ;
#line 1376
    if (((__sd->grp_id & 4U) != 0U && (unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->video)->s_stream != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                int  ))0)) {
#line 1376
      (*(((__sd->ops)->video)->s_stream))(__sd, 1);
    } else {

    }
#line 1376
    __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1376
    __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
    ldv_43408: ;
#line 1376
    if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1378
      goto ldv_43407;
    } else {

    }
#line 1377
    ivtv_init_mpeg_decoder(itv);
  } else {

  }
#line 1381
  if ((unsigned int )itv->has_cx23415 == 0U) {
#line 1382
    writel(3U, itv->reg_mem + 16UL);
#line 1382
    readl((void const volatile   *)itv->reg_mem + 16U);
  } else {

  }
#line 1384
  ivtv_s_std_enc(itv, itv->tuner_std);
#line 1391
  if ((itv->v4l2_cap & 2U) != 0U) {
#line 1392
    ivtv_clear_irq_mask(itv, 168100864U);
#line 1393
    ivtv_set_osd_alpha(itv);
#line 1394
    ivtv_s_std_dec(itv, itv->tuner_std);
  } else {
#line 1396
    ivtv_clear_irq_mask(itv, 168099840U);
  }
#line 1400
  cx2341x_handler_setup(& itv->cxhdl);
#line 1401
  return (0);
}
}
#line 1404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static void ivtv_remove(struct pci_dev *pdev ) 
{ 
  struct v4l2_device *v4l2_dev ;
  void *tmp ;
  struct ivtv *itv ;
  struct ivtv *tmp___0 ;
  int i ;
  int tmp___1 ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int type ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1406
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1406
  v4l2_dev = (struct v4l2_device *)tmp;
#line 1407
  tmp___0 = to_ivtv(v4l2_dev);
#line 1407
  itv = tmp___0;
#line 1410
  if ((ivtv_debug & 2) != 0) {
#line 1410
    printk("\016%s:  info: Removing card\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1412
  flush_request_modules(itv);
#line 1414
  tmp___4 = constant_test_bit(21L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1414
  if (tmp___4 != 0) {
#line 1416
    if ((ivtv_debug & 2) != 0) {
#line 1416
      printk("\016%s:  info: Stopping all streams\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 1417
    tmp___1 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 1417
    if (tmp___1 > 0) {
#line 1418
      ivtv_stop_all_captures(itv);
    } else {

    }
#line 1421
    if ((ivtv_debug & 2) != 0) {
#line 1421
      printk("\016%s:  info: Stopping decoding\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 1424
    if ((itv->v4l2_cap & 2U) != 0U) {
#line 1425
      __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1425
      __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1425
      goto ldv_43422;
      ldv_43421: ;
#line 1425
      if (((__sd->grp_id & 4U) != 0U && (unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->video)->s_stream != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                  int  ))0)) {
#line 1425
        (*(((__sd->ops)->video)->s_stream))(__sd, 0);
      } else {

      }
#line 1425
      __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1425
      __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
      ldv_43422: ;
#line 1425
      if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1427
        goto ldv_43421;
      } else {

      }

    } else {

    }
#line 1426
    tmp___3 = atomic_read((atomic_t const   *)(& itv->decoding));
#line 1426
    if (tmp___3 > 0) {
#line 1429
      tmp___2 = constant_test_bit(7L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1429
      if (tmp___2 != 0) {
#line 1430
        type = 8;
      } else {
#line 1432
        type = 5;
      }
#line 1433
      ivtv_stop_v4l2_decode_stream((struct ivtv_stream *)(& itv->streams) + (unsigned long )type,
                                   3, 0ULL);
    } else {

    }
#line 1436
    ivtv_halt_firmware(itv);
  } else {

  }
#line 1440
  ivtv_set_irq_mask(itv, 4294967295U);
#line 1441
  ldv_del_timer_sync_55(& itv->dma_timer);
#line 1444
  flush_kthread_worker(& itv->irq_worker);
#line 1445
  kthread_stop(itv->irq_worker_task);
#line 1447
  ivtv_streams_cleanup(itv);
#line 1448
  ivtv_udma_free(itv);
#line 1450
  v4l2_ctrl_handler_free(& itv->cxhdl.hdl);
#line 1452
  exit_ivtv_i2c(itv);
#line 1454
  ldv_free_irq_56((itv->pdev)->irq, (void *)itv);
#line 1455
  ivtv_iounmap(itv);
#line 1457
  __release_region(& iomem_resource, itv->base_addr, 8388608ULL);
#line 1458
  __release_region(& iomem_resource, itv->base_addr + 33554432ULL, 65536ULL);
#line 1459
  if ((unsigned int )itv->has_cx23415 != 0U) {
#line 1460
    __release_region(& iomem_resource, itv->base_addr + 16777216ULL, 8388608ULL);
  } else {

  }
#line 1462
  pci_disable_device(itv->pdev);
#line 1463
  i = 0;
#line 1463
  goto ldv_43426;
  ldv_43425: 
#line 1464
  kfree((void const   *)itv->vbi.sliced_mpeg_data[i]);
#line 1463
  i = i + 1;
  ldv_43426: ;
#line 1463
  if (i <= 31) {
#line 1465
    goto ldv_43425;
  } else {

  }
#line 1466
  printk("\016ivtv: Removed %s\n", itv->card_name);
#line 1468
  v4l2_device_unregister(& itv->v4l2_dev);
#line 1469
  kfree((void const   *)itv);
#line 1470
  return;
}
}
#line 1473 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static struct pci_driver ivtv_pci_driver  = 
#line 1473
     {{0, 0}, "ivtv", (struct pci_device_id  const  *)(& ivtv_pci_tbl), & ivtv_probe,
    & ivtv_remove, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0,
                                         0, 0, 0, 0}, {{{{{{0}}, 0U, 0U, 0, {0, {0,
                                                                                 0},
                                                                             0, 0,
                                                                             0UL}}}},
                                                       {0, 0}}};
#line 1480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static int module_start(void) 
{ 
  int tmp ;

  {
#line 1482
  printk("\016ivtv: Start initialization, version %s\n", (char *)"1.4.3");
#line 1485
  if (ivtv_first_minor < 0 || ivtv_first_minor > 31) {
#line 1486
    printk("\vivtv: Exiting, ivtv_first_minor must be between 0 and %d\n", 31);
#line 1488
    return (-1);
  } else {

  }
#line 1491
  if (ivtv_debug < 0 || ivtv_debug > 2047) {
#line 1492
    ivtv_debug = 0;
#line 1493
    printk("\016ivtv: Debug value must be >= 0 and <= 2047\n");
  } else {

  }
#line 1496
  tmp = ldv___pci_register_driver_57(& ivtv_pci_driver, & __this_module, "ivtv");
#line 1496
  if (tmp != 0) {
#line 1497
    printk("\vivtv: Error detecting PCI card\n");
#line 1498
    return (-19);
  } else {

  }
#line 1500
  printk("\016ivtv: End initialization\n");
#line 1501
  return (0);
}
}
#line 1504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static void module_cleanup(void) 
{ 


  {
#line 1506
  ldv_pci_unregister_driver_58(& ivtv_pci_driver);
#line 1507
  return;
}
}
#line 1511 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_set_irq_mask[18U]  = 
#line 1511
  {      'i',      'v',      't',      'v', 
        '_',      's',      'e',      't', 
        '_',      'i',      'r',      'q', 
        '_',      'm',      'a',      's', 
        'k',      '\000'};
#line 1511
struct kernel_symbol  const  __ksymtab_ivtv_set_irq_mask ;
#line 1511 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_set_irq_mask  =    {(unsigned long )(& ivtv_set_irq_mask), (char const   *)(& __kstrtab_ivtv_set_irq_mask)};
#line 1512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_api[9U]  = 
#line 1512
  {      'i',      'v',      't',      'v', 
        '_',      'a',      'p',      'i', 
        '\000'};
#line 1512
struct kernel_symbol  const  __ksymtab_ivtv_api ;
#line 1512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_api  =    {(unsigned long )(& ivtv_api), (char const   *)(& __kstrtab_ivtv_api)};
#line 1513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_vapi[10U]  = 
#line 1513
  {      'i',      'v',      't',      'v', 
        '_',      'v',      'a',      'p', 
        'i',      '\000'};
#line 1513
struct kernel_symbol  const  __ksymtab_ivtv_vapi ;
#line 1513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_vapi  =    {(unsigned long )(& ivtv_vapi), (char const   *)(& __kstrtab_ivtv_vapi)};
#line 1514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_vapi_result[17U]  = 
#line 1514
  {      'i',      'v',      't',      'v', 
        '_',      'v',      'a',      'p', 
        'i',      '_',      'r',      'e', 
        's',      'u',      'l',      't', 
        '\000'};
#line 1514
struct kernel_symbol  const  __ksymtab_ivtv_vapi_result ;
#line 1514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_vapi_result  =    {(unsigned long )(& ivtv_vapi_result), (char const   *)(& __kstrtab_ivtv_vapi_result)};
#line 1515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_clear_irq_mask[20U]  = 
#line 1515
  {      'i',      'v',      't',      'v', 
        '_',      'c',      'l',      'e', 
        'a',      'r',      '_',      'i', 
        'r',      'q',      '_',      'm', 
        'a',      's',      'k',      '\000'};
#line 1515
struct kernel_symbol  const  __ksymtab_ivtv_clear_irq_mask ;
#line 1515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_clear_irq_mask  =    {(unsigned long )(& ivtv_clear_irq_mask), (char const   *)(& __kstrtab_ivtv_clear_irq_mask)};
#line 1516 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_debug[11U]  = 
#line 1516
  {      'i',      'v',      't',      'v', 
        '_',      'd',      'e',      'b', 
        'u',      'g',      '\000'};
#line 1516
struct kernel_symbol  const  __ksymtab_ivtv_debug ;
#line 1516 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_debug  =    {(unsigned long )(& ivtv_debug), (char const   *)(& __kstrtab_ivtv_debug)};
#line 1518 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_fw_debug[14U]  = 
#line 1518
  {      'i',      'v',      't',      'v', 
        '_',      'f',      'w',      '_', 
        'd',      'e',      'b',      'u', 
        'g',      '\000'};
#line 1518
struct kernel_symbol  const  __ksymtab_ivtv_fw_debug ;
#line 1518 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_fw_debug  =    {(unsigned long )(& ivtv_fw_debug), (char const   *)(& __kstrtab_ivtv_fw_debug)};
#line 1520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_reset_ir_gpio[19U]  = 
#line 1520
  {      'i',      'v',      't',      'v', 
        '_',      'r',      'e',      's', 
        'e',      't',      '_',      'i', 
        'r',      '_',      'g',      'p', 
        'i',      'o',      '\000'};
#line 1520
struct kernel_symbol  const  __ksymtab_ivtv_reset_ir_gpio ;
#line 1520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_reset_ir_gpio  =    {(unsigned long )(& ivtv_reset_ir_gpio), (char const   *)(& __kstrtab_ivtv_reset_ir_gpio)};
#line 1521 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_udma_setup[16U]  = 
#line 1521
  {      'i',      'v',      't',      'v', 
        '_',      'u',      'd',      'm', 
        'a',      '_',      's',      'e', 
        't',      'u',      'p',      '\000'};
#line 1521
struct kernel_symbol  const  __ksymtab_ivtv_udma_setup ;
#line 1521 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_udma_setup  =    {(unsigned long )(& ivtv_udma_setup), (char const   *)(& __kstrtab_ivtv_udma_setup)};
#line 1522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_udma_unmap[16U]  = 
#line 1522
  {      'i',      'v',      't',      'v', 
        '_',      'u',      'd',      'm', 
        'a',      '_',      'u',      'n', 
        'm',      'a',      'p',      '\000'};
#line 1522
struct kernel_symbol  const  __ksymtab_ivtv_udma_unmap ;
#line 1522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_udma_unmap  =    {(unsigned long )(& ivtv_udma_unmap), (char const   *)(& __kstrtab_ivtv_udma_unmap)};
#line 1523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_udma_alloc[16U]  = 
#line 1523
  {      'i',      'v',      't',      'v', 
        '_',      'u',      'd',      'm', 
        'a',      '_',      'a',      'l', 
        'l',      'o',      'c',      '\000'};
#line 1523
struct kernel_symbol  const  __ksymtab_ivtv_udma_alloc ;
#line 1523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_udma_alloc  =    {(unsigned long )(& ivtv_udma_alloc), (char const   *)(& __kstrtab_ivtv_udma_alloc)};
#line 1524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_udma_prepare[18U]  = 
#line 1524
  {      'i',      'v',      't',      'v', 
        '_',      'u',      'd',      'm', 
        'a',      '_',      'p',      'r', 
        'e',      'p',      'a',      'r', 
        'e',      '\000'};
#line 1524
struct kernel_symbol  const  __ksymtab_ivtv_udma_prepare ;
#line 1524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_udma_prepare  =    {(unsigned long )(& ivtv_udma_prepare), (char const   *)(& __kstrtab_ivtv_udma_prepare)};
#line 1525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_init_on_first_open[24U]  = 
#line 1525
  {      'i',      'v',      't',      'v', 
        '_',      'i',      'n',      'i', 
        't',      '_',      'o',      'n', 
        '_',      'f',      'i',      'r', 
        's',      't',      '_',      'o', 
        'p',      'e',      'n',      '\000'};
#line 1525
struct kernel_symbol  const  __ksymtab_ivtv_init_on_first_open ;
#line 1525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_init_on_first_open  =    {(unsigned long )(& ivtv_init_on_first_open), (char const   *)(& __kstrtab_ivtv_init_on_first_open)};
#line 1526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
static char const   __kstrtab_ivtv_firmware_check[20U]  = 
#line 1526
  {      'i',      'v',      't',      'v', 
        '_',      'f',      'i',      'r', 
        'm',      'w',      'a',      'r', 
        'e',      '_',      'c',      'h', 
        'e',      'c',      'k',      '\000'};
#line 1526
struct kernel_symbol  const  __ksymtab_ivtv_firmware_check ;
#line 1526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.c"
struct kernel_symbol  const  __ksymtab_ivtv_firmware_check  =    {(unsigned long )(& ivtv_firmware_check), (char const   *)(& __kstrtab_ivtv_firmware_check)};
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_retval_0  ;
#line 116
extern void ldv_initialize(void) ;
#line 117
extern int ldv_shutdown_15(void) ;
#line 118
void ldv_check_final_state(void) ;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_retval_2  ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void work_init_2(void) 
{ 


  {
#line 123
  ldv_work_2_0 = 0;
#line 124
  ldv_work_2_1 = 0;
#line 125
  ldv_work_2_2 = 0;
#line 126
  ldv_work_2_3 = 0;
#line 127
  return;
}
}
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void choose_timer_3(struct timer_list *timer ) 
{ 


  {
#line 131
  LDV_IN_INTERRUPT = 2;
#line 132
  (*(timer->function))(timer->data);
#line 133
  LDV_IN_INTERRUPT = 1;
#line 134
  ldv_timer_state_3 = 2;
#line 135
  return;
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void call_and_disable_all_2(int state ) 
{ 


  {
#line 140
  if (ldv_work_2_0 == state) {
#line 141
    call_and_disable_work_2(ldv_work_struct_2_0);
  } else {

  }
#line 142
  if (ldv_work_2_1 == state) {
#line 143
    call_and_disable_work_2(ldv_work_struct_2_1);
  } else {

  }
#line 144
  if (ldv_work_2_2 == state) {
#line 145
    call_and_disable_work_2(ldv_work_struct_2_2);
  } else {

  }
#line 146
  if (ldv_work_2_3 == state) {
#line 147
    call_and_disable_work_2(ldv_work_struct_2_3);
  } else {

  }
#line 148
  return;
}
}
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 152
  if ((unsigned long )handler == (unsigned long )(& ivtv_irq_handler)) {
#line 153
    return (1);
  } else {

  }
#line 155
  return (0);
}
}
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void ldv_pci_driver_15(void) 
{ 
  void *tmp ;

  {
#line 160
  tmp = ldv_init_zalloc(2976UL);
#line 160
  ivtv_pci_driver_group1 = (struct pci_dev *)tmp;
#line 161
  return;
}
}
#line 164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void activate_work_2(struct work_struct *work , int state ) 
{ 


  {
#line 165
  if (ldv_work_2_0 == 0) {
#line 166
    ldv_work_struct_2_0 = work;
#line 167
    ldv_work_2_0 = state;
#line 168
    return;
  } else {

  }
#line 171
  if (ldv_work_2_1 == 0) {
#line 172
    ldv_work_struct_2_1 = work;
#line 173
    ldv_work_2_1 = state;
#line 174
    return;
  } else {

  }
#line 177
  if (ldv_work_2_2 == 0) {
#line 178
    ldv_work_struct_2_2 = work;
#line 179
    ldv_work_2_2 = state;
#line 180
    return;
  } else {

  }
#line 183
  if (ldv_work_2_3 == 0) {
#line 184
    ldv_work_struct_2_3 = work;
#line 185
    ldv_work_2_3 = state;
#line 186
    return;
  } else {

  }
#line 188
  return;
}
}
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void choose_interrupt_1(void) 
{ 
  int tmp ;

  {
#line 192
  tmp = __VERIFIER_nondet_int();
#line 192
  switch (tmp) {
  case 0: 
#line 194
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_0, ldv_irq_line_1_0, ldv_irq_data_1_0);
#line 196
  goto ldv_43567;
  case 1: 
#line 198
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_1, ldv_irq_line_1_1, ldv_irq_data_1_1);
#line 200
  goto ldv_43567;
  case 2: 
#line 202
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_2, ldv_irq_line_1_2, ldv_irq_data_1_2);
#line 204
  goto ldv_43567;
  case 3: 
#line 206
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_3, ldv_irq_line_1_3, ldv_irq_data_1_3);
#line 208
  goto ldv_43567;
  default: 
#line 209
  ldv_stop();
  }
  ldv_43567: ;
#line 211
  return;
}
}
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void disable_suitable_timer_3(struct timer_list *timer ) 
{ 


  {
#line 216
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_3) {
#line 217
    ldv_timer_state_3 = 0;
#line 218
    return;
  } else {

  }
#line 220
  return;
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void disable_work_2(struct work_struct *work ) 
{ 


  {
#line 225
  if ((ldv_work_2_0 == 3 || ldv_work_2_0 == 2) && (unsigned long )ldv_work_struct_2_0 == (unsigned long )work) {
#line 227
    ldv_work_2_0 = 1;
  } else {

  }
#line 229
  if ((ldv_work_2_1 == 3 || ldv_work_2_1 == 2) && (unsigned long )ldv_work_struct_2_1 == (unsigned long )work) {
#line 231
    ldv_work_2_1 = 1;
  } else {

  }
#line 233
  if ((ldv_work_2_2 == 3 || ldv_work_2_2 == 2) && (unsigned long )ldv_work_struct_2_2 == (unsigned long )work) {
#line 235
    ldv_work_2_2 = 1;
  } else {

  }
#line 237
  if ((ldv_work_2_3 == 3 || ldv_work_2_3 == 2) && (unsigned long )ldv_work_struct_2_3 == (unsigned long )work) {
#line 239
    ldv_work_2_3 = 1;
  } else {

  }
#line 240
  return;
}
}
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void disable_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 245
  if (ldv_irq_1_0 != 0 && line == ldv_irq_line_1_0) {
#line 246
    ldv_irq_1_0 = 0;
#line 247
    return;
  } else {

  }
#line 249
  if (ldv_irq_1_1 != 0 && line == ldv_irq_line_1_1) {
#line 250
    ldv_irq_1_1 = 0;
#line 251
    return;
  } else {

  }
#line 253
  if (ldv_irq_1_2 != 0 && line == ldv_irq_line_1_2) {
#line 254
    ldv_irq_1_2 = 0;
#line 255
    return;
  } else {

  }
#line 257
  if (ldv_irq_1_3 != 0 && line == ldv_irq_line_1_3) {
#line 258
    ldv_irq_1_3 = 0;
#line 259
    return;
  } else {

  }
#line 261
  return;
}
}
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_irq_1(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 267
  tmp = __VERIFIER_nondet_int();
#line 267
  irq_retval = (irqreturn_t )tmp;
#line 269
  if (state != 0) {
#line 270
    tmp___0 = __VERIFIER_nondet_int();
#line 270
    switch (tmp___0) {
    case 0: ;
#line 272
    if (state == 1) {
#line 273
      LDV_IN_INTERRUPT = 2;
#line 274
      irq_retval = ivtv_irq_handler(line, data);
#line 275
      LDV_IN_INTERRUPT = 1;
#line 276
      return (state);
    } else {

    }
#line 279
    goto ldv_43589;
    default: 
#line 280
    ldv_stop();
    }
    ldv_43589: ;
  } else {

  }
#line 283
  return (state);
}
}
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void activate_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 288
  if (ldv_irq_1_0 == 0) {
#line 289
    ldv_irq_line_1_0 = line;
#line 290
    ldv_irq_data_1_0 = data;
#line 291
    ldv_irq_1_0 = 1;
#line 292
    return;
  } else {

  }
#line 294
  if (ldv_irq_1_1 == 0) {
#line 295
    ldv_irq_line_1_1 = line;
#line 296
    ldv_irq_data_1_1 = data;
#line 297
    ldv_irq_1_1 = 1;
#line 298
    return;
  } else {

  }
#line 300
  if (ldv_irq_1_2 == 0) {
#line 301
    ldv_irq_line_1_2 = line;
#line 302
    ldv_irq_data_1_2 = data;
#line 303
    ldv_irq_1_2 = 1;
#line 304
    return;
  } else {

  }
#line 306
  if (ldv_irq_1_3 == 0) {
#line 307
    ldv_irq_line_1_3 = line;
#line 308
    ldv_irq_data_1_3 = data;
#line 309
    ldv_irq_1_3 = 1;
#line 310
    return;
  } else {

  }
#line 312
  return;
}
}
#line 316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void activate_pending_timer_3(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 316
  if ((unsigned long )ldv_timer_list_3 == (unsigned long )timer) {
#line 317
    if (ldv_timer_state_3 == 2 || pending_flag != 0) {
#line 318
      ldv_timer_list_3 = timer;
#line 319
      ldv_timer_list_3->data = data;
#line 320
      ldv_timer_state_3 = 1;
    } else {

    }
#line 322
    return;
  } else {

  }
#line 324
  reg_timer_3(timer);
#line 325
  ldv_timer_list_3->data = data;
#line 326
  return;
}
}
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int reg_timer_3(struct timer_list *timer ) 
{ 


  {
#line 331
  ldv_timer_list_3 = timer;
#line 332
  ldv_timer_state_3 = 1;
#line 333
  return (0);
}
}
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void call_and_disable_work_2(struct work_struct *work ) 
{ 


  {
#line 339
  if ((ldv_work_2_0 == 2 || ldv_work_2_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_0) {
#line 341
    request_module_async(work);
#line 342
    ldv_work_2_0 = 1;
#line 343
    return;
  } else {

  }
#line 345
  if ((ldv_work_2_1 == 2 || ldv_work_2_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_1) {
#line 347
    request_module_async(work);
#line 348
    ldv_work_2_1 = 1;
#line 349
    return;
  } else {

  }
#line 351
  if ((ldv_work_2_2 == 2 || ldv_work_2_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_2) {
#line 353
    request_module_async(work);
#line 354
    ldv_work_2_2 = 1;
#line 355
    return;
  } else {

  }
#line 357
  if ((ldv_work_2_3 == 2 || ldv_work_2_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_3) {
#line 359
    request_module_async(work);
#line 360
    ldv_work_2_3 = 1;
#line 361
    return;
  } else {

  }
#line 363
  return;
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void invoke_work_2(void) 
{ 
  int tmp ;

  {
#line 368
  tmp = __VERIFIER_nondet_int();
#line 368
  switch (tmp) {
  case 0: ;
#line 370
  if (ldv_work_2_0 == 2 || ldv_work_2_0 == 3) {
#line 371
    ldv_work_2_0 = 4;
#line 372
    request_module_async(ldv_work_struct_2_0);
#line 373
    ldv_work_2_0 = 1;
  } else {

  }
#line 376
  goto ldv_43616;
  case 1: ;
#line 378
  if (ldv_work_2_1 == 2 || ldv_work_2_1 == 3) {
#line 379
    ldv_work_2_1 = 4;
#line 380
    request_module_async(ldv_work_struct_2_0);
#line 381
    ldv_work_2_1 = 1;
  } else {

  }
#line 384
  goto ldv_43616;
  case 2: ;
#line 386
  if (ldv_work_2_2 == 2 || ldv_work_2_2 == 3) {
#line 387
    ldv_work_2_2 = 4;
#line 388
    request_module_async(ldv_work_struct_2_0);
#line 389
    ldv_work_2_2 = 1;
  } else {

  }
#line 392
  goto ldv_43616;
  case 3: ;
#line 394
  if (ldv_work_2_3 == 2 || ldv_work_2_3 == 3) {
#line 395
    ldv_work_2_3 = 4;
#line 396
    request_module_async(ldv_work_struct_2_0);
#line 397
    ldv_work_2_3 = 1;
  } else {

  }
#line 400
  goto ldv_43616;
  default: 
#line 401
  ldv_stop();
  }
  ldv_43616: ;
#line 403
  return;
}
}
#line 408
void ldv_main_exported_7(void) ;
#line 409
void ldv_main_exported_6(void) ;
#line 410
void ldv_main_exported_4(void) ;
#line 411
void ldv_main_exported_5(void) ;
#line 412
void ldv_main_exported_11(void) ;
#line 413
void ldv_main_exported_13(void) ;
#line 414
void ldv_main_exported_10(void) ;
#line 415
void ldv_main_exported_12(void) ;
#line 416
void ldv_main_exported_14(void) ;
#line 419
void ldv_main_exported_8(void) ;
#line 420
void ldv_main_exported_9(void) ;
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int main(void) 
{ 
  struct pci_device_id *ldvarg105 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 429
  tmp = ldv_init_zalloc(32UL);
#line 429
  ldvarg105 = (struct pci_device_id *)tmp;
#line 427
  ldv_initialize();
#line 431
  ldv_state_variable_11 = 0;
#line 432
  ldv_state_variable_7 = 0;
#line 433
  ldv_state_variable_17 = 0;
#line 435
  work_init_2();
#line 437
  ldv_state_variable_2 = 1;
#line 439
  ldv_state_variable_1 = 1;
#line 440
  ref_cnt = 0;
#line 441
  ldv_state_variable_0 = 1;
#line 442
  ldv_state_variable_16 = 0;
#line 443
  ldv_state_variable_13 = 0;
#line 444
  ldv_state_variable_6 = 0;
#line 446
  ldv_state_variable_3 = 1;
#line 447
  ldv_state_variable_9 = 0;
#line 448
  ldv_state_variable_12 = 0;
#line 449
  ldv_state_variable_14 = 0;
#line 450
  ldv_state_variable_15 = 0;
#line 451
  ldv_state_variable_8 = 0;
#line 452
  ldv_state_variable_4 = 0;
#line 453
  ldv_state_variable_10 = 0;
#line 454
  ldv_state_variable_5 = 0;
  ldv_43685: 
#line 456
  tmp___0 = __VERIFIER_nondet_int();
#line 456
  switch (tmp___0) {
  case 0: ;
#line 460
  if (ldv_state_variable_11 != 0) {
#line 461
    ldv_main_exported_11();
  } else {

  }
#line 464
  goto ldv_43656;
  case 1: ;
#line 468
  if (ldv_state_variable_7 != 0) {
#line 469
    ldv_main_exported_7();
  } else {

  }
#line 472
  goto ldv_43656;
  case 2: ;
#line 476
  if (ldv_state_variable_17 != 0) {
#line 477
    ldv_main_exported_17();
  } else {

  }
#line 480
  goto ldv_43656;
  case 3: ;
#line 484
  if (ldv_state_variable_2 != 0) {
#line 485
    invoke_work_2();
  } else {

  }
#line 488
  goto ldv_43656;
  case 4: ;
#line 492
  if (ldv_state_variable_1 != 0) {
#line 493
    choose_interrupt_1();
  } else {

  }
#line 496
  goto ldv_43656;
  case 5: ;
#line 500
  if (ldv_state_variable_0 != 0) {
#line 501
    tmp___1 = __VERIFIER_nondet_int();
#line 501
    switch (tmp___1) {
    case 0: ;
#line 504
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 506
      module_cleanup();
#line 507
      ldv_state_variable_0 = 2;
#line 508
      goto ldv_final;
    } else {

    }
#line 511
    goto ldv_43664;
    case 1: ;
#line 514
    if (ldv_state_variable_0 == 1) {
#line 516
      ldv_retval_0 = module_start();
#line 518
      if (ldv_retval_0 == 0) {
#line 519
        ldv_state_variable_0 = 3;
#line 520
        ldv_state_variable_5 = 1;
#line 521
        ldv_initialize_v4l2_file_operations_5();
#line 522
        ldv_state_variable_10 = 1;
#line 523
        ldv_state_variable_13 = 1;
#line 524
        ldv_initialize_v4l2_subdev_core_ops_13();
#line 525
        ldv_state_variable_16 = 1;
#line 526
        ldv_initialize_v4l2_ctrl_ops_16();
#line 527
        ldv_state_variable_4 = 1;
#line 528
        ldv_initialize_v4l2_file_operations_4();
#line 529
        ldv_state_variable_8 = 1;
#line 530
        ldv_state_variable_14 = 1;
#line 531
        ldv_state_variable_12 = 1;
#line 532
        ldv_initialize_v4l2_subdev_tuner_ops_12();
#line 533
        ldv_state_variable_17 = 1;
#line 534
        ldv_initialize_cx2341x_handler_ops_17();
#line 535
        ldv_state_variable_9 = 1;
#line 536
        ldv_initialize_i2c_algorithm_9();
#line 537
        ldv_state_variable_7 = 1;
#line 538
        ldv_initialize_v4l2_ioctl_ops_7();
#line 539
        ldv_state_variable_11 = 1;
#line 540
        ldv_initialize_v4l2_subdev_audio_ops_11();
#line 541
        ldv_state_variable_6 = 1;
#line 542
        ldv_initialize_v4l2_file_operations_6();
      } else {

      }
#line 544
      if (ldv_retval_0 != 0) {
#line 545
        ldv_state_variable_0 = 2;
#line 546
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 550
    goto ldv_43664;
    default: 
#line 551
    ldv_stop();
    }
    ldv_43664: ;
  } else {

  }
#line 555
  goto ldv_43656;
  case 6: ;
#line 559
  if (ldv_state_variable_16 != 0) {
#line 560
    ldv_main_exported_16();
  } else {

  }
#line 563
  goto ldv_43656;
  case 7: ;
#line 567
  if (ldv_state_variable_13 != 0) {
#line 568
    ldv_main_exported_13();
  } else {

  }
#line 571
  goto ldv_43656;
  case 8: ;
#line 575
  if (ldv_state_variable_6 != 0) {
#line 576
    ldv_main_exported_6();
  } else {

  }
#line 579
  goto ldv_43656;
  case 9: ;
#line 583
  if (ldv_state_variable_3 != 0) {
#line 584
    choose_timer_3(ldv_timer_list_3);
  } else {

  }
#line 587
  goto ldv_43656;
  case 10: ;
#line 591
  if (ldv_state_variable_9 != 0) {
#line 592
    ldv_main_exported_9();
  } else {

  }
#line 595
  goto ldv_43656;
  case 11: ;
#line 599
  if (ldv_state_variable_12 != 0) {
#line 600
    ldv_main_exported_12();
  } else {

  }
#line 603
  goto ldv_43656;
  case 12: ;
#line 607
  if (ldv_state_variable_14 != 0) {
#line 608
    ldv_main_exported_14();
  } else {

  }
#line 611
  goto ldv_43656;
  case 13: ;
#line 615
  if (ldv_state_variable_15 != 0) {
#line 616
    tmp___2 = __VERIFIER_nondet_int();
#line 616
    switch (tmp___2) {
    case 0: ;
#line 619
    if (ldv_state_variable_15 == 1) {
#line 621
      ldv_retval_2 = ivtv_probe(ivtv_pci_driver_group1, (struct pci_device_id  const  *)ldvarg105);
#line 622
      if (ldv_retval_2 == 0) {
#line 623
        ldv_state_variable_15 = 2;
#line 624
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 628
    goto ldv_43676;
    case 1: ;
#line 631
    if (ldv_state_variable_15 == 2) {
#line 633
      ivtv_remove(ivtv_pci_driver_group1);
#line 634
      ldv_state_variable_15 = 1;
    } else {

    }
#line 637
    goto ldv_43676;
    case 2: ;
#line 640
    if (ldv_state_variable_15 == 2) {
#line 642
      ldv_shutdown_15();
#line 643
      ldv_state_variable_15 = 2;
    } else {

    }
#line 646
    goto ldv_43676;
    default: 
#line 647
    ldv_stop();
    }
    ldv_43676: ;
  } else {

  }
#line 651
  goto ldv_43656;
  case 14: ;
#line 655
  if (ldv_state_variable_8 != 0) {
#line 656
    ldv_main_exported_8();
  } else {

  }
#line 659
  goto ldv_43656;
  case 15: ;
#line 663
  if (ldv_state_variable_4 != 0) {
#line 664
    ldv_main_exported_4();
  } else {

  }
#line 667
  goto ldv_43656;
  case 16: ;
#line 671
  if (ldv_state_variable_10 != 0) {
#line 672
    ldv_main_exported_10();
  } else {

  }
#line 675
  goto ldv_43656;
  case 17: ;
#line 679
  if (ldv_state_variable_5 != 0) {
#line 680
    ldv_main_exported_5();
  } else {

  }
#line 683
  goto ldv_43656;
  default: 
#line 684
  ldv_stop();
  }
  ldv_43656: ;
#line 686
  goto ldv_43685;
  ldv_final: 
#line 688
  ldv_check_final_state();
#line 689
  return 0;
}
}
#line 704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 707
  tmp = ldv_is_err(ptr);
#line 707
  return (tmp);
}
}
#line 716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
bool ldv_queue_work_on_47(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 720
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 720
  ldv_func_res = tmp;
#line 722
  activate_work_2(ldv_func_arg3, 2);
#line 724
  return (ldv_func_res);
}
}
#line 727 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
bool ldv_queue_delayed_work_on_48(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 731
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 731
  ldv_func_res = tmp;
#line 733
  activate_work_2(& ldv_func_arg3->work, 2);
#line 735
  return (ldv_func_res);
}
}
#line 738 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
bool ldv_queue_work_on_49(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 742
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 742
  ldv_func_res = tmp;
#line 744
  activate_work_2(ldv_func_arg3, 2);
#line 746
  return (ldv_func_res);
}
}
#line 749 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void ldv_flush_workqueue_50(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 752
  flush_workqueue(ldv_func_arg1);
#line 754
  call_and_disable_all_2(2);
#line 755
  return;
}
}
#line 757 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
bool ldv_queue_delayed_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 761
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 761
  ldv_func_res = tmp;
#line 763
  activate_work_2(& ldv_func_arg3->work, 2);
#line 765
  return (ldv_func_res);
}
}
#line 768 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
bool ldv_flush_work_52(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 772
  tmp = flush_work(ldv_func_arg1);
#line 772
  ldv_func_res = tmp;
#line 774
  call_and_disable_work_2(ldv_func_arg1);
#line 776
  return (ldv_func_res);
}
}
#line 779 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
__inline static int ldv_request_irq_53(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 783
  tmp = request_irq(irq, handler, flags, name, dev);
#line 783
  ldv_func_res = tmp;
#line 785
  tmp___0 = reg_check_1(handler);
#line 785
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 786
    activate_suitable_irq_1((int )irq, dev);
  } else {

  }
#line 789
  return (ldv_func_res);
}
}
#line 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void ldv_free_irq_54(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 795
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 797
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
#line 798
  return;
}
}
#line 800 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv_del_timer_sync_55(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 804
  tmp = del_timer_sync(ldv_func_arg1);
#line 804
  ldv_func_res = tmp;
#line 806
  disable_suitable_timer_3(ldv_func_arg1);
#line 808
  return (ldv_func_res);
}
}
#line 811 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void ldv_free_irq_56(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 814
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 816
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
#line 817
  return;
}
}
#line 819 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
int ldv___pci_register_driver_57(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 823
  tmp = __pci_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 823
  ldv_func_res = tmp;
#line 825
  ldv_state_variable_15 = 1;
#line 826
  ldv_pci_driver_15();
#line 829
  return (ldv_func_res);
}
}
#line 832 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-driver.o.c.prepared"
void ldv_pci_unregister_driver_58(struct pci_driver *ldv_func_arg1 ) 
{ 


  {
#line 835
  pci_unregister_driver(ldv_func_arg1);
#line 837
  ldv_state_variable_15 = 0;
#line 838
  return;
}
}
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 250 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 252
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 252
  return ((int )((signed char )c) != 0);
}
}
#line 248 "include/linux/kernel.h"
extern void __might_fault(char const   * , int  ) ;
#line 187 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 111 "include/linux/string.h"
extern void *memchr(void const   * , int  , __kernel_size_t  ) ;
#line 138 "include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 141
extern int mutex_lock_interruptible_nested(struct mutex * , unsigned int  ) ;
#line 174
extern void mutex_unlock(struct mutex * ) ;
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_75(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_77(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_76(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_79(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_78(struct workqueue_struct *ldv_func_arg1 ) ;
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 2847 "include/linux/sched.h"
__inline static int signal_pending___0(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 2849
  tmp = test_tsk_thread_flag(p, 2);
#line 2849
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2849
  return ((int )tmp___0);
}
}
#line 832 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 835
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 836
    return ((char const   *)dev->init_name);
  } else {

  }
#line 838
  tmp = kobject_name(& dev->kobj);
#line 838
  return (tmp);
}
}
#line 652 "./arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 677
extern void __copy_to_user_overflow(void) ;
#line 728 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 730
  tmp = __builtin_object_size(from, 0);
#line 730
  sz = (int )tmp;
#line 732
  __might_fault("./arch/x86/include/asm/uaccess.h", 732);
#line 735
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
#line 735
  if (tmp___0 != 0L) {
#line 736
    n = _copy_to_user(to, from, (unsigned int )n);
  } else {
#line 740
    __copy_to_user_overflow();
  }
#line 742
  return (n);
}
}
#line 42 "include/linux/poll.h"
__inline static void poll_wait(struct file *filp , wait_queue_head_t *wait_address ,
                               poll_table *p ) 
{ 


  {
#line 44
  if (((unsigned long )p != (unsigned long )((poll_table *)0) && (unsigned long )p->_qproc != (unsigned long )((void (*)(struct file * ,
                                                                                                                         wait_queue_head_t * ,
                                                                                                                         struct poll_table_struct * ))0)) && (unsigned long )wait_address != (unsigned long )((wait_queue_head_t *)0)) {
#line 45
    (*(p->_qproc))(filp, wait_address, p);
  } else {

  }
#line 46
  return;
}
}
#line 64 "include/linux/poll.h"
__inline static unsigned long poll_requested_events(poll_table const   *p ) 
{ 


  {
#line 66
  return ((unsigned long )p != (unsigned long )((poll_table const   *)0) ? (unsigned long )p->_key : 0xffffffffffffffffUL);
}
}
#line 207 "include/media/v4l2-dev.h"
__inline static void *video_get_drvdata(struct video_device *vdev ) 
{ 
  void *tmp ;

  {
#line 209
  tmp = dev_get_drvdata((struct device  const  *)(& vdev->dev));
#line 209
  return (tmp);
}
}
#line 217
extern struct video_device *video_devdata(struct file * ) ;
#line 226 "include/media/v4l2-dev.h"
__inline static char const   *video_device_node_name(struct video_device *vdev ) 
{ 
  char const   *tmp ;

  {
#line 228
  tmp = dev_name((struct device  const  *)(& vdev->dev));
#line 228
  return (tmp);
}
}
#line 376 "include/media/v4l2-ctrls.h"
__inline static void v4l2_ctrl_lock(struct v4l2_ctrl *ctrl ) 
{ 


  {
#line 378
  mutex_lock_nested((ctrl->handler)->lock, 0U);
#line 379
  return;
}
}
#line 385 "include/media/v4l2-ctrls.h"
__inline static void v4l2_ctrl_unlock(struct v4l2_ctrl *ctrl ) 
{ 


  {
#line 387
  mutex_unlock((ctrl->handler)->lock);
#line 388
  return;
}
}
#line 707
extern s32 v4l2_ctrl_g_ctrl(struct v4l2_ctrl * ) ;
#line 710
extern int __v4l2_ctrl_s_ctrl(struct v4l2_ctrl * , s32  ) ;
#line 721 "include/media/v4l2-ctrls.h"
__inline static int v4l2_ctrl_s_ctrl(struct v4l2_ctrl *ctrl , s32 val ) 
{ 
  int rval ;

  {
#line 725
  v4l2_ctrl_lock(ctrl);
#line 726
  rval = __v4l2_ctrl_s_ctrl(ctrl, val);
#line 727
  v4l2_ctrl_unlock(ctrl);
#line 729
  return (rval);
}
}
#line 60 "include/media/v4l2-fh.h"
extern void v4l2_fh_init(struct v4l2_fh * , struct video_device * ) ;
#line 65
extern void v4l2_fh_add(struct v4l2_fh * ) ;
#line 78
extern void v4l2_fh_del(struct v4l2_fh * ) ;
#line 85
extern void v4l2_fh_exit(struct v4l2_fh * ) ;
#line 97
extern int v4l2_fh_is_singular(struct v4l2_fh * ) ;
#line 102 "include/media/v4l2-fh.h"
__inline static int v4l2_fh_is_singular_file(struct file *filp ) 
{ 
  int tmp ;

  {
#line 104
  tmp = v4l2_fh_is_singular((struct v4l2_fh *)filp->private_data);
#line 104
  return (tmp);
}
}
#line 388 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
__inline static struct ivtv_open_id *fh2id(struct v4l2_fh *fh ) 
{ 
  struct v4l2_fh  const  *__mptr ;

  {
#line 390
  __mptr = (struct v4l2_fh  const  *)fh;
#line 390
  return ((struct ivtv_open_id *)__mptr);
}
}
#line 795 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-driver.h"
__inline static int ivtv_raw_vbi(struct ivtv  const  *itv ) 
{ 


  {
#line 797
  return ((unsigned int )itv->vbi.in.type == 4U);
}
}
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-fileops.h"
int ivtv_v4l2_open(struct file *filp ) ;
#line 26
ssize_t ivtv_v4l2_read(struct file *filp , char *buf , size_t count , loff_t *pos ) ;
#line 28
ssize_t ivtv_v4l2_write(struct file *filp , char const   *user_buf , size_t count ,
                        loff_t *pos ) ;
#line 30
int ivtv_v4l2_close(struct file *filp ) ;
#line 31
unsigned int ivtv_v4l2_enc_poll(struct file *filp , poll_table *wait ) ;
#line 32
unsigned int ivtv_v4l2_dec_poll(struct file *filp , poll_table *wait ) ;
#line 33
int ivtv_start_capture(struct ivtv_open_id *id ) ;
#line 34
void ivtv_stop_capture(struct ivtv_open_id *id , int gop_end ) ;
#line 35
int ivtv_start_decoding(struct ivtv_open_id *id , int speed ) ;
#line 36
void ivtv_mute(struct ivtv *itv ) ;
#line 37
void ivtv_unmute(struct ivtv *itv ) ;
#line 41
int ivtv_claim_stream(struct ivtv_open_id *id , int type ) ;
#line 42
void ivtv_release_stream(struct ivtv_stream *s ) ;
#line 67 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-queue.h"
int ivtv_buf_copy_from_user(struct ivtv_stream *s , struct ivtv_buffer *buf , char const   *src ,
                            int copybytes ) ;
#line 68
void ivtv_buf_swap(struct ivtv_buffer *buf ) ;
#line 71
void ivtv_queue_init(struct ivtv_queue *q ) ;
#line 72
void ivtv_enqueue(struct ivtv_stream *s , struct ivtv_buffer *buf , struct ivtv_queue *q ) ;
#line 73
struct ivtv_buffer *ivtv_dequeue(struct ivtv_stream *s , struct ivtv_queue *q ) ;
#line 74
int ivtv_queue_move(struct ivtv_stream *s , struct ivtv_queue *from , struct ivtv_queue *steal ,
                    struct ivtv_queue *to , int needed_bytes ) ;
#line 76
void ivtv_flush_queues(struct ivtv_stream *s ) ;
#line 50 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-irq.h"
void ivtv_dma_stream_dec_prepare(struct ivtv_stream *s , u32 offset , int lock ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-vbi.h"
ssize_t ivtv_write_vbi_from_user(struct ivtv *itv , struct v4l2_sliced_vbi_data  const  *sliced ,
                                 size_t cnt ) ;
#line 27
void ivtv_process_vbi_data(struct ivtv *itv , struct ivtv_buffer *buf , u64 pts_stamp ,
                           int streamtype ) ;
#line 30
void ivtv_disable_cc(struct ivtv *itv ) ;
#line 29 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-streams.h"
int ivtv_start_v4l2_encode_stream(struct ivtv_stream *s ) ;
#line 30
int ivtv_stop_v4l2_encode_stream(struct ivtv_stream *s , int gop_end ) ;
#line 31
int ivtv_start_v4l2_decode_stream(struct ivtv_stream *s , int gop_offset ) ;
#line 37 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-yuv.h"
void ivtv_yuv_setup_stream_frame(struct ivtv *itv ) ;
#line 38
int ivtv_yuv_udma_stream_frame(struct ivtv *itv , void *src ) ;
#line 41
void ivtv_yuv_close(struct ivtv *itv ) ;
#line 28 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-ioctl.h"
int ivtv_set_speed(struct ivtv *itv , int speed ) ;
#line 126 "include/media/v4l2-event.h"
extern int v4l2_event_pending(struct v4l2_fh * ) ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
int ivtv_claim_stream(struct ivtv_open_id *id , int type ) 
{ 
  struct ivtv *itv ;
  struct ivtv_stream *s ;
  struct ivtv_stream *s_vbi ;
  int vbi_type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 46
  itv = id->itv;
#line 47
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )type;
#line 51
  tmp = test_and_set_bit(3L, (unsigned long volatile   *)(& s->s_flags));
#line 51
  if (tmp != 0) {
#line 53
    if ((unsigned long )s->fh == (unsigned long )(& id->fh)) {
#line 55
      return (0);
    } else {

    }
#line 57
    if ((unsigned long )s->fh == (unsigned long )((struct v4l2_fh *)0) && (type == 6 || type == 2)) {
#line 62
      s->fh = & id->fh;
#line 63
      if ((ivtv_debug & 2) != 0) {
#line 63
        printk("\016%s:  info: Start Read VBI\n", (char *)(& itv->v4l2_dev.name));
      } else {

      }
#line 64
      return (0);
    } else {

    }
#line 67
    if ((ivtv_debug & 2) != 0) {
#line 67
      printk("\016%s:  info: Stream %d is busy\n", (char *)(& itv->v4l2_dev.name),
             type);
    } else {

    }
#line 68
    return (-16);
  } else {

  }
#line 70
  s->fh = & id->fh;
#line 71
  if (type == 6) {
#line 73
    ivtv_clear_irq_mask(itv, 524288U);
  } else {

  }
#line 80
  if (type == 5) {
#line 81
    vbi_type = 6;
  } else
#line 82
  if (type == 0 && itv->vbi.insert_mpeg != 0) {
#line 82
    tmp___0 = ivtv_raw_vbi((struct ivtv  const  *)itv);
#line 82
    if (tmp___0 == 0) {
#line 84
      vbi_type = 2;
    } else {
#line 86
      return (0);
    }
  } else {
#line 86
    return (0);
  }
#line 88
  s_vbi = (struct ivtv_stream *)(& itv->streams) + (unsigned long )vbi_type;
#line 90
  tmp___1 = test_and_set_bit(3L, (unsigned long volatile   *)(& s_vbi->s_flags));
#line 90
  if (tmp___1 == 0) {
#line 92
    if (vbi_type == 6) {
#line 93
      ivtv_clear_irq_mask(itv, 524288U);
    } else {

    }
  } else {

  }
#line 96
  set_bit(5L, (unsigned long volatile   *)(& s_vbi->s_flags));
#line 97
  return (0);
}
}
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
static char const   __kstrtab_ivtv_claim_stream[18U]  = 
#line 99
  {      'i',      'v',      't',      'v', 
        '_',      'c',      'l',      'a', 
        'i',      'm',      '_',      's', 
        't',      'r',      'e',      'a', 
        'm',      '\000'};
#line 99
struct kernel_symbol  const  __ksymtab_ivtv_claim_stream ;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
struct kernel_symbol  const  __ksymtab_ivtv_claim_stream  =    {(unsigned long )(& ivtv_claim_stream), (char const   *)(& __kstrtab_ivtv_claim_stream)};
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
void ivtv_release_stream(struct ivtv_stream *s ) 
{ 
  struct ivtv *itv ;
  struct ivtv_stream *s_vbi ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 105
  itv = s->itv;
#line 108
  s->fh = (struct v4l2_fh *)0;
#line 109
  if (s->type == 6 || s->type == 2) {
#line 109
    tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& s->s_flags));
#line 109
    if (tmp != 0) {
#line 112
      return;
    } else {

    }
  } else {

  }
#line 114
  tmp___0 = test_and_clear_bit(3L, (unsigned long volatile   *)(& s->s_flags));
#line 114
  if (tmp___0 == 0) {
#line 115
    if (ivtv_debug & 1) {
#line 115
      printk("\016%s:  warn: Release stream %s not in use!\n", (char *)(& itv->v4l2_dev.name),
             s->name);
    } else {

    }
#line 116
    return;
  } else {

  }
#line 119
  ivtv_flush_queues(s);
#line 122
  if (s->type == 6) {
#line 123
    ivtv_set_irq_mask(itv, 524288U);
  } else {

  }
#line 128
  if (s->type == 5) {
#line 129
    s_vbi = (struct ivtv_stream *)(& itv->streams) + 6UL;
  } else
#line 130
  if (s->type == 0) {
#line 131
    s_vbi = (struct ivtv_stream *)(& itv->streams) + 2UL;
  } else {
#line 133
    return;
  }
#line 136
  tmp___1 = test_and_clear_bit(5L, (unsigned long volatile   *)(& s_vbi->s_flags));
#line 136
  if (tmp___1 == 0) {
#line 138
    return;
  } else {

  }
#line 140
  if ((unsigned long )s_vbi->fh != (unsigned long )((struct v4l2_fh *)0)) {
#line 142
    return;
  } else {

  }
#line 145
  if (s_vbi->type == 6) {
#line 146
    ivtv_set_irq_mask(itv, 524288U);
  } else {

  }
#line 147
  clear_bit(3L, (unsigned long volatile   *)(& s_vbi->s_flags));
#line 148
  ivtv_flush_queues(s_vbi);
#line 149
  return;
}
}
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
static char const   __kstrtab_ivtv_release_stream[20U]  = 
#line 150
  {      'i',      'v',      't',      'v', 
        '_',      'r',      'e',      'l', 
        'e',      'a',      's',      'e', 
        '_',      's',      't',      'r', 
        'e',      'a',      'm',      '\000'};
#line 150
struct kernel_symbol  const  __ksymtab_ivtv_release_stream ;
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
struct kernel_symbol  const  __ksymtab_ivtv_release_stream  =    {(unsigned long )(& ivtv_release_stream), (char const   *)(& __kstrtab_ivtv_release_stream)};
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
static void ivtv_dualwatch(struct ivtv *itv ) 
{ 
  struct v4l2_tuner vt ;
  u32 new_stereo_mode ;
  u32 dual ;
  s32 tmp ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;

  {
#line 156
  dual = 2U;
#line 158
  tmp = v4l2_ctrl_g_ctrl(itv->cxhdl.__annonCompField92.audio_mode);
#line 158
  new_stereo_mode = (u32 )tmp;
#line 159
  memset((void *)(& vt), 0, 84UL);
#line 160
  __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 160
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 160
  goto ldv_39385;
  ldv_39384: ;
#line 160
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->g_tuner != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                              struct v4l2_tuner * ))0)) {
#line 160
    (*(((__sd->ops)->tuner)->g_tuner))(__sd, & vt);
  } else {

  }
#line 160
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 160
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_39385: ;
#line 160
  if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 162
    goto ldv_39384;
  } else {

  }

#line 161
  if (vt.audmode == 4U && (vt.rxsubchans & 4U) != 0U) {
#line 162
    new_stereo_mode = dual;
  } else {

  }
#line 164
  if (itv->dualwatch_stereo_mode == new_stereo_mode) {
#line 165
    return;
  } else {

  }
#line 167
  if ((ivtv_debug & 2) != 0) {
#line 167
    printk("\016%s:  info: dualwatch: change stereo flag from 0x%x to 0x%x.\n", (char *)(& itv->v4l2_dev.name),
           itv->dualwatch_stereo_mode, new_stereo_mode);
  } else {

  }
#line 169
  tmp___0 = v4l2_ctrl_s_ctrl(itv->cxhdl.__annonCompField92.audio_mode, (s32 )new_stereo_mode);
#line 169
  if (tmp___0 != 0) {
#line 170
    if ((ivtv_debug & 2) != 0) {
#line 170
      printk("\016%s:  info: dualwatch: changing stereo flag failed\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
  } else {

  }
#line 171
  return;
}
}
#line 173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
static void ivtv_update_pgm_info(struct ivtv *itv ) 
{ 
  u32 wr_idx ;
  unsigned int tmp ;
  int cnt ;
  int i ;
  int idx ;
  struct v4l2_enc_idx_entry *e ;
  u32 addr ;
  int mapping[8U] ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 175
  tmp = readl((void const volatile   *)itv->enc_mem + (unsigned long )itv->pgm_info_offset);
#line 175
  wr_idx = ((tmp - itv->pgm_info_offset) - 4U) / 24U;
#line 177
  i = 0;
#line 179
  if (itv->pgm_info_num <= wr_idx) {
#line 180
    if (ivtv_debug & 1) {
#line 180
      printk("\016%s:  warn: Invalid PGM index %d (>= %d)\n", (char *)(& itv->v4l2_dev.name),
             wr_idx, itv->pgm_info_num);
    } else {

    }
#line 181
    return;
  } else {

  }
#line 183
  cnt = (int )(((itv->pgm_info_num + wr_idx) - itv->pgm_info_write_idx) % itv->pgm_info_num);
#line 184
  goto ldv_39399;
  ldv_39398: 
#line 185
  idx = (int )((itv->pgm_info_write_idx + (u32 )i) % itv->pgm_info_num);
#line 186
  e = (struct v4l2_enc_idx_entry *)(& itv->pgm_info) + (unsigned long )idx;
#line 187
  addr = (itv->pgm_info_offset + (u32 )(idx * 24)) + 4U;
#line 188
  mapping[0] = -1;
#line 188
  mapping[1] = 0;
#line 188
  mapping[2] = 1;
#line 188
  mapping[3] = -1;
#line 188
  mapping[4] = 2;
#line 188
  mapping[5] = -1;
#line 188
  mapping[6] = -1;
#line 188
  mapping[7] = -1;
#line 192
  tmp___0 = readl((void const volatile   *)itv->enc_mem + (unsigned long )(addr + 4U));
#line 192
  tmp___1 = readl((void const volatile   *)itv->enc_mem + (unsigned long )(addr + 8U));
#line 192
  e->offset = (unsigned long long )tmp___0 + ((unsigned long long )tmp___1 << 32);
#line 193
  if (e->offset > itv->mpg_data_received) {
#line 194
    goto ldv_39397;
  } else {

  }
#line 196
  e->offset = e->offset + itv->vbi_data_inserted;
#line 197
  e->length = readl((void const volatile   *)itv->enc_mem + (unsigned long )addr);
#line 198
  tmp___2 = readl((void const volatile   *)itv->enc_mem + (unsigned long )(addr + 16U));
#line 198
  tmp___3 = readl((void const volatile   *)itv->enc_mem + (unsigned long )(addr + 20U));
#line 198
  e->pts = (unsigned long long )tmp___2 + (((unsigned long long )tmp___3 & 1ULL) << 32);
#line 199
  tmp___4 = readl((void const volatile   *)itv->enc_mem + (unsigned long )(addr + 12U));
#line 199
  e->flags = (__u32 )mapping[tmp___4 & 7U];
#line 200
  i = i + 1;
  ldv_39399: ;
#line 184
  if (i < cnt) {
#line 186
    goto ldv_39398;
  } else {

  }
  ldv_39397: 
#line 202
  itv->pgm_info_write_idx = (itv->pgm_info_write_idx + (u32 )i) % itv->pgm_info_num;
#line 203
  return;
}
}
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
static struct ivtv_buffer *ivtv_get_buffer(struct ivtv_stream *s , int non_block ,
                                           int *err ) 
{ 
  struct ivtv *itv ;
  struct ivtv_stream *s_vbi ;
  struct ivtv_buffer *buf ;
  wait_queue_t wait ;
  struct task_struct *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct task_struct *tmp___4 ;
  int tmp___5 ;

  {
#line 207
  itv = s->itv;
#line 208
  s_vbi = (struct ivtv_stream *)(& itv->streams) + 2UL;
#line 210
  tmp = get_current();
#line 210
  wait.flags = 0U;
#line 210
  wait.private = (void *)tmp;
#line 210
  wait.func = & autoremove_wake_function;
#line 210
  wait.task_list.next = & wait.task_list;
#line 210
  wait.task_list.prev = & wait.task_list;
#line 212
  *err = 0;
  ldv_39418: ;
#line 214
  if (s->type == 0) {
#line 216
    ivtv_update_pgm_info(itv);
#line 218
    tmp___0 = msecs_to_jiffies(1000U);
#line 218
    if ((long )((itv->dualwatch_jiffies + tmp___0) - (unsigned long )jiffies) < 0L) {
#line 221
      itv->dualwatch_jiffies = jiffies;
#line 222
      ivtv_dualwatch(itv);
    } else {

    }
#line 225
    tmp___1 = constant_test_bit(5L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 225
    if (tmp___1 != 0) {
#line 225
      tmp___2 = constant_test_bit(8L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 225
      if (tmp___2 == 0) {
#line 227
        goto ldv_39416;
        ldv_39415: 
#line 229
        ivtv_process_vbi_data(itv, buf, s_vbi->dma_pts, s_vbi->type);
#line 230
        ivtv_enqueue(s_vbi, buf, & s_vbi->q_free);
        ldv_39416: 
#line 227
        buf = ivtv_dequeue(s_vbi, & s_vbi->q_full);
#line 227
        if ((unsigned long )buf != (unsigned long )((struct ivtv_buffer *)0)) {
#line 229
          goto ldv_39415;
        } else {

        }

      } else {

      }
    } else {

    }
#line 233
    buf = & itv->vbi.sliced_mpeg_buf;
#line 234
    if (buf->readpos != buf->bytesused) {
#line 235
      return (buf);
    } else {

    }
  } else {

  }
#line 240
  buf = ivtv_dequeue(s, & s->q_io);
#line 241
  if ((unsigned long )buf != (unsigned long )((struct ivtv_buffer *)0)) {
#line 242
    return (buf);
  } else {

  }
#line 245
  buf = ivtv_dequeue(s, & s->q_full);
#line 246
  if ((unsigned long )buf != (unsigned long )((struct ivtv_buffer *)0)) {
#line 247
    if (((int )buf->b_flags & 1) == 0) {
#line 248
      return (buf);
    } else {

    }
#line 249
    buf->b_flags = (unsigned int )buf->b_flags & 65534U;
#line 250
    if (s->type == 0) {
#line 252
      ivtv_buf_swap(buf);
    } else
#line 253
    if (s->type != 6) {
#line 255
      ivtv_process_vbi_data(itv, buf, s->dma_pts, s->type);
    } else {

    }
#line 257
    return (buf);
  } else {

  }
#line 261
  if (s->type != 6) {
#line 261
    tmp___3 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 261
    if (tmp___3 == 0) {
#line 262
      if ((ivtv_debug & 2) != 0) {
#line 262
        printk("\016%s:  info: EOS %s\n", (char *)(& itv->v4l2_dev.name), s->name);
      } else {

      }
#line 263
      return ((struct ivtv_buffer *)0);
    } else {

    }
  } else {

  }
#line 267
  if (non_block != 0) {
#line 268
    *err = -11;
#line 269
    return ((struct ivtv_buffer *)0);
  } else {

  }
#line 273
  mutex_unlock(& itv->serialize_lock);
#line 274
  prepare_to_wait(& s->waitq, & wait, 1);
#line 276
  if (s->q_full.buffers == 0U) {
#line 277
    schedule();
  } else {

  }
#line 278
  finish_wait(& s->waitq, & wait);
#line 279
  mutex_lock_nested(& itv->serialize_lock, 0U);
#line 280
  tmp___4 = get_current();
#line 280
  tmp___5 = signal_pending___0(tmp___4);
#line 280
  if (tmp___5 != 0) {
#line 282
    if ((ivtv_debug & 2) != 0) {
#line 282
      printk("\016%s:  info: User stopped %s\n", (char *)(& itv->v4l2_dev.name), s->name);
    } else {

    }
#line 283
    *err = -4;
#line 284
    return ((struct ivtv_buffer *)0);
  } else {

  }
#line 286
  goto ldv_39418;
}
}
#line 289 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
static void ivtv_setup_sliced_vbi_buf(struct ivtv *itv ) 
{ 
  int idx ;

  {
#line 291
  idx = (int )itv->vbi.inserted_frame & 31;
#line 293
  itv->vbi.sliced_mpeg_buf.buf = (char *)itv->vbi.sliced_mpeg_data[idx];
#line 294
  itv->vbi.sliced_mpeg_buf.bytesused = itv->vbi.sliced_mpeg_size[idx];
#line 295
  itv->vbi.sliced_mpeg_buf.readpos = 0U;
#line 296
  return;
}
}
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
static size_t ivtv_copy_buf_to_user(struct ivtv_stream *s , struct ivtv_buffer *buf ,
                                    char *ubuf , size_t ucount ) 
{ 
  struct ivtv *itv ;
  size_t len ;
  char const   *start ;
  char const   *p ;
  u8 const   *q ;
  u8 ch ;
  int stuffing ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 301
  itv = s->itv;
#line 302
  len = (size_t )(buf->bytesused - buf->readpos);
#line 304
  if (len > ucount) {
#line 304
    len = ucount;
  } else {

  }
#line 305
  if (itv->vbi.insert_mpeg != 0 && s->type == 0) {
#line 305
    tmp___0 = ivtv_raw_vbi((struct ivtv  const  *)itv);
#line 305
    if (tmp___0 == 0) {
#line 305
      if ((unsigned long )(& itv->vbi.sliced_mpeg_buf) != (unsigned long )buf) {
#line 307
        start = (char const   *)buf->buf + (unsigned long )buf->readpos;
#line 308
        p = start + 1UL;
#line 310
        ch = itv->search_pack_header != 0 ? 186U : 224U;
#line 313
        goto ldv_39437;
        ldv_39442: 
#line 314
        p = (char const   *)q + 1U;
#line 315
        if ((((unsigned long )((char *)q + 15UL) >= (unsigned long )(buf->buf + (unsigned long )buf->bytesused) || (unsigned int )((unsigned char )*(q + 1UL)) != 0U) || (unsigned int )((unsigned char )*(q + 2UL)) != 1U) || (int )((unsigned char )*(q + 3UL)) != (int )ch) {
#line 317
          goto ldv_39437;
        } else {

        }
#line 319
        if (itv->search_pack_header == 0) {
#line 320
          if (((int )*(q + 6UL) & 192) != 128) {
#line 321
            goto ldv_39437;
          } else {

          }
#line 322
          if ((((int )*(q + 7UL) & 192) == 128 && ((int )*(q + 9UL) & 240) == 32) || (((int )*(q + 7UL) & 192) == 192 && ((int )*(q + 9UL) & 240) == 48)) {
#line 324
            ch = 186U;
#line 325
            itv->search_pack_header = 1;
#line 326
            p = (char const   *)q + 9U;
          } else {

          }
#line 328
          goto ldv_39437;
        } else {

        }
#line 330
        stuffing = (int )*(q + 13UL) & 7;
#line 332
        i = 0;
#line 332
        goto ldv_39440;
        ldv_39439: ;
#line 333
        if ((unsigned int )((unsigned char )*(q + (unsigned long )(i + 14))) != 255U) {
#line 334
          goto ldv_39438;
        } else {

        }
#line 332
        i = i + 1;
        ldv_39440: ;
#line 332
        if (i < stuffing) {
#line 334
          goto ldv_39439;
        } else {

        }
        ldv_39438: ;
#line 335
        if (((((i == stuffing && ((int )*(q + 4UL) & 196) == 68) && ((int )*(q + 12UL) & 3) == 3) && (unsigned int )((unsigned char )*(q + (unsigned long )(stuffing + 14))) == 0U) && (unsigned int )((unsigned char )*(q + (unsigned long )(stuffing + 15))) == 0U) && (unsigned int )((unsigned char )*(q + (unsigned long )(stuffing + 16))) == 1U) {
#line 338
          itv->search_pack_header = 0;
#line 339
          len = (size_t )((long )q - (long )start);
#line 340
          ivtv_setup_sliced_vbi_buf(itv);
#line 341
          goto ldv_39441;
        } else {

        }
        ldv_39437: ;
#line 313
        if ((unsigned long )(start + len) > (unsigned long )p) {
#line 313
          tmp = memchr((void const   *)p, 0, (__kernel_size_t )((long )(start + len) - (long )p));
#line 313
          q = (u8 const   *)tmp;
#line 313
          if ((unsigned long )q != (unsigned long )((u8 const   *)0U)) {
#line 315
            goto ldv_39442;
          } else {
#line 318
            goto ldv_39441;
          }
        } else {

        }
        ldv_39441: ;
      } else {

      }
    } else {

    }
  } else {

  }
#line 345
  tmp___1 = copy_to_user((void *)ubuf, (void const   *)buf->buf + (unsigned long )buf->readpos,
                         len);
#line 345
  if (tmp___1 != 0UL) {
#line 346
    if (ivtv_debug & 1) {
#line 346
      printk("\016%s:  warn: copy %zd bytes to user failed for %s\n", (char *)(& itv->v4l2_dev.name),
             len, s->name);
    } else {

    }
#line 347
    return (0xfffffffffffffff2UL);
  } else {

  }
#line 352
  buf->readpos = buf->readpos + (u32 )len;
#line 353
  if (s->type == 0 && (unsigned long )(& itv->vbi.sliced_mpeg_buf) != (unsigned long )buf) {
#line 354
    itv->mpg_data_received = itv->mpg_data_received + (unsigned long long )len;
  } else {

  }
#line 355
  return (len);
}
}
#line 358 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
static ssize_t ivtv_read(struct ivtv_stream *s , char *ubuf , size_t tot_count , int non_block ) 
{ 
  struct ivtv *itv ;
  size_t tot_written ;
  int single_frame ;
  int tmp ;
  int tmp___0 ;
  struct ivtv_buffer *buf ;
  int rc ;
  size_t tmp___1 ;
  int idx ;

  {
#line 360
  itv = s->itv;
#line 361
  tot_written = 0UL;
#line 362
  single_frame = 0;
#line 364
  tmp = atomic_read((atomic_t const   *)(& itv->capturing));
#line 364
  if (tmp == 0 && (unsigned long )s->fh == (unsigned long )((struct v4l2_fh *)0)) {
#line 366
    if (ivtv_debug & 1) {
#line 366
      printk("\016%s:  warn: Stream %s not initialized before read\n", (char *)(& itv->v4l2_dev.name),
             s->name);
    } else {

    }
#line 367
    return (-5L);
  } else {

  }
#line 372
  if (s->type == 6) {
#line 374
    single_frame = 1;
  } else
#line 372
  if (s->type == 2) {
#line 372
    tmp___0 = ivtv_raw_vbi((struct ivtv  const  *)itv);
#line 372
    if (tmp___0 == 0) {
#line 374
      single_frame = 1;
    } else {

    }
  } else {

  }
  ldv_39456: 
#line 380
  buf = ivtv_get_buffer(s, non_block, & rc);
#line 382
  if ((unsigned long )buf == (unsigned long )((struct ivtv_buffer *)0)) {
#line 384
    if (tot_written != 0UL) {
#line 385
      goto ldv_39454;
    } else {

    }
#line 387
    if (rc == 0) {
#line 388
      clear_bit(7L, (unsigned long volatile   *)(& s->s_flags));
#line 389
      clear_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 390
      ivtv_release_stream(s);
    } else {

    }
#line 393
    return ((ssize_t )rc);
  } else {

  }
#line 395
  tmp___1 = ivtv_copy_buf_to_user(s, buf, ubuf + tot_written, tot_count - tot_written);
#line 395
  rc = (int )tmp___1;
#line 396
  if ((unsigned long )(& itv->vbi.sliced_mpeg_buf) != (unsigned long )buf) {
#line 397
    ivtv_enqueue(s, buf, buf->readpos == buf->bytesused ? & s->q_free : & s->q_io);
  } else
#line 399
  if (buf->readpos == buf->bytesused) {
#line 400
    idx = (int )itv->vbi.inserted_frame & 31;
#line 401
    itv->vbi.sliced_mpeg_size[idx] = 0U;
#line 402
    itv->vbi.inserted_frame = itv->vbi.inserted_frame + 1U;
#line 403
    itv->vbi_data_inserted = itv->vbi_data_inserted + (u64 )buf->bytesused;
  } else {

  }
#line 405
  if (rc < 0) {
#line 406
    return ((ssize_t )rc);
  } else {

  }
#line 407
  tot_written = (size_t )rc + tot_written;
#line 409
  if (tot_written == tot_count || single_frame != 0) {
#line 410
    goto ldv_39454;
  } else {

  }
#line 411
  goto ldv_39456;
  ldv_39454: ;
#line 412
  return ((ssize_t )tot_written);
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
static ssize_t ivtv_read_pos(struct ivtv_stream *s , char *ubuf , size_t count , loff_t *pos ,
                             int non_block ) 
{ 
  ssize_t rc ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  struct ivtv *itv ;

  {
#line 418
  if (count != 0UL) {
#line 418
    tmp = ivtv_read(s, ubuf, count, non_block);
#line 418
    tmp___0 = tmp;
  } else {
#line 418
    tmp___0 = 0L;
  }
#line 418
  rc = tmp___0;
#line 419
  itv = s->itv;
#line 421
  if ((ivtv_debug & 16) != 0 && (ivtv_debug & 1024) != 0) {
#line 421
    printk("\016%s:  file: read %zd from %s, got %zd\n", (char *)(& itv->v4l2_dev.name),
           count, s->name, rc);
  } else {

  }
#line 422
  if (rc > 0L) {
#line 423
    pos = pos + (unsigned long )rc;
  } else {

  }
#line 424
  return (rc);
}
}
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
int ivtv_start_capture(struct ivtv_open_id *id ) 
{ 
  struct ivtv *itv ;
  struct ivtv_stream *s ;
  struct ivtv_stream *s_vbi ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 429
  itv = id->itv;
#line 430
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )id->type;
#line 433
  if (((s->type == 4 || s->type == 5) || s->type == 8) || s->type == 7) {
#line 438
    return (-22);
  } else {

  }
#line 442
  tmp = ivtv_claim_stream(id, s->type);
#line 442
  if (tmp != 0) {
#line 443
    return (-16);
  } else {

  }
#line 446
  if (s->type == 6) {
#line 447
    set_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 448
    return (0);
  } else {

  }
#line 453
  tmp___0 = constant_test_bit(7L, (unsigned long const volatile   *)(& s->s_flags));
#line 453
  if (tmp___0 != 0) {
#line 454
    set_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 455
    return (0);
  } else {
#line 453
    tmp___1 = test_and_set_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 453
    if (tmp___1 != 0) {
#line 454
      set_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 455
      return (0);
    } else {

    }
  }
#line 459
  s_vbi = (struct ivtv_stream *)(& itv->streams) + 2UL;
#line 460
  if (s->type == 0) {
#line 460
    tmp___3 = constant_test_bit(5L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 460
    if (tmp___3 != 0) {
#line 460
      tmp___4 = test_and_set_bit(4L, (unsigned long volatile   *)(& s_vbi->s_flags));
#line 460
      if (tmp___4 == 0) {
#line 466
        tmp___2 = ivtv_start_v4l2_encode_stream(s_vbi);
#line 466
        if (tmp___2 != 0) {
#line 467
          if (ivtv_debug & 1) {
#line 467
            printk("\016%s:  warn: VBI capture start failed\n", (char *)(& itv->v4l2_dev.name));
          } else {

          }
#line 470
          clear_bit(4L, (unsigned long volatile   *)(& s_vbi->s_flags));
#line 471
          clear_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 473
          ivtv_release_stream(s);
#line 474
          return (-5);
        } else {

        }
#line 476
        if ((ivtv_debug & 2) != 0) {
#line 476
          printk("\016%s:  info: VBI insertion started\n", (char *)(& itv->v4l2_dev.name));
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 480
  tmp___6 = ivtv_start_v4l2_encode_stream(s);
#line 480
  if (tmp___6 == 0) {
#line 482
    set_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 484
    tmp___5 = test_and_clear_bit(13L, (unsigned long volatile   *)(& itv->i_flags));
#line 484
    if (tmp___5 != 0) {
#line 485
      ivtv_vapi(itv, 210, 1, 1);
    } else {

    }
#line 486
    return (0);
  } else {

  }
#line 490
  if (ivtv_debug & 1) {
#line 490
    printk("\016%s:  warn: Failed to start capturing for stream %s\n", (char *)(& itv->v4l2_dev.name),
           s->name);
  } else {

  }
#line 495
  if (s->type == 0) {
#line 495
    tmp___7 = constant_test_bit(4L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 495
    if (tmp___7 != 0) {
#line 497
      ivtv_stop_v4l2_encode_stream(s_vbi, 0);
#line 498
      clear_bit(4L, (unsigned long volatile   *)(& s_vbi->s_flags));
    } else {

    }
  } else {

  }
#line 500
  clear_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 501
  ivtv_release_stream(s);
#line 502
  return (-5);
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
ssize_t ivtv_v4l2_read(struct file *filp , char *buf , size_t count , loff_t *pos ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  struct ivtv_stream *s ;
  ssize_t rc ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 507
  tmp = fh2id((struct v4l2_fh *)filp->private_data);
#line 507
  id = tmp;
#line 508
  itv = id->itv;
#line 509
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )id->type;
#line 512
  if ((ivtv_debug & 16) != 0 && (ivtv_debug & 1024) != 0) {
#line 512
    printk("\016%s:  file: read %zd bytes from %s\n", (char *)(& itv->v4l2_dev.name),
           count, s->name);
  } else {

  }
#line 514
  tmp___0 = mutex_lock_interruptible_nested(& itv->serialize_lock, 0U);
#line 514
  if (tmp___0 != 0) {
#line 515
    return (-512L);
  } else {

  }
#line 516
  tmp___1 = ivtv_start_capture(id);
#line 516
  rc = (ssize_t )tmp___1;
#line 517
  if (rc == 0L) {
#line 518
    rc = ivtv_read_pos(s, buf, count, pos, (int )filp->f_flags & 2048);
  } else {

  }
#line 519
  mutex_unlock(& itv->serialize_lock);
#line 520
  return (rc);
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
int ivtv_start_decoding(struct ivtv_open_id *id , int speed ) 
{ 
  struct ivtv *itv ;
  struct ivtv_stream *s ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 525
  itv = id->itv;
#line 526
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )id->type;
#line 529
  tmp___0 = atomic_read((atomic_t const   *)(& itv->decoding));
#line 529
  if (tmp___0 == 0) {
#line 530
    tmp = ivtv_claim_stream(id, s->type);
#line 530
    if (tmp != 0) {
#line 532
      if (ivtv_debug & 1) {
#line 532
        printk("\016%s:  warn: start decode, stream already claimed\n", (char *)(& itv->v4l2_dev.name));
      } else {

      }
#line 533
      return (-16);
    } else {

    }
#line 535
    rc = ivtv_start_v4l2_decode_stream(s, 0);
#line 536
    if (rc < 0) {
#line 537
      if (rc == -11) {
#line 538
        rc = ivtv_start_v4l2_decode_stream(s, 0);
      } else {

      }
#line 539
      if (rc < 0) {
#line 540
        return (rc);
      } else {

      }
    } else {

    }
  } else {

  }
#line 543
  if (s->type == 5) {
#line 544
    tmp___1 = ivtv_set_speed(itv, speed);
#line 544
    return (tmp___1);
  } else {

  }
#line 545
  return (0);
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
static ssize_t ivtv_write(struct file *filp , char const   *user_buf , size_t count ,
                          loff_t *pos ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  struct ivtv_stream *s ;
  struct yuv_playback_info *yi ;
  struct ivtv_buffer *buf ;
  struct ivtv_queue q ;
  int bytes_written ;
  int mode ;
  int rc ;
  wait_queue_t wait ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;
  int elems ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  struct task_struct *tmp___4 ;
  int tmp___5 ;
  int got_sig ;
  struct task_struct *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 550
  tmp = fh2id((struct v4l2_fh *)filp->private_data);
#line 550
  id = tmp;
#line 551
  itv = id->itv;
#line 552
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )id->type;
#line 553
  yi = & itv->yuv_info;
#line 556
  bytes_written = 0;
#line 559
  tmp___0 = get_current();
#line 559
  wait.flags = 0U;
#line 559
  wait.private = (void *)tmp___0;
#line 559
  wait.func = & autoremove_wake_function;
#line 559
  wait.task_list.next = & wait.task_list;
#line 559
  wait.task_list.prev = & wait.task_list;
#line 561
  if ((ivtv_debug & 16) != 0 && (ivtv_debug & 1024) != 0) {
#line 561
    printk("\016%s:  file: write %zd bytes to %s\n", (char *)(& itv->v4l2_dev.name),
           count, s->name);
  } else {

  }
#line 563
  if ((s->type != 5 && s->type != 8) && s->type != 7) {
#line 567
    return (-22L);
  } else {

  }
#line 570
  tmp___1 = ivtv_claim_stream(id, s->type);
#line 570
  if (tmp___1 != 0) {
#line 571
    return (-16L);
  } else {

  }
#line 574
  if (s->type == 7) {
#line 575
    elems = (int )(count / 64UL);
#line 577
    set_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 578
    tmp___2 = ivtv_write_vbi_from_user(itv, (struct v4l2_sliced_vbi_data  const  *)user_buf,
                                       (size_t )elems);
#line 578
    return (tmp___2);
  } else {

  }
#line 582
  mode = s->type == 5 ? 1 : 2;
#line 584
  tmp___3 = ivtv_set_output_mode(itv, mode);
#line 584
  if (tmp___3 != mode) {
#line 585
    ivtv_release_stream(s);
#line 586
    return (-16L);
  } else {

  }
#line 588
  ivtv_queue_init(& q);
#line 589
  set_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 592
  rc = ivtv_start_decoding(id, itv->speed);
#line 593
  if (rc != 0) {
#line 594
    if (ivtv_debug & 1) {
#line 594
      printk("\016%s:  warn: Failed start decode stream %s\n", (char *)(& itv->v4l2_dev.name),
             s->name);
    } else {

    }
#line 597
    clear_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 598
    clear_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 599
    return ((ssize_t )rc);
  } else {

  }
  retry: ;
#line 605
  if ((mode == 2 && s->q_full.length == 0U) && itv->dma_data_req_size != 0U) {
#line 606
    goto ldv_39508;
    ldv_39507: 
#line 607
    rc = ivtv_yuv_udma_stream_frame(itv, (void *)user_buf);
#line 609
    if (rc < 0) {
#line 610
      return ((ssize_t )rc);
    } else {

    }
#line 612
    bytes_written = (int )(itv->dma_data_req_size + (u32 )bytes_written);
#line 613
    user_buf = user_buf + (unsigned long )itv->dma_data_req_size;
#line 614
    count = count - (size_t )itv->dma_data_req_size;
    ldv_39508: ;
#line 606
    if ((size_t )itv->dma_data_req_size <= count) {
#line 608
      goto ldv_39507;
    } else {

    }

#line 616
    if (count == 0UL) {
#line 617
      if ((ivtv_debug & 16) != 0 && (ivtv_debug & 1024) != 0) {
#line 617
        printk("\016%s:  file: Wrote %d bytes to %s (%d)\n", (char *)(& itv->v4l2_dev.name),
               bytes_written, s->name, s->q_full.bytesused);
      } else {

      }
#line 618
      return ((ssize_t )bytes_written);
    } else {

    }
  } else {

  }
  ldv_39517: ;
#line 624
  goto ldv_39511;
  ldv_39510: 
#line 625
  ivtv_enqueue(s, buf, & q);
  ldv_39511: ;
#line 624
  if ((size_t )(q.length - q.bytesused) < count) {
#line 624
    buf = ivtv_dequeue(s, & s->q_io);
#line 624
    if ((unsigned long )buf != (unsigned long )((struct ivtv_buffer *)0)) {
#line 626
      goto ldv_39510;
    } else {
#line 629
      goto ldv_39512;
    }
  } else {

  }
  ldv_39512: ;
#line 626
  goto ldv_39514;
  ldv_39513: 
#line 627
  ivtv_enqueue(s, buf, & q);
  ldv_39514: ;
#line 626
  if ((size_t )(q.length - q.bytesused) < count) {
#line 626
    buf = ivtv_dequeue(s, & s->q_free);
#line 626
    if ((unsigned long )buf != (unsigned long )((struct ivtv_buffer *)0)) {
#line 628
      goto ldv_39513;
    } else {
#line 631
      goto ldv_39515;
    }
  } else {

  }
  ldv_39515: ;
#line 629
  if (q.buffers != 0U) {
#line 630
    goto ldv_39516;
  } else {

  }
#line 631
  if ((filp->f_flags & 2048U) != 0U) {
#line 632
    return (-11L);
  } else {

  }
#line 633
  mutex_unlock(& itv->serialize_lock);
#line 634
  prepare_to_wait(& s->waitq, & wait, 1);
#line 636
  if (s->q_free.buffers == 0U) {
#line 637
    schedule();
  } else {

  }
#line 638
  finish_wait(& s->waitq, & wait);
#line 639
  mutex_lock_nested(& itv->serialize_lock, 0U);
#line 640
  tmp___4 = get_current();
#line 640
  tmp___5 = signal_pending___0(tmp___4);
#line 640
  if (tmp___5 != 0) {
#line 641
    if ((ivtv_debug & 2) != 0) {
#line 641
      printk("\016%s:  info: User stopped %s\n", (char *)(& itv->v4l2_dev.name), s->name);
    } else {

    }
#line 642
    return (-4L);
  } else {

  }
#line 644
  goto ldv_39517;
  ldv_39516: ;
#line 647
  goto ldv_39520;
  ldv_39519: ;
#line 650
  if (s->type == 8 && (size_t )yi->stream_size + count > (size_t )itv->dma_data_req_size) {
#line 652
    rc = ivtv_buf_copy_from_user(s, buf, user_buf, (int )(itv->dma_data_req_size - (u32 )yi->stream_size));
  } else {
#line 655
    rc = ivtv_buf_copy_from_user(s, buf, user_buf, (int )count);
  }
#line 658
  if (rc < 0) {
#line 659
    ivtv_queue_move(s, & q, (struct ivtv_queue *)0, & s->q_free, 0);
#line 660
    return ((ssize_t )rc);
  } else {

  }
#line 662
  user_buf = user_buf + (unsigned long )rc;
#line 663
  count = count - (size_t )rc;
#line 664
  bytes_written = bytes_written + rc;
#line 666
  if (s->type == 8) {
#line 667
    yi->stream_size = yi->stream_size + rc;
#line 669
    if ((u32 )yi->stream_size == itv->dma_data_req_size) {
#line 670
      ivtv_enqueue(s, buf, & s->q_full);
#line 671
      yi->stream_size = 0;
#line 672
      goto ldv_39518;
    } else {

    }
  } else {

  }
#line 676
  if (buf->bytesused != s->buf_size) {
#line 678
    ivtv_enqueue(s, buf, & s->q_io);
#line 679
    goto ldv_39518;
  } else {

  }
#line 682
  if (s->type == 5) {
#line 683
    ivtv_buf_swap(buf);
  } else {

  }
#line 684
  ivtv_enqueue(s, buf, & s->q_full);
  ldv_39520: 
#line 647
  buf = ivtv_dequeue(s, & q);
#line 647
  if ((unsigned long )buf != (unsigned long )((struct ivtv_buffer *)0)) {
#line 649
    goto ldv_39519;
  } else {

  }
  ldv_39518: 
#line 687
  tmp___8 = constant_test_bit(2L, (unsigned long const volatile   *)(& s->s_flags));
#line 687
  if (tmp___8 != 0) {
#line 688
    if (s->q_full.length >= itv->dma_data_req_size) {
#line 691
      if (mode == 2) {
#line 692
        ivtv_yuv_setup_stream_frame(itv);
      } else {

      }
#line 694
      mutex_unlock(& itv->serialize_lock);
#line 695
      prepare_to_wait(& itv->dma_waitq, & wait, 1);
#line 696
      goto ldv_39523;
      ldv_39522: 
#line 698
      schedule();
      ldv_39523: 
#line 696
      tmp___6 = get_current();
#line 696
      got_sig = signal_pending___0(tmp___6);
#line 696
      if (got_sig == 0) {
#line 696
        tmp___7 = constant_test_bit(0L, (unsigned long const volatile   *)(& s->s_flags));
#line 696
        if (tmp___7 != 0) {
#line 698
          goto ldv_39522;
        } else {
#line 701
          goto ldv_39524;
        }
      } else {

      }
      ldv_39524: 
#line 700
      finish_wait(& itv->dma_waitq, & wait);
#line 701
      mutex_lock_nested(& itv->serialize_lock, 0U);
#line 702
      if (got_sig != 0) {
#line 703
        if ((ivtv_debug & 2) != 0) {
#line 703
          printk("\016%s:  info: User interrupted %s\n", (char *)(& itv->v4l2_dev.name),
                 s->name);
        } else {

        }
#line 704
        return (-4L);
      } else {

      }
#line 707
      clear_bit(2L, (unsigned long volatile   *)(& s->s_flags));
#line 708
      ivtv_queue_move(s, & s->q_full, (struct ivtv_queue *)0, & s->q_predma, (int )itv->dma_data_req_size);
#line 709
      ivtv_dma_stream_dec_prepare(s, itv->dma_data_req_offset + 16777216U, 1);
    } else {

    }
  } else {

  }
#line 714
  if (count != 0UL && (filp->f_flags & 2048U) == 0U) {
#line 715
    goto retry;
  } else {

  }
#line 716
  if ((ivtv_debug & 16) != 0 && (ivtv_debug & 1024) != 0) {
#line 716
    printk("\016%s:  file: Wrote %d bytes to %s (%d)\n", (char *)(& itv->v4l2_dev.name),
           bytes_written, s->name, s->q_full.bytesused);
  } else {

  }
#line 717
  return ((ssize_t )bytes_written);
}
}
#line 720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
ssize_t ivtv_v4l2_write(struct file *filp , char const   *user_buf , size_t count ,
                        loff_t *pos ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  ssize_t res ;
  int tmp___0 ;

  {
#line 722
  tmp = fh2id((struct v4l2_fh *)filp->private_data);
#line 722
  id = tmp;
#line 723
  itv = id->itv;
#line 726
  tmp___0 = mutex_lock_interruptible_nested(& itv->serialize_lock, 0U);
#line 726
  if (tmp___0 != 0) {
#line 727
    return (-512L);
  } else {

  }
#line 728
  res = ivtv_write(filp, user_buf, count, pos);
#line 729
  mutex_unlock(& itv->serialize_lock);
#line 730
  return (res);
}
}
#line 733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
unsigned int ivtv_v4l2_dec_poll(struct file *filp , poll_table *wait ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  struct ivtv_stream *s ;
  int res ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 735
  tmp = fh2id((struct v4l2_fh *)filp->private_data);
#line 735
  id = tmp;
#line 736
  itv = id->itv;
#line 737
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )id->type;
#line 738
  res = 0;
#line 741
  if ((ivtv_debug & 16) != 0 && (ivtv_debug & 1024) != 0) {
#line 741
    printk("\016%s:  file: Decoder poll\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 745
  tmp___3 = list_empty((struct list_head  const  *)(& id->fh.subscribed));
#line 745
  if (tmp___3 == 0) {
#line 746
    poll_wait(filp, & id->fh.wait, wait);
#line 748
    clear_bit(31L, (unsigned long volatile   *)(& itv->i_flags));
#line 749
    tmp___0 = v4l2_event_pending(& id->fh);
#line 749
    if (tmp___0 != 0) {
#line 750
      res = 2;
    } else {

    }
  } else {
#line 754
    poll_wait(filp, & s->waitq, wait);
#line 755
    set_bit(31L, (unsigned long volatile   *)(& itv->i_flags));
#line 756
    tmp___1 = constant_test_bit(29L, (unsigned long const volatile   *)(& itv->i_flags));
#line 756
    if (tmp___1 != 0) {
#line 758
      res = 2;
    } else {
#line 756
      tmp___2 = constant_test_bit(28L, (unsigned long const volatile   *)(& itv->i_flags));
#line 756
      if (tmp___2 != 0) {
#line 758
        res = 2;
      } else {

      }
    }
  }
#line 762
  if (s->q_free.buffers != 0U) {
#line 763
    res = res | 260;
  } else {

  }
#line 764
  return ((unsigned int )res);
}
}
#line 767 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
unsigned int ivtv_v4l2_enc_poll(struct file *filp , poll_table *wait ) 
{ 
  unsigned long req_events ;
  unsigned long tmp ;
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp___0 ;
  struct ivtv *itv ;
  struct ivtv_stream *s ;
  int eof ;
  int tmp___1 ;
  unsigned int res ;
  int rc ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 769
  tmp = poll_requested_events((poll_table const   *)wait);
#line 769
  req_events = tmp;
#line 770
  tmp___0 = fh2id((struct v4l2_fh *)filp->private_data);
#line 770
  id = tmp___0;
#line 771
  itv = id->itv;
#line 772
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )id->type;
#line 773
  tmp___1 = constant_test_bit(7L, (unsigned long const volatile   *)(& s->s_flags));
#line 773
  eof = tmp___1;
#line 774
  res = 0U;
#line 777
  if (eof == 0) {
#line 777
    tmp___2 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 777
    if (tmp___2 == 0) {
#line 777
      if (s->type != 4) {
#line 777
        if ((req_events & 65UL) != 0UL) {
#line 782
          mutex_lock_nested(& itv->serialize_lock, 0U);
#line 783
          rc = ivtv_start_capture(id);
#line 784
          mutex_unlock(& itv->serialize_lock);
#line 785
          if (rc != 0) {
#line 786
            if ((ivtv_debug & 2) != 0) {
#line 786
              printk("\016%s:  info: Could not start capture for %s (%d)\n", (char *)(& itv->v4l2_dev.name),
                     s->name, rc);
            } else {

            }
#line 788
            return (8U);
          } else {

          }
#line 790
          if ((ivtv_debug & 16) != 0) {
#line 790
            printk("\016%s:  file: Encoder poll started capture\n", (char *)(& itv->v4l2_dev.name));
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 794
  if ((ivtv_debug & 16) != 0 && (ivtv_debug & 1024) != 0) {
#line 794
    printk("\016%s:  file: Encoder poll\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 795
  poll_wait(filp, & s->waitq, wait);
#line 796
  tmp___3 = v4l2_event_pending(& id->fh);
#line 796
  if (tmp___3 != 0) {
#line 797
    res = res | 2U;
  } else {
#line 799
    poll_wait(filp, & id->fh.wait, wait);
  }
#line 801
  if (s->q_full.length != 0U || s->q_io.length != 0U) {
#line 802
    return (res | 65U);
  } else {

  }
#line 803
  if (eof != 0) {
#line 804
    return (res | 16U);
  } else {

  }
#line 805
  return (res);
}
}
#line 808 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
void ivtv_stop_capture(struct ivtv_open_id *id , int gop_end ) 
{ 
  struct ivtv *itv ;
  struct ivtv_stream *s ;
  struct ivtv_stream *s_vbi ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 810
  itv = id->itv;
#line 811
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )id->type;
#line 813
  if ((ivtv_debug & 16) != 0) {
#line 813
    printk("\016%s:  file: close() of %s\n", (char *)(& itv->v4l2_dev.name), s->name);
  } else {

  }
#line 818
  tmp___2 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 818
  if (tmp___2 != 0) {
#line 819
    s_vbi = (struct ivtv_stream *)(& itv->streams) + 2UL;
#line 821
    if ((ivtv_debug & 2) != 0) {
#line 821
      printk("\016%s:  info: close stopping capture\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 824
    if (id->type == 0) {
#line 824
      tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 824
      if (tmp != 0) {
#line 824
        tmp___0 = constant_test_bit(8L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 824
        if (tmp___0 == 0) {
#line 827
          if ((ivtv_debug & 2) != 0) {
#line 827
            printk("\016%s:  info: close stopping embedded VBI capture\n", (char *)(& itv->v4l2_dev.name));
          } else {

          }
#line 828
          ivtv_stop_v4l2_encode_stream(s_vbi, 0);
        } else {

        }
      } else {

      }
    } else {

    }
#line 830
    if (id->type == 6 || id->type == 2) {
#line 830
      tmp___1 = constant_test_bit(5L, (unsigned long const volatile   *)(& s->s_flags));
#line 830
      if (tmp___1 != 0) {
#line 834
        s->fh = (struct v4l2_fh *)0;
      } else {
#line 837
        ivtv_stop_v4l2_encode_stream(s, gop_end);
      }
    } else {
#line 837
      ivtv_stop_v4l2_encode_stream(s, gop_end);
    }
  } else {

  }
#line 840
  if (gop_end == 0) {
#line 841
    clear_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 842
    clear_bit(7L, (unsigned long volatile   *)(& s->s_flags));
#line 843
    ivtv_release_stream(s);
  } else {

  }
#line 845
  return;
}
}
#line 847 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
static void ivtv_stop_decoding(struct ivtv_open_id *id , int flags , u64 pts ) 
{ 
  struct ivtv *itv ;
  struct ivtv_stream *s ;
  int tmp ;
  int tmp___0 ;

  {
#line 849
  itv = id->itv;
#line 850
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )id->type;
#line 852
  if ((ivtv_debug & 16) != 0) {
#line 852
    printk("\016%s:  file: close() of %s\n", (char *)(& itv->v4l2_dev.name), s->name);
  } else {

  }
#line 854
  if (id->type == 8) {
#line 854
    tmp = constant_test_bit(12L, (unsigned long const volatile   *)(& itv->i_flags));
#line 854
    if (tmp != 0) {
#line 857
      ivtv_yuv_close(itv);
    } else {

    }
  } else {

  }
#line 861
  tmp___0 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 861
  if (tmp___0 != 0) {
#line 862
    if ((ivtv_debug & 2) != 0) {
#line 862
      printk("\016%s:  info: close stopping decode\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 864
    ivtv_stop_v4l2_decode_stream(s, flags, pts);
#line 865
    itv->output_mode = 0;
  } else {

  }
#line 867
  clear_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 868
  clear_bit(7L, (unsigned long volatile   *)(& s->s_flags));
#line 870
  if (itv->output_mode == 3 && id->yuv_frames != 0) {
#line 871
    itv->output_mode = 0;
  } else {

  }
#line 873
  itv->speed = 0;
#line 874
  clear_bit(20L, (unsigned long volatile   *)(& itv->i_flags));
#line 875
  ivtv_release_stream(s);
#line 876
  return;
}
}
#line 878 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
int ivtv_v4l2_close(struct file *filp ) 
{ 
  struct v4l2_fh *fh ;
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  struct ivtv_stream *s ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct v4l2_subdev *__sd___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct ivtv_stream *s_vout ;
  int tmp___4 ;

  {
#line 880
  fh = (struct v4l2_fh *)filp->private_data;
#line 881
  tmp = fh2id(fh);
#line 881
  id = tmp;
#line 882
  itv = id->itv;
#line 883
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )id->type;
#line 885
  if ((ivtv_debug & 16) != 0) {
#line 885
    printk("\016%s:  file: close %s\n", (char *)(& itv->v4l2_dev.name), s->name);
  } else {

  }
#line 887
  mutex_lock_nested(& itv->serialize_lock, 0U);
#line 890
  if (id->type == 4) {
#line 890
    tmp___3 = v4l2_fh_is_singular_file(filp);
#line 890
    if (tmp___3 != 0) {
#line 893
      ivtv_mute(itv);
#line 895
      clear_bit(5L, (unsigned long volatile   *)(& itv->i_flags));
#line 897
      __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 897
      __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 897
      goto ldv_39580;
      ldv_39579: ;
#line 897
      if ((unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->video)->s_std != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                v4l2_std_id  ))0)) {
#line 897
        (*(((__sd->ops)->video)->s_std))(__sd, itv->std);
      } else {

      }
#line 897
      __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 897
      __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
      ldv_39580: ;
#line 897
      if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 899
        goto ldv_39579;
      } else {

      }
#line 899
      ivtv_audio_set_io(itv);
#line 900
      if ((itv->hw_flags & 258U) != 0U) {
#line 901
        __mptr___1 = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 901
        __sd___0 = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff88UL;
#line 901
        goto ldv_39588;
        ldv_39587: ;
#line 901
        if (((__sd___0->grp_id & 258U) != 0U && (unsigned long )(__sd___0->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0)) && (unsigned long )((__sd___0->ops)->video)->s_crystal_freq != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                                        u32  ,
                                                                                                                                                                                                                                                                        u32  ))0)) {
#line 901
          (*(((__sd___0->ops)->video)->s_crystal_freq))(__sd___0, 32110000U, 0U);
        } else {

        }
#line 901
        __mptr___2 = (struct list_head  const  *)__sd___0->list.next;
#line 901
        __sd___0 = (struct v4l2_subdev *)__mptr___2 + 0xffffffffffffff88UL;
        ldv_39588: ;
#line 901
        if ((unsigned long )(& __sd___0->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 903
          goto ldv_39587;
        } else {

        }

      } else {

      }
#line 904
      tmp___2 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 904
      if (tmp___2 > 0) {
#line 906
        tmp___0 = v4l2_ctrl_g_ctrl(itv->cxhdl.__annonCompField95.video_mute);
#line 906
        tmp___1 = v4l2_ctrl_g_ctrl(itv->cxhdl.__annonCompField95.video_mute_yuv);
#line 906
        ivtv_vapi(itv, 217, 1, tmp___0 | (tmp___1 << 8));
      } else {

      }
#line 911
      ivtv_unmute(itv);
    } else {

    }
  } else {

  }
#line 914
  v4l2_fh_del(fh);
#line 915
  v4l2_fh_exit(fh);
#line 918
  if ((unsigned long )s->fh != (unsigned long )(& id->fh)) {
#line 919
    goto close_done;
  } else {

  }
#line 923
  if (s->type > 4) {
#line 924
    s_vout = (struct ivtv_stream *)(& itv->streams) + 7UL;
#line 926
    ivtv_stop_decoding(id, 3, 0ULL);
#line 930
    if (itv->output_mode == 0) {
#line 930
      tmp___4 = constant_test_bit(8L, (unsigned long const volatile   *)(& s_vout->s_flags));
#line 930
      if (tmp___4 == 0) {
#line 932
        ivtv_disable_cc(itv);
      } else {

      }
    } else {

    }
  } else {
#line 935
    ivtv_stop_capture(id, 0);
  }
  close_done: 
#line 938
  kfree((void const   *)id);
#line 939
  mutex_unlock(& itv->serialize_lock);
#line 940
  return (0);
}
}
#line 943 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
static int ivtv_open(struct file *filp ) 
{ 
  struct video_device *vdev ;
  struct video_device *tmp ;
  struct ivtv_stream *s ;
  void *tmp___0 ;
  struct ivtv *itv ;
  struct ivtv_open_id *item ;
  int res ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct v4l2_subdev *__sd___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  int tmp___10 ;

  {
#line 945
  tmp = video_devdata(filp);
#line 945
  vdev = tmp;
#line 946
  tmp___0 = video_get_drvdata(vdev);
#line 946
  s = (struct ivtv_stream *)tmp___0;
#line 947
  itv = s->itv;
#line 949
  res = 0;
#line 951
  if ((ivtv_debug & 16) != 0) {
#line 951
    printk("\016%s:  file: open %s\n", (char *)(& itv->v4l2_dev.name), s->name);
  } else {

  }
#line 953
  tmp___2 = ivtv_init_on_first_open(itv);
#line 953
  if (tmp___2 != 0) {
#line 954
    tmp___1 = video_device_node_name(vdev);
#line 954
    printk("\v%s: Failed to initialize on device %s\n", (char *)(& itv->v4l2_dev.name),
           tmp___1);
#line 956
    return (-6);
  } else {

  }
#line 961
  if (ivtv_fw_debug != 0) {
#line 962
    tmp___3 = video_device_node_name(vdev);
#line 962
    printk("\f%s: Opening %s with dead firmware lockout disabled\n", (char *)(& itv->v4l2_dev.name),
           tmp___3);
#line 964
    printk("\f%s: Selected firmware errors will be ignored\n", (char *)(& itv->v4l2_dev.name));
  } else {
#line 969
    res = ivtv_firmware_check(itv, (char *)"ivtv_serialized_open");
#line 970
    if (res == -11) {
#line 971
      res = ivtv_firmware_check(itv, (char *)"ivtv_serialized_open");
    } else {

    }
#line 972
    if (res < 0) {
#line 973
      return (-5);
    } else {

    }
  }
#line 976
  if (s->type == 5) {
#line 976
    tmp___4 = constant_test_bit(3L, (unsigned long const volatile   *)(& itv->streams[8].s_flags));
#line 976
    if (tmp___4 != 0) {
#line 978
      return (-16);
    } else {

    }
  } else {

  }
#line 980
  if (s->type == 8) {
#line 980
    tmp___5 = constant_test_bit(3L, (unsigned long const volatile   *)(& itv->streams[5].s_flags));
#line 980
    if (tmp___5 != 0) {
#line 982
      return (-16);
    } else {

    }
  } else {

  }
#line 984
  if (s->type == 8) {
#line 985
    tmp___6 = readl((void const volatile   *)itv->reg_mem + 2092U);
#line 985
    if (tmp___6 == 0U) {
#line 986
      printk("\v%s: Tried to open YUV output device but need to send data to mpeg decoder before it can be used\n",
             (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 989
    ivtv_udma_alloc(itv);
  } else {

  }
#line 993
  tmp___7 = kzalloc(192UL, 208U);
#line 993
  item = (struct ivtv_open_id *)tmp___7;
#line 994
  if ((unsigned long )item == (unsigned long )((struct ivtv_open_id *)0)) {
#line 995
    if (ivtv_debug & 1) {
#line 995
      printk("\016%s:  warn: nomem on v4l2 open\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 996
    return (-12);
  } else {

  }
#line 998
  v4l2_fh_init(& item->fh, & s->vdev);
#line 999
  item->itv = itv;
#line 1000
  item->type = s->type;
#line 1002
  filp->private_data = (void *)(& item->fh);
#line 1003
  v4l2_fh_add(& item->fh);
#line 1005
  if (item->type == 4) {
#line 1005
    tmp___10 = v4l2_fh_is_singular_file(filp);
#line 1005
    if (tmp___10 != 0) {
#line 1007
      tmp___9 = constant_test_bit(5L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1007
      if (tmp___9 == 0) {
#line 1008
        tmp___8 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 1008
        if (tmp___8 > 0) {
#line 1011
          v4l2_fh_del(& item->fh);
#line 1012
          v4l2_fh_exit(& item->fh);
#line 1013
          kfree((void const   *)item);
#line 1014
          return (-16);
        } else {

        }
      } else {

      }
#line 1018
      set_bit(5L, (unsigned long volatile   *)(& itv->i_flags));
#line 1020
      ivtv_mute(itv);
#line 1022
      __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1022
      __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1022
      goto ldv_39606;
      ldv_39605: ;
#line 1022
      if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->s_radio != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 1022
        (*(((__sd->ops)->tuner)->s_radio))(__sd);
      } else {

      }
#line 1022
      __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1022
      __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
      ldv_39606: ;
#line 1022
      if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1024
        goto ldv_39605;
      } else {

      }
#line 1024
      ivtv_audio_set_io(itv);
#line 1025
      if ((itv->hw_flags & 258U) != 0U) {
#line 1026
        __mptr___1 = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1026
        __sd___0 = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff88UL;
#line 1026
        goto ldv_39614;
        ldv_39613: ;
#line 1026
        if (((__sd___0->grp_id & 258U) != 0U && (unsigned long )(__sd___0->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0)) && (unsigned long )((__sd___0->ops)->video)->s_crystal_freq != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                                        u32  ,
                                                                                                                                                                                                                                                                        u32  ))0)) {
#line 1026
          (*(((__sd___0->ops)->video)->s_crystal_freq))(__sd___0, 32110000U, 4U);
        } else {

        }
#line 1026
        __mptr___2 = (struct list_head  const  *)__sd___0->list.next;
#line 1026
        __sd___0 = (struct v4l2_subdev *)__mptr___2 + 0xffffffffffffff88UL;
        ldv_39614: ;
#line 1026
        if ((unsigned long )(& __sd___0->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1028
          goto ldv_39613;
        } else {

        }

      } else {

      }
#line 1030
      ivtv_unmute(itv);
    } else {

    }
  } else {

  }
#line 1034
  if (s->type == 5) {
#line 1035
    clear_bit(7L, (unsigned long volatile   *)(& itv->i_flags));
  } else
#line 1036
  if (s->type == 8) {
#line 1037
    set_bit(7L, (unsigned long volatile   *)(& itv->i_flags));
#line 1039
    itv->dma_data_req_size = ((itv->yuv_info.v4l2_src_h + 31U) & 4294967264U) * 1080U;
#line 1041
    itv->yuv_info.stream_size = 0;
  } else {

  }
#line 1043
  return (0);
}
}
#line 1046 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
int ivtv_v4l2_open(struct file *filp ) 
{ 
  struct video_device *vdev ;
  struct video_device *tmp ;
  int res ;
  int tmp___0 ;

  {
#line 1048
  tmp = video_devdata(filp);
#line 1048
  vdev = tmp;
#line 1051
  tmp___0 = mutex_lock_interruptible_nested(vdev->lock, 0U);
#line 1051
  if (tmp___0 != 0) {
#line 1052
    return (-512);
  } else {

  }
#line 1053
  res = ivtv_open(filp);
#line 1054
  mutex_unlock(vdev->lock);
#line 1055
  return (res);
}
}
#line 1058 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
void ivtv_mute(struct ivtv *itv ) 
{ 
  int tmp ;

  {
#line 1060
  tmp = atomic_read((atomic_t const   *)(& itv->capturing));
#line 1060
  if (tmp != 0) {
#line 1061
    ivtv_vapi(itv, 218, 1, 1);
  } else {

  }
#line 1062
  if ((ivtv_debug & 2) != 0) {
#line 1062
    printk("\016%s:  info: Mute\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1063
  return;
}
}
#line 1065 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.c"
void ivtv_unmute(struct ivtv *itv ) 
{ 
  int tmp ;

  {
#line 1067
  tmp = atomic_read((atomic_t const   *)(& itv->capturing));
#line 1067
  if (tmp != 0) {
#line 1068
    ivtv_msleep_timeout(100U, 0);
#line 1069
    ivtv_vapi(itv, 220, 1, 12);
#line 1070
    ivtv_vapi(itv, 218, 1, 0);
  } else {

  }
#line 1072
  if ((ivtv_debug & 2) != 0) {
#line 1072
    printk("\016%s:  info: Unmute\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1073
  return;
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.o.c.prepared"
bool ldv_queue_work_on_75(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 142
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 142
  ldv_func_res = tmp;
#line 144
  activate_work_2(ldv_func_arg3, 2);
#line 146
  return (ldv_func_res);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.o.c.prepared"
bool ldv_queue_delayed_work_on_76(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 153
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 153
  ldv_func_res = tmp;
#line 155
  activate_work_2(& ldv_func_arg3->work, 2);
#line 157
  return (ldv_func_res);
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.o.c.prepared"
bool ldv_queue_work_on_77(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 164
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 164
  ldv_func_res = tmp;
#line 166
  activate_work_2(ldv_func_arg3, 2);
#line 168
  return (ldv_func_res);
}
}
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.o.c.prepared"
void ldv_flush_workqueue_78(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 174
  flush_workqueue(ldv_func_arg1);
#line 176
  call_and_disable_all_2(2);
#line 177
  return;
}
}
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-fileops.o.c.prepared"
bool ldv_queue_delayed_work_on_79(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 183
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 183
  ldv_func_res = tmp;
#line 185
  activate_work_2(& ldv_func_arg3->work, 2);
#line 187
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_89(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_91(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_90(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_93(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_92(struct workqueue_struct *ldv_func_arg1 ) ;
#line 70 "./arch/x86/include/asm/io.h"
__inline static void __writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 70
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)));
#line 71
  return;
}
}
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-mailbox.h"
void ivtv_api_get_data(struct ivtv_mailbox_data *mbdata , int mb , int argc , u32 *data ) ;
#line 33
void ivtv_mailbox_cache_invalidate(struct ivtv *itv ) ;
#line 36 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-yuv.h"
int ivtv_yuv_filter_check(struct ivtv *itv ) ;
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 51
extern void release_firmware(struct firmware  const  * ) ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-firmware.c"
static int load_fw_direct(char const   *fn , u8 volatile   *mem , struct ivtv *itv ,
                          long size ) 
{ 
  struct firmware  const  *fw ;
  int retries ;
  int i ;
  u32 volatile   *dst ;
  u32 const   *src ;
  int tmp ;

  {
#line 54
  fw = (struct firmware  const  *)0;
#line 55
  retries = 3;
  retry: ;
#line 58
  if (retries != 0) {
#line 58
    tmp = request_firmware(& fw, fn, & (itv->pdev)->dev);
#line 58
    if (tmp == 0) {
#line 60
      dst = (u32 volatile   *)mem;
#line 61
      src = (u32 const   *)fw->data;
#line 63
      if ((unsigned long )fw->size != (unsigned long )size) {
#line 68
        printk("\016%s: Retry: file loaded was not %s (expected size %ld, got %zu)\n",
               (char *)(& itv->v4l2_dev.name), fn, size, fw->size);
#line 69
        release_firmware(fw);
#line 70
        retries = retries - 1;
#line 71
        goto retry;
      } else {

      }
#line 73
      i = 0;
#line 73
      goto ldv_39110;
      ldv_39109: 
#line 75
      __writel(*src, (void volatile   *)dst);
#line 76
      dst = dst + 1;
#line 77
      src = src + 1;
#line 73
      i = i + 4;
      ldv_39110: ;
#line 73
      if ((unsigned long )i < (unsigned long )fw->size) {
#line 75
        goto ldv_39109;
      } else {

      }
#line 79
      printk("\016%s: Loaded %s firmware (%zu bytes)\n", (char *)(& itv->v4l2_dev.name),
             fn, fw->size);
#line 80
      release_firmware(fw);
#line 81
      return ((int )size);
    } else {

    }
  } else {

  }
#line 83
  printk("\v%s: Unable to open firmware %s (must be %ld bytes)\n", (char *)(& itv->v4l2_dev.name),
         fn, size);
#line 84
  printk("\v%s: Did you put the firmware in the hotplug firmware directory?\n", (char *)(& itv->v4l2_dev.name));
#line 85
  return (-12);
}
}
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-firmware.c"
void ivtv_halt_firmware(struct ivtv *itv ) 
{ 
  struct ivtv_mailbox  volatile  *tmp ;

  {
#line 90
  if ((ivtv_debug & 2) != 0) {
#line 90
    printk("\016%s:  info: Preparing for firmware halt.\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 91
  if ((unsigned int )itv->has_cx23415 != 0U && (unsigned long )itv->dec_mbox.mbox != (unsigned long )((struct ivtv_mailbox  volatile  *)0)) {
#line 92
    ivtv_vapi(itv, 14, 0);
  } else {

  }
#line 93
  if ((unsigned long )itv->enc_mbox.mbox != (unsigned long )((struct ivtv_mailbox  volatile  *)0)) {
#line 94
    ivtv_vapi(itv, 195, 0);
  } else {

  }
#line 96
  ivtv_msleep_timeout(10U, 0);
#line 97
  tmp = (struct ivtv_mailbox  volatile  *)0;
#line 97
  itv->dec_mbox.mbox = tmp;
#line 97
  itv->enc_mbox.mbox = tmp;
#line 99
  if ((ivtv_debug & 2) != 0) {
#line 99
    printk("\016%s:  info: Stopping VDM\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 100
  writel(0U, itv->reg_mem + 10240UL);
#line 102
  if ((ivtv_debug & 2) != 0) {
#line 102
    printk("\016%s:  info: Stopping AO\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 103
  writel(5U, itv->reg_mem + 11520UL);
#line 105
  if ((ivtv_debug & 2) != 0) {
#line 105
    printk("\016%s:  info: pinging (?) APU\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 106
  writel(0U, itv->reg_mem + 41060UL);
#line 108
  if ((ivtv_debug & 2) != 0) {
#line 108
    printk("\016%s:  info: Stopping VPU\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 109
  if ((unsigned int )itv->has_cx23415 == 0U) {
#line 110
    writel(4294967278U, itv->reg_mem + 36952UL);
  } else {
#line 112
    writel(4294967294U, itv->reg_mem + 36952UL);
  }
#line 114
  if ((ivtv_debug & 2) != 0) {
#line 114
    printk("\016%s:  info: Resetting Hw Blocks\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 115
  writel(4294967295U, itv->reg_mem + 36948UL);
#line 117
  if ((ivtv_debug & 2) != 0) {
#line 117
    printk("\016%s:  info: Stopping SPU\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 118
  writel(1U, itv->reg_mem + 36944UL);
#line 120
  ivtv_msleep_timeout(10U, 0);
#line 122
  if ((ivtv_debug & 2) != 0) {
#line 122
    printk("\016%s:  info: init Encoder SDRAM pre-charge\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 123
  writel(26U, itv->reg_mem + 2044UL);
#line 125
  if ((ivtv_debug & 2) != 0) {
#line 125
    printk("\016%s:  info: init Encoder SDRAM refresh to 1us\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 126
  writel(2147485248U, itv->reg_mem + 2040UL);
#line 128
  if ((unsigned int )itv->has_cx23415 != 0U) {
#line 129
    if ((ivtv_debug & 2) != 0) {
#line 129
      printk("\016%s:  info: init Decoder SDRAM pre-charge\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 130
    writel(26U, itv->reg_mem + 2300UL);
#line 132
    if ((ivtv_debug & 2) != 0) {
#line 132
      printk("\016%s:  info: init Decoder SDRAM refresh to 1us\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 133
    writel(2147485248U, itv->reg_mem + 2296UL);
  } else {

  }
#line 136
  if ((ivtv_debug & 2) != 0) {
#line 136
    printk("\016%s:  info: Sleeping for %dms\n", (char *)(& itv->v4l2_dev.name), 600);
  } else {

  }
#line 137
  ivtv_msleep_timeout(600U, 0);
#line 138
  return;
}
}
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-firmware.c"
void ivtv_firmware_versions(struct ivtv *itv ) 
{ 
  u32 data[16U] ;

  {
#line 145
  ivtv_vapi_result(itv, (u32 *)(& data), 196, 0);
#line 146
  printk("\016%s: Encoder revision: 0x%08x\n", (char *)(& itv->v4l2_dev.name), data[0]);
#line 148
  if (data[0] != 33947705U) {
#line 149
    printk("\f%s: Recommended firmware version is 0x02060039.\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 151
  if ((unsigned int )itv->has_cx23415 != 0U) {
#line 153
    ivtv_vapi_result(itv, (u32 *)(& data), 17, 0);
#line 154
    printk("\016%s: Decoder revision: 0x%08x\n", (char *)(& itv->v4l2_dev.name), data[0]);
  } else {

  }
#line 156
  return;
}
}
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-firmware.c"
static int ivtv_firmware_copy(struct ivtv *itv ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 160
  if ((ivtv_debug & 2) != 0) {
#line 160
    printk("\016%s:  info: Loading encoder image\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 161
  tmp = load_fw_direct("v4l-cx2341x-enc.fw", (u8 volatile   *)itv->enc_mem, itv, 376836L);
#line 161
  if (tmp != 376836) {
#line 163
    if (ivtv_debug & 1) {
#line 163
      printk("\016%s:  warn: failed loading encoder firmware\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 164
    return (-3);
  } else {

  }
#line 166
  if ((unsigned int )itv->has_cx23415 == 0U) {
#line 167
    return (0);
  } else {

  }
#line 169
  if ((ivtv_debug & 2) != 0) {
#line 169
    printk("\016%s:  info: Loading decoder image\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 170
  tmp___0 = load_fw_direct("v4l-cx2341x-dec.fw", (u8 volatile   *)itv->dec_mem, itv,
                           262144L);
#line 170
  if (tmp___0 != 262144) {
#line 172
    if (ivtv_debug & 1) {
#line 172
      printk("\016%s:  warn: failed loading decoder firmware\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 173
    return (-1);
  } else {

  }
#line 175
  return (0);
}
}
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-firmware.c"
static struct ivtv_mailbox  volatile  *ivtv_search_mailbox(u8 const volatile   *mem ,
                                                           u32 size ) 
{ 
  int i ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 184
  i = 0;
#line 184
  goto ldv_39128;
  ldv_39127: 
#line 185
  tmp = readl((void const volatile   *)mem + (unsigned long )i);
#line 185
  if (tmp == 305419896U) {
#line 185
    tmp___0 = readl((void const volatile   *)(mem + ((unsigned long )i + 4UL)));
#line 185
    if (tmp___0 == 878082066U) {
#line 185
      tmp___1 = readl((void const volatile   *)(mem + ((unsigned long )i + 8UL)));
#line 185
      if (tmp___1 == 1450709556U) {
#line 185
        tmp___2 = readl((void const volatile   *)(mem + ((unsigned long )i + 12UL)));
#line 185
        if (tmp___2 == 2014458966U) {
#line 189
          return ((struct ivtv_mailbox  volatile  *)(mem + ((unsigned long )i + 16UL)));
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 184
  i = i + 256;
  ldv_39128: ;
#line 184
  if ((u32 )i < size) {
#line 186
    goto ldv_39127;
  } else {

  }

#line 192
  return ((struct ivtv_mailbox  volatile  *)0);
}
}
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-firmware.c"
int ivtv_firmware_init(struct ivtv *itv ) 
{ 
  int err ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 199
  ivtv_halt_firmware(itv);
#line 202
  err = ivtv_firmware_copy(itv);
#line 203
  if (err != 0) {
#line 204
    if (ivtv_debug & 1) {
#line 204
      printk("\016%s:  warn: Error %d loading firmware\n", (char *)(& itv->v4l2_dev.name),
             err);
    } else {

    }
#line 205
    return (err);
  } else {

  }
#line 209
  tmp = readl((void const volatile   *)itv->reg_mem + 36944U);
#line 209
  writel(tmp & 4294967294U, itv->reg_mem + 36944UL);
#line 210
  ivtv_msleep_timeout(100U, 0);
#line 211
  if ((unsigned int )itv->has_cx23415 != 0U) {
#line 212
    tmp___0 = readl((void const volatile   *)itv->reg_mem + 36952U);
#line 212
    writel(tmp___0 & 4294967286U, itv->reg_mem + 36952UL);
  } else {
#line 214
    tmp___1 = readl((void const volatile   *)itv->reg_mem + 36952U);
#line 214
    writel(tmp___1 & 4294967291U, itv->reg_mem + 36952UL);
  }
#line 215
  ivtv_msleep_timeout(100U, 0);
#line 218
  itv->enc_mbox.mbox = ivtv_search_mailbox((u8 const volatile   *)itv->enc_mem, 8388608U);
#line 219
  if ((unsigned long )itv->enc_mbox.mbox == (unsigned long )((struct ivtv_mailbox  volatile  *)0)) {
#line 220
    printk("\v%s: Encoder mailbox not found\n", (char *)(& itv->v4l2_dev.name));
  } else {
#line 221
    tmp___2 = ivtv_vapi(itv, 128, 0);
#line 221
    if (tmp___2 != 0) {
#line 222
      printk("\v%s: Encoder firmware dead!\n", (char *)(& itv->v4l2_dev.name));
#line 223
      itv->enc_mbox.mbox = (struct ivtv_mailbox  volatile  *)0;
    } else {

    }
  }
#line 225
  if ((unsigned long )itv->enc_mbox.mbox == (unsigned long )((struct ivtv_mailbox  volatile  *)0)) {
#line 226
    return (-19);
  } else {

  }
#line 228
  if ((unsigned int )itv->has_cx23415 == 0U) {
#line 229
    return (0);
  } else {

  }
#line 231
  itv->dec_mbox.mbox = ivtv_search_mailbox((u8 const volatile   *)itv->dec_mem, 8388608U);
#line 232
  if ((unsigned long )itv->dec_mbox.mbox == (unsigned long )((struct ivtv_mailbox  volatile  *)0)) {
#line 233
    printk("\v%s: Decoder mailbox not found\n", (char *)(& itv->v4l2_dev.name));
  } else
#line 234
  if ((unsigned int )itv->has_cx23415 != 0U) {
#line 234
    tmp___3 = ivtv_vapi(itv, 0, 0);
#line 234
    if (tmp___3 != 0) {
#line 235
      printk("\v%s: Decoder firmware dead!\n", (char *)(& itv->v4l2_dev.name));
#line 236
      itv->dec_mbox.mbox = (struct ivtv_mailbox  volatile  *)0;
    } else {
#line 239
      ivtv_yuv_filter_check(itv);
    }
  } else {
#line 239
    ivtv_yuv_filter_check(itv);
  }
#line 241
  return ((unsigned long )itv->dec_mbox.mbox != (unsigned long )((struct ivtv_mailbox  volatile  *)0) ? 0 : -19);
}
}
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-firmware.c"
void ivtv_init_mpeg_decoder(struct ivtv *itv ) 
{ 
  u32 data[16U] ;
  long readbytes ;
  u8 volatile   *mem_offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 250
  data[0] = 0U;
#line 251
  data[1] = (u32 )itv->cxhdl.width;
#line 252
  data[2] = (u32 )itv->cxhdl.height;
#line 253
  data[3] = itv->cxhdl.audio_properties;
#line 255
  tmp = ivtv_api(itv, 26, 4, (u32 *)(& data));
#line 255
  if (tmp != 0) {
#line 256
    printk("\v%s: ivtv_init_mpeg_decoder failed to set decoder source\n", (char *)(& itv->v4l2_dev.name));
#line 257
    return;
  } else {

  }
#line 260
  tmp___0 = ivtv_vapi(itv, 1, 2, 0, 1);
#line 260
  if (tmp___0 != 0) {
#line 261
    printk("\v%s: ivtv_init_mpeg_decoder failed to start playback\n", (char *)(& itv->v4l2_dev.name));
#line 262
    return;
  } else {

  }
#line 264
  ivtv_api_get_data(& itv->dec_mbox, 9, 2, (u32 *)(& data));
#line 265
  mem_offset = (u8 volatile   *)itv->dec_mem + (unsigned long )data[1];
#line 267
  tmp___1 = load_fw_direct("v4l-cx2341x-init.mpg", mem_offset, itv, 155648L);
#line 267
  readbytes = (long )tmp___1;
#line 267
  if (readbytes <= 0L) {
#line 269
    if (ivtv_debug & 1) {
#line 269
      printk("\016%s:  warn: failed to read mpeg decoder initialisation file %s\n",
             (char *)(& itv->v4l2_dev.name), (char *)"v4l-cx2341x-init.mpg");
    } else {

    }
  } else {
#line 272
    ivtv_vapi(itv, 11, 3, 0, readbytes, 0);
#line 273
    ivtv_msleep_timeout(100U, 0);
  }
#line 275
  ivtv_vapi(itv, 2, 4, 0, 0, 0, 1);
#line 276
  return;
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-firmware.c"
static int ivtv_firmware_restart(struct ivtv *itv ) 
{ 
  int rc ;
  v4l2_std_id std ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct v4l2_subdev *__sd___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 281
  rc = 0;
#line 284
  if ((itv->v4l2_cap & 2U) != 0U) {
#line 286
    __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 286
    __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 286
    goto ldv_39151;
    ldv_39150: ;
#line 286
    if (((__sd->grp_id & 4U) != 0U && (unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->video)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                 u32  ,
                                                                                                                                                                                                                                                 u32  ,
                                                                                                                                                                                                                                                 u32  ))0)) {
#line 286
      (*(((__sd->ops)->video)->s_routing))(__sd, 1U, (u32 )((itv->card)->video_outputs + (unsigned long )itv->active_output)->video_output,
                                           0U);
    } else {

    }
#line 286
    __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 286
    __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
    ldv_39151: ;
#line 286
    if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 288
      goto ldv_39150;
    } else {

    }

  } else {

  }
#line 291
  mutex_lock_nested(& itv->udma.lock, 0U);
#line 293
  rc = ivtv_firmware_init(itv);
#line 294
  if (rc != 0) {
#line 295
    mutex_unlock(& itv->udma.lock);
#line 296
    return (rc);
  } else {

  }
#line 300
  ivtv_mailbox_cache_invalidate(itv);
#line 303
  std = itv->std;
#line 304
  itv->std = 0ULL;
#line 305
  ivtv_s_std_enc(itv, std);
#line 307
  if ((itv->v4l2_cap & 2U) != 0U) {
#line 308
    ivtv_init_mpeg_decoder(itv);
#line 311
    std = itv->std_out;
#line 312
    itv->std_out = 0ULL;
#line 313
    ivtv_s_std_dec(itv, std);
#line 316
    if ((unsigned long )itv->ivtvfb_restore != (unsigned long )((void (*)(struct ivtv * ))0)) {
#line 317
      (*(itv->ivtvfb_restore))(itv);
    } else {

    }
#line 320
    ivtv_set_osd_alpha(itv);
#line 323
    __mptr___1 = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 323
    __sd___0 = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff88UL;
#line 323
    goto ldv_39159;
    ldv_39158: ;
#line 323
    if (((__sd___0->grp_id & 4U) != 0U && (unsigned long )(__sd___0->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0)) && (unsigned long )((__sd___0->ops)->video)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                             u32  ,
                                                                                                                                                                                                                                                             u32  ,
                                                                                                                                                                                                                                                             u32  ))0)) {
#line 323
      (*(((__sd___0->ops)->video)->s_routing))(__sd___0, 0U, (u32 )((itv->card)->video_outputs + (unsigned long )itv->active_output)->video_output,
                                               0U);
    } else {

    }
#line 323
    __mptr___2 = (struct list_head  const  *)__sd___0->list.next;
#line 323
    __sd___0 = (struct v4l2_subdev *)__mptr___2 + 0xffffffffffffff88UL;
    ldv_39159: ;
#line 323
    if ((unsigned long )(& __sd___0->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 325
      goto ldv_39158;
    } else {

    }

  } else {

  }
#line 329
  mutex_unlock(& itv->udma.lock);
#line 330
  return (rc);
}
}
#line 335 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-firmware.c"
int ivtv_firmware_check(struct ivtv *itv , char *where ) 
{ 
  int res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 337
  res = 0;
#line 340
  tmp = ivtv_vapi(itv, 128, 0);
#line 340
  if (tmp < 0) {
#line 341
    printk("\f%s: Encoder has died : %s\n", (char *)(& itv->v4l2_dev.name), where);
#line 342
    res = -1;
  } else {

  }
#line 346
  if (res == 0) {
#line 346
    tmp___1 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 346
    if (tmp___1 == 0) {
#line 346
      tmp___2 = atomic_read((atomic_t const   *)(& itv->decoding));
#line 346
      if (tmp___2 == 0) {
#line 346
        goto _L;
      } else {
#line 346
        tmp___3 = atomic_read((atomic_t const   *)(& itv->decoding));
#line 346
        if (tmp___3 <= 1) {
#line 346
          tmp___4 = constant_test_bit(7L, (unsigned long const volatile   *)(& itv->i_flags));
#line 346
          if (tmp___4 != 0) {
            _L: /* CIL Label */ 
#line 351
            tmp___0 = ivtv_vapi(itv, 220, 1, 12);
#line 351
            if (tmp___0 < 0) {
#line 352
              printk("\f%s: Audio has died (Encoder OK) : %s\n", (char *)(& itv->v4l2_dev.name),
                     where);
#line 353
              res = -2;
            } else {

            }
          } else {

          }
        } else {

        }
      }
    } else {

    }
  } else {

  }
#line 357
  if ((itv->v4l2_cap & 2U) != 0U) {
#line 359
    if (res != -2) {
#line 359
      tmp___7 = readl((void const volatile   *)itv->dec_mem + 256U);
#line 359
      tmp___8 = readl((void const volatile   *)itv->dec_mem + 260U);
#line 359
      if (tmp___7 != tmp___8) {
#line 361
        ivtv_msleep_timeout(14U, 0);
#line 362
        tmp___5 = readl((void const volatile   *)itv->dec_mem + 256U);
#line 362
        tmp___6 = readl((void const volatile   *)itv->dec_mem + 260U);
#line 362
        if (tmp___5 != tmp___6) {
#line 363
          printk("\f%s: Audio has died (Decoder) : %s\n", (char *)(& itv->v4l2_dev.name),
                 where);
#line 365
          res = -1;
        } else {

        }
      } else {

      }
    } else {

    }
#line 370
    tmp___9 = ivtv_vapi(itv, 0, 0);
#line 370
    if (tmp___9 < 0) {
#line 371
      printk("\f%s: Decoder has died : %s\n", (char *)(& itv->v4l2_dev.name), where);
#line 372
      res = -1;
    } else {

    }
  } else {

  }
#line 377
  if (res != 0) {
#line 377
    tmp___10 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 377
    if (tmp___10 == 0) {
#line 377
      tmp___11 = atomic_read((atomic_t const   *)(& itv->decoding));
#line 377
      if (tmp___11 == 0) {
#line 379
        printk("\016%s: Detected in %s that firmware had failed - Reloading\n", (char *)(& itv->v4l2_dev.name),
               where);
#line 381
        res = ivtv_firmware_restart(itv);
#line 387
        if (res == 0) {
#line 388
          printk("\016%s: Firmware restart okay\n", (char *)(& itv->v4l2_dev.name));
#line 389
          res = -11;
        } else {
#line 391
          printk("\016%s: Firmware restart failed\n", (char *)(& itv->v4l2_dev.name));
        }
      } else {
#line 377
        goto _L___1;
      }
    } else {
#line 377
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 393
  if (res != 0) {
#line 394
    res = -5;
  } else {

  }
#line 397
  return (res);
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-firmware.o.c.prepared"
bool ldv_queue_work_on_89(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 142
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 142
  ldv_func_res = tmp;
#line 144
  activate_work_2(ldv_func_arg3, 2);
#line 146
  return (ldv_func_res);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-firmware.o.c.prepared"
bool ldv_queue_delayed_work_on_90(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 153
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 153
  ldv_func_res = tmp;
#line 155
  activate_work_2(& ldv_func_arg3->work, 2);
#line 157
  return (ldv_func_res);
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-firmware.o.c.prepared"
bool ldv_queue_work_on_91(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 164
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 164
  ldv_func_res = tmp;
#line 166
  activate_work_2(ldv_func_arg3, 2);
#line 168
  return (ldv_func_res);
}
}
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-firmware.o.c.prepared"
void ldv_flush_workqueue_92(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 174
  flush_workqueue(ldv_func_arg1);
#line 176
  call_and_disable_all_2(2);
#line 177
  return;
}
}
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-firmware.o.c.prepared"
bool ldv_queue_delayed_work_on_93(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 183
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 183
  ldv_func_res = tmp;
#line 185
  activate_work_2(& ldv_func_arg3->work, 2);
#line 187
  return (ldv_func_res);
}
}
#line 405 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_103(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_105(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_104(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_107(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_106(struct workqueue_struct *ldv_func_arg1 ) ;
#line 422 "include/linux/sched.h"
extern long schedule_timeout_interruptible(long  ) ;
#line 343 "include/media/v4l2-ctrls.h"
extern int v4l2_ctrl_handler_init_class(struct v4l2_ctrl_handler * , unsigned int  ,
                                        struct lock_class_key * , char const   * ) ;
#line 398
extern int v4l2_ctrl_handler_setup(struct v4l2_ctrl_handler * ) ;
#line 411
extern void v4l2_ctrl_handler_log_status(struct v4l2_ctrl_handler * , char const   * ) ;
#line 822
extern int v4l2_subdev_queryctrl(struct v4l2_subdev * , struct v4l2_queryctrl * ) ;
#line 823
extern int v4l2_subdev_querymenu(struct v4l2_subdev * , struct v4l2_querymenu * ) ;
#line 824
extern int v4l2_subdev_g_ext_ctrls(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
#line 825
extern int v4l2_subdev_try_ext_ctrls(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
#line 826
extern int v4l2_subdev_s_ext_ctrls(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
#line 827
extern int v4l2_subdev_g_ctrl(struct v4l2_subdev * , struct v4l2_control * ) ;
#line 828
extern int v4l2_subdev_s_ctrl(struct v4l2_subdev * , struct v4l2_control * ) ;
#line 683 "include/media/v4l2-subdev.h"
extern void v4l2_subdev_init(struct v4l2_subdev * , struct v4l2_subdev_ops  const  * ) ;
#line 109 "include/media/v4l2-device.h"
extern int v4l2_device_register_subdev(struct v4l2_device * , struct v4l2_subdev * ) ;
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
void ivtv_reset_ir_gpio(struct ivtv *itv ) 
{ 
  int curdir ;
  int curout ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 110
  if ((int )(itv->card)->type != 2) {
#line 111
    return;
  } else {

  }
#line 112
  if ((ivtv_debug & 2) != 0) {
#line 112
    printk("\016%s:  info: Resetting PVR150 IR\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 113
  tmp = readl((void const volatile   *)itv->reg_mem + 36876U);
#line 113
  curout = (int )tmp;
#line 114
  tmp___0 = readl((void const volatile   *)itv->reg_mem + 36896U);
#line 114
  curdir = (int )tmp___0;
#line 115
  curdir = curdir | 128;
#line 116
  writel((unsigned int )curdir, itv->reg_mem + 36896UL);
#line 117
  curout = (curout & -16) | 1;
#line 118
  writel((unsigned int )curout, itv->reg_mem + 36876UL);
#line 120
  tmp___1 = msecs_to_jiffies(1U);
#line 120
  schedule_timeout_interruptible((long )tmp___1);
#line 121
  curout = curout | 2;
#line 122
  writel((unsigned int )curout, itv->reg_mem + 36876UL);
#line 123
  curdir = curdir & -129;
#line 124
  writel((unsigned int )curdir, itv->reg_mem + 36896UL);
#line 125
  return;
}
}
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
int ivtv_reset_tuner_gpio(void *dev , int component , int cmd , int value ) 
{ 
  struct i2c_algo_bit_data *algo ;
  struct ivtv *itv ;
  u32 curout ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 130
  algo = (struct i2c_algo_bit_data *)dev;
#line 131
  itv = (struct ivtv *)algo->data;
#line 134
  if (cmd != 0) {
#line 135
    return (0);
  } else {

  }
#line 136
  if ((ivtv_debug & 2) != 0) {
#line 136
    printk("\016%s:  info: Resetting tuner\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 137
  curout = readl((void const volatile   *)itv->reg_mem + 36876U);
#line 138
  curout = (u32 )(~ (1 << (int )(itv->card)->xceive_pin)) & curout;
#line 139
  writel(curout, itv->reg_mem + 36876UL);
#line 140
  tmp = msecs_to_jiffies(1U);
#line 140
  schedule_timeout_interruptible((long )tmp);
#line 142
  curout = (u32 )(1 << (int )(itv->card)->xceive_pin) | curout;
#line 143
  writel(curout, itv->reg_mem + 36876UL);
#line 144
  tmp___0 = msecs_to_jiffies(1U);
#line 144
  schedule_timeout_interruptible((long )tmp___0);
#line 145
  return (0);
}
}
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
__inline static struct ivtv *sd_to_ivtv(struct v4l2_subdev *sd ) 
{ 
  struct v4l2_subdev  const  *__mptr ;

  {
#line 150
  __mptr = (struct v4l2_subdev  const  *)sd;
#line 150
  return ((struct ivtv *)__mptr + 0xfffffffffffffb80UL);
}
}
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
__inline static struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl ) 
{ 
  struct v4l2_ctrl_handler  const  *__mptr ;

  {
#line 155
  __mptr = (struct v4l2_ctrl_handler  const  *)ctrl->handler;
#line 155
  return (& ((struct ivtv *)__mptr + 0xfffffffffffffc70UL)->sd_gpio);
}
}
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
static int subdev_s_clock_freq(struct v4l2_subdev *sd , u32 freq ) 
{ 
  struct ivtv *itv ;
  struct ivtv *tmp ;
  u16 mask ;
  u16 data ;
  unsigned int tmp___0 ;

  {
#line 160
  tmp = sd_to_ivtv(sd);
#line 160
  itv = tmp;
#line 163
  mask = (itv->card)->gpio_audio_freq.mask;
#line 164
  switch (freq) {
  case 32000U: 
#line 166
  data = (itv->card)->gpio_audio_freq.f32000;
#line 167
  goto ldv_39664;
  case 44100U: 
#line 169
  data = (itv->card)->gpio_audio_freq.f44100;
#line 170
  goto ldv_39664;
  case 48000U: ;
  default: 
#line 173
  data = (itv->card)->gpio_audio_freq.f48000;
#line 174
  goto ldv_39664;
  }
  ldv_39664: ;
#line 176
  if ((unsigned int )mask != 0U) {
#line 177
    tmp___0 = readl((void const volatile   *)itv->reg_mem + 36876U);
#line 177
    writel((tmp___0 & (unsigned int )(~ ((int )mask))) | (unsigned int )((int )data & (int )mask),
           itv->reg_mem + 36876UL);
  } else {

  }
#line 178
  return (0);
}
}
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
static int subdev_g_tuner(struct v4l2_subdev *sd , struct v4l2_tuner *vt ) 
{ 
  struct ivtv *itv ;
  struct ivtv *tmp ;
  u16 mask ;
  unsigned int tmp___0 ;

  {
#line 183
  tmp = sd_to_ivtv(sd);
#line 183
  itv = tmp;
#line 186
  mask = (itv->card)->gpio_audio_detect.mask;
#line 187
  if ((unsigned int )mask == 0U) {
#line 188
    vt->rxsubchans = 14U;
  } else {
#line 187
    tmp___0 = readl((void const volatile   *)itv->reg_mem + 36872U);
#line 187
    if ((tmp___0 & (unsigned int )mask) != 0U) {
#line 188
      vt->rxsubchans = 14U;
    } else {
#line 191
      vt->rxsubchans = 1U;
    }
  }
#line 192
  return (0);
}
}
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
static int subdev_s_tuner(struct v4l2_subdev *sd , struct v4l2_tuner  const  *vt ) 
{ 
  struct ivtv *itv ;
  struct ivtv *tmp ;
  u16 mask ;
  u16 data ;
  unsigned int tmp___0 ;

  {
#line 197
  tmp = sd_to_ivtv(sd);
#line 197
  itv = tmp;
#line 200
  mask = (itv->card)->gpio_audio_mode.mask;
#line 201
  switch (vt->audmode) {
  case 3U: 
#line 203
  data = (itv->card)->gpio_audio_mode.lang1;
#line 204
  goto ldv_39682;
  case 2U: 
#line 206
  data = (itv->card)->gpio_audio_mode.lang2;
#line 207
  goto ldv_39682;
  case 0U: 
#line 209
  data = (itv->card)->gpio_audio_mode.mono;
#line 210
  goto ldv_39682;
  case 1U: ;
  case 4U: ;
  default: 
#line 214
  data = (itv->card)->gpio_audio_mode.stereo;
#line 215
  goto ldv_39682;
  }
  ldv_39682: ;
#line 217
  if ((unsigned int )mask != 0U) {
#line 218
    tmp___0 = readl((void const volatile   *)itv->reg_mem + 36876U);
#line 218
    writel((tmp___0 & (unsigned int )(~ ((int )mask))) | (unsigned int )((int )data & (int )mask),
           itv->reg_mem + 36876UL);
  } else {

  }
#line 219
  return (0);
}
}
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
static int subdev_s_radio(struct v4l2_subdev *sd ) 
{ 
  struct ivtv *itv ;
  struct ivtv *tmp ;
  u16 mask ;
  u16 data ;
  unsigned int tmp___0 ;

  {
#line 224
  tmp = sd_to_ivtv(sd);
#line 224
  itv = tmp;
#line 227
  mask = (itv->card)->gpio_audio_input.mask;
#line 228
  data = (itv->card)->gpio_audio_input.radio;
#line 229
  if ((unsigned int )mask != 0U) {
#line 230
    tmp___0 = readl((void const volatile   *)itv->reg_mem + 36876U);
#line 230
    writel((tmp___0 & (unsigned int )(~ ((int )mask))) | (unsigned int )((int )data & (int )mask),
           itv->reg_mem + 36876UL);
  } else {

  }
#line 231
  return (0);
}
}
#line 234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
static int subdev_s_audio_routing(struct v4l2_subdev *sd , u32 input , u32 output ,
                                  u32 config ) 
{ 
  struct ivtv *itv ;
  struct ivtv *tmp ;
  u16 mask ;
  u16 data ;
  unsigned int tmp___0 ;

  {
#line 237
  tmp = sd_to_ivtv(sd);
#line 237
  itv = tmp;
#line 240
  if (input > 2U) {
#line 241
    return (-22);
  } else {

  }
#line 242
  mask = (itv->card)->gpio_audio_input.mask;
#line 243
  switch (input) {
  case 0U: 
#line 245
  data = (itv->card)->gpio_audio_input.tuner;
#line 246
  goto ldv_39704;
  case 1U: 
#line 248
  data = (itv->card)->gpio_audio_input.linein;
#line 249
  goto ldv_39704;
  case 2U: ;
  default: 
#line 252
  data = (itv->card)->gpio_audio_input.radio;
#line 253
  goto ldv_39704;
  }
  ldv_39704: ;
#line 255
  if ((unsigned int )mask != 0U) {
#line 256
    tmp___0 = readl((void const volatile   *)itv->reg_mem + 36876U);
#line 256
    writel((tmp___0 & (unsigned int )(~ ((int )mask))) | (unsigned int )((int )data & (int )mask),
           itv->reg_mem + 36876UL);
  } else {

  }
#line 257
  return (0);
}
}
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
static int subdev_s_ctrl(struct v4l2_ctrl *ctrl ) 
{ 
  struct v4l2_subdev *sd ;
  struct v4l2_subdev *tmp ;
  struct ivtv *itv ;
  struct ivtv *tmp___0 ;
  u16 mask ;
  u16 data ;
  unsigned int tmp___1 ;

  {
#line 262
  tmp = to_sd(ctrl);
#line 262
  sd = tmp;
#line 263
  tmp___0 = sd_to_ivtv(sd);
#line 263
  itv = tmp___0;
#line 266
  switch (ctrl->id) {
  case 9963785U: 
#line 268
  mask = (itv->card)->gpio_audio_mute.mask;
#line 269
  data = ctrl->val != 0 ? (u16 )(itv->card)->gpio_audio_mute.mute : 0U;
#line 270
  if ((unsigned int )mask != 0U) {
#line 271
    tmp___1 = readl((void const volatile   *)itv->reg_mem + 36876U);
#line 271
    writel((tmp___1 & (unsigned int )(~ ((int )mask))) | (unsigned int )((int )data & (int )mask),
           itv->reg_mem + 36876UL);
  } else {

  }
#line 273
  return (0);
  }
#line 275
  return (-22);
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
static int subdev_log_status(struct v4l2_subdev *sd ) 
{ 
  struct ivtv *itv ;
  struct ivtv *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 281
  tmp = sd_to_ivtv(sd);
#line 281
  itv = tmp;
#line 283
  tmp___0 = readl((void const volatile   *)itv->reg_mem + 36872U);
#line 283
  tmp___1 = readl((void const volatile   *)itv->reg_mem + 36876U);
#line 283
  tmp___2 = readl((void const volatile   *)itv->reg_mem + 36896U);
#line 283
  printk("\016%s: GPIO status: DIR=0x%04x OUT=0x%04x IN=0x%04x\n", (char *)(& itv->v4l2_dev.name),
         tmp___2, tmp___1, tmp___0);
#line 286
  v4l2_ctrl_handler_log_status(& itv->hdl_gpio, (char const   *)(& sd->name));
#line 287
  return (0);
}
}
#line 290 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
static int subdev_s_video_routing(struct v4l2_subdev *sd , u32 input , u32 output ,
                                  u32 config ) 
{ 
  struct ivtv *itv ;
  struct ivtv *tmp ;
  u16 mask ;
  u16 data ;
  unsigned int tmp___0 ;

  {
#line 293
  tmp = sd_to_ivtv(sd);
#line 293
  itv = tmp;
#line 296
  if (input > 2U) {
#line 297
    return (-22);
  } else {

  }
#line 298
  mask = (itv->card)->gpio_video_input.mask;
#line 299
  if (input == 0U) {
#line 300
    data = (itv->card)->gpio_video_input.tuner;
  } else
#line 301
  if (input == 1U) {
#line 302
    data = (itv->card)->gpio_video_input.composite;
  } else {
#line 304
    data = (itv->card)->gpio_video_input.svideo;
  }
#line 305
  if ((unsigned int )mask != 0U) {
#line 306
    tmp___0 = readl((void const volatile   *)itv->reg_mem + 36876U);
#line 306
    writel((tmp___0 & (unsigned int )(~ ((int )mask))) | (unsigned int )((int )data & (int )mask),
           itv->reg_mem + 36876UL);
  } else {

  }
#line 307
  return (0);
}
}
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
static struct v4l2_ctrl_ops  const  gpio_ctrl_ops  =    {0, 0, & subdev_s_ctrl};
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
static struct v4l2_subdev_core_ops  const  subdev_core_ops  = 
#line 314
     {& subdev_log_status, 0, 0, 0, 0, 0, & v4l2_subdev_queryctrl, & v4l2_subdev_g_ctrl,
    & v4l2_subdev_s_ctrl, & v4l2_subdev_g_ext_ctrls, & v4l2_subdev_s_ext_ctrls, & v4l2_subdev_try_ext_ctrls,
    & v4l2_subdev_querymenu, 0, 0, 0, 0, 0, 0, 0, 0};
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
static struct v4l2_subdev_tuner_ops  const  subdev_tuner_ops  = 
#line 325
     {& subdev_s_radio, 0, 0, 0, & subdev_g_tuner, & subdev_s_tuner, 0, 0, 0, 0};
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
static struct v4l2_subdev_audio_ops  const  subdev_audio_ops  =    {& subdev_s_clock_freq, 0, & subdev_s_audio_routing, 0};
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
static struct v4l2_subdev_video_ops  const  subdev_video_ops  = 
#line 336
     {& subdev_s_video_routing, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0};
#line 340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
static struct v4l2_subdev_ops  const  subdev_ops  = 
#line 340
     {& subdev_core_ops, & subdev_tuner_ops, & subdev_audio_ops, & subdev_video_ops,
    0, 0, 0, 0};
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.c"
int ivtv_gpio_init(struct ivtv *itv ) 
{ 
  u16 pin ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  struct lock_class_key _key ;
  int tmp___1 ;

  {
#line 349
  pin = 0U;
#line 351
  if ((unsigned int )((unsigned char )(itv->card)->xceive_pin) != 0U) {
#line 352
    pin = (u16 )(1 << (int )(itv->card)->xceive_pin);
  } else {

  }
#line 354
  if ((unsigned int )((int )((unsigned short )(itv->card)->gpio_init.direction) | (int )pin) == 0U) {
#line 355
    return (0);
  } else {

  }
#line 357
  if ((ivtv_debug & 2) != 0) {
#line 357
    tmp = readl((void const volatile   *)itv->reg_mem + 36876U);
#line 357
    tmp___0 = readl((void const volatile   *)itv->reg_mem + 36896U);
#line 357
    printk("\016%s:  info: GPIO initial dir: %08x out: %08x\n", (char *)(& itv->v4l2_dev.name),
           tmp___0, tmp);
  } else {

  }
#line 361
  writel((unsigned int )((int )((unsigned short )(itv->card)->gpio_init.initial_value) | (int )pin),
         itv->reg_mem + 36876UL);
#line 362
  writel((unsigned int )((int )((unsigned short )(itv->card)->gpio_init.direction) | (int )pin),
         itv->reg_mem + 36896UL);
#line 363
  v4l2_subdev_init(& itv->sd_gpio, & subdev_ops);
#line 364
  snprintf((char *)(& itv->sd_gpio.name), 32UL, "%s-gpio", (char *)(& itv->v4l2_dev.name));
#line 365
  itv->sd_gpio.grp_id = 32768U;
#line 366
  v4l2_ctrl_handler_init_class(& itv->hdl_gpio, 1U, & _key, "ivtv_gpio:366:(&itv->hdl_gpio)->_lock");
#line 367
  v4l2_ctrl_new_std(& itv->hdl_gpio, & gpio_ctrl_ops, 9963785U, 0LL, 1LL, 1ULL, 0LL);
#line 369
  if (itv->hdl_gpio.error != 0) {
#line 370
    return (itv->hdl_gpio.error);
  } else {

  }
#line 371
  itv->sd_gpio.ctrl_handler = & itv->hdl_gpio;
#line 372
  v4l2_ctrl_handler_setup(& itv->hdl_gpio);
#line 373
  tmp___1 = v4l2_device_register_subdev(& itv->v4l2_dev, & itv->sd_gpio);
#line 373
  return (tmp___1);
}
}
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.o.c.prepared"
void ldv_initialize_v4l2_subdev_audio_ops_11(void) 
{ 
  void *tmp ;

  {
#line 116
  tmp = ldv_init_zalloc(304UL);
#line 116
  subdev_audio_ops_group0 = (struct v4l2_subdev *)tmp;
#line 117
  return;
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.o.c.prepared"
void ldv_initialize_v4l2_subdev_tuner_ops_12(void) 
{ 
  void *tmp ;

  {
#line 120
  tmp = ldv_init_zalloc(304UL);
#line 120
  subdev_tuner_ops_group0 = (struct v4l2_subdev *)tmp;
#line 121
  return;
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.o.c.prepared"
void ldv_initialize_v4l2_subdev_core_ops_13(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 124
  tmp = ldv_init_zalloc(8UL);
#line 124
  subdev_core_ops_group2 = (struct v4l2_control *)tmp;
#line 125
  tmp___0 = ldv_init_zalloc(304UL);
#line 125
  subdev_core_ops_group1 = (struct v4l2_subdev *)tmp___0;
#line 126
  tmp___1 = ldv_init_zalloc(32UL);
#line 126
  subdev_core_ops_group0 = (struct v4l2_ext_controls *)tmp___1;
#line 127
  return;
}
}
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.o.c.prepared"
void ldv_main_exported_11(void) 
{ 
  u32 ldvarg2 ;
  u32 ldvarg0 ;
  u32 ldvarg3 ;
  u32 ldvarg1 ;
  int tmp ;

  {
#line 130
  ldv_memset((void *)(& ldvarg2), 0, 4UL);
#line 131
  ldv_memset((void *)(& ldvarg0), 0, 4UL);
#line 132
  ldv_memset((void *)(& ldvarg3), 0, 4UL);
#line 133
  ldv_memset((void *)(& ldvarg1), 0, 4UL);
#line 135
  tmp = __VERIFIER_nondet_int();
#line 135
  switch (tmp) {
  case 0: ;
#line 138
  if (ldv_state_variable_11 == 1) {
#line 140
    subdev_s_audio_routing(subdev_audio_ops_group0, ldvarg3, ldvarg2, ldvarg1);
#line 142
    ldv_state_variable_11 = 1;
  } else {

  }
#line 145
  goto ldv_39758;
  case 1: ;
#line 148
  if (ldv_state_variable_11 == 1) {
#line 150
    subdev_s_clock_freq(subdev_audio_ops_group0, ldvarg0);
#line 152
    ldv_state_variable_11 = 1;
  } else {

  }
#line 155
  goto ldv_39758;
  default: 
#line 156
  ldv_stop();
  }
  ldv_39758: ;
#line 160
  return;
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.o.c.prepared"
void ldv_main_exported_13(void) 
{ 
  struct v4l2_queryctrl *ldvarg90 ;
  void *tmp ;
  struct v4l2_querymenu *ldvarg89 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 163
  tmp = ldv_init_zalloc(68UL);
#line 163
  ldvarg90 = (struct v4l2_queryctrl *)tmp;
#line 164
  tmp___0 = ldv_init_zalloc(44UL);
#line 164
  ldvarg89 = (struct v4l2_querymenu *)tmp___0;
#line 166
  tmp___1 = __VERIFIER_nondet_int();
#line 166
  switch (tmp___1) {
  case 0: ;
#line 169
  if (ldv_state_variable_13 == 1) {
#line 171
    v4l2_subdev_queryctrl(subdev_core_ops_group1, ldvarg90);
#line 173
    ldv_state_variable_13 = 1;
  } else {

  }
#line 176
  goto ldv_39767;
  case 1: ;
#line 179
  if (ldv_state_variable_13 == 1) {
#line 181
    v4l2_subdev_g_ext_ctrls(subdev_core_ops_group1, subdev_core_ops_group0);
#line 183
    ldv_state_variable_13 = 1;
  } else {

  }
#line 186
  goto ldv_39767;
  case 2: ;
#line 189
  if (ldv_state_variable_13 == 1) {
#line 191
    v4l2_subdev_try_ext_ctrls(subdev_core_ops_group1, subdev_core_ops_group0);
#line 193
    ldv_state_variable_13 = 1;
  } else {

  }
#line 196
  goto ldv_39767;
  case 3: ;
#line 199
  if (ldv_state_variable_13 == 1) {
#line 201
    v4l2_subdev_s_ext_ctrls(subdev_core_ops_group1, subdev_core_ops_group0);
#line 203
    ldv_state_variable_13 = 1;
  } else {

  }
#line 206
  goto ldv_39767;
  case 4: ;
#line 209
  if (ldv_state_variable_13 == 1) {
#line 211
    subdev_log_status(subdev_core_ops_group1);
#line 213
    ldv_state_variable_13 = 1;
  } else {

  }
#line 216
  goto ldv_39767;
  case 5: ;
#line 219
  if (ldv_state_variable_13 == 1) {
#line 221
    v4l2_subdev_querymenu(subdev_core_ops_group1, ldvarg89);
#line 223
    ldv_state_variable_13 = 1;
  } else {

  }
#line 226
  goto ldv_39767;
  case 6: ;
#line 229
  if (ldv_state_variable_13 == 1) {
#line 231
    v4l2_subdev_s_ctrl(subdev_core_ops_group1, subdev_core_ops_group2);
#line 233
    ldv_state_variable_13 = 1;
  } else {

  }
#line 236
  goto ldv_39767;
  case 7: ;
#line 239
  if (ldv_state_variable_13 == 1) {
#line 241
    v4l2_subdev_g_ctrl(subdev_core_ops_group1, subdev_core_ops_group2);
#line 243
    ldv_state_variable_13 = 1;
  } else {

  }
#line 246
  goto ldv_39767;
  default: 
#line 247
  ldv_stop();
  }
  ldv_39767: ;
#line 251
  return;
}
}
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.o.c.prepared"
void ldv_main_exported_10(void) 
{ 
  u32 ldvarg115 ;
  u32 ldvarg118 ;
  u32 ldvarg117 ;
  struct v4l2_subdev *ldvarg116 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 257
  tmp = ldv_init_zalloc(304UL);
#line 257
  ldvarg116 = (struct v4l2_subdev *)tmp;
#line 254
  ldv_memset((void *)(& ldvarg115), 0, 4UL);
#line 255
  ldv_memset((void *)(& ldvarg118), 0, 4UL);
#line 256
  ldv_memset((void *)(& ldvarg117), 0, 4UL);
#line 259
  tmp___0 = __VERIFIER_nondet_int();
#line 259
  switch (tmp___0) {
  case 0: ;
#line 262
  if (ldv_state_variable_10 == 1) {
#line 264
    subdev_s_video_routing(ldvarg116, ldvarg118, ldvarg117, ldvarg115);
#line 266
    ldv_state_variable_10 = 1;
  } else {

  }
#line 269
  goto ldv_39784;
  default: 
#line 270
  ldv_stop();
  }
  ldv_39784: ;
#line 274
  return;
}
}
#line 276 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.o.c.prepared"
void ldv_main_exported_12(void) 
{ 
  struct v4l2_tuner *ldvarg103 ;
  void *tmp ;
  struct v4l2_tuner *ldvarg102 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 277
  tmp = ldv_init_zalloc(84UL);
#line 277
  ldvarg103 = (struct v4l2_tuner *)tmp;
#line 278
  tmp___0 = ldv_init_zalloc(84UL);
#line 278
  ldvarg102 = (struct v4l2_tuner *)tmp___0;
#line 280
  tmp___1 = __VERIFIER_nondet_int();
#line 280
  switch (tmp___1) {
  case 0: ;
#line 283
  if (ldv_state_variable_12 == 1) {
#line 285
    subdev_s_tuner(subdev_tuner_ops_group0, (struct v4l2_tuner  const  *)ldvarg103);
#line 287
    ldv_state_variable_12 = 1;
  } else {

  }
#line 290
  goto ldv_39792;
  case 1: ;
#line 293
  if (ldv_state_variable_12 == 1) {
#line 295
    subdev_g_tuner(subdev_tuner_ops_group0, ldvarg102);
#line 297
    ldv_state_variable_12 = 1;
  } else {

  }
#line 300
  goto ldv_39792;
  case 2: ;
#line 303
  if (ldv_state_variable_12 == 1) {
#line 305
    subdev_s_radio(subdev_tuner_ops_group0);
#line 307
    ldv_state_variable_12 = 1;
  } else {

  }
#line 310
  goto ldv_39792;
  default: 
#line 311
  ldv_stop();
  }
  ldv_39792: ;
#line 315
  return;
}
}
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.o.c.prepared"
void ldv_main_exported_14(void) 
{ 
  struct v4l2_ctrl *ldvarg104 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 318
  tmp = ldv_init_zalloc(208UL);
#line 318
  ldvarg104 = (struct v4l2_ctrl *)tmp;
#line 320
  tmp___0 = __VERIFIER_nondet_int();
#line 320
  switch (tmp___0) {
  case 0: ;
#line 323
  if (ldv_state_variable_14 == 1) {
#line 325
    subdev_s_ctrl(ldvarg104);
#line 327
    ldv_state_variable_14 = 1;
  } else {

  }
#line 330
  goto ldv_39801;
  default: 
#line 331
  ldv_stop();
  }
  ldv_39801: ;
#line 335
  return;
}
}
#line 360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.o.c.prepared"
bool ldv_queue_work_on_103(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 364
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 364
  ldv_func_res = tmp;
#line 366
  activate_work_2(ldv_func_arg3, 2);
#line 368
  return (ldv_func_res);
}
}
#line 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.o.c.prepared"
bool ldv_queue_delayed_work_on_104(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 375
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 375
  ldv_func_res = tmp;
#line 377
  activate_work_2(& ldv_func_arg3->work, 2);
#line 379
  return (ldv_func_res);
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.o.c.prepared"
bool ldv_queue_work_on_105(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 386
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 386
  ldv_func_res = tmp;
#line 388
  activate_work_2(ldv_func_arg3, 2);
#line 390
  return (ldv_func_res);
}
}
#line 393 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.o.c.prepared"
void ldv_flush_workqueue_106(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 396
  flush_workqueue(ldv_func_arg1);
#line 398
  call_and_disable_all_2(2);
#line 399
  return;
}
}
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-gpio.o.c.prepared"
bool ldv_queue_delayed_work_on_107(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 405
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 405
  ldv_func_res = tmp;
#line 407
  activate_work_2(& ldv_func_arg3->work, 2);
#line 409
  return (ldv_func_res);
}
}
#line 402 "include/linux/kernel.h"
extern int sprintf(char * , char const   *  , ...) ;
#line 64 "./arch/x86/include/asm/string_64.h"
extern size_t strlen(char const   * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_117(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_119(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_118(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_121(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_120(struct workqueue_struct *ldv_func_arg1 ) ;
#line 868 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 870
  dev->driver_data = data;
#line 871
  return;
}
}
#line 62 "include/linux/i2c.h"
extern int i2c_master_send(struct i2c_client  const  * , char const   * , int  ) ;
#line 64
extern int i2c_master_recv(struct i2c_client  const  * , char * , int  ) ;
#line 335
extern struct i2c_client *i2c_new_probed_device(struct i2c_adapter * , struct i2c_board_info * ,
                                                unsigned short const   * , int (*)(struct i2c_adapter * ,
                                                                                   unsigned short  ) ) ;
#line 523 "include/linux/i2c.h"
__inline static void *i2c_get_adapdata(struct i2c_adapter  const  *dev ) 
{ 
  void *tmp ;

  {
#line 525
  tmp = dev_get_drvdata(& dev->dev);
#line 525
  return (tmp);
}
}
#line 528 "include/linux/i2c.h"
__inline static void i2c_set_adapdata(struct i2c_adapter *dev , void *data ) 
{ 


  {
#line 530
  dev_set_drvdata(& dev->dev, data);
#line 531
  return;
}
}
#line 579
extern int i2c_add_adapter(struct i2c_adapter * ) ;
#line 580
extern void i2c_del_adapter(struct i2c_adapter * ) ;
#line 51 "include/linux/i2c-algo-bit.h"
extern int i2c_bit_add_bus(struct i2c_adapter * ) ;
#line 102 "include/media/v4l2-common.h"
extern struct v4l2_subdev *v4l2_i2c_new_subdev(struct v4l2_device * , struct i2c_adapter * ,
                                               char const   * , u8  , unsigned short const   * ) ;
#line 108
extern struct v4l2_subdev *v4l2_i2c_new_subdev_board(struct v4l2_device * , struct i2c_adapter * ,
                                                     struct i2c_board_info * , unsigned short const   * ) ;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static u8 const   hw_addrs[22U]  = 
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
  {      68U,      33U,      68U,      64U, 
        0U,      27U,      17U,      0U, 
        33U,      18U,      92U,      33U, 
        26U,      91U,      72U,      0U, 
        64U,      26U,      24U,      112U, 
        113U,      107U};
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static char const   * const  hw_devicenames[22U]  = 
#line 126
  {      "cx25840",      "saa7115",      "saa7127_auto",      "msp3400", 
        "tuner",      "wm8775",      "cs53l32a",      "tveeprom", 
        "saa7114",      "upd64031a",      "upd64083",      "saa717x", 
        "wm8739",      "vp27smpx",      "m52790",      "gpio", 
        "ir_video",      "ir_video",      "ir_video",      "ir_tx_z8f0811_haup", 
        "ir_rx_z8f0811_haup",      "ir_video"};
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int get_key_adaptec(struct IR_i2c *ir , enum rc_type *protocol , u32 *scancode ,
                           u8 *toggle ) 
{ 
  unsigned char keybuf[4U] ;
  int tmp ;

  {
#line 156
  keybuf[0] = 0U;
#line 157
  i2c_master_send((struct i2c_client  const  *)ir->c, (char const   *)(& keybuf),
                  1);
#line 159
  tmp = i2c_master_recv((struct i2c_client  const  *)ir->c, (char *)(& keybuf), 4);
#line 159
  if (tmp != 4) {
#line 160
    return (0);
  } else {

  }
#line 164
  if ((unsigned int )keybuf[2] == 255U) {
#line 165
    return (0);
  } else {

  }
#line 168
  keybuf[2] = (unsigned int )keybuf[2] & 127U;
#line 169
  keybuf[3] = (unsigned int )keybuf[3] | 128U;
#line 171
  *protocol = 0;
#line 172
  *scancode = (u32 )((((int )keybuf[3] | ((int )keybuf[2] << 8)) | ((int )keybuf[1] << 16)) | ((int )keybuf[0] << 24));
#line 173
  *toggle = 0U;
#line 174
  return (1);
}
}
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_i2c_new_ir(struct ivtv *itv , u32 hw , char const   *type , u8 addr ) 
{ 
  struct i2c_board_info info ;
  struct i2c_adapter *adap ;
  struct IR_i2c_init_data *init_data ;
  unsigned short addr_list[2U] ;
  struct i2c_client *tmp ;
  struct i2c_client *tmp___0 ;

  {
#line 180
  adap = & itv->i2c_adap;
#line 181
  init_data = & itv->ir_i2c_init_data;
#line 182
  addr_list[0] = (unsigned short )addr;
#line 182
  addr_list[1] = 65534U;
#line 185
  if ((hw & 524288U) != 0U) {
#line 186
    if ((itv->hw_flags & 524288U) != 0U) {
#line 187
      return (-1);
    } else {

    }
#line 188
    memset((void *)(& info), 0, 64UL);
#line 189
    strlcpy((char *)(& info.type), type, 20UL);
#line 190
    tmp = i2c_new_probed_device(adap, & info, (unsigned short const   *)(& addr_list),
                                (int (*)(struct i2c_adapter * , unsigned short  ))0);
#line 190
    return ((unsigned long )tmp == (unsigned long )((struct i2c_client *)0) ? -1 : 0);
  } else {

  }
#line 195
  if ((itv->hw_flags & 3604480U) != 0U) {
#line 196
    return (-1);
  } else {

  }
#line 199
  switch (hw) {
  case 65536U: 
#line 201
  init_data->ir_codes = (char *)"rc-avermedia-cardbus";
#line 202
  init_data->internal_get_key_func = 6;
#line 204
  init_data->type = 2ULL;
#line 205
  init_data->name = "AVerMedia AVerTV card";
#line 206
  goto ldv_39133;
  case 131072U: ;
  case 262144U: 
#line 209
  init_data->ir_codes = (char *)"rc-hauppauge";
#line 210
  init_data->internal_get_key_func = 2;
#line 211
  init_data->type = 8ULL;
#line 212
  init_data->name = itv->card_name;
#line 213
  goto ldv_39133;
  case 1048576U: 
#line 216
  init_data->ir_codes = (char *)"rc-hauppauge";
#line 217
  init_data->internal_get_key_func = 5;
#line 218
  init_data->type = 8ULL;
#line 219
  init_data->name = itv->card_name;
#line 220
  goto ldv_39133;
  case 2097152U: 
#line 222
  init_data->get_key = & get_key_adaptec;
#line 223
  init_data->name = itv->card_name;
#line 225
  init_data->ir_codes = (char *)"rc-empty";
#line 226
  init_data->type = 1ULL;
#line 227
  goto ldv_39133;
  }
  ldv_39133: 
#line 230
  memset((void *)(& info), 0, 64UL);
#line 231
  info.platform_data = (void *)init_data;
#line 232
  strlcpy((char *)(& info.type), type, 20UL);
#line 234
  tmp___0 = i2c_new_probed_device(adap, & info, (unsigned short const   *)(& addr_list),
                                  (int (*)(struct i2c_adapter * , unsigned short  ))0);
#line 234
  return ((unsigned long )tmp___0 == (unsigned long )((struct i2c_client *)0) ? -1 : 0);
}
}
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
struct i2c_client *ivtv_i2c_new_ir_legacy(struct ivtv *itv ) 
{ 
  struct i2c_board_info info ;
  unsigned short addr_list[3U] ;
  struct i2c_client *tmp ;

  {
#line 253
  addr_list[0] = 26U;
#line 253
  addr_list[1] = 24U;
#line 253
  addr_list[2] = 65534U;
#line 259
  memset((void *)(& info), 0, 64UL);
#line 260
  strlcpy((char *)(& info.type), "ir_video", 20UL);
#line 261
  tmp = i2c_new_probed_device(& itv->i2c_adap, & info, (unsigned short const   *)(& addr_list),
                              (int (*)(struct i2c_adapter * , unsigned short  ))0);
#line 261
  return (tmp);
}
}
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
int ivtv_i2c_register(struct ivtv *itv , unsigned int idx ) 
{ 
  struct v4l2_subdev *sd ;
  struct i2c_adapter *adap ;
  char const   *type ;
  u32 hw ;
  int tmp ;
  unsigned short __constr_expr_0[2] ;
  struct cx25840_platform_data pdata ;
  struct i2c_board_info cx25840_info ;
  unsigned int tmp___0 ;

  {
#line 267
  adap = & itv->i2c_adap;
#line 268
  type = hw_devicenames[idx];
#line 269
  hw = (u32 )(1 << (int )idx);
#line 271
  if (hw == 16U) {
#line 273
    sd = v4l2_i2c_new_subdev(& itv->v4l2_dev, adap, type, 0, (unsigned short const   *)(& (itv->card_i2c)->radio));
#line 275
    if ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0)) {
#line 276
      sd->grp_id = (u32 )(1 << (int )idx);
    } else {

    }
#line 277
    sd = v4l2_i2c_new_subdev(& itv->v4l2_dev, adap, type, 0, (unsigned short const   *)(& (itv->card_i2c)->demod));
#line 279
    if ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0)) {
#line 280
      sd->grp_id = (u32 )(1 << (int )idx);
    } else {

    }
#line 281
    sd = v4l2_i2c_new_subdev(& itv->v4l2_dev, adap, type, 0, (unsigned short const   *)(& (itv->card_i2c)->tv));
#line 283
    if ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0)) {
#line 284
      sd->grp_id = (u32 )(1 << (int )idx);
    } else {

    }
#line 285
    return ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0) ? 0 : -1);
  } else {

  }
#line 288
  if ((hw & 4128768U) != 0U) {
#line 289
    tmp = ivtv_i2c_new_ir(itv, hw, type, (int )hw_addrs[idx]);
#line 289
    return (tmp);
  } else {

  }
#line 292
  if ((unsigned int )((unsigned char )hw_addrs[idx]) == 0U) {
#line 293
    return (-1);
  } else {

  }
#line 296
  if (hw == 512U || hw == 1024U) {
#line 297
    __constr_expr_0[0] = (unsigned short )hw_addrs[idx];
#line 297
    __constr_expr_0[1] = 65534U;
#line 297
    sd = v4l2_i2c_new_subdev(& itv->v4l2_dev, adap, type, 0, (unsigned short const   *)(& __constr_expr_0));
  } else
#line 299
  if (hw == 1U) {
#line 301
    cx25840_info.type[0] = 'c';
#line 301
    cx25840_info.type[1] = 'x';
#line 301
    cx25840_info.type[2] = '2';
#line 301
    cx25840_info.type[3] = '5';
#line 301
    cx25840_info.type[4] = '8';
#line 301
    cx25840_info.type[5] = '4';
#line 301
    cx25840_info.type[6] = '0';
#line 301
    cx25840_info.type[7] = '\000';
#line 301
    tmp___0 = 8U;
#line 301
    while (1) {
#line 301
      if (tmp___0 >= 20U) {
#line 301
        break;
      } else {

      }
#line 301
      cx25840_info.type[tmp___0] = (char)0;
#line 301
      tmp___0 = tmp___0 + 1U;
    }
#line 301
    cx25840_info.flags = (unsigned short)0;
#line 301
    cx25840_info.addr = (unsigned short )hw_addrs[idx];
#line 301
    cx25840_info.platform_data = (void *)(& pdata);
#line 301
    cx25840_info.archdata = 0;
#line 301
    cx25840_info.of_node = 0;
#line 301
    cx25840_info.fwnode = 0;
#line 301
    cx25840_info.irq = 0;
#line 307
    pdata.pvr150_workaround = (int )itv->pvr150_workaround;
#line 308
    sd = v4l2_i2c_new_subdev_board(& itv->v4l2_dev, adap, & cx25840_info, (unsigned short const   *)0U);
  } else {
#line 311
    sd = v4l2_i2c_new_subdev(& itv->v4l2_dev, adap, type, (int )hw_addrs[idx], (unsigned short const   *)0U);
  }
#line 314
  if ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0)) {
#line 315
    sd->grp_id = (u32 )(1 << (int )idx);
  } else {

  }
#line 316
  return ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0) ? 0 : -1);
}
}
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
struct v4l2_subdev *ivtv_find_hw(struct ivtv *itv , u32 hw ) 
{ 
  struct v4l2_subdev *result ;
  struct v4l2_subdev *sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 321
  result = (struct v4l2_subdev *)0;
#line 324
  spin_lock(& itv->v4l2_dev.lock);
#line 325
  __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 325
  sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 325
  goto ldv_39166;
  ldv_39165: ;
#line 326
  if (sd->grp_id == hw) {
#line 327
    result = sd;
#line 328
    goto ldv_39164;
  } else {

  }
#line 325
  __mptr___0 = (struct list_head  const  *)sd->list.next;
#line 325
  sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_39166: ;
#line 325
  if ((unsigned long )(& sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 327
    goto ldv_39165;
  } else {

  }
  ldv_39164: 
#line 331
  spin_unlock(& itv->v4l2_dev.lock);
#line 332
  return (result);
}
}
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static void ivtv_setscl(struct ivtv *itv , int state ) 
{ 


  {
#line 340
  writel((unsigned int )(~ state), itv->reg_mem + 28672UL);
#line 341
  return;
}
}
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static void ivtv_setsda(struct ivtv *itv , int state ) 
{ 


  {
#line 348
  writel((state & 1) == 0, itv->reg_mem + 28676UL);
#line 349
  return;
}
}
#line 352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_getscl(struct ivtv *itv ) 
{ 
  unsigned int tmp ;

  {
#line 354
  tmp = readl((void const volatile   *)itv->reg_mem + 28680U);
#line 354
  return ((int )tmp & 1);
}
}
#line 358 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_getsda(struct ivtv *itv ) 
{ 
  unsigned int tmp ;

  {
#line 360
  tmp = readl((void const volatile   *)itv->reg_mem + 28684U);
#line 360
  return ((int )tmp & 1);
}
}
#line 364 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static void ivtv_scldelay(struct ivtv *itv ) 
{ 
  int i ;

  {
#line 368
  i = 0;
#line 368
  goto ldv_39186;
  ldv_39185: 
#line 369
  ivtv_getscl(itv);
#line 368
  i = i + 1;
  ldv_39186: ;
#line 368
  if (i <= 4) {
#line 370
    goto ldv_39185;
  } else {

  }

#line 375
  return;
}
}
#line 373 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_waitscl(struct ivtv *itv , int val ) 
{ 
  int i ;
  int tmp ;

  {
#line 377
  ivtv_scldelay(itv);
#line 378
  i = 0;
#line 378
  goto ldv_39194;
  ldv_39193: 
#line 379
  tmp = ivtv_getscl(itv);
#line 379
  if (tmp == val) {
#line 380
    return (1);
  } else {

  }
#line 378
  i = i + 1;
  ldv_39194: ;
#line 378
  if (i <= 999) {
#line 380
    goto ldv_39193;
  } else {

  }

#line 382
  return (0);
}
}
#line 386 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_waitsda(struct ivtv *itv , int val ) 
{ 
  int i ;
  int tmp ;

  {
#line 390
  ivtv_scldelay(itv);
#line 391
  i = 0;
#line 391
  goto ldv_39202;
  ldv_39201: 
#line 392
  tmp = ivtv_getsda(itv);
#line 392
  if (tmp == val) {
#line 393
    return (1);
  } else {

  }
#line 391
  i = i + 1;
  ldv_39202: ;
#line 391
  if (i <= 999) {
#line 393
    goto ldv_39201;
  } else {

  }

#line 395
  return (0);
}
}
#line 399 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_ack(struct ivtv *itv ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 401
  ret = 0;
#line 403
  tmp___0 = ivtv_getscl(itv);
#line 403
  if (tmp___0 == 1) {
#line 404
    if ((ivtv_debug & 512) != 0 && (ivtv_debug & 1024) != 0) {
#line 404
      printk("\016%s:  i2c: SCL was high starting an ack\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 405
    ivtv_setscl(itv, 0);
#line 406
    tmp = ivtv_waitscl(itv, 0);
#line 406
    if (tmp == 0) {
#line 407
      if ((ivtv_debug & 512) != 0) {
#line 407
        printk("\016%s:  i2c: Could not set SCL low starting an ack\n", (char *)(& itv->v4l2_dev.name));
      } else {

      }
#line 408
      return (-121);
    } else {

    }
  } else {

  }
#line 411
  ivtv_setsda(itv, 1);
#line 412
  ivtv_scldelay(itv);
#line 413
  ivtv_setscl(itv, 1);
#line 414
  tmp___1 = ivtv_waitsda(itv, 0);
#line 414
  if (tmp___1 == 0) {
#line 415
    if ((ivtv_debug & 512) != 0) {
#line 415
      printk("\016%s:  i2c: Slave did not ack\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 416
    ret = -121;
  } else {

  }
#line 418
  ivtv_setscl(itv, 0);
#line 419
  tmp___2 = ivtv_waitscl(itv, 0);
#line 419
  if (tmp___2 == 0) {
#line 420
    if ((ivtv_debug & 512) != 0) {
#line 420
      printk("\016%s:  i2c: Failed to set SCL low after ACK\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 421
    ret = -121;
  } else {

  }
#line 423
  return (ret);
}
}
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_sendbyte(struct ivtv *itv , unsigned char byte ) 
{ 
  int i ;
  int bit ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 431
  if ((ivtv_debug & 512) != 0 && (ivtv_debug & 1024) != 0) {
#line 431
    printk("\016%s:  i2c: write %x\n", (char *)(& itv->v4l2_dev.name), (int )byte);
  } else {

  }
#line 432
  i = 0;
#line 432
  goto ldv_39215;
  ldv_39214: 
#line 433
  ivtv_setscl(itv, 0);
#line 434
  tmp = ivtv_waitscl(itv, 0);
#line 434
  if (tmp == 0) {
#line 435
    if ((ivtv_debug & 512) != 0) {
#line 435
      printk("\016%s:  i2c: Error setting SCL low\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 436
    return (-121);
  } else {

  }
#line 438
  bit = ((int )byte >> 7) & 1;
#line 439
  ivtv_setsda(itv, bit);
#line 440
  tmp___0 = ivtv_waitsda(itv, bit);
#line 440
  if (tmp___0 == 0) {
#line 441
    if ((ivtv_debug & 512) != 0) {
#line 441
      printk("\016%s:  i2c: Error setting SDA\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 442
    return (-121);
  } else {

  }
#line 444
  ivtv_setscl(itv, 1);
#line 445
  tmp___1 = ivtv_waitscl(itv, 1);
#line 445
  if (tmp___1 == 0) {
#line 446
    if ((ivtv_debug & 512) != 0) {
#line 446
      printk("\016%s:  i2c: Slave not ready for bit\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 447
    return (-121);
  } else {

  }
#line 432
  i = i + 1;
#line 432
  byte = (int )byte << 1U;
  ldv_39215: ;
#line 432
  if (i <= 7) {
#line 434
    goto ldv_39214;
  } else {

  }
#line 450
  ivtv_setscl(itv, 0);
#line 451
  tmp___2 = ivtv_waitscl(itv, 0);
#line 451
  if (tmp___2 == 0) {
#line 452
    if ((ivtv_debug & 512) != 0) {
#line 452
      printk("\016%s:  i2c: Error setting SCL low\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 453
    return (-121);
  } else {

  }
#line 455
  tmp___3 = ivtv_ack(itv);
#line 455
  return (tmp___3);
}
}
#line 460 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_readbyte(struct ivtv *itv , unsigned char *byte , int nack ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 464
  *byte = 0U;
#line 466
  ivtv_setsda(itv, 1);
#line 467
  ivtv_scldelay(itv);
#line 468
  i = 0;
#line 468
  goto ldv_39224;
  ldv_39223: 
#line 469
  ivtv_setscl(itv, 0);
#line 470
  ivtv_scldelay(itv);
#line 471
  ivtv_setscl(itv, 1);
#line 472
  tmp = ivtv_waitscl(itv, 1);
#line 472
  if (tmp == 0) {
#line 473
    if ((ivtv_debug & 512) != 0) {
#line 473
      printk("\016%s:  i2c: Error setting SCL high\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 474
    return (-121);
  } else {

  }
#line 476
  tmp___0 = ivtv_getsda(itv);
#line 476
  *byte = (unsigned char )((int )((signed char )((int )*byte << 1)) | (int )((signed char )tmp___0));
#line 468
  i = i + 1;
  ldv_39224: ;
#line 468
  if (i <= 7) {
#line 470
    goto ldv_39223;
  } else {

  }
#line 478
  ivtv_setscl(itv, 0);
#line 479
  ivtv_scldelay(itv);
#line 480
  ivtv_setsda(itv, nack);
#line 481
  ivtv_scldelay(itv);
#line 482
  ivtv_setscl(itv, 1);
#line 483
  ivtv_scldelay(itv);
#line 484
  ivtv_setscl(itv, 0);
#line 485
  ivtv_scldelay(itv);
#line 486
  if ((ivtv_debug & 512) != 0 && (ivtv_debug & 1024) != 0) {
#line 486
    printk("\016%s:  i2c: read %x\n", (char *)(& itv->v4l2_dev.name), (int )*byte);
  } else {

  }
#line 487
  return (0);
}
}
#line 492 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_start(struct ivtv *itv ) 
{ 
  int sda ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 496
  sda = ivtv_getsda(itv);
#line 497
  if (sda != 1) {
#line 498
    if ((ivtv_debug & 512) != 0 && (ivtv_debug & 1024) != 0) {
#line 498
      printk("\016%s:  i2c: SDA was low at start\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 499
    ivtv_setsda(itv, 1);
#line 500
    tmp = ivtv_waitsda(itv, 1);
#line 500
    if (tmp == 0) {
#line 501
      if ((ivtv_debug & 512) != 0) {
#line 501
        printk("\016%s:  i2c: SDA stuck low\n", (char *)(& itv->v4l2_dev.name));
      } else {

      }
#line 502
      return (-121);
    } else {

    }
  } else {

  }
#line 505
  tmp___1 = ivtv_getscl(itv);
#line 505
  if (tmp___1 != 1) {
#line 506
    ivtv_setscl(itv, 1);
#line 507
    tmp___0 = ivtv_waitscl(itv, 1);
#line 507
    if (tmp___0 == 0) {
#line 508
      if ((ivtv_debug & 512) != 0) {
#line 508
        printk("\016%s:  i2c: SCL stuck low at start\n", (char *)(& itv->v4l2_dev.name));
      } else {

      }
#line 509
      return (-121);
    } else {

    }
  } else {

  }
#line 512
  ivtv_setsda(itv, 0);
#line 513
  ivtv_scldelay(itv);
#line 514
  return (0);
}
}
#line 518 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_stop(struct ivtv *itv ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 522
  tmp___0 = ivtv_getscl(itv);
#line 522
  if (tmp___0 != 0) {
#line 523
    if ((ivtv_debug & 512) != 0 && (ivtv_debug & 1024) != 0) {
#line 523
      printk("\016%s:  i2c: SCL not low when stopping\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 524
    ivtv_setscl(itv, 0);
#line 525
    tmp = ivtv_waitscl(itv, 0);
#line 525
    if (tmp == 0) {
#line 526
      if ((ivtv_debug & 512) != 0) {
#line 526
        printk("\016%s:  i2c: SCL could not be set low\n", (char *)(& itv->v4l2_dev.name));
      } else {

      }
    } else {

    }
  } else {

  }
#line 529
  ivtv_setsda(itv, 0);
#line 530
  ivtv_scldelay(itv);
#line 531
  ivtv_setscl(itv, 1);
#line 532
  tmp___1 = ivtv_waitscl(itv, 1);
#line 532
  if (tmp___1 == 0) {
#line 533
    if ((ivtv_debug & 512) != 0) {
#line 533
      printk("\016%s:  i2c: SCL could not be set high\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 534
    return (-121);
  } else {

  }
#line 536
  ivtv_scldelay(itv);
#line 537
  ivtv_setsda(itv, 1);
#line 538
  tmp___2 = ivtv_waitsda(itv, 1);
#line 538
  if (tmp___2 == 0) {
#line 539
    if ((ivtv_debug & 512) != 0) {
#line 539
      printk("\016%s:  i2c: resetting I2C\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 540
    i = 0;
#line 540
    goto ldv_39235;
    ldv_39234: 
#line 541
    ivtv_setscl(itv, 0);
#line 542
    ivtv_scldelay(itv);
#line 543
    ivtv_setscl(itv, 1);
#line 544
    ivtv_scldelay(itv);
#line 545
    ivtv_setsda(itv, 1);
#line 540
    i = i + 1;
    ldv_39235: ;
#line 540
    if (i <= 15) {
#line 542
      goto ldv_39234;
    } else {

    }
#line 547
    ivtv_waitsda(itv, 1);
#line 548
    return (-121);
  } else {

  }
#line 550
  return (0);
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_write___0(struct ivtv *itv , unsigned char addr , unsigned char *data ,
                          u32 len , int do_stop ) 
{ 
  int retry ;
  int ret ;
  u32 i ;

  {
#line 557
  ret = -121;
#line 560
  retry = 0;
#line 560
  goto ldv_39251;
  ldv_39250: 
#line 561
  ret = ivtv_start(itv);
#line 563
  if (ret == 0) {
#line 564
    ret = ivtv_sendbyte(itv, (int )addr << 1U);
#line 565
    i = 0U;
#line 565
    goto ldv_39248;
    ldv_39247: 
#line 566
    ret = ivtv_sendbyte(itv, (int )*(data + (unsigned long )i));
#line 565
    i = i + 1U;
    ldv_39248: ;
#line 565
    if (ret == 0 && i < len) {
#line 567
      goto ldv_39247;
    } else {

    }

  } else {

  }
#line 568
  if (ret != 0 || do_stop != 0) {
#line 569
    ivtv_stop(itv);
  } else {

  }
#line 560
  retry = retry + 1;
  ldv_39251: ;
#line 560
  if (ret != 0 && retry <= 7) {
#line 562
    goto ldv_39250;
  } else {

  }

#line 572
  if (ret != 0) {
#line 573
    if ((ivtv_debug & 512) != 0) {
#line 573
      printk("\016%s:  i2c: i2c write to %x failed\n", (char *)(& itv->v4l2_dev.name),
             (int )addr);
    } else {

    }
  } else {

  }
#line 574
  return (ret);
}
}
#line 578 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_read___0(struct ivtv *itv , unsigned char addr , unsigned char *data ,
                         u32 len ) 
{ 
  int retry ;
  int ret ;
  u32 i ;

  {
#line 580
  ret = -121;
#line 583
  retry = 0;
#line 583
  goto ldv_39266;
  ldv_39265: 
#line 584
  ret = ivtv_start(itv);
#line 585
  if (ret == 0) {
#line 586
    ret = ivtv_sendbyte(itv, (int )((unsigned char )((int )((signed char )((int )addr << 1)) | 1)));
  } else {

  }
#line 587
  i = 0U;
#line 587
  goto ldv_39263;
  ldv_39262: 
#line 588
  ret = ivtv_readbyte(itv, data + (unsigned long )i, len - 1U == i);
#line 587
  i = i + 1U;
  ldv_39263: ;
#line 587
  if (ret == 0 && i < len) {
#line 589
    goto ldv_39262;
  } else {

  }
#line 590
  ivtv_stop(itv);
#line 583
  retry = retry + 1;
  ldv_39266: ;
#line 583
  if (ret != 0 && retry <= 7) {
#line 585
    goto ldv_39265;
  } else {

  }

#line 592
  if (ret != 0) {
#line 593
    if ((ivtv_debug & 512) != 0) {
#line 593
      printk("\016%s:  i2c: i2c read from %x failed\n", (char *)(& itv->v4l2_dev.name),
             (int )addr);
    } else {

    }
  } else {

  }
#line 594
  return (ret);
}
}
#line 600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_xfer(struct i2c_adapter *i2c_adap , struct i2c_msg *msgs , int num ) 
{ 
  struct v4l2_device *v4l2_dev ;
  void *tmp ;
  struct ivtv *itv ;
  struct ivtv *tmp___0 ;
  int retval ;
  int i ;
  int stop ;

  {
#line 602
  tmp = i2c_get_adapdata((struct i2c_adapter  const  *)i2c_adap);
#line 602
  v4l2_dev = (struct v4l2_device *)tmp;
#line 603
  tmp___0 = to_ivtv(v4l2_dev);
#line 603
  itv = tmp___0;
#line 607
  mutex_lock_nested(& itv->i2c_bus_lock, 0U);
#line 608
  retval = 0;
#line 608
  i = retval;
#line 608
  goto ldv_39279;
  ldv_39278: ;
#line 609
  if ((int )(msgs + (unsigned long )i)->flags & 1) {
#line 610
    retval = ivtv_read___0(itv, (int )((unsigned char )(msgs + (unsigned long )i)->addr),
                           (msgs + (unsigned long )i)->buf, (u32 )(msgs + (unsigned long )i)->len);
  } else {
#line 613
    stop = i + 1 >= num || (unsigned int )(msgs + ((unsigned long )i + 1UL))->flags != 1U;
#line 615
    retval = ivtv_write___0(itv, (int )((unsigned char )(msgs + (unsigned long )i)->addr),
                            (msgs + (unsigned long )i)->buf, (u32 )(msgs + (unsigned long )i)->len,
                            stop);
  }
#line 608
  i = i + 1;
  ldv_39279: ;
#line 608
  if (retval == 0 && i < num) {
#line 610
    goto ldv_39278;
  } else {

  }
#line 618
  mutex_unlock(& itv->i2c_bus_lock);
#line 619
  return (retval != 0 ? retval : num);
}
}
#line 623 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static u32 ivtv_functionality(struct i2c_adapter *adap ) 
{ 


  {
#line 625
  return (251592713U);
}
}
#line 628 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static struct i2c_algorithm ivtv_algo  =    {& ivtv_xfer, 0, & ivtv_functionality, 0, 0};
#line 634 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static struct i2c_adapter ivtv_i2c_adap_hw_template  = 
#line 634
     {& __this_module, 0U, (struct i2c_algorithm  const  *)(& ivtv_algo), (void *)0,
    {{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}, {0}, 0, 0, 0, 0, 0, 0, 0}, 0, 0,
    {0, 0, {0, {0, 0}, 0, 0, 0, 0, {{0}}, {{{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}},
                                           {{0, 0}, 0UL, 0, 0UL, 0U, 0, 0, 0, {(char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0},
                                            {0, {0, 0}, 0, 0, 0UL}}, 0, 0}, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     0, 0, {{0}, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}},
     0, 0, 0, 0, {{0}, (unsigned char)0, (unsigned char)0, (_Bool)0, (_Bool)0, (_Bool)0,
                  (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, {{{{{0}}, 0U, 0U, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                  {0, 0}, {0U, {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0,
                                                                                 0}}},
                  0, (_Bool)0, (_Bool)0, {{0, 0}, 0UL, 0, 0UL, 0U, 0, 0, 0, {(char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0},
                                          {0, {0, 0}, 0, 0, 0UL}}, 0UL, {{0L}, {0,
                                                                                0},
                                                                         0, {0, {0,
                                                                                 0},
                                                                             0, 0,
                                                                             0UL}},
                  {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}, 0, {0},
                  {0}, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                  (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                  (unsigned char)0, (unsigned char)0, (unsigned char)0, 0, 0, 0, 0,
                  0UL, 0UL, 0UL, 0UL, 0, 0, 0}, 0, 0, 0, 0, 0ULL, 0UL, 0, {0, 0},
     0, 0, {0, 0}, 0, 0, 0U, 0U, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0,
                                                                                  0},
     {0, {0, 0}, {{0}}}, 0, 0, 0, 0, (_Bool)0, (_Bool)0}, 0, {'i', 'v', 't', 'v',
                                                              ' ', 'i', '2', 'c',
                                                              ' ', 'd', 'r', 'i',
                                                              'v', 'e', 'r', '\000'},
    {0U, {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}}, {{0}, {{{{{0}},
                                                                             0U, 0U,
                                                                             0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                                     {0, 0}, 0, 0,
                                                                     {0, {0, 0}, 0,
                                                                      0, 0UL}}, {0,
                                                                                 0},
    0, 0};
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static void ivtv_setscl_old(void *data , int state ) 
{ 
  struct ivtv *itv ;

  {
#line 643
  itv = (struct ivtv *)data;
#line 645
  if (state != 0) {
#line 646
    itv->i2c_state = itv->i2c_state | 1;
  } else {
#line 648
    itv->i2c_state = itv->i2c_state & -2;
  }
#line 652
  writel((unsigned int )(~ itv->i2c_state), itv->reg_mem + 28672UL);
#line 653
  return;
}
}
#line 655 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static void ivtv_setsda_old(void *data , int state ) 
{ 
  struct ivtv *itv ;

  {
#line 657
  itv = (struct ivtv *)data;
#line 659
  if (state != 0) {
#line 660
    itv->i2c_state = itv->i2c_state | 1;
  } else {
#line 662
    itv->i2c_state = itv->i2c_state & -2;
  }
#line 666
  writel((unsigned int )(~ itv->i2c_state), itv->reg_mem + 28676UL);
#line 667
  return;
}
}
#line 669 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_getscl_old(void *data ) 
{ 
  struct ivtv *itv ;
  unsigned int tmp ;

  {
#line 671
  itv = (struct ivtv *)data;
#line 673
  tmp = readl((void const volatile   *)itv->reg_mem + 28680U);
#line 673
  return ((int )tmp & 1);
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static int ivtv_getsda_old(void *data ) 
{ 
  struct ivtv *itv ;
  unsigned int tmp ;

  {
#line 678
  itv = (struct ivtv *)data;
#line 680
  tmp = readl((void const volatile   *)itv->reg_mem + 28684U);
#line 680
  return ((int )tmp & 1);
}
}
#line 684 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static struct i2c_adapter ivtv_i2c_adap_template  = 
#line 684
     {& __this_module, 0U, (struct i2c_algorithm  const  *)0, (void *)0, {{{{0}}, 0U,
                                                                         0U, 0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                        {0}, 0, 0,
                                                                        0, 0, 0, 0,
                                                                        0}, 0, 0,
    {0, 0, {0, {0, 0}, 0, 0, 0, 0, {{0}}, {{{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}},
                                           {{0, 0}, 0UL, 0, 0UL, 0U, 0, 0, 0, {(char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0},
                                            {0, {0, 0}, 0, 0, 0UL}}, 0, 0}, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     0, 0, {{0}, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}},
     0, 0, 0, 0, {{0}, (unsigned char)0, (unsigned char)0, (_Bool)0, (_Bool)0, (_Bool)0,
                  (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, {{{{{0}}, 0U, 0U, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                  {0, 0}, {0U, {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0,
                                                                                 0}}},
                  0, (_Bool)0, (_Bool)0, {{0, 0}, 0UL, 0, 0UL, 0U, 0, 0, 0, {(char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0},
                                          {0, {0, 0}, 0, 0, 0UL}}, 0UL, {{0L}, {0,
                                                                                0},
                                                                         0, {0, {0,
                                                                                 0},
                                                                             0, 0,
                                                                             0UL}},
                  {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}, 0, {0},
                  {0}, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                  (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                  (unsigned char)0, (unsigned char)0, (unsigned char)0, 0, 0, 0, 0,
                  0UL, 0UL, 0UL, 0UL, 0, 0, 0}, 0, 0, 0, 0, 0ULL, 0UL, 0, {0, 0},
     0, 0, {0, 0}, 0, 0, 0U, 0U, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0,
                                                                                  0},
     {0, {0, 0}, {{0}}}, 0, 0, 0, 0, (_Bool)0, (_Bool)0}, 0, {'i', 'v', 't', 'v',
                                                              ' ', 'i', '2', 'c',
                                                              ' ', 'd', 'r', 'i',
                                                              'v', 'e', 'r', '\000'},
    {0U, {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}}, {{0}, {{{{{0}},
                                                                             0U, 0U,
                                                                             0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                                     {0, 0}, 0, 0,
                                                                     {0, {0, 0}, 0,
                                                                      0, 0UL}}, {0,
                                                                                 0},
    0, 0};
#line 693 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static struct i2c_algo_bit_data  const  ivtv_i2c_algo_template  = 
#line 693
     {0, & ivtv_setsda_old, & ivtv_setscl_old, & ivtv_getsda_old, & ivtv_getscl_old,
    0, 0, 10, 500};
#line 702 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
static struct i2c_client ivtv_i2c_client_template  = 
#line 702
     {(unsigned short)0, (unsigned short)0, {'i', 'v', 't', 'v', ' ', 'i', 'n', 't',
                                           'e', 'r', 'n', 'a', 'l', '\000'}, 0, {0,
                                                                                 0,
                                                                                 {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  {{0}},
                                                                                  {{{0L},
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}},
                                                                                   {{0,
                                                                                     0},
                                                                                    0UL,
                                                                                    0,
                                                                                    0UL,
                                                                                    0U,
                                                                                    0,
                                                                                    0,
                                                                                    0,
                                                                                    {(char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0},
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}},
                                                                                   0,
                                                                                   0},
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0},
                                                                                 0,
                                                                                 0,
                                                                                 {{0},
                                                                                  {{{{{0}},
                                                                                     0U,
                                                                                     0U,
                                                                                     0,
                                                                                     {0,
                                                                                      {0,
                                                                                       0},
                                                                                      0,
                                                                                      0,
                                                                                      0UL}}}},
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  {0,
                                                                                   {0,
                                                                                    0},
                                                                                   0,
                                                                                   0,
                                                                                   0UL}},
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 {{0},
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  {{{{{0}},
                                                                                     0U,
                                                                                     0U,
                                                                                     0,
                                                                                     {0,
                                                                                      {0,
                                                                                       0},
                                                                                      0,
                                                                                      0,
                                                                                      0UL}}}},
                                                                                  {0,
                                                                                   0},
                                                                                  {0U,
                                                                                   {{{{{{0}},
                                                                                       0U,
                                                                                       0U,
                                                                                       0,
                                                                                       {0,
                                                                                        {0,
                                                                                         0},
                                                                                        0,
                                                                                        0,
                                                                                        0UL}}}},
                                                                                    {0,
                                                                                     0}}},
                                                                                  0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  {{0,
                                                                                    0},
                                                                                   0UL,
                                                                                   0,
                                                                                   0UL,
                                                                                   0U,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   {(char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0},
                                                                                   {0,
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    0,
                                                                                    0UL}},
                                                                                  0UL,
                                                                                  {{0L},
                                                                                   {0,
                                                                                    0},
                                                                                   0,
                                                                                   {0,
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    0,
                                                                                    0UL}},
                                                                                  {{{{{{0}},
                                                                                      0U,
                                                                                      0U,
                                                                                      0,
                                                                                      {0,
                                                                                       {0,
                                                                                        0},
                                                                                       0,
                                                                                       0,
                                                                                       0UL}}}},
                                                                                   {0,
                                                                                    0}},
                                                                                  0,
                                                                                  {0},
                                                                                  {0},
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  0UL,
                                                                                  0UL,
                                                                                  0UL,
                                                                                  0UL,
                                                                                  0,
                                                                                  0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 0ULL,
                                                                                 0UL,
                                                                                 0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0U,
                                                                                 0U,
                                                                                 {{{{{0}},
                                                                                    0U,
                                                                                    0U,
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}}}},
                                                                                 {0,
                                                                                  0},
                                                                                 {0,
                                                                                  {0,
                                                                                   0},
                                                                                  {{0}}},
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 (_Bool)0,
                                                                                 (_Bool)0},
    0, {0, 0}, 0};
#line 707 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
int init_ivtv_i2c(struct ivtv *itv ) 
{ 
  int retval ;
  size_t tmp ;

  {
#line 711
  if ((ivtv_debug & 512) != 0) {
#line 711
    printk("\016%s:  i2c: i2c init\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 720
  if (itv->options.newi2c > 0) {
#line 721
    itv->i2c_adap = ivtv_i2c_adap_hw_template;
  } else {
#line 723
    itv->i2c_adap = ivtv_i2c_adap_template;
#line 724
    itv->i2c_algo = ivtv_i2c_algo_template;
  }
#line 726
  itv->i2c_algo.udelay = itv->options.i2c_clock_period / 2;
#line 727
  itv->i2c_algo.data = (void *)itv;
#line 728
  itv->i2c_adap.algo_data = (void *)(& itv->i2c_algo);
#line 730
  tmp = strlen((char const   *)(& itv->i2c_adap.name));
#line 730
  sprintf((char *)(& itv->i2c_adap.name) + tmp, " #%d", (int )itv->instance);
#line 732
  i2c_set_adapdata(& itv->i2c_adap, (void *)(& itv->v4l2_dev));
#line 734
  itv->i2c_client = ivtv_i2c_client_template;
#line 735
  itv->i2c_client.adapter = & itv->i2c_adap;
#line 736
  itv->i2c_adap.dev.parent = & (itv->pdev)->dev;
#line 738
  if ((ivtv_debug & 512) != 0) {
#line 738
    printk("\016%s:  i2c: setting scl and sda to 1\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 739
  ivtv_setscl(itv, 1);
#line 740
  ivtv_setsda(itv, 1);
#line 742
  if (itv->options.newi2c > 0) {
#line 743
    retval = i2c_add_adapter(& itv->i2c_adap);
  } else {
#line 745
    retval = i2c_bit_add_bus(& itv->i2c_adap);
  }
#line 747
  return (retval);
}
}
#line 750 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.c"
void exit_ivtv_i2c(struct ivtv *itv ) 
{ 


  {
#line 752
  if ((ivtv_debug & 512) != 0) {
#line 752
    printk("\016%s:  i2c: i2c exit\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 754
  i2c_del_adapter(& itv->i2c_adap);
#line 755
  return;
}
}
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.o.c.prepared"
void ldv_initialize_i2c_algorithm_9(void) 
{ 
  void *tmp ;

  {
#line 116
  tmp = ldv_init_zalloc(1936UL);
#line 116
  ivtv_algo_group0 = (struct i2c_adapter *)tmp;
#line 117
  return;
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.o.c.prepared"
void ldv_main_exported_8(void) 
{ 
  int ldvarg109 ;
  int ldvarg107 ;
  void *ldvarg106 ;
  void *tmp ;
  void *ldvarg108 ;
  void *tmp___0 ;
  void *ldvarg110 ;
  void *tmp___1 ;
  void *ldvarg111 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 122
  tmp = ldv_init_zalloc(1UL);
#line 122
  ldvarg106 = tmp;
#line 123
  tmp___0 = ldv_init_zalloc(1UL);
#line 123
  ldvarg108 = tmp___0;
#line 124
  tmp___1 = ldv_init_zalloc(1UL);
#line 124
  ldvarg110 = tmp___1;
#line 125
  tmp___2 = ldv_init_zalloc(1UL);
#line 125
  ldvarg111 = tmp___2;
#line 120
  ldv_memset((void *)(& ldvarg109), 0, 4UL);
#line 121
  ldv_memset((void *)(& ldvarg107), 0, 4UL);
#line 127
  tmp___3 = __VERIFIER_nondet_int();
#line 127
  switch (tmp___3) {
  case 0: ;
#line 130
  if (ldv_state_variable_8 == 1) {
#line 132
    ivtv_getscl_old(ldvarg111);
#line 134
    ldv_state_variable_8 = 1;
  } else {

  }
#line 137
  goto ldv_39331;
  case 1: ;
#line 140
  if (ldv_state_variable_8 == 1) {
#line 142
    ivtv_getsda_old(ldvarg110);
#line 144
    ldv_state_variable_8 = 1;
  } else {

  }
#line 147
  goto ldv_39331;
  case 2: ;
#line 150
  if (ldv_state_variable_8 == 1) {
#line 152
    ivtv_setsda_old(ldvarg108, ldvarg109);
#line 154
    ldv_state_variable_8 = 1;
  } else {

  }
#line 157
  goto ldv_39331;
  case 3: ;
#line 160
  if (ldv_state_variable_8 == 1) {
#line 162
    ivtv_setscl_old(ldvarg106, ldvarg107);
#line 164
    ldv_state_variable_8 = 1;
  } else {

  }
#line 167
  goto ldv_39331;
  default: 
#line 168
  ldv_stop();
  }
  ldv_39331: ;
#line 172
  return;
}
}
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.o.c.prepared"
void ldv_main_exported_9(void) 
{ 
  int ldvarg100 ;
  struct i2c_msg *ldvarg101 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 176
  tmp = ldv_init_zalloc(16UL);
#line 176
  ldvarg101 = (struct i2c_msg *)tmp;
#line 175
  ldv_memset((void *)(& ldvarg100), 0, 4UL);
#line 178
  tmp___0 = __VERIFIER_nondet_int();
#line 178
  switch (tmp___0) {
  case 0: ;
#line 181
  if (ldv_state_variable_9 == 1) {
#line 183
    ivtv_xfer(ivtv_algo_group0, ldvarg101, ldvarg100);
#line 185
    ldv_state_variable_9 = 1;
  } else {

  }
#line 188
  goto ldv_39342;
  case 1: ;
#line 191
  if (ldv_state_variable_9 == 1) {
#line 193
    ivtv_functionality(ivtv_algo_group0);
#line 195
    ldv_state_variable_9 = 1;
  } else {

  }
#line 198
  goto ldv_39342;
  default: 
#line 199
  ldv_stop();
  }
  ldv_39342: ;
#line 203
  return;
}
}
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.o.c.prepared"
bool ldv_queue_work_on_117(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 232
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 232
  ldv_func_res = tmp;
#line 234
  activate_work_2(ldv_func_arg3, 2);
#line 236
  return (ldv_func_res);
}
}
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.o.c.prepared"
bool ldv_queue_delayed_work_on_118(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 243
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 243
  ldv_func_res = tmp;
#line 245
  activate_work_2(& ldv_func_arg3->work, 2);
#line 247
  return (ldv_func_res);
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.o.c.prepared"
bool ldv_queue_work_on_119(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 254
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 254
  ldv_func_res = tmp;
#line 256
  activate_work_2(ldv_func_arg3, 2);
#line 258
  return (ldv_func_res);
}
}
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.o.c.prepared"
void ldv_flush_workqueue_120(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 264
  flush_workqueue(ldv_func_arg1);
#line 266
  call_and_disable_all_2(2);
#line 267
  return;
}
}
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-i2c.o.c.prepared"
bool ldv_queue_delayed_work_on_121(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 273
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 273
  ldv_func_res = tmp;
#line 275
  activate_work_2(& ldv_func_arg3->work, 2);
#line 277
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_131(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_133(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_132(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_134(struct workqueue_struct *ldv_func_arg1 ) ;
#line 2847 "include/linux/sched.h"
__inline static int signal_pending___1(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 2849
  tmp = test_tsk_thread_flag(p, 2);
#line 2849
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2849
  return ((int )tmp___0);
}
}
#line 1481 "include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
#line 1483
  tmp = dev_name(& pdev->dev);
#line 1483
  return (tmp);
}
}
#line 792 "include/media/v4l2-ctrls.h"
extern struct v4l2_subscribed_event_ops  const  v4l2_ctrl_sub_ev_ops ;
#line 35 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-streams.h"
int ivtv_passthrough_mode(struct ivtv *itv , int enable ) ;
#line 40 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-yuv.h"
int ivtv_yuv_prep_frame(struct ivtv *itv , struct ivtv_dma_frame *args ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-ioctl.h"
u16 ivtv_service2vbi(int type ) ;
#line 29
void ivtv_set_funcs(struct video_device *vdev ) ;
#line 127 "include/media/v4l2-event.h"
extern int v4l2_event_subscribe(struct v4l2_fh * , struct v4l2_event_subscription  const  * ,
                                unsigned int  , struct v4l2_subscribed_event_ops  const  * ) ;
#line 130
extern int v4l2_event_unsubscribe(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
u16 ivtv_service2vbi(int type ) 
{ 


  {
#line 42
  switch (type) {
  case 1: ;
#line 44
  return (1U);
  case 4096: ;
#line 46
  return (4U);
  case 16384: ;
#line 48
  return (5U);
  case 1024: ;
#line 50
  return (7U);
  default: ;
#line 52
  return (0U);
  }
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int valid_service_line(int field , int line , int is_pal ) 
{ 


  {
#line 58
  return (((is_pal != 0 && line > 5) && (line != 23 || field == 0)) || ((is_pal == 0 && line > 9) && line <= 21));
}
}
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static u16 select_service_from_set(int field , int line , u16 set , int is_pal ) 
{ 
  u16 valid_set ;
  int i ;
  int tmp ;

  {
#line 64
  valid_set = is_pal != 0 ? 17409U : 4096U;
#line 67
  set = (u16 )((int )set & (int )valid_set);
#line 68
  if ((unsigned int )set == 0U) {
#line 69
    return (0U);
  } else {
#line 68
    tmp = valid_service_line(field, line, is_pal);
#line 68
    if (tmp == 0) {
#line 69
      return (0U);
    } else {

    }
  }
#line 71
  if (is_pal == 0) {
#line 72
    if (line == 21 && ((int )set & 4096) != 0) {
#line 73
      return (4096U);
    } else {

    }
  } else {
#line 76
    if ((line == 16 && field == 0) && ((int )set & 1024) != 0) {
#line 77
      return (1024U);
    } else {

    }
#line 78
    if ((line == 23 && field == 0) && ((int )set & 16384) != 0) {
#line 79
      return (16384U);
    } else {

    }
#line 80
    if (line == 23) {
#line 81
      return (0U);
    } else {

    }
  }
#line 83
  i = 0;
#line 83
  goto ldv_41992;
  ldv_41991: ;
#line 84
  if (((int )set >> i) & 1) {
#line 85
    return ((u16 )(1 << i));
  } else {

  }
#line 83
  i = i + 1;
  ldv_41992: ;
#line 83
  if (i <= 31) {
#line 85
    goto ldv_41991;
  } else {

  }

#line 87
  return (0U);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
void ivtv_expand_service_set(struct v4l2_sliced_vbi_format *fmt , int is_pal ) 
{ 
  u16 set ;
  int f ;
  int l ;

  {
#line 92
  set = fmt->service_set;
#line 95
  fmt->service_set = 0U;
#line 96
  f = 0;
#line 96
  goto ldv_42005;
  ldv_42004: 
#line 97
  l = 0;
#line 97
  goto ldv_42002;
  ldv_42001: 
#line 98
  fmt->service_lines[f][l] = select_service_from_set(f, l, (int )set, is_pal);
#line 97
  l = l + 1;
  ldv_42002: ;
#line 97
  if (l <= 23) {
#line 99
    goto ldv_42001;
  } else {

  }
#line 96
  f = f + 1;
  ldv_42005: ;
#line 96
  if (f <= 1) {
#line 98
    goto ldv_42004;
  } else {

  }

#line 103
  return;
}
}
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static void check_service_set(struct v4l2_sliced_vbi_format *fmt , int is_pal ) 
{ 
  int f ;
  int l ;

  {
#line 107
  f = 0;
#line 107
  goto ldv_42017;
  ldv_42016: 
#line 108
  l = 0;
#line 108
  goto ldv_42014;
  ldv_42013: 
#line 109
  fmt->service_lines[f][l] = select_service_from_set(f, l, (int )fmt->service_lines[f][l],
                                                     is_pal);
#line 108
  l = l + 1;
  ldv_42014: ;
#line 108
  if (l <= 23) {
#line 110
    goto ldv_42013;
  } else {

  }
#line 107
  f = f + 1;
  ldv_42017: ;
#line 107
  if (f <= 1) {
#line 109
    goto ldv_42016;
  } else {

  }

#line 114
  return;
}
}
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
u16 ivtv_get_service_set(struct v4l2_sliced_vbi_format *fmt ) 
{ 
  int f ;
  int l ;
  u16 set ;

  {
#line 117
  set = 0U;
#line 119
  f = 0;
#line 119
  goto ldv_42029;
  ldv_42028: 
#line 120
  l = 0;
#line 120
  goto ldv_42026;
  ldv_42025: 
#line 121
  set = (u16 )((int )fmt->service_lines[f][l] | (int )set);
#line 120
  l = l + 1;
  ldv_42026: ;
#line 120
  if (l <= 23) {
#line 122
    goto ldv_42025;
  } else {

  }
#line 119
  f = f + 1;
  ldv_42029: ;
#line 119
  if (f <= 1) {
#line 121
    goto ldv_42028;
  } else {

  }

#line 124
  return (set);
}
}
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
void ivtv_set_osd_alpha(struct ivtv *itv ) 
{ 


  {
#line 129
  ivtv_vapi(itv, 75, 3, itv->osd_global_alpha_state, (int )itv->osd_global_alpha,
            itv->osd_local_alpha_state == 0);
#line 131
  ivtv_vapi(itv, 96, 2, itv->osd_chroma_key_state, itv->osd_chroma_key);
#line 132
  return;
}
}
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
int ivtv_set_speed(struct ivtv *itv , int speed ) 
{ 
  u32 data[16U] ;
  int single_step ;
  wait_queue_t wait ;
  struct task_struct *tmp ;
  s32 tmp___0 ;
  int got_sig ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 137
  single_step = speed == 1 || speed == -1;
#line 138
  tmp = get_current();
#line 138
  wait.flags = 0U;
#line 138
  wait.private = (void *)tmp;
#line 138
  wait.func = & autoremove_wake_function;
#line 138
  wait.task_list.next = & wait.task_list;
#line 138
  wait.task_list.prev = & wait.task_list;
#line 140
  if (speed == 0) {
#line 140
    speed = 1000;
  } else {

  }
#line 143
  if (itv->speed == speed && single_step == 0) {
#line 144
    return (0);
  } else {

  }
#line 146
  if (single_step != 0 && (speed >= 0) ^ (itv->speed < 0)) {
#line 148
    ivtv_vapi(itv, 5, 1, 0);
#line 149
    itv->speed = speed;
#line 150
    return (0);
  } else {

  }
#line 152
  if (single_step != 0) {
#line 154
    speed = speed < 0 ? -1000 : 1000;
  } else {

  }
#line 156
  data[0] = speed > 1000 || speed < -1000 ? 2147483648U : 0U;
#line 157
  data[0] = data[0] | (speed > 1000 || speed < -1500 ? 1073741824U : 0U);
#line 158
  data[1] = speed < 0;
#line 159
  data[2] = speed < 0 ? 3U : 7U;
#line 160
  tmp___0 = v4l2_ctrl_g_ctrl(itv->cxhdl.__annonCompField93.video_b_frames);
#line 160
  data[3] = (u32 )tmp___0;
#line 161
  data[4] = speed == 1500 || speed == 500 ? (u32 )itv->speed_mute_audio : 0U;
#line 162
  data[5] = 0U;
#line 163
  data[6] = 0U;
#line 165
  if (speed == 1500 || speed == -1500) {
#line 165
    data[0] = data[0] | 1U;
  } else
#line 166
  if (speed == 2000 || speed == -2000) {
#line 166
    data[0] = data[0] | 2U;
  } else
#line 167
  if (speed >= -999 && speed < 0) {
#line 167
    data[0] = data[0] | (u32 )(-1000 / speed);
  } else
#line 168
  if (speed <= 999 && speed > 0) {
#line 168
    data[0] = data[0] | (u32 )(1000 / speed);
  } else {

  }
#line 171
  tmp___3 = atomic_read((atomic_t const   *)(& itv->decoding));
#line 171
  if (tmp___3 > 0) {
#line 172
    got_sig = 0;
#line 175
    ivtv_vapi(itv, 13, 1, 0);
#line 178
    mutex_unlock(& itv->serialize_lock);
#line 179
    prepare_to_wait(& itv->dma_waitq, & wait, 1);
#line 180
    goto ldv_42044;
    ldv_42043: 
#line 181
    tmp___1 = get_current();
#line 181
    got_sig = signal_pending___1(tmp___1);
#line 182
    if (got_sig != 0) {
#line 183
      goto ldv_42042;
    } else {

    }
#line 184
    got_sig = 0;
#line 185
    schedule();
    ldv_42044: 
#line 180
    tmp___2 = constant_test_bit(0L, (unsigned long const volatile   *)(& itv->i_flags));
#line 180
    if (tmp___2 != 0) {
#line 182
      goto ldv_42043;
    } else {

    }
    ldv_42042: 
#line 187
    finish_wait(& itv->dma_waitq, & wait);
#line 188
    mutex_lock_nested(& itv->serialize_lock, 0U);
#line 189
    if (got_sig != 0) {
#line 190
      return (-4);
    } else {

    }
#line 193
    ivtv_api(itv, 3, 7, (u32 *)(& data));
#line 194
    if ((ivtv_debug & 2) != 0) {
#line 194
      printk("\016%s:  info: Setting Speed to 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",
             (char *)(& itv->v4l2_dev.name), data[0], data[1], data[2], data[3], data[4],
             data[5], data[6]);
    } else {

    }
  } else {

  }
#line 197
  if (single_step != 0) {
#line 198
    speed = speed < 0 ? -1 : 1;
#line 199
    ivtv_vapi(itv, 5, 1, 0);
  } else {

  }
#line 201
  itv->speed = speed;
#line 202
  return (0);
}
}
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_validate_speed(int cur_speed , int new_speed ) 
{ 
  int fact ;
  int s ;

  {
#line 207
  fact = new_speed < 0 ? -1 : 1;
#line 210
  if (cur_speed == 0) {
#line 211
    cur_speed = 1000;
  } else {

  }
#line 212
  if (new_speed < 0) {
#line 213
    new_speed = - new_speed;
  } else {

  }
#line 214
  if (cur_speed < 0) {
#line 215
    cur_speed = - cur_speed;
  } else {

  }
#line 217
  if (cur_speed <= new_speed) {
#line 218
    if (new_speed > 1500) {
#line 219
      return (fact * 2000);
    } else {

    }
#line 220
    if (new_speed > 1000) {
#line 221
      return (fact * 1500);
    } else {

    }
  } else {
#line 224
    if (new_speed > 1999) {
#line 225
      return (fact * 2000);
    } else {

    }
#line 226
    if (new_speed > 1499) {
#line 227
      return (fact * 1500);
    } else {

    }
#line 228
    if (new_speed > 999) {
#line 229
      return (fact * 1000);
    } else {

    }
  }
#line 231
  if (new_speed == 0) {
#line 232
    return (1000);
  } else {

  }
#line 233
  if (new_speed == 1 || new_speed == 1000) {
#line 234
    return (fact * new_speed);
  } else {

  }
#line 236
  s = new_speed;
#line 237
  new_speed = 1000 / new_speed;
#line 238
  if (1000 / cur_speed == new_speed) {
#line 239
    new_speed = (cur_speed < s ? -1 : 1) + new_speed;
  } else {

  }
#line 240
  if (new_speed > 60) {
#line 240
    return (1000 / (fact * 60));
  } else {

  }
#line 241
  return (1000 / (fact * new_speed));
}
}
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_video_command(struct ivtv *itv , struct ivtv_open_id *id , struct v4l2_decoder_cmd *dc ,
                              int try ) 
{ 
  struct ivtv_stream *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int speed ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 247
  s = (struct ivtv_stream *)(& itv->streams) + 5UL;
#line 249
  if ((itv->v4l2_cap & 2U) == 0U) {
#line 250
    return (-22);
  } else {

  }
#line 252
  switch (dc->cmd) {
  case 0U: 
#line 254
  dc->flags = dc->flags & 1U;
#line 255
  dc->__annonCompField85.start.speed = ivtv_validate_speed(itv->speed, dc->__annonCompField85.start.speed);
#line 256
  if (dc->__annonCompField85.start.speed < 0) {
#line 257
    dc->__annonCompField85.start.format = 1U;
  } else {
#line 259
    dc->__annonCompField85.start.format = 0U;
  }
#line 260
  if (dc->__annonCompField85.start.speed != 500 && dc->__annonCompField85.start.speed != 1500) {
#line 261
    dc->flags = dc->__annonCompField85.start.speed != 1000;
  } else {

  }
#line 263
  if (try != 0) {
#line 263
    goto ldv_42059;
  } else {

  }
#line 265
  itv->speed_mute_audio = (unsigned int )((u8 )dc->flags) & 1U;
#line 266
  tmp = ivtv_set_output_mode(itv, 1);
#line 266
  if (tmp != 1) {
#line 267
    return (-16);
  } else {

  }
#line 268
  tmp___0 = test_and_clear_bit(20L, (unsigned long volatile   *)(& itv->i_flags));
#line 268
  if (tmp___0 != 0) {
#line 270
    itv->speed = 0;
  } else {

  }
#line 272
  tmp___1 = ivtv_start_decoding(id, dc->__annonCompField85.start.speed);
#line 272
  return (tmp___1);
  case 1U: 
#line 276
  dc->flags = dc->flags & 3U;
#line 277
  if ((dc->flags & 2U) != 0U) {
#line 278
    dc->__annonCompField85.stop.pts = 0ULL;
  } else {

  }
#line 279
  if (try != 0) {
#line 279
    goto ldv_42059;
  } else {

  }
#line 280
  tmp___2 = atomic_read((atomic_t const   *)(& itv->decoding));
#line 280
  if (tmp___2 == 0) {
#line 281
    return (0);
  } else {

  }
#line 282
  if (itv->output_mode != 1) {
#line 283
    return (-16);
  } else {

  }
#line 285
  itv->output_mode = 0;
#line 286
  tmp___3 = ivtv_stop_v4l2_decode_stream(s, (int )dc->flags, dc->__annonCompField85.stop.pts);
#line 286
  return (tmp___3);
  case 2U: 
#line 289
  dc->flags = dc->flags & 1U;
#line 290
  if (try != 0) {
#line 290
    goto ldv_42059;
  } else {

  }
#line 291
  tmp___4 = atomic_read((atomic_t const   *)(& itv->decoding));
#line 291
  if (tmp___4 == 0) {
#line 292
    return (-1);
  } else {

  }
#line 293
  if (itv->output_mode != 1) {
#line 294
    return (-16);
  } else {

  }
#line 295
  tmp___5 = atomic_read((atomic_t const   *)(& itv->decoding));
#line 295
  if (tmp___5 > 0) {
#line 296
    ivtv_vapi(itv, 13, 1, (int )dc->flags & 1);
#line 298
    set_bit(20L, (unsigned long volatile   *)(& itv->i_flags));
  } else {

  }
#line 300
  goto ldv_42059;
  case 3U: 
#line 303
  dc->flags = 0U;
#line 304
  if (try != 0) {
#line 304
    goto ldv_42059;
  } else {

  }
#line 305
  tmp___6 = atomic_read((atomic_t const   *)(& itv->decoding));
#line 305
  if (tmp___6 == 0) {
#line 306
    return (-1);
  } else {

  }
#line 307
  if (itv->output_mode != 1) {
#line 308
    return (-16);
  } else {

  }
#line 309
  tmp___8 = test_and_clear_bit(20L, (unsigned long volatile   *)(& itv->i_flags));
#line 309
  if (tmp___8 != 0) {
#line 310
    speed = itv->speed;
#line 311
    itv->speed = 0;
#line 312
    tmp___7 = ivtv_start_decoding(id, speed);
#line 312
    return (tmp___7);
  } else {

  }
#line 314
  goto ldv_42059;
  default: ;
#line 317
  return (-22);
  }
  ldv_42059: ;
#line 319
  return (0);
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_fmt_sliced_vbi_out(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  struct v4l2_sliced_vbi_format *vbifmt ;

  {
#line 324
  tmp = fh2id((struct v4l2_fh *)fh);
#line 324
  itv = tmp->itv;
#line 325
  vbifmt = & fmt->fmt.sliced;
#line 327
  vbifmt->reserved[0] = 0U;
#line 328
  vbifmt->reserved[1] = 0U;
#line 329
  if ((itv->v4l2_cap & 128U) == 0U) {
#line 330
    return (-22);
  } else {

  }
#line 331
  vbifmt->io_size = 2304U;
#line 332
  memset((void *)(& vbifmt->service_lines), 0, 96UL);
#line 333
  if ((unsigned int )itv->is_60hz != 0U) {
#line 334
    vbifmt->service_lines[0][21] = 4096U;
#line 335
    vbifmt->service_lines[1][21] = 4096U;
  } else {
#line 337
    vbifmt->service_lines[0][23] = 16384U;
#line 338
    vbifmt->service_lines[0][16] = 1024U;
  }
#line 340
  vbifmt->service_set = ivtv_get_service_set(vbifmt);
#line 341
  return (0);
}
}
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_fmt_vid_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  struct v4l2_pix_format *pixfmt ;

  {
#line 346
  tmp = fh2id((struct v4l2_fh *)fh);
#line 346
  id = tmp;
#line 347
  itv = id->itv;
#line 348
  pixfmt = & fmt->fmt.pix;
#line 350
  pixfmt->width = (__u32 )itv->cxhdl.width;
#line 351
  pixfmt->height = (__u32 )itv->cxhdl.height;
#line 352
  pixfmt->colorspace = 1U;
#line 353
  pixfmt->field = 4U;
#line 354
  if (id->type == 1) {
#line 355
    pixfmt->pixelformat = 842091848U;
#line 357
    pixfmt->sizeimage = (pixfmt->height * 2160U) / 2U;
#line 358
    pixfmt->bytesperline = 720U;
  } else {
#line 360
    pixfmt->pixelformat = 1195724877U;
#line 361
    pixfmt->sizeimage = 131072U;
#line 362
    pixfmt->bytesperline = 0U;
  }
#line 364
  return (0);
}
}
#line 367 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_fmt_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  struct v4l2_vbi_format *vbifmt ;
  __u32 tmp___0 ;

  {
#line 369
  tmp = fh2id((struct v4l2_fh *)fh);
#line 369
  itv = tmp->itv;
#line 370
  vbifmt = & fmt->fmt.vbi;
#line 372
  vbifmt->sampling_rate = 27000000U;
#line 373
  vbifmt->offset = 248U;
#line 374
  vbifmt->samples_per_line = itv->vbi.raw_decoder_line_size - 4U;
#line 375
  vbifmt->sample_format = 1497715271U;
#line 376
  vbifmt->start[0] = (__s32 )itv->vbi.start[0];
#line 377
  vbifmt->start[1] = (__s32 )itv->vbi.start[1];
#line 378
  tmp___0 = itv->vbi.count;
#line 378
  vbifmt->count[1] = tmp___0;
#line 378
  vbifmt->count[0] = tmp___0;
#line 379
  vbifmt->flags = 0U;
#line 380
  vbifmt->reserved[0] = 0U;
#line 381
  vbifmt->reserved[1] = 0U;
#line 382
  return (0);
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_fmt_sliced_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct v4l2_sliced_vbi_format *vbifmt ;
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;

  {
#line 387
  vbifmt = & fmt->fmt.sliced;
#line 388
  tmp = fh2id((struct v4l2_fh *)fh);
#line 388
  id = tmp;
#line 389
  itv = id->itv;
#line 391
  vbifmt->reserved[0] = 0U;
#line 392
  vbifmt->reserved[1] = 0U;
#line 393
  vbifmt->io_size = 2304U;
#line 395
  if (id->type == 6) {
#line 396
    vbifmt->service_set = (unsigned int )itv->is_50hz != 0U ? 17409U : 4096U;
#line 398
    ivtv_expand_service_set(vbifmt, (int )itv->is_50hz);
#line 399
    vbifmt->service_set = ivtv_get_service_set(vbifmt);
#line 400
    return (0);
  } else {

  }
#line 403
  if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 403
    if ((unsigned long )((itv->sd_video)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->vbi)->g_sliced_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                     struct v4l2_sliced_vbi_format * ))0)) {
#line 403
      (*((((itv->sd_video)->ops)->vbi)->g_sliced_fmt))(itv->sd_video, vbifmt);
    } else {

    }
  } else {

  }
#line 404
  vbifmt->service_set = ivtv_get_service_set(vbifmt);
#line 405
  return (0);
}
}
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_fmt_vid_out(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  struct v4l2_pix_format *pixfmt ;

  {
#line 410
  tmp = fh2id((struct v4l2_fh *)fh);
#line 410
  id = tmp;
#line 411
  itv = id->itv;
#line 412
  pixfmt = & fmt->fmt.pix;
#line 414
  if ((itv->v4l2_cap & 2U) == 0U) {
#line 415
    return (-22);
  } else {

  }
#line 416
  pixfmt->width = itv->main_rect.width;
#line 417
  pixfmt->height = itv->main_rect.height;
#line 418
  pixfmt->colorspace = 1U;
#line 419
  pixfmt->field = 4U;
#line 420
  if (id->type == 8) {
#line 421
    switch (itv->yuv_info.lace_mode & 3) {
    case 0: 
#line 423
    pixfmt->field = (itv->yuv_info.lace_mode & 4) != 0 ? 9U : 8U;
#line 425
    goto ldv_42104;
    case 1: 
#line 427
    pixfmt->field = 1U;
#line 428
    goto ldv_42104;
    default: 
#line 430
    pixfmt->field = 0U;
#line 431
    goto ldv_42104;
    }
    ldv_42104: 
#line 433
    pixfmt->pixelformat = 842091848U;
#line 434
    pixfmt->bytesperline = 720U;
#line 435
    pixfmt->width = itv->yuv_info.v4l2_src_w;
#line 436
    pixfmt->height = itv->yuv_info.v4l2_src_h;
#line 438
    pixfmt->sizeimage = ((pixfmt->height + 31U) & 4294967264U) * 1080U;
  } else {
#line 441
    pixfmt->pixelformat = 1195724877U;
#line 442
    pixfmt->sizeimage = 131072U;
#line 443
    pixfmt->bytesperline = 0U;
  }
#line 445
  return (0);
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_fmt_vid_out_overlay(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  struct ivtv_stream *s ;
  struct ivtv_open_id *tmp___0 ;
  struct v4l2_window *winfmt ;
  __s32 tmp___1 ;

  {
#line 450
  tmp = fh2id((struct v4l2_fh *)fh);
#line 450
  itv = tmp->itv;
#line 451
  tmp___0 = fh2id((struct v4l2_fh *)fh);
#line 451
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )tmp___0->type;
#line 452
  winfmt = & fmt->fmt.win;
#line 454
  if ((s->caps & 512U) == 0U) {
#line 455
    return (-22);
  } else {

  }
#line 456
  if (itv->osd_video_pbase == 0UL) {
#line 457
    return (-22);
  } else {

  }
#line 458
  winfmt->chromakey = itv->osd_chroma_key;
#line 459
  winfmt->global_alpha = itv->osd_global_alpha;
#line 460
  winfmt->field = 4U;
#line 461
  winfmt->clips = (struct v4l2_clip *)0;
#line 462
  winfmt->clipcount = 0U;
#line 463
  winfmt->bitmap = (void *)0;
#line 464
  tmp___1 = 0;
#line 464
  winfmt->w.left = tmp___1;
#line 464
  winfmt->w.top = tmp___1;
#line 465
  winfmt->w.width = itv->osd_rect.width;
#line 466
  winfmt->w.height = itv->osd_rect.height;
#line 467
  return (0);
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_try_fmt_sliced_vbi_out(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  int tmp ;

  {
#line 472
  tmp = ivtv_g_fmt_sliced_vbi_out(file, fh, fmt);
#line 472
  return (tmp);
}
}
#line 475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_try_fmt_vid_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  int w ;
  int h ;
  int min_h ;
  int _min1 ;
  int _min2 ;
  int _max1 ;
  int _max2 ;
  int _min1___0 ;
  int _min2___0 ;
  int _max1___0 ;
  int _max2___0 ;

  {
#line 477
  tmp = fh2id((struct v4l2_fh *)fh);
#line 477
  id = tmp;
#line 478
  itv = id->itv;
#line 479
  w = (int )fmt->fmt.pix.width;
#line 480
  h = (int )fmt->fmt.pix.height;
#line 481
  min_h = 2;
#line 483
  _min1 = w;
#line 483
  _min2 = 720;
#line 483
  w = _min1 < _min2 ? _min1 : _min2;
#line 484
  _max1 = w;
#line 484
  _max2 = 2;
#line 484
  w = _max1 > _max2 ? _max1 : _max2;
#line 485
  if (id->type == 1) {
#line 487
    h = h & -32;
#line 488
    min_h = 32;
  } else {

  }
#line 490
  _min1___0 = h;
#line 490
  _min2___0 = (unsigned int )itv->is_50hz != 0U ? 576 : 480;
#line 490
  h = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 491
  _max1___0 = h;
#line 491
  _max2___0 = min_h;
#line 491
  h = _max1___0 > _max2___0 ? _max1___0 : _max2___0;
#line 492
  ivtv_g_fmt_vid_cap(file, fh, fmt);
#line 493
  fmt->fmt.pix.width = (__u32 )w;
#line 494
  fmt->fmt.pix.height = (__u32 )h;
#line 495
  return (0);
}
}
#line 498 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_try_fmt_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  int tmp ;

  {
#line 500
  tmp = ivtv_g_fmt_vbi_cap(file, fh, fmt);
#line 500
  return (tmp);
}
}
#line 503 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_try_fmt_sliced_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct v4l2_sliced_vbi_format *vbifmt ;
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  int tmp___0 ;

  {
#line 505
  vbifmt = & fmt->fmt.sliced;
#line 506
  tmp = fh2id((struct v4l2_fh *)fh);
#line 506
  id = tmp;
#line 507
  itv = id->itv;
#line 509
  if (id->type == 6) {
#line 510
    tmp___0 = ivtv_g_fmt_sliced_vbi_cap(file, fh, fmt);
#line 510
    return (tmp___0);
  } else {

  }
#line 513
  vbifmt->io_size = 2304U;
#line 514
  vbifmt->reserved[0] = 0U;
#line 515
  vbifmt->reserved[1] = 0U;
#line 517
  if ((unsigned int )vbifmt->service_set != 0U) {
#line 518
    ivtv_expand_service_set(vbifmt, (int )itv->is_50hz);
  } else {

  }
#line 519
  check_service_set(vbifmt, (int )itv->is_50hz);
#line 520
  vbifmt->service_set = ivtv_get_service_set(vbifmt);
#line 521
  return (0);
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_try_fmt_vid_out(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  s32 w ;
  s32 h ;
  int field ;
  int ret ;
  int tmp___0 ;
  s32 _min1 ;
  int _min2 ;
  s32 _max1 ;
  int _max2 ;
  s32 _min1___0 ;
  int _min2___0 ;
  s32 _max1___0 ;
  int _max2___0 ;

  {
#line 526
  tmp = fh2id((struct v4l2_fh *)fh);
#line 526
  id = tmp;
#line 527
  w = (s32 )fmt->fmt.pix.width;
#line 528
  h = (s32 )fmt->fmt.pix.height;
#line 529
  field = (int )fmt->fmt.pix.field;
#line 530
  tmp___0 = ivtv_g_fmt_vid_out(file, fh, fmt);
#line 530
  ret = tmp___0;
#line 532
  _min1 = w;
#line 532
  _min2 = 720;
#line 532
  w = _min1 < _min2 ? _min1 : _min2;
#line 533
  _max1 = w;
#line 533
  _max2 = 2;
#line 533
  w = _max1 > _max2 ? _max1 : _max2;
#line 549
  _min1___0 = h;
#line 549
  _min2___0 = 576;
#line 549
  h = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 550
  _max1___0 = h;
#line 550
  _max2___0 = 2;
#line 550
  h = _max1___0 > _max2___0 ? _max1___0 : _max2___0;
#line 551
  if (id->type == 8) {
#line 552
    fmt->fmt.pix.field = (__u32 )field;
  } else {

  }
#line 553
  fmt->fmt.pix.width = (__u32 )w;
#line 554
  fmt->fmt.pix.height = (__u32 )h;
#line 555
  return (ret);
}
}
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_try_fmt_vid_out_overlay(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  struct ivtv_stream *s ;
  struct ivtv_open_id *tmp___0 ;
  u32 chromakey ;
  u8 global_alpha ;

  {
#line 560
  tmp = fh2id((struct v4l2_fh *)fh);
#line 560
  itv = tmp->itv;
#line 561
  tmp___0 = fh2id((struct v4l2_fh *)fh);
#line 561
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )tmp___0->type;
#line 562
  chromakey = fmt->fmt.win.chromakey;
#line 563
  global_alpha = fmt->fmt.win.global_alpha;
#line 565
  if ((s->caps & 512U) == 0U) {
#line 566
    return (-22);
  } else {

  }
#line 567
  if (itv->osd_video_pbase == 0UL) {
#line 568
    return (-22);
  } else {

  }
#line 569
  ivtv_g_fmt_vid_out_overlay(file, fh, fmt);
#line 570
  fmt->fmt.win.chromakey = chromakey;
#line 571
  fmt->fmt.win.global_alpha = global_alpha;
#line 572
  return (0);
}
}
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_s_fmt_sliced_vbi_out(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  int tmp ;

  {
#line 577
  tmp = ivtv_g_fmt_sliced_vbi_out(file, fh, fmt);
#line 577
  return (tmp);
}
}
#line 580 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_s_fmt_vid_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  struct v4l2_subdev_format format ;
  int ret ;
  int tmp___0 ;
  int w ;
  int h ;
  int tmp___1 ;
  s32 tmp___2 ;
  int tmp___3 ;

  {
#line 582
  tmp = fh2id((struct v4l2_fh *)fh);
#line 582
  id = tmp;
#line 583
  itv = id->itv;
#line 584
  format.which = 1U;
#line 584
  format.pad = 0U;
#line 584
  format.format.width = 0U;
#line 584
  format.format.height = 0U;
#line 584
  format.format.code = 0U;
#line 584
  format.format.field = 0U;
#line 584
  format.format.colorspace = 0U;
#line 584
  format.format.ycbcr_enc = (unsigned short)0;
#line 584
  format.format.quantization = (unsigned short)0;
#line 584
  format.format.xfer_func = (unsigned short)0;
#line 584
  format.format.reserved[0] = (unsigned short)0;
#line 584
  format.format.reserved[1] = (unsigned short)0;
#line 584
  format.format.reserved[2] = (unsigned short)0;
#line 584
  format.format.reserved[3] = (unsigned short)0;
#line 584
  format.format.reserved[4] = (unsigned short)0;
#line 584
  format.format.reserved[5] = (unsigned short)0;
#line 584
  format.format.reserved[6] = (unsigned short)0;
#line 584
  format.format.reserved[7] = (unsigned short)0;
#line 584
  format.format.reserved[8] = (unsigned short)0;
#line 584
  format.format.reserved[9] = (unsigned short)0;
#line 584
  format.format.reserved[10] = (unsigned short)0;
#line 584
  format.reserved[0] = 0U;
#line 584
  format.reserved[1] = 0U;
#line 584
  format.reserved[2] = 0U;
#line 584
  format.reserved[3] = 0U;
#line 584
  format.reserved[4] = 0U;
#line 584
  format.reserved[5] = 0U;
#line 584
  format.reserved[6] = 0U;
#line 584
  format.reserved[7] = 0U;
#line 587
  tmp___0 = ivtv_try_fmt_vid_cap(file, fh, fmt);
#line 587
  ret = tmp___0;
#line 588
  w = (int )fmt->fmt.pix.width;
#line 589
  h = (int )fmt->fmt.pix.height;
#line 591
  if (ret != 0) {
#line 592
    return (ret);
  } else {

  }
#line 594
  if ((int )itv->cxhdl.width == w && (int )itv->cxhdl.height == h) {
#line 595
    return (0);
  } else {

  }
#line 597
  tmp___1 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 597
  if (tmp___1 > 0) {
#line 598
    return (-16);
  } else {

  }
#line 600
  itv->cxhdl.width = (u16 )w;
#line 601
  itv->cxhdl.height = (u16 )h;
#line 602
  tmp___2 = v4l2_ctrl_g_ctrl(itv->cxhdl.__annonCompField94.video_encoding);
#line 602
  if (tmp___2 == 0) {
#line 603
    fmt->fmt.pix.width = fmt->fmt.pix.width / 2U;
  } else {

  }
#line 604
  format.format.width = fmt->fmt.pix.width;
#line 605
  format.format.height = (__u32 )h;
#line 606
  format.format.code = 1U;
#line 607
  if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 607
    if ((unsigned long )((itv->sd_video)->ops)->pad != (unsigned long )((struct v4l2_subdev_pad_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->pad)->set_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                struct v4l2_subdev_pad_config * ,
                                                                                                                                                                                                                                struct v4l2_subdev_format * ))0)) {
#line 607
      (*((((itv->sd_video)->ops)->pad)->set_fmt))(itv->sd_video, (struct v4l2_subdev_pad_config *)0,
                                                  & format);
    } else {

    }
  } else {

  }
#line 608
  tmp___3 = ivtv_g_fmt_vid_cap(file, fh, fmt);
#line 608
  return (tmp___3);
}
}
#line 611 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_s_fmt_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 613
  tmp = fh2id((struct v4l2_fh *)fh);
#line 613
  itv = tmp->itv;
#line 615
  tmp___0 = ivtv_raw_vbi((struct ivtv  const  *)itv);
#line 615
  if (tmp___0 == 0) {
#line 615
    tmp___1 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 615
    if (tmp___1 > 0) {
#line 616
      return (-16);
    } else {

    }
  } else {

  }
#line 617
  (itv->vbi.sliced_in)->service_set = 0U;
#line 618
  itv->vbi.in.type = 4U;
#line 619
  if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 619
    if ((unsigned long )((itv->sd_video)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->vbi)->s_raw_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                  struct v4l2_vbi_format * ))0)) {
#line 619
      (*((((itv->sd_video)->ops)->vbi)->s_raw_fmt))(itv->sd_video, & fmt->fmt.vbi);
    } else {

    }
  } else {

  }
#line 620
  tmp___2 = ivtv_g_fmt_vbi_cap(file, fh, fmt);
#line 620
  return (tmp___2);
}
}
#line 623 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_s_fmt_sliced_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct v4l2_sliced_vbi_format *vbifmt ;
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 625
  vbifmt = & fmt->fmt.sliced;
#line 626
  tmp = fh2id((struct v4l2_fh *)fh);
#line 626
  id = tmp;
#line 627
  itv = id->itv;
#line 628
  tmp___0 = ivtv_try_fmt_sliced_vbi_cap(file, fh, fmt);
#line 628
  ret = tmp___0;
#line 630
  if (ret != 0 || id->type == 6) {
#line 631
    return (ret);
  } else {

  }
#line 633
  check_service_set(vbifmt, (int )itv->is_50hz);
#line 634
  tmp___1 = ivtv_raw_vbi((struct ivtv  const  *)itv);
#line 634
  if (tmp___1 != 0) {
#line 634
    tmp___2 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 634
    if (tmp___2 > 0) {
#line 635
      return (-16);
    } else {

    }
  } else {

  }
#line 636
  itv->vbi.in.type = 6U;
#line 637
  if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 637
    if ((unsigned long )((itv->sd_video)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->vbi)->s_sliced_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                     struct v4l2_sliced_vbi_format * ))0)) {
#line 637
      (*((((itv->sd_video)->ops)->vbi)->s_sliced_fmt))(itv->sd_video, vbifmt);
    } else {

    }
  } else {

  }
#line 638
  memcpy((void *)itv->vbi.sliced_in, (void const   *)vbifmt, 112UL);
#line 639
  return (0);
}
}
#line 642 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_s_fmt_vid_out(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  struct yuv_playback_info *yi ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 644
  tmp = fh2id((struct v4l2_fh *)fh);
#line 644
  id = tmp;
#line 645
  itv = id->itv;
#line 646
  yi = & itv->yuv_info;
#line 647
  tmp___0 = ivtv_try_fmt_vid_out(file, fh, fmt);
#line 647
  ret = tmp___0;
#line 649
  if (ret != 0) {
#line 650
    return (ret);
  } else {

  }
#line 652
  if (id->type != 8) {
#line 653
    return (0);
  } else {

  }
#line 656
  if (yi->stream_size != 0) {
#line 657
    return (-16);
  } else {

  }
#line 659
  yi->v4l2_src_w = fmt->fmt.pix.width;
#line 660
  yi->v4l2_src_h = fmt->fmt.pix.height;
#line 662
  switch (fmt->fmt.pix.field) {
  case 1U: 
#line 664
  yi->lace_mode = 1;
#line 665
  goto ldv_42227;
  case 0U: 
#line 667
  yi->lace_mode = 2;
#line 668
  goto ldv_42227;
  case 9U: 
#line 670
  yi->lace_mode = 4;
#line 672
  goto ldv_42227;
  case 8U: ;
  default: 
#line 675
  yi->lace_mode = 0;
#line 676
  goto ldv_42227;
  }
  ldv_42227: 
#line 678
  yi->lace_sync_field = (yi->lace_mode & 4) != 0;
#line 680
  tmp___1 = constant_test_bit(7L, (unsigned long const volatile   *)(& itv->i_flags));
#line 680
  if (tmp___1 != 0) {
#line 681
    itv->dma_data_req_size = ((yi->v4l2_src_h + 31U) & 4294967264U) * 1080U;
  } else {

  }
#line 684
  return (0);
}
}
#line 687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_s_fmt_vid_out_overlay(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  int ret ;
  int tmp___0 ;

  {
#line 689
  tmp = fh2id((struct v4l2_fh *)fh);
#line 689
  itv = tmp->itv;
#line 690
  tmp___0 = ivtv_try_fmt_vid_out_overlay(file, fh, fmt);
#line 690
  ret = tmp___0;
#line 692
  if (ret == 0) {
#line 693
    itv->osd_chroma_key = fmt->fmt.win.chromakey;
#line 694
    itv->osd_global_alpha = fmt->fmt.win.global_alpha;
#line 695
    ivtv_set_osd_alpha(itv);
  } else {

  }
#line 697
  return (ret);
}
}
#line 701 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_itvc(struct ivtv *itv , bool get , u64 reg , u64 *val ) 
{ 
  u8 volatile   *reg_start ;
  unsigned int tmp ;

  {
#line 705
  if ((reg & 3ULL) != 0ULL) {
#line 706
    return (-22);
  } else {

  }
#line 707
  if (reg > 33554431ULL && reg <= 33619967ULL) {
#line 708
    reg_start = (u8 volatile   *)itv->reg_mem + 0xfffffffffe000000UL;
  } else
#line 709
  if (((unsigned int )itv->has_cx23415 != 0U && reg > 16777215ULL) && reg <= 25165823ULL) {
#line 711
    reg_start = (u8 volatile   *)itv->dec_mem + 0xffffffffff000000UL;
  } else
#line 712
  if (reg <= 8388607ULL) {
#line 713
    reg_start = (u8 volatile   *)itv->enc_mem;
  } else {
#line 715
    return (-22);
  }
#line 717
  if ((int )get) {
#line 718
    tmp = readl((void const volatile   *)(reg_start + reg));
#line 718
    *val = (u64 )tmp;
  } else {
#line 720
    writel((unsigned int )*val, (void volatile   *)(reg_start + reg));
  }
#line 721
  return (0);
}
}
#line 724 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_register(struct file *file , void *fh , struct v4l2_dbg_register *reg ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  int tmp___0 ;

  {
#line 726
  tmp = fh2id((struct v4l2_fh *)fh);
#line 726
  itv = tmp->itv;
#line 728
  reg->size = 4U;
#line 729
  tmp___0 = ivtv_itvc(itv, 1, reg->reg, & reg->val);
#line 729
  return (tmp___0);
}
}
#line 732 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_s_register(struct file *file , void *fh , struct v4l2_dbg_register  const  *reg ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  u64 val ;
  int tmp___0 ;

  {
#line 734
  tmp = fh2id((struct v4l2_fh *)fh);
#line 734
  itv = tmp->itv;
#line 735
  val = reg->val;
#line 737
  tmp___0 = ivtv_itvc(itv, 0, reg->reg, & val);
#line 737
  return (tmp___0);
}
}
#line 741 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_querycap(struct file *file , void *fh , struct v4l2_capability *vcap ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  struct ivtv_stream *s ;
  char const   *tmp___0 ;

  {
#line 743
  tmp = fh2id((struct v4l2_fh *)file->private_data);
#line 743
  id = tmp;
#line 744
  itv = id->itv;
#line 745
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )id->type;
#line 747
  strlcpy((char *)(& vcap->driver), "ivtv", 16UL);
#line 748
  strlcpy((char *)(& vcap->card), itv->card_name, 32UL);
#line 749
  tmp___0 = pci_name((struct pci_dev  const  *)itv->pdev);
#line 749
  snprintf((char *)(& vcap->bus_info), 32UL, "PCI:%s", tmp___0);
#line 750
  vcap->capabilities = itv->v4l2_cap | 2147483648U;
#line 751
  vcap->device_caps = s->caps;
#line 752
  if ((s->caps & 512U) != 0U && itv->osd_video_pbase == 0UL) {
#line 754
    vcap->capabilities = vcap->capabilities & 4294966783U;
#line 755
    vcap->device_caps = vcap->device_caps & 4294966783U;
  } else {

  }
#line 757
  return (0);
}
}
#line 760 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_enumaudio(struct file *file , void *fh , struct v4l2_audio *vin ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  int tmp___0 ;

  {
#line 762
  tmp = fh2id((struct v4l2_fh *)fh);
#line 762
  itv = tmp->itv;
#line 764
  tmp___0 = ivtv_get_audio_input(itv, (int )((u16 )vin->index), vin);
#line 764
  return (tmp___0);
}
}
#line 767 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_audio(struct file *file , void *fh , struct v4l2_audio *vin ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  int tmp___0 ;

  {
#line 769
  tmp = fh2id((struct v4l2_fh *)fh);
#line 769
  itv = tmp->itv;
#line 771
  vin->index = itv->audio_input;
#line 772
  tmp___0 = ivtv_get_audio_input(itv, (int )((u16 )vin->index), vin);
#line 772
  return (tmp___0);
}
}
#line 775 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_s_audio(struct file *file , void *fh , struct v4l2_audio  const  *vout ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;

  {
#line 777
  tmp = fh2id((struct v4l2_fh *)fh);
#line 777
  itv = tmp->itv;
#line 779
  if ((unsigned int )vout->index >= (unsigned int )itv->nof_audio_inputs) {
#line 780
    return (-22);
  } else {

  }
#line 782
  itv->audio_input = vout->index;
#line 783
  ivtv_audio_set_io(itv);
#line 785
  return (0);
}
}
#line 788 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_enumaudout(struct file *file , void *fh , struct v4l2_audioout *vin ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  int tmp___0 ;

  {
#line 790
  tmp = fh2id((struct v4l2_fh *)fh);
#line 790
  itv = tmp->itv;
#line 793
  tmp___0 = ivtv_get_audio_output(itv, (int )((u16 )vin->index), vin);
#line 793
  return (tmp___0);
}
}
#line 796 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_audout(struct file *file , void *fh , struct v4l2_audioout *vin ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  int tmp___0 ;

  {
#line 798
  tmp = fh2id((struct v4l2_fh *)fh);
#line 798
  itv = tmp->itv;
#line 800
  vin->index = 0U;
#line 801
  tmp___0 = ivtv_get_audio_output(itv, (int )((u16 )vin->index), vin);
#line 801
  return (tmp___0);
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_s_audout(struct file *file , void *fh , struct v4l2_audioout  const  *vout ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;

  {
#line 806
  tmp = fh2id((struct v4l2_fh *)fh);
#line 806
  itv = tmp->itv;
#line 808
  if ((unsigned long )(itv->card)->video_outputs == (unsigned long )((struct ivtv_card_output  const  */* const  */)0) || (unsigned int )vout->index != 0U) {
#line 809
    return (-22);
  } else {

  }
#line 810
  return (0);
}
}
#line 813 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_enum_input(struct file *file , void *fh , struct v4l2_input *vin ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  int tmp___0 ;

  {
#line 815
  tmp = fh2id((struct v4l2_fh *)fh);
#line 815
  itv = tmp->itv;
#line 818
  tmp___0 = ivtv_get_input(itv, (int )((u16 )vin->index), vin);
#line 818
  return (tmp___0);
}
}
#line 821 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_enum_output(struct file *file , void *fh , struct v4l2_output *vout ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  int tmp___0 ;

  {
#line 823
  tmp = fh2id((struct v4l2_fh *)fh);
#line 823
  itv = tmp->itv;
#line 825
  tmp___0 = ivtv_get_output(itv, (int )((u16 )vout->index), vout);
#line 825
  return (tmp___0);
}
}
#line 828 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_cropcap(struct file *file , void *fh , struct v4l2_cropcap *cropcap ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;

  {
#line 830
  tmp = fh2id((struct v4l2_fh *)fh);
#line 830
  id = tmp;
#line 831
  itv = id->itv;
#line 833
  if (cropcap->type == 1U) {
#line 834
    cropcap->pixelaspect.numerator = (unsigned int )itv->is_50hz != 0U ? 59U : 10U;
#line 835
    cropcap->pixelaspect.denominator = (unsigned int )itv->is_50hz != 0U ? 54U : 11U;
  } else
#line 836
  if (cropcap->type == 2U) {
#line 837
    cropcap->pixelaspect.numerator = (unsigned int )itv->is_out_50hz != 0U ? 59U : 10U;
#line 838
    cropcap->pixelaspect.denominator = (unsigned int )itv->is_out_50hz != 0U ? 54U : 11U;
  } else {
#line 840
    return (-22);
  }
#line 842
  return (0);
}
}
#line 845 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_s_selection(struct file *file , void *fh , struct v4l2_selection *sel ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  struct yuv_playback_info *yi ;
  struct v4l2_rect r ;
  int streamtype ;
  unsigned int _min1 ;
  __u32 _max1 ;
  unsigned int _max2 ;
  __u32 _min2 ;
  unsigned int _min1___0 ;
  __u32 _max1___0 ;
  unsigned int _max2___0 ;
  __u32 _min2___0 ;
  unsigned int __min1 ;
  unsigned int __max1 ;
  unsigned int __max2 ;
  unsigned int __min2 ;
  unsigned int __min1___0 ;
  unsigned int __max1___0 ;
  unsigned int __max2___0 ;
  unsigned int __min2___0 ;
  int tmp___0 ;

  {
#line 848
  tmp = fh2id((struct v4l2_fh *)fh);
#line 848
  id = tmp;
#line 849
  itv = id->itv;
#line 850
  yi = & itv->yuv_info;
#line 851
  r.left = 0;
#line 851
  r.top = 0;
#line 851
  r.width = 720U;
#line 851
  r.height = 0U;
#line 852
  streamtype = id->type;
#line 854
  if (sel->type != 2U || (itv->v4l2_cap & 2U) == 0U) {
#line 856
    return (-22);
  } else {

  }
#line 858
  if (sel->target != 256U) {
#line 859
    return (-22);
  } else {

  }
#line 862
  if (sel->type != 2U || (itv->v4l2_cap & 2U) == 0U) {
#line 864
    return (-22);
  } else {

  }
#line 866
  r.height = (unsigned int )itv->is_out_50hz != 0U ? 576U : 480U;
#line 867
  if (streamtype == 8 && (unsigned int )yi->track_osd != 0U) {
#line 868
    r.width = yi->osd_full_w;
#line 869
    r.height = yi->osd_full_h;
  } else {

  }
#line 871
  _max1 = sel->r.width;
#line 871
  _max2 = 16U;
#line 871
  _min1 = _max1 > _max2 ? _max1 : _max2;
#line 871
  _min2 = r.width;
#line 871
  sel->r.width = _min1 < _min2 ? _min1 : _min2;
#line 872
  _max1___0 = sel->r.height;
#line 872
  _max2___0 = 16U;
#line 872
  _min1___0 = _max1___0 > _max2___0 ? _max1___0 : _max2___0;
#line 872
  _min2___0 = r.height;
#line 872
  sel->r.height = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 873
  __max1 = (unsigned int )sel->r.left;
#line 873
  __max2 = 0U;
#line 873
  __min1 = __max1 > __max2 ? __max1 : __max2;
#line 873
  __min2 = r.width - sel->r.width;
#line 873
  sel->r.left = (__s32 )(__min1 < __min2 ? __min1 : __min2);
#line 874
  __max1___0 = (unsigned int )sel->r.top;
#line 874
  __max2___0 = 0U;
#line 874
  __min1___0 = __max1___0 > __max2___0 ? __max1___0 : __max2___0;
#line 874
  __min2___0 = r.height - sel->r.height;
#line 874
  sel->r.top = (__s32 )(__min1___0 < __min2___0 ? __min1___0 : __min2___0);
#line 876
  if (streamtype == 8) {
#line 877
    yi->main_rect = sel->r;
#line 878
    return (0);
  } else {

  }
#line 880
  tmp___0 = ivtv_vapi(itv, 86, 4, sel->r.width, sel->r.height, sel->r.left, sel->r.top);
#line 880
  if (tmp___0 == 0) {
#line 882
    itv->main_rect = sel->r;
#line 883
    return (0);
  } else {

  }
#line 885
  return (-22);
}
}
#line 888 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_selection(struct file *file , void *fh , struct v4l2_selection *sel ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  struct yuv_playback_info *yi ;
  struct v4l2_rect r ;
  int streamtype ;
  __s32 tmp___0 ;

  {
#line 891
  tmp = fh2id((struct v4l2_fh *)fh);
#line 891
  id = tmp;
#line 892
  itv = id->itv;
#line 893
  yi = & itv->yuv_info;
#line 894
  r.left = 0;
#line 894
  r.top = 0;
#line 894
  r.width = 720U;
#line 894
  r.height = 0U;
#line 895
  streamtype = id->type;
#line 897
  if (sel->type == 1U) {
#line 898
    switch (sel->target) {
    case 1U: ;
    case 2U: 
#line 901
    tmp___0 = 0;
#line 901
    sel->r.left = tmp___0;
#line 901
    sel->r.top = tmp___0;
#line 902
    sel->r.width = 720U;
#line 903
    sel->r.height = (unsigned int )itv->is_50hz != 0U ? 576U : 480U;
#line 904
    return (0);
    default: ;
#line 906
    return (-22);
    }
  } else {

  }
#line 910
  if (sel->type != 2U || (itv->v4l2_cap & 2U) == 0U) {
#line 912
    return (-22);
  } else {

  }
#line 914
  switch (sel->target) {
  case 256U: ;
#line 916
  if (streamtype == 8) {
#line 917
    sel->r = yi->main_rect;
  } else {
#line 919
    sel->r = itv->main_rect;
  }
#line 920
  return (0);
  case 257U: ;
  case 258U: 
#line 923
  r.height = (unsigned int )itv->is_out_50hz != 0U ? 576U : 480U;
#line 924
  if (streamtype == 8 && (unsigned int )yi->track_osd != 0U) {
#line 925
    r.width = yi->osd_full_w;
#line 926
    r.height = yi->osd_full_h;
  } else {

  }
#line 928
  sel->r = r;
#line 929
  return (0);
  }
#line 931
  return (-22);
}
}
#line 934 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_enum_fmt_vid_cap(struct file *file , void *fh , struct v4l2_fmtdesc *fmt ) 
{ 
  struct v4l2_fmtdesc hm12 ;
  unsigned int tmp ;
  struct v4l2_fmtdesc mpeg ;
  unsigned int tmp___0 ;
  struct ivtv *itv ;
  struct ivtv_open_id *tmp___1 ;
  struct ivtv_stream *s ;
  struct ivtv_open_id *tmp___2 ;

  {
#line 936
  hm12.index = 0U;
#line 936
  hm12.type = 1U;
#line 936
  hm12.flags = 0U;
#line 936
  hm12.description[0] = 'H';
#line 936
  hm12.description[1] = 'M';
#line 936
  hm12.description[2] = '1';
#line 936
  hm12.description[3] = '2';
#line 936
  hm12.description[4] = ' ';
#line 936
  hm12.description[5] = '(';
#line 936
  hm12.description[6] = 'Y';
#line 936
  hm12.description[7] = 'U';
#line 936
  hm12.description[8] = 'V';
#line 936
  hm12.description[9] = ' ';
#line 936
  hm12.description[10] = '4';
#line 936
  hm12.description[11] = ':';
#line 936
  hm12.description[12] = '2';
#line 936
  hm12.description[13] = ':';
#line 936
  hm12.description[14] = '0';
#line 936
  hm12.description[15] = ')';
#line 936
  hm12.description[16] = '\000';
#line 936
  tmp = 17U;
#line 936
  while (1) {
#line 936
    if (tmp >= 32U) {
#line 936
      break;
    } else {

    }
#line 936
    hm12.description[tmp] = (unsigned char)0;
#line 936
    tmp = tmp + 1U;
  }
#line 936
  hm12.pixelformat = 842091848U;
#line 936
  hm12.reserved[0] = 0U;
#line 936
  hm12.reserved[1] = 0U;
#line 936
  hm12.reserved[2] = 0U;
#line 936
  hm12.reserved[3] = 0U;
#line 941
  mpeg.index = 0U;
#line 941
  mpeg.type = 1U;
#line 941
  mpeg.flags = 1U;
#line 941
  mpeg.description[0] = 'M';
#line 941
  mpeg.description[1] = 'P';
#line 941
  mpeg.description[2] = 'E';
#line 941
  mpeg.description[3] = 'G';
#line 941
  mpeg.description[4] = '\000';
#line 941
  tmp___0 = 5U;
#line 941
  while (1) {
#line 941
    if (tmp___0 >= 32U) {
#line 941
      break;
    } else {

    }
#line 941
    mpeg.description[tmp___0] = (unsigned char)0;
#line 941
    tmp___0 = tmp___0 + 1U;
  }
#line 941
  mpeg.pixelformat = 1195724877U;
#line 941
  mpeg.reserved[0] = 0U;
#line 941
  mpeg.reserved[1] = 0U;
#line 941
  mpeg.reserved[2] = 0U;
#line 941
  mpeg.reserved[3] = 0U;
#line 946
  tmp___1 = fh2id((struct v4l2_fh *)fh);
#line 946
  itv = tmp___1->itv;
#line 947
  tmp___2 = fh2id((struct v4l2_fh *)fh);
#line 947
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )tmp___2->type;
#line 949
  if (fmt->index != 0U) {
#line 950
    return (-22);
  } else {

  }
#line 951
  if (s->type == 0) {
#line 952
    *fmt = mpeg;
  } else
#line 953
  if (s->type == 1) {
#line 954
    *fmt = hm12;
  } else {
#line 956
    return (-22);
  }
#line 957
  return (0);
}
}
#line 960 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_enum_fmt_vid_out(struct file *file , void *fh , struct v4l2_fmtdesc *fmt ) 
{ 
  struct v4l2_fmtdesc hm12 ;
  unsigned int tmp ;
  struct v4l2_fmtdesc mpeg ;
  unsigned int tmp___0 ;
  struct ivtv *itv ;
  struct ivtv_open_id *tmp___1 ;
  struct ivtv_stream *s ;
  struct ivtv_open_id *tmp___2 ;

  {
#line 962
  hm12.index = 0U;
#line 962
  hm12.type = 2U;
#line 962
  hm12.flags = 0U;
#line 962
  hm12.description[0] = 'H';
#line 962
  hm12.description[1] = 'M';
#line 962
  hm12.description[2] = '1';
#line 962
  hm12.description[3] = '2';
#line 962
  hm12.description[4] = ' ';
#line 962
  hm12.description[5] = '(';
#line 962
  hm12.description[6] = 'Y';
#line 962
  hm12.description[7] = 'U';
#line 962
  hm12.description[8] = 'V';
#line 962
  hm12.description[9] = ' ';
#line 962
  hm12.description[10] = '4';
#line 962
  hm12.description[11] = ':';
#line 962
  hm12.description[12] = '2';
#line 962
  hm12.description[13] = ':';
#line 962
  hm12.description[14] = '0';
#line 962
  hm12.description[15] = ')';
#line 962
  hm12.description[16] = '\000';
#line 962
  tmp = 17U;
#line 962
  while (1) {
#line 962
    if (tmp >= 32U) {
#line 962
      break;
    } else {

    }
#line 962
    hm12.description[tmp] = (unsigned char)0;
#line 962
    tmp = tmp + 1U;
  }
#line 962
  hm12.pixelformat = 842091848U;
#line 962
  hm12.reserved[0] = 0U;
#line 962
  hm12.reserved[1] = 0U;
#line 962
  hm12.reserved[2] = 0U;
#line 962
  hm12.reserved[3] = 0U;
#line 967
  mpeg.index = 0U;
#line 967
  mpeg.type = 2U;
#line 967
  mpeg.flags = 1U;
#line 967
  mpeg.description[0] = 'M';
#line 967
  mpeg.description[1] = 'P';
#line 967
  mpeg.description[2] = 'E';
#line 967
  mpeg.description[3] = 'G';
#line 967
  mpeg.description[4] = '\000';
#line 967
  tmp___0 = 5U;
#line 967
  while (1) {
#line 967
    if (tmp___0 >= 32U) {
#line 967
      break;
    } else {

    }
#line 967
    mpeg.description[tmp___0] = (unsigned char)0;
#line 967
    tmp___0 = tmp___0 + 1U;
  }
#line 967
  mpeg.pixelformat = 1195724877U;
#line 967
  mpeg.reserved[0] = 0U;
#line 967
  mpeg.reserved[1] = 0U;
#line 967
  mpeg.reserved[2] = 0U;
#line 967
  mpeg.reserved[3] = 0U;
#line 972
  tmp___1 = fh2id((struct v4l2_fh *)fh);
#line 972
  itv = tmp___1->itv;
#line 973
  tmp___2 = fh2id((struct v4l2_fh *)fh);
#line 973
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )tmp___2->type;
#line 975
  if (fmt->index != 0U) {
#line 976
    return (-22);
  } else {

  }
#line 977
  if (s->type == 5) {
#line 978
    *fmt = mpeg;
  } else
#line 979
  if (s->type == 8) {
#line 980
    *fmt = hm12;
  } else {
#line 982
    return (-22);
  }
#line 983
  return (0);
}
}
#line 986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_input(struct file *file , void *fh , unsigned int *i ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;

  {
#line 988
  tmp = fh2id((struct v4l2_fh *)fh);
#line 988
  itv = tmp->itv;
#line 990
  *i = itv->active_input;
#line 992
  return (0);
}
}
#line 995 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
int ivtv_s_input(struct file *file , void *fh , unsigned int inp ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  v4l2_std_id std ;
  int i ;
  int tmp___0 ;

  {
#line 997
  tmp = fh2id((struct v4l2_fh *)fh);
#line 997
  itv = tmp->itv;
#line 1001
  if ((unsigned int )itv->nof_inputs <= inp) {
#line 1002
    return (-22);
  } else {

  }
#line 1004
  if (itv->active_input == inp) {
#line 1005
    if ((ivtv_debug & 2) != 0) {
#line 1005
      printk("\016%s:  info: Input unchanged\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 1006
    return (0);
  } else {

  }
#line 1009
  tmp___0 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 1009
  if (tmp___0 > 0) {
#line 1010
    return (-16);
  } else {

  }
#line 1013
  if ((ivtv_debug & 2) != 0) {
#line 1013
    printk("\016%s:  info: Changing input from %d to %d\n", (char *)(& itv->v4l2_dev.name),
           itv->active_input, inp);
  } else {

  }
#line 1016
  itv->active_input = inp;
#line 1019
  itv->audio_input = (u32 )(itv->card)->video_inputs[inp].audio_index;
#line 1021
  if ((unsigned int )((unsigned char )(itv->card)->video_inputs[inp].video_type) == 1U) {
#line 1022
    std = itv->tuner_std;
  } else {
#line 1024
    std = 16777215ULL;
  }
#line 1025
  i = 0;
#line 1025
  goto ldv_42411;
  ldv_42410: 
#line 1026
  itv->streams[i].vdev.tvnorms = std;
#line 1025
  i = i + 1;
  ldv_42411: ;
#line 1025
  if (i <= 2) {
#line 1027
    goto ldv_42410;
  } else {

  }
#line 1030
  ivtv_mute(itv);
#line 1031
  ivtv_video_set_io(itv);
#line 1032
  ivtv_audio_set_io(itv);
#line 1033
  ivtv_unmute(itv);
#line 1035
  return (0);
}
}
#line 1038 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_output(struct file *file , void *fh , unsigned int *i ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;

  {
#line 1040
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1040
  itv = tmp->itv;
#line 1042
  if ((itv->v4l2_cap & 2U) == 0U) {
#line 1043
    return (-22);
  } else {

  }
#line 1045
  *i = itv->active_output;
#line 1047
  return (0);
}
}
#line 1050 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_s_output(struct file *file , void *fh , unsigned int outp ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1052
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1052
  itv = tmp->itv;
#line 1054
  if ((unsigned int )(itv->card)->nof_outputs <= outp) {
#line 1055
    return (-22);
  } else {

  }
#line 1057
  if (itv->active_output == outp) {
#line 1058
    if ((ivtv_debug & 2) != 0) {
#line 1058
      printk("\016%s:  info: Output unchanged\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 1059
    return (0);
  } else {

  }
#line 1061
  if ((ivtv_debug & 2) != 0) {
#line 1061
    printk("\016%s:  info: Changing output from %d to %d\n", (char *)(& itv->v4l2_dev.name),
           itv->active_output, outp);
  } else {

  }
#line 1064
  itv->active_output = outp;
#line 1065
  __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1065
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1065
  goto ldv_42431;
  ldv_42430: ;
#line 1065
  if (((__sd->grp_id & 4U) != 0U && (unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->video)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                               u32  ,
                                                                                                                                                                                                                                               u32  ,
                                                                                                                                                                                                                                               u32  ))0)) {
#line 1065
    (*(((__sd->ops)->video)->s_routing))(__sd, 0U, (u32 )((itv->card)->video_outputs + (unsigned long )outp)->video_output,
                                         0U);
  } else {

  }
#line 1065
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1065
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_42431: ;
#line 1065
  if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1067
    goto ldv_42430;
  } else {

  }

#line 1069
  return (0);
}
}
#line 1072 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_frequency(struct file *file , void *fh , struct v4l2_frequency *vf ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  struct ivtv_stream *s ;
  struct ivtv_open_id *tmp___0 ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1074
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1074
  itv = tmp->itv;
#line 1075
  tmp___0 = fh2id((struct v4l2_fh *)fh);
#line 1075
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )tmp___0->type;
#line 1077
  if (s->vdev.vfl_dir != 0) {
#line 1078
    return (-25);
  } else {

  }
#line 1079
  if (vf->tuner != 0U) {
#line 1080
    return (-22);
  } else {

  }
#line 1082
  __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1082
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1082
  goto ldv_42446;
  ldv_42445: ;
#line 1082
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->g_frequency != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                  struct v4l2_frequency * ))0)) {
#line 1082
    (*(((__sd->ops)->tuner)->g_frequency))(__sd, vf);
  } else {

  }
#line 1082
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1082
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_42446: ;
#line 1082
  if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1084
    goto ldv_42445;
  } else {

  }

#line 1083
  return (0);
}
}
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
int ivtv_s_frequency(struct file *file , void *fh , struct v4l2_frequency  const  *vf ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  struct ivtv_stream *s ;
  struct ivtv_open_id *tmp___0 ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1088
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1088
  itv = tmp->itv;
#line 1089
  tmp___0 = fh2id((struct v4l2_fh *)fh);
#line 1089
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )tmp___0->type;
#line 1091
  if (s->vdev.vfl_dir != 0) {
#line 1092
    return (-25);
  } else {

  }
#line 1093
  if ((unsigned int )vf->tuner != 0U) {
#line 1094
    return (-22);
  } else {

  }
#line 1096
  ivtv_mute(itv);
#line 1097
  if ((ivtv_debug & 2) != 0) {
#line 1097
    printk("\016%s:  info: v4l2 ioctl: set frequency %d\n", (char *)(& itv->v4l2_dev.name),
           vf->frequency);
  } else {

  }
#line 1098
  __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1098
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1098
  goto ldv_42461;
  ldv_42460: ;
#line 1098
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->s_frequency != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                  struct v4l2_frequency  const  * ))0)) {
#line 1098
    (*(((__sd->ops)->tuner)->s_frequency))(__sd, vf);
  } else {

  }
#line 1098
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1098
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_42461: ;
#line 1098
  if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1100
    goto ldv_42460;
  } else {

  }
#line 1099
  ivtv_unmute(itv);
#line 1100
  return (0);
}
}
#line 1103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_std(struct file *file , void *fh , v4l2_std_id *std ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;

  {
#line 1105
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1105
  itv = tmp->itv;
#line 1107
  *std = itv->std;
#line 1108
  return (0);
}
}
#line 1111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
void ivtv_s_std_enc(struct ivtv *itv , v4l2_std_id std ) 
{ 
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1113
  itv->std = std;
#line 1114
  itv->is_60hz = (std & 63744ULL) != 0ULL;
#line 1115
  itv->is_50hz = (unsigned int )itv->is_60hz == 0U;
#line 1116
  cx2341x_handler_set_50hz(& itv->cxhdl, (int )itv->is_50hz);
#line 1117
  itv->cxhdl.width = 720U;
#line 1118
  itv->cxhdl.height = (unsigned int )itv->is_50hz != 0U ? 576U : 480U;
#line 1119
  itv->vbi.count = (unsigned int )itv->is_50hz != 0U ? 18U : 12U;
#line 1120
  itv->vbi.start[0] = (unsigned int )itv->is_50hz != 0U ? 6U : 10U;
#line 1121
  itv->vbi.start[1] = (unsigned int )itv->is_50hz != 0U ? 318U : 273U;
#line 1123
  if ((int )itv->hw_flags & 1) {
#line 1124
    itv->vbi.sliced_decoder_line_size = (unsigned int )itv->is_60hz != 0U ? 272U : 284U;
  } else {

  }
#line 1127
  __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1127
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1127
  goto ldv_42479;
  ldv_42478: ;
#line 1127
  if ((unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->video)->s_std != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                            v4l2_std_id  ))0)) {
#line 1127
    (*(((__sd->ops)->video)->s_std))(__sd, itv->std);
  } else {

  }
#line 1127
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1127
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_42479: ;
#line 1127
  if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1129
    goto ldv_42478;
  } else {

  }

#line 1135
  return;
}
}
#line 1130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
void ivtv_s_std_dec(struct ivtv *itv , v4l2_std_id std ) 
{ 
  struct yuv_playback_info *yi ;
  wait_queue_t wait ;
  struct task_struct *tmp ;
  int f ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  unsigned int tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 1132
  yi = & itv->yuv_info;
#line 1133
  tmp = get_current();
#line 1133
  wait.flags = 0U;
#line 1133
  wait.private = (void *)tmp;
#line 1133
  wait.func = & autoremove_wake_function;
#line 1133
  wait.task_list.next = & wait.task_list;
#line 1133
  wait.task_list.prev = & wait.task_list;
#line 1137
  itv->std_out = std;
#line 1138
  itv->is_out_60hz = (std & 63744ULL) != 0ULL;
#line 1139
  itv->is_out_50hz = (unsigned int )itv->is_out_60hz == 0U;
#line 1140
  __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1140
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1140
  goto ldv_42494;
  ldv_42493: ;
#line 1140
  if ((unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->video)->s_std_output != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                   v4l2_std_id  ))0)) {
#line 1140
    (*(((__sd->ops)->video)->s_std_output))(__sd, itv->std_out);
  } else {

  }
#line 1140
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1140
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_42494: ;
#line 1140
  if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1142
    goto ldv_42493;
  } else {

  }
#line 1148
  mutex_unlock(& itv->serialize_lock);
#line 1149
  f = 0;
#line 1149
  goto ldv_42498;
  ldv_42497: 
#line 1150
  prepare_to_wait(& itv->vsync_waitq, & wait, 2);
#line 1152
  tmp___0 = readl((void const volatile   *)itv->reg_mem + 10432U);
#line 1152
  if (tmp___0 >> 16 <= 99U) {
#line 1153
    goto ldv_42496;
  } else {

  }
#line 1154
  tmp___1 = msecs_to_jiffies(25U);
#line 1154
  schedule_timeout((long )tmp___1);
#line 1149
  f = f + 1;
  ldv_42498: ;
#line 1149
  if (f <= 3) {
#line 1151
    goto ldv_42497;
  } else {

  }
  ldv_42496: 
#line 1156
  finish_wait(& itv->vsync_waitq, & wait);
#line 1157
  mutex_lock_nested(& itv->serialize_lock, 0U);
#line 1159
  if (f == 4) {
#line 1160
    printk("\f%s: Mode change failed to sync to decoder\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1162
  ivtv_vapi(itv, 16, 1, (int )itv->is_out_50hz);
#line 1163
  itv->main_rect.left = 0;
#line 1164
  itv->main_rect.top = 0;
#line 1165
  itv->main_rect.width = 720U;
#line 1166
  itv->main_rect.height = (unsigned int )itv->is_out_50hz != 0U ? 576U : 480U;
#line 1167
  ivtv_vapi(itv, 86, 4, 720, itv->main_rect.height, 0, 0);
#line 1169
  yi->main_rect = itv->main_rect;
#line 1170
  if ((unsigned long )itv->osd_info == (unsigned long )((struct osd_info *)0)) {
#line 1171
    yi->osd_full_w = 720U;
#line 1172
    yi->osd_full_h = (unsigned int )itv->is_out_50hz != 0U ? 576U : 480U;
  } else {

  }
#line 1174
  return;
}
}
#line 1176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_s_std(struct file *file , void *fh , v4l2_std_id std ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1178
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1178
  itv = tmp->itv;
#line 1180
  if ((std & 16777215ULL) == 0ULL) {
#line 1181
    return (-22);
  } else {

  }
#line 1183
  if (itv->std == std) {
#line 1184
    return (0);
  } else {

  }
#line 1186
  tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1186
  if (tmp___0 != 0) {
#line 1191
    return (-16);
  } else {
#line 1186
    tmp___1 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 1186
    if (tmp___1 > 0) {
#line 1191
      return (-16);
    } else {
#line 1186
      tmp___2 = atomic_read((atomic_t const   *)(& itv->decoding));
#line 1186
      if (tmp___2 > 0) {
#line 1191
        return (-16);
      } else {

      }
    }
  }
#line 1194
  if ((ivtv_debug & 2) != 0) {
#line 1194
    printk("\016%s:  info: Switching standard to %llx.\n", (char *)(& itv->v4l2_dev.name),
           itv->std);
  } else {

  }
#line 1197
  ivtv_s_std_enc(itv, std);
#line 1198
  if ((itv->v4l2_cap & 2U) != 0U) {
#line 1199
    ivtv_s_std_dec(itv, std);
  } else {

  }
#line 1201
  return (0);
}
}
#line 1204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_s_tuner(struct file *file , void *fh , struct v4l2_tuner  const  *vt ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1206
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1206
  id = tmp;
#line 1207
  itv = id->itv;
#line 1209
  if ((unsigned int )vt->index != 0U) {
#line 1210
    return (-22);
  } else {

  }
#line 1212
  __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1212
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1212
  goto ldv_42518;
  ldv_42517: ;
#line 1212
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->s_tuner != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                              struct v4l2_tuner  const  * ))0)) {
#line 1212
    (*(((__sd->ops)->tuner)->s_tuner))(__sd, vt);
  } else {

  }
#line 1212
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1212
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_42518: ;
#line 1212
  if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1214
    goto ldv_42517;
  } else {

  }

#line 1214
  return (0);
}
}
#line 1217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_tuner(struct file *file , void *fh , struct v4l2_tuner *vt ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1219
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1219
  itv = tmp->itv;
#line 1221
  if (vt->index != 0U) {
#line 1222
    return (-22);
  } else {

  }
#line 1224
  __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1224
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1224
  goto ldv_42532;
  ldv_42531: ;
#line 1224
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->g_tuner != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                              struct v4l2_tuner * ))0)) {
#line 1224
    (*(((__sd->ops)->tuner)->g_tuner))(__sd, vt);
  } else {

  }
#line 1224
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1224
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_42532: ;
#line 1224
  if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1226
    goto ldv_42531;
  } else {

  }

#line 1226
  if (vt->type == 1U) {
#line 1227
    strlcpy((char *)(& vt->name), "ivtv Radio Tuner", 32UL);
  } else {
#line 1229
    strlcpy((char *)(& vt->name), "ivtv TV Tuner", 32UL);
  }
#line 1230
  return (0);
}
}
#line 1233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_sliced_vbi_cap(struct file *file , void *fh , struct v4l2_sliced_vbi_cap *cap ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  int set ;
  int f ;
  int l ;
  int tmp___0 ;

  {
#line 1235
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1235
  itv = tmp->itv;
#line 1236
  set = (unsigned int )itv->is_50hz != 0U ? 17409 : 4096;
#line 1239
  if (cap->type == 6U) {
#line 1240
    f = 0;
#line 1240
    goto ldv_42547;
    ldv_42546: 
#line 1241
    l = 0;
#line 1241
    goto ldv_42544;
    ldv_42543: 
#line 1242
    tmp___0 = valid_service_line(f, l, (int )itv->is_50hz);
#line 1242
    if (tmp___0 != 0) {
#line 1243
      cap->service_lines[f][l] = (__u16 )set;
    } else {

    }
#line 1241
    l = l + 1;
    ldv_42544: ;
#line 1241
    if (l <= 23) {
#line 1243
      goto ldv_42543;
    } else {

    }
#line 1240
    f = f + 1;
    ldv_42547: ;
#line 1240
    if (f <= 1) {
#line 1242
      goto ldv_42546;
    } else {

    }

  } else
#line 1246
  if (cap->type == 7U) {
#line 1247
    if ((itv->v4l2_cap & 128U) == 0U) {
#line 1248
      return (-22);
    } else {

    }
#line 1249
    if ((unsigned int )itv->is_60hz != 0U) {
#line 1250
      cap->service_lines[0][21] = 4096U;
#line 1251
      cap->service_lines[1][21] = 4096U;
    } else {
#line 1253
      cap->service_lines[0][23] = 16384U;
#line 1254
      cap->service_lines[0][16] = 1024U;
    }
  } else {
#line 1257
    return (-22);
  }
#line 1260
  set = 0;
#line 1261
  f = 0;
#line 1261
  goto ldv_42553;
  ldv_42552: 
#line 1262
  l = 0;
#line 1262
  goto ldv_42550;
  ldv_42549: 
#line 1263
  set = (int )cap->service_lines[f][l] | set;
#line 1262
  l = l + 1;
  ldv_42550: ;
#line 1262
  if (l <= 23) {
#line 1264
    goto ldv_42549;
  } else {

  }
#line 1261
  f = f + 1;
  ldv_42553: ;
#line 1261
  if (f <= 1) {
#line 1263
    goto ldv_42552;
  } else {

  }
#line 1264
  cap->service_set = (__u16 )set;
#line 1265
  return (0);
}
}
#line 1268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_enc_index(struct file *file , void *fh , struct v4l2_enc_idx *idx ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  struct v4l2_enc_idx_entry *e ;
  int entries ;
  int i ;
  int tmp___0 ;

  {
#line 1270
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1270
  itv = tmp->itv;
#line 1271
  e = (struct v4l2_enc_idx_entry *)(& idx->entry);
#line 1275
  entries = (int )(((itv->pgm_info_write_idx - itv->pgm_info_read_idx) + 400U) % 400U);
#line 1277
  if (entries > 64) {
#line 1278
    entries = 64;
  } else {

  }
#line 1279
  idx->entries = 0U;
#line 1280
  idx->entries_cap = 400U;
#line 1281
  tmp___0 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 1281
  if (tmp___0 == 0) {
#line 1282
    return (0);
  } else {

  }
#line 1283
  i = 0;
#line 1283
  goto ldv_42565;
  ldv_42564: 
#line 1284
  *e = itv->pgm_info[(itv->pgm_info_read_idx + (u32 )i) % 400U];
#line 1285
  if ((e->flags & 15U) <= 2U) {
#line 1286
    idx->entries = idx->entries + 1U;
#line 1287
    e = e + 1;
  } else {

  }
#line 1283
  i = i + 1;
  ldv_42565: ;
#line 1283
  if (i < entries) {
#line 1285
    goto ldv_42564;
  } else {

  }
#line 1290
  itv->pgm_info_read_idx = (itv->pgm_info_read_idx + idx->entries) % 400U;
#line 1291
  return (0);
}
}
#line 1294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_encoder_cmd(struct file *file , void *fh , struct v4l2_encoder_cmd *enc ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1296
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1296
  id = tmp;
#line 1297
  itv = id->itv;
#line 1300
  switch (enc->cmd) {
  case 0U: ;
#line 1302
  if ((ivtv_debug & 8) != 0) {
#line 1302
    printk("\016%s:  ioctl: V4L2_ENC_CMD_START\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1303
  enc->flags = 0U;
#line 1304
  tmp___0 = ivtv_start_capture(id);
#line 1304
  return (tmp___0);
  case 1U: ;
#line 1307
  if ((ivtv_debug & 8) != 0) {
#line 1307
    printk("\016%s:  ioctl: V4L2_ENC_CMD_STOP\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1308
  enc->flags = enc->flags & 1U;
#line 1309
  ivtv_stop_capture(id, (int )enc->flags & 1);
#line 1310
  return (0);
  case 2U: ;
#line 1313
  if ((ivtv_debug & 8) != 0) {
#line 1313
    printk("\016%s:  ioctl: V4L2_ENC_CMD_PAUSE\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1314
  enc->flags = 0U;
#line 1316
  tmp___1 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 1316
  if (tmp___1 == 0) {
#line 1317
    return (-1);
  } else {

  }
#line 1318
  tmp___2 = test_and_set_bit(13L, (unsigned long volatile   *)(& itv->i_flags));
#line 1318
  if (tmp___2 != 0) {
#line 1319
    return (0);
  } else {

  }
#line 1321
  ivtv_mute(itv);
#line 1322
  ivtv_vapi(itv, 210, 1, 0);
#line 1323
  goto ldv_42577;
  case 3U: ;
#line 1326
  if ((ivtv_debug & 8) != 0) {
#line 1326
    printk("\016%s:  ioctl: V4L2_ENC_CMD_RESUME\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1327
  enc->flags = 0U;
#line 1329
  tmp___3 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 1329
  if (tmp___3 == 0) {
#line 1330
    return (-1);
  } else {

  }
#line 1332
  tmp___4 = test_and_clear_bit(13L, (unsigned long volatile   *)(& itv->i_flags));
#line 1332
  if (tmp___4 == 0) {
#line 1333
    return (0);
  } else {

  }
#line 1335
  ivtv_vapi(itv, 210, 1, 1);
#line 1336
  ivtv_unmute(itv);
#line 1337
  goto ldv_42577;
  default: ;
#line 1339
  if ((ivtv_debug & 8) != 0) {
#line 1339
    printk("\016%s:  ioctl: Unknown cmd %d\n", (char *)(& itv->v4l2_dev.name), enc->cmd);
  } else {

  }
#line 1340
  return (-22);
  }
  ldv_42577: ;
#line 1343
  return (0);
}
}
#line 1346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_try_encoder_cmd(struct file *file , void *fh , struct v4l2_encoder_cmd *enc ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;

  {
#line 1348
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1348
  itv = tmp->itv;
#line 1350
  switch (enc->cmd) {
  case 0U: ;
#line 1352
  if ((ivtv_debug & 8) != 0) {
#line 1352
    printk("\016%s:  ioctl: V4L2_ENC_CMD_START\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1353
  enc->flags = 0U;
#line 1354
  return (0);
  case 1U: ;
#line 1357
  if ((ivtv_debug & 8) != 0) {
#line 1357
    printk("\016%s:  ioctl: V4L2_ENC_CMD_STOP\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1358
  enc->flags = enc->flags & 1U;
#line 1359
  return (0);
  case 2U: ;
#line 1362
  if ((ivtv_debug & 8) != 0) {
#line 1362
    printk("\016%s:  ioctl: V4L2_ENC_CMD_PAUSE\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1363
  enc->flags = 0U;
#line 1364
  return (0);
  case 3U: ;
#line 1367
  if ((ivtv_debug & 8) != 0) {
#line 1367
    printk("\016%s:  ioctl: V4L2_ENC_CMD_RESUME\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1368
  enc->flags = 0U;
#line 1369
  return (0);
  default: ;
#line 1371
  if ((ivtv_debug & 8) != 0) {
#line 1371
    printk("\016%s:  ioctl: Unknown cmd %d\n", (char *)(& itv->v4l2_dev.name), enc->cmd);
  } else {

  }
#line 1372
  return (-22);
  }
}
}
#line 1376 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_g_fbuf(struct file *file , void *fh , struct v4l2_framebuffer *fb ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  struct ivtv_stream *s ;
  struct ivtv_open_id *tmp___0 ;
  u32 data[16U] ;
  struct yuv_playback_info *yi ;
  int pixfmt ;
  u32 pixel_format[16U] ;
  unsigned int tmp___1 ;

  {
#line 1378
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1378
  itv = tmp->itv;
#line 1379
  tmp___0 = fh2id((struct v4l2_fh *)fh);
#line 1379
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )tmp___0->type;
#line 1381
  yi = & itv->yuv_info;
#line 1384
  pixel_format[0] = 944521552U;
#line 1384
  pixel_format[1] = 1346520914U;
#line 1384
  pixel_format[2] = 1329743698U;
#line 1384
  pixel_format[3] = 875836498U;
#line 1384
  pixel_format[4] = 876758866U;
#line 1384
  pixel_format[5] = 0U;
#line 1384
  pixel_format[6] = 0U;
#line 1384
  pixel_format[7] = 0U;
#line 1384
  pixel_format[8] = 944521552U;
#line 1384
  pixel_format[9] = 1347835225U;
#line 1384
  pixel_format[10] = 1331058009U;
#line 1384
  pixel_format[11] = 875836505U;
#line 1384
  pixel_format[12] = 878073177U;
#line 1384
  pixel_format[13] = 0U;
#line 1384
  pixel_format[14] = 0U;
#line 1384
  pixel_format[15] = 0U;
#line 1403
  if ((s->caps & 512U) == 0U) {
#line 1404
    return (-25);
  } else {

  }
#line 1405
  if (itv->osd_video_pbase == 0UL) {
#line 1406
    return (-25);
  } else {

  }
#line 1408
  fb->capability = 35U;
#line 1411
  ivtv_vapi_result(itv, (u32 *)(& data), 68, 0);
#line 1412
  tmp___1 = readl((void const volatile   *)itv->reg_mem + 10752U);
#line 1412
  data[0] = data[0] | ((tmp___1 >> 7) & 64U);
#line 1413
  pixfmt = (int )(data[0] >> 3) & 15;
#line 1415
  fb->fmt.pixelformat = pixel_format[pixfmt];
#line 1416
  fb->fmt.width = itv->osd_rect.width;
#line 1417
  fb->fmt.height = itv->osd_rect.height;
#line 1418
  fb->fmt.field = 4U;
#line 1419
  fb->fmt.bytesperline = fb->fmt.width;
#line 1420
  fb->fmt.colorspace = 1U;
#line 1421
  fb->fmt.field = 4U;
#line 1422
  if (fb->fmt.pixelformat != 944521552U) {
#line 1423
    fb->fmt.bytesperline = fb->fmt.bytesperline * 2U;
  } else {

  }
#line 1424
  if (fb->fmt.pixelformat == 876758866U || fb->fmt.pixelformat == 878073177U) {
#line 1426
    fb->fmt.bytesperline = fb->fmt.bytesperline * 2U;
  } else {

  }
#line 1427
  fb->fmt.sizeimage = fb->fmt.bytesperline * fb->fmt.height;
#line 1428
  fb->base = (void *)itv->osd_video_pbase;
#line 1429
  fb->flags = 0U;
#line 1431
  if (itv->osd_chroma_key_state != 0) {
#line 1432
    fb->flags = fb->flags | 4U;
  } else {

  }
#line 1434
  if (itv->osd_global_alpha_state != 0) {
#line 1435
    fb->flags = fb->flags | 16U;
  } else {

  }
#line 1437
  if ((unsigned int )yi->track_osd != 0U) {
#line 1438
    fb->flags = fb->flags | 2U;
  } else {

  }
#line 1440
  pixfmt = pixfmt & 7;
#line 1443
  if (pixfmt == 1 || pixfmt > 4) {
#line 1444
    return (0);
  } else {

  }
#line 1447
  if (pixfmt == 2 || pixfmt == 3) {
#line 1448
    fb->capability = fb->capability | 64U;
  } else {
#line 1450
    fb->capability = fb->capability | 16U;
  }
#line 1452
  if (itv->osd_local_alpha_state != 0) {
#line 1454
    if (pixfmt == 2 || pixfmt == 3) {
#line 1455
      fb->flags = fb->flags | 32U;
    } else {
#line 1457
      fb->flags = fb->flags | 8U;
    }
  } else {

  }
#line 1460
  return (0);
}
}
#line 1463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_s_fbuf(struct file *file , void *fh , struct v4l2_framebuffer  const  *fb ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  struct ivtv_stream *s ;
  struct ivtv_open_id *tmp___0 ;
  struct yuv_playback_info *yi ;

  {
#line 1465
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1465
  id = tmp;
#line 1466
  itv = id->itv;
#line 1467
  tmp___0 = fh2id((struct v4l2_fh *)fh);
#line 1467
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )tmp___0->type;
#line 1468
  yi = & itv->yuv_info;
#line 1470
  if ((s->caps & 512U) == 0U) {
#line 1471
    return (-25);
  } else {

  }
#line 1472
  if (itv->osd_video_pbase == 0UL) {
#line 1473
    return (-25);
  } else {

  }
#line 1475
  itv->osd_global_alpha_state = ((unsigned int )fb->flags & 16U) != 0U;
#line 1476
  itv->osd_local_alpha_state = ((unsigned int )fb->flags & 40U) != 0U;
#line 1478
  itv->osd_chroma_key_state = ((unsigned int )fb->flags & 4U) != 0U;
#line 1479
  ivtv_set_osd_alpha(itv);
#line 1480
  yi->track_osd = ((unsigned int )fb->flags & 2U) != 0U;
#line 1481
  return (0);
}
}
#line 1484 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_overlay(struct file *file , void *fh , unsigned int on ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  struct ivtv_stream *s ;
  struct ivtv_open_id *tmp___0 ;

  {
#line 1486
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1486
  id = tmp;
#line 1487
  itv = id->itv;
#line 1488
  tmp___0 = fh2id((struct v4l2_fh *)fh);
#line 1488
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )tmp___0->type;
#line 1490
  if ((s->caps & 512U) == 0U) {
#line 1491
    return (-25);
  } else {

  }
#line 1492
  if (itv->osd_video_pbase == 0UL) {
#line 1493
    return (-25);
  } else {

  }
#line 1495
  ivtv_vapi(itv, 69, 1, on != 0U);
#line 1497
  return (0);
}
}
#line 1500 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_subscribe_event(struct v4l2_fh *fh , struct v4l2_event_subscription  const  *sub ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1502
  switch (sub->type) {
  case 1U: ;
  case 2U: 
#line 1505
  tmp = v4l2_event_subscribe(fh, sub, 0U, (struct v4l2_subscribed_event_ops  const  *)0);
#line 1505
  return (tmp);
  case 3U: 
#line 1507
  tmp___0 = v4l2_event_subscribe(fh, sub, 0U, & v4l2_ctrl_sub_ev_ops);
#line 1507
  return (tmp___0);
  default: ;
#line 1509
  return (-22);
  }
}
}
#line 1513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_log_status(struct file *file , void *fh ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  u32 data[16U] ;
  int has_output ;
  struct v4l2_input vidin ;
  struct v4l2_audio audin ;
  int i ;
  struct tveeprom tv ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct v4l2_output vidout ;
  struct v4l2_audioout audout ;
  int mode ;
  char const   *output_modes[5U] ;
  char const   *alpha_mode[4U] ;
  char const   *pixel_format[16U] ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  struct ivtv_stream *s ;

  {
#line 1515
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1515
  itv = tmp->itv;
#line 1518
  has_output = (int )itv->v4l2_cap & 2;
#line 1523
  printk("\016%s: Version: %s Card: %s\n", (char *)(& itv->v4l2_dev.name), (char *)"1.4.3",
         itv->card_name);
#line 1524
  if ((itv->hw_flags & 128U) != 0U) {
#line 1527
    ivtv_read_eeprom(itv, & tv);
  } else {

  }
#line 1529
  __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 1529
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1529
  goto ldv_42644;
  ldv_42643: ;
#line 1529
  if ((unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->core)->log_status != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 1529
    (*(((__sd->ops)->core)->log_status))(__sd);
  } else {

  }
#line 1529
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1529
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_42644: ;
#line 1529
  if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 1531
    goto ldv_42643;
  } else {

  }
#line 1530
  ivtv_get_input(itv, (int )((u16 )itv->active_input), & vidin);
#line 1531
  ivtv_get_audio_input(itv, (int )((u16 )itv->audio_input), & audin);
#line 1532
  printk("\016%s: Video Input:  %s\n", (char *)(& itv->v4l2_dev.name), (__u8 *)(& vidin.name));
#line 1533
  printk("\016%s: Audio Input:  %s%s\n", (char *)(& itv->v4l2_dev.name), (__u8 *)(& audin.name),
         itv->dualwatch_stereo_mode == 2U ? (char *)" (Bilingual)" : (char *)"");
#line 1536
  if (has_output != 0) {
#line 1539
    mode = itv->output_mode;
#line 1540
    output_modes[0] = "None";
#line 1540
    output_modes[1] = "MPEG Streaming";
#line 1540
    output_modes[2] = "YUV Streaming";
#line 1540
    output_modes[3] = "YUV Frames";
#line 1540
    output_modes[4] = "Passthrough";
#line 1547
    alpha_mode[0] = "None";
#line 1547
    alpha_mode[1] = "Global";
#line 1547
    alpha_mode[2] = "Local";
#line 1547
    alpha_mode[3] = "Global and Local";
#line 1553
    pixel_format[0] = "ARGB Indexed";
#line 1553
    pixel_format[1] = "RGB 5:6:5";
#line 1553
    pixel_format[2] = "ARGB 1:5:5:5";
#line 1553
    pixel_format[3] = "ARGB 1:4:4:4";
#line 1553
    pixel_format[4] = "ARGB 8:8:8:8";
#line 1553
    pixel_format[5] = "5";
#line 1553
    pixel_format[6] = "6";
#line 1553
    pixel_format[7] = "7";
#line 1553
    pixel_format[8] = "AYUV Indexed";
#line 1553
    pixel_format[9] = "YUV 5:6:5";
#line 1553
    pixel_format[10] = "AYUV 1:5:5:5";
#line 1553
    pixel_format[11] = "AYUV 1:4:4:4";
#line 1553
    pixel_format[12] = "AYUV 8:8:8:8";
#line 1553
    pixel_format[13] = "13";
#line 1553
    pixel_format[14] = "14";
#line 1553
    pixel_format[15] = "15";
#line 1572
    ivtv_get_output(itv, (int )((u16 )itv->active_output), & vidout);
#line 1573
    ivtv_get_audio_output(itv, 0, & audout);
#line 1574
    printk("\016%s: Video Output: %s\n", (char *)(& itv->v4l2_dev.name), (__u8 *)(& vidout.name));
#line 1575
    if (mode < 0 || mode > 4) {
#line 1576
      mode = 0;
    } else {

    }
#line 1577
    printk("\016%s: Output Mode:  %s\n", (char *)(& itv->v4l2_dev.name), output_modes[mode]);
#line 1578
    ivtv_vapi_result(itv, (u32 *)(& data), 68, 0);
#line 1579
    tmp___0 = readl((void const volatile   *)itv->reg_mem + 10752U);
#line 1579
    data[0] = data[0] | ((tmp___0 >> 7) & 64U);
#line 1580
    printk("\016%s: Overlay:      %s, Alpha: %s, Pixel Format: %s\n", (char *)(& itv->v4l2_dev.name),
           (int )data[0] & 1 ? (char *)"On" : (char *)"Off", alpha_mode[(data[0] >> 1) & 3U],
           pixel_format[(data[0] >> 3) & 15U]);
  } else {

  }
#line 1585
  tmp___1 = constant_test_bit(5L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1585
  printk("\016%s: Tuner:  %s\n", (char *)(& itv->v4l2_dev.name), tmp___1 != 0 ? (char *)"Radio" : (char *)"TV");
#line 1587
  v4l2_ctrl_handler_log_status(& itv->cxhdl.hdl, (char const   *)(& itv->v4l2_dev.name));
#line 1588
  printk("\016%s: Status flags:    0x%08lx\n", (char *)(& itv->v4l2_dev.name), itv->i_flags);
#line 1589
  i = 0;
#line 1589
  goto ldv_42655;
  ldv_42654: 
#line 1590
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )i;
#line 1592
  if ((unsigned long )s->vdev.v4l2_dev == (unsigned long )((struct v4l2_device *)0) || s->buffers == 0U) {
#line 1593
    goto ldv_42653;
  } else {

  }
#line 1594
  printk("\016%s: Stream %s: status 0x%04lx, %d%% of %d KiB (%d buffers) in use\n",
         (char *)(& itv->v4l2_dev.name), s->name, s->s_flags, ((s->buffers - s->q_free.buffers) * 100U) / s->buffers,
         (s->buffers * s->buf_size) / 1024U, s->buffers);
  ldv_42653: 
#line 1589
  i = i + 1;
  ldv_42655: ;
#line 1589
  if (i <= 8) {
#line 1591
    goto ldv_42654;
  } else {

  }
#line 1599
  printk("\016%s: Read MPG/VBI: %lld/%lld bytes\n", (char *)(& itv->v4l2_dev.name),
         (long long )itv->mpg_data_received, (long long )itv->vbi_data_inserted);
#line 1602
  return (0);
}
}
#line 1605 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_decoder_cmd(struct file *file , void *fh , struct v4l2_decoder_cmd *dec ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  int tmp___0 ;

  {
#line 1607
  tmp = fh2id((struct v4l2_fh *)file->private_data);
#line 1607
  id = tmp;
#line 1608
  itv = id->itv;
#line 1610
  if ((ivtv_debug & 8) != 0) {
#line 1610
    printk("\016%s:  ioctl: VIDIOC_DECODER_CMD %d\n", (char *)(& itv->v4l2_dev.name),
           dec->cmd);
  } else {

  }
#line 1611
  tmp___0 = ivtv_video_command(itv, id, dec, 0);
#line 1611
  return (tmp___0);
}
}
#line 1614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_try_decoder_cmd(struct file *file , void *fh , struct v4l2_decoder_cmd *dec ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  int tmp___0 ;

  {
#line 1616
  tmp = fh2id((struct v4l2_fh *)file->private_data);
#line 1616
  id = tmp;
#line 1617
  itv = id->itv;
#line 1619
  if ((ivtv_debug & 8) != 0) {
#line 1619
    printk("\016%s:  ioctl: VIDIOC_TRY_DECODER_CMD %d\n", (char *)(& itv->v4l2_dev.name),
           dec->cmd);
  } else {

  }
#line 1620
  tmp___0 = ivtv_video_command(itv, id, dec, 1);
#line 1620
  return (tmp___0);
}
}
#line 1623 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static int ivtv_decoder_ioctls(struct file *filp , unsigned int cmd , void *arg ) 
{ 
  struct ivtv_open_id *id ;
  struct ivtv_open_id *tmp ;
  struct ivtv *itv ;
  int nonblocking ;
  struct ivtv_stream *s ;
  unsigned long iarg ;
  struct ivtv_dma_frame *args ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  s64 *pts ;
  s64 frame ;
  int tmp___4 ;
  s64 *frame___0 ;
  s64 pts___0 ;
  int tmp___5 ;
  struct v4l2_decoder_cmd dc ;
  int tmp___6 ;
  struct v4l2_decoder_cmd dc___0 ;
  int tmp___7 ;
  struct v4l2_decoder_cmd dc___1 ;
  int tmp___8 ;
  struct v4l2_decoder_cmd dc___2 ;
  int tmp___9 ;
  struct v4l2_decoder_cmd *dc___3 ;
  int try ;
  int tmp___10 ;
  struct video_event *ev ;
  wait_queue_t wait ;
  struct task_struct *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  struct task_struct *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 1625
  tmp = fh2id((struct v4l2_fh *)filp->private_data);
#line 1625
  id = tmp;
#line 1626
  itv = id->itv;
#line 1627
  nonblocking = (int )filp->f_flags & 2048;
#line 1628
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )id->type;
#line 1629
  iarg = (unsigned long )arg;
#line 1631
  switch (cmd) {
  case 1077958336U: 
#line 1633
  args = (struct ivtv_dma_frame *)arg;
#line 1635
  if ((ivtv_debug & 8) != 0) {
#line 1635
    printk("\016%s:  ioctl: IVTV_IOC_DMA_FRAME\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1636
  if ((itv->v4l2_cap & 2U) == 0U) {
#line 1637
    return (-22);
  } else {

  }
#line 1638
  if ((unsigned int )args->type != 2U) {
#line 1639
    return (-22);
  } else {

  }
#line 1640
  if (itv->output_mode == 3 && (unsigned long )args->y_source == (unsigned long )((void *)0)) {
#line 1641
    return (0);
  } else {

  }
#line 1642
  tmp___0 = ivtv_start_decoding(id, id->type);
#line 1642
  if (tmp___0 != 0) {
#line 1643
    return (-16);
  } else {

  }
#line 1645
  tmp___1 = ivtv_set_output_mode(itv, 3);
#line 1645
  if (tmp___1 != 3) {
#line 1646
    ivtv_release_stream(s);
#line 1647
    return (-16);
  } else {

  }
#line 1650
  id->yuv_frames = 1;
#line 1651
  if ((unsigned long )args->y_source == (unsigned long )((void *)0)) {
#line 1652
    return (0);
  } else {

  }
#line 1653
  tmp___2 = ivtv_yuv_prep_frame(itv, args);
#line 1653
  return (tmp___2);
  case 1074026177U: ;
#line 1657
  if ((ivtv_debug & 8) != 0) {
#line 1657
    printk("\016%s:  ioctl: IVTV_IOC_PASSTHROUGH_MODE\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1658
  if ((itv->v4l2_cap & 2U) == 0U) {
#line 1659
    return (-22);
  } else {

  }
#line 1660
  tmp___3 = ivtv_passthrough_mode(itv, *((int *)arg) != 0);
#line 1660
  return (tmp___3);
  case 2148036409U: 
#line 1663
  pts = (s64 *)arg;
#line 1666
  if ((ivtv_debug & 8) != 0) {
#line 1666
    printk("\016%s:  ioctl: VIDEO_GET_PTS\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1667
  if (s->type <= 4) {
#line 1668
    *pts = (s64 )s->dma_pts;
#line 1669
    goto ldv_42687;
  } else {

  }
#line 1671
  if ((itv->v4l2_cap & 2U) == 0U) {
#line 1672
    return (-22);
  } else {

  }
#line 1673
  tmp___4 = ivtv_g_pts_frame(itv, pts, & frame);
#line 1673
  return (tmp___4);
  case 2148036410U: 
#line 1677
  frame___0 = (s64 *)arg;
#line 1680
  if ((ivtv_debug & 8) != 0) {
#line 1680
    printk("\016%s:  ioctl: VIDEO_GET_FRAME_COUNT\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1681
  if (s->type <= 4) {
#line 1682
    *frame___0 = 0LL;
#line 1683
    goto ldv_42687;
  } else {

  }
#line 1685
  if ((itv->v4l2_cap & 2U) == 0U) {
#line 1686
    return (-22);
  } else {

  }
#line 1687
  tmp___5 = ivtv_g_pts_frame(itv, & pts___0, frame___0);
#line 1687
  return (tmp___5);
  case 28438U: ;
#line 1693
  if ((ivtv_debug & 8) != 0) {
#line 1693
    printk("\016%s:  ioctl: VIDEO_PLAY\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1694
  memset((void *)(& dc), 0, 72UL);
#line 1695
  dc.cmd = 0U;
#line 1696
  tmp___6 = ivtv_video_command(itv, id, & dc, 0);
#line 1696
  return (tmp___6);
  case 28437U: ;
#line 1702
  if ((ivtv_debug & 8) != 0) {
#line 1702
    printk("\016%s:  ioctl: VIDEO_STOP\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1703
  memset((void *)(& dc___0), 0, 72UL);
#line 1704
  dc___0.cmd = 1U;
#line 1705
  dc___0.flags = 3U;
#line 1706
  tmp___7 = ivtv_video_command(itv, id, & dc___0, 0);
#line 1706
  return (tmp___7);
  case 28439U: ;
#line 1712
  if ((ivtv_debug & 8) != 0) {
#line 1712
    printk("\016%s:  ioctl: VIDEO_FREEZE\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1713
  memset((void *)(& dc___1), 0, 72UL);
#line 1714
  dc___1.cmd = 2U;
#line 1715
  tmp___8 = ivtv_video_command(itv, id, & dc___1, 0);
#line 1715
  return (tmp___8);
  case 28440U: ;
#line 1721
  if ((ivtv_debug & 8) != 0) {
#line 1721
    printk("\016%s:  ioctl: VIDEO_CONTINUE\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1722
  memset((void *)(& dc___2), 0, 72UL);
#line 1723
  dc___2.cmd = 3U;
#line 1724
  tmp___9 = ivtv_video_command(itv, id, & dc___2, 0);
#line 1724
  return (tmp___9);
  case 3225972539U: ;
  case 3225972540U: 
#line 1731
  dc___3 = (struct v4l2_decoder_cmd *)arg;
#line 1732
  try = cmd == 3225972540U;
#line 1734
  if (try != 0) {
#line 1735
    if ((ivtv_debug & 8) != 0) {
#line 1735
      printk("\016%s:  ioctl: VIDEO_TRY_COMMAND %d\n", (char *)(& itv->v4l2_dev.name),
             dc___3->cmd);
    } else {

    }
  } else
#line 1737
  if ((ivtv_debug & 8) != 0) {
#line 1737
    printk("\016%s:  ioctl: VIDEO_COMMAND %d\n", (char *)(& itv->v4l2_dev.name), dc___3->cmd);
  } else {

  }
#line 1738
  tmp___10 = ivtv_video_command(itv, id, dc___3, try);
#line 1738
  return (tmp___10);
  case 2149609244U: 
#line 1742
  ev = (struct video_event *)arg;
#line 1743
  tmp___11 = get_current();
#line 1743
  wait.flags = 0U;
#line 1743
  wait.private = (void *)tmp___11;
#line 1743
  wait.func = & autoremove_wake_function;
#line 1743
  wait.task_list.next = & wait.task_list;
#line 1743
  wait.task_list.prev = & wait.task_list;
#line 1745
  if ((ivtv_debug & 8) != 0) {
#line 1745
    printk("\016%s:  ioctl: VIDEO_GET_EVENT\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1746
  if ((itv->v4l2_cap & 2U) == 0U) {
#line 1747
    return (-22);
  } else {

  }
#line 1748
  memset((void *)ev, 0, 32UL);
#line 1749
  set_bit(31L, (unsigned long volatile   *)(& itv->i_flags));
  ldv_42706: 
#line 1752
  tmp___14 = test_and_clear_bit(28L, (unsigned long volatile   *)(& itv->i_flags));
#line 1752
  if (tmp___14 != 0) {
#line 1753
    ev->type = 3;
  } else {
#line 1754
    tmp___13 = test_and_clear_bit(29L, (unsigned long volatile   *)(& itv->i_flags));
#line 1754
    if (tmp___13 != 0) {
#line 1755
      ev->type = 4;
#line 1756
      tmp___12 = constant_test_bit(30L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1756
      ev->u.vsync_field = tmp___12 != 0 ? 1U : 2U;
#line 1758
      if (itv->output_mode == 3 && (itv->yuv_info.lace_mode & 3) == 1) {
#line 1761
        ev->u.vsync_field = 3U;
      } else {

      }
    } else {

    }
  }
#line 1764
  if (ev->type != 0) {
#line 1765
    return (0);
  } else {

  }
#line 1766
  if (nonblocking != 0) {
#line 1767
    return (-11);
  } else {

  }
#line 1771
  mutex_unlock(& itv->serialize_lock);
#line 1772
  prepare_to_wait(& itv->event_waitq, & wait, 1);
#line 1773
  tmp___15 = constant_test_bit(28L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1773
  if (tmp___15 == 0) {
#line 1773
    tmp___16 = constant_test_bit(29L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1773
    if (tmp___16 == 0) {
#line 1775
      schedule();
    } else {

    }
  } else {

  }
#line 1776
  finish_wait(& itv->event_waitq, & wait);
#line 1777
  mutex_lock_nested(& itv->serialize_lock, 0U);
#line 1778
  tmp___17 = get_current();
#line 1778
  tmp___18 = signal_pending___1(tmp___17);
#line 1778
  if (tmp___18 != 0) {
#line 1780
    if ((ivtv_debug & 2) != 0) {
#line 1780
      printk("\016%s:  info: User stopped wait for event\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 1781
    return (-4);
  } else {

  }
#line 1783
  goto ldv_42706;
  case 28441U: ;
#line 1788
  if ((ivtv_debug & 8) != 0) {
#line 1788
    printk("\016%s:  ioctl: VIDEO_SELECT_SOURCE\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1789
  if ((itv->v4l2_cap & 2U) == 0U) {
#line 1790
    return (-22);
  } else {

  }
#line 1791
  tmp___19 = ivtv_passthrough_mode(itv, iarg == 0UL);
#line 1791
  return (tmp___19);
  case 28422U: ;
#line 1794
  if ((ivtv_debug & 8) != 0) {
#line 1794
    printk("\016%s:  ioctl: AUDIO_SET_MUTE\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1795
  itv->speed_mute_audio = (u8 )iarg;
#line 1796
  return (0);
  case 28425U: ;
#line 1799
  if ((ivtv_debug & 8) != 0) {
#line 1799
    printk("\016%s:  ioctl: AUDIO_CHANNEL_SELECT\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1800
  if (iarg > 4UL) {
#line 1801
    return (-22);
  } else {

  }
#line 1802
  tmp___20 = v4l2_ctrl_s_ctrl(itv->__annonCompField106.ctrl_audio_playback, (s32 )((unsigned int )iarg + 1U));
#line 1802
  return (tmp___20);
  case 28436U: ;
#line 1805
  if ((ivtv_debug & 8) != 0) {
#line 1805
    printk("\016%s:  ioctl: AUDIO_BILINGUAL_CHANNEL_SELECT\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1806
  if (iarg > 4UL) {
#line 1807
    return (-22);
  } else {

  }
#line 1808
  tmp___21 = v4l2_ctrl_s_ctrl(itv->__annonCompField106.ctrl_audio_multilingual_playback,
                              (s32 )((unsigned int )iarg + 1U));
#line 1808
  return (tmp___21);
  default: ;
#line 1811
  return (-22);
  }
  ldv_42687: ;
#line 1813
  return (0);
}
}
#line 1816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static long ivtv_default(struct file *file , void *fh , bool valid_prio , unsigned int cmd ,
                         void *arg ) 
{ 
  struct ivtv *itv ;
  struct ivtv_open_id *tmp ;
  u32 val ;
  int tmp___0 ;

  {
#line 1819
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1819
  itv = tmp->itv;
#line 1821
  if (! valid_prio) {
#line 1822
    switch (cmd) {
    case 1074026177U: ;
    case 28438U: ;
    case 28437U: ;
    case 28439U: ;
    case 28440U: ;
    case 3225972539U: ;
    case 28441U: ;
    case 28422U: ;
    case 28425U: ;
    case 28436U: ;
#line 1833
    return (-16L);
    }
  } else {

  }
#line 1837
  switch (cmd) {
  case 1074029670U: 
#line 1839
  val = *((u32 *)arg);
#line 1841
  if ((val == 0U && itv->options.newi2c != 0) || (int )val & 1) {
#line 1842
    ivtv_reset_ir_gpio(itv);
  } else {

  }
#line 1843
  if ((val & 2U) != 0U) {
#line 1844
    if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 1844
      if ((unsigned long )((itv->sd_video)->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->core)->reset != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                   u32  ))0)) {
#line 1844
        (*((((itv->sd_video)->ops)->core)->reset))(itv->sd_video, 0U);
      } else {

      }
    } else {

    }
  } else {

  }
#line 1845
  goto ldv_42732;
  case 1077958336U: ;
  case 1074026177U: ;
  case 2148036409U: ;
  case 2148036410U: ;
  case 2149609244U: ;
  case 28438U: ;
  case 28437U: ;
  case 28439U: ;
  case 28440U: ;
  case 3225972539U: ;
  case 3225972540U: ;
  case 28441U: ;
  case 28422U: ;
  case 28425U: ;
  case 28436U: 
#line 1863
  tmp___0 = ivtv_decoder_ioctls(file, cmd, arg);
#line 1863
  return ((long )tmp___0);
  default: ;
#line 1866
  return (-25L);
  }
  ldv_42732: ;
#line 1868
  return (0L);
}
}
#line 1871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
static struct v4l2_ioctl_ops  const  ivtv_ioctl_ops  = 
#line 1871
     {& ivtv_querycap, & ivtv_enum_fmt_vid_cap, 0, & ivtv_enum_fmt_vid_out, 0, 0, 0,
    & ivtv_g_fmt_vid_cap, 0, & ivtv_g_fmt_vid_out, & ivtv_g_fmt_vid_out_overlay, & ivtv_g_fmt_vbi_cap,
    0, & ivtv_g_fmt_sliced_vbi_cap, & ivtv_g_fmt_sliced_vbi_out, 0, 0, 0, & ivtv_s_fmt_vid_cap,
    0, & ivtv_s_fmt_vid_out, & ivtv_s_fmt_vid_out_overlay, & ivtv_s_fmt_vbi_cap, 0,
    & ivtv_s_fmt_sliced_vbi_cap, & ivtv_s_fmt_sliced_vbi_out, 0, 0, 0, & ivtv_try_fmt_vid_cap,
    0, & ivtv_try_fmt_vid_out, & ivtv_try_fmt_vid_out_overlay, & ivtv_try_fmt_vbi_cap,
    0, & ivtv_try_fmt_sliced_vbi_cap, & ivtv_try_fmt_sliced_vbi_out, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, & ivtv_overlay, & ivtv_g_fbuf, & ivtv_s_fbuf, 0, 0, & ivtv_g_std,
    & ivtv_s_std, 0, & ivtv_enum_input, & ivtv_g_input, & ivtv_s_input, & ivtv_enum_output,
    & ivtv_g_output, & ivtv_s_output, 0, 0, 0, 0, 0, 0, 0, 0, & ivtv_enumaudio, & ivtv_g_audio,
    & ivtv_s_audio, & ivtv_enumaudout, & ivtv_g_audout, & ivtv_s_audout, 0, 0, & ivtv_cropcap,
    0, 0, & ivtv_g_selection, & ivtv_s_selection, 0, 0, & ivtv_g_enc_index, & ivtv_encoder_cmd,
    & ivtv_try_encoder_cmd, & ivtv_decoder_cmd, & ivtv_try_decoder_cmd, 0, 0, & ivtv_g_tuner,
    & ivtv_s_tuner, & ivtv_g_frequency, & ivtv_s_frequency, 0, & ivtv_g_sliced_vbi_cap,
    & ivtv_log_status, 0, & ivtv_g_register, & ivtv_s_register, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, & ivtv_subscribe_event, & v4l2_event_unsubscribe, & ivtv_default};
#line 1933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.c"
void ivtv_set_funcs(struct video_device *vdev ) 
{ 


  {
#line 1935
  vdev->ioctl_ops = & ivtv_ioctl_ops;
#line 1936
  return;
}
}
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.o.c.prepared"
void ldv_initialize_v4l2_ioctl_ops_7(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
#line 116
  tmp = ldv_init_zalloc(208UL);
#line 116
  ivtv_ioctl_ops_group6 = (struct v4l2_format *)tmp;
#line 117
  tmp___0 = ldv_init_zalloc(52UL);
#line 117
  ivtv_ioctl_ops_group7 = (struct v4l2_audioout *)tmp___0;
#line 118
  tmp___1 = ldv_init_zalloc(64UL);
#line 118
  ivtv_ioctl_ops_group0 = (struct v4l2_fmtdesc *)tmp___1;
#line 119
  tmp___2 = ldv_init_zalloc(32UL);
#line 119
  ivtv_ioctl_ops_group1 = (struct v4l2_event_subscription  const  *)tmp___2;
#line 120
  tmp___3 = ldv_init_zalloc(52UL);
#line 120
  ivtv_ioctl_ops_group2 = (struct v4l2_audio *)tmp___3;
#line 121
  tmp___4 = __VERIFIER_nondet_pointer();
#line 121
  ivtv_ioctl_ops_group3 = (struct file *)tmp___4;
#line 122
  tmp___5 = ldv_init_zalloc(176UL);
#line 122
  ivtv_ioctl_ops_group4 = (struct v4l2_fh *)tmp___5;
#line 123
  tmp___6 = ldv_init_zalloc(64UL);
#line 123
  ivtv_ioctl_ops_group9 = (struct v4l2_selection *)tmp___6;
#line 124
  tmp___7 = ldv_init_zalloc(40UL);
#line 124
  ivtv_ioctl_ops_group8 = (struct v4l2_encoder_cmd *)tmp___7;
#line 125
  tmp___8 = ldv_init_zalloc(72UL);
#line 125
  ivtv_ioctl_ops_group5 = (struct v4l2_decoder_cmd *)tmp___8;
#line 126
  return;
}
}
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.o.c.prepared"
void ldv_main_exported_7(void) 
{ 
  struct v4l2_output *ldvarg52 ;
  void *tmp ;
  struct v4l2_tuner *ldvarg74 ;
  void *tmp___0 ;
  void *ldvarg22 ;
  void *tmp___1 ;
  void *ldvarg61 ;
  void *tmp___2 ;
  struct v4l2_frequency *ldvarg17 ;
  void *tmp___3 ;
  struct v4l2_cropcap *ldvarg25 ;
  void *tmp___4 ;
  void *ldvarg21 ;
  void *tmp___5 ;
  v4l2_std_id *ldvarg15 ;
  void *tmp___6 ;
  void *ldvarg78 ;
  void *tmp___7 ;
  void *ldvarg73 ;
  void *tmp___8 ;
  void *ldvarg26 ;
  void *tmp___9 ;
  void *ldvarg27 ;
  void *tmp___10 ;
  bool ldvarg9 ;
  void *ldvarg66 ;
  void *tmp___11 ;
  void *ldvarg65 ;
  void *tmp___12 ;
  void *ldvarg57 ;
  void *tmp___13 ;
  unsigned int ldvarg8 ;
  struct v4l2_frequency *ldvarg62 ;
  void *tmp___14 ;
  void *ldvarg80 ;
  void *tmp___15 ;
  void *ldvarg39 ;
  void *tmp___16 ;
  void *ldvarg34 ;
  void *tmp___17 ;
  void *ldvarg14 ;
  void *tmp___18 ;
  void *ldvarg48 ;
  void *tmp___19 ;
  void *ldvarg38 ;
  void *tmp___20 ;
  struct v4l2_tuner *ldvarg35 ;
  void *tmp___21 ;
  void *ldvarg24 ;
  void *tmp___22 ;
  void *ldvarg29 ;
  void *tmp___23 ;
  void *ldvarg37 ;
  void *tmp___24 ;
  void *ldvarg56 ;
  void *tmp___25 ;
  void *ldvarg72 ;
  void *tmp___26 ;
  struct v4l2_framebuffer *ldvarg71 ;
  void *tmp___27 ;
  void *ldvarg43 ;
  void *tmp___28 ;
  void *ldvarg67 ;
  void *tmp___29 ;
  void *ldvarg23 ;
  void *tmp___30 ;
  void *ldvarg11 ;
  void *tmp___31 ;
  void *ldvarg18 ;
  void *tmp___32 ;
  unsigned int ldvarg77 ;
  void *ldvarg75 ;
  void *tmp___33 ;
  struct v4l2_capability *ldvarg19 ;
  void *tmp___34 ;
  void *ldvarg76 ;
  void *tmp___35 ;
  void *ldvarg82 ;
  void *tmp___36 ;
  void *ldvarg54 ;
  void *tmp___37 ;
  void *ldvarg30 ;
  void *tmp___38 ;
  void *ldvarg68 ;
  void *tmp___39 ;
  void *ldvarg70 ;
  void *tmp___40 ;
  void *ldvarg63 ;
  void *tmp___41 ;
  struct v4l2_sliced_vbi_cap *ldvarg45 ;
  void *tmp___42 ;
  unsigned int *ldvarg81 ;
  void *tmp___43 ;
  struct v4l2_dbg_register *ldvarg40 ;
  void *tmp___44 ;
  void *ldvarg10 ;
  void *tmp___45 ;
  void *ldvarg36 ;
  void *tmp___46 ;
  struct v4l2_dbg_register *ldvarg55 ;
  void *tmp___47 ;
  struct v4l2_input *ldvarg13 ;
  void *tmp___48 ;
  void *ldvarg79 ;
  void *tmp___49 ;
  void *ldvarg49 ;
  void *tmp___50 ;
  void *ldvarg59 ;
  void *tmp___51 ;
  void *ldvarg41 ;
  void *tmp___52 ;
  unsigned int *ldvarg60 ;
  void *tmp___53 ;
  void *ldvarg31 ;
  void *tmp___54 ;
  void *ldvarg20 ;
  void *tmp___55 ;
  unsigned int ldvarg47 ;
  void *ldvarg28 ;
  void *tmp___56 ;
  struct v4l2_audio *ldvarg4 ;
  void *tmp___57 ;
  void *ldvarg16 ;
  void *tmp___58 ;
  void *ldvarg6 ;
  void *tmp___59 ;
  v4l2_std_id ldvarg33 ;
  void *ldvarg5 ;
  void *tmp___60 ;
  void *ldvarg69 ;
  void *tmp___61 ;
  void *ldvarg83 ;
  void *tmp___62 ;
  void *ldvarg44 ;
  void *tmp___63 ;
  struct v4l2_audioout *ldvarg64 ;
  void *tmp___64 ;
  void *ldvarg53 ;
  void *tmp___65 ;
  unsigned int ldvarg58 ;
  void *ldvarg46 ;
  void *tmp___66 ;
  struct v4l2_framebuffer *ldvarg50 ;
  void *tmp___67 ;
  void *ldvarg12 ;
  void *tmp___68 ;
  struct v4l2_enc_idx *ldvarg42 ;
  void *tmp___69 ;
  void *ldvarg7 ;
  void *tmp___70 ;
  void *ldvarg32 ;
  void *tmp___71 ;
  void *ldvarg51 ;
  void *tmp___72 ;
  void *ldvarg84 ;
  void *tmp___73 ;
  int tmp___74 ;

  {
#line 129
  tmp = ldv_init_zalloc(72UL);
#line 129
  ldvarg52 = (struct v4l2_output *)tmp;
#line 130
  tmp___0 = ldv_init_zalloc(84UL);
#line 130
  ldvarg74 = (struct v4l2_tuner *)tmp___0;
#line 131
  tmp___1 = ldv_init_zalloc(1UL);
#line 131
  ldvarg22 = tmp___1;
#line 132
  tmp___2 = ldv_init_zalloc(1UL);
#line 132
  ldvarg61 = tmp___2;
#line 133
  tmp___3 = ldv_init_zalloc(44UL);
#line 133
  ldvarg17 = (struct v4l2_frequency *)tmp___3;
#line 134
  tmp___4 = ldv_init_zalloc(44UL);
#line 134
  ldvarg25 = (struct v4l2_cropcap *)tmp___4;
#line 135
  tmp___5 = ldv_init_zalloc(1UL);
#line 135
  ldvarg21 = tmp___5;
#line 136
  tmp___6 = ldv_init_zalloc(8UL);
#line 136
  ldvarg15 = (v4l2_std_id *)tmp___6;
#line 137
  tmp___7 = ldv_init_zalloc(1UL);
#line 137
  ldvarg78 = tmp___7;
#line 138
  tmp___8 = ldv_init_zalloc(1UL);
#line 138
  ldvarg73 = tmp___8;
#line 139
  tmp___9 = ldv_init_zalloc(1UL);
#line 139
  ldvarg26 = tmp___9;
#line 140
  tmp___10 = ldv_init_zalloc(1UL);
#line 140
  ldvarg27 = tmp___10;
#line 142
  tmp___11 = ldv_init_zalloc(1UL);
#line 142
  ldvarg66 = tmp___11;
#line 143
  tmp___12 = ldv_init_zalloc(1UL);
#line 143
  ldvarg65 = tmp___12;
#line 144
  tmp___13 = ldv_init_zalloc(1UL);
#line 144
  ldvarg57 = tmp___13;
#line 146
  tmp___14 = ldv_init_zalloc(44UL);
#line 146
  ldvarg62 = (struct v4l2_frequency *)tmp___14;
#line 147
  tmp___15 = ldv_init_zalloc(1UL);
#line 147
  ldvarg80 = tmp___15;
#line 148
  tmp___16 = ldv_init_zalloc(1UL);
#line 148
  ldvarg39 = tmp___16;
#line 149
  tmp___17 = ldv_init_zalloc(1UL);
#line 149
  ldvarg34 = tmp___17;
#line 150
  tmp___18 = ldv_init_zalloc(1UL);
#line 150
  ldvarg14 = tmp___18;
#line 151
  tmp___19 = ldv_init_zalloc(1UL);
#line 151
  ldvarg48 = tmp___19;
#line 152
  tmp___20 = ldv_init_zalloc(1UL);
#line 152
  ldvarg38 = tmp___20;
#line 153
  tmp___21 = ldv_init_zalloc(84UL);
#line 153
  ldvarg35 = (struct v4l2_tuner *)tmp___21;
#line 154
  tmp___22 = ldv_init_zalloc(1UL);
#line 154
  ldvarg24 = tmp___22;
#line 155
  tmp___23 = ldv_init_zalloc(1UL);
#line 155
  ldvarg29 = tmp___23;
#line 156
  tmp___24 = ldv_init_zalloc(1UL);
#line 156
  ldvarg37 = tmp___24;
#line 157
  tmp___25 = ldv_init_zalloc(1UL);
#line 157
  ldvarg56 = tmp___25;
#line 158
  tmp___26 = ldv_init_zalloc(1UL);
#line 158
  ldvarg72 = tmp___26;
#line 159
  tmp___27 = ldv_init_zalloc(48UL);
#line 159
  ldvarg71 = (struct v4l2_framebuffer *)tmp___27;
#line 160
  tmp___28 = ldv_init_zalloc(1UL);
#line 160
  ldvarg43 = tmp___28;
#line 161
  tmp___29 = ldv_init_zalloc(1UL);
#line 161
  ldvarg67 = tmp___29;
#line 162
  tmp___30 = ldv_init_zalloc(1UL);
#line 162
  ldvarg23 = tmp___30;
#line 163
  tmp___31 = ldv_init_zalloc(1UL);
#line 163
  ldvarg11 = tmp___31;
#line 164
  tmp___32 = ldv_init_zalloc(1UL);
#line 164
  ldvarg18 = tmp___32;
#line 166
  tmp___33 = ldv_init_zalloc(1UL);
#line 166
  ldvarg75 = tmp___33;
#line 167
  tmp___34 = ldv_init_zalloc(104UL);
#line 167
  ldvarg19 = (struct v4l2_capability *)tmp___34;
#line 168
  tmp___35 = ldv_init_zalloc(1UL);
#line 168
  ldvarg76 = tmp___35;
#line 169
  tmp___36 = ldv_init_zalloc(1UL);
#line 169
  ldvarg82 = tmp___36;
#line 170
  tmp___37 = ldv_init_zalloc(1UL);
#line 170
  ldvarg54 = tmp___37;
#line 171
  tmp___38 = ldv_init_zalloc(1UL);
#line 171
  ldvarg30 = tmp___38;
#line 172
  tmp___39 = ldv_init_zalloc(1UL);
#line 172
  ldvarg68 = tmp___39;
#line 173
  tmp___40 = ldv_init_zalloc(1UL);
#line 173
  ldvarg70 = tmp___40;
#line 174
  tmp___41 = ldv_init_zalloc(1UL);
#line 174
  ldvarg63 = tmp___41;
#line 175
  tmp___42 = ldv_init_zalloc(116UL);
#line 175
  ldvarg45 = (struct v4l2_sliced_vbi_cap *)tmp___42;
#line 176
  tmp___43 = ldv_init_zalloc(4UL);
#line 176
  ldvarg81 = (unsigned int *)tmp___43;
#line 177
  tmp___44 = ldv_init_zalloc(56UL);
#line 177
  ldvarg40 = (struct v4l2_dbg_register *)tmp___44;
#line 178
  tmp___45 = ldv_init_zalloc(1UL);
#line 178
  ldvarg10 = tmp___45;
#line 179
  tmp___46 = ldv_init_zalloc(1UL);
#line 179
  ldvarg36 = tmp___46;
#line 180
  tmp___47 = ldv_init_zalloc(56UL);
#line 180
  ldvarg55 = (struct v4l2_dbg_register *)tmp___47;
#line 181
  tmp___48 = ldv_init_zalloc(80UL);
#line 181
  ldvarg13 = (struct v4l2_input *)tmp___48;
#line 182
  tmp___49 = ldv_init_zalloc(1UL);
#line 182
  ldvarg79 = tmp___49;
#line 183
  tmp___50 = ldv_init_zalloc(1UL);
#line 183
  ldvarg49 = tmp___50;
#line 184
  tmp___51 = ldv_init_zalloc(1UL);
#line 184
  ldvarg59 = tmp___51;
#line 185
  tmp___52 = ldv_init_zalloc(1UL);
#line 185
  ldvarg41 = tmp___52;
#line 186
  tmp___53 = ldv_init_zalloc(4UL);
#line 186
  ldvarg60 = (unsigned int *)tmp___53;
#line 187
  tmp___54 = ldv_init_zalloc(1UL);
#line 187
  ldvarg31 = tmp___54;
#line 188
  tmp___55 = ldv_init_zalloc(1UL);
#line 188
  ldvarg20 = tmp___55;
#line 190
  tmp___56 = ldv_init_zalloc(1UL);
#line 190
  ldvarg28 = tmp___56;
#line 191
  tmp___57 = ldv_init_zalloc(52UL);
#line 191
  ldvarg4 = (struct v4l2_audio *)tmp___57;
#line 192
  tmp___58 = ldv_init_zalloc(1UL);
#line 192
  ldvarg16 = tmp___58;
#line 193
  tmp___59 = ldv_init_zalloc(1UL);
#line 193
  ldvarg6 = tmp___59;
#line 195
  tmp___60 = ldv_init_zalloc(1UL);
#line 195
  ldvarg5 = tmp___60;
#line 196
  tmp___61 = ldv_init_zalloc(1UL);
#line 196
  ldvarg69 = tmp___61;
#line 197
  tmp___62 = ldv_init_zalloc(1UL);
#line 197
  ldvarg83 = tmp___62;
#line 198
  tmp___63 = ldv_init_zalloc(1UL);
#line 198
  ldvarg44 = tmp___63;
#line 199
  tmp___64 = ldv_init_zalloc(52UL);
#line 199
  ldvarg64 = (struct v4l2_audioout *)tmp___64;
#line 200
  tmp___65 = ldv_init_zalloc(1UL);
#line 200
  ldvarg53 = tmp___65;
#line 202
  tmp___66 = ldv_init_zalloc(1UL);
#line 202
  ldvarg46 = tmp___66;
#line 203
  tmp___67 = ldv_init_zalloc(48UL);
#line 203
  ldvarg50 = (struct v4l2_framebuffer *)tmp___67;
#line 204
  tmp___68 = ldv_init_zalloc(1UL);
#line 204
  ldvarg12 = tmp___68;
#line 205
  tmp___69 = ldv_init_zalloc(2072UL);
#line 205
  ldvarg42 = (struct v4l2_enc_idx *)tmp___69;
#line 206
  tmp___70 = ldv_init_zalloc(1UL);
#line 206
  ldvarg7 = tmp___70;
#line 207
  tmp___71 = ldv_init_zalloc(1UL);
#line 207
  ldvarg32 = tmp___71;
#line 208
  tmp___72 = ldv_init_zalloc(1UL);
#line 208
  ldvarg51 = tmp___72;
#line 209
  tmp___73 = ldv_init_zalloc(1UL);
#line 209
  ldvarg84 = tmp___73;
#line 141
  ldv_memset((void *)(& ldvarg9), 0, 1UL);
#line 145
  ldv_memset((void *)(& ldvarg8), 0, 4UL);
#line 165
  ldv_memset((void *)(& ldvarg77), 0, 4UL);
#line 189
  ldv_memset((void *)(& ldvarg47), 0, 4UL);
#line 194
  ldv_memset((void *)(& ldvarg33), 0, 8UL);
#line 201
  ldv_memset((void *)(& ldvarg58), 0, 4UL);
#line 211
  tmp___74 = __VERIFIER_nondet_int();
#line 211
  switch (tmp___74) {
  case 0: ;
#line 214
  if (ldv_state_variable_7 == 1) {
#line 216
    ivtv_g_fmt_vid_out(ivtv_ioctl_ops_group3, ldvarg84, ivtv_ioctl_ops_group6);
#line 218
    ldv_state_variable_7 = 1;
  } else {

  }
#line 221
  goto ldv_42841;
  case 1: ;
#line 224
  if (ldv_state_variable_7 == 1) {
#line 226
    ivtv_try_fmt_sliced_vbi_cap(ivtv_ioctl_ops_group3, ldvarg83, ivtv_ioctl_ops_group6);
#line 228
    ldv_state_variable_7 = 1;
  } else {

  }
#line 231
  goto ldv_42841;
  case 2: ;
#line 234
  if (ldv_state_variable_7 == 1) {
#line 236
    ivtv_g_output(ivtv_ioctl_ops_group3, ldvarg82, ldvarg81);
#line 238
    ldv_state_variable_7 = 1;
  } else {

  }
#line 241
  goto ldv_42841;
  case 3: ;
#line 244
  if (ldv_state_variable_7 == 1) {
#line 246
    ivtv_s_fmt_vbi_cap(ivtv_ioctl_ops_group3, ldvarg80, ivtv_ioctl_ops_group6);
#line 248
    ldv_state_variable_7 = 1;
  } else {

  }
#line 251
  goto ldv_42841;
  case 4: ;
#line 254
  if (ldv_state_variable_7 == 1) {
#line 256
    ivtv_try_fmt_vid_out(ivtv_ioctl_ops_group3, ldvarg79, ivtv_ioctl_ops_group6);
#line 258
    ldv_state_variable_7 = 1;
  } else {

  }
#line 261
  goto ldv_42841;
  case 5: ;
#line 264
  if (ldv_state_variable_7 == 1) {
#line 266
    ivtv_overlay(ivtv_ioctl_ops_group3, ldvarg78, ldvarg77);
#line 268
    ldv_state_variable_7 = 1;
  } else {

  }
#line 271
  goto ldv_42841;
  case 6: ;
#line 274
  if (ldv_state_variable_7 == 1) {
#line 276
    ivtv_try_fmt_vid_cap(ivtv_ioctl_ops_group3, ldvarg76, ivtv_ioctl_ops_group6);
#line 278
    ldv_state_variable_7 = 1;
  } else {

  }
#line 281
  goto ldv_42841;
  case 7: ;
#line 284
  if (ldv_state_variable_7 == 1) {
#line 286
    ivtv_s_tuner(ivtv_ioctl_ops_group3, ldvarg75, (struct v4l2_tuner  const  *)ldvarg74);
#line 288
    ldv_state_variable_7 = 1;
  } else {

  }
#line 291
  goto ldv_42841;
  case 8: ;
#line 294
  if (ldv_state_variable_7 == 1) {
#line 296
    ivtv_try_encoder_cmd(ivtv_ioctl_ops_group3, ldvarg73, ivtv_ioctl_ops_group8);
#line 298
    ldv_state_variable_7 = 1;
  } else {

  }
#line 301
  goto ldv_42841;
  case 9: ;
#line 304
  if (ldv_state_variable_7 == 1) {
#line 306
    ivtv_g_fbuf(ivtv_ioctl_ops_group3, ldvarg72, ldvarg71);
#line 308
    ldv_state_variable_7 = 1;
  } else {

  }
#line 311
  goto ldv_42841;
  case 10: ;
#line 314
  if (ldv_state_variable_7 == 1) {
#line 316
    ivtv_enum_fmt_vid_cap(ivtv_ioctl_ops_group3, ldvarg70, ivtv_ioctl_ops_group0);
#line 318
    ldv_state_variable_7 = 1;
  } else {

  }
#line 321
  goto ldv_42841;
  case 11: ;
#line 324
  if (ldv_state_variable_7 == 1) {
#line 326
    ivtv_encoder_cmd(ivtv_ioctl_ops_group3, ldvarg69, ivtv_ioctl_ops_group8);
#line 328
    ldv_state_variable_7 = 1;
  } else {

  }
#line 331
  goto ldv_42841;
  case 12: ;
#line 334
  if (ldv_state_variable_7 == 1) {
#line 336
    ivtv_s_fmt_vid_cap(ivtv_ioctl_ops_group3, ldvarg68, ivtv_ioctl_ops_group6);
#line 338
    ldv_state_variable_7 = 1;
  } else {

  }
#line 341
  goto ldv_42841;
  case 13: ;
#line 344
  if (ldv_state_variable_7 == 1) {
#line 346
    ivtv_g_fmt_vid_out_overlay(ivtv_ioctl_ops_group3, ldvarg67, ivtv_ioctl_ops_group6);
#line 348
    ldv_state_variable_7 = 1;
  } else {

  }
#line 351
  goto ldv_42841;
  case 14: ;
#line 354
  if (ldv_state_variable_7 == 1) {
#line 356
    ivtv_g_fmt_sliced_vbi_out(ivtv_ioctl_ops_group3, ldvarg66, ivtv_ioctl_ops_group6);
#line 358
    ldv_state_variable_7 = 1;
  } else {

  }
#line 361
  goto ldv_42841;
  case 15: ;
#line 364
  if (ldv_state_variable_7 == 1) {
#line 366
    ivtv_s_audout(ivtv_ioctl_ops_group3, ldvarg65, (struct v4l2_audioout  const  *)ldvarg64);
#line 368
    ldv_state_variable_7 = 1;
  } else {

  }
#line 371
  goto ldv_42841;
  case 16: ;
#line 374
  if (ldv_state_variable_7 == 1) {
#line 376
    ivtv_g_frequency(ivtv_ioctl_ops_group3, ldvarg63, ldvarg62);
#line 378
    ldv_state_variable_7 = 1;
  } else {

  }
#line 381
  goto ldv_42841;
  case 17: ;
#line 384
  if (ldv_state_variable_7 == 1) {
#line 386
    ivtv_g_input(ivtv_ioctl_ops_group3, ldvarg61, ldvarg60);
#line 388
    ldv_state_variable_7 = 1;
  } else {

  }
#line 391
  goto ldv_42841;
  case 18: ;
#line 394
  if (ldv_state_variable_7 == 1) {
#line 396
    ivtv_s_output(ivtv_ioctl_ops_group3, ldvarg59, ldvarg58);
#line 398
    ldv_state_variable_7 = 1;
  } else {

  }
#line 401
  goto ldv_42841;
  case 19: ;
#line 404
  if (ldv_state_variable_7 == 1) {
#line 406
    ivtv_g_audout(ivtv_ioctl_ops_group3, ldvarg57, ivtv_ioctl_ops_group7);
#line 408
    ldv_state_variable_7 = 1;
  } else {

  }
#line 411
  goto ldv_42841;
  case 20: ;
#line 414
  if (ldv_state_variable_7 == 1) {
#line 416
    ivtv_g_register(ivtv_ioctl_ops_group3, ldvarg56, ldvarg55);
#line 418
    ldv_state_variable_7 = 1;
  } else {

  }
#line 421
  goto ldv_42841;
  case 21: ;
#line 424
  if (ldv_state_variable_7 == 1) {
#line 426
    ivtv_enum_fmt_vid_out(ivtv_ioctl_ops_group3, ldvarg54, ivtv_ioctl_ops_group0);
#line 428
    ldv_state_variable_7 = 1;
  } else {

  }
#line 431
  goto ldv_42841;
  case 22: ;
#line 434
  if (ldv_state_variable_7 == 1) {
#line 436
    ivtv_enum_output(ivtv_ioctl_ops_group3, ldvarg53, ldvarg52);
#line 438
    ldv_state_variable_7 = 1;
  } else {

  }
#line 441
  goto ldv_42841;
  case 23: ;
#line 444
  if (ldv_state_variable_7 == 1) {
#line 446
    ivtv_s_fbuf(ivtv_ioctl_ops_group3, ldvarg51, (struct v4l2_framebuffer  const  *)ldvarg50);
#line 448
    ldv_state_variable_7 = 1;
  } else {

  }
#line 451
  goto ldv_42841;
  case 24: ;
#line 454
  if (ldv_state_variable_7 == 1) {
#line 456
    ivtv_enumaudout(ivtv_ioctl_ops_group3, ldvarg49, ivtv_ioctl_ops_group7);
#line 458
    ldv_state_variable_7 = 1;
  } else {

  }
#line 461
  goto ldv_42841;
  case 25: ;
#line 464
  if (ldv_state_variable_7 == 1) {
#line 466
    ivtv_s_input(ivtv_ioctl_ops_group3, ldvarg48, ldvarg47);
#line 468
    ldv_state_variable_7 = 1;
  } else {

  }
#line 471
  goto ldv_42841;
  case 26: ;
#line 474
  if (ldv_state_variable_7 == 1) {
#line 476
    ivtv_g_sliced_vbi_cap(ivtv_ioctl_ops_group3, ldvarg46, ldvarg45);
#line 478
    ldv_state_variable_7 = 1;
  } else {

  }
#line 481
  goto ldv_42841;
  case 27: ;
#line 484
  if (ldv_state_variable_7 == 1) {
#line 486
    ivtv_g_fmt_sliced_vbi_cap(ivtv_ioctl_ops_group3, ldvarg44, ivtv_ioctl_ops_group6);
#line 488
    ldv_state_variable_7 = 1;
  } else {

  }
#line 491
  goto ldv_42841;
  case 28: ;
#line 494
  if (ldv_state_variable_7 == 1) {
#line 496
    ivtv_g_enc_index(ivtv_ioctl_ops_group3, ldvarg43, ldvarg42);
#line 498
    ldv_state_variable_7 = 1;
  } else {

  }
#line 501
  goto ldv_42841;
  case 29: ;
#line 504
  if (ldv_state_variable_7 == 1) {
#line 506
    ivtv_s_register(ivtv_ioctl_ops_group3, ldvarg41, (struct v4l2_dbg_register  const  *)ldvarg40);
#line 508
    ldv_state_variable_7 = 1;
  } else {

  }
#line 511
  goto ldv_42841;
  case 30: ;
#line 514
  if (ldv_state_variable_7 == 1) {
#line 516
    ivtv_enumaudio(ivtv_ioctl_ops_group3, ldvarg39, ivtv_ioctl_ops_group2);
#line 518
    ldv_state_variable_7 = 1;
  } else {

  }
#line 521
  goto ldv_42841;
  case 31: ;
#line 524
  if (ldv_state_variable_7 == 1) {
#line 526
    ivtv_s_selection(ivtv_ioctl_ops_group3, ldvarg38, ivtv_ioctl_ops_group9);
#line 528
    ldv_state_variable_7 = 1;
  } else {

  }
#line 531
  goto ldv_42841;
  case 32: ;
#line 534
  if (ldv_state_variable_7 == 1) {
#line 536
    v4l2_event_unsubscribe(ivtv_ioctl_ops_group4, ivtv_ioctl_ops_group1);
#line 538
    ldv_state_variable_7 = 1;
  } else {

  }
#line 541
  goto ldv_42841;
  case 33: ;
#line 544
  if (ldv_state_variable_7 == 1) {
#line 546
    ivtv_s_fmt_vid_out(ivtv_ioctl_ops_group3, ldvarg37, ivtv_ioctl_ops_group6);
#line 548
    ldv_state_variable_7 = 1;
  } else {

  }
#line 551
  goto ldv_42841;
  case 34: ;
#line 554
  if (ldv_state_variable_7 == 1) {
#line 556
    ivtv_g_tuner(ivtv_ioctl_ops_group3, ldvarg36, ldvarg35);
#line 558
    ldv_state_variable_7 = 1;
  } else {

  }
#line 561
  goto ldv_42841;
  case 35: ;
#line 564
  if (ldv_state_variable_7 == 1) {
#line 566
    ivtv_s_std(ivtv_ioctl_ops_group3, ldvarg34, ldvarg33);
#line 568
    ldv_state_variable_7 = 1;
  } else {

  }
#line 571
  goto ldv_42841;
  case 36: ;
#line 574
  if (ldv_state_variable_7 == 1) {
#line 576
    ivtv_decoder_cmd(ivtv_ioctl_ops_group3, ldvarg32, ivtv_ioctl_ops_group5);
#line 578
    ldv_state_variable_7 = 1;
  } else {

  }
#line 581
  goto ldv_42841;
  case 37: ;
#line 584
  if (ldv_state_variable_7 == 1) {
#line 586
    ivtv_try_fmt_vbi_cap(ivtv_ioctl_ops_group3, ldvarg31, ivtv_ioctl_ops_group6);
#line 588
    ldv_state_variable_7 = 1;
  } else {

  }
#line 591
  goto ldv_42841;
  case 38: ;
#line 594
  if (ldv_state_variable_7 == 1) {
#line 596
    ivtv_log_status(ivtv_ioctl_ops_group3, ldvarg30);
#line 598
    ldv_state_variable_7 = 1;
  } else {

  }
#line 601
  goto ldv_42841;
  case 39: ;
#line 604
  if (ldv_state_variable_7 == 1) {
#line 606
    ivtv_try_decoder_cmd(ivtv_ioctl_ops_group3, ldvarg29, ivtv_ioctl_ops_group5);
#line 608
    ldv_state_variable_7 = 1;
  } else {

  }
#line 611
  goto ldv_42841;
  case 40: ;
#line 614
  if (ldv_state_variable_7 == 1) {
#line 616
    ivtv_s_fmt_sliced_vbi_out(ivtv_ioctl_ops_group3, ldvarg28, ivtv_ioctl_ops_group6);
#line 618
    ldv_state_variable_7 = 1;
  } else {

  }
#line 621
  goto ldv_42841;
  case 41: ;
#line 624
  if (ldv_state_variable_7 == 1) {
#line 626
    ivtv_g_selection(ivtv_ioctl_ops_group3, ldvarg27, ivtv_ioctl_ops_group9);
#line 628
    ldv_state_variable_7 = 1;
  } else {

  }
#line 631
  goto ldv_42841;
  case 42: ;
#line 634
  if (ldv_state_variable_7 == 1) {
#line 636
    ivtv_cropcap(ivtv_ioctl_ops_group3, ldvarg26, ldvarg25);
#line 638
    ldv_state_variable_7 = 1;
  } else {

  }
#line 641
  goto ldv_42841;
  case 43: ;
#line 644
  if (ldv_state_variable_7 == 1) {
#line 646
    ivtv_g_fmt_vid_cap(ivtv_ioctl_ops_group3, ldvarg24, ivtv_ioctl_ops_group6);
#line 648
    ldv_state_variable_7 = 1;
  } else {

  }
#line 651
  goto ldv_42841;
  case 44: ;
#line 654
  if (ldv_state_variable_7 == 1) {
#line 656
    ivtv_s_fmt_sliced_vbi_cap(ivtv_ioctl_ops_group3, ldvarg23, ivtv_ioctl_ops_group6);
#line 658
    ldv_state_variable_7 = 1;
  } else {

  }
#line 661
  goto ldv_42841;
  case 45: ;
#line 664
  if (ldv_state_variable_7 == 1) {
#line 666
    ivtv_g_audio(ivtv_ioctl_ops_group3, ldvarg22, ivtv_ioctl_ops_group2);
#line 668
    ldv_state_variable_7 = 1;
  } else {

  }
#line 671
  goto ldv_42841;
  case 46: ;
#line 674
  if (ldv_state_variable_7 == 1) {
#line 676
    ivtv_s_fmt_vid_out_overlay(ivtv_ioctl_ops_group3, ldvarg21, ivtv_ioctl_ops_group6);
#line 678
    ldv_state_variable_7 = 1;
  } else {

  }
#line 681
  goto ldv_42841;
  case 47: ;
#line 684
  if (ldv_state_variable_7 == 1) {
#line 686
    ivtv_querycap(ivtv_ioctl_ops_group3, ldvarg20, ldvarg19);
#line 688
    ldv_state_variable_7 = 1;
  } else {

  }
#line 691
  goto ldv_42841;
  case 48: ;
#line 694
  if (ldv_state_variable_7 == 1) {
#line 696
    ivtv_s_frequency(ivtv_ioctl_ops_group3, ldvarg18, (struct v4l2_frequency  const  *)ldvarg17);
#line 698
    ldv_state_variable_7 = 1;
  } else {

  }
#line 701
  goto ldv_42841;
  case 49: ;
#line 704
  if (ldv_state_variable_7 == 1) {
#line 706
    ivtv_g_std(ivtv_ioctl_ops_group3, ldvarg16, ldvarg15);
#line 708
    ldv_state_variable_7 = 1;
  } else {

  }
#line 711
  goto ldv_42841;
  case 50: ;
#line 714
  if (ldv_state_variable_7 == 1) {
#line 716
    ivtv_enum_input(ivtv_ioctl_ops_group3, ldvarg14, ldvarg13);
#line 718
    ldv_state_variable_7 = 1;
  } else {

  }
#line 721
  goto ldv_42841;
  case 51: ;
#line 724
  if (ldv_state_variable_7 == 1) {
#line 726
    ivtv_try_fmt_vid_out_overlay(ivtv_ioctl_ops_group3, ldvarg12, ivtv_ioctl_ops_group6);
#line 728
    ldv_state_variable_7 = 1;
  } else {

  }
#line 731
  goto ldv_42841;
  case 52: ;
#line 734
  if (ldv_state_variable_7 == 1) {
#line 736
    ivtv_subscribe_event(ivtv_ioctl_ops_group4, ivtv_ioctl_ops_group1);
#line 738
    ldv_state_variable_7 = 1;
  } else {

  }
#line 741
  goto ldv_42841;
  case 53: ;
#line 744
  if (ldv_state_variable_7 == 1) {
#line 746
    ivtv_default(ivtv_ioctl_ops_group3, ldvarg10, (int )ldvarg9, ldvarg8, ldvarg11);
#line 748
    ldv_state_variable_7 = 1;
  } else {

  }
#line 751
  goto ldv_42841;
  case 54: ;
#line 754
  if (ldv_state_variable_7 == 1) {
#line 756
    ivtv_g_fmt_vbi_cap(ivtv_ioctl_ops_group3, ldvarg7, ivtv_ioctl_ops_group6);
#line 758
    ldv_state_variable_7 = 1;
  } else {

  }
#line 761
  goto ldv_42841;
  case 55: ;
#line 764
  if (ldv_state_variable_7 == 1) {
#line 766
    ivtv_try_fmt_sliced_vbi_out(ivtv_ioctl_ops_group3, ldvarg6, ivtv_ioctl_ops_group6);
#line 768
    ldv_state_variable_7 = 1;
  } else {

  }
#line 771
  goto ldv_42841;
  case 56: ;
#line 774
  if (ldv_state_variable_7 == 1) {
#line 776
    ivtv_s_audio(ivtv_ioctl_ops_group3, ldvarg5, (struct v4l2_audio  const  *)ldvarg4);
#line 778
    ldv_state_variable_7 = 1;
  } else {

  }
#line 781
  goto ldv_42841;
  default: 
#line 782
  ldv_stop();
  }
  ldv_42841: ;
#line 786
  return;
}
}
#line 811 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.o.c.prepared"
bool ldv_queue_work_on_131(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 815
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 815
  ldv_func_res = tmp;
#line 817
  activate_work_2(ldv_func_arg3, 2);
#line 819
  return (ldv_func_res);
}
}
#line 822 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.o.c.prepared"
bool ldv_queue_delayed_work_on_132(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 826
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 826
  ldv_func_res = tmp;
#line 828
  activate_work_2(& ldv_func_arg3->work, 2);
#line 830
  return (ldv_func_res);
}
}
#line 833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.o.c.prepared"
bool ldv_queue_work_on_133(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 837
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 837
  ldv_func_res = tmp;
#line 839
  activate_work_2(ldv_func_arg3, 2);
#line 841
  return (ldv_func_res);
}
}
#line 844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.o.c.prepared"
void ldv_flush_workqueue_134(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 847
  flush_workqueue(ldv_func_arg1);
#line 849
  call_and_disable_all_2(2);
#line 850
  return;
}
}
#line 852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-ioctl.o.c.prepared"
bool ldv_queue_delayed_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 856
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 856
  ldv_func_res = tmp;
#line 858
  activate_work_2(& ldv_func_arg3->work, 2);
#line 860
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 34 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 45
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 370 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 372
  _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
#line 373
  return;
}
}
#line 149 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 169 "include/linux/timer.h"
extern int del_timer(struct timer_list * ) ;
#line 172
int ldv_del_timer_150(struct timer_list *ldv_func_arg1 ) ;
#line 176
int ldv_del_timer_151(struct timer_list *ldv_func_arg1 ) ;
#line 180
int ldv_del_timer_152(struct timer_list *ldv_func_arg1 ) ;
#line 224
extern void add_timer(struct timer_list * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_145(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_147(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_146(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_149(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_148(struct workqueue_struct *ldv_func_arg1 ) ;
#line 215 "./arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void const volatile   *src , size_t count ) 
{ 


  {
#line 217
  memcpy(dst, (void const   *)src, count);
#line 218
  return;
}
}
#line 73 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 75
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 59 "include/linux/dma-debug.h"
extern void debug_dma_sync_single_for_cpu(struct device * , dma_addr_t  , size_t  ,
                                          int  ) ;
#line 63
extern void debug_dma_sync_single_for_device(struct device * , dma_addr_t  , size_t  ,
                                             int  ) ;
#line 30 "./arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops ;
#line 32 "./arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 102 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev , dma_addr_t addr ,
                                             size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 106
  tmp = get_dma_ops(dev);
#line 106
  ops = tmp;
#line 108
  tmp___0 = valid_dma_direction((int )dir);
#line 108
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 108
  if (tmp___1 != 0L) {
#line 108
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (108), "i" (12UL));
    ldv_30285: ;
#line 108
    goto ldv_30285;
  } else {

  }
#line 109
  if ((unsigned long )ops->sync_single_for_cpu != (unsigned long )((void (*)(struct device * ,
                                                                             dma_addr_t  ,
                                                                             size_t  ,
                                                                             enum dma_data_direction  ))0)) {
#line 110
    (*(ops->sync_single_for_cpu))(dev, addr, size, dir);
  } else {

  }
#line 111
  debug_dma_sync_single_for_cpu(dev, addr, size, (int )dir);
#line 112
  return;
}
}
#line 114 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev , dma_addr_t addr ,
                                                size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 118
  tmp = get_dma_ops(dev);
#line 118
  ops = tmp;
#line 120
  tmp___0 = valid_dma_direction((int )dir);
#line 120
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 120
  if (tmp___1 != 0L) {
#line 120
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (120), "i" (12UL));
    ldv_30293: ;
#line 120
    goto ldv_30293;
  } else {

  }
#line 121
  if ((unsigned long )ops->sync_single_for_device != (unsigned long )((void (*)(struct device * ,
                                                                                dma_addr_t  ,
                                                                                size_t  ,
                                                                                enum dma_data_direction  ))0)) {
#line 122
    (*(ops->sync_single_for_device))(dev, addr, size, dir);
  } else {

  }
#line 123
  debug_dma_sync_single_for_device(dev, addr, size, (int )dir);
#line 124
  return;
}
}
#line 79 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_cpu(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                 size_t size , int direction ) 
{ 


  {
#line 82
  dma_sync_single_for_cpu((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                          dma_handle, size, (enum dma_data_direction )direction);
#line 83
  return;
}
}
#line 86 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_device(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                    size_t size , int direction ) 
{ 


  {
#line 89
  dma_sync_single_for_device((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                             dma_handle, size, (enum dma_data_direction )direction);
#line 90
  return;
}
}
#line 126 "include/linux/kthread.h"
extern bool queue_kthread_work(struct kthread_worker * , struct kthread_work * ) ;
#line 35 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-queue.h"
__inline static int ivtv_use_pio(struct ivtv_stream *s ) 
{ 
  struct ivtv *itv ;

  {
#line 37
  itv = s->itv;
#line 39
  return (s->dma == 3);
}
}
#line 48 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-queue.h"
__inline static int ivtv_use_dma(struct ivtv_stream *s ) 
{ 
  int tmp ;

  {
#line 50
  tmp = ivtv_use_pio(s);
#line 50
  return (tmp == 0);
}
}
#line 53 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-queue.h"
__inline static void ivtv_buf_sync_for_cpu(struct ivtv_stream *s , struct ivtv_buffer *buf ) 
{ 
  int tmp ;

  {
#line 55
  tmp = ivtv_use_dma(s);
#line 55
  if (tmp != 0) {
#line 56
    pci_dma_sync_single_for_cpu((s->itv)->pdev, buf->dma_handle, (size_t )(s->buf_size + 256U),
                                s->dma);
  } else {

  }
#line 58
  return;
}
}
#line 60 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-queue.h"
__inline static void ivtv_buf_sync_for_device(struct ivtv_stream *s , struct ivtv_buffer *buf ) 
{ 
  int tmp ;

  {
#line 62
  tmp = ivtv_use_dma(s);
#line 62
  if (tmp != 0) {
#line 63
    pci_dma_sync_single_for_device((s->itv)->pdev, buf->dma_handle, (size_t )(s->buf_size + 256U),
                                   s->dma);
  } else {

  }
#line 65
  return;
}
}
#line 82 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-queue.h"
__inline static void ivtv_stream_sync_for_cpu(struct ivtv_stream *s ) 
{ 
  int tmp ;

  {
#line 84
  tmp = ivtv_use_dma(s);
#line 84
  if (tmp != 0) {
#line 85
    pci_dma_sync_single_for_cpu((s->itv)->pdev, s->sg_handle, 12UL, 1);
  } else {

  }
#line 86
  return;
}
}
#line 89 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-queue.h"
__inline static void ivtv_stream_sync_for_device(struct ivtv_stream *s ) 
{ 
  int tmp ;

  {
#line 91
  tmp = ivtv_use_dma(s);
#line 91
  if (tmp != 0) {
#line 92
    pci_dma_sync_single_for_device((s->itv)->pdev, s->sg_handle, 12UL, 1);
  } else {

  }
#line 93
  return;
}
}
#line 34 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-udma.h"
void ivtv_udma_start(struct ivtv *itv ) ;
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-vbi.h"
void ivtv_vbi_work_handler(struct ivtv *itv ) ;
#line 34 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-yuv.h"
u32 const   yuv_offset[8U] ;
#line 39
void ivtv_yuv_frame_complete(struct ivtv *itv ) ;
#line 42
void ivtv_yuv_work_handler(struct ivtv *itv ) ;
#line 124 "include/media/v4l2-event.h"
extern void v4l2_event_queue(struct video_device * , struct v4l2_event  const  * ) ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_dma_dec_start(struct ivtv_stream *s ) ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static int const   ivtv_stream_map[4U]  = {      0,      1,      3,      2};
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_pcm_work_handler(struct ivtv *itv ) 
{ 
  struct ivtv_stream *s ;
  struct ivtv_buffer *buf ;

  {
#line 43
  s = (struct ivtv_stream *)(& itv->streams) + 3UL;
  ldv_39122: 
#line 55
  buf = ivtv_dequeue(s, & s->q_io);
#line 56
  if ((unsigned long )buf == (unsigned long )((struct ivtv_buffer *)0)) {
#line 57
    buf = ivtv_dequeue(s, & s->q_full);
  } else {

  }
#line 58
  if ((unsigned long )buf == (unsigned long )((struct ivtv_buffer *)0)) {
#line 59
    goto ldv_39121;
  } else {

  }
#line 61
  if (buf->readpos < buf->bytesused) {
#line 62
    (*(itv->pcm_announce_callback))(itv->alsa, (u8 *)buf->buf + (unsigned long )buf->readpos,
                                    (unsigned long )(buf->bytesused - buf->readpos));
  } else {

  }
#line 66
  ivtv_enqueue(s, buf, & s->q_free);
#line 67
  goto ldv_39122;
  ldv_39121: ;
#line 69
  return;
}
}
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_pio_work_handler(struct ivtv *itv ) 
{ 
  struct ivtv_stream *s ;
  struct ivtv_buffer *buf ;
  int i ;
  int tmp ;
  struct list_head  const  *__mptr ;
  u32 size ;
  struct list_head  const  *__mptr___0 ;

  {
#line 72
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )itv->cur_pio_stream;
#line 74
  i = 0;
#line 76
  if ((ivtv_debug & 32) != 0 && (ivtv_debug & 1024) != 0) {
#line 76
    printk("\016%s:  dma: ivtv_pio_work_handler\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 77
  if ((itv->cur_pio_stream < 0 || itv->cur_pio_stream > 8) || (unsigned long )s->vdev.v4l2_dev == (unsigned long )((struct v4l2_device *)0)) {
#line 79
    itv->cur_pio_stream = -1;
#line 81
    writel(33554432U, itv->reg_mem + 68UL);
#line 82
    return;
  } else {
#line 77
    tmp = ivtv_use_pio(s);
#line 77
    if (tmp == 0) {
#line 79
      itv->cur_pio_stream = -1;
#line 81
      writel(33554432U, itv->reg_mem + 68UL);
#line 82
      return;
    } else {

    }
  }
#line 84
  if ((ivtv_debug & 32) != 0 && (ivtv_debug & 1024) != 0) {
#line 84
    printk("\016%s:  dma: Process PIO %s\n", (char *)(& itv->v4l2_dev.name), s->name);
  } else {

  }
#line 85
  __mptr = (struct list_head  const  *)s->q_dma.list.next;
#line 85
  buf = (struct ivtv_buffer *)__mptr;
#line 85
  goto ldv_39136;
  ldv_39135: 
#line 86
  size = (s->sg_processing + (unsigned long )i)->size & 262143U;
#line 89
  if (s->type == 6) {
#line 90
    memcpy_fromio((void *)buf->buf, (void const volatile   *)(itv->dec_mem + ((unsigned long )(s->sg_processing + (unsigned long )i)->src + 0xffffffffff000000UL)),
                  (size_t )size);
  } else {
#line 93
    memcpy_fromio((void *)buf->buf, (void const volatile   *)itv->enc_mem + (unsigned long )(s->sg_processing + (unsigned long )i)->src,
                  (size_t )size);
  }
#line 95
  i = i + 1;
#line 96
  if (s->sg_processing_size == i) {
#line 97
    goto ldv_39134;
  } else {

  }
#line 85
  __mptr___0 = (struct list_head  const  *)buf->list.next;
#line 85
  buf = (struct ivtv_buffer *)__mptr___0;
  ldv_39136: ;
#line 85
  if ((unsigned long )(& buf->list) != (unsigned long )(& s->q_dma.list)) {
#line 87
    goto ldv_39135;
  } else {

  }
  ldv_39134: 
#line 99
  writel(33554432U, itv->reg_mem + 68UL);
#line 100
  return;
}
}
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
void ivtv_irq_work_handler(struct kthread_work *work ) 
{ 
  struct ivtv *itv ;
  struct kthread_work  const  *__mptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 104
  __mptr = (struct kthread_work  const  *)work;
#line 104
  itv = (struct ivtv *)__mptr + 0xffffffffffffa690UL;
#line 106
  tmp = test_and_clear_bit(18L, (unsigned long volatile   *)(& itv->i_flags));
#line 106
  if (tmp != 0) {
#line 107
    ivtv_pio_work_handler(itv);
  } else {

  }
#line 109
  tmp___0 = test_and_clear_bit(16L, (unsigned long volatile   *)(& itv->i_flags));
#line 109
  if (tmp___0 != 0) {
#line 110
    ivtv_vbi_work_handler(itv);
  } else {

  }
#line 112
  tmp___1 = test_and_clear_bit(17L, (unsigned long volatile   *)(& itv->i_flags));
#line 112
  if (tmp___1 != 0) {
#line 113
    ivtv_yuv_work_handler(itv);
  } else {

  }
#line 115
  tmp___2 = test_and_clear_bit(23L, (unsigned long volatile   *)(& itv->i_flags));
#line 115
  if (tmp___2 != 0) {
#line 116
    ivtv_pcm_work_handler(itv);
  } else {

  }
#line 117
  return;
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static int stream_enc_dma_append(struct ivtv_stream *s , u32 *data ) 
{ 
  struct ivtv *itv ;
  struct ivtv_buffer *buf ;
  u32 bytes_needed ;
  u32 offset ;
  u32 size ;
  u32 UVoffset ;
  u32 UVsize ;
  int skip_bufs ;
  int idx ;
  int rc ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___10 ;
  u32 _min1 ;
  u32 _min2 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 125
  itv = s->itv;
#line 127
  bytes_needed = 0U;
#line 129
  UVoffset = 0U;
#line 129
  UVsize = 0U;
#line 130
  skip_bufs = (int )s->q_predma.buffers;
#line 131
  idx = s->sg_pending_size;
#line 135
  if ((unsigned long )s->vdev.v4l2_dev == (unsigned long )((struct v4l2_device *)0)) {
#line 136
    if (ivtv_debug & 1) {
#line 136
      printk("\016%s:  warn: Stream %s not started\n", (char *)(& itv->v4l2_dev.name),
             s->name);
    } else {

    }
#line 137
    return (-1);
  } else {

  }
#line 139
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& s->s_flags));
#line 139
  if (tmp == 0) {
#line 140
    if (ivtv_debug & 1) {
#line 140
      printk("\016%s:  warn: Stream %s not open\n", (char *)(& itv->v4l2_dev.name),
             s->name);
    } else {

    }
#line 141
    return (-1);
  } else {

  }
#line 145
  switch (s->type) {
  case 0: 
#line 147
  offset = *(data + 1UL);
#line 148
  size = *(data + 2UL);
#line 149
  s->pending_pts = 0ULL;
#line 150
  goto ldv_39158;
  case 1: 
#line 153
  offset = *(data + 1UL);
#line 154
  size = *(data + 2UL);
#line 155
  UVoffset = *(data + 3UL);
#line 156
  UVsize = *(data + 4UL);
#line 157
  s->pending_pts = ((unsigned long long )*(data + 5UL) << 32) | (unsigned long long )*(data + 6UL);
#line 158
  goto ldv_39158;
  case 3: 
#line 161
  offset = *(data + 1UL) + 12U;
#line 162
  size = *(data + 2UL) - 12U;
#line 163
  tmp___0 = readl((void const volatile   *)itv->dec_mem + (unsigned long )(offset - 8U));
#line 163
  tmp___1 = readl((void const volatile   *)itv->dec_mem + (unsigned long )(offset - 12U));
#line 163
  s->pending_pts = (unsigned long long )tmp___0 | ((unsigned long long )tmp___1 << 32);
#line 165
  if ((unsigned int )itv->has_cx23415 != 0U) {
#line 166
    offset = offset + 16777216U;
  } else {

  }
#line 167
  goto ldv_39158;
  case 2: 
#line 170
  size = itv->vbi.enc_size * (u32 )itv->vbi.fpi;
#line 171
  tmp___2 = readl((void const volatile   *)itv->enc_mem + (unsigned long )(itv->vbi.enc_start - 4U));
#line 171
  offset = tmp___2 + 12U;
#line 172
  if (offset == 12U) {
#line 173
    if ((ivtv_debug & 2) != 0) {
#line 173
      printk("\016%s:  info: VBI offset == 0\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 174
    return (-1);
  } else {

  }
#line 176
  tmp___3 = readl((void const volatile   *)itv->enc_mem + (unsigned long )(offset - 4U));
#line 176
  tmp___4 = readl((void const volatile   *)itv->enc_mem + (unsigned long )(offset - 8U));
#line 176
  s->pending_pts = (unsigned long long )tmp___3 | ((unsigned long long )tmp___4 << 32);
#line 177
  goto ldv_39158;
  case 6: 
#line 180
  tmp___5 = readl((void const volatile   *)itv->dec_mem + (unsigned long )(itv->vbi.dec_start + 4U));
#line 180
  size = tmp___5 + 8U;
#line 181
  tmp___6 = readl((void const volatile   *)itv->dec_mem + (unsigned long )itv->vbi.dec_start);
#line 181
  offset = tmp___6 + itv->vbi.dec_start;
#line 182
  s->pending_pts = 0ULL;
#line 183
  offset = offset + 16777216U;
#line 184
  goto ldv_39158;
  default: ;
#line 187
  return (-1);
  }
  ldv_39158: ;
#line 191
  if (s->sg_pending_size == 0) {
#line 191
    tmp___7 = ivtv_use_dma(s);
#line 191
    if (tmp___7 != 0) {
#line 192
      if ((unsigned int )itv->has_cx23415 != 0U && (s->type == 3 || s->type == 6)) {
#line 194
        s->pending_backup = readl((void const volatile   *)itv->dec_mem + (unsigned long )(offset - 16777216U));
#line 195
        writel(510U, itv->dec_mem + (unsigned long )(offset - 16777216U));
#line 195
        readl((void const volatile   *)itv->dec_mem + (unsigned long )(offset - 16777216U));
      } else {
#line 198
        s->pending_backup = readl((void const volatile   *)itv->enc_mem + (unsigned long )offset);
#line 199
        writel(510U, itv->enc_mem + (unsigned long )offset);
#line 199
        readl((void const volatile   *)itv->enc_mem + (unsigned long )offset);
      }
#line 201
      s->pending_offset = offset;
    } else {

    }
  } else {

  }
#line 204
  bytes_needed = size;
#line 205
  if (s->type == 1) {
#line 209
    bytes_needed = s->buf_size * (((s->buf_size + bytes_needed) - 1U) / s->buf_size);
#line 210
    bytes_needed = bytes_needed + UVsize;
  } else {

  }
#line 213
  if ((ivtv_debug & 32) != 0 && (ivtv_debug & 1024) != 0) {
#line 213
    tmp___8 = ivtv_use_pio(s);
#line 213
    printk("\016%s:  dma: %s %s: 0x%08x bytes at 0x%08x\n", (char *)(& itv->v4l2_dev.name),
           tmp___8 != 0 ? (char *)"PIO" : (char *)"DMA", s->name, bytes_needed, offset);
  } else {

  }
#line 216
  rc = ivtv_queue_move(s, & s->q_free, & s->q_full, & s->q_predma, (int )bytes_needed);
#line 217
  if (rc < 0) {
#line 218
    if (ivtv_debug & 1) {
#line 218
      printk("\016%s:  warn: Cannot obtain %d bytes for %s data transfer\n", (char *)(& itv->v4l2_dev.name),
             bytes_needed, s->name);
    } else {

    }
#line 220
    return (-1);
  } else {

  }
#line 222
  if (rc != 0 && s->buffers_stolen == 0U) {
#line 222
    tmp___9 = constant_test_bit(8L, (unsigned long const volatile   *)(& s->s_flags));
#line 222
    if (tmp___9 != 0) {
#line 223
      printk("\f%s: All %s stream buffers are full. Dropping data.\n", (char *)(& itv->v4l2_dev.name),
             s->name);
#line 224
      printk("\f%s: Cause: the application is not reading fast enough.\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
  } else {

  }
#line 226
  s->buffers_stolen = (u32 )rc;
#line 229
  __mptr = (struct list_head  const  *)s->q_predma.list.next;
#line 229
  buf = (struct ivtv_buffer *)__mptr;
#line 230
  memset((void *)buf->buf, 0, 128UL);
#line 231
  __mptr___0 = (struct list_head  const  *)s->q_predma.list.next;
#line 231
  buf = (struct ivtv_buffer *)__mptr___0;
#line 231
  goto ldv_39175;
  ldv_39174: 
#line 232
  tmp___10 = skip_bufs;
#line 232
  skip_bufs = skip_bufs - 1;
#line 232
  if (tmp___10 > 0) {
#line 233
    goto ldv_39170;
  } else {

  }
#line 234
  (s->sg_pending + (unsigned long )idx)->dst = (u32 )buf->dma_handle;
#line 235
  (s->sg_pending + (unsigned long )idx)->src = offset;
#line 236
  (s->sg_pending + (unsigned long )idx)->size = s->buf_size;
#line 237
  _min1 = size;
#line 237
  _min2 = s->buf_size;
#line 237
  buf->bytesused = _min1 < _min2 ? _min1 : _min2;
#line 238
  buf->dma_xfer_cnt = s->dma_xfer_cnt;
#line 240
  s->q_predma.bytesused = s->q_predma.bytesused + buf->bytesused;
#line 241
  size = size - buf->bytesused;
#line 242
  offset = s->buf_size + offset;
#line 245
  ivtv_buf_sync_for_device(s, buf);
#line 247
  if (size == 0U) {
#line 249
    offset = UVoffset;
#line 250
    size = UVsize;
  } else {

  }
#line 252
  idx = idx + 1;
  ldv_39170: 
#line 231
  __mptr___1 = (struct list_head  const  *)buf->list.next;
#line 231
  buf = (struct ivtv_buffer *)__mptr___1;
  ldv_39175: ;
#line 231
  if ((unsigned long )(& buf->list) != (unsigned long )(& s->q_predma.list)) {
#line 233
    goto ldv_39174;
  } else {

  }
#line 254
  s->sg_pending_size = idx;
#line 255
  return (0);
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void dma_post(struct ivtv_stream *s ) 
{ 
  struct ivtv *itv ;
  struct ivtv_buffer *buf ;
  struct list_head *p ;
  u32 offset ;
  __le32 *u32buf ;
  int x ;
  int tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 260
  itv = s->itv;
#line 261
  buf = (struct ivtv_buffer *)0;
#line 265
  x = 0;
#line 267
  if ((ivtv_debug & 32) != 0 && (ivtv_debug & 1024) != 0) {
#line 267
    tmp = ivtv_use_pio(s);
#line 267
    printk("\016%s:  dma: %s %s completed (%x)\n", (char *)(& itv->v4l2_dev.name),
           tmp != 0 ? (char *)"PIO" : (char *)"DMA", s->name, s->dma_offset);
  } else {

  }
#line 269
  p = s->q_dma.list.next;
#line 269
  goto ldv_39192;
  ldv_39191: 
#line 270
  __mptr = (struct list_head  const  *)p;
#line 270
  buf = (struct ivtv_buffer *)__mptr;
#line 271
  u32buf = (__le32 *)buf->buf;
#line 274
  ivtv_buf_sync_for_cpu(s, buf);
#line 276
  if (x == 0) {
#line 276
    tmp___0 = ivtv_use_dma(s);
#line 276
    if (tmp___0 != 0) {
#line 277
      offset = s->dma_last_offset;
#line 278
      if (*(u32buf + (unsigned long )(offset / 4U)) != 510U) {
#line 280
        offset = 0U;
#line 280
        goto ldv_39190;
        ldv_39189: ;
#line 281
        if (*(u32buf + (unsigned long )offset) == 510U) {
#line 282
          goto ldv_39188;
        } else {

        }
#line 280
        offset = offset + 1U;
        ldv_39190: ;
#line 280
        if (offset <= 63U) {
#line 282
          goto ldv_39189;
        } else {

        }
        ldv_39188: 
#line 283
        offset = offset * 4U;
#line 284
        if (offset == 256U) {
#line 285
          if (ivtv_debug & 1) {
#line 285
            printk("\016%s:  warn: %s: Couldn\'t find start of buffer within the first 256 bytes\n",
                   (char *)(& itv->v4l2_dev.name), s->name);
          } else {

          }
#line 286
          offset = s->dma_last_offset;
        } else {

        }
#line 288
        if (s->dma_last_offset != offset) {
#line 289
          if (ivtv_debug & 1) {
#line 289
            printk("\016%s:  warn: %s: offset %d -> %d\n", (char *)(& itv->v4l2_dev.name),
                   s->name, s->dma_last_offset, offset);
          } else {

          }
        } else {

        }
#line 290
        s->dma_last_offset = offset;
      } else {

      }
#line 292
      if ((unsigned int )itv->has_cx23415 != 0U && (s->type == 3 || s->type == 6)) {
#line 294
        writel(0U, itv->dec_mem + (unsigned long )(s->dma_offset - 16777216U));
#line 294
        readl((void const volatile   *)itv->dec_mem + (unsigned long )(s->dma_offset - 16777216U));
      } else {
#line 297
        writel(0U, itv->enc_mem + (unsigned long )s->dma_offset);
#line 297
        readl((void const volatile   *)itv->enc_mem + (unsigned long )s->dma_offset);
      }
#line 299
      if (offset != 0U) {
#line 300
        buf->bytesused = buf->bytesused - offset;
#line 301
        memcpy((void *)buf->buf, (void const   *)buf->buf + (unsigned long )offset,
                 (size_t )(buf->bytesused + offset));
      } else {

      }
#line 303
      *u32buf = s->dma_backup;
    } else {

    }
  } else {

  }
#line 305
  x = x + 1;
#line 307
  if (s->type == 0 || s->type == 2) {
#line 309
    buf->b_flags = (unsigned int )buf->b_flags | 1U;
  } else {

  }
#line 269
  p = p->next;
  ldv_39192: ;
#line 269
  if ((unsigned long )(& s->q_dma.list) != (unsigned long )p) {
#line 271
    goto ldv_39191;
  } else {

  }

#line 311
  if ((unsigned long )buf != (unsigned long )((struct ivtv_buffer *)0)) {
#line 312
    buf->bytesused = buf->bytesused + s->dma_last_offset;
  } else {

  }
#line 313
  if ((unsigned long )buf != (unsigned long )((struct ivtv_buffer *)0) && s->type == 6) {
#line 314
    __mptr___0 = (struct list_head  const  *)s->q_dma.list.next;
#line 314
    buf = (struct ivtv_buffer *)__mptr___0;
#line 314
    goto ldv_39199;
    ldv_39198: 
#line 316
    s->q_dma.bytesused = s->q_dma.bytesused - buf->bytesused;
#line 317
    ivtv_process_vbi_data(itv, buf, 0ULL, s->type);
#line 318
    s->q_dma.bytesused = s->q_dma.bytesused + buf->bytesused;
#line 314
    __mptr___1 = (struct list_head  const  *)buf->list.next;
#line 314
    buf = (struct ivtv_buffer *)__mptr___1;
    ldv_39199: ;
#line 314
    if ((unsigned long )(& buf->list) != (unsigned long )(& s->q_dma.list)) {
#line 316
      goto ldv_39198;
    } else {

    }

#line 320
    if ((unsigned long )s->fh == (unsigned long )((struct v4l2_fh *)0)) {
#line 321
      ivtv_queue_move(s, & s->q_dma, (struct ivtv_queue *)0, & s->q_free, 0);
#line 322
      return;
    } else {

    }
  } else {

  }
#line 326
  ivtv_queue_move(s, & s->q_dma, (struct ivtv_queue *)0, & s->q_full, (int )s->q_dma.bytesused);
#line 328
  if (s->type == 3 && (unsigned long )itv->pcm_announce_callback != (unsigned long )((void (*)(struct snd_ivtv_card * ,
                                                                                               u8 * ,
                                                                                               size_t  ))0)) {
#line 341
    set_bit(23L, (unsigned long volatile   *)(& itv->i_flags));
#line 342
    set_bit(15L, (unsigned long volatile   *)(& itv->i_flags));
  } else {

  }
#line 345
  if ((unsigned long )s->fh != (unsigned long )((struct v4l2_fh *)0)) {
#line 346
    __wake_up(& s->waitq, 3U, 1, (void *)0);
  } else {

  }
#line 347
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
void ivtv_dma_stream_dec_prepare(struct ivtv_stream *s , u32 offset , int lock ) 
{ 
  struct ivtv *itv ;
  struct yuv_playback_info *yi ;
  u8 frame ;
  struct yuv_frame_info *f ;
  struct ivtv_buffer *buf ;
  u32 y_size ;
  u32 uv_offset ;
  int y_done ;
  int bytes_written ;
  int idx ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 351
  itv = s->itv;
#line 352
  yi = & itv->yuv_info;
#line 353
  frame = yi->draw_frame;
#line 354
  f = (struct yuv_frame_info *)(& yi->new_frame_info) + (unsigned long )frame;
#line 356
  y_size = ((f->src_h + 31U) & 4294967264U) * 720U;
#line 357
  uv_offset = offset + 414720U;
#line 358
  y_done = 0;
#line 359
  bytes_written = 0;
#line 360
  idx = 0;
#line 362
  if ((ivtv_debug & 32) != 0 && (ivtv_debug & 1024) != 0) {
#line 362
    printk("\016%s:  dma: DEC PREPARE DMA %s: %08x %08x\n", (char *)(& itv->v4l2_dev.name),
           s->name, s->q_predma.bytesused, offset);
  } else {

  }
#line 365
  if (s->type == 8 && f->offset_y != 0U) {
#line 366
    if (yi->blanking_dmaptr != 0ULL) {
#line 367
      (s->sg_pending + (unsigned long )idx)->src = (u32 )yi->blanking_dmaptr;
#line 368
      (s->sg_pending + (unsigned long )idx)->dst = offset;
#line 369
      (s->sg_pending + (unsigned long )idx)->size = 11520U;
    } else {

    }
#line 371
    offset = offset + 11520U;
#line 372
    idx = idx + 1;
  } else {

  }
#line 375
  __mptr = (struct list_head  const  *)s->q_predma.list.next;
#line 375
  buf = (struct ivtv_buffer *)__mptr;
#line 375
  goto ldv_39221;
  ldv_39220: ;
#line 377
  if ((s->type == 8 && y_done == 0) && buf->bytesused + (u32 )bytes_written >= y_size) {
#line 379
    (s->sg_pending + (unsigned long )idx)->src = (u32 )buf->dma_handle;
#line 380
    (s->sg_pending + (unsigned long )idx)->dst = offset;
#line 381
    (s->sg_pending + (unsigned long )idx)->size = y_size - (u32 )bytes_written;
#line 382
    offset = uv_offset;
#line 383
    if ((s->sg_pending + (unsigned long )idx)->size != buf->bytesused) {
#line 384
      idx = idx + 1;
#line 385
      (s->sg_pending + (unsigned long )idx)->src = (u32 )buf->dma_handle + (s->sg_pending + ((unsigned long )idx + 0xffffffffffffffffUL))->size;
#line 387
      (s->sg_pending + (unsigned long )idx)->dst = offset;
#line 388
      (s->sg_pending + (unsigned long )idx)->size = buf->bytesused - (s->sg_pending + ((unsigned long )idx + 0xffffffffffffffffUL))->size;
#line 390
      offset = (s->sg_pending + (unsigned long )idx)->size + offset;
    } else {

    }
#line 392
    y_done = 1;
  } else {
#line 394
    (s->sg_pending + (unsigned long )idx)->src = (u32 )buf->dma_handle;
#line 395
    (s->sg_pending + (unsigned long )idx)->dst = offset;
#line 396
    (s->sg_pending + (unsigned long )idx)->size = buf->bytesused;
#line 397
    offset = buf->bytesused + offset;
  }
#line 399
  bytes_written = (int )(buf->bytesused + (u32 )bytes_written);
#line 402
  ivtv_buf_sync_for_device(s, buf);
#line 403
  idx = idx + 1;
#line 375
  __mptr___0 = (struct list_head  const  *)buf->list.next;
#line 375
  buf = (struct ivtv_buffer *)__mptr___0;
  ldv_39221: ;
#line 375
  if ((unsigned long )(& buf->list) != (unsigned long )(& s->q_predma.list)) {
#line 377
    goto ldv_39220;
  } else {

  }
#line 405
  s->sg_pending_size = idx;
#line 408
  ivtv_stream_sync_for_device(s);
#line 409
  if (lock != 0) {
#line 410
    flags = 0UL;
#line 412
    tmp = spinlock_check(& itv->dma_reg_lock);
#line 412
    flags = _raw_spin_lock_irqsave(tmp);
#line 413
    tmp___0 = constant_test_bit(0L, (unsigned long const volatile   *)(& itv->i_flags));
#line 413
    if (tmp___0 == 0) {
#line 414
      ivtv_dma_dec_start(s);
    } else {
#line 416
      set_bit(0L, (unsigned long volatile   *)(& s->s_flags));
    }
#line 417
    spin_unlock_irqrestore(& itv->dma_reg_lock, flags);
  } else {
#line 419
    tmp___1 = constant_test_bit(0L, (unsigned long const volatile   *)(& itv->i_flags));
#line 419
    if (tmp___1 == 0) {
#line 420
      ivtv_dma_dec_start(s);
    } else {
#line 422
      set_bit(0L, (unsigned long volatile   *)(& s->s_flags));
    }
  }
#line 423
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_dma_enc_start_xfer(struct ivtv_stream *s ) 
{ 
  struct ivtv *itv ;
  unsigned int tmp ;
  unsigned long tmp___0 ;

  {
#line 428
  itv = s->itv;
#line 430
  (s->sg_dma)->src = (s->sg_processing + (unsigned long )s->sg_processed)->src;
#line 431
  (s->sg_dma)->dst = (s->sg_processing + (unsigned long )s->sg_processed)->dst;
#line 432
  (s->sg_dma)->size = (s->sg_processing + (unsigned long )s->sg_processed)->size | 2147483648U;
#line 433
  s->sg_processed = s->sg_processed + 1;
#line 435
  ivtv_stream_sync_for_device(s);
#line 436
  writel((unsigned int )s->sg_handle, itv->reg_mem + 12UL);
#line 437
  tmp = readl((void const volatile   *)itv->reg_mem);
#line 437
  writel(tmp | 2U, itv->reg_mem);
#line 437
  readl((void const volatile   *)itv->reg_mem);
#line 438
  tmp___0 = msecs_to_jiffies(300U);
#line 438
  itv->dma_timer.expires = tmp___0 + (unsigned long )jiffies;
#line 439
  add_timer(& itv->dma_timer);
#line 440
  return;
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_dma_dec_start_xfer(struct ivtv_stream *s ) 
{ 
  struct ivtv *itv ;
  unsigned int tmp ;
  unsigned long tmp___0 ;

  {
#line 444
  itv = s->itv;
#line 446
  (s->sg_dma)->src = (s->sg_processing + (unsigned long )s->sg_processed)->src;
#line 447
  (s->sg_dma)->dst = (s->sg_processing + (unsigned long )s->sg_processed)->dst;
#line 448
  (s->sg_dma)->size = (s->sg_processing + (unsigned long )s->sg_processed)->size | 2147483648U;
#line 449
  s->sg_processed = s->sg_processed + 1;
#line 451
  ivtv_stream_sync_for_device(s);
#line 452
  writel((unsigned int )s->sg_handle, itv->reg_mem + 8UL);
#line 453
  tmp = readl((void const volatile   *)itv->reg_mem);
#line 453
  writel(tmp | 1U, itv->reg_mem);
#line 453
  readl((void const volatile   *)itv->reg_mem);
#line 454
  tmp___0 = msecs_to_jiffies(300U);
#line 454
  itv->dma_timer.expires = tmp___0 + (unsigned long )jiffies;
#line 455
  add_timer(& itv->dma_timer);
#line 456
  return;
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_dma_enc_start(struct ivtv_stream *s ) 
{ 
  struct ivtv *itv ;
  struct ivtv_stream *s_vbi ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 461
  itv = s->itv;
#line 462
  s_vbi = (struct ivtv_stream *)(& itv->streams) + 2UL;
#line 465
  if ((ivtv_debug & 32) != 0 && (ivtv_debug & 1024) != 0) {
#line 465
    tmp = ivtv_use_dma(s);
#line 465
    printk("\016%s:  dma: start %s for %s\n", (char *)(& itv->v4l2_dev.name), tmp != 0 ? (char *)"DMA" : (char *)"PIO",
           s->name);
  } else {

  }
#line 467
  if (s->q_predma.bytesused != 0U) {
#line 468
    ivtv_queue_move(s, & s->q_predma, (struct ivtv_queue *)0, & s->q_dma, (int )s->q_predma.bytesused);
  } else {

  }
#line 470
  tmp___0 = ivtv_use_dma(s);
#line 470
  if (tmp___0 != 0) {
#line 471
    (s->sg_pending + ((unsigned long )s->sg_pending_size + 0xffffffffffffffffUL))->size = (s->sg_pending + ((unsigned long )s->sg_pending_size + 0xffffffffffffffffUL))->size + 256U;
  } else {

  }
#line 481
  clear_bit(1L, (unsigned long volatile   *)(& s->s_flags));
#line 482
  if ((s->type == 0 && s_vbi->sg_pending_size != 0) && (u32 )(s->sg_pending_size + s_vbi->sg_pending_size) <= s->buffers) {
#line 484
    ivtv_queue_move(s_vbi, & s_vbi->q_predma, (struct ivtv_queue *)0, & s_vbi->q_dma,
                    (int )s_vbi->q_predma.bytesused);
#line 485
    tmp___1 = ivtv_use_dma(s_vbi);
#line 485
    if (tmp___1 != 0) {
#line 486
      (s_vbi->sg_pending + ((unsigned long )s_vbi->sg_pending_size + 0xffffffffffffffffUL))->size = (s_vbi->sg_pending + ((unsigned long )s_vbi->sg_pending_size + 0xffffffffffffffffUL))->size + 256U;
    } else {

    }
#line 487
    i = 0;
#line 487
    goto ldv_39242;
    ldv_39241: 
#line 488
    tmp___2 = s->sg_pending_size;
#line 488
    s->sg_pending_size = s->sg_pending_size + 1;
#line 488
    *(s->sg_pending + (unsigned long )tmp___2) = *(s_vbi->sg_pending + (unsigned long )i);
#line 487
    i = i + 1;
    ldv_39242: ;
#line 487
    if (s_vbi->sg_pending_size > i) {
#line 489
      goto ldv_39241;
    } else {

    }
#line 490
    s_vbi->dma_offset = s_vbi->pending_offset;
#line 491
    s_vbi->sg_pending_size = 0;
#line 492
    s_vbi->dma_xfer_cnt = (u16 )((int )s_vbi->dma_xfer_cnt + 1);
#line 493
    set_bit(1L, (unsigned long volatile   *)(& s->s_flags));
#line 494
    if ((ivtv_debug & 32) != 0 && (ivtv_debug & 1024) != 0) {
#line 494
      printk("\016%s:  dma: include DMA for %s\n", (char *)(& itv->v4l2_dev.name),
             s_vbi->name);
    } else {

    }
  } else {

  }
#line 497
  s->dma_xfer_cnt = (u16 )((int )s->dma_xfer_cnt + 1);
#line 498
  memcpy((void *)s->sg_processing, (void const   *)s->sg_pending, (unsigned long )s->sg_pending_size * 12UL);
#line 499
  s->sg_processing_size = s->sg_pending_size;
#line 500
  s->sg_pending_size = 0;
#line 501
  s->sg_processed = 0;
#line 502
  s->dma_offset = s->pending_offset;
#line 503
  s->dma_backup = s->pending_backup;
#line 504
  s->dma_pts = s->pending_pts;
#line 506
  tmp___3 = ivtv_use_pio(s);
#line 506
  if (tmp___3 != 0) {
#line 507
    set_bit(18L, (unsigned long volatile   *)(& itv->i_flags));
#line 508
    set_bit(15L, (unsigned long volatile   *)(& itv->i_flags));
#line 509
    set_bit(19L, (unsigned long volatile   *)(& itv->i_flags));
#line 510
    itv->cur_pio_stream = s->type;
  } else {
#line 513
    itv->dma_retries = 0;
#line 514
    ivtv_dma_enc_start_xfer(s);
#line 515
    set_bit(0L, (unsigned long volatile   *)(& itv->i_flags));
#line 516
    itv->cur_dma_stream = s->type;
  }
#line 518
  return;
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_dma_dec_start(struct ivtv_stream *s ) 
{ 
  struct ivtv *itv ;

  {
#line 522
  itv = s->itv;
#line 524
  if (s->q_predma.bytesused != 0U) {
#line 525
    ivtv_queue_move(s, & s->q_predma, (struct ivtv_queue *)0, & s->q_dma, (int )s->q_predma.bytesused);
  } else {

  }
#line 526
  s->dma_xfer_cnt = (u16 )((int )s->dma_xfer_cnt + 1);
#line 527
  memcpy((void *)s->sg_processing, (void const   *)s->sg_pending, (unsigned long )s->sg_pending_size * 12UL);
#line 528
  s->sg_processing_size = s->sg_pending_size;
#line 529
  s->sg_pending_size = 0;
#line 530
  s->sg_processed = 0;
#line 532
  if ((ivtv_debug & 32) != 0 && (ivtv_debug & 1024) != 0) {
#line 532
    printk("\016%s:  dma: start DMA for %s\n", (char *)(& itv->v4l2_dev.name), s->name);
  } else {

  }
#line 533
  itv->dma_retries = 0;
#line 534
  ivtv_dma_dec_start_xfer(s);
#line 535
  set_bit(0L, (unsigned long volatile   *)(& itv->i_flags));
#line 536
  itv->cur_dma_stream = s->type;
#line 537
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_irq_dma_read(struct ivtv *itv ) 
{ 
  struct ivtv_stream *s ;
  struct ivtv_buffer *buf ;
  int hw_stream_type ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 541
  s = (struct ivtv_stream *)0;
#line 543
  hw_stream_type = 0;
#line 545
  if ((ivtv_debug & 64) != 0 && (ivtv_debug & 1024) != 0) {
#line 545
    printk("\016%s:  irq: DEC DMA READ\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 547
  ldv_del_timer_150(& itv->dma_timer);
#line 549
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& itv->i_flags));
#line 549
  if (tmp == 0 && itv->cur_dma_stream < 0) {
#line 550
    return;
  } else {

  }
#line 552
  tmp___3 = constant_test_bit(1L, (unsigned long const volatile   *)(& itv->i_flags));
#line 552
  if (tmp___3 == 0) {
#line 553
    s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )itv->cur_dma_stream;
#line 554
    ivtv_stream_sync_for_cpu(s);
#line 556
    tmp___2 = readl((void const volatile   *)itv->reg_mem + 4U);
#line 556
    if ((tmp___2 & 20U) != 0U) {
#line 557
      if (ivtv_debug & 1) {
#line 557
        tmp___0 = readl((void const volatile   *)itv->reg_mem + 4U);
#line 557
        printk("\016%s:  warn: DEC DMA OLD_ERROR %x (xfer %d of %d, retry %d)\n", (char *)(& itv->v4l2_dev.name),
               tmp___0, s->sg_processed, s->sg_processing_size, itv->dma_retries);
      } else {

      }
#line 560
      tmp___1 = readl((void const volatile   *)itv->reg_mem + 4U);
#line 560
      writel(tmp___1 & 3U, itv->reg_mem + 4UL);
#line 561
      if (itv->dma_retries == 3) {
#line 563
        itv->dma_retries = 0;
#line 564
        s->sg_processed = s->sg_processing_size;
      } else {
#line 569
        s->sg_processed = 0;
#line 570
        itv->dma_retries = itv->dma_retries + 1;
      }
    } else {

    }
#line 573
    if (s->sg_processed < s->sg_processing_size) {
#line 575
      ivtv_dma_dec_start_xfer(s);
#line 576
      return;
    } else {

    }
#line 578
    if (s->type == 8) {
#line 579
      hw_stream_type = 2;
    } else {

    }
#line 580
    if ((ivtv_debug & 32) != 0 && (ivtv_debug & 1024) != 0) {
#line 580
      printk("\016%s:  dma: DEC DATA READ %s: %d\n", (char *)(& itv->v4l2_dev.name),
             s->name, s->q_dma.bytesused);
    } else {

    }
#line 588
    ivtv_vapi(itv, 11, 3, 0, s->q_dma.bytesused, hw_stream_type);
#line 592
    goto ldv_39255;
    ldv_39254: 
#line 593
    ivtv_buf_sync_for_cpu(s, buf);
#line 594
    ivtv_enqueue(s, buf, & s->q_free);
    ldv_39255: 
#line 592
    buf = ivtv_dequeue(s, & s->q_dma);
#line 592
    if ((unsigned long )buf != (unsigned long )((struct ivtv_buffer *)0)) {
#line 594
      goto ldv_39254;
    } else {

    }
#line 596
    __wake_up(& s->waitq, 3U, 1, (void *)0);
  } else {

  }
#line 598
  clear_bit(1L, (unsigned long volatile   *)(& itv->i_flags));
#line 599
  clear_bit(0L, (unsigned long volatile   *)(& itv->i_flags));
#line 600
  itv->cur_dma_stream = -1;
#line 601
  __wake_up(& itv->dma_waitq, 3U, 1, (void *)0);
#line 602
  return;
}
}
#line 604 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_irq_enc_dma_complete(struct ivtv *itv ) 
{ 
  u32 data[16U] ;
  struct ivtv_stream *s ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 609
  ivtv_api_get_data(& itv->enc_mbox, 8, 2, (u32 *)(& data));
#line 610
  if ((ivtv_debug & 64) != 0 && (ivtv_debug & 1024) != 0) {
#line 610
    printk("\016%s:  irq: ENC DMA COMPLETE %x %d (%d)\n", (char *)(& itv->v4l2_dev.name),
           data[0], data[1], itv->cur_dma_stream);
  } else {

  }
#line 612
  ldv_del_timer_151(& itv->dma_timer);
#line 614
  if (itv->cur_dma_stream < 0) {
#line 615
    return;
  } else {

  }
#line 617
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )itv->cur_dma_stream;
#line 618
  ivtv_stream_sync_for_cpu(s);
#line 620
  if ((data[0] & 24U) != 0U) {
#line 621
    if (ivtv_debug & 1) {
#line 621
      printk("\016%s:  warn: ENC DMA OLD_ERROR %x (offset %08x, xfer %d of %d, retry %d)\n",
             (char *)(& itv->v4l2_dev.name), data[0], s->dma_offset, s->sg_processed,
             s->sg_processing_size, itv->dma_retries);
    } else {

    }
#line 623
    tmp = readl((void const volatile   *)itv->reg_mem + 4U);
#line 623
    writel(tmp & 3U, itv->reg_mem + 4UL);
#line 624
    if (itv->dma_retries == 3) {
#line 626
      itv->dma_retries = 0;
#line 627
      s->sg_processed = s->sg_processing_size;
    } else {
#line 632
      s->sg_processed = 0;
#line 633
      itv->dma_retries = itv->dma_retries + 1;
    }
  } else {

  }
#line 636
  if (s->sg_processed < s->sg_processing_size) {
#line 638
    ivtv_dma_enc_start_xfer(s);
#line 639
    return;
  } else {

  }
#line 641
  clear_bit(0L, (unsigned long volatile   *)(& itv->i_flags));
#line 642
  itv->cur_dma_stream = -1;
#line 643
  dma_post(s);
#line 644
  tmp___0 = test_and_clear_bit(1L, (unsigned long volatile   *)(& s->s_flags));
#line 644
  if (tmp___0 != 0) {
#line 645
    s = (struct ivtv_stream *)(& itv->streams) + 2UL;
#line 646
    dma_post(s);
  } else {

  }
#line 648
  s->sg_processing_size = 0;
#line 649
  s->sg_processed = 0;
#line 650
  __wake_up(& itv->dma_waitq, 3U, 1, (void *)0);
#line 651
  return;
}
}
#line 653 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_irq_enc_pio_complete(struct ivtv *itv ) 
{ 
  struct ivtv_stream *s ;
  int tmp ;

  {
#line 657
  if (itv->cur_pio_stream < 0 || itv->cur_pio_stream > 8) {
#line 658
    itv->cur_pio_stream = -1;
#line 659
    return;
  } else {

  }
#line 661
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )itv->cur_pio_stream;
#line 662
  if ((ivtv_debug & 64) != 0 && (ivtv_debug & 1024) != 0) {
#line 662
    printk("\016%s:  irq: ENC PIO COMPLETE %s\n", (char *)(& itv->v4l2_dev.name),
           s->name);
  } else {

  }
#line 663
  clear_bit(19L, (unsigned long volatile   *)(& itv->i_flags));
#line 664
  itv->cur_pio_stream = -1;
#line 665
  dma_post(s);
#line 666
  if (s->type == 0) {
#line 667
    ivtv_vapi(itv, 204, 3, 0, 0, 0);
  } else
#line 668
  if (s->type == 1) {
#line 669
    ivtv_vapi(itv, 204, 3, 0, 0, 1);
  } else
#line 670
  if (s->type == 3) {
#line 671
    ivtv_vapi(itv, 204, 3, 0, 0, 2);
  } else {

  }
#line 672
  clear_bit(19L, (unsigned long volatile   *)(& itv->i_flags));
#line 673
  tmp = test_and_clear_bit(1L, (unsigned long volatile   *)(& s->s_flags));
#line 673
  if (tmp != 0) {
#line 674
    s = (struct ivtv_stream *)(& itv->streams) + 2UL;
#line 675
    dma_post(s);
  } else {

  }
#line 677
  __wake_up(& itv->dma_waitq, 3U, 1, (void *)0);
#line 678
  return;
}
}
#line 680 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_irq_dma_err(struct ivtv *itv ) 
{ 
  u32 data[16U] ;
  u32 status ;
  struct ivtv_stream *s ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 685
  ldv_del_timer_152(& itv->dma_timer);
#line 687
  ivtv_api_get_data(& itv->enc_mbox, 8, 2, (u32 *)(& data));
#line 688
  status = readl((void const volatile   *)itv->reg_mem + 4U);
#line 689
  if (ivtv_debug & 1) {
#line 689
    printk("\016%s:  warn: DMA OLD_ERROR %08x %08x %08x %d\n", (char *)(& itv->v4l2_dev.name),
           data[0], data[1], status, itv->cur_dma_stream);
  } else {

  }
#line 700
  status = status & 3U;
#line 701
  if (status == 3U) {
#line 702
    writel(status, itv->reg_mem + 4UL);
  } else {

  }
#line 704
  tmp___0 = constant_test_bit(1L, (unsigned long const volatile   *)(& itv->i_flags));
#line 704
  if ((tmp___0 == 0 && itv->cur_dma_stream >= 0) && itv->cur_dma_stream <= 8) {
#line 706
    s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )itv->cur_dma_stream;
#line 708
    if (s->type > 4) {
#line 714
      ivtv_dma_dec_start(s);
#line 715
      return;
    } else {
#line 717
      if ((status & 2U) == 0U) {
#line 722
        tmp = msecs_to_jiffies(600U);
#line 722
        itv->dma_timer.expires = tmp + (unsigned long )jiffies;
#line 724
        add_timer(& itv->dma_timer);
#line 725
        return;
      } else {

      }
#line 728
      if (itv->dma_retries <= 2) {
#line 735
        s->sg_processed = 0;
#line 736
        itv->dma_retries = itv->dma_retries + 1;
#line 737
        ivtv_dma_enc_start_xfer(s);
#line 738
        return;
      } else {

      }
    }
  } else {

  }
#line 744
  tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& itv->i_flags));
#line 744
  if (tmp___1 != 0) {
#line 745
    ivtv_udma_start(itv);
#line 746
    return;
  } else {

  }
#line 748
  clear_bit(1L, (unsigned long volatile   *)(& itv->i_flags));
#line 749
  clear_bit(0L, (unsigned long volatile   *)(& itv->i_flags));
#line 750
  itv->cur_dma_stream = -1;
#line 751
  __wake_up(& itv->dma_waitq, 3U, 1, (void *)0);
#line 752
  return;
}
}
#line 754 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_irq_enc_start_cap(struct ivtv *itv ) 
{ 
  u32 data[16U] ;
  struct ivtv_stream *s ;
  int tmp ;
  int tmp___0 ;

  {
#line 760
  ivtv_api_get_data(& itv->enc_mbox, 9, 7, (u32 *)(& data));
#line 761
  if ((ivtv_debug & 64) != 0 && (ivtv_debug & 1024) != 0) {
#line 761
    printk("\016%s:  irq: ENC START CAP %d: %08x %08x\n", (char *)(& itv->v4l2_dev.name),
           data[0], data[1], data[2]);
  } else {

  }
#line 763
  if ((data[0] > 2U || data[1] == 0U) || data[2] == 0U) {
#line 764
    if (ivtv_debug & 1) {
#line 764
      printk("\016%s:  warn: Unknown input: %08x %08x %08x\n", (char *)(& itv->v4l2_dev.name),
             data[0], data[1], data[2]);
    } else {

    }
#line 766
    return;
  } else {

  }
#line 768
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )ivtv_stream_map[data[0]];
#line 769
  tmp___0 = stream_enc_dma_append(s, (u32 *)(& data));
#line 769
  if (tmp___0 == 0) {
#line 770
    tmp = ivtv_use_pio(s);
#line 770
    set_bit(tmp != 0 ? 9L : 0L, (unsigned long volatile   *)(& s->s_flags));
  } else {

  }
#line 771
  return;
}
}
#line 774 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_irq_enc_vbi_cap(struct ivtv *itv ) 
{ 
  u32 data[16U] ;
  struct ivtv_stream *s ;
  int tmp ;
  int tmp___0 ;

  {
#line 779
  if ((ivtv_debug & 64) != 0 && (ivtv_debug & 1024) != 0) {
#line 779
    printk("\016%s:  irq: ENC START VBI CAP\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 780
  s = (struct ivtv_stream *)(& itv->streams) + 2UL;
#line 782
  tmp___0 = stream_enc_dma_append(s, (u32 *)(& data));
#line 782
  if (tmp___0 == 0) {
#line 783
    tmp = ivtv_use_pio(s);
#line 783
    set_bit(tmp != 0 ? 9L : 0L, (unsigned long volatile   *)(& s->s_flags));
  } else {

  }
#line 784
  return;
}
}
#line 786 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_irq_dec_vbi_reinsert(struct ivtv *itv ) 
{ 
  u32 data[16U] ;
  struct ivtv_stream *s ;
  int tmp ;
  int tmp___0 ;

  {
#line 789
  s = (struct ivtv_stream *)(& itv->streams) + 6UL;
#line 791
  if ((ivtv_debug & 64) != 0 && (ivtv_debug & 1024) != 0) {
#line 791
    printk("\016%s:  irq: DEC VBI REINSERT\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 792
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& s->s_flags));
#line 792
  if (tmp != 0) {
#line 792
    tmp___0 = stream_enc_dma_append(s, (u32 *)(& data));
#line 792
    if (tmp___0 == 0) {
#line 794
      set_bit(9L, (unsigned long volatile   *)(& s->s_flags));
    } else {

    }
  } else {

  }
#line 795
  return;
}
}
#line 798 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_irq_dec_data_req(struct ivtv *itv ) 
{ 
  u32 data[16U] ;
  struct ivtv_stream *s ;
  int tmp ;
  u32 __min1 ;
  u32 __min2 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 805
  tmp___0 = constant_test_bit(7L, (unsigned long const volatile   *)(& itv->i_flags));
#line 805
  if (tmp___0 != 0) {
#line 806
    ivtv_api_get_data(& itv->dec_mbox, 9, 2, (u32 *)(& data));
#line 807
    itv->dma_data_req_size = ((itv->yuv_info.v4l2_src_h + 31U) & 4294967264U) * 1080U;
#line 809
    itv->dma_data_req_offset = data[1];
#line 810
    tmp = atomic_read((atomic_t const   *)(& itv->yuv_info.next_dma_frame));
#line 810
    if (tmp >= 0) {
#line 811
      ivtv_yuv_frame_complete(itv);
    } else {

    }
#line 812
    s = (struct ivtv_stream *)(& itv->streams) + 8UL;
  } else {
#line 815
    ivtv_api_get_data(& itv->dec_mbox, 9, 3, (u32 *)(& data));
#line 816
    __min1 = data[2];
#line 816
    __min2 = 65536U;
#line 816
    itv->dma_data_req_size = __min1 < __min2 ? __min1 : __min2;
#line 817
    itv->dma_data_req_offset = data[1];
#line 818
    s = (struct ivtv_stream *)(& itv->streams) + 5UL;
  }
#line 820
  if ((ivtv_debug & 64) != 0 && (ivtv_debug & 1024) != 0) {
#line 820
    printk("\016%s:  irq: DEC DATA REQ %s: %d %08x %u\n", (char *)(& itv->v4l2_dev.name),
           s->name, s->q_full.bytesused, itv->dma_data_req_offset, itv->dma_data_req_size);
  } else {

  }
#line 822
  if (itv->dma_data_req_size == 0U || s->q_full.bytesused < itv->dma_data_req_size) {
#line 823
    set_bit(2L, (unsigned long volatile   *)(& s->s_flags));
  } else {
#line 826
    tmp___1 = constant_test_bit(7L, (unsigned long const volatile   *)(& itv->i_flags));
#line 826
    if (tmp___1 != 0) {
#line 827
      ivtv_yuv_setup_stream_frame(itv);
    } else {

    }
#line 828
    clear_bit(2L, (unsigned long volatile   *)(& s->s_flags));
#line 829
    ivtv_queue_move(s, & s->q_full, (struct ivtv_queue *)0, & s->q_predma, (int )itv->dma_data_req_size);
#line 830
    ivtv_dma_stream_dec_prepare(s, itv->dma_data_req_offset + 16777216U, 0);
  }
#line 832
  return;
}
}
#line 834 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
static void ivtv_irq_vsync(struct ivtv *itv ) 
{ 
  unsigned int frame ;
  unsigned int tmp ;
  struct yuv_playback_info *yi ;
  int last_dma_frame ;
  int tmp___0 ;
  struct yuv_frame_info *f ;
  int next_dma_frame ;
  int tmp___1 ;
  struct v4l2_event evtop ;
  struct v4l2_event evbottom ;
  struct ivtv_stream *s ;
  struct ivtv_stream *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 843
  tmp = readl((void const volatile   *)itv->reg_mem + 10432U);
#line 843
  frame = tmp & 1U;
#line 844
  yi = & itv->yuv_info;
#line 845
  tmp___0 = atomic_read((atomic_t const   *)(& yi->next_dma_frame));
#line 845
  last_dma_frame = tmp___0;
#line 846
  f = (struct yuv_frame_info *)(& yi->new_frame_info) + (unsigned long )last_dma_frame;
#line 850
  if ((f->sync_field == frame && (itv->last_vsync_field & 1U) != f->sync_field) || ((itv->last_vsync_field & 1U) != frame && f->interlaced == 0U)) {
#line 853
    next_dma_frame = last_dma_frame;
#line 855
    if ((f->interlaced == 0U || f->delay == 0U) || (unsigned int )yi->fields_lapsed != 0U) {
#line 856
      if (next_dma_frame >= 0) {
#line 856
        tmp___1 = atomic_read((atomic_t const   *)(& yi->next_fill_frame));
#line 856
        if (tmp___1 != next_dma_frame) {
#line 857
          writel(yuv_offset[next_dma_frame] >> 4, itv->reg_mem + 2092UL);
#line 858
          writel(((unsigned int )yuv_offset[next_dma_frame] + 414720U) >> 4, itv->reg_mem + 2096UL);
#line 859
          writel(yuv_offset[next_dma_frame] >> 4, itv->reg_mem + 2100UL);
#line 860
          writel(((unsigned int )yuv_offset[next_dma_frame] + 414720U) >> 4, itv->reg_mem + 2104UL);
#line 861
          next_dma_frame = (next_dma_frame + 1) % 8;
#line 862
          atomic_set(& yi->next_dma_frame, next_dma_frame);
#line 863
          yi->fields_lapsed = 255U;
#line 864
          yi->running = 1U;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 868
  if ((itv->last_vsync_field & 1U) != frame) {
#line 869
    evtop.type = 1U;
#line 869
    evtop.u.vsync.field = 2U;
#line 869
    evtop.pending = 0U;
#line 869
    evtop.sequence = 0U;
#line 869
    evtop.timestamp.tv_sec = 0L;
#line 869
    evtop.timestamp.tv_nsec = 0L;
#line 869
    evtop.id = 0U;
#line 869
    evtop.reserved[0] = 0U;
#line 869
    evtop.reserved[1] = 0U;
#line 869
    evtop.reserved[2] = 0U;
#line 869
    evtop.reserved[3] = 0U;
#line 869
    evtop.reserved[4] = 0U;
#line 869
    evtop.reserved[5] = 0U;
#line 869
    evtop.reserved[6] = 0U;
#line 869
    evtop.reserved[7] = 0U;
#line 873
    evbottom.type = 1U;
#line 873
    evbottom.u.vsync.field = 3U;
#line 873
    evbottom.pending = 0U;
#line 873
    evbottom.sequence = 0U;
#line 873
    evbottom.timestamp.tv_sec = 0L;
#line 873
    evbottom.timestamp.tv_nsec = 0L;
#line 873
    evbottom.id = 0U;
#line 873
    evbottom.reserved[0] = 0U;
#line 873
    evbottom.reserved[1] = 0U;
#line 873
    evbottom.reserved[2] = 0U;
#line 873
    evbottom.reserved[3] = 0U;
#line 873
    evbottom.reserved[4] = 0U;
#line 873
    evbottom.reserved[5] = 0U;
#line 873
    evbottom.reserved[6] = 0U;
#line 873
    evbottom.reserved[7] = 0U;
#line 877
    tmp___2 = ivtv_get_output_stream(itv);
#line 877
    s = tmp___2;
#line 879
    itv->last_vsync_field = itv->last_vsync_field + 1U;
#line 880
    if (frame == 0U) {
#line 881
      clear_bit(14L, (unsigned long volatile   *)(& itv->i_flags));
#line 882
      clear_bit(30L, (unsigned long volatile   *)(& itv->i_flags));
    } else {
#line 885
      set_bit(30L, (unsigned long volatile   *)(& itv->i_flags));
    }
#line 887
    tmp___3 = constant_test_bit(31L, (unsigned long const volatile   *)(& itv->i_flags));
#line 887
    if (tmp___3 != 0) {
#line 888
      set_bit(29L, (unsigned long volatile   *)(& itv->i_flags));
#line 889
      __wake_up(& itv->event_waitq, 3U, 1, (void *)0);
#line 890
      if ((unsigned long )s != (unsigned long )((struct ivtv_stream *)0)) {
#line 891
        __wake_up(& s->waitq, 3U, 1, (void *)0);
      } else {

      }
    } else {

    }
#line 893
    if ((unsigned long )s != (unsigned long )((struct ivtv_stream *)0) && (unsigned long )s->vdev.v4l2_dev != (unsigned long )((struct v4l2_device *)0)) {
#line 894
      v4l2_event_queue(& s->vdev, frame != 0U ? & evtop : & evbottom);
    } else {

    }
#line 895
    __wake_up(& itv->vsync_waitq, 3U, 1, (void *)0);
#line 898
    if (frame != 0U) {
#line 898
      if (itv->output_mode == 4) {
#line 902
        set_bit(16L, (unsigned long volatile   *)(& itv->i_flags));
#line 903
        set_bit(15L, (unsigned long volatile   *)(& itv->i_flags));
      } else {
#line 898
        tmp___4 = constant_test_bit(10L, (unsigned long const volatile   *)(& itv->i_flags));
#line 898
        if (tmp___4 != 0) {
#line 902
          set_bit(16L, (unsigned long volatile   *)(& itv->i_flags));
#line 903
          set_bit(15L, (unsigned long volatile   *)(& itv->i_flags));
        } else {
#line 898
          tmp___5 = constant_test_bit(11L, (unsigned long const volatile   *)(& itv->i_flags));
#line 898
          if (tmp___5 != 0) {
#line 902
            set_bit(16L, (unsigned long volatile   *)(& itv->i_flags));
#line 903
            set_bit(15L, (unsigned long volatile   *)(& itv->i_flags));
          } else {
#line 898
            tmp___6 = constant_test_bit(9L, (unsigned long const volatile   *)(& itv->i_flags));
#line 898
            if (tmp___6 != 0) {
#line 902
              set_bit(16L, (unsigned long volatile   *)(& itv->i_flags));
#line 903
              set_bit(15L, (unsigned long volatile   *)(& itv->i_flags));
            } else {

            }
          }
        }
      }
    } else {

    }
#line 907
    if ((unsigned int )yi->running != 0U && (yi->yuv_forced_update != 0U || f->update != 0U)) {
#line 908
      if (f->update == 0U) {
#line 909
        tmp___7 = atomic_read((atomic_t const   *)(& yi->next_dma_frame));
#line 909
        last_dma_frame = (int )((unsigned int )((unsigned char )tmp___7) - 1U) & 7;
#line 912
        f = (struct yuv_frame_info *)(& yi->new_frame_info) + (unsigned long )last_dma_frame;
      } else {

      }
#line 915
      if (f->src_w != 0U) {
#line 916
        yi->update_frame = last_dma_frame;
#line 917
        f->update = 0U;
#line 918
        yi->yuv_forced_update = 0U;
#line 919
        set_bit(17L, (unsigned long volatile   *)(& itv->i_flags));
#line 920
        set_bit(15L, (unsigned long volatile   *)(& itv->i_flags));
      } else {

      }
    } else {

    }
#line 924
    yi->fields_lapsed = (u8 )((int )yi->fields_lapsed + 1);
  } else {

  }
#line 926
  return;
}
}
#line 930 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
irqreturn_t ivtv_irq_handler(int irq , void *dev_id ) 
{ 
  struct ivtv *itv ;
  u32 combo ;
  u32 stat ;
  int i ;
  u8 vsync_force ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int idx ;
  struct ivtv_stream *s ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int idx___0 ;
  struct ivtv_stream *s___0 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 932
  itv = (struct ivtv *)dev_id;
#line 936
  vsync_force = 0U;
#line 938
  spin_lock(& itv->dma_reg_lock);
#line 940
  stat = readl((void const volatile   *)itv->reg_mem + 64U);
#line 942
  combo = ~ itv->irqmask & stat;
#line 945
  if (combo != 0U) {
#line 945
    writel(combo, itv->reg_mem + 64UL);
  } else {

  }
#line 947
  if (combo == 0U) {
#line 951
    if ((itv->irqmask & 1024U) == 0U) {
#line 953
      tmp___0 = readl((void const volatile   *)itv->reg_mem + 10432U);
#line 953
      if ((int )(itv->last_vsync_field ^ tmp___0) & 1) {
#line 956
        if ((ivtv_debug & 256) != 0) {
#line 956
          tmp = readl((void const volatile   *)itv->reg_mem + 10432U);
#line 956
          printk("\016%s:  yuv: VSync interrupt missed %d\n", (char *)(& itv->v4l2_dev.name),
                 tmp >> 16);
        } else {

        }
#line 958
        vsync_force = 1U;
      } else {

      }
    } else {

    }
#line 962
    if ((unsigned int )vsync_force == 0U) {
#line 964
      spin_unlock(& itv->dma_reg_lock);
#line 965
      return (0);
    } else {

    }
  } else {

  }
#line 971
  if ((combo & 9632767U) != 0U) {
#line 972
    if ((ivtv_debug & 64) != 0 && (ivtv_debug & 1024) != 0) {
#line 972
      printk("\016%s:  irq: ======= valid IRQ bits: 0x%08x ======\n", (char *)(& itv->v4l2_dev.name),
             combo);
    } else {

    }
  } else {

  }
#line 974
  if ((combo & 1048576U) != 0U) {
#line 975
    if ((ivtv_debug & 64) != 0 && (ivtv_debug & 1024) != 0) {
#line 975
      printk("\016%s:  irq: DEC DMA COMPLETE\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
  } else {

  }
#line 978
  if ((combo & 65536U) != 0U) {
#line 979
    ivtv_irq_dma_read(itv);
  } else {

  }
#line 982
  if ((combo & 134217728U) != 0U) {
#line 983
    ivtv_irq_enc_dma_complete(itv);
  } else {

  }
#line 986
  if ((combo & 33554432U) != 0U) {
#line 987
    ivtv_irq_enc_pio_complete(itv);
  } else {

  }
#line 990
  if ((combo & 262144U) != 0U) {
#line 991
    ivtv_irq_dma_err(itv);
  } else {

  }
#line 994
  if ((int )combo < 0) {
#line 995
    ivtv_irq_enc_start_cap(itv);
  } else {

  }
#line 998
  if ((combo & 536870912U) != 0U) {
#line 999
    ivtv_irq_enc_vbi_cap(itv);
  } else {

  }
#line 1002
  if ((combo & 524288U) != 0U) {
#line 1003
    ivtv_irq_dec_vbi_reinsert(itv);
  } else {

  }
#line 1006
  if ((combo & 1073741824U) != 0U) {
#line 1007
    if ((ivtv_debug & 64) != 0) {
#line 1007
      printk("\016%s:  irq: ENC EOS\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 1008
    set_bit(4L, (unsigned long volatile   *)(& itv->i_flags));
#line 1009
    __wake_up(& itv->eos_waitq, 3U, 1, (void *)0);
  } else {

  }
#line 1012
  if ((combo & 4194304U) != 0U) {
#line 1013
    ivtv_irq_dec_data_req(itv);
  } else {

  }
#line 1017
  if ((itv->irqmask & 1024U) == 0U) {
#line 1018
    ivtv_irq_vsync(itv);
  } else {

  }
#line 1021
  if ((combo & 268435456U) != 0U) {
#line 1022
    if ((ivtv_debug & 64) != 0) {
#line 1022
      printk("\016%s:  irq: VIM RST\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
  } else {

  }
#line 1026
  if ((combo & 16777216U) != 0U) {
#line 1027
    if ((ivtv_debug & 2) != 0) {
#line 1027
      printk("\016%s:  info: Stereo mode changed\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
  } else {

  }
#line 1030
  if ((combo & 2823618560U) != 0U) {
#line 1030
    tmp___3 = constant_test_bit(0L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1030
    if (tmp___3 == 0) {
#line 1031
      itv->irq_rr_idx = itv->irq_rr_idx + 1U;
#line 1032
      i = 0;
#line 1032
      goto ldv_39320;
      ldv_39319: 
#line 1033
      idx = (int )((itv->irq_rr_idx + (u32 )i) % 9U);
#line 1034
      s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )idx;
#line 1036
      tmp___1 = test_and_clear_bit(0L, (unsigned long volatile   *)(& s->s_flags));
#line 1036
      if (tmp___1 == 0) {
#line 1037
        goto ldv_39317;
      } else {

      }
#line 1038
      if (s->type > 4) {
#line 1039
        ivtv_dma_dec_start(s);
      } else {
#line 1041
        ivtv_dma_enc_start(s);
      }
#line 1042
      goto ldv_39318;
      ldv_39317: 
#line 1032
      i = i + 1;
      ldv_39320: ;
#line 1032
      if (i <= 8) {
#line 1034
        goto ldv_39319;
      } else {

      }
      ldv_39318: ;
#line 1045
      if (i == 9) {
#line 1045
        tmp___2 = constant_test_bit(2L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1045
        if (tmp___2 != 0) {
#line 1047
          ivtv_udma_start(itv);
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 1050
  if ((combo & 2823618560U) != 0U) {
#line 1050
    tmp___5 = constant_test_bit(19L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1050
    if (tmp___5 == 0) {
#line 1051
      itv->irq_rr_idx = itv->irq_rr_idx + 1U;
#line 1052
      i = 0;
#line 1052
      goto ldv_39326;
      ldv_39325: 
#line 1053
      idx___0 = (int )((itv->irq_rr_idx + (u32 )i) % 9U);
#line 1054
      s___0 = (struct ivtv_stream *)(& itv->streams) + (unsigned long )idx___0;
#line 1056
      tmp___4 = test_and_clear_bit(9L, (unsigned long volatile   *)(& s___0->s_flags));
#line 1056
      if (tmp___4 == 0) {
#line 1057
        goto ldv_39323;
      } else {

      }
#line 1058
      if (s___0->type == 6 || s___0->type <= 4) {
#line 1059
        ivtv_dma_enc_start(s___0);
      } else {

      }
#line 1060
      goto ldv_39324;
      ldv_39323: 
#line 1052
      i = i + 1;
      ldv_39326: ;
#line 1052
      if (i <= 8) {
#line 1054
        goto ldv_39325;
      } else {

      }
      ldv_39324: ;
    } else {

    }
  } else {

  }
#line 1064
  tmp___6 = test_and_clear_bit(15L, (unsigned long volatile   *)(& itv->i_flags));
#line 1064
  if (tmp___6 != 0) {
#line 1065
    queue_kthread_work(& itv->irq_worker, & itv->irq_work);
  } else {

  }
#line 1068
  spin_unlock(& itv->dma_reg_lock);
#line 1074
  return ((unsigned int )vsync_force == 0U);
}
}
#line 1077 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.c"
void ivtv_unfinished_dma(unsigned long arg ) 
{ 
  struct ivtv *itv ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1079
  itv = (struct ivtv *)arg;
#line 1081
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1081
  if (tmp == 0) {
#line 1082
    return;
  } else {

  }
#line 1083
  tmp___0 = readl((void const volatile   *)itv->reg_mem + 4U);
#line 1083
  printk("\v%s: DMA TIMEOUT %08x %d\n", (char *)(& itv->v4l2_dev.name), tmp___0, itv->cur_dma_stream);
#line 1085
  tmp___1 = readl((void const volatile   *)itv->reg_mem + 4U);
#line 1085
  writel(tmp___1 & 3U, itv->reg_mem + 4UL);
#line 1086
  clear_bit(1L, (unsigned long volatile   *)(& itv->i_flags));
#line 1087
  clear_bit(0L, (unsigned long volatile   *)(& itv->i_flags));
#line 1088
  itv->cur_dma_stream = -1;
#line 1089
  __wake_up(& itv->dma_waitq, 3U, 1, (void *)0);
#line 1090
  return;
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.o.c.prepared"
bool ldv_queue_work_on_145(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 142
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 142
  ldv_func_res = tmp;
#line 144
  activate_work_2(ldv_func_arg3, 2);
#line 146
  return (ldv_func_res);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.o.c.prepared"
bool ldv_queue_delayed_work_on_146(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 153
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 153
  ldv_func_res = tmp;
#line 155
  activate_work_2(& ldv_func_arg3->work, 2);
#line 157
  return (ldv_func_res);
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.o.c.prepared"
bool ldv_queue_work_on_147(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 164
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 164
  ldv_func_res = tmp;
#line 166
  activate_work_2(ldv_func_arg3, 2);
#line 168
  return (ldv_func_res);
}
}
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.o.c.prepared"
void ldv_flush_workqueue_148(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 174
  flush_workqueue(ldv_func_arg1);
#line 176
  call_and_disable_all_2(2);
#line 177
  return;
}
}
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.o.c.prepared"
bool ldv_queue_delayed_work_on_149(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 183
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 183
  ldv_func_res = tmp;
#line 185
  activate_work_2(& ldv_func_arg3->work, 2);
#line 187
  return (ldv_func_res);
}
}
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.o.c.prepared"
int ldv_del_timer_150(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 194
  tmp = del_timer(ldv_func_arg1);
#line 194
  ldv_func_res = tmp;
#line 196
  disable_suitable_timer_3(ldv_func_arg1);
#line 198
  return (ldv_func_res);
}
}
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.o.c.prepared"
int ldv_del_timer_151(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 205
  tmp = del_timer(ldv_func_arg1);
#line 205
  ldv_func_res = tmp;
#line 207
  disable_suitable_timer_3(ldv_func_arg1);
#line 209
  return (ldv_func_res);
}
}
#line 212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-irq.o.c.prepared"
int ldv_del_timer_152(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 216
  tmp = del_timer(ldv_func_arg1);
#line 216
  ldv_func_res = tmp;
#line 218
  disable_suitable_timer_3(ldv_func_arg1);
#line 220
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
void ldv__builtin_va_end(__builtin_va_list * ) ;
#line 1
void ldv__builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;
#line 1
void ldv__builtin_va_start(__builtin_va_list * ) ;
#line 63 "./arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 284 "include/linux/jiffies.h"
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_167(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_166(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_169(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_168(struct workqueue_struct *ldv_func_arg1 ) ;
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.c"
static struct ivtv_api_info  const  api_info[256U]  = 
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.c"
  {      {6, "CX2341X_DEC_PING_FW"}, 
        {66, "CX2341X_DEC_START_PLAYBACK"}, 
        {2, "CX2341X_DEC_STOP_PLAYBACK"}, 
        {2, "CX2341X_DEC_SET_PLAYBACK_SPEED"}, 
        {0, 0}, 
        {2, "CX2341X_DEC_STEP_VIDEO"}, 
        {0, 0}, 
        {0, 0}, 
        {1, "CX2341X_DEC_SET_DMA_BLOCK_SIZE"}, 
        {6, "CX2341X_DEC_GET_XFER_INFO"}, 
        {6, "CX2341X_DEC_GET_DMA_STATUS"}, 
        {40, "CX2341X_DEC_SCHED_DMA_FROM_HOST"}, 
        {0, 0}, 
        {2, "CX2341X_DEC_PAUSE_PLAYBACK"}, 
        {6, "CX2341X_DEC_HALT_FW"}, 
        {0, 0}, 
        {1, "CX2341X_DEC_SET_STANDARD"}, 
        {6, "CX2341X_DEC_GET_VERSION"}, 
        {0, 0}, 
        {0, 0}, 
        {1, "CX2341X_DEC_SET_STREAM_INPUT"}, 
        {2, "CX2341X_DEC_GET_TIMING_INFO"}, 
        {1, "CX2341X_DEC_SET_AUDIO_MODE"}, 
        {2, "CX2341X_DEC_SET_EVENT_NOTIFICATION"}, 
        {1, "CX2341X_DEC_SET_DISPLAY_BUFFERS"}, 
        {2, "CX2341X_DEC_EXTRACT_VBI"}, 
        {6, "CX2341X_DEC_SET_DECODER_SOURCE"}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {1, "CX2341X_DEC_SET_PREBUFFERING"}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {6, "CX2341X_OSD_GET_FRAMEBUFFER"}, 
        {6, "CX2341X_OSD_GET_PIXEL_FORMAT"}, 
        {1, "CX2341X_OSD_SET_PIXEL_FORMAT"}, 
        {6, "CX2341X_OSD_GET_STATE"}, 
        {1, "CX2341X_OSD_SET_STATE"}, 
        {6, "CX2341X_OSD_GET_OSD_COORDS"}, 
        {1, "CX2341X_OSD_SET_OSD_COORDS"}, 
        {6, "CX2341X_OSD_GET_SCREEN_COORDS"}, 
        {1, "CX2341X_OSD_SET_SCREEN_COORDS"}, 
        {6, "CX2341X_OSD_GET_GLOBAL_ALPHA"}, 
        {1, "CX2341X_OSD_SET_GLOBAL_ALPHA"}, 
        {1, "CX2341X_OSD_SET_BLEND_COORDS"}, 
        {0, 0}, 
        {0, 0}, 
        {6, "CX2341X_OSD_GET_FLICKER_STATE"}, 
        {1, "CX2341X_OSD_SET_FLICKER_STATE"}, 
        {0, 0}, 
        {2, "CX2341X_OSD_BLT_COPY"}, 
        {2, "CX2341X_OSD_BLT_FILL"}, 
        {2, "CX2341X_OSD_BLT_TEXT"}, 
        {0, 0}, 
        {1, "CX2341X_OSD_SET_FRAMEBUFFER_WINDOW"}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {1, "CX2341X_OSD_SET_CHROMA_KEY"}, 
        {6, "CX2341X_OSD_GET_ALPHA_CONTENT_INDEX"}, 
        {1, "CX2341X_OSD_SET_ALPHA_CONTENT_INDEX"}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {6, "CX2341X_ENC_PING_FW"}, 
        {66, "CX2341X_ENC_START_CAPTURE"}, 
        {2, "CX2341X_ENC_STOP_CAPTURE"}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_AUDIO_ID"}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_VIDEO_ID"}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_PCR_ID"}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_FRAME_RATE"}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_FRAME_SIZE"}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_BIT_RATE"}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_GOP_PROPERTIES"}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_ASPECT_RATIO"}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_DNR_FILTER_MODE"}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_DNR_FILTER_PROPS"}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_CORING_LEVELS"}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_SPATIAL_FILTER_TYPE"}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {1, "0xb1"}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {2, "CX2341X_ENC_SET_VBI_LINE"}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_STREAM_TYPE"}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_OUTPUT_PORT"}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_AUDIO_PROPERTIES"}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {6, "CX2341X_ENC_HALT_FW"}, 
        {6, "CX2341X_ENC_GET_VERSION"}, 
        {1, "CX2341X_ENC_SET_GOP_CLOSURE"}, 
        {2, "CX2341X_ENC_GET_SEQ_END"}, 
        {6, "CX2341X_ENC_SET_PGM_INDEX_INFO"}, 
        {2, "CX2341X_ENC_SET_VBI_CONFIG"}, 
        {1, "CX2341X_ENC_SET_DMA_BLOCK_SIZE"}, 
        {6, "CX2341X_ENC_GET_PREV_DMA_INFO_MB_10"}, 
        {6, "CX2341X_ENC_GET_PREV_DMA_INFO_MB_9"}, 
        {40, "CX2341X_ENC_SCHED_DMA_TO_HOST"}, 
        {2, "CX2341X_ENC_INITIALIZE_INPUT"}, 
        {0, 0}, 
        {0, 0}, 
        {1, "CX2341X_ENC_SET_FRAME_DROP_RATE"}, 
        {0, 0}, 
        {2, "CX2341X_ENC_PAUSE_ENCODER"}, 
        {48, "CX2341X_ENC_REFRESH_INPUT"}, 
        {1, "CX2341X_ENC_SET_COPYRIGHT"}, 
        {2, "CX2341X_ENC_SET_EVENT_NOTIFICATION"}, 
        {1, "CX2341X_ENC_SET_NUM_VSYNC_LINES"}, 
        {1, "CX2341X_ENC_SET_PLACEHOLDER"}, 
        {0, 0}, 
        {2, "CX2341X_ENC_MUTE_VIDEO"}, 
        {2, "CX2341X_ENC_MUTE_AUDIO"}, 
        {6, "CX2341X_ENC_SET_VERT_CROP_LINE"}, 
        {6, "CX2341X_ENC_MISC"}};
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.c"
static int try_mailbox(struct ivtv *itv , struct ivtv_mailbox_data *mbdata , int mb ) 
{ 
  u32 flags ;
  unsigned int tmp ;
  int is_free ;
  int tmp___0 ;

  {
#line 147
  tmp = readl((void const volatile   *)(& (mbdata->mbox + (unsigned long )mb)->flags));
#line 147
  flags = tmp;
#line 148
  is_free = flags == 0U || (flags & 4U) != 0U;
#line 151
  if (is_free != 0) {
#line 151
    tmp___0 = test_and_set_bit((long )mb, (unsigned long volatile   *)(& mbdata->busy));
#line 151
    if (tmp___0 == 0) {
#line 152
      writel(1U, (void volatile   *)(& (mbdata->mbox + (unsigned long )mb)->flags));
#line 152
      readl((void const volatile   *)(& (mbdata->mbox + (unsigned long )mb)->flags));
#line 153
      return (1);
    } else {

    }
  } else {

  }
#line 155
  return (0);
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.c"
static int get_mailbox(struct ivtv *itv , struct ivtv_mailbox_data *mbdata , int flags ) 
{ 
  unsigned long then ;
  int i ;
  int mb ;
  int max_mbox ;
  int retries ;
  int tmp ;
  unsigned long tmp___0 ;

  {
#line 162
  then = jiffies;
#line 164
  max_mbox = (int )mbdata->max_mbox;
#line 165
  retries = 100;
#line 169
  if ((flags & 6) == 2) {
#line 170
    max_mbox = 1;
  } else {

  }
#line 173
  i = 0;
#line 173
  goto ldv_38938;
  ldv_38937: 
#line 174
  mb = 1;
#line 174
  goto ldv_38928;
  ldv_38927: 
#line 175
  tmp = try_mailbox(itv, mbdata, mb);
#line 175
  if (tmp != 0) {
#line 176
    return (mb);
  } else {

  }
#line 174
  mb = mb + 1;
  ldv_38928: ;
#line 174
  if (mb <= max_mbox) {
#line 176
    goto ldv_38927;
  } else {

  }

#line 179
  if ((flags & 16) == 0) {
#line 180
    tmp___0 = msecs_to_jiffies((unsigned int const   )(retries * 10));
#line 180
    if ((long )((tmp___0 + then) - (unsigned long )jiffies) < 0L) {
#line 182
      goto ldv_38936;
    } else {

    }
#line 183
    ivtv_msleep_timeout(10U, 0);
  } else {

  }
#line 173
  i = i + 1;
  ldv_38938: ;
#line 173
  if (i < retries) {
#line 175
    goto ldv_38937;
  } else {

  }
  ldv_38936: ;
#line 186
  return (-19);
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.c"
static void write_mailbox(struct ivtv_mailbox  volatile  *mbox , int cmd , int args ,
                          u32 *data ) 
{ 
  int i ;

  {
#line 193
  writel((unsigned int )cmd, (void volatile   *)(& mbox->cmd));
#line 193
  readl((void const volatile   *)(& mbox->cmd));
#line 194
  writel(33554432U, (void volatile   *)(& mbox->timeout));
#line 194
  readl((void const volatile   *)(& mbox->timeout));
#line 196
  i = 0;
#line 196
  goto ldv_38947;
  ldv_38946: 
#line 197
  writel(*(data + (unsigned long )i), (void volatile   *)(& mbox->data) + (unsigned long )i);
#line 197
  readl((void const volatile   *)(& mbox->data) + (unsigned long )i);
#line 196
  i = i + 1;
  ldv_38947: ;
#line 196
  if (i <= 15) {
#line 198
    goto ldv_38946;
  } else {

  }
#line 199
  writel(3U, (void volatile   *)(& mbox->flags));
#line 199
  readl((void const volatile   *)(& mbox->flags));
#line 200
  return;
}
}
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.c"
static void clear_all_mailboxes(struct ivtv *itv , struct ivtv_mailbox_data *mbdata ) 
{ 
  int i ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 206
  i = 0;
#line 206
  goto ldv_38955;
  ldv_38954: ;
#line 207
  if (ivtv_debug & 1) {
#line 207
    tmp = readl((void const volatile   *)(& (mbdata->mbox + (unsigned long )i)->flags));
#line 207
    tmp___0 = readl((void const volatile   *)(& (mbdata->mbox + (unsigned long )i)->cmd));
#line 207
    printk("\016%s:  warn: Clearing mailbox %d: cmd 0x%08x flags 0x%08x\n", (char *)(& itv->v4l2_dev.name),
           i, tmp___0, tmp);
  } else {

  }
#line 209
  writel(0U, (void volatile   *)(& (mbdata->mbox + (unsigned long )i)->flags));
#line 209
  readl((void const volatile   *)(& (mbdata->mbox + (unsigned long )i)->flags));
#line 210
  clear_bit((long )i, (unsigned long volatile   *)(& mbdata->busy));
#line 206
  i = i + 1;
  ldv_38955: ;
#line 206
  if ((int )mbdata->max_mbox >= i) {
#line 208
    goto ldv_38954;
  } else {

  }

#line 213
  return;
}
}
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.c"
static int ivtv_api_call(struct ivtv *itv , int cmd , int args , u32 *data ) 
{ 
  struct ivtv_mailbox_data *mbdata ;
  struct ivtv_mailbox  volatile  *mbox ;
  int api_timeout ;
  unsigned long tmp ;
  int flags ;
  int mb ;
  int i ;
  unsigned long then ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned int tmp___5 ;
  unsigned long __ms ;
  unsigned long tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned long tmp___9 ;

  {
#line 216
  mbdata = cmd > 127 ? & itv->enc_mbox : & itv->dec_mbox;
#line 218
  tmp = msecs_to_jiffies(1000U);
#line 218
  api_timeout = (int )tmp;
#line 223
  if ((unsigned long )mbdata == (unsigned long )((struct ivtv_mailbox_data *)0)) {
#line 224
    printk("\v%s: No mailbox allocated\n", (char *)(& itv->v4l2_dev.name));
#line 225
    return (-19);
  } else {

  }
#line 227
  if ((((args < 0 || args > 16) || cmd < 0) || cmd > 255) || (unsigned long )api_info[cmd].name == (unsigned long )((char const   */* const  */)0)) {
#line 229
    printk("\v%s: Invalid MB call: cmd = 0x%02x, args = %d\n", (char *)(& itv->v4l2_dev.name),
           cmd, args);
#line 230
    return (-22);
  } else {

  }
#line 233
  if (((int )api_info[cmd].flags & 32) != 0) {
#line 234
    if ((ivtv_debug & 4) != 0 && (ivtv_debug & 1024) != 0) {
#line 234
      printk("\016%s:  mb: MB Call: %s\n", (char *)(& itv->v4l2_dev.name), api_info[cmd].name);
    } else {

    }
  } else
#line 237
  if ((ivtv_debug & 4) != 0) {
#line 237
    printk("\016%s:  mb: MB Call: %s\n", (char *)(& itv->v4l2_dev.name), api_info[cmd].name);
  } else {

  }
#line 241
  i = args;
#line 241
  goto ldv_38971;
  ldv_38970: 
#line 242
  *(data + (unsigned long )i) = 0U;
#line 241
  i = i + 1;
  ldv_38971: ;
#line 241
  if (i <= 15) {
#line 243
    goto ldv_38970;
  } else {

  }

#line 248
  if (itv->api_cache[cmd].last_jiffies != 0UL) {
#line 248
    tmp___0 = msecs_to_jiffies(1800000U);
#line 248
    if ((long )((unsigned long )jiffies - (itv->api_cache[cmd].last_jiffies + tmp___0)) < 0L) {
#line 248
      tmp___1 = memcmp((void const   *)data, (void const   *)(& itv->api_cache[cmd].data),
                       64UL);
#line 248
      if (tmp___1 == 0) {
#line 252
        itv->api_cache[cmd].last_jiffies = jiffies;
#line 253
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
#line 256
  flags = api_info[cmd].flags;
#line 258
  if ((flags & 8) != 0) {
#line 259
    i = 0;
#line 259
    goto ldv_38980;
    ldv_38979: 
#line 260
    mb = i % ((int )mbdata->max_mbox + 1);
#line 261
    tmp___2 = try_mailbox(itv, mbdata, mb);
#line 261
    if (tmp___2 != 0) {
#line 262
      write_mailbox(mbdata->mbox + (unsigned long )mb, cmd, args, data);
#line 263
      clear_bit((long )mb, (unsigned long volatile   *)(& mbdata->busy));
#line 264
      return (0);
    } else {

    }
#line 266
    if (ivtv_debug & 1) {
#line 266
      tmp___3 = readl((void const volatile   *)(& (mbdata->mbox + (unsigned long )mb)->flags));
#line 266
      printk("\016%s:  warn: %s: mailbox %d not free %08x\n", (char *)(& itv->v4l2_dev.name),
             api_info[cmd].name, mb, tmp___3);
    } else {

    }
#line 259
    i = i + 1;
    ldv_38980: ;
#line 259
    if (i <= 99) {
#line 261
      goto ldv_38979;
    } else {

    }
#line 269
    printk("\f%s: Could not find free DMA mailbox for %s\n", (char *)(& itv->v4l2_dev.name),
           api_info[cmd].name);
#line 270
    clear_all_mailboxes(itv, mbdata);
#line 271
    return (-16);
  } else {

  }
#line 274
  if ((flags & 6) == 6) {
#line 275
    tmp___4 = msecs_to_jiffies(100U);
#line 275
    api_timeout = (int )tmp___4;
  } else {

  }
#line 277
  mb = get_mailbox(itv, mbdata, flags);
#line 278
  if (mb < 0) {
#line 279
    if (ivtv_debug & 1) {
#line 279
      printk("\016%s:  warn: No free mailbox found (%s)\n", (char *)(& itv->v4l2_dev.name),
             api_info[cmd].name);
    } else {

    }
#line 280
    clear_all_mailboxes(itv, mbdata);
#line 281
    return (-16);
  } else {

  }
#line 283
  mbox = mbdata->mbox + (unsigned long )mb;
#line 284
  write_mailbox(mbox, cmd, args, data);
#line 285
  if (flags & 1) {
#line 286
    memcpy((void *)(& itv->api_cache[cmd].data), (void const   *)data, 64UL);
#line 287
    itv->api_cache[cmd].last_jiffies = jiffies;
  } else {

  }
#line 289
  if ((flags & 2) == 0) {
#line 290
    clear_bit((long )mb, (unsigned long volatile   *)(& mbdata->busy));
#line 291
    return (0);
  } else {

  }
#line 295
  then = jiffies;
#line 297
  if ((flags & 64) == 0) {
#line 299
    i = 0;
#line 299
    goto ldv_38984;
    ldv_38983: 
#line 300
    tmp___5 = readl((void const volatile   *)(& mbox->flags));
#line 300
    if ((tmp___5 & 4U) != 0U) {
#line 301
      goto ldv_38982;
    } else {

    }
#line 299
    i = i + 1;
    ldv_38984: ;
#line 299
    if (i <= 99) {
#line 301
      goto ldv_38983;
    } else {

    }
    ldv_38982: ;
  } else {

  }
#line 304
  goto ldv_38996;
  ldv_38995: ;
#line 305
  if ((long )(((unsigned long )api_timeout + then) - (unsigned long )jiffies) < 0L) {
#line 306
    if (ivtv_debug & 1) {
#line 306
      printk("\016%s:  warn: Could not get result (%s)\n", (char *)(& itv->v4l2_dev.name),
             api_info[cmd].name);
    } else {

    }
#line 308
    writel(0U, (void volatile   *)(& mbox->flags));
#line 308
    readl((void const volatile   *)(& mbox->flags));
#line 309
    clear_bit((long )mb, (unsigned long volatile   *)(& mbdata->busy));
#line 310
    return (-5);
  } else {

  }
#line 312
  if ((flags & 32) != 0) {
#line 313
    if (1) {
#line 313
      __const_udelay(4295000UL);
    } else {
#line 313
      __ms = 1UL;
#line 313
      goto ldv_38993;
      ldv_38992: 
#line 313
      __const_udelay(4295000UL);
      ldv_38993: 
#line 313
      tmp___6 = __ms;
#line 313
      __ms = __ms - 1UL;
#line 313
      if (tmp___6 != 0UL) {
#line 315
        goto ldv_38992;
      } else {

      }

    }
  } else {
#line 315
    ivtv_msleep_timeout(1U, 0);
  }
  ldv_38996: 
#line 304
  tmp___7 = readl((void const volatile   *)(& mbox->flags));
#line 304
  if ((tmp___7 & 4U) == 0U) {
#line 306
    goto ldv_38995;
  } else {

  }
#line 317
  tmp___9 = msecs_to_jiffies(100U);
#line 317
  if ((long )((tmp___9 + then) - (unsigned long )jiffies) < 0L) {
#line 318
    if (ivtv_debug & 1) {
#line 318
      tmp___8 = jiffies_to_msecs((unsigned long )jiffies - then);
#line 318
      printk("\016%s:  warn: %s took %u jiffies\n", (char *)(& itv->v4l2_dev.name),
             api_info[cmd].name, tmp___8);
    } else {

    }
  } else {

  }
#line 322
  i = 0;
#line 322
  goto ldv_39005;
  ldv_39004: 
#line 323
  *(data + (unsigned long )i) = readl((void const volatile   *)(& mbox->data) + (unsigned long )i);
#line 322
  i = i + 1;
  ldv_39005: ;
#line 322
  if (i <= 15) {
#line 324
    goto ldv_39004;
  } else {

  }
#line 324
  writel(0U, (void volatile   *)(& mbox->flags));
#line 324
  readl((void const volatile   *)(& mbox->flags));
#line 325
  clear_bit((long )mb, (unsigned long volatile   *)(& mbdata->busy));
#line 326
  return (0);
}
}
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.c"
int ivtv_api(struct ivtv *itv , int cmd , int args , u32 *data ) 
{ 
  int res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 331
  tmp = ivtv_api_call(itv, cmd, args, data);
#line 331
  res = tmp;
#line 336
  if (res == -16) {
#line 336
    tmp___0 = ivtv_api_call(itv, cmd, args, data);
#line 336
    tmp___1 = tmp___0;
  } else {
#line 336
    tmp___1 = res;
  }
#line 336
  return (tmp___1);
}
}
#line 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.c"
int ivtv_api_func(void *priv , u32 cmd , int in , int out , u32 *data ) 
{ 
  int tmp ;

  {
#line 341
  tmp = ivtv_api((struct ivtv *)priv, (int )cmd, in, data);
#line 341
  return (tmp);
}
}
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.c"
int ivtv_vapi_result(struct ivtv *itv , u32 *data , int cmd , int args  , ...) 
{ 
  va_list ap ;
  int i ;
  u32 tmp ;
  int tmp___0 ;

  {
#line 349
  ldv__builtin_va_start((va_list *)(& ap));
#line 350
  i = 0;
#line 350
  goto ldv_39030;
  ldv_39029: 
#line 351
  ldv__builtin_va_arg(ap, sizeof(u32 ), (void *)(& tmp));
#line 351
  *(data + (unsigned long )i) = tmp;
#line 350
  i = i + 1;
  ldv_39030: ;
#line 350
  if (i < args) {
#line 352
    goto ldv_39029;
  } else {

  }
#line 353
  ldv__builtin_va_end((va_list *)(& ap));
#line 354
  tmp___0 = ivtv_api(itv, cmd, args, data);
#line 354
  return (tmp___0);
}
}
#line 357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.c"
int ivtv_vapi(struct ivtv *itv , int cmd , int args  , ...) 
{ 
  u32 data[16U] ;
  va_list ap ;
  int i ;
  u32 tmp ;
  int tmp___0 ;

  {
#line 363
  ldv__builtin_va_start((va_list *)(& ap));
#line 364
  i = 0;
#line 364
  goto ldv_39041;
  ldv_39040: 
#line 365
  ldv__builtin_va_arg(ap, sizeof(u32 ), (void *)(& tmp));
#line 365
  data[i] = tmp;
#line 364
  i = i + 1;
  ldv_39041: ;
#line 364
  if (i < args) {
#line 366
    goto ldv_39040;
  } else {

  }
#line 367
  ldv__builtin_va_end((va_list *)(& ap));
#line 368
  tmp___0 = ivtv_api(itv, cmd, args, (u32 *)(& data));
#line 368
  return (tmp___0);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.c"
void ivtv_api_get_data(struct ivtv_mailbox_data *mbdata , int mb , int argc , u32 *data ) 
{ 
  u32 volatile   *p ;
  int i ;

  {
#line 375
  p = (u32 volatile   *)(& (mbdata->mbox + (unsigned long )mb)->data);
#line 377
  i = 0;
#line 377
  goto ldv_39052;
  ldv_39051: 
#line 378
  *(data + (unsigned long )i) = readl((void const volatile   *)p);
#line 377
  i = i + 1;
#line 377
  p = p + 1;
  ldv_39052: ;
#line 377
  if (i < argc) {
#line 379
    goto ldv_39051;
  } else {

  }

#line 384
  return;
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.c"
void ivtv_mailbox_cache_invalidate(struct ivtv *itv ) 
{ 
  int i ;

  {
#line 385
  i = 0;
#line 385
  goto ldv_39059;
  ldv_39058: 
#line 386
  itv->api_cache[i].last_jiffies = 0UL;
#line 385
  i = i + 1;
  ldv_39059: ;
#line 385
  if (i <= 255) {
#line 387
    goto ldv_39058;
  } else {

  }

#line 392
  return;
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.o.c.prepared"
bool ldv_queue_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 142
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 142
  ldv_func_res = tmp;
#line 144
  activate_work_2(ldv_func_arg3, 2);
#line 146
  return (ldv_func_res);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.o.c.prepared"
bool ldv_queue_delayed_work_on_166(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 153
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 153
  ldv_func_res = tmp;
#line 155
  activate_work_2(& ldv_func_arg3->work, 2);
#line 157
  return (ldv_func_res);
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.o.c.prepared"
bool ldv_queue_work_on_167(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 164
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 164
  ldv_func_res = tmp;
#line 166
  activate_work_2(ldv_func_arg3, 2);
#line 168
  return (ldv_func_res);
}
}
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.o.c.prepared"
void ldv_flush_workqueue_168(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 174
  flush_workqueue(ldv_func_arg1);
#line 176
  call_and_disable_all_2(2);
#line 177
  return;
}
}
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-mailbox.o.c.prepared"
bool ldv_queue_delayed_work_on_169(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 183
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 183
  ldv_func_res = tmp;
#line 185
  activate_work_2(& ldv_func_arg3->work, 2);
#line 187
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 7 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 167 "include/uapi/linux/swab.h"
__inline static __u32 __swab32p(__u32 const   *p ) 
{ 
  __u32 tmp ;

  {
#line 172
  tmp = __fswab32(*p);
#line 172
  return (tmp);
}
}
#line 235 "include/uapi/linux/swab.h"
__inline static void __swab32s(__u32 *p ) 
{ 


  {
#line 240
  *p = __swab32p((__u32 const   *)p);
#line 241
  return;
}
}
#line 48 "include/linux/list.h"
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 75 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 77
  __list_add(new, head->prev, head);
#line 78
  return;
}
}
#line 112
extern void __list_del_entry(struct list_head * ) ;
#line 143 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 145
  __list_del_entry(entry);
#line 146
  INIT_LIST_HEAD(entry);
#line 147
  return;
}
}
#line 165 "include/linux/list.h"
__inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
{ 


  {
#line 168
  __list_del_entry(list);
#line 169
  list_add_tail(list, head);
#line 170
  return;
}
}
#line 23 "./arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_179(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_181(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_180(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_183(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_182(struct workqueue_struct *ldv_func_arg1 ) ;
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 10 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 19
  if (tmp___1 != 0L) {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_30213: ;
#line 19
    goto ldv_30213;
  } else {

  }
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
#line 26
  return (addr);
}
}
#line 29 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 36
  if (tmp___1 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_30222: ;
#line 36
    goto ldv_30222;
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
#line 40
  return;
}
}
#line 102 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu___0(struct device *dev , dma_addr_t addr ,
                                                 size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 106
  tmp = get_dma_ops(dev);
#line 106
  ops = tmp;
#line 108
  tmp___0 = valid_dma_direction((int )dir);
#line 108
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 108
  if (tmp___1 != 0L) {
#line 108
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (108), "i" (12UL));
    ldv_30273: ;
#line 108
    goto ldv_30273;
  } else {

  }
#line 109
  if ((unsigned long )ops->sync_single_for_cpu != (unsigned long )((void (*)(struct device * ,
                                                                             dma_addr_t  ,
                                                                             size_t  ,
                                                                             enum dma_data_direction  ))0)) {
#line 110
    (*(ops->sync_single_for_cpu))(dev, addr, size, dir);
  } else {

  }
#line 111
  debug_dma_sync_single_for_cpu(dev, addr, size, (int )dir);
#line 112
  return;
}
}
#line 38 "include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev , void *ptr , size_t size ,
                                          int direction ) 
{ 
  dma_addr_t tmp ;

  {
#line 40
  tmp = dma_map_single_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                             ptr, size, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 40
  return (tmp);
}
}
#line 44 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_single(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                      size_t size , int direction ) 
{ 


  {
#line 47
  dma_unmap_single_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                         dma_addr, size, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 48
  return;
}
}
#line 79 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_cpu___0(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                     size_t size , int direction ) 
{ 


  {
#line 82
  dma_sync_single_for_cpu___0((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                              dma_handle, size, (enum dma_data_direction )direction);
#line 83
  return;
}
}
#line 650 "./arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 672
extern void __copy_from_user_overflow(void) ;
#line 693 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 695
  tmp = __builtin_object_size((void const   *)to, 0);
#line 695
  sz = (int )tmp;
#line 697
  __might_fault("./arch/x86/include/asm/uaccess.h", 697);
#line 717
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
#line 717
  if (tmp___0 != 0L) {
#line 718
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
#line 722
    __copy_from_user_overflow();
  }
#line 724
  return (n);
}
}
#line 43 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-queue.h"
__inline static int ivtv_might_use_dma(struct ivtv_stream *s ) 
{ 


  {
#line 45
  return (s->dma != 3);
}
}
#line 53 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-queue.h"
__inline static void ivtv_buf_sync_for_cpu___0(struct ivtv_stream *s , struct ivtv_buffer *buf ) 
{ 
  int tmp ;

  {
#line 55
  tmp = ivtv_use_dma(s);
#line 55
  if (tmp != 0) {
#line 56
    pci_dma_sync_single_for_cpu___0((s->itv)->pdev, buf->dma_handle, (size_t )(s->buf_size + 256U),
                                    s->dma);
  } else {

  }
#line 58
  return;
}
}
#line 79
int ivtv_stream_alloc(struct ivtv_stream *s ) ;
#line 80
void ivtv_stream_free(struct ivtv_stream *s ) ;
#line 82 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-queue.h"
__inline static void ivtv_stream_sync_for_cpu___0(struct ivtv_stream *s ) 
{ 
  int tmp ;

  {
#line 84
  tmp = ivtv_use_dma(s);
#line 84
  if (tmp != 0) {
#line 85
    pci_dma_sync_single_for_cpu___0((s->itv)->pdev, s->sg_handle, 12UL, 1);
  } else {

  }
#line 86
  return;
}
}
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.c"
int ivtv_buf_copy_from_user(struct ivtv_stream *s , struct ivtv_buffer *buf , char const   *src ,
                            int copybytes ) 
{ 
  unsigned long tmp ;

  {
#line 27
  if (s->buf_size - buf->bytesused < (u32 )copybytes) {
#line 28
    copybytes = (int )(s->buf_size - buf->bytesused);
  } else {

  }
#line 29
  tmp = copy_from_user((void *)buf->buf + (unsigned long )buf->bytesused, (void const   *)src,
                       (unsigned long )copybytes);
#line 29
  if (tmp != 0UL) {
#line 30
    return (-14);
  } else {

  }
#line 32
  buf->bytesused = buf->bytesused + (u32 )copybytes;
#line 33
  return (copybytes);
}
}
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.c"
void ivtv_buf_swap(struct ivtv_buffer *buf ) 
{ 
  int i ;

  {
#line 40
  i = 0;
#line 40
  goto ldv_38945;
  ldv_38944: 
#line 41
  __swab32s((__u32 *)buf->buf + (unsigned long )i);
#line 40
  i = i + 4;
  ldv_38945: ;
#line 40
  if ((u32 )i < buf->bytesused) {
#line 42
    goto ldv_38944;
  } else {

  }

#line 47
  return;
}
}
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.c"
void ivtv_queue_init(struct ivtv_queue *q ) 
{ 


  {
#line 46
  INIT_LIST_HEAD(& q->list);
#line 47
  q->buffers = 0U;
#line 48
  q->length = 0U;
#line 49
  q->bytesused = 0U;
#line 50
  return;
}
}
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.c"
void ivtv_enqueue(struct ivtv_stream *s , struct ivtv_buffer *buf , struct ivtv_queue *q ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 57
  if ((unsigned long )(& s->q_free) == (unsigned long )q) {
#line 58
    buf->bytesused = 0U;
#line 59
    buf->readpos = 0U;
#line 60
    buf->b_flags = 0U;
#line 61
    buf->dma_xfer_cnt = 0U;
  } else {

  }
#line 63
  tmp = spinlock_check(& s->qlock);
#line 63
  flags = _raw_spin_lock_irqsave(tmp);
#line 64
  list_add_tail(& buf->list, & q->list);
#line 65
  q->buffers = q->buffers + 1U;
#line 66
  q->length = q->length + s->buf_size;
#line 67
  q->bytesused = q->bytesused + (buf->bytesused - buf->readpos);
#line 68
  spin_unlock_irqrestore(& s->qlock, flags);
#line 69
  return;
}
}
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.c"
struct ivtv_buffer *ivtv_dequeue(struct ivtv_stream *s , struct ivtv_queue *q ) 
{ 
  struct ivtv_buffer *buf ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
#line 73
  buf = (struct ivtv_buffer *)0;
#line 76
  tmp = spinlock_check(& s->qlock);
#line 76
  flags = _raw_spin_lock_irqsave(tmp);
#line 77
  tmp___0 = list_empty((struct list_head  const  *)(& q->list));
#line 77
  if (tmp___0 == 0) {
#line 78
    __mptr = (struct list_head  const  *)q->list.next;
#line 78
    buf = (struct ivtv_buffer *)__mptr;
#line 79
    list_del_init(q->list.next);
#line 80
    q->buffers = q->buffers - 1U;
#line 81
    q->length = q->length - s->buf_size;
#line 82
    q->bytesused = q->bytesused + (buf->readpos - buf->bytesused);
  } else {

  }
#line 84
  spin_unlock_irqrestore(& s->qlock, flags);
#line 85
  return (buf);
}
}
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.c"
static void ivtv_queue_move_buf(struct ivtv_stream *s , struct ivtv_queue *from ,
                                struct ivtv_queue *to , int clear ) 
{ 
  struct ivtv_buffer *buf ;
  struct list_head  const  *__mptr ;
  u32 tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;

  {
#line 91
  __mptr = (struct list_head  const  *)from->list.next;
#line 91
  buf = (struct ivtv_buffer *)__mptr;
#line 93
  list_move_tail(from->list.next, & to->list);
#line 94
  from->buffers = from->buffers - 1U;
#line 95
  from->length = from->length - s->buf_size;
#line 96
  from->bytesused = from->bytesused + (buf->readpos - buf->bytesused);
#line 98
  if (clear != 0) {
#line 99
    tmp___1 = 0U;
#line 99
    buf->dma_xfer_cnt = tmp___1;
#line 99
    tmp___0 = tmp___1;
#line 99
    buf->b_flags = tmp___0;
#line 99
    tmp = (u32 )tmp___0;
#line 99
    buf->readpos = tmp;
#line 99
    buf->bytesused = tmp;
  } else {

  }
#line 100
  to->buffers = to->buffers + 1U;
#line 101
  to->length = to->length + s->buf_size;
#line 102
  to->bytesused = to->bytesused + (buf->bytesused - buf->readpos);
#line 103
  return;
}
}
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.c"
int ivtv_queue_move(struct ivtv_stream *s , struct ivtv_queue *from , struct ivtv_queue *steal ,
                    struct ivtv_queue *to , int needed_bytes ) 
{ 
  unsigned long flags ;
  int rc ;
  int from_free ;
  int to_free ;
  int bytes_available ;
  int bytes_steal ;
  raw_spinlock_t *tmp ;
  struct ivtv_buffer *buf ;
  struct list_head  const  *__mptr ;
  u16 dma_xfer_cnt ;
  u32 tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;
  int tmp___3 ;
  struct list_head  const  *__mptr___0 ;
  u32 old_length ;
  u32 old_bytesused ;

  {
#line 126
  rc = 0;
#line 127
  from_free = (unsigned long )(& s->q_free) == (unsigned long )from;
#line 128
  to_free = (unsigned long )(& s->q_free) == (unsigned long )to;
#line 131
  tmp = spinlock_check(& s->qlock);
#line 131
  flags = _raw_spin_lock_irqsave(tmp);
#line 132
  if (needed_bytes == 0) {
#line 133
    from_free = 1;
#line 134
    needed_bytes = (int )from->length;
  } else {

  }
#line 137
  bytes_available = (int )(from_free != 0 ? from->length : from->bytesused);
#line 138
  bytes_steal = from_free != 0 && (unsigned long )steal != (unsigned long )((struct ivtv_queue *)0) ? (int )steal->length : 0;
#line 140
  if (bytes_available + bytes_steal < needed_bytes) {
#line 141
    spin_unlock_irqrestore(& s->qlock, flags);
#line 142
    return (-12);
  } else {

  }
#line 144
  goto ldv_39005;
  ldv_39004: 
#line 145
  __mptr = (struct list_head  const  *)steal->list.prev;
#line 145
  buf = (struct ivtv_buffer *)__mptr;
#line 146
  dma_xfer_cnt = buf->dma_xfer_cnt;
#line 152
  goto ldv_39003;
  ldv_39002: 
#line 153
  list_move_tail(steal->list.prev, & from->list);
#line 154
  rc = rc + 1;
#line 155
  steal->buffers = steal->buffers - 1U;
#line 156
  steal->length = steal->length - s->buf_size;
#line 157
  steal->bytesused = steal->bytesused + (buf->readpos - buf->bytesused);
#line 158
  tmp___2 = 0U;
#line 158
  buf->dma_xfer_cnt = tmp___2;
#line 158
  tmp___1 = tmp___2;
#line 158
  buf->b_flags = tmp___1;
#line 158
  tmp___0 = (u32 )tmp___1;
#line 158
  buf->readpos = tmp___0;
#line 158
  buf->bytesused = tmp___0;
#line 159
  from->buffers = from->buffers + 1U;
#line 160
  from->length = from->length + s->buf_size;
#line 161
  bytes_available = (int )(s->buf_size + (u32 )bytes_available);
#line 162
  tmp___3 = list_empty((struct list_head  const  *)(& steal->list));
#line 162
  if (tmp___3 != 0) {
#line 163
    goto ldv_38999;
  } else {

  }
#line 164
  __mptr___0 = (struct list_head  const  *)steal->list.prev;
#line 164
  buf = (struct ivtv_buffer *)__mptr___0;
  ldv_39003: ;
#line 152
  if ((int )buf->dma_xfer_cnt == (int )dma_xfer_cnt) {
#line 154
    goto ldv_39002;
  } else {

  }
  ldv_38999: ;
  ldv_39005: ;
#line 144
  if (bytes_available < needed_bytes) {
#line 146
    goto ldv_39004;
  } else {

  }

#line 167
  if (from_free != 0) {
#line 168
    old_length = to->length;
#line 170
    goto ldv_39009;
    ldv_39008: 
#line 171
    ivtv_queue_move_buf(s, from, to, 1);
    ldv_39009: ;
#line 170
    if (to->length - old_length < (u32 )needed_bytes) {
#line 172
      goto ldv_39008;
    } else {

    }

  } else {
#line 175
    old_bytesused = to->bytesused;
#line 177
    goto ldv_39013;
    ldv_39012: 
#line 178
    ivtv_queue_move_buf(s, from, to, to_free);
    ldv_39013: ;
#line 177
    if (to->bytesused - old_bytesused < (u32 )needed_bytes) {
#line 179
      goto ldv_39012;
    } else {

    }

  }
#line 181
  spin_unlock_irqrestore(& s->qlock, flags);
#line 182
  return (rc);
}
}
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.c"
void ivtv_flush_queues(struct ivtv_stream *s ) 
{ 


  {
#line 187
  ivtv_queue_move(s, & s->q_io, (struct ivtv_queue *)0, & s->q_free, 0);
#line 188
  ivtv_queue_move(s, & s->q_full, (struct ivtv_queue *)0, & s->q_free, 0);
#line 189
  ivtv_queue_move(s, & s->q_dma, (struct ivtv_queue *)0, & s->q_free, 0);
#line 190
  ivtv_queue_move(s, & s->q_predma, (struct ivtv_queue *)0, & s->q_free, 0);
#line 191
  return;
}
}
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.c"
int ivtv_stream_alloc(struct ivtv_stream *s ) 
{ 
  struct ivtv *itv ;
  int SGsize ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  struct ivtv_buffer *buf ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 195
  itv = s->itv;
#line 196
  SGsize = (int )(s->buffers * 12U);
#line 199
  if (s->buffers == 0U) {
#line 200
    return (0);
  } else {

  }
#line 202
  if ((ivtv_debug & 2) != 0) {
#line 202
    printk("\016%s:  info: Allocate %s%s stream: %d x %d buffers (%dkB total)\n",
           (char *)(& itv->v4l2_dev.name), s->dma != 3 ? (char *)"DMA " : (char *)"",
           s->name, s->buffers, s->buf_size, (s->buffers * s->buf_size) / 1024U);
  } else {

  }
#line 206
  tmp = kzalloc((size_t )SGsize, 720U);
#line 206
  s->sg_pending = (struct ivtv_sg_host_element *)tmp;
#line 207
  if ((unsigned long )s->sg_pending == (unsigned long )((struct ivtv_sg_host_element *)0)) {
#line 208
    printk("\v%s: Could not allocate sg_pending for %s stream\n", (char *)(& itv->v4l2_dev.name),
           s->name);
#line 209
    return (-12);
  } else {

  }
#line 211
  s->sg_pending_size = 0;
#line 213
  tmp___0 = kzalloc((size_t )SGsize, 720U);
#line 213
  s->sg_processing = (struct ivtv_sg_host_element *)tmp___0;
#line 214
  if ((unsigned long )s->sg_processing == (unsigned long )((struct ivtv_sg_host_element *)0)) {
#line 215
    printk("\v%s: Could not allocate sg_processing for %s stream\n", (char *)(& itv->v4l2_dev.name),
           s->name);
#line 216
    kfree((void const   *)s->sg_pending);
#line 217
    s->sg_pending = (struct ivtv_sg_host_element *)0;
#line 218
    return (-12);
  } else {

  }
#line 220
  s->sg_processing_size = 0;
#line 222
  tmp___1 = kzalloc(12UL, 720U);
#line 222
  s->sg_dma = (struct ivtv_sg_element *)tmp___1;
#line 224
  if ((unsigned long )s->sg_dma == (unsigned long )((struct ivtv_sg_element *)0)) {
#line 225
    printk("\v%s: Could not allocate sg_dma for %s stream\n", (char *)(& itv->v4l2_dev.name),
           s->name);
#line 226
    kfree((void const   *)s->sg_pending);
#line 227
    s->sg_pending = (struct ivtv_sg_host_element *)0;
#line 228
    kfree((void const   *)s->sg_processing);
#line 229
    s->sg_processing = (struct ivtv_sg_host_element *)0;
#line 230
    return (-12);
  } else {

  }
#line 232
  tmp___2 = ivtv_might_use_dma(s);
#line 232
  if (tmp___2 != 0) {
#line 233
    s->sg_handle = pci_map_single(itv->pdev, (void *)s->sg_dma, 12UL, 1);
#line 235
    ivtv_stream_sync_for_cpu___0(s);
  } else {

  }
#line 239
  i = 0;
#line 239
  goto ldv_39027;
  ldv_39026: 
#line 240
  tmp___3 = kzalloc(48UL, 720U);
#line 240
  buf = (struct ivtv_buffer *)tmp___3;
#line 243
  if ((unsigned long )buf == (unsigned long )((struct ivtv_buffer *)0)) {
#line 244
    goto ldv_39025;
  } else {

  }
#line 245
  tmp___4 = kmalloc((size_t )(s->buf_size + 256U), 720U);
#line 245
  buf->buf = (char *)tmp___4;
#line 246
  if ((unsigned long )buf->buf == (unsigned long )((char *)0)) {
#line 247
    kfree((void const   *)buf);
#line 248
    goto ldv_39025;
  } else {

  }
#line 250
  INIT_LIST_HEAD(& buf->list);
#line 251
  tmp___5 = ivtv_might_use_dma(s);
#line 251
  if (tmp___5 != 0) {
#line 252
    buf->dma_handle = pci_map_single((s->itv)->pdev, (void *)buf->buf, (size_t )(s->buf_size + 256U),
                                     s->dma);
#line 254
    ivtv_buf_sync_for_cpu___0(s, buf);
  } else {

  }
#line 256
  ivtv_enqueue(s, buf, & s->q_free);
#line 239
  i = i + 1;
  ldv_39027: ;
#line 239
  if ((u32 )i < s->buffers) {
#line 241
    goto ldv_39026;
  } else {

  }
  ldv_39025: ;
#line 258
  if ((u32 )i == s->buffers) {
#line 259
    return (0);
  } else {

  }
#line 260
  printk("\v%s: Couldn\'t allocate buffers for %s stream\n", (char *)(& itv->v4l2_dev.name),
         s->name);
#line 261
  ivtv_stream_free(s);
#line 262
  return (-12);
}
}
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.c"
void ivtv_stream_free(struct ivtv_stream *s ) 
{ 
  struct ivtv_buffer *buf ;
  int tmp ;

  {
#line 270
  ivtv_flush_queues(s);
#line 273
  goto ldv_39033;
  ldv_39032: 
#line 274
  tmp = ivtv_might_use_dma(s);
#line 274
  if (tmp != 0) {
#line 275
    pci_unmap_single((s->itv)->pdev, buf->dma_handle, (size_t )(s->buf_size + 256U),
                     s->dma);
  } else {

  }
#line 277
  kfree((void const   *)buf->buf);
#line 278
  kfree((void const   *)buf);
  ldv_39033: 
#line 273
  buf = ivtv_dequeue(s, & s->q_free);
#line 273
  if ((unsigned long )buf != (unsigned long )((struct ivtv_buffer *)0)) {
#line 275
    goto ldv_39032;
  } else {

  }

#line 282
  if ((unsigned long )s->sg_dma != (unsigned long )((struct ivtv_sg_element *)0)) {
#line 283
    if (s->sg_handle != 4294967295ULL) {
#line 284
      pci_unmap_single((s->itv)->pdev, s->sg_handle, 12UL, 1);
#line 286
      s->sg_handle = 4294967295ULL;
    } else {

    }
#line 288
    kfree((void const   *)s->sg_pending);
#line 289
    kfree((void const   *)s->sg_processing);
#line 290
    kfree((void const   *)s->sg_dma);
#line 291
    s->sg_pending = (struct ivtv_sg_host_element *)0;
#line 292
    s->sg_processing = (struct ivtv_sg_host_element *)0;
#line 293
    s->sg_dma = (struct ivtv_sg_element *)0;
#line 294
    s->sg_pending_size = 0;
#line 295
    s->sg_processing_size = 0;
  } else {

  }
#line 297
  return;
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.o.c.prepared"
bool ldv_queue_work_on_179(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 142
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 142
  ldv_func_res = tmp;
#line 144
  activate_work_2(ldv_func_arg3, 2);
#line 146
  return (ldv_func_res);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.o.c.prepared"
bool ldv_queue_delayed_work_on_180(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 153
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 153
  ldv_func_res = tmp;
#line 155
  activate_work_2(& ldv_func_arg3->work, 2);
#line 157
  return (ldv_func_res);
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.o.c.prepared"
bool ldv_queue_work_on_181(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 164
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 164
  ldv_func_res = tmp;
#line 166
  activate_work_2(ldv_func_arg3, 2);
#line 168
  return (ldv_func_res);
}
}
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.o.c.prepared"
void ldv_flush_workqueue_182(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 174
  flush_workqueue(ldv_func_arg1);
#line 176
  call_and_disable_all_2(2);
#line 177
  return;
}
}
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-queue.o.c.prepared"
bool ldv_queue_delayed_work_on_183(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 183
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 183
  ldv_func_res = tmp;
#line 185
  activate_work_2(& ldv_func_arg3->work, 2);
#line 187
  return (ldv_func_res);
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 102 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 104
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 106
  return;
}
}
#line 14 "include/linux/wait.h"
extern int default_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 110
extern void add_wait_queue(wait_queue_head_t * , wait_queue_t * ) ;
#line 112
extern void remove_wait_queue(wait_queue_head_t * , wait_queue_t * ) ;
#line 172 "include/linux/timer.h"
int ldv_del_timer_198(struct timer_list *ldv_func_arg1 ) ;
#line 176
int ldv_del_timer_199(struct timer_list *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_193(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_195(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_194(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_197(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_196(struct workqueue_struct *ldv_func_arg1 ) ;
#line 149 "include/media/v4l2-dev.h"
extern int __video_register_device(struct video_device * , int  , int  , int  , struct module * ) ;
#line 164 "include/media/v4l2-dev.h"
__inline static int video_register_device_no_warn(struct video_device *vdev , int type ,
                                                  int nr ) 
{ 
  int tmp ;

  {
#line 167
  tmp = __video_register_device(vdev, type, nr, 0, (vdev->fops)->owner);
#line 167
  return (tmp);
}
}
#line 172
extern void video_unregister_device(struct video_device * ) ;
#line 184
extern void video_device_release_empty(struct video_device * ) ;
#line 200 "include/media/v4l2-dev.h"
__inline static void v4l2_disable_ioctl(struct video_device *vdev , unsigned int cmd ) 
{ 


  {
#line 202
  if ((cmd & 255U) <= 191U) {
#line 203
    set_bit((long )cmd & 255L, (unsigned long volatile   *)(& vdev->valid_ioctls));
  } else {

  }
#line 204
  return;
}
}
#line 212 "include/media/v4l2-dev.h"
__inline static void video_set_drvdata(struct video_device *vdev , void *data ) 
{ 


  {
#line 214
  dev_set_drvdata(& vdev->dev, data);
#line 215
  return;
}
}
#line 333 "include/media/v4l2-ioctl.h"
extern long video_ioctl2(struct file * , unsigned int  , unsigned long  ) ;
#line 197 "include/media/cx2341x.h"
extern void cx2341x_handler_set_busy(struct cx2341x_handler * , int  ) ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
static struct v4l2_file_operations  const  ivtv_v4l2_enc_fops  = 
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
     {& __this_module, & ivtv_v4l2_read, & ivtv_v4l2_write, & ivtv_v4l2_enc_poll, & video_ioctl2,
    0, 0, 0, & ivtv_v4l2_open, & ivtv_v4l2_close};
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
static struct v4l2_file_operations  const  ivtv_v4l2_dec_fops  = 
#line 58
     {& __this_module, & ivtv_v4l2_read, & ivtv_v4l2_write, & ivtv_v4l2_dec_poll, & video_ioctl2,
    0, 0, 0, & ivtv_v4l2_open, & ivtv_v4l2_close};
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
static struct v4l2_file_operations  const  ivtv_v4l2_radio_fops  = 
#line 68
     {& __this_module, 0, 0, & ivtv_v4l2_enc_poll, & video_ioctl2, 0, 0, 0, & ivtv_v4l2_open,
    & ivtv_v4l2_close};
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
static struct __anonstruct_ivtv_stream_info_314 ivtv_stream_info[9U]  = 
#line 90
  {      {"encoder MPG", 0, 0, 2, 0, 16973825U, & ivtv_v4l2_enc_fops}, 
        {"encoder YUV", 0, 32, 2, 0, 16973825U, & ivtv_v4l2_enc_fops}, 
        {"encoder VBI", 1, 0, 2, 0, 16973904U, & ivtv_v4l2_enc_fops}, 
        {"encoder PCM", 0, 24, 2, 0, 16973824U, & ivtv_v4l2_enc_fops}, 
        {"encoder radio", 2, 0, 3, 1, 327680U, & ivtv_v4l2_radio_fops}, 
        {"decoder MPG", 0, 16, 1, 0, 16908802U, & ivtv_v4l2_dec_fops}, 
        {"decoder VBI", 1, 8, 3, 1, 16777280U, & ivtv_v4l2_enc_fops}, 
        {"decoder VOUT", 1, 16, 3, 1, 16908416U, & ivtv_v4l2_dec_fops}, 
        {"decoder YUV", 0, 48, 1, 0, 16908802U, & ivtv_v4l2_dec_fops}};
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
static void ivtv_stream_init(struct ivtv *itv , int type ) 
{ 
  struct ivtv_stream *s ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 163
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )type;
#line 166
  memset((void *)s, 0, 2320UL);
#line 169
  s->itv = itv;
#line 170
  s->type = type;
#line 171
  s->name = ivtv_stream_info[type].name;
#line 172
  s->caps = ivtv_stream_info[type].v4l2_caps;
#line 174
  if (ivtv_stream_info[type].pio != 0) {
#line 175
    s->dma = 3;
  } else {
#line 177
    s->dma = ivtv_stream_info[type].dma;
  }
#line 178
  s->buf_size = (u32 )itv->stream_buf_size[type];
#line 179
  if (s->buf_size != 0U) {
#line 180
    s->buffers = (((u32 )(itv->options.kilobytes[type] * 1024) + s->buf_size) - 1U) / s->buf_size;
  } else {

  }
#line 181
  spinlock_check(& s->qlock);
#line 181
  __raw_spin_lock_init(& s->qlock.__annonCompField18.rlock, "&(&s->qlock)->rlock",
                       & __key);
#line 182
  __init_waitqueue_head(& s->waitq, "&s->waitq", & __key___0);
#line 183
  s->sg_handle = 4294967295ULL;
#line 184
  ivtv_queue_init(& s->q_free);
#line 185
  ivtv_queue_init(& s->q_full);
#line 186
  ivtv_queue_init(& s->q_dma);
#line 187
  ivtv_queue_init(& s->q_predma);
#line 188
  ivtv_queue_init(& s->q_io);
#line 189
  return;
}
}
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
static int ivtv_prep_dev(struct ivtv *itv , int type ) 
{ 
  struct ivtv_stream *s ;
  int num_offset ;
  int num ;

  {
#line 193
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )type;
#line 194
  num_offset = ivtv_stream_info[type].num_offset;
#line 195
  num = ((int )itv->instance + ivtv_first_minor) + num_offset;
#line 200
  s->vdev.v4l2_dev = (struct v4l2_device *)0;
#line 201
  s->itv = itv;
#line 202
  s->type = type;
#line 203
  s->name = ivtv_stream_info[type].name;
#line 206
  if (type == 4 && (itv->v4l2_cap & 262144U) == 0U) {
#line 207
    return (0);
  } else {

  }
#line 208
  if (type > 4 && (itv->v4l2_cap & 2U) == 0U) {
#line 209
    return (0);
  } else {

  }
#line 213
  if (ivtv_stream_info[type].dma != 3 && itv->options.kilobytes[type] == 0) {
#line 215
    printk("\016%s: Disabled %s device\n", (char *)(& itv->v4l2_dev.name), ivtv_stream_info[type].name);
#line 216
    return (0);
  } else {

  }
#line 219
  ivtv_stream_init(itv, type);
#line 221
  snprintf((char *)(& s->vdev.name), 32UL, "%s %s", (char *)(& itv->v4l2_dev.name),
           s->name);
#line 224
  s->vdev.num = (u16 )num;
#line 225
  s->vdev.v4l2_dev = & itv->v4l2_dev;
#line 226
  if ((ivtv_stream_info[type].v4l2_caps & 130U) != 0U) {
#line 228
    s->vdev.vfl_dir = 1;
  } else {

  }
#line 229
  s->vdev.fops = ivtv_stream_info[type].fops;
#line 230
  s->vdev.ctrl_handler = itv->v4l2_dev.ctrl_handler;
#line 231
  s->vdev.release = & video_device_release_empty;
#line 232
  s->vdev.tvnorms = 16777215ULL;
#line 233
  s->vdev.lock = & itv->serialize_lock;
#line 234
  if (s->type == 6) {
#line 235
    v4l2_disable_ioctl(& s->vdev, 1077171746U);
#line 236
    v4l2_disable_ioctl(& s->vdev, 2150913569U);
#line 237
    v4l2_disable_ioctl(& s->vdev, 3224655425U);
#line 238
    v4l2_disable_ioctl(& s->vdev, 3226490394U);
#line 239
    v4l2_disable_ioctl(& s->vdev, 3221509671U);
#line 240
    v4l2_disable_ioctl(& s->vdev, 2147767846U);
#line 241
    v4l2_disable_ioctl(& s->vdev, 1076647481U);
#line 242
    v4l2_disable_ioctl(& s->vdev, 3224131128U);
#line 243
    v4l2_disable_ioctl(& s->vdev, 1079268894U);
#line 244
    v4l2_disable_ioctl(& s->vdev, 3226752541U);
#line 245
    v4l2_disable_ioctl(& s->vdev, 1074288152U);
  } else {

  }
#line 247
  ivtv_set_funcs(& s->vdev);
#line 248
  return (0);
}
}
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
int ivtv_streams_setup(struct ivtv *itv ) 
{ 
  int type ;
  int tmp ;
  int tmp___0 ;

  {
#line 257
  type = 0;
#line 257
  goto ldv_39284;
  ldv_39283: 
#line 259
  tmp = ivtv_prep_dev(itv, type);
#line 259
  if (tmp != 0) {
#line 260
    goto ldv_39281;
  } else {

  }
#line 262
  if ((unsigned long )itv->streams[type].vdev.v4l2_dev == (unsigned long )((struct v4l2_device *)0)) {
#line 263
    goto ldv_39282;
  } else {

  }
#line 266
  tmp___0 = ivtv_stream_alloc((struct ivtv_stream *)(& itv->streams) + (unsigned long )type);
#line 266
  if (tmp___0 != 0) {
#line 267
    goto ldv_39281;
  } else {

  }
  ldv_39282: 
#line 257
  type = type + 1;
  ldv_39284: ;
#line 257
  if (type <= 8) {
#line 259
    goto ldv_39283;
  } else {

  }
  ldv_39281: ;
#line 269
  if (type == 9) {
#line 270
    return (0);
  } else {

  }
#line 273
  ivtv_streams_cleanup(itv);
#line 274
  return (-12);
}
}
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
static int ivtv_reg_dev(struct ivtv *itv , int type ) 
{ 
  struct ivtv_stream *s ;
  int vfl_type ;
  char const   *name ;
  int num ;
  struct ivtv_stream *s_mpg ;
  int tmp ;

  {
#line 279
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )type;
#line 280
  vfl_type = ivtv_stream_info[type].vfl_type;
#line 284
  if ((unsigned long )s->vdev.v4l2_dev == (unsigned long )((struct v4l2_device *)0)) {
#line 285
    return (0);
  } else {

  }
#line 287
  num = (int )s->vdev.num;
#line 289
  if (type != 0) {
#line 290
    s_mpg = (struct ivtv_stream *)(& itv->streams);
#line 292
    if ((unsigned long )s_mpg->vdev.v4l2_dev != (unsigned long )((struct v4l2_device *)0)) {
#line 293
      num = (int )s_mpg->vdev.num + ivtv_stream_info[type].num_offset;
    } else {

    }
  } else {

  }
#line 295
  video_set_drvdata(& s->vdev, (void *)s);
#line 298
  tmp = video_register_device_no_warn(& s->vdev, vfl_type, num);
#line 298
  if (tmp != 0) {
#line 299
    printk("\v%s: Couldn\'t register v4l2 device for %s (device node number %d)\n",
           (char *)(& itv->v4l2_dev.name), s->name, num);
#line 301
    return (-12);
  } else {

  }
#line 303
  name = video_device_node_name(& s->vdev);
#line 305
  switch (vfl_type) {
  case 0: 
#line 307
  printk("\016%s: Registered device %s for %s (%d kB)\n", (char *)(& itv->v4l2_dev.name),
         name, s->name, itv->options.kilobytes[type]);
#line 309
  goto ldv_39295;
  case 2: 
#line 311
  printk("\016%s: Registered device %s for %s\n", (char *)(& itv->v4l2_dev.name),
         name, s->name);
#line 313
  goto ldv_39295;
  case 1: ;
#line 315
  if (itv->options.kilobytes[type] != 0) {
#line 316
    printk("\016%s: Registered device %s for %s (%d kB)\n", (char *)(& itv->v4l2_dev.name),
           name, s->name, itv->options.kilobytes[type]);
  } else {
#line 319
    printk("\016%s: Registered device %s for %s\n", (char *)(& itv->v4l2_dev.name),
           name, s->name);
  }
#line 321
  goto ldv_39295;
  }
  ldv_39295: ;
#line 323
  return (0);
}
}
#line 327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
int ivtv_streams_register(struct ivtv *itv ) 
{ 
  int type ;
  int err ;
  int tmp ;

  {
#line 330
  err = 0;
#line 333
  type = 0;
#line 333
  goto ldv_39304;
  ldv_39303: 
#line 334
  tmp = ivtv_reg_dev(itv, type);
#line 334
  err = tmp | err;
#line 333
  type = type + 1;
  ldv_39304: ;
#line 333
  if (type <= 8) {
#line 335
    goto ldv_39303;
  } else {

  }

#line 336
  if (err == 0) {
#line 337
    return (0);
  } else {

  }
#line 340
  ivtv_streams_cleanup(itv);
#line 341
  return (-12);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
void ivtv_streams_cleanup(struct ivtv *itv ) 
{ 
  int type ;
  struct video_device *vdev ;

  {
#line 350
  type = 0;
#line 350
  goto ldv_39313;
  ldv_39312: 
#line 351
  vdev = & itv->streams[type].vdev;
#line 353
  if ((unsigned long )vdev->v4l2_dev == (unsigned long )((struct v4l2_device *)0)) {
#line 354
    goto ldv_39311;
  } else {

  }
#line 356
  video_unregister_device(vdev);
#line 357
  ivtv_stream_free((struct ivtv_stream *)(& itv->streams) + (unsigned long )type);
#line 358
  itv->streams[type].vdev.v4l2_dev = (struct v4l2_device *)0;
  ldv_39311: 
#line 350
  type = type + 1;
  ldv_39313: ;
#line 350
  if (type <= 8) {
#line 352
    goto ldv_39312;
  } else {

  }

#line 357
  return;
}
}
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
static void ivtv_vbi_setup(struct ivtv *itv ) 
{ 
  int raw ;
  int tmp ;
  u32 data[16U] ;
  int lines ;
  int i ;
  int valid ;

  {
#line 364
  tmp = ivtv_raw_vbi((struct ivtv  const  *)itv);
#line 364
  raw = tmp;
#line 370
  ivtv_vapi(itv, 183, 5, 65535, 0, 0, 0, 0);
#line 373
  if (raw != 0) {
#line 374
    if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 374
      if ((unsigned long )((itv->sd_video)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->vbi)->s_raw_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                    struct v4l2_vbi_format * ))0)) {
#line 374
        (*((((itv->sd_video)->ops)->vbi)->s_raw_fmt))(itv->sd_video, & itv->vbi.in.fmt.vbi);
      } else {

      }
    } else {

    }
  } else
#line 376
  if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 376
    if ((unsigned long )((itv->sd_video)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->vbi)->s_sliced_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                     struct v4l2_sliced_vbi_format * ))0)) {
#line 376
      (*((((itv->sd_video)->ops)->vbi)->s_sliced_fmt))(itv->sd_video, & itv->vbi.in.fmt.sliced);
    } else {

    }
  } else {

  }
#line 383
  if (raw != 0) {
#line 384
    lines = (int )(itv->vbi.count * 2U);
  } else {
#line 386
    lines = (unsigned int )itv->is_60hz != 0U ? 24 : 38;
#line 387
    if ((unsigned int )itv->is_60hz != 0U && (int )itv->hw_flags & 1) {
#line 388
      lines = lines + 2;
    } else {

    }
  }
#line 391
  itv->vbi.enc_size = (raw != 0 ? itv->vbi.raw_size : itv->vbi.sliced_size) * (u32 )lines;
#line 395
  data[0] = (u32 )(raw | 48386);
#line 398
  data[1] = 1U;
#line 400
  data[2] = raw == 0 ? (itv->vbi.raw_size / itv->vbi.enc_size) * 4U : 4U;
#line 408
  if ((int )itv->hw_flags & 1) {
#line 410
    if (raw != 0) {
#line 411
      data[3] = 543170656U;
#line 412
      data[4] = 812658800U;
    } else {
#line 414
      data[3] = 2968563952U;
#line 415
      data[4] = 2699075808U;
    }
#line 418
    data[5] = (u32 )lines;
#line 420
    data[6] = raw != 0 ? itv->vbi.raw_size : itv->vbi.sliced_size;
  } else {
#line 423
    if (raw != 0) {
#line 424
      data[3] = 623207010U;
#line 425
      data[4] = 947879807U;
    } else {
#line 427
      data[3] = 2880171244U;
#line 428
      data[4] = 3069309425U;
    }
#line 431
    data[5] = (u32 )lines;
#line 433
    data[6] = itv->vbi.enc_size / (u32 )lines;
  }
#line 436
  if ((ivtv_debug & 2) != 0) {
#line 436
    printk("\016%s:  info: Setup VBI API header 0x%08x pkts %d buffs %d ln %d sz %d\n",
           (char *)(& itv->v4l2_dev.name), data[0], data[1], data[2], data[5], data[6]);
  } else {

  }
#line 440
  ivtv_api(itv, 200, 7, (u32 *)(& data));
#line 443
  itv->vbi.enc_start = data[2];
#line 444
  itv->vbi.fpi = (int )data[0];
#line 445
  if (itv->vbi.fpi == 0) {
#line 446
    itv->vbi.fpi = 1;
  } else {

  }
#line 448
  if ((ivtv_debug & 2) != 0) {
#line 448
    printk("\016%s:  info: Setup VBI start 0x%08x frames %d fpi %d\n", (char *)(& itv->v4l2_dev.name),
           itv->vbi.enc_start, data[1], itv->vbi.fpi);
  } else {

  }
#line 453
  i = 2;
#line 453
  goto ldv_39324;
  ldv_39323: ;
#line 456
  if ((unsigned int )itv->is_60hz != 0U) {
#line 457
    valid = i > 9 && i <= 21;
  } else {
#line 459
    valid = i > 5 && i <= 23;
  }
#line 461
  ivtv_vapi(itv, 183, 5, i + -1, valid, 0, 0, 0);
#line 463
  ivtv_vapi(itv, 183, 5, (unsigned int )(i + -1) | 2147483648U, valid, 0, 0, 0);
#line 453
  i = i + 1;
  ldv_39324: ;
#line 453
  if (i <= 24) {
#line 455
    goto ldv_39323;
  } else {

  }

#line 460
  return;
}
}
#line 475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
int ivtv_start_v4l2_encode_stream(struct ivtv_stream *s ) 
{ 
  u32 data[16U] ;
  struct ivtv *itv ;
  int captype ;
  int subtype ;
  int enable_passthrough ;
  u64 tmp ;
  s32 tmp___0 ;
  int digitizer ;
  s32 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 478
  itv = s->itv;
#line 479
  captype = 0;
#line 479
  subtype = 0;
#line 480
  enable_passthrough = 0;
#line 482
  if ((unsigned long )s->vdev.v4l2_dev == (unsigned long )((struct v4l2_device *)0)) {
#line 483
    return (-22);
  } else {

  }
#line 485
  if ((ivtv_debug & 2) != 0) {
#line 485
    printk("\016%s:  info: Start encoder stream %s\n", (char *)(& itv->v4l2_dev.name),
           s->name);
  } else {

  }
#line 487
  switch (s->type) {
  case 0: 
#line 489
  captype = 0;
#line 490
  subtype = 3;
#line 493
  if (itv->output_mode == 4) {
#line 494
    ivtv_passthrough_mode(itv, 0);
#line 495
    enable_passthrough = 1;
  } else {

  }
#line 497
  tmp = 0ULL;
#line 497
  itv->vbi_data_inserted = tmp;
#line 497
  itv->mpg_data_received = tmp;
#line 498
  itv->dualwatch_jiffies = jiffies;
#line 499
  tmp___0 = v4l2_ctrl_g_ctrl(itv->cxhdl.__annonCompField92.audio_mode);
#line 499
  itv->dualwatch_stereo_mode = (u32 )tmp___0;
#line 500
  itv->search_pack_header = 0;
#line 501
  goto ldv_39335;
  case 1: ;
#line 504
  if (itv->output_mode == 4) {
#line 505
    captype = 2;
#line 506
    subtype = 11;
#line 507
    goto ldv_39335;
  } else {

  }
#line 509
  captype = 1;
#line 510
  subtype = 1;
#line 511
  goto ldv_39335;
  case 3: 
#line 513
  captype = 1;
#line 514
  subtype = 2;
#line 515
  goto ldv_39335;
  case 2: 
#line 517
  captype = 1;
#line 518
  subtype = 4;
#line 520
  itv->vbi.frame = 0U;
#line 521
  itv->vbi.inserted_frame = 0U;
#line 522
  memset((void *)(& itv->vbi.sliced_mpeg_size), 0, 128UL);
#line 524
  goto ldv_39335;
  default: ;
#line 526
  return (-22);
  }
  ldv_39335: 
#line 528
  s->subtype = subtype;
#line 529
  s->buffers_stolen = 0U;
#line 532
  clear_bit(7L, (unsigned long volatile   *)(& s->s_flags));
#line 534
  tmp___3 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 534
  if (tmp___3 == 0) {
#line 543
    ivtv_vapi(itv, 201, 2, 1, 1);
#line 546
    ivtv_vapi(itv, 219, 1, 0);
#line 553
    ivtv_vapi(itv, 220, 2, 3, (unsigned int )itv->has_cx23415 == 0U);
#line 554
    ivtv_vapi(itv, 220, 2, 8, 0);
#line 555
    ivtv_vapi(itv, 220, 2, 4, 1);
#line 556
    ivtv_vapi(itv, 220, 1, 12);
#line 559
    ivtv_vapi(itv, 215, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
#line 562
    if (((unsigned int )(itv->card)->hw_all & 2050U) != 0U) {
#line 563
      digitizer = 241;
    } else
#line 564
    if (((unsigned int )(itv->card)->hw_all & 256U) != 0U) {
#line 565
      digitizer = 239;
    } else {
#line 567
      digitizer = 320;
    }
#line 569
    ivtv_vapi(itv, 214, 2, digitizer, digitizer);
#line 572
    if ((itv->v4l2_cap & 16U) != 0U) {
#line 573
      ivtv_vbi_setup(itv);
    } else {

    }
#line 577
    ivtv_vapi_result(itv, (u32 *)(& data), 199, 2, 7, 400);
#line 578
    itv->pgm_info_offset = data[0];
#line 579
    itv->pgm_info_num = data[1];
#line 580
    itv->pgm_info_write_idx = 0U;
#line 581
    itv->pgm_info_read_idx = 0U;
#line 583
    if ((ivtv_debug & 2) != 0) {
#line 583
      printk("\016%s:  info: PGM Index at 0x%08x with %d elements\n", (char *)(& itv->v4l2_dev.name),
             itv->pgm_info_offset, itv->pgm_info_num);
    } else {

    }
#line 587
    cx2341x_handler_setup(& itv->cxhdl);
#line 590
    tmp___2 = constant_test_bit(5L, (unsigned long const volatile   *)(& itv->i_flags));
#line 590
    if (tmp___2 != 0) {
#line 591
      tmp___1 = v4l2_ctrl_g_ctrl(itv->cxhdl.__annonCompField95.video_mute_yuv);
#line 591
      ivtv_vapi(itv, 217, 1, (tmp___1 << 8) | 1);
    } else {

    }
  } else {

  }
#line 596
  if ((unsigned int )itv->has_cx23415 != 0U) {
#line 596
    tmp___4 = test_and_set_bit(6L, (unsigned long volatile   *)(& itv->i_flags));
#line 596
    if (tmp___4 == 0) {
#line 598
      ivtv_vapi(itv, 213, 4, 0, 1, 268435456, -1);
#line 599
      ivtv_clear_irq_mask(itv, 268435456U);
    } else {

    }
  } else {

  }
#line 602
  tmp___5 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 602
  if (tmp___5 == 0) {
#line 604
    ivtv_set_irq_mask(itv, 3221225472U);
#line 606
    clear_bit(4L, (unsigned long volatile   *)(& itv->i_flags));
#line 608
    cx2341x_handler_set_busy(& itv->cxhdl, 1);
#line 612
    if ((unsigned long )itv->sd_audio != (unsigned long )((struct v4l2_subdev *)0)) {
#line 612
      if ((unsigned long )((itv->sd_audio)->ops)->audio != (unsigned long )((struct v4l2_subdev_audio_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_audio)->ops)->audio)->s_stream != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                         int  ))0)) {
#line 612
        (*((((itv->sd_audio)->ops)->audio)->s_stream))(itv->sd_audio, 1);
      } else {

      }
    } else {

    }
#line 614
    if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 614
      if ((unsigned long )((itv->sd_video)->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->video)->s_stream != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                         int  ))0)) {
#line 614
        (*((((itv->sd_video)->ops)->video)->s_stream))(itv->sd_video, 0);
      } else {

      }
    } else {

    }
#line 615
    ivtv_msleep_timeout(300U, 0);
#line 616
    ivtv_vapi(itv, 205, 0);
#line 617
    if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 617
      if ((unsigned long )((itv->sd_video)->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->video)->s_stream != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                         int  ))0)) {
#line 617
        (*((((itv->sd_video)->ops)->video)->s_stream))(itv->sd_video, 1);
      } else {

      }
    } else {

    }
  } else {

  }
#line 621
  tmp___6 = ivtv_vapi(itv, 129, 2, captype, subtype);
#line 621
  if (tmp___6 != 0) {
#line 623
    if (ivtv_debug & 1) {
#line 623
      printk("\016%s:  warn: Error starting capture!\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 624
    return (-22);
  } else {

  }
#line 628
  if (enable_passthrough != 0) {
#line 629
    ivtv_passthrough_mode(itv, 1);
  } else {

  }
#line 632
  if (s->type == 2) {
#line 633
    ivtv_clear_irq_mask(itv, 536870912U);
  } else {
#line 635
    ivtv_clear_irq_mask(itv, 3221225472U);
  }
#line 638
  atomic_inc(& itv->capturing);
#line 639
  return (0);
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
static char const   __kstrtab_ivtv_start_v4l2_encode_stream[30U]  = 
#line 641
  {      'i',      'v',      't',      'v', 
        '_',      's',      't',      'a', 
        'r',      't',      '_',      'v', 
        '4',      'l',      '2',      '_', 
        'e',      'n',      'c',      'o', 
        'd',      'e',      '_',      's', 
        't',      'r',      'e',      'a', 
        'm',      '\000'};
#line 641
struct kernel_symbol  const  __ksymtab_ivtv_start_v4l2_encode_stream ;
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
struct kernel_symbol  const  __ksymtab_ivtv_start_v4l2_encode_stream  =    {(unsigned long )(& ivtv_start_v4l2_encode_stream), (char const   *)(& __kstrtab_ivtv_start_v4l2_encode_stream)};
#line 643 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
static int ivtv_setup_v4l2_decode_stream(struct ivtv_stream *s ) 
{ 
  u32 data[16U] ;
  struct ivtv *itv ;
  int datatype ;
  u16 width ;
  u16 height ;
  int tmp ;
  int tmp___0 ;

  {
#line 646
  itv = s->itv;
#line 651
  if ((unsigned long )s->vdev.v4l2_dev == (unsigned long )((struct v4l2_device *)0)) {
#line 652
    return (-22);
  } else {

  }
#line 654
  if ((ivtv_debug & 2) != 0) {
#line 654
    printk("\016%s:  info: Setting some initial decoder settings\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 656
  width = itv->cxhdl.width;
#line 657
  height = itv->cxhdl.height;
#line 660
  ivtv_vapi(itv, 22, 2, (int )itv->audio_bilingual_mode, (int )itv->audio_stereo_mode);
#line 663
  ivtv_vapi(itv, 24, 1, 0);
#line 666
  ivtv_vapi(itv, 30, 1, 1);
#line 669
  ivtv_vapi_result(itv, (u32 *)(& data), 25, 1, 1);
#line 670
  itv->vbi.dec_start = data[0];
#line 672
  if ((ivtv_debug & 2) != 0) {
#line 672
    printk("\016%s:  info: Decoder VBI RE-Insert start 0x%08x size 0x%08x\n", (char *)(& itv->v4l2_dev.name),
           itv->vbi.dec_start, data[1]);
  } else {

  }
#line 679
  switch (s->type) {
  case 8: ;
#line 681
  if (itv->output_mode == 4) {
#line 682
    datatype = 1;
  } else {
#line 685
    datatype = 2;
#line 686
    width = 720U;
#line 687
    height = (unsigned int )itv->is_out_50hz != 0U ? 576U : 480U;
  }
#line 689
  if ((ivtv_debug & 2) != 0) {
#line 689
    printk("\016%s:  info: Setup DEC YUV Stream data[0] = %d\n", (char *)(& itv->v4l2_dev.name),
           datatype);
  } else {

  }
#line 690
  goto ldv_39357;
  case 5: ;
  default: 
#line 693
  datatype = 0;
#line 694
  goto ldv_39357;
  }
  ldv_39357: 
#line 696
  tmp = ivtv_vapi(itv, 26, 4, datatype, (int )width, (int )height, itv->cxhdl.audio_properties);
#line 696
  if (tmp != 0) {
#line 698
    if (ivtv_debug & 1) {
#line 698
      printk("\016%s:  warn: Couldn\'t initialize decoder source\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
  } else {

  }
#line 702
  ivtv_msleep_timeout(10U, 0);
#line 705
  tmp___0 = ivtv_firmware_check(itv, (char *)"ivtv_setup_v4l2_decode_stream");
#line 705
  return (tmp___0);
}
}
#line 708 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
int ivtv_start_v4l2_decode_stream(struct ivtv_stream *s , int gop_offset ) 
{ 
  struct ivtv *itv ;
  int rc ;
  int tmp ;

  {
#line 710
  itv = s->itv;
#line 713
  if ((unsigned long )s->vdev.v4l2_dev == (unsigned long )((struct v4l2_device *)0)) {
#line 714
    return (-22);
  } else {

  }
#line 716
  tmp = test_and_set_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 716
  if (tmp != 0) {
#line 717
    return (0);
  } else {

  }
#line 719
  if ((ivtv_debug & 2) != 0) {
#line 719
    printk("\016%s:  info: Starting decode stream %s (gop_offset %d)\n", (char *)(& itv->v4l2_dev.name),
           s->name, gop_offset);
  } else {

  }
#line 721
  rc = ivtv_setup_v4l2_decode_stream(s);
#line 722
  if (rc < 0) {
#line 723
    clear_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 724
    return (rc);
  } else {

  }
#line 728
  ivtv_vapi(itv, 8, 1, 65536);
#line 731
  clear_bit(7L, (unsigned long volatile   *)(& s->s_flags));
#line 734
  writel(0U, (void volatile   *)(& (itv->dec_mbox.mbox + 8UL)->data));
#line 735
  writel(0U, (void volatile   *)(& (itv->dec_mbox.mbox + 8UL)->data) + 1U);
#line 736
  writel(0U, (void volatile   *)(& (itv->dec_mbox.mbox + 8UL)->data) + 2U);
#line 737
  writel(0U, (void volatile   *)(& (itv->dec_mbox.mbox + 8UL)->data) + 3U);
#line 738
  writel(0U, (void volatile   *)(& (itv->dec_mbox.mbox + 9UL)->data));
#line 739
  writel(0U, (void volatile   *)(& (itv->dec_mbox.mbox + 9UL)->data) + 1U);
#line 740
  writel(0U, (void volatile   *)(& (itv->dec_mbox.mbox + 9UL)->data) + 2U);
#line 741
  writel(0U, (void volatile   *)(& (itv->dec_mbox.mbox + 9UL)->data) + 3U);
#line 744
  ivtv_vapi(itv, 23, 4, 0, 1, 16777216, -1);
#line 747
  ivtv_vapi(itv, 1, 2, gop_offset, 0);
#line 750
  ivtv_msleep_timeout(10U, 0);
#line 753
  ivtv_clear_irq_mask(itv, 20971520U);
#line 754
  if ((ivtv_debug & 64) != 0) {
#line 754
    printk("\016%s:  irq: IRQ Mask is now: 0x%08x\n", (char *)(& itv->v4l2_dev.name),
           itv->irqmask);
  } else {

  }
#line 757
  atomic_inc(& itv->decoding);
#line 758
  return (0);
}
}
#line 761 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
void ivtv_stop_all_captures(struct ivtv *itv ) 
{ 
  int i ;
  struct ivtv_stream *s ;
  int tmp ;

  {
#line 765
  i = 8;
#line 765
  goto ldv_39373;
  ldv_39372: 
#line 766
  s = (struct ivtv_stream *)(& itv->streams) + (unsigned long )i;
#line 768
  if ((unsigned long )s->vdev.v4l2_dev == (unsigned long )((struct v4l2_device *)0)) {
#line 769
    goto ldv_39371;
  } else {

  }
#line 770
  tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 770
  if (tmp != 0) {
#line 771
    ivtv_stop_v4l2_encode_stream(s, 0);
  } else {

  }
  ldv_39371: 
#line 765
  i = i - 1;
  ldv_39373: ;
#line 765
  if (i >= 0) {
#line 767
    goto ldv_39372;
  } else {

  }

#line 772
  return;
}
}
#line 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
int ivtv_stop_v4l2_encode_stream(struct ivtv_stream *s , int gop_end ) 
{ 
  struct ivtv *itv ;
  wait_queue_t wait ;
  struct task_struct *tmp ;
  int cap_type ;
  int stopmode ;
  int tmp___0 ;
  unsigned long duration ;
  unsigned long then ;
  struct task_struct *tmp___1 ;
  long volatile   __ret ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  unsigned long tmp___8 ;
  int tmp___9 ;
  struct task_struct *tmp___10 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___11 ;
  struct task_struct *tmp___12 ;
  struct task_struct *tmp___13 ;
  struct task_struct *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 778
  itv = s->itv;
#line 779
  tmp = get_current();
#line 779
  wait.flags = 0U;
#line 779
  wait.private = (void *)tmp;
#line 779
  wait.func = & default_wake_function;
#line 779
  wait.task_list.next = (struct list_head *)0;
#line 779
  wait.task_list.prev = (struct list_head *)0;
#line 783
  if ((unsigned long )s->vdev.v4l2_dev == (unsigned long )((struct v4l2_device *)0)) {
#line 784
    return (-22);
  } else {

  }
#line 789
  if ((ivtv_debug & 2) != 0) {
#line 789
    printk("\016%s:  info: Stop Capture\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 791
  if (s->type == 7) {
#line 792
    return (0);
  } else {

  }
#line 793
  tmp___0 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 793
  if (tmp___0 == 0) {
#line 794
    return (0);
  } else {

  }
#line 796
  switch (s->type) {
  case 1: 
#line 798
  cap_type = 1;
#line 799
  goto ldv_39384;
  case 3: 
#line 801
  cap_type = 1;
#line 802
  goto ldv_39384;
  case 2: 
#line 804
  cap_type = 1;
#line 805
  goto ldv_39384;
  case 0: ;
  default: 
#line 808
  cap_type = 0;
#line 809
  goto ldv_39384;
  }
  ldv_39384: ;
#line 813
  if (s->type == 0 && gop_end != 0) {
#line 814
    stopmode = 0;
  } else {
#line 816
    stopmode = 1;
  }
#line 821
  ivtv_vapi(itv, 130, 3, stopmode, cap_type, s->subtype);
#line 823
  tmp___15 = constant_test_bit(6L, (unsigned long const volatile   *)(& s->s_flags));
#line 823
  if (tmp___15 == 0) {
#line 824
    if (s->type == 0 && gop_end != 0) {
#line 827
      then = jiffies;
#line 829
      add_wait_queue(& itv->eos_waitq, & wait);
#line 831
      tmp___1 = get_current();
#line 831
      tmp___1->task_state_change = 0UL;
#line 831
      __ret = 1L;
#line 831
      switch (8UL) {
      case 1UL: 
#line 831
      tmp___2 = get_current();
#line 831
      __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___2->state): : "memory",
                           "cc");
#line 831
      goto ldv_39393;
      case 2UL: 
#line 831
      tmp___3 = get_current();
#line 831
      __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                           "cc");
#line 831
      goto ldv_39393;
      case 4UL: 
#line 831
      tmp___4 = get_current();
#line 831
      __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                           "cc");
#line 831
      goto ldv_39393;
      case 8UL: 
#line 831
      tmp___5 = get_current();
#line 831
      __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___5->state): : "memory",
                           "cc");
#line 831
      goto ldv_39393;
      default: 
#line 831
      __xchg_wrong_size();
      }
      ldv_39393: ;
#line 834
      goto ldv_39406;
      ldv_39405: 
#line 837
      tmp___6 = msecs_to_jiffies(10U);
#line 837
      schedule_timeout((long )tmp___6);
      ldv_39406: 
#line 834
      tmp___7 = constant_test_bit(4L, (unsigned long const volatile   *)(& itv->i_flags));
#line 835
      if (tmp___7 == 0) {
#line 835
        tmp___8 = msecs_to_jiffies(2000U);
#line 835
        if ((long )((unsigned long )jiffies - (tmp___8 + then)) < 0L) {
#line 837
          goto ldv_39405;
        } else {
#line 840
          goto ldv_39407;
        }
      } else {

      }
      ldv_39407: 
#line 847
      duration = ((unsigned long )jiffies - then) * 4UL;
#line 849
      tmp___9 = constant_test_bit(4L, (unsigned long const volatile   *)(& itv->i_flags));
#line 849
      if (tmp___9 == 0) {
#line 850
        if (ivtv_debug & 1) {
#line 850
          printk("\016%s:  warn: %s: EOS interrupt not received! stopping anyway.\n",
                 (char *)(& itv->v4l2_dev.name), s->name);
        } else {

        }
#line 851
        if (ivtv_debug & 1) {
#line 851
          printk("\016%s:  warn: %s: waited %lu ms.\n", (char *)(& itv->v4l2_dev.name),
                 s->name, duration);
        } else {

        }
      } else
#line 853
      if ((ivtv_debug & 2) != 0) {
#line 853
        printk("\016%s:  info: %s: EOS took %lu ms to occur.\n", (char *)(& itv->v4l2_dev.name),
               s->name, duration);
      } else {

      }
#line 855
      tmp___10 = get_current();
#line 855
      tmp___10->task_state_change = 0UL;
#line 855
      __ret___0 = 0L;
#line 855
      switch (8UL) {
      case 1UL: 
#line 855
      tmp___11 = get_current();
#line 855
      __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (tmp___11->state): : "memory",
                           "cc");
#line 855
      goto ldv_39410;
      case 2UL: 
#line 855
      tmp___12 = get_current();
#line 855
      __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (tmp___12->state): : "memory",
                           "cc");
#line 855
      goto ldv_39410;
      case 4UL: 
#line 855
      tmp___13 = get_current();
#line 855
      __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (tmp___13->state): : "memory",
                           "cc");
#line 855
      goto ldv_39410;
      case 8UL: 
#line 855
      tmp___14 = get_current();
#line 855
      __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (tmp___14->state): : "memory",
                           "cc");
#line 855
      goto ldv_39410;
      default: 
#line 855
      __xchg_wrong_size();
      }
      ldv_39410: 
#line 856
      remove_wait_queue(& itv->eos_waitq, & wait);
#line 857
      set_bit(7L, (unsigned long volatile   *)(& s->s_flags));
    } else {

    }
#line 861
    ivtv_msleep_timeout(100U, 0);
  } else {

  }
#line 864
  atomic_dec(& itv->capturing);
#line 867
  clear_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 869
  if (s->type == 2) {
#line 870
    ivtv_set_irq_mask(itv, 536870912U);
  } else {

  }
#line 872
  tmp___16 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 872
  if (tmp___16 > 0) {
#line 873
    return (0);
  } else {

  }
#line 876
  cx2341x_handler_set_busy(& itv->cxhdl, 0);
#line 879
  ivtv_set_irq_mask(itv, 3221225472U);
#line 880
  ldv_del_timer_198(& itv->dma_timer);
#line 883
  tmp___17 = test_and_clear_bit(6L, (unsigned long volatile   *)(& itv->i_flags));
#line 883
  if (tmp___17 != 0) {
#line 886
    ivtv_vapi(itv, 213, 4, 0, 0, 268435456, -1);
#line 887
    ivtv_set_irq_mask(itv, 268435456U);
  } else {

  }
#line 892
  ivtv_vapi(itv, 130, 3, 1, 2, 7);
#line 894
  __wake_up(& s->waitq, 3U, 1, (void *)0);
#line 896
  return (0);
}
}
#line 898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
static char const   __kstrtab_ivtv_stop_v4l2_encode_stream[29U]  = 
#line 898
  {      'i',      'v',      't',      'v', 
        '_',      's',      't',      'o', 
        'p',      '_',      'v',      '4', 
        'l',      '2',      '_',      'e', 
        'n',      'c',      'o',      'd', 
        'e',      '_',      's',      't', 
        'r',      'e',      'a',      'm', 
        '\000'};
#line 898
struct kernel_symbol  const  __ksymtab_ivtv_stop_v4l2_encode_stream ;
#line 898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
struct kernel_symbol  const  __ksymtab_ivtv_stop_v4l2_encode_stream  =    {(unsigned long )(& ivtv_stop_v4l2_encode_stream), (char const   *)(& __kstrtab_ivtv_stop_v4l2_encode_stream)};
#line 900 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
int ivtv_stop_v4l2_decode_stream(struct ivtv_stream *s , int flags , u64 pts ) 
{ 
  struct v4l2_event ev ;
  struct ivtv *itv ;
  int tmp ;
  u32 tmp___0 ;
  u32 data[16U] ;
  int tmp___1 ;

  {
#line 902
  ev.type = 2U;
#line 902
  ev.u.data[0] = (unsigned char)0;
#line 902
  ev.u.data[1] = (unsigned char)0;
#line 902
  ev.u.data[2] = (unsigned char)0;
#line 902
  ev.u.data[3] = (unsigned char)0;
#line 902
  ev.u.data[4] = (unsigned char)0;
#line 902
  ev.u.data[5] = (unsigned char)0;
#line 902
  ev.u.data[6] = (unsigned char)0;
#line 902
  ev.u.data[7] = (unsigned char)0;
#line 902
  ev.u.data[8] = (unsigned char)0;
#line 902
  ev.u.data[9] = (unsigned char)0;
#line 902
  ev.u.data[10] = (unsigned char)0;
#line 902
  ev.u.data[11] = (unsigned char)0;
#line 902
  ev.u.data[12] = (unsigned char)0;
#line 902
  ev.u.data[13] = (unsigned char)0;
#line 902
  ev.u.data[14] = (unsigned char)0;
#line 902
  ev.u.data[15] = (unsigned char)0;
#line 902
  ev.u.data[16] = (unsigned char)0;
#line 902
  ev.u.data[17] = (unsigned char)0;
#line 902
  ev.u.data[18] = (unsigned char)0;
#line 902
  ev.u.data[19] = (unsigned char)0;
#line 902
  ev.u.data[20] = (unsigned char)0;
#line 902
  ev.u.data[21] = (unsigned char)0;
#line 902
  ev.u.data[22] = (unsigned char)0;
#line 902
  ev.u.data[23] = (unsigned char)0;
#line 902
  ev.u.data[24] = (unsigned char)0;
#line 902
  ev.u.data[25] = (unsigned char)0;
#line 902
  ev.u.data[26] = (unsigned char)0;
#line 902
  ev.u.data[27] = (unsigned char)0;
#line 902
  ev.u.data[28] = (unsigned char)0;
#line 902
  ev.u.data[29] = (unsigned char)0;
#line 902
  ev.u.data[30] = (unsigned char)0;
#line 902
  ev.u.data[31] = (unsigned char)0;
#line 902
  ev.u.data[32] = (unsigned char)0;
#line 902
  ev.u.data[33] = (unsigned char)0;
#line 902
  ev.u.data[34] = (unsigned char)0;
#line 902
  ev.u.data[35] = (unsigned char)0;
#line 902
  ev.u.data[36] = (unsigned char)0;
#line 902
  ev.u.data[37] = (unsigned char)0;
#line 902
  ev.u.data[38] = (unsigned char)0;
#line 902
  ev.u.data[39] = (unsigned char)0;
#line 902
  ev.u.data[40] = (unsigned char)0;
#line 902
  ev.u.data[41] = (unsigned char)0;
#line 902
  ev.u.data[42] = (unsigned char)0;
#line 902
  ev.u.data[43] = (unsigned char)0;
#line 902
  ev.u.data[44] = (unsigned char)0;
#line 902
  ev.u.data[45] = (unsigned char)0;
#line 902
  ev.u.data[46] = (unsigned char)0;
#line 902
  ev.u.data[47] = (unsigned char)0;
#line 902
  ev.u.data[48] = (unsigned char)0;
#line 902
  ev.u.data[49] = (unsigned char)0;
#line 902
  ev.u.data[50] = (unsigned char)0;
#line 902
  ev.u.data[51] = (unsigned char)0;
#line 902
  ev.u.data[52] = (unsigned char)0;
#line 902
  ev.u.data[53] = (unsigned char)0;
#line 902
  ev.u.data[54] = (unsigned char)0;
#line 902
  ev.u.data[55] = (unsigned char)0;
#line 902
  ev.u.data[56] = (unsigned char)0;
#line 902
  ev.u.data[57] = (unsigned char)0;
#line 902
  ev.u.data[58] = (unsigned char)0;
#line 902
  ev.u.data[59] = (unsigned char)0;
#line 902
  ev.u.data[60] = (unsigned char)0;
#line 902
  ev.u.data[61] = (unsigned char)0;
#line 902
  ev.u.data[62] = (unsigned char)0;
#line 902
  ev.u.data[63] = (unsigned char)0;
#line 902
  ev.pending = 0U;
#line 902
  ev.sequence = 0U;
#line 902
  ev.timestamp.tv_sec = 0L;
#line 902
  ev.timestamp.tv_nsec = 0L;
#line 902
  ev.id = 0U;
#line 902
  ev.reserved[0] = 0U;
#line 902
  ev.reserved[1] = 0U;
#line 902
  ev.reserved[2] = 0U;
#line 902
  ev.reserved[3] = 0U;
#line 902
  ev.reserved[4] = 0U;
#line 902
  ev.reserved[5] = 0U;
#line 902
  ev.reserved[6] = 0U;
#line 902
  ev.reserved[7] = 0U;
#line 905
  itv = s->itv;
#line 907
  if ((unsigned long )s->vdev.v4l2_dev == (unsigned long )((struct v4l2_device *)0)) {
#line 908
    return (-22);
  } else {

  }
#line 910
  if (s->type != 8 && s->type != 5) {
#line 911
    return (-22);
  } else {

  }
#line 913
  tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 913
  if (tmp == 0) {
#line 914
    return (0);
  } else {

  }
#line 916
  if ((ivtv_debug & 2) != 0) {
#line 916
    printk("\016%s:  info: Stop Decode at %llu, flags: %x\n", (char *)(& itv->v4l2_dev.name),
           pts, flags);
  } else {

  }
#line 919
  if ((flags & 2) == 0 || pts != 0ULL) {
#line 920
    tmp___0 = 0U;
#line 923
    if (pts != 0ULL) {
#line 924
      ivtv_vapi(itv, 2, 3, 0, (unsigned int )pts, (unsigned int )(pts >> 32));
    } else {

    }
    ldv_39434: 
#line 929
    ivtv_vapi_result(itv, (u32 *)(& data), 9, 0);
#line 930
    if (s->q_full.buffers + s->q_dma.buffers == 0U) {
#line 931
      if (data[3] == tmp___0) {
#line 932
        goto ldv_39433;
      } else {

      }
#line 933
      tmp___0 = data[3];
    } else {

    }
#line 935
    tmp___1 = ivtv_msleep_timeout(100U, 1);
#line 935
    if (tmp___1 != 0) {
#line 936
      goto ldv_39433;
    } else {

    }
#line 937
    goto ldv_39434;
    ldv_39433: ;
  } else {

  }
#line 939
  ivtv_vapi(itv, 2, 3, flags & 1, 0, 0);
#line 942
  ivtv_vapi(itv, 23, 4, 0, 0, 16777216, -1);
#line 944
  ivtv_set_irq_mask(itv, 20971520U);
#line 945
  ldv_del_timer_199(& itv->dma_timer);
#line 947
  clear_bit(2L, (unsigned long volatile   *)(& s->s_flags));
#line 948
  clear_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 949
  ivtv_flush_queues(s);
#line 952
  ivtv_msleep_timeout(40U, 0);
#line 955
  atomic_dec(& itv->decoding);
#line 957
  set_bit(28L, (unsigned long volatile   *)(& itv->i_flags));
#line 958
  __wake_up(& itv->event_waitq, 3U, 1, (void *)0);
#line 959
  v4l2_event_queue(& s->vdev, & ev);
#line 962
  __wake_up(& s->waitq, 3U, 1, (void *)0);
#line 964
  return (0);
}
}
#line 967 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.c"
int ivtv_passthrough_mode(struct ivtv *itv , int enable ) 
{ 
  struct ivtv_stream *yuv_stream ;
  struct ivtv_stream *dec_stream ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 969
  yuv_stream = (struct ivtv_stream *)(& itv->streams) + 1UL;
#line 970
  dec_stream = (struct ivtv_stream *)(& itv->streams) + 8UL;
#line 972
  if ((unsigned long )yuv_stream->vdev.v4l2_dev == (unsigned long )((struct v4l2_device *)0) || (unsigned long )dec_stream->vdev.v4l2_dev == (unsigned long )((struct v4l2_device *)0)) {
#line 973
    return (-22);
  } else {

  }
#line 975
  if ((ivtv_debug & 2) != 0) {
#line 975
    printk("\016%s:  info: ivtv ioctl: Select passthrough mode\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 979
  if (enable != 0) {
#line 980
    if (itv->output_mode == 4) {
#line 981
      return (0);
    } else {

    }
#line 983
    tmp = ivtv_set_output_mode(itv, 4);
#line 983
    if (tmp != 4) {
#line 984
      return (-16);
    } else {

    }
#line 987
    set_bit(6L, (unsigned long volatile   *)(& dec_stream->s_flags));
#line 988
    set_bit(4L, (unsigned long volatile   *)(& dec_stream->s_flags));
#line 991
    ivtv_setup_v4l2_decode_stream(dec_stream);
#line 994
    ivtv_vapi(itv, 1, 2, 0, 1);
#line 995
    atomic_inc(& itv->decoding);
#line 998
    tmp___0 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 998
    if (tmp___0 == 0) {
#line 999
      cx2341x_handler_setup(& itv->cxhdl);
#line 1000
      cx2341x_handler_set_busy(& itv->cxhdl, 1);
    } else {

    }
#line 1004
    ivtv_vapi(itv, 129, 2, 2, 11);
#line 1005
    atomic_inc(& itv->capturing);
#line 1006
    return (0);
  } else {

  }
#line 1009
  if (itv->output_mode != 4) {
#line 1010
    return (0);
  } else {

  }
#line 1013
  ivtv_vapi(itv, 130, 3, 1, 2, 11);
#line 1014
  ivtv_vapi(itv, 2, 3, 1, 0, 0);
#line 1016
  atomic_dec(& itv->capturing);
#line 1017
  atomic_dec(& itv->decoding);
#line 1018
  clear_bit(6L, (unsigned long volatile   *)(& dec_stream->s_flags));
#line 1019
  clear_bit(4L, (unsigned long volatile   *)(& dec_stream->s_flags));
#line 1020
  itv->output_mode = 0;
#line 1021
  tmp___1 = atomic_read((atomic_t const   *)(& itv->capturing));
#line 1021
  if (tmp___1 == 0) {
#line 1022
    cx2341x_handler_set_busy(& itv->cxhdl, 0);
  } else {

  }
#line 1024
  return (0);
}
}
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
int ldv_retval_4  ;
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
int ldv_retval_1  ;
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
int ldv_retval_3  ;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
void ldv_initialize_v4l2_file_operations_6(void) 
{ 
  void *tmp ;

  {
#line 120
  tmp = __VERIFIER_nondet_pointer();
#line 120
  ivtv_v4l2_enc_fops_group0 = (struct file *)tmp;
#line 121
  return;
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
void ldv_initialize_v4l2_file_operations_5(void) 
{ 
  void *tmp ;

  {
#line 124
  tmp = __VERIFIER_nondet_pointer();
#line 124
  ivtv_v4l2_dec_fops_group0 = (struct file *)tmp;
#line 125
  return;
}
}
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
void ldv_initialize_v4l2_file_operations_4(void) 
{ 
  void *tmp ;

  {
#line 128
  tmp = __VERIFIER_nondet_pointer();
#line 128
  ivtv_v4l2_radio_fops_group0 = (struct file *)tmp;
#line 129
  return;
}
}
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
void ldv_main_exported_6(void) 
{ 
  char *ldvarg99 ;
  void *tmp ;
  char *ldvarg96 ;
  void *tmp___0 ;
  unsigned int ldvarg92 ;
  loff_t *ldvarg97 ;
  void *tmp___1 ;
  size_t ldvarg98 ;
  struct poll_table_struct *ldvarg93 ;
  void *tmp___2 ;
  unsigned long ldvarg91 ;
  loff_t *ldvarg94 ;
  void *tmp___3 ;
  size_t ldvarg95 ;
  int tmp___4 ;

  {
#line 132
  tmp = ldv_init_zalloc(1UL);
#line 132
  ldvarg99 = (char *)tmp;
#line 133
  tmp___0 = ldv_init_zalloc(1UL);
#line 133
  ldvarg96 = (char *)tmp___0;
#line 135
  tmp___1 = ldv_init_zalloc(8UL);
#line 135
  ldvarg97 = (loff_t *)tmp___1;
#line 137
  tmp___2 = ldv_init_zalloc(16UL);
#line 137
  ldvarg93 = (struct poll_table_struct *)tmp___2;
#line 139
  tmp___3 = ldv_init_zalloc(8UL);
#line 139
  ldvarg94 = (loff_t *)tmp___3;
#line 134
  ldv_memset((void *)(& ldvarg92), 0, 4UL);
#line 136
  ldv_memset((void *)(& ldvarg98), 0, 8UL);
#line 138
  ldv_memset((void *)(& ldvarg91), 0, 8UL);
#line 140
  ldv_memset((void *)(& ldvarg95), 0, 8UL);
#line 142
  tmp___4 = __VERIFIER_nondet_int();
#line 142
  switch (tmp___4) {
  case 0: ;
#line 145
  if (ldv_state_variable_6 == 2) {
#line 147
    ivtv_v4l2_close(ivtv_v4l2_enc_fops_group0);
#line 149
    ldv_state_variable_6 = 1;
#line 150
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 153
  goto ldv_39466;
  case 1: ;
#line 156
  if (ldv_state_variable_6 == 1) {
#line 158
    ldv_retval_1 = ivtv_v4l2_open(ivtv_v4l2_enc_fops_group0);
#line 160
    if (ldv_retval_1 == 0) {
#line 161
      ldv_state_variable_6 = 2;
#line 162
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 166
  goto ldv_39466;
  case 2: ;
#line 169
  if (ldv_state_variable_6 == 2) {
#line 171
    ivtv_v4l2_write(ivtv_v4l2_enc_fops_group0, (char const   *)ldvarg99, ldvarg98,
                    ldvarg97);
#line 173
    ldv_state_variable_6 = 2;
  } else {

  }
#line 176
  goto ldv_39466;
  case 3: ;
#line 179
  if (ldv_state_variable_6 == 2) {
#line 181
    ivtv_v4l2_read(ivtv_v4l2_enc_fops_group0, ldvarg96, ldvarg95, ldvarg94);
#line 183
    ldv_state_variable_6 = 2;
  } else {

  }
#line 186
  goto ldv_39466;
  case 4: ;
#line 189
  if (ldv_state_variable_6 == 1) {
#line 191
    ivtv_v4l2_enc_poll(ivtv_v4l2_enc_fops_group0, ldvarg93);
#line 193
    ldv_state_variable_6 = 1;
  } else {

  }
#line 196
  if (ldv_state_variable_6 == 2) {
#line 198
    ivtv_v4l2_enc_poll(ivtv_v4l2_enc_fops_group0, ldvarg93);
#line 200
    ldv_state_variable_6 = 2;
  } else {

  }
#line 203
  goto ldv_39466;
  case 5: ;
#line 206
  if (ldv_state_variable_6 == 1) {
#line 208
    video_ioctl2(ivtv_v4l2_enc_fops_group0, ldvarg92, ldvarg91);
#line 210
    ldv_state_variable_6 = 1;
  } else {

  }
#line 213
  if (ldv_state_variable_6 == 2) {
#line 215
    video_ioctl2(ivtv_v4l2_enc_fops_group0, ldvarg92, ldvarg91);
#line 217
    ldv_state_variable_6 = 2;
  } else {

  }
#line 220
  goto ldv_39466;
  default: 
#line 221
  ldv_stop();
  }
  ldv_39466: ;
#line 225
  return;
}
}
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
void ldv_main_exported_4(void) 
{ 
  struct poll_table_struct *ldvarg114 ;
  void *tmp ;
  unsigned int ldvarg113 ;
  unsigned long ldvarg112 ;
  int tmp___0 ;

  {
#line 228
  tmp = ldv_init_zalloc(16UL);
#line 228
  ldvarg114 = (struct poll_table_struct *)tmp;
#line 229
  ldv_memset((void *)(& ldvarg113), 0, 4UL);
#line 230
  ldv_memset((void *)(& ldvarg112), 0, 8UL);
#line 232
  tmp___0 = __VERIFIER_nondet_int();
#line 232
  switch (tmp___0) {
  case 0: ;
#line 235
  if (ldv_state_variable_4 == 2) {
#line 237
    ivtv_v4l2_close(ivtv_v4l2_radio_fops_group0);
#line 239
    ldv_state_variable_4 = 1;
#line 240
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 243
  goto ldv_39480;
  case 1: ;
#line 246
  if (ldv_state_variable_4 == 1) {
#line 248
    ldv_retval_3 = ivtv_v4l2_open(ivtv_v4l2_radio_fops_group0);
#line 250
    if (ldv_retval_3 == 0) {
#line 251
      ldv_state_variable_4 = 2;
#line 252
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 256
  goto ldv_39480;
  case 2: ;
#line 259
  if (ldv_state_variable_4 == 1) {
#line 261
    ivtv_v4l2_enc_poll(ivtv_v4l2_radio_fops_group0, ldvarg114);
#line 263
    ldv_state_variable_4 = 1;
  } else {

  }
#line 266
  if (ldv_state_variable_4 == 2) {
#line 268
    ivtv_v4l2_enc_poll(ivtv_v4l2_radio_fops_group0, ldvarg114);
#line 270
    ldv_state_variable_4 = 2;
  } else {

  }
#line 273
  goto ldv_39480;
  case 3: ;
#line 276
  if (ldv_state_variable_4 == 1) {
#line 278
    video_ioctl2(ivtv_v4l2_radio_fops_group0, ldvarg113, ldvarg112);
#line 280
    ldv_state_variable_4 = 1;
  } else {

  }
#line 283
  if (ldv_state_variable_4 == 2) {
#line 285
    video_ioctl2(ivtv_v4l2_radio_fops_group0, ldvarg113, ldvarg112);
#line 287
    ldv_state_variable_4 = 2;
  } else {

  }
#line 290
  goto ldv_39480;
  default: 
#line 291
  ldv_stop();
  }
  ldv_39480: ;
#line 295
  return;
}
}
#line 297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
void ldv_main_exported_5(void) 
{ 
  loff_t *ldvarg125 ;
  void *tmp ;
  unsigned long ldvarg119 ;
  unsigned int ldvarg120 ;
  size_t ldvarg123 ;
  size_t ldvarg126 ;
  loff_t *ldvarg122 ;
  void *tmp___0 ;
  char *ldvarg124 ;
  void *tmp___1 ;
  char *ldvarg127 ;
  void *tmp___2 ;
  struct poll_table_struct *ldvarg121 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 298
  tmp = ldv_init_zalloc(8UL);
#line 298
  ldvarg125 = (loff_t *)tmp;
#line 303
  tmp___0 = ldv_init_zalloc(8UL);
#line 303
  ldvarg122 = (loff_t *)tmp___0;
#line 304
  tmp___1 = ldv_init_zalloc(1UL);
#line 304
  ldvarg124 = (char *)tmp___1;
#line 305
  tmp___2 = ldv_init_zalloc(1UL);
#line 305
  ldvarg127 = (char *)tmp___2;
#line 306
  tmp___3 = ldv_init_zalloc(16UL);
#line 306
  ldvarg121 = (struct poll_table_struct *)tmp___3;
#line 299
  ldv_memset((void *)(& ldvarg119), 0, 8UL);
#line 300
  ldv_memset((void *)(& ldvarg120), 0, 4UL);
#line 301
  ldv_memset((void *)(& ldvarg123), 0, 8UL);
#line 302
  ldv_memset((void *)(& ldvarg126), 0, 8UL);
#line 308
  tmp___4 = __VERIFIER_nondet_int();
#line 308
  switch (tmp___4) {
  case 0: ;
#line 311
  if (ldv_state_variable_5 == 2) {
#line 313
    ivtv_v4l2_close(ivtv_v4l2_dec_fops_group0);
#line 315
    ldv_state_variable_5 = 1;
#line 316
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 319
  goto ldv_39498;
  case 1: ;
#line 322
  if (ldv_state_variable_5 == 1) {
#line 324
    ldv_retval_4 = ivtv_v4l2_open(ivtv_v4l2_dec_fops_group0);
#line 326
    if (ldv_retval_4 == 0) {
#line 327
      ldv_state_variable_5 = 2;
#line 328
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 332
  goto ldv_39498;
  case 2: ;
#line 335
  if (ldv_state_variable_5 == 2) {
#line 337
    ivtv_v4l2_write(ivtv_v4l2_dec_fops_group0, (char const   *)ldvarg127, ldvarg126,
                    ldvarg125);
#line 339
    ldv_state_variable_5 = 2;
  } else {

  }
#line 342
  goto ldv_39498;
  case 3: ;
#line 345
  if (ldv_state_variable_5 == 2) {
#line 347
    ivtv_v4l2_read(ivtv_v4l2_dec_fops_group0, ldvarg124, ldvarg123, ldvarg122);
#line 349
    ldv_state_variable_5 = 2;
  } else {

  }
#line 352
  goto ldv_39498;
  case 4: ;
#line 355
  if (ldv_state_variable_5 == 1) {
#line 357
    ivtv_v4l2_dec_poll(ivtv_v4l2_dec_fops_group0, ldvarg121);
#line 359
    ldv_state_variable_5 = 1;
  } else {

  }
#line 362
  if (ldv_state_variable_5 == 2) {
#line 364
    ivtv_v4l2_dec_poll(ivtv_v4l2_dec_fops_group0, ldvarg121);
#line 366
    ldv_state_variable_5 = 2;
  } else {

  }
#line 369
  goto ldv_39498;
  case 5: ;
#line 372
  if (ldv_state_variable_5 == 1) {
#line 374
    video_ioctl2(ivtv_v4l2_dec_fops_group0, ldvarg120, ldvarg119);
#line 376
    ldv_state_variable_5 = 1;
  } else {

  }
#line 379
  if (ldv_state_variable_5 == 2) {
#line 381
    video_ioctl2(ivtv_v4l2_dec_fops_group0, ldvarg120, ldvarg119);
#line 383
    ldv_state_variable_5 = 2;
  } else {

  }
#line 386
  goto ldv_39498;
  default: 
#line 387
  ldv_stop();
  }
  ldv_39498: ;
#line 391
  return;
}
}
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
bool ldv_queue_work_on_193(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 420
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 420
  ldv_func_res = tmp;
#line 422
  activate_work_2(ldv_func_arg3, 2);
#line 424
  return (ldv_func_res);
}
}
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
bool ldv_queue_delayed_work_on_194(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 431
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 431
  ldv_func_res = tmp;
#line 433
  activate_work_2(& ldv_func_arg3->work, 2);
#line 435
  return (ldv_func_res);
}
}
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
bool ldv_queue_work_on_195(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 442
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 442
  ldv_func_res = tmp;
#line 444
  activate_work_2(ldv_func_arg3, 2);
#line 446
  return (ldv_func_res);
}
}
#line 449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
void ldv_flush_workqueue_196(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 452
  flush_workqueue(ldv_func_arg1);
#line 454
  call_and_disable_all_2(2);
#line 455
  return;
}
}
#line 457 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
bool ldv_queue_delayed_work_on_197(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 461
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 461
  ldv_func_res = tmp;
#line 463
  activate_work_2(& ldv_func_arg3->work, 2);
#line 465
  return (ldv_func_res);
}
}
#line 468 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
int ldv_del_timer_198(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 472
  tmp = del_timer(ldv_func_arg1);
#line 472
  ldv_func_res = tmp;
#line 474
  disable_suitable_timer_3(ldv_func_arg1);
#line 476
  return (ldv_func_res);
}
}
#line 479 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-streams.o.c.prepared"
int ldv_del_timer_199(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 483
  tmp = del_timer(ldv_func_arg1);
#line 483
  ldv_func_res = tmp;
#line 485
  disable_suitable_timer_3(ldv_func_arg1);
#line 487
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 369 "./arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 829 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 831
  __edi = __edi;
#line 831
  __esi = __esi;
#line 831
  __edx = __edx;
#line 831
  __ecx = __ecx;
#line 831
  __eax = __eax;
#line 831
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 831
  if (tmp != 0L) {
#line 831
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4860: ;
#line 831
    goto ldv_4860;
  } else {

  }
#line 831
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 831
  __ret = __eax;
#line 831
  return (__ret);
}
}
#line 834 "./arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_restore(unsigned long f ) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 836
  __edi = __edi;
#line 836
  __esi = __esi;
#line 836
  __edx = __edx;
#line 836
  __ecx = __ecx;
#line 836
  __eax = __eax;
#line 836
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.restore_fl.func == (unsigned long )((void *)0),
                         0L);
#line 836
  if (tmp != 0L) {
#line 836
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (836), "i" (12UL));
    ldv_4870: ;
#line 836
    goto ldv_4870;
  } else {

  }
#line 836
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.restore_fl.func), [paravirt_clobber] "i" (1),
                       "D" (f): "memory", "cc");
#line 838
  return;
}
}
#line 839 "./arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_disable(void) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 841
  __edi = __edi;
#line 841
  __esi = __esi;
#line 841
  __edx = __edx;
#line 841
  __ecx = __ecx;
#line 841
  __eax = __eax;
#line 841
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.irq_disable.func == (unsigned long )((void *)0),
                         0L);
#line 841
  if (tmp != 0L) {
#line 841
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (841), "i" (12UL));
    ldv_4879: ;
#line 841
    goto ldv_4879;
  } else {

  }
#line 841
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (45UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.irq_disable.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 843
  return;
}
}
#line 849 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_irq_save(void) 
{ 
  unsigned long f ;

  {
#line 853
  f = arch_local_save_flags();
#line 854
  arch_local_irq_disable();
#line 855
  return (f);
}
}
#line 151 "./arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 153
  return ((flags & 512UL) == 0UL);
}
}
#line 20 "include/linux/irqflags.h"
extern void trace_hardirqs_on(void) ;
#line 21
extern void trace_hardirqs_off(void) ;
#line 8 "./arch/x86/include/asm/preempt.h"
extern int __preempt_count ;
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6059;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6059;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6059;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6059;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6059: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6071;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6071;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6071;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6071;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6071: ;
#line 79
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_211(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_213(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_212(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_215(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_214(struct workqueue_struct *ldv_func_arg1 ) ;
#line 322 "include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 325 "include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 327
  tmp = alloc_pages_current(gfp_mask, order);
#line 327
  return (tmp);
}
}
#line 366
extern void __free_pages(struct page * , unsigned int  ) ;
#line 257 "include/linux/page-flags.h"
__inline static int PageHighMem(struct page  const  *page ) 
{ 


  {
#line 257
  return (0);
}
}
#line 569 "include/linux/mm.h"
extern void put_page(struct page * ) ;
#line 924 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 926
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 1196
extern long get_user_pages_unlocked(struct task_struct * , struct mm_struct * , unsigned long  ,
                                    unsigned long  , int  , int  , struct page ** ) ;
#line 82 "include/linux/scatterlist.h"
__inline static void sg_assign_page(struct scatterlist *sg , struct page *page ) 
{ 
  unsigned long page_link ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 84
  page_link = sg->page_link & 3UL;
#line 90
  tmp = ldv__builtin_expect(((unsigned long )page & 3UL) != 0UL, 0L);
#line 90
  if (tmp != 0L) {
#line 90
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (90), "i" (12UL));
    ldv_29431: ;
#line 90
    goto ldv_29431;
  } else {

  }
#line 92
  tmp___0 = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 92
  if (tmp___0 != 0L) {
#line 92
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (92), "i" (12UL));
    ldv_29432: ;
#line 92
    goto ldv_29432;
  } else {

  }
#line 93
  tmp___1 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 93
  if (tmp___1 != 0L) {
#line 93
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (93), "i" (12UL));
    ldv_29433: ;
#line 93
    goto ldv_29433;
  } else {

  }
#line 95
  sg->page_link = page_link | (unsigned long )page;
#line 96
  return;
}
}
#line 112 "include/linux/scatterlist.h"
__inline static void sg_set_page(struct scatterlist *sg , struct page *page , unsigned int len ,
                                 unsigned int offset ) 
{ 


  {
#line 115
  sg_assign_page(sg, page);
#line 116
  sg->offset = offset;
#line 117
  sg->length = len;
#line 118
  return;
}
}
#line 120 "include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 123
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 123
  if (tmp != 0L) {
#line 123
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (123), "i" (12UL));
    ldv_29443: ;
#line 123
    goto ldv_29443;
  } else {

  }
#line 124
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 124
  if (tmp___0 != 0L) {
#line 124
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (124), "i" (12UL));
    ldv_29444: ;
#line 124
    goto ldv_29444;
  } else {

  }
#line 126
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 243 "include/linux/scatterlist.h"
__inline static void *sg_virt(struct scatterlist *sg ) 
{ 
  struct page *tmp ;
  void *tmp___0 ;

  {
#line 245
  tmp = sg_page(sg);
#line 245
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
#line 245
  return (tmp___0 + (unsigned long )sg->offset);
}
}
#line 250
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 47 "include/linux/dma-debug.h"
extern void debug_dma_map_sg(struct device * , struct scatterlist * , int  , int  ,
                             int  ) ;
#line 50
extern void debug_dma_unmap_sg(struct device * , struct scatterlist * , int  , int  ) ;
#line 46 "include/asm-generic/dma-mapping-common.h"
__inline static int dma_map_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                     int nents , enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int i ;
  int ents ;
  struct scatterlist *s ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 50
  tmp = get_dma_ops(dev);
#line 50
  ops = tmp;
#line 54
  i = 0;
#line 54
  s = sg;
#line 54
  goto ldv_30235;
  ldv_30234: 
#line 55
  tmp___0 = sg_virt(s);
#line 55
  kmemcheck_mark_initialized(tmp___0, s->length);
#line 54
  i = i + 1;
#line 54
  s = sg_next(s);
  ldv_30235: ;
#line 54
  if (i < nents) {
#line 56
    goto ldv_30234;
  } else {

  }
#line 56
  tmp___1 = valid_dma_direction((int )dir);
#line 56
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 56
  if (tmp___2 != 0L) {
#line 56
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (56), "i" (12UL));
    ldv_30237: ;
#line 56
    goto ldv_30237;
  } else {

  }
#line 57
  ents = (*(ops->map_sg))(dev, sg, nents, dir, attrs);
#line 58
  tmp___3 = ldv__builtin_expect(ents < 0, 0L);
#line 58
  if (tmp___3 != 0L) {
#line 58
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (58), "i" (12UL));
    ldv_30238: ;
#line 58
    goto ldv_30238;
  } else {

  }
#line 59
  debug_dma_map_sg(dev, sg, nents, ents, (int )dir);
#line 61
  return (ents);
}
}
#line 64 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                        int nents , enum dma_data_direction dir ,
                                        struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 68
  tmp = get_dma_ops(dev);
#line 68
  ops = tmp;
#line 70
  tmp___0 = valid_dma_direction((int )dir);
#line 70
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 70
  if (tmp___1 != 0L) {
#line 70
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (70), "i" (12UL));
    ldv_30247: ;
#line 70
    goto ldv_30247;
  } else {

  }
#line 71
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
#line 72
  if ((unsigned long )ops->unmap_sg != (unsigned long )((void (*)(struct device * ,
                                                                  struct scatterlist * ,
                                                                  int  , enum dma_data_direction  ,
                                                                  struct dma_attrs * ))0)) {
#line 73
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
  } else {

  }
#line 74
  return;
}
}
#line 114 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device___0(struct device *dev , dma_addr_t addr ,
                                                    size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 118
  tmp = get_dma_ops(dev);
#line 118
  ops = tmp;
#line 120
  tmp___0 = valid_dma_direction((int )dir);
#line 120
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 120
  if (tmp___1 != 0L) {
#line 120
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (120), "i" (12UL));
    ldv_30281: ;
#line 120
    goto ldv_30281;
  } else {

  }
#line 121
  if ((unsigned long )ops->sync_single_for_device != (unsigned long )((void (*)(struct device * ,
                                                                                dma_addr_t  ,
                                                                                size_t  ,
                                                                                enum dma_data_direction  ))0)) {
#line 122
    (*(ops->sync_single_for_device))(dev, addr, size, dir);
  } else {

  }
#line 123
  debug_dma_sync_single_for_device(dev, addr, size, (int )dir);
#line 124
  return;
}
}
#line 65 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_map_sg(struct pci_dev *hwdev , struct scatterlist *sg , int nents ,
                               int direction ) 
{ 
  int tmp ;

  {
#line 68
  tmp = dma_map_sg_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                         sg, nents, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 68
  return (tmp);
}
}
#line 72 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_sg(struct pci_dev *hwdev , struct scatterlist *sg ,
                                  int nents , int direction ) 
{ 


  {
#line 75
  dma_unmap_sg_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                     sg, nents, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 76
  return;
}
}
#line 86 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_device___0(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                        size_t size , int direction ) 
{ 


  {
#line 89
  dma_sync_single_for_device___0((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                                 dma_handle, size, (enum dma_data_direction )direction);
#line 90
  return;
}
}
#line 7 "include/linux/uaccess.h"
__inline static void pagefault_disabled_inc(void) 
{ 
  struct task_struct *tmp ;

  {
#line 9
  tmp = get_current();
#line 9
  tmp->pagefault_disabled = tmp->pagefault_disabled + 1;
#line 10
  return;
}
}
#line 12 "include/linux/uaccess.h"
__inline static void pagefault_disabled_dec(void) 
{ 
  struct task_struct *tmp ;
  int __ret_warn_on ;
  struct task_struct *tmp___0 ;
  long tmp___1 ;

  {
#line 14
  tmp = get_current();
#line 14
  tmp->pagefault_disabled = tmp->pagefault_disabled - 1;
#line 15
  tmp___0 = get_current();
#line 15
  __ret_warn_on = tmp___0->pagefault_disabled < 0;
#line 15
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 15
  if (tmp___1 != 0L) {
#line 15
    warn_slowpath_null("include/linux/uaccess.h", 15);
  } else {

  }
#line 15
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 17
  return;
}
}
#line 25 "include/linux/uaccess.h"
__inline static void pagefault_disable(void) 
{ 


  {
#line 27
  pagefault_disabled_inc();
#line 32
  __asm__  volatile   ("": : : "memory");
#line 33
  return;
}
}
#line 35 "include/linux/uaccess.h"
__inline static void pagefault_enable(void) 
{ 


  {
#line 41
  __asm__  volatile   ("": : : "memory");
#line 42
  pagefault_disabled_dec();
#line 43
  return;
}
}
#line 66 "include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page ) 
{ 
  void *tmp ;

  {
#line 68
  __preempt_count_add(1);
#line 68
  __asm__  volatile   ("": : : "memory");
#line 69
  pagefault_disable();
#line 70
  tmp = lowmem_page_address((struct page  const  *)page);
#line 70
  return (tmp);
}
}
#line 74 "include/linux/highmem.h"
__inline static void __kunmap_atomic(void *addr ) 
{ 


  {
#line 76
  pagefault_enable();
#line 77
  __asm__  volatile   ("": : : "memory");
#line 77
  __preempt_count_sub(1);
#line 78
  return;
}
}
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-udma.h"
void ivtv_udma_get_page_info(struct ivtv_dma_page_info *dma_page , unsigned long first ,
                             unsigned long size ) ;
#line 26
int ivtv_udma_fill_sg_list(struct ivtv_user_dma *dma , struct ivtv_dma_page_info *dma_page ,
                           int map_offset ) ;
#line 27
void ivtv_udma_fill_sg_array(struct ivtv_user_dma *dma , u32 buffer_offset , u32 buffer_offset_2 ,
                             u32 split ) ;
#line 36 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-udma.h"
__inline static void ivtv_udma_sync_for_device(struct ivtv *itv ) 
{ 


  {
#line 38
  pci_dma_sync_single_for_device___0(itv->pdev, itv->udma.SG_handle, 8448UL, 1);
#line 39
  return;
}
}
#line 42 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/ivtv/ivtv-udma.h"
__inline static void ivtv_udma_sync_for_cpu(struct ivtv *itv ) 
{ 


  {
#line 44
  pci_dma_sync_single_for_cpu___0(itv->pdev, itv->udma.SG_handle, 8448UL, 1);
#line 45
  return;
}
}
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-udma.c"
void ivtv_udma_get_page_info(struct ivtv_dma_page_info *dma_page , unsigned long first ,
                             unsigned long size ) 
{ 


  {
#line 28
  dma_page->uaddr = first & 0xfffffffffffff000UL;
#line 29
  dma_page->offset = (unsigned int )first & 4095U;
#line 30
  dma_page->tail = ((((unsigned int )first + (unsigned int )size) - 1U) & 4095U) + 1U;
#line 31
  dma_page->first = first >> 12;
#line 32
  dma_page->last = ((first + size) - 1UL) >> 12;
#line 33
  dma_page->page_count = (int )(((unsigned int )dma_page->last - (unsigned int )dma_page->first) + 1U);
#line 34
  if (dma_page->page_count == 1) {
#line 34
    dma_page->tail = dma_page->tail - dma_page->offset;
  } else {

  }
#line 35
  return;
}
}
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-udma.c"
int ivtv_udma_fill_sg_list(struct ivtv_user_dma *dma , struct ivtv_dma_page_info *dma_page ,
                           int map_offset ) 
{ 
  int i ;
  int offset ;
  unsigned long flags ;
  unsigned int len ;
  void *src ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 42
  if (map_offset < 0) {
#line 43
    return (map_offset);
  } else {

  }
#line 45
  offset = (int )dma_page->offset;
#line 48
  i = 0;
#line 48
  goto ldv_38942;
  ldv_38941: 
#line 49
  len = dma_page->page_count + -1 == i ? dma_page->tail : 4096U - (unsigned int )offset;
#line 52
  tmp___2 = PageHighMem((struct page  const  *)dma->map[map_offset]);
#line 52
  if (tmp___2 != 0) {
#line 55
    if ((unsigned long )dma->bouncemap[map_offset] == (unsigned long )((struct page *)0)) {
#line 56
      dma->bouncemap[map_offset] = alloc_pages(208U, 0U);
    } else {

    }
#line 57
    if ((unsigned long )dma->bouncemap[map_offset] == (unsigned long )((struct page *)0)) {
#line 58
      return (-1);
    } else {

    }
#line 59
    flags = arch_local_irq_save();
#line 59
    trace_hardirqs_off();
#line 60
    tmp = kmap_atomic(dma->map[map_offset]);
#line 60
    src = tmp + (unsigned long )offset;
#line 61
    tmp___0 = lowmem_page_address((struct page  const  *)dma->bouncemap[map_offset]);
#line 61
    memcpy(tmp___0 + (unsigned long )offset, (void const   *)src, (size_t )len);
#line 62
    __kunmap_atomic(src);
#line 63
    tmp___1 = arch_irqs_disabled_flags(flags);
#line 63
    if (tmp___1 != 0) {
#line 63
      arch_local_irq_restore(flags);
#line 63
      trace_hardirqs_off();
    } else {
#line 63
      trace_hardirqs_on();
#line 63
      arch_local_irq_restore(flags);
    }
#line 64
    sg_set_page((struct scatterlist *)(& dma->SGlist) + (unsigned long )map_offset,
                dma->bouncemap[map_offset], len, (unsigned int )offset);
  } else {
#line 67
    sg_set_page((struct scatterlist *)(& dma->SGlist) + (unsigned long )map_offset,
                dma->map[map_offset], len, (unsigned int )offset);
  }
#line 69
  offset = 0;
#line 70
  map_offset = map_offset + 1;
#line 48
  i = i + 1;
  ldv_38942: ;
#line 48
  if (dma_page->page_count > i) {
#line 50
    goto ldv_38941;
  } else {

  }

#line 72
  return (map_offset);
}
}
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-udma.c"
void ivtv_udma_fill_sg_array(struct ivtv_user_dma *dma , u32 buffer_offset , u32 buffer_offset_2 ,
                             u32 split ) 
{ 
  int i ;
  struct scatterlist *sg ;

  {
#line 79
  i = 0;
#line 79
  sg = (struct scatterlist *)(& dma->SGlist);
#line 79
  goto ldv_38953;
  ldv_38952: 
#line 80
  dma->SGarray[i].size = sg->dma_length;
#line 81
  dma->SGarray[i].src = (unsigned int )sg->dma_address;
#line 82
  dma->SGarray[i].dst = buffer_offset;
#line 83
  buffer_offset = sg->dma_length + buffer_offset;
#line 85
  split = split - sg->dma_length;
#line 86
  if (split == 0U) {
#line 87
    buffer_offset = buffer_offset_2;
  } else {

  }
#line 79
  i = i + 1;
#line 79
  sg = sg_next(sg);
  ldv_38953: ;
#line 79
  if (dma->SG_length > i) {
#line 81
    goto ldv_38952;
  } else {

  }

#line 86
  return;
}
}
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-udma.c"
void ivtv_udma_alloc(struct ivtv *itv ) 
{ 


  {
#line 94
  if (itv->udma.SG_handle == 0ULL) {
#line 96
    itv->udma.SG_handle = pci_map_single(itv->pdev, (void *)(& itv->udma.SGarray),
                                         8448UL, 1);
#line 98
    ivtv_udma_sync_for_cpu(itv);
  } else {

  }
#line 100
  return;
}
}
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-udma.c"
int ivtv_udma_setup(struct ivtv *itv , unsigned long ivtv_dest_addr , void *userbuf ,
                    int size_in_bytes ) 
{ 
  struct ivtv_dma_page_info user_dma ;
  struct ivtv_user_dma *dma ;
  int i ;
  int err ;
  struct task_struct *tmp ;
  struct task_struct *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 106
  dma = & itv->udma;
#line 109
  if ((ivtv_debug & 32) != 0) {
#line 109
    printk("\016%s:  dma: ivtv_udma_setup, dst: 0x%08x\n", (char *)(& itv->v4l2_dev.name),
           (unsigned int )ivtv_dest_addr);
  } else {

  }
#line 112
  if (dma->SG_length != 0 || dma->page_count != 0) {
#line 113
    if (ivtv_debug & 1) {
#line 113
      printk("\016%s:  warn: ivtv_udma_setup: SG_length %d page_count %d still full?\n",
             (char *)(& itv->v4l2_dev.name), dma->SG_length, dma->page_count);
    } else {

    }
#line 115
    return (-16);
  } else {

  }
#line 118
  ivtv_udma_get_page_info(& user_dma, (unsigned long )userbuf, (unsigned long )size_in_bytes);
#line 120
  if (user_dma.page_count <= 0) {
#line 121
    if (ivtv_debug & 1) {
#line 121
      printk("\016%s:  warn: ivtv_udma_setup: Error %d page_count from %d bytes %d offset\n",
             (char *)(& itv->v4l2_dev.name), user_dma.page_count, size_in_bytes, user_dma.offset);
    } else {

    }
#line 123
    return (-22);
  } else {

  }
#line 127
  tmp = get_current();
#line 127
  tmp___0 = get_current();
#line 127
  tmp___1 = get_user_pages_unlocked(tmp___0, tmp->mm, user_dma.uaddr, (unsigned long )user_dma.page_count,
                                    0, 1, (struct page **)(& dma->map));
#line 127
  err = (int )tmp___1;
#line 130
  if (user_dma.page_count != err) {
#line 131
    if (ivtv_debug & 1) {
#line 131
      printk("\016%s:  warn: failed to map user pages, returned %d instead of %d\n",
             (char *)(& itv->v4l2_dev.name), err, user_dma.page_count);
    } else {

    }
#line 133
    if (err >= 0) {
#line 134
      i = 0;
#line 134
      goto ldv_38969;
      ldv_38968: 
#line 135
      put_page(dma->map[i]);
#line 134
      i = i + 1;
      ldv_38969: ;
#line 134
      if (i < err) {
#line 136
        goto ldv_38968;
      } else {

      }

#line 136
      return (-22);
    } else {

    }
#line 138
    return (err);
  } else {

  }
#line 141
  dma->page_count = user_dma.page_count;
#line 144
  tmp___2 = ivtv_udma_fill_sg_list(dma, & user_dma, 0);
#line 144
  if (tmp___2 < 0) {
#line 145
    i = 0;
#line 145
    goto ldv_38972;
    ldv_38971: 
#line 146
    put_page(dma->map[i]);
#line 145
    i = i + 1;
    ldv_38972: ;
#line 145
    if (dma->page_count > i) {
#line 147
      goto ldv_38971;
    } else {

    }
#line 148
    dma->page_count = 0;
#line 149
    return (-12);
  } else {

  }
#line 153
  dma->SG_length = pci_map_sg(itv->pdev, (struct scatterlist *)(& dma->SGlist), dma->page_count,
                              1);
#line 156
  ivtv_udma_fill_sg_array(dma, (u32 )ivtv_dest_addr, 0U, 4294967295U);
#line 159
  dma->SGarray[dma->SG_length + -1].size = dma->SGarray[dma->SG_length + -1].size | 2147483648U;
#line 161
  ivtv_udma_sync_for_device(itv);
#line 162
  return (dma->page_count);
}
}
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-udma.c"
void ivtv_udma_unmap(struct ivtv *itv ) 
{ 
  struct ivtv_user_dma *dma ;
  int i ;

  {
#line 167
  dma = & itv->udma;
#line 170
  if ((ivtv_debug & 2) != 0) {
#line 170
    printk("\016%s:  info: ivtv_unmap_user_dma\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 173
  if (dma->page_count == 0) {
#line 174
    return;
  } else {

  }
#line 177
  if (dma->SG_length != 0) {
#line 178
    pci_unmap_sg(itv->pdev, (struct scatterlist *)(& dma->SGlist), dma->page_count,
                 1);
#line 179
    dma->SG_length = 0;
  } else {

  }
#line 182
  ivtv_udma_sync_for_cpu(itv);
#line 185
  i = 0;
#line 185
  goto ldv_38980;
  ldv_38979: 
#line 186
  put_page(dma->map[i]);
#line 185
  i = i + 1;
  ldv_38980: ;
#line 185
  if (dma->page_count > i) {
#line 187
    goto ldv_38979;
  } else {

  }
#line 188
  dma->page_count = 0;
#line 189
  return;
}
}
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-udma.c"
void ivtv_udma_free(struct ivtv *itv ) 
{ 
  int i ;

  {
#line 196
  if (itv->udma.SG_handle != 0ULL) {
#line 197
    pci_unmap_single(itv->pdev, itv->udma.SG_handle, 8448UL, 1);
  } else {

  }
#line 202
  if (itv->udma.SG_length != 0) {
#line 203
    pci_unmap_sg(itv->pdev, (struct scatterlist *)(& itv->udma.SGlist), itv->udma.page_count,
                 1);
  } else {

  }
#line 206
  i = 0;
#line 206
  goto ldv_38987;
  ldv_38986: ;
#line 207
  if ((unsigned long )itv->udma.bouncemap[i] != (unsigned long )((struct page *)0)) {
#line 208
    __free_pages(itv->udma.bouncemap[i], 0U);
  } else {

  }
#line 206
  i = i + 1;
  ldv_38987: ;
#line 206
  if ((unsigned int )i <= 703U) {
#line 208
    goto ldv_38986;
  } else {

  }

#line 213
  return;
}
}
#line 212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-udma.c"
void ivtv_udma_start(struct ivtv *itv ) 
{ 
  unsigned int tmp ;

  {
#line 214
  if ((ivtv_debug & 32) != 0) {
#line 214
    printk("\016%s:  dma: start UDMA\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 215
  writel((unsigned int )itv->udma.SG_handle, itv->reg_mem + 8UL);
#line 216
  tmp = readl((void const volatile   *)itv->reg_mem);
#line 216
  writel(tmp | 1U, itv->reg_mem);
#line 216
  readl((void const volatile   *)itv->reg_mem);
#line 217
  set_bit(0L, (unsigned long volatile   *)(& itv->i_flags));
#line 218
  set_bit(1L, (unsigned long volatile   *)(& itv->i_flags));
#line 219
  clear_bit(2L, (unsigned long volatile   *)(& itv->i_flags));
#line 220
  return;
}
}
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-udma.c"
void ivtv_udma_prepare(struct ivtv *itv ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
#line 226
  tmp = spinlock_check(& itv->dma_reg_lock);
#line 226
  flags = _raw_spin_lock_irqsave(tmp);
#line 227
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile   *)(& itv->i_flags));
#line 227
  if (tmp___0 == 0) {
#line 228
    ivtv_udma_start(itv);
  } else {
#line 230
    set_bit(2L, (unsigned long volatile   *)(& itv->i_flags));
  }
#line 231
  spin_unlock_irqrestore(& itv->dma_reg_lock, flags);
#line 232
  return;
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-udma.o.c.prepared"
bool ldv_queue_work_on_211(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 142
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 142
  ldv_func_res = tmp;
#line 144
  activate_work_2(ldv_func_arg3, 2);
#line 146
  return (ldv_func_res);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-udma.o.c.prepared"
bool ldv_queue_delayed_work_on_212(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 153
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 153
  ldv_func_res = tmp;
#line 155
  activate_work_2(& ldv_func_arg3->work, 2);
#line 157
  return (ldv_func_res);
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-udma.o.c.prepared"
bool ldv_queue_work_on_213(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 164
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 164
  ldv_func_res = tmp;
#line 166
  activate_work_2(ldv_func_arg3, 2);
#line 168
  return (ldv_func_res);
}
}
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-udma.o.c.prepared"
void ldv_flush_workqueue_214(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 174
  flush_workqueue(ldv_func_arg1);
#line 176
  call_and_disable_all_2(2);
#line 177
  return;
}
}
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-udma.o.c.prepared"
bool ldv_queue_delayed_work_on_215(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 183
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 183
  ldv_func_res = tmp;
#line 185
  activate_work_2(& ldv_func_arg3->work, 2);
#line 187
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 61 "./arch/x86/include/asm/string_64.h"
extern void *__memmove(void * , void const   * , size_t  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_225(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_227(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_226(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_229(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_228(struct workqueue_struct *ldv_func_arg1 ) ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
static void ivtv_set_vps(struct ivtv *itv , int enabled ) 
{ 
  struct v4l2_sliced_vbi_data data ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 31
  if ((itv->v4l2_cap & 2U) == 0U) {
#line 32
    return;
  } else {

  }
#line 33
  data.id = 1024U;
#line 34
  data.field = 0U;
#line 35
  data.line = enabled != 0 ? 16U : 0U;
#line 36
  data.data[2] = itv->vbi.vps_payload.data[0];
#line 37
  data.data[8] = itv->vbi.vps_payload.data[1];
#line 38
  data.data[9] = itv->vbi.vps_payload.data[2];
#line 39
  data.data[10] = itv->vbi.vps_payload.data[3];
#line 40
  data.data[11] = itv->vbi.vps_payload.data[4];
#line 41
  __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 41
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 41
  goto ldv_39100;
  ldv_39099: ;
#line 41
  if (((__sd->grp_id & 4U) != 0U && (unsigned long )(__sd->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->vbi)->s_vbi_data != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                          struct v4l2_sliced_vbi_data  const  * ))0)) {
#line 41
    (*(((__sd->ops)->vbi)->s_vbi_data))(__sd, (struct v4l2_sliced_vbi_data  const  *)(& data));
  } else {

  }
#line 41
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 41
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_39100: ;
#line 41
  if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 43
    goto ldv_39099;
  } else {

  }

#line 49
  return;
}
}
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
static void ivtv_set_cc(struct ivtv *itv , int mode , struct vbi_cc  const  *cc ) 
{ 
  struct v4l2_sliced_vbi_data data ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct v4l2_subdev *__sd___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 48
  if ((itv->v4l2_cap & 2U) == 0U) {
#line 49
    return;
  } else {

  }
#line 50
  data.id = 4096U;
#line 51
  data.field = 0U;
#line 52
  data.line = mode & 1 ? 21U : 0U;
#line 53
  data.data[0] = cc->odd[0];
#line 54
  data.data[1] = cc->odd[1];
#line 55
  __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 55
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 55
  goto ldv_39114;
  ldv_39113: ;
#line 55
  if (((__sd->grp_id & 4U) != 0U && (unsigned long )(__sd->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->vbi)->s_vbi_data != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                          struct v4l2_sliced_vbi_data  const  * ))0)) {
#line 55
    (*(((__sd->ops)->vbi)->s_vbi_data))(__sd, (struct v4l2_sliced_vbi_data  const  *)(& data));
  } else {

  }
#line 55
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 55
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_39114: ;
#line 55
  if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 57
    goto ldv_39113;
  } else {

  }
#line 56
  data.field = 1U;
#line 57
  data.line = (mode & 2) != 0 ? 21U : 0U;
#line 58
  data.data[0] = cc->even[0];
#line 59
  data.data[1] = cc->even[1];
#line 60
  __mptr___1 = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 60
  __sd___0 = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff88UL;
#line 60
  goto ldv_39122;
  ldv_39121: ;
#line 60
  if (((__sd___0->grp_id & 4U) != 0U && (unsigned long )(__sd___0->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0)) && (unsigned long )((__sd___0->ops)->vbi)->s_vbi_data != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                      struct v4l2_sliced_vbi_data  const  * ))0)) {
#line 60
    (*(((__sd___0->ops)->vbi)->s_vbi_data))(__sd___0, (struct v4l2_sliced_vbi_data  const  *)(& data));
  } else {

  }
#line 60
  __mptr___2 = (struct list_head  const  *)__sd___0->list.next;
#line 60
  __sd___0 = (struct v4l2_subdev *)__mptr___2 + 0xffffffffffffff88UL;
  ldv_39122: ;
#line 60
  if ((unsigned long )(& __sd___0->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 62
    goto ldv_39121;
  } else {

  }

#line 68
  return;
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
static void ivtv_set_wss(struct ivtv *itv , int enabled , int mode ) 
{ 
  struct v4l2_sliced_vbi_data data ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 67
  if ((itv->v4l2_cap & 2U) == 0U) {
#line 68
    return;
  } else {

  }
#line 74
  if ((itv->std_out & 16713471ULL) != 0ULL && enabled == 0) {
#line 75
    enabled = 1;
#line 76
    mode = 8;
  } else {

  }
#line 78
  data.id = 16384U;
#line 79
  data.field = 0U;
#line 80
  data.line = enabled != 0 ? 23U : 0U;
#line 81
  data.data[0] = (__u8 )mode;
#line 82
  data.data[1] = (__u8 )(mode >> 8);
#line 83
  __mptr = (struct list_head  const  *)itv->v4l2_dev.subdevs.next;
#line 83
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 83
  goto ldv_39136;
  ldv_39135: ;
#line 83
  if (((__sd->grp_id & 4U) != 0U && (unsigned long )(__sd->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->vbi)->s_vbi_data != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                          struct v4l2_sliced_vbi_data  const  * ))0)) {
#line 83
    (*(((__sd->ops)->vbi)->s_vbi_data))(__sd, (struct v4l2_sliced_vbi_data  const  *)(& data));
  } else {

  }
#line 83
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 83
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_39136: ;
#line 83
  if ((unsigned long )(& __sd->list) != (unsigned long )(& itv->v4l2_dev.subdevs)) {
#line 85
    goto ldv_39135;
  } else {

  }

#line 91
  return;
}
}
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
static int odd_parity(u8 c ) 
{ 


  {
#line 88
  c = (u8 )(((int )c >> 4) ^ (int )c);
#line 89
  c = (u8 )(((int )c >> 2) ^ (int )c);
#line 90
  c = (u8 )(((int )c >> 1) ^ (int )c);
#line 92
  return ((int )c & 1);
}
}
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
static void ivtv_write_vbi_line(struct ivtv *itv , struct v4l2_sliced_vbi_data  const  *d ,
                                struct vbi_cc *cc , int *found_cc ) 
{ 
  struct vbi_info *vi ;
  struct vbi_vps vps ;
  int tmp ;
  int wss ;

  {
#line 99
  vi = & itv->vbi;
#line 101
  if ((unsigned int )d->id == 4096U && (unsigned int )d->line == 21U) {
#line 102
    if ((unsigned int )d->field != 0U) {
#line 103
      cc->even[0] = d->data[0];
#line 104
      cc->even[1] = d->data[1];
    } else {
#line 106
      cc->odd[0] = d->data[0];
#line 107
      cc->odd[1] = d->data[1];
    }
#line 109
    *found_cc = 1;
  } else
#line 110
  if (((unsigned int )d->id == 1024U && (unsigned int )d->line == 16U) && (unsigned int )d->field == 0U) {
#line 113
    vps.data[0] = d->data[2];
#line 114
    vps.data[1] = d->data[8];
#line 115
    vps.data[2] = d->data[9];
#line 116
    vps.data[3] = d->data[10];
#line 117
    vps.data[4] = d->data[11];
#line 118
    tmp = memcmp((void const   *)(& vps), (void const   *)(& vi->vps_payload), 5UL);
#line 118
    if (tmp != 0) {
#line 119
      vi->vps_payload = vps;
#line 120
      set_bit(11L, (unsigned long volatile   *)(& itv->i_flags));
    } else {

    }
  } else
#line 122
  if (((unsigned int )d->id == 16384U && (unsigned int )d->line == 23U) && (unsigned int )d->field == 0U) {
#line 124
    wss = (int )d->data[0] | ((int )d->data[1] << 8);
#line 126
    if (vi->wss_payload != wss) {
#line 127
      vi->wss_payload = wss;
#line 128
      set_bit(10L, (unsigned long volatile   *)(& itv->i_flags));
    } else {

    }
  } else {

  }
#line 131
  return;
}
}
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
static void ivtv_write_vbi_cc_lines(struct ivtv *itv , struct vbi_cc  const  *cc ) 
{ 
  struct vbi_info *vi ;

  {
#line 135
  vi = & itv->vbi;
#line 137
  if ((unsigned int )vi->cc_payload_idx <= 255U) {
#line 138
    memcpy((void *)(& vi->cc_payload) + (unsigned long )vi->cc_payload_idx, (void const   *)cc,
             4UL);
#line 140
    vi->cc_payload_idx = vi->cc_payload_idx + 1;
#line 141
    set_bit(9L, (unsigned long volatile   *)(& itv->i_flags));
  } else {

  }
#line 143
  return;
}
}
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
static void ivtv_write_vbi(struct ivtv *itv , struct v4l2_sliced_vbi_data  const  *sliced ,
                           size_t cnt ) 
{ 
  struct vbi_cc cc ;
  int found_cc ;
  size_t i ;

  {
#line 149
  cc.odd[0] = 128U;
#line 149
  cc.odd[1] = 128U;
#line 149
  cc.even[0] = 128U;
#line 149
  cc.even[1] = 128U;
#line 150
  found_cc = 0;
#line 153
  i = 0UL;
#line 153
  goto ldv_39166;
  ldv_39165: 
#line 154
  ivtv_write_vbi_line(itv, sliced + i, & cc, & found_cc);
#line 153
  i = i + 1UL;
  ldv_39166: ;
#line 153
  if (i < cnt) {
#line 155
    goto ldv_39165;
  } else {

  }

#line 156
  if (found_cc != 0) {
#line 157
    ivtv_write_vbi_cc_lines(itv, (struct vbi_cc  const  *)(& cc));
  } else {

  }
#line 158
  return;
}
}
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
ssize_t ivtv_write_vbi_from_user(struct ivtv *itv , struct v4l2_sliced_vbi_data  const  *sliced ,
                                 size_t cnt ) 
{ 
  struct vbi_cc cc ;
  int found_cc ;
  size_t i ;
  struct v4l2_sliced_vbi_data d ;
  ssize_t ret ;
  unsigned long tmp ;

  {
#line 165
  cc.odd[0] = 128U;
#line 165
  cc.odd[1] = 128U;
#line 165
  cc.even[0] = 128U;
#line 165
  cc.even[1] = 128U;
#line 166
  found_cc = 0;
#line 169
  ret = (ssize_t )(cnt * 64UL);
#line 171
  i = 0UL;
#line 171
  goto ldv_39180;
  ldv_39179: 
#line 172
  tmp = copy_from_user((void *)(& d), (void const   *)(sliced + i), 64UL);
#line 172
  if (tmp != 0UL) {
#line 174
    ret = -14L;
#line 175
    goto ldv_39178;
  } else {

  }
#line 177
  ivtv_write_vbi_line(itv, (struct v4l2_sliced_vbi_data  const  *)(& d), & cc, & found_cc);
#line 171
  i = i + 1UL;
  ldv_39180: ;
#line 171
  if (i < cnt) {
#line 173
    goto ldv_39179;
  } else {

  }
  ldv_39178: ;
#line 180
  if (found_cc != 0) {
#line 181
    ivtv_write_vbi_cc_lines(itv, (struct vbi_cc  const  *)(& cc));
  } else {

  }
#line 183
  return (ret);
}
}
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
static void copy_vbi_data(struct ivtv *itv , int lines , u32 pts_stamp ) 
{ 
  int line ;
  int i ;
  u32 linemask[2U] ;
  unsigned short size ;
  u8 mpeg_hdr_data[32U] ;
  int sd ;
  int idx ;
  u8 *dst ;
  int f ;
  int l ;
  u16 tmp ;

  {
#line 188
  line = 0;
#line 190
  linemask[0] = 0U;
#line 190
  linemask[1] = 0U;
#line 192
  mpeg_hdr_data[0] = 0U;
#line 192
  mpeg_hdr_data[1] = 0U;
#line 192
  mpeg_hdr_data[2] = 1U;
#line 192
  mpeg_hdr_data[3] = 186U;
#line 192
  mpeg_hdr_data[4] = 68U;
#line 192
  mpeg_hdr_data[5] = 0U;
#line 192
  mpeg_hdr_data[6] = 12U;
#line 192
  mpeg_hdr_data[7] = 102U;
#line 192
  mpeg_hdr_data[8] = 36U;
#line 192
  mpeg_hdr_data[9] = 1U;
#line 192
  mpeg_hdr_data[10] = 1U;
#line 192
  mpeg_hdr_data[11] = 209U;
#line 192
  mpeg_hdr_data[12] = 211U;
#line 192
  mpeg_hdr_data[13] = 250U;
#line 192
  mpeg_hdr_data[14] = 255U;
#line 192
  mpeg_hdr_data[15] = 255U;
#line 192
  mpeg_hdr_data[16] = 0U;
#line 192
  mpeg_hdr_data[17] = 0U;
#line 192
  mpeg_hdr_data[18] = 1U;
#line 192
  mpeg_hdr_data[19] = 189U;
#line 192
  mpeg_hdr_data[20] = 0U;
#line 192
  mpeg_hdr_data[21] = 26U;
#line 192
  mpeg_hdr_data[22] = 132U;
#line 192
  mpeg_hdr_data[23] = 128U;
#line 192
  mpeg_hdr_data[24] = 7U;
#line 192
  mpeg_hdr_data[25] = 33U;
#line 192
  mpeg_hdr_data[26] = 0U;
#line 192
  mpeg_hdr_data[27] = 93U;
#line 192
  mpeg_hdr_data[28] = 99U;
#line 192
  mpeg_hdr_data[29] = 167U;
#line 192
  mpeg_hdr_data[30] = 255U;
#line 192
  mpeg_hdr_data[31] = 255U;
#line 198
  sd = 32;
#line 199
  idx = (int )itv->vbi.frame & 31;
#line 200
  dst = itv->vbi.sliced_mpeg_data[idx];
#line 202
  i = 0;
#line 202
  goto ldv_39198;
  ldv_39197: ;
#line 205
  if (itv->vbi.sliced_data[i].id == 0U) {
#line 206
    goto ldv_39196;
  } else {

  }
#line 208
  l = (int )(itv->vbi.sliced_data[i].line - 6U);
#line 209
  f = (int )itv->vbi.sliced_data[i].field;
#line 210
  if (f != 0) {
#line 211
    l = l + 18;
  } else {

  }
#line 212
  if (l <= 31) {
#line 213
    linemask[0] = linemask[0] | (u32 )(1 << l);
  } else {
#line 215
    linemask[1] = linemask[1] | (u32 )(1 << (l + -32));
  }
#line 216
  tmp = ivtv_service2vbi((int )itv->vbi.sliced_data[i].id);
#line 216
  *(dst + (unsigned long )((sd + 12) + line * 43)) = (u8 )tmp;
#line 218
  memcpy((void *)(dst + (((unsigned long )sd + (unsigned long )(line * 43)) + 13UL)),
           (void const   *)(& itv->vbi.sliced_data[i].data), 42UL);
#line 219
  line = line + 1;
  ldv_39196: 
#line 202
  i = i + 1;
  ldv_39198: ;
#line 202
  if (i < lines) {
#line 204
    goto ldv_39197;
  } else {

  }
#line 221
  memcpy((void *)dst, (void const   *)(& mpeg_hdr_data), 32UL);
#line 222
  if (line == 36) {
#line 226
    memcpy((void *)dst + (unsigned long )sd, (void const   *)"ITV0", 4UL);
#line 227
    __memmove((void *)(dst + ((unsigned long )sd + 4UL)), (void const   *)(dst + ((unsigned long )sd + 12UL)),
              (size_t )(line * 43));
#line 228
    size = (((unsigned int )((unsigned short )line) * 43U + 3U) & 65532U) + 4U;
  } else {
#line 230
    memcpy((void *)dst + (unsigned long )sd, (void const   *)"itv0", 4UL);
#line 233
    memcpy((void *)(dst + ((unsigned long )sd + 4UL)), (void const   *)(& linemask),
             8UL);
#line 234
    size = (((unsigned int )((unsigned short )line) * 43U + 3U) & 65532U) + 12U;
  }
#line 236
  *(dst + 20UL) = (u8 )(((int )size + 10) >> 8);
#line 237
  *(dst + 21UL) = (u8 )((unsigned int )((unsigned char )size) + 10U);
#line 238
  *(dst + 25UL) = ((unsigned int )((u8 )(pts_stamp >> 29)) & 6U) | 33U;
#line 239
  *(dst + 26UL) = (u8 )(pts_stamp >> 22);
#line 240
  *(dst + 27UL) = (unsigned int )((u8 )(pts_stamp >> 14)) | 1U;
#line 241
  *(dst + 28UL) = (u8 )(pts_stamp >> 7);
#line 242
  *(dst + 29UL) = (unsigned int )((int )((u8 )pts_stamp) << 1U) | 1U;
#line 243
  itv->vbi.sliced_mpeg_size[idx] = (u32 )((int )size + sd);
#line 244
  return;
}
}
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
static int ivtv_convert_ivtv_vbi(struct ivtv *itv , u8 *p ) 
{ 
  u32 linemask[2U] ;
  int i ;
  int l ;
  int id2 ;
  int line ;
  int tmp ;
  int tmp___0 ;
  int err ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 250
  line = 0;
#line 252
  tmp___0 = memcmp((void const   *)p, (void const   *)"itv0", 4UL);
#line 252
  if (tmp___0 == 0) {
#line 253
    memcpy((void *)(& linemask), (void const   *)p + 4U, 8UL);
#line 254
    p = p + 12UL;
  } else {
#line 255
    tmp = memcmp((void const   *)p, (void const   *)"ITV0", 4UL);
#line 255
    if (tmp == 0) {
#line 256
      linemask[0] = 4294967295U;
#line 257
      linemask[1] = 15U;
#line 258
      p = p + 4UL;
    } else {
#line 261
      linemask[1] = 0U;
#line 261
      linemask[0] = linemask[1];
    }
  }
#line 263
  i = 0;
#line 263
  goto ldv_39218;
  ldv_39217: 
#line 264
  err = 0;
#line 266
  if (i <= 31 && (linemask[0] & (u32 )(1 << i)) == 0U) {
#line 267
    goto ldv_39210;
  } else {

  }
#line 268
  if (i > 31 && (linemask[1] & (u32 )(1 << (i + -32))) == 0U) {
#line 269
    goto ldv_39210;
  } else {

  }
#line 270
  id2 = (int )*p & 15;
#line 271
  switch (id2) {
  case 1: 
#line 273
  id2 = 1;
#line 274
  goto ldv_39212;
  case 4: 
#line 276
  id2 = 4096;
#line 277
  tmp___1 = odd_parity((int )*(p + 1UL));
#line 277
  if (tmp___1 == 0) {
#line 277
    tmp___3 = 1;
  } else {
#line 277
    tmp___2 = odd_parity((int )*(p + 2UL));
#line 277
    if (tmp___2 == 0) {
#line 277
      tmp___3 = 1;
    } else {
#line 277
      tmp___3 = 0;
    }
  }
#line 277
  err = tmp___3;
#line 278
  goto ldv_39212;
  case 7: 
#line 280
  id2 = 1024;
#line 281
  goto ldv_39212;
  case 5: 
#line 283
  id2 = 16384;
#line 284
  goto ldv_39212;
  default: 
#line 286
  id2 = 0;
#line 287
  goto ldv_39212;
  }
  ldv_39212: ;
#line 289
  if (err == 0) {
#line 290
    l = i <= 17 ? i + 6 : i + -12;
#line 291
    itv->vbi.sliced_dec_data[line].line = (__u32 )l;
#line 292
    itv->vbi.sliced_dec_data[line].field = i > 17;
#line 293
    itv->vbi.sliced_dec_data[line].id = (__u32 )id2;
#line 294
    memcpy((void *)(& itv->vbi.sliced_dec_data[line].data), (void const   *)p + 1U,
             42UL);
#line 295
    line = line + 1;
  } else {

  }
#line 297
  p = p + 43UL;
  ldv_39210: 
#line 263
  i = i + 1;
  ldv_39218: ;
#line 263
  if (i <= 35) {
#line 265
    goto ldv_39217;
  } else {

  }

#line 299
  goto ldv_39221;
  ldv_39220: 
#line 300
  itv->vbi.sliced_dec_data[line].id = 0U;
#line 301
  itv->vbi.sliced_dec_data[line].line = 0U;
#line 302
  itv->vbi.sliced_dec_data[line].field = 0U;
#line 303
  line = line + 1;
  ldv_39221: ;
#line 299
  if (line <= 35) {
#line 301
    goto ldv_39220;
  } else {

  }

#line 305
  return ((int )((unsigned int )line * 64U));
}
}
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
static u32 compress_raw_buf(struct ivtv *itv , u8 *buf , u32 size ) 
{ 
  u32 line_size ;
  u32 lines ;
  u8 sav1 ;
  u8 sav2 ;
  u8 *q ;
  u8 *p ;
  int i ;

  {
#line 313
  line_size = itv->vbi.raw_decoder_line_size;
#line 314
  lines = itv->vbi.count;
#line 315
  sav1 = itv->vbi.raw_decoder_sav_odd_field;
#line 316
  sav2 = itv->vbi.raw_decoder_sav_even_field;
#line 317
  q = buf;
#line 321
  i = 0;
#line 321
  goto ldv_39237;
  ldv_39236: 
#line 322
  p = buf + (unsigned long )((u32 )i * line_size);
#line 325
  if ((((unsigned int )*p != 255U || (unsigned int )*(p + 1UL) != 0U) || (unsigned int )*(p + 2UL) != 0U) || ((int )*(p + 3UL) != (int )sav1 && (int )*(p + 3UL) != (int )sav2)) {
#line 326
    goto ldv_39235;
  } else {

  }
#line 328
  memcpy((void *)q, (void const   *)p + 4U, (size_t )(line_size - 4U));
#line 329
  q = q + (unsigned long )(line_size - 4U);
#line 321
  i = i + 1;
  ldv_39237: ;
#line 321
  if ((u32 )i < lines) {
#line 323
    goto ldv_39236;
  } else {

  }
  ldv_39235: ;
#line 331
  return ((line_size - 4U) * lines);
}
}
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
static u32 compress_sliced_buf(struct ivtv *itv , u32 line , u8 *buf , u32 size ,
                               u8 sav ) 
{ 
  u32 line_size ;
  struct v4l2_decode_vbi_line vbi ;
  int i ;
  unsigned int lines ;
  u8 *p ;

  {
#line 339
  line_size = itv->vbi.sliced_decoder_line_size;
#line 342
  lines = 0U;
#line 345
  i = 0;
#line 345
  goto ldv_39251;
  ldv_39250: ;
#line 346
  if ((((unsigned int )*buf == 255U && (unsigned int )*(buf + 1UL) == 0U) && (unsigned int )*(buf + 2UL) == 0U) && (int )*(buf + 3UL) == (int )sav) {
#line 347
    goto ldv_39249;
  } else {

  }
#line 345
  i = i + 1;
#line 345
  buf = buf + 1;
  ldv_39251: ;
#line 345
  if ((u32 )i < size) {
#line 347
    goto ldv_39250;
  } else {

  }
  ldv_39249: 
#line 350
  size = size - (u32 )i;
#line 351
  if (size < line_size) {
#line 352
    return (line);
  } else {

  }
#line 354
  i = 0;
#line 354
  goto ldv_39255;
  ldv_39254: 
#line 355
  p = buf + (unsigned long )((u32 )i * line_size);
#line 358
  if ((((unsigned int )*p != 255U || (unsigned int )*(p + 1UL) != 0U) || (unsigned int )*(p + 2UL) != 0U) || (int )*(p + 3UL) != (int )sav) {
#line 359
    goto ldv_39253;
  } else {

  }
#line 361
  vbi.p = p + 4UL;
#line 362
  if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 362
    if ((unsigned long )((itv->sd_video)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->vbi)->decode_vbi_line != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                        struct v4l2_decode_vbi_line * ))0)) {
#line 362
      (*((((itv->sd_video)->ops)->vbi)->decode_vbi_line))(itv->sd_video, & vbi);
    } else {

    }
  } else {

  }
#line 363
  if (vbi.type != 0U && ((unsigned int )(1 << (int )vbi.line) & lines) == 0U) {
#line 364
    lines = (unsigned int )(1 << (int )vbi.line) | lines;
#line 365
    itv->vbi.sliced_data[line].id = vbi.type;
#line 366
    itv->vbi.sliced_data[line].field = vbi.is_second_field;
#line 367
    itv->vbi.sliced_data[line].line = vbi.line;
#line 368
    memcpy((void *)(& itv->vbi.sliced_data[line].data), (void const   *)vbi.p, 42UL);
#line 369
    line = line + 1U;
  } else {

  }
  ldv_39253: 
#line 354
  i = i + 1;
  ldv_39255: ;
#line 354
  if ((u32 )i < size / line_size) {
#line 356
    goto ldv_39254;
  } else {

  }

#line 372
  return (line);
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
void ivtv_process_vbi_data(struct ivtv *itv , struct ivtv_buffer *buf , u64 pts_stamp ,
                           int streamtype ) 
{ 
  u8 *p ;
  u32 size ;
  int y ;
  u8 type ;
  u32 tmp ;
  int tmp___0 ;
  int lines ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  int offset ;
  int cnt ;

  {
#line 378
  p = (u8 *)buf->buf;
#line 379
  size = buf->bytesused;
#line 383
  if (streamtype == 2) {
#line 383
    tmp___0 = ivtv_raw_vbi((struct ivtv  const  *)itv);
#line 383
    if (tmp___0 != 0) {
#line 386
      ivtv_buf_swap(buf);
#line 388
      type = *(p + 3UL);
#line 390
      tmp = compress_raw_buf(itv, p, size);
#line 390
      buf->bytesused = tmp;
#line 390
      size = tmp;
#line 393
      if ((int )itv->vbi.raw_decoder_sav_even_field == (int )type) {
#line 396
        p = p + (unsigned long )(size - 4U);
#line 397
        memcpy((void *)p, (void const   *)(& itv->vbi.frame), 4UL);
#line 398
        itv->vbi.frame = itv->vbi.frame + 1U;
      } else {

      }
#line 400
      return;
    } else {

    }
  } else {

  }
#line 404
  if (streamtype == 2) {
#line 407
    ivtv_buf_swap(buf);
#line 410
    tmp___1 = compress_sliced_buf(itv, 0U, p, size / 2U, (int )itv->vbi.sliced_decoder_sav_odd_field);
#line 410
    lines = (int )tmp___1;
#line 415
    tmp___2 = compress_sliced_buf(itv, (u32 )lines, p + ((unsigned long )(size / 2U) + 0xffffffffffffffe0UL),
                                  size / 2U + 32U, (int )itv->vbi.sliced_decoder_sav_even_field);
#line 415
    lines = (int )tmp___2;
#line 418
    if (lines == 0) {
#line 419
      itv->vbi.sliced_data[0].id = 0U;
#line 420
      itv->vbi.sliced_data[0].line = 0U;
#line 421
      itv->vbi.sliced_data[0].field = 0U;
#line 422
      lines = 1;
    } else {

    }
#line 424
    size = (u32 )((unsigned long )lines) * 64U;
#line 424
    buf->bytesused = size;
#line 425
    memcpy((void *)p, (void const   *)(& itv->vbi.sliced_data), (size_t )size);
#line 427
    if (itv->vbi.insert_mpeg != 0) {
#line 428
      copy_vbi_data(itv, lines, (u32 )pts_stamp);
    } else {

    }
#line 430
    itv->vbi.frame = itv->vbi.frame + 1U;
#line 431
    return;
  } else {

  }
#line 435
  if (streamtype == 6) {
#line 443
    offset = (int )size & 3;
#line 446
    if (offset != 0) {
#line 447
      p = p + (unsigned long )(4 - offset);
    } else {

    }
#line 450
    y = 0;
#line 450
    goto ldv_39271;
    ldv_39270: 
#line 451
    __swab32s((__u32 *)p + (unsigned long )y);
#line 450
    y = y + 4;
    ldv_39271: ;
#line 450
    if ((u32 )y < size) {
#line 452
      goto ldv_39270;
    } else {

    }
#line 454
    cnt = ivtv_convert_ivtv_vbi(itv, p + (unsigned long )offset);
#line 455
    memcpy((void *)buf->buf, (void const   *)(& itv->vbi.sliced_dec_data), (size_t )cnt);
#line 456
    buf->bytesused = (u32 )cnt;
#line 458
    ivtv_write_vbi(itv, (struct v4l2_sliced_vbi_data  const  *)(& itv->vbi.sliced_dec_data),
                   (unsigned long )cnt / 64UL);
#line 460
    return;
  } else {

  }
#line 462
  return;
}
}
#line 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
void ivtv_disable_cc(struct ivtv *itv ) 
{ 
  struct vbi_cc cc ;

  {
#line 466
  cc.odd[0] = 128U;
#line 466
  cc.odd[1] = 128U;
#line 466
  cc.even[0] = 128U;
#line 466
  cc.even[1] = 128U;
#line 468
  clear_bit(9L, (unsigned long volatile   *)(& itv->i_flags));
#line 469
  ivtv_set_cc(itv, 0, (struct vbi_cc  const  *)(& cc));
#line 470
  itv->vbi.cc_payload_idx = 0;
#line 471
  return;
}
}
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.c"
void ivtv_vbi_work_handler(struct ivtv *itv ) 
{ 
  struct vbi_info *vi ;
  struct v4l2_sliced_vbi_data data ;
  struct vbi_cc cc ;
  int tmp ;
  int mode ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 476
  vi = & itv->vbi;
#line 478
  cc.odd[0] = 128U;
#line 478
  cc.odd[1] = 128U;
#line 478
  cc.even[0] = 128U;
#line 478
  cc.even[1] = 128U;
#line 481
  if (itv->output_mode == 4) {
#line 482
    if ((unsigned int )itv->is_50hz != 0U) {
#line 483
      data.id = 16384U;
#line 484
      data.field = 0U;
#line 486
      if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 486
        if ((unsigned long )((itv->sd_video)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->vbi)->g_vbi_data != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                       struct v4l2_sliced_vbi_data * ))0)) {
#line 486
          tmp = (*((((itv->sd_video)->ops)->vbi)->g_vbi_data))(itv->sd_video, & data);
#line 486
          if (tmp == 0) {
#line 487
            ivtv_set_wss(itv, 1, (int )data.data[0] & 15);
#line 488
            vi->wss_missing_cnt = 0U;
          } else {
#line 486
            goto _L;
          }
        } else {
#line 486
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 489
      if ((unsigned int )vi->wss_missing_cnt == 4U) {
#line 490
        ivtv_set_wss(itv, 1, 8);
      } else {
#line 492
        vi->wss_missing_cnt = (u8 )((int )vi->wss_missing_cnt + 1);
      }
    } else {
#line 496
      mode = 0;
#line 498
      data.id = 4096U;
#line 499
      data.field = 0U;
#line 500
      if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 500
        if ((unsigned long )((itv->sd_video)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->vbi)->g_vbi_data != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                       struct v4l2_sliced_vbi_data * ))0)) {
#line 500
          tmp___0 = (*((((itv->sd_video)->ops)->vbi)->g_vbi_data))(itv->sd_video,
                                                                   & data);
#line 500
          if (tmp___0 == 0) {
#line 501
            mode = mode | 1;
#line 502
            cc.odd[0] = data.data[0];
#line 503
            cc.odd[1] = data.data[1];
          } else {

          }
        } else {

        }
      } else {

      }
#line 505
      data.field = 1U;
#line 506
      if ((unsigned long )itv->sd_video != (unsigned long )((struct v4l2_subdev *)0)) {
#line 506
        if ((unsigned long )((itv->sd_video)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((itv->sd_video)->ops)->vbi)->g_vbi_data != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                       struct v4l2_sliced_vbi_data * ))0)) {
#line 506
          tmp___1 = (*((((itv->sd_video)->ops)->vbi)->g_vbi_data))(itv->sd_video,
                                                                   & data);
#line 506
          if (tmp___1 == 0) {
#line 507
            mode = mode | 2;
#line 508
            cc.even[0] = data.data[0];
#line 509
            cc.even[1] = data.data[1];
          } else {

          }
        } else {

        }
      } else {

      }
#line 511
      if (mode != 0) {
#line 512
        vi->cc_missing_cnt = 0U;
#line 513
        ivtv_set_cc(itv, mode, (struct vbi_cc  const  *)(& cc));
      } else
#line 514
      if ((unsigned int )vi->cc_missing_cnt == 4U) {
#line 515
        ivtv_set_cc(itv, 0, (struct vbi_cc  const  *)(& cc));
      } else {
#line 517
        vi->cc_missing_cnt = (u8 )((int )vi->cc_missing_cnt + 1);
      }
    }
#line 520
    return;
  } else {

  }
#line 523
  tmp___2 = test_and_clear_bit(10L, (unsigned long volatile   *)(& itv->i_flags));
#line 523
  if (tmp___2 != 0) {
#line 524
    ivtv_set_wss(itv, 1, vi->wss_payload & 15);
  } else {

  }
#line 527
  tmp___3 = constant_test_bit(9L, (unsigned long const volatile   *)(& itv->i_flags));
#line 527
  if (tmp___3 != 0) {
#line 528
    if (vi->cc_payload_idx == 0) {
#line 529
      clear_bit(9L, (unsigned long volatile   *)(& itv->i_flags));
#line 530
      ivtv_set_cc(itv, 3, (struct vbi_cc  const  *)(& cc));
    } else {

    }
#line 532
    goto ldv_39284;
    ldv_39286: 
#line 533
    cc = vi->cc_payload[0];
#line 535
    __memmove((void *)(& vi->cc_payload), (void const   *)(& vi->cc_payload) + 1U,
              1020UL);
#line 537
    vi->cc_payload_idx = vi->cc_payload_idx - 1;
#line 538
    if ((vi->cc_payload_idx != 0 && (unsigned int )cc.odd[0] == 128U) && (unsigned int )cc.odd[1] == 128U) {
#line 539
      goto ldv_39284;
    } else {

    }
#line 541
    ivtv_set_cc(itv, 3, (struct vbi_cc  const  *)(& cc));
#line 542
    goto ldv_39285;
    ldv_39284: ;
#line 532
    if (vi->cc_payload_idx != 0) {
#line 534
      goto ldv_39286;
    } else {

    }
    ldv_39285: ;
  } else {

  }
#line 546
  tmp___4 = test_and_clear_bit(11L, (unsigned long volatile   *)(& itv->i_flags));
#line 546
  if (tmp___4 != 0) {
#line 547
    ivtv_set_vps(itv, 1);
  } else {

  }
#line 548
  return;
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.o.c.prepared"
bool ldv_queue_work_on_225(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 142
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 142
  ldv_func_res = tmp;
#line 144
  activate_work_2(ldv_func_arg3, 2);
#line 146
  return (ldv_func_res);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.o.c.prepared"
bool ldv_queue_delayed_work_on_226(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 153
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 153
  ldv_func_res = tmp;
#line 155
  activate_work_2(& ldv_func_arg3->work, 2);
#line 157
  return (ldv_func_res);
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.o.c.prepared"
bool ldv_queue_work_on_227(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 164
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 164
  ldv_func_res = tmp;
#line 166
  activate_work_2(ldv_func_arg3, 2);
#line 168
  return (ldv_func_res);
}
}
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.o.c.prepared"
void ldv_flush_workqueue_228(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 174
  flush_workqueue(ldv_func_arg1);
#line 176
  call_and_disable_all_2(2);
#line 177
  return;
}
}
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-vbi.o.c.prepared"
bool ldv_queue_delayed_work_on_229(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 183
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 183
  ldv_func_res = tmp;
#line 185
  activate_work_2(& ldv_func_arg3->work, 2);
#line 187
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 108 "include/linux/rwsem.h"
extern void down_read(struct rw_semaphore * ) ;
#line 128
extern void up_read(struct rw_semaphore * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_239(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_241(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_240(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_243(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_242(struct workqueue_struct *ldv_func_arg1 ) ;
#line 2847 "include/linux/sched.h"
__inline static int signal_pending___2(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 2849
  tmp = test_tsk_thread_flag(p, 2);
#line 2849
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2849
  return ((int )tmp___0);
}
}
#line 1184 "include/linux/mm.h"
extern long get_user_pages(struct task_struct * , struct mm_struct * , unsigned long  ,
                           unsigned long  , int  , int  , struct page ** , struct vm_area_struct ** ) ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
u32 const   yuv_offset[8U]  = 
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
  {      1738240U,      2360320U,      2982400U,      3604480U, 
        167936U,      790016U,      7013376U,      7635456U};
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
static int ivtv_yuv_prep_user_dma(struct ivtv *itv , struct ivtv_user_dma *dma , struct ivtv_dma_frame *args ) 
{ 
  struct ivtv_dma_page_info y_dma ;
  struct ivtv_dma_page_info uv_dma ;
  struct yuv_playback_info *yi ;
  u8 frame ;
  struct yuv_frame_info *f ;
  int i ;
  int y_pages ;
  int uv_pages ;
  unsigned long y_buffer_offset ;
  unsigned long uv_buffer_offset ;
  int y_decode_height ;
  int uv_decode_height ;
  int y_size ;
  struct task_struct *tmp ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  long tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  long tmp___5 ;
  struct task_struct *tmp___6 ;
  int rc ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 42
  yi = & itv->yuv_info;
#line 43
  frame = yi->draw_frame;
#line 44
  f = (struct yuv_frame_info *)(& yi->new_frame_info) + (unsigned long )frame;
#line 50
  y_buffer_offset = (unsigned long )((unsigned int )yuv_offset[(int )frame] + 16777216U);
#line 51
  uv_buffer_offset = y_buffer_offset + 414720UL;
#line 53
  uv_decode_height = (int )(f->src_h + (u32 )f->src_y);
#line 53
  y_decode_height = uv_decode_height;
#line 55
  if (f->offset_y != 0U) {
#line 56
    y_buffer_offset = y_buffer_offset + 11520UL;
  } else {

  }
#line 58
  if ((y_decode_height & 15) != 0) {
#line 59
    y_decode_height = (y_decode_height + 16) & -16;
  } else {

  }
#line 61
  if ((uv_decode_height & 31) != 0) {
#line 62
    uv_decode_height = (uv_decode_height + 32) & -32;
  } else {

  }
#line 64
  y_size = y_decode_height * 720;
#line 67
  if (dma->SG_length != 0 || dma->page_count != 0) {
#line 68
    if (ivtv_debug & 1) {
#line 68
      printk("\016%s:  warn: prep_user_dma: SG_length %d page_count %d still full?\n",
             (char *)(& itv->v4l2_dev.name), dma->SG_length, dma->page_count);
    } else {

    }
#line 71
    return (-16);
  } else {

  }
#line 74
  ivtv_udma_get_page_info(& y_dma, (unsigned long )args->y_source, (unsigned long )(y_decode_height * 720));
#line 75
  ivtv_udma_get_page_info(& uv_dma, (unsigned long )args->uv_source, (unsigned long )(uv_decode_height * 360));
#line 78
  tmp = get_current();
#line 78
  down_read(& (tmp->mm)->mmap_sem);
#line 79
  tmp___0 = get_current();
#line 79
  tmp___1 = get_current();
#line 79
  tmp___2 = get_user_pages(tmp___1, tmp___0->mm, y_dma.uaddr, (unsigned long )y_dma.page_count,
                           0, 1, (struct page **)(& dma->map), (struct vm_area_struct **)0);
#line 79
  y_pages = (int )tmp___2;
#line 80
  uv_pages = 0;
#line 81
  if (y_dma.page_count == y_pages) {
#line 82
    tmp___3 = get_current();
#line 82
    tmp___4 = get_current();
#line 82
    tmp___5 = get_user_pages(tmp___4, tmp___3->mm, uv_dma.uaddr, (unsigned long )uv_dma.page_count,
                             0, 1, (struct page **)(& dma->map) + (unsigned long )y_pages,
                             (struct vm_area_struct **)0);
#line 82
    uv_pages = (int )tmp___5;
  } else {

  }
#line 86
  tmp___6 = get_current();
#line 86
  up_read(& (tmp___6->mm)->mmap_sem);
#line 88
  if (y_dma.page_count != y_pages || uv_dma.page_count != uv_pages) {
#line 89
    rc = -14;
#line 91
    if (y_dma.page_count == y_pages) {
#line 92
      if (ivtv_debug & 1) {
#line 92
        printk("\016%s:  warn: failed to map uv user pages, returned %d expecting %d\n",
               (char *)(& itv->v4l2_dev.name), uv_pages, uv_dma.page_count);
      } else {

      }
#line 96
      if (uv_pages >= 0) {
#line 97
        i = 0;
#line 97
        goto ldv_38951;
        ldv_38950: 
#line 98
        put_page(dma->map[y_pages + i]);
#line 97
        i = i + 1;
        ldv_38951: ;
#line 97
        if (i < uv_pages) {
#line 99
          goto ldv_38950;
        } else {

        }
#line 99
        rc = -14;
      } else {
#line 101
        rc = uv_pages;
      }
    } else
#line 104
    if (ivtv_debug & 1) {
#line 104
      printk("\016%s:  warn: failed to map y user pages, returned %d expecting %d\n",
             (char *)(& itv->v4l2_dev.name), y_pages, y_dma.page_count);
    } else {

    }
#line 108
    if (y_pages >= 0) {
#line 109
      i = 0;
#line 109
      goto ldv_38954;
      ldv_38953: 
#line 110
      put_page(dma->map[i]);
#line 109
      i = i + 1;
      ldv_38954: ;
#line 109
      if (i < y_pages) {
#line 111
        goto ldv_38953;
      } else {

      }

    } else {
#line 118
      rc = y_pages;
    }
#line 120
    return (rc);
  } else {

  }
#line 123
  dma->page_count = y_pages + uv_pages;
#line 126
  tmp___7 = ivtv_udma_fill_sg_list(dma, & y_dma, 0);
#line 126
  tmp___8 = ivtv_udma_fill_sg_list(dma, & uv_dma, tmp___7);
#line 126
  if (tmp___8 < 0) {
#line 127
    if (ivtv_debug & 1) {
#line 127
      printk("\016%s:  warn: could not allocate bounce buffers for highmem userspace buffers\n",
             (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 128
    i = 0;
#line 128
    goto ldv_38957;
    ldv_38956: 
#line 129
    put_page(dma->map[i]);
#line 128
    i = i + 1;
    ldv_38957: ;
#line 128
    if (dma->page_count > i) {
#line 130
      goto ldv_38956;
    } else {

    }
#line 131
    dma->page_count = 0;
#line 132
    return (-12);
  } else {

  }
#line 134
  dma->SG_length = pci_map_sg(itv->pdev, (struct scatterlist *)(& dma->SGlist), dma->page_count,
                              1);
#line 137
  ivtv_udma_fill_sg_array(dma, (u32 )y_buffer_offset, (u32 )uv_buffer_offset, (u32 )y_size);
#line 140
  if (f->offset_y != 0U && yi->blanking_dmaptr != 0ULL) {
#line 141
    dma->SGarray[dma->SG_length].size = 11520U;
#line 142
    dma->SGarray[dma->SG_length].src = (unsigned int )yi->blanking_dmaptr;
#line 143
    dma->SGarray[dma->SG_length].dst = (unsigned int )yuv_offset[(int )frame] + 16777216U;
#line 144
    dma->SG_length = dma->SG_length + 1;
  } else {

  }
#line 148
  dma->SGarray[dma->SG_length + -1].size = dma->SGarray[dma->SG_length + -1].size | 2147483648U;
#line 150
  ivtv_udma_sync_for_device(itv);
#line 151
  return (0);
}
}
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
int ivtv_yuv_filter_check(struct ivtv *itv ) 
{ 
  int i ;
  int y ;
  int uv ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 159
  i = 0;
#line 159
  y = 16;
#line 159
  uv = 4;
#line 159
  goto ldv_38966;
  ldv_38965: 
#line 160
  tmp = readl((void const volatile   *)itv->dec_mem + (unsigned long )((unsigned int )(y + 9688)));
#line 160
  if (tmp != (unsigned int )(i << 16)) {
#line 162
    printk("\f%s: YUV filter table not found in firmware.\n", (char *)(& itv->v4l2_dev.name));
#line 163
    return (-1);
  } else {
#line 160
    tmp___0 = readl((void const volatile   *)itv->dec_mem + (unsigned long )((unsigned int )(uv + 13144)));
#line 160
    if (tmp___0 != (unsigned int )(i << 16)) {
#line 162
      printk("\f%s: YUV filter table not found in firmware.\n", (char *)(& itv->v4l2_dev.name));
#line 163
      return (-1);
    } else {

    }
  }
#line 159
  i = i + 1;
#line 159
  y = y + 24;
#line 159
  uv = uv + 12;
  ldv_38966: ;
#line 159
  if (i <= 15) {
#line 161
    goto ldv_38965;
  } else {

  }

#line 166
  return (0);
}
}
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
static void ivtv_yuv_filter(struct ivtv *itv , int h_filter , int v_filter_1 , int v_filter_2 ) 
{ 
  u32 i ;
  u32 line ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;

  {
#line 174
  if (h_filter >= 0) {
#line 175
    if (h_filter > 4) {
#line 176
      h_filter = 4;
    } else {

    }
#line 177
    i = (u32 )(h_filter * 384 + 9688);
#line 178
    line = 0U;
#line 178
    goto ldv_38977;
    ldv_38976: 
#line 179
    tmp = readl((void const volatile   *)itv->dec_mem + (unsigned long )i);
#line 179
    writel(tmp, itv->reg_mem + 10244UL);
#line 180
    tmp___0 = readl((void const volatile   *)itv->dec_mem + (unsigned long )i);
#line 180
    writel(tmp___0, itv->reg_mem + 10268UL);
#line 181
    i = i + 4U;
#line 182
    tmp___1 = readl((void const volatile   *)itv->dec_mem + (unsigned long )i);
#line 182
    writel(tmp___1, itv->reg_mem + 10248UL);
#line 183
    tmp___2 = readl((void const volatile   *)itv->dec_mem + (unsigned long )i);
#line 183
    writel(tmp___2, itv->reg_mem + 10272UL);
#line 184
    i = i + 4U;
#line 185
    tmp___3 = readl((void const volatile   *)itv->dec_mem + (unsigned long )i);
#line 185
    writel(tmp___3, itv->reg_mem + 10252UL);
#line 186
    tmp___4 = readl((void const volatile   *)itv->dec_mem + (unsigned long )i);
#line 186
    writel(tmp___4, itv->reg_mem + 10276UL);
#line 187
    i = i + 4U;
#line 188
    tmp___5 = readl((void const volatile   *)itv->dec_mem + (unsigned long )i);
#line 188
    writel(tmp___5, itv->reg_mem + 10256UL);
#line 189
    tmp___6 = readl((void const volatile   *)itv->dec_mem + (unsigned long )i);
#line 189
    writel(tmp___6, itv->reg_mem + 10280UL);
#line 190
    i = i + 4U;
#line 191
    tmp___7 = readl((void const volatile   *)itv->dec_mem + (unsigned long )i);
#line 191
    writel(tmp___7, itv->reg_mem + 10260UL);
#line 192
    tmp___8 = readl((void const volatile   *)itv->dec_mem + (unsigned long )i);
#line 192
    writel(tmp___8, itv->reg_mem + 10284UL);
#line 193
    i = i + 8U;
#line 194
    writel(0U, itv->reg_mem + 10264UL);
#line 195
    writel(0U, itv->reg_mem + 10288UL);
#line 178
    line = line + 1U;
    ldv_38977: ;
#line 178
    if (line <= 15U) {
#line 180
      goto ldv_38976;
    } else {

    }

#line 197
    if ((ivtv_debug & 256) != 0) {
#line 197
      printk("\016%s:  yuv: h_filter -> %d\n", (char *)(& itv->v4l2_dev.name), h_filter);
    } else {

    }
  } else {

  }
#line 200
  if (v_filter_1 >= 0) {
#line 201
    if (v_filter_1 > 4) {
#line 202
      v_filter_1 = 4;
    } else {

    }
#line 203
    i = (u32 )(v_filter_1 * 192 + 13144);
#line 204
    line = 0U;
#line 204
    goto ldv_38980;
    ldv_38979: 
#line 205
    tmp___9 = readl((void const volatile   *)itv->dec_mem + (unsigned long )i);
#line 205
    writel(tmp___9, itv->reg_mem + 10496UL);
#line 206
    i = i + 4U;
#line 207
    tmp___10 = readl((void const volatile   *)itv->dec_mem + (unsigned long )i);
#line 207
    writel(tmp___10, itv->reg_mem + 10500UL);
#line 208
    i = i + 8U;
#line 209
    writel(0U, itv->reg_mem + 10504UL);
#line 204
    line = line + 1U;
    ldv_38980: ;
#line 204
    if (line <= 15U) {
#line 206
      goto ldv_38979;
    } else {

    }

#line 211
    if ((ivtv_debug & 256) != 0) {
#line 211
      printk("\016%s:  yuv: v_filter_1 -> %d\n", (char *)(& itv->v4l2_dev.name), v_filter_1);
    } else {

    }
  } else {

  }
#line 214
  if (v_filter_2 >= 0) {
#line 215
    if (v_filter_2 > 4) {
#line 216
      v_filter_2 = 4;
    } else {

    }
#line 217
    i = (u32 )(v_filter_2 * 192 + 13144);
#line 218
    line = 0U;
#line 218
    goto ldv_38983;
    ldv_38982: 
#line 219
    tmp___11 = readl((void const volatile   *)itv->dec_mem + (unsigned long )i);
#line 219
    writel(tmp___11, itv->reg_mem + 10508UL);
#line 220
    i = i + 4U;
#line 221
    tmp___12 = readl((void const volatile   *)itv->dec_mem + (unsigned long )i);
#line 221
    writel(tmp___12, itv->reg_mem + 10512UL);
#line 222
    i = i + 8U;
#line 223
    writel(0U, itv->reg_mem + 10516UL);
#line 218
    line = line + 1U;
    ldv_38983: ;
#line 218
    if (line <= 15U) {
#line 220
      goto ldv_38982;
    } else {

    }

#line 225
    if ((ivtv_debug & 256) != 0) {
#line 225
      printk("\016%s:  yuv: v_filter_2 -> %d\n", (char *)(& itv->v4l2_dev.name), v_filter_2);
    } else {

    }
  } else {

  }
#line 227
  return;
}
}
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
static void ivtv_yuv_handle_horizontal(struct ivtv *itv , struct yuv_frame_info *f ) 
{ 
  struct yuv_playback_info *yi ;
  u32 reg_2834 ;
  u32 reg_2838 ;
  u32 reg_283c ;
  u32 reg_2844 ;
  u32 reg_2854 ;
  u32 reg_285c ;
  u32 reg_2864 ;
  u32 reg_2874 ;
  u32 reg_2890 ;
  u32 reg_2870 ;
  u32 reg_2870_base ;
  u32 reg_2870_offset ;
  int x_cutoff ;
  int h_filter ;
  u32 master_width ;

  {
#line 231
  yi = & itv->yuv_info;
#line 240
  if (ivtv_debug & 1) {
#line 240
    printk("\016%s:  warn: Adjust to width %d src_w %d dst_w %d src_x %d dst_x %d\n",
           (char *)(& itv->v4l2_dev.name), f->tru_w, f->src_w, f->dst_w, f->src_x,
           f->dst_x);
  } else {

  }
#line 245
  x_cutoff = (int )(f->src_w + (u32 )f->src_x);
#line 248
  reg_2834 = f->dst_w;
#line 249
  reg_2838 = reg_2834;
#line 252
  reg_2890 = (u32 )f->dst_x;
#line 255
  reg_2870 = 0U;
#line 263
  if (f->vis_w == 720U) {
#line 264
    if ((f->tru_x - f->pan_x >= 0 && f->tru_x - f->pan_x <= 40) && f->dst_w > 679U) {
#line 265
      reg_2870 = (u32 )(10 - (f->tru_x - f->pan_x) / 4);
    } else
#line 266
    if ((f->tru_x - f->pan_x < 0 && f->tru_x - f->pan_x >= -20) && f->dst_w > 659U) {
#line 267
      reg_2870 = (u32 )((f->tru_x - f->pan_x) / 2 + 10);
    } else {

    }
#line 269
    if (f->dst_w >= f->src_w) {
#line 270
      reg_2870 = (reg_2870 << 16) | reg_2870;
    } else {
#line 272
      reg_2870 = ((reg_2870 & 4294967294U) << 15) | (reg_2870 & 4294967294U);
    }
  } else {

  }
#line 275
  if (f->dst_w < f->src_w) {
#line 276
    reg_2870 = 851982U - reg_2870;
  } else {
#line 278
    reg_2870 = 1179662U - reg_2870;
  }
#line 281
  reg_2870_offset = (u32 )f->src_x * ((f->dst_w << 21) / f->src_w) >> 19;
#line 283
  if (f->dst_w >= f->src_w) {
#line 284
    x_cutoff = x_cutoff & -2;
#line 285
    master_width = (f->src_w * 2097152U) / f->dst_w;
#line 286
    if (f->dst_w * master_width != f->src_w * 2097152U) {
#line 287
      master_width = master_width + 1U;
    } else {

    }
#line 288
    reg_2834 = (reg_2834 << 16) | (u32 )x_cutoff;
#line 289
    reg_2838 = (reg_2838 << 16) | (u32 )x_cutoff;
#line 290
    reg_283c = master_width >> 2;
#line 291
    reg_2844 = master_width >> 2;
#line 292
    reg_2854 = master_width;
#line 293
    reg_285c = master_width >> 1;
#line 294
    reg_2864 = master_width >> 1;
#line 298
    if (f->dst_w > f->src_w) {
#line 299
      reg_2870_base = ((f->dst_w - f->src_w) << 16) / (f->src_w << 14);
    } else {
#line 301
      reg_2870_base = 0U;
    }
#line 303
    reg_2870 = ((((reg_2870_offset << 14) & 4294901760U) | (reg_2870_offset >> 2)) + ((reg_2870_base << 17) | reg_2870_base)) + reg_2870;
#line 304
    reg_2874 = 0U;
  } else
#line 305
  if (f->dst_w < f->src_w / 2U) {
#line 306
    master_width = (f->src_w * 524288U) / f->dst_w;
#line 307
    if (f->dst_w * master_width != f->src_w * 524288U) {
#line 308
      master_width = master_width + 1U;
    } else {

    }
#line 309
    reg_2834 = (reg_2834 << 16) | (u32 )x_cutoff;
#line 310
    reg_2838 = (reg_2838 << 16) | (u32 )x_cutoff;
#line 311
    reg_283c = master_width >> 2;
#line 312
    reg_2844 = master_width >> 1;
#line 313
    reg_2854 = master_width;
#line 314
    reg_285c = master_width >> 1;
#line 315
    reg_2864 = master_width >> 1;
#line 316
    reg_2870 = (((reg_2870_offset << 15) & 4294901760U) | reg_2870_offset) + reg_2870;
#line 317
    reg_2870 = ((5U - ((f->src_w + f->src_w / 2U) - 1U) / f->dst_w) << 16) + reg_2870;
#line 318
    reg_2874 = 18U;
  } else {
#line 320
    master_width = (f->src_w * 1048576U) / f->dst_w;
#line 321
    if (f->dst_w * master_width != f->src_w * 1048576U) {
#line 322
      master_width = master_width + 1U;
    } else {

    }
#line 323
    reg_2834 = (reg_2834 << 16) | (u32 )x_cutoff;
#line 324
    reg_2838 = (reg_2838 << 16) | (u32 )x_cutoff;
#line 325
    reg_283c = master_width >> 2;
#line 326
    reg_2844 = master_width >> 1;
#line 327
    reg_2854 = master_width;
#line 328
    reg_285c = master_width >> 1;
#line 329
    reg_2864 = master_width >> 1;
#line 330
    reg_2870 = (((reg_2870_offset << 14) & 4294901760U) | (reg_2870_offset >> 1)) + reg_2870;
#line 331
    reg_2870 = ((5U - (f->src_w * 3U - 1U) / f->dst_w) << 16) + reg_2870;
#line 332
    reg_2874 = 1U;
  }
#line 336
  if (f->src_w == f->dst_w) {
#line 338
    h_filter = 0;
  } else {
#line 341
    h_filter = (int )((f->src_w << 16) / f->dst_w >> 15);
#line 342
    h_filter = (h_filter >> 1) + (h_filter & 1);
#line 344
    h_filter = (h_filter == 0) + h_filter;
  }
#line 347
  writel(reg_2834, itv->reg_mem + 10292UL);
#line 348
  writel(reg_2838, itv->reg_mem + 10296UL);
#line 349
  if ((ivtv_debug & 256) != 0) {
#line 349
    printk("\016%s:  yuv: Update reg 0x2834 %08x->%08x 0x2838 %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2834, reg_2834, yi->reg_2838, reg_2838);
  } else {

  }
#line 352
  writel(reg_283c, itv->reg_mem + 10300UL);
#line 353
  writel(reg_2844, itv->reg_mem + 10308UL);
#line 355
  if ((ivtv_debug & 256) != 0) {
#line 355
    printk("\016%s:  yuv: Update reg 0x283c %08x->%08x 0x2844 %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_283c, reg_283c, yi->reg_2844, reg_2844);
  } else {

  }
#line 358
  writel(525588U, itv->reg_mem + 10304UL);
#line 359
  writel(1049876U, itv->reg_mem + 10312UL);
#line 360
  if ((ivtv_debug & 256) != 0) {
#line 360
    printk("\016%s:  yuv: Update reg 0x2840 %08x->%08x 0x2848 %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2840, 525588, yi->reg_2848, 1049876);
  } else {

  }
#line 363
  writel(reg_2854, itv->reg_mem + 10324UL);
#line 364
  if ((ivtv_debug & 256) != 0) {
#line 364
    printk("\016%s:  yuv: Update reg 0x2854 %08x->%08x \n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2854, reg_2854);
  } else {

  }
#line 367
  writel(reg_285c, itv->reg_mem + 10332UL);
#line 368
  writel(reg_2864, itv->reg_mem + 10340UL);
#line 369
  if ((ivtv_debug & 256) != 0) {
#line 369
    printk("\016%s:  yuv: Update reg 0x285c %08x->%08x 0x2864 %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_285c, reg_285c, yi->reg_2864, reg_2864);
  } else {

  }
#line 372
  writel(reg_2874, itv->reg_mem + 10356UL);
#line 373
  if ((ivtv_debug & 256) != 0) {
#line 373
    printk("\016%s:  yuv: Update reg 0x2874 %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2874, reg_2874);
  } else {

  }
#line 376
  writel(reg_2870, itv->reg_mem + 10352UL);
#line 377
  if ((ivtv_debug & 256) != 0) {
#line 377
    printk("\016%s:  yuv: Update reg 0x2870 %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2870, reg_2870);
  } else {

  }
#line 380
  writel(reg_2890, itv->reg_mem + 10384UL);
#line 381
  if ((ivtv_debug & 256) != 0) {
#line 381
    printk("\016%s:  yuv: Update reg 0x2890 %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2890, reg_2890);
  } else {

  }
#line 385
  if (yi->h_filter != h_filter) {
#line 386
    ivtv_yuv_filter(itv, h_filter, -1, -1);
#line 387
    yi->h_filter = h_filter;
  } else {

  }
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
static void ivtv_yuv_handle_vertical(struct ivtv *itv , struct yuv_frame_info *f ) 
{ 
  struct yuv_playback_info *yi ;
  u32 master_height ;
  u32 reg_2918 ;
  u32 reg_291c ;
  u32 reg_2920 ;
  u32 reg_2928 ;
  u32 reg_2930 ;
  u32 reg_2934 ;
  u32 reg_293c ;
  u32 reg_2940 ;
  u32 reg_2944 ;
  u32 reg_294c ;
  u32 reg_2950 ;
  u32 reg_2954 ;
  u32 reg_2958 ;
  u32 reg_295c ;
  u32 reg_2960 ;
  u32 reg_2964 ;
  u32 reg_2968 ;
  u32 reg_296c ;
  u32 reg_289c ;
  u32 src_major_y ;
  u32 src_minor_y ;
  u32 src_major_uv ;
  u32 src_minor_uv ;
  u32 reg_2964_base ;
  u32 reg_2968_base ;
  int v_filter_1 ;
  int v_filter_2 ;

  {
#line 393
  yi = & itv->yuv_info;
#line 406
  if (ivtv_debug & 1) {
#line 406
    printk("\016%s:  warn: Adjust to height %d src_h %d dst_h %d src_y %d dst_y %d\n",
           (char *)(& itv->v4l2_dev.name), f->tru_h, f->src_h, f->dst_h, f->src_y,
           f->dst_y);
  } else {

  }
#line 411
  if ((ivtv_debug & 256) != 0) {
#line 411
    printk("\016%s:  yuv: Scaling mode Y: %s\n", (char *)(& itv->v4l2_dev.name), f->interlaced_y != 0U ? (char *)"Interlaced" : (char *)"Progressive");
  } else {

  }
#line 414
  if ((ivtv_debug & 256) != 0) {
#line 414
    printk("\016%s:  yuv: Scaling mode UV: %s\n", (char *)(& itv->v4l2_dev.name),
           f->interlaced_uv != 0U ? (char *)"Interlaced" : (char *)"Progressive");
  } else {

  }
#line 418
  if (ivtv_debug & 1) {
#line 418
    printk("\016%s:  warn: Source video: %s\n", (char *)(& itv->v4l2_dev.name), f->interlaced != 0U ? (char *)"Interlaced" : (char *)"Progressive");
  } else {

  }
#line 423
  if (f->src_y <= 7) {
#line 424
    src_minor_uv = (u32 )f->src_y;
#line 425
    src_major_uv = 0U;
  } else {
#line 427
    src_minor_uv = 8U;
#line 428
    src_major_uv = (u32 )(f->src_y + -8);
  }
#line 431
  src_minor_y = src_minor_uv;
#line 432
  src_major_y = src_major_uv;
#line 434
  if (f->offset_y != 0U) {
#line 435
    src_minor_y = src_minor_y + 16U;
  } else {

  }
#line 437
  if (f->interlaced_y != 0U) {
#line 438
    reg_2918 = (f->dst_h << 16) | (f->src_h + src_minor_y);
  } else {
#line 440
    reg_2918 = (f->dst_h << 16) | ((f->src_h + src_minor_y) << 1);
  }
#line 442
  if (f->interlaced_uv != 0U) {
#line 443
    reg_291c = (f->dst_h << 16) | ((f->src_h + src_minor_uv) >> 1);
  } else {
#line 445
    reg_291c = (f->dst_h << 16) | (f->src_h + src_minor_uv);
  }
#line 447
  reg_2964_base = ((f->dst_h << 16) / f->src_h) * src_minor_y >> 14;
#line 448
  reg_2968_base = ((f->dst_h << 16) / f->src_h) * src_minor_uv >> 14;
#line 450
  if (f->dst_h / 2U >= f->src_h && f->interlaced_y == 0U) {
#line 451
    master_height = (f->src_h * 4194304U) / f->dst_h;
#line 452
    if (f->src_h * 4194304U - f->dst_h * master_height >= f->dst_h / 2U) {
#line 453
      master_height = master_height + 1U;
    } else {

    }
#line 454
    reg_2920 = master_height >> 2;
#line 455
    reg_2928 = master_height >> 3;
#line 456
    reg_2930 = master_height;
#line 457
    reg_2940 = master_height >> 1;
#line 458
    reg_2964_base = reg_2964_base >> 3;
#line 459
    reg_2968_base = reg_2968_base >> 3;
#line 460
    reg_296c = 0U;
  } else
#line 461
  if (f->dst_h >= f->src_h) {
#line 462
    master_height = (f->src_h * 4194304U) / f->dst_h;
#line 463
    master_height = (master_height >> 1) + (master_height & 1U);
#line 464
    reg_2920 = master_height >> 2;
#line 465
    reg_2928 = master_height >> 2;
#line 466
    reg_2930 = master_height;
#line 467
    reg_2940 = master_height >> 1;
#line 468
    reg_296c = 0U;
#line 469
    if (f->interlaced_y != 0U) {
#line 470
      reg_2964_base = reg_2964_base >> 3;
    } else {
#line 472
      reg_296c = reg_296c + 1U;
#line 473
      reg_2964_base = reg_2964_base >> 2;
    }
#line 475
    if (f->interlaced_uv != 0U) {
#line 476
      reg_2928 = reg_2928 >> 1;
    } else {

    }
#line 477
    reg_2968_base = reg_2968_base >> 3;
  } else
#line 478
  if (f->dst_h >= f->src_h / 2U) {
#line 479
    master_height = (f->src_h * 2097152U) / f->dst_h;
#line 480
    master_height = (master_height >> 1) + (master_height & 1U);
#line 481
    reg_2920 = master_height >> 2;
#line 482
    reg_2928 = master_height >> 2;
#line 483
    reg_2930 = master_height;
#line 484
    reg_2940 = master_height;
#line 485
    reg_296c = 257U;
#line 486
    if (f->interlaced_y != 0U) {
#line 487
      reg_2964_base = reg_2964_base >> 2;
    } else {
#line 489
      reg_296c = reg_296c + 1U;
#line 490
      reg_2964_base = reg_2964_base >> 1;
    }
#line 492
    if (f->interlaced_uv != 0U) {
#line 493
      reg_2928 = reg_2928 >> 1;
    } else {

    }
#line 494
    reg_2968_base = reg_2968_base >> 2;
  } else {
#line 496
    master_height = (f->src_h * 1048576U) / f->dst_h;
#line 497
    master_height = (master_height >> 1) + (master_height & 1U);
#line 498
    reg_2920 = master_height >> 2;
#line 499
    reg_2928 = master_height >> 2;
#line 500
    reg_2930 = master_height;
#line 501
    reg_2940 = master_height;
#line 502
    reg_2964_base = reg_2964_base >> 1;
#line 503
    reg_2968_base = reg_2968_base >> 2;
#line 504
    reg_296c = 258U;
  }
#line 509
  if (f->src_h == f->dst_h) {
#line 510
    reg_2934 = 131072U;
#line 511
    reg_293c = 1048576U;
#line 512
    reg_2944 = 262144U;
#line 513
    reg_294c = 720896U;
  } else {
#line 515
    reg_2934 = 4080U;
#line 516
    reg_293c = 4080U;
#line 517
    reg_2944 = 4080U;
#line 518
    reg_294c = 4080U;
  }
#line 522
  reg_2950 = src_major_y + 65536U;
#line 523
  if (f->interlaced_y != 0U) {
#line 524
    reg_2950 = reg_2950 + 65536U;
  } else {

  }
#line 525
  reg_2954 = reg_2950 + 1U;
#line 527
  reg_2958 = (src_major_y >> 1) + 65536U;
#line 528
  if (f->interlaced_uv != 0U) {
#line 529
    reg_2958 = reg_2958 + 65536U;
  } else {

  }
#line 530
  reg_295c = reg_2958 + 1U;
#line 532
  if (yi->decode_height == 480) {
#line 533
    reg_289c = 18743319U;
  } else {
#line 535
    reg_289c = 22020119U;
  }
#line 537
  if (f->dst_y < 0) {
#line 538
    reg_289c = (reg_289c - (u32 )((f->dst_y & -2) << 15)) - (u32 )(f->dst_y >> 1);
  } else {
#line 540
    reg_289c = ((u32 )((f->dst_y & -2) << 15) + reg_289c) + (u32 )(f->dst_y >> 1);
  }
#line 544
  reg_2960 = (((f->src_h + src_minor_y) + src_major_y) - 1U) | (((((f->src_h + src_minor_uv) + src_major_uv) - 1U) & 4294967294U) << 15);
#line 548
  if (f->src_h == f->dst_h) {
#line 549
    reg_2964 = 1U;
  } else {
#line 551
    reg_2964 = (f->dst_h << 1) / f->src_h + 2U;
#line 552
    reg_2964 = (reg_2964 >> 1) + (reg_2964 & 1U);
  }
#line 554
  reg_2968 = ((reg_2964 << 16) + reg_2964) + (reg_2964 >> 1);
#line 555
  reg_2964 = ((reg_2964 << 16) + reg_2964) + (reg_2964 * 46U) / 94U;
#line 560
  reg_2964 = ((reg_2964 & 65535U) - (reg_2964 >> 16)) + 65537U;
#line 561
  reg_2968 = ((reg_2968 & 65535U) - (reg_2968 >> 16)) + 65537U;
#line 566
  if (reg_2964 != 65537U && f->dst_h / 2U <= f->src_h) {
#line 567
    reg_2964 = (reg_2964 & 4294901760U) + (reg_2964 & 65535U) / 2U;
  } else {

  }
#line 569
  if (f->interlaced_y == 0U) {
#line 570
    reg_2964 = reg_2964 - 65537U;
  } else {

  }
#line 571
  if (f->interlaced_uv == 0U) {
#line 572
    reg_2968 = reg_2968 - 65537U;
  } else {

  }
#line 574
  reg_2964 = ((reg_2964_base << 16) | reg_2964_base) + reg_2964;
#line 575
  reg_2968 = ((reg_2968_base << 16) | reg_2968_base) + reg_2968;
#line 578
  if (f->src_h == f->dst_h) {
#line 580
    v_filter_1 = 0;
#line 581
    v_filter_2 = 1;
  } else {
#line 584
    v_filter_1 = (int )((f->src_h << 16) / f->dst_h >> 15);
#line 585
    v_filter_1 = (v_filter_1 >> 1) + (v_filter_1 & 1);
#line 587
    v_filter_1 = (v_filter_1 == 0) + v_filter_1;
#line 588
    v_filter_2 = v_filter_1;
  }
#line 591
  writel(reg_2934, itv->reg_mem + 10548UL);
#line 592
  writel(reg_293c, itv->reg_mem + 10556UL);
#line 593
  if ((ivtv_debug & 256) != 0) {
#line 593
    printk("\016%s:  yuv: Update reg 0x2934 %08x->%08x 0x293c %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2934, reg_2934, yi->reg_293c, reg_293c);
  } else {

  }
#line 595
  writel(reg_2944, itv->reg_mem + 10564UL);
#line 596
  writel(reg_294c, itv->reg_mem + 10572UL);
#line 597
  if ((ivtv_debug & 256) != 0) {
#line 597
    printk("\016%s:  yuv: Update reg 0x2944 %08x->%08x 0x294c %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2944, reg_2944, yi->reg_294c, reg_294c);
  } else {

  }
#line 604
  writel(reg_2930, itv->reg_mem + 10552UL);
#line 605
  writel(reg_2930, itv->reg_mem + 10544UL);
#line 606
  if ((ivtv_debug & 256) != 0) {
#line 606
    printk("\016%s:  yuv: Update reg 0x2930 %08x->%08x 0x2938 %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2930, reg_2930, yi->reg_2938, reg_2930);
  } else {

  }
#line 609
  writel(reg_2928, itv->reg_mem + 10536UL);
#line 610
  writel(reg_2928 + 1300U, itv->reg_mem + 10540UL);
#line 611
  if ((ivtv_debug & 256) != 0) {
#line 611
    printk("\016%s:  yuv: Update reg 0x2928 %08x->%08x 0x292c %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2928, reg_2928, yi->reg_292c, reg_2928 + 1300U);
  } else {

  }
#line 614
  writel(reg_2920, itv->reg_mem + 10528UL);
#line 615
  writel(reg_2920 + 1300U, itv->reg_mem + 10532UL);
#line 616
  if ((ivtv_debug & 256) != 0) {
#line 616
    printk("\016%s:  yuv: Update reg 0x2920 %08x->%08x 0x2924 %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2920, reg_2920, yi->reg_2924, reg_2920 + 1300U);
  } else {

  }
#line 619
  writel(reg_2918, itv->reg_mem + 10520UL);
#line 620
  writel(reg_291c, itv->reg_mem + 10524UL);
#line 621
  if ((ivtv_debug & 256) != 0) {
#line 621
    printk("\016%s:  yuv: Update reg 0x2918 %08x->%08x 0x291C %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2918, reg_2918, yi->reg_291c, reg_291c);
  } else {

  }
#line 624
  writel(reg_296c, itv->reg_mem + 10604UL);
#line 625
  if ((ivtv_debug & 256) != 0) {
#line 625
    printk("\016%s:  yuv: Update reg 0x296c %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_296c, reg_296c);
  } else {

  }
#line 628
  writel(reg_2940, itv->reg_mem + 10568UL);
#line 629
  writel(reg_2940, itv->reg_mem + 10560UL);
#line 630
  if ((ivtv_debug & 256) != 0) {
#line 630
    printk("\016%s:  yuv: Update reg 0x2940 %08x->%08x 0x2948 %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2940, reg_2940, yi->reg_2948, reg_2940);
  } else {

  }
#line 633
  writel(reg_2950, itv->reg_mem + 10576UL);
#line 634
  writel(reg_2954, itv->reg_mem + 10580UL);
#line 635
  if ((ivtv_debug & 256) != 0) {
#line 635
    printk("\016%s:  yuv: Update reg 0x2950 %08x->%08x 0x2954 %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2950, reg_2950, yi->reg_2954, reg_2954);
  } else {

  }
#line 638
  writel(reg_2958, itv->reg_mem + 10584UL);
#line 639
  writel(reg_295c, itv->reg_mem + 10588UL);
#line 640
  if ((ivtv_debug & 256) != 0) {
#line 640
    printk("\016%s:  yuv: Update reg 0x2958 %08x->%08x 0x295C %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2958, reg_2958, yi->reg_295c, reg_295c);
  } else {

  }
#line 643
  writel(reg_2960, itv->reg_mem + 10592UL);
#line 644
  if ((ivtv_debug & 256) != 0) {
#line 644
    printk("\016%s:  yuv: Update reg 0x2960 %08x->%08x \n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2960, reg_2960);
  } else {

  }
#line 647
  writel(reg_2964, itv->reg_mem + 10596UL);
#line 648
  writel(reg_2968, itv->reg_mem + 10600UL);
#line 649
  if ((ivtv_debug & 256) != 0) {
#line 649
    printk("\016%s:  yuv: Update reg 0x2964 %08x->%08x 0x2968 %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_2964, reg_2964, yi->reg_2968, reg_2968);
  } else {

  }
#line 652
  writel(reg_289c, itv->reg_mem + 10396UL);
#line 653
  if ((ivtv_debug & 256) != 0) {
#line 653
    printk("\016%s:  yuv: Update reg 0x289c %08x->%08x\n", (char *)(& itv->v4l2_dev.name),
           yi->reg_289c, reg_289c);
  } else {

  }
#line 657
  if (yi->v_filter_1 != v_filter_1) {
#line 658
    ivtv_yuv_filter(itv, -1, v_filter_1, -1);
#line 659
    yi->v_filter_1 = v_filter_1;
  } else {

  }
#line 663
  if (yi->v_filter_2 != v_filter_2) {
#line 664
    ivtv_yuv_filter(itv, -1, -1, v_filter_2);
#line 665
    yi->v_filter_2 = v_filter_2;
  } else {

  }
#line 667
  return;
}
}
#line 670 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
static u32 ivtv_yuv_window_setup(struct ivtv *itv , struct yuv_frame_info *f ) 
{ 
  struct yuv_frame_info *of ;
  int osd_crop ;
  u32 osd_scale ;
  u32 yuv_update ;

  {
#line 672
  of = & itv->yuv_info.old_frame_info;
#line 675
  yuv_update = 0U;
#line 678
  if (f->src_x < 0) {
#line 679
    f->src_x = 0;
  } else {

  }
#line 680
  if (f->src_y < 0) {
#line 681
    f->src_y = 0;
  } else {

  }
#line 684
  osd_crop = (int )(f->src_w - f->dst_w * 4U);
#line 684
  if (osd_crop > 0) {
#line 685
    f->src_x = f->src_x + osd_crop / 2;
#line 686
    f->src_w = (f->src_w - (u32 )osd_crop) & 4294967292U;
#line 687
    f->dst_w = f->src_w / 4U;
#line 688
    f->dst_w = f->dst_w + (f->dst_w & 1U);
  } else {

  }
#line 692
  if (f->src_h / f->dst_h > 1U) {
#line 695
    f->interlaced_y = 1U;
#line 697
    osd_crop = (int )(f->src_h - f->dst_h * 4U);
#line 697
    if (osd_crop > 0) {
#line 699
      f->src_y = f->src_y + osd_crop / 2;
#line 700
      f->src_h = (f->src_h - (u32 )osd_crop) & 4294967292U;
#line 701
      f->dst_h = f->src_h / 4U;
#line 702
      f->dst_h = f->dst_h + (f->dst_h & 1U);
    } else {

    }
  } else {

  }
#line 707
  if ((((int )f->dst_w <= 2 || (int )f->dst_h <= 2) || (int )f->src_w <= 2) || (int )f->src_h <= 2) {
#line 709
    return (4U);
  } else {

  }
#line 713
  osd_scale = (f->src_h << 16) / f->dst_h;
#line 715
  osd_crop = f->pan_y - f->dst_y;
#line 715
  if (osd_crop > 0) {
#line 717
    f->src_y = (s32 )((u32 )f->src_y + (osd_scale * (u32 )osd_crop >> 16));
#line 718
    f->src_h = f->src_h - (osd_scale * (u32 )osd_crop >> 16);
#line 719
    f->dst_h = f->dst_h - (u32 )osd_crop;
#line 720
    f->dst_y = 0;
  } else {
#line 722
    f->dst_y = f->dst_y - f->pan_y;
  }
#line 725
  osd_crop = (int )((f->dst_h + (u32 )f->dst_y) - f->vis_h);
#line 725
  if (osd_crop > 0) {
#line 727
    f->dst_h = f->dst_h - (u32 )osd_crop;
#line 728
    f->src_h = f->src_h - (osd_scale * (u32 )osd_crop >> 16);
  } else {

  }
#line 731
  osd_scale = (f->src_w << 16) / f->dst_w;
#line 733
  osd_crop = f->pan_x - f->dst_x;
#line 733
  if (osd_crop > 0) {
#line 735
    f->src_x = (s32 )((u32 )f->src_x + (osd_scale * (u32 )osd_crop >> 16));
#line 736
    f->src_w = f->src_w - (osd_scale * (u32 )osd_crop >> 16);
#line 737
    f->dst_w = f->dst_w - (u32 )osd_crop;
#line 738
    f->dst_x = 0;
  } else {
#line 740
    f->dst_x = f->dst_x - f->pan_x;
  }
#line 743
  osd_crop = (int )((f->dst_w + (u32 )f->dst_x) - f->vis_w);
#line 743
  if (osd_crop > 0) {
#line 745
    f->dst_w = f->dst_w - (u32 )osd_crop;
#line 746
    f->src_w = f->src_w - (osd_scale * (u32 )osd_crop >> 16);
  } else {

  }
#line 749
  if ((unsigned int )itv->yuv_info.track_osd != 0U) {
#line 751
    f->dst_x = (s32 )((u32 )f->dst_x + itv->yuv_info.osd_x_offset);
#line 752
    f->dst_y = (s32 )((u32 )f->dst_y + itv->yuv_info.osd_y_offset);
  } else {

  }
#line 757
  f->dst_w = f->dst_w & 4294967294U;
#line 758
  f->dst_x = f->dst_x & -2;
#line 760
  f->src_w = f->src_w + ((u32 )f->src_x & 1U);
#line 761
  f->src_x = f->src_x & -2;
#line 763
  f->src_w = f->src_w & 4294967294U;
#line 764
  f->dst_w = f->dst_w & 4294967294U;
#line 766
  f->dst_h = f->dst_h & 4294967294U;
#line 767
  f->dst_y = f->dst_y & -2;
#line 769
  f->src_h = f->src_h + ((u32 )f->src_y & 1U);
#line 770
  f->src_y = f->src_y & -2;
#line 772
  f->src_h = f->src_h & 4294967294U;
#line 773
  f->dst_h = f->dst_h & 4294967294U;
#line 778
  if (f->dst_w < f->src_w / 4U) {
#line 779
    f->src_w = f->src_w & 4294967292U;
#line 780
    f->dst_w = f->src_w / 4U;
#line 781
    f->dst_w = f->dst_w + (f->dst_w & 1U);
  } else {

  }
#line 783
  if (f->dst_h < f->src_h / 4U) {
#line 784
    f->src_h = f->src_h & 4294967292U;
#line 785
    f->dst_h = f->src_h / 4U;
#line 786
    f->dst_h = f->dst_h + (f->dst_h & 1U);
  } else {

  }
#line 790
  if ((((int )f->dst_w <= 2 || (int )f->dst_h <= 2) || (int )f->src_w <= 2) || (int )f->src_h <= 2) {
#line 792
    return (4U);
  } else {

  }
#line 796
  if (((((of->dst_w != f->dst_w || of->src_w != f->src_w) || of->dst_x != f->dst_x) || of->src_x != f->src_x) || of->pan_x != f->pan_x) || of->vis_w != f->vis_w) {
#line 799
    yuv_update = yuv_update | 1U;
  } else {

  }
#line 802
  if ((((((((of->src_h != f->src_h || of->dst_h != f->dst_h) || of->dst_y != f->dst_y) || of->src_y != f->src_y) || of->pan_y != f->pan_y) || of->vis_h != f->vis_h) || of->lace_mode != f->lace_mode) || of->interlaced_y != f->interlaced_y) || of->interlaced_uv != f->interlaced_uv) {
#line 808
    yuv_update = yuv_update | 2U;
  } else {

  }
#line 811
  return (yuv_update);
}
}
#line 815 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
void ivtv_yuv_work_handler(struct ivtv *itv ) 
{ 
  struct yuv_playback_info *yi ;
  struct yuv_frame_info f ;
  int frame ;
  u32 yuv_update ;

  {
#line 817
  yi = & itv->yuv_info;
#line 819
  frame = yi->update_frame;
#line 822
  if ((ivtv_debug & 256) != 0) {
#line 822
    printk("\016%s:  yuv: Update yuv registers for frame %d\n", (char *)(& itv->v4l2_dev.name),
           frame);
  } else {

  }
#line 823
  f = yi->new_frame_info[frame];
#line 825
  if ((unsigned int )yi->track_osd != 0U) {
#line 827
    f.pan_x = (s32 )yi->osd_x_pan;
#line 828
    f.pan_y = (s32 )yi->osd_y_pan;
#line 829
    f.vis_w = yi->osd_vis_w;
#line 830
    f.vis_h = yi->osd_vis_h;
  } else {
#line 833
    f.pan_x = 0;
#line 834
    f.pan_y = 0;
#line 835
    f.vis_w = 720U;
#line 836
    f.vis_h = (u32 )yi->decode_height;
  }
#line 840
  yuv_update = ivtv_yuv_window_setup(itv, & f);
#line 840
  if (yuv_update == 0U) {
#line 841
    return;
  } else {

  }
#line 843
  if ((yuv_update & 4U) != 0U) {
#line 844
    writel(16810112U, itv->reg_mem + 10392UL);
  } else
#line 845
  if (yuv_update != 0U) {
#line 846
    writel(1081472U, itv->reg_mem + 10392UL);
#line 848
    if ((int )yuv_update & 1) {
#line 849
      ivtv_yuv_handle_horizontal(itv, & f);
    } else {

    }
#line 851
    if ((yuv_update & 2U) != 0U) {
#line 852
      ivtv_yuv_handle_vertical(itv, & f);
    } else {

    }
  } else {

  }
#line 854
  yi->old_frame_info = f;
#line 855
  return;
}
}
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
static void ivtv_yuv_init(struct ivtv *itv ) 
{ 
  struct yuv_playback_info *yi ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 859
  yi = & itv->yuv_info;
#line 861
  if ((ivtv_debug & 256) != 0) {
#line 861
    printk("\016%s:  yuv: ivtv_yuv_init\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 864
  yi->reg_2834 = readl((void const volatile   *)itv->reg_mem + 10292U);
#line 865
  yi->reg_2838 = readl((void const volatile   *)itv->reg_mem + 10296U);
#line 866
  yi->reg_283c = readl((void const volatile   *)itv->reg_mem + 10300U);
#line 867
  yi->reg_2840 = readl((void const volatile   *)itv->reg_mem + 10304U);
#line 868
  yi->reg_2844 = readl((void const volatile   *)itv->reg_mem + 10308U);
#line 869
  yi->reg_2848 = readl((void const volatile   *)itv->reg_mem + 10312U);
#line 870
  yi->reg_2854 = readl((void const volatile   *)itv->reg_mem + 10324U);
#line 871
  yi->reg_285c = readl((void const volatile   *)itv->reg_mem + 10332U);
#line 872
  yi->reg_2864 = readl((void const volatile   *)itv->reg_mem + 10340U);
#line 873
  yi->reg_2870 = readl((void const volatile   *)itv->reg_mem + 10352U);
#line 874
  yi->reg_2874 = readl((void const volatile   *)itv->reg_mem + 10356U);
#line 875
  yi->reg_2898 = readl((void const volatile   *)itv->reg_mem + 10392U);
#line 876
  yi->reg_2890 = readl((void const volatile   *)itv->reg_mem + 10384U);
#line 878
  yi->reg_289c = readl((void const volatile   *)itv->reg_mem + 10396U);
#line 879
  yi->reg_2918 = readl((void const volatile   *)itv->reg_mem + 10520U);
#line 880
  yi->reg_291c = readl((void const volatile   *)itv->reg_mem + 10524U);
#line 881
  yi->reg_2920 = readl((void const volatile   *)itv->reg_mem + 10528U);
#line 882
  yi->reg_2924 = readl((void const volatile   *)itv->reg_mem + 10532U);
#line 883
  yi->reg_2928 = readl((void const volatile   *)itv->reg_mem + 10536U);
#line 884
  yi->reg_292c = readl((void const volatile   *)itv->reg_mem + 10540U);
#line 885
  yi->reg_2930 = readl((void const volatile   *)itv->reg_mem + 10544U);
#line 886
  yi->reg_2934 = readl((void const volatile   *)itv->reg_mem + 10548U);
#line 887
  yi->reg_2938 = readl((void const volatile   *)itv->reg_mem + 10552U);
#line 888
  yi->reg_293c = readl((void const volatile   *)itv->reg_mem + 10556U);
#line 889
  yi->reg_2940 = readl((void const volatile   *)itv->reg_mem + 10560U);
#line 890
  yi->reg_2944 = readl((void const volatile   *)itv->reg_mem + 10564U);
#line 891
  yi->reg_2948 = readl((void const volatile   *)itv->reg_mem + 10568U);
#line 892
  yi->reg_294c = readl((void const volatile   *)itv->reg_mem + 10572U);
#line 893
  yi->reg_2950 = readl((void const volatile   *)itv->reg_mem + 10576U);
#line 894
  yi->reg_2954 = readl((void const volatile   *)itv->reg_mem + 10580U);
#line 895
  yi->reg_2958 = readl((void const volatile   *)itv->reg_mem + 10584U);
#line 896
  yi->reg_295c = readl((void const volatile   *)itv->reg_mem + 10588U);
#line 897
  yi->reg_2960 = readl((void const volatile   *)itv->reg_mem + 10592U);
#line 898
  yi->reg_2964 = readl((void const volatile   *)itv->reg_mem + 10596U);
#line 899
  yi->reg_2968 = readl((void const volatile   *)itv->reg_mem + 10600U);
#line 900
  yi->reg_296c = readl((void const volatile   *)itv->reg_mem + 10604U);
#line 901
  yi->reg_2970 = readl((void const volatile   *)itv->reg_mem + 10608U);
#line 903
  yi->v_filter_1 = -1;
#line 904
  yi->v_filter_2 = -1;
#line 905
  yi->h_filter = -1;
#line 908
  tmp = readl((void const volatile   *)itv->reg_mem + 10756U);
#line 908
  yi->osd_x_offset = tmp & 4095U;
#line 909
  tmp___0 = readl((void const volatile   *)itv->reg_mem + 10756U);
#line 909
  yi->osd_y_offset = (tmp___0 >> 16) & 4095U;
#line 913
  tmp___1 = readl((void const volatile   *)itv->reg_mem + 10360U);
#line 913
  if ((tmp___1 & 4U) != 0U) {
#line 914
    yi->decode_height = 576;
  } else {
#line 916
    yi->decode_height = 480;
  }
#line 918
  if ((unsigned long )itv->osd_info == (unsigned long )((struct osd_info *)0)) {
#line 919
    yi->osd_vis_w = 720U - yi->osd_x_offset;
#line 920
    yi->osd_vis_h = (u32 )yi->decode_height - yi->osd_y_offset;
  } else {
#line 923
    if (yi->osd_vis_w == 0U) {
#line 924
      yi->osd_vis_w = 720U - yi->osd_x_offset;
    } else {

    }
#line 926
    if (yi->osd_vis_h == 0U) {
#line 927
      yi->osd_vis_h = (u32 )yi->decode_height - yi->osd_y_offset;
    } else
#line 928
    if (yi->osd_vis_h + yi->osd_y_offset > (u32 )yi->decode_height) {
#line 931
      if (ivtv_debug & 1) {
#line 931
        printk("\016%s:  warn: Clipping yuv output - fb size (%d) exceeds video standard limit (%d)\n",
               (char *)(& itv->v4l2_dev.name), yi->osd_vis_h + yi->osd_y_offset, yi->decode_height);
      } else {

      }
#line 934
      yi->osd_vis_h = (u32 )yi->decode_height - yi->osd_y_offset;
    } else {

    }
  }
#line 939
  yi->blanking_ptr = kzalloc(11520UL, 720U);
#line 940
  if ((unsigned long )yi->blanking_ptr != (unsigned long )((void *)0)) {
#line 941
    yi->blanking_dmaptr = pci_map_single(itv->pdev, yi->blanking_ptr, 11520UL, 1);
  } else {
#line 943
    yi->blanking_dmaptr = 0ULL;
#line 944
    if (ivtv_debug & 1) {
#line 944
      printk("\016%s:  warn: Failed to allocate yuv blanking buffer\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
  }
#line 948
  writel(1U, itv->reg_mem + 10240UL);
#line 948
  readl((void const volatile   *)itv->reg_mem + 10240U);
#line 950
  set_bit(12L, (unsigned long volatile   *)(& itv->i_flags));
#line 951
  atomic_set(& yi->next_dma_frame, 0);
#line 952
  return;
}
}
#line 955 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
static void ivtv_yuv_next_free(struct ivtv *itv ) 
{ 
  int draw ;
  int display ;
  struct yuv_playback_info *yi ;
  int tmp ;

  {
#line 958
  yi = & itv->yuv_info;
#line 960
  tmp = atomic_read((atomic_t const   *)(& yi->next_dma_frame));
#line 960
  if (tmp == -1) {
#line 961
    ivtv_yuv_init(itv);
  } else {

  }
#line 963
  draw = atomic_read((atomic_t const   *)(& yi->next_fill_frame));
#line 964
  display = atomic_read((atomic_t const   *)(& yi->next_dma_frame));
#line 966
  if (display > draw) {
#line 967
    display = display + -8;
  } else {

  }
#line 969
  if (draw - display >= (int )yi->max_frames_buffered) {
#line 970
    draw = (int )((unsigned int )((unsigned char )draw) - 1U) & 7;
  } else {
#line 972
    yi->new_frame_info[draw].update = 0U;
  }
#line 974
  yi->draw_frame = (u8 )draw;
#line 975
  return;
}
}
#line 978 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
static void ivtv_yuv_setup_frame(struct ivtv *itv , struct ivtv_dma_frame *args ) 
{ 
  struct yuv_playback_info *yi ;
  u8 frame ;
  u8 last_frame ;
  struct yuv_frame_info *nf ;
  struct yuv_frame_info *of ;
  int lace_threshold ;
  int update ;
  int tmp ;

  {
#line 980
  yi = & itv->yuv_info;
#line 981
  frame = yi->draw_frame;
#line 982
  last_frame = (unsigned int )((u8 )((unsigned int )frame - 1U)) & 7U;
#line 983
  nf = (struct yuv_frame_info *)(& yi->new_frame_info) + (unsigned long )frame;
#line 984
  of = (struct yuv_frame_info *)(& yi->new_frame_info) + (unsigned long )last_frame;
#line 985
  lace_threshold = yi->lace_threshold;
#line 988
  update = (int )nf->update;
#line 991
  nf->src_x = args->src.left;
#line 992
  nf->src_y = args->src.top;
#line 993
  nf->src_w = args->src.width;
#line 994
  nf->src_h = args->src.height;
#line 995
  nf->dst_x = args->dst.left;
#line 996
  nf->dst_y = args->dst.top;
#line 997
  nf->dst_w = args->dst.width;
#line 998
  nf->dst_h = args->dst.height;
#line 999
  nf->tru_x = args->dst.left;
#line 1000
  nf->tru_w = args->src_width;
#line 1001
  nf->tru_h = args->src_height;
#line 1004
  nf->offset_y = nf->tru_h + (u32 )nf->src_x <= 495U;
#line 1006
  nf->update = 0U;
#line 1007
  nf->interlaced_y = 0U;
#line 1008
  nf->interlaced_uv = 0U;
#line 1009
  nf->delay = 0U;
#line 1010
  nf->sync_field = 0U;
#line 1011
  nf->lace_mode = yi->lace_mode & 3;
#line 1013
  if (lace_threshold < 0) {
#line 1014
    lace_threshold = yi->decode_height + -1;
  } else {

  }
#line 1017
  switch (nf->lace_mode) {
  case 1: 
#line 1019
  nf->interlaced = 0U;
#line 1020
  if (nf->tru_h <= 511U || (nf->tru_h > 576U && nf->tru_h <= 1020U)) {
#line 1021
    nf->interlaced_y = 0U;
  } else {
#line 1023
    nf->interlaced_y = 1U;
  }
#line 1025
  if (nf->tru_h <= 1020U && nf->dst_h >= nf->src_h / 2U) {
#line 1026
    nf->interlaced_uv = 0U;
  } else {
#line 1028
    nf->interlaced_uv = 1U;
  }
#line 1029
  goto ldv_39075;
  case 2: ;
#line 1032
  if ((nf->tru_h <= (u32 )lace_threshold || nf->tru_h > 576U) || nf->tru_w > 720U) {
#line 1033
    nf->interlaced = 0U;
#line 1034
    if ((nf->tru_h <= 511U || (nf->tru_h > 576U && nf->tru_h <= 1020U)) || (nf->tru_w > 720U && nf->tru_h <= 1020U)) {
#line 1037
      nf->interlaced_y = 0U;
    } else {
#line 1039
      nf->interlaced_y = 1U;
    }
#line 1040
    if (nf->tru_h <= 1020U && nf->dst_h >= nf->src_h / 2U) {
#line 1041
      nf->interlaced_uv = 0U;
    } else {
#line 1043
      nf->interlaced_uv = 1U;
    }
  } else {
#line 1045
    nf->interlaced = 1U;
#line 1046
    nf->interlaced_y = 1U;
#line 1047
    nf->interlaced_uv = 1U;
  }
#line 1049
  goto ldv_39075;
  case 0: ;
  default: 
#line 1053
  nf->interlaced = 1U;
#line 1054
  nf->interlaced_y = 1U;
#line 1055
  nf->interlaced_uv = 1U;
#line 1056
  goto ldv_39075;
  }
  ldv_39075: 
#line 1059
  tmp = memcmp((void const   *)(& yi->old_frame_info_args), (void const   *)nf, 92UL);
#line 1059
  if (tmp != 0) {
#line 1060
    yi->old_frame_info_args = *nf;
#line 1061
    nf->update = 1U;
#line 1062
    if ((ivtv_debug & 256) != 0) {
#line 1062
      printk("\016%s:  yuv: Requesting reg update for frame %d\n", (char *)(& itv->v4l2_dev.name),
             (int )frame);
    } else {

    }
  } else {

  }
#line 1065
  nf->update = nf->update | (u32 )update;
#line 1066
  nf->sync_field = (u32 )yi->lace_sync_field;
#line 1067
  nf->delay = nf->sync_field != of->sync_field;
#line 1068
  return;
}
}
#line 1071 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
void ivtv_yuv_frame_complete(struct ivtv *itv ) 
{ 


  {
#line 1073
  atomic_set(& itv->yuv_info.next_fill_frame, ((int )itv->yuv_info.draw_frame + 1) % 8);
#line 1075
  return;
}
}
#line 1077 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
static int ivtv_yuv_udma_frame(struct ivtv *itv , struct ivtv_dma_frame *args ) 
{ 
  wait_queue_t wait ;
  struct task_struct *tmp ;
  int rc ;
  int got_sig ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1079
  tmp = get_current();
#line 1079
  wait.flags = 0U;
#line 1079
  wait.private = (void *)tmp;
#line 1079
  wait.func = & autoremove_wake_function;
#line 1079
  wait.task_list.next = & wait.task_list;
#line 1079
  wait.task_list.prev = & wait.task_list;
#line 1080
  rc = 0;
#line 1081
  got_sig = 0;
#line 1083
  mutex_lock_nested(& itv->udma.lock, 0U);
#line 1085
  rc = ivtv_yuv_prep_user_dma(itv, & itv->udma, args);
#line 1085
  if (rc != 0) {
#line 1086
    mutex_unlock(& itv->udma.lock);
#line 1087
    return (rc);
  } else {

  }
#line 1090
  ivtv_udma_prepare(itv);
#line 1091
  prepare_to_wait(& itv->dma_waitq, & wait, 1);
#line 1094
  goto ldv_39091;
  ldv_39090: 
#line 1098
  tmp___0 = get_current();
#line 1098
  got_sig = signal_pending___2(tmp___0);
#line 1099
  if (got_sig != 0) {
#line 1099
    tmp___1 = test_and_clear_bit(2L, (unsigned long volatile   *)(& itv->i_flags));
#line 1099
    if (tmp___1 != 0) {
#line 1100
      goto ldv_39089;
    } else {

    }
  } else {

  }
#line 1101
  got_sig = 0;
#line 1102
  schedule();
  ldv_39091: 
#line 1094
  tmp___2 = constant_test_bit(2L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1094
  if (tmp___2 != 0) {
#line 1096
    goto ldv_39090;
  } else {
#line 1094
    tmp___3 = constant_test_bit(1L, (unsigned long const volatile   *)(& itv->i_flags));
#line 1094
    if (tmp___3 != 0) {
#line 1096
      goto ldv_39090;
    } else {
#line 1099
      goto ldv_39089;
    }
  }
  ldv_39089: 
#line 1104
  finish_wait(& itv->dma_waitq, & wait);
#line 1107
  ivtv_udma_unmap(itv);
#line 1109
  if (got_sig != 0) {
#line 1110
    if ((ivtv_debug & 2) != 0) {
#line 1110
      printk("\016%s:  info: User stopped YUV UDMA\n", (char *)(& itv->v4l2_dev.name));
    } else {

    }
#line 1111
    mutex_unlock(& itv->udma.lock);
#line 1112
    return (-4);
  } else {

  }
#line 1115
  ivtv_yuv_frame_complete(itv);
#line 1117
  mutex_unlock(& itv->udma.lock);
#line 1118
  return (rc);
}
}
#line 1122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
void ivtv_yuv_setup_stream_frame(struct ivtv *itv ) 
{ 
  struct yuv_playback_info *yi ;
  struct ivtv_dma_frame dma_args ;

  {
#line 1124
  yi = & itv->yuv_info;
#line 1127
  ivtv_yuv_next_free(itv);
#line 1130
  dma_args.y_source = (void *)0;
#line 1131
  dma_args.uv_source = (void *)0;
#line 1132
  dma_args.src.left = 0;
#line 1133
  dma_args.src.top = 0;
#line 1134
  dma_args.src.width = yi->v4l2_src_w;
#line 1135
  dma_args.src.height = yi->v4l2_src_h;
#line 1136
  dma_args.dst = yi->main_rect;
#line 1137
  dma_args.src_width = yi->v4l2_src_w;
#line 1138
  dma_args.src_height = yi->v4l2_src_h;
#line 1141
  ivtv_yuv_setup_frame(itv, & dma_args);
#line 1143
  if (itv->dma_data_req_offset == 0U) {
#line 1144
    itv->dma_data_req_offset = yuv_offset[(int )yi->draw_frame];
  } else {

  }
#line 1145
  return;
}
}
#line 1148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
int ivtv_yuv_udma_stream_frame(struct ivtv *itv , void *src ) 
{ 
  struct yuv_playback_info *yi ;
  struct ivtv_dma_frame dma_args ;
  int res ;

  {
#line 1150
  yi = & itv->yuv_info;
#line 1154
  ivtv_yuv_setup_stream_frame(itv);
#line 1157
  dma_args.y_source = src;
#line 1158
  dma_args.uv_source = src + (unsigned long )(((yi->v4l2_src_h + 31U) & 4294967264U) * 720U);
#line 1162
  mutex_unlock(& itv->serialize_lock);
#line 1163
  res = ivtv_yuv_udma_frame(itv, & dma_args);
#line 1164
  mutex_lock_nested(& itv->serialize_lock, 0U);
#line 1165
  return (res);
}
}
#line 1169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
int ivtv_yuv_prep_frame(struct ivtv *itv , struct ivtv_dma_frame *args ) 
{ 
  int res ;

  {
#line 1174
  ivtv_yuv_next_free(itv);
#line 1175
  ivtv_yuv_setup_frame(itv, args);
#line 1179
  mutex_unlock(& itv->serialize_lock);
#line 1180
  res = ivtv_yuv_udma_frame(itv, args);
#line 1181
  mutex_lock_nested(& itv->serialize_lock, 0U);
#line 1182
  return (res);
}
}
#line 1185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.c"
void ivtv_yuv_close(struct ivtv *itv ) 
{ 
  struct yuv_playback_info *yi ;
  int h_filter ;
  int v_filter_1 ;
  int v_filter_2 ;

  {
#line 1187
  yi = & itv->yuv_info;
#line 1190
  if ((ivtv_debug & 256) != 0) {
#line 1190
    printk("\016%s:  yuv: ivtv_yuv_close\n", (char *)(& itv->v4l2_dev.name));
  } else {

  }
#line 1191
  mutex_unlock(& itv->serialize_lock);
#line 1192
  ivtv_waitq(& itv->vsync_waitq);
#line 1193
  mutex_lock_nested(& itv->serialize_lock, 0U);
#line 1195
  yi->running = 0U;
#line 1196
  atomic_set(& yi->next_dma_frame, -1);
#line 1197
  atomic_set(& yi->next_fill_frame, 0);
#line 1204
  writel(yi->reg_2898 | 16777216U, itv->reg_mem + 10392UL);
#line 1206
  writel(yi->reg_2834, itv->reg_mem + 10292UL);
#line 1207
  writel(yi->reg_2838, itv->reg_mem + 10296UL);
#line 1208
  writel(yi->reg_283c, itv->reg_mem + 10300UL);
#line 1209
  writel(yi->reg_2840, itv->reg_mem + 10304UL);
#line 1210
  writel(yi->reg_2844, itv->reg_mem + 10308UL);
#line 1211
  writel(yi->reg_2848, itv->reg_mem + 10312UL);
#line 1212
  writel(yi->reg_2854, itv->reg_mem + 10324UL);
#line 1213
  writel(yi->reg_285c, itv->reg_mem + 10332UL);
#line 1214
  writel(yi->reg_2864, itv->reg_mem + 10340UL);
#line 1215
  writel(yi->reg_2870, itv->reg_mem + 10352UL);
#line 1216
  writel(yi->reg_2874, itv->reg_mem + 10356UL);
#line 1217
  writel(yi->reg_2890, itv->reg_mem + 10384UL);
#line 1218
  writel(yi->reg_289c, itv->reg_mem + 10396UL);
#line 1220
  writel(yi->reg_2918, itv->reg_mem + 10520UL);
#line 1221
  writel(yi->reg_291c, itv->reg_mem + 10524UL);
#line 1222
  writel(yi->reg_2920, itv->reg_mem + 10528UL);
#line 1223
  writel(yi->reg_2924, itv->reg_mem + 10532UL);
#line 1224
  writel(yi->reg_2928, itv->reg_mem + 10536UL);
#line 1225
  writel(yi->reg_292c, itv->reg_mem + 10540UL);
#line 1226
  writel(yi->reg_2930, itv->reg_mem + 10544UL);
#line 1227
  writel(yi->reg_2934, itv->reg_mem + 10548UL);
#line 1228
  writel(yi->reg_2938, itv->reg_mem + 10552UL);
#line 1229
  writel(yi->reg_293c, itv->reg_mem + 10556UL);
#line 1230
  writel(yi->reg_2940, itv->reg_mem + 10560UL);
#line 1231
  writel(yi->reg_2944, itv->reg_mem + 10564UL);
#line 1232
  writel(yi->reg_2948, itv->reg_mem + 10568UL);
#line 1233
  writel(yi->reg_294c, itv->reg_mem + 10572UL);
#line 1234
  writel(yi->reg_2950, itv->reg_mem + 10576UL);
#line 1235
  writel(yi->reg_2954, itv->reg_mem + 10580UL);
#line 1236
  writel(yi->reg_2958, itv->reg_mem + 10584UL);
#line 1237
  writel(yi->reg_295c, itv->reg_mem + 10588UL);
#line 1238
  writel(yi->reg_2960, itv->reg_mem + 10592UL);
#line 1239
  writel(yi->reg_2964, itv->reg_mem + 10596UL);
#line 1240
  writel(yi->reg_2968, itv->reg_mem + 10600UL);
#line 1241
  writel(yi->reg_296c, itv->reg_mem + 10604UL);
#line 1242
  writel(yi->reg_2970, itv->reg_mem + 10608UL);
#line 1247
  if ((yi->reg_2834 & 65535U) == yi->reg_2834 >> 16) {
#line 1249
    h_filter = 0;
  } else {
#line 1252
    h_filter = (int )((yi->reg_2834 << 16) / (yi->reg_2834 >> 16) >> 15);
#line 1253
    h_filter = (h_filter >> 1) + (h_filter & 1);
#line 1255
    h_filter = (h_filter == 0) + h_filter;
  }
#line 1259
  if ((yi->reg_2918 & 65535U) == yi->reg_2918 >> 16) {
#line 1261
    v_filter_1 = 0;
#line 1262
    v_filter_2 = 1;
  } else {
#line 1265
    v_filter_1 = (int )((yi->reg_2918 << 16) / (yi->reg_2918 >> 16) >> 15);
#line 1266
    v_filter_1 = (v_filter_1 >> 1) + (v_filter_1 & 1);
#line 1268
    v_filter_1 = (v_filter_1 == 0) + v_filter_1;
#line 1269
    v_filter_2 = v_filter_1;
  }
#line 1273
  ivtv_yuv_filter(itv, h_filter, v_filter_1, v_filter_2);
#line 1276
  writel(0U, itv->reg_mem + 10260UL);
#line 1277
  writel(0U, itv->reg_mem + 10284UL);
#line 1278
  writel(0U, itv->reg_mem + 10500UL);
#line 1279
  writel(0U, itv->reg_mem + 10512UL);
#line 1282
  if ((unsigned long )yi->blanking_ptr != (unsigned long )((void *)0)) {
#line 1283
    kfree((void const   *)yi->blanking_ptr);
#line 1284
    yi->blanking_ptr = (void *)0;
#line 1285
    pci_unmap_single(itv->pdev, yi->blanking_dmaptr, 11520UL, 1);
  } else {

  }
#line 1289
  yi->old_frame_info.src_w = 0U;
#line 1290
  yi->old_frame_info.src_h = 0U;
#line 1291
  yi->old_frame_info_args.src_w = 0U;
#line 1292
  yi->old_frame_info_args.src_h = 0U;
#line 1295
  clear_bit(12L, (unsigned long volatile   *)(& itv->i_flags));
#line 1296
  return;
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.o.c.prepared"
bool ldv_queue_work_on_239(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 142
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 142
  ldv_func_res = tmp;
#line 144
  activate_work_2(ldv_func_arg3, 2);
#line 146
  return (ldv_func_res);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.o.c.prepared"
bool ldv_queue_delayed_work_on_240(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 153
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 153
  ldv_func_res = tmp;
#line 155
  activate_work_2(& ldv_func_arg3->work, 2);
#line 157
  return (ldv_func_res);
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.o.c.prepared"
bool ldv_queue_work_on_241(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 164
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 164
  ldv_func_res = tmp;
#line 166
  activate_work_2(ldv_func_arg3, 2);
#line 168
  return (ldv_func_res);
}
}
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.o.c.prepared"
void ldv_flush_workqueue_242(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 174
  flush_workqueue(ldv_func_arg1);
#line 176
  call_and_disable_all_2(2);
#line 177
  return;
}
}
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/dscv/ri/08_1a/drivers/media/pci/ivtv/ivtv-yuv.o.c.prepared"
bool ldv_queue_delayed_work_on_243(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 183
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 183
  ldv_func_res = tmp;
#line 185
  activate_work_2(& ldv_func_arg3->work, 2);
#line 187
  return (ldv_func_res);
}
}
#line 8 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *memset(void * , int  , size_t  ) ;
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 7 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_module_refcounter  =    1;
#line 10 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_get(struct module *module ) 
{ 


  {
#line 13
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 15
    ldv_module_refcounter = ldv_module_refcounter + 1;
  } else {

  }
#line 16
  return;
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_try_module_get(struct module *module ) 
{ 
  int module_get_succeeded ;

  {
#line 25
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 28
    module_get_succeeded = ldv_undef_int();
#line 30
    if (module_get_succeeded == 1) {
#line 32
      ldv_module_refcounter = ldv_module_refcounter + 1;
#line 34
      return (1);
    } else {
#line 39
      return (0);
    }
  } else {

  }
#line 41
  return (0);
}
}
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put(struct module *module ) 
{ 


  {
#line 48
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 50
    if (ldv_module_refcounter <= 1) {
#line 50
      ldv_error();
    } else {

    }
#line 52
    ldv_module_refcounter = ldv_module_refcounter - 1;
  } else {

  }
#line 54
  return;
}
}
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put_and_exit(void) 
{ 


  {
#line 59
  ldv_module_put((struct module *)1);
  LDV_STOP: ;
#line 61
  goto LDV_STOP;
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
unsigned int ldv_module_refcount(void) 
{ 


  {
#line 68
  return ((unsigned int )(ldv_module_refcounter + -1));
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4063/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 75
  if (ldv_module_refcounter != 1) {
#line 75
    ldv_error();
  } else {

  }
#line 79
  return;
}
}
