extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 234 "include/linux/printk.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 555 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 103
struct compat_timespec;
#line 104 "include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 104 "include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 104
struct pollfd;
#line 104 "include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 104 "include/linux/bug.h"
union __anonunion____missing_field_name_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};
#line 104 "include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_19 __annonCompField8 ;
};
#line 328 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_29 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField12 ;
   struct __anonstruct____missing_field_name_30 __annonCompField13 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_31 __annonCompField15 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 33 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField17 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField18 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_46 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_47 kgid_t;
#line 139 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct vm_area_struct;
#line 12 "include/linux/wait.h"
struct __wait_queue;
#line 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 177
struct rw_semaphore;
#line 178 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 172 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 296 "include/linux/rcupdate.h"
struct notifier_block;
#line 1121 "include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 242 "include/linux/timer.h"
struct hrtimer;
#line 243
enum hrtimer_restart;
#line 244 "include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 837 "include/uapi/linux/sysctl.h"
struct ctl_table;
#line 838
struct nsproxy;
#line 839
struct ctl_table_root;
#line 840
struct ctl_table_header;
#line 841
struct ctl_dir;
#line 37 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 57 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 96 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 117 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 122 "include/linux/sysctl.h"
struct __anonstruct____missing_field_name_50 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 122 "include/linux/sysctl.h"
union __anonunion____missing_field_name_49 {
   struct __anonstruct____missing_field_name_50 __annonCompField19 ;
   struct callback_head rcu ;
};
#line 122
struct ctl_table_set;
#line 122 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_49 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 143 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 149 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 154 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 19 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField33 ;
   struct __anonstruct____missing_field_name_149 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_152 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_156 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_154 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_151 {
   union __anonunion____missing_field_name_152 __annonCompField37 ;
   union __anonunion____missing_field_name_153 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_157 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_158 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_159 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32
struct kmem_cache;
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_160 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct __anonstruct____missing_field_name_151 __annonCompField42 ;
   union __anonunion____missing_field_name_157 __annonCompField45 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
union __anonunion____missing_field_name_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 53 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_166 __annonCompField47 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_172 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_172 __annonCompField49 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_180 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_181 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_197 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_199 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_199 __annonCompField52 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_198 __annonCompField53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion____missing_field_name_201 __annonCompField54 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 72 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1161
struct uts_namespace;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769
struct ftrace_ret_stack;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 27 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
struct xpc_rsvd_page;
#line 33
struct xpc_channel;
#line 41
struct xpc_partition;
#line 53
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203
struct of_device_id;
#line 203
struct acpi_device_id;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 34 "./arch/x86/include/asm/kdebug.h"
struct die_args {
   struct pt_regs *regs ;
   char const   *str ;
   long err ;
   int trapnr ;
   int signr ;
};
#line 17 "./arch/x86/include/asm/uv/uv.h"
enum xp_retval {
    xpSuccess = 0,
    xpNotConnected = 1,
    xpConnected = 2,
    xpRETIRED1 = 3,
    xpMsgReceived = 4,
    xpMsgDelivered = 5,
    xpRETIRED2 = 6,
    xpNoWait = 7,
    xpRetry = 8,
    xpTimeout = 9,
    xpInterrupted = 10,
    xpUnequalMsgSizes = 11,
    xpInvalidAddress = 12,
    xpNoMemory = 13,
    xpLackOfResources = 14,
    xpUnregistered = 15,
    xpAlreadyRegistered = 16,
    xpPartitionDown = 17,
    xpNotLoaded = 18,
    xpUnloading = 19,
    xpBadMagic = 20,
    xpReactivating = 21,
    xpUnregistering = 22,
    xpOtherUnregistering = 23,
    xpCloneKThread = 24,
    xpCloneKThreadFailed = 25,
    xpNoHeartbeat = 26,
    xpPioReadError = 27,
    xpPhysAddrRegFailed = 28,
    xpRETIRED3 = 29,
    xpRETIRED4 = 30,
    xpRETIRED5 = 31,
    xpRETIRED6 = 32,
    xpRETIRED7 = 33,
    xpRETIRED8 = 34,
    xpRETIRED9 = 35,
    xpRETIRED10 = 36,
    xpRETIRED11 = 37,
    xpRETIRED12 = 38,
    xpBadVersion = 39,
    xpVarsNotSet = 40,
    xpNoRsvdPageAddr = 41,
    xpInvalidPartid = 42,
    xpLocalPartid = 43,
    xpOtherGoingDown = 44,
    xpSystemGoingDown = 45,
    xpSystemHalt = 46,
    xpSystemReboot = 47,
    xpSystemPoweroff = 48,
    xpDisconnecting = 49,
    xpOpenCloseError = 50,
    xpDisconnected = 51,
    xpBteCopyError = 52,
    xpSalError = 53,
    xpRsvdPageNotSet = 54,
    xpPayloadTooBig = 55,
    xpUnsupported = 56,
    xpNeedMoreInfo = 57,
    xpGruCopyError = 58,
    xpGruSendMqError = 59,
    xpBadChannelNumber = 60,
    xpBadMsgType = 61,
    xpBiosError = 62,
    xpUnknownReason = 63
} ;
#line 357 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xp.h"
struct __anonstruct_sn2_218 {
   unsigned long vars_pa ;
};
#line 357 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xp.h"
struct __anonstruct_uv_219 {
   unsigned long heartbeat_gpa ;
   unsigned long activate_gru_mq_desc_gpa ;
};
#line 357 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xp.h"
union __anonunion_sn_217 {
   struct __anonstruct_sn2_218 sn2 ;
   struct __anonstruct_uv_219 uv ;
};
#line 357 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xp.h"
struct xpc_rsvd_page {
   u64 SAL_signature ;
   u64 SAL_version ;
   short SAL_partid ;
   short max_npartitions ;
   u8 version ;
   u8 pad1[3U] ;
   unsigned long ts_jiffies ;
   union __anonunion_sn_217 sn ;
   u64 pad2[9U] ;
   u64 SAL_nasids_size ;
};
#line 106 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct amo;
#line 162 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_heartbeat_uv {
   unsigned long value ;
   unsigned long offline ;
};
#line 286 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_gp_sn2 {
   s64 get ;
   s64 put ;
};
#line 307 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_openclose_args {
   u16 reason ;
   u16 entry_size ;
   u16 remote_nentries ;
   u16 local_nentries ;
   unsigned long local_msgqueue_pa ;
};
#line 322 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_fifo_entry_uv {
   struct xpc_fifo_entry_uv *next ;
};
#line 335 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_fifo_head_uv {
   struct xpc_fifo_entry_uv *first ;
   struct xpc_fifo_entry_uv *last ;
   spinlock_t lock ;
   int n_entries ;
};
#line 342 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_msg_sn2 {
   u8 flags ;
   u8 reserved[7U] ;
   s64 number ;
   u64 payload ;
};
#line 392 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_notify_sn2 {
   u8 type ;
   void (*func)(enum xp_retval  , short  , int  , void * ) ;
   void *key ;
};
#line 406 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_send_msg_slot_uv {
   struct xpc_fifo_entry_uv next ;
   unsigned int msg_slot_number ;
   void (*func)(enum xp_retval  , short  , int  , void * ) ;
   void *key ;
};
#line 421 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_channel_sn2 {
   struct xpc_openclose_args *local_openclose_args ;
   void *local_msgqueue_base ;
   struct xpc_msg_sn2 *local_msgqueue ;
   void *remote_msgqueue_base ;
   struct xpc_msg_sn2 *remote_msgqueue ;
   unsigned long remote_msgqueue_pa ;
   struct xpc_notify_sn2 *notify_queue ;
   struct xpc_gp_sn2 *local_GP ;
   struct xpc_gp_sn2 remote_GP ;
   struct xpc_gp_sn2 w_local_GP ;
   struct xpc_gp_sn2 w_remote_GP ;
   s64 next_msg_to_pull ;
   struct mutex msg_to_pull_mutex ;
};
#line 529 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_channel_uv {
   void *cached_notify_gru_mq_desc ;
   struct xpc_send_msg_slot_uv *send_msg_slots ;
   void *recv_msg_slots ;
   struct xpc_fifo_head_uv msg_slot_free_list ;
   struct xpc_fifo_head_uv recv_msg_list ;
};
#line 541 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
union __anonunion_sn_221 {
   struct xpc_channel_sn2 sn2 ;
   struct xpc_channel_uv uv ;
};
#line 541 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_channel {
   short partid ;
   spinlock_t lock ;
   unsigned int flags ;
   enum xp_retval reason ;
   int reason_line ;
   u16 number ;
   u16 entry_size ;
   u16 local_nentries ;
   u16 remote_nentries ;
   atomic_t references ;
   atomic_t n_on_msg_allocate_wq ;
   wait_queue_head_t msg_allocate_wq ;
   u8 delayed_chctl_flags ;
   atomic_t n_to_notify ;
   void (*func)(enum xp_retval  , short  , int  , void * , void * ) ;
   void *key ;
   struct completion wdisconnect_wait ;
   atomic_t kthreads_assigned ;
   u32 kthreads_assigned_limit ;
   atomic_t kthreads_idle ;
   u32 kthreads_idle_limit ;
   atomic_t kthreads_active ;
   wait_queue_head_t idle_wq ;
   union __anonunion_sn_221 sn ;
};
#line 586 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
union xpc_channel_ctl_flags {
   u64 all_flags ;
   u8 flags[2U] ;
};
#line 668 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_partition_sn2 {
   unsigned long remote_amos_page_pa ;
   int activate_IRQ_nasid ;
   int activate_IRQ_phys_cpuid ;
   unsigned long remote_vars_pa ;
   unsigned long remote_vars_part_pa ;
   u8 remote_vars_version ;
   void *local_GPs_base ;
   struct xpc_gp_sn2 *local_GPs ;
   void *remote_GPs_base ;
   struct xpc_gp_sn2 *remote_GPs ;
   unsigned long remote_GPs_pa ;
   void *local_openclose_args_base ;
   struct xpc_openclose_args *local_openclose_args ;
   unsigned long remote_openclose_args_pa ;
   int notify_IRQ_nasid ;
   int notify_IRQ_phys_cpuid ;
   char notify_IRQ_owner[8U] ;
   struct amo *remote_chctl_amo_va ;
   struct amo *local_chctl_amo_va ;
   struct timer_list dropped_notify_IRQ_timer ;
};
#line 705 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_partition_uv {
   unsigned long heartbeat_gpa ;
   struct xpc_heartbeat_uv cached_heartbeat ;
   unsigned long activate_gru_mq_desc_gpa ;
   void *cached_activate_gru_mq_desc ;
   struct mutex cached_activate_gru_mq_desc_mutex ;
   spinlock_t flags_lock ;
   unsigned int flags ;
   u8 remote_act_state ;
   u8 act_state_req ;
   enum xp_retval reason ;
};
#line 722 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
union __anonunion_sn_222 {
   struct xpc_partition_sn2 sn2 ;
   struct xpc_partition_uv uv ;
};
#line 722 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_partition {
   u8 remote_rp_version ;
   unsigned long remote_rp_ts_jiffies ;
   unsigned long remote_rp_pa ;
   u64 last_heartbeat ;
   u32 activate_IRQ_rcvd ;
   spinlock_t act_lock ;
   u8 act_state ;
   enum xp_retval reason ;
   int reason_line ;
   unsigned long disengage_timeout ;
   struct timer_list disengage_timer ;
   u8 setup_state ;
   wait_queue_head_t teardown_wq ;
   atomic_t references ;
   u8 nchannels ;
   atomic_t nchannels_active ;
   atomic_t nchannels_engaged ;
   struct xpc_channel *channels ;
   union xpc_channel_ctl_flags chctl ;
   spinlock_t chctl_lock ;
   void *remote_openclose_args_base ;
   struct xpc_openclose_args *remote_openclose_args ;
   atomic_t channel_mgr_requests ;
   wait_queue_head_t channel_mgr_wq ;
   union __anonunion_sn_222 sn ;
};
#line 781 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_arch_operations {
   int (*setup_partitions)(void) ;
   void (*teardown_partitions)(void) ;
   void (*process_activate_IRQ_rcvd)(void) ;
   enum xp_retval (*get_partition_rsvd_page_pa)(void * , u64 * , unsigned long * ,
                                                size_t * ) ;
   int (*setup_rsvd_page)(struct xpc_rsvd_page * ) ;
   void (*allow_hb)(short  ) ;
   void (*disallow_hb)(short  ) ;
   void (*disallow_all_hbs)(void) ;
   void (*increment_heartbeat)(void) ;
   void (*offline_heartbeat)(void) ;
   void (*online_heartbeat)(void) ;
   void (*heartbeat_init)(void) ;
   void (*heartbeat_exit)(void) ;
   enum xp_retval (*get_remote_heartbeat)(struct xpc_partition * ) ;
   void (*request_partition_activation)(struct xpc_rsvd_page * , unsigned long  ,
                                        int  ) ;
   void (*request_partition_reactivation)(struct xpc_partition * ) ;
   void (*request_partition_deactivation)(struct xpc_partition * ) ;
   void (*cancel_partition_deactivation_request)(struct xpc_partition * ) ;
   enum xp_retval (*setup_ch_structures)(struct xpc_partition * ) ;
   void (*teardown_ch_structures)(struct xpc_partition * ) ;
   enum xp_retval (*make_first_contact)(struct xpc_partition * ) ;
   u64 (*get_chctl_all_flags)(struct xpc_partition * ) ;
   void (*send_chctl_closerequest)(struct xpc_channel * , unsigned long * ) ;
   void (*send_chctl_closereply)(struct xpc_channel * , unsigned long * ) ;
   void (*send_chctl_openrequest)(struct xpc_channel * , unsigned long * ) ;
   void (*send_chctl_openreply)(struct xpc_channel * , unsigned long * ) ;
   void (*send_chctl_opencomplete)(struct xpc_channel * , unsigned long * ) ;
   void (*process_msg_chctl_flags)(struct xpc_partition * , int  ) ;
   enum xp_retval (*save_remote_msgqueue_pa)(struct xpc_channel * , unsigned long  ) ;
   enum xp_retval (*setup_msg_structures)(struct xpc_channel * ) ;
   void (*teardown_msg_structures)(struct xpc_channel * ) ;
   void (*indicate_partition_engaged)(struct xpc_partition * ) ;
   void (*indicate_partition_disengaged)(struct xpc_partition * ) ;
   void (*assume_partition_disengaged)(short  ) ;
   int (*partition_engaged)(short  ) ;
   int (*any_partition_engaged)(void) ;
   int (*n_of_deliverable_payloads)(struct xpc_channel * ) ;
   enum xp_retval (*send_payload)(struct xpc_channel * , u32  , void * , u16  , u8  ,
                                  void (*)(enum xp_retval  , short  , int  , void * ) ,
                                  void * ) ;
   void *(*get_deliverable_payload)(struct xpc_channel * ) ;
   void (*received_payload)(struct xpc_channel * , void * ) ;
   void (*notify_senders_of_disconnect)(struct xpc_channel * ) ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 66
struct bdi_writeback;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 2242
struct mnt_namespace;
#line 2243
struct ipc_namespace;
#line 2244
struct net;
#line 2244 "include/linux/mm.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 84 "include/linux/nsproxy.h"
struct proc_ns_operations;
#line 85 "include/linux/nsproxy.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
#line 11 "include/linux/ns_common.h"
struct pidmap {
   atomic_t nr_free ;
   void *page ;
};
#line 17 "include/linux/pid_namespace.h"
struct fs_pin;
#line 18
struct vfsmount;
#line 18 "include/linux/pid_namespace.h"
struct pid_namespace {
   struct kref kref ;
   struct pidmap pidmap[128U] ;
   struct callback_head rcu ;
   int last_pid ;
   unsigned int nr_hashed ;
   struct task_struct *child_reaper ;
   struct kmem_cache *pid_cachep ;
   unsigned int level ;
   struct pid_namespace *parent ;
   struct vfsmount *proc_mnt ;
   struct dentry *proc_self ;
   struct dentry *proc_thread_self ;
   struct fs_pin *bacct ;
   struct user_namespace *user_ns ;
   struct work_struct proc_work ;
   kgid_t pid_gid ;
   int hide_pid ;
   int reboot ;
   struct ns_common ns ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_230 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_229 {
   struct __anonstruct____missing_field_name_230 __annonCompField58 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_229 __annonCompField59 ;
};
#line 50 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_232 {
   u32 hash ;
   u32 len ;
};
#line 50 "include/linux/lockref.h"
union __anonunion____missing_field_name_231 {
   struct __anonstruct____missing_field_name_232 __annonCompField60 ;
   u64 hash_len ;
};
#line 50 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_231 __annonCompField61 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_233 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_233 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_237 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_236 {
   struct __anonstruct____missing_field_name_237 __annonCompField62 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_236 __annonCompField63 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 47
struct block_device;
#line 60 "include/uapi/linux/fs.h"
struct export_operations;
#line 63
struct kiocb;
#line 64
struct poll_table_struct;
#line 65
struct kstatfs;
#line 66
struct swap_info_struct;
#line 67
struct iov_iter;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_241 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_241 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_242 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_242 __annonCompField65 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_245 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_246 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_247 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_245 __annonCompField66 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_246 __annonCompField67 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_247 __annonCompField68 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_248 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_248 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_250 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_249 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_250 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_249 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 18 "./arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 45 "./arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 731 "include/linux/ftrace.h"
struct ftrace_ret_stack {
   unsigned long ret ;
   unsigned long func ;
   unsigned long long calltime ;
   unsigned long long subtime ;
   unsigned long fp ;
};
#line 442 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
typedef int ldv_func_ret_type___2;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 251 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xp.h"
struct xpc_registration {
   struct mutex mutex ;
   void (*func)(enum xp_retval  , short  , int  , void * , void * ) ;
   void *key ;
   u16 nentries ;
   u16 entry_size ;
   u32 assigned_limit ;
   u32 idle_limit ;
};
#line 72 "./arch/x86/include/asm/preempt.h"
typedef int pao_T__;
#line 77 "./arch/x86/include/asm/preempt.h"
typedef int pao_T_____0;
#line 243 "include/linux/timer.h"
enum hrtimer_restart;
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 357 "include/linux/nodemask.h"
enum node_states {
    N_POSSIBLE = 0,
    N_ONLINE = 1,
    N_NORMAL_MEMORY = 2,
    N_HIGH_MEMORY = 2,
    N_MEMORY = 3,
    N_CPU = 4,
    NR_NODE_STATES = 5
} ;
#line 90 "include/linux/mmzone.h"
struct free_area {
   struct list_head free_list[6U] ;
   unsigned long nr_free ;
};
#line 96
struct pglist_data;
#line 97 "include/linux/mmzone.h"
struct zone_padding {
   char x[0U] ;
};
#line 202 "include/linux/mmzone.h"
struct zone_reclaim_stat {
   unsigned long recent_rotated[2U] ;
   unsigned long recent_scanned[2U] ;
};
#line 215
struct zone;
#line 215 "include/linux/mmzone.h"
struct lruvec {
   struct list_head lists[5U] ;
   struct zone_reclaim_stat reclaim_stat ;
   struct zone *zone ;
};
#line 247 "include/linux/mmzone.h"
struct per_cpu_pages {
   int count ;
   int high ;
   int batch ;
   struct list_head lists[3U] ;
};
#line 260 "include/linux/mmzone.h"
struct per_cpu_pageset {
   struct per_cpu_pages pcp ;
   s8 expire ;
   s8 stat_threshold ;
   s8 vm_stat_diff[39U] ;
};
#line 270
enum zone_type {
    ZONE_DMA = 0,
    ZONE_DMA32 = 1,
    ZONE_NORMAL = 2,
    ZONE_MOVABLE = 3,
    __MAX_NR_ZONES = 4
} ;
#line 278 "include/linux/mmzone.h"
struct zone {
   unsigned long watermark[3U] ;
   long lowmem_reserve[4U] ;
   int node ;
   unsigned int inactive_ratio ;
   struct pglist_data *zone_pgdat ;
   struct per_cpu_pageset *pageset ;
   unsigned long dirty_balance_reserve ;
   unsigned long min_unmapped_pages ;
   unsigned long min_slab_pages ;
   unsigned long zone_start_pfn ;
   unsigned long managed_pages ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   char const   *name ;
   int nr_migrate_reserve_block ;
   unsigned long nr_isolate_pageblock ;
   seqlock_t span_seqlock ;
   wait_queue_head_t *wait_table ;
   unsigned long wait_table_hash_nr_entries ;
   unsigned long wait_table_bits ;
   struct zone_padding _pad1_ ;
   struct free_area free_area[11U] ;
   unsigned long flags ;
   spinlock_t lock ;
   struct zone_padding _pad2_ ;
   spinlock_t lru_lock ;
   struct lruvec lruvec ;
   atomic_long_t inactive_age ;
   unsigned long percpu_drift_mark ;
   unsigned long compact_cached_free_pfn ;
   unsigned long compact_cached_migrate_pfn[2U] ;
   unsigned int compact_considered ;
   unsigned int compact_defer_shift ;
   int compact_order_failed ;
   bool compact_blockskip_flush ;
   struct zone_padding _pad3_ ;
   atomic_long_t vm_stat[39U] ;
};
#line 567 "include/linux/mmzone.h"
struct zonelist_cache {
   unsigned short z_to_n[4096U] ;
   unsigned long fullzones[64U] ;
   unsigned long last_full_zap ;
};
#line 654 "include/linux/mmzone.h"
struct zoneref {
   struct zone *zone ;
   int zone_idx ;
};
#line 667 "include/linux/mmzone.h"
struct zonelist {
   struct zonelist_cache *zlcache_ptr ;
   struct zoneref _zonerefs[4097U] ;
   struct zonelist_cache zlcache ;
};
#line 705 "include/linux/mmzone.h"
struct pglist_data {
   struct zone node_zones[4U] ;
   struct zonelist node_zonelists[2U] ;
   int nr_zones ;
   spinlock_t node_size_lock ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   wait_queue_head_t kswapd_wait ;
   wait_queue_head_t pfmemalloc_wait ;
   struct task_struct *kswapd ;
   int kswapd_max_order ;
   enum zone_type classzone_idx ;
   spinlock_t numabalancing_migrate_lock ;
   unsigned long numabalancing_migrate_next_window ;
   unsigned long numabalancing_migrate_nr_pages ;
   unsigned long first_deferred_pfn ;
};
#line 773 "include/linux/mmzone.h"
typedef struct pglist_data pg_data_t;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 2242 "include/linux/mm.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 2926 "./arch/x86/include/asm/uv/uv_mmrs.h"
struct uv_scir_s {
   struct timer_list timer ;
   unsigned long offset ;
   unsigned long last ;
   unsigned long idle_on ;
   unsigned long idle_off ;
   unsigned char state ;
   unsigned char enabled ;
};
#line 139 "./arch/x86/include/asm/uv/uv_hub.h"
struct uv_hub_info_s {
   unsigned long global_mmr_base ;
   unsigned long gpa_mask ;
   unsigned int gnode_extra ;
   unsigned char hub_revision ;
   unsigned char apic_pnode_shift ;
   unsigned char m_shift ;
   unsigned char n_lshift ;
   unsigned long gnode_upper ;
   unsigned long lowmem_remap_top ;
   unsigned long lowmem_remap_base ;
   unsigned short pnode ;
   unsigned short pnode_mask ;
   unsigned short coherency_domain_number ;
   unsigned short numa_blade_id ;
   unsigned char blade_processor_id ;
   unsigned char m_val ;
   unsigned char n_val ;
   struct uv_scir_s scir ;
};
#line 485 "./arch/x86/include/asm/uv/uv_hub.h"
struct uv_blade_info {
   unsigned short nr_possible_cpus ;
   unsigned short nr_online_cpus ;
   unsigned short pnode ;
   short memory_nid ;
   spinlock_t nmi_lock ;
   unsigned long nmi_count ;
};
#line 91 "include/linux/kdev_t.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 3032 "include/linux/fs.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 113 "./arch/x86/include/asm/uv/bios.h"
struct uv_IO_APIC_route_entry {
   unsigned char vector ;
   unsigned char delivery_mode : 3 ;
   unsigned char dest_mode : 1 ;
   unsigned char delivery_status : 1 ;
   unsigned char polarity : 1 ;
   unsigned char __reserved_1 : 1 ;
   unsigned char trigger : 1 ;
   unsigned char mask : 1 ;
   unsigned short __reserved_2 : 15 ;
   unsigned int dest ;
};
#line 66 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/../sgi-gru/gru.h"
struct gru_message_queue_desc {
   void *mq ;
   unsigned long mq_gpa ;
   int qlines ;
   int interrupt_vector ;
   int interrupt_pnode ;
   int interrupt_apicid ;
};
#line 198 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_gru_mq_uv {
   void *address ;
   unsigned int order ;
   int irq ;
   int mmr_blade ;
   unsigned long mmr_offset ;
   unsigned long mmr_value ;
   int watchlist_num ;
   void *gru_mq_desc ;
};
#line 212 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_activate_mq_msghdr_uv {
   unsigned int gru_msg_hdr ;
   short partid ;
   u8 act_state ;
   u8 type ;
   unsigned long rp_ts_jiffies ;
};
#line 224 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_activate_mq_msg_uv {
   struct xpc_activate_mq_msghdr_uv hdr ;
};
#line 243 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_activate_mq_msg_activate_req_uv {
   struct xpc_activate_mq_msghdr_uv hdr ;
   unsigned long rp_gpa ;
   unsigned long heartbeat_gpa ;
   unsigned long activate_gru_mq_desc_gpa ;
};
#line 250 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_activate_mq_msg_deactivate_req_uv {
   struct xpc_activate_mq_msghdr_uv hdr ;
   enum xp_retval reason ;
};
#line 255 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_activate_mq_msg_chctl_closerequest_uv {
   struct xpc_activate_mq_msghdr_uv hdr ;
   short ch_number ;
   enum xp_retval reason ;
};
#line 261 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_activate_mq_msg_chctl_closereply_uv {
   struct xpc_activate_mq_msghdr_uv hdr ;
   short ch_number ;
};
#line 266 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_activate_mq_msg_chctl_openrequest_uv {
   struct xpc_activate_mq_msghdr_uv hdr ;
   short ch_number ;
   short entry_size ;
   short local_nentries ;
};
#line 273 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_activate_mq_msg_chctl_openreply_uv {
   struct xpc_activate_mq_msghdr_uv hdr ;
   short ch_number ;
   short remote_nentries ;
   short local_nentries ;
   unsigned long notify_gru_mq_desc_gpa ;
};
#line 281 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_activate_mq_msg_chctl_opencomplete_uv {
   struct xpc_activate_mq_msghdr_uv hdr ;
   short ch_number ;
};
#line 360 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
union __anonunion_u_254 {
   unsigned int gru_msg_hdr ;
   struct xpc_fifo_entry_uv next ;
};
#line 360 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_notify_mq_msghdr_uv {
   union __anonunion_u_254 u ;
   short partid ;
   u8 ch_number ;
   u8 size ;
   unsigned int msg_slot_number ;
};
#line 387 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_notify_mq_msg_uv {
   struct xpc_notify_mq_msghdr_uv hdr ;
   unsigned long payload ;
};
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 107 "./arch/x86/include/asm/ptrace.h"
__inline static int user_mode(struct pt_regs *regs ) 
{ 


  {
#line 112
  return ((regs->cs & 3UL) != 0UL);
}
}
#line 53 "include/linux/dynamic_debug.h"
extern void __dynamic_dev_dbg(struct _ddebug * , struct device  const  * , char const   * 
                              , ...) ;
#line 178 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 3 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
bool ldv_is_err(void const   *ptr ) ;
#line 8
void ldv_spin_lock(void) ;
#line 9
void ldv_spin_unlock(void) ;
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 8
extern void *memset(void * , int  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3233;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3233;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3233;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3233;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_3233: ;
#line 14
  return (pfo_ret__);
}
}
#line 754 "include/linux/cpumask.h"
extern unsigned long const   cpu_bit_bitmap[65U][128U] ;
#line 756 "include/linux/cpumask.h"
__inline static struct cpumask  const  *get_cpu_mask(unsigned int cpu ) 
{ 
  unsigned long const   *p ;

  {
#line 758
  p = (unsigned long const   *)(& cpu_bit_bitmap) + (unsigned long )((cpu & 63U) + 1U);
#line 759
  p = p + - ((unsigned long )(cpu / 64U));
#line 760
  return ((struct cpumask  const  *)p);
}
}
#line 41 "include/linux/err.h"
__inline static bool IS_ERR(void const   *ptr ) ;
#line 13 "./arch/x86/include/asm/cmpxchg.h"
extern void __cmpxchg_wrong_size(void) ;
#line 15
extern void __xadd_wrong_size(void) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 102 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 104
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 106
  return;
}
}
#line 155 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 157
  __ret = i;
#line 157
  switch (4UL) {
  case 1UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5763;
  case 2UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5763;
  case 4UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5763;
  case 8UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5763;
  default: 
#line 157
  __xadd_wrong_size();
  }
  ldv_5763: ;
#line 157
  return (__ret + i);
}
}
#line 167 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_return(int i , atomic_t *v ) 
{ 
  int tmp ;

  {
#line 169
  tmp = atomic_add_return(- i, v);
#line 169
  return (tmp);
}
}
#line 175 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_cmpxchg(atomic_t *v , int old , int new ) 
{ 
  int __ret ;
  int __old ;
  int __new ;
  u8 volatile   *__ptr ;
  u16 volatile   *__ptr___0 ;
  u32 volatile   *__ptr___1 ;
  u64 volatile   *__ptr___2 ;

  {
#line 177
  __old = old;
#line 177
  __new = new;
#line 177
  switch (4UL) {
  case 1UL: 
#line 177
  __ptr = (u8 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1": "=a" (__ret),
                       "+m" (*__ptr): "q" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5783;
  case 2UL: 
#line 177
  __ptr___0 = (u16 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1": "=a" (__ret),
                       "+m" (*__ptr___0): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5783;
  case 4UL: 
#line 177
  __ptr___1 = (u32 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1": "=a" (__ret),
                       "+m" (*__ptr___1): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5783;
  case 8UL: 
#line 177
  __ptr___2 = (u64 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1": "=a" (__ret),
                       "+m" (*__ptr___2): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5783;
  default: 
#line 177
  __cmpxchg_wrong_size();
  }
  ldv_5783: ;
#line 177
  return (__ret);
}
}
#line 194 "./arch/x86/include/asm/atomic.h"
__inline static int __atomic_add_unless(atomic_t *v , int a , int u ) 
{ 
  int c ;
  int old ;
  long tmp ;
  long tmp___0 ;

  {
#line 197
  c = atomic_read((atomic_t const   *)v);
  ldv_5812: 
#line 199
  tmp = ldv__builtin_expect(c == u, 0L);
#line 199
  if (tmp != 0L) {
#line 200
    goto ldv_5811;
  } else {

  }
#line 201
  old = atomic_cmpxchg(v, c, c + a);
#line 202
  tmp___0 = ldv__builtin_expect(old == c, 1L);
#line 202
  if (tmp___0 != 0L) {
#line 203
    goto ldv_5811;
  } else {

  }
#line 204
  c = old;
#line 205
  goto ldv_5812;
  ldv_5811: ;
#line 206
  return (c);
}
}
#line 15 "include/linux/atomic.h"
__inline static int atomic_add_unless(atomic_t *v , int a , int u ) 
{ 
  int tmp ;

  {
#line 17
  tmp = __atomic_add_unless(v, a, u);
#line 17
  return (tmp != u);
}
}
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 45
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void ldv_spin_lock_5(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField18.rlock);
#line 313
  return;
}
}
#line 310
__inline static void spin_lock(spinlock_t *lock ) ;
#line 359 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_9(spinlock_t *lock ) 
{ 


  {
#line 361
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
#line 362
  return;
}
}
#line 359
__inline static void spin_unlock(spinlock_t *lock ) ;
#line 386 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_12(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 388
  _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
#line 389
  return;
}
}
#line 386
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 149
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 926
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 927
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 928
extern void abort_exclusive_wait(wait_queue_head_t * , wait_queue_t * , unsigned int  ,
                                 void * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 91
extern void wait_for_completion(struct completion * ) ;
#line 106
extern void complete(struct completion * ) ;
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 224 "include/linux/timer.h"
extern void add_timer(struct timer_list * ) ;
#line 229
extern int del_timer_sync(struct timer_list * ) ;
#line 232
int ldv_del_timer_sync_23(struct timer_list *ldv_func_arg1 ) ;
#line 44 "include/linux/sysctl.h"
extern int proc_dointvec_minmax(struct ctl_table * , int  , void * , size_t * , loff_t * ) ;
#line 184
extern struct ctl_table_header *register_sysctl_table(struct ctl_table * ) ;
#line 188
extern void unregister_sysctl_table(struct ctl_table_header * ) ;
#line 425 "include/linux/sched.h"
extern void schedule(void) ;
#line 2181
extern int set_cpus_allowed_ptr(struct task_struct * , struct cpumask  const  * ) ;
#line 2410
extern int wake_up_process(struct task_struct * ) ;
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 293
void *ldv_kmem_cache_alloc_20(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 18 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
void ldv_check_alloc_flags(gfp_t flags ) ;
#line 27 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
struct xpc_rsvd_page *xpc_arch_ops_uv_group2  ;
#line 28 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 30 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
int ldv_timer_state_2  =    0;
#line 31 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
int ldv_state_variable_0  ;
#line 32 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
int ldv_state_variable_5  ;
#line 33 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
struct xpc_channel *xpc_arch_ops_uv_group0  ;
#line 34 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
int ldv_state_variable_3  ;
#line 35 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
struct timer_list *ldv_timer_list_2  ;
#line 36 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
int ldv_timer_state_1  =    0;
#line 37 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
int ldv_state_variable_2  ;
#line 38 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
int ref_cnt  ;
#line 39 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
int ldv_state_variable_1  ;
#line 40 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
struct timer_list *ldv_timer_list_1  ;
#line 41 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
struct xpc_partition *xpc_arch_ops_uv_group1  ;
#line 42 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
int ldv_state_variable_4  ;
#line 44
void activate_pending_timer_1(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 45
void choose_timer_1(struct timer_list *timer ) ;
#line 46
void ldv_initialize_xpc_arch_operations_3(void) ;
#line 47
int reg_timer_1(struct timer_list *timer ) ;
#line 48
void choose_timer_2(struct timer_list *timer ) ;
#line 49
int reg_timer_2(struct timer_list *timer ) ;
#line 50
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 51
void disable_suitable_timer_2(struct timer_list *timer ) ;
#line 52
void disable_suitable_timer_1(struct timer_list *timer ) ;
#line 842 "include/linux/device.h"
extern int dev_set_name(struct device * , char const   *  , ...) ;
#line 1084
extern void dev_err(struct device  const  * , char const   *  , ...) ;
#line 1086
extern void dev_warn(struct device  const  * , char const   *  , ...) ;
#line 1090
extern void _dev_info(struct device  const  * , char const   *  , ...) ;
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 47 "include/linux/delay.h"
extern unsigned long msleep_interruptible(unsigned int  ) ;
#line 38 "include/linux/reboot.h"
extern int register_reboot_notifier(struct notifier_block * ) ;
#line 39
extern int unregister_reboot_notifier(struct notifier_block * ) ;
#line 16 "include/linux/kdebug.h"
extern int register_die_notifier(struct notifier_block * ) ;
#line 17
extern int unregister_die_notifier(struct notifier_block * ) ;
#line 8 "include/linux/kthread.h"
extern struct task_struct *kthread_create_on_node(int (*)(void * ) , void * , int  ,
                                                  char const   *  , ...) ;
#line 12 "./arch/x86/include/asm/uv/uv.h"
extern int is_uv_system(void) ;
#line 295 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xp.h"
extern void xpc_set_interface(void (*)(int  ) , void (*)(int  ) , enum xp_retval (*)(short  ,
                                                                                     int  ,
                                                                                     u32  ,
                                                                                     void * ,
                                                                                     u16  ) ,
                              enum xp_retval (*)(short  , int  , u32  , void * , u16  ,
                                                 void (*)(enum xp_retval  , short  ,
                                                          int  , void * ) , void * ) ,
                              void (*)(short  , int  , void * ) , enum xp_retval (*)(short  ,
                                                                                     void * ) ) ;
#line 302
extern void xpc_clear_interface(void) ;
#line 336
extern short xp_max_npartitions ;
#line 337
extern short xp_partition_id ;
#line 877 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct device *xpc_part ;
#line 878
struct device *xpc_chan ;
#line 879 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_arch_operations xpc_arch_ops  ;
#line 880
int xpc_disengage_timelimit ;
#line 881 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
int xpc_disengage_timedout  ;
#line 882 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
int xpc_activate_IRQ_rcvd  ;
#line 883
spinlock_t xpc_activate_IRQ_rcvd_lock ;
#line 884
wait_queue_head_t xpc_activate_IRQ_wq ;
#line 885
void *xpc_kzalloc_cacheline_aligned(size_t size , gfp_t flags , void **base ) ;
#line 886
void xpc_activate_partition(struct xpc_partition *part ) ;
#line 887
void xpc_activate_kthreads(struct xpc_channel *ch , int needed ) ;
#line 888
void xpc_create_kthreads(struct xpc_channel *ch , int needed , int ignore_disconnecting ) ;
#line 889
void xpc_disconnect_wait(int ch_number ) ;
#line 896
int xpc_init_uv(void) ;
#line 897
void xpc_exit_uv(void) ;
#line 900
int xpc_exiting ;
#line 904
struct xpc_partition *xpc_partitions ;
#line 906
int xpc_setup_rsvd_page(void) ;
#line 907
void xpc_teardown_rsvd_page(void) ;
#line 909
int xpc_partition_disengaged(struct xpc_partition *part ) ;
#line 910
enum xp_retval xpc_mark_partition_active(struct xpc_partition *part ) ;
#line 911
void xpc_mark_partition_inactive(struct xpc_partition *part ) ;
#line 912
void xpc_discovery(void) ;
#line 916
void xpc_deactivate_partition(int const   line , struct xpc_partition *part , enum xp_retval reason ) ;
#line 918
enum xp_retval xpc_initiate_partid_to_nasids(short partid , void *nasid_mask ) ;
#line 921
void xpc_initiate_connect(int ch_number ) ;
#line 922
void xpc_initiate_disconnect(int ch_number ) ;
#line 924
enum xp_retval xpc_initiate_send(short partid , int ch_number , u32 flags , void *payload ,
                                 u16 payload_size ) ;
#line 925
enum xp_retval xpc_initiate_send_notify(short partid , int ch_number , u32 flags ,
                                        void *payload , u16 payload_size , void (*func)(enum xp_retval  ,
                                                                                        short  ,
                                                                                        int  ,
                                                                                        void * ) ,
                                        void *key ) ;
#line 927
void xpc_initiate_received(short partid , int ch_number , void *payload ) ;
#line 928
void xpc_process_sent_chctl_flags(struct xpc_partition *part ) ;
#line 929
void xpc_connected_callout(struct xpc_channel *ch ) ;
#line 930
void xpc_deliver_payload(struct xpc_channel *ch ) ;
#line 931
void xpc_disconnect_channel(int const   line , struct xpc_channel *ch , enum xp_retval reason ,
                            unsigned long *irq_flags ) ;
#line 933
void xpc_disconnect_callout(struct xpc_channel *ch , enum xp_retval reason ) ;
#line 937 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
__inline static void xpc_wakeup_channel_mgr(struct xpc_partition *part ) 
{ 
  int tmp ;

  {
#line 939
  tmp = atomic_add_return(1, & part->channel_mgr_requests);
#line 939
  if (tmp == 1) {
#line 940
    __wake_up(& part->channel_mgr_wq, 3U, 1, (void *)0);
  } else {

  }
#line 941
  return;
}
}
#line 948 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
__inline static void xpc_msgqueue_ref(struct xpc_channel *ch ) 
{ 


  {
#line 950
  atomic_inc(& ch->references);
#line 951
  return;
}
}
#line 954 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
__inline static void xpc_msgqueue_deref(struct xpc_channel *ch ) 
{ 
  s32 refs ;
  int tmp ;

  {
#line 956
  tmp = atomic_sub_return(1, & ch->references);
#line 956
  refs = tmp;
#line 959
  if (refs == 0) {
#line 960
    xpc_wakeup_channel_mgr(xpc_partitions + (unsigned long )ch->partid);
  } else {

  }
#line 961
  return;
}
}
#line 971 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
__inline static void xpc_part_deref(struct xpc_partition *part ) 
{ 
  s32 refs ;
  int tmp ;

  {
#line 973
  tmp = atomic_sub_return(1, & part->references);
#line 973
  refs = tmp;
#line 976
  if (refs == 0 && (unsigned int )part->setup_state == 2U) {
#line 977
    __wake_up(& part->teardown_wq, 3U, 1, (void *)0);
  } else {

  }
#line 978
  return;
}
}
#line 981 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
__inline static int xpc_part_ref(struct xpc_partition *part ) 
{ 
  int setup ;

  {
#line 985
  atomic_inc(& part->references);
#line 986
  setup = (unsigned int )part->setup_state == 1U;
#line 987
  if (setup == 0) {
#line 988
    xpc_part_deref(part);
  } else {

  }
#line 990
  return (setup);
}
}
#line 62 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
struct device_driver xpc_dbg_name  = 
#line 62 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
     {"xpc", 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 66 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
struct device xpc_part_dbg_subname  = 
#line 66
     {0, 0, {0, {0, 0}, 0, 0, 0, 0, {{0}}, {{{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}},
                                          {{0, 0}, 0UL, 0, 0UL, 0U, 0, 0, 0, {(char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0},
                                           {0, {0, 0}, 0, 0, 0UL}}, 0, 0}, (unsigned char)0,
           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
    "", 0, {{0}, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}},
    0, & xpc_dbg_name, 0, 0, {{0}, (unsigned char)0, (unsigned char)0, (_Bool)0, (_Bool)0,
                              (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, {{{{{0}},
                                                                                   0U,
                                                                                   0U,
                                                                                   0,
                                                                                   {0,
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    0,
                                                                                    0UL}}}},
                              {0, 0}, {0U, {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0,
                                                                  0UL}}}}, {0, 0}}},
                              0, (_Bool)0, (_Bool)0, {{0, 0}, 0UL, 0, 0UL, 0U, 0,
                                                      0, 0, {(char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0}, {0, {0, 0},
                                                                        0, 0, 0UL}},
                              0UL, {{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}}, {{{{{{0}},
                                                                                  0U,
                                                                                  0U,
                                                                                  0,
                                                                                  {0,
                                                                                   {0,
                                                                                    0},
                                                                                   0,
                                                                                   0,
                                                                                   0UL}}}},
                                                                               {0,
                                                                                0}},
                              0, {0}, {0}, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, 0, 0, 0, 0, 0UL,
                              0UL, 0UL, 0UL, 0, 0, 0}, 0, 0, 0, 0, 0ULL, 0UL, 0, {0,
                                                                                  0},
    0, 0, {0, 0}, 0, 0, 0U, 0U, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0,
                                                                                 0},
    {0, {0, 0}, {{0}}}, 0, 0, 0, 0, (_Bool)0, (_Bool)0};
#line 71 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
struct device xpc_chan_dbg_subname  = 
#line 71
     {0, 0, {0, {0, 0}, 0, 0, 0, 0, {{0}}, {{{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}},
                                          {{0, 0}, 0UL, 0, 0UL, 0U, 0, 0, 0, {(char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0},
                                           {0, {0, 0}, 0, 0, 0UL}}, 0, 0}, (unsigned char)0,
           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
    "", 0, {{0}, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}},
    0, & xpc_dbg_name, 0, 0, {{0}, (unsigned char)0, (unsigned char)0, (_Bool)0, (_Bool)0,
                              (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, {{{{{0}},
                                                                                   0U,
                                                                                   0U,
                                                                                   0,
                                                                                   {0,
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    0,
                                                                                    0UL}}}},
                              {0, 0}, {0U, {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0,
                                                                  0UL}}}}, {0, 0}}},
                              0, (_Bool)0, (_Bool)0, {{0, 0}, 0UL, 0, 0UL, 0U, 0,
                                                      0, 0, {(char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0}, {0, {0, 0},
                                                                        0, 0, 0UL}},
                              0UL, {{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}}, {{{{{{0}},
                                                                                  0U,
                                                                                  0U,
                                                                                  0,
                                                                                  {0,
                                                                                   {0,
                                                                                    0},
                                                                                   0,
                                                                                   0,
                                                                                   0UL}}}},
                                                                               {0,
                                                                                0}},
                              0, {0}, {0}, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, 0, 0, 0, 0, 0UL,
                              0UL, 0UL, 0UL, 0, 0, 0}, 0, 0, 0, 0, 0ULL, 0UL, 0, {0,
                                                                                  0},
    0, 0, {0, 0}, 0, 0, 0U, 0U, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0,
                                                                                 0},
    {0, {0, 0}, {{0}}}, 0, 0, 0, 0, (_Bool)0, (_Bool)0};
#line 76 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
struct device *xpc_part  =    & xpc_part_dbg_subname;
#line 77 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
struct device *xpc_chan  =    & xpc_chan_dbg_subname;
#line 83 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_hb_interval  =    5;
#line 84 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_hb_min_interval  =    1;
#line 85 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_hb_max_interval  =    10;
#line 87 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_hb_check_interval  =    20;
#line 88 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_hb_check_min_interval  =    10;
#line 89 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_hb_check_max_interval  =    120;
#line 91 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
int xpc_disengage_timelimit  =    90;
#line 92 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_disengage_min_timelimit  ;
#line 93 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_disengage_max_timelimit  =    120;
#line 95 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static struct ctl_table xpc_sys_xpc_hb_dir[3U]  = {      {"hb_interval", (void *)(& xpc_hb_interval), 4, 420U, 0, & proc_dointvec_minmax,
      0, (void *)(& xpc_hb_min_interval), (void *)(& xpc_hb_max_interval)}, 
        {"hb_check_interval", (void *)(& xpc_hb_check_interval), 4, 420U, 0, & proc_dointvec_minmax,
      0, (void *)(& xpc_hb_check_min_interval), (void *)(& xpc_hb_check_max_interval)}};
#line 114 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static struct ctl_table xpc_sys_xpc_dir[3U]  = {      {"hb", 0, 0, 365U, (struct ctl_table *)(& xpc_sys_xpc_hb_dir), 0, 0, 0, 0}, 
        {"disengage_timelimit", (void *)(& xpc_disengage_timelimit), 4, 420U, 0, & proc_dointvec_minmax,
      0, (void *)(& xpc_disengage_min_timelimit), (void *)(& xpc_disengage_max_timelimit)}};
#line 129 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static struct ctl_table xpc_sys_dir[2U]  = {      {"xpc", 0, 0, 365U, (struct ctl_table *)(& xpc_sys_xpc_dir), 0, 0, 0, 0}};
#line 136 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static struct ctl_table_header *xpc_sysctl  ;
#line 143 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
spinlock_t xpc_activate_IRQ_rcvd_lock  =    {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "xpc_activate_IRQ_rcvd_lock",
                                                    0, 0UL}}}};
#line 146 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
wait_queue_head_t xpc_activate_IRQ_wq  =    {{{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "xpc_activate_IRQ_wq.lock",
                                                     0, 0UL}}}}, {& xpc_activate_IRQ_wq.task_list,
                                                                  & xpc_activate_IRQ_wq.task_list}};
#line 148 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static unsigned long xpc_hb_check_timeout  ;
#line 149 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static struct timer_list xpc_hb_timer  ;
#line 152 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static struct completion xpc_hb_checker_exited  =    {0U, {{{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "(xpc_hb_checker_exited).wait.lock",
                                                          0, 0UL}}}}, {& xpc_hb_checker_exited.wait.task_list,
                                                                       & xpc_hb_checker_exited.wait.task_list}}};
#line 155 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static struct completion xpc_discovery_exited  =    {0U, {{{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "(xpc_discovery_exited).wait.lock",
                                                          0, 0UL}}}}, {& xpc_discovery_exited.wait.task_list,
                                                                       & xpc_discovery_exited.wait.task_list}}};
#line 157
static void xpc_kthread_waitmsgs(struct xpc_partition *part , struct xpc_channel *ch ) ;
#line 159
static int xpc_system_reboot(struct notifier_block *nb , unsigned long event , void *unused ) ;
#line 160 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static struct notifier_block xpc_reboot_notifier  =    {& xpc_system_reboot, 0, 0};
#line 164
static int xpc_system_die(struct notifier_block *nb , unsigned long event , void *_die_args ) ;
#line 165 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static struct notifier_block xpc_die_notifier  =    {& xpc_system_die, 0, 0};
#line 175 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static void xpc_timeout_partition_disengage(unsigned long data ) 
{ 
  struct xpc_partition *part ;

  {
#line 177
  part = (struct xpc_partition *)data;
#line 181
  xpc_partition_disengaged(part);
#line 182
  return;
}
}
#line 193 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static void xpc_hb_beater(unsigned long dummy ) 
{ 


  {
#line 195
  (*(xpc_arch_ops.increment_heartbeat))();
#line 197
  if ((long )((unsigned long )jiffies - xpc_hb_check_timeout) >= 0L) {
#line 198
    __wake_up(& xpc_activate_IRQ_wq, 1U, 1, (void *)0);
  } else {

  }
#line 200
  xpc_hb_timer.expires = (unsigned long )(xpc_hb_interval * 250) + (unsigned long )jiffies;
#line 201
  add_timer(& xpc_hb_timer);
#line 202
  return;
}
}
#line 205 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static void xpc_start_hb_beater(void) 
{ 


  {
#line 207
  (*(xpc_arch_ops.heartbeat_init))();
#line 208
  reg_timer_1(& xpc_hb_timer);
#line 209
  xpc_hb_timer.function = & xpc_hb_beater;
#line 210
  xpc_hb_beater(0UL);
#line 211
  return;
}
}
#line 214 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static void xpc_stop_hb_beater(void) 
{ 


  {
#line 216
  ldv_del_timer_sync_23(& xpc_hb_timer);
#line 217
  (*(xpc_arch_ops.heartbeat_exit))();
#line 218
  return;
}
}
#line 225 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static void xpc_check_remote_hb(void) 
{ 
  struct xpc_partition *part ;
  short partid ;
  enum xp_retval ret ;

  {
#line 231
  partid = 0;
#line 231
  goto ldv_30820;
  ldv_30819: ;
#line 233
  if (xpc_exiting != 0) {
#line 234
    goto ldv_30817;
  } else {

  }
#line 236
  if ((int )partid == (int )xp_partition_id) {
#line 237
    goto ldv_30818;
  } else {

  }
#line 239
  part = xpc_partitions + (unsigned long )partid;
#line 241
  if ((unsigned int )part->act_state == 0U || (unsigned int )part->act_state == 4U) {
#line 243
    goto ldv_30818;
  } else {

  }
#line 246
  ret = (*(xpc_arch_ops.get_remote_heartbeat))(part);
#line 247
  if ((unsigned int )ret != 0U) {
#line 248
    xpc_deactivate_partition(248, part, ret);
  } else {

  }
  ldv_30818: 
#line 231
  partid = (short )((int )partid + 1);
  ldv_30820: ;
#line 231
  if ((int )partid < (int )xp_max_npartitions) {
#line 233
    goto ldv_30819;
  } else {

  }
  ldv_30817: ;
#line 238
  return;
}
}
#line 257 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_hb_checker(void *ignore ) 
{ 
  int force_IRQ ;
  struct cpumask  const  *tmp ;
  struct task_struct *tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  long tmp___3 ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___4 ;
  struct _ddebug descriptor___2 ;
  long tmp___5 ;

  {
#line 259
  force_IRQ = 0;
#line 263
  tmp = get_cpu_mask(0U);
#line 263
  tmp___0 = get_current();
#line 263
  set_cpus_allowed_ptr(tmp___0, tmp);
#line 266
  xpc_hb_check_timeout = (unsigned long )(xpc_hb_check_interval * 250) + (unsigned long )jiffies;
#line 267
  xpc_start_hb_beater();
#line 269
  goto ldv_30857;
  ldv_30856: 
#line 271
  descriptor.modname = "xpc";
#line 271
  descriptor.function = "xpc_hb_checker";
#line 271
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c";
#line 271
  descriptor.format = "woke up with %d ticks rem; %d IRQs have been received\n";
#line 271
  descriptor.lineno = 274U;
#line 271
  descriptor.flags = 0U;
#line 271
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 271
  if (tmp___1 != 0L) {
#line 271
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_part, "woke up with %d ticks rem; %d IRQs have been received\n",
                      (int )((unsigned int )xpc_hb_check_timeout - (unsigned int )jiffies),
                      xpc_activate_IRQ_rcvd);
  } else {

  }
#line 277
  if ((long )((unsigned long )jiffies - xpc_hb_check_timeout) >= 0L) {
#line 278
    xpc_hb_check_timeout = (unsigned long )(xpc_hb_check_interval * 250) + (unsigned long )jiffies;
#line 281
    descriptor___0.modname = "xpc";
#line 281
    descriptor___0.function = "xpc_hb_checker";
#line 281
    descriptor___0.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c";
#line 281
    descriptor___0.format = "checking remote heartbeats\n";
#line 281
    descriptor___0.lineno = 281U;
#line 281
    descriptor___0.flags = 0U;
#line 281
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 281
    if (tmp___2 != 0L) {
#line 281
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)xpc_part, "checking remote heartbeats\n");
    } else {

    }
#line 282
    xpc_check_remote_hb();
  } else {

  }
#line 293
  if (xpc_activate_IRQ_rcvd > 0 || force_IRQ != 0) {
#line 294
    force_IRQ = 0;
#line 295
    descriptor___1.modname = "xpc";
#line 295
    descriptor___1.function = "xpc_hb_checker";
#line 295
    descriptor___1.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c";
#line 295
    descriptor___1.format = "processing activate IRQs received\n";
#line 295
    descriptor___1.lineno = 296U;
#line 295
    descriptor___1.flags = 0U;
#line 295
    tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 295
    if (tmp___3 != 0L) {
#line 295
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)xpc_part, "processing activate IRQs received\n");
    } else {

    }
#line 297
    (*(xpc_arch_ops.process_activate_IRQ_rcvd))();
  } else {

  }
#line 301
  __ret = 0;
#line 301
  __might_sleep("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c",
                305, 0);
#line 301
  if (((long )((unsigned long )jiffies - xpc_hb_check_timeout) < 0L && xpc_activate_IRQ_rcvd <= 0) && xpc_exiting == 0) {
#line 301
    __ret___0 = 0L;
#line 301
    INIT_LIST_HEAD(& __wait.task_list);
#line 301
    __wait.flags = 0U;
    ldv_30853: 
#line 301
    tmp___4 = prepare_to_wait_event(& xpc_activate_IRQ_wq, & __wait, 1);
#line 301
    __int = tmp___4;
#line 301
    if (((long )((unsigned long )jiffies - xpc_hb_check_timeout) >= 0L || xpc_activate_IRQ_rcvd > 0) || xpc_exiting != 0) {
#line 301
      goto ldv_30852;
    } else {

    }
#line 301
    if (__int != 0L) {
#line 301
      __ret___0 = __int;
#line 301
      goto ldv_30852;
    } else {

    }
#line 301
    schedule();
#line 301
    goto ldv_30853;
    ldv_30852: 
#line 301
    finish_wait(& xpc_activate_IRQ_wq, & __wait);
#line 301
    __ret = (int )__ret___0;
  } else {

  }
  ldv_30857: ;
#line 269
  if (xpc_exiting == 0) {
#line 271
    goto ldv_30856;
  } else {

  }
#line 308
  xpc_stop_hb_beater();
#line 310
  descriptor___2.modname = "xpc";
#line 310
  descriptor___2.function = "xpc_hb_checker";
#line 310
  descriptor___2.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c";
#line 310
  descriptor___2.format = "heartbeat checker is exiting\n";
#line 310
  descriptor___2.lineno = 310U;
#line 310
  descriptor___2.flags = 0U;
#line 310
  tmp___5 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 310
  if (tmp___5 != 0L) {
#line 310
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)xpc_part, "heartbeat checker is exiting\n");
  } else {

  }
#line 313
  complete(& xpc_hb_checker_exited);
#line 314
  return (0);
}
}
#line 323 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_initiate_discovery(void *ignore ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 325
  xpc_discovery();
#line 327
  descriptor.modname = "xpc";
#line 327
  descriptor.function = "xpc_initiate_discovery";
#line 327
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c";
#line 327
  descriptor.format = "discovery thread is exiting\n";
#line 327
  descriptor.lineno = 327U;
#line 327
  descriptor.flags = 0U;
#line 327
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 327
  if (tmp != 0L) {
#line 327
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_part, "discovery thread is exiting\n");
  } else {

  }
#line 330
  complete(& xpc_discovery_exited);
#line 331
  return (0);
}
}
#line 347 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static void xpc_channel_mgr(struct xpc_partition *part ) 
{ 
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 349
  goto ldv_30878;
  ldv_30877: 
#line 353
  xpc_process_sent_chctl_flags(part);
#line 368
  atomic_dec(& part->channel_mgr_requests);
#line 369
  __ret = 0;
#line 369
  __might_sleep("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c",
                374, 0);
#line 369
  tmp___3 = atomic_read((atomic_t const   *)(& part->channel_mgr_requests));
#line 369
  if (tmp___3 <= 0 && part->chctl.all_flags == 0ULL) {
#line 369
    if ((unsigned int )part->act_state != 4U) {
#line 369
      goto _L;
    } else {
#line 369
      tmp___4 = atomic_read((atomic_t const   *)(& part->nchannels_active));
#line 369
      if (tmp___4 != 0) {
#line 369
        goto _L;
      } else {
#line 369
        tmp___5 = xpc_partition_disengaged(part);
#line 369
        if (tmp___5 == 0) {
          _L: /* CIL Label */ 
#line 369
          __ret___0 = 0L;
#line 369
          INIT_LIST_HEAD(& __wait.task_list);
#line 369
          __wait.flags = 0U;
          ldv_30874: 
#line 369
          tmp = prepare_to_wait_event(& part->channel_mgr_wq, & __wait, 1);
#line 369
          __int = tmp;
#line 369
          tmp___0 = atomic_read((atomic_t const   *)(& part->channel_mgr_requests));
#line 369
          if (tmp___0 > 0 || part->chctl.all_flags != 0ULL) {
#line 369
            goto ldv_30873;
          } else
#line 369
          if ((unsigned int )part->act_state == 4U) {
#line 369
            tmp___1 = atomic_read((atomic_t const   *)(& part->nchannels_active));
#line 369
            if (tmp___1 == 0) {
#line 369
              tmp___2 = xpc_partition_disengaged(part);
#line 369
              if (tmp___2 != 0) {
#line 369
                goto ldv_30873;
              } else {

              }
            } else {

            }
          } else {

          }
#line 369
          if (__int != 0L) {
#line 369
            __ret___0 = __int;
#line 369
            goto ldv_30873;
          } else {

          }
#line 369
          schedule();
#line 369
          goto ldv_30874;
          ldv_30873: 
#line 369
          finish_wait(& part->channel_mgr_wq, & __wait);
#line 369
          __ret = (int )__ret___0;
        } else {

        }
      }
    }
  } else {

  }
#line 375
  atomic_set(& part->channel_mgr_requests, 1);
  ldv_30878: ;
#line 349
  if ((unsigned int )part->act_state != 4U) {
#line 353
    goto ldv_30877;
  } else {
#line 349
    tmp___6 = atomic_read((atomic_t const   *)(& part->nchannels_active));
#line 349
    if (tmp___6 > 0) {
#line 353
      goto ldv_30877;
    } else {
#line 349
      tmp___7 = xpc_partition_disengaged(part);
#line 349
      if (tmp___7 == 0) {
#line 353
        goto ldv_30877;
      } else {
#line 356
        goto ldv_30879;
      }
    }
  }
  ldv_30879: ;
#line 358
  return;
}
}
#line 383 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
void *xpc_kzalloc_cacheline_aligned(size_t size , gfp_t flags , void **base ) 
{ 


  {
#line 386
  *base = kzalloc(size, flags);
#line 387
  if ((unsigned long )*base == (unsigned long )((void *)0)) {
#line 388
    return ((void *)0);
  } else {

  }
#line 390
  if ((unsigned long long )*base == (((unsigned long long )*base + 63ULL) & 0xffffffffffffffc0ULL)) {
#line 391
    return (*base);
  } else {

  }
#line 393
  kfree((void const   *)*base);
#line 396
  *base = kzalloc(size + 64UL, flags);
#line 397
  if ((unsigned long )*base == (unsigned long )((void *)0)) {
#line 398
    return ((void *)0);
  } else {

  }
#line 400
  return ((void *)(((unsigned long long )*base + 63ULL) & 0xffffffffffffffc0ULL));
}
}
#line 408 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static enum xp_retval xpc_setup_ch_structures(struct xpc_partition *part ) 
{ 
  enum xp_retval ret ;
  int ch_number ;
  struct xpc_channel *ch ;
  short partid ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;

  {
#line 413
  partid = (short )(((long )part - (long )xpc_partitions) / 896L);
#line 420
  tmp = kzalloc(1536UL, 208U);
#line 420
  part->channels = (struct xpc_channel *)tmp;
#line 422
  if ((unsigned long )part->channels == (unsigned long )((struct xpc_channel *)0)) {
#line 423
    dev_err((struct device  const  *)xpc_chan, "can\'t get memory for channels\n");
#line 424
    return (13);
  } else {

  }
#line 429
  tmp___0 = xpc_kzalloc_cacheline_aligned(64UL, 208U, & part->remote_openclose_args_base);
#line 429
  part->remote_openclose_args = (struct xpc_openclose_args *)tmp___0;
#line 433
  if ((unsigned long )part->remote_openclose_args == (unsigned long )((struct xpc_openclose_args *)0)) {
#line 434
    dev_err((struct device  const  *)xpc_chan, "can\'t get memory for remote connect args\n");
#line 435
    ret = 13;
#line 436
    goto out_1;
  } else {

  }
#line 439
  part->chctl.all_flags = 0ULL;
#line 440
  spinlock_check(& part->chctl_lock);
#line 440
  __raw_spin_lock_init(& part->chctl_lock.__annonCompField18.rlock, "&(&part->chctl_lock)->rlock",
                       & __key);
#line 442
  atomic_set(& part->channel_mgr_requests, 1);
#line 443
  __init_waitqueue_head(& part->channel_mgr_wq, "&part->channel_mgr_wq", & __key___0);
#line 445
  part->nchannels = 2U;
#line 447
  atomic_set(& part->nchannels_active, 0);
#line 448
  atomic_set(& part->nchannels_engaged, 0);
#line 450
  ch_number = 0;
#line 450
  goto ldv_30899;
  ldv_30898: 
#line 451
  ch = part->channels + (unsigned long )ch_number;
#line 453
  ch->partid = partid;
#line 454
  ch->number = (u16 )ch_number;
#line 455
  ch->flags = 65536U;
#line 457
  atomic_set(& ch->kthreads_assigned, 0);
#line 458
  atomic_set(& ch->kthreads_idle, 0);
#line 459
  atomic_set(& ch->kthreads_active, 0);
#line 461
  atomic_set(& ch->references, 0);
#line 462
  atomic_set(& ch->n_to_notify, 0);
#line 464
  spinlock_check(& ch->lock);
#line 464
  __raw_spin_lock_init(& ch->lock.__annonCompField18.rlock, "&(&ch->lock)->rlock",
                       & __key___1);
#line 465
  init_completion(& ch->wdisconnect_wait);
#line 467
  atomic_set(& ch->n_on_msg_allocate_wq, 0);
#line 468
  __init_waitqueue_head(& ch->msg_allocate_wq, "&ch->msg_allocate_wq", & __key___2);
#line 469
  __init_waitqueue_head(& ch->idle_wq, "&ch->idle_wq", & __key___3);
#line 450
  ch_number = ch_number + 1;
  ldv_30899: ;
#line 450
  if ((int )part->nchannels > ch_number) {
#line 452
    goto ldv_30898;
  } else {

  }
#line 472
  ret = (*(xpc_arch_ops.setup_ch_structures))(part);
#line 473
  if ((unsigned int )ret != 0U) {
#line 474
    goto out_2;
  } else {

  }
#line 480
  part->setup_state = 1U;
#line 482
  return (0);
  out_2: 
#line 486
  kfree((void const   *)part->remote_openclose_args_base);
#line 487
  part->remote_openclose_args = (struct xpc_openclose_args *)0;
  out_1: 
#line 489
  kfree((void const   *)part->channels);
#line 490
  part->channels = (struct xpc_channel *)0;
#line 491
  return (ret);
}
}
#line 499 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static void xpc_teardown_ch_structures(struct xpc_partition *part ) 
{ 
  int tmp ;
  wait_queue_t __wait ;
  long __ret ;
  long __int ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 510
  part->setup_state = 2U;
#line 512
  __might_sleep("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c",
                512, 0);
#line 512
  tmp = atomic_read((atomic_t const   *)(& part->references));
#line 512
  if (tmp == 0) {
#line 512
    goto ldv_30905;
  } else {

  }
#line 512
  __ret = 0L;
#line 512
  INIT_LIST_HEAD(& __wait.task_list);
#line 512
  __wait.flags = 0U;
  ldv_30911: 
#line 512
  tmp___0 = prepare_to_wait_event(& part->teardown_wq, & __wait, 2);
#line 512
  __int = tmp___0;
#line 512
  tmp___1 = atomic_read((atomic_t const   *)(& part->references));
#line 512
  if (tmp___1 == 0) {
#line 512
    goto ldv_30910;
  } else {

  }
#line 512
  schedule();
#line 512
  goto ldv_30911;
  ldv_30910: 
#line 512
  finish_wait(& part->teardown_wq, & __wait);

  ldv_30905: 
#line 516
  (*(xpc_arch_ops.teardown_ch_structures))(part);
#line 518
  kfree((void const   *)part->remote_openclose_args_base);
#line 519
  part->remote_openclose_args = (struct xpc_openclose_args *)0;
#line 520
  kfree((void const   *)part->channels);
#line 521
  part->channels = (struct xpc_channel *)0;
#line 523
  part->setup_state = 3U;
#line 524
  return;
}
}
#line 538 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_activating(void *__partid ) 
{ 
  short partid ;
  struct xpc_partition *part ;
  unsigned long irq_flags ;
  struct _ddebug descriptor ;
  long tmp ;
  enum xp_retval tmp___0 ;
  enum xp_retval tmp___1 ;

  {
#line 540
  partid = (short )((long )__partid);
#line 541
  part = xpc_partitions + (unsigned long )partid;
#line 546
  ldv_spin_lock();
#line 548
  if ((unsigned int )part->act_state == 4U) {
#line 549
    part->act_state = 0U;
#line 550
    spin_unlock_irqrestore(& part->act_lock, irq_flags);
#line 551
    part->remote_rp_pa = 0UL;
#line 552
    return (0);
  } else {

  }
#line 557
  part->act_state = 2U;
#line 559
  part->reason = 0;
#line 559
  part->reason_line = 0;
#line 560
  spin_unlock_irqrestore(& part->act_lock, irq_flags);
#line 562
  descriptor.modname = "xpc";
#line 562
  descriptor.function = "xpc_activating";
#line 562
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c";
#line 562
  descriptor.format = "activating partition %d\n";
#line 562
  descriptor.lineno = 562U;
#line 562
  descriptor.flags = 0U;
#line 562
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 562
  if (tmp != 0L) {
#line 562
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_part, "activating partition %d\n",
                      (int )partid);
  } else {

  }
#line 564
  (*(xpc_arch_ops.allow_hb))((int )partid);
#line 566
  tmp___1 = xpc_setup_ch_structures(part);
#line 566
  if ((unsigned int )tmp___1 == 0U) {
#line 567
    xpc_part_ref(part);
#line 569
    tmp___0 = (*(xpc_arch_ops.make_first_contact))(part);
#line 569
    if ((unsigned int )tmp___0 == 0U) {
#line 570
      xpc_mark_partition_active(part);
#line 571
      xpc_channel_mgr(part);
    } else {

    }
#line 575
    xpc_part_deref(part);
#line 576
    xpc_teardown_ch_structures(part);
  } else {

  }
#line 579
  (*(xpc_arch_ops.disallow_hb))((int )partid);
#line 580
  xpc_mark_partition_inactive(part);
#line 582
  if ((unsigned int )part->reason == 21U) {
#line 584
    (*(xpc_arch_ops.request_partition_reactivation))(part);
  } else {

  }
#line 587
  return (0);
}
}
#line 591 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
void xpc_activate_partition(struct xpc_partition *part ) 
{ 
  short partid ;
  unsigned long irq_flags ;
  struct task_struct *kthread ;
  struct task_struct *__k ;
  struct task_struct *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;

  {
#line 593
  partid = (short )(((long )part - (long )xpc_partitions) / 896L);
#line 597
  ldv_spin_lock();
#line 601
  part->act_state = 1U;
#line 602
  part->reason = 24;
#line 602
  part->reason_line = 602;
#line 604
  spin_unlock_irqrestore(& part->act_lock, irq_flags);
#line 606
  tmp = kthread_create_on_node(& xpc_activating, (void *)((unsigned long long )partid),
                               -1, "xpc%02d", (int )partid);
#line 606
  __k = tmp;
#line 606
  tmp___0 = IS_ERR((void const   *)__k);
#line 606
  if (tmp___0) {
#line 606
    tmp___1 = 0;
  } else {
#line 606
    tmp___1 = 1;
  }
#line 606
  if (tmp___1) {
#line 606
    wake_up_process(__k);
  } else {

  }
#line 606
  kthread = __k;
#line 608
  tmp___2 = IS_ERR((void const   *)kthread);
#line 608
  if ((int )tmp___2) {
#line 609
    ldv_spin_lock();
#line 610
    part->act_state = 0U;
#line 611
    part->reason = 25;
#line 611
    part->reason_line = 611;
#line 612
    spin_unlock_irqrestore(& part->act_lock, irq_flags);
  } else {

  }
#line 614
  return;
}
}
#line 617 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
void xpc_activate_kthreads(struct xpc_channel *ch , int needed ) 
{ 
  int idle ;
  int tmp ;
  int assigned ;
  int tmp___0 ;
  int wakeup ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  long tmp___2 ;

  {
#line 619
  tmp = atomic_read((atomic_t const   *)(& ch->kthreads_idle));
#line 619
  idle = tmp;
#line 620
  tmp___0 = atomic_read((atomic_t const   *)(& ch->kthreads_assigned));
#line 620
  assigned = tmp___0;
#line 625
  if (idle > 0) {
#line 626
    wakeup = idle < needed ? idle : needed;
#line 627
    needed = needed - wakeup;
#line 629
    descriptor.modname = "xpc";
#line 629
    descriptor.function = "xpc_activate_kthreads";
#line 629
    descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c";
#line 629
    descriptor.format = "wakeup %d idle kthreads, partid=%d, channel=%d\n";
#line 629
    descriptor.lineno = 630U;
#line 629
    descriptor.flags = 0U;
#line 629
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 629
    if (tmp___1 != 0L) {
#line 629
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_chan, "wakeup %d idle kthreads, partid=%d, channel=%d\n",
                        wakeup, (int )ch->partid, (int )ch->number);
    } else {

    }
#line 633
    __wake_up(& ch->idle_wq, 3U, wakeup, (void *)0);
  } else {

  }
#line 636
  if (needed <= 0) {
#line 637
    return;
  } else {

  }
#line 639
  if ((u32 )(needed + assigned) > ch->kthreads_assigned_limit) {
#line 640
    needed = (int )(ch->kthreads_assigned_limit - (u32 )assigned);
#line 641
    if (needed <= 0) {
#line 642
      return;
    } else {

    }
  } else {

  }
#line 645
  descriptor___0.modname = "xpc";
#line 645
  descriptor___0.function = "xpc_activate_kthreads";
#line 645
  descriptor___0.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c";
#line 645
  descriptor___0.format = "create %d new kthreads, partid=%d, channel=%d\n";
#line 645
  descriptor___0.lineno = 646U;
#line 645
  descriptor___0.flags = 0U;
#line 645
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 645
  if (tmp___2 != 0L) {
#line 645
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)xpc_chan, "create %d new kthreads, partid=%d, channel=%d\n",
                      needed, (int )ch->partid, (int )ch->number);
  } else {

  }
#line 648
  xpc_create_kthreads(ch, needed, 0);
#line 649
  return;
}
}
#line 655 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static void xpc_kthread_waitmsgs(struct xpc_partition *part , struct xpc_channel *ch ) 
{ 
  int (*n_of_deliverable_payloads)(struct xpc_channel * ) ;
  int tmp ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 657
  n_of_deliverable_payloads = xpc_arch_ops.n_of_deliverable_payloads;
  ldv_30960: ;
#line 663
  goto ldv_30946;
  ldv_30945: 
#line 665
  xpc_deliver_payload(ch);
  ldv_30946: 
#line 663
  tmp = (*n_of_deliverable_payloads)(ch);
#line 663
  if (tmp > 0 && (ch->flags & 131072U) == 0U) {
#line 666
    goto ldv_30945;
  } else {

  }
#line 668
  tmp___0 = atomic_add_return(1, & ch->kthreads_idle);
#line 668
  if ((u32 )tmp___0 > ch->kthreads_idle_limit) {
#line 671
    atomic_dec(& ch->kthreads_idle);
#line 672
    goto ldv_30948;
  } else {

  }
#line 675
  descriptor.modname = "xpc";
#line 675
  descriptor.function = "xpc_kthread_waitmsgs";
#line 675
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c";
#line 675
  descriptor.format = "idle kthread calling wait_event_interruptible_exclusive()\n";
#line 675
  descriptor.lineno = 676U;
#line 675
  descriptor.flags = 0U;
#line 675
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 675
  if (tmp___1 != 0L) {
#line 675
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_chan, "idle kthread calling wait_event_interruptible_exclusive()\n");
  } else {

  }
#line 678
  __ret = 0;
#line 678
  __might_sleep("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c",
                680, 0);
#line 678
  tmp___4 = (*n_of_deliverable_payloads)(ch);
#line 678
  if (tmp___4 <= 0 && (ch->flags & 131072U) == 0U) {
#line 678
    __ret___0 = 0L;
#line 678
    INIT_LIST_HEAD(& __wait.task_list);
#line 678
    __wait.flags = 1U;
    ldv_30957: 
#line 678
    tmp___2 = prepare_to_wait_event(& ch->idle_wq, & __wait, 1);
#line 678
    __int = tmp___2;
#line 678
    tmp___3 = (*n_of_deliverable_payloads)(ch);
#line 678
    if (tmp___3 > 0 || (ch->flags & 131072U) != 0U) {
#line 678
      goto ldv_30956;
    } else {

    }
#line 678
    if (__int != 0L) {
#line 678
      __ret___0 = __int;
#line 678
      abort_exclusive_wait(& ch->idle_wq, & __wait, 1U, (void *)0);
#line 678
      goto __out___0;
#line 678
      goto ldv_30956;
    } else {

    }
#line 678
    schedule();
#line 678
    goto ldv_30957;
    ldv_30956: 
#line 678
    finish_wait(& ch->idle_wq, & __wait);
    __out___0: 
#line 678
    __ret = (int )__ret___0;
  } else {

  }
#line 682
  atomic_dec(& ch->kthreads_idle);
#line 684
  if ((ch->flags & 131072U) == 0U) {
#line 686
    goto ldv_30960;
  } else {

  }
  ldv_30948: ;
#line 691
  return;
}
}
#line 688 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_kthread_start(void *args ) 
{ 
  short partid ;
  u16 ch_number ;
  struct xpc_partition *part ;
  struct xpc_channel *ch ;
  int n_needed ;
  unsigned long irq_flags ;
  int (*n_of_deliverable_payloads)(struct xpc_channel * ) ;
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;

  {
#line 690
  partid = (short )((long )args);
#line 691
  ch_number = (u16 )((unsigned long long )args >> 32);
#line 692
  part = xpc_partitions + (unsigned long )partid;
#line 696
  n_of_deliverable_payloads = xpc_arch_ops.n_of_deliverable_payloads;
#line 699
  descriptor.modname = "xpc";
#line 699
  descriptor.function = "xpc_kthread_start";
#line 699
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c";
#line 699
  descriptor.format = "kthread starting, partid=%d, channel=%d\n";
#line 699
  descriptor.lineno = 700U;
#line 699
  descriptor.flags = 0U;
#line 699
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 699
  if (tmp != 0L) {
#line 699
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_chan, "kthread starting, partid=%d, channel=%d\n",
                      (int )partid, (int )ch_number);
  } else {

  }
#line 702
  ch = part->channels + (unsigned long )ch_number;
#line 704
  if ((ch->flags & 131072U) == 0U) {
#line 708
    ldv_spin_lock();
#line 709
    if ((ch->flags & 256U) == 0U) {
#line 710
      ch->flags = ch->flags | 256U;
#line 711
      spin_unlock_irqrestore(& ch->lock, irq_flags);
#line 713
      xpc_connected_callout(ch);
#line 715
      ldv_spin_lock();
#line 716
      ch->flags = ch->flags | 512U;
#line 717
      spin_unlock_irqrestore(& ch->lock, irq_flags);
#line 726
      tmp___0 = (*n_of_deliverable_payloads)(ch);
#line 726
      n_needed = tmp___0 + -1;
#line 727
      if (n_needed > 0 && (ch->flags & 131072U) == 0U) {
#line 728
        xpc_activate_kthreads(ch, n_needed);
      } else {

      }
    } else {
#line 731
      spin_unlock_irqrestore(& ch->lock, irq_flags);
    }
#line 734
    xpc_kthread_waitmsgs(part, ch);
  } else {

  }
#line 739
  ldv_spin_lock();
#line 740
  if ((ch->flags & 512U) != 0U && (ch->flags & 262144U) == 0U) {
#line 742
    ch->flags = ch->flags | 262144U;
#line 743
    spin_unlock_irqrestore(& ch->lock, irq_flags);
#line 745
    xpc_disconnect_callout(ch, 49);
#line 747
    ldv_spin_lock();
#line 748
    ch->flags = ch->flags | 524288U;
  } else {

  }
#line 750
  spin_unlock_irqrestore(& ch->lock, irq_flags);
#line 752
  tmp___1 = atomic_sub_return(1, & ch->kthreads_assigned);
#line 752
  if (tmp___1 == 0) {
#line 752
    tmp___2 = atomic_sub_return(1, & part->nchannels_engaged);
#line 752
    if (tmp___2 == 0) {
#line 754
      (*(xpc_arch_ops.indicate_partition_disengaged))(part);
    } else {

    }
  } else {

  }
#line 757
  xpc_msgqueue_deref(ch);
#line 759
  descriptor___0.modname = "xpc";
#line 759
  descriptor___0.function = "xpc_kthread_start";
#line 759
  descriptor___0.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c";
#line 759
  descriptor___0.format = "kthread exiting, partid=%d, channel=%d\n";
#line 759
  descriptor___0.lineno = 760U;
#line 759
  descriptor___0.flags = 0U;
#line 759
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 759
  if (tmp___3 != 0L) {
#line 759
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)xpc_chan, "kthread exiting, partid=%d, channel=%d\n",
                      (int )partid, (int )ch_number);
  } else {

  }
#line 762
  xpc_part_deref(part);
#line 763
  return (0);
}
}
#line 779 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
void xpc_create_kthreads(struct xpc_channel *ch , int needed , int ignore_disconnecting ) 
{ 
  unsigned long irq_flags ;
  u64 args ;
  struct xpc_partition *part ;
  struct task_struct *kthread ;
  void (*indicate_partition_disengaged)(struct xpc_partition * ) ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct task_struct *__k ;
  struct task_struct *tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;

  {
#line 783
  args = ((unsigned long long )ch->partid & 4294967295ULL) | ((unsigned long long )ch->number << 32);
#line 784
  part = xpc_partitions + (unsigned long )ch->partid;
#line 786
  indicate_partition_disengaged = xpc_arch_ops.indicate_partition_disengaged;
#line 789
  goto ldv_30991;
  ldv_30990: ;
#line 796
  if (ignore_disconnecting != 0) {
#line 797
    tmp___0 = atomic_add_unless(& ch->kthreads_assigned, 1, 0);
#line 797
    if (tmp___0 == 0) {
#line 799
      tmp = ldv__builtin_expect((ch->flags & 524288U) == 0U, 0L);
#line 799
      if (tmp != 0L) {
#line 799
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"),
                             "i" (800), "i" (12UL));
        ldv_30986: ;
#line 799
        goto ldv_30986;
      } else {

      }
#line 801
      goto ldv_30987;
    } else {

    }
  } else
#line 804
  if ((ch->flags & 131072U) != 0U) {
#line 805
    goto ldv_30987;
  } else {
#line 807
    tmp___1 = atomic_add_return(1, & ch->kthreads_assigned);
#line 807
    if (tmp___1 == 1) {
#line 807
      tmp___2 = atomic_add_return(1, & part->nchannels_engaged);
#line 807
      if (tmp___2 == 1) {
#line 809
        (*(xpc_arch_ops.indicate_partition_engaged))(part);
      } else {

      }
    } else {

    }
  }
#line 811
  xpc_part_ref(part);
#line 812
  xpc_msgqueue_ref(ch);
#line 814
  tmp___3 = kthread_create_on_node(& xpc_kthread_start, (void *)args, -1, "xpc%02dc%d",
                                   (int )ch->partid, (int )ch->number);
#line 814
  __k = tmp___3;
#line 814
  tmp___4 = IS_ERR((void const   *)__k);
#line 814
  if (tmp___4) {
#line 814
    tmp___5 = 0;
  } else {
#line 814
    tmp___5 = 1;
  }
#line 814
  if (tmp___5) {
#line 814
    wake_up_process(__k);
  } else {

  }
#line 814
  kthread = __k;
#line 816
  tmp___9 = IS_ERR((void const   *)kthread);
#line 816
  if ((int )tmp___9) {
#line 829
    tmp___6 = atomic_sub_return(1, & ch->kthreads_assigned);
#line 829
    if (tmp___6 == 0) {
#line 829
      tmp___7 = atomic_sub_return(1, & part->nchannels_engaged);
#line 829
      if (tmp___7 == 0) {
#line 831
        (*indicate_partition_disengaged)(part);
      } else {

      }
    } else {

    }
#line 833
    xpc_msgqueue_deref(ch);
#line 834
    xpc_part_deref(part);
#line 836
    tmp___8 = atomic_read((atomic_t const   *)(& ch->kthreads_assigned));
#line 836
    if ((u32 )tmp___8 < ch->kthreads_idle_limit) {
#line 843
      ldv_spin_lock();
#line 844
      xpc_disconnect_channel(845, ch, 14, & irq_flags);
#line 846
      spin_unlock_irqrestore(& ch->lock, irq_flags);
    } else {

    }
#line 848
    goto ldv_30987;
  } else {

  }
  ldv_30991: 
#line 789
  tmp___10 = needed;
#line 789
  needed = needed - 1;
#line 789
  if (tmp___10 > 0) {
#line 791
    goto ldv_30990;
  } else {

  }
  ldv_30987: ;
#line 796
  return;
}
}
#line 854 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
void xpc_disconnect_wait(int ch_number ) 
{ 
  unsigned long irq_flags ;
  short partid ;
  struct xpc_partition *part ;
  struct xpc_channel *ch ;
  int wakeup_channel_mgr ;
  int tmp ;

  {
#line 863
  partid = 0;
#line 863
  goto ldv_31002;
  ldv_31001: 
#line 864
  part = xpc_partitions + (unsigned long )partid;
#line 866
  tmp = xpc_part_ref(part);
#line 866
  if (tmp == 0) {
#line 867
    goto ldv_31000;
  } else {

  }
#line 869
  ch = part->channels + (unsigned long )ch_number;
#line 871
  if ((ch->flags & 1048576U) == 0U) {
#line 872
    xpc_part_deref(part);
#line 873
    goto ldv_31000;
  } else {

  }
#line 876
  wait_for_completion(& ch->wdisconnect_wait);
#line 878
  ldv_spin_lock();
#line 880
  wakeup_channel_mgr = 0;
#line 882
  if ((unsigned int )ch->delayed_chctl_flags != 0U) {
#line 883
    if ((unsigned int )part->act_state != 4U) {
#line 884
      spin_lock(& part->chctl_lock);
#line 885
      part->chctl.flags[(int )ch->number] = (u8 )((int )part->chctl.flags[(int )ch->number] | (int )ch->delayed_chctl_flags);
#line 887
      spin_unlock(& part->chctl_lock);
#line 888
      wakeup_channel_mgr = 1;
    } else {

    }
#line 890
    ch->delayed_chctl_flags = 0U;
  } else {

  }
#line 893
  ch->flags = ch->flags & 4293918719U;
#line 894
  spin_unlock_irqrestore(& ch->lock, irq_flags);
#line 896
  if (wakeup_channel_mgr != 0) {
#line 897
    xpc_wakeup_channel_mgr(part);
  } else {

  }
#line 899
  xpc_part_deref(part);
  ldv_31000: 
#line 863
  partid = (short )((int )partid + 1);
  ldv_31002: ;
#line 863
  if ((int )partid < (int )xp_max_npartitions) {
#line 865
    goto ldv_31001;
  } else {

  }

#line 870
  return;
}
}
#line 904 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_setup_partitions(void) 
{ 
  short partid ;
  struct xpc_partition *part ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  int tmp___0 ;

  {
#line 909
  tmp = kzalloc((unsigned long )xp_max_npartitions * 896UL, 208U);
#line 909
  xpc_partitions = (struct xpc_partition *)tmp;
#line 911
  if ((unsigned long )xpc_partitions == (unsigned long )((struct xpc_partition *)0)) {
#line 912
    dev_err((struct device  const  *)xpc_part, "can\'t get memory for partition structure\n");
#line 913
    return (-12);
  } else {

  }
#line 924
  partid = 0;
#line 924
  goto ldv_31012;
  ldv_31011: 
#line 925
  part = xpc_partitions + (unsigned long )partid;
#line 929
  part->activate_IRQ_rcvd = 0U;
#line 930
  spinlock_check(& part->act_lock);
#line 930
  __raw_spin_lock_init(& part->act_lock.__annonCompField18.rlock, "&(&part->act_lock)->rlock",
                       & __key);
#line 931
  part->act_state = 0U;
#line 932
  part->reason = 0;
#line 932
  part->reason_line = 0;
#line 934
  reg_timer_1(& part->disengage_timer);
#line 935
  part->disengage_timer.function = & xpc_timeout_partition_disengage;
#line 937
  part->disengage_timer.data = (unsigned long )part;
#line 939
  part->setup_state = 0U;
#line 940
  __init_waitqueue_head(& part->teardown_wq, "&part->teardown_wq", & __key___0);
#line 941
  atomic_set(& part->references, 0);
#line 924
  partid = (short )((int )partid + 1);
  ldv_31012: ;
#line 924
  if ((int )partid < (int )xp_max_npartitions) {
#line 926
    goto ldv_31011;
  } else {

  }
#line 944
  tmp___0 = (*(xpc_arch_ops.setup_partitions))();
#line 944
  return (tmp___0);
}
}
#line 948 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static void xpc_teardown_partitions(void) 
{ 


  {
#line 950
  (*(xpc_arch_ops.teardown_partitions))();
#line 951
  kfree((void const   *)xpc_partitions);
#line 952
  return;
}
}
#line 955 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static void xpc_do_exit(enum xp_retval reason ) 
{ 
  short partid ;
  int active_part_count ;
  int printed_waiting_msg ;
  struct xpc_partition *part ;
  unsigned long printmsg_time ;
  unsigned long disengage_timeout ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 958
  printed_waiting_msg = 0;
#line 960
  disengage_timeout = 0UL;
#line 970
  xpc_exiting = 1;
#line 971
  __wake_up(& xpc_activate_IRQ_wq, 1U, 1, (void *)0);
#line 974
  wait_for_completion(& xpc_discovery_exited);
#line 977
  wait_for_completion(& xpc_hb_checker_exited);
#line 980
  msleep_interruptible(300U);
#line 984
  printmsg_time = (unsigned long )jiffies + 2500UL;
#line 985
  xpc_disengage_timedout = 0;
  ldv_31037: 
#line 988
  active_part_count = 0;
#line 990
  partid = 0;
#line 990
  goto ldv_31028;
  ldv_31027: 
#line 991
  part = xpc_partitions + (unsigned long )partid;
#line 993
  tmp = xpc_partition_disengaged(part);
#line 993
  if (tmp != 0 && (unsigned int )part->act_state == 0U) {
#line 995
    goto ldv_31026;
  } else {

  }
#line 998
  active_part_count = active_part_count + 1;
#line 1000
  xpc_deactivate_partition(1000, part, reason);
#line 1002
  if (part->disengage_timeout > disengage_timeout) {
#line 1003
    disengage_timeout = part->disengage_timeout;
  } else {

  }
  ldv_31026: 
#line 990
  partid = (short )((int )partid + 1);
  ldv_31028: ;
#line 990
  if ((int )partid < (int )xp_max_npartitions) {
#line 992
    goto ldv_31027;
  } else {

  }
#line 1006
  tmp___0 = (*(xpc_arch_ops.any_partition_engaged))();
#line 1006
  if (tmp___0 != 0) {
#line 1007
    if ((long )(printmsg_time - (unsigned long )jiffies) < 0L) {
#line 1008
      _dev_info((struct device  const  *)xpc_part, "waiting for remote partitions to deactivate, timeout in %ld seconds\n",
                (disengage_timeout - (unsigned long )jiffies) / 250UL);
#line 1012
      printmsg_time = (unsigned long )jiffies + 2500UL;
#line 1014
      printed_waiting_msg = 1;
    } else {

    }
  } else
#line 1017
  if (active_part_count > 0) {
#line 1018
    if (printed_waiting_msg != 0) {
#line 1019
      _dev_info((struct device  const  *)xpc_part, "waiting for local partition to deactivate\n");
#line 1021
      printed_waiting_msg = 0;
    } else {

    }
  } else {
#line 1025
    if (xpc_disengage_timedout == 0) {
#line 1026
      _dev_info((struct device  const  *)xpc_part, "all partitions have deactivated\n");
    } else {

    }
#line 1029
    goto ldv_31036;
  }
#line 1033
  msleep_interruptible(300U);
#line 1035
  goto ldv_31037;
  ldv_31036: 
#line 1039
  xpc_teardown_rsvd_page();
#line 1041
  if ((unsigned int )reason == 19U) {
#line 1042
    unregister_die_notifier(& xpc_die_notifier);
#line 1043
    unregister_reboot_notifier(& xpc_reboot_notifier);
  } else {

  }
#line 1047
  xpc_clear_interface();
#line 1049
  if ((unsigned long )xpc_sysctl != (unsigned long )((struct ctl_table_header *)0)) {
#line 1050
    unregister_sysctl_table(xpc_sysctl);
  } else {

  }
#line 1052
  xpc_teardown_partitions();
#line 1056
  tmp___1 = is_uv_system();
#line 1056
  if (tmp___1 != 0) {
#line 1057
    xpc_exit_uv();
  } else {

  }
#line 1058
  return;
}
}
#line 1064 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_system_reboot(struct notifier_block *nb , unsigned long event , void *unused ) 
{ 
  enum xp_retval reason ;

  {
#line 1068
  switch (event) {
  case 1UL: 
#line 1070
  reason = 47;
#line 1071
  goto ldv_31045;
  case 2UL: 
#line 1073
  reason = 46;
#line 1074
  goto ldv_31045;
  case 3UL: 
#line 1076
  reason = 48;
#line 1077
  goto ldv_31045;
  default: 
#line 1079
  reason = 45;
  }
  ldv_31045: 
#line 1082
  xpc_do_exit(reason);
#line 1083
  return (0);
}
}
#line 1087 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static unsigned int xpc_die_disconnecting  ;
#line 1094 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static void xpc_die_deactivate(void) 
{ 
  struct xpc_partition *part ;
  short partid ;
  int any_engaged ;
  long keep_waiting ;
  long wait_to_print ;
  unsigned int __ret ;
  unsigned int __old ;
  unsigned int __new ;
  u8 volatile   *__ptr ;
  u16 volatile   *__ptr___0 ;
  u32 volatile   *__ptr___1 ;
  u64 volatile   *__ptr___2 ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 1102
  __old = 0U;
#line 1102
  __new = 1U;
#line 1102
  switch (4UL) {
  case 1UL: 
#line 1102
  __ptr = (u8 volatile   *)(& xpc_die_disconnecting);
#line 1102
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1": "=a" (__ret),
                       "+m" (*__ptr): "q" (__new), "0" (__old): "memory");
#line 1102
  goto ldv_31063;
  case 2UL: 
#line 1102
  __ptr___0 = (u16 volatile   *)(& xpc_die_disconnecting);
#line 1102
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1": "=a" (__ret),
                       "+m" (*__ptr___0): "r" (__new), "0" (__old): "memory");
#line 1102
  goto ldv_31063;
  case 4UL: 
#line 1102
  __ptr___1 = (u32 volatile   *)(& xpc_die_disconnecting);
#line 1102
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1": "=a" (__ret),
                       "+m" (*__ptr___1): "r" (__new), "0" (__old): "memory");
#line 1102
  goto ldv_31063;
  case 8UL: 
#line 1102
  __ptr___2 = (u64 volatile   *)(& xpc_die_disconnecting);
#line 1102
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1": "=a" (__ret),
                       "+m" (*__ptr___2): "r" (__new), "0" (__old): "memory");
#line 1102
  goto ldv_31063;
  default: 
#line 1102
  __cmpxchg_wrong_size();
  }
  ldv_31063: ;
#line 1102
  if (__ret != 0U) {
#line 1103
    return;
  } else {

  }
#line 1106
  xpc_exiting = 1;
#line 1108
  (*(xpc_arch_ops.disallow_all_hbs))();
#line 1110
  partid = 0;
#line 1110
  goto ldv_31073;
  ldv_31072: 
#line 1111
  part = xpc_partitions + (unsigned long )partid;
#line 1113
  tmp = (*(xpc_arch_ops.partition_engaged))((int )partid);
#line 1113
  if (tmp != 0 || (unsigned int )part->act_state != 0U) {
#line 1115
    (*(xpc_arch_ops.request_partition_deactivation))(part);
#line 1116
    (*(xpc_arch_ops.indicate_partition_disengaged))(part);
  } else {

  }
#line 1110
  partid = (short )((int )partid + 1);
  ldv_31073: ;
#line 1110
  if ((int )partid < (int )xp_max_npartitions) {
#line 1112
    goto ldv_31072;
  } else {

  }
#line 1129
  keep_waiting = (long )(xpc_disengage_timelimit * 5000);
#line 1130
  wait_to_print = 50000L;
  ldv_31079: 
#line 1133
  any_engaged = (*(xpc_arch_ops.any_partition_engaged))();
#line 1134
  if (any_engaged == 0) {
#line 1135
    _dev_info((struct device  const  *)xpc_part, "all partitions have deactivated\n");
#line 1136
    goto ldv_31075;
  } else {

  }
#line 1139
  tmp___1 = keep_waiting;
#line 1139
  keep_waiting = keep_waiting - 1L;
#line 1139
  if (tmp___1 == 0L) {
#line 1140
    partid = 0;
#line 1140
    goto ldv_31077;
    ldv_31076: 
#line 1142
    tmp___0 = (*(xpc_arch_ops.partition_engaged))((int )partid);
#line 1142
    if (tmp___0 != 0) {
#line 1143
      _dev_info((struct device  const  *)xpc_part, "deactivate from remote partition %d timed out\n",
                (int )partid);
    } else {

    }
#line 1141
    partid = (short )((int )partid + 1);
    ldv_31077: ;
#line 1140
    if ((int )partid < (int )xp_max_npartitions) {
#line 1142
      goto ldv_31076;
    } else {

    }

#line 1148
    goto ldv_31075;
  } else {

  }
#line 1151
  tmp___2 = wait_to_print;
#line 1151
  wait_to_print = wait_to_print - 1L;
#line 1151
  if (tmp___2 == 0L) {
#line 1152
    _dev_info((struct device  const  *)xpc_part, "waiting for remote partitions to deactivate, timeout in %ld seconds\n",
              keep_waiting / 5000L);
#line 1155
    wait_to_print = 50000L;
  } else {

  }
#line 1159
  __const_udelay(859000UL);
#line 1160
  goto ldv_31079;
  ldv_31075: ;
#line 1162
  return;
}
}
#line 1172 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
static int xpc_system_die(struct notifier_block *nb , unsigned long event , void *_die_args ) 
{ 
  struct die_args *die_args ;
  int tmp ;

  {
#line 1204
  die_args = (struct die_args *)_die_args;
#line 1206
  switch (event) {
  case 8UL: ;
#line 1208
  if (die_args->trapnr == 8) {
#line 1209
    xpc_die_deactivate();
  } else {

  }
#line 1211
  if (die_args->trapnr == 16 || die_args->trapnr == 19) {
#line 1211
    tmp = user_mode(die_args->regs);
#line 1211
    if (tmp == 0) {
#line 1214
      xpc_die_deactivate();
    } else {

    }
  } else {

  }
#line 1216
  goto ldv_31087;
  case 2UL: ;
  case 3UL: ;
#line 1219
  goto ldv_31087;
  case 1UL: ;
  case 9UL: ;
  default: 
#line 1223
  xpc_die_deactivate();
  }
  ldv_31087: ;
#line 1227
  return (0);
}
}
#line 1231 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
int xpc_init(void) 
{ 
  int ret ;
  struct task_struct *kthread ;
  int tmp ;
  struct task_struct *__k ;
  struct task_struct *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  struct task_struct *__k___0 ;
  struct task_struct *tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;

  {
#line 1236
  dev_set_name(xpc_part, "part");
#line 1237
  dev_set_name(xpc_chan, "chan");
#line 1253
  tmp = is_uv_system();
#line 1253
  if (tmp != 0) {
#line 1254
    ret = xpc_init_uv();
  } else {
#line 1257
    ret = -19;
  }
#line 1260
  if (ret != 0) {
#line 1261
    return (ret);
  } else {

  }
#line 1263
  ret = xpc_setup_partitions();
#line 1264
  if (ret != 0) {
#line 1265
    dev_err((struct device  const  *)xpc_part, "can\'t get memory for partition structure\n");
#line 1266
    goto out_1;
  } else {

  }
#line 1269
  xpc_sysctl = register_sysctl_table((struct ctl_table *)(& xpc_sys_dir));
#line 1276
  ret = xpc_setup_rsvd_page();
#line 1277
  if (ret != 0) {
#line 1278
    dev_err((struct device  const  *)xpc_part, "can\'t setup our reserved page\n");
#line 1279
    goto out_2;
  } else {

  }
#line 1283
  ret = register_reboot_notifier(& xpc_reboot_notifier);
#line 1284
  if (ret != 0) {
#line 1285
    dev_warn((struct device  const  *)xpc_part, "can\'t register reboot notifier\n");
  } else {

  }
#line 1288
  ret = register_die_notifier(& xpc_die_notifier);
#line 1289
  if (ret != 0) {
#line 1290
    dev_warn((struct device  const  *)xpc_part, "can\'t register die notifier\n");
  } else {

  }
#line 1296
  tmp___0 = kthread_create_on_node(& xpc_hb_checker, (void *)0, -1, "xpc_hb");
#line 1296
  __k = tmp___0;
#line 1296
  tmp___1 = IS_ERR((void const   *)__k);
#line 1296
  if (tmp___1) {
#line 1296
    tmp___2 = 0;
  } else {
#line 1296
    tmp___2 = 1;
  }
#line 1296
  if (tmp___2) {
#line 1296
    wake_up_process(__k);
  } else {

  }
#line 1296
  kthread = __k;
#line 1297
  tmp___3 = IS_ERR((void const   *)kthread);
#line 1297
  if ((int )tmp___3) {
#line 1298
    dev_err((struct device  const  *)xpc_part, "failed while forking hb check thread\n");
#line 1299
    ret = -16;
#line 1300
    goto out_3;
  } else {

  }
#line 1308
  tmp___4 = kthread_create_on_node(& xpc_initiate_discovery, (void *)0, -1, "xpc_discovery");
#line 1308
  __k___0 = tmp___4;
#line 1308
  tmp___5 = IS_ERR((void const   *)__k___0);
#line 1308
  if (tmp___5) {
#line 1308
    tmp___6 = 0;
  } else {
#line 1308
    tmp___6 = 1;
  }
#line 1308
  if (tmp___6) {
#line 1308
    wake_up_process(__k___0);
  } else {

  }
#line 1308
  kthread = __k___0;
#line 1310
  tmp___7 = IS_ERR((void const   *)kthread);
#line 1310
  if ((int )tmp___7) {
#line 1311
    dev_err((struct device  const  *)xpc_part, "failed while forking discovery thread\n");
#line 1314
    complete(& xpc_discovery_exited);
#line 1316
    xpc_do_exit(19);
#line 1317
    return (-16);
  } else {

  }
#line 1321
  xpc_set_interface(& xpc_initiate_connect, & xpc_initiate_disconnect, & xpc_initiate_send,
                    & xpc_initiate_send_notify, & xpc_initiate_received, & xpc_initiate_partid_to_nasids);
#line 1325
  return (0);
  out_3: 
#line 1329
  xpc_teardown_rsvd_page();
#line 1331
  unregister_die_notifier(& xpc_die_notifier);
#line 1332
  unregister_reboot_notifier(& xpc_reboot_notifier);
  out_2: ;
#line 1334
  if ((unsigned long )xpc_sysctl != (unsigned long )((struct ctl_table_header *)0)) {
#line 1335
    unregister_sysctl_table(xpc_sysctl);
  } else {

  }
#line 1337
  xpc_teardown_partitions();
  out_1: 
#line 1341
  tmp___8 = is_uv_system();
#line 1341
  if (tmp___8 != 0) {
#line 1342
    xpc_exit_uv();
  } else {

  }
#line 1343
  return (ret);
}
}
#line 1349 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.c"
void xpc_exit(void) 
{ 


  {
#line 1351
  xpc_do_exit(19);
#line 1352
  return;
}
}
#line 54 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
int ldv_retval_0  ;
#line 55
extern void ldv_initialize(void) ;
#line 56
extern void ldv_check_final_state(void) ;
#line 60 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
void activate_pending_timer_1(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 60
  if ((unsigned long )ldv_timer_list_1 == (unsigned long )timer) {
#line 61
    if (ldv_timer_state_1 == 2 || pending_flag != 0) {
#line 62
      ldv_timer_list_1 = timer;
#line 63
      ldv_timer_list_1->data = data;
#line 64
      ldv_timer_state_1 = 1;
    } else {

    }
#line 66
    return;
  } else {

  }
#line 68
  reg_timer_1(timer);
#line 69
  ldv_timer_list_1->data = data;
#line 70
  return;
}
}
#line 73 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
void choose_timer_1(struct timer_list *timer ) 
{ 


  {
#line 74
  LDV_IN_INTERRUPT = 2;
#line 75
  (*(timer->function))(timer->data);
#line 76
  LDV_IN_INTERRUPT = 1;
#line 77
  ldv_timer_state_1 = 2;
#line 78
  return;
}
}
#line 81 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
int reg_timer_1(struct timer_list *timer ) 
{ 


  {
#line 82
  ldv_timer_list_1 = timer;
#line 83
  ldv_timer_state_1 = 1;
#line 84
  return (0);
}
}
#line 87 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
void choose_timer_2(struct timer_list *timer ) 
{ 


  {
#line 88
  LDV_IN_INTERRUPT = 2;
#line 89
  (*(timer->function))(timer->data);
#line 90
  LDV_IN_INTERRUPT = 1;
#line 91
  ldv_timer_state_2 = 2;
#line 92
  return;
}
}
#line 95 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
int reg_timer_2(struct timer_list *timer ) 
{ 


  {
#line 96
  ldv_timer_list_2 = timer;
#line 97
  ldv_timer_state_2 = 1;
#line 98
  return (0);
}
}
#line 101 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 101
  if ((unsigned long )ldv_timer_list_2 == (unsigned long )timer) {
#line 102
    if (ldv_timer_state_2 == 2 || pending_flag != 0) {
#line 103
      ldv_timer_list_2 = timer;
#line 104
      ldv_timer_list_2->data = data;
#line 105
      ldv_timer_state_2 = 1;
    } else {

    }
#line 107
    return;
  } else {

  }
#line 109
  reg_timer_2(timer);
#line 110
  ldv_timer_list_2->data = data;
#line 111
  return;
}
}
#line 114 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
void disable_suitable_timer_2(struct timer_list *timer ) 
{ 


  {
#line 115
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_2) {
#line 116
    ldv_timer_state_2 = 0;
#line 117
    return;
  } else {

  }
#line 119
  return;
}
}
#line 122 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
void disable_suitable_timer_1(struct timer_list *timer ) 
{ 


  {
#line 123
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_1) {
#line 124
    ldv_timer_state_1 = 0;
#line 125
    return;
  } else {

  }
#line 127
  return;
}
}
#line 131
void ldv_main_exported_3(void) ;
#line 138 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
void main(void) 
{ 
  void *ldvarg1 ;
  void *tmp ;
  struct notifier_block *ldvarg0 ;
  void *tmp___0 ;
  unsigned long ldvarg2 ;
  struct notifier_block *ldvarg27 ;
  void *tmp___1 ;
  unsigned long ldvarg29 ;
  void *ldvarg28 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 141
  tmp = ldv_init_zalloc(1UL);
#line 141
  ldvarg1 = tmp;
#line 142
  tmp___0 = ldv_init_zalloc(24UL);
#line 142
  ldvarg0 = (struct notifier_block *)tmp___0;
#line 144
  tmp___1 = ldv_init_zalloc(24UL);
#line 144
  ldvarg27 = (struct notifier_block *)tmp___1;
#line 146
  tmp___2 = ldv_init_zalloc(1UL);
#line 146
  ldvarg28 = tmp___2;
#line 139
  ldv_initialize();
#line 143
  ldv_memset((void *)(& ldvarg2), 0, 8UL);
#line 145
  ldv_memset((void *)(& ldvarg29), 0, 8UL);
#line 148
  ldv_state_variable_4 = 0;
#line 150
  ldv_state_variable_1 = 1;
#line 151
  ref_cnt = 0;
#line 152
  ldv_state_variable_0 = 1;
#line 153
  ldv_state_variable_3 = 0;
#line 155
  ldv_state_variable_2 = 1;
#line 156
  ldv_state_variable_5 = 0;
  ldv_31268: 
#line 158
  tmp___3 = __VERIFIER_nondet_int();
#line 158
  switch (tmp___3) {
  case 0: ;
#line 162
  if (ldv_state_variable_4 != 0) {
#line 163
    tmp___4 = __VERIFIER_nondet_int();
#line 163
    switch (tmp___4) {
    case 0: ;
#line 166
    if (ldv_state_variable_4 == 1) {
#line 168
      xpc_system_die(ldvarg0, ldvarg2, ldvarg1);
#line 170
      ldv_state_variable_4 = 1;
    } else {

    }
#line 173
    goto ldv_31251;
    default: 
#line 174
    ldv_stop();
    }
    ldv_31251: ;
  } else {

  }
#line 178
  goto ldv_31253;
  case 1: ;
#line 182
  if (ldv_state_variable_1 != 0) {
#line 183
    choose_timer_1(ldv_timer_list_1);
  } else {

  }
#line 186
  goto ldv_31253;
  case 2: ;
#line 190
  if (ldv_state_variable_0 != 0) {
#line 191
    tmp___5 = __VERIFIER_nondet_int();
#line 191
    switch (tmp___5) {
    case 0: ;
#line 194
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 196
      xpc_exit();
#line 197
      ldv_state_variable_0 = 2;
#line 198
      goto ldv_final;
    } else {

    }
#line 201
    goto ldv_31258;
    case 1: ;
#line 204
    if (ldv_state_variable_0 == 1) {
#line 206
      ldv_retval_0 = xpc_init();
#line 208
      if (ldv_retval_0 == 0) {
#line 209
        ldv_state_variable_0 = 3;
#line 210
        ldv_state_variable_5 = 1;
#line 211
        ldv_state_variable_3 = 1;
#line 212
        ldv_initialize_xpc_arch_operations_3();
#line 213
        ldv_state_variable_4 = 1;
      } else {

      }
#line 215
      if (ldv_retval_0 != 0) {
#line 216
        ldv_state_variable_0 = 2;
#line 217
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 221
    goto ldv_31258;
    default: 
#line 222
    ldv_stop();
    }
    ldv_31258: ;
  } else {

  }
#line 226
  goto ldv_31253;
  case 3: ;
#line 230
  if (ldv_state_variable_3 != 0) {
#line 231
    ldv_main_exported_3();
  } else {

  }
#line 234
  goto ldv_31253;
  case 4: ;
#line 238
  if (ldv_state_variable_2 != 0) {
#line 239
    choose_timer_2(ldv_timer_list_2);
  } else {

  }
#line 242
  goto ldv_31253;
  case 5: ;
#line 246
  if (ldv_state_variable_5 != 0) {
#line 247
    tmp___6 = __VERIFIER_nondet_int();
#line 247
    switch (tmp___6) {
    case 0: ;
#line 250
    if (ldv_state_variable_5 == 1) {
#line 252
      xpc_system_reboot(ldvarg27, ldvarg29, ldvarg28);
#line 254
      ldv_state_variable_5 = 1;
    } else {

    }
#line 257
    goto ldv_31265;
    default: 
#line 258
    ldv_stop();
    }
    ldv_31265: ;
  } else {

  }
#line 262
  goto ldv_31253;
  default: 
#line 263
  ldv_stop();
  }
  ldv_31253: ;
#line 265
  goto ldv_31268;
  ldv_final: 
#line 267
  ldv_check_final_state();
#line 268
  return;
}
}
#line 283 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 286
  tmp = ldv_is_err(ptr);
#line 286
  return (tmp);
}
}
#line 295 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 298
  ldv_spin_lock();
#line 300
  ldv_spin_lock_5(lock);
#line 301
  return;
}
}
#line 330 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 333
  ldv_spin_unlock();
#line 335
  ldv_spin_unlock_9(lock);
#line 336
  return;
}
}
#line 354 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 357
  ldv_spin_unlock();
#line 359
  ldv_spin_unlock_irqrestore_12(lock, flags);
#line 360
  return;
}
}
#line 419 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
void *ldv_kmem_cache_alloc_20(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 422
  ldv_check_alloc_flags(flags);
#line 423
  tmp = ldv_undef_ptr();
#line 423
  return (tmp);
}
}
#line 426 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 429
  ldv_check_alloc_flags(flags);
#line 430
  tmp = ldv_undef_ptr();
#line 430
  return (tmp);
}
}
#line 440 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_main.o.c.prepared"
int ldv_del_timer_sync_23(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 444
  tmp = del_timer_sync(ldv_func_arg1);
#line 444
  ldv_func_res = tmp;
#line 446
  disable_suitable_timer_1(ldv_func_arg1);
#line 448
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) ;
#line 359
__inline static void spin_unlock(spinlock_t *lock ) ;
#line 386
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 924 "include/linux/wait.h"
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 931
extern int autoremove_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 173 "include/linux/mutex.h"
extern int mutex_trylock(struct mutex * ) ;
#line 174
extern void mutex_unlock(struct mutex * ) ;
#line 421 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_44(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 874 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
extern struct xpc_registration xpc_registrations[] ;
#line 923
enum xp_retval xpc_allocate_msg_wait(struct xpc_channel *ch ) ;
#line 934
void xpc_partition_going_down(struct xpc_partition *part , enum xp_retval reason ) ;
#line 27 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
static void xpc_process_connect(struct xpc_channel *ch , unsigned long *irq_flags ) 
{ 
  enum xp_retval ret ;

  {
#line 33
  if ((ch->flags & 64U) == 0U || (ch->flags & 32U) == 0U) {
#line 36
    return;
  } else {

  }
#line 40
  if ((ch->flags & 128U) == 0U) {
#line 41
    spin_unlock_irqrestore(& ch->lock, *irq_flags);
#line 42
    ret = (*(xpc_arch_ops.setup_msg_structures))(ch);
#line 43
    ldv_spin_lock();
#line 45
    if ((unsigned int )ret != 0U) {
#line 46
      xpc_disconnect_channel(46, ch, ret, irq_flags);
    } else {
#line 48
      ch->flags = ch->flags | 128U;
    }
#line 50
    if ((ch->flags & 131072U) != 0U) {
#line 51
      return;
    } else {

    }
  } else {

  }
#line 54
  if ((ch->flags & 16U) == 0U) {
#line 55
    ch->flags = ch->flags | 16U;
#line 56
    (*(xpc_arch_ops.send_chctl_openreply))(ch, irq_flags);
  } else {

  }
#line 59
  if ((ch->flags & 8U) == 0U) {
#line 60
    return;
  } else {

  }
#line 62
  if ((ch->flags & 4U) == 0U) {
#line 63
    ch->flags = ch->flags | 1028U;
#line 64
    (*(xpc_arch_ops.send_chctl_opencomplete))(ch, irq_flags);
  } else {

  }
#line 67
  if ((ch->flags & 2U) == 0U) {
#line 68
    return;
  } else {

  }
#line 70
  _dev_info((struct device  const  *)xpc_chan, "channel %d to partition %d connected\n",
            (int )ch->number, (int )ch->partid);
#line 73
  ch->flags = 1152U;
#line 74
  return;
}
}
#line 80 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
static void xpc_process_disconnect(struct xpc_channel *ch , unsigned long *irq_flags ) 
{ 
  struct xpc_partition *part ;
  u32 channel_was_connected ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 82
  part = xpc_partitions + (unsigned long )ch->partid;
#line 83
  channel_was_connected = ch->flags & 1U;
#line 87
  if ((ch->flags & 131072U) == 0U) {
#line 88
    return;
  } else {

  }
#line 94
  tmp = atomic_read((atomic_t const   *)(& ch->kthreads_assigned));
#line 94
  if (tmp > 0) {
#line 96
    return;
  } else {
#line 94
    tmp___0 = atomic_read((atomic_t const   *)(& ch->references));
#line 94
    if (tmp___0 > 0) {
#line 96
      return;
    } else {

    }
  }
#line 101
  if ((unsigned int )part->act_state == 4U) {
#line 103
    tmp___1 = (*(xpc_arch_ops.partition_engaged))((int )ch->partid);
#line 103
    if (tmp___1 != 0) {
#line 104
      return;
    } else {

    }
  } else {
#line 110
    if ((ch->flags & 16384U) == 0U) {
#line 111
      return;
    } else {

    }
#line 113
    if ((ch->flags & 8192U) == 0U) {
#line 114
      ch->flags = ch->flags | 8192U;
#line 115
      (*(xpc_arch_ops.send_chctl_closereply))(ch, irq_flags);
    } else {

    }
#line 118
    if ((ch->flags & 4096U) == 0U) {
#line 119
      return;
    } else {

    }
  }
#line 123
  tmp___2 = atomic_read((atomic_t const   *)(& ch->n_to_notify));
#line 123
  if (tmp___2 > 0) {
#line 125
    (*(xpc_arch_ops.notify_senders_of_disconnect))(ch);
  } else {

  }
#line 130
  if ((ch->flags & 524288U) != 0U) {
#line 131
    spin_unlock_irqrestore(& ch->lock, *irq_flags);
#line 132
    xpc_disconnect_callout(ch, 51);
#line 133
    ldv_spin_lock();
  } else {

  }
#line 139
  (*(xpc_arch_ops.teardown_msg_structures))(ch);
#line 141
  ch->func = (void (*)(enum xp_retval  , short  , int  , void * , void * ))0;
#line 142
  ch->key = (void *)0;
#line 143
  ch->entry_size = 0U;
#line 144
  ch->local_nentries = 0U;
#line 145
  ch->remote_nentries = 0U;
#line 146
  ch->kthreads_assigned_limit = 0U;
#line 147
  ch->kthreads_idle_limit = 0U;
#line 155
  ch->flags = (ch->flags & 1048576U) | 65536U;
#line 157
  atomic_dec(& part->nchannels_active);
#line 159
  if (channel_was_connected != 0U) {
#line 160
    _dev_info((struct device  const  *)xpc_chan, "channel %d to partition %d disconnected, reason=%d\n",
              (int )ch->number, (int )ch->partid, (unsigned int )ch->reason);
  } else {

  }
#line 164
  if ((ch->flags & 1048576U) != 0U) {
#line 166
    complete(& ch->wdisconnect_wait);
  } else
#line 167
  if ((unsigned int )ch->delayed_chctl_flags != 0U) {
#line 168
    if ((unsigned int )part->act_state != 4U) {
#line 170
      spin_lock(& part->chctl_lock);
#line 171
      part->chctl.flags[(int )ch->number] = (u8 )((int )part->chctl.flags[(int )ch->number] | (int )ch->delayed_chctl_flags);
#line 173
      spin_unlock(& part->chctl_lock);
    } else {

    }
#line 175
    ch->delayed_chctl_flags = 0U;
  } else {

  }
#line 177
  return;
}
}
#line 183 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
static void xpc_process_openclose_chctl_flags(struct xpc_partition *part , int ch_number ,
                                              u8 chctl_flags ) 
{ 
  unsigned long irq_flags ;
  struct xpc_openclose_args *args ;
  struct xpc_channel *ch ;
  enum xp_retval reason ;
  enum xp_retval ret ;
  int create_kthread ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;
  struct _ddebug descriptor___4 ;
  long tmp___4 ;
  struct _ddebug descriptor___5 ;
  long tmp___5 ;

  {
#line 187
  args = part->remote_openclose_args + (unsigned long )ch_number;
#line 189
  ch = part->channels + (unsigned long )ch_number;
#line 192
  create_kthread = 0;
#line 194
  ldv_spin_lock();
  again: ;
#line 198
  if ((ch->flags & 65536U) != 0U && (ch->flags & 1048576U) != 0U) {
#line 204
    ch->delayed_chctl_flags = (u8 )((int )ch->delayed_chctl_flags | (int )chctl_flags);
#line 205
    goto out;
  } else {

  }
#line 208
  if ((int )chctl_flags & 1) {
#line 210
    descriptor.modname = "xpc";
#line 210
    descriptor.function = "xpc_process_openclose_chctl_flags";
#line 210
    descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 210
    descriptor.format = "XPC_CHCTL_CLOSEREQUEST (reason=%d) received from partid=%d, channel=%d\n";
#line 210
    descriptor.lineno = 212U;
#line 210
    descriptor.flags = 0U;
#line 210
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 210
    if (tmp != 0L) {
#line 210
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_chan, "XPC_CHCTL_CLOSEREQUEST (reason=%d) received from partid=%d, channel=%d\n",
                        (int )args->reason, (int )ch->partid, (int )ch->number);
    } else {

    }
#line 220
    if ((ch->flags & 16384U) != 0U) {
#line 227
      chctl_flags = (unsigned int )chctl_flags & 253U;
#line 228
      ch->flags = ch->flags | 4096U;
#line 231
      xpc_process_disconnect(ch, & irq_flags);
#line 233
      goto again;
    } else {

    }
#line 236
    if ((ch->flags & 65536U) != 0U) {
#line 237
      if (((int )chctl_flags & 4) == 0) {
#line 238
        if (((int )part->chctl.flags[ch_number] & 4) != 0) {
#line 242
          spin_lock(& part->chctl_lock);
#line 243
          part->chctl.flags[ch_number] = (u8 )((unsigned int )part->chctl.flags[ch_number] | 1U);
#line 245
          spin_unlock(& part->chctl_lock);
        } else {

        }
#line 247
        goto out;
      } else {

      }
#line 250
      ch->reason = 0;
#line 250
      ch->reason_line = 0;
#line 251
      ch->flags = ch->flags & 4294901759U;
#line 253
      atomic_inc(& part->nchannels_active);
#line 254
      ch->flags = ch->flags | 2080U;
    } else {

    }
#line 257
    chctl_flags = (unsigned int )chctl_flags & 227U;
#line 265
    ch->flags = ch->flags | 16384U;
#line 267
    if ((ch->flags & 131072U) == 0U) {
#line 268
      reason = (enum xp_retval )args->reason;
#line 269
      if ((unsigned int )reason == 0U || (unsigned int )reason > 63U) {
#line 270
        reason = 63;
      } else
#line 271
      if ((unsigned int )reason == 22U) {
#line 272
        reason = 23;
      } else {

      }
#line 274
      xpc_disconnect_channel(274, ch, reason, & irq_flags);
#line 277
      goto out;
    } else {

    }
#line 280
    xpc_process_disconnect(ch, & irq_flags);
  } else {

  }
#line 283
  if (((int )chctl_flags & 2) != 0) {
#line 285
    descriptor___0.modname = "xpc";
#line 285
    descriptor___0.function = "xpc_process_openclose_chctl_flags";
#line 285
    descriptor___0.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 285
    descriptor___0.format = "XPC_CHCTL_CLOSEREPLY received from partid=%d, channel=%d\n";
#line 285
    descriptor___0.lineno = 286U;
#line 285
    descriptor___0.flags = 0U;
#line 285
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 285
    if (tmp___0 != 0L) {
#line 285
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)xpc_chan, "XPC_CHCTL_CLOSEREPLY received from partid=%d, channel=%d\n",
                        (int )ch->partid, (int )ch->number);
    } else {

    }
#line 288
    if ((ch->flags & 65536U) != 0U) {
#line 290
      goto out;
    } else {

    }
#line 295
    if ((ch->flags & 16384U) == 0U) {
#line 296
      if ((int )part->chctl.flags[ch_number] & 1) {
#line 300
        spin_lock(& part->chctl_lock);
#line 301
        part->chctl.flags[ch_number] = (u8 )((unsigned int )part->chctl.flags[ch_number] | 2U);
#line 303
        spin_unlock(& part->chctl_lock);
      } else {

      }
#line 305
      goto out;
    } else {

    }
#line 308
    ch->flags = ch->flags | 4096U;
#line 310
    if ((ch->flags & 8192U) != 0U) {
#line 312
      xpc_process_disconnect(ch, & irq_flags);
    } else {

    }
  } else {

  }
#line 316
  if (((int )chctl_flags & 4) != 0) {
#line 318
    descriptor___1.modname = "xpc";
#line 318
    descriptor___1.function = "xpc_process_openclose_chctl_flags";
#line 318
    descriptor___1.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 318
    descriptor___1.format = "XPC_CHCTL_OPENREQUEST (entry_size=%d, local_nentries=%d) received from partid=%d, channel=%d\n";
#line 318
    descriptor___1.lineno = 321U;
#line 318
    descriptor___1.flags = 0U;
#line 318
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 318
    if (tmp___1 != 0L) {
#line 318
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)xpc_chan, "XPC_CHCTL_OPENREQUEST (entry_size=%d, local_nentries=%d) received from partid=%d, channel=%d\n",
                        (int )args->entry_size, (int )args->local_nentries, (int )ch->partid,
                        (int )ch->number);
    } else {

    }
#line 323
    if ((unsigned int )part->act_state == 4U || (ch->flags & 32U) != 0U) {
#line 325
      goto out;
    } else {

    }
#line 328
    if ((ch->flags & 1179648U) != 0U) {
#line 329
      ch->delayed_chctl_flags = (u8 )((unsigned int )ch->delayed_chctl_flags | 4U);
#line 330
      goto out;
    } else {

    }
#line 342
    if ((unsigned int )args->entry_size == 0U || (unsigned int )args->local_nentries == 0U) {
#line 344
      goto out;
    } else {

    }
#line 347
    ch->flags = ch->flags | 2080U;
#line 348
    ch->remote_nentries = args->local_nentries;
#line 350
    if ((ch->flags & 64U) != 0U) {
#line 351
      if ((int )args->entry_size != (int )ch->entry_size) {
#line 352
        xpc_disconnect_channel(353, ch, 11, & irq_flags);
#line 354
        goto out;
      } else {

      }
    } else {
#line 357
      ch->entry_size = args->entry_size;
#line 359
      ch->reason = 0;
#line 359
      ch->reason_line = 0;
#line 360
      ch->flags = ch->flags & 4294901759U;
#line 362
      atomic_inc(& part->nchannels_active);
    }
#line 365
    xpc_process_connect(ch, & irq_flags);
  } else {

  }
#line 368
  if (((int )chctl_flags & 8) != 0) {
#line 370
    descriptor___2.modname = "xpc";
#line 370
    descriptor___2.function = "xpc_process_openclose_chctl_flags";
#line 370
    descriptor___2.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 370
    descriptor___2.format = "XPC_CHCTL_OPENREPLY (local_msgqueue_pa=0x%lx, local_nentries=%d, remote_nentries=%d) received from partid=%d, channel=%d\n";
#line 370
    descriptor___2.lineno = 374U;
#line 370
    descriptor___2.flags = 0U;
#line 370
    tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 370
    if (tmp___2 != 0L) {
#line 370
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)xpc_chan, "XPC_CHCTL_OPENREPLY (local_msgqueue_pa=0x%lx, local_nentries=%d, remote_nentries=%d) received from partid=%d, channel=%d\n",
                        args->local_msgqueue_pa, (int )args->local_nentries, (int )args->remote_nentries,
                        (int )ch->partid, (int )ch->number);
    } else {

    }
#line 376
    if ((ch->flags & 196608U) != 0U) {
#line 377
      goto out;
    } else {

    }
#line 379
    if ((ch->flags & 64U) == 0U) {
#line 380
      xpc_disconnect_channel(381, ch, 50, & irq_flags);
#line 382
      goto out;
    } else {

    }
#line 399
    ret = (*(xpc_arch_ops.save_remote_msgqueue_pa))(ch, args->local_msgqueue_pa);
#line 401
    if ((unsigned int )ret != 0U) {
#line 402
      xpc_disconnect_channel(402, ch, ret, & irq_flags);
#line 403
      goto out;
    } else {

    }
#line 405
    ch->flags = ch->flags | 8U;
#line 407
    if ((int )args->local_nentries < (int )ch->remote_nentries) {
#line 408
      descriptor___3.modname = "xpc";
#line 408
      descriptor___3.function = "xpc_process_openclose_chctl_flags";
#line 408
      descriptor___3.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 408
      descriptor___3.format = "XPC_CHCTL_OPENREPLY: new remote_nentries=%d, old remote_nentries=%d, partid=%d, channel=%d\n";
#line 408
      descriptor___3.lineno = 412U;
#line 408
      descriptor___3.flags = 0U;
#line 408
      tmp___3 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
#line 408
      if (tmp___3 != 0L) {
#line 408
        __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)xpc_chan, "XPC_CHCTL_OPENREPLY: new remote_nentries=%d, old remote_nentries=%d, partid=%d, channel=%d\n",
                          (int )args->local_nentries, (int )ch->remote_nentries, (int )ch->partid,
                          (int )ch->number);
      } else {

      }
#line 414
      ch->remote_nentries = args->local_nentries;
    } else {

    }
#line 416
    if ((int )args->remote_nentries < (int )ch->local_nentries) {
#line 417
      descriptor___4.modname = "xpc";
#line 417
      descriptor___4.function = "xpc_process_openclose_chctl_flags";
#line 417
      descriptor___4.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 417
      descriptor___4.format = "XPC_CHCTL_OPENREPLY: new local_nentries=%d, old local_nentries=%d, partid=%d, channel=%d\n";
#line 417
      descriptor___4.lineno = 421U;
#line 417
      descriptor___4.flags = 0U;
#line 417
      tmp___4 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
#line 417
      if (tmp___4 != 0L) {
#line 417
        __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)xpc_chan, "XPC_CHCTL_OPENREPLY: new local_nentries=%d, old local_nentries=%d, partid=%d, channel=%d\n",
                          (int )args->remote_nentries, (int )ch->local_nentries, (int )ch->partid,
                          (int )ch->number);
      } else {

      }
#line 423
      ch->local_nentries = args->remote_nentries;
    } else {

    }
#line 426
    xpc_process_connect(ch, & irq_flags);
  } else {

  }
#line 429
  if (((int )chctl_flags & 16) != 0) {
#line 431
    descriptor___5.modname = "xpc";
#line 431
    descriptor___5.function = "xpc_process_openclose_chctl_flags";
#line 431
    descriptor___5.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 431
    descriptor___5.format = "XPC_CHCTL_OPENCOMPLETE received from partid=%d, channel=%d\n";
#line 431
    descriptor___5.lineno = 432U;
#line 431
    descriptor___5.flags = 0U;
#line 431
    tmp___5 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
#line 431
    if (tmp___5 != 0L) {
#line 431
      __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)xpc_chan, "XPC_CHCTL_OPENCOMPLETE received from partid=%d, channel=%d\n",
                        (int )ch->partid, (int )ch->number);
    } else {

    }
#line 434
    if ((ch->flags & 196608U) != 0U) {
#line 435
      goto out;
    } else {

    }
#line 437
    if ((ch->flags & 64U) == 0U || (ch->flags & 16U) == 0U) {
#line 439
      xpc_disconnect_channel(440, ch, 50, & irq_flags);
#line 441
      goto out;
    } else {

    }
#line 448
    ch->flags = ch->flags | 2U;
#line 450
    xpc_process_connect(ch, & irq_flags);
#line 451
    create_kthread = 1;
  } else {

  }
  out: 
#line 455
  spin_unlock_irqrestore(& ch->lock, irq_flags);
#line 457
  if (create_kthread != 0) {
#line 458
    xpc_create_kthreads(ch, 1, 0);
  } else {

  }
#line 459
  return;
}
}
#line 465 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
static enum xp_retval xpc_connect_channel(struct xpc_channel *ch ) 
{ 
  unsigned long irq_flags ;
  struct xpc_registration *registration ;
  int tmp ;

  {
#line 468
  registration = (struct xpc_registration *)(& xpc_registrations) + (unsigned long )ch->number;
#line 470
  tmp = mutex_trylock(& registration->mutex);
#line 470
  if (tmp == 0) {
#line 471
    return (8);
  } else {

  }
#line 473
  if ((unsigned long )xpc_registrations[(int )ch->number].func == (unsigned long )((void (*)(enum xp_retval  ,
                                                                                             short  ,
                                                                                             int  ,
                                                                                             void * ,
                                                                                             void * ))0)) {
#line 474
    mutex_unlock(& registration->mutex);
#line 475
    return (15);
  } else {

  }
#line 478
  ldv_spin_lock();
#line 483
  if ((ch->flags & 131072U) != 0U) {
#line 484
    spin_unlock_irqrestore(& ch->lock, irq_flags);
#line 485
    mutex_unlock(& registration->mutex);
#line 486
    return (ch->reason);
  } else {

  }
#line 491
  ch->kthreads_assigned_limit = registration->assigned_limit;
#line 492
  ch->kthreads_idle_limit = registration->idle_limit;
#line 497
  ch->func = registration->func;
#line 499
  ch->key = registration->key;
#line 501
  ch->local_nentries = registration->nentries;
#line 503
  if ((ch->flags & 32U) != 0U) {
#line 504
    if ((int )registration->entry_size != (int )ch->entry_size) {
#line 516
      mutex_unlock(& registration->mutex);
#line 517
      xpc_disconnect_channel(518, ch, 11, & irq_flags);
#line 519
      spin_unlock_irqrestore(& ch->lock, irq_flags);
#line 520
      return (11);
    } else {

    }
  } else {
#line 523
    ch->entry_size = registration->entry_size;
#line 525
    ch->reason = 0;
#line 525
    ch->reason_line = 0;
#line 526
    ch->flags = ch->flags & 4294901759U;
#line 528
    atomic_inc(& (xpc_partitions + (unsigned long )ch->partid)->nchannels_active);
  }
#line 531
  mutex_unlock(& registration->mutex);
#line 535
  ch->flags = ch->flags | 2112U;
#line 536
  (*(xpc_arch_ops.send_chctl_openrequest))(ch, & irq_flags);
#line 538
  xpc_process_connect(ch, & irq_flags);
#line 540
  spin_unlock_irqrestore(& ch->lock, irq_flags);
#line 542
  return (0);
}
}
#line 546 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
void xpc_process_sent_chctl_flags(struct xpc_partition *part ) 
{ 
  unsigned long irq_flags ;
  union xpc_channel_ctl_flags chctl ;
  struct xpc_channel *ch ;
  int ch_number ;
  u32 ch_flags ;

  {
#line 554
  chctl.all_flags = (*(xpc_arch_ops.get_chctl_all_flags))(part);
#line 563
  ch_number = 0;
#line 563
  goto ldv_21935;
  ldv_21934: 
#line 564
  ch = part->channels + (unsigned long )ch_number;
#line 571
  if (((int )chctl.flags[ch_number] & 31) != 0) {
#line 572
    xpc_process_openclose_chctl_flags(part, ch_number, (int )chctl.flags[ch_number]);
  } else {

  }
#line 576
  ch_flags = ch->flags;
#line 578
  if ((ch_flags & 131072U) != 0U) {
#line 579
    ldv_spin_lock();
#line 580
    xpc_process_disconnect(ch, & irq_flags);
#line 581
    spin_unlock_irqrestore(& ch->lock, irq_flags);
#line 582
    goto ldv_21933;
  } else {

  }
#line 585
  if ((unsigned int )part->act_state == 4U) {
#line 586
    goto ldv_21933;
  } else {

  }
#line 588
  if ((ch_flags & 1024U) == 0U) {
#line 589
    if ((ch_flags & 64U) == 0U) {
#line 591
      xpc_connect_channel(ch);
    } else {

    }
#line 593
    goto ldv_21933;
  } else {

  }
#line 602
  if (((int )chctl.flags[ch_number] & 32) != 0) {
#line 603
    (*(xpc_arch_ops.process_msg_chctl_flags))(part, ch_number);
  } else {

  }
  ldv_21933: 
#line 563
  ch_number = ch_number + 1;
  ldv_21935: ;
#line 563
  if ((int )part->nchannels > ch_number) {
#line 565
    goto ldv_21934;
  } else {

  }

#line 570
  return;
}
}
#line 617 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
void xpc_partition_going_down(struct xpc_partition *part , enum xp_retval reason ) 
{ 
  unsigned long irq_flags ;
  int ch_number ;
  struct xpc_channel *ch ;
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;

  {
#line 623
  descriptor.modname = "xpc";
#line 623
  descriptor.function = "xpc_partition_going_down";
#line 623
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 623
  descriptor.format = "deactivating partition %d, reason=%d\n";
#line 623
  descriptor.lineno = 624U;
#line 623
  descriptor.flags = 0U;
#line 623
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 623
  if (tmp != 0L) {
#line 623
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_chan, "deactivating partition %d, reason=%d\n",
                      (int )((short )(((long )part - (long )xpc_partitions) / 896L)),
                      (unsigned int )reason);
  } else {

  }
#line 626
  tmp___0 = xpc_part_ref(part);
#line 626
  if (tmp___0 == 0) {
#line 628
    return;
  } else {

  }
#line 633
  ch_number = 0;
#line 633
  goto ldv_21947;
  ldv_21946: 
#line 634
  ch = part->channels + (unsigned long )ch_number;
#line 636
  xpc_msgqueue_ref(ch);
#line 637
  ldv_spin_lock();
#line 639
  xpc_disconnect_channel(639, ch, reason, & irq_flags);
#line 641
  spin_unlock_irqrestore(& ch->lock, irq_flags);
#line 642
  xpc_msgqueue_deref(ch);
#line 633
  ch_number = ch_number + 1;
  ldv_21947: ;
#line 633
  if ((int )part->nchannels > ch_number) {
#line 635
    goto ldv_21946;
  } else {

  }
#line 645
  xpc_wakeup_channel_mgr(part);
#line 647
  xpc_part_deref(part);
#line 648
  return;
}
}
#line 655 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
void xpc_initiate_connect(int ch_number ) 
{ 
  short partid ;
  struct xpc_partition *part ;
  struct xpc_channel *ch ;
  int tmp ;

  {
#line 663
  partid = 0;
#line 663
  goto ldv_21956;
  ldv_21955: 
#line 664
  part = xpc_partitions + (unsigned long )partid;
#line 666
  tmp = xpc_part_ref(part);
#line 666
  if (tmp != 0) {
#line 667
    ch = part->channels + (unsigned long )ch_number;
#line 673
    xpc_wakeup_channel_mgr(part);
#line 674
    xpc_part_deref(part);
  } else {

  }
#line 663
  partid = (short )((int )partid + 1);
  ldv_21956: ;
#line 663
  if ((int )partid < (int )xp_max_npartitions) {
#line 665
    goto ldv_21955;
  } else {

  }

#line 670
  return;
}
}
#line 680 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
void xpc_connected_callout(struct xpc_channel *ch ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
#line 684
  if ((unsigned long )ch->func != (unsigned long )((void (*)(enum xp_retval  , short  ,
                                                             int  , void * , void * ))0)) {
#line 685
    descriptor.modname = "xpc";
#line 685
    descriptor.function = "xpc_connected_callout";
#line 685
    descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 685
    descriptor.format = "ch->func() called, reason=xpConnected, partid=%d, channel=%d\n";
#line 685
    descriptor.lineno = 686U;
#line 685
    descriptor.flags = 0U;
#line 685
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 685
    if (tmp != 0L) {
#line 685
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_chan, "ch->func() called, reason=xpConnected, partid=%d, channel=%d\n",
                        (int )ch->partid, (int )ch->number);
    } else {

    }
#line 688
    (*(ch->func))(2, (int )ch->partid, (int )ch->number, (void *)((unsigned long long )ch->local_nentries),
                  ch->key);
#line 691
    descriptor___0.modname = "xpc";
#line 691
    descriptor___0.function = "xpc_connected_callout";
#line 691
    descriptor___0.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 691
    descriptor___0.format = "ch->func() returned, reason=xpConnected, partid=%d, channel=%d\n";
#line 691
    descriptor___0.lineno = 692U;
#line 691
    descriptor___0.flags = 0U;
#line 691
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 691
    if (tmp___0 != 0L) {
#line 691
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)xpc_chan, "ch->func() returned, reason=xpConnected, partid=%d, channel=%d\n",
                        (int )ch->partid, (int )ch->number);
    } else {

    }
  } else {

  }
#line 694
  return;
}
}
#line 710 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
void xpc_initiate_disconnect(int ch_number ) 
{ 
  unsigned long irq_flags ;
  short partid ;
  struct xpc_partition *part ;
  struct xpc_channel *ch ;
  int tmp ;

  {
#line 720
  partid = 0;
#line 720
  goto ldv_21972;
  ldv_21971: 
#line 721
  part = xpc_partitions + (unsigned long )partid;
#line 723
  tmp = xpc_part_ref(part);
#line 723
  if (tmp != 0) {
#line 724
    ch = part->channels + (unsigned long )ch_number;
#line 725
    xpc_msgqueue_ref(ch);
#line 727
    ldv_spin_lock();
#line 729
    if ((ch->flags & 65536U) == 0U) {
#line 730
      ch->flags = ch->flags | 1048576U;
#line 732
      xpc_disconnect_channel(733, ch, 22, & irq_flags);
    } else {

    }
#line 736
    spin_unlock_irqrestore(& ch->lock, irq_flags);
#line 738
    xpc_msgqueue_deref(ch);
#line 739
    xpc_part_deref(part);
  } else {

  }
#line 720
  partid = (short )((int )partid + 1);
  ldv_21972: ;
#line 720
  if ((int )partid < (int )xp_max_npartitions) {
#line 722
    goto ldv_21971;
  } else {

  }
#line 743
  xpc_disconnect_wait(ch_number);
#line 744
  return;
}
}
#line 756 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
void xpc_disconnect_channel(int const   line , struct xpc_channel *ch , enum xp_retval reason ,
                            unsigned long *irq_flags ) 
{ 
  u32 channel_was_connected ;
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 759
  channel_was_connected = ch->flags & 1024U;
#line 763
  if ((ch->flags & 196608U) != 0U) {
#line 764
    return;
  } else {

  }
#line 768
  descriptor.modname = "xpc";
#line 768
  descriptor.function = "xpc_disconnect_channel";
#line 768
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 768
  descriptor.format = "reason=%d, line=%d, partid=%d, channel=%d\n";
#line 768
  descriptor.lineno = 769U;
#line 768
  descriptor.flags = 0U;
#line 768
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 768
  if (tmp != 0L) {
#line 768
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_chan, "reason=%d, line=%d, partid=%d, channel=%d\n",
                      (unsigned int )reason, line, (int )ch->partid, (int )ch->number);
  } else {

  }
#line 771
  ch->reason = reason;
#line 771
  ch->reason_line = line;
#line 773
  ch->flags = ch->flags | 163840U;
#line 775
  ch->flags = ch->flags & 4294964103U;
#line 779
  (*(xpc_arch_ops.send_chctl_closerequest))(ch, irq_flags);
#line 781
  if (channel_was_connected != 0U) {
#line 782
    ch->flags = ch->flags | 1U;
  } else {

  }
#line 784
  spin_unlock_irqrestore(& ch->lock, *irq_flags);
#line 787
  tmp___0 = atomic_read((atomic_t const   *)(& ch->kthreads_idle));
#line 787
  if (tmp___0 > 0) {
#line 788
    __wake_up(& ch->idle_wq, 3U, 0, (void *)0);
  } else
#line 790
  if ((ch->flags & 512U) != 0U && (ch->flags & 262144U) == 0U) {
#line 793
    xpc_create_kthreads(ch, 1, 1);
  } else {

  }
#line 797
  tmp___1 = atomic_read((atomic_t const   *)(& ch->n_on_msg_allocate_wq));
#line 797
  if (tmp___1 > 0) {
#line 798
    __wake_up(& ch->msg_allocate_wq, 3U, 1, (void *)0);
  } else {

  }
#line 800
  ldv_spin_lock();
#line 801
  return;
}
}
#line 804 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
void xpc_disconnect_callout(struct xpc_channel *ch , enum xp_retval reason ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
#line 812
  if ((unsigned long )ch->func != (unsigned long )((void (*)(enum xp_retval  , short  ,
                                                             int  , void * , void * ))0)) {
#line 813
    descriptor.modname = "xpc";
#line 813
    descriptor.function = "xpc_disconnect_callout";
#line 813
    descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 813
    descriptor.format = "ch->func() called, reason=%d, partid=%d, channel=%d\n";
#line 813
    descriptor.lineno = 814U;
#line 813
    descriptor.flags = 0U;
#line 813
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 813
    if (tmp != 0L) {
#line 813
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_chan, "ch->func() called, reason=%d, partid=%d, channel=%d\n",
                        (unsigned int )reason, (int )ch->partid, (int )ch->number);
    } else {

    }
#line 816
    (*(ch->func))(reason, (int )ch->partid, (int )ch->number, (void *)0, ch->key);
#line 818
    descriptor___0.modname = "xpc";
#line 818
    descriptor___0.function = "xpc_disconnect_callout";
#line 818
    descriptor___0.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 818
    descriptor___0.format = "ch->func() returned, reason=%d, partid=%d, channel=%d\n";
#line 818
    descriptor___0.lineno = 819U;
#line 818
    descriptor___0.flags = 0U;
#line 818
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 818
    if (tmp___0 != 0L) {
#line 818
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)xpc_chan, "ch->func() returned, reason=%d, partid=%d, channel=%d\n",
                        (unsigned int )reason, (int )ch->partid, (int )ch->number);
    } else {

    }
  } else {

  }
#line 821
  return;
}
}
#line 828 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
enum xp_retval xpc_allocate_msg_wait(struct xpc_channel *ch ) 
{ 
  enum xp_retval ret ;
  wait_queue_t wait ;
  struct task_struct *tmp ;
  long tmp___0 ;

  {
#line 831
  tmp = get_current();
#line 831
  wait.flags = 0U;
#line 831
  wait.private = (void *)tmp;
#line 831
  wait.func = & autoremove_wake_function;
#line 831
  wait.task_list.next = & wait.task_list;
#line 831
  wait.task_list.prev = & wait.task_list;
#line 833
  if ((ch->flags & 131072U) != 0U) {
#line 835
    return (ch->reason);
  } else {

  }
#line 838
  atomic_inc(& ch->n_on_msg_allocate_wq);
#line 839
  prepare_to_wait(& ch->msg_allocate_wq, & wait, 1);
#line 840
  tmp___0 = schedule_timeout(1L);
#line 840
  ret = (enum xp_retval )tmp___0;
#line 841
  finish_wait(& ch->msg_allocate_wq, & wait);
#line 842
  atomic_dec(& ch->n_on_msg_allocate_wq);
#line 844
  if ((ch->flags & 131072U) != 0U) {
#line 845
    ret = ch->reason;
  } else
#line 847
  if ((unsigned int )ret == 0U) {
#line 848
    ret = 9;
  } else {
#line 850
    ret = 10;
  }
#line 853
  return (ret);
}
}
#line 875 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
enum xp_retval xpc_initiate_send(short partid , int ch_number , u32 flags , void *payload ,
                                 u16 payload_size ) 
{ 
  struct xpc_partition *part ;
  enum xp_retval ret ;
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;

  {
#line 878
  part = xpc_partitions + (unsigned long )partid;
#line 879
  ret = 63;
#line 881
  descriptor.modname = "xpc";
#line 881
  descriptor.function = "xpc_initiate_send";
#line 881
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 881
  descriptor.format = "payload=0x%p, partid=%d, channel=%d\n";
#line 881
  descriptor.lineno = 882U;
#line 881
  descriptor.flags = 0U;
#line 881
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 881
  if (tmp != 0L) {
#line 881
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_chan, "payload=0x%p, partid=%d, channel=%d\n",
                      payload, (int )partid, ch_number);
  } else {

  }
#line 888
  tmp___0 = xpc_part_ref(part);
#line 888
  if (tmp___0 != 0) {
#line 889
    ret = (*(xpc_arch_ops.send_payload))(part->channels + (unsigned long )ch_number,
                                         flags, payload, (int )payload_size, 0, (void (*)(enum xp_retval  ,
                                                                                          short  ,
                                                                                          int  ,
                                                                                          void * ))0,
                                         (void *)0);
#line 891
    xpc_part_deref(part);
  } else {

  }
#line 894
  return (ret);
}
}
#line 926 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
enum xp_retval xpc_initiate_send_notify(short partid , int ch_number , u32 flags ,
                                        void *payload , u16 payload_size , void (*func)(enum xp_retval  ,
                                                                                        short  ,
                                                                                        int  ,
                                                                                        void * ) ,
                                        void *key ) 
{ 
  struct xpc_partition *part ;
  enum xp_retval ret ;
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;

  {
#line 929
  part = xpc_partitions + (unsigned long )partid;
#line 930
  ret = 63;
#line 932
  descriptor.modname = "xpc";
#line 932
  descriptor.function = "xpc_initiate_send_notify";
#line 932
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 932
  descriptor.format = "payload=0x%p, partid=%d, channel=%d\n";
#line 932
  descriptor.lineno = 933U;
#line 932
  descriptor.flags = 0U;
#line 932
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 932
  if (tmp != 0L) {
#line 932
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_chan, "payload=0x%p, partid=%d, channel=%d\n",
                      payload, (int )partid, ch_number);
  } else {

  }
#line 940
  tmp___0 = xpc_part_ref(part);
#line 940
  if (tmp___0 != 0) {
#line 941
    ret = (*(xpc_arch_ops.send_payload))(part->channels + (unsigned long )ch_number,
                                         flags, payload, (int )payload_size, 1, func,
                                         key);
#line 943
    xpc_part_deref(part);
  } else {

  }
#line 945
  return (ret);
}
}
#line 952 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
void xpc_deliver_payload(struct xpc_channel *ch ) 
{ 
  void *payload ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
#line 956
  payload = (*(xpc_arch_ops.get_deliverable_payload))(ch);
#line 957
  if ((unsigned long )payload != (unsigned long )((void *)0)) {
#line 964
    xpc_msgqueue_ref(ch);
#line 966
    atomic_inc(& ch->kthreads_active);
#line 968
    if ((unsigned long )ch->func != (unsigned long )((void (*)(enum xp_retval  , short  ,
                                                               int  , void * , void * ))0)) {
#line 969
      descriptor.modname = "xpc";
#line 969
      descriptor.function = "xpc_deliver_payload";
#line 969
      descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 969
      descriptor.format = "ch->func() called, payload=0x%p partid=%d channel=%d\n";
#line 969
      descriptor.lineno = 971U;
#line 969
      descriptor.flags = 0U;
#line 969
      tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 969
      if (tmp != 0L) {
#line 969
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_chan, "ch->func() called, payload=0x%p partid=%d channel=%d\n",
                          payload, (int )ch->partid, (int )ch->number);
      } else {

      }
#line 974
      (*(ch->func))(4, (int )ch->partid, (int )ch->number, payload, ch->key);
#line 977
      descriptor___0.modname = "xpc";
#line 977
      descriptor___0.function = "xpc_deliver_payload";
#line 977
      descriptor___0.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c";
#line 977
      descriptor___0.format = "ch->func() returned, payload=0x%p partid=%d channel=%d\n";
#line 977
      descriptor___0.lineno = 979U;
#line 977
      descriptor___0.flags = 0U;
#line 977
      tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 977
      if (tmp___0 != 0L) {
#line 977
        __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)xpc_chan, "ch->func() returned, payload=0x%p partid=%d channel=%d\n",
                          payload, (int )ch->partid, (int )ch->number);
      } else {

      }
    } else {

    }
#line 982
    atomic_dec(& ch->kthreads_active);
  } else {

  }
#line 984
  return;
}
}
#line 1001 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.c"
void xpc_initiate_received(short partid , int ch_number , void *payload ) 
{ 
  struct xpc_partition *part ;
  struct xpc_channel *ch ;

  {
#line 1003
  part = xpc_partitions + (unsigned long )partid;
#line 1009
  ch = part->channels + (unsigned long )ch_number;
#line 1010
  (*(xpc_arch_ops.received_payload))(ch, payload);
#line 1013
  xpc_msgqueue_deref(ch);
#line 1014
  return;
}
}
#line 201 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_channel.o.c.prepared"
void *ldv_kmem_cache_alloc_44(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 204
  ldv_check_alloc_flags(flags);
#line 205
  tmp = ldv_undef_ptr();
#line 205
  return (tmp);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 314 "./arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 295 "include/linux/percpu-defs.h"
extern void __bad_size_call_parameter(void) ;
#line 57 "./arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 8 "./arch/x86/include/asm/preempt.h"
extern int __preempt_count ;
#line 20 "./arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void) 
{ 
  int pfo_ret__ ;

  {
#line 22
  switch (4UL) {
  case 1UL: 
#line 22
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6106;
  case 2UL: 
#line 22
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6106;
  case 4UL: 
#line 22
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6106;
  case 8UL: 
#line 22
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6106;
  default: 
#line 22
  __bad_percpu_size();
  }
  ldv_6106: ;
#line 22
  return (pfo_ret__ & 2147483647);
}
}
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6163;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6163;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6163;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6163;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6163: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6175;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6175;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6175;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6175;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6175: ;
#line 79
  return;
}
}
#line 386 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 232 "include/linux/timer.h"
int ldv_del_timer_sync_69(struct timer_list *ldv_func_arg1 ) ;
#line 38 "./arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_66(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 418
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 338 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xp.h"
extern u8 xp_region_size ;
#line 340
extern unsigned long (*xp_pa)(void * ) ;
#line 341
extern unsigned long (*xp_socket_pa)(unsigned long  ) ;
#line 342
extern enum xp_retval (*xp_remote_memcpy)(unsigned long  , unsigned long const    ,
                                          size_t  ) ;
#line 344
extern int (*xp_cpu_to_nasid)(int  ) ;
#line 900 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
int xpc_exiting  ;
#line 901 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
int xpc_nasid_mask_nlongs  ;
#line 902 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_rsvd_page *xpc_rsvd_page  ;
#line 903 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
unsigned long *xpc_mach_nasids  ;
#line 904 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xpc.h"
struct xpc_partition *xpc_partitions  ;
#line 905
void *xpc_kmalloc_cacheline_aligned(size_t size , gfp_t flags , void **base ) ;
#line 913
enum xp_retval xpc_get_remote_rp(int nasid , unsigned long *discovered_nasids , struct xpc_rsvd_page *remote_rp ,
                                 unsigned long *remote_rp_pa ) ;
#line 29 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c"
static unsigned long *xpc_part_nasids  ;
#line 32 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c"
static int xpc_nasid_mask_nbytes  ;
#line 41 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c"
void *xpc_kmalloc_cacheline_aligned(size_t size , gfp_t flags , void **base ) 
{ 


  {
#line 44
  *base = kzalloc(size, flags);
#line 45
  if ((unsigned long )*base == (unsigned long )((void *)0)) {
#line 46
    return ((void *)0);
  } else {

  }
#line 48
  if ((unsigned long long )*base == (((unsigned long long )*base + 63ULL) & 0xffffffffffffffc0ULL)) {
#line 49
    return (*base);
  } else {

  }
#line 51
  kfree((void const   *)*base);
#line 54
  *base = kzalloc(size + 64UL, flags);
#line 55
  if ((unsigned long )*base == (unsigned long )((void *)0)) {
#line 56
    return ((void *)0);
  } else {

  }
#line 58
  return ((void *)(((unsigned long long )*base + 63ULL) & 0xffffffffffffffc0ULL));
}
}
#line 66 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c"
static unsigned long xpc_get_rsvd_page_pa(int nasid ) 
{ 
  enum xp_retval ret ;
  u64 cookie ;
  unsigned long rp_pa ;
  size_t len ;
  size_t buf_len ;
  void *buf ;
  void *buf_base ;
  enum xp_retval (*get_partition_rsvd_page_pa)(void * , u64 * , unsigned long * ,
                                               size_t * ) ;
  struct _ddebug descriptor ;
  long tmp ;
  unsigned long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;

  {
#line 69
  cookie = 0ULL;
#line 70
  rp_pa = (unsigned long )nasid;
#line 71
  len = 0UL;
#line 72
  buf_len = 0UL;
#line 73
  buf = buf;
#line 74
  buf_base = (void *)0;
#line 75
  get_partition_rsvd_page_pa = xpc_arch_ops.get_partition_rsvd_page_pa;
  ldv_24705: 
#line 87
  ret = (*get_partition_rsvd_page_pa)(buf, & cookie, & rp_pa, & len);
#line 89
  descriptor.modname = "xpc";
#line 89
  descriptor.function = "xpc_get_rsvd_page_pa";
#line 89
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c";
#line 89
  descriptor.format = "SAL returned with ret=%d, cookie=0x%016lx, address=0x%016lx, len=0x%016lx\n";
#line 89
  descriptor.lineno = 91U;
#line 89
  descriptor.flags = 0U;
#line 89
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 89
  if (tmp != 0L) {
#line 89
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_part, "SAL returned with ret=%d, cookie=0x%016lx, address=0x%016lx, len=0x%016lx\n",
                      (unsigned int )ret, (unsigned long )cookie, rp_pa, len);
  } else {

  }
#line 93
  if ((unsigned int )ret != 57U) {
#line 94
    goto ldv_24703;
  } else {

  }
#line 100
  if (len > buf_len) {
#line 101
    if ((unsigned long )buf_base != (unsigned long )((void *)0)) {
#line 102
      kfree((void const   *)buf_base);
    } else {

    }
#line 103
    buf_len = (len + 63UL) & 0xffffffffffffffc0UL;
#line 104
    buf = xpc_kmalloc_cacheline_aligned(buf_len, 208U, & buf_base);
#line 106
    if ((unsigned long )buf_base == (unsigned long )((void *)0)) {
#line 107
      dev_err((struct device  const  *)xpc_part, "unable to kmalloc len=0x%016lx\n",
              buf_len);
#line 109
      ret = 13;
#line 110
      goto ldv_24703;
    } else {

    }
  } else {

  }
#line 114
  tmp___0 = (*xp_pa)(buf);
#line 114
  ret = (*xp_remote_memcpy)(tmp___0, rp_pa, len);
#line 115
  if ((unsigned int )ret != 0U) {
#line 116
    descriptor___0.modname = "xpc";
#line 116
    descriptor___0.function = "xpc_get_rsvd_page_pa";
#line 116
    descriptor___0.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c";
#line 116
    descriptor___0.format = "xp_remote_memcpy failed %d\n";
#line 116
    descriptor___0.lineno = 116U;
#line 116
    descriptor___0.flags = 0U;
#line 116
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 116
    if (tmp___1 != 0L) {
#line 116
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)xpc_part, "xp_remote_memcpy failed %d\n",
                        (unsigned int )ret);
    } else {

    }
#line 117
    goto ldv_24703;
  } else {

  }
#line 119
  goto ldv_24705;
  ldv_24703: 
#line 121
  kfree((void const   *)buf_base);
#line 123
  if ((unsigned int )ret != 0U) {
#line 124
    rp_pa = 0UL;
  } else {

  }
#line 126
  descriptor___1.modname = "xpc";
#line 126
  descriptor___1.function = "xpc_get_rsvd_page_pa";
#line 126
  descriptor___1.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c";
#line 126
  descriptor___1.format = "reserved page at phys address 0x%016lx\n";
#line 126
  descriptor___1.lineno = 126U;
#line 126
  descriptor___1.flags = 0U;
#line 126
  tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 126
  if (tmp___2 != 0L) {
#line 126
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)xpc_part, "reserved page at phys address 0x%016lx\n",
                      rp_pa);
  } else {

  }
#line 127
  return (rp_pa);
}
}
#line 136 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c"
int xpc_setup_rsvd_page(void) 
{ 
  int ret ;
  struct xpc_rsvd_page *rp ;
  unsigned long rp_pa ;
  unsigned long new_ts_jiffies ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp ;
  unsigned long tmp___0 ;
  long tmp___1 ;

  {
#line 145
  __preempt_count_add(1);
#line 145
  __asm__  volatile   ("": : : "memory");
#line 146
  __vpp_verify = (void const   *)0;
#line 146
  switch (4UL) {
  case 1UL: ;
#line 146
  switch (4UL) {
  case 1UL: 
#line 146
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 146
  goto ldv_24719;
  case 2UL: 
#line 146
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 146
  goto ldv_24719;
  case 4UL: 
#line 146
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 146
  goto ldv_24719;
  case 8UL: 
#line 146
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 146
  goto ldv_24719;
  default: 
#line 146
  __bad_percpu_size();
  }
  ldv_24719: 
#line 146
  pscr_ret__ = pfo_ret__;
#line 146
  goto ldv_24725;
  case 2UL: ;
#line 146
  switch (4UL) {
  case 1UL: 
#line 146
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 146
  goto ldv_24729;
  case 2UL: 
#line 146
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 146
  goto ldv_24729;
  case 4UL: 
#line 146
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 146
  goto ldv_24729;
  case 8UL: 
#line 146
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 146
  goto ldv_24729;
  default: 
#line 146
  __bad_percpu_size();
  }
  ldv_24729: 
#line 146
  pscr_ret__ = pfo_ret_____0;
#line 146
  goto ldv_24725;
  case 4UL: ;
#line 146
  switch (4UL) {
  case 1UL: 
#line 146
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 146
  goto ldv_24738;
  case 2UL: 
#line 146
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 146
  goto ldv_24738;
  case 4UL: 
#line 146
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 146
  goto ldv_24738;
  case 8UL: 
#line 146
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 146
  goto ldv_24738;
  default: 
#line 146
  __bad_percpu_size();
  }
  ldv_24738: 
#line 146
  pscr_ret__ = pfo_ret_____1;
#line 146
  goto ldv_24725;
  case 8UL: ;
#line 146
  switch (4UL) {
  case 1UL: 
#line 146
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 146
  goto ldv_24747;
  case 2UL: 
#line 146
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 146
  goto ldv_24747;
  case 4UL: 
#line 146
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 146
  goto ldv_24747;
  case 8UL: 
#line 146
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 146
  goto ldv_24747;
  default: 
#line 146
  __bad_percpu_size();
  }
  ldv_24747: 
#line 146
  pscr_ret__ = pfo_ret_____2;
#line 146
  goto ldv_24725;
  default: 
#line 146
  __bad_size_call_parameter();
#line 146
  goto ldv_24725;
  }
  ldv_24725: 
#line 146
  tmp = (*xp_cpu_to_nasid)(pscr_ret__);
#line 146
  rp_pa = xpc_get_rsvd_page_pa(tmp);
#line 147
  __asm__  volatile   ("": : : "memory");
#line 147
  __preempt_count_sub(1);
#line 148
  if (rp_pa == 0UL) {
#line 149
    dev_err((struct device  const  *)xpc_part, "SAL failed to locate the reserved page\n");
#line 150
    return (-3);
  } else {

  }
#line 152
  tmp___0 = (*xp_socket_pa)(rp_pa);
#line 152
  rp = (struct xpc_rsvd_page *)(tmp___0 + 0xffff880000000000UL);
#line 154
  if (rp->SAL_version <= 2ULL) {
#line 156
    rp->SAL_partid = (int )rp->SAL_partid & 255;
  } else {

  }
#line 158
  tmp___1 = ldv__builtin_expect((int )rp->SAL_partid != (int )xp_partition_id, 0L);
#line 158
  if (tmp___1 != 0L) {
#line 158
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c"),
                         "i" (158), "i" (12UL));
    ldv_24755: ;
#line 158
    goto ldv_24755;
  } else {

  }
#line 160
  if ((int )rp->SAL_partid < 0 || (int )rp->SAL_partid >= (int )xp_max_npartitions) {
#line 161
    dev_err((struct device  const  *)xpc_part, "the reserved page\'s partid of %d is outside supported range (< 0 || >= %d)\n",
            (int )rp->SAL_partid, (int )xp_max_npartitions);
#line 164
    return (-22);
  } else {

  }
#line 167
  rp->version = 48U;
#line 168
  rp->max_npartitions = xp_max_npartitions;
#line 171
  if (rp->SAL_version == 1ULL) {
#line 173
    rp->SAL_nasids_size = 128ULL;
  } else {

  }
#line 175
  xpc_nasid_mask_nbytes = (int )rp->SAL_nasids_size;
#line 176
  xpc_nasid_mask_nlongs = (int )(((rp->SAL_nasids_size + 8ULL) * 8ULL - 1ULL) / 64ULL);
#line 180
  xpc_part_nasids = (unsigned long *)rp + 128U;
#line 181
  xpc_mach_nasids = (unsigned long *)rp + ((unsigned long )xpc_nasid_mask_nlongs + 128UL);
#line 183
  ret = (*(xpc_arch_ops.setup_rsvd_page))(rp);
#line 184
  if (ret != 0) {
#line 185
    return (ret);
  } else {

  }
#line 192
  new_ts_jiffies = jiffies;
#line 193
  if (new_ts_jiffies == 0UL || rp->ts_jiffies == new_ts_jiffies) {
#line 194
    new_ts_jiffies = new_ts_jiffies + 1UL;
  } else {

  }
#line 195
  rp->ts_jiffies = new_ts_jiffies;
#line 197
  xpc_rsvd_page = rp;
#line 198
  return (0);
}
}
#line 202 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c"
void xpc_teardown_rsvd_page(void) 
{ 


  {
#line 205
  xpc_rsvd_page->ts_jiffies = 0UL;
#line 206
  return;
}
}
#line 216 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c"
enum xp_retval xpc_get_remote_rp(int nasid , unsigned long *discovered_nasids , struct xpc_rsvd_page *remote_rp ,
                                 unsigned long *remote_rp_pa ) 
{ 
  int l ;
  enum xp_retval ret ;
  unsigned long tmp ;
  unsigned long *remote_part_nasids ;

  {
#line 224
  *remote_rp_pa = xpc_get_rsvd_page_pa(nasid);
#line 225
  if (*remote_rp_pa == 0UL) {
#line 226
    return (41);
  } else {

  }
#line 229
  tmp = (*xp_pa)((void *)remote_rp);
#line 229
  ret = (*xp_remote_memcpy)(tmp, *remote_rp_pa, (unsigned long )xpc_nasid_mask_nbytes + 128UL);
#line 231
  if ((unsigned int )ret != 0U) {
#line 232
    return (ret);
  } else {

  }
#line 234
  if ((unsigned long )discovered_nasids != (unsigned long )((unsigned long *)0UL)) {
#line 235
    remote_part_nasids = (unsigned long *)remote_rp + 128U;
#line 238
    l = 0;
#line 238
    goto ldv_24769;
    ldv_24768: 
#line 239
    *(discovered_nasids + (unsigned long )l) = *(discovered_nasids + (unsigned long )l) | *(remote_part_nasids + (unsigned long )l);
#line 238
    l = l + 1;
    ldv_24769: ;
#line 238
    if (l < xpc_nasid_mask_nlongs) {
#line 240
      goto ldv_24768;
    } else {

    }

  } else {

  }
#line 243
  if (remote_rp->ts_jiffies == 0UL) {
#line 244
    return (54);
  } else {

  }
#line 246
  if ((unsigned int )((int )remote_rp->version >> 4) != 3U) {
#line 248
    return (39);
  } else {

  }
#line 252
  if (((int )remote_rp->SAL_partid < 0 || (int )remote_rp->SAL_partid >= (int )xp_max_npartitions) || (int )remote_rp->max_npartitions <= (int )xp_partition_id) {
#line 255
    return (42);
  } else {

  }
#line 258
  if ((int )remote_rp->SAL_partid == (int )xp_partition_id) {
#line 259
    return (43);
  } else {

  }
#line 261
  return (0);
}
}
#line 270 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c"
int xpc_partition_disengaged(struct xpc_partition *part ) 
{ 
  short partid ;
  int disengaged ;
  int tmp ;
  int tmp___0 ;

  {
#line 272
  partid = (short )(((long )part - (long )xpc_partitions) / 896L);
#line 275
  tmp = (*(xpc_arch_ops.partition_engaged))((int )partid);
#line 275
  disengaged = tmp == 0;
#line 276
  if (part->disengage_timeout != 0UL) {
#line 277
    if (disengaged == 0) {
#line 278
      if ((long )((unsigned long )jiffies - part->disengage_timeout) < 0L) {
#line 280
        return (0);
      } else {

      }
#line 288
      _dev_info((struct device  const  *)xpc_part, "deactivate request to remote partition %d timed out\n",
                (int )partid);
#line 290
      xpc_disengage_timedout = 1;
#line 291
      (*(xpc_arch_ops.assume_partition_disengaged))((int )partid);
#line 292
      disengaged = 1;
    } else {

    }
#line 294
    part->disengage_timeout = 0UL;
#line 297
    tmp___0 = preempt_count();
#line 297
    if (((unsigned long )tmp___0 & 2096896UL) == 0UL) {
#line 298
      ldv_del_timer_sync_69(& part->disengage_timer);
    } else {

    }
#line 302
    if ((unsigned int )part->act_state != 0U) {
#line 303
      xpc_wakeup_channel_mgr(part);
    } else {

    }
#line 305
    (*(xpc_arch_ops.cancel_partition_deactivation_request))(part);
  } else {

  }
#line 307
  return (disengaged);
}
}
#line 314 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c"
enum xp_retval xpc_mark_partition_active(struct xpc_partition *part ) 
{ 
  unsigned long irq_flags ;
  enum xp_retval ret ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 319
  descriptor.modname = "xpc";
#line 319
  descriptor.function = "xpc_mark_partition_active";
#line 319
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c";
#line 319
  descriptor.format = "setting partition %d to ACTIVE\n";
#line 319
  descriptor.lineno = 319U;
#line 319
  descriptor.flags = 0U;
#line 319
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 319
  if (tmp != 0L) {
#line 319
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_part, "setting partition %d to ACTIVE\n",
                      (int )((short )(((long )part - (long )xpc_partitions) / 896L)));
  } else {

  }
#line 321
  ldv_spin_lock();
#line 322
  if ((unsigned int )part->act_state == 2U) {
#line 323
    part->act_state = 3U;
#line 324
    ret = 0;
  } else {
#line 327
    ret = part->reason;
  }
#line 329
  spin_unlock_irqrestore(& part->act_lock, irq_flags);
#line 331
  return (ret);
}
}
#line 338 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c"
void xpc_deactivate_partition(int const   line , struct xpc_partition *part , enum xp_retval reason ) 
{ 
  unsigned long irq_flags ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 343
  ldv_spin_lock();
#line 345
  if ((unsigned int )part->act_state == 0U) {
#line 346
    part->reason = reason;
#line 346
    part->reason_line = line;
#line 347
    spin_unlock_irqrestore(& part->act_lock, irq_flags);
#line 348
    if ((unsigned int )reason == 21U) {
#line 350
      (*(xpc_arch_ops.request_partition_reactivation))(part);
    } else {

    }
#line 352
    return;
  } else {

  }
#line 354
  if ((unsigned int )part->act_state == 4U) {
#line 355
    if (((unsigned int )part->reason == 19U && (unsigned int )reason != 19U) || (unsigned int )reason == 21U) {
#line 357
      part->reason = reason;
#line 357
      part->reason_line = line;
    } else {

    }
#line 359
    spin_unlock_irqrestore(& part->act_lock, irq_flags);
#line 360
    return;
  } else {

  }
#line 363
  part->act_state = 4U;
#line 364
  part->reason = reason;
#line 364
  part->reason_line = line;
#line 366
  spin_unlock_irqrestore(& part->act_lock, irq_flags);
#line 369
  (*(xpc_arch_ops.request_partition_deactivation))(part);
#line 372
  part->disengage_timeout = (unsigned long )(xpc_disengage_timelimit * 250) + (unsigned long )jiffies;
#line 373
  part->disengage_timer.expires = part->disengage_timeout;
#line 374
  add_timer(& part->disengage_timer);
#line 376
  descriptor.modname = "xpc";
#line 376
  descriptor.function = "xpc_deactivate_partition";
#line 376
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c";
#line 376
  descriptor.format = "bringing partition %d down, reason = %d\n";
#line 376
  descriptor.lineno = 377U;
#line 376
  descriptor.flags = 0U;
#line 376
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 376
  if (tmp != 0L) {
#line 376
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_part, "bringing partition %d down, reason = %d\n",
                      (int )((short )(((long )part - (long )xpc_partitions) / 896L)),
                      (unsigned int )reason);
  } else {

  }
#line 379
  xpc_partition_going_down(part, reason);
#line 380
  return;
}
}
#line 386 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c"
void xpc_mark_partition_inactive(struct xpc_partition *part ) 
{ 
  unsigned long irq_flags ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 390
  descriptor.modname = "xpc";
#line 390
  descriptor.function = "xpc_mark_partition_inactive";
#line 390
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c";
#line 390
  descriptor.format = "setting partition %d to INACTIVE\n";
#line 390
  descriptor.lineno = 391U;
#line 390
  descriptor.flags = 0U;
#line 390
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 390
  if (tmp != 0L) {
#line 390
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_part, "setting partition %d to INACTIVE\n",
                      (int )((short )(((long )part - (long )xpc_partitions) / 896L)));
  } else {

  }
#line 393
  ldv_spin_lock();
#line 394
  part->act_state = 0U;
#line 395
  spin_unlock_irqrestore(& part->act_lock, irq_flags);
#line 396
  part->remote_rp_pa = 0UL;
#line 397
  return;
}
}
#line 409 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c"
void xpc_discovery(void) 
{ 
  void *remote_rp_base ;
  struct xpc_rsvd_page *remote_rp ;
  unsigned long remote_rp_pa ;
  int region ;
  int region_size ;
  int max_regions ;
  int nasid ;
  struct xpc_rsvd_page *rp ;
  unsigned long *discovered_nasids ;
  enum xp_retval ret ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  struct _ddebug descriptor ;
  long tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;
  struct _ddebug descriptor___1 ;
  long tmp___4 ;
  int tmp___5 ;
  struct _ddebug descriptor___2 ;
  long tmp___6 ;
  int tmp___7 ;
  struct _ddebug descriptor___3 ;
  long tmp___8 ;
  int tmp___9 ;
  struct _ddebug descriptor___4 ;
  long tmp___10 ;

  {
#line 422
  tmp = xpc_kmalloc_cacheline_aligned((unsigned long )xpc_nasid_mask_nbytes + 128UL,
                                      208U, & remote_rp_base);
#line 422
  remote_rp = (struct xpc_rsvd_page *)tmp;
#line 425
  if ((unsigned long )remote_rp == (unsigned long )((struct xpc_rsvd_page *)0)) {
#line 426
    return;
  } else {

  }
#line 428
  tmp___0 = kzalloc((unsigned long )xpc_nasid_mask_nlongs * 8UL, 208U);
#line 428
  discovered_nasids = (unsigned long *)tmp___0;
#line 430
  if ((unsigned long )discovered_nasids == (unsigned long )((unsigned long *)0UL)) {
#line 431
    kfree((void const   *)remote_rp_base);
#line 432
    return;
  } else {

  }
#line 435
  rp = xpc_rsvd_page;
#line 442
  region_size = (int )xp_region_size;
#line 444
  tmp___1 = is_uv_system();
#line 444
  if (tmp___1 != 0) {
#line 445
    max_regions = 256;
  } else {
#line 447
    max_regions = 64;
#line 449
    switch (region_size) {
    case 128: 
#line 451
    max_regions = max_regions * 2;
    case 64: 
#line 453
    max_regions = max_regions * 2;
    case 32: 
#line 455
    max_regions = max_regions * 2;
#line 456
    region_size = 16;
    }
  }
#line 461
  region = 0;
#line 461
  goto ldv_24832;
  ldv_24831: ;
#line 463
  if (xpc_exiting != 0) {
#line 464
    goto ldv_24819;
  } else {

  }
#line 466
  descriptor.modname = "xpc";
#line 466
  descriptor.function = "xpc_discovery";
#line 466
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c";
#line 466
  descriptor.format = "searching region %d\n";
#line 466
  descriptor.lineno = 466U;
#line 466
  descriptor.flags = 0U;
#line 466
  tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 466
  if (tmp___2 != 0L) {
#line 466
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_part, "searching region %d\n",
                      region);
  } else {

  }
#line 468
  nasid = (region * region_size) * 2;
#line 468
  goto ldv_24830;
  ldv_24829: ;
#line 471
  if (xpc_exiting != 0) {
#line 472
    goto ldv_24822;
  } else {

  }
#line 474
  descriptor___0.modname = "xpc";
#line 474
  descriptor___0.function = "xpc_discovery";
#line 474
  descriptor___0.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c";
#line 474
  descriptor___0.format = "checking nasid %d\n";
#line 474
  descriptor___0.lineno = 474U;
#line 474
  descriptor___0.flags = 0U;
#line 474
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 474
  if (tmp___3 != 0L) {
#line 474
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)xpc_part, "checking nasid %d\n",
                      nasid);
  } else {

  }
#line 476
  tmp___5 = variable_test_bit((long )(nasid / 2), (unsigned long const volatile   *)xpc_part_nasids);
#line 476
  if (tmp___5 != 0) {
#line 477
    descriptor___1.modname = "xpc";
#line 477
    descriptor___1.function = "xpc_discovery";
#line 477
    descriptor___1.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c";
#line 477
    descriptor___1.format = "PROM indicates Nasid %d is part of the local partition; skipping region\n";
#line 477
    descriptor___1.lineno = 479U;
#line 477
    descriptor___1.flags = 0U;
#line 477
    tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 477
    if (tmp___4 != 0L) {
#line 477
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)xpc_part, "PROM indicates Nasid %d is part of the local partition; skipping region\n",
                        nasid);
    } else {

    }
#line 480
    goto ldv_24822;
  } else {

  }
#line 483
  tmp___7 = variable_test_bit((long )(nasid / 2), (unsigned long const volatile   *)xpc_mach_nasids);
#line 483
  if (tmp___7 == 0) {
#line 484
    descriptor___2.modname = "xpc";
#line 484
    descriptor___2.function = "xpc_discovery";
#line 484
    descriptor___2.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c";
#line 484
    descriptor___2.format = "PROM indicates Nasid %d was not on Numa-Link network at reset\n";
#line 484
    descriptor___2.lineno = 486U;
#line 484
    descriptor___2.flags = 0U;
#line 484
    tmp___6 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 484
    if (tmp___6 != 0L) {
#line 484
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)xpc_part, "PROM indicates Nasid %d was not on Numa-Link network at reset\n",
                        nasid);
    } else {

    }
#line 487
    goto ldv_24826;
  } else {

  }
#line 490
  tmp___9 = variable_test_bit((long )(nasid / 2), (unsigned long const volatile   *)discovered_nasids);
#line 490
  if (tmp___9 != 0) {
#line 491
    descriptor___3.modname = "xpc";
#line 491
    descriptor___3.function = "xpc_discovery";
#line 491
    descriptor___3.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c";
#line 491
    descriptor___3.format = "Nasid %d is part of a partition which was previously discovered\n";
#line 491
    descriptor___3.lineno = 493U;
#line 491
    descriptor___3.flags = 0U;
#line 491
    tmp___8 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
#line 491
    if (tmp___8 != 0L) {
#line 491
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)xpc_part, "Nasid %d is part of a partition which was previously discovered\n",
                        nasid);
    } else {

    }
#line 494
    goto ldv_24826;
  } else {

  }
#line 499
  ret = xpc_get_remote_rp(nasid, discovered_nasids, remote_rp, & remote_rp_pa);
#line 501
  if ((unsigned int )ret != 0U) {
#line 502
    descriptor___4.modname = "xpc";
#line 502
    descriptor___4.function = "xpc_discovery";
#line 502
    descriptor___4.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c";
#line 502
    descriptor___4.format = "unable to get reserved page from nasid %d, reason=%d\n";
#line 502
    descriptor___4.lineno = 504U;
#line 502
    descriptor___4.flags = 0U;
#line 502
    tmp___10 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
#line 502
    if (tmp___10 != 0L) {
#line 502
      __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)xpc_part, "unable to get reserved page from nasid %d, reason=%d\n",
                        nasid, (unsigned int )ret);
    } else {

    }
#line 506
    if ((unsigned int )ret == 43U) {
#line 507
      goto ldv_24822;
    } else {

    }
#line 509
    goto ldv_24826;
  } else {

  }
#line 512
  (*(xpc_arch_ops.request_partition_activation))(remote_rp, remote_rp_pa, nasid);
  ldv_24826: 
#line 469
  nasid = nasid + 2;
  ldv_24830: ;
#line 468
  if (((region + 1) * 2) * region_size > nasid) {
#line 471
    goto ldv_24829;
  } else {

  }
  ldv_24822: 
#line 461
  region = region + 1;
  ldv_24832: ;
#line 461
  if (region < max_regions) {
#line 463
    goto ldv_24831;
  } else {

  }
  ldv_24819: 
#line 517
  kfree((void const   *)discovered_nasids);
#line 518
  kfree((void const   *)remote_rp_base);
#line 519
  return;
}
}
#line 526 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.c"
enum xp_retval xpc_initiate_partid_to_nasids(short partid , void *nasid_mask ) 
{ 
  struct xpc_partition *part ;
  unsigned long part_nasid_pa ;
  unsigned long tmp ;
  enum xp_retval tmp___0 ;

  {
#line 531
  part = xpc_partitions + (unsigned long )partid;
#line 532
  if (part->remote_rp_pa == 0UL) {
#line 533
    return (17);
  } else {

  }
#line 535
  memset(nasid_mask, 0, (size_t )xpc_nasid_mask_nbytes);
#line 537
  part_nasid_pa = part->remote_rp_pa + 128UL;
#line 539
  tmp = (*xp_pa)(nasid_mask);
#line 539
  tmp___0 = (*xp_remote_memcpy)(tmp, part_nasid_pa, (size_t )xpc_nasid_mask_nbytes);
#line 539
  return (tmp___0);
}
}
#line 201 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.o.c.prepared"
void *ldv_kmem_cache_alloc_66(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 204
  ldv_check_alloc_flags(flags);
#line 205
  tmp = ldv_undef_ptr();
#line 205
  return (tmp);
}
}
#line 222 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_partition.o.c.prepared"
int ldv_del_timer_sync_69(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 226
  tmp = del_timer_sync(ldv_func_arg1);
#line 226
  ldv_func_res = tmp;
#line 228
  disable_suitable_timer_1(ldv_func_arg1);
#line 230
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 479 "./arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x ) 
{ 
  int bitpos ;

  {
#line 481
  bitpos = -1;
#line 487
  __asm__  ("bsrq %1,%q0": "+r" (bitpos): "rm" (x));
#line 490
  return (bitpos + 1);
}
}
#line 14 "include/asm-generic/bitops/find.h"
extern unsigned long find_next_bit(unsigned long const   * , unsigned long  , unsigned long  ) ;
#line 42
extern unsigned long find_first_bit(unsigned long const   * , unsigned long  ) ;
#line 5 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.o.c.prepared"
void *ldv_err_ptr(long error ) ;
#line 6
long ldv_ptr_err(void const   *ptr ) ;
#line 554 "./arch/x86/include/asm/percpu.h"
extern unsigned long this_cpu_off ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 23 "./arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 13 "include/asm-generic/getorder.h"
__inline static int __get_order(unsigned long size ) 
{ 
  int order ;

  {
#line 17
  size = size - 1UL;
#line 18
  size = size >> 12;
#line 22
  order = fls64((__u64 )size);
#line 24
  return (order);
}
}
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 37 "include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 114 "include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 117
  __ret_warn_once = (unsigned int )nr_cpu_ids <= cpu;
#line 117
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 117
  if (tmp___1 != 0L) {
#line 117
    __ret_warn_on = ! __warned;
#line 117
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp != 0L) {
#line 117
      warn_slowpath_null("include/linux/cpumask.h", 117);
    } else {

    }
#line 117
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp___0 != 0L) {
#line 117
      __warned = 1;
    } else {

    }
  } else {

  }
#line 117
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 119
  return (cpu);
}
}
#line 184 "include/linux/cpumask.h"
__inline static unsigned int cpumask_next(int n , struct cpumask  const  *srcp ) 
{ 
  unsigned long tmp ;

  {
#line 187
  if (n != -1) {
#line 188
    cpumask_check((unsigned int )n);
  } else {

  }
#line 189
  tmp = find_next_bit((unsigned long const   *)(& srcp->bits), (unsigned long )nr_cpu_ids,
                      (unsigned long )(n + 1));
#line 189
  return ((unsigned int )tmp);
}
}
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 32
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) ;
#line 359
__inline static void spin_unlock(spinlock_t *lock ) ;
#line 386
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 251 "include/linux/nodemask.h"
__inline static int __first_node(nodemask_t const   *srcp ) 
{ 
  int __min1 ;
  int __min2 ;
  unsigned long tmp ;

  {
#line 253
  __min1 = 1024;
#line 253
  tmp = find_first_bit((unsigned long const   *)(& srcp->bits), 1024UL);
#line 253
  __min2 = (int )tmp;
#line 253
  return (__min1 < __min2 ? __min1 : __min2);
}
}
#line 257 "include/linux/nodemask.h"
__inline static int __next_node(int n , nodemask_t const   *srcp ) 
{ 
  int __min1 ;
  int __min2 ;
  unsigned long tmp ;

  {
#line 259
  __min1 = 1024;
#line 259
  tmp = find_next_bit((unsigned long const   *)(& srcp->bits), 1024UL, (unsigned long )(n + 1));
#line 259
  __min2 = (int )tmp;
#line 259
  return (__min1 < __min2 ? __min1 : __min2);
}
}
#line 395
extern nodemask_t node_states[5U] ;
#line 398 "include/linux/nodemask.h"
__inline static int node_state(int node , enum node_states state ) 
{ 
  int tmp ;

  {
#line 400
  tmp = variable_test_bit((long )node, (unsigned long const volatile   *)(& node_states[(unsigned int )state].bits));
#line 400
  return (tmp);
}
}
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 138
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 158 "include/linux/memory_hotplug.h"
extern pg_data_t *node_data[] ;
#line 57 "./arch/x86/include/asm/topology.h"
extern int __cpu_to_node(int  ) ;
#line 76
extern struct cpumask  const  *cpumask_of_node(int  ) ;
#line 90 "./arch/x86/include/asm/io.h"
__inline static unsigned long readq(void const volatile   *addr ) 
{ 
  unsigned long ret ;

  {
#line 90
  __asm__  volatile   ("movq %1,%0": "=r" (ret): "m" (*((unsigned long volatile   *)addr)): "memory");
#line 90
  return (ret);
}
}
#line 263 "include/linux/gfp.h"
__inline static int gfp_zonelist(gfp_t flags ) 
{ 
  long tmp ;

  {
#line 265
  tmp = ldv__builtin_expect((flags & 262144U) != 0U, 0L);
#line 265
  if (tmp != 0L) {
#line 266
    return (1);
  } else {

  }
#line 268
  return (0);
}
}
#line 280 "include/linux/gfp.h"
__inline static struct zonelist *node_zonelist(int nid , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 282
  tmp = gfp_zonelist(flags);
#line 282
  return ((struct zonelist *)(& (node_data[nid])->node_zonelists) + (unsigned long )tmp);
}
}
#line 293
extern struct page *__alloc_pages_nodemask(gfp_t  , unsigned int  , struct zonelist * ,
                                           nodemask_t * ) ;
#line 297 "include/linux/gfp.h"
__inline static struct page *__alloc_pages(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ) 
{ 
  struct page *tmp ;

  {
#line 300
  tmp = __alloc_pages_nodemask(gfp_mask, order, zonelist, (nodemask_t *)0);
#line 300
  return (tmp);
}
}
#line 313 "include/linux/gfp.h"
__inline static struct page *alloc_pages_exact_node(int nid , gfp_t gfp_mask , unsigned int order ) 
{ 
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  struct zonelist *tmp___2 ;
  struct page *tmp___3 ;

  {
#line 316
  if (nid < 0 || nid > 1023) {
#line 316
    tmp___0 = 1;
  } else {
#line 316
    tmp = node_state(nid, 1);
#line 316
    if (tmp == 0) {
#line 316
      tmp___0 = 1;
    } else {
#line 316
      tmp___0 = 0;
    }
  }
#line 316
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 316
  if (tmp___1 != 0L) {
#line 316
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/gfp.h"),
                         "i" (316), "i" (12UL));
    ldv_13766: ;
#line 316
    goto ldv_13766;
  } else {

  }
#line 318
  tmp___2 = node_zonelist(nid, gfp_mask);
#line 318
  tmp___3 = __alloc_pages(gfp_mask, order, tmp___2);
#line 318
  return (tmp___3);
}
}
#line 367
extern void free_pages(unsigned long  , unsigned int  ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_90(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 418
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 924 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 926
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 127 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 132 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 135
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 135
  return (tmp);
}
}
#line 146
extern void free_irq(unsigned int  , void * ) ;
#line 229 "include/linux/cpu.h"
extern void get_online_cpus(void) ;
#line 231
extern void put_online_cpus(void) ;
#line 166 "./arch/x86/include/asm/uv/uv_hub.h"
extern struct uv_hub_info_s __uv_hub_info ;
#line 311 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static unsigned long uv_soc_phys_ram_to_gpa(unsigned long paddr ) 
{ 
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;
  void const   *__vpp_verify___0 ;
  unsigned long tcp_ptr_____0 ;
  void const   *__vpp_verify___1 ;
  unsigned long tcp_ptr_____1 ;
  void const   *__vpp_verify___2 ;
  unsigned long tcp_ptr_____2 ;
  void const   *__vpp_verify___3 ;
  unsigned long tcp_ptr_____3 ;
  void const   *__vpp_verify___4 ;
  unsigned long tcp_ptr_____4 ;
  void const   *__vpp_verify___5 ;
  unsigned long tcp_ptr_____5 ;

  {
#line 313
  __vpp_verify___0 = (void const   *)0;
#line 313
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____0): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 313
  if (((struct uv_hub_info_s *)tcp_ptr_____0)->lowmem_remap_top > paddr) {
#line 314
    __vpp_verify = (void const   *)0;
#line 314
    __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off),
                         "0" (& __uv_hub_info));
#line 314
    paddr = ((struct uv_hub_info_s *)tcp_ptr__)->lowmem_remap_base | paddr;
  } else {

  }
#line 315
  __vpp_verify___1 = (void const   *)0;
#line 315
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____1): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 315
  paddr = ((struct uv_hub_info_s *)tcp_ptr_____1)->gnode_upper | paddr;
#line 316
  __vpp_verify___2 = (void const   *)0;
#line 316
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____2): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 316
  __vpp_verify___3 = (void const   *)0;
#line 316
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____3): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 317
  __vpp_verify___4 = (void const   *)0;
#line 317
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____4): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 317
  __vpp_verify___5 = (void const   *)0;
#line 317
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____5): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 317
  paddr = ((paddr << (int )((struct uv_hub_info_s *)tcp_ptr_____2)->m_shift) >> (int )((struct uv_hub_info_s *)tcp_ptr_____3)->m_shift) | ((paddr >> (int )((struct uv_hub_info_s *)tcp_ptr_____4)->m_val) << (int )((struct uv_hub_info_s *)tcp_ptr_____5)->n_lshift);
#line 318
  return (paddr);
}
}
#line 323 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static unsigned long uv_gpa(void *v ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 325
  tmp = __phys_addr((unsigned long )v);
#line 325
  tmp___0 = uv_soc_phys_ram_to_gpa(tmp);
#line 325
  return (tmp___0);
}
}
#line 421 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static void volatile   *uv_global_mmr64_address(int pnode , unsigned long offset ) 
{ 
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;

  {
#line 423
  __vpp_verify = (void const   *)0;
#line 423
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off), "0" (& __uv_hub_info));
#line 423
  return ((void volatile   *)(((((struct uv_hub_info_s *)tcp_ptr__)->global_mmr_base | ((unsigned long )pnode << 26)) | offset) + 0xffff880000000000UL));
}
}
#line 432 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static unsigned long uv_read_global_mmr64(int pnode , unsigned long offset ) 
{ 
  void volatile   *tmp ;
  unsigned long tmp___0 ;

  {
#line 434
  tmp = uv_global_mmr64_address(pnode, offset);
#line 434
  tmp___0 = readq((void const volatile   *)tmp);
#line 434
  return (tmp___0);
}
}
#line 498
extern struct uv_blade_info *uv_blade_info ;
#line 500
extern short *uv_cpu_to_blade ;
#line 516 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_cpu_to_blade_id(int cpu ) 
{ 


  {
#line 518
  return ((int )*(uv_cpu_to_blade + (unsigned long )cpu));
}
}
#line 528 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_blade_to_pnode(int bid ) 
{ 


  {
#line 530
  return ((int )(uv_blade_info + (unsigned long )bid)->pnode);
}
}
#line 552 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_cpu_to_pnode(int cpu ) 
{ 
  int tmp ;

  {
#line 554
  tmp = uv_cpu_to_blade_id(cpu);
#line 554
  return ((int )(uv_blade_info + (unsigned long )tmp)->pnode);
}
}
#line 95 "./arch/x86/include/asm/uv/bios.h"
extern int uv_bios_mq_watchlist_alloc(unsigned long  , unsigned int  , unsigned long * ) ;
#line 97
extern int uv_bios_mq_watchlist_free(int  , int  ) ;
#line 99
extern s64 uv_bios_reserved_page_pa(u64  , u64 * , u64 * , u64 * ) ;
#line 106
extern long sn_partition_id ;
#line 35 "./arch/x86/include/asm/uv/uv_irq.h"
extern int uv_setup_irq(char * , int  , int  , unsigned long  , int  ) ;
#line 36
extern void uv_teardown_irq(unsigned int  ) ;
#line 74 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/../sgi-gru/grukservices.h"
extern int gru_create_message_queue(struct gru_message_queue_desc * , void * , unsigned int  ,
                                    int  , int  , int  ) ;
#line 94
extern int gru_send_message_gpa(struct gru_message_queue_desc * , void * , unsigned int  ) ;
#line 114
extern void gru_free_message(struct gru_message_queue_desc * , void * ) ;
#line 130
extern void *gru_get_next_message(struct gru_message_queue_desc * ) ;
#line 345 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-xp/xp.h"
extern enum xp_retval (*xp_expand_memprotect)(unsigned long  , unsigned long  ) ;
#line 346
extern enum xp_retval (*xp_restrict_memprotect)(unsigned long  , unsigned long  ) ;
#line 52 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static struct xpc_heartbeat_uv *xpc_heartbeat_uv  ;
#line 64 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static int xpc_mq_node  =    -1;
#line 66 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static struct xpc_gru_mq_uv *xpc_activate_mq_uv  ;
#line 67 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static struct xpc_gru_mq_uv *xpc_notify_mq_uv  ;
#line 70 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static int xpc_setup_partitions_uv(void) 
{ 
  short partid ;
  struct xpc_partition_uv *part_uv ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 75
  partid = 0;
#line 75
  goto ldv_32506;
  ldv_32505: 
#line 76
  part_uv = & (xpc_partitions + (unsigned long )partid)->sn.uv;
#line 78
  __mutex_init(& part_uv->cached_activate_gru_mq_desc_mutex, "&part_uv->cached_activate_gru_mq_desc_mutex",
               & __key);
#line 79
  spinlock_check(& part_uv->flags_lock);
#line 79
  __raw_spin_lock_init(& part_uv->flags_lock.__annonCompField18.rlock, "&(&part_uv->flags_lock)->rlock",
                       & __key___0);
#line 80
  part_uv->remote_act_state = 0U;
#line 75
  partid = (short )((int )partid + 1);
  ldv_32506: ;
#line 75
  if ((int )partid <= 255) {
#line 77
    goto ldv_32505;
  } else {

  }

#line 82
  return (0);
}
}
#line 86 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_teardown_partitions_uv(void) 
{ 
  short partid ;
  struct xpc_partition_uv *part_uv ;
  unsigned long irq_flags ;

  {
#line 92
  partid = 0;
#line 92
  goto ldv_32515;
  ldv_32514: 
#line 93
  part_uv = & (xpc_partitions + (unsigned long )partid)->sn.uv;
#line 95
  if ((unsigned long )part_uv->cached_activate_gru_mq_desc != (unsigned long )((void *)0)) {
#line 96
    mutex_lock_nested(& part_uv->cached_activate_gru_mq_desc_mutex, 0U);
#line 97
    ldv_spin_lock();
#line 98
    part_uv->flags = part_uv->flags & 4294967294U;
#line 99
    spin_unlock_irqrestore(& part_uv->flags_lock, irq_flags);
#line 100
    kfree((void const   *)part_uv->cached_activate_gru_mq_desc);
#line 101
    part_uv->cached_activate_gru_mq_desc = (void *)0;
#line 102
    mutex_unlock(& part_uv->cached_activate_gru_mq_desc_mutex);
  } else {

  }
#line 92
  partid = (short )((int )partid + 1);
  ldv_32515: ;
#line 92
  if ((int )partid <= 255) {
#line 94
    goto ldv_32514;
  } else {

  }

#line 99
  return;
}
}
#line 109 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static int xpc_get_gru_mq_irq_uv(struct xpc_gru_mq_uv *mq , int cpu , char *irq_name ) 
{ 
  int mmr_pnode ;
  int tmp ;

  {
#line 111
  tmp = uv_blade_to_pnode(mq->mmr_blade);
#line 111
  mmr_pnode = tmp;
#line 114
  mq->irq = uv_setup_irq(irq_name, cpu, mq->mmr_blade, mq->mmr_offset, 2);
#line 116
  if (mq->irq < 0) {
#line 117
    return (mq->irq);
  } else {

  }
#line 119
  mq->mmr_value = uv_read_global_mmr64(mmr_pnode, mq->mmr_offset);
#line 135
  return (0);
}
}
#line 139 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_release_gru_mq_irq_uv(struct xpc_gru_mq_uv *mq ) 
{ 


  {
#line 142
  uv_teardown_irq((unsigned int )mq->irq);
#line 143
  return;
}
}
#line 158 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static int xpc_gru_mq_watchlist_alloc_uv(struct xpc_gru_mq_uv *mq ) 
{ 
  int ret ;
  unsigned long tmp ;

  {
#line 173
  tmp = uv_gpa(mq->address);
#line 173
  ret = uv_bios_mq_watchlist_alloc(tmp, mq->order, & mq->mmr_offset);
#line 175
  if (ret < 0) {
#line 176
    dev_err((struct device  const  *)xpc_part, "uv_bios_mq_watchlist_alloc() failed, ret=%d\n",
            ret);
#line 178
    return (ret);
  } else {

  }
#line 184
  mq->watchlist_num = ret;
#line 185
  return (0);
}
}
#line 189 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_gru_mq_watchlist_free_uv(struct xpc_gru_mq_uv *mq ) 
{ 
  int ret ;
  int mmr_pnode ;
  int tmp ;
  long tmp___0 ;

  {
#line 192
  tmp = uv_blade_to_pnode(mq->mmr_blade);
#line 192
  mmr_pnode = tmp;
#line 195
  ret = uv_bios_mq_watchlist_free(mmr_pnode, mq->watchlist_num);
#line 196
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 196
  if (tmp___0 != 0L) {
#line 196
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"),
                         "i" (196), "i" (12UL));
    ldv_32535: ;
#line 196
    goto ldv_32535;
  } else {

  }
#line 198
  return;
}
}
#line 206 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static struct xpc_gru_mq_uv *xpc_create_gru_mq_uv(unsigned int mq_size , int cpu ,
                                                  char *irq_name , irqreturn_t (*irq_handler)(int  ,
                                                                                              void * ) ) 
{ 
  enum xp_retval xp_ret ;
  int ret ;
  int nid ;
  int nasid ;
  int pg_order ;
  struct page *page ;
  struct xpc_gru_mq_uv *mq ;
  struct uv_IO_APIC_route_entry *mmr_value ;
  void *tmp ;
  int tmp___0 ;
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;
  unsigned long tmp___1 ;
  void *tmp___2 ;

  {
#line 218
  tmp = kzalloc(56UL, 208U);
#line 218
  mq = (struct xpc_gru_mq_uv *)tmp;
#line 219
  if ((unsigned long )mq == (unsigned long )((struct xpc_gru_mq_uv *)0)) {
#line 220
    dev_err((struct device  const  *)xpc_part, "xpc_create_gru_mq_uv() failed to kmalloc() a xpc_gru_mq_uv structure\n");
#line 222
    ret = -12;
#line 223
    goto out_0;
  } else {

  }
#line 226
  mq->gru_mq_desc = kzalloc(32UL, 208U);
#line 228
  if ((unsigned long )mq->gru_mq_desc == (unsigned long )((void *)0)) {
#line 229
    dev_err((struct device  const  *)xpc_part, "xpc_create_gru_mq_uv() failed to kmalloc() a gru_message_queue_desc structure\n");
#line 231
    ret = -12;
#line 232
    goto out_1;
  } else {

  }
#line 235
  pg_order = __get_order((unsigned long )mq_size);
#line 236
  mq->order = (unsigned int )(pg_order + 12);
#line 237
  mq_size = (unsigned int )(1UL << (int )mq->order);
#line 239
  mq->mmr_blade = uv_cpu_to_blade_id(cpu);
#line 241
  nid = __cpu_to_node(cpu);
#line 242
  page = alloc_pages_exact_node(nid, 295120U, (unsigned int )pg_order);
#line 245
  if ((unsigned long )page == (unsigned long )((struct page *)0)) {
#line 246
    dev_err((struct device  const  *)xpc_part, "xpc_create_gru_mq_uv() failed to alloc %d bytes of memory on nid=%d for GRU mq\n",
            mq_size, nid);
#line 248
    ret = -12;
#line 249
    goto out_2;
  } else {

  }
#line 251
  mq->address = lowmem_page_address((struct page  const  *)page);
#line 254
  ret = xpc_gru_mq_watchlist_alloc_uv(mq);
#line 255
  if (ret != 0) {
#line 256
    goto out_3;
  } else {

  }
#line 258
  ret = xpc_get_gru_mq_irq_uv(mq, cpu, irq_name);
#line 259
  if (ret != 0) {
#line 260
    goto out_4;
  } else {

  }
#line 262
  ret = request_irq((unsigned int )mq->irq, irq_handler, 0UL, (char const   *)irq_name,
                    (void *)0);
#line 263
  if (ret != 0) {
#line 264
    dev_err((struct device  const  *)xpc_part, "request_irq(irq=%d) returned error=%d\n",
            mq->irq, - ret);
#line 266
    goto out_5;
  } else {

  }
#line 269
  tmp___0 = uv_cpu_to_pnode(cpu);
#line 269
  __vpp_verify = (void const   *)0;
#line 269
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off), "0" (& __uv_hub_info));
#line 269
  nasid = (int )(((unsigned int )tmp___0 | ((struct uv_hub_info_s *)tcp_ptr__)->gnode_extra) << 1);
#line 271
  mmr_value = (struct uv_IO_APIC_route_entry *)(& mq->mmr_value);
#line 272
  ret = gru_create_message_queue((struct gru_message_queue_desc *)mq->gru_mq_desc,
                                 mq->address, mq_size, nasid, (int )mmr_value->vector,
                                 (int )mmr_value->dest);
#line 274
  if (ret != 0) {
#line 275
    dev_err((struct device  const  *)xpc_part, "gru_create_message_queue() returned error=%d\n",
            ret);
#line 277
    ret = -22;
#line 278
    goto out_6;
  } else {

  }
#line 282
  tmp___1 = (*xp_pa)(mq->address);
#line 282
  xp_ret = (*xp_expand_memprotect)(tmp___1, (unsigned long )mq_size);
#line 283
  if ((unsigned int )xp_ret != 0U) {
#line 284
    ret = -13;
#line 285
    goto out_6;
  } else {

  }
#line 288
  return (mq);
  out_6: 
#line 292
  free_irq((unsigned int )mq->irq, (void *)0);
  out_5: 
#line 294
  xpc_release_gru_mq_irq_uv(mq);
  out_4: 
#line 296
  xpc_gru_mq_watchlist_free_uv(mq);
  out_3: 
#line 298
  free_pages((unsigned long )mq->address, (unsigned int )pg_order);
  out_2: 
#line 300
  kfree((void const   *)mq->gru_mq_desc);
  out_1: 
#line 302
  kfree((void const   *)mq);
  out_0: 
#line 304
  tmp___2 = ERR_PTR((long )ret);
#line 304
  return ((struct xpc_gru_mq_uv *)tmp___2);
}
}
#line 308 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_destroy_gru_mq_uv(struct xpc_gru_mq_uv *mq ) 
{ 
  unsigned int mq_size ;
  int pg_order ;
  int ret ;
  unsigned long tmp ;
  enum xp_retval tmp___0 ;
  long tmp___1 ;

  {
#line 315
  mq_size = (unsigned int )(1UL << (int )mq->order);
#line 316
  tmp = (*xp_pa)(mq->address);
#line 316
  tmp___0 = (*xp_restrict_memprotect)(tmp, (unsigned long )mq_size);
#line 316
  ret = (int )tmp___0;
#line 317
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 317
  if (tmp___1 != 0L) {
#line 317
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"),
                         "i" (317), "i" (12UL));
    ldv_32567: ;
#line 317
    goto ldv_32567;
  } else {

  }
#line 320
  free_irq((unsigned int )mq->irq, (void *)0);
#line 321
  xpc_release_gru_mq_irq_uv(mq);
#line 324
  xpc_gru_mq_watchlist_free_uv(mq);
#line 326
  pg_order = (int )(mq->order - 12U);
#line 327
  free_pages((unsigned long )mq->address, (unsigned int )pg_order);
#line 329
  kfree((void const   *)mq);
#line 330
  return;
}
}
#line 333 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static enum xp_retval xpc_send_gru_msg(struct gru_message_queue_desc *gru_mq_desc ,
                                       void *msg , size_t msg_size ) 
{ 
  enum xp_retval xp_ret ;
  int ret ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
  ldv_32579: 
#line 340
  ret = gru_send_message_gpa(gru_mq_desc, msg, (unsigned int )msg_size);
#line 341
  if (ret == 0) {
#line 342
    xp_ret = 0;
#line 343
    goto ldv_32575;
  } else {

  }
#line 346
  if (ret == 2) {
#line 347
    descriptor.modname = "xpc";
#line 347
    descriptor.function = "xpc_send_gru_msg";
#line 347
    descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c";
#line 347
    descriptor.format = "gru_send_message_gpa() returned error=MQE_QUEUE_FULL\n";
#line 347
    descriptor.lineno = 348U;
#line 347
    descriptor.flags = 0U;
#line 347
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 347
    if (tmp != 0L) {
#line 347
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_chan, "gru_send_message_gpa() returned error=MQE_QUEUE_FULL\n");
    } else {

    }
#line 351
    msleep_interruptible(10U);
  } else
#line 352
  if (ret == 1) {
#line 353
    descriptor___0.modname = "xpc";
#line 353
    descriptor___0.function = "xpc_send_gru_msg";
#line 353
    descriptor___0.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c";
#line 353
    descriptor___0.format = "gru_send_message_gpa() returned error=MQE_CONGESTION\n";
#line 353
    descriptor___0.lineno = 354U;
#line 353
    descriptor___0.flags = 0U;
#line 353
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 353
    if (tmp___0 != 0L) {
#line 353
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)xpc_chan, "gru_send_message_gpa() returned error=MQE_CONGESTION\n");
    } else {

    }
  } else {
#line 359
    dev_err((struct device  const  *)xpc_chan, "gru_send_message_gpa() returned error=%d\n",
            ret);
#line 361
    xp_ret = 59;
#line 362
    goto ldv_32575;
  }
#line 364
  goto ldv_32579;
  ldv_32575: ;
#line 365
  return (xp_ret);
}
}
#line 369 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_process_activate_IRQ_rcvd_uv(void) 
{ 
  unsigned long irq_flags ;
  short partid ;
  struct xpc_partition *part ;
  u8 act_state_req ;
  long tmp ;

  {
#line 378
  ldv_spin_lock();
#line 379
  partid = 0;
#line 379
  goto ldv_32592;
  ldv_32591: 
#line 380
  part = xpc_partitions + (unsigned long )partid;
#line 382
  if ((unsigned int )part->sn.uv.act_state_req == 0U) {
#line 383
    goto ldv_32587;
  } else {

  }
#line 385
  xpc_activate_IRQ_rcvd = xpc_activate_IRQ_rcvd - 1;
#line 386
  tmp = ldv__builtin_expect(xpc_activate_IRQ_rcvd < 0, 0L);
#line 386
  if (tmp != 0L) {
#line 386
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"),
                         "i" (386), "i" (12UL));
    ldv_32588: ;
#line 386
    goto ldv_32588;
  } else {

  }
#line 388
  act_state_req = part->sn.uv.act_state_req;
#line 389
  part->sn.uv.act_state_req = 0U;
#line 390
  spin_unlock_irqrestore(& xpc_activate_IRQ_rcvd_lock, irq_flags);
#line 392
  if ((unsigned int )act_state_req == 1U) {
#line 393
    if ((unsigned int )part->act_state == 0U) {
#line 394
      xpc_activate_partition(part);
    } else
#line 395
    if ((unsigned int )part->act_state == 4U) {
#line 396
      xpc_deactivate_partition(396, part, 21);
    } else {

    }
  } else
#line 398
  if ((unsigned int )act_state_req == 2U) {
#line 399
    if ((unsigned int )part->act_state == 0U) {
#line 400
      xpc_activate_partition(part);
    } else {
#line 402
      xpc_deactivate_partition(402, part, 21);
    }
  } else
#line 404
  if ((unsigned int )act_state_req == 3U) {
#line 405
    xpc_deactivate_partition(405, part, part->sn.uv.reason);
  } else {
#line 408
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"),
                         "i" (408), "i" (12UL));
    ldv_32589: ;
#line 408
    goto ldv_32589;
  }
#line 411
  ldv_spin_lock();
#line 412
  if (xpc_activate_IRQ_rcvd == 0) {
#line 413
    goto ldv_32590;
  } else {

  }
  ldv_32587: 
#line 379
  partid = (short )((int )partid + 1);
  ldv_32592: ;
#line 379
  if ((int )partid <= 255) {
#line 381
    goto ldv_32591;
  } else {

  }
  ldv_32590: 
#line 415
  spin_unlock_irqrestore(& xpc_activate_IRQ_rcvd_lock, irq_flags);
#line 416
  return;
}
}
#line 420 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_handle_activate_mq_msg_uv(struct xpc_partition *part , struct xpc_activate_mq_msghdr_uv *msg_hdr ,
                                          int part_setup , int *wakeup_hb_checker ) 
{ 
  unsigned long irq_flags ;
  struct xpc_partition_uv *part_uv ;
  struct xpc_openclose_args *args ;
  struct xpc_activate_mq_msg_activate_req_uv *msg ;
  struct xpc_activate_mq_msghdr_uv  const  *__mptr ;
  struct xpc_activate_mq_msg_deactivate_req_uv *msg___0 ;
  struct xpc_activate_mq_msghdr_uv  const  *__mptr___0 ;
  struct xpc_activate_mq_msg_chctl_closerequest_uv *msg___1 ;
  struct xpc_activate_mq_msghdr_uv  const  *__mptr___1 ;
  struct xpc_activate_mq_msg_chctl_closereply_uv *msg___2 ;
  struct xpc_activate_mq_msghdr_uv  const  *__mptr___2 ;
  struct xpc_activate_mq_msg_chctl_openrequest_uv *msg___3 ;
  struct xpc_activate_mq_msghdr_uv  const  *__mptr___3 ;
  struct xpc_activate_mq_msg_chctl_openreply_uv *msg___4 ;
  struct xpc_activate_mq_msghdr_uv  const  *__mptr___4 ;
  struct xpc_activate_mq_msg_chctl_opencomplete_uv *msg___5 ;
  struct xpc_activate_mq_msghdr_uv  const  *__mptr___5 ;

  {
#line 426
  part_uv = & part->sn.uv;
#line 429
  part_uv->remote_act_state = msg_hdr->act_state;
#line 431
  switch ((int )msg_hdr->type) {
  case 0: ;
#line 434
  goto ldv_32603;
  case 1: 
#line 444
  __mptr = (struct xpc_activate_mq_msghdr_uv  const  *)msg_hdr;
#line 444
  msg = (struct xpc_activate_mq_msg_activate_req_uv *)__mptr;
#line 447
  ldv_spin_lock();
#line 448
  if ((unsigned int )part_uv->act_state_req == 0U) {
#line 449
    xpc_activate_IRQ_rcvd = xpc_activate_IRQ_rcvd + 1;
  } else {

  }
#line 450
  part_uv->act_state_req = 1U;
#line 451
  part->remote_rp_pa = msg->rp_gpa;
#line 452
  part->remote_rp_ts_jiffies = msg_hdr->rp_ts_jiffies;
#line 453
  part_uv->heartbeat_gpa = msg->heartbeat_gpa;
#line 455
  if (msg->activate_gru_mq_desc_gpa != part_uv->activate_gru_mq_desc_gpa) {
#line 457
    spin_lock(& part_uv->flags_lock);
#line 458
    part_uv->flags = part_uv->flags & 4294967294U;
#line 459
    spin_unlock(& part_uv->flags_lock);
#line 460
    part_uv->activate_gru_mq_desc_gpa = msg->activate_gru_mq_desc_gpa;
  } else {

  }
#line 463
  spin_unlock_irqrestore(& xpc_activate_IRQ_rcvd_lock, irq_flags);
#line 465
  *wakeup_hb_checker = *wakeup_hb_checker + 1;
#line 466
  goto ldv_32603;
  case 2: 
#line 471
  __mptr___0 = (struct xpc_activate_mq_msghdr_uv  const  *)msg_hdr;
#line 471
  msg___0 = (struct xpc_activate_mq_msg_deactivate_req_uv *)__mptr___0;
#line 474
  ldv_spin_lock();
#line 475
  if ((unsigned int )part_uv->act_state_req == 0U) {
#line 476
    xpc_activate_IRQ_rcvd = xpc_activate_IRQ_rcvd + 1;
  } else {

  }
#line 477
  part_uv->act_state_req = 3U;
#line 478
  part_uv->reason = msg___0->reason;
#line 479
  spin_unlock_irqrestore(& xpc_activate_IRQ_rcvd_lock, irq_flags);
#line 481
  *wakeup_hb_checker = *wakeup_hb_checker + 1;
#line 482
  return;
  case 3: ;
#line 487
  if (part_setup == 0) {
#line 488
    goto ldv_32603;
  } else {

  }
#line 490
  __mptr___1 = (struct xpc_activate_mq_msghdr_uv  const  *)msg_hdr;
#line 490
  msg___1 = (struct xpc_activate_mq_msg_chctl_closerequest_uv *)__mptr___1;
#line 493
  args = part->remote_openclose_args + (unsigned long )msg___1->ch_number;
#line 494
  args->reason = (u16 )msg___1->reason;
#line 496
  ldv_spin_lock();
#line 497
  part->chctl.flags[(int )msg___1->ch_number] = (u8 )((unsigned int )part->chctl.flags[(int )msg___1->ch_number] | 1U);
#line 498
  spin_unlock_irqrestore(& part->chctl_lock, irq_flags);
#line 500
  xpc_wakeup_channel_mgr(part);
#line 501
  goto ldv_32603;
  case 4: ;
#line 506
  if (part_setup == 0) {
#line 507
    goto ldv_32603;
  } else {

  }
#line 509
  __mptr___2 = (struct xpc_activate_mq_msghdr_uv  const  *)msg_hdr;
#line 509
  msg___2 = (struct xpc_activate_mq_msg_chctl_closereply_uv *)__mptr___2;
#line 513
  ldv_spin_lock();
#line 514
  part->chctl.flags[(int )msg___2->ch_number] = (u8 )((unsigned int )part->chctl.flags[(int )msg___2->ch_number] | 2U);
#line 515
  spin_unlock_irqrestore(& part->chctl_lock, irq_flags);
#line 517
  xpc_wakeup_channel_mgr(part);
#line 518
  goto ldv_32603;
  case 5: ;
#line 523
  if (part_setup == 0) {
#line 524
    goto ldv_32603;
  } else {

  }
#line 526
  __mptr___3 = (struct xpc_activate_mq_msghdr_uv  const  *)msg_hdr;
#line 526
  msg___3 = (struct xpc_activate_mq_msg_chctl_openrequest_uv *)__mptr___3;
#line 529
  args = part->remote_openclose_args + (unsigned long )msg___3->ch_number;
#line 530
  args->entry_size = (u16 )msg___3->entry_size;
#line 531
  args->local_nentries = (u16 )msg___3->local_nentries;
#line 533
  ldv_spin_lock();
#line 534
  part->chctl.flags[(int )msg___3->ch_number] = (u8 )((unsigned int )part->chctl.flags[(int )msg___3->ch_number] | 4U);
#line 535
  spin_unlock_irqrestore(& part->chctl_lock, irq_flags);
#line 537
  xpc_wakeup_channel_mgr(part);
#line 538
  goto ldv_32603;
  case 6: ;
#line 543
  if (part_setup == 0) {
#line 544
    goto ldv_32603;
  } else {

  }
#line 546
  __mptr___4 = (struct xpc_activate_mq_msghdr_uv  const  *)msg_hdr;
#line 546
  msg___4 = (struct xpc_activate_mq_msg_chctl_openreply_uv *)__mptr___4;
#line 548
  args = part->remote_openclose_args + (unsigned long )msg___4->ch_number;
#line 549
  args->remote_nentries = (u16 )msg___4->remote_nentries;
#line 550
  args->local_nentries = (u16 )msg___4->local_nentries;
#line 551
  args->local_msgqueue_pa = msg___4->notify_gru_mq_desc_gpa;
#line 553
  ldv_spin_lock();
#line 554
  part->chctl.flags[(int )msg___4->ch_number] = (u8 )((unsigned int )part->chctl.flags[(int )msg___4->ch_number] | 8U);
#line 555
  spin_unlock_irqrestore(& part->chctl_lock, irq_flags);
#line 557
  xpc_wakeup_channel_mgr(part);
#line 558
  goto ldv_32603;
  case 7: ;
#line 563
  if (part_setup == 0) {
#line 564
    goto ldv_32603;
  } else {

  }
#line 566
  __mptr___5 = (struct xpc_activate_mq_msghdr_uv  const  *)msg_hdr;
#line 566
  msg___5 = (struct xpc_activate_mq_msg_chctl_opencomplete_uv *)__mptr___5;
#line 568
  ldv_spin_lock();
#line 569
  part->chctl.flags[(int )msg___5->ch_number] = (u8 )((unsigned int )part->chctl.flags[(int )msg___5->ch_number] | 16U);
#line 570
  spin_unlock_irqrestore(& part->chctl_lock, irq_flags);
#line 572
  xpc_wakeup_channel_mgr(part);
  case 8: 
#line 575
  ldv_spin_lock();
#line 576
  part_uv->flags = part_uv->flags | 2U;
#line 577
  spin_unlock_irqrestore(& part_uv->flags_lock, irq_flags);
#line 578
  goto ldv_32603;
  case 9: 
#line 581
  ldv_spin_lock();
#line 582
  part_uv->flags = part_uv->flags & 4294967293U;
#line 583
  spin_unlock_irqrestore(& part_uv->flags_lock, irq_flags);
#line 584
  goto ldv_32603;
  default: 
#line 587
  dev_err((struct device  const  *)xpc_part, "received unknown activate_mq msg type=%d from partition=%d\n",
          (int )msg_hdr->type, (int )((short )(((long )part - (long )xpc_partitions) / 896L)));
#line 591
  ldv_spin_lock();
#line 592
  if ((unsigned int )part_uv->act_state_req == 0U) {
#line 593
    xpc_activate_IRQ_rcvd = xpc_activate_IRQ_rcvd + 1;
  } else {

  }
#line 594
  part_uv->act_state_req = 3U;
#line 595
  part_uv->reason = 61;
#line 596
  spin_unlock_irqrestore(& xpc_activate_IRQ_rcvd_lock, irq_flags);
#line 598
  *wakeup_hb_checker = *wakeup_hb_checker + 1;
#line 599
  return;
  }
  ldv_32603: ;
#line 602
  if (msg_hdr->rp_ts_jiffies != part->remote_rp_ts_jiffies && part->remote_rp_ts_jiffies != 0UL) {
#line 608
    ldv_spin_lock();
#line 609
    if ((unsigned int )part_uv->act_state_req == 0U) {
#line 610
      xpc_activate_IRQ_rcvd = xpc_activate_IRQ_rcvd + 1;
    } else {

    }
#line 611
    part_uv->act_state_req = 2U;
#line 612
    spin_unlock_irqrestore(& xpc_activate_IRQ_rcvd_lock, irq_flags);
#line 614
    *wakeup_hb_checker = *wakeup_hb_checker + 1;
  } else {

  }
#line 616
  return;
}
}
#line 619 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static irqreturn_t xpc_handle_activate_IRQ_uv(int irq , void *dev_id ) 
{ 
  struct xpc_activate_mq_msghdr_uv *msg_hdr ;
  short partid ;
  struct xpc_partition *part ;
  int wakeup_hb_checker ;
  int part_referenced ;
  void *tmp ;

  {
#line 624
  wakeup_hb_checker = 0;
  ldv_32645: 
#line 628
  tmp = gru_get_next_message((struct gru_message_queue_desc *)xpc_activate_mq_uv->gru_mq_desc);
#line 628
  msg_hdr = (struct xpc_activate_mq_msghdr_uv *)tmp;
#line 629
  if ((unsigned long )msg_hdr == (unsigned long )((struct xpc_activate_mq_msghdr_uv *)0)) {
#line 630
    goto ldv_32644;
  } else {

  }
#line 632
  partid = msg_hdr->partid;
#line 633
  if ((int )partid < 0 || (int )partid > 255) {
#line 634
    dev_err((struct device  const  *)xpc_part, "xpc_handle_activate_IRQ_uv() received invalid partid=0x%x in message\n",
            (int )partid);
  } else {
#line 638
    part = xpc_partitions + (unsigned long )partid;
#line 640
    part_referenced = xpc_part_ref(part);
#line 641
    xpc_handle_activate_mq_msg_uv(part, msg_hdr, part_referenced, & wakeup_hb_checker);
#line 644
    if (part_referenced != 0) {
#line 645
      xpc_part_deref(part);
    } else {

    }
  }
#line 648
  gru_free_message((struct gru_message_queue_desc *)xpc_activate_mq_uv->gru_mq_desc,
                   (void *)msg_hdr);
#line 649
  goto ldv_32645;
  ldv_32644: ;
#line 651
  if (wakeup_hb_checker != 0) {
#line 652
    __wake_up(& xpc_activate_IRQ_wq, 1U, 1, (void *)0);
  } else {

  }
#line 654
  return (1);
}
}
#line 658 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static enum xp_retval xpc_cache_remote_gru_mq_desc_uv(struct gru_message_queue_desc *gru_mq_desc ,
                                                      unsigned long gru_mq_desc_gpa ) 
{ 
  enum xp_retval ret ;
  unsigned long tmp ;

  {
#line 663
  tmp = uv_gpa((void *)gru_mq_desc);
#line 663
  ret = (*xp_remote_memcpy)(tmp, gru_mq_desc_gpa, 32UL);
#line 665
  if ((unsigned int )ret == 0U) {
#line 666
    gru_mq_desc->mq = (void *)0;
  } else {

  }
#line 668
  return (ret);
}
}
#line 672 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static enum xp_retval xpc_send_activate_IRQ_uv(struct xpc_partition *part , void *msg ,
                                               size_t msg_size , int msg_type ) 
{ 
  struct xpc_activate_mq_msghdr_uv *msg_hdr ;
  struct xpc_partition_uv *part_uv ;
  struct gru_message_queue_desc *gru_mq_desc ;
  unsigned long irq_flags ;
  enum xp_retval ret ;
  void *tmp ;

  {
#line 675
  msg_hdr = (struct xpc_activate_mq_msghdr_uv *)msg;
#line 676
  part_uv = & part->sn.uv;
#line 683
  msg_hdr->type = (u8 )msg_type;
#line 684
  msg_hdr->partid = xp_partition_id;
#line 685
  msg_hdr->act_state = part->act_state;
#line 686
  msg_hdr->rp_ts_jiffies = xpc_rsvd_page->ts_jiffies;
#line 688
  mutex_lock_nested(& part_uv->cached_activate_gru_mq_desc_mutex, 0U);
  again: ;
#line 690
  if ((part_uv->flags & 1U) == 0U) {
#line 691
    gru_mq_desc = (struct gru_message_queue_desc *)part_uv->cached_activate_gru_mq_desc;
#line 692
    if ((unsigned long )gru_mq_desc == (unsigned long )((struct gru_message_queue_desc *)0)) {
#line 693
      tmp = kzalloc(32UL, 208U);
#line 693
      gru_mq_desc = (struct gru_message_queue_desc *)tmp;
#line 696
      if ((unsigned long )gru_mq_desc == (unsigned long )((struct gru_message_queue_desc *)0)) {
#line 697
        ret = 13;
#line 698
        goto done;
      } else {

      }
#line 700
      part_uv->cached_activate_gru_mq_desc = (void *)gru_mq_desc;
    } else {

    }
#line 703
    ret = xpc_cache_remote_gru_mq_desc_uv(gru_mq_desc, part_uv->activate_gru_mq_desc_gpa);
#line 706
    if ((unsigned int )ret != 0U) {
#line 707
      goto done;
    } else {

    }
#line 709
    ldv_spin_lock();
#line 710
    part_uv->flags = part_uv->flags | 1U;
#line 711
    spin_unlock_irqrestore(& part_uv->flags_lock, irq_flags);
  } else {

  }
#line 715
  ret = xpc_send_gru_msg((struct gru_message_queue_desc *)part_uv->cached_activate_gru_mq_desc,
                         msg, msg_size);
#line 717
  if ((unsigned int )ret != 0U) {
#line 718
    __asm__  volatile   ("": : : "memory");
#line 719
    if ((part_uv->flags & 1U) == 0U) {
#line 720
      goto again;
    } else {

    }
  } else {

  }
  done: 
#line 723
  mutex_unlock(& part_uv->cached_activate_gru_mq_desc_mutex);
#line 724
  return (ret);
}
}
#line 728 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_send_activate_IRQ_part_uv(struct xpc_partition *part , void *msg ,
                                          size_t msg_size , int msg_type ) 
{ 
  enum xp_retval ret ;
  long tmp ;

  {
#line 733
  ret = xpc_send_activate_IRQ_uv(part, msg, msg_size, msg_type);
#line 734
  tmp = ldv__builtin_expect((unsigned int )ret != 0U, 0L);
#line 734
  if (tmp != 0L) {
#line 735
    xpc_deactivate_partition(735, part, ret);
  } else {

  }
#line 736
  return;
}
}
#line 739 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_send_activate_IRQ_ch_uv(struct xpc_channel *ch , unsigned long *irq_flags ,
                                        void *msg , size_t msg_size , int msg_type ) 
{ 
  struct xpc_partition *part ;
  enum xp_retval ret ;
  long tmp ;

  {
#line 742
  part = xpc_partitions + (unsigned long )ch->partid;
#line 745
  ret = xpc_send_activate_IRQ_uv(part, msg, msg_size, msg_type);
#line 746
  tmp = ldv__builtin_expect((unsigned int )ret != 0U, 0L);
#line 746
  if (tmp != 0L) {
#line 747
    if ((unsigned long )irq_flags != (unsigned long )((unsigned long *)0UL)) {
#line 748
      spin_unlock_irqrestore(& ch->lock, *irq_flags);
    } else {

    }
#line 750
    xpc_deactivate_partition(750, part, ret);
#line 752
    if ((unsigned long )irq_flags != (unsigned long )((unsigned long *)0UL)) {
#line 753
      ldv_spin_lock();
    } else {

    }
  } else {

  }
#line 755
  return;
}
}
#line 758 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_send_local_activate_IRQ_uv(struct xpc_partition *part , int act_state_req ) 
{ 
  unsigned long irq_flags ;
  struct xpc_partition_uv *part_uv ;

  {
#line 761
  part_uv = & part->sn.uv;
#line 769
  ldv_spin_lock();
#line 770
  if ((unsigned int )part_uv->act_state_req == 0U) {
#line 771
    xpc_activate_IRQ_rcvd = xpc_activate_IRQ_rcvd + 1;
  } else {

  }
#line 772
  part_uv->act_state_req = (u8 )act_state_req;
#line 773
  spin_unlock_irqrestore(& xpc_activate_IRQ_rcvd_lock, irq_flags);
#line 775
  __wake_up(& xpc_activate_IRQ_wq, 1U, 1, (void *)0);
#line 776
  return;
}
}
#line 779 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static enum xp_retval xpc_get_partition_rsvd_page_pa_uv(void *buf , u64 *cookie ,
                                                        unsigned long *rp_pa , size_t *len ) 
{ 
  s64 status ;
  enum xp_retval ret ;

  {
#line 786
  status = uv_bios_reserved_page_pa((unsigned long long )buf, cookie, (u64 *)rp_pa,
                                    (u64 *)len);
#line 788
  if (status == 0LL) {
#line 789
    ret = 0;
  } else
#line 790
  if (status == 1LL) {
#line 791
    ret = 57;
  } else {
#line 793
    ret = 62;
  }
#line 808
  return (ret);
}
}
#line 812 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static int xpc_setup_rsvd_page_uv(struct xpc_rsvd_page *rp ) 
{ 


  {
#line 814
  xpc_heartbeat_uv = & (xpc_partitions + (unsigned long )sn_partition_id)->sn.uv.cached_heartbeat;
#line 816
  rp->sn.uv.heartbeat_gpa = uv_gpa((void *)xpc_heartbeat_uv);
#line 817
  rp->sn.uv.activate_gru_mq_desc_gpa = uv_gpa(xpc_activate_mq_uv->gru_mq_desc);
#line 819
  return (0);
}
}
#line 823 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_allow_hb_uv(short partid ) 
{ 


  {
#line 825
  return;
}
}
#line 828 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_disallow_hb_uv(short partid ) 
{ 


  {
#line 830
  return;
}
}
#line 833 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_disallow_all_hbs_uv(void) 
{ 


  {
#line 835
  return;
}
}
#line 838 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_increment_heartbeat_uv(void) 
{ 


  {
#line 840
  xpc_heartbeat_uv->value = xpc_heartbeat_uv->value + 1UL;
#line 841
  return;
}
}
#line 844 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_offline_heartbeat_uv(void) 
{ 


  {
#line 846
  xpc_increment_heartbeat_uv();
#line 847
  xpc_heartbeat_uv->offline = 1UL;
#line 848
  return;
}
}
#line 851 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_online_heartbeat_uv(void) 
{ 


  {
#line 853
  xpc_increment_heartbeat_uv();
#line 854
  xpc_heartbeat_uv->offline = 0UL;
#line 855
  return;
}
}
#line 858 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_heartbeat_init_uv(void) 
{ 


  {
#line 860
  xpc_heartbeat_uv->value = 1UL;
#line 861
  xpc_heartbeat_uv->offline = 0UL;
#line 862
  return;
}
}
#line 865 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_heartbeat_exit_uv(void) 
{ 


  {
#line 867
  xpc_offline_heartbeat_uv();
#line 868
  return;
}
}
#line 871 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static enum xp_retval xpc_get_remote_heartbeat_uv(struct xpc_partition *part ) 
{ 
  struct xpc_partition_uv *part_uv ;
  enum xp_retval ret ;
  unsigned long tmp ;

  {
#line 873
  part_uv = & part->sn.uv;
#line 876
  tmp = uv_gpa((void *)(& part_uv->cached_heartbeat));
#line 876
  ret = (*xp_remote_memcpy)(tmp, part_uv->heartbeat_gpa, 16UL);
#line 879
  if ((unsigned int )ret != 0U) {
#line 880
    return (ret);
  } else {

  }
#line 882
  if ((unsigned long long )part_uv->cached_heartbeat.value == part->last_heartbeat && part_uv->cached_heartbeat.offline == 0UL) {
#line 885
    ret = 26;
  } else {
#line 887
    part->last_heartbeat = (u64 )part_uv->cached_heartbeat.value;
  }
#line 889
  return (ret);
}
}
#line 893 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_request_partition_activation_uv(struct xpc_rsvd_page *remote_rp ,
                                                unsigned long remote_rp_gpa , int nasid ) 
{ 
  short partid ;
  struct xpc_partition *part ;
  struct xpc_activate_mq_msg_activate_req_uv msg ;

  {
#line 896
  partid = remote_rp->SAL_partid;
#line 897
  part = xpc_partitions + (unsigned long )partid;
#line 900
  part->remote_rp_pa = remote_rp_gpa;
#line 901
  part->remote_rp_ts_jiffies = remote_rp->ts_jiffies;
#line 902
  part->sn.uv.heartbeat_gpa = remote_rp->sn.uv.heartbeat_gpa;
#line 903
  part->sn.uv.activate_gru_mq_desc_gpa = remote_rp->sn.uv.activate_gru_mq_desc_gpa;
#line 910
  if ((unsigned int )part->sn.uv.remote_act_state == 0U) {
#line 911
    msg.rp_gpa = uv_gpa((void *)xpc_rsvd_page);
#line 912
    msg.heartbeat_gpa = xpc_rsvd_page->sn.uv.heartbeat_gpa;
#line 913
    msg.activate_gru_mq_desc_gpa = xpc_rsvd_page->sn.uv.activate_gru_mq_desc_gpa;
#line 915
    xpc_send_activate_IRQ_part_uv(part, (void *)(& msg), 40UL, 1);
  } else {

  }
#line 919
  if ((unsigned int )part->act_state == 0U) {
#line 920
    xpc_send_local_activate_IRQ_uv(part, 1);
  } else {

  }
#line 921
  return;
}
}
#line 924 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_request_partition_reactivation_uv(struct xpc_partition *part ) 
{ 


  {
#line 926
  xpc_send_local_activate_IRQ_uv(part, 1);
#line 927
  return;
}
}
#line 930 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_request_partition_deactivation_uv(struct xpc_partition *part ) 
{ 
  struct xpc_activate_mq_msg_deactivate_req_uv msg ;

  {
#line 938
  if ((unsigned int )part->sn.uv.remote_act_state != 4U && (unsigned int )part->sn.uv.remote_act_state != 0U) {
#line 941
    msg.reason = part->reason;
#line 942
    xpc_send_activate_IRQ_part_uv(part, (void *)(& msg), 24UL, 2);
  } else {

  }
#line 944
  return;
}
}
#line 948 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_cancel_partition_deactivation_request_uv(struct xpc_partition *part ) 
{ 


  {
#line 951
  return;
}
}
#line 955 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_init_fifo_uv(struct xpc_fifo_head_uv *head ) 
{ 
  struct lock_class_key __key ;

  {
#line 957
  head->first = (struct xpc_fifo_entry_uv *)0;
#line 958
  head->last = (struct xpc_fifo_entry_uv *)0;
#line 959
  spinlock_check(& head->lock);
#line 959
  __raw_spin_lock_init(& head->lock.__annonCompField18.rlock, "&(&head->lock)->rlock",
                       & __key);
#line 960
  head->n_entries = 0;
#line 961
  return;
}
}
#line 964 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void *xpc_get_fifo_entry_uv(struct xpc_fifo_head_uv *head ) 
{ 
  unsigned long irq_flags ;
  struct xpc_fifo_entry_uv *first ;
  long tmp ;

  {
#line 969
  ldv_spin_lock();
#line 970
  first = head->first;
#line 971
  if ((unsigned long )head->first != (unsigned long )((struct xpc_fifo_entry_uv *)0)) {
#line 972
    head->first = first->next;
#line 973
    if ((unsigned long )head->first == (unsigned long )((struct xpc_fifo_entry_uv *)0)) {
#line 974
      head->last = (struct xpc_fifo_entry_uv *)0;
    } else {

    }
#line 976
    head->n_entries = head->n_entries - 1;
#line 977
    tmp = ldv__builtin_expect(head->n_entries < 0, 0L);
#line 977
    if (tmp != 0L) {
#line 977
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"),
                           "i" (977), "i" (12UL));
      ldv_32753: ;
#line 977
      goto ldv_32753;
    } else {

    }
#line 979
    first->next = (struct xpc_fifo_entry_uv *)0;
  } else {

  }
#line 981
  spin_unlock_irqrestore(& head->lock, irq_flags);
#line 982
  return ((void *)first);
}
}
#line 986 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_put_fifo_entry_uv(struct xpc_fifo_head_uv *head , struct xpc_fifo_entry_uv *last ) 
{ 
  unsigned long irq_flags ;

  {
#line 991
  last->next = (struct xpc_fifo_entry_uv *)0;
#line 992
  ldv_spin_lock();
#line 993
  if ((unsigned long )head->last != (unsigned long )((struct xpc_fifo_entry_uv *)0)) {
#line 994
    (head->last)->next = last;
  } else {
#line 996
    head->first = last;
  }
#line 997
  head->last = last;
#line 998
  head->n_entries = head->n_entries + 1;
#line 999
  spin_unlock_irqrestore(& head->lock, irq_flags);
#line 1000
  return;
}
}
#line 1003 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static int xpc_n_of_fifo_entries_uv(struct xpc_fifo_head_uv *head ) 
{ 


  {
#line 1005
  return (head->n_entries);
}
}
#line 1012 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static enum xp_retval xpc_setup_ch_structures_uv(struct xpc_partition *part ) 
{ 
  struct xpc_channel_uv *ch_uv ;
  int ch_number ;

  {
#line 1017
  ch_number = 0;
#line 1017
  goto ldv_32768;
  ldv_32767: 
#line 1018
  ch_uv = & (part->channels + (unsigned long )ch_number)->sn.uv;
#line 1020
  xpc_init_fifo_uv(& ch_uv->msg_slot_free_list);
#line 1021
  xpc_init_fifo_uv(& ch_uv->recv_msg_list);
#line 1017
  ch_number = ch_number + 1;
  ldv_32768: ;
#line 1017
  if ((int )part->nchannels > ch_number) {
#line 1019
    goto ldv_32767;
  } else {

  }

#line 1024
  return (0);
}
}
#line 1031 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_teardown_ch_structures_uv(struct xpc_partition *part ) 
{ 


  {
#line 1034
  return;
}
}
#line 1038 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static enum xp_retval xpc_make_first_contact_uv(struct xpc_partition *part ) 
{ 
  struct xpc_activate_mq_msg_uv msg ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 1047
  xpc_send_activate_IRQ_part_uv(part, (void *)(& msg), 16UL, 0);
#line 1050
  goto ldv_32780;
  ldv_32779: 
#line 1053
  descriptor.modname = "xpc";
#line 1053
  descriptor.function = "xpc_make_first_contact_uv";
#line 1053
  descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c";
#line 1053
  descriptor.format = "waiting to make first contact with partition %d\n";
#line 1053
  descriptor.lineno = 1054U;
#line 1053
  descriptor.flags = 0U;
#line 1053
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1053
  if (tmp != 0L) {
#line 1053
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_part, "waiting to make first contact with partition %d\n",
                      (int )((short )(((long )part - (long )xpc_partitions) / 896L)));
  } else {

  }
#line 1057
  msleep_interruptible(250U);
#line 1059
  if ((unsigned int )part->act_state == 4U) {
#line 1060
    return (part->reason);
  } else {

  }
  ldv_32780: ;
#line 1050
  if ((unsigned int )part->sn.uv.remote_act_state != 2U && (unsigned int )part->sn.uv.remote_act_state != 3U) {
#line 1053
    goto ldv_32779;
  } else {

  }

#line 1063
  return (0);
}
}
#line 1067 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static u64 xpc_get_chctl_all_flags_uv(struct xpc_partition *part ) 
{ 
  unsigned long irq_flags ;
  union xpc_channel_ctl_flags chctl ;

  {
#line 1072
  ldv_spin_lock();
#line 1073
  chctl = part->chctl;
#line 1074
  if (chctl.all_flags != 0ULL) {
#line 1075
    part->chctl.all_flags = 0ULL;
  } else {

  }
#line 1077
  spin_unlock_irqrestore(& part->chctl_lock, irq_flags);
#line 1078
  return (chctl.all_flags);
}
}
#line 1082 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static enum xp_retval xpc_allocate_send_msg_slot_uv(struct xpc_channel *ch ) 
{ 
  struct xpc_channel_uv *ch_uv ;
  struct xpc_send_msg_slot_uv *msg_slot ;
  unsigned long irq_flags ;
  int nentries ;
  int entry ;
  size_t nbytes ;
  void *tmp ;

  {
#line 1084
  ch_uv = & ch->sn.uv;
#line 1091
  nentries = (int )ch->local_nentries;
#line 1091
  goto ldv_32801;
  ldv_32800: 
#line 1092
  nbytes = (unsigned long )nentries * 32UL;
#line 1093
  tmp = kzalloc(nbytes, 208U);
#line 1093
  ch_uv->send_msg_slots = (struct xpc_send_msg_slot_uv *)tmp;
#line 1094
  if ((unsigned long )ch_uv->send_msg_slots == (unsigned long )((struct xpc_send_msg_slot_uv *)0)) {
#line 1095
    goto ldv_32796;
  } else {

  }
#line 1097
  entry = 0;
#line 1097
  goto ldv_32798;
  ldv_32797: 
#line 1098
  msg_slot = ch_uv->send_msg_slots + (unsigned long )entry;
#line 1100
  msg_slot->msg_slot_number = (unsigned int )entry;
#line 1101
  xpc_put_fifo_entry_uv(& ch_uv->msg_slot_free_list, & msg_slot->next);
#line 1097
  entry = entry + 1;
  ldv_32798: ;
#line 1097
  if (entry < nentries) {
#line 1099
    goto ldv_32797;
  } else {

  }
#line 1105
  ldv_spin_lock();
#line 1106
  if ((int )ch->local_nentries > nentries) {
#line 1107
    ch->local_nentries = (u16 )nentries;
  } else {

  }
#line 1108
  spin_unlock_irqrestore(& ch->lock, irq_flags);
#line 1109
  return (0);
  ldv_32796: 
#line 1091
  nentries = nentries - 1;
  ldv_32801: ;
#line 1091
  if (nentries > 0) {
#line 1093
    goto ldv_32800;
  } else {

  }

#line 1112
  return (13);
}
}
#line 1116 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static enum xp_retval xpc_allocate_recv_msg_slot_uv(struct xpc_channel *ch ) 
{ 
  struct xpc_channel_uv *ch_uv ;
  struct xpc_notify_mq_msg_uv *msg_slot ;
  unsigned long irq_flags ;
  int nentries ;
  int entry ;
  size_t nbytes ;

  {
#line 1118
  ch_uv = & ch->sn.uv;
#line 1125
  nentries = (int )ch->remote_nentries;
#line 1125
  goto ldv_32817;
  ldv_32816: 
#line 1126
  nbytes = (size_t )((int )ch->entry_size * nentries);
#line 1127
  ch_uv->recv_msg_slots = kzalloc(nbytes, 208U);
#line 1128
  if ((unsigned long )ch_uv->recv_msg_slots == (unsigned long )((void *)0)) {
#line 1129
    goto ldv_32812;
  } else {

  }
#line 1131
  entry = 0;
#line 1131
  goto ldv_32814;
  ldv_32813: 
#line 1132
  msg_slot = (struct xpc_notify_mq_msg_uv *)ch_uv->recv_msg_slots + (unsigned long )((int )ch->entry_size * entry);
#line 1135
  msg_slot->hdr.msg_slot_number = (unsigned int )entry;
#line 1131
  entry = entry + 1;
  ldv_32814: ;
#line 1131
  if (entry < nentries) {
#line 1133
    goto ldv_32813;
  } else {

  }
#line 1138
  ldv_spin_lock();
#line 1139
  if ((int )ch->remote_nentries > nentries) {
#line 1140
    ch->remote_nentries = (u16 )nentries;
  } else {

  }
#line 1141
  spin_unlock_irqrestore(& ch->lock, irq_flags);
#line 1142
  return (0);
  ldv_32812: 
#line 1125
  nentries = nentries - 1;
  ldv_32817: ;
#line 1125
  if (nentries > 0) {
#line 1127
    goto ldv_32816;
  } else {

  }

#line 1145
  return (13);
}
}
#line 1152 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static enum xp_retval xpc_setup_msg_structures_uv(struct xpc_channel *ch ) 
{ 
  enum xp_retval ret ;
  struct xpc_channel_uv *ch_uv ;

  {
#line 1155
  ch_uv = & ch->sn.uv;
#line 1159
  ch_uv->cached_notify_gru_mq_desc = kzalloc(32UL, 208U);
#line 1162
  if ((unsigned long )ch_uv->cached_notify_gru_mq_desc == (unsigned long )((void *)0)) {
#line 1163
    return (13);
  } else {

  }
#line 1165
  ret = xpc_allocate_send_msg_slot_uv(ch);
#line 1166
  if ((unsigned int )ret == 0U) {
#line 1168
    ret = xpc_allocate_recv_msg_slot_uv(ch);
#line 1169
    if ((unsigned int )ret != 0U) {
#line 1170
      kfree((void const   *)ch_uv->send_msg_slots);
#line 1171
      xpc_init_fifo_uv(& ch_uv->msg_slot_free_list);
    } else {

    }
  } else {

  }
#line 1174
  return (ret);
}
}
#line 1182 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_teardown_msg_structures_uv(struct xpc_channel *ch ) 
{ 
  struct xpc_channel_uv *ch_uv ;

  {
#line 1184
  ch_uv = & ch->sn.uv;
#line 1188
  kfree((void const   *)ch_uv->cached_notify_gru_mq_desc);
#line 1189
  ch_uv->cached_notify_gru_mq_desc = (void *)0;
#line 1191
  if ((ch->flags & 128U) != 0U) {
#line 1192
    xpc_init_fifo_uv(& ch_uv->msg_slot_free_list);
#line 1193
    kfree((void const   *)ch_uv->send_msg_slots);
#line 1194
    xpc_init_fifo_uv(& ch_uv->recv_msg_list);
#line 1195
    kfree((void const   *)ch_uv->recv_msg_slots);
  } else {

  }
#line 1197
  return;
}
}
#line 1200 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_send_chctl_closerequest_uv(struct xpc_channel *ch , unsigned long *irq_flags ) 
{ 
  struct xpc_activate_mq_msg_chctl_closerequest_uv msg ;

  {
#line 1204
  msg.ch_number = (short )ch->number;
#line 1205
  msg.reason = ch->reason;
#line 1206
  xpc_send_activate_IRQ_ch_uv(ch, irq_flags, (void *)(& msg), 24UL, 3);
#line 1207
  return;
}
}
#line 1211 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_send_chctl_closereply_uv(struct xpc_channel *ch , unsigned long *irq_flags ) 
{ 
  struct xpc_activate_mq_msg_chctl_closereply_uv msg ;

  {
#line 1215
  msg.ch_number = (short )ch->number;
#line 1216
  xpc_send_activate_IRQ_ch_uv(ch, irq_flags, (void *)(& msg), 24UL, 4);
#line 1217
  return;
}
}
#line 1221 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_send_chctl_openrequest_uv(struct xpc_channel *ch , unsigned long *irq_flags ) 
{ 
  struct xpc_activate_mq_msg_chctl_openrequest_uv msg ;

  {
#line 1225
  msg.ch_number = (short )ch->number;
#line 1226
  msg.entry_size = (short )ch->entry_size;
#line 1227
  msg.local_nentries = (short )ch->local_nentries;
#line 1228
  xpc_send_activate_IRQ_ch_uv(ch, irq_flags, (void *)(& msg), 24UL, 5);
#line 1229
  return;
}
}
#line 1233 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_send_chctl_openreply_uv(struct xpc_channel *ch , unsigned long *irq_flags ) 
{ 
  struct xpc_activate_mq_msg_chctl_openreply_uv msg ;

  {
#line 1237
  msg.ch_number = (short )ch->number;
#line 1238
  msg.local_nentries = (short )ch->local_nentries;
#line 1239
  msg.remote_nentries = (short )ch->remote_nentries;
#line 1240
  msg.notify_gru_mq_desc_gpa = uv_gpa(xpc_notify_mq_uv->gru_mq_desc);
#line 1241
  xpc_send_activate_IRQ_ch_uv(ch, irq_flags, (void *)(& msg), 32UL, 6);
#line 1242
  return;
}
}
#line 1246 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_send_chctl_opencomplete_uv(struct xpc_channel *ch , unsigned long *irq_flags ) 
{ 
  struct xpc_activate_mq_msg_chctl_opencomplete_uv msg ;

  {
#line 1250
  msg.ch_number = (short )ch->number;
#line 1251
  xpc_send_activate_IRQ_ch_uv(ch, irq_flags, (void *)(& msg), 24UL, 7);
#line 1252
  return;
}
}
#line 1256 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_send_chctl_local_msgrequest_uv(struct xpc_partition *part , int ch_number ) 
{ 
  unsigned long irq_flags ;

  {
#line 1260
  ldv_spin_lock();
#line 1261
  part->chctl.flags[ch_number] = (u8 )((unsigned int )part->chctl.flags[ch_number] | 32U);
#line 1262
  spin_unlock_irqrestore(& part->chctl_lock, irq_flags);
#line 1264
  xpc_wakeup_channel_mgr(part);
#line 1265
  return;
}
}
#line 1268 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static enum xp_retval xpc_save_remote_msgqueue_pa_uv(struct xpc_channel *ch , unsigned long gru_mq_desc_gpa ) 
{ 
  struct xpc_channel_uv *ch_uv ;
  enum xp_retval tmp ;

  {
#line 1271
  ch_uv = & ch->sn.uv;
#line 1274
  tmp = xpc_cache_remote_gru_mq_desc_uv((struct gru_message_queue_desc *)ch_uv->cached_notify_gru_mq_desc,
                                        gru_mq_desc_gpa);
#line 1274
  return (tmp);
}
}
#line 1279 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_indicate_partition_engaged_uv(struct xpc_partition *part ) 
{ 
  struct xpc_activate_mq_msg_uv msg ;

  {
#line 1283
  xpc_send_activate_IRQ_part_uv(part, (void *)(& msg), 16UL, 8);
#line 1284
  return;
}
}
#line 1288 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_indicate_partition_disengaged_uv(struct xpc_partition *part ) 
{ 
  struct xpc_activate_mq_msg_uv msg ;

  {
#line 1292
  xpc_send_activate_IRQ_part_uv(part, (void *)(& msg), 16UL, 9);
#line 1293
  return;
}
}
#line 1297 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_assume_partition_disengaged_uv(short partid ) 
{ 
  struct xpc_partition_uv *part_uv ;
  unsigned long irq_flags ;

  {
#line 1299
  part_uv = & (xpc_partitions + (unsigned long )partid)->sn.uv;
#line 1302
  ldv_spin_lock();
#line 1303
  part_uv->flags = part_uv->flags & 4294967293U;
#line 1304
  spin_unlock_irqrestore(& part_uv->flags_lock, irq_flags);
#line 1305
  return;
}
}
#line 1308 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static int xpc_partition_engaged_uv(short partid ) 
{ 


  {
#line 1310
  return (((xpc_partitions + (unsigned long )partid)->sn.uv.flags & 2U) != 0U);
}
}
#line 1314 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static int xpc_any_partition_engaged_uv(void) 
{ 
  struct xpc_partition_uv *part_uv ;
  short partid ;

  {
#line 1319
  partid = 0;
#line 1319
  goto ldv_32885;
  ldv_32884: 
#line 1320
  part_uv = & (xpc_partitions + (unsigned long )partid)->sn.uv;
#line 1321
  if ((part_uv->flags & 2U) != 0U) {
#line 1322
    return (1);
  } else {

  }
#line 1319
  partid = (short )((int )partid + 1);
  ldv_32885: ;
#line 1319
  if ((int )partid <= 255) {
#line 1321
    goto ldv_32884;
  } else {

  }

#line 1324
  return (0);
}
}
#line 1328 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static enum xp_retval xpc_allocate_msg_slot_uv(struct xpc_channel *ch , u32 flags ,
                                               struct xpc_send_msg_slot_uv **address_of_msg_slot ) 
{ 
  enum xp_retval ret ;
  struct xpc_send_msg_slot_uv *msg_slot ;
  struct xpc_fifo_entry_uv *entry ;
  void *tmp ;
  struct xpc_fifo_entry_uv  const  *__mptr ;

  {
  ldv_32896: 
#line 1336
  tmp = xpc_get_fifo_entry_uv(& ch->sn.uv.msg_slot_free_list);
#line 1336
  entry = (struct xpc_fifo_entry_uv *)tmp;
#line 1337
  if ((unsigned long )entry != (unsigned long )((struct xpc_fifo_entry_uv *)0)) {
#line 1338
    goto ldv_32895;
  } else {

  }
#line 1340
  if ((int )flags & 1) {
#line 1341
    return (7);
  } else {

  }
#line 1343
  ret = xpc_allocate_msg_wait(ch);
#line 1344
  if ((unsigned int )ret != 10U && (unsigned int )ret != 9U) {
#line 1345
    return (ret);
  } else {

  }
#line 1346
  goto ldv_32896;
  ldv_32895: 
#line 1348
  __mptr = (struct xpc_fifo_entry_uv  const  *)entry;
#line 1348
  msg_slot = (struct xpc_send_msg_slot_uv *)__mptr;
#line 1349
  *address_of_msg_slot = msg_slot;
#line 1350
  return (0);
}
}
#line 1354 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_free_msg_slot_uv(struct xpc_channel *ch , struct xpc_send_msg_slot_uv *msg_slot ) 
{ 
  int tmp ;

  {
#line 1357
  xpc_put_fifo_entry_uv(& ch->sn.uv.msg_slot_free_list, & msg_slot->next);
#line 1360
  tmp = atomic_read((atomic_t const   *)(& ch->n_on_msg_allocate_wq));
#line 1360
  if (tmp > 0) {
#line 1361
    __wake_up(& ch->msg_allocate_wq, 3U, 1, (void *)0);
  } else {

  }
#line 1362
  return;
}
}
#line 1365 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_notify_sender_uv(struct xpc_channel *ch , struct xpc_send_msg_slot_uv *msg_slot ,
                                 enum xp_retval reason ) 
{ 
  void (*func)(enum xp_retval  , short  , int  , void * ) ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  void (*__ret)(enum xp_retval  , short  , int  , void * ) ;
  void (*__old)(enum xp_retval  , short  , int  , void * ) ;
  void (*__new)(enum xp_retval  , short  , int  , void * ) ;
  u8 volatile   *__ptr ;
  u16 volatile   *__ptr___0 ;
  u32 volatile   *__ptr___1 ;
  u64 volatile   *__ptr___2 ;

  {
#line 1369
  func = msg_slot->func;
#line 1371
  if ((unsigned long )func != (unsigned long )((void (*)(enum xp_retval  , short  ,
                                                         int  , void * ))0)) {
#line 1371
    __old = func;
#line 1371
    __new = (void (*)(enum xp_retval  , short  , int  , void * ))0;
#line 1371
    switch (8UL) {
    case 1UL: 
#line 1371
    __ptr = (u8 volatile   *)(& msg_slot->func);
#line 1371
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1": "=a" (__ret),
                         "+m" (*__ptr): "q" (__new), "0" (__old): "memory");
#line 1371
    goto ldv_32914;
    case 2UL: 
#line 1371
    __ptr___0 = (u16 volatile   *)(& msg_slot->func);
#line 1371
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1": "=a" (__ret),
                         "+m" (*__ptr___0): "r" (__new), "0" (__old): "memory");
#line 1371
    goto ldv_32914;
    case 4UL: 
#line 1371
    __ptr___1 = (u32 volatile   *)(& msg_slot->func);
#line 1371
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1": "=a" (__ret),
                         "+m" (*__ptr___1): "r" (__new), "0" (__old): "memory");
#line 1371
    goto ldv_32914;
    case 8UL: 
#line 1371
    __ptr___2 = (u64 volatile   *)(& msg_slot->func);
#line 1371
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1": "=a" (__ret),
                         "+m" (*__ptr___2): "r" (__new), "0" (__old): "memory");
#line 1371
    goto ldv_32914;
    default: 
#line 1371
    __cmpxchg_wrong_size();
    }
    ldv_32914: ;
#line 1371
    if ((unsigned long )__ret == (unsigned long )func) {
#line 1373
      atomic_dec(& ch->n_to_notify);
#line 1375
      descriptor.modname = "xpc";
#line 1375
      descriptor.function = "xpc_notify_sender_uv";
#line 1375
      descriptor.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c";
#line 1375
      descriptor.format = "msg_slot->func() called, msg_slot=0x%p msg_slot_number=%d partid=%d channel=%d\n";
#line 1375
      descriptor.lineno = 1377U;
#line 1375
      descriptor.flags = 0U;
#line 1375
      tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1375
      if (tmp != 0L) {
#line 1375
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)xpc_chan, "msg_slot->func() called, msg_slot=0x%p msg_slot_number=%d partid=%d channel=%d\n",
                          msg_slot, msg_slot->msg_slot_number, (int )ch->partid, (int )ch->number);
      } else {

      }
#line 1379
      (*func)(reason, (int )ch->partid, (int )ch->number, msg_slot->key);
#line 1381
      descriptor___0.modname = "xpc";
#line 1381
      descriptor___0.function = "xpc_notify_sender_uv";
#line 1381
      descriptor___0.filename = "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c";
#line 1381
      descriptor___0.format = "msg_slot->func() returned, msg_slot=0x%p msg_slot_number=%d partid=%d channel=%d\n";
#line 1381
      descriptor___0.lineno = 1383U;
#line 1381
      descriptor___0.flags = 0U;
#line 1381
      tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 1381
      if (tmp___0 != 0L) {
#line 1381
        __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)xpc_chan, "msg_slot->func() returned, msg_slot=0x%p msg_slot_number=%d partid=%d channel=%d\n",
                          msg_slot, msg_slot->msg_slot_number, (int )ch->partid, (int )ch->number);
      } else {

      }
    } else {

    }
  } else {

  }
#line 1384
  return;
}
}
#line 1388 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_handle_notify_mq_ack_uv(struct xpc_channel *ch , struct xpc_notify_mq_msg_uv *msg ) 
{ 
  struct xpc_send_msg_slot_uv *msg_slot ;
  int entry ;
  long tmp ;

  {
#line 1392
  entry = (int )(msg->hdr.msg_slot_number % (unsigned int )ch->local_nentries);
#line 1394
  msg_slot = ch->sn.uv.send_msg_slots + (unsigned long )entry;
#line 1396
  tmp = ldv__builtin_expect(msg_slot->msg_slot_number != msg->hdr.msg_slot_number, 0L);
#line 1396
  if (tmp != 0L) {
#line 1396
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"),
                         "i" (1396), "i" (12UL));
    ldv_32932: ;
#line 1396
    goto ldv_32932;
  } else {

  }
#line 1397
  msg_slot->msg_slot_number = msg_slot->msg_slot_number + (unsigned int )ch->local_nentries;
#line 1399
  if ((unsigned long )msg_slot->func != (unsigned long )((void (*)(enum xp_retval  ,
                                                                   short  , int  ,
                                                                   void * ))0)) {
#line 1400
    xpc_notify_sender_uv(ch, msg_slot, 5);
  } else {

  }
#line 1402
  xpc_free_msg_slot_uv(ch, msg_slot);
#line 1403
  return;
}
}
#line 1406 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_handle_notify_mq_msg_uv(struct xpc_partition *part , struct xpc_notify_mq_msg_uv *msg ) 
{ 
  struct xpc_partition_uv *part_uv ;
  struct xpc_channel *ch ;
  struct xpc_channel_uv *ch_uv ;
  struct xpc_notify_mq_msg_uv *msg_slot ;
  unsigned long irq_flags ;
  int ch_number ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 1409
  part_uv = & part->sn.uv;
#line 1414
  ch_number = (int )msg->hdr.ch_number;
#line 1416
  tmp = ldv__builtin_expect((int )part->nchannels <= ch_number, 0L);
#line 1416
  if (tmp != 0L) {
#line 1417
    dev_err((struct device  const  *)xpc_part, "xpc_handle_notify_IRQ_uv() received invalid channel number=0x%x in message from partid=%d\n",
            ch_number, (int )((short )(((long )part - (long )xpc_partitions) / 896L)));
#line 1422
    ldv_spin_lock();
#line 1423
    if ((unsigned int )part_uv->act_state_req == 0U) {
#line 1424
      xpc_activate_IRQ_rcvd = xpc_activate_IRQ_rcvd + 1;
    } else {

    }
#line 1425
    part_uv->act_state_req = 3U;
#line 1426
    part_uv->reason = 60;
#line 1427
    spin_unlock_irqrestore(& xpc_activate_IRQ_rcvd_lock, irq_flags);
#line 1429
    __wake_up(& xpc_activate_IRQ_wq, 1U, 1, (void *)0);
#line 1430
    return;
  } else {

  }
#line 1433
  ch = part->channels + (unsigned long )ch_number;
#line 1434
  xpc_msgqueue_ref(ch);
#line 1436
  if ((ch->flags & 1024U) == 0U) {
#line 1437
    xpc_msgqueue_deref(ch);
#line 1438
    return;
  } else {

  }
#line 1442
  if ((unsigned int )msg->hdr.size == 0U) {
#line 1443
    xpc_handle_notify_mq_ack_uv(ch, msg);
#line 1444
    xpc_msgqueue_deref(ch);
#line 1445
    return;
  } else {

  }
#line 1449
  ch_uv = & ch->sn.uv;
#line 1451
  msg_slot = (struct xpc_notify_mq_msg_uv *)ch_uv->recv_msg_slots + (unsigned long )((msg->hdr.msg_slot_number % (unsigned int )ch->remote_nentries) * (unsigned int )ch->entry_size);
#line 1454
  tmp___0 = ldv__builtin_expect((unsigned int )msg_slot->hdr.size != 0U, 0L);
#line 1454
  if (tmp___0 != 0L) {
#line 1454
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"),
                         "i" (1454), "i" (12UL));
    ldv_32943: ;
#line 1454
    goto ldv_32943;
  } else {

  }
#line 1456
  memcpy((void *)msg_slot, (void const   *)msg, (size_t )msg->hdr.size);
#line 1458
  xpc_put_fifo_entry_uv(& ch_uv->recv_msg_list, & msg_slot->hdr.u.next);
#line 1460
  if ((ch->flags & 512U) != 0U) {
#line 1466
    tmp___1 = atomic_read((atomic_t const   *)(& ch->kthreads_idle));
#line 1466
    if (tmp___1 > 0) {
#line 1467
      __wake_up(& ch->idle_wq, 3U, 1, (void *)0);
    } else {
#line 1469
      xpc_send_chctl_local_msgrequest_uv(part, (int )ch->number);
    }
  } else {

  }
#line 1471
  xpc_msgqueue_deref(ch);
#line 1472
  return;
}
}
#line 1475 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static irqreturn_t xpc_handle_notify_IRQ_uv(int irq , void *dev_id ) 
{ 
  struct xpc_notify_mq_msg_uv *msg ;
  short partid ;
  struct xpc_partition *part ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1481
  goto ldv_32952;
  ldv_32951: 
#line 1484
  partid = msg->hdr.partid;
#line 1485
  if ((int )partid < 0 || (int )partid > 255) {
#line 1486
    dev_err((struct device  const  *)xpc_part, "xpc_handle_notify_IRQ_uv() received invalid partid=0x%x in message\n",
            (int )partid);
  } else {
#line 1489
    part = xpc_partitions + (unsigned long )partid;
#line 1491
    tmp = xpc_part_ref(part);
#line 1491
    if (tmp != 0) {
#line 1492
      xpc_handle_notify_mq_msg_uv(part, msg);
#line 1493
      xpc_part_deref(part);
    } else {

    }
  }
#line 1497
  gru_free_message((struct gru_message_queue_desc *)xpc_notify_mq_uv->gru_mq_desc,
                   (void *)msg);
  ldv_32952: 
#line 1481
  tmp___0 = gru_get_next_message((struct gru_message_queue_desc *)xpc_notify_mq_uv->gru_mq_desc);
#line 1481
  msg = (struct xpc_notify_mq_msg_uv *)tmp___0;
#line 1481
  if ((unsigned long )msg != (unsigned long )((struct xpc_notify_mq_msg_uv *)0)) {
#line 1483
    goto ldv_32951;
  } else {

  }

#line 1500
  return (1);
}
}
#line 1504 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static int xpc_n_of_deliverable_payloads_uv(struct xpc_channel *ch ) 
{ 
  int tmp ;

  {
#line 1506
  tmp = xpc_n_of_fifo_entries_uv(& ch->sn.uv.recv_msg_list);
#line 1506
  return (tmp);
}
}
#line 1510 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_process_msg_chctl_flags_uv(struct xpc_partition *part , int ch_number ) 
{ 
  struct xpc_channel *ch ;
  int ndeliverable_payloads ;

  {
#line 1512
  ch = part->channels + (unsigned long )ch_number;
#line 1515
  xpc_msgqueue_ref(ch);
#line 1517
  ndeliverable_payloads = xpc_n_of_deliverable_payloads_uv(ch);
#line 1519
  if ((ndeliverable_payloads > 0 && (ch->flags & 1024U) != 0U) && (ch->flags & 512U) != 0U) {
#line 1523
    xpc_activate_kthreads(ch, ndeliverable_payloads);
  } else {

  }
#line 1526
  xpc_msgqueue_deref(ch);
#line 1527
  return;
}
}
#line 1530 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static enum xp_retval xpc_send_payload_uv(struct xpc_channel *ch , u32 flags , void *payload ,
                                          u16 payload_size , u8 notify_type , void (*func)(enum xp_retval  ,
                                                                                           short  ,
                                                                                           int  ,
                                                                                           void * ) ,
                                          void *key ) 
{ 
  enum xp_retval ret ;
  struct xpc_send_msg_slot_uv *msg_slot ;
  struct xpc_notify_mq_msg_uv *msg ;
  u8 msg_buffer[128U] ;
  size_t msg_size ;
  void (*__ret)(enum xp_retval  , short  , int  , void * ) ;
  void (*__old)(enum xp_retval  , short  , int  , void * ) ;
  void (*__new)(enum xp_retval  , short  , int  , void * ) ;
  u8 volatile   *__ptr ;
  u16 volatile   *__ptr___0 ;
  u32 volatile   *__ptr___1 ;
  u64 volatile   *__ptr___2 ;

  {
#line 1534
  ret = 0;
#line 1535
  msg_slot = (struct xpc_send_msg_slot_uv *)0;
#line 1542
  msg_size = (unsigned long )payload_size + 16UL;
#line 1543
  if ((size_t )ch->entry_size < msg_size) {
#line 1544
    return (55);
  } else {

  }
#line 1546
  xpc_msgqueue_ref(ch);
#line 1548
  if ((ch->flags & 131072U) != 0U) {
#line 1549
    ret = ch->reason;
#line 1550
    goto out_1;
  } else {

  }
#line 1552
  if ((ch->flags & 1024U) == 0U) {
#line 1553
    ret = 1;
#line 1554
    goto out_1;
  } else {

  }
#line 1557
  ret = xpc_allocate_msg_slot_uv(ch, flags, & msg_slot);
#line 1558
  if ((unsigned int )ret != 0U) {
#line 1559
    goto out_1;
  } else {

  }
#line 1561
  if ((unsigned long )func != (unsigned long )((void (*)(enum xp_retval  , short  ,
                                                         int  , void * ))0)) {
#line 1562
    atomic_inc(& ch->n_to_notify);
#line 1564
    msg_slot->key = key;
#line 1565
    __asm__  volatile   ("": : : "memory");
#line 1566
    msg_slot->func = func;
#line 1568
    if ((ch->flags & 131072U) != 0U) {
#line 1569
      ret = ch->reason;
#line 1570
      goto out_2;
    } else {

    }
  } else {

  }
#line 1574
  msg = (struct xpc_notify_mq_msg_uv *)(& msg_buffer);
#line 1575
  msg->hdr.partid = xp_partition_id;
#line 1576
  msg->hdr.ch_number = (u8 )ch->number;
#line 1577
  msg->hdr.size = (u8 )msg_size;
#line 1578
  msg->hdr.msg_slot_number = msg_slot->msg_slot_number;
#line 1579
  memcpy((void *)(& msg->payload), (void const   *)payload, (size_t )payload_size);
#line 1581
  ret = xpc_send_gru_msg((struct gru_message_queue_desc *)ch->sn.uv.cached_notify_gru_mq_desc,
                         (void *)msg, msg_size);
#line 1583
  if ((unsigned int )ret == 0U) {
#line 1584
    goto out_1;
  } else {

  }
#line 1586
  xpc_deactivate_partition(1586, xpc_partitions + (unsigned long )ch->partid, ret);
  out_2: ;
#line 1588
  if ((unsigned long )func != (unsigned long )((void (*)(enum xp_retval  , short  ,
                                                         int  , void * ))0)) {
#line 1599
    __old = func;
#line 1599
    __new = (void (*)(enum xp_retval  , short  , int  , void * ))0;
#line 1599
    switch (8UL) {
    case 1UL: 
#line 1599
    __ptr = (u8 volatile   *)(& msg_slot->func);
#line 1599
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1": "=a" (__ret),
                         "+m" (*__ptr): "q" (__new), "0" (__old): "memory");
#line 1599
    goto ldv_32984;
    case 2UL: 
#line 1599
    __ptr___0 = (u16 volatile   *)(& msg_slot->func);
#line 1599
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1": "=a" (__ret),
                         "+m" (*__ptr___0): "r" (__new), "0" (__old): "memory");
#line 1599
    goto ldv_32984;
    case 4UL: 
#line 1599
    __ptr___1 = (u32 volatile   *)(& msg_slot->func);
#line 1599
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1": "=a" (__ret),
                         "+m" (*__ptr___1): "r" (__new), "0" (__old): "memory");
#line 1599
    goto ldv_32984;
    case 8UL: 
#line 1599
    __ptr___2 = (u64 volatile   *)(& msg_slot->func);
#line 1599
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1": "=a" (__ret),
                         "+m" (*__ptr___2): "r" (__new), "0" (__old): "memory");
#line 1599
    goto ldv_32984;
    default: 
#line 1599
    __cmpxchg_wrong_size();
    }
    ldv_32984: ;
#line 1599
    if ((unsigned long )__ret != (unsigned long )func) {
#line 1600
      ret = 0;
#line 1601
      goto out_1;
    } else {

    }
#line 1604
    msg_slot->key = (void *)0;
#line 1605
    atomic_dec(& ch->n_to_notify);
  } else {

  }
#line 1607
  xpc_free_msg_slot_uv(ch, msg_slot);
  out_1: 
#line 1609
  xpc_msgqueue_deref(ch);
#line 1610
  return (ret);
}
}
#line 1621 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_notify_senders_of_disconnect_uv(struct xpc_channel *ch ) 
{ 
  struct xpc_send_msg_slot_uv *msg_slot ;
  int entry ;
  int tmp ;

  {
#line 1628
  entry = 0;
#line 1628
  goto ldv_33000;
  ldv_32999: 
#line 1630
  tmp = atomic_read((atomic_t const   *)(& ch->n_to_notify));
#line 1630
  if (tmp == 0) {
#line 1631
    goto ldv_32998;
  } else {

  }
#line 1633
  msg_slot = ch->sn.uv.send_msg_slots + (unsigned long )entry;
#line 1634
  if ((unsigned long )msg_slot->func != (unsigned long )((void (*)(enum xp_retval  ,
                                                                   short  , int  ,
                                                                   void * ))0)) {
#line 1635
    xpc_notify_sender_uv(ch, msg_slot, ch->reason);
  } else {

  }
#line 1628
  entry = entry + 1;
  ldv_33000: ;
#line 1628
  if ((int )ch->local_nentries > entry) {
#line 1630
    goto ldv_32999;
  } else {

  }
  ldv_32998: ;
#line 1635
  return;
}
}
#line 1643 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void *xpc_get_deliverable_payload_uv(struct xpc_channel *ch ) 
{ 
  struct xpc_fifo_entry_uv *entry ;
  struct xpc_notify_mq_msg_uv *msg ;
  void *payload ;
  void *tmp ;
  struct xpc_fifo_entry_uv  const  *__mptr ;

  {
#line 1647
  payload = (void *)0;
#line 1649
  if ((ch->flags & 131072U) == 0U) {
#line 1650
    tmp = xpc_get_fifo_entry_uv(& ch->sn.uv.recv_msg_list);
#line 1650
    entry = (struct xpc_fifo_entry_uv *)tmp;
#line 1651
    if ((unsigned long )entry != (unsigned long )((struct xpc_fifo_entry_uv *)0)) {
#line 1652
      __mptr = (struct xpc_fifo_entry_uv  const  *)entry;
#line 1652
      msg = (struct xpc_notify_mq_msg_uv *)__mptr;
#line 1654
      payload = (void *)(& msg->payload);
    } else {

    }
  } else {

  }
#line 1657
  return (payload);
}
}
#line 1661 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static void xpc_received_payload_uv(struct xpc_channel *ch , void *payload ) 
{ 
  struct xpc_notify_mq_msg_uv *msg ;
  enum xp_retval ret ;
  unsigned long const   *__mptr ;

  {
#line 1666
  __mptr = (unsigned long const   *)payload;
#line 1666
  msg = (struct xpc_notify_mq_msg_uv *)__mptr + 0xfffffffffffffff0UL;
#line 1670
  msg->hdr.partid = xp_partition_id;
#line 1671
  msg->hdr.size = 0U;
#line 1673
  ret = xpc_send_gru_msg((struct gru_message_queue_desc *)ch->sn.uv.cached_notify_gru_mq_desc,
                         (void *)msg, 16UL);
#line 1675
  if ((unsigned int )ret != 0U) {
#line 1676
    xpc_deactivate_partition(1676, xpc_partitions + (unsigned long )ch->partid, ret);
  } else {

  }
#line 1677
  return;
}
}
#line 1679 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static struct xpc_arch_operations xpc_arch_ops_uv  = 
#line 1679
     {& xpc_setup_partitions_uv, & xpc_teardown_partitions_uv, & xpc_process_activate_IRQ_rcvd_uv,
    & xpc_get_partition_rsvd_page_pa_uv, & xpc_setup_rsvd_page_uv, & xpc_allow_hb_uv,
    & xpc_disallow_hb_uv, & xpc_disallow_all_hbs_uv, & xpc_increment_heartbeat_uv,
    & xpc_offline_heartbeat_uv, & xpc_online_heartbeat_uv, & xpc_heartbeat_init_uv,
    & xpc_heartbeat_exit_uv, & xpc_get_remote_heartbeat_uv, & xpc_request_partition_activation_uv,
    & xpc_request_partition_reactivation_uv, & xpc_request_partition_deactivation_uv,
    & xpc_cancel_partition_deactivation_request_uv, & xpc_setup_ch_structures_uv,
    & xpc_teardown_ch_structures_uv, & xpc_make_first_contact_uv, & xpc_get_chctl_all_flags_uv,
    & xpc_send_chctl_closerequest_uv, & xpc_send_chctl_closereply_uv, & xpc_send_chctl_openrequest_uv,
    & xpc_send_chctl_openreply_uv, & xpc_send_chctl_opencomplete_uv, & xpc_process_msg_chctl_flags_uv,
    & xpc_save_remote_msgqueue_pa_uv, & xpc_setup_msg_structures_uv, & xpc_teardown_msg_structures_uv,
    & xpc_indicate_partition_engaged_uv, & xpc_indicate_partition_disengaged_uv, & xpc_assume_partition_disengaged_uv,
    & xpc_partition_engaged_uv, & xpc_any_partition_engaged_uv, & xpc_n_of_deliverable_payloads_uv,
    & xpc_send_payload_uv, & xpc_get_deliverable_payload_uv, & xpc_received_payload_uv,
    & xpc_notify_senders_of_disconnect_uv};
#line 1737 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
static int xpc_init_mq_node(int nid ) 
{ 
  int cpu ;
  bool tmp ;
  int tmp___0 ;
  struct cpumask  const  *tmp___1 ;
  unsigned int tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  struct cpumask  const  *tmp___7 ;
  unsigned int tmp___8 ;
  long tmp___9 ;
  bool tmp___10 ;

  {
#line 1741
  get_online_cpus();
#line 1743
  cpu = -1;
#line 1743
  goto ldv_33024;
  ldv_33023: 
#line 1744
  xpc_activate_mq_uv = xpc_create_gru_mq_uv(65536U, nid, (char *)"xpc_activate", & xpc_handle_activate_IRQ_uv);
#line 1748
  tmp = IS_ERR((void const   *)xpc_activate_mq_uv);
#line 1748
  if (tmp) {
#line 1748
    tmp___0 = 0;
  } else {
#line 1748
    tmp___0 = 1;
  }
#line 1748
  if (tmp___0) {
#line 1749
    goto ldv_33022;
  } else {

  }
  ldv_33024: 
#line 1743
  tmp___1 = cpumask_of_node(nid);
#line 1743
  tmp___2 = cpumask_next(cpu, tmp___1);
#line 1743
  cpu = (int )tmp___2;
#line 1743
  if (cpu < nr_cpu_ids) {
#line 1745
    goto ldv_33023;
  } else {

  }
  ldv_33022: 
#line 1751
  tmp___4 = IS_ERR((void const   *)xpc_activate_mq_uv);
#line 1751
  if ((int )tmp___4) {
#line 1752
    put_online_cpus();
#line 1753
    tmp___3 = PTR_ERR((void const   *)xpc_activate_mq_uv);
#line 1753
    return ((int )tmp___3);
  } else {

  }
#line 1756
  cpu = -1;
#line 1756
  goto ldv_33027;
  ldv_33026: 
#line 1757
  xpc_notify_mq_uv = xpc_create_gru_mq_uv(131072U, nid, (char *)"xpc_notify", & xpc_handle_notify_IRQ_uv);
#line 1761
  tmp___5 = IS_ERR((void const   *)xpc_notify_mq_uv);
#line 1761
  if (tmp___5) {
#line 1761
    tmp___6 = 0;
  } else {
#line 1761
    tmp___6 = 1;
  }
#line 1761
  if (tmp___6) {
#line 1762
    goto ldv_33025;
  } else {

  }
  ldv_33027: 
#line 1756
  tmp___7 = cpumask_of_node(nid);
#line 1756
  tmp___8 = cpumask_next(cpu, tmp___7);
#line 1756
  cpu = (int )tmp___8;
#line 1756
  if (cpu < nr_cpu_ids) {
#line 1758
    goto ldv_33026;
  } else {

  }
  ldv_33025: 
#line 1764
  tmp___10 = IS_ERR((void const   *)xpc_notify_mq_uv);
#line 1764
  if ((int )tmp___10) {
#line 1765
    xpc_destroy_gru_mq_uv(xpc_activate_mq_uv);
#line 1766
    put_online_cpus();
#line 1767
    tmp___9 = PTR_ERR((void const   *)xpc_notify_mq_uv);
#line 1767
    return ((int )tmp___9);
  } else {

  }
#line 1770
  put_online_cpus();
#line 1771
  return (0);
}
}
#line 1775 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
int xpc_init_uv(void) 
{ 
  int nid ;
  int ret ;

  {
#line 1778
  ret = 0;
#line 1780
  xpc_arch_ops = xpc_arch_ops_uv;
#line 1788
  if (xpc_mq_node < 0) {
#line 1789
    nid = __first_node((nodemask_t const   *)(& node_states) + 1U);
#line 1789
    goto ldv_33035;
    ldv_33034: 
#line 1790
    ret = xpc_init_mq_node(nid);
#line 1792
    if (ret == 0) {
#line 1793
      goto ldv_33033;
    } else {

    }
#line 1789
    nid = __next_node(nid, (nodemask_t const   *)(& node_states) + 1U);
    ldv_33035: ;
#line 1789
    if (nid <= 1023) {
#line 1791
      goto ldv_33034;
    } else {

    }
    ldv_33033: ;
  } else {
#line 1796
    ret = xpc_init_mq_node(xpc_mq_node);
  }
#line 1798
  if (ret < 0) {
#line 1799
    dev_err((struct device  const  *)xpc_part, "xpc_init_mq_node() returned error=%d\n",
            - ret);
  } else {

  }
#line 1802
  return (ret);
}
}
#line 1806 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.c"
void xpc_exit_uv(void) 
{ 


  {
#line 1808
  xpc_destroy_gru_mq_uv(xpc_notify_mq_uv);
#line 1809
  xpc_destroy_gru_mq_uv(xpc_activate_mq_uv);
#line 1810
  return;
}
}
#line 53 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.o.c.prepared"
extern int ldv_probe_3(void) ;
#line 56 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.o.c.prepared"
void ldv_initialize_xpc_arch_operations_3(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 57
  tmp = ldv_init_zalloc(896UL);
#line 57
  xpc_arch_ops_uv_group1 = (struct xpc_partition *)tmp;
#line 58
  tmp___0 = ldv_init_zalloc(768UL);
#line 58
  xpc_arch_ops_uv_group0 = (struct xpc_channel *)tmp___0;
#line 59
  tmp___1 = ldv_init_zalloc(128UL);
#line 59
  xpc_arch_ops_uv_group2 = (struct xpc_rsvd_page *)tmp___1;
#line 60
  return;
}
}
#line 62 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.o.c.prepared"
void ldv_main_exported_3(void) 
{ 
  u16 ldvarg19 ;
  u32 ldvarg22 ;
  unsigned long *ldvarg17 ;
  void *tmp ;
  unsigned long *ldvarg14 ;
  void *tmp___0 ;
  unsigned long *ldvarg4 ;
  void *tmp___1 ;
  short ldvarg25 ;
  void *ldvarg21 ;
  void *tmp___2 ;
  unsigned long *ldvarg16 ;
  void *tmp___3 ;
  short ldvarg15 ;
  size_t *ldvarg6 ;
  void *tmp___4 ;
  int ldvarg5 ;
  unsigned long *ldvarg26 ;
  void *tmp___5 ;
  short ldvarg24 ;
  u64 *ldvarg9 ;
  void *tmp___6 ;
  unsigned long ldvarg10 ;
  unsigned long ldvarg13 ;
  unsigned long *ldvarg8 ;
  void *tmp___7 ;
  int ldvarg12 ;
  short ldvarg3 ;
  u8 ldvarg23 ;
  void *ldvarg7 ;
  void *tmp___8 ;
  void *ldvarg20 ;
  void *tmp___9 ;
  void *ldvarg11 ;
  void *tmp___10 ;
  void (*ldvarg18)(enum xp_retval  , short  , int  , void * ) ;
  int tmp___11 ;

  {
#line 65
  tmp = ldv_init_zalloc(8UL);
#line 65
  ldvarg17 = (unsigned long *)tmp;
#line 66
  tmp___0 = ldv_init_zalloc(8UL);
#line 66
  ldvarg14 = (unsigned long *)tmp___0;
#line 67
  tmp___1 = ldv_init_zalloc(8UL);
#line 67
  ldvarg4 = (unsigned long *)tmp___1;
#line 69
  tmp___2 = ldv_init_zalloc(1UL);
#line 69
  ldvarg21 = tmp___2;
#line 70
  tmp___3 = ldv_init_zalloc(8UL);
#line 70
  ldvarg16 = (unsigned long *)tmp___3;
#line 72
  tmp___4 = ldv_init_zalloc(8UL);
#line 72
  ldvarg6 = (size_t *)tmp___4;
#line 74
  tmp___5 = ldv_init_zalloc(8UL);
#line 74
  ldvarg26 = (unsigned long *)tmp___5;
#line 76
  tmp___6 = ldv_init_zalloc(8UL);
#line 76
  ldvarg9 = (u64 *)tmp___6;
#line 79
  tmp___7 = ldv_init_zalloc(8UL);
#line 79
  ldvarg8 = (unsigned long *)tmp___7;
#line 83
  tmp___8 = ldv_init_zalloc(1UL);
#line 83
  ldvarg7 = tmp___8;
#line 84
  tmp___9 = ldv_init_zalloc(1UL);
#line 84
  ldvarg20 = tmp___9;
#line 85
  tmp___10 = ldv_init_zalloc(1UL);
#line 85
  ldvarg11 = tmp___10;
#line 63
  ldv_memset((void *)(& ldvarg19), 0, 2UL);
#line 64
  ldv_memset((void *)(& ldvarg22), 0, 4UL);
#line 68
  ldv_memset((void *)(& ldvarg25), 0, 2UL);
#line 71
  ldv_memset((void *)(& ldvarg15), 0, 2UL);
#line 73
  ldv_memset((void *)(& ldvarg5), 0, 4UL);
#line 75
  ldv_memset((void *)(& ldvarg24), 0, 2UL);
#line 77
  ldv_memset((void *)(& ldvarg10), 0, 8UL);
#line 78
  ldv_memset((void *)(& ldvarg13), 0, 8UL);
#line 80
  ldv_memset((void *)(& ldvarg12), 0, 4UL);
#line 81
  ldv_memset((void *)(& ldvarg3), 0, 2UL);
#line 82
  ldv_memset((void *)(& ldvarg23), 0, 1UL);
#line 86
  ldv_memset((void *)(& ldvarg18), 0, 8UL);
#line 88
  tmp___11 = __VERIFIER_nondet_int();
#line 88
  switch (tmp___11) {
  case 0: ;
#line 91
  if (ldv_state_variable_3 == 1) {
#line 93
    xpc_setup_ch_structures_uv(xpc_arch_ops_uv_group1);
#line 95
    ldv_state_variable_3 = 1;
  } else {

  }
#line 98
  if (ldv_state_variable_3 == 2) {
#line 100
    xpc_setup_ch_structures_uv(xpc_arch_ops_uv_group1);
#line 102
    ldv_state_variable_3 = 2;
  } else {

  }
#line 105
  goto ldv_33099;
  case 1: ;
#line 108
  if (ldv_state_variable_3 == 1) {
#line 110
    xpc_send_chctl_closereply_uv(xpc_arch_ops_uv_group0, ldvarg26);
#line 112
    ldv_state_variable_3 = 1;
  } else {

  }
#line 115
  if (ldv_state_variable_3 == 2) {
#line 117
    xpc_send_chctl_closereply_uv(xpc_arch_ops_uv_group0, ldvarg26);
#line 119
    ldv_state_variable_3 = 2;
  } else {

  }
#line 122
  goto ldv_33099;
  case 2: ;
#line 125
  if (ldv_state_variable_3 == 1) {
#line 127
    xpc_increment_heartbeat_uv();
#line 129
    ldv_state_variable_3 = 1;
  } else {

  }
#line 132
  if (ldv_state_variable_3 == 2) {
#line 134
    xpc_increment_heartbeat_uv();
#line 136
    ldv_state_variable_3 = 2;
  } else {

  }
#line 139
  goto ldv_33099;
  case 3: ;
#line 142
  if (ldv_state_variable_3 == 1) {
#line 144
    xpc_disallow_hb_uv((int )ldvarg25);
#line 146
    ldv_state_variable_3 = 1;
  } else {

  }
#line 149
  if (ldv_state_variable_3 == 2) {
#line 151
    xpc_disallow_hb_uv((int )ldvarg25);
#line 153
    ldv_state_variable_3 = 2;
  } else {

  }
#line 156
  goto ldv_33099;
  case 4: ;
#line 159
  if (ldv_state_variable_3 == 1) {
#line 161
    xpc_partition_engaged_uv((int )ldvarg24);
#line 163
    ldv_state_variable_3 = 1;
  } else {

  }
#line 166
  if (ldv_state_variable_3 == 2) {
#line 168
    xpc_partition_engaged_uv((int )ldvarg24);
#line 170
    ldv_state_variable_3 = 2;
  } else {

  }
#line 173
  goto ldv_33099;
  case 5: ;
#line 176
  if (ldv_state_variable_3 == 1) {
#line 178
    xpc_send_payload_uv(xpc_arch_ops_uv_group0, ldvarg22, ldvarg20, (int )ldvarg19,
                        (int )ldvarg23, ldvarg18, ldvarg21);
#line 180
    ldv_state_variable_3 = 1;
  } else {

  }
#line 183
  if (ldv_state_variable_3 == 2) {
#line 185
    xpc_send_payload_uv(xpc_arch_ops_uv_group0, ldvarg22, ldvarg20, (int )ldvarg19,
                        (int )ldvarg23, ldvarg18, ldvarg21);
#line 187
    ldv_state_variable_3 = 2;
  } else {

  }
#line 190
  goto ldv_33099;
  case 6: ;
#line 193
  if (ldv_state_variable_3 == 1) {
#line 195
    xpc_send_chctl_closerequest_uv(xpc_arch_ops_uv_group0, ldvarg17);
#line 197
    ldv_state_variable_3 = 1;
  } else {

  }
#line 200
  if (ldv_state_variable_3 == 2) {
#line 202
    xpc_send_chctl_closerequest_uv(xpc_arch_ops_uv_group0, ldvarg17);
#line 204
    ldv_state_variable_3 = 2;
  } else {

  }
#line 207
  goto ldv_33099;
  case 7: ;
#line 210
  if (ldv_state_variable_3 == 1) {
#line 212
    xpc_send_chctl_openrequest_uv(xpc_arch_ops_uv_group0, ldvarg16);
#line 214
    ldv_state_variable_3 = 1;
  } else {

  }
#line 217
  if (ldv_state_variable_3 == 2) {
#line 219
    xpc_send_chctl_openrequest_uv(xpc_arch_ops_uv_group0, ldvarg16);
#line 221
    ldv_state_variable_3 = 2;
  } else {

  }
#line 224
  goto ldv_33099;
  case 8: ;
#line 227
  if (ldv_state_variable_3 == 1) {
#line 229
    xpc_assume_partition_disengaged_uv((int )ldvarg15);
#line 231
    ldv_state_variable_3 = 1;
  } else {

  }
#line 234
  if (ldv_state_variable_3 == 2) {
#line 236
    xpc_assume_partition_disengaged_uv((int )ldvarg15);
#line 238
    ldv_state_variable_3 = 2;
  } else {

  }
#line 241
  goto ldv_33099;
  case 9: ;
#line 244
  if (ldv_state_variable_3 == 1) {
#line 246
    xpc_setup_msg_structures_uv(xpc_arch_ops_uv_group0);
#line 248
    ldv_state_variable_3 = 1;
  } else {

  }
#line 251
  if (ldv_state_variable_3 == 2) {
#line 253
    xpc_setup_msg_structures_uv(xpc_arch_ops_uv_group0);
#line 255
    ldv_state_variable_3 = 2;
  } else {

  }
#line 258
  goto ldv_33099;
  case 10: ;
#line 261
  if (ldv_state_variable_3 == 1) {
#line 263
    xpc_get_deliverable_payload_uv(xpc_arch_ops_uv_group0);
#line 265
    ldv_state_variable_3 = 1;
  } else {

  }
#line 268
  if (ldv_state_variable_3 == 2) {
#line 270
    xpc_get_deliverable_payload_uv(xpc_arch_ops_uv_group0);
#line 272
    ldv_state_variable_3 = 2;
  } else {

  }
#line 275
  goto ldv_33099;
  case 11: ;
#line 278
  if (ldv_state_variable_3 == 1) {
#line 280
    xpc_send_chctl_opencomplete_uv(xpc_arch_ops_uv_group0, ldvarg14);
#line 282
    ldv_state_variable_3 = 1;
  } else {

  }
#line 285
  if (ldv_state_variable_3 == 2) {
#line 287
    xpc_send_chctl_opencomplete_uv(xpc_arch_ops_uv_group0, ldvarg14);
#line 289
    ldv_state_variable_3 = 2;
  } else {

  }
#line 292
  goto ldv_33099;
  case 12: ;
#line 295
  if (ldv_state_variable_3 == 2) {
#line 297
    xpc_notify_senders_of_disconnect_uv(xpc_arch_ops_uv_group0);
#line 299
    ldv_state_variable_3 = 1;
#line 300
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 303
  goto ldv_33099;
  case 13: ;
#line 306
  if (ldv_state_variable_3 == 1) {
#line 308
    xpc_disallow_all_hbs_uv();
#line 310
    ldv_state_variable_3 = 1;
  } else {

  }
#line 313
  if (ldv_state_variable_3 == 2) {
#line 315
    xpc_disallow_all_hbs_uv();
#line 317
    ldv_state_variable_3 = 2;
  } else {

  }
#line 320
  goto ldv_33099;
  case 14: ;
#line 323
  if (ldv_state_variable_3 == 1) {
#line 325
    xpc_request_partition_deactivation_uv(xpc_arch_ops_uv_group1);
#line 327
    ldv_state_variable_3 = 1;
  } else {

  }
#line 330
  if (ldv_state_variable_3 == 2) {
#line 332
    xpc_request_partition_deactivation_uv(xpc_arch_ops_uv_group1);
#line 334
    ldv_state_variable_3 = 2;
  } else {

  }
#line 337
  goto ldv_33099;
  case 15: ;
#line 340
  if (ldv_state_variable_3 == 1) {
#line 342
    xpc_indicate_partition_engaged_uv(xpc_arch_ops_uv_group1);
#line 344
    ldv_state_variable_3 = 1;
  } else {

  }
#line 347
  if (ldv_state_variable_3 == 2) {
#line 349
    xpc_indicate_partition_engaged_uv(xpc_arch_ops_uv_group1);
#line 351
    ldv_state_variable_3 = 2;
  } else {

  }
#line 354
  goto ldv_33099;
  case 16: ;
#line 357
  if (ldv_state_variable_3 == 1) {
#line 359
    xpc_teardown_ch_structures_uv(xpc_arch_ops_uv_group1);
#line 361
    ldv_state_variable_3 = 1;
  } else {

  }
#line 364
  if (ldv_state_variable_3 == 2) {
#line 366
    xpc_teardown_ch_structures_uv(xpc_arch_ops_uv_group1);
#line 368
    ldv_state_variable_3 = 2;
  } else {

  }
#line 371
  goto ldv_33099;
  case 17: ;
#line 374
  if (ldv_state_variable_3 == 1) {
#line 376
    xpc_request_partition_activation_uv(xpc_arch_ops_uv_group2, ldvarg13, ldvarg12);
#line 378
    ldv_state_variable_3 = 1;
  } else {

  }
#line 381
  if (ldv_state_variable_3 == 2) {
#line 383
    xpc_request_partition_activation_uv(xpc_arch_ops_uv_group2, ldvarg13, ldvarg12);
#line 385
    ldv_state_variable_3 = 2;
  } else {

  }
#line 388
  goto ldv_33099;
  case 18: ;
#line 391
  if (ldv_state_variable_3 == 1) {
#line 393
    xpc_cancel_partition_deactivation_request_uv(xpc_arch_ops_uv_group1);
#line 395
    ldv_state_variable_3 = 1;
  } else {

  }
#line 398
  if (ldv_state_variable_3 == 2) {
#line 400
    xpc_cancel_partition_deactivation_request_uv(xpc_arch_ops_uv_group1);
#line 402
    ldv_state_variable_3 = 2;
  } else {

  }
#line 405
  goto ldv_33099;
  case 19: ;
#line 408
  if (ldv_state_variable_3 == 1) {
#line 410
    xpc_request_partition_reactivation_uv(xpc_arch_ops_uv_group1);
#line 412
    ldv_state_variable_3 = 1;
  } else {

  }
#line 415
  if (ldv_state_variable_3 == 2) {
#line 417
    xpc_request_partition_reactivation_uv(xpc_arch_ops_uv_group1);
#line 419
    ldv_state_variable_3 = 2;
  } else {

  }
#line 422
  goto ldv_33099;
  case 20: ;
#line 425
  if (ldv_state_variable_3 == 1) {
#line 427
    xpc_any_partition_engaged_uv();
#line 429
    ldv_state_variable_3 = 1;
  } else {

  }
#line 432
  if (ldv_state_variable_3 == 2) {
#line 434
    xpc_any_partition_engaged_uv();
#line 436
    ldv_state_variable_3 = 2;
  } else {

  }
#line 439
  goto ldv_33099;
  case 21: ;
#line 442
  if (ldv_state_variable_3 == 1) {
#line 444
    xpc_received_payload_uv(xpc_arch_ops_uv_group0, ldvarg11);
#line 446
    ldv_state_variable_3 = 1;
  } else {

  }
#line 449
  if (ldv_state_variable_3 == 2) {
#line 451
    xpc_received_payload_uv(xpc_arch_ops_uv_group0, ldvarg11);
#line 453
    ldv_state_variable_3 = 2;
  } else {

  }
#line 456
  goto ldv_33099;
  case 22: ;
#line 459
  if (ldv_state_variable_3 == 1) {
#line 461
    xpc_offline_heartbeat_uv();
#line 463
    ldv_state_variable_3 = 1;
  } else {

  }
#line 466
  if (ldv_state_variable_3 == 2) {
#line 468
    xpc_offline_heartbeat_uv();
#line 470
    ldv_state_variable_3 = 2;
  } else {

  }
#line 473
  goto ldv_33099;
  case 23: ;
#line 476
  if (ldv_state_variable_3 == 1) {
#line 478
    xpc_heartbeat_init_uv();
#line 480
    ldv_state_variable_3 = 1;
  } else {

  }
#line 483
  if (ldv_state_variable_3 == 2) {
#line 485
    xpc_heartbeat_init_uv();
#line 487
    ldv_state_variable_3 = 2;
  } else {

  }
#line 490
  goto ldv_33099;
  case 24: ;
#line 493
  if (ldv_state_variable_3 == 1) {
#line 495
    xpc_teardown_msg_structures_uv(xpc_arch_ops_uv_group0);
#line 497
    ldv_state_variable_3 = 1;
  } else {

  }
#line 500
  if (ldv_state_variable_3 == 2) {
#line 502
    xpc_teardown_msg_structures_uv(xpc_arch_ops_uv_group0);
#line 504
    ldv_state_variable_3 = 2;
  } else {

  }
#line 507
  goto ldv_33099;
  case 25: ;
#line 510
  if (ldv_state_variable_3 == 1) {
#line 512
    xpc_save_remote_msgqueue_pa_uv(xpc_arch_ops_uv_group0, ldvarg10);
#line 514
    ldv_state_variable_3 = 1;
  } else {

  }
#line 517
  if (ldv_state_variable_3 == 2) {
#line 519
    xpc_save_remote_msgqueue_pa_uv(xpc_arch_ops_uv_group0, ldvarg10);
#line 521
    ldv_state_variable_3 = 2;
  } else {

  }
#line 524
  goto ldv_33099;
  case 26: ;
#line 527
  if (ldv_state_variable_3 == 1) {
#line 529
    xpc_get_partition_rsvd_page_pa_uv(ldvarg7, ldvarg9, ldvarg8, ldvarg6);
#line 531
    ldv_state_variable_3 = 1;
  } else {

  }
#line 534
  if (ldv_state_variable_3 == 2) {
#line 536
    xpc_get_partition_rsvd_page_pa_uv(ldvarg7, ldvarg9, ldvarg8, ldvarg6);
#line 538
    ldv_state_variable_3 = 2;
  } else {

  }
#line 541
  goto ldv_33099;
  case 27: ;
#line 544
  if (ldv_state_variable_3 == 1) {
#line 546
    xpc_make_first_contact_uv(xpc_arch_ops_uv_group1);
#line 548
    ldv_state_variable_3 = 1;
  } else {

  }
#line 551
  if (ldv_state_variable_3 == 2) {
#line 553
    xpc_make_first_contact_uv(xpc_arch_ops_uv_group1);
#line 555
    ldv_state_variable_3 = 2;
  } else {

  }
#line 558
  goto ldv_33099;
  case 28: ;
#line 561
  if (ldv_state_variable_3 == 1) {
#line 563
    xpc_get_remote_heartbeat_uv(xpc_arch_ops_uv_group1);
#line 565
    ldv_state_variable_3 = 1;
  } else {

  }
#line 568
  if (ldv_state_variable_3 == 2) {
#line 570
    xpc_get_remote_heartbeat_uv(xpc_arch_ops_uv_group1);
#line 572
    ldv_state_variable_3 = 2;
  } else {

  }
#line 575
  goto ldv_33099;
  case 29: ;
#line 578
  if (ldv_state_variable_3 == 1) {
#line 580
    xpc_process_msg_chctl_flags_uv(xpc_arch_ops_uv_group1, ldvarg5);
#line 582
    ldv_state_variable_3 = 1;
  } else {

  }
#line 585
  if (ldv_state_variable_3 == 2) {
#line 587
    xpc_process_msg_chctl_flags_uv(xpc_arch_ops_uv_group1, ldvarg5);
#line 589
    ldv_state_variable_3 = 2;
  } else {

  }
#line 592
  goto ldv_33099;
  case 30: ;
#line 595
  if (ldv_state_variable_3 == 1) {
#line 597
    xpc_online_heartbeat_uv();
#line 599
    ldv_state_variable_3 = 1;
  } else {

  }
#line 602
  if (ldv_state_variable_3 == 2) {
#line 604
    xpc_online_heartbeat_uv();
#line 606
    ldv_state_variable_3 = 2;
  } else {

  }
#line 609
  goto ldv_33099;
  case 31: ;
#line 612
  if (ldv_state_variable_3 == 1) {
#line 614
    xpc_indicate_partition_disengaged_uv(xpc_arch_ops_uv_group1);
#line 616
    ldv_state_variable_3 = 1;
  } else {

  }
#line 619
  if (ldv_state_variable_3 == 2) {
#line 621
    xpc_indicate_partition_disengaged_uv(xpc_arch_ops_uv_group1);
#line 623
    ldv_state_variable_3 = 2;
  } else {

  }
#line 626
  goto ldv_33099;
  case 32: ;
#line 629
  if (ldv_state_variable_3 == 1) {
#line 631
    xpc_process_activate_IRQ_rcvd_uv();
#line 633
    ldv_state_variable_3 = 1;
  } else {

  }
#line 636
  if (ldv_state_variable_3 == 2) {
#line 638
    xpc_process_activate_IRQ_rcvd_uv();
#line 640
    ldv_state_variable_3 = 2;
  } else {

  }
#line 643
  goto ldv_33099;
  case 33: ;
#line 646
  if (ldv_state_variable_3 == 1) {
#line 648
    xpc_send_chctl_openreply_uv(xpc_arch_ops_uv_group0, ldvarg4);
#line 650
    ldv_state_variable_3 = 1;
  } else {

  }
#line 653
  if (ldv_state_variable_3 == 2) {
#line 655
    xpc_send_chctl_openreply_uv(xpc_arch_ops_uv_group0, ldvarg4);
#line 657
    ldv_state_variable_3 = 2;
  } else {

  }
#line 660
  goto ldv_33099;
  case 34: ;
#line 663
  if (ldv_state_variable_3 == 1) {
#line 665
    xpc_teardown_partitions_uv();
#line 667
    ldv_state_variable_3 = 1;
  } else {

  }
#line 670
  if (ldv_state_variable_3 == 2) {
#line 672
    xpc_teardown_partitions_uv();
#line 674
    ldv_state_variable_3 = 2;
  } else {

  }
#line 677
  goto ldv_33099;
  case 35: ;
#line 680
  if (ldv_state_variable_3 == 1) {
#line 682
    xpc_allow_hb_uv((int )ldvarg3);
#line 684
    ldv_state_variable_3 = 1;
  } else {

  }
#line 687
  if (ldv_state_variable_3 == 2) {
#line 689
    xpc_allow_hb_uv((int )ldvarg3);
#line 691
    ldv_state_variable_3 = 2;
  } else {

  }
#line 694
  goto ldv_33099;
  case 36: ;
#line 697
  if (ldv_state_variable_3 == 1) {
#line 699
    xpc_setup_partitions_uv();
#line 701
    ldv_state_variable_3 = 1;
  } else {

  }
#line 704
  if (ldv_state_variable_3 == 2) {
#line 706
    xpc_setup_partitions_uv();
#line 708
    ldv_state_variable_3 = 2;
  } else {

  }
#line 711
  goto ldv_33099;
  case 37: ;
#line 714
  if (ldv_state_variable_3 == 1) {
#line 716
    xpc_n_of_deliverable_payloads_uv(xpc_arch_ops_uv_group0);
#line 718
    ldv_state_variable_3 = 1;
  } else {

  }
#line 721
  if (ldv_state_variable_3 == 2) {
#line 723
    xpc_n_of_deliverable_payloads_uv(xpc_arch_ops_uv_group0);
#line 725
    ldv_state_variable_3 = 2;
  } else {

  }
#line 728
  goto ldv_33099;
  case 38: ;
#line 731
  if (ldv_state_variable_3 == 1) {
#line 733
    xpc_get_chctl_all_flags_uv(xpc_arch_ops_uv_group1);
#line 735
    ldv_state_variable_3 = 1;
  } else {

  }
#line 738
  if (ldv_state_variable_3 == 2) {
#line 740
    xpc_get_chctl_all_flags_uv(xpc_arch_ops_uv_group1);
#line 742
    ldv_state_variable_3 = 2;
  } else {

  }
#line 745
  goto ldv_33099;
  case 39: ;
#line 748
  if (ldv_state_variable_3 == 1) {
#line 750
    xpc_heartbeat_exit_uv();
#line 752
    ldv_state_variable_3 = 1;
  } else {

  }
#line 755
  if (ldv_state_variable_3 == 2) {
#line 757
    xpc_heartbeat_exit_uv();
#line 759
    ldv_state_variable_3 = 2;
  } else {

  }
#line 762
  goto ldv_33099;
  case 40: ;
#line 765
  if (ldv_state_variable_3 == 1) {
#line 767
    xpc_setup_rsvd_page_uv(xpc_arch_ops_uv_group2);
#line 769
    ldv_state_variable_3 = 1;
  } else {

  }
#line 772
  if (ldv_state_variable_3 == 2) {
#line 774
    xpc_setup_rsvd_page_uv(xpc_arch_ops_uv_group2);
#line 776
    ldv_state_variable_3 = 2;
  } else {

  }
#line 779
  goto ldv_33099;
  case 41: ;
#line 782
  if (ldv_state_variable_3 == 1) {
#line 784
    ldv_probe_3();
#line 786
    ldv_state_variable_3 = 2;
#line 787
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 790
  goto ldv_33099;
  default: 
#line 791
  ldv_stop();
  }
  ldv_33099: ;
#line 795
  return;
}
}
#line 796 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.o.c.prepared"
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
#line 799
  tmp = ldv_err_ptr(error);
#line 799
  return (tmp);
}
}
#line 802 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.o.c.prepared"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 805
  tmp = ldv_ptr_err(ptr);
#line 805
  return (tmp);
}
}
#line 944 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/dscv/ri/43_2a/drivers/misc/sgi-xp/xpc_uv.o.c.prepared"
void *ldv_kmem_cache_alloc_90(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 947
  ldv_check_alloc_flags(flags);
#line 948
  tmp = ldv_undef_ptr();
#line 948
  return (tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 20 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin  =    0;
#line 24 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 27
  if (ldv_spin != 0 && (flags & 16U) != 0U) {
#line 27
    ldv_error();
  } else {

  }
#line 31
  return;
}
}
#line 30
extern struct page *ldv_some_page(void) ;
#line 33 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
struct page *ldv_check_alloc_flags_and_return_some_page(gfp_t flags ) 
{ 
  struct page *tmp ;

  {
#line 36
  if (ldv_spin != 0 && (flags & 16U) != 0U) {
#line 36
    ldv_error();
  } else {

  }
#line 38
  tmp = ldv_some_page();
#line 38
  return (tmp);
}
}
#line 42 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
#line 45
  if (ldv_spin != 0) {
#line 45
    ldv_error();
  } else {

  }
#line 49
  return;
}
}
#line 49 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_lock(void) 
{ 


  {
#line 52
  ldv_spin = 1;
#line 53
  return;
}
}
#line 56 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_unlock(void) 
{ 


  {
#line 59
  ldv_spin = 0;
#line 60
  return;
}
}
#line 63 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3731/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin_trylock(void) 
{ 
  int is_lock ;

  {
#line 68
  is_lock = ldv_undef_int();
#line 70
  if (is_lock != 0) {
#line 73
    return (0);
  } else {
#line 78
    ldv_spin = 1;
#line 80
    return (1);
  }
}
}
