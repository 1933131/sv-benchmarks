extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 37 "include/uapi/linux/types.h"
typedef __u64 __be64;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 432 "include/linux/printk.h"
struct completion;
#line 555 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 103
struct compat_timespec;
#line 104 "include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 104 "include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 104
struct pollfd;
#line 104 "include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 104 "include/linux/bug.h"
union __anonunion____missing_field_name_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};
#line 104 "include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_19 __annonCompField8 ;
};
#line 328 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_29 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField12 ;
   struct __anonstruct____missing_field_name_30 __annonCompField13 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_31 __annonCompField15 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 33 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField17 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField18 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_46 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_47 kgid_t;
#line 36 "include/linux/stat.h"
struct vm_area_struct;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 177
struct rw_semaphore;
#line 178 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 172 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 1121 "include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 238 "include/linux/timer.h"
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 240 "include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 838 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 64 "./arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 172 "./arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 133 "./arch/x86/include/asm/topology.h"
struct pci_bus;
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 19 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField33 ;
   struct __anonstruct____missing_field_name_149 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_152 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_156 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_154 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_151 {
   union __anonunion____missing_field_name_152 __annonCompField37 ;
   union __anonunion____missing_field_name_153 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_157 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_158 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_159 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32
struct kmem_cache;
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_160 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct __anonstruct____missing_field_name_151 __annonCompField42 ;
   union __anonunion____missing_field_name_157 __annonCompField45 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
union __anonunion____missing_field_name_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 53 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_166 __annonCompField47 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_172 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_172 __annonCompField49 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_180 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_181 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_197 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_199 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_199 __annonCompField52 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_198 __annonCompField53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion____missing_field_name_201 __annonCompField54 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 72 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769
struct ftrace_ret_stack;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 650
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 70 "include/linux/resource_ext.h"
struct hotplug_slot;
#line 70 "include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "include/linux/pci.h"
typedef int pci_power_t;
#line 137 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 190 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 247
struct pcie_link_state;
#line 248
struct pci_vpd;
#line 249
struct pci_sriov;
#line 250
struct pci_ats;
#line 251
struct proc_dir_entry;
#line 251
struct pci_driver;
#line 251 "include/linux/pci.h"
union __anonunion____missing_field_name_220 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 251 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned char ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char no_64bit_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   unsigned char irq_managed : 1 ;
   unsigned char has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_220 __annonCompField58 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 440
struct pci_ops;
#line 440
struct msi_controller;
#line 440 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 563 "include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus * , unsigned int  , int  ) ;
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 591 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 605 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 615 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 648 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 19 "include/linux/dmapool.h"
struct dma_pool;
#line 35 "include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 34 "./arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 672 "include/linux/interrupt.h"
struct semaphore {
   raw_spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
#line 142 "include/uapi/linux/if_ether.h"
struct mmu_notifier;
#line 143
struct mmu_notifier_ops;
#line 144 "include/uapi/linux/if_ether.h"
struct mmu_notifier_mm {
   struct hlist_head list ;
   spinlock_t lock ;
};
#line 26 "include/linux/mmu_notifier.h"
struct mmu_notifier_ops {
   void (*release)(struct mmu_notifier * , struct mm_struct * ) ;
   int (*clear_flush_young)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                            unsigned long  ) ;
   int (*test_young)(struct mmu_notifier * , struct mm_struct * , unsigned long  ) ;
   void (*change_pte)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                      pte_t  ) ;
   void (*invalidate_page)(struct mmu_notifier * , struct mm_struct * , unsigned long  ) ;
   void (*invalidate_range_start)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                                  unsigned long  ) ;
   void (*invalidate_range_end)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                                unsigned long  ) ;
   void (*invalidate_range)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                            unsigned long  ) ;
};
#line 170 "include/linux/mmu_notifier.h"
struct mmu_notifier {
   struct hlist_node hlist ;
   struct mmu_notifier_ops  const  *ops ;
};
#line 58 "include/rdma/ib_verbs.h"
struct __anonstruct_global_229 {
   __be64 subnet_prefix ;
   __be64 interface_id ;
};
#line 58 "include/rdma/ib_verbs.h"
union ib_gid {
   u8 raw[16U] ;
   struct __anonstruct_global_229 global ;
};
#line 93
enum rdma_link_layer {
    IB_LINK_LAYER_UNSPECIFIED = 0,
    IB_LINK_LAYER_INFINIBAND = 1,
    IB_LINK_LAYER_ETHERNET = 2
} ;
#line 141
enum ib_atomic_cap {
    IB_ATOMIC_NONE = 0,
    IB_ATOMIC_HCA = 1,
    IB_ATOMIC_GLOB = 2
} ;
#line 159 "include/rdma/ib_verbs.h"
struct __anonstruct_per_transport_caps_230 {
   uint32_t rc_odp_caps ;
   uint32_t uc_odp_caps ;
   uint32_t ud_odp_caps ;
};
#line 159 "include/rdma/ib_verbs.h"
struct ib_odp_caps {
   uint64_t general_caps ;
   struct __anonstruct_per_transport_caps_230 per_transport_caps ;
};
#line 179 "include/rdma/ib_verbs.h"
struct ib_cq_init_attr {
   unsigned int cqe ;
   int comp_vector ;
   u32 flags ;
};
#line 185 "include/rdma/ib_verbs.h"
struct ib_device_attr {
   u64 fw_ver ;
   __be64 sys_image_guid ;
   u64 max_mr_size ;
   u64 page_size_cap ;
   u32 vendor_id ;
   u32 vendor_part_id ;
   u32 hw_ver ;
   int max_qp ;
   int max_qp_wr ;
   int device_cap_flags ;
   int max_sge ;
   int max_sge_rd ;
   int max_cq ;
   int max_cqe ;
   int max_mr ;
   int max_pd ;
   int max_qp_rd_atom ;
   int max_ee_rd_atom ;
   int max_res_rd_atom ;
   int max_qp_init_rd_atom ;
   int max_ee_init_rd_atom ;
   enum ib_atomic_cap atomic_cap ;
   enum ib_atomic_cap masked_atomic_cap ;
   int max_ee ;
   int max_rdd ;
   int max_mw ;
   int max_raw_ipv6_qp ;
   int max_raw_ethy_qp ;
   int max_mcast_grp ;
   int max_mcast_qp_attach ;
   int max_total_mcast_qp_attach ;
   int max_ah ;
   int max_fmr ;
   int max_map_per_fmr ;
   int max_srq ;
   int max_srq_wr ;
   int max_srq_sge ;
   unsigned int max_fast_reg_page_list_len ;
   u16 max_pkeys ;
   u8 local_ca_ack_delay ;
   int sig_prot_cap ;
   int sig_guard_cap ;
   struct ib_odp_caps odp_caps ;
   uint64_t timestamp_mask ;
   uint64_t hca_core_clock ;
};
#line 233
enum ib_mtu {
    IB_MTU_256 = 1,
    IB_MTU_512 = 2,
    IB_MTU_1024 = 3,
    IB_MTU_2048 = 4,
    IB_MTU_4096 = 5
} ;
#line 253
enum ib_port_state {
    IB_PORT_NOP = 0,
    IB_PORT_DOWN = 1,
    IB_PORT_INIT = 2,
    IB_PORT_ARMED = 3,
    IB_PORT_ACTIVE = 4,
    IB_PORT_ACTIVE_DEFER = 5
} ;
#line 316 "include/rdma/ib_verbs.h"
struct ib_protocol_stats {

};
#line 319 "include/rdma/ib_verbs.h"
struct iw_protocol_stats {
   u64 ipInReceives ;
   u64 ipInHdrErrors ;
   u64 ipInTooBigErrors ;
   u64 ipInNoRoutes ;
   u64 ipInAddrErrors ;
   u64 ipInUnknownProtos ;
   u64 ipInTruncatedPkts ;
   u64 ipInDiscards ;
   u64 ipInDelivers ;
   u64 ipOutForwDatagrams ;
   u64 ipOutRequests ;
   u64 ipOutDiscards ;
   u64 ipOutNoRoutes ;
   u64 ipReasmTimeout ;
   u64 ipReasmReqds ;
   u64 ipReasmOKs ;
   u64 ipReasmFails ;
   u64 ipFragOKs ;
   u64 ipFragFails ;
   u64 ipFragCreates ;
   u64 ipInMcastPkts ;
   u64 ipOutMcastPkts ;
   u64 ipInBcastPkts ;
   u64 ipOutBcastPkts ;
   u64 tcpRtoAlgorithm ;
   u64 tcpRtoMin ;
   u64 tcpRtoMax ;
   u64 tcpMaxConn ;
   u64 tcpActiveOpens ;
   u64 tcpPassiveOpens ;
   u64 tcpAttemptFails ;
   u64 tcpEstabResets ;
   u64 tcpCurrEstab ;
   u64 tcpInSegs ;
   u64 tcpOutSegs ;
   u64 tcpRetransSegs ;
   u64 tcpInErrs ;
   u64 tcpOutRsts ;
};
#line 362 "include/rdma/ib_verbs.h"
union rdma_protocol_stats {
   struct ib_protocol_stats ib ;
   struct iw_protocol_stats iw ;
};
#line 367 "include/rdma/ib_verbs.h"
struct ib_port_attr {
   enum ib_port_state state ;
   enum ib_mtu max_mtu ;
   enum ib_mtu active_mtu ;
   int gid_tbl_len ;
   u32 port_cap_flags ;
   u32 max_msg_sz ;
   u32 bad_pkey_cntr ;
   u32 qkey_viol_cntr ;
   u16 pkey_tbl_len ;
   u16 lid ;
   u16 sm_lid ;
   u8 lmc ;
   u8 max_vl_num ;
   u8 sm_sl ;
   u8 subnet_timeout ;
   u8 init_type_reply ;
   u8 active_width ;
   u8 active_speed ;
   u8 phys_state ;
};
#line 430 "include/rdma/ib_verbs.h"
struct ib_device_modify {
   u64 sys_image_guid ;
   char node_desc[64U] ;
};
#line 441 "include/rdma/ib_verbs.h"
struct ib_port_modify {
   u32 set_port_cap_mask ;
   u32 clr_port_cap_mask ;
   u8 init_type ;
};
#line 447
enum ib_event_type {
    IB_EVENT_CQ_ERR = 0,
    IB_EVENT_QP_FATAL = 1,
    IB_EVENT_QP_REQ_ERR = 2,
    IB_EVENT_QP_ACCESS_ERR = 3,
    IB_EVENT_COMM_EST = 4,
    IB_EVENT_SQ_DRAINED = 5,
    IB_EVENT_PATH_MIG = 6,
    IB_EVENT_PATH_MIG_ERR = 7,
    IB_EVENT_DEVICE_FATAL = 8,
    IB_EVENT_PORT_ACTIVE = 9,
    IB_EVENT_PORT_ERR = 10,
    IB_EVENT_LID_CHANGE = 11,
    IB_EVENT_PKEY_CHANGE = 12,
    IB_EVENT_SM_CHANGE = 13,
    IB_EVENT_SRQ_ERR = 14,
    IB_EVENT_SRQ_LIMIT_REACHED = 15,
    IB_EVENT_QP_LAST_WQE_REACHED = 16,
    IB_EVENT_CLIENT_REREGISTER = 17,
    IB_EVENT_GID_CHANGE = 18
} ;
#line 471
struct ib_device;
#line 471
struct ib_cq;
#line 471
struct ib_qp;
#line 471
struct ib_srq;
#line 471 "include/rdma/ib_verbs.h"
union __anonunion_element_231 {
   struct ib_cq *cq ;
   struct ib_qp *qp ;
   struct ib_srq *srq ;
   u8 port_num ;
};
#line 471 "include/rdma/ib_verbs.h"
struct ib_event {
   struct ib_device *device ;
   union __anonunion_element_231 element ;
   enum ib_event_type event ;
};
#line 482 "include/rdma/ib_verbs.h"
struct ib_event_handler {
   struct ib_device *device ;
   void (*handler)(struct ib_event_handler * , struct ib_event * ) ;
   struct list_head list ;
};
#line 488 "include/rdma/ib_verbs.h"
struct ib_global_route {
   union ib_gid dgid ;
   u32 flow_label ;
   u8 sgid_index ;
   u8 hop_limit ;
   u8 traffic_class ;
};
#line 503 "include/rdma/ib_verbs.h"
struct ib_grh {
   __be32 version_tclass_flow ;
   __be16 paylen ;
   u8 next_hdr ;
   u8 hop_limit ;
   union ib_gid sgid ;
   union ib_gid dgid ;
};
#line 562 "include/rdma/ib_verbs.h"
struct ib_mr_init_attr {
   int max_reg_descriptors ;
   u32 flags ;
};
#line 574
enum ib_signature_type {
    IB_SIG_TYPE_NONE = 0,
    IB_SIG_TYPE_T10_DIF = 1
} ;
#line 579
enum ib_t10_dif_bg_type {
    IB_T10DIF_CRC = 0,
    IB_T10DIF_CSUM = 1
} ;
#line 584 "include/rdma/ib_verbs.h"
struct ib_t10_dif_domain {
   enum ib_t10_dif_bg_type bg_type ;
   u16 pi_interval ;
   u16 bg ;
   u16 app_tag ;
   u32 ref_tag ;
   bool ref_remap ;
   bool app_escape ;
   bool ref_escape ;
   u16 apptag_check_mask ;
};
#line 619 "include/rdma/ib_verbs.h"
union __anonunion_sig_232 {
   struct ib_t10_dif_domain dif ;
};
#line 619 "include/rdma/ib_verbs.h"
struct ib_sig_domain {
   enum ib_signature_type sig_type ;
   union __anonunion_sig_232 sig ;
};
#line 632 "include/rdma/ib_verbs.h"
struct ib_sig_attrs {
   u8 check_mask ;
   struct ib_sig_domain mem ;
   struct ib_sig_domain wire ;
};
#line 644
enum ib_sig_err_type {
    IB_SIG_BAD_GUARD = 0,
    IB_SIG_BAD_REFTAG = 1,
    IB_SIG_BAD_APPTAG = 2
} ;
#line 650 "include/rdma/ib_verbs.h"
struct ib_sig_err {
   enum ib_sig_err_type err_type ;
   u32 expected ;
   u32 actual ;
   u64 sig_err_offset ;
   u32 key ;
};
#line 665 "include/rdma/ib_verbs.h"
struct ib_mr_status {
   u32 fail_status ;
   struct ib_sig_err sig_err ;
};
#line 685 "include/rdma/ib_verbs.h"
struct ib_ah_attr {
   struct ib_global_route grh ;
   u16 dlid ;
   u8 sl ;
   u8 src_path_bits ;
   u8 static_rate ;
   u8 ah_flags ;
   u8 port_num ;
   u8 dmac[6U] ;
   u16 vlan_id ;
};
#line 697
enum ib_wc_status {
    IB_WC_SUCCESS = 0,
    IB_WC_LOC_LEN_ERR = 1,
    IB_WC_LOC_QP_OP_ERR = 2,
    IB_WC_LOC_EEC_OP_ERR = 3,
    IB_WC_LOC_PROT_ERR = 4,
    IB_WC_WR_FLUSH_ERR = 5,
    IB_WC_MW_BIND_ERR = 6,
    IB_WC_BAD_RESP_ERR = 7,
    IB_WC_LOC_ACCESS_ERR = 8,
    IB_WC_REM_INV_REQ_ERR = 9,
    IB_WC_REM_ACCESS_ERR = 10,
    IB_WC_REM_OP_ERR = 11,
    IB_WC_RETRY_EXC_ERR = 12,
    IB_WC_RNR_RETRY_EXC_ERR = 13,
    IB_WC_LOC_RDD_VIOL_ERR = 14,
    IB_WC_REM_INV_RD_REQ_ERR = 15,
    IB_WC_REM_ABORT_ERR = 16,
    IB_WC_INV_EECN_ERR = 17,
    IB_WC_INV_EEC_STATE_ERR = 18,
    IB_WC_FATAL_ERR = 19,
    IB_WC_RESP_TIMEOUT_ERR = 20,
    IB_WC_GENERAL_ERR = 21
} ;
#line 724
enum ib_wc_opcode {
    IB_WC_SEND = 0,
    IB_WC_RDMA_WRITE = 1,
    IB_WC_RDMA_READ = 2,
    IB_WC_COMP_SWAP = 3,
    IB_WC_FETCH_ADD = 4,
    IB_WC_BIND_MW = 5,
    IB_WC_LSO = 6,
    IB_WC_LOCAL_INV = 7,
    IB_WC_FAST_REG_MR = 8,
    IB_WC_MASKED_COMP_SWAP = 9,
    IB_WC_MASKED_FETCH_ADD = 10,
    IB_WC_RECV = 128,
    IB_WC_RECV_RDMA_WITH_IMM = 129
} ;
#line 749 "include/rdma/ib_verbs.h"
union __anonunion_ex_233 {
   __be32 imm_data ;
   u32 invalidate_rkey ;
};
#line 749 "include/rdma/ib_verbs.h"
struct ib_wc {
   u64 wr_id ;
   enum ib_wc_status status ;
   enum ib_wc_opcode opcode ;
   u32 vendor_err ;
   u32 byte_len ;
   struct ib_qp *qp ;
   union __anonunion_ex_233 ex ;
   u32 src_qp ;
   int wc_flags ;
   u16 pkey_index ;
   u16 slid ;
   u8 sl ;
   u8 dlid_path_bits ;
   u8 port_num ;
   u8 smac[6U] ;
   u16 vlan_id ;
};
#line 775
enum ib_cq_notify_flags {
    IB_CQ_SOLICITED = 1,
    IB_CQ_NEXT_COMP = 2,
    IB_CQ_SOLICITED_MASK = 3,
    IB_CQ_REPORT_MISSED_EVENTS = 4
} ;
#line 782
enum ib_srq_type {
    IB_SRQT_BASIC = 0,
    IB_SRQT_XRC = 1
} ;
#line 787
enum ib_srq_attr_mask {
    IB_SRQ_MAX_WR = 1,
    IB_SRQ_LIMIT = 2
} ;
#line 792 "include/rdma/ib_verbs.h"
struct ib_srq_attr {
   u32 max_wr ;
   u32 max_sge ;
   u32 srq_limit ;
};
#line 798
struct ib_xrcd;
#line 798 "include/rdma/ib_verbs.h"
struct __anonstruct_xrc_235 {
   struct ib_xrcd *xrcd ;
   struct ib_cq *cq ;
};
#line 798 "include/rdma/ib_verbs.h"
union __anonunion_ext_234 {
   struct __anonstruct_xrc_235 xrc ;
};
#line 798 "include/rdma/ib_verbs.h"
struct ib_srq_init_attr {
   void (*event_handler)(struct ib_event * , void * ) ;
   void *srq_context ;
   struct ib_srq_attr attr ;
   enum ib_srq_type srq_type ;
   union __anonunion_ext_234 ext ;
};
#line 812 "include/rdma/ib_verbs.h"
struct ib_qp_cap {
   u32 max_send_wr ;
   u32 max_recv_wr ;
   u32 max_send_sge ;
   u32 max_recv_sge ;
   u32 max_inline_data ;
};
#line 820
enum ib_sig_type {
    IB_SIGNAL_ALL_WR = 0,
    IB_SIGNAL_REQ_WR = 1
} ;
#line 825
enum ib_qp_type {
    IB_QPT_SMI = 0,
    IB_QPT_GSI = 1,
    IB_QPT_RC = 2,
    IB_QPT_UC = 3,
    IB_QPT_UD = 4,
    IB_QPT_RAW_IPV6 = 5,
    IB_QPT_RAW_ETHERTYPE = 6,
    IB_QPT_RAW_PACKET = 8,
    IB_QPT_XRC_INI = 9,
    IB_QPT_XRC_TGT = 10,
    IB_QPT_MAX = 11,
    IB_QPT_RESERVED1 = 4096,
    IB_QPT_RESERVED2 = 4097,
    IB_QPT_RESERVED3 = 4098,
    IB_QPT_RESERVED4 = 4099,
    IB_QPT_RESERVED5 = 4100,
    IB_QPT_RESERVED6 = 4101,
    IB_QPT_RESERVED7 = 4102,
    IB_QPT_RESERVED8 = 4103,
    IB_QPT_RESERVED9 = 4104,
    IB_QPT_RESERVED10 = 4105
} ;
#line 849
enum ib_qp_create_flags {
    IB_QP_CREATE_IPOIB_UD_LSO = 1,
    IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = 2,
    IB_QP_CREATE_NETIF_QP = 32,
    IB_QP_CREATE_SIGNATURE_EN = 64,
    IB_QP_CREATE_USE_GFP_NOIO = 128,
    IB_QP_CREATE_RESERVED_START = 67108864,
    IB_QP_CREATE_RESERVED_END = (-0x7FFFFFFF-1)
} ;
#line 859 "include/rdma/ib_verbs.h"
struct ib_qp_init_attr {
   void (*event_handler)(struct ib_event * , void * ) ;
   void *qp_context ;
   struct ib_cq *send_cq ;
   struct ib_cq *recv_cq ;
   struct ib_srq *srq ;
   struct ib_xrcd *xrcd ;
   struct ib_qp_cap cap ;
   enum ib_sig_type sq_sig_type ;
   enum ib_qp_type qp_type ;
   enum ib_qp_create_flags create_flags ;
   u8 port_num ;
};
#line 960
enum ib_qp_state {
    IB_QPS_RESET = 0,
    IB_QPS_INIT = 1,
    IB_QPS_RTR = 2,
    IB_QPS_RTS = 3,
    IB_QPS_SQD = 4,
    IB_QPS_SQE = 5,
    IB_QPS_ERR = 6
} ;
#line 970
enum ib_mig_state {
    IB_MIG_MIGRATED = 0,
    IB_MIG_REARM = 1,
    IB_MIG_ARMED = 2
} ;
#line 976
enum ib_mw_type {
    IB_MW_TYPE_1 = 1,
    IB_MW_TYPE_2 = 2
} ;
#line 981 "include/rdma/ib_verbs.h"
struct ib_qp_attr {
   enum ib_qp_state qp_state ;
   enum ib_qp_state cur_qp_state ;
   enum ib_mtu path_mtu ;
   enum ib_mig_state path_mig_state ;
   u32 qkey ;
   u32 rq_psn ;
   u32 sq_psn ;
   u32 dest_qp_num ;
   int qp_access_flags ;
   struct ib_qp_cap cap ;
   struct ib_ah_attr ah_attr ;
   struct ib_ah_attr alt_ah_attr ;
   u16 pkey_index ;
   u16 alt_pkey_index ;
   u8 en_sqd_async_notify ;
   u8 sq_draining ;
   u8 max_rd_atomic ;
   u8 max_dest_rd_atomic ;
   u8 min_rnr_timer ;
   u8 port_num ;
   u8 timeout ;
   u8 retry_cnt ;
   u8 rnr_retry ;
   u8 alt_port_num ;
   u8 alt_timeout ;
   u8 smac[6U] ;
   u8 alt_smac[6U] ;
   u16 vlan_id ;
   u16 alt_vlan_id ;
};
#line 1013
enum ib_wr_opcode {
    IB_WR_RDMA_WRITE = 0,
    IB_WR_RDMA_WRITE_WITH_IMM = 1,
    IB_WR_SEND = 2,
    IB_WR_SEND_WITH_IMM = 3,
    IB_WR_RDMA_READ = 4,
    IB_WR_ATOMIC_CMP_AND_SWP = 5,
    IB_WR_ATOMIC_FETCH_AND_ADD = 6,
    IB_WR_LSO = 7,
    IB_WR_SEND_WITH_INV = 8,
    IB_WR_RDMA_READ_WITH_INV = 9,
    IB_WR_LOCAL_INV = 10,
    IB_WR_FAST_REG_MR = 11,
    IB_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
    IB_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
    IB_WR_BIND_MW = 14,
    IB_WR_REG_SIG_MR = 15,
    IB_WR_RESERVED1 = 240,
    IB_WR_RESERVED2 = 241,
    IB_WR_RESERVED3 = 242,
    IB_WR_RESERVED4 = 243,
    IB_WR_RESERVED5 = 244,
    IB_WR_RESERVED6 = 245,
    IB_WR_RESERVED7 = 246,
    IB_WR_RESERVED8 = 247,
    IB_WR_RESERVED9 = 248,
    IB_WR_RESERVED10 = 249
} ;
#line 1052 "include/rdma/ib_verbs.h"
struct ib_sge {
   u64 addr ;
   u32 length ;
   u32 lkey ;
};
#line 1063 "include/rdma/ib_verbs.h"
struct ib_fast_reg_page_list {
   struct ib_device *device ;
   u64 *page_list ;
   unsigned int max_page_list_len ;
};
#line 1069
struct ib_mr;
#line 1069 "include/rdma/ib_verbs.h"
struct ib_mw_bind_info {
   struct ib_mr *mr ;
   u64 addr ;
   u64 length ;
   int mw_access_flags ;
};
#line 1086 "include/rdma/ib_verbs.h"
union __anonunion_ex_236 {
   __be32 imm_data ;
   u32 invalidate_rkey ;
};
#line 1086 "include/rdma/ib_verbs.h"
struct __anonstruct_rdma_238 {
   u64 remote_addr ;
   u32 rkey ;
};
#line 1086 "include/rdma/ib_verbs.h"
struct __anonstruct_atomic_239 {
   u64 remote_addr ;
   u64 compare_add ;
   u64 swap ;
   u64 compare_add_mask ;
   u64 swap_mask ;
   u32 rkey ;
};
#line 1086
struct ib_ah;
#line 1086 "include/rdma/ib_verbs.h"
struct __anonstruct_ud_240 {
   struct ib_ah *ah ;
   void *header ;
   int hlen ;
   int mss ;
   u32 remote_qpn ;
   u32 remote_qkey ;
   u16 pkey_index ;
   u8 port_num ;
};
#line 1086 "include/rdma/ib_verbs.h"
struct __anonstruct_fast_reg_241 {
   u64 iova_start ;
   struct ib_fast_reg_page_list *page_list ;
   unsigned int page_shift ;
   unsigned int page_list_len ;
   u32 length ;
   int access_flags ;
   u32 rkey ;
};
#line 1086
struct ib_mw;
#line 1086 "include/rdma/ib_verbs.h"
struct __anonstruct_bind_mw_242 {
   struct ib_mw *mw ;
   u32 rkey ;
   struct ib_mw_bind_info bind_info ;
};
#line 1086 "include/rdma/ib_verbs.h"
struct __anonstruct_sig_handover_243 {
   struct ib_sig_attrs *sig_attrs ;
   struct ib_mr *sig_mr ;
   int access_flags ;
   struct ib_sge *prot ;
};
#line 1086 "include/rdma/ib_verbs.h"
union __anonunion_wr_237 {
   struct __anonstruct_rdma_238 rdma ;
   struct __anonstruct_atomic_239 atomic ;
   struct __anonstruct_ud_240 ud ;
   struct __anonstruct_fast_reg_241 fast_reg ;
   struct __anonstruct_bind_mw_242 bind_mw ;
   struct __anonstruct_sig_handover_243 sig_handover ;
};
#line 1086 "include/rdma/ib_verbs.h"
struct ib_send_wr {
   struct ib_send_wr *next ;
   u64 wr_id ;
   struct ib_sge *sg_list ;
   int num_sge ;
   enum ib_wr_opcode opcode ;
   int send_flags ;
   union __anonunion_ex_236 ex ;
   union __anonunion_wr_237 wr ;
   u32 xrc_remote_srq_num ;
};
#line 1145 "include/rdma/ib_verbs.h"
struct ib_recv_wr {
   struct ib_recv_wr *next ;
   u64 wr_id ;
   struct ib_sge *sg_list ;
   int num_sge ;
};
#line 1162 "include/rdma/ib_verbs.h"
struct ib_phys_buf {
   u64 addr ;
   u64 size ;
};
#line 1167
struct ib_pd;
#line 1167 "include/rdma/ib_verbs.h"
struct ib_mr_attr {
   struct ib_pd *pd ;
   u64 device_virt_addr ;
   u64 size ;
   int mr_access_flags ;
   u32 lkey ;
   u32 rkey ;
};
#line 1183 "include/rdma/ib_verbs.h"
struct ib_mw_bind {
   u64 wr_id ;
   int send_flags ;
   struct ib_mw_bind_info bind_info ;
};
#line 1195 "include/rdma/ib_verbs.h"
struct ib_fmr_attr {
   int max_pages ;
   int max_maps ;
   u8 page_shift ;
};
#line 1201
struct ib_umem;
#line 1202 "include/rdma/ib_verbs.h"
struct ib_ucontext {
   struct ib_device *device ;
   struct list_head pd_list ;
   struct list_head mr_list ;
   struct list_head mw_list ;
   struct list_head cq_list ;
   struct list_head qp_list ;
   struct list_head srq_list ;
   struct list_head ah_list ;
   struct list_head xrcd_list ;
   struct list_head rule_list ;
   int closing ;
   struct pid *tgid ;
   struct rb_root umem_tree ;
   struct rw_semaphore umem_rwsem ;
   void (*invalidate_range)(struct ib_umem * , unsigned long  , unsigned long  ) ;
   struct mmu_notifier mn ;
   atomic_t notifier_count ;
   struct list_head no_private_counters ;
   int odp_mrs_count ;
};
#line 1234 "include/rdma/ib_verbs.h"
struct ib_uobject {
   u64 user_handle ;
   struct ib_ucontext *context ;
   void *object ;
   struct list_head list ;
   int id ;
   struct kref ref ;
   struct rw_semaphore mutex ;
   int live ;
};
#line 1246 "include/rdma/ib_verbs.h"
struct ib_udata {
   void const   *inbuf ;
   void *outbuf ;
   size_t inlen ;
   size_t outlen ;
};
#line 1253 "include/rdma/ib_verbs.h"
struct ib_pd {
   struct ib_device *device ;
   struct ib_uobject *uobject ;
   atomic_t usecnt ;
};
#line 1259 "include/rdma/ib_verbs.h"
struct ib_xrcd {
   struct ib_device *device ;
   atomic_t usecnt ;
   struct inode *inode ;
   struct mutex tgt_qp_mutex ;
   struct list_head tgt_qp_list ;
};
#line 1268 "include/rdma/ib_verbs.h"
struct ib_ah {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_uobject *uobject ;
};
#line 1276 "include/rdma/ib_verbs.h"
struct ib_cq {
   struct ib_device *device ;
   struct ib_uobject *uobject ;
   void (*comp_handler)(struct ib_cq * , void * ) ;
   void (*event_handler)(struct ib_event * , void * ) ;
   void *cq_context ;
   int cqe ;
   atomic_t usecnt ;
};
#line 1286 "include/rdma/ib_verbs.h"
struct __anonstruct_xrc_245 {
   struct ib_xrcd *xrcd ;
   struct ib_cq *cq ;
   u32 srq_num ;
};
#line 1286 "include/rdma/ib_verbs.h"
union __anonunion_ext_244 {
   struct __anonstruct_xrc_245 xrc ;
};
#line 1286 "include/rdma/ib_verbs.h"
struct ib_srq {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_uobject *uobject ;
   void (*event_handler)(struct ib_event * , void * ) ;
   void *srq_context ;
   enum ib_srq_type srq_type ;
   atomic_t usecnt ;
   union __anonunion_ext_244 ext ;
};
#line 1304 "include/rdma/ib_verbs.h"
struct ib_qp {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_cq *send_cq ;
   struct ib_cq *recv_cq ;
   struct ib_srq *srq ;
   struct ib_xrcd *xrcd ;
   struct list_head xrcd_list ;
   atomic_t usecnt ;
   struct list_head open_list ;
   struct ib_qp *real_qp ;
   struct ib_uobject *uobject ;
   void (*event_handler)(struct ib_event * , void * ) ;
   void *qp_context ;
   u32 qp_num ;
   enum ib_qp_type qp_type ;
};
#line 1323 "include/rdma/ib_verbs.h"
struct ib_mr {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_uobject *uobject ;
   u32 lkey ;
   u32 rkey ;
   atomic_t usecnt ;
};
#line 1332 "include/rdma/ib_verbs.h"
struct ib_mw {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_uobject *uobject ;
   u32 rkey ;
   enum ib_mw_type type ;
};
#line 1340 "include/rdma/ib_verbs.h"
struct ib_fmr {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct list_head list ;
   u32 lkey ;
   u32 rkey ;
};
#line 1348
enum ib_flow_attr_type {
    IB_FLOW_ATTR_NORMAL = 0,
    IB_FLOW_ATTR_ALL_DEFAULT = 1,
    IB_FLOW_ATTR_MC_DEFAULT = 2,
    IB_FLOW_ATTR_SNIFFER = 3
} ;
#line 1450 "include/rdma/ib_verbs.h"
struct ib_flow_attr {
   enum ib_flow_attr_type type ;
   u16 size ;
   u16 priority ;
   u32 flags ;
   u8 num_of_specs ;
   u8 port ;
};
#line 1459 "include/rdma/ib_verbs.h"
struct ib_flow {
   struct ib_qp *qp ;
   struct ib_uobject *uobject ;
};
#line 1468
struct ib_mad_hdr;
#line 1482
struct ib_pkey_cache;
#line 1482
struct ib_gid_cache;
#line 1482 "include/rdma/ib_verbs.h"
struct ib_cache {
   rwlock_t lock ;
   struct ib_event_handler event_handler ;
   struct ib_pkey_cache **pkey_cache ;
   struct ib_gid_cache **gid_cache ;
   u8 *lmc_cache ;
};
#line 1494 "include/rdma/ib_verbs.h"
struct ib_dma_mapping_ops {
   int (*mapping_error)(struct ib_device * , u64  ) ;
   u64 (*map_single)(struct ib_device * , void * , size_t  , enum dma_data_direction  ) ;
   void (*unmap_single)(struct ib_device * , u64  , size_t  , enum dma_data_direction  ) ;
   u64 (*map_page)(struct ib_device * , struct page * , unsigned long  , size_t  ,
                   enum dma_data_direction  ) ;
   void (*unmap_page)(struct ib_device * , u64  , size_t  , enum dma_data_direction  ) ;
   int (*map_sg)(struct ib_device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*unmap_sg)(struct ib_device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_single_for_cpu)(struct ib_device * , u64  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct ib_device * , u64  , size_t  , enum dma_data_direction  ) ;
   void *(*alloc_coherent)(struct ib_device * , size_t  , u64 * , gfp_t  ) ;
   void (*free_coherent)(struct ib_device * , size_t  , void * , u64  ) ;
};
#line 1531
struct iw_cm_verbs;
#line 1532 "include/rdma/ib_verbs.h"
struct ib_port_immutable {
   int pkey_tbl_len ;
   int gid_tbl_len ;
   u32 core_cap_flags ;
   u32 max_mad_size ;
};
#line 1542
enum ldv_23857 {
    IB_DEV_UNINITIALIZED = 0,
    IB_DEV_REGISTERED = 1,
    IB_DEV_UNREGISTERED = 2
} ;
#line 1548 "include/rdma/ib_verbs.h"
struct ib_device {
   struct device *dma_device ;
   char name[64U] ;
   struct list_head event_handler_list ;
   spinlock_t event_handler_lock ;
   spinlock_t client_data_lock ;
   struct list_head core_list ;
   struct list_head client_data_list ;
   struct ib_cache cache ;
   struct ib_port_immutable *port_immutable ;
   int num_comp_vectors ;
   struct iw_cm_verbs *iwcm ;
   int (*get_protocol_stats)(struct ib_device * , union rdma_protocol_stats * ) ;
   int (*query_device)(struct ib_device * , struct ib_device_attr * , struct ib_udata * ) ;
   int (*query_port)(struct ib_device * , u8  , struct ib_port_attr * ) ;
   enum rdma_link_layer (*get_link_layer)(struct ib_device * , u8  ) ;
   int (*query_gid)(struct ib_device * , u8  , int  , union ib_gid * ) ;
   int (*query_pkey)(struct ib_device * , u8  , u16  , u16 * ) ;
   int (*modify_device)(struct ib_device * , int  , struct ib_device_modify * ) ;
   int (*modify_port)(struct ib_device * , u8  , int  , struct ib_port_modify * ) ;
   struct ib_ucontext *(*alloc_ucontext)(struct ib_device * , struct ib_udata * ) ;
   int (*dealloc_ucontext)(struct ib_ucontext * ) ;
   int (*mmap)(struct ib_ucontext * , struct vm_area_struct * ) ;
   struct ib_pd *(*alloc_pd)(struct ib_device * , struct ib_ucontext * , struct ib_udata * ) ;
   int (*dealloc_pd)(struct ib_pd * ) ;
   struct ib_ah *(*create_ah)(struct ib_pd * , struct ib_ah_attr * ) ;
   int (*modify_ah)(struct ib_ah * , struct ib_ah_attr * ) ;
   int (*query_ah)(struct ib_ah * , struct ib_ah_attr * ) ;
   int (*destroy_ah)(struct ib_ah * ) ;
   struct ib_srq *(*create_srq)(struct ib_pd * , struct ib_srq_init_attr * , struct ib_udata * ) ;
   int (*modify_srq)(struct ib_srq * , struct ib_srq_attr * , enum ib_srq_attr_mask  ,
                     struct ib_udata * ) ;
   int (*query_srq)(struct ib_srq * , struct ib_srq_attr * ) ;
   int (*destroy_srq)(struct ib_srq * ) ;
   int (*post_srq_recv)(struct ib_srq * , struct ib_recv_wr * , struct ib_recv_wr ** ) ;
   struct ib_qp *(*create_qp)(struct ib_pd * , struct ib_qp_init_attr * , struct ib_udata * ) ;
   int (*modify_qp)(struct ib_qp * , struct ib_qp_attr * , int  , struct ib_udata * ) ;
   int (*query_qp)(struct ib_qp * , struct ib_qp_attr * , int  , struct ib_qp_init_attr * ) ;
   int (*destroy_qp)(struct ib_qp * ) ;
   int (*post_send)(struct ib_qp * , struct ib_send_wr * , struct ib_send_wr ** ) ;
   int (*post_recv)(struct ib_qp * , struct ib_recv_wr * , struct ib_recv_wr ** ) ;
   struct ib_cq *(*create_cq)(struct ib_device * , struct ib_cq_init_attr  const  * ,
                              struct ib_ucontext * , struct ib_udata * ) ;
   int (*modify_cq)(struct ib_cq * , u16  , u16  ) ;
   int (*destroy_cq)(struct ib_cq * ) ;
   int (*resize_cq)(struct ib_cq * , int  , struct ib_udata * ) ;
   int (*poll_cq)(struct ib_cq * , int  , struct ib_wc * ) ;
   int (*peek_cq)(struct ib_cq * , int  ) ;
   int (*req_notify_cq)(struct ib_cq * , enum ib_cq_notify_flags  ) ;
   int (*req_ncomp_notif)(struct ib_cq * , int  ) ;
   struct ib_mr *(*get_dma_mr)(struct ib_pd * , int  ) ;
   struct ib_mr *(*reg_phys_mr)(struct ib_pd * , struct ib_phys_buf * , int  , int  ,
                                u64 * ) ;
   struct ib_mr *(*reg_user_mr)(struct ib_pd * , u64  , u64  , u64  , int  , struct ib_udata * ) ;
   int (*rereg_user_mr)(struct ib_mr * , int  , u64  , u64  , u64  , int  , struct ib_pd * ,
                        struct ib_udata * ) ;
   int (*query_mr)(struct ib_mr * , struct ib_mr_attr * ) ;
   int (*dereg_mr)(struct ib_mr * ) ;
   int (*destroy_mr)(struct ib_mr * ) ;
   struct ib_mr *(*create_mr)(struct ib_pd * , struct ib_mr_init_attr * ) ;
   struct ib_mr *(*alloc_fast_reg_mr)(struct ib_pd * , int  ) ;
   struct ib_fast_reg_page_list *(*alloc_fast_reg_page_list)(struct ib_device * ,
                                                             int  ) ;
   void (*free_fast_reg_page_list)(struct ib_fast_reg_page_list * ) ;
   int (*rereg_phys_mr)(struct ib_mr * , int  , struct ib_pd * , struct ib_phys_buf * ,
                        int  , int  , u64 * ) ;
   struct ib_mw *(*alloc_mw)(struct ib_pd * , enum ib_mw_type  ) ;
   int (*bind_mw)(struct ib_qp * , struct ib_mw * , struct ib_mw_bind * ) ;
   int (*dealloc_mw)(struct ib_mw * ) ;
   struct ib_fmr *(*alloc_fmr)(struct ib_pd * , int  , struct ib_fmr_attr * ) ;
   int (*map_phys_fmr)(struct ib_fmr * , u64 * , int  , u64  ) ;
   int (*unmap_fmr)(struct list_head * ) ;
   int (*dealloc_fmr)(struct ib_fmr * ) ;
   int (*attach_mcast)(struct ib_qp * , union ib_gid * , u16  ) ;
   int (*detach_mcast)(struct ib_qp * , union ib_gid * , u16  ) ;
   int (*process_mad)(struct ib_device * , int  , u8  , struct ib_wc  const  * , struct ib_grh  const  * ,
                      struct ib_mad_hdr  const  * , size_t  , struct ib_mad_hdr * ,
                      size_t * , u16 * ) ;
   struct ib_xrcd *(*alloc_xrcd)(struct ib_device * , struct ib_ucontext * , struct ib_udata * ) ;
   int (*dealloc_xrcd)(struct ib_xrcd * ) ;
   struct ib_flow *(*create_flow)(struct ib_qp * , struct ib_flow_attr * , int  ) ;
   int (*destroy_flow)(struct ib_flow * ) ;
   int (*check_mr_status)(struct ib_mr * , u32  , struct ib_mr_status * ) ;
   struct ib_dma_mapping_ops *dma_ops ;
   struct module *owner ;
   struct device dev ;
   struct kobject *ports_parent ;
   struct list_head port_list ;
   enum ldv_23857 reg_state ;
   int uverbs_abi_ver ;
   u64 uverbs_cmd_mask ;
   u64 uverbs_ex_cmd_mask ;
   char node_desc[64U] ;
   __be64 node_guid ;
   u32 local_dma_lkey ;
   u8 node_type ;
   u8 phys_port_cnt ;
   int (*get_port_immutable)(struct ib_device * , u8  , struct ib_port_immutable * ) ;
};
#line 266 "include/rdma/ib_pack.h"
struct mthca_buf_list {
   void *buf ;
   dma_addr_t mapping ;
};
#line 56 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_uar {
   unsigned long pfn ;
   int index ;
};
#line 70
struct mthca_mtt;
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_mr {
   struct ib_mr ibmr ;
   struct ib_umem *umem ;
   struct mthca_mtt *mtt ;
};
#line 96 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_pd {
   struct ib_pd ibpd ;
   u32 pd_num ;
   atomic_t sqp_count ;
   struct mthca_mr ntmr ;
   int privileged ;
};
#line 104
struct mthca_dev;
#line 104 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_eq {
   struct mthca_dev *dev ;
   int eqn ;
   u32 eqn_mask ;
   u32 cons_index ;
   u16 msi_x_vector ;
   u16 msi_x_entry ;
   int have_irq ;
   int nent ;
   struct mthca_buf_list *page_list ;
   struct mthca_mr mr ;
   char irq_name[64U] ;
};
#line 129 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_doorbell.h"
struct mthca_cmd_context;
#line 129 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_doorbell.h"
struct mthca_cmd {
   struct dma_pool *pool ;
   struct mutex hcr_mutex ;
   struct semaphore poll_sem ;
   struct semaphore event_sem ;
   int max_cmds ;
   spinlock_t context_lock ;
   int free_head ;
   struct mthca_cmd_context *context ;
   u16 token_mask ;
   u32 flags ;
   void *dbell_map ;
   u16 dbell_offsets[8U] ;
};
#line 134 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_limits {
   int num_ports ;
   int vl_cap ;
   int mtu_cap ;
   int gid_table_len ;
   int pkey_table_len ;
   int local_ca_ack_delay ;
   int num_uars ;
   int max_sg ;
   int num_qps ;
   int max_wqes ;
   int max_desc_sz ;
   int max_qp_init_rdma ;
   int reserved_qps ;
   int num_srqs ;
   int max_srq_wqes ;
   int max_srq_sge ;
   int reserved_srqs ;
   int num_eecs ;
   int reserved_eecs ;
   int num_cqs ;
   int max_cqes ;
   int reserved_cqs ;
   int num_eqs ;
   int reserved_eqs ;
   int num_mpts ;
   int num_mtt_segs ;
   int mtt_seg_size ;
   int fmr_reserved_mtts ;
   int reserved_mtts ;
   int reserved_mrws ;
   int reserved_uars ;
   int num_mgms ;
   int num_amgms ;
   int reserved_mcgs ;
   int num_pds ;
   int reserved_pds ;
   u32 page_size_cap ;
   u32 flags ;
   u16 stat_rate_support ;
   u8 port_width_cap ;
};
#line 177 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_alloc {
   u32 last ;
   u32 top ;
   u32 max ;
   u32 mask ;
   spinlock_t lock ;
   unsigned long *table ;
};
#line 186 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct __anonstruct_page_list_250 {
   void **page ;
   int used ;
};
#line 186 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_array {
   struct __anonstruct_page_list_250 *page_list ;
};
#line 193 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_uar_table {
   struct mthca_alloc alloc ;
   u64 uarc_base ;
   int uarc_size ;
};
#line 199 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_pd_table {
   struct mthca_alloc alloc ;
};
#line 203 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_buddy {
   unsigned long **bits ;
   int *num_free ;
   int max_order ;
   spinlock_t lock ;
};
#line 210
struct mthca_icm_table;
#line 210 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct __anonstruct_tavor_fmr_251 {
   void *mpt_base ;
   void *mtt_base ;
   struct mthca_buddy mtt_buddy ;
};
#line 210 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_mr_table {
   struct mthca_alloc mpt_alloc ;
   struct mthca_buddy mtt_buddy ;
   struct mthca_buddy *fmr_mtt_buddy ;
   u64 mtt_base ;
   u64 mpt_base ;
   struct mthca_icm_table *mtt_table ;
   struct mthca_icm_table *mpt_table ;
   struct __anonstruct_tavor_fmr_251 tavor_fmr ;
};
#line 225 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_eq_table {
   struct mthca_alloc alloc ;
   void *clr_int ;
   u32 clr_mask ;
   u32 arm_mask ;
   struct mthca_eq eq[3U] ;
   u64 icm_virt ;
   struct page *icm_page ;
   dma_addr_t icm_dma ;
   int have_irq ;
   u8 inta_pin ;
};
#line 238 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_cq_table {
   struct mthca_alloc alloc ;
   spinlock_t lock ;
   struct mthca_array cq ;
   struct mthca_icm_table *table ;
};
#line 245 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_srq_table {
   struct mthca_alloc alloc ;
   spinlock_t lock ;
   struct mthca_array srq ;
   struct mthca_icm_table *table ;
};
#line 252 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_qp_table {
   struct mthca_alloc alloc ;
   u32 rdb_base ;
   int rdb_shift ;
   int sqp_start ;
   spinlock_t lock ;
   struct mthca_array qp ;
   struct mthca_icm_table *qp_table ;
   struct mthca_icm_table *eqp_table ;
   struct mthca_icm_table *rdb_table ;
};
#line 264 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_av_table {
   struct dma_pool *pool ;
   int num_ddr_avs ;
   u64 ddr_av_base ;
   void *av_map ;
   struct mthca_alloc alloc ;
};
#line 272 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_mcg_table {
   struct mutex mutex ;
   struct mthca_alloc alloc ;
   struct mthca_icm_table *table ;
};
#line 278 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_catas_err {
   u64 addr ;
   u32 *map ;
   u32 size ;
   struct timer_list timer ;
   struct list_head list ;
};
#line 288 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct __anonstruct_tavor_253 {
   u64 fw_start ;
   u64 fw_end ;
};
#line 288
struct mthca_icm;
#line 288 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct __anonstruct_arbel_254 {
   u64 clr_int_base ;
   u64 eq_arm_base ;
   u64 eq_set_ci_base ;
   struct mthca_icm *fw_icm ;
   struct mthca_icm *aux_icm ;
   u16 fw_pages ;
};
#line 288 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
union __anonunion_fw_252 {
   struct __anonstruct_tavor_253 tavor ;
   struct __anonstruct_arbel_254 arbel ;
};
#line 288 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct __anonstruct_tavor_256 {
   void *ecr_base ;
};
#line 288 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct __anonstruct_arbel_257 {
   void *eq_arm ;
   void *eq_set_ci_base ;
};
#line 288 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
union __anonunion_eq_regs_255 {
   struct __anonstruct_tavor_256 tavor ;
   struct __anonstruct_arbel_257 arbel ;
};
#line 288
struct mthca_db_table;
#line 288
struct ib_mad_agent;
#line 288 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_dev {
   struct ib_device ib_dev ;
   struct pci_dev *pdev ;
   int hca_type ;
   unsigned long mthca_flags ;
   unsigned long device_cap_flags ;
   u32 rev_id ;
   char board_id[64U] ;
   u64 fw_ver ;
   union __anonunion_fw_252 fw ;
   u64 ddr_start ;
   u64 ddr_end ;
   struct mutex cap_mask_mutex ;
   void *hcr ;
   void *kar ;
   void *clr_base ;
   union __anonunion_eq_regs_255 eq_regs ;
   struct mthca_cmd cmd ;
   struct mthca_limits limits ;
   struct mthca_uar_table uar_table ;
   struct mthca_pd_table pd_table ;
   struct mthca_mr_table mr_table ;
   struct mthca_eq_table eq_table ;
   struct mthca_cq_table cq_table ;
   struct mthca_srq_table srq_table ;
   struct mthca_qp_table qp_table ;
   struct mthca_av_table av_table ;
   struct mthca_mcg_table mcg_table ;
   struct mthca_catas_err catas_err ;
   struct mthca_uar driver_uar ;
   struct mthca_db_table *db_tab ;
   struct mthca_pd driver_pd ;
   struct mthca_mr driver_mr ;
   struct ib_mad_agent *send_agent[2U][2U] ;
   struct ib_ah *sm_ah[2U] ;
   spinlock_t sm_lock ;
   u8 rate[2U] ;
   bool active ;
};
#line 119 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct __anonstruct_tavor_259 {
   int max_avs ;
};
#line 119 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct __anonstruct_arbel_260 {
   int resize_srq ;
   int max_pbl_sz ;
   u8 bmme_flags ;
   u32 reserved_lkey ;
   int lam_required ;
   u64 max_icm_sz ;
};
#line 119 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
union __anonunion_hca_258 {
   struct __anonstruct_tavor_259 tavor ;
   struct __anonstruct_arbel_260 arbel ;
};
#line 119 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_dev_lim {
   int max_srq_sz ;
   int max_qp_sz ;
   int reserved_qps ;
   int max_qps ;
   int reserved_srqs ;
   int max_srqs ;
   int reserved_eecs ;
   int max_eecs ;
   int max_cq_sz ;
   int reserved_cqs ;
   int max_cqs ;
   int max_mpts ;
   int reserved_eqs ;
   int max_eqs ;
   int reserved_mtts ;
   int max_mrw_sz ;
   int reserved_mrws ;
   int max_mtt_seg ;
   int max_requester_per_qp ;
   int max_responder_per_qp ;
   int max_rdma_global ;
   int local_ca_ack_delay ;
   int max_mtu ;
   int max_port_width ;
   int max_vl ;
   int num_ports ;
   int max_gids ;
   u16 stat_rate_support ;
   int max_pkeys ;
   u32 flags ;
   int reserved_uars ;
   int uar_size ;
   int min_page_sz ;
   int max_sg ;
   int max_desc_sz ;
   int max_qp_per_mcg ;
   int reserved_mgms ;
   int max_mcgs ;
   int reserved_pds ;
   int max_pds ;
   int reserved_rdds ;
   int max_rdds ;
   int eec_entry_sz ;
   int qpc_entry_sz ;
   int eeec_entry_sz ;
   int eqpc_entry_sz ;
   int eqc_entry_sz ;
   int cqc_entry_sz ;
   int srq_entry_sz ;
   int uar_scratch_entry_sz ;
   int mpt_entry_sz ;
   union __anonunion_hca_258 hca ;
};
#line 186 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_adapter {
   u32 vendor_id ;
   u32 device_id ;
   u32 revision_id ;
   char board_id[64U] ;
   u8 inta_pin ;
};
#line 194 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_init_hca_param {
   u64 qpc_base ;
   u64 eec_base ;
   u64 srqc_base ;
   u64 cqc_base ;
   u64 eqpc_base ;
   u64 eeec_base ;
   u64 eqc_base ;
   u64 rdb_base ;
   u64 mc_base ;
   u64 mpt_base ;
   u64 mtt_base ;
   u64 uar_scratch_base ;
   u64 uarc_base ;
   u16 log_mc_entry_sz ;
   u16 mc_hash_sz ;
   u8 log_num_qps ;
   u8 log_num_eecs ;
   u8 log_num_srqs ;
   u8 log_num_cqs ;
   u8 log_num_eqs ;
   u8 log_mc_table_sz ;
   u8 mtt_seg_sz ;
   u8 log_mpt_sz ;
   u8 log_uar_sz ;
   u8 log_uarc_sz ;
};
#line 324 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_profile {
   int num_qp ;
   int rdb_per_qp ;
   int num_srq ;
   int num_cq ;
   int num_mcg ;
   int num_mpt ;
   int num_mtt ;
   int num_udav ;
   int num_uar ;
   int uarc_size ;
   int fmr_reserved_mtts ;
};
#line 57 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_icm {
   struct list_head chunk_list ;
   int refcount ;
};
#line 62 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_icm_table {
   u64 virt ;
   int num_icm ;
   int num_obj ;
   int obj_size ;
   int lowmem ;
   int coherent ;
   struct mutex mutex ;
   struct mthca_icm *icm[0U] ;
};
#line 137 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_db_page {
   unsigned long used[8U] ;
   __be64 *db_rec ;
   dma_addr_t mapping ;
};
#line 143 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_db_table {
   int npages ;
   int max_group1 ;
   int min_group2 ;
   struct mthca_db_page *page ;
   struct mutex mutex ;
};
#line 886 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
struct __anonstruct_mthca_hca_table_262 {
   u64 latest_fw ;
   u32 flags ;
};
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
typedef bool ldv_func_ret_type;
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
typedef bool ldv_func_ret_type___0;
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
typedef bool ldv_func_ret_type___1;
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 249 "include/uapi/rdma/ib_user_mad.h"
struct ib_mad_hdr {
   u8 base_version ;
   u8 mgmt_class ;
   u8 class_version ;
   u8 method ;
   __be16 status ;
   __be16 class_specific ;
   __be64 tid ;
   __be16 attr_id ;
   __be16 resv ;
   __be32 attr_mod ;
};
#line 185 "include/rdma/ib_mad.h"
struct ib_mad {
   struct ib_mad_hdr mad_hdr ;
   u8 data[232U] ;
};
#line 190 "include/rdma/ib_mad.h"
struct opa_mad {
   struct ib_mad_hdr mad_hdr ;
   u8 data[2024U] ;
};
#line 242 "include/rdma/ib_mad.h"
struct ib_mad_send_buf {
   struct ib_mad_send_buf *next ;
   void *mad ;
   struct ib_mad_agent *mad_agent ;
   struct ib_ah *ah ;
   void *context[2U] ;
   int hdr_len ;
   int data_len ;
   int seg_count ;
   int seg_size ;
   int seg_rmpp_size ;
   int timeout_ms ;
   int retries ;
};
#line 327
struct ib_mad_send_wc;
#line 328
struct ib_mad_recv_wc;
#line 371 "include/rdma/ib_mad.h"
struct ib_mad_agent {
   struct ib_device *device ;
   struct ib_qp *qp ;
   struct ib_mr *mr ;
   void (*recv_handler)(struct ib_mad_agent * , struct ib_mad_recv_wc * ) ;
   void (*send_handler)(struct ib_mad_agent * , struct ib_mad_send_wc * ) ;
   void (*snoop_handler)(struct ib_mad_agent * , struct ib_mad_send_buf * , struct ib_mad_send_wc * ) ;
   void *context ;
   u32 hi_tid ;
   u32 flags ;
   u8 port_num ;
   u8 rmpp_version ;
};
#line 401 "include/rdma/ib_mad.h"
struct ib_mad_send_wc {
   struct ib_mad_send_buf *send_buf ;
   enum ib_wc_status status ;
   u32 vendor_err ;
};
#line 414 "include/rdma/ib_mad.h"
union __anonunion____missing_field_name_239 {
   struct ib_mad *mad ;
   struct opa_mad *opa_mad ;
};
#line 414 "include/rdma/ib_mad.h"
struct ib_mad_recv_buf {
   struct list_head list ;
   struct ib_grh *grh ;
   union __anonunion____missing_field_name_239 __annonCompField60 ;
};
#line 431 "include/rdma/ib_mad.h"
struct ib_mad_recv_wc {
   struct ib_wc *wc ;
   struct ib_mad_recv_buf recv_buf ;
   struct list_head rmpp_list ;
   int mad_len ;
   size_t mad_seg_size ;
};
#line 651 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_mailbox {
   dma_addr_t dma ;
   void *buf ;
};
#line 222 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_init_ib_param {
   int port_width ;
   int vl_cap ;
   int mtu_cap ;
   u16 gid_cap ;
   u16 pkey_cap ;
   int set_guid0 ;
   u64 guid0 ;
   int set_node_guid ;
   u64 node_guid ;
   int set_si_guid ;
   u64 si_guid ;
};
#line 236 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_set_ib_param {
   int set_si_guid ;
   int reset_qkey_viol ;
   u64 si_guid ;
   u32 cap_mask ;
};
#line 330 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_icm_chunk {
   struct list_head list ;
   int npages ;
   int nsg ;
   struct scatterlist mem[5U] ;
};
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_icm_iter {
   struct mthca_icm *icm ;
   struct mthca_icm_chunk *chunk ;
   int page_idx ;
};
#line 268 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_cmd_context {
   struct completion done ;
   int result ;
   int next ;
   u64 out_param ;
   u16 token ;
   u8 status ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_profile.c"
struct mthca_resource {
   u64 size ;
   u64 start ;
   int type ;
   int num ;
   int log_num ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 234 "include/linux/printk.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 51 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
union mthca_buf {
   struct mthca_buf_list direct ;
   struct mthca_buf_list *page_list ;
};
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.c"
struct __anonstruct_251 {
   void **page ;
   int used ;
};
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.c"
struct __anonstruct_253 {
   void **page ;
   int used ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.o.c.prepared"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 331 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_eq_context {
   __be32 flags ;
   __be64 start ;
   __be32 logsize_usrpage ;
   __be32 tavor_pd ;
   u8 reserved1[3U] ;
   u8 intr ;
   __be32 arbel_pd ;
   __be32 lkey ;
   u32 reserved2[2U] ;
   __be32 consumer_index ;
   __be32 producer_index ;
   u32 reserved3[4U] ;
};
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
struct __anonstruct_comp_262 {
   __be32 cqn ;
};
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
struct __anonstruct_cmd_263 {
   u16 reserved1 ;
   __be16 token ;
   u32 reserved2 ;
   u8 reserved3[3U] ;
   u8 status ;
   __be64 out_param ;
};
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
struct __anonstruct_qp_264 {
   __be32 qpn ;
};
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
struct __anonstruct_srq_265 {
   __be32 srqn ;
};
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
struct __anonstruct_cq_err_266 {
   __be32 cqn ;
   u32 reserved1 ;
   u8 reserved2[3U] ;
   u8 syndrome ;
};
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
struct __anonstruct_port_change_267 {
   u32 reserved1[2U] ;
   __be32 port ;
};
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
union __anonunion_event_261 {
   u32 raw[6U] ;
   struct __anonstruct_comp_262 comp ;
   struct __anonstruct_cmd_263 cmd ;
   struct __anonstruct_qp_264 qp ;
   struct __anonstruct_srq_265 srq ;
   struct __anonstruct_cq_err_266 cq_err ;
   struct __anonstruct_port_change_267 port_change ;
};
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
struct mthca_eqe {
   u8 reserved1 ;
   u8 type ;
   u8 reserved2 ;
   u8 subtype ;
   union __anonunion_event_261 event ;
   u8 reserved3[3U] ;
   u8 owner ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 12 "include/linux/wait.h"
struct __wait_queue;
#line 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 61 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_user_db_table;
#line 62 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_ucontext {
   struct ib_ucontext ibucontext ;
   struct mthca_uar uar ;
   struct mthca_user_db_table *db_tab ;
   int reg_mr_warned ;
};
#line 134 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_cq_buf {
   union mthca_buf queue ;
   struct mthca_mr mr ;
   int is_direct ;
};
#line 190
enum ldv_23839 {
    CQ_RESIZE_ALLOC = 0,
    CQ_RESIZE_READY = 1,
    CQ_RESIZE_SWAPPED = 2
} ;
#line 196 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_cq_resize {
   struct mthca_cq_buf buf ;
   int cqe ;
   enum ldv_23839 state ;
};
#line 200 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_cq {
   struct ib_cq ibcq ;
   spinlock_t lock ;
   int refcount ;
   int cqn ;
   u32 cons_index ;
   struct mthca_cq_buf buf ;
   struct mthca_cq_resize *resize_buf ;
   int is_kernel ;
   int set_ci_db_index ;
   __be32 *set_ci_db ;
   int arm_db_index ;
   __be32 *arm_db ;
   int arm_sn ;
   wait_queue_head_t wait ;
   struct mutex mutex ;
};
#line 221 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_srq {
   struct ib_srq ibsrq ;
   spinlock_t lock ;
   int refcount ;
   int srqn ;
   int max ;
   int max_gs ;
   int wqe_shift ;
   int first_free ;
   int last_free ;
   u16 counter ;
   int db_index ;
   __be32 *db ;
   void *last ;
   int is_direct ;
   u64 *wrid ;
   union mthca_buf queue ;
   struct mthca_mr mr ;
   wait_queue_head_t wait ;
   struct mutex mutex ;
};
#line 245 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_wq {
   spinlock_t lock ;
   int max ;
   unsigned int next_ind ;
   unsigned int last_comp ;
   unsigned int head ;
   unsigned int tail ;
   void *last ;
   int max_gs ;
   int wqe_shift ;
   int db_index ;
   __be32 *db ;
};
#line 260 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_qp {
   struct ib_qp ibqp ;
   int refcount ;
   u32 qpn ;
   int is_direct ;
   u8 port ;
   u8 alt_port ;
   u8 transport ;
   u8 state ;
   u8 atomic_rd_en ;
   u8 resp_depth ;
   struct mthca_mr mr ;
   struct mthca_wq rq ;
   struct mthca_wq sq ;
   enum ib_sig_type sq_policy ;
   int send_wqe_offset ;
   int max_inline_data ;
   u64 *wrid ;
   union mthca_buf queue ;
   wait_queue_head_t wait ;
   struct mutex mutex ;
};
#line 151 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
enum mthca_db_type {
    MTHCA_DB_TYPE_INVALID = 0,
    MTHCA_DB_TYPE_CQ_SET_CI = 1,
    MTHCA_DB_TYPE_CQ_ARM = 2,
    MTHCA_DB_TYPE_SQ = 3,
    MTHCA_DB_TYPE_RQ = 4,
    MTHCA_DB_TYPE_SRQ = 5,
    MTHCA_DB_TYPE_GROUP_SEP = 7
} ;
#line 190 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_cq_context {
   __be32 flags ;
   __be64 start ;
   __be32 logsize_usrpage ;
   __be32 error_eqn ;
   __be32 comp_eqn ;
   __be32 pd ;
   __be32 lkey ;
   __be32 last_notified_index ;
   __be32 solicit_producer_index ;
   __be32 consumer_index ;
   __be32 producer_index ;
   __be32 cqn ;
   __be32 ci_db ;
   __be32 state_db ;
   u32 reserved ;
};
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
struct mthca_cqe {
   __be32 my_qpn ;
   __be32 my_ee ;
   __be32 rqpn ;
   u8 sl_ipok ;
   u8 g_mlpath ;
   __be16 rlid ;
   __be32 imm_etype_pkey_eec ;
   __be32 byte_cnt ;
   __be32 wqe ;
   u8 opcode ;
   u8 is_send ;
   u8 reserved ;
   u8 owner ;
};
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
struct mthca_err_cqe {
   __be32 my_qpn ;
   u32 reserved1[3U] ;
   u8 syndrome ;
   u8 vendor_err ;
   __be16 db_cnt ;
   u32 reserved2 ;
   __be32 wqe ;
   u8 opcode ;
   u8 reserved3[2U] ;
   u8 owner ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 78 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_mpt_entry;
#line 78 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct __anonstruct_tavor_240 {
   struct mthca_mpt_entry *mpt ;
   u64 *mtts ;
};
#line 78 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct __anonstruct_arbel_241 {
   struct mthca_mpt_entry *mpt ;
   __be64 *mtts ;
   dma_addr_t dma_handle ;
};
#line 78 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
union __anonunion_mem_239 {
   struct __anonstruct_tavor_240 tavor ;
   struct __anonstruct_arbel_241 arbel ;
};
#line 78 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_fmr {
   struct ib_fmr ibmr ;
   struct ib_fmr_attr attr ;
   struct mthca_mtt *mtt ;
   int maps ;
   union __anonunion_mem_239 mem ;
};
#line 178 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_mtt {
   struct mthca_buddy *buddy ;
   int order ;
   u32 first_seg ;
};
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
struct mthca_mpt_entry {
   __be32 flags ;
   __be32 page_size ;
   __be32 key ;
   __be32 pd ;
   __be64 start ;
   __be64 length ;
   __be32 lkey ;
   __be32 window_count ;
   __be32 window_count_limit ;
   __be64 mtt_seg ;
   __be32 mtt_sz ;
   u32 reserved[2U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 520 "include/rdma/ib_verbs.h"
enum ib_rate {
    IB_RATE_PORT_CURRENT = 0,
    IB_RATE_2_5_GBPS = 2,
    IB_RATE_5_GBPS = 5,
    IB_RATE_10_GBPS = 3,
    IB_RATE_20_GBPS = 6,
    IB_RATE_30_GBPS = 4,
    IB_RATE_40_GBPS = 7,
    IB_RATE_60_GBPS = 8,
    IB_RATE_80_GBPS = 9,
    IB_RATE_120_GBPS = 10,
    IB_RATE_14_GBPS = 11,
    IB_RATE_56_GBPS = 12,
    IB_RATE_112_GBPS = 13,
    IB_RATE_168_GBPS = 14,
    IB_RATE_25_GBPS = 15,
    IB_RATE_100_GBPS = 16,
    IB_RATE_200_GBPS = 17,
    IB_RATE_300_GBPS = 18
} ;
#line 932
enum ib_qp_attr_mask {
    IB_QP_STATE = 1,
    IB_QP_CUR_STATE = 2,
    IB_QP_EN_SQD_ASYNC_NOTIFY = 4,
    IB_QP_ACCESS_FLAGS = 8,
    IB_QP_PKEY_INDEX = 16,
    IB_QP_PORT = 32,
    IB_QP_QKEY = 64,
    IB_QP_AV = 128,
    IB_QP_PATH_MTU = 256,
    IB_QP_TIMEOUT = 512,
    IB_QP_RETRY_CNT = 1024,
    IB_QP_RNR_RETRY = 2048,
    IB_QP_RQ_PSN = 4096,
    IB_QP_MAX_QP_RD_ATOMIC = 8192,
    IB_QP_ALT_PATH = 16384,
    IB_QP_MIN_RNR_TIMER = 32768,
    IB_QP_SQ_PSN = 65536,
    IB_QP_MAX_DEST_RD_ATOMIC = 131072,
    IB_QP_PATH_MIG_STATE = 262144,
    IB_QP_CAP = 524288,
    IB_QP_DEST_QPN = 1048576,
    IB_QP_SMAC = 2097152,
    IB_QP_ALT_SMAC = 4194304,
    IB_QP_VID = 8388608,
    IB_QP_ALT_VID = 16777216
} ;
#line 147 "include/rdma/ib_pack.h"
struct ib_unpacked_lrh {
   u8 virtual_lane ;
   u8 link_version ;
   u8 service_level ;
   u8 link_next_header ;
   __be16 destination_lid ;
   __be16 packet_length ;
   __be16 source_lid ;
};
#line 187 "include/rdma/ib_pack.h"
struct ib_unpacked_grh {
   u8 ip_version ;
   u8 traffic_class ;
   __be32 flow_label ;
   __be16 payload_length ;
   u8 next_header ;
   u8 hop_limit ;
   union ib_gid source_gid ;
   union ib_gid destination_gid ;
};
#line 198 "include/rdma/ib_pack.h"
struct ib_unpacked_bth {
   u8 opcode ;
   u8 solicited_event ;
   u8 mig_req ;
   u8 pad_count ;
   u8 transport_header_version ;
   __be16 pkey ;
   __be32 destination_qpn ;
   u8 ack_req ;
   __be32 psn ;
};
#line 210 "include/rdma/ib_pack.h"
struct ib_unpacked_deth {
   __be32 qkey ;
   __be32 source_qpn ;
};
#line 215 "include/rdma/ib_pack.h"
struct ib_unpacked_eth {
   u8 dmac_h[4U] ;
   u8 dmac_l[2U] ;
   u8 smac_h[2U] ;
   u8 smac_l[4U] ;
   __be16 type ;
};
#line 223 "include/rdma/ib_pack.h"
struct ib_unpacked_vlan {
   __be16 tag ;
   __be16 type ;
};
#line 228 "include/rdma/ib_pack.h"
struct ib_ud_header {
   int lrh_present ;
   struct ib_unpacked_lrh lrh ;
   int eth_present ;
   struct ib_unpacked_eth eth ;
   int vlan_present ;
   struct ib_unpacked_vlan vlan ;
   int grh_present ;
   struct ib_unpacked_grh grh ;
   struct ib_unpacked_bth bth ;
   struct ib_unpacked_deth deth ;
   int immediate_present ;
   __be32 immediate_data ;
};
#line 118 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_av;
#line 119
enum mthca_ah_type {
    MTHCA_AH_ON_HCA = 0,
    MTHCA_AH_PCI_POOL = 1,
    MTHCA_AH_KMALLOC = 2
} ;
#line 125 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_ah {
   struct ib_ah ibah ;
   enum mthca_ah_type type ;
   u32 key ;
   struct mthca_av *av ;
   dma_addr_t avdma ;
};
#line 287 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_sqp {
   struct mthca_qp qp ;
   int pkey_index ;
   u32 qkey ;
   u32 send_psn ;
   struct ib_ud_header ud_header ;
   int header_buf_size ;
   void *header_buf ;
   dma_addr_t header_dma ;
};
#line 196 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_next_seg {
   __be32 nda_op ;
   __be32 ee_nds ;
   __be32 flags ;
   __be32 imm ;
};
#line 63 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_tavor_ud_seg {
   u32 reserved1 ;
   __be32 lkey ;
   __be64 av_addr ;
   u32 reserved2[4U] ;
   __be32 dqpn ;
   __be32 qkey ;
   u32 reserved3[2U] ;
};
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_arbel_ud_seg {
   __be32 av[8U] ;
   __be32 dqpn ;
   __be32 qkey ;
   u32 reserved[2U] ;
};
#line 89 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_raddr_seg {
   __be64 raddr ;
   __be32 rkey ;
   u32 reserved ;
};
#line 95 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_atomic_seg {
   __be64 swap_add ;
   __be64 compare ;
};
#line 100 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_data_seg {
   __be32 byte_count ;
   __be32 lkey ;
   __be64 addr ;
};
#line 106 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_mlx_seg {
   __be32 nda_op ;
   __be32 nds ;
   __be32 flags ;
   __be16 rlid ;
   __be16 vcrc ;
};
#line 182 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_qp_path {
   __be32 port_pkey ;
   u8 rnr_retry ;
   u8 g_mylmc ;
   __be16 rlid ;
   u8 ackto ;
   u8 mgid_index ;
   u8 static_rate ;
   u8 hop_limit ;
   __be32 sl_tclass_flowlabel ;
   u8 rgid[16U] ;
};
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
struct mthca_qp_context {
   __be32 flags ;
   __be32 tavor_sched_queue ;
   u8 mtu_msgmax ;
   u8 rq_size_stride ;
   u8 sq_size_stride ;
   u8 rlkey_arbel_sched_queue ;
   __be32 usr_page ;
   __be32 local_qpn ;
   __be32 remote_qpn ;
   u32 reserved1[2U] ;
   struct mthca_qp_path pri_path ;
   struct mthca_qp_path alt_path ;
   __be32 rdd ;
   __be32 pd ;
   __be32 wqe_base ;
   __be32 wqe_lkey ;
   __be32 params1 ;
   __be32 reserved2 ;
   __be32 next_send_psn ;
   __be32 cqn_snd ;
   __be32 snd_wqe_base_l ;
   __be32 snd_db_index ;
   __be32 last_acked_psn ;
   __be32 ssn ;
   __be32 params2 ;
   __be32 rnr_nextrecvpsn ;
   __be32 ra_buff_indx ;
   __be32 cqn_rcv ;
   __be32 rcv_wqe_base_l ;
   __be32 rcv_db_index ;
   __be32 qkey ;
   __be32 srqn ;
   __be32 rmsn ;
   __be16 rq_wqe_counter ;
   __be16 sq_wqe_counter ;
   u32 reserved3[18U] ;
};
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
struct mthca_qp_param {
   __be32 opt_param_mask ;
   u32 reserved1 ;
   struct mthca_qp_context context ;
   u32 reserved2[62U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 610 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_av {
   __be32 port_pd ;
   u8 reserved1 ;
   u8 g_slid ;
   __be16 dlid ;
   u8 reserved2 ;
   u8 gid_index ;
   u8 msg_sr ;
   u8 hop_limit ;
   __be32 sl_tclass_flowlabel ;
   __be32 dgid[4U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 324 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_mgm {
   __be32 next_gid_index ;
   u32 reserved[3U] ;
   u8 gid[16U] ;
   __be32 qp[56U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 289 "include/rdma/ib_verbs.h"
enum ib_port_width {
    IB_WIDTH_1X = 1,
    IB_WIDTH_4X = 2,
    IB_WIDTH_8X = 4,
    IB_WIDTH_12X = 8
} ;
#line 450 "include/rdma/ib_mad.h"
struct ib_mad_reg_req {
   u8 mgmt_class ;
   u8 mgmt_class_version ;
   u8 oui[3U] ;
   unsigned long method_mask[2U] ;
};
#line 708 "include/rdma/ib_mad.h"
struct ib_smp {
   u8 base_version ;
   u8 mgmt_class ;
   u8 class_version ;
   u8 method ;
   __be16 status ;
   u8 hop_ptr ;
   u8 hop_cnt ;
   __be64 tid ;
   __be16 attr_id ;
   __be16 resv ;
   __be32 attr_mod ;
   __be64 mkey ;
   __be16 dr_slid ;
   __be16 dr_dlid ;
   u8 reserved[28U] ;
   u8 data[64U] ;
   u8 initial_path[64U] ;
   u8 return_path[64U] ;
};
#line 65 "include/rdma/ib_smi.h"
struct ib_port_info {
   __be64 mkey ;
   __be64 gid_prefix ;
   __be16 lid ;
   __be16 sm_lid ;
   __be32 cap_mask ;
   __be16 diag_code ;
   __be16 mkey_lease_period ;
   u8 local_port_num ;
   u8 link_width_enabled ;
   u8 link_width_supported ;
   u8 link_width_active ;
   u8 linkspeed_portstate ;
   u8 portphysstate_linkdown ;
   u8 mkeyprot_resv_lmc ;
   u8 linkspeedactive_enabled ;
   u8 neighbormtu_mastersmsl ;
   u8 vlcap_inittype ;
   u8 vl_high_limit ;
   u8 vl_arb_high_cap ;
   u8 vl_arb_low_cap ;
   u8 inittypereply_mtucap ;
   u8 vlstallcnt_hoqlife ;
   u8 operationalvl_pei_peo_fpi_fpo ;
   __be16 mkey_violations ;
   __be16 pkey_violations ;
   __be16 qkey_violations ;
   u8 guid_cap ;
   u8 clientrereg_resv_subnetto ;
   u8 resv_resptimevalue ;
   u8 localphyerrors_overrunerrors ;
   __be16 max_credit_hint ;
   u8 resv ;
   u8 link_roundtrip_latency[3U] ;
};
#line 107 "include/linux/types.h"
typedef __u16 uint16_t;
#line 98 "./arch/x86/include/asm/desc_defs.h"
enum page_cache_mode {
    _PAGE_CACHE_MODE_WB = 0,
    _PAGE_CACHE_MODE_WC = 1,
    _PAGE_CACHE_MODE_UC_MINUS = 2,
    _PAGE_CACHE_MODE_UC = 3,
    _PAGE_CACHE_MODE_WT = 4,
    _PAGE_CACHE_MODE_WP = 5,
    _PAGE_CACHE_MODE_NUM = 8
} ;
#line 716 "./arch/x86/include/asm/paravirt_types.h"
struct cpuinfo_x86;
#line 81 "./arch/x86/include/asm/processor.h"
struct cpuinfo_x86 {
   __u8 x86 ;
   __u8 x86_vendor ;
   __u8 x86_model ;
   __u8 x86_mask ;
   int x86_tlbsize ;
   __u8 x86_virt_bits ;
   __u8 x86_phys_bits ;
   __u8 x86_coreid_bits ;
   __u32 extended_cpuid_level ;
   int cpuid_level ;
   __u32 x86_capability[14U] ;
   char x86_vendor_id[16U] ;
   char x86_model_id[64U] ;
   int x86_cache_size ;
   int x86_cache_alignment ;
   int x86_cache_max_rmid ;
   int x86_cache_occ_scale ;
   int x86_power ;
   unsigned long loops_per_jiffy ;
   u16 x86_max_cores ;
   u16 apicid ;
   u16 initial_apicid ;
   u16 x86_clflush_size ;
   u16 booted_cores ;
   u16 phys_proc_id ;
   u16 cpu_core_id ;
   u8 compute_unit_id ;
   u16 cpu_index ;
   u32 microcode ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 127 "include/rdma/ib_smi.h"
struct ib_umem_odp;
#line 128 "include/rdma/ib_smi.h"
struct ib_umem {
   struct ib_ucontext *context ;
   size_t length ;
   unsigned long address ;
   int page_size ;
   int writable ;
   int hugetlb ;
   struct work_struct work ;
   struct pid *pid ;
   struct mm_struct *mm ;
   unsigned long diff ;
   struct ib_umem_odp *odp_data ;
   struct sg_table sg_head ;
   int nmap ;
   int npages ;
};
#line 324 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_alloc_ucontext_resp {
   __u32 qp_tab_size ;
   __u32 uarc_size ;
};
#line 62 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_user.h"
struct mthca_reg_mr {
   __u32 mr_attrs ;
   __u32 reserved ;
};
#line 72 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_user.h"
struct mthca_create_cq {
   __u32 lkey ;
   __u32 pdn ;
   __u64 arm_db_page ;
   __u64 set_db_page ;
   __u32 arm_db_index ;
   __u32 set_db_index ;
};
#line 86 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_user.h"
struct mthca_resize_cq {
   __u32 lkey ;
   __u32 reserved ;
};
#line 91 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_user.h"
struct mthca_create_srq {
   __u32 lkey ;
   __u32 db_index ;
   __u64 db_page ;
};
#line 102 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_user.h"
struct mthca_create_qp {
   __u32 lkey ;
   __u32 reserved ;
   __u64 sq_db_page ;
   __u64 rq_db_page ;
   __u32 sq_db_index ;
   __u32 rq_db_index ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 329 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct __anonstruct_page_253 {
   u64 uvirt ;
   struct scatterlist mem ;
   int refcount ;
};
#line 329 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_user_db_table {
   struct mutex mutex ;
   struct __anonstruct_page_253 page[0U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 134 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_tavor_srq_context {
   __be64 wqe_base_ds ;
   __be32 state_pd ;
   __be32 lkey ;
   __be32 uar ;
   __be16 limit_watermark ;
   __be16 wqe_cnt ;
   u32 reserved[2U] ;
};
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
struct mthca_arbel_srq_context {
   __be32 state_logsize_srqn ;
   __be32 lkey ;
   __be32 db_index ;
   __be32 logstride_usrpage ;
   __be64 wqe_base ;
   __be32 eq_pd ;
   __be16 limit_watermark ;
   __be16 wqe_cnt ;
   u16 reserved1 ;
   __be16 wqe_counter ;
   u32 reserved2[3U] ;
};
#line 243 "include/linux/timer.h"
enum hrtimer_restart;
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
typedef int ldv_func_ret_type___4;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 479 "./arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x ) 
{ 
  int bitpos ;

  {
#line 481
  bitpos = -1;
#line 487
  __asm__  ("bsrq %1,%q0": "+r" (bitpos): "rm" (x));
#line 490
  return (bitpos + 1);
}
}
#line 174 "include/linux/bitops.h"
__inline static unsigned int fls_long(unsigned long l ) 
{ 
  int tmp___0 ;

  {
#line 178
  tmp___0 = fls64((__u64 )l);
#line 178
  return ((unsigned int )tmp___0);
}
}
#line 61 "include/linux/log2.h"
__inline static unsigned long __roundup_pow_of_two(unsigned long n ) 
{ 
  unsigned int tmp ;

  {
#line 63
  tmp = fls_long(n - 1UL);
#line 63
  return (1UL << (int )tmp);
}
}
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *memset(void * , int  , size_t  ) ;
#line 138 "include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 174
extern void mutex_unlock(struct mutex * ) ;
#line 429 "include/linux/workqueue.h"
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 433
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 439
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 443
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 452
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 455
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
#line 181 "./arch/x86/include/asm/io.h"
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 190 "./arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ 
  void *tmp ;

  {
#line 192
  tmp = ioremap_nocache(offset, size);
#line 192
  return (tmp);
}
}
#line 195
extern void iounmap(void volatile   * ) ;
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
struct work_struct *ldv_work_struct_1_0  ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
struct work_struct *ldv_work_struct_1_1  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int pci_counter  ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
struct work_struct *ldv_work_struct_1_3  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_work_1_3  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_state_variable_6  ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_state_variable_0  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_state_variable_5  ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_state_variable_2  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_work_1_1  ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_work_1_2  ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
struct work_struct *ldv_work_struct_1_2  ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_timer_state_2  =    0;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
struct pci_dev *mthca_driver_group1  ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_state_variable_3  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
struct timer_list *ldv_timer_list_2  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ref_cnt  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_work_1_0  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_state_variable_1  ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_state_variable_7  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_state_variable_4  ;
#line 48
void work_init_1(void) ;
#line 50
void call_and_disable_all_1(int state ) ;
#line 53
void activate_work_1(struct work_struct *work , int state ) ;
#line 54
void ldv_pci_driver_7(void) ;
#line 832 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 835
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 836
    return ((char const   *)dev->init_name);
  } else {

  }
#line 838
  tmp = kobject_name(& dev->kobj);
#line 838
  return (tmp);
}
}
#line 863 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 865
  return ((void *)dev->driver_data);
}
}
#line 868 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 870
  dev->driver_data = data;
#line 871
  return;
}
}
#line 1075
extern void dev_printk(char const   * , struct device  const  * , char const   * 
                       , ...) ;
#line 1084
extern void dev_err(struct device  const  * , char const   *  , ...) ;
#line 1086
extern void dev_warn(struct device  const  * , char const   *  , ...) ;
#line 1090
extern void _dev_info(struct device  const  * , char const   *  , ...) ;
#line 833 "include/linux/pci.h"
extern int pci_find_capability(struct pci_dev * , int  ) ;
#line 949
extern int pci_enable_device(struct pci_dev * ) ;
#line 966
extern void pci_disable_device(struct pci_dev * ) ;
#line 969
extern void pci_set_master(struct pci_dev * ) ;
#line 986
extern int pcix_get_max_mmrbc(struct pci_dev * ) ;
#line 988
extern int pcix_set_mmrbc(struct pci_dev * , int  ) ;
#line 990
extern int pcie_set_readrq(struct pci_dev * , int  ) ;
#line 1092
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 1094
extern void pci_release_regions(struct pci_dev * ) ;
#line 1140
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1144
int ldv___pci_register_driver_10(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) ;
#line 1153
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1156
void ldv_pci_unregister_driver_11(struct pci_driver *ldv_func_arg1 ) ;
#line 1213
extern void pci_disable_msix(struct pci_dev * ) ;
#line 1224
extern int pci_enable_msix_range(struct pci_dev * , struct msix_entry * , int  , int  ) ;
#line 1226 "include/linux/pci.h"
__inline static int pci_enable_msix_exact(struct pci_dev *dev , struct msix_entry *entries ,
                                          int nvec ) 
{ 
  int rc ;
  int tmp ;

  {
#line 1229
  tmp = pci_enable_msix_range(dev, entries, nvec, nvec);
#line 1229
  rc = tmp;
#line 1230
  if (rc < 0) {
#line 1231
    return (rc);
  } else {

  }
#line 1232
  return (0);
}
}
#line 60 "./arch/x86/include/asm/dma-mapping.h"
extern int dma_supported(struct device * , u64  ) ;
#line 61
extern int dma_set_mask(struct device * , u64  ) ;
#line 101 "include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 103
  tmp = dma_supported(dev, mask);
#line 103
  if (tmp == 0) {
#line 104
    return (-5);
  } else {

  }
#line 105
  dev->coherent_dma_mask = mask;
#line 106
  return (0);
}
}
#line 151 "include/linux/dma-mapping.h"
__inline static unsigned int dma_set_max_seg_size(struct device *dev , unsigned int size ) 
{ 


  {
#line 154
  if ((unsigned long )dev->dma_parms != (unsigned long )((struct device_dma_parameters *)0)) {
#line 155
    (dev->dma_parms)->max_segment_size = size;
#line 156
    return (0U);
  } else {
#line 158
    return (4294967291U);
  }
}
}
#line 192 "include/linux/dma-mapping.h"
__inline static int dma_get_cache_alignment(void) 
{ 


  {
#line 197
  return (1);
}
}
#line 113 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 115
  tmp = dma_set_mask(& dev->dev, mask);
#line 115
  return (tmp);
}
}
#line 118 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 120
  tmp = dma_set_coherent_mask(& dev->dev, mask);
#line 120
  return (tmp);
}
}
#line 1468 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1470
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1470
  return (tmp);
}
}
#line 1473 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
#line 1475
  dev_set_drvdata(& pdev->dev, data);
#line 1476
  return;
}
}
#line 1481 "include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
#line 1483
  tmp = dev_name(& pdev->dev);
#line 1483
  return (tmp);
}
}
#line 1715 "include/linux/pci.h"
__inline static int pci_pcie_cap(struct pci_dev *dev ) 
{ 


  {
#line 1717
  return ((int )dev->pcie_cap);
}
}
#line 1726 "include/linux/pci.h"
__inline static bool pci_is_pcie(struct pci_dev *dev ) 
{ 
  int tmp ;

  {
#line 1728
  tmp = pci_pcie_cap(dev);
#line 1728
  return (tmp != 0);
}
}
#line 1768 "include/rdma/ib_verbs.h"
extern struct ib_device *ib_alloc_device(size_t  ) ;
#line 1769
extern void ib_dealloc_device(struct ib_device * ) ;
#line 287 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mutex mthca_device_mutex ;
#line 364
int mthca_debug_level ;
#line 412
int mthca_reset(struct mthca_dev *mdev ) ;
#line 430
int mthca_init_uar_table(struct mthca_dev *dev ) ;
#line 431
int mthca_init_pd_table(struct mthca_dev *dev ) ;
#line 432
int mthca_init_mr_table(struct mthca_dev *dev ) ;
#line 433
int mthca_init_eq_table(struct mthca_dev *dev ) ;
#line 434
int mthca_init_cq_table(struct mthca_dev *dev ) ;
#line 435
int mthca_init_srq_table(struct mthca_dev *dev ) ;
#line 436
int mthca_init_qp_table(struct mthca_dev *dev ) ;
#line 437
int mthca_init_av_table(struct mthca_dev *dev ) ;
#line 438
int mthca_init_mcg_table(struct mthca_dev *dev ) ;
#line 440
void mthca_cleanup_uar_table(struct mthca_dev *dev ) ;
#line 441
void mthca_cleanup_pd_table(struct mthca_dev *dev ) ;
#line 442
void mthca_cleanup_mr_table(struct mthca_dev *dev ) ;
#line 443
void mthca_cleanup_eq_table(struct mthca_dev *dev ) ;
#line 444
void mthca_cleanup_cq_table(struct mthca_dev *dev ) ;
#line 445
void mthca_cleanup_srq_table(struct mthca_dev *dev ) ;
#line 446
void mthca_cleanup_qp_table(struct mthca_dev *dev ) ;
#line 447
void mthca_cleanup_av_table(struct mthca_dev *dev ) ;
#line 448
void mthca_cleanup_mcg_table(struct mthca_dev *dev ) ;
#line 450
int mthca_register_device(struct mthca_dev *dev ) ;
#line 451
void mthca_unregister_device(struct mthca_dev *dev ) ;
#line 455
int __mthca_restart_one(struct pci_dev *pdev ) ;
#line 456
int mthca_catas_init(void) ;
#line 457
void mthca_catas_cleanup(void) ;
#line 459
int mthca_uar_alloc(struct mthca_dev *dev , struct mthca_uar *uar ) ;
#line 460
void mthca_uar_free(struct mthca_dev *dev , struct mthca_uar *uar ) ;
#line 462
int mthca_pd_alloc(struct mthca_dev *dev , int privileged , struct mthca_pd *pd ) ;
#line 463
void mthca_pd_free(struct mthca_dev *dev , struct mthca_pd *pd ) ;
#line 491
int mthca_map_eq_icm(struct mthca_dev *dev , u64 icm_virt ) ;
#line 492
void mthca_unmap_eq_icm(struct mthca_dev *dev ) ;
#line 518
int mthca_max_srq_sge(struct mthca_dev *dev ) ;
#line 584
int mthca_create_agents(struct mthca_dev *dev ) ;
#line 585
void mthca_free_agents(struct mthca_dev *dev ) ;
#line 592 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
__inline static int mthca_is_memfree(struct mthca_dev *dev ) 
{ 


  {
#line 594
  return ((int )dev->mthca_flags & 64);
}
}
#line 244 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
int mthca_cmd_init(struct mthca_dev *dev ) ;
#line 245
void mthca_cmd_cleanup(struct mthca_dev *dev ) ;
#line 246
int mthca_cmd_use_events(struct mthca_dev *dev ) ;
#line 247
void mthca_cmd_use_polling(struct mthca_dev *dev ) ;
#line 255
int mthca_SYS_EN(struct mthca_dev *dev ) ;
#line 256
int mthca_SYS_DIS(struct mthca_dev *dev ) ;
#line 257
int mthca_MAP_FA(struct mthca_dev *dev , struct mthca_icm *icm ) ;
#line 258
int mthca_UNMAP_FA(struct mthca_dev *dev ) ;
#line 259
int mthca_RUN_FW(struct mthca_dev *dev ) ;
#line 260
int mthca_QUERY_FW(struct mthca_dev *dev ) ;
#line 261
int mthca_ENABLE_LAM(struct mthca_dev *dev ) ;
#line 262
int mthca_DISABLE_LAM(struct mthca_dev *dev ) ;
#line 263
int mthca_QUERY_DDR(struct mthca_dev *dev ) ;
#line 264
int mthca_QUERY_DEV_LIM(struct mthca_dev *dev , struct mthca_dev_lim *dev_lim ) ;
#line 266
int mthca_QUERY_ADAPTER(struct mthca_dev *dev , struct mthca_adapter *adapter ) ;
#line 268
int mthca_INIT_HCA(struct mthca_dev *dev , struct mthca_init_hca_param *param ) ;
#line 273
int mthca_CLOSE_IB(struct mthca_dev *dev , int port ) ;
#line 274
int mthca_CLOSE_HCA(struct mthca_dev *dev , int panic___0 ) ;
#line 280
int mthca_MAP_ICM_AUX(struct mthca_dev *dev , struct mthca_icm *icm ) ;
#line 281
int mthca_UNMAP_ICM_AUX(struct mthca_dev *dev ) ;
#line 282
int mthca_SET_ICM_SIZE(struct mthca_dev *dev , u64 icm_size , u64 *aux_pages ) ;
#line 323
int mthca_NOP(struct mthca_dev *dev ) ;
#line 54 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_profile.h"
s64 mthca_make_profile(struct mthca_dev *dev , struct mthca_profile *request , struct mthca_dev_lim *dev_lim ,
                       struct mthca_init_hca_param *init_hca ) ;
#line 82 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_icm *mthca_alloc_icm(struct mthca_dev *dev , int npages , gfp_t gfp_mask ,
                                  int coherent ) ;
#line 84
void mthca_free_icm(struct mthca_dev *dev , struct mthca_icm *icm , int coherent ) ;
#line 86
struct mthca_icm_table *mthca_alloc_icm_table(struct mthca_dev *dev , u64 virt , int obj_size ,
                                              int nobj , int reserved , int use_lowmem ,
                                              int use_coherent ) ;
#line 90
void mthca_free_icm_table(struct mthca_dev *dev , struct mthca_icm_table *table ) ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
int mthca_debug_level  =    0;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int msi_x  =    1;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int tune_pci  =    0;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
struct mutex mthca_device_mutex  =    {{1}, {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "mthca_device_mutex.wait_lock",
                                                          0, 0UL}}}}, {& mthca_device_mutex.wait_list,
                                                                       & mthca_device_mutex.wait_list},
    0, (void *)(& mthca_device_mutex), {0, {0, 0}, "mthca_device_mutex", 0, 0UL}};
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static struct mthca_profile hca_profile  = 
#line 90
     {65536, 4, 0, 65536, 8192, 131072, 1048576, 32768, 0, 262144, 262144};
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int log_mtts_per_seg  =    3;
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static char mthca_version[63U]  = 
#line 133
  {      'i',      'b',      '_',      'm', 
        't',      'h',      'c',      'a', 
        ':',      ' ',      'M',      'e', 
        'l',      'l',      'a',      'n', 
        'o',      'x',      ' ',      'I', 
        'n',      'f',      'i',      'n', 
        'i',      'B',      'a',      'n', 
        'd',      ' ',      'H',      'C', 
        'A',      ' ',      'd',      'r', 
        'i',      'v',      'e',      'r', 
        ' ',      'v',      '1',      '.', 
        '0',      ' ',      '(',      'A', 
        'p',      'r',      'i',      'l', 
        ' ',      '4',      ',',      ' ', 
        '2',      '0',      '0',      '8', 
        ')',      '\n',      '\000'};
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int mthca_tune_pci(struct mthca_dev *mdev ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;

  {
#line 139
  if (tune_pci == 0) {
#line 140
    return (0);
  } else {

  }
#line 143
  tmp___1 = pci_find_capability(mdev->pdev, 7);
#line 143
  if (tmp___1 != 0) {
#line 144
    tmp = pcix_get_max_mmrbc(mdev->pdev);
#line 144
    tmp___0 = pcix_set_mmrbc(mdev->pdev, tmp);
#line 144
    if (tmp___0 != 0) {
#line 145
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t set PCI-X max read count, aborting.\n");
#line 147
      return (-19);
    } else {

    }
  } else
#line 149
  if ((mdev->mthca_flags & 128UL) == 0UL) {
#line 150
    _dev_info((struct device  const  *)(& (mdev->pdev)->dev), "No PCI-X capability, not setting RBC.\n");
  } else {

  }
#line 152
  tmp___3 = pci_is_pcie(mdev->pdev);
#line 152
  if ((int )tmp___3) {
#line 153
    tmp___2 = pcie_set_readrq(mdev->pdev, 4096);
#line 153
    if (tmp___2 != 0) {
#line 154
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t write PCI Express read request, aborting.\n");
#line 156
      return (-19);
    } else {

    }
  } else
#line 158
  if ((mdev->mthca_flags & 128UL) != 0UL) {
#line 159
    _dev_info((struct device  const  *)(& (mdev->pdev)->dev), "No PCI Express capability, not setting Max Read Request Size.\n");
  } else {

  }
#line 162
  return (0);
}
}
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int mthca_dev_lim(struct mthca_dev *mdev , struct mthca_dev_lim *dev_lim ) 
{ 
  int err ;
  int __min1 ;
  int __min2 ;
  int tmp ;

  {
#line 169
  mdev->limits.mtt_seg_size = 8 << log_mtts_per_seg;
#line 170
  err = mthca_QUERY_DEV_LIM(mdev, dev_lim);
#line 171
  if (err != 0) {
#line 172
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "QUERY_DEV_LIM command returned %d, aborting.\n",
            err);
#line 174
    return (err);
  } else {

  }
#line 176
  if ((unsigned int )dev_lim->min_page_sz > 4096U) {
#line 177
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "HCA minimum page size of %d bigger than kernel PAGE_SIZE of %ld, aborting.\n",
            dev_lim->min_page_sz, 4096UL);
#line 180
    return (-19);
  } else {

  }
#line 182
  if (dev_lim->num_ports > 2) {
#line 183
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "HCA has %d ports, but we only support %d, aborting.\n",
            dev_lim->num_ports, 2);
#line 186
    return (-19);
  } else {

  }
#line 189
  if ((resource_size_t )dev_lim->uar_size > ((mdev->pdev)->resource[2].start != 0ULL || (mdev->pdev)->resource[2].end != (mdev->pdev)->resource[2].start ? ((mdev->pdev)->resource[2].end - (mdev->pdev)->resource[2].start) + 1ULL : 0ULL)) {
#line 190
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "HCA reported UAR size of 0x%x bigger than PCI resource 2 size of 0x%llx, aborting.\n",
            dev_lim->uar_size, (mdev->pdev)->resource[2].start != 0ULL || (mdev->pdev)->resource[2].end != (mdev->pdev)->resource[2].start ? ((mdev->pdev)->resource[2].end - (mdev->pdev)->resource[2].start) + 1ULL : 0ULL);
#line 194
    return (-19);
  } else {

  }
#line 197
  mdev->limits.num_ports = dev_lim->num_ports;
#line 198
  mdev->limits.vl_cap = dev_lim->max_vl;
#line 199
  mdev->limits.mtu_cap = dev_lim->max_mtu;
#line 200
  mdev->limits.gid_table_len = dev_lim->max_gids;
#line 201
  mdev->limits.pkey_table_len = dev_lim->max_pkeys;
#line 202
  mdev->limits.local_ca_ack_delay = dev_lim->local_ca_ack_delay;
#line 208
  __min1 = dev_lim->max_sg;
#line 208
  mthca_is_memfree(mdev);
#line 208
  __min2 = (int )(((unsigned long )dev_lim->max_desc_sz - 64UL) / 16UL);
#line 208
  mdev->limits.max_sg = __min1 < __min2 ? __min1 : __min2;
#line 215
  mdev->limits.max_wqes = dev_lim->max_qp_sz;
#line 216
  mdev->limits.max_qp_init_rdma = dev_lim->max_requester_per_qp;
#line 217
  mdev->limits.reserved_qps = dev_lim->reserved_qps;
#line 218
  mdev->limits.max_srq_wqes = dev_lim->max_srq_sz;
#line 219
  mdev->limits.reserved_srqs = dev_lim->reserved_srqs;
#line 220
  mdev->limits.reserved_eecs = dev_lim->reserved_eecs;
#line 221
  mdev->limits.max_desc_sz = dev_lim->max_desc_sz;
#line 222
  mdev->limits.max_srq_sge = mthca_max_srq_sge(mdev);
#line 228
  mdev->limits.max_cqes = dev_lim->max_cq_sz + -1;
#line 229
  mdev->limits.reserved_cqs = dev_lim->reserved_cqs;
#line 230
  mdev->limits.reserved_eqs = dev_lim->reserved_eqs;
#line 231
  mdev->limits.reserved_mtts = dev_lim->reserved_mtts;
#line 232
  mdev->limits.reserved_mrws = dev_lim->reserved_mrws;
#line 233
  mdev->limits.reserved_uars = dev_lim->reserved_uars;
#line 234
  mdev->limits.reserved_pds = dev_lim->reserved_pds;
#line 235
  mdev->limits.port_width_cap = (u8 )dev_lim->max_port_width;
#line 236
  mdev->limits.page_size_cap = - ((unsigned int )dev_lim->min_page_sz);
#line 237
  mdev->limits.flags = dev_lim->flags;
#line 244
  if ((unsigned int )dev_lim->stat_rate_support != 0U) {
#line 245
    mdev->limits.stat_rate_support = dev_lim->stat_rate_support;
  } else
#line 246
  if ((mdev->mthca_flags & 256UL) != 0UL) {
#line 247
    mdev->limits.stat_rate_support = 15U;
  } else {
#line 249
    mdev->limits.stat_rate_support = 3U;
  }
#line 258
  mdev->device_cap_flags = 7200UL;
#line 263
  if ((dev_lim->flags & 256U) != 0U) {
#line 264
    mdev->device_cap_flags = mdev->device_cap_flags | 2UL;
  } else {

  }
#line 266
  if ((dev_lim->flags & 512U) != 0U) {
#line 267
    mdev->device_cap_flags = mdev->device_cap_flags | 4UL;
  } else {

  }
#line 269
  if ((dev_lim->flags & 524288U) != 0U) {
#line 270
    mdev->device_cap_flags = mdev->device_cap_flags | 8UL;
  } else {

  }
#line 272
  if ((dev_lim->flags & 131072U) != 0U) {
#line 273
    mdev->device_cap_flags = mdev->device_cap_flags | 16UL;
  } else {

  }
#line 275
  if ((dev_lim->flags & 1048576U) != 0U) {
#line 276
    mdev->device_cap_flags = mdev->device_cap_flags | 64UL;
  } else {

  }
#line 278
  if ((dev_lim->flags & 64U) != 0U) {
#line 279
    mdev->mthca_flags = mdev->mthca_flags | 4UL;
  } else {

  }
#line 281
  tmp = mthca_is_memfree(mdev);
#line 281
  if (tmp != 0) {
#line 282
    if ((dev_lim->flags & 128U) != 0U) {
#line 283
      mdev->device_cap_flags = mdev->device_cap_flags | 262144UL;
    } else {

    }
  } else {

  }
#line 285
  return (0);
}
}
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int mthca_init_tavor(struct mthca_dev *mdev ) 
{ 
  s64 size ;
  int err ;
  struct mthca_dev_lim dev_lim ;
  struct mthca_profile profile ;
  struct mthca_init_hca_param init_hca ;

  {
#line 296
  err = mthca_SYS_EN(mdev);
#line 297
  if (err != 0) {
#line 298
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "SYS_EN command returned %d, aborting.\n",
            err);
#line 299
    return (err);
  } else {

  }
#line 302
  err = mthca_QUERY_FW(mdev);
#line 303
  if (err != 0) {
#line 304
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "QUERY_FW command returned %d, aborting.\n",
            err);
#line 306
    goto err_disable;
  } else {

  }
#line 308
  err = mthca_QUERY_DDR(mdev);
#line 309
  if (err != 0) {
#line 310
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "QUERY_DDR command returned %d, aborting.\n",
            err);
#line 311
    goto err_disable;
  } else {

  }
#line 314
  err = mthca_dev_lim(mdev, & dev_lim);
#line 315
  if (err != 0) {
#line 316
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "QUERY_DEV_LIM command returned %d, aborting.\n",
            err);
#line 317
    goto err_disable;
  } else {

  }
#line 320
  profile = hca_profile;
#line 321
  profile.num_uar = (int )((unsigned long )dev_lim.uar_size / 4096UL);
#line 322
  profile.uarc_size = 0;
#line 323
  if ((mdev->mthca_flags & 4UL) != 0UL) {
#line 324
    profile.num_srq = dev_lim.max_srqs;
  } else {

  }
#line 326
  size = mthca_make_profile(mdev, & profile, & dev_lim, & init_hca);
#line 327
  if (size < 0LL) {
#line 328
    err = (int )size;
#line 329
    goto err_disable;
  } else {

  }
#line 332
  err = mthca_INIT_HCA(mdev, & init_hca);
#line 333
  if (err != 0) {
#line 334
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "INIT_HCA command returned %d, aborting.\n",
            err);
#line 335
    goto err_disable;
  } else {

  }
#line 338
  return (0);
  err_disable: 
#line 341
  mthca_SYS_DIS(mdev);
#line 343
  return (err);
}
}
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int mthca_load_fw(struct mthca_dev *mdev ) 
{ 
  int err ;

  {
#line 352
  mdev->fw.arbel.fw_icm = mthca_alloc_icm(mdev, (int )mdev->fw.arbel.fw_pages, 131794U,
                                          0);
#line 355
  if ((unsigned long )mdev->fw.arbel.fw_icm == (unsigned long )((struct mthca_icm *)0)) {
#line 356
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t allocate FW area, aborting.\n");
#line 357
    return (-12);
  } else {

  }
#line 360
  err = mthca_MAP_FA(mdev, mdev->fw.arbel.fw_icm);
#line 361
  if (err != 0) {
#line 362
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "MAP_FA command returned %d, aborting.\n",
            err);
#line 363
    goto err_free;
  } else {

  }
#line 365
  err = mthca_RUN_FW(mdev);
#line 366
  if (err != 0) {
#line 367
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "RUN_FW command returned %d, aborting.\n",
            err);
#line 368
    goto err_unmap_fa;
  } else {

  }
#line 371
  return (0);
  err_unmap_fa: 
#line 374
  mthca_UNMAP_FA(mdev);
  err_free: 
#line 377
  mthca_free_icm(mdev, mdev->fw.arbel.fw_icm, 0);
#line 378
  return (err);
}
}
#line 381 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int mthca_init_icm(struct mthca_dev *mdev , struct mthca_dev_lim *dev_lim ,
                          struct mthca_init_hca_param *init_hca , u64 icm_size ) 
{ 
  u64 aux_pages ;
  int err ;
  int tmp ;
  int tmp___0 ;

  {
#line 389
  err = mthca_SET_ICM_SIZE(mdev, icm_size, & aux_pages);
#line 390
  if (err != 0) {
#line 391
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "SET_ICM_SIZE command returned %d, aborting.\n",
            err);
#line 392
    return (err);
  } else {

  }
#line 395
  if (mthca_debug_level != 0) {
#line 395
    dev_printk("\017", (struct device  const  *)(& (mdev->pdev)->dev), "%lld KB of HCA context requires %lld KB aux memory.\n",
               icm_size >> 10, aux_pages << 2);
  } else {

  }
#line 399
  mdev->fw.arbel.aux_icm = mthca_alloc_icm(mdev, (int )aux_pages, 131794U, 0);
#line 401
  if ((unsigned long )mdev->fw.arbel.aux_icm == (unsigned long )((struct mthca_icm *)0)) {
#line 402
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t allocate aux memory, aborting.\n");
#line 403
    return (-12);
  } else {

  }
#line 406
  err = mthca_MAP_ICM_AUX(mdev, mdev->fw.arbel.aux_icm);
#line 407
  if (err != 0) {
#line 408
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "MAP_ICM_AUX returned %d, aborting.\n",
            err);
#line 409
    goto err_free_aux;
  } else {

  }
#line 412
  err = mthca_map_eq_icm(mdev, init_hca->eqc_base);
#line 413
  if (err != 0) {
#line 414
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map EQ context memory, aborting.\n");
#line 415
    goto err_unmap_aux;
  } else {

  }
#line 419
  tmp = dma_get_cache_alignment();
#line 419
  tmp___0 = dma_get_cache_alignment();
#line 419
  mdev->limits.reserved_mtts = ((mdev->limits.reserved_mtts * mdev->limits.mtt_seg_size + (tmp + -1)) & - tmp___0) / mdev->limits.mtt_seg_size;
#line 422
  mdev->mr_table.mtt_table = mthca_alloc_icm_table(mdev, init_hca->mtt_base, mdev->limits.mtt_seg_size,
                                                   mdev->limits.num_mtt_segs, mdev->limits.reserved_mtts,
                                                   1, 0);
#line 427
  if ((unsigned long )mdev->mr_table.mtt_table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 428
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map MTT context memory, aborting.\n");
#line 429
    err = -12;
#line 430
    goto err_unmap_eq;
  } else {

  }
#line 433
  mdev->mr_table.mpt_table = mthca_alloc_icm_table(mdev, init_hca->mpt_base, dev_lim->mpt_entry_sz,
                                                   mdev->limits.num_mpts, mdev->limits.reserved_mrws,
                                                   1, 1);
#line 438
  if ((unsigned long )mdev->mr_table.mpt_table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 439
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map MPT context memory, aborting.\n");
#line 440
    err = -12;
#line 441
    goto err_unmap_mtt;
  } else {

  }
#line 444
  mdev->qp_table.qp_table = mthca_alloc_icm_table(mdev, init_hca->qpc_base, dev_lim->qpc_entry_sz,
                                                  mdev->limits.num_qps, mdev->limits.reserved_qps,
                                                  0, 0);
#line 449
  if ((unsigned long )mdev->qp_table.qp_table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 450
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map QP context memory, aborting.\n");
#line 451
    err = -12;
#line 452
    goto err_unmap_mpt;
  } else {

  }
#line 455
  mdev->qp_table.eqp_table = mthca_alloc_icm_table(mdev, init_hca->eqpc_base, dev_lim->eqpc_entry_sz,
                                                   mdev->limits.num_qps, mdev->limits.reserved_qps,
                                                   0, 0);
#line 460
  if ((unsigned long )mdev->qp_table.eqp_table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 461
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map EQP context memory, aborting.\n");
#line 462
    err = -12;
#line 463
    goto err_unmap_qp;
  } else {

  }
#line 466
  mdev->qp_table.rdb_table = mthca_alloc_icm_table(mdev, init_hca->rdb_base, 32, mdev->limits.num_qps << mdev->qp_table.rdb_shift,
                                                   0, 0, 0);
#line 471
  if ((unsigned long )mdev->qp_table.rdb_table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 472
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map RDB context memory, aborting\n");
#line 473
    err = -12;
#line 474
    goto err_unmap_eqp;
  } else {

  }
#line 477
  mdev->cq_table.table = mthca_alloc_icm_table(mdev, init_hca->cqc_base, dev_lim->cqc_entry_sz,
                                               mdev->limits.num_cqs, mdev->limits.reserved_cqs,
                                               0, 0);
#line 482
  if ((unsigned long )mdev->cq_table.table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 483
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map CQ context memory, aborting.\n");
#line 484
    err = -12;
#line 485
    goto err_unmap_rdb;
  } else {

  }
#line 488
  if ((mdev->mthca_flags & 4UL) != 0UL) {
#line 489
    mdev->srq_table.table = mthca_alloc_icm_table(mdev, init_hca->srqc_base, dev_lim->srq_entry_sz,
                                                  mdev->limits.num_srqs, mdev->limits.reserved_srqs,
                                                  0, 0);
#line 495
    if ((unsigned long )mdev->srq_table.table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 496
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map SRQ context memory, aborting.\n");
#line 498
      err = -12;
#line 499
      goto err_unmap_cq;
    } else {

    }
  } else {

  }
#line 508
  mdev->mcg_table.table = mthca_alloc_icm_table(mdev, init_hca->mc_base, 256, mdev->limits.num_mgms + mdev->limits.num_amgms,
                                                mdev->limits.num_mgms + mdev->limits.num_amgms,
                                                0, 0);
#line 515
  if ((unsigned long )mdev->mcg_table.table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 516
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map MCG context memory, aborting.\n");
#line 517
    err = -12;
#line 518
    goto err_unmap_srq;
  } else {

  }
#line 521
  return (0);
  err_unmap_srq: ;
#line 524
  if ((mdev->mthca_flags & 4UL) != 0UL) {
#line 525
    mthca_free_icm_table(mdev, mdev->srq_table.table);
  } else {

  }
  err_unmap_cq: 
#line 528
  mthca_free_icm_table(mdev, mdev->cq_table.table);
  err_unmap_rdb: 
#line 531
  mthca_free_icm_table(mdev, mdev->qp_table.rdb_table);
  err_unmap_eqp: 
#line 534
  mthca_free_icm_table(mdev, mdev->qp_table.eqp_table);
  err_unmap_qp: 
#line 537
  mthca_free_icm_table(mdev, mdev->qp_table.qp_table);
  err_unmap_mpt: 
#line 540
  mthca_free_icm_table(mdev, mdev->mr_table.mpt_table);
  err_unmap_mtt: 
#line 543
  mthca_free_icm_table(mdev, mdev->mr_table.mtt_table);
  err_unmap_eq: 
#line 546
  mthca_unmap_eq_icm(mdev);
  err_unmap_aux: 
#line 549
  mthca_UNMAP_ICM_AUX(mdev);
  err_free_aux: 
#line 552
  mthca_free_icm(mdev, mdev->fw.arbel.aux_icm, 0);
#line 554
  return (err);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static void mthca_free_icms(struct mthca_dev *mdev ) 
{ 


  {
#line 560
  mthca_free_icm_table(mdev, mdev->mcg_table.table);
#line 561
  if ((mdev->mthca_flags & 4UL) != 0UL) {
#line 562
    mthca_free_icm_table(mdev, mdev->srq_table.table);
  } else {

  }
#line 563
  mthca_free_icm_table(mdev, mdev->cq_table.table);
#line 564
  mthca_free_icm_table(mdev, mdev->qp_table.rdb_table);
#line 565
  mthca_free_icm_table(mdev, mdev->qp_table.eqp_table);
#line 566
  mthca_free_icm_table(mdev, mdev->qp_table.qp_table);
#line 567
  mthca_free_icm_table(mdev, mdev->mr_table.mpt_table);
#line 568
  mthca_free_icm_table(mdev, mdev->mr_table.mtt_table);
#line 569
  mthca_unmap_eq_icm(mdev);
#line 571
  mthca_UNMAP_ICM_AUX(mdev);
#line 572
  mthca_free_icm(mdev, mdev->fw.arbel.aux_icm, 0);
#line 573
  return;
}
}
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int mthca_init_arbel(struct mthca_dev *mdev ) 
{ 
  struct mthca_dev_lim dev_lim ;
  struct mthca_profile profile ;
  struct mthca_init_hca_param init_hca ;
  s64 icm_size ;
  int err ;

  {
#line 583
  err = mthca_QUERY_FW(mdev);
#line 584
  if (err != 0) {
#line 585
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "QUERY_FW command failed %d, aborting.\n",
            err);
#line 586
    return (err);
  } else {

  }
#line 589
  err = mthca_ENABLE_LAM(mdev);
#line 590
  if (err == -11) {
#line 591
    if (mthca_debug_level != 0) {
#line 591
      dev_printk("\017", (struct device  const  *)(& (mdev->pdev)->dev), "No HCA-attached memory (running in MemFree mode)\n");
    } else {

    }
#line 592
    mdev->mthca_flags = mdev->mthca_flags | 16UL;
  } else
#line 593
  if (err != 0) {
#line 594
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "ENABLE_LAM returned %d, aborting.\n",
            err);
#line 595
    return (err);
  } else {

  }
#line 598
  err = mthca_load_fw(mdev);
#line 599
  if (err != 0) {
#line 600
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Loading FW returned %d, aborting.\n",
            err);
#line 601
    goto err_disable;
  } else {

  }
#line 604
  err = mthca_dev_lim(mdev, & dev_lim);
#line 605
  if (err != 0) {
#line 606
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "QUERY_DEV_LIM returned %d, aborting.\n",
            err);
#line 607
    goto err_stop_fw;
  } else {

  }
#line 610
  profile = hca_profile;
#line 611
  profile.num_uar = (int )((unsigned long )dev_lim.uar_size / 4096UL);
#line 612
  profile.num_udav = 0;
#line 613
  if ((mdev->mthca_flags & 4UL) != 0UL) {
#line 614
    profile.num_srq = dev_lim.max_srqs;
  } else {

  }
#line 616
  icm_size = mthca_make_profile(mdev, & profile, & dev_lim, & init_hca);
#line 617
  if (icm_size < 0LL) {
#line 618
    err = (int )icm_size;
#line 619
    goto err_stop_fw;
  } else {

  }
#line 622
  err = mthca_init_icm(mdev, & dev_lim, & init_hca, (u64 )icm_size);
#line 623
  if (err != 0) {
#line 624
    goto err_stop_fw;
  } else {

  }
#line 626
  err = mthca_INIT_HCA(mdev, & init_hca);
#line 627
  if (err != 0) {
#line 628
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "INIT_HCA command returned %d, aborting.\n",
            err);
#line 629
    goto err_free_icm;
  } else {

  }
#line 632
  return (0);
  err_free_icm: 
#line 635
  mthca_free_icms(mdev);
  err_stop_fw: 
#line 638
  mthca_UNMAP_FA(mdev);
#line 639
  mthca_free_icm(mdev, mdev->fw.arbel.fw_icm, 0);
  err_disable: ;
#line 642
  if ((mdev->mthca_flags & 16UL) == 0UL) {
#line 643
    mthca_DISABLE_LAM(mdev);
  } else {

  }
#line 645
  return (err);
}
}
#line 648 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static void mthca_close_hca(struct mthca_dev *mdev ) 
{ 
  int tmp ;

  {
#line 650
  mthca_CLOSE_HCA(mdev, 0);
#line 652
  tmp = mthca_is_memfree(mdev);
#line 652
  if (tmp != 0) {
#line 653
    mthca_free_icms(mdev);
#line 655
    mthca_UNMAP_FA(mdev);
#line 656
    mthca_free_icm(mdev, mdev->fw.arbel.fw_icm, 0);
#line 658
    if ((mdev->mthca_flags & 16UL) == 0UL) {
#line 659
      mthca_DISABLE_LAM(mdev);
    } else {

    }
  } else {
#line 661
    mthca_SYS_DIS(mdev);
  }
#line 662
  return;
}
}
#line 664 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int mthca_init_hca(struct mthca_dev *mdev ) 
{ 
  int err ;
  struct mthca_adapter adapter ;
  int tmp ;
  int tmp___0 ;

  {
#line 669
  tmp = mthca_is_memfree(mdev);
#line 669
  if (tmp != 0) {
#line 670
    err = mthca_init_arbel(mdev);
  } else {
#line 672
    err = mthca_init_tavor(mdev);
  }
#line 674
  if (err != 0) {
#line 675
    return (err);
  } else {

  }
#line 677
  err = mthca_QUERY_ADAPTER(mdev, & adapter);
#line 678
  if (err != 0) {
#line 679
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "QUERY_ADAPTER command returned %d, aborting.\n",
            err);
#line 680
    goto err_close;
  } else {

  }
#line 683
  mdev->eq_table.inta_pin = adapter.inta_pin;
#line 684
  tmp___0 = mthca_is_memfree(mdev);
#line 684
  if (tmp___0 == 0) {
#line 685
    mdev->rev_id = adapter.revision_id;
  } else {

  }
#line 686
  memcpy((void *)(& mdev->board_id), (void const   *)(& adapter.board_id), 64UL);
#line 688
  return (0);
  err_close: 
#line 691
  mthca_close_hca(mdev);
#line 692
  return (err);
}
}
#line 695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int mthca_setup_hca(struct mthca_dev *dev ) 
{ 
  int err ;

  {
#line 701
  err = mthca_init_uar_table(dev);
#line 702
  if (err != 0) {
#line 703
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize user access region table, aborting.\n");
#line 705
    return (err);
  } else {

  }
#line 708
  err = mthca_uar_alloc(dev, & dev->driver_uar);
#line 709
  if (err != 0) {
#line 710
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to allocate driver access region, aborting.\n");
#line 712
    goto err_uar_table_free;
  } else {

  }
#line 715
  dev->kar = ioremap((unsigned long long )dev->driver_uar.pfn << 12, 4096UL);
#line 716
  if ((unsigned long )dev->kar == (unsigned long )((void *)0)) {
#line 717
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Couldn\'t map kernel access region, aborting.\n");
#line 719
    err = -12;
#line 720
    goto err_uar_free;
  } else {

  }
#line 723
  err = mthca_init_pd_table(dev);
#line 724
  if (err != 0) {
#line 725
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize protection domain table, aborting.\n");
#line 727
    goto err_kar_unmap;
  } else {

  }
#line 730
  err = mthca_init_mr_table(dev);
#line 731
  if (err != 0) {
#line 732
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize memory region table, aborting.\n");
#line 734
    goto err_pd_table_free;
  } else {

  }
#line 737
  err = mthca_pd_alloc(dev, 1, & dev->driver_pd);
#line 738
  if (err != 0) {
#line 739
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to create driver PD, aborting.\n");
#line 741
    goto err_mr_table_free;
  } else {

  }
#line 744
  err = mthca_init_eq_table(dev);
#line 745
  if (err != 0) {
#line 746
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize event queue table, aborting.\n");
#line 748
    goto err_pd_free;
  } else {

  }
#line 751
  err = mthca_cmd_use_events(dev);
#line 752
  if (err != 0) {
#line 753
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to switch to event-driven firmware commands, aborting.\n");
#line 755
    goto err_eq_table_free;
  } else {

  }
#line 758
  err = mthca_NOP(dev);
#line 759
  if (err != 0) {
#line 760
    if ((dev->mthca_flags & 8UL) != 0UL) {
#line 761
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "NOP command failed to generate interrupt (IRQ %d).\n",
               (int )dev->eq_table.eq[0].msi_x_vector);
#line 764
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Trying again with MSI-X disabled.\n");
    } else {
#line 766
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "NOP command failed to generate interrupt (IRQ %d), aborting.\n",
              (dev->pdev)->irq);
#line 769
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "BIOS or ACPI interrupt routing problem?\n");
    }
#line 772
    goto err_cmd_poll;
  } else {

  }
#line 775
  if (mthca_debug_level != 0) {
#line 775
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "NOP command IRQ test passed\n");
  } else {

  }
#line 777
  err = mthca_init_cq_table(dev);
#line 778
  if (err != 0) {
#line 779
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize completion queue table, aborting.\n");
#line 781
    goto err_cmd_poll;
  } else {

  }
#line 784
  err = mthca_init_srq_table(dev);
#line 785
  if (err != 0) {
#line 786
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize shared receive queue table, aborting.\n");
#line 788
    goto err_cq_table_free;
  } else {

  }
#line 791
  err = mthca_init_qp_table(dev);
#line 792
  if (err != 0) {
#line 793
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize queue pair table, aborting.\n");
#line 795
    goto err_srq_table_free;
  } else {

  }
#line 798
  err = mthca_init_av_table(dev);
#line 799
  if (err != 0) {
#line 800
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize address vector table, aborting.\n");
#line 802
    goto err_qp_table_free;
  } else {

  }
#line 805
  err = mthca_init_mcg_table(dev);
#line 806
  if (err != 0) {
#line 807
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize multicast group table, aborting.\n");
#line 809
    goto err_av_table_free;
  } else {

  }
#line 812
  return (0);
  err_av_table_free: 
#line 815
  mthca_cleanup_av_table(dev);
  err_qp_table_free: 
#line 818
  mthca_cleanup_qp_table(dev);
  err_srq_table_free: 
#line 821
  mthca_cleanup_srq_table(dev);
  err_cq_table_free: 
#line 824
  mthca_cleanup_cq_table(dev);
  err_cmd_poll: 
#line 827
  mthca_cmd_use_polling(dev);
  err_eq_table_free: 
#line 830
  mthca_cleanup_eq_table(dev);
  err_pd_free: 
#line 833
  mthca_pd_free(dev, & dev->driver_pd);
  err_mr_table_free: 
#line 836
  mthca_cleanup_mr_table(dev);
  err_pd_table_free: 
#line 839
  mthca_cleanup_pd_table(dev);
  err_kar_unmap: 
#line 842
  iounmap((void volatile   *)dev->kar);
  err_uar_free: 
#line 845
  mthca_uar_free(dev, & dev->driver_uar);
  err_uar_table_free: 
#line 848
  mthca_cleanup_uar_table(dev);
#line 849
  return (err);
}
}
#line 852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int mthca_enable_msi_x(struct mthca_dev *mdev ) 
{ 
  struct msix_entry entries[3U] ;
  int err ;

  {
#line 857
  entries[0].entry = 0U;
#line 858
  entries[1].entry = 1U;
#line 859
  entries[2].entry = 2U;
#line 861
  err = pci_enable_msix_exact(mdev->pdev, (struct msix_entry *)(& entries), 3);
#line 862
  if (err != 0) {
#line 863
    return (err);
  } else {

  }
#line 865
  mdev->eq_table.eq[2].msi_x_vector = (u16 )entries[0].vector;
#line 866
  mdev->eq_table.eq[1].msi_x_vector = (u16 )entries[1].vector;
#line 867
  mdev->eq_table.eq[0].msi_x_vector = (u16 )entries[2].vector;
#line 869
  return (0);
}
}
#line 886 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static struct __anonstruct_mthca_hca_table_262 mthca_hca_table[4U]  = {      {12885229568ULL, 0U}, 
        {17180393672ULL, 128U}, 
        {21475033088ULL, 192U}, 
        {4295098368ULL, 448U}};
#line 900 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int __mthca_init_one(struct pci_dev *pdev , int hca_type ) 
{ 
  int ddr_hidden ;
  int err ;
  struct mthca_dev *mdev ;
  char const   *tmp ;
  struct ib_device *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 902
  ddr_hidden = 0;
#line 906
  tmp = pci_name((struct pci_dev  const  *)pdev);
#line 906
  printk("\016ib_mthca: Initializing %s\n", tmp);
#line 909
  err = pci_enable_device(pdev);
#line 910
  if (err != 0) {
#line 911
    dev_err((struct device  const  *)(& pdev->dev), "Cannot enable PCI device, aborting.\n");
#line 913
    return (err);
  } else {

  }
#line 920
  if ((pdev->resource[0].flags & 512UL) == 0UL || ((pdev->resource[0].start == 0ULL && pdev->resource[0].end == pdev->resource[0].start) || pdev->resource[0].end - pdev->resource[0].start != 1048575ULL)) {
#line 922
    dev_err((struct device  const  *)(& pdev->dev), "Missing DCS, aborting.\n");
#line 923
    err = -19;
#line 924
    goto err_disable_pdev;
  } else {

  }
#line 926
  if ((pdev->resource[2].flags & 512UL) == 0UL) {
#line 927
    dev_err((struct device  const  *)(& pdev->dev), "Missing UAR, aborting.\n");
#line 928
    err = -19;
#line 929
    goto err_disable_pdev;
  } else {

  }
#line 931
  if ((pdev->resource[4].flags & 512UL) == 0UL) {
#line 932
    ddr_hidden = 1;
  } else {

  }
#line 934
  err = pci_request_regions(pdev, "ib_mthca");
#line 935
  if (err != 0) {
#line 936
    dev_err((struct device  const  *)(& pdev->dev), "Cannot obtain PCI resources, aborting.\n");
#line 938
    goto err_disable_pdev;
  } else {

  }
#line 941
  pci_set_master(pdev);
#line 943
  err = pci_set_dma_mask(pdev, 0xffffffffffffffffULL);
#line 944
  if (err != 0) {
#line 945
    dev_warn((struct device  const  *)(& pdev->dev), "Warning: couldn\'t set 64-bit PCI DMA mask.\n");
#line 946
    err = pci_set_dma_mask(pdev, 4294967295ULL);
#line 947
    if (err != 0) {
#line 948
      dev_err((struct device  const  *)(& pdev->dev), "Can\'t set PCI DMA mask, aborting.\n");
#line 949
      goto err_free_res;
    } else {

    }
  } else {

  }
#line 952
  err = pci_set_consistent_dma_mask(pdev, 0xffffffffffffffffULL);
#line 953
  if (err != 0) {
#line 954
    dev_warn((struct device  const  *)(& pdev->dev), "Warning: couldn\'t set 64-bit consistent PCI DMA mask.\n");
#line 956
    err = pci_set_consistent_dma_mask(pdev, 4294967295ULL);
#line 957
    if (err != 0) {
#line 958
      dev_err((struct device  const  *)(& pdev->dev), "Can\'t set consistent PCI DMA mask, aborting.\n");
#line 960
      goto err_free_res;
    } else {

    }
  } else {

  }
#line 965
  dma_set_max_seg_size(& pdev->dev, 1073741824U);
#line 967
  tmp___0 = ib_alloc_device(6136UL);
#line 967
  mdev = (struct mthca_dev *)tmp___0;
#line 968
  if ((unsigned long )mdev == (unsigned long )((struct mthca_dev *)0)) {
#line 969
    dev_err((struct device  const  *)(& pdev->dev), "Device struct alloc failed, aborting.\n");
#line 971
    err = -12;
#line 972
    goto err_free_res;
  } else {

  }
#line 975
  mdev->pdev = pdev;
#line 977
  mdev->mthca_flags = (unsigned long )mthca_hca_table[hca_type].flags;
#line 978
  if (ddr_hidden != 0) {
#line 979
    mdev->mthca_flags = mdev->mthca_flags | 2UL;
  } else {

  }
#line 986
  err = mthca_reset(mdev);
#line 987
  if (err != 0) {
#line 988
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to reset HCA, aborting.\n");
#line 989
    goto err_free_dev;
  } else {

  }
#line 992
  tmp___1 = mthca_cmd_init(mdev);
#line 992
  if (tmp___1 != 0) {
#line 993
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to init command interface, aborting.\n");
#line 994
    goto err_free_dev;
  } else {

  }
#line 997
  err = mthca_tune_pci(mdev);
#line 998
  if (err != 0) {
#line 999
    goto err_cmd;
  } else {

  }
#line 1001
  err = mthca_init_hca(mdev);
#line 1002
  if (err != 0) {
#line 1003
    goto err_cmd;
  } else {

  }
#line 1005
  if (mdev->fw_ver < mthca_hca_table[hca_type].latest_fw) {
#line 1006
    dev_warn((struct device  const  *)(& (mdev->pdev)->dev), "HCA FW version %d.%d.%03d is old (%d.%d.%03d is current).\n",
             (int )(mdev->fw_ver >> 32), (int )(mdev->fw_ver >> 16) & 65535, (int )mdev->fw_ver & 65535,
             (int )(mthca_hca_table[hca_type].latest_fw >> 32), (int )(mthca_hca_table[hca_type].latest_fw >> 16) & 65535,
             (int )mthca_hca_table[hca_type].latest_fw & 65535);
#line 1012
    dev_warn((struct device  const  *)(& (mdev->pdev)->dev), "If you have problems, try updating your HCA FW.\n");
  } else {

  }
#line 1015
  if (msi_x != 0) {
#line 1015
    tmp___2 = mthca_enable_msi_x(mdev);
#line 1015
    if (tmp___2 == 0) {
#line 1016
      mdev->mthca_flags = mdev->mthca_flags | 8UL;
    } else {

    }
  } else {

  }
#line 1018
  err = mthca_setup_hca(mdev);
#line 1019
  if (err == -16 && (mdev->mthca_flags & 8UL) != 0UL) {
#line 1020
    if ((mdev->mthca_flags & 8UL) != 0UL) {
#line 1021
      pci_disable_msix(pdev);
    } else {

    }
#line 1022
    mdev->mthca_flags = mdev->mthca_flags & 0xfffffffffffffff7UL;
#line 1024
    err = mthca_setup_hca(mdev);
  } else {

  }
#line 1027
  if (err != 0) {
#line 1028
    goto err_close;
  } else {

  }
#line 1030
  err = mthca_register_device(mdev);
#line 1031
  if (err != 0) {
#line 1032
    goto err_cleanup;
  } else {

  }
#line 1034
  err = mthca_create_agents(mdev);
#line 1035
  if (err != 0) {
#line 1036
    goto err_unregister;
  } else {

  }
#line 1038
  pci_set_drvdata(pdev, (void *)mdev);
#line 1039
  mdev->hca_type = hca_type;
#line 1041
  mdev->active = 1;
#line 1043
  return (0);
  err_unregister: 
#line 1046
  mthca_unregister_device(mdev);
  err_cleanup: 
#line 1049
  mthca_cleanup_mcg_table(mdev);
#line 1050
  mthca_cleanup_av_table(mdev);
#line 1051
  mthca_cleanup_qp_table(mdev);
#line 1052
  mthca_cleanup_srq_table(mdev);
#line 1053
  mthca_cleanup_cq_table(mdev);
#line 1054
  mthca_cmd_use_polling(mdev);
#line 1055
  mthca_cleanup_eq_table(mdev);
#line 1057
  mthca_pd_free(mdev, & mdev->driver_pd);
#line 1059
  mthca_cleanup_mr_table(mdev);
#line 1060
  mthca_cleanup_pd_table(mdev);
#line 1061
  mthca_cleanup_uar_table(mdev);
  err_close: ;
#line 1064
  if ((mdev->mthca_flags & 8UL) != 0UL) {
#line 1065
    pci_disable_msix(pdev);
  } else {

  }
#line 1067
  mthca_close_hca(mdev);
  err_cmd: 
#line 1070
  mthca_cmd_cleanup(mdev);
  err_free_dev: 
#line 1073
  ib_dealloc_device(& mdev->ib_dev);
  err_free_res: 
#line 1076
  pci_release_regions(pdev);
  err_disable_pdev: 
#line 1079
  pci_disable_device(pdev);
#line 1080
  pci_set_drvdata(pdev, (void *)0);
#line 1081
  return (err);
}
}
#line 1084 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static void __mthca_remove_one(struct pci_dev *pdev ) 
{ 
  struct mthca_dev *mdev ;
  void *tmp ;
  int p ;

  {
#line 1086
  tmp = pci_get_drvdata(pdev);
#line 1086
  mdev = (struct mthca_dev *)tmp;
#line 1089
  if ((unsigned long )mdev != (unsigned long )((struct mthca_dev *)0)) {
#line 1090
    mthca_free_agents(mdev);
#line 1091
    mthca_unregister_device(mdev);
#line 1093
    p = 1;
#line 1093
    goto ldv_32511;
    ldv_32510: 
#line 1094
    mthca_CLOSE_IB(mdev, p);
#line 1093
    p = p + 1;
    ldv_32511: ;
#line 1093
    if (mdev->limits.num_ports >= p) {
#line 1095
      goto ldv_32510;
    } else {

    }
#line 1096
    mthca_cleanup_mcg_table(mdev);
#line 1097
    mthca_cleanup_av_table(mdev);
#line 1098
    mthca_cleanup_qp_table(mdev);
#line 1099
    mthca_cleanup_srq_table(mdev);
#line 1100
    mthca_cleanup_cq_table(mdev);
#line 1101
    mthca_cmd_use_polling(mdev);
#line 1102
    mthca_cleanup_eq_table(mdev);
#line 1104
    mthca_pd_free(mdev, & mdev->driver_pd);
#line 1106
    mthca_cleanup_mr_table(mdev);
#line 1107
    mthca_cleanup_pd_table(mdev);
#line 1109
    iounmap((void volatile   *)mdev->kar);
#line 1110
    mthca_uar_free(mdev, & mdev->driver_uar);
#line 1111
    mthca_cleanup_uar_table(mdev);
#line 1112
    mthca_close_hca(mdev);
#line 1113
    mthca_cmd_cleanup(mdev);
#line 1115
    if ((mdev->mthca_flags & 8UL) != 0UL) {
#line 1116
      pci_disable_msix(pdev);
    } else {

    }
#line 1118
    ib_dealloc_device(& mdev->ib_dev);
#line 1119
    pci_release_regions(pdev);
#line 1120
    pci_disable_device(pdev);
#line 1121
    pci_set_drvdata(pdev, (void *)0);
  } else {

  }
#line 1123
  return;
}
}
#line 1125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
int __mthca_restart_one(struct pci_dev *pdev ) 
{ 
  struct mthca_dev *mdev ;
  int hca_type ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1130
  tmp = pci_get_drvdata(pdev);
#line 1130
  mdev = (struct mthca_dev *)tmp;
#line 1131
  if ((unsigned long )mdev == (unsigned long )((struct mthca_dev *)0)) {
#line 1132
    return (-19);
  } else {

  }
#line 1133
  hca_type = mdev->hca_type;
#line 1134
  __mthca_remove_one(pdev);
#line 1135
  tmp___0 = __mthca_init_one(pdev, hca_type);
#line 1135
  return (tmp___0);
}
}
#line 1138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int mthca_init_one(struct pci_dev *pdev , struct pci_device_id  const  *id ) 
{ 
  int ret ;
  bool __print_once ;
  char const   *tmp ;

  {
#line 1142
  mutex_lock_nested(& mthca_device_mutex, 0U);
#line 1144
  if (! __print_once) {
#line 1144
    __print_once = 1;
#line 1144
    printk("\016%s", (char *)(& mthca_version));
  } else {

  }
#line 1146
  if ((unsigned long )id->driver_data > 3UL) {
#line 1147
    tmp = pci_name((struct pci_dev  const  *)pdev);
#line 1147
    printk("\vib_mthca: %s has invalid driver data %lx\n", tmp, id->driver_data);
#line 1149
    mutex_unlock(& mthca_device_mutex);
#line 1150
    return (-19);
  } else {

  }
#line 1153
  ret = __mthca_init_one(pdev, (int )id->driver_data);
#line 1155
  mutex_unlock(& mthca_device_mutex);
#line 1157
  return (ret);
}
}
#line 1160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static void mthca_remove_one(struct pci_dev *pdev ) 
{ 


  {
#line 1162
  mutex_lock_nested(& mthca_device_mutex, 0U);
#line 1163
  __mthca_remove_one(pdev);
#line 1164
  mutex_unlock(& mthca_device_mutex);
#line 1165
  return;
}
}
#line 1167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static struct pci_device_id mthca_pci_table[11U]  = 
#line 1167
  {      {5555U, 23108U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6247U, 23108U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {5555U, 25208U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {6247U, 25208U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {5555U, 25218U, 4294967295U, 4294967295U, 0U, 0U, 2UL}, 
        {6247U, 25218U, 4294967295U, 4294967295U, 0U, 0U, 2UL}, 
        {5555U, 25204U, 4294967295U, 4294967295U, 0U, 0U, 3UL}, 
        {6247U, 25204U, 4294967295U, 4294967295U, 0U, 0U, 3UL}, 
        {5555U, 24204U, 4294967295U, 4294967295U, 0U, 0U, 3UL}, 
        {6247U, 24204U, 4294967295U, 4294967295U, 0U, 0U, 3UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 1191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
struct pci_device_id  const  __mod_pci__mthca_pci_table_device_table[11U]  ;
#line 1193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static struct pci_driver mthca_driver  = 
#line 1193
     {{0, 0}, "ib_mthca", (struct pci_device_id  const  *)(& mthca_pci_table), & mthca_init_one,
    & mthca_remove_one, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0,
                                              0, 0, 0, 0, 0, 0}, {{{{{{0}}, 0U, 0U,
                                                                     0, {0, {0, 0},
                                                                         0, 0, 0UL}}}},
                                                                  {0, 0}}};
#line 1200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static void __mthca_check_profile_val(char const   *name , int *pval , int pval_default ) 
{ 
  int old_pval ;
  unsigned long tmp ;

  {
#line 1204
  old_pval = *pval;
#line 1206
  if (old_pval <= 0) {
#line 1207
    *pval = pval_default;
  } else {
#line 1209
    tmp = __roundup_pow_of_two((unsigned long )old_pval);
#line 1209
    *pval = (int )tmp;
  }
#line 1211
  if (*pval != old_pval) {
#line 1212
    printk("\fib_mthca: Invalid value %d for %s in module parameter.\n", old_pval,
           name);
#line 1214
    printk("\fib_mthca: Corrected %s to %d.\n", name, *pval);
  } else {

  }
#line 1216
  return;
}
}
#line 1221 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static void mthca_validate_profile(void) 
{ 


  {
#line 1223
  __mthca_check_profile_val("num_qp", & hca_profile.num_qp, 65536);
#line 1224
  __mthca_check_profile_val("rdb_per_qp", & hca_profile.rdb_per_qp, 4);
#line 1225
  __mthca_check_profile_val("num_cq", & hca_profile.num_cq, 65536);
#line 1226
  __mthca_check_profile_val("num_mcg", & hca_profile.num_mcg, 8192);
#line 1227
  __mthca_check_profile_val("num_mpt", & hca_profile.num_mpt, 131072);
#line 1228
  __mthca_check_profile_val("num_mtt", & hca_profile.num_mtt, 1048576);
#line 1229
  __mthca_check_profile_val("num_udav", & hca_profile.num_udav, 32768);
#line 1230
  __mthca_check_profile_val("fmr_reserved_mtts", & hca_profile.fmr_reserved_mtts,
                            262144);
#line 1232
  if (hca_profile.fmr_reserved_mtts >= hca_profile.num_mtt) {
#line 1233
    printk("\fib_mthca: Invalid fmr_reserved_mtts module parameter %d.\n", hca_profile.fmr_reserved_mtts);
#line 1235
    printk("\fib_mthca: (Must be smaller than num_mtt %d)\n", hca_profile.num_mtt);
#line 1237
    hca_profile.fmr_reserved_mtts = hca_profile.num_mtt / 2;
#line 1238
    printk("\fib_mthca: Corrected fmr_reserved_mtts to %d.\n", hca_profile.fmr_reserved_mtts);
  } else {

  }
#line 1242
  if (log_mtts_per_seg <= 0 || log_mtts_per_seg > 5) {
#line 1243
    printk("\fib_mthca: bad log_mtts_per_seg (%d). Using default - %d\n", log_mtts_per_seg,
           3);
#line 1245
    log_mtts_per_seg = 3;
  } else {

  }
#line 1247
  return;
}
}
#line 1249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static int mthca_init(void) 
{ 
  int ret ;

  {
#line 1253
  mthca_validate_profile();
#line 1255
  ret = mthca_catas_init();
#line 1256
  if (ret != 0) {
#line 1257
    return (ret);
  } else {

  }
#line 1259
  ret = ldv___pci_register_driver_10(& mthca_driver, & __this_module, "ib_mthca");
#line 1260
  if (ret < 0) {
#line 1261
    mthca_catas_cleanup();
#line 1262
    return (ret);
  } else {

  }
#line 1265
  return (0);
}
}
#line 1268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.c"
static void mthca_cleanup(void) 
{ 


  {
#line 1270
  ldv_pci_unregister_driver_11(& mthca_driver);
#line 1271
  mthca_catas_cleanup();
#line 1272
  return;
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_retval_0  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv_retval_1  ;
#line 58
extern void ldv_initialize(void) ;
#line 59
extern int ldv_shutdown_7(void) ;
#line 60
void ldv_check_final_state(void) ;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
void ldv_pci_driver_7(void) 
{ 
  void *tmp ;

  {
#line 65
  tmp = ldv_init_zalloc(2976UL);
#line 65
  mthca_driver_group1 = (struct pci_dev *)tmp;
#line 66
  return;
}
}
#line 70
void ldv_main_exported_6(void) ;
#line 71
void ldv_main_exported_4(void) ;
#line 72
void ldv_main_exported_3(void) ;
#line 73
void ldv_main_exported_5(void) ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int main(void) 
{ 
  struct pci_device_id *ldvarg6 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 82
  tmp = ldv_init_zalloc(32UL);
#line 82
  ldvarg6 = (struct pci_device_id *)tmp;
#line 80
  ldv_initialize();
#line 84
  ldv_state_variable_6 = 0;
#line 85
  ldv_state_variable_3 = 0;
#line 86
  ldv_state_variable_7 = 0;
#line 88
  ldv_state_variable_2 = 1;
#line 90
  work_init_1();
#line 92
  ldv_state_variable_1 = 1;
#line 93
  ldv_state_variable_4 = 0;
#line 94
  ref_cnt = 0;
#line 95
  ldv_state_variable_0 = 1;
#line 96
  ldv_state_variable_5 = 0;
  ldv_32607: 
#line 98
  tmp___0 = __VERIFIER_nondet_int();
#line 98
  switch (tmp___0) {
  case 0: ;
#line 102
  if (ldv_state_variable_6 != 0) {
#line 103
    ldv_main_exported_6();
  } else {

  }
#line 106
  goto ldv_32588;
  case 1: ;
#line 110
  if (ldv_state_variable_3 != 0) {
#line 111
    ldv_main_exported_3();
  } else {

  }
#line 114
  goto ldv_32588;
  case 2: ;
#line 118
  if (ldv_state_variable_7 != 0) {
#line 119
    tmp___1 = __VERIFIER_nondet_int();
#line 119
    switch (tmp___1) {
    case 0: ;
#line 122
    if (ldv_state_variable_7 == 1) {
#line 124
      ldv_retval_0 = mthca_init_one(mthca_driver_group1, (struct pci_device_id  const  *)ldvarg6);
#line 125
      if (ldv_retval_0 == 0) {
#line 126
        ldv_state_variable_7 = 2;
#line 127
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 131
    goto ldv_32592;
    case 1: ;
#line 134
    if (ldv_state_variable_7 == 2) {
#line 136
      mthca_remove_one(mthca_driver_group1);
#line 137
      ldv_state_variable_7 = 1;
    } else {

    }
#line 140
    goto ldv_32592;
    case 2: ;
#line 143
    if (ldv_state_variable_7 == 2) {
#line 145
      ldv_shutdown_7();
#line 146
      ldv_state_variable_7 = 2;
    } else {

    }
#line 149
    goto ldv_32592;
    default: 
#line 150
    ldv_stop();
    }
    ldv_32592: ;
  } else {

  }
#line 154
  goto ldv_32588;
  case 3: ;
#line 161
  goto ldv_32588;
  case 4: ;
#line 168
  goto ldv_32588;
  case 5: ;
#line 172
  if (ldv_state_variable_4 != 0) {
#line 173
    ldv_main_exported_4();
  } else {

  }
#line 176
  goto ldv_32588;
  case 6: ;
#line 180
  if (ldv_state_variable_0 != 0) {
#line 181
    tmp___2 = __VERIFIER_nondet_int();
#line 181
    switch (tmp___2) {
    case 0: ;
#line 184
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 186
      mthca_cleanup();
#line 187
      ldv_state_variable_0 = 2;
#line 188
      goto ldv_final;
    } else {

    }
#line 191
    goto ldv_32602;
    case 1: ;
#line 194
    if (ldv_state_variable_0 == 1) {
#line 196
      ldv_retval_1 = mthca_init();
#line 198
      if (ldv_retval_1 == 0) {
#line 199
        ldv_state_variable_0 = 3;
#line 200
        ldv_state_variable_5 = 1;
#line 201
        ldv_state_variable_3 = 1;
#line 202
        ldv_state_variable_4 = 1;
#line 203
        ldv_state_variable_6 = 1;
      } else {

      }
#line 205
      if (ldv_retval_1 != 0) {
#line 206
        ldv_state_variable_0 = 2;
#line 207
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 211
    goto ldv_32602;
    default: 
#line 212
    ldv_stop();
    }
    ldv_32602: ;
  } else {

  }
#line 216
  goto ldv_32588;
  case 7: ;
#line 220
  if (ldv_state_variable_5 != 0) {
#line 221
    ldv_main_exported_5();
  } else {

  }
#line 224
  goto ldv_32588;
  default: 
#line 225
  ldv_stop();
  }
  ldv_32588: ;
#line 227
  goto ldv_32607;
  ldv_final: 
#line 229
  ldv_check_final_state();
#line 230
  return 0;
}
}
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 261
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 261
  ldv_func_res = tmp;
#line 263
  activate_work_1(ldv_func_arg3, 2);
#line 265
  return (ldv_func_res);
}
}
#line 268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 272
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 272
  ldv_func_res = tmp;
#line 274
  activate_work_1(& ldv_func_arg3->work, 2);
#line 276
  return (ldv_func_res);
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 283
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 283
  ldv_func_res = tmp;
#line 285
  activate_work_1(ldv_func_arg3, 2);
#line 287
  return (ldv_func_res);
}
}
#line 290 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 293
  flush_workqueue(ldv_func_arg1);
#line 295
  call_and_disable_all_1(2);
#line 296
  return;
}
}
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 302
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 302
  ldv_func_res = tmp;
#line 304
  activate_work_1(& ldv_func_arg3->work, 2);
#line 306
  return (ldv_func_res);
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
int ldv___pci_register_driver_10(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 313
  tmp = __pci_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 313
  ldv_func_res = tmp;
#line 315
  ldv_state_variable_7 = 1;
#line 316
  ldv_pci_driver_7();
#line 319
  return (ldv_func_res);
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_main.o.c.prepared"
void ldv_pci_unregister_driver_11(struct pci_driver *ldv_func_arg1 ) 
{ 


  {
#line 325
  pci_unregister_driver(ldv_func_arg1);
#line 327
  ldv_state_variable_7 = 0;
#line 328
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 396 "./arch/x86/include/asm/bitops.h"
__inline static int ffs(int x ) 
{ 
  int r ;

  {
#line 410
  __asm__  ("bsfl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 423
  return (r + 1);
}
}
#line 7 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 14 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 


  {
#line 30
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
#line 31
  return (val);
}
}
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 68 "include/uapi/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ 
  __u64 tmp ;

  {
#line 73
  tmp = __arch_swab64(val);
#line 73
  return (tmp);
}
}
#line 154 "include/uapi/linux/swab.h"
__inline static __u16 __swab16p(__u16 const   *p ) 
{ 
  __u16 tmp ;

  {
#line 159
  tmp = __fswab16((int )*p);
#line 159
  return (tmp);
}
}
#line 167 "include/uapi/linux/swab.h"
__inline static __u32 __swab32p(__u32 const   *p ) 
{ 
  __u32 tmp ;

  {
#line 172
  tmp = __fswab32(*p);
#line 172
  return (tmp);
}
}
#line 180 "include/uapi/linux/swab.h"
__inline static __u64 __swab64p(__u64 const   *p ) 
{ 
  __u64 tmp ;

  {
#line 185
  tmp = __fswab64(*p);
#line 185
  return (tmp);
}
}
#line 71 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u64 __be64_to_cpup(__be64 const   *p ) 
{ 
  __u64 tmp ;

  {
#line 73
  tmp = __swab64p(p);
#line 73
  return (tmp);
}
}
#line 79 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u32 __be32_to_cpup(__be32 const   *p ) 
{ 
  __u32 tmp ;

  {
#line 81
  tmp = __swab32p(p);
#line 81
  return (tmp);
}
}
#line 87 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u16 __be16_to_cpup(__be16 const   *p ) 
{ 
  __u16 tmp ;

  {
#line 89
  tmp = __swab16p(p);
#line 89
  return (tmp);
}
}
#line 3 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.o.c.prepared"
bool ldv_is_err(void const   *ptr ) ;
#line 5
void *ldv_err_ptr(long error ) ;
#line 6
long ldv_ptr_err(void const   *ptr ) ;
#line 187 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_3129: ;
#line 14
  return (pfo_ret__);
}
}
#line 26 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 32
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 11 "./arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField18.rlock);
#line 313
  return;
}
}
#line 355 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 357
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
#line 358
  return;
}
}
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 95
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long  ) ;
#line 106
extern void complete(struct completion * ) ;
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 292
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
#line 354 "include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
#line 361
  tmp___0 = __msecs_to_jiffies(m);
#line 361
  return (tmp___0);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_23(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_25(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_24(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_27(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_26(struct workqueue_struct *ldv_func_arg1 ) ;
#line 58 "./arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 58
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 58
  return (ret);
}
}
#line 62 "./arch/x86/include/asm/io.h"
__inline static unsigned int __readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 62
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)));
#line 62
  return (ret);
}
}
#line 70 "./arch/x86/include/asm/io.h"
__inline static void __writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 70
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)));
#line 71
  return;
}
}
#line 425 "include/linux/sched.h"
extern void schedule(void) ;
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 289
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 19 "include/linux/dmapool.h"
extern struct dma_pool *dma_pool_create(char const   * , struct device * , size_t  ,
                                        size_t  , size_t  ) ;
#line 22
extern void dma_pool_destroy(struct dma_pool * ) ;
#line 24
extern void *dma_pool_alloc(struct dma_pool * , gfp_t  , dma_addr_t * ) ;
#line 27
extern void dma_pool_free(struct dma_pool * , void * , dma_addr_t  ) ;
#line 32 "include/linux/semaphore.h"
__inline static void sema_init(struct semaphore *sem , int val ) 
{ 
  struct lock_class_key __key ;
  struct semaphore __constr_expr_0 ;

  {
#line 35
  __constr_expr_0.lock.raw_lock.val.counter = 0;
#line 35
  __constr_expr_0.lock.magic = 3735899821U;
#line 35
  __constr_expr_0.lock.owner_cpu = 4294967295U;
#line 35
  __constr_expr_0.lock.owner = (void *)-1;
#line 35
  __constr_expr_0.lock.dep_map.key = 0;
#line 35
  __constr_expr_0.lock.dep_map.class_cache[0] = 0;
#line 35
  __constr_expr_0.lock.dep_map.class_cache[1] = 0;
#line 35
  __constr_expr_0.lock.dep_map.name = "(*sem).lock";
#line 35
  __constr_expr_0.lock.dep_map.cpu = 0;
#line 35
  __constr_expr_0.lock.dep_map.ip = 0UL;
#line 35
  __constr_expr_0.count = (unsigned int )val;
#line 35
  __constr_expr_0.wait_list.next = & sem->wait_list;
#line 35
  __constr_expr_0.wait_list.prev = & sem->wait_list;
#line 35
  *sem = __constr_expr_0;
#line 36
  lockdep_init_map(& sem->lock.dep_map, "semaphore->lock", & __key, 0);
#line 37
  return;
}
}
#line 39
extern void down(struct semaphore * ) ;
#line 44
extern void up(struct semaphore * ) ;
#line 385 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
extern void __buggy_use_of_MTHCA_GET(void) ;
#line 386
extern void __buggy_use_of_MTHCA_PUT(void) ;
#line 248 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
void mthca_cmd_event(struct mthca_dev *dev , u16 token , u8 status , u64 out_param ) ;
#line 251
struct mthca_mailbox *mthca_alloc_mailbox(struct mthca_dev *dev , gfp_t gfp_mask ) ;
#line 253
void mthca_free_mailbox(struct mthca_dev *dev , struct mthca_mailbox *mailbox ) ;
#line 270
int mthca_INIT_IB(struct mthca_dev *dev , struct mthca_init_ib_param *param , int port ) ;
#line 275
int mthca_SET_IB(struct mthca_dev *dev , struct mthca_set_ib_param *param , int port ) ;
#line 277
int mthca_MAP_ICM(struct mthca_dev *dev , struct mthca_icm *icm , u64 virt ) ;
#line 278
int mthca_MAP_ICM_page(struct mthca_dev *dev , u64 dma_addr , u64 virt ) ;
#line 279
int mthca_UNMAP_ICM(struct mthca_dev *dev , u64 virt , u32 page_count___0 ) ;
#line 283
int mthca_SW2HW_MPT(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int mpt_index ) ;
#line 285
int mthca_HW2SW_MPT(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int mpt_index ) ;
#line 287
int mthca_WRITE_MTT(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int num_mtt ) ;
#line 289
int mthca_SYNC_TPT(struct mthca_dev *dev ) ;
#line 290
int mthca_MAP_EQ(struct mthca_dev *dev , u64 event_mask , int unmap , int eq_num ) ;
#line 292
int mthca_SW2HW_EQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int eq_num ) ;
#line 294
int mthca_HW2SW_EQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int eq_num ) ;
#line 296
int mthca_SW2HW_CQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int cq_num ) ;
#line 298
int mthca_HW2SW_CQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int cq_num ) ;
#line 300
int mthca_RESIZE_CQ(struct mthca_dev *dev , int cq_num , u32 lkey , u8 log_size ) ;
#line 301
int mthca_SW2HW_SRQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int srq_num ) ;
#line 303
int mthca_HW2SW_SRQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int srq_num ) ;
#line 305
int mthca_QUERY_SRQ(struct mthca_dev *dev , u32 num , struct mthca_mailbox *mailbox ) ;
#line 307
int mthca_ARM_SRQ(struct mthca_dev *dev , int srq_num , int limit ) ;
#line 308
int mthca_MODIFY_QP(struct mthca_dev *dev , enum ib_qp_state cur , enum ib_qp_state next ,
                    u32 num , int is_ee , struct mthca_mailbox *mailbox , u32 optmask ) ;
#line 311
int mthca_QUERY_QP(struct mthca_dev *dev , u32 num , int is_ee , struct mthca_mailbox *mailbox ) ;
#line 313
int mthca_CONF_SPECIAL_QP(struct mthca_dev *dev , int type , u32 qpn ) ;
#line 314
int mthca_MAD_IFC(struct mthca_dev *dev , int ignore_mkey , int ignore_bkey , int port ,
                  struct ib_wc  const  *in_wc , struct ib_grh  const  *in_grh , void const   *in_mad ,
                  void *response_mad ) ;
#line 317
int mthca_READ_MGM(struct mthca_dev *dev , int index , struct mthca_mailbox *mailbox ) ;
#line 319
int mthca_WRITE_MGM(struct mthca_dev *dev , int index , struct mthca_mailbox *mailbox ) ;
#line 321
int mthca_MGID_HASH(struct mthca_dev *dev , struct mthca_mailbox *mailbox , u16 *hash ) ;
#line 99 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
__inline static void mthca_icm_first(struct mthca_icm *icm , struct mthca_icm_iter *iter ) 
{ 
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
#line 102
  iter->icm = icm;
#line 104
  tmp___0 = list_empty((struct list_head  const  *)(& icm->chunk_list));
#line 104
  if (tmp___0 == 0) {
#line 104
    __mptr = (struct list_head  const  *)icm->chunk_list.next;
#line 104
    iter->chunk = (struct mthca_icm_chunk *)__mptr;
  } else {
#line 104
    iter->chunk = (struct mthca_icm_chunk *)0;
  }
#line 106
  iter->page_idx = 0;
#line 107
  return;
}
}
#line 109 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
__inline static int mthca_icm_last(struct mthca_icm_iter *iter ) 
{ 


  {
#line 111
  return ((unsigned long )iter->chunk == (unsigned long )((struct mthca_icm_chunk *)0));
}
}
#line 114 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
__inline static void mthca_icm_next(struct mthca_icm_iter *iter ) 
{ 
  struct list_head  const  *__mptr ;

  {
#line 116
  iter->page_idx = iter->page_idx + 1;
#line 116
  if (iter->page_idx >= (iter->chunk)->nsg) {
#line 117
    if ((unsigned long )(iter->chunk)->list.next == (unsigned long )(& (iter->icm)->chunk_list)) {
#line 118
      iter->chunk = (struct mthca_icm_chunk *)0;
#line 119
      return;
    } else {

    }
#line 122
    __mptr = (struct list_head  const  *)(iter->chunk)->list.next;
#line 122
    iter->chunk = (struct mthca_icm_chunk *)__mptr;
#line 124
    iter->page_idx = 0;
  } else {

  }
#line 126
  return;
}
}
#line 128 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
__inline static dma_addr_t mthca_icm_addr(struct mthca_icm_iter *iter ) 
{ 


  {
#line 130
  return (((struct scatterlist *)(& (iter->chunk)->mem) + (unsigned long )iter->page_idx)->dma_address);
}
}
#line 133 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
__inline static unsigned long mthca_icm_size(struct mthca_icm_iter *iter ) 
{ 


  {
#line 135
  return ((unsigned long )((struct scatterlist *)(& (iter->chunk)->mem) + (unsigned long )iter->page_idx)->dma_length);
}
}
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
static int fw_cmd_doorbell  =    0;
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
__inline static int go_bit(struct mthca_dev *dev ) 
{ 
  unsigned int tmp ;

  {
#line 194
  tmp = readl((void const volatile   *)dev->hcr + 24U);
#line 194
  return ((int )tmp & 32768);
}
}
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
static void mthca_cmd_post_dbell(struct mthca_dev *dev , u64 in_param , u64 out_param ,
                                 u32 in_modifier , u8 op_modifier , u16 op , u16 token ) 
{ 
  void *ptr ;
  u16 *offs ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;

  {
#line 206
  ptr = dev->cmd.dbell_map;
#line 207
  offs = (u16 *)(& dev->cmd.dbell_offsets);
#line 209
  tmp = __fswab32((__u32 )(in_param >> 32));
#line 209
  __writel(tmp, (void volatile   *)ptr + (unsigned long )*offs);
#line 210
  __asm__  volatile   ("sfence": : : "memory");
#line 211
  tmp___0 = __fswab32((__u32 )in_param);
#line 211
  __writel(tmp___0, (void volatile   *)ptr + (unsigned long )*(offs + 1UL));
#line 212
  __asm__  volatile   ("sfence": : : "memory");
#line 213
  tmp___1 = __fswab32(in_modifier);
#line 213
  __writel(tmp___1, (void volatile   *)ptr + (unsigned long )*(offs + 2UL));
#line 214
  __asm__  volatile   ("sfence": : : "memory");
#line 215
  tmp___2 = __fswab32((__u32 )(out_param >> 32));
#line 215
  __writel(tmp___2, (void volatile   *)ptr + (unsigned long )*(offs + 3UL));
#line 216
  __asm__  volatile   ("sfence": : : "memory");
#line 217
  tmp___3 = __fswab32((__u32 )out_param);
#line 217
  __writel(tmp___3, (void volatile   *)ptr + (unsigned long )*(offs + 4UL));
#line 218
  __asm__  volatile   ("sfence": : : "memory");
#line 219
  tmp___4 = __fswab32((__u32 )((int )token << 16));
#line 219
  __writel(tmp___4, (void volatile   *)ptr + (unsigned long )*(offs + 5UL));
#line 220
  __asm__  volatile   ("sfence": : : "memory");
#line 221
  tmp___5 = __fswab32((__u32 )((((int )op_modifier << 12) | 12582912) | (int )op));
#line 221
  __writel(tmp___5, (void volatile   *)ptr + (unsigned long )*(offs + 6UL));
#line 225
  __asm__  volatile   ("sfence": : : "memory");
#line 226
  __writel(0U, (void volatile   *)ptr + (unsigned long )*(offs + 7UL));
#line 227
  __asm__  volatile   ("sfence": : : "memory");
#line 228
  return;
}
}
#line 230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
static int mthca_cmd_post_hcr(struct mthca_dev *dev , u64 in_param , u64 out_param ,
                              u32 in_modifier , u8 op_modifier , u16 op , u16 token ,
                              int event ) 
{ 
  unsigned long end ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;

  {
#line 239
  if (event != 0) {
#line 240
    end = (unsigned long )jiffies + 2500UL;
#line 242
    goto ldv_31021;
    ldv_31020: 
#line 243
    tmp = get_current();
#line 243
    tmp->task_state_change = 0UL;
#line 243
    __ret = 0L;
#line 243
    switch (8UL) {
    case 1UL: 
#line 243
    tmp___0 = get_current();
#line 243
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
#line 243
    goto ldv_31014;
    case 2UL: 
#line 243
    tmp___1 = get_current();
#line 243
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
#line 243
    goto ldv_31014;
    case 4UL: 
#line 243
    tmp___2 = get_current();
#line 243
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
#line 243
    goto ldv_31014;
    case 8UL: 
#line 243
    tmp___3 = get_current();
#line 243
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
#line 243
    goto ldv_31014;
    default: 
#line 243
    __xchg_wrong_size();
    }
    ldv_31014: 
#line 244
    schedule();
    ldv_31021: 
#line 242
    tmp___4 = go_bit(dev);
#line 242
    if (tmp___4 != 0 && (long )((unsigned long )jiffies - end) < 0L) {
#line 244
      goto ldv_31020;
    } else {

    }

  } else {

  }
#line 248
  tmp___5 = go_bit(dev);
#line 248
  if (tmp___5 != 0) {
#line 249
    return (-11);
  } else {

  }
#line 257
  tmp___6 = __fswab32((__u32 )(in_param >> 32));
#line 257
  __writel(tmp___6, (void volatile   *)dev->hcr);
#line 258
  tmp___7 = __fswab32((__u32 )in_param);
#line 258
  __writel(tmp___7, (void volatile   *)dev->hcr + 4U);
#line 259
  tmp___8 = __fswab32(in_modifier);
#line 259
  __writel(tmp___8, (void volatile   *)dev->hcr + 8U);
#line 260
  tmp___9 = __fswab32((__u32 )(out_param >> 32));
#line 260
  __writel(tmp___9, (void volatile   *)dev->hcr + 12U);
#line 261
  tmp___10 = __fswab32((__u32 )out_param);
#line 261
  __writel(tmp___10, (void volatile   *)dev->hcr + 16U);
#line 262
  tmp___11 = __fswab32((__u32 )((int )token << 16));
#line 262
  __writel(tmp___11, (void volatile   *)dev->hcr + 20U);
#line 265
  __asm__  volatile   ("sfence": : : "memory");
#line 267
  tmp___12 = __fswab32((__u32 )(((event != 0 ? 12582912 : 8388608) | ((int )op_modifier << 12)) | (int )op));
#line 267
  __writel(tmp___12, (void volatile   *)dev->hcr + 24U);
#line 272
  return (0);
}
}
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
static int mthca_cmd_post(struct mthca_dev *dev , u64 in_param , u64 out_param , u32 in_modifier ,
                          u8 op_modifier , u16 op , u16 token , int event ) 
{ 
  int err ;

  {
#line 284
  err = 0;
#line 286
  mutex_lock_nested(& dev->cmd.hcr_mutex, 0U);
#line 288
  if ((event != 0 && (dev->cmd.flags & 2U) != 0U) && fw_cmd_doorbell != 0) {
#line 289
    mthca_cmd_post_dbell(dev, in_param, out_param, in_modifier, (int )op_modifier,
                         (int )op, (int )token);
  } else {
#line 292
    err = mthca_cmd_post_hcr(dev, in_param, out_param, in_modifier, (int )op_modifier,
                             (int )op, (int )token, event);
  }
#line 299
  __asm__  volatile   ("": : : "memory");
#line 301
  mutex_unlock(& dev->cmd.hcr_mutex);
#line 302
  return (err);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
static int mthca_status_to_errno(u8 status ) 
{ 
  int trans_table[65U] ;

  {
#line 308
  trans_table[0] = 0;
#line 308
  trans_table[1] = -5;
#line 308
  trans_table[2] = -1;
#line 308
  trans_table[3] = -22;
#line 308
  trans_table[4] = -6;
#line 308
  trans_table[5] = -9;
#line 308
  trans_table[6] = -16;
#line 308
  trans_table[7] = -12;
#line 308
  trans_table[8] = -12;
#line 308
  trans_table[9] = -9;
#line 308
  trans_table[10] = -9;
#line 308
  trans_table[11] = -14;
#line 308
  trans_table[12] = 0;
#line 308
  trans_table[13] = 0;
#line 308
  trans_table[14] = 0;
#line 308
  trans_table[15] = 0;
#line 308
  trans_table[16] = -22;
#line 308
  trans_table[17] = 0;
#line 308
  trans_table[18] = 0;
#line 308
  trans_table[19] = 0;
#line 308
  trans_table[20] = 0;
#line 308
  trans_table[21] = 0;
#line 308
  trans_table[22] = 0;
#line 308
  trans_table[23] = 0;
#line 308
  trans_table[24] = 0;
#line 308
  trans_table[25] = 0;
#line 308
  trans_table[26] = 0;
#line 308
  trans_table[27] = 0;
#line 308
  trans_table[28] = 0;
#line 308
  trans_table[29] = 0;
#line 308
  trans_table[30] = 0;
#line 308
  trans_table[31] = 0;
#line 308
  trans_table[32] = -14;
#line 308
  trans_table[33] = -16;
#line 308
  trans_table[34] = -11;
#line 308
  trans_table[35] = 0;
#line 308
  trans_table[36] = 0;
#line 308
  trans_table[37] = 0;
#line 308
  trans_table[38] = 0;
#line 308
  trans_table[39] = 0;
#line 308
  trans_table[40] = 0;
#line 308
  trans_table[41] = 0;
#line 308
  trans_table[42] = 0;
#line 308
  trans_table[43] = 0;
#line 308
  trans_table[44] = 0;
#line 308
  trans_table[45] = 0;
#line 308
  trans_table[46] = 0;
#line 308
  trans_table[47] = 0;
#line 308
  trans_table[48] = -74;
#line 308
  trans_table[49] = 0;
#line 308
  trans_table[50] = 0;
#line 308
  trans_table[51] = 0;
#line 308
  trans_table[52] = 0;
#line 308
  trans_table[53] = 0;
#line 308
  trans_table[54] = 0;
#line 308
  trans_table[55] = 0;
#line 308
  trans_table[56] = 0;
#line 308
  trans_table[57] = 0;
#line 308
  trans_table[58] = 0;
#line 308
  trans_table[59] = 0;
#line 308
  trans_table[60] = 0;
#line 308
  trans_table[61] = 0;
#line 308
  trans_table[62] = 0;
#line 308
  trans_table[63] = 0;
#line 308
  trans_table[64] = -12;
#line 328
  if ((unsigned int )status > 64U || ((unsigned int )status != 0U && trans_table[(int )status] == 0)) {
#line 331
    return (-22);
  } else {

  }
#line 333
  return (trans_table[(int )status]);
}
}
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
static int mthca_cmd_poll(struct mthca_dev *dev , u64 in_param , u64 *out_param ,
                          int out_is_imm , u32 in_modifier , u8 op_modifier , u16 op ,
                          unsigned long timeout ) 
{ 
  int err ;
  unsigned long end ;
  u8 status ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  __u32 tmp___7 ;
  unsigned int tmp___8 ;
  __u32 tmp___9 ;
  unsigned int tmp___10 ;
  __u32 tmp___11 ;

  {
#line 346
  err = 0;
#line 350
  down(& dev->cmd.poll_sem);
#line 352
  err = mthca_cmd_post(dev, in_param, (unsigned long )out_param != (unsigned long )((u64 *)0ULL) ? *out_param : 0ULL,
                       in_modifier, (int )op_modifier, (int )op, 65535, 0);
#line 356
  if (err != 0) {
#line 357
    goto out;
  } else {

  }
#line 359
  end = timeout + (unsigned long )jiffies;
#line 360
  goto ldv_31069;
  ldv_31068: 
#line 361
  tmp = get_current();
#line 361
  tmp->task_state_change = 0UL;
#line 361
  __ret = 0L;
#line 361
  switch (8UL) {
  case 1UL: 
#line 361
  tmp___0 = get_current();
#line 361
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
#line 361
  goto ldv_31062;
  case 2UL: 
#line 361
  tmp___1 = get_current();
#line 361
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
#line 361
  goto ldv_31062;
  case 4UL: 
#line 361
  tmp___2 = get_current();
#line 361
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 361
  goto ldv_31062;
  case 8UL: 
#line 361
  tmp___3 = get_current();
#line 361
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
#line 361
  goto ldv_31062;
  default: 
#line 361
  __xchg_wrong_size();
  }
  ldv_31062: 
#line 362
  schedule();
  ldv_31069: 
#line 360
  tmp___4 = go_bit(dev);
#line 360
  if (tmp___4 != 0 && (long )((unsigned long )jiffies - end) < 0L) {
#line 362
    goto ldv_31068;
  } else {

  }
#line 365
  tmp___5 = go_bit(dev);
#line 365
  if (tmp___5 != 0) {
#line 366
    err = -16;
#line 367
    goto out;
  } else {

  }
#line 370
  if (out_is_imm != 0) {
#line 371
    tmp___6 = __readl((void const volatile   *)dev->hcr + 12U);
#line 371
    tmp___7 = __fswab32(tmp___6);
#line 371
    tmp___8 = __readl((void const volatile   *)dev->hcr + 16U);
#line 371
    tmp___9 = __fswab32(tmp___8);
#line 371
    *out_param = ((unsigned long long )tmp___7 << 32) | (unsigned long long )tmp___9;
  } else {

  }
#line 377
  tmp___10 = __readl((void const volatile   *)dev->hcr + 24U);
#line 377
  tmp___11 = __fswab32(tmp___10);
#line 377
  status = (u8 )(tmp___11 >> 24);
#line 378
  if ((unsigned int )status != 0U) {
#line 379
    if (mthca_debug_level != 0) {
#line 379
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Command %02x completed with status %02x\n",
                 (int )op, (int )status);
    } else {

    }
#line 381
    err = mthca_status_to_errno((int )status);
  } else {

  }
  out: 
#line 385
  up(& dev->cmd.poll_sem);
#line 386
  return (err);
}
}
#line 389 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
void mthca_cmd_event(struct mthca_dev *dev , u16 token , u8 status , u64 out_param ) 
{ 
  struct mthca_cmd_context *context ;

  {
#line 394
  context = dev->cmd.context + (unsigned long )((int )dev->cmd.token_mask & (int )token);
#line 398
  if ((int )context->token != (int )token) {
#line 399
    return;
  } else {

  }
#line 401
  context->result = 0;
#line 402
  context->status = status;
#line 403
  context->out_param = out_param;
#line 405
  complete(& context->done);
#line 406
  return;
}
}
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
static int mthca_cmd_wait(struct mthca_dev *dev , u64 in_param , u64 *out_param ,
                          int out_is_imm , u32 in_modifier , u8 op_modifier , u16 op ,
                          unsigned long timeout ) 
{ 
  int err ;
  struct mthca_cmd_context *context ;
  long tmp ;
  unsigned long tmp___0 ;

  {
#line 417
  err = 0;
#line 420
  down(& dev->cmd.event_sem);
#line 422
  spin_lock(& dev->cmd.context_lock);
#line 423
  tmp = ldv__builtin_expect(dev->cmd.free_head < 0, 0L);
#line 423
  if (tmp != 0L) {
#line 423
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"),
                         "i" (423), "i" (12UL));
    ldv_31090: ;
#line 423
    goto ldv_31090;
  } else {

  }
#line 424
  context = dev->cmd.context + (unsigned long )dev->cmd.free_head;
#line 425
  context->token = (unsigned int )((int )context->token + (int )dev->cmd.token_mask) + 1U;
#line 426
  dev->cmd.free_head = context->next;
#line 427
  spin_unlock(& dev->cmd.context_lock);
#line 429
  init_completion(& context->done);
#line 431
  err = mthca_cmd_post(dev, in_param, (unsigned long )out_param != (unsigned long )((u64 *)0ULL) ? *out_param : 0ULL,
                       in_modifier, (int )op_modifier, (int )op, (int )context->token,
                       1);
#line 435
  if (err != 0) {
#line 436
    goto out;
  } else {

  }
#line 438
  tmp___0 = wait_for_completion_timeout(& context->done, timeout);
#line 438
  if (tmp___0 == 0UL) {
#line 439
    err = -16;
#line 440
    goto out;
  } else {

  }
#line 443
  err = context->result;
#line 444
  if (err != 0) {
#line 445
    goto out;
  } else {

  }
#line 447
  if ((unsigned int )context->status != 0U) {
#line 448
    if (mthca_debug_level != 0) {
#line 448
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Command %02x completed with status %02x\n",
                 (int )op, (int )context->status);
    } else {

    }
#line 450
    err = mthca_status_to_errno((int )context->status);
  } else {

  }
#line 453
  if (out_is_imm != 0) {
#line 454
    *out_param = context->out_param;
  } else {

  }
  out: 
#line 457
  spin_lock(& dev->cmd.context_lock);
#line 458
  context->next = dev->cmd.free_head;
#line 459
  dev->cmd.free_head = (int )(((long )context - (long )dev->cmd.context) / 120L);
#line 460
  spin_unlock(& dev->cmd.context_lock);
#line 462
  up(& dev->cmd.event_sem);
#line 463
  return (err);
}
}
#line 467 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
static int mthca_cmd_box(struct mthca_dev *dev , u64 in_param , u64 out_param , u32 in_modifier ,
                         u8 op_modifier , u16 op , unsigned long timeout ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 475
  if ((int )dev->cmd.flags & 1) {
#line 476
    tmp = mthca_cmd_wait(dev, in_param, & out_param, 0, in_modifier, (int )op_modifier,
                         (int )op, timeout);
#line 476
    return (tmp);
  } else {
#line 480
    tmp___0 = mthca_cmd_poll(dev, in_param, & out_param, 0, in_modifier, (int )op_modifier,
                             (int )op, timeout);
#line 480
    return (tmp___0);
  }
}
}
#line 486 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
static int mthca_cmd(struct mthca_dev *dev , u64 in_param , u32 in_modifier , u8 op_modifier ,
                     u16 op , unsigned long timeout ) 
{ 
  int tmp ;

  {
#line 493
  tmp = mthca_cmd_box(dev, in_param, 0ULL, in_modifier, (int )op_modifier, (int )op,
                      timeout);
#line 493
  return (tmp);
}
}
#line 502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
static int mthca_cmd_imm(struct mthca_dev *dev , u64 in_param , u64 *out_param , u32 in_modifier ,
                         u8 op_modifier , u16 op , unsigned long timeout ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 510
  if ((int )dev->cmd.flags & 1) {
#line 511
    tmp = mthca_cmd_wait(dev, in_param, out_param, 1, in_modifier, (int )op_modifier,
                         (int )op, timeout);
#line 511
    return (tmp);
  } else {
#line 515
    tmp___0 = mthca_cmd_poll(dev, in_param, out_param, 1, in_modifier, (int )op_modifier,
                             (int )op, timeout);
#line 515
    return (tmp___0);
  }
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_cmd_init(struct mthca_dev *dev ) 
{ 
  struct lock_class_key __key ;

  {
#line 522
  __mutex_init(& dev->cmd.hcr_mutex, "&dev->cmd.hcr_mutex", & __key);
#line 523
  sema_init(& dev->cmd.poll_sem, 1);
#line 524
  dev->cmd.flags = 0U;
#line 526
  dev->hcr = ioremap((dev->pdev)->resource[0].start + 525952ULL, 28UL);
#line 528
  if ((unsigned long )dev->hcr == (unsigned long )((void *)0)) {
#line 529
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Couldn\'t map command register.");
#line 530
    return (-12);
  } else {

  }
#line 533
  dev->cmd.pool = dma_pool_create("mthca_cmd", & (dev->pdev)->dev, 4096UL, 4096UL,
                                  0UL);
#line 536
  if ((unsigned long )dev->cmd.pool == (unsigned long )((struct dma_pool *)0)) {
#line 537
    iounmap((void volatile   *)dev->hcr);
#line 538
    return (-12);
  } else {

  }
#line 541
  return (0);
}
}
#line 544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
void mthca_cmd_cleanup(struct mthca_dev *dev ) 
{ 


  {
#line 546
  dma_pool_destroy(dev->cmd.pool);
#line 547
  iounmap((void volatile   *)dev->hcr);
#line 548
  if ((dev->cmd.flags & 2U) != 0U) {
#line 549
    iounmap((void volatile   *)dev->cmd.dbell_map);
  } else {

  }
#line 550
  return;
}
}
#line 556 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_cmd_use_events(struct mthca_dev *dev ) 
{ 
  int i ;
  void *tmp ;
  struct lock_class_key __key ;

  {
#line 560
  tmp = kmalloc((unsigned long )dev->cmd.max_cmds * 120UL, 208U);
#line 560
  dev->cmd.context = (struct mthca_cmd_context *)tmp;
#line 563
  if ((unsigned long )dev->cmd.context == (unsigned long )((struct mthca_cmd_context *)0)) {
#line 564
    return (-12);
  } else {

  }
#line 566
  i = 0;
#line 566
  goto ldv_31130;
  ldv_31129: 
#line 567
  (dev->cmd.context + (unsigned long )i)->token = (u16 )i;
#line 568
  (dev->cmd.context + (unsigned long )i)->next = i + 1;
#line 566
  i = i + 1;
  ldv_31130: ;
#line 566
  if (dev->cmd.max_cmds > i) {
#line 568
    goto ldv_31129;
  } else {

  }
#line 571
  (dev->cmd.context + ((unsigned long )dev->cmd.max_cmds + 0xffffffffffffffffUL))->next = -1;
#line 572
  dev->cmd.free_head = 0;
#line 574
  sema_init(& dev->cmd.event_sem, dev->cmd.max_cmds);
#line 575
  spinlock_check(& dev->cmd.context_lock);
#line 575
  __raw_spin_lock_init(& dev->cmd.context_lock.__annonCompField18.rlock, "&(&dev->cmd.context_lock)->rlock",
                       & __key);
#line 577
  dev->cmd.token_mask = 1U;
#line 577
  goto ldv_31134;
  ldv_31133: 
#line 579
  dev->cmd.token_mask = (int )dev->cmd.token_mask << 1U;
  ldv_31134: ;
#line 577
  if ((int )dev->cmd.token_mask < dev->cmd.max_cmds) {
#line 580
    goto ldv_31133;
  } else {

  }
#line 581
  dev->cmd.token_mask = (u16 )((int )dev->cmd.token_mask - 1);
#line 583
  dev->cmd.flags = dev->cmd.flags | 1U;
#line 585
  down(& dev->cmd.poll_sem);
#line 587
  return (0);
}
}
#line 593 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
void mthca_cmd_use_polling(struct mthca_dev *dev ) 
{ 
  int i ;

  {
#line 597
  dev->cmd.flags = dev->cmd.flags & 4294967294U;
#line 599
  i = 0;
#line 599
  goto ldv_31141;
  ldv_31140: 
#line 600
  down(& dev->cmd.event_sem);
#line 599
  i = i + 1;
  ldv_31141: ;
#line 599
  if (dev->cmd.max_cmds > i) {
#line 601
    goto ldv_31140;
  } else {

  }
#line 602
  kfree((void const   *)dev->cmd.context);
#line 604
  up(& dev->cmd.poll_sem);
#line 605
  return;
}
}
#line 607 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
struct mthca_mailbox *mthca_alloc_mailbox(struct mthca_dev *dev , gfp_t gfp_mask ) 
{ 
  struct mthca_mailbox *mailbox ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 612
  tmp = kmalloc(16UL, gfp_mask);
#line 612
  mailbox = (struct mthca_mailbox *)tmp;
#line 613
  if ((unsigned long )mailbox == (unsigned long )((struct mthca_mailbox *)0)) {
#line 614
    tmp___0 = ERR_PTR(-12L);
#line 614
    return ((struct mthca_mailbox *)tmp___0);
  } else {

  }
#line 616
  mailbox->buf = dma_pool_alloc(dev->cmd.pool, gfp_mask, & mailbox->dma);
#line 617
  if ((unsigned long )mailbox->buf == (unsigned long )((void *)0)) {
#line 618
    kfree((void const   *)mailbox);
#line 619
    tmp___1 = ERR_PTR(-12L);
#line 619
    return ((struct mthca_mailbox *)tmp___1);
  } else {

  }
#line 622
  return (mailbox);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
void mthca_free_mailbox(struct mthca_dev *dev , struct mthca_mailbox *mailbox ) 
{ 


  {
#line 627
  if ((unsigned long )mailbox == (unsigned long )((struct mthca_mailbox *)0)) {
#line 628
    return;
  } else {

  }
#line 630
  dma_pool_free(dev->cmd.pool, mailbox->buf, mailbox->dma);
#line 631
  kfree((void const   *)mailbox);
#line 632
  return;
}
}
#line 634 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_SYS_EN(struct mthca_dev *dev ) 
{ 
  u64 out ;
  int ret ;

  {
#line 639
  ret = mthca_cmd_imm(dev, 0ULL, & out, 0U, 0, 1, 15000UL);
#line 641
  if (ret == -12) {
#line 642
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "SYS_EN DDR error: syn=%x, sock=%d, sladdr=%d, SPD source=%s\n",
             (int )(out >> 6) & 15, (int )(out >> 4) & 3, (int )(out >> 1) & 7, (int )out & 1 ? (char *)"NVMEM" : (char *)"DIMM");
  } else {

  }
#line 647
  return (ret);
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_SYS_DIS(struct mthca_dev *dev ) 
{ 
  int tmp ;

  {
#line 652
  tmp = mthca_cmd(dev, 0ULL, 0U, 0, 2, 15000UL);
#line 652
  return (tmp);
}
}
#line 655 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
static int mthca_map_cmd(struct mthca_dev *dev , u16 op , struct mthca_icm *icm ,
                         u64 virt ) 
{ 
  struct mthca_mailbox *mailbox ;
  struct mthca_icm_iter iter ;
  __be64 *pages ;
  int lg ;
  int nent ;
  int i ;
  int err ;
  int ts ;
  int tc ;
  long tmp ;
  bool tmp___0 ;
  dma_addr_t tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  dma_addr_t tmp___5 ;
  __u64 tmp___6 ;
  dma_addr_t tmp___7 ;
  __u64 tmp___8 ;
  unsigned long tmp___9 ;
  int tmp___10 ;

  {
#line 662
  nent = 0;
#line 664
  err = 0;
#line 665
  ts = 0;
#line 665
  tc = 0;
#line 667
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 668
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 668
  if ((int )tmp___0) {
#line 669
    tmp = PTR_ERR((void const   *)mailbox);
#line 669
    return ((int )tmp);
  } else {

  }
#line 670
  memset(mailbox->buf, 0, 4096UL);
#line 671
  pages = (__be64 *)mailbox->buf;
#line 673
  mthca_icm_first(icm, & iter);
#line 673
  goto ldv_31180;
  ldv_31179: 
#line 681
  tmp___1 = mthca_icm_addr(& iter);
#line 681
  tmp___2 = mthca_icm_size(& iter);
#line 681
  tmp___3 = ffs((int )((unsigned int )tmp___1 | (unsigned int )tmp___2));
#line 681
  lg = tmp___3 + -1;
#line 682
  if (lg <= 11) {
#line 683
    tmp___4 = mthca_icm_size(& iter);
#line 683
    tmp___5 = mthca_icm_addr(& iter);
#line 683
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Got FW area not aligned to %d (%llx/%lx).\n",
             4096, tmp___5, tmp___4);
#line 687
    err = -22;
#line 688
    goto out;
  } else {

  }
#line 690
  i = 0;
#line 690
  goto ldv_31177;
  ldv_31176: ;
#line 691
  if (virt != 0xffffffffffffffffULL) {
#line 692
    tmp___6 = __fswab64(virt);
#line 692
    *(pages + (unsigned long )(nent * 2)) = tmp___6;
#line 693
    virt = (u64 )(1 << lg) + virt;
  } else {

  }
#line 696
  tmp___7 = mthca_icm_addr(& iter);
#line 696
  tmp___8 = __fswab64((tmp___7 + (dma_addr_t )(i << lg)) | (dma_addr_t )(lg + -12));
#line 696
  *(pages + ((unsigned long )(nent * 2) + 1UL)) = tmp___8;
#line 699
  ts = (1 << (lg + -10)) + ts;
#line 700
  tc = tc + 1;
#line 702
  nent = nent + 1;
#line 702
  if (nent == 256) {
#line 703
    err = mthca_cmd(dev, mailbox->dma, (u32 )nent, 0, (int )op, 15000UL);
#line 705
    if (err != 0) {
#line 706
      goto out;
    } else {

    }
#line 707
    nent = 0;
  } else {

  }
#line 690
  i = i + 1;
  ldv_31177: 
#line 690
  tmp___9 = mthca_icm_size(& iter);
#line 690
  if ((unsigned long )i < tmp___9 >> lg) {
#line 692
    goto ldv_31176;
  } else {

  }
#line 675
  mthca_icm_next(& iter);
  ldv_31180: 
#line 673
  tmp___10 = mthca_icm_last(& iter);
#line 673
  if (tmp___10 == 0) {
#line 676
    goto ldv_31179;
  } else {

  }

#line 712
  if (nent != 0) {
#line 713
    err = mthca_cmd(dev, mailbox->dma, (u32 )nent, 0, (int )op, 15000UL);
  } else {

  }
#line 716
  switch ((int )op) {
  case 4095: ;
#line 718
  if (mthca_debug_level != 0) {
#line 718
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Mapped %d chunks/%d KB for FW.\n",
               tc, ts);
  } else {

  }
#line 719
  goto ldv_31183;
  case 4092: ;
#line 721
  if (mthca_debug_level != 0) {
#line 721
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Mapped %d chunks/%d KB for ICM aux.\n",
               tc, ts);
  } else {

  }
#line 722
  goto ldv_31183;
  case 4090: ;
#line 724
  if (mthca_debug_level != 0) {
#line 724
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Mapped %d chunks/%d KB at %llx for ICM.\n",
               tc, ts, virt - (u64 )(ts << 10));
  } else {

  }
#line 726
  goto ldv_31183;
  }
  ldv_31183: ;
  out: 
#line 730
  mthca_free_mailbox(dev, mailbox);
#line 731
  return (err);
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_MAP_FA(struct mthca_dev *dev , struct mthca_icm *icm ) 
{ 
  int tmp ;

  {
#line 736
  tmp = mthca_map_cmd(dev, 4095, icm, 0xffffffffffffffffULL);
#line 736
  return (tmp);
}
}
#line 739 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_UNMAP_FA(struct mthca_dev *dev ) 
{ 
  int tmp ;

  {
#line 741
  tmp = mthca_cmd(dev, 0ULL, 0U, 0, 4094, 15000UL);
#line 741
  return (tmp);
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_RUN_FW(struct mthca_dev *dev ) 
{ 
  int tmp ;

  {
#line 746
  tmp = mthca_cmd(dev, 0ULL, 0U, 0, 4086, 15000UL);
#line 746
  return (tmp);
}
}
#line 749 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
static void mthca_setup_cmd_doorbells(struct mthca_dev *dev , u64 base ) 
{ 
  phys_addr_t addr ;
  u16 max_off ;
  int i ;
  u16 _max1 ;
  u16 _max2 ;

  {
#line 752
  max_off = 0U;
#line 755
  i = 0;
#line 755
  goto ldv_31207;
  ldv_31206: 
#line 756
  _max1 = max_off;
#line 756
  _max2 = dev->cmd.dbell_offsets[i];
#line 756
  max_off = (u16 )((int )_max1 > (int )_max2 ? _max1 : _max2);
#line 755
  i = i + 1;
  ldv_31207: ;
#line 755
  if (i <= 7) {
#line 757
    goto ldv_31206;
  } else {

  }

#line 758
  if (((((u64 )max_off + base) ^ base) & 0xfffffffffffff000ULL) != 0ULL) {
#line 759
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Firmware doorbell region at 0x%016llx, length 0x%x crosses a page boundary\n",
             base, (int )max_off);
#line 762
    return;
  } else {

  }
#line 765
  addr = (dev->pdev)->resource[2].start + (((dev->pdev)->resource[2].start != 0ULL || (dev->pdev)->resource[2].end != (dev->pdev)->resource[2].start ? (dev->pdev)->resource[2].end - (dev->pdev)->resource[2].start : 0xffffffffffffffffULL) & base);
#line 767
  dev->cmd.dbell_map = ioremap(addr, (unsigned long )max_off + 4UL);
#line 768
  if ((unsigned long )dev->cmd.dbell_map == (unsigned long )((void *)0)) {
#line 769
    return;
  } else {

  }
#line 771
  dev->cmd.flags = dev->cmd.flags | 2U;
#line 772
  if (mthca_debug_level != 0) {
#line 772
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Mapped doorbell page for posting FW commands\n");
  } else {

  }
#line 773
  return;
}
}
#line 775 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_QUERY_FW(struct mthca_dev *dev ) 
{ 
  struct mthca_mailbox *mailbox ;
  u32 *outbox ;
  u64 base ;
  u32 tmp ;
  int err ;
  u8 lg ;
  int i ;
  long tmp___0 ;
  bool tmp___1 ;
  void *__p ;
  __u16 tmp___2 ;
  __u32 tmp___3 ;
  void *__p___0 ;
  __u16 tmp___4 ;
  __u32 tmp___5 ;
  __u64 tmp___6 ;
  void *__p___1 ;
  __u16 tmp___7 ;
  __u32 tmp___8 ;
  void *__p___2 ;
  __u16 tmp___9 ;
  __u64 tmp___10 ;
  void *__p___3 ;
  __u16 tmp___11 ;
  __u64 tmp___12 ;
  void *__p___4 ;
  __u16 tmp___13 ;
  __u32 tmp___14 ;
  void *__p___5 ;
  __u32 tmp___15 ;
  __u64 tmp___16 ;
  void *__p___6 ;
  __u32 tmp___17 ;
  __u64 tmp___18 ;
  void *__p___7 ;
  __u16 tmp___19 ;
  __u32 tmp___20 ;
  void *__p___8 ;
  __u16 tmp___21 ;
  __u32 tmp___22 ;
  void *__p___9 ;
  __u16 tmp___23 ;
  __u32 tmp___24 ;
  void *__p___10 ;
  __u16 tmp___25 ;
  __u32 tmp___26 ;
  void *__p___11 ;
  __u16 tmp___27 ;
  __u32 tmp___28 ;
  int tmp___29 ;

  {
#line 781
  err = 0;
#line 803
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 804
  tmp___1 = IS_ERR((void const   *)mailbox);
#line 804
  if ((int )tmp___1) {
#line 805
    tmp___0 = PTR_ERR((void const   *)mailbox);
#line 805
    return ((int )tmp___0);
  } else {

  }
#line 806
  outbox = (u32 *)mailbox->buf;
#line 808
  err = mthca_cmd_box(dev, 0ULL, mailbox->dma, 0U, 0, 4, 15000UL);
#line 811
  if (err != 0) {
#line 812
    goto out;
  } else {

  }
#line 814
  __p = (void *)outbox;
#line 814
  switch (8UL) {
  case 1UL: 
#line 814
  dev->fw_ver = (u64 )*((u8 *)__p);
#line 814
  goto ldv_31222;
  case 2UL: 
#line 814
  tmp___2 = __be16_to_cpup((__be16 const   *)__p);
#line 814
  dev->fw_ver = (u64 )tmp___2;
#line 814
  goto ldv_31222;
  case 4UL: 
#line 814
  tmp___3 = __be32_to_cpup((__be32 const   *)__p);
#line 814
  dev->fw_ver = (u64 )tmp___3;
#line 814
  goto ldv_31222;
  case 8UL: 
#line 814
  dev->fw_ver = __be64_to_cpup((__be64 const   *)__p);
#line 814
  goto ldv_31222;
  default: 
#line 814
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31222: 
#line 819
  dev->fw_ver = ((dev->fw_ver & 281470681743360ULL) | ((dev->fw_ver & 4294901760ULL) >> 16)) | ((dev->fw_ver << 16) & 4294967295ULL);
#line 823
  __p___0 = (void *)outbox + 15U;
#line 823
  switch (1UL) {
  case 1UL: 
#line 823
  lg = *((u8 *)__p___0);
#line 823
  goto ldv_31229;
  case 2UL: 
#line 823
  tmp___4 = __be16_to_cpup((__be16 const   *)__p___0);
#line 823
  lg = (u8 )tmp___4;
#line 823
  goto ldv_31229;
  case 4UL: 
#line 823
  tmp___5 = __be32_to_cpup((__be32 const   *)__p___0);
#line 823
  lg = (u8 )tmp___5;
#line 823
  goto ldv_31229;
  case 8UL: 
#line 823
  tmp___6 = __be64_to_cpup((__be64 const   *)__p___0);
#line 823
  lg = (u8 )tmp___6;
#line 823
  goto ldv_31229;
  default: 
#line 823
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31229: 
#line 824
  dev->cmd.max_cmds = 1 << (int )lg;
#line 826
  if (mthca_debug_level != 0) {
#line 826
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "FW version %012llx, max commands %d\n",
               dev->fw_ver, dev->cmd.max_cmds);
  } else {

  }
#line 829
  __p___1 = (void *)outbox + 48U;
#line 829
  switch (8UL) {
  case 1UL: 
#line 829
  dev->catas_err.addr = (u64 )*((u8 *)__p___1);
#line 829
  goto ldv_31236;
  case 2UL: 
#line 829
  tmp___7 = __be16_to_cpup((__be16 const   *)__p___1);
#line 829
  dev->catas_err.addr = (u64 )tmp___7;
#line 829
  goto ldv_31236;
  case 4UL: 
#line 829
  tmp___8 = __be32_to_cpup((__be32 const   *)__p___1);
#line 829
  dev->catas_err.addr = (u64 )tmp___8;
#line 829
  goto ldv_31236;
  case 8UL: 
#line 829
  dev->catas_err.addr = __be64_to_cpup((__be64 const   *)__p___1);
#line 829
  goto ldv_31236;
  default: 
#line 829
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31236: 
#line 830
  __p___2 = (void *)outbox + 56U;
#line 830
  switch (4UL) {
  case 1UL: 
#line 830
  dev->catas_err.size = (u32 )*((u8 *)__p___2);
#line 830
  goto ldv_31243;
  case 2UL: 
#line 830
  tmp___9 = __be16_to_cpup((__be16 const   *)__p___2);
#line 830
  dev->catas_err.size = (u32 )tmp___9;
#line 830
  goto ldv_31243;
  case 4UL: 
#line 830
  dev->catas_err.size = __be32_to_cpup((__be32 const   *)__p___2);
#line 830
  goto ldv_31243;
  case 8UL: 
#line 830
  tmp___10 = __be64_to_cpup((__be64 const   *)__p___2);
#line 830
  dev->catas_err.size = (u32 )tmp___10;
#line 830
  goto ldv_31243;
  default: 
#line 830
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31243: ;
#line 832
  if (mthca_debug_level != 0) {
#line 832
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Catastrophic error buffer at 0x%llx, size 0x%x\n",
               dev->catas_err.addr, dev->catas_err.size);
  } else {

  }
#line 835
  __p___3 = (void *)outbox + 16U;
#line 835
  switch (4UL) {
  case 1UL: 
#line 835
  tmp = (u32 )*((u8 *)__p___3);
#line 835
  goto ldv_31250;
  case 2UL: 
#line 835
  tmp___11 = __be16_to_cpup((__be16 const   *)__p___3);
#line 835
  tmp = (u32 )tmp___11;
#line 835
  goto ldv_31250;
  case 4UL: 
#line 835
  tmp = __be32_to_cpup((__be32 const   *)__p___3);
#line 835
  goto ldv_31250;
  case 8UL: 
#line 835
  tmp___12 = __be64_to_cpup((__be64 const   *)__p___3);
#line 835
  tmp = (u32 )tmp___12;
#line 835
  goto ldv_31250;
  default: 
#line 835
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31250: ;
#line 836
  if ((int )tmp & 1) {
#line 837
    if (mthca_debug_level != 0) {
#line 837
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "FW supports commands through doorbells\n");
    } else {

    }
#line 839
    __p___4 = (void *)outbox + 96U;
#line 839
    switch (8UL) {
    case 1UL: 
#line 839
    base = (u64 )*((u8 *)__p___4);
#line 839
    goto ldv_31257;
    case 2UL: 
#line 839
    tmp___13 = __be16_to_cpup((__be16 const   *)__p___4);
#line 839
    base = (u64 )tmp___13;
#line 839
    goto ldv_31257;
    case 4UL: 
#line 839
    tmp___14 = __be32_to_cpup((__be32 const   *)__p___4);
#line 839
    base = (u64 )tmp___14;
#line 839
    goto ldv_31257;
    case 8UL: 
#line 839
    base = __be64_to_cpup((__be64 const   *)__p___4);
#line 839
    goto ldv_31257;
    default: 
#line 839
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31257: 
#line 840
    i = 0;
#line 840
    goto ldv_31270;
    ldv_31269: 
#line 841
    __p___5 = (void *)outbox + (unsigned long )((i << 1) + 80);
#line 841
    switch (2UL) {
    case 1UL: 
#line 841
    dev->cmd.dbell_offsets[i] = (u16 )*((u8 *)__p___5);
#line 841
    goto ldv_31264;
    case 2UL: 
#line 841
    dev->cmd.dbell_offsets[i] = __be16_to_cpup((__be16 const   *)__p___5);
#line 841
    goto ldv_31264;
    case 4UL: 
#line 841
    tmp___15 = __be32_to_cpup((__be32 const   *)__p___5);
#line 841
    dev->cmd.dbell_offsets[i] = (u16 )tmp___15;
#line 841
    goto ldv_31264;
    case 8UL: 
#line 841
    tmp___16 = __be64_to_cpup((__be64 const   *)__p___5);
#line 841
    dev->cmd.dbell_offsets[i] = (u16 )tmp___16;
#line 841
    goto ldv_31264;
    default: 
#line 841
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31264: 
#line 840
    i = i + 1;
    ldv_31270: ;
#line 840
    if (i <= 7) {
#line 842
      goto ldv_31269;
    } else {

    }
#line 844
    mthca_setup_cmd_doorbells(dev, base);
  } else {

  }
#line 847
  tmp___29 = mthca_is_memfree(dev);
#line 847
  if (tmp___29 != 0) {
#line 848
    __p___6 = (void *)outbox;
#line 848
    switch (2UL) {
    case 1UL: 
#line 848
    dev->fw.arbel.fw_pages = (u16 )*((u8 *)__p___6);
#line 848
    goto ldv_31274;
    case 2UL: 
#line 848
    dev->fw.arbel.fw_pages = __be16_to_cpup((__be16 const   *)__p___6);
#line 848
    goto ldv_31274;
    case 4UL: 
#line 848
    tmp___17 = __be32_to_cpup((__be32 const   *)__p___6);
#line 848
    dev->fw.arbel.fw_pages = (u16 )tmp___17;
#line 848
    goto ldv_31274;
    case 8UL: 
#line 848
    tmp___18 = __be64_to_cpup((__be64 const   *)__p___6);
#line 848
    dev->fw.arbel.fw_pages = (u16 )tmp___18;
#line 848
    goto ldv_31274;
    default: 
#line 848
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31274: 
#line 849
    __p___7 = (void *)outbox + 32U;
#line 849
    switch (8UL) {
    case 1UL: 
#line 849
    dev->fw.arbel.clr_int_base = (u64 )*((u8 *)__p___7);
#line 849
    goto ldv_31281;
    case 2UL: 
#line 849
    tmp___19 = __be16_to_cpup((__be16 const   *)__p___7);
#line 849
    dev->fw.arbel.clr_int_base = (u64 )tmp___19;
#line 849
    goto ldv_31281;
    case 4UL: 
#line 849
    tmp___20 = __be32_to_cpup((__be32 const   *)__p___7);
#line 849
    dev->fw.arbel.clr_int_base = (u64 )tmp___20;
#line 849
    goto ldv_31281;
    case 8UL: 
#line 849
    dev->fw.arbel.clr_int_base = __be64_to_cpup((__be64 const   *)__p___7);
#line 849
    goto ldv_31281;
    default: 
#line 849
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31281: 
#line 850
    __p___8 = (void *)outbox + 64U;
#line 850
    switch (8UL) {
    case 1UL: 
#line 850
    dev->fw.arbel.eq_arm_base = (u64 )*((u8 *)__p___8);
#line 850
    goto ldv_31288;
    case 2UL: 
#line 850
    tmp___21 = __be16_to_cpup((__be16 const   *)__p___8);
#line 850
    dev->fw.arbel.eq_arm_base = (u64 )tmp___21;
#line 850
    goto ldv_31288;
    case 4UL: 
#line 850
    tmp___22 = __be32_to_cpup((__be32 const   *)__p___8);
#line 850
    dev->fw.arbel.eq_arm_base = (u64 )tmp___22;
#line 850
    goto ldv_31288;
    case 8UL: 
#line 850
    dev->fw.arbel.eq_arm_base = __be64_to_cpup((__be64 const   *)__p___8);
#line 850
    goto ldv_31288;
    default: 
#line 850
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31288: 
#line 851
    __p___9 = (void *)outbox + 72U;
#line 851
    switch (8UL) {
    case 1UL: 
#line 851
    dev->fw.arbel.eq_set_ci_base = (u64 )*((u8 *)__p___9);
#line 851
    goto ldv_31295;
    case 2UL: 
#line 851
    tmp___23 = __be16_to_cpup((__be16 const   *)__p___9);
#line 851
    dev->fw.arbel.eq_set_ci_base = (u64 )tmp___23;
#line 851
    goto ldv_31295;
    case 4UL: 
#line 851
    tmp___24 = __be32_to_cpup((__be32 const   *)__p___9);
#line 851
    dev->fw.arbel.eq_set_ci_base = (u64 )tmp___24;
#line 851
    goto ldv_31295;
    case 8UL: 
#line 851
    dev->fw.arbel.eq_set_ci_base = __be64_to_cpup((__be64 const   *)__p___9);
#line 851
    goto ldv_31295;
    default: 
#line 851
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31295: ;
#line 852
    if (mthca_debug_level != 0) {
#line 852
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "FW size %d KB\n",
                 (int )dev->fw.arbel.fw_pages << 2);
    } else {

    }
#line 858
    dev->fw.arbel.fw_pages = dev->fw.arbel.fw_pages;
#line 862
    if (mthca_debug_level != 0) {
#line 862
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Clear int @ %llx, EQ arm @ %llx, EQ set CI @ %llx\n",
                 dev->fw.arbel.clr_int_base, dev->fw.arbel.eq_arm_base, dev->fw.arbel.eq_set_ci_base);
    } else {

    }
  } else {
#line 867
    __p___10 = (void *)outbox + 32U;
#line 867
    switch (8UL) {
    case 1UL: 
#line 867
    dev->fw.tavor.fw_start = (u64 )*((u8 *)__p___10);
#line 867
    goto ldv_31302;
    case 2UL: 
#line 867
    tmp___25 = __be16_to_cpup((__be16 const   *)__p___10);
#line 867
    dev->fw.tavor.fw_start = (u64 )tmp___25;
#line 867
    goto ldv_31302;
    case 4UL: 
#line 867
    tmp___26 = __be32_to_cpup((__be32 const   *)__p___10);
#line 867
    dev->fw.tavor.fw_start = (u64 )tmp___26;
#line 867
    goto ldv_31302;
    case 8UL: 
#line 867
    dev->fw.tavor.fw_start = __be64_to_cpup((__be64 const   *)__p___10);
#line 867
    goto ldv_31302;
    default: 
#line 867
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31302: 
#line 868
    __p___11 = (void *)outbox + 40U;
#line 868
    switch (8UL) {
    case 1UL: 
#line 868
    dev->fw.tavor.fw_end = (u64 )*((u8 *)__p___11);
#line 868
    goto ldv_31309;
    case 2UL: 
#line 868
    tmp___27 = __be16_to_cpup((__be16 const   *)__p___11);
#line 868
    dev->fw.tavor.fw_end = (u64 )tmp___27;
#line 868
    goto ldv_31309;
    case 4UL: 
#line 868
    tmp___28 = __be32_to_cpup((__be32 const   *)__p___11);
#line 868
    dev->fw.tavor.fw_end = (u64 )tmp___28;
#line 868
    goto ldv_31309;
    case 8UL: 
#line 868
    dev->fw.tavor.fw_end = __be64_to_cpup((__be64 const   *)__p___11);
#line 868
    goto ldv_31309;
    default: 
#line 868
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31309: ;
#line 870
    if (mthca_debug_level != 0) {
#line 870
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "FW size %d KB (start %llx, end %llx)\n",
                 (int )((dev->fw.tavor.fw_end - dev->fw.tavor.fw_start) >> 10), dev->fw.tavor.fw_start,
                 dev->fw.tavor.fw_end);
    } else {

    }
  }
  out: 
#line 877
  mthca_free_mailbox(dev, mailbox);
#line 878
  return (err);
}
}
#line 881 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_ENABLE_LAM(struct mthca_dev *dev ) 
{ 
  struct mthca_mailbox *mailbox ;
  u8 info ;
  u32 *outbox ;
  int err ;
  long tmp ;
  bool tmp___0 ;
  void *__p ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  void *__p___0 ;
  __u16 tmp___3 ;
  __u32 tmp___4 ;
  void *__p___1 ;
  __u16 tmp___5 ;
  __u32 tmp___6 ;
  __u64 tmp___7 ;

  {
#line 886
  err = 0;
#line 896
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 897
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 897
  if ((int )tmp___0) {
#line 898
    tmp = PTR_ERR((void const   *)mailbox);
#line 898
    return ((int )tmp);
  } else {

  }
#line 899
  outbox = (u32 *)mailbox->buf;
#line 901
  err = mthca_cmd_box(dev, 0ULL, mailbox->dma, 0U, 0, 4088, 15000UL);
#line 904
  if (err != 0) {
#line 905
    goto out;
  } else {

  }
#line 907
  __p = (void *)outbox;
#line 907
  switch (8UL) {
  case 1UL: 
#line 907
  dev->ddr_start = (u64 )*((u8 *)__p);
#line 907
  goto ldv_31324;
  case 2UL: 
#line 907
  tmp___1 = __be16_to_cpup((__be16 const   *)__p);
#line 907
  dev->ddr_start = (u64 )tmp___1;
#line 907
  goto ldv_31324;
  case 4UL: 
#line 907
  tmp___2 = __be32_to_cpup((__be32 const   *)__p);
#line 907
  dev->ddr_start = (u64 )tmp___2;
#line 907
  goto ldv_31324;
  case 8UL: 
#line 907
  dev->ddr_start = __be64_to_cpup((__be64 const   *)__p);
#line 907
  goto ldv_31324;
  default: 
#line 907
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31324: 
#line 908
  __p___0 = (void *)outbox + 8U;
#line 908
  switch (8UL) {
  case 1UL: 
#line 908
  dev->ddr_end = (u64 )*((u8 *)__p___0);
#line 908
  goto ldv_31331;
  case 2UL: 
#line 908
  tmp___3 = __be16_to_cpup((__be16 const   *)__p___0);
#line 908
  dev->ddr_end = (u64 )tmp___3;
#line 908
  goto ldv_31331;
  case 4UL: 
#line 908
  tmp___4 = __be32_to_cpup((__be32 const   *)__p___0);
#line 908
  dev->ddr_end = (u64 )tmp___4;
#line 908
  goto ldv_31331;
  case 8UL: 
#line 908
  dev->ddr_end = __be64_to_cpup((__be64 const   *)__p___0);
#line 908
  goto ldv_31331;
  default: 
#line 908
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31331: 
#line 909
  __p___1 = (void *)outbox + 19U;
#line 909
  switch (1UL) {
  case 1UL: 
#line 909
  info = *((u8 *)__p___1);
#line 909
  goto ldv_31338;
  case 2UL: 
#line 909
  tmp___5 = __be16_to_cpup((__be16 const   *)__p___1);
#line 909
  info = (u8 )tmp___5;
#line 909
  goto ldv_31338;
  case 4UL: 
#line 909
  tmp___6 = __be32_to_cpup((__be32 const   *)__p___1);
#line 909
  info = (u8 )tmp___6;
#line 909
  goto ldv_31338;
  case 8UL: 
#line 909
  tmp___7 = __be64_to_cpup((__be64 const   *)__p___1);
#line 909
  info = (u8 )tmp___7;
#line 909
  goto ldv_31338;
  default: 
#line 909
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31338: ;
#line 911
  if ((((int )info & 16) != 0) ^ ((dev->mthca_flags & 2UL) != 0UL)) {
#line 913
    _dev_info((struct device  const  *)(& (dev->pdev)->dev), "FW reports that HCA-attached memory is %s hidden; does not match PCI config\n",
              ((int )info & 16) != 0 ? (char *)"" : (char *)"not");
  } else {

  }
#line 918
  if (((int )info & 16) != 0) {
#line 919
    if (mthca_debug_level != 0) {
#line 919
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "HCA-attached memory is hidden.\n");
    } else {

    }
  } else {

  }
#line 921
  if (mthca_debug_level != 0) {
#line 921
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "HCA memory size %d KB (start %llx, end %llx)\n",
               (int )((dev->ddr_end - dev->ddr_start) >> 10), dev->ddr_start, dev->ddr_end);
  } else {

  }
  out: 
#line 927
  mthca_free_mailbox(dev, mailbox);
#line 928
  return (err);
}
}
#line 931 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_DISABLE_LAM(struct mthca_dev *dev ) 
{ 
  int tmp ;

  {
#line 933
  tmp = mthca_cmd(dev, 0ULL, 0U, 0, 2, 15000UL);
#line 933
  return (tmp);
}
}
#line 936 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_QUERY_DDR(struct mthca_dev *dev ) 
{ 
  struct mthca_mailbox *mailbox ;
  u8 info ;
  u32 *outbox ;
  int err ;
  long tmp ;
  bool tmp___0 ;
  void *__p ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  void *__p___0 ;
  __u16 tmp___3 ;
  __u32 tmp___4 ;
  void *__p___1 ;
  __u16 tmp___5 ;
  __u32 tmp___6 ;
  __u64 tmp___7 ;

  {
#line 941
  err = 0;
#line 951
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 952
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 952
  if ((int )tmp___0) {
#line 953
    tmp = PTR_ERR((void const   *)mailbox);
#line 953
    return ((int )tmp);
  } else {

  }
#line 954
  outbox = (u32 *)mailbox->buf;
#line 956
  err = mthca_cmd_box(dev, 0ULL, mailbox->dma, 0U, 0, 5, 15000UL);
#line 959
  if (err != 0) {
#line 960
    goto out;
  } else {

  }
#line 962
  __p = (void *)outbox;
#line 962
  switch (8UL) {
  case 1UL: 
#line 962
  dev->ddr_start = (u64 )*((u8 *)__p);
#line 962
  goto ldv_31356;
  case 2UL: 
#line 962
  tmp___1 = __be16_to_cpup((__be16 const   *)__p);
#line 962
  dev->ddr_start = (u64 )tmp___1;
#line 962
  goto ldv_31356;
  case 4UL: 
#line 962
  tmp___2 = __be32_to_cpup((__be32 const   *)__p);
#line 962
  dev->ddr_start = (u64 )tmp___2;
#line 962
  goto ldv_31356;
  case 8UL: 
#line 962
  dev->ddr_start = __be64_to_cpup((__be64 const   *)__p);
#line 962
  goto ldv_31356;
  default: 
#line 962
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31356: 
#line 963
  __p___0 = (void *)outbox + 8U;
#line 963
  switch (8UL) {
  case 1UL: 
#line 963
  dev->ddr_end = (u64 )*((u8 *)__p___0);
#line 963
  goto ldv_31363;
  case 2UL: 
#line 963
  tmp___3 = __be16_to_cpup((__be16 const   *)__p___0);
#line 963
  dev->ddr_end = (u64 )tmp___3;
#line 963
  goto ldv_31363;
  case 4UL: 
#line 963
  tmp___4 = __be32_to_cpup((__be32 const   *)__p___0);
#line 963
  dev->ddr_end = (u64 )tmp___4;
#line 963
  goto ldv_31363;
  case 8UL: 
#line 963
  dev->ddr_end = __be64_to_cpup((__be64 const   *)__p___0);
#line 963
  goto ldv_31363;
  default: 
#line 963
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31363: 
#line 964
  __p___1 = (void *)outbox + 19U;
#line 964
  switch (1UL) {
  case 1UL: 
#line 964
  info = *((u8 *)__p___1);
#line 964
  goto ldv_31370;
  case 2UL: 
#line 964
  tmp___5 = __be16_to_cpup((__be16 const   *)__p___1);
#line 964
  info = (u8 )tmp___5;
#line 964
  goto ldv_31370;
  case 4UL: 
#line 964
  tmp___6 = __be32_to_cpup((__be32 const   *)__p___1);
#line 964
  info = (u8 )tmp___6;
#line 964
  goto ldv_31370;
  case 8UL: 
#line 964
  tmp___7 = __be64_to_cpup((__be64 const   *)__p___1);
#line 964
  info = (u8 )tmp___7;
#line 964
  goto ldv_31370;
  default: 
#line 964
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31370: ;
#line 966
  if ((((int )info & 16) != 0) ^ ((dev->mthca_flags & 2UL) != 0UL)) {
#line 968
    _dev_info((struct device  const  *)(& (dev->pdev)->dev), "FW reports that HCA-attached memory is %s hidden; does not match PCI config\n",
              ((int )info & 16) != 0 ? (char *)"" : (char *)"not");
  } else {

  }
#line 973
  if (((int )info & 16) != 0) {
#line 974
    if (mthca_debug_level != 0) {
#line 974
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "HCA-attached memory is hidden.\n");
    } else {

    }
  } else {

  }
#line 976
  if (mthca_debug_level != 0) {
#line 976
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "HCA memory size %d KB (start %llx, end %llx)\n",
               (int )((dev->ddr_end - dev->ddr_start) >> 10), dev->ddr_start, dev->ddr_end);
  } else {

  }
  out: 
#line 982
  mthca_free_mailbox(dev, mailbox);
#line 983
  return (err);
}
}
#line 986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_QUERY_DEV_LIM(struct mthca_dev *dev , struct mthca_dev_lim *dev_lim ) 
{ 
  struct mthca_mailbox *mailbox ;
  u32 *outbox ;
  u8 field ;
  u16 size ;
  u16 stat_rate ;
  int err ;
  long tmp ;
  bool tmp___0 ;
  void *__p ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  __u64 tmp___3 ;
  void *__p___0 ;
  __u16 tmp___4 ;
  __u32 tmp___5 ;
  __u64 tmp___6 ;
  void *__p___1 ;
  __u16 tmp___7 ;
  __u32 tmp___8 ;
  __u64 tmp___9 ;
  void *__p___2 ;
  __u16 tmp___10 ;
  __u32 tmp___11 ;
  __u64 tmp___12 ;
  void *__p___3 ;
  __u16 tmp___13 ;
  __u32 tmp___14 ;
  __u64 tmp___15 ;
  void *__p___4 ;
  __u16 tmp___16 ;
  __u32 tmp___17 ;
  __u64 tmp___18 ;
  void *__p___5 ;
  __u16 tmp___19 ;
  __u32 tmp___20 ;
  __u64 tmp___21 ;
  void *__p___6 ;
  __u16 tmp___22 ;
  __u32 tmp___23 ;
  __u64 tmp___24 ;
  void *__p___7 ;
  __u16 tmp___25 ;
  __u32 tmp___26 ;
  __u64 tmp___27 ;
  void *__p___8 ;
  __u16 tmp___28 ;
  __u32 tmp___29 ;
  __u64 tmp___30 ;
  void *__p___9 ;
  __u16 tmp___31 ;
  __u32 tmp___32 ;
  __u64 tmp___33 ;
  void *__p___10 ;
  __u16 tmp___34 ;
  __u32 tmp___35 ;
  __u64 tmp___36 ;
  void *__p___11 ;
  __u16 tmp___37 ;
  __u32 tmp___38 ;
  __u64 tmp___39 ;
  int tmp___40 ;
  void *__p___12 ;
  __u16 tmp___41 ;
  __u32 tmp___42 ;
  __u64 tmp___43 ;
  void *__p___13 ;
  __u16 tmp___44 ;
  __u32 tmp___45 ;
  __u64 tmp___46 ;
  void *__p___14 ;
  __u16 tmp___47 ;
  __u32 tmp___48 ;
  __u64 tmp___49 ;
  void *__p___15 ;
  __u16 tmp___50 ;
  __u32 tmp___51 ;
  __u64 tmp___52 ;
  void *__p___16 ;
  __u16 tmp___53 ;
  __u32 tmp___54 ;
  __u64 tmp___55 ;
  void *__p___17 ;
  __u16 tmp___56 ;
  __u32 tmp___57 ;
  __u64 tmp___58 ;
  void *__p___18 ;
  __u16 tmp___59 ;
  __u32 tmp___60 ;
  __u64 tmp___61 ;
  void *__p___19 ;
  __u16 tmp___62 ;
  __u32 tmp___63 ;
  __u64 tmp___64 ;
  void *__p___20 ;
  __u16 tmp___65 ;
  __u32 tmp___66 ;
  __u64 tmp___67 ;
  void *__p___21 ;
  __u16 tmp___68 ;
  __u32 tmp___69 ;
  __u64 tmp___70 ;
  void *__p___22 ;
  __u32 tmp___71 ;
  __u64 tmp___72 ;
  void *__p___23 ;
  __u16 tmp___73 ;
  __u32 tmp___74 ;
  __u64 tmp___75 ;
  void *__p___24 ;
  __u16 tmp___76 ;
  __u64 tmp___77 ;
  void *__p___25 ;
  __u16 tmp___78 ;
  __u32 tmp___79 ;
  __u64 tmp___80 ;
  void *__p___26 ;
  __u16 tmp___81 ;
  __u32 tmp___82 ;
  __u64 tmp___83 ;
  void *__p___27 ;
  __u16 tmp___84 ;
  __u32 tmp___85 ;
  __u64 tmp___86 ;
  void *__p___28 ;
  __u16 tmp___87 ;
  __u32 tmp___88 ;
  __u64 tmp___89 ;
  void *__p___29 ;
  __u32 tmp___90 ;
  __u64 tmp___91 ;
  void *__p___30 ;
  __u16 tmp___92 ;
  __u32 tmp___93 ;
  __u64 tmp___94 ;
  void *__p___31 ;
  __u16 tmp___95 ;
  __u32 tmp___96 ;
  __u64 tmp___97 ;
  void *__p___32 ;
  __u16 tmp___98 ;
  __u32 tmp___99 ;
  __u64 tmp___100 ;
  void *__p___33 ;
  __u16 tmp___101 ;
  __u32 tmp___102 ;
  __u64 tmp___103 ;
  void *__p___34 ;
  __u16 tmp___104 ;
  __u32 tmp___105 ;
  __u64 tmp___106 ;
  void *__p___35 ;
  __u16 tmp___107 ;
  __u32 tmp___108 ;
  __u64 tmp___109 ;
  void *__p___36 ;
  __u16 tmp___110 ;
  __u32 tmp___111 ;
  __u64 tmp___112 ;
  void *__p___37 ;
  __u32 tmp___113 ;
  __u64 tmp___114 ;
  void *__p___38 ;
  __u32 tmp___115 ;
  __u64 tmp___116 ;
  void *__p___39 ;
  __u32 tmp___117 ;
  __u64 tmp___118 ;
  void *__p___40 ;
  __u32 tmp___119 ;
  __u64 tmp___120 ;
  void *__p___41 ;
  __u32 tmp___121 ;
  __u64 tmp___122 ;
  void *__p___42 ;
  __u32 tmp___123 ;
  __u64 tmp___124 ;
  void *__p___43 ;
  __u32 tmp___125 ;
  __u64 tmp___126 ;
  void *__p___44 ;
  __u32 tmp___127 ;
  __u64 tmp___128 ;
  void *__p___45 ;
  __u16 tmp___129 ;
  __u32 tmp___130 ;
  __u64 tmp___131 ;
  void *__p___46 ;
  __u16 tmp___132 ;
  __u32 tmp___133 ;
  __u64 tmp___134 ;
  void *__p___47 ;
  __u16 tmp___135 ;
  __u32 tmp___136 ;
  __u64 tmp___137 ;
  void *__p___48 ;
  __u16 tmp___138 ;
  __u32 tmp___139 ;
  __u64 tmp___140 ;
  int __min1 ;
  int __min2 ;
  void *__p___49 ;
  __u32 tmp___141 ;
  __u64 tmp___142 ;
  int __min1___0 ;
  int __min2___0 ;
  void *__p___50 ;
  __u32 tmp___143 ;
  __u64 tmp___144 ;
  void *__p___51 ;
  __u16 tmp___145 ;
  __u32 tmp___146 ;
  __u64 tmp___147 ;
  void *__p___52 ;
  __u16 tmp___148 ;
  __u32 tmp___149 ;
  __u64 tmp___150 ;
  void *__p___53 ;
  __u16 tmp___151 ;
  __u64 tmp___152 ;
  void *__p___54 ;
  __u16 tmp___153 ;
  __u32 tmp___154 ;
  __u64 tmp___155 ;
  void *__p___55 ;
  __u16 tmp___156 ;
  __u32 tmp___157 ;
  void *__p___56 ;
  __u16 tmp___158 ;
  __u32 tmp___159 ;
  __u64 tmp___160 ;
  void *__p___57 ;
  __u16 tmp___161 ;
  __u32 tmp___162 ;
  __u64 tmp___163 ;
  void *__p___58 ;
  __u16 tmp___164 ;
  __u32 tmp___165 ;
  __u64 tmp___166 ;
  int tmp___167 ;

  {
#line 1057
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1058
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1058
  if ((int )tmp___0) {
#line 1059
    tmp = PTR_ERR((void const   *)mailbox);
#line 1059
    return ((int )tmp);
  } else {

  }
#line 1060
  outbox = (u32 *)mailbox->buf;
#line 1062
  err = mthca_cmd_box(dev, 0ULL, mailbox->dma, 0U, 0, 3, 15000UL);
#line 1065
  if (err != 0) {
#line 1066
    goto out;
  } else {

  }
#line 1068
  __p = (void *)outbox + 18U;
#line 1068
  switch (1UL) {
  case 1UL: 
#line 1068
  field = *((u8 *)__p);
#line 1068
  goto ldv_31388;
  case 2UL: 
#line 1068
  tmp___1 = __be16_to_cpup((__be16 const   *)__p);
#line 1068
  field = (u8 )tmp___1;
#line 1068
  goto ldv_31388;
  case 4UL: 
#line 1068
  tmp___2 = __be32_to_cpup((__be32 const   *)__p);
#line 1068
  field = (u8 )tmp___2;
#line 1068
  goto ldv_31388;
  case 8UL: 
#line 1068
  tmp___3 = __be64_to_cpup((__be64 const   *)__p);
#line 1068
  field = (u8 )tmp___3;
#line 1068
  goto ldv_31388;
  default: 
#line 1068
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31388: 
#line 1069
  dev_lim->reserved_qps = 1 << ((int )field & 15);
#line 1070
  __p___0 = (void *)outbox + 19U;
#line 1070
  switch (1UL) {
  case 1UL: 
#line 1070
  field = *((u8 *)__p___0);
#line 1070
  goto ldv_31395;
  case 2UL: 
#line 1070
  tmp___4 = __be16_to_cpup((__be16 const   *)__p___0);
#line 1070
  field = (u8 )tmp___4;
#line 1070
  goto ldv_31395;
  case 4UL: 
#line 1070
  tmp___5 = __be32_to_cpup((__be32 const   *)__p___0);
#line 1070
  field = (u8 )tmp___5;
#line 1070
  goto ldv_31395;
  case 8UL: 
#line 1070
  tmp___6 = __be64_to_cpup((__be64 const   *)__p___0);
#line 1070
  field = (u8 )tmp___6;
#line 1070
  goto ldv_31395;
  default: 
#line 1070
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31395: 
#line 1071
  dev_lim->max_qps = 1 << ((int )field & 31);
#line 1072
  __p___1 = (void *)outbox + 20U;
#line 1072
  switch (1UL) {
  case 1UL: 
#line 1072
  field = *((u8 *)__p___1);
#line 1072
  goto ldv_31402;
  case 2UL: 
#line 1072
  tmp___7 = __be16_to_cpup((__be16 const   *)__p___1);
#line 1072
  field = (u8 )tmp___7;
#line 1072
  goto ldv_31402;
  case 4UL: 
#line 1072
  tmp___8 = __be32_to_cpup((__be32 const   *)__p___1);
#line 1072
  field = (u8 )tmp___8;
#line 1072
  goto ldv_31402;
  case 8UL: 
#line 1072
  tmp___9 = __be64_to_cpup((__be64 const   *)__p___1);
#line 1072
  field = (u8 )tmp___9;
#line 1072
  goto ldv_31402;
  default: 
#line 1072
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31402: 
#line 1073
  dev_lim->reserved_srqs = 1 << ((int )field >> 4);
#line 1074
  __p___2 = (void *)outbox + 21U;
#line 1074
  switch (1UL) {
  case 1UL: 
#line 1074
  field = *((u8 *)__p___2);
#line 1074
  goto ldv_31409;
  case 2UL: 
#line 1074
  tmp___10 = __be16_to_cpup((__be16 const   *)__p___2);
#line 1074
  field = (u8 )tmp___10;
#line 1074
  goto ldv_31409;
  case 4UL: 
#line 1074
  tmp___11 = __be32_to_cpup((__be32 const   *)__p___2);
#line 1074
  field = (u8 )tmp___11;
#line 1074
  goto ldv_31409;
  case 8UL: 
#line 1074
  tmp___12 = __be64_to_cpup((__be64 const   *)__p___2);
#line 1074
  field = (u8 )tmp___12;
#line 1074
  goto ldv_31409;
  default: 
#line 1074
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31409: 
#line 1075
  dev_lim->max_srqs = 1 << ((int )field & 31);
#line 1076
  __p___3 = (void *)outbox + 22U;
#line 1076
  switch (1UL) {
  case 1UL: 
#line 1076
  field = *((u8 *)__p___3);
#line 1076
  goto ldv_31416;
  case 2UL: 
#line 1076
  tmp___13 = __be16_to_cpup((__be16 const   *)__p___3);
#line 1076
  field = (u8 )tmp___13;
#line 1076
  goto ldv_31416;
  case 4UL: 
#line 1076
  tmp___14 = __be32_to_cpup((__be32 const   *)__p___3);
#line 1076
  field = (u8 )tmp___14;
#line 1076
  goto ldv_31416;
  case 8UL: 
#line 1076
  tmp___15 = __be64_to_cpup((__be64 const   *)__p___3);
#line 1076
  field = (u8 )tmp___15;
#line 1076
  goto ldv_31416;
  default: 
#line 1076
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31416: 
#line 1077
  dev_lim->reserved_eecs = 1 << ((int )field & 15);
#line 1078
  __p___4 = (void *)outbox + 23U;
#line 1078
  switch (1UL) {
  case 1UL: 
#line 1078
  field = *((u8 *)__p___4);
#line 1078
  goto ldv_31423;
  case 2UL: 
#line 1078
  tmp___16 = __be16_to_cpup((__be16 const   *)__p___4);
#line 1078
  field = (u8 )tmp___16;
#line 1078
  goto ldv_31423;
  case 4UL: 
#line 1078
  tmp___17 = __be32_to_cpup((__be32 const   *)__p___4);
#line 1078
  field = (u8 )tmp___17;
#line 1078
  goto ldv_31423;
  case 8UL: 
#line 1078
  tmp___18 = __be64_to_cpup((__be64 const   *)__p___4);
#line 1078
  field = (u8 )tmp___18;
#line 1078
  goto ldv_31423;
  default: 
#line 1078
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31423: 
#line 1079
  dev_lim->max_eecs = 1 << ((int )field & 31);
#line 1080
  __p___5 = (void *)outbox + 25U;
#line 1080
  switch (1UL) {
  case 1UL: 
#line 1080
  field = *((u8 *)__p___5);
#line 1080
  goto ldv_31430;
  case 2UL: 
#line 1080
  tmp___19 = __be16_to_cpup((__be16 const   *)__p___5);
#line 1080
  field = (u8 )tmp___19;
#line 1080
  goto ldv_31430;
  case 4UL: 
#line 1080
  tmp___20 = __be32_to_cpup((__be32 const   *)__p___5);
#line 1080
  field = (u8 )tmp___20;
#line 1080
  goto ldv_31430;
  case 8UL: 
#line 1080
  tmp___21 = __be64_to_cpup((__be64 const   *)__p___5);
#line 1080
  field = (u8 )tmp___21;
#line 1080
  goto ldv_31430;
  default: 
#line 1080
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31430: 
#line 1081
  dev_lim->max_cq_sz = 1 << (int )field;
#line 1082
  __p___6 = (void *)outbox + 26U;
#line 1082
  switch (1UL) {
  case 1UL: 
#line 1082
  field = *((u8 *)__p___6);
#line 1082
  goto ldv_31437;
  case 2UL: 
#line 1082
  tmp___22 = __be16_to_cpup((__be16 const   *)__p___6);
#line 1082
  field = (u8 )tmp___22;
#line 1082
  goto ldv_31437;
  case 4UL: 
#line 1082
  tmp___23 = __be32_to_cpup((__be32 const   *)__p___6);
#line 1082
  field = (u8 )tmp___23;
#line 1082
  goto ldv_31437;
  case 8UL: 
#line 1082
  tmp___24 = __be64_to_cpup((__be64 const   *)__p___6);
#line 1082
  field = (u8 )tmp___24;
#line 1082
  goto ldv_31437;
  default: 
#line 1082
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31437: 
#line 1083
  dev_lim->reserved_cqs = 1 << ((int )field & 15);
#line 1084
  __p___7 = (void *)outbox + 27U;
#line 1084
  switch (1UL) {
  case 1UL: 
#line 1084
  field = *((u8 *)__p___7);
#line 1084
  goto ldv_31444;
  case 2UL: 
#line 1084
  tmp___25 = __be16_to_cpup((__be16 const   *)__p___7);
#line 1084
  field = (u8 )tmp___25;
#line 1084
  goto ldv_31444;
  case 4UL: 
#line 1084
  tmp___26 = __be32_to_cpup((__be32 const   *)__p___7);
#line 1084
  field = (u8 )tmp___26;
#line 1084
  goto ldv_31444;
  case 8UL: 
#line 1084
  tmp___27 = __be64_to_cpup((__be64 const   *)__p___7);
#line 1084
  field = (u8 )tmp___27;
#line 1084
  goto ldv_31444;
  default: 
#line 1084
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31444: 
#line 1085
  dev_lim->max_cqs = 1 << ((int )field & 31);
#line 1086
  __p___8 = (void *)outbox + 29U;
#line 1086
  switch (1UL) {
  case 1UL: 
#line 1086
  field = *((u8 *)__p___8);
#line 1086
  goto ldv_31451;
  case 2UL: 
#line 1086
  tmp___28 = __be16_to_cpup((__be16 const   *)__p___8);
#line 1086
  field = (u8 )tmp___28;
#line 1086
  goto ldv_31451;
  case 4UL: 
#line 1086
  tmp___29 = __be32_to_cpup((__be32 const   *)__p___8);
#line 1086
  field = (u8 )tmp___29;
#line 1086
  goto ldv_31451;
  case 8UL: 
#line 1086
  tmp___30 = __be64_to_cpup((__be64 const   *)__p___8);
#line 1086
  field = (u8 )tmp___30;
#line 1086
  goto ldv_31451;
  default: 
#line 1086
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31451: 
#line 1087
  dev_lim->max_mpts = 1 << ((int )field & 63);
#line 1088
  __p___9 = (void *)outbox + 30U;
#line 1088
  switch (1UL) {
  case 1UL: 
#line 1088
  field = *((u8 *)__p___9);
#line 1088
  goto ldv_31458;
  case 2UL: 
#line 1088
  tmp___31 = __be16_to_cpup((__be16 const   *)__p___9);
#line 1088
  field = (u8 )tmp___31;
#line 1088
  goto ldv_31458;
  case 4UL: 
#line 1088
  tmp___32 = __be32_to_cpup((__be32 const   *)__p___9);
#line 1088
  field = (u8 )tmp___32;
#line 1088
  goto ldv_31458;
  case 8UL: 
#line 1088
  tmp___33 = __be64_to_cpup((__be64 const   *)__p___9);
#line 1088
  field = (u8 )tmp___33;
#line 1088
  goto ldv_31458;
  default: 
#line 1088
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31458: 
#line 1089
  dev_lim->reserved_eqs = 1 << ((int )field & 15);
#line 1090
  __p___10 = (void *)outbox + 31U;
#line 1090
  switch (1UL) {
  case 1UL: 
#line 1090
  field = *((u8 *)__p___10);
#line 1090
  goto ldv_31465;
  case 2UL: 
#line 1090
  tmp___34 = __be16_to_cpup((__be16 const   *)__p___10);
#line 1090
  field = (u8 )tmp___34;
#line 1090
  goto ldv_31465;
  case 4UL: 
#line 1090
  tmp___35 = __be32_to_cpup((__be32 const   *)__p___10);
#line 1090
  field = (u8 )tmp___35;
#line 1090
  goto ldv_31465;
  case 8UL: 
#line 1090
  tmp___36 = __be64_to_cpup((__be64 const   *)__p___10);
#line 1090
  field = (u8 )tmp___36;
#line 1090
  goto ldv_31465;
  default: 
#line 1090
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31465: 
#line 1091
  dev_lim->max_eqs = 1 << ((int )field & 7);
#line 1092
  __p___11 = (void *)outbox + 32U;
#line 1092
  switch (1UL) {
  case 1UL: 
#line 1092
  field = *((u8 *)__p___11);
#line 1092
  goto ldv_31472;
  case 2UL: 
#line 1092
  tmp___37 = __be16_to_cpup((__be16 const   *)__p___11);
#line 1092
  field = (u8 )tmp___37;
#line 1092
  goto ldv_31472;
  case 4UL: 
#line 1092
  tmp___38 = __be32_to_cpup((__be32 const   *)__p___11);
#line 1092
  field = (u8 )tmp___38;
#line 1092
  goto ldv_31472;
  case 8UL: 
#line 1092
  tmp___39 = __be64_to_cpup((__be64 const   *)__p___11);
#line 1092
  field = (u8 )tmp___39;
#line 1092
  goto ldv_31472;
  default: 
#line 1092
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31472: 
#line 1093
  tmp___40 = mthca_is_memfree(dev);
#line 1093
  if (tmp___40 != 0) {
#line 1094
    dev_lim->reserved_mtts = (int )(((((unsigned long )(1 << ((int )field >> 4)) * 8UL + (unsigned long )dev->limits.mtt_seg_size) - 1UL) & - ((unsigned long )dev->limits.mtt_seg_size)) / (unsigned long )dev->limits.mtt_seg_size);
  } else {
#line 1097
    dev_lim->reserved_mtts = 1 << ((int )field >> 4);
  }
#line 1098
  __p___12 = (void *)outbox + 33U;
#line 1098
  switch (1UL) {
  case 1UL: 
#line 1098
  field = *((u8 *)__p___12);
#line 1098
  goto ldv_31479;
  case 2UL: 
#line 1098
  tmp___41 = __be16_to_cpup((__be16 const   *)__p___12);
#line 1098
  field = (u8 )tmp___41;
#line 1098
  goto ldv_31479;
  case 4UL: 
#line 1098
  tmp___42 = __be32_to_cpup((__be32 const   *)__p___12);
#line 1098
  field = (u8 )tmp___42;
#line 1098
  goto ldv_31479;
  case 8UL: 
#line 1098
  tmp___43 = __be64_to_cpup((__be64 const   *)__p___12);
#line 1098
  field = (u8 )tmp___43;
#line 1098
  goto ldv_31479;
  default: 
#line 1098
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31479: 
#line 1099
  dev_lim->max_mrw_sz = 1 << (int )field;
#line 1100
  __p___13 = (void *)outbox + 34U;
#line 1100
  switch (1UL) {
  case 1UL: 
#line 1100
  field = *((u8 *)__p___13);
#line 1100
  goto ldv_31486;
  case 2UL: 
#line 1100
  tmp___44 = __be16_to_cpup((__be16 const   *)__p___13);
#line 1100
  field = (u8 )tmp___44;
#line 1100
  goto ldv_31486;
  case 4UL: 
#line 1100
  tmp___45 = __be32_to_cpup((__be32 const   *)__p___13);
#line 1100
  field = (u8 )tmp___45;
#line 1100
  goto ldv_31486;
  case 8UL: 
#line 1100
  tmp___46 = __be64_to_cpup((__be64 const   *)__p___13);
#line 1100
  field = (u8 )tmp___46;
#line 1100
  goto ldv_31486;
  default: 
#line 1100
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31486: 
#line 1101
  dev_lim->reserved_mrws = 1 << ((int )field & 15);
#line 1102
  __p___14 = (void *)outbox + 35U;
#line 1102
  switch (1UL) {
  case 1UL: 
#line 1102
  field = *((u8 *)__p___14);
#line 1102
  goto ldv_31493;
  case 2UL: 
#line 1102
  tmp___47 = __be16_to_cpup((__be16 const   *)__p___14);
#line 1102
  field = (u8 )tmp___47;
#line 1102
  goto ldv_31493;
  case 4UL: 
#line 1102
  tmp___48 = __be32_to_cpup((__be32 const   *)__p___14);
#line 1102
  field = (u8 )tmp___48;
#line 1102
  goto ldv_31493;
  case 8UL: 
#line 1102
  tmp___49 = __be64_to_cpup((__be64 const   *)__p___14);
#line 1102
  field = (u8 )tmp___49;
#line 1102
  goto ldv_31493;
  default: 
#line 1102
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31493: 
#line 1103
  dev_lim->max_mtt_seg = 1 << ((int )field & 63);
#line 1104
  __p___15 = (void *)outbox + 41U;
#line 1104
  switch (1UL) {
  case 1UL: 
#line 1104
  field = *((u8 *)__p___15);
#line 1104
  goto ldv_31500;
  case 2UL: 
#line 1104
  tmp___50 = __be16_to_cpup((__be16 const   *)__p___15);
#line 1104
  field = (u8 )tmp___50;
#line 1104
  goto ldv_31500;
  case 4UL: 
#line 1104
  tmp___51 = __be32_to_cpup((__be32 const   *)__p___15);
#line 1104
  field = (u8 )tmp___51;
#line 1104
  goto ldv_31500;
  case 8UL: 
#line 1104
  tmp___52 = __be64_to_cpup((__be64 const   *)__p___15);
#line 1104
  field = (u8 )tmp___52;
#line 1104
  goto ldv_31500;
  default: 
#line 1104
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31500: 
#line 1105
  dev_lim->max_requester_per_qp = 1 << ((int )field & 63);
#line 1106
  __p___16 = (void *)outbox + 43U;
#line 1106
  switch (1UL) {
  case 1UL: 
#line 1106
  field = *((u8 *)__p___16);
#line 1106
  goto ldv_31507;
  case 2UL: 
#line 1106
  tmp___53 = __be16_to_cpup((__be16 const   *)__p___16);
#line 1106
  field = (u8 )tmp___53;
#line 1106
  goto ldv_31507;
  case 4UL: 
#line 1106
  tmp___54 = __be32_to_cpup((__be32 const   *)__p___16);
#line 1106
  field = (u8 )tmp___54;
#line 1106
  goto ldv_31507;
  case 8UL: 
#line 1106
  tmp___55 = __be64_to_cpup((__be64 const   *)__p___16);
#line 1106
  field = (u8 )tmp___55;
#line 1106
  goto ldv_31507;
  default: 
#line 1106
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31507: 
#line 1107
  dev_lim->max_responder_per_qp = 1 << ((int )field & 63);
#line 1108
  __p___17 = (void *)outbox + 47U;
#line 1108
  switch (1UL) {
  case 1UL: 
#line 1108
  field = *((u8 *)__p___17);
#line 1108
  goto ldv_31514;
  case 2UL: 
#line 1108
  tmp___56 = __be16_to_cpup((__be16 const   *)__p___17);
#line 1108
  field = (u8 )tmp___56;
#line 1108
  goto ldv_31514;
  case 4UL: 
#line 1108
  tmp___57 = __be32_to_cpup((__be32 const   *)__p___17);
#line 1108
  field = (u8 )tmp___57;
#line 1108
  goto ldv_31514;
  case 8UL: 
#line 1108
  tmp___58 = __be64_to_cpup((__be64 const   *)__p___17);
#line 1108
  field = (u8 )tmp___58;
#line 1108
  goto ldv_31514;
  default: 
#line 1108
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31514: 
#line 1109
  dev_lim->max_rdma_global = 1 << ((int )field & 63);
#line 1110
  __p___18 = (void *)outbox + 53U;
#line 1110
  switch (1UL) {
  case 1UL: 
#line 1110
  field = *((u8 *)__p___18);
#line 1110
  goto ldv_31521;
  case 2UL: 
#line 1110
  tmp___59 = __be16_to_cpup((__be16 const   *)__p___18);
#line 1110
  field = (u8 )tmp___59;
#line 1110
  goto ldv_31521;
  case 4UL: 
#line 1110
  tmp___60 = __be32_to_cpup((__be32 const   *)__p___18);
#line 1110
  field = (u8 )tmp___60;
#line 1110
  goto ldv_31521;
  case 8UL: 
#line 1110
  tmp___61 = __be64_to_cpup((__be64 const   *)__p___18);
#line 1110
  field = (u8 )tmp___61;
#line 1110
  goto ldv_31521;
  default: 
#line 1110
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31521: 
#line 1111
  dev_lim->local_ca_ack_delay = (int )field & 31;
#line 1112
  __p___19 = (void *)outbox + 54U;
#line 1112
  switch (1UL) {
  case 1UL: 
#line 1112
  field = *((u8 *)__p___19);
#line 1112
  goto ldv_31528;
  case 2UL: 
#line 1112
  tmp___62 = __be16_to_cpup((__be16 const   *)__p___19);
#line 1112
  field = (u8 )tmp___62;
#line 1112
  goto ldv_31528;
  case 4UL: 
#line 1112
  tmp___63 = __be32_to_cpup((__be32 const   *)__p___19);
#line 1112
  field = (u8 )tmp___63;
#line 1112
  goto ldv_31528;
  case 8UL: 
#line 1112
  tmp___64 = __be64_to_cpup((__be64 const   *)__p___19);
#line 1112
  field = (u8 )tmp___64;
#line 1112
  goto ldv_31528;
  default: 
#line 1112
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31528: 
#line 1113
  dev_lim->max_mtu = (int )field >> 4;
#line 1114
  dev_lim->max_port_width = (int )field & 15;
#line 1115
  __p___20 = (void *)outbox + 55U;
#line 1115
  switch (1UL) {
  case 1UL: 
#line 1115
  field = *((u8 *)__p___20);
#line 1115
  goto ldv_31535;
  case 2UL: 
#line 1115
  tmp___65 = __be16_to_cpup((__be16 const   *)__p___20);
#line 1115
  field = (u8 )tmp___65;
#line 1115
  goto ldv_31535;
  case 4UL: 
#line 1115
  tmp___66 = __be32_to_cpup((__be32 const   *)__p___20);
#line 1115
  field = (u8 )tmp___66;
#line 1115
  goto ldv_31535;
  case 8UL: 
#line 1115
  tmp___67 = __be64_to_cpup((__be64 const   *)__p___20);
#line 1115
  field = (u8 )tmp___67;
#line 1115
  goto ldv_31535;
  default: 
#line 1115
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31535: 
#line 1116
  dev_lim->max_vl = (int )field >> 4;
#line 1117
  dev_lim->num_ports = (int )field & 15;
#line 1118
  __p___21 = (void *)outbox + 59U;
#line 1118
  switch (1UL) {
  case 1UL: 
#line 1118
  field = *((u8 *)__p___21);
#line 1118
  goto ldv_31542;
  case 2UL: 
#line 1118
  tmp___68 = __be16_to_cpup((__be16 const   *)__p___21);
#line 1118
  field = (u8 )tmp___68;
#line 1118
  goto ldv_31542;
  case 4UL: 
#line 1118
  tmp___69 = __be32_to_cpup((__be32 const   *)__p___21);
#line 1118
  field = (u8 )tmp___69;
#line 1118
  goto ldv_31542;
  case 8UL: 
#line 1118
  tmp___70 = __be64_to_cpup((__be64 const   *)__p___21);
#line 1118
  field = (u8 )tmp___70;
#line 1118
  goto ldv_31542;
  default: 
#line 1118
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31542: 
#line 1119
  dev_lim->max_gids = 1 << ((int )field & 15);
#line 1120
  __p___22 = (void *)outbox + 60U;
#line 1120
  switch (2UL) {
  case 1UL: 
#line 1120
  stat_rate = (u16 )*((u8 *)__p___22);
#line 1120
  goto ldv_31549;
  case 2UL: 
#line 1120
  stat_rate = __be16_to_cpup((__be16 const   *)__p___22);
#line 1120
  goto ldv_31549;
  case 4UL: 
#line 1120
  tmp___71 = __be32_to_cpup((__be32 const   *)__p___22);
#line 1120
  stat_rate = (u16 )tmp___71;
#line 1120
  goto ldv_31549;
  case 8UL: 
#line 1120
  tmp___72 = __be64_to_cpup((__be64 const   *)__p___22);
#line 1120
  stat_rate = (u16 )tmp___72;
#line 1120
  goto ldv_31549;
  default: 
#line 1120
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31549: 
#line 1121
  dev_lim->stat_rate_support = stat_rate;
#line 1122
  __p___23 = (void *)outbox + 63U;
#line 1122
  switch (1UL) {
  case 1UL: 
#line 1122
  field = *((u8 *)__p___23);
#line 1122
  goto ldv_31556;
  case 2UL: 
#line 1122
  tmp___73 = __be16_to_cpup((__be16 const   *)__p___23);
#line 1122
  field = (u8 )tmp___73;
#line 1122
  goto ldv_31556;
  case 4UL: 
#line 1122
  tmp___74 = __be32_to_cpup((__be32 const   *)__p___23);
#line 1122
  field = (u8 )tmp___74;
#line 1122
  goto ldv_31556;
  case 8UL: 
#line 1122
  tmp___75 = __be64_to_cpup((__be64 const   *)__p___23);
#line 1122
  field = (u8 )tmp___75;
#line 1122
  goto ldv_31556;
  default: 
#line 1122
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31556: 
#line 1123
  dev_lim->max_pkeys = 1 << ((int )field & 15);
#line 1124
  __p___24 = (void *)outbox + 68U;
#line 1124
  switch (4UL) {
  case 1UL: 
#line 1124
  dev_lim->flags = (u32 )*((u8 *)__p___24);
#line 1124
  goto ldv_31563;
  case 2UL: 
#line 1124
  tmp___76 = __be16_to_cpup((__be16 const   *)__p___24);
#line 1124
  dev_lim->flags = (u32 )tmp___76;
#line 1124
  goto ldv_31563;
  case 4UL: 
#line 1124
  dev_lim->flags = __be32_to_cpup((__be32 const   *)__p___24);
#line 1124
  goto ldv_31563;
  case 8UL: 
#line 1124
  tmp___77 = __be64_to_cpup((__be64 const   *)__p___24);
#line 1124
  dev_lim->flags = (u32 )tmp___77;
#line 1124
  goto ldv_31563;
  default: 
#line 1124
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31563: 
#line 1125
  __p___25 = (void *)outbox + 72U;
#line 1125
  switch (1UL) {
  case 1UL: 
#line 1125
  field = *((u8 *)__p___25);
#line 1125
  goto ldv_31570;
  case 2UL: 
#line 1125
  tmp___78 = __be16_to_cpup((__be16 const   *)__p___25);
#line 1125
  field = (u8 )tmp___78;
#line 1125
  goto ldv_31570;
  case 4UL: 
#line 1125
  tmp___79 = __be32_to_cpup((__be32 const   *)__p___25);
#line 1125
  field = (u8 )tmp___79;
#line 1125
  goto ldv_31570;
  case 8UL: 
#line 1125
  tmp___80 = __be64_to_cpup((__be64 const   *)__p___25);
#line 1125
  field = (u8 )tmp___80;
#line 1125
  goto ldv_31570;
  default: 
#line 1125
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31570: 
#line 1126
  dev_lim->reserved_uars = (int )field >> 4;
#line 1127
  __p___26 = (void *)outbox + 73U;
#line 1127
  switch (1UL) {
  case 1UL: 
#line 1127
  field = *((u8 *)__p___26);
#line 1127
  goto ldv_31577;
  case 2UL: 
#line 1127
  tmp___81 = __be16_to_cpup((__be16 const   *)__p___26);
#line 1127
  field = (u8 )tmp___81;
#line 1127
  goto ldv_31577;
  case 4UL: 
#line 1127
  tmp___82 = __be32_to_cpup((__be32 const   *)__p___26);
#line 1127
  field = (u8 )tmp___82;
#line 1127
  goto ldv_31577;
  case 8UL: 
#line 1127
  tmp___83 = __be64_to_cpup((__be64 const   *)__p___26);
#line 1127
  field = (u8 )tmp___83;
#line 1127
  goto ldv_31577;
  default: 
#line 1127
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31577: 
#line 1128
  dev_lim->uar_size = 1 << (((int )field & 63) + 20);
#line 1129
  __p___27 = (void *)outbox + 75U;
#line 1129
  switch (1UL) {
  case 1UL: 
#line 1129
  field = *((u8 *)__p___27);
#line 1129
  goto ldv_31584;
  case 2UL: 
#line 1129
  tmp___84 = __be16_to_cpup((__be16 const   *)__p___27);
#line 1129
  field = (u8 )tmp___84;
#line 1129
  goto ldv_31584;
  case 4UL: 
#line 1129
  tmp___85 = __be32_to_cpup((__be32 const   *)__p___27);
#line 1129
  field = (u8 )tmp___85;
#line 1129
  goto ldv_31584;
  case 8UL: 
#line 1129
  tmp___86 = __be64_to_cpup((__be64 const   *)__p___27);
#line 1129
  field = (u8 )tmp___86;
#line 1129
  goto ldv_31584;
  default: 
#line 1129
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31584: 
#line 1130
  dev_lim->min_page_sz = 1 << (int )field;
#line 1131
  __p___28 = (void *)outbox + 81U;
#line 1131
  switch (1UL) {
  case 1UL: 
#line 1131
  field = *((u8 *)__p___28);
#line 1131
  goto ldv_31591;
  case 2UL: 
#line 1131
  tmp___87 = __be16_to_cpup((__be16 const   *)__p___28);
#line 1131
  field = (u8 )tmp___87;
#line 1131
  goto ldv_31591;
  case 4UL: 
#line 1131
  tmp___88 = __be32_to_cpup((__be32 const   *)__p___28);
#line 1131
  field = (u8 )tmp___88;
#line 1131
  goto ldv_31591;
  case 8UL: 
#line 1131
  tmp___89 = __be64_to_cpup((__be64 const   *)__p___28);
#line 1131
  field = (u8 )tmp___89;
#line 1131
  goto ldv_31591;
  default: 
#line 1131
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31591: 
#line 1132
  dev_lim->max_sg = (int )field;
#line 1134
  __p___29 = (void *)outbox + 82U;
#line 1134
  switch (2UL) {
  case 1UL: 
#line 1134
  size = (u16 )*((u8 *)__p___29);
#line 1134
  goto ldv_31598;
  case 2UL: 
#line 1134
  size = __be16_to_cpup((__be16 const   *)__p___29);
#line 1134
  goto ldv_31598;
  case 4UL: 
#line 1134
  tmp___90 = __be32_to_cpup((__be32 const   *)__p___29);
#line 1134
  size = (u16 )tmp___90;
#line 1134
  goto ldv_31598;
  case 8UL: 
#line 1134
  tmp___91 = __be64_to_cpup((__be64 const   *)__p___29);
#line 1134
  size = (u16 )tmp___91;
#line 1134
  goto ldv_31598;
  default: 
#line 1134
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31598: 
#line 1135
  dev_lim->max_desc_sz = (int )size;
#line 1137
  __p___30 = (void *)outbox + 97U;
#line 1137
  switch (1UL) {
  case 1UL: 
#line 1137
  field = *((u8 *)__p___30);
#line 1137
  goto ldv_31605;
  case 2UL: 
#line 1137
  tmp___92 = __be16_to_cpup((__be16 const   *)__p___30);
#line 1137
  field = (u8 )tmp___92;
#line 1137
  goto ldv_31605;
  case 4UL: 
#line 1137
  tmp___93 = __be32_to_cpup((__be32 const   *)__p___30);
#line 1137
  field = (u8 )tmp___93;
#line 1137
  goto ldv_31605;
  case 8UL: 
#line 1137
  tmp___94 = __be64_to_cpup((__be64 const   *)__p___30);
#line 1137
  field = (u8 )tmp___94;
#line 1137
  goto ldv_31605;
  default: 
#line 1137
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31605: 
#line 1138
  dev_lim->max_qp_per_mcg = 1 << (int )field;
#line 1139
  __p___31 = (void *)outbox + 98U;
#line 1139
  switch (1UL) {
  case 1UL: 
#line 1139
  field = *((u8 *)__p___31);
#line 1139
  goto ldv_31612;
  case 2UL: 
#line 1139
  tmp___95 = __be16_to_cpup((__be16 const   *)__p___31);
#line 1139
  field = (u8 )tmp___95;
#line 1139
  goto ldv_31612;
  case 4UL: 
#line 1139
  tmp___96 = __be32_to_cpup((__be32 const   *)__p___31);
#line 1139
  field = (u8 )tmp___96;
#line 1139
  goto ldv_31612;
  case 8UL: 
#line 1139
  tmp___97 = __be64_to_cpup((__be64 const   *)__p___31);
#line 1139
  field = (u8 )tmp___97;
#line 1139
  goto ldv_31612;
  default: 
#line 1139
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31612: 
#line 1140
  dev_lim->reserved_mgms = (int )field & 15;
#line 1141
  __p___32 = (void *)outbox + 99U;
#line 1141
  switch (1UL) {
  case 1UL: 
#line 1141
  field = *((u8 *)__p___32);
#line 1141
  goto ldv_31619;
  case 2UL: 
#line 1141
  tmp___98 = __be16_to_cpup((__be16 const   *)__p___32);
#line 1141
  field = (u8 )tmp___98;
#line 1141
  goto ldv_31619;
  case 4UL: 
#line 1141
  tmp___99 = __be32_to_cpup((__be32 const   *)__p___32);
#line 1141
  field = (u8 )tmp___99;
#line 1141
  goto ldv_31619;
  case 8UL: 
#line 1141
  tmp___100 = __be64_to_cpup((__be64 const   *)__p___32);
#line 1141
  field = (u8 )tmp___100;
#line 1141
  goto ldv_31619;
  default: 
#line 1141
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31619: 
#line 1142
  dev_lim->max_mcgs = 1 << (int )field;
#line 1143
  __p___33 = (void *)outbox + 100U;
#line 1143
  switch (1UL) {
  case 1UL: 
#line 1143
  field = *((u8 *)__p___33);
#line 1143
  goto ldv_31626;
  case 2UL: 
#line 1143
  tmp___101 = __be16_to_cpup((__be16 const   *)__p___33);
#line 1143
  field = (u8 )tmp___101;
#line 1143
  goto ldv_31626;
  case 4UL: 
#line 1143
  tmp___102 = __be32_to_cpup((__be32 const   *)__p___33);
#line 1143
  field = (u8 )tmp___102;
#line 1143
  goto ldv_31626;
  case 8UL: 
#line 1143
  tmp___103 = __be64_to_cpup((__be64 const   *)__p___33);
#line 1143
  field = (u8 )tmp___103;
#line 1143
  goto ldv_31626;
  default: 
#line 1143
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31626: 
#line 1144
  dev_lim->reserved_pds = (int )field >> 4;
#line 1145
  __p___34 = (void *)outbox + 101U;
#line 1145
  switch (1UL) {
  case 1UL: 
#line 1145
  field = *((u8 *)__p___34);
#line 1145
  goto ldv_31633;
  case 2UL: 
#line 1145
  tmp___104 = __be16_to_cpup((__be16 const   *)__p___34);
#line 1145
  field = (u8 )tmp___104;
#line 1145
  goto ldv_31633;
  case 4UL: 
#line 1145
  tmp___105 = __be32_to_cpup((__be32 const   *)__p___34);
#line 1145
  field = (u8 )tmp___105;
#line 1145
  goto ldv_31633;
  case 8UL: 
#line 1145
  tmp___106 = __be64_to_cpup((__be64 const   *)__p___34);
#line 1145
  field = (u8 )tmp___106;
#line 1145
  goto ldv_31633;
  default: 
#line 1145
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31633: 
#line 1146
  dev_lim->max_pds = 1 << ((int )field & 63);
#line 1147
  __p___35 = (void *)outbox + 102U;
#line 1147
  switch (1UL) {
  case 1UL: 
#line 1147
  field = *((u8 *)__p___35);
#line 1147
  goto ldv_31640;
  case 2UL: 
#line 1147
  tmp___107 = __be16_to_cpup((__be16 const   *)__p___35);
#line 1147
  field = (u8 )tmp___107;
#line 1147
  goto ldv_31640;
  case 4UL: 
#line 1147
  tmp___108 = __be32_to_cpup((__be32 const   *)__p___35);
#line 1147
  field = (u8 )tmp___108;
#line 1147
  goto ldv_31640;
  case 8UL: 
#line 1147
  tmp___109 = __be64_to_cpup((__be64 const   *)__p___35);
#line 1147
  field = (u8 )tmp___109;
#line 1147
  goto ldv_31640;
  default: 
#line 1147
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31640: 
#line 1148
  dev_lim->reserved_rdds = (int )field >> 4;
#line 1149
  __p___36 = (void *)outbox + 103U;
#line 1149
  switch (1UL) {
  case 1UL: 
#line 1149
  field = *((u8 *)__p___36);
#line 1149
  goto ldv_31647;
  case 2UL: 
#line 1149
  tmp___110 = __be16_to_cpup((__be16 const   *)__p___36);
#line 1149
  field = (u8 )tmp___110;
#line 1149
  goto ldv_31647;
  case 4UL: 
#line 1149
  tmp___111 = __be32_to_cpup((__be32 const   *)__p___36);
#line 1149
  field = (u8 )tmp___111;
#line 1149
  goto ldv_31647;
  case 8UL: 
#line 1149
  tmp___112 = __be64_to_cpup((__be64 const   *)__p___36);
#line 1149
  field = (u8 )tmp___112;
#line 1149
  goto ldv_31647;
  default: 
#line 1149
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31647: 
#line 1150
  dev_lim->max_rdds = 1 << ((int )field & 63);
#line 1152
  __p___37 = (void *)outbox + 128U;
#line 1152
  switch (2UL) {
  case 1UL: 
#line 1152
  size = (u16 )*((u8 *)__p___37);
#line 1152
  goto ldv_31654;
  case 2UL: 
#line 1152
  size = __be16_to_cpup((__be16 const   *)__p___37);
#line 1152
  goto ldv_31654;
  case 4UL: 
#line 1152
  tmp___113 = __be32_to_cpup((__be32 const   *)__p___37);
#line 1152
  size = (u16 )tmp___113;
#line 1152
  goto ldv_31654;
  case 8UL: 
#line 1152
  tmp___114 = __be64_to_cpup((__be64 const   *)__p___37);
#line 1152
  size = (u16 )tmp___114;
#line 1152
  goto ldv_31654;
  default: 
#line 1152
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31654: 
#line 1153
  dev_lim->eec_entry_sz = (int )size;
#line 1154
  __p___38 = (void *)outbox + 130U;
#line 1154
  switch (2UL) {
  case 1UL: 
#line 1154
  size = (u16 )*((u8 *)__p___38);
#line 1154
  goto ldv_31661;
  case 2UL: 
#line 1154
  size = __be16_to_cpup((__be16 const   *)__p___38);
#line 1154
  goto ldv_31661;
  case 4UL: 
#line 1154
  tmp___115 = __be32_to_cpup((__be32 const   *)__p___38);
#line 1154
  size = (u16 )tmp___115;
#line 1154
  goto ldv_31661;
  case 8UL: 
#line 1154
  tmp___116 = __be64_to_cpup((__be64 const   *)__p___38);
#line 1154
  size = (u16 )tmp___116;
#line 1154
  goto ldv_31661;
  default: 
#line 1154
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31661: 
#line 1155
  dev_lim->qpc_entry_sz = (int )size;
#line 1156
  __p___39 = (void *)outbox + 132U;
#line 1156
  switch (2UL) {
  case 1UL: 
#line 1156
  size = (u16 )*((u8 *)__p___39);
#line 1156
  goto ldv_31668;
  case 2UL: 
#line 1156
  size = __be16_to_cpup((__be16 const   *)__p___39);
#line 1156
  goto ldv_31668;
  case 4UL: 
#line 1156
  tmp___117 = __be32_to_cpup((__be32 const   *)__p___39);
#line 1156
  size = (u16 )tmp___117;
#line 1156
  goto ldv_31668;
  case 8UL: 
#line 1156
  tmp___118 = __be64_to_cpup((__be64 const   *)__p___39);
#line 1156
  size = (u16 )tmp___118;
#line 1156
  goto ldv_31668;
  default: 
#line 1156
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31668: 
#line 1157
  dev_lim->eeec_entry_sz = (int )size;
#line 1158
  __p___40 = (void *)outbox + 134U;
#line 1158
  switch (2UL) {
  case 1UL: 
#line 1158
  size = (u16 )*((u8 *)__p___40);
#line 1158
  goto ldv_31675;
  case 2UL: 
#line 1158
  size = __be16_to_cpup((__be16 const   *)__p___40);
#line 1158
  goto ldv_31675;
  case 4UL: 
#line 1158
  tmp___119 = __be32_to_cpup((__be32 const   *)__p___40);
#line 1158
  size = (u16 )tmp___119;
#line 1158
  goto ldv_31675;
  case 8UL: 
#line 1158
  tmp___120 = __be64_to_cpup((__be64 const   *)__p___40);
#line 1158
  size = (u16 )tmp___120;
#line 1158
  goto ldv_31675;
  default: 
#line 1158
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31675: 
#line 1159
  dev_lim->eqpc_entry_sz = (int )size;
#line 1160
  __p___41 = (void *)outbox + 136U;
#line 1160
  switch (2UL) {
  case 1UL: 
#line 1160
  size = (u16 )*((u8 *)__p___41);
#line 1160
  goto ldv_31682;
  case 2UL: 
#line 1160
  size = __be16_to_cpup((__be16 const   *)__p___41);
#line 1160
  goto ldv_31682;
  case 4UL: 
#line 1160
  tmp___121 = __be32_to_cpup((__be32 const   *)__p___41);
#line 1160
  size = (u16 )tmp___121;
#line 1160
  goto ldv_31682;
  case 8UL: 
#line 1160
  tmp___122 = __be64_to_cpup((__be64 const   *)__p___41);
#line 1160
  size = (u16 )tmp___122;
#line 1160
  goto ldv_31682;
  default: 
#line 1160
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31682: 
#line 1161
  dev_lim->eqc_entry_sz = (int )size;
#line 1162
  __p___42 = (void *)outbox + 138U;
#line 1162
  switch (2UL) {
  case 1UL: 
#line 1162
  size = (u16 )*((u8 *)__p___42);
#line 1162
  goto ldv_31689;
  case 2UL: 
#line 1162
  size = __be16_to_cpup((__be16 const   *)__p___42);
#line 1162
  goto ldv_31689;
  case 4UL: 
#line 1162
  tmp___123 = __be32_to_cpup((__be32 const   *)__p___42);
#line 1162
  size = (u16 )tmp___123;
#line 1162
  goto ldv_31689;
  case 8UL: 
#line 1162
  tmp___124 = __be64_to_cpup((__be64 const   *)__p___42);
#line 1162
  size = (u16 )tmp___124;
#line 1162
  goto ldv_31689;
  default: 
#line 1162
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31689: 
#line 1163
  dev_lim->cqc_entry_sz = (int )size;
#line 1164
  __p___43 = (void *)outbox + 140U;
#line 1164
  switch (2UL) {
  case 1UL: 
#line 1164
  size = (u16 )*((u8 *)__p___43);
#line 1164
  goto ldv_31696;
  case 2UL: 
#line 1164
  size = __be16_to_cpup((__be16 const   *)__p___43);
#line 1164
  goto ldv_31696;
  case 4UL: 
#line 1164
  tmp___125 = __be32_to_cpup((__be32 const   *)__p___43);
#line 1164
  size = (u16 )tmp___125;
#line 1164
  goto ldv_31696;
  case 8UL: 
#line 1164
  tmp___126 = __be64_to_cpup((__be64 const   *)__p___43);
#line 1164
  size = (u16 )tmp___126;
#line 1164
  goto ldv_31696;
  default: 
#line 1164
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31696: 
#line 1165
  dev_lim->srq_entry_sz = (int )size;
#line 1166
  __p___44 = (void *)outbox + 142U;
#line 1166
  switch (2UL) {
  case 1UL: 
#line 1166
  size = (u16 )*((u8 *)__p___44);
#line 1166
  goto ldv_31703;
  case 2UL: 
#line 1166
  size = __be16_to_cpup((__be16 const   *)__p___44);
#line 1166
  goto ldv_31703;
  case 4UL: 
#line 1166
  tmp___127 = __be32_to_cpup((__be32 const   *)__p___44);
#line 1166
  size = (u16 )tmp___127;
#line 1166
  goto ldv_31703;
  case 8UL: 
#line 1166
  tmp___128 = __be64_to_cpup((__be64 const   *)__p___44);
#line 1166
  size = (u16 )tmp___128;
#line 1166
  goto ldv_31703;
  default: 
#line 1166
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31703: 
#line 1167
  dev_lim->uar_scratch_entry_sz = (int )size;
#line 1169
  tmp___167 = mthca_is_memfree(dev);
#line 1169
  if (tmp___167 != 0) {
#line 1170
    __p___45 = (void *)outbox + 16U;
#line 1170
    switch (1UL) {
    case 1UL: 
#line 1170
    field = *((u8 *)__p___45);
#line 1170
    goto ldv_31710;
    case 2UL: 
#line 1170
    tmp___129 = __be16_to_cpup((__be16 const   *)__p___45);
#line 1170
    field = (u8 )tmp___129;
#line 1170
    goto ldv_31710;
    case 4UL: 
#line 1170
    tmp___130 = __be32_to_cpup((__be32 const   *)__p___45);
#line 1170
    field = (u8 )tmp___130;
#line 1170
    goto ldv_31710;
    case 8UL: 
#line 1170
    tmp___131 = __be64_to_cpup((__be64 const   *)__p___45);
#line 1170
    field = (u8 )tmp___131;
#line 1170
    goto ldv_31710;
    default: 
#line 1170
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31710: 
#line 1171
    dev_lim->max_srq_sz = 1 << (int )field;
#line 1172
    __p___46 = (void *)outbox + 17U;
#line 1172
    switch (1UL) {
    case 1UL: 
#line 1172
    field = *((u8 *)__p___46);
#line 1172
    goto ldv_31717;
    case 2UL: 
#line 1172
    tmp___132 = __be16_to_cpup((__be16 const   *)__p___46);
#line 1172
    field = (u8 )tmp___132;
#line 1172
    goto ldv_31717;
    case 4UL: 
#line 1172
    tmp___133 = __be32_to_cpup((__be32 const   *)__p___46);
#line 1172
    field = (u8 )tmp___133;
#line 1172
    goto ldv_31717;
    case 8UL: 
#line 1172
    tmp___134 = __be64_to_cpup((__be64 const   *)__p___46);
#line 1172
    field = (u8 )tmp___134;
#line 1172
    goto ldv_31717;
    default: 
#line 1172
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31717: 
#line 1173
    dev_lim->max_qp_sz = 1 << (int )field;
#line 1174
    __p___47 = (void *)outbox + 51U;
#line 1174
    switch (1UL) {
    case 1UL: 
#line 1174
    field = *((u8 *)__p___47);
#line 1174
    goto ldv_31724;
    case 2UL: 
#line 1174
    tmp___135 = __be16_to_cpup((__be16 const   *)__p___47);
#line 1174
    field = (u8 )tmp___135;
#line 1174
    goto ldv_31724;
    case 4UL: 
#line 1174
    tmp___136 = __be32_to_cpup((__be32 const   *)__p___47);
#line 1174
    field = (u8 )tmp___136;
#line 1174
    goto ldv_31724;
    case 8UL: 
#line 1174
    tmp___137 = __be64_to_cpup((__be64 const   *)__p___47);
#line 1174
    field = (u8 )tmp___137;
#line 1174
    goto ldv_31724;
    default: 
#line 1174
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31724: 
#line 1175
    dev_lim->hca.arbel.resize_srq = (int )field & 1;
#line 1176
    __p___48 = (void *)outbox + 85U;
#line 1176
    switch (1UL) {
    case 1UL: 
#line 1176
    field = *((u8 *)__p___48);
#line 1176
    goto ldv_31731;
    case 2UL: 
#line 1176
    tmp___138 = __be16_to_cpup((__be16 const   *)__p___48);
#line 1176
    field = (u8 )tmp___138;
#line 1176
    goto ldv_31731;
    case 4UL: 
#line 1176
    tmp___139 = __be32_to_cpup((__be32 const   *)__p___48);
#line 1176
    field = (u8 )tmp___139;
#line 1176
    goto ldv_31731;
    case 8UL: 
#line 1176
    tmp___140 = __be64_to_cpup((__be64 const   *)__p___48);
#line 1176
    field = (u8 )tmp___140;
#line 1176
    goto ldv_31731;
    default: 
#line 1176
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31731: 
#line 1177
    __min1 = (int )field;
#line 1177
    __min2 = dev_lim->max_sg;
#line 1177
    dev_lim->max_sg = __min1 < __min2 ? __min1 : __min2;
#line 1178
    __p___49 = (void *)outbox + 86U;
#line 1178
    switch (2UL) {
    case 1UL: 
#line 1178
    size = (u16 )*((u8 *)__p___49);
#line 1178
    goto ldv_31741;
    case 2UL: 
#line 1178
    size = __be16_to_cpup((__be16 const   *)__p___49);
#line 1178
    goto ldv_31741;
    case 4UL: 
#line 1178
    tmp___141 = __be32_to_cpup((__be32 const   *)__p___49);
#line 1178
    size = (u16 )tmp___141;
#line 1178
    goto ldv_31741;
    case 8UL: 
#line 1178
    tmp___142 = __be64_to_cpup((__be64 const   *)__p___49);
#line 1178
    size = (u16 )tmp___142;
#line 1178
    goto ldv_31741;
    default: 
#line 1178
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31741: 
#line 1179
    __min1___0 = (int )size;
#line 1179
    __min2___0 = dev_lim->max_desc_sz;
#line 1179
    dev_lim->max_desc_sz = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
#line 1180
    __p___50 = (void *)outbox + 146U;
#line 1180
    switch (2UL) {
    case 1UL: 
#line 1180
    size = (u16 )*((u8 *)__p___50);
#line 1180
    goto ldv_31751;
    case 2UL: 
#line 1180
    size = __be16_to_cpup((__be16 const   *)__p___50);
#line 1180
    goto ldv_31751;
    case 4UL: 
#line 1180
    tmp___143 = __be32_to_cpup((__be32 const   *)__p___50);
#line 1180
    size = (u16 )tmp___143;
#line 1180
    goto ldv_31751;
    case 8UL: 
#line 1180
    tmp___144 = __be64_to_cpup((__be64 const   *)__p___50);
#line 1180
    size = (u16 )tmp___144;
#line 1180
    goto ldv_31751;
    default: 
#line 1180
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31751: 
#line 1181
    dev_lim->mpt_entry_sz = (int )size;
#line 1182
    __p___51 = (void *)outbox + 150U;
#line 1182
    switch (1UL) {
    case 1UL: 
#line 1182
    field = *((u8 *)__p___51);
#line 1182
    goto ldv_31758;
    case 2UL: 
#line 1182
    tmp___145 = __be16_to_cpup((__be16 const   *)__p___51);
#line 1182
    field = (u8 )tmp___145;
#line 1182
    goto ldv_31758;
    case 4UL: 
#line 1182
    tmp___146 = __be32_to_cpup((__be32 const   *)__p___51);
#line 1182
    field = (u8 )tmp___146;
#line 1182
    goto ldv_31758;
    case 8UL: 
#line 1182
    tmp___147 = __be64_to_cpup((__be64 const   *)__p___51);
#line 1182
    field = (u8 )tmp___147;
#line 1182
    goto ldv_31758;
    default: 
#line 1182
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31758: 
#line 1183
    dev_lim->hca.arbel.max_pbl_sz = 1 << ((int )field & 63);
#line 1184
    __p___52 = (void *)outbox + 151U;
#line 1184
    switch (1UL) {
    case 1UL: 
#line 1184
    dev_lim->hca.arbel.bmme_flags = *((u8 *)__p___52);
#line 1184
    goto ldv_31765;
    case 2UL: 
#line 1184
    tmp___148 = __be16_to_cpup((__be16 const   *)__p___52);
#line 1184
    dev_lim->hca.arbel.bmme_flags = (u8 )tmp___148;
#line 1184
    goto ldv_31765;
    case 4UL: 
#line 1184
    tmp___149 = __be32_to_cpup((__be32 const   *)__p___52);
#line 1184
    dev_lim->hca.arbel.bmme_flags = (u8 )tmp___149;
#line 1184
    goto ldv_31765;
    case 8UL: 
#line 1184
    tmp___150 = __be64_to_cpup((__be64 const   *)__p___52);
#line 1184
    dev_lim->hca.arbel.bmme_flags = (u8 )tmp___150;
#line 1184
    goto ldv_31765;
    default: 
#line 1184
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31765: 
#line 1186
    __p___53 = (void *)outbox + 152U;
#line 1186
    switch (4UL) {
    case 1UL: 
#line 1186
    dev_lim->hca.arbel.reserved_lkey = (u32 )*((u8 *)__p___53);
#line 1186
    goto ldv_31772;
    case 2UL: 
#line 1186
    tmp___151 = __be16_to_cpup((__be16 const   *)__p___53);
#line 1186
    dev_lim->hca.arbel.reserved_lkey = (u32 )tmp___151;
#line 1186
    goto ldv_31772;
    case 4UL: 
#line 1186
    dev_lim->hca.arbel.reserved_lkey = __be32_to_cpup((__be32 const   *)__p___53);
#line 1186
    goto ldv_31772;
    case 8UL: 
#line 1186
    tmp___152 = __be64_to_cpup((__be64 const   *)__p___53);
#line 1186
    dev_lim->hca.arbel.reserved_lkey = (u32 )tmp___152;
#line 1186
    goto ldv_31772;
    default: 
#line 1186
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31772: 
#line 1188
    __p___54 = (void *)outbox + 159U;
#line 1188
    switch (1UL) {
    case 1UL: 
#line 1188
    field = *((u8 *)__p___54);
#line 1188
    goto ldv_31779;
    case 2UL: 
#line 1188
    tmp___153 = __be16_to_cpup((__be16 const   *)__p___54);
#line 1188
    field = (u8 )tmp___153;
#line 1188
    goto ldv_31779;
    case 4UL: 
#line 1188
    tmp___154 = __be32_to_cpup((__be32 const   *)__p___54);
#line 1188
    field = (u8 )tmp___154;
#line 1188
    goto ldv_31779;
    case 8UL: 
#line 1188
    tmp___155 = __be64_to_cpup((__be64 const   *)__p___54);
#line 1188
    field = (u8 )tmp___155;
#line 1188
    goto ldv_31779;
    default: 
#line 1188
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31779: 
#line 1189
    dev_lim->hca.arbel.lam_required = (int )field & 1;
#line 1190
    __p___55 = (void *)outbox + 160U;
#line 1190
    switch (8UL) {
    case 1UL: 
#line 1190
    dev_lim->hca.arbel.max_icm_sz = (u64 )*((u8 *)__p___55);
#line 1190
    goto ldv_31786;
    case 2UL: 
#line 1190
    tmp___156 = __be16_to_cpup((__be16 const   *)__p___55);
#line 1190
    dev_lim->hca.arbel.max_icm_sz = (u64 )tmp___156;
#line 1190
    goto ldv_31786;
    case 4UL: 
#line 1190
    tmp___157 = __be32_to_cpup((__be32 const   *)__p___55);
#line 1190
    dev_lim->hca.arbel.max_icm_sz = (u64 )tmp___157;
#line 1190
    goto ldv_31786;
    case 8UL: 
#line 1190
    dev_lim->hca.arbel.max_icm_sz = __be64_to_cpup((__be64 const   *)__p___55);
#line 1190
    goto ldv_31786;
    default: 
#line 1190
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31786: ;
#line 1193
    if ((int )dev_lim->hca.arbel.bmme_flags & 1) {
#line 1194
      if (mthca_debug_level != 0) {
#line 1194
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Base MM extensions: yes (flags %d, max PBL %d, rsvd L_Key %08x)\n",
                   (int )dev_lim->hca.arbel.bmme_flags, dev_lim->hca.arbel.max_pbl_sz,
                   dev_lim->hca.arbel.reserved_lkey);
      } else {

      }
    } else
#line 1200
    if (mthca_debug_level != 0) {
#line 1200
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Base MM extensions: no\n");
    } else {

    }
#line 1202
    if (mthca_debug_level != 0) {
#line 1202
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max ICM size %lld MB\n",
                 dev_lim->hca.arbel.max_icm_sz >> 20);
    } else {

    }
  } else {
#line 1205
    __p___56 = (void *)outbox + 16U;
#line 1205
    switch (1UL) {
    case 1UL: 
#line 1205
    field = *((u8 *)__p___56);
#line 1205
    goto ldv_31793;
    case 2UL: 
#line 1205
    tmp___158 = __be16_to_cpup((__be16 const   *)__p___56);
#line 1205
    field = (u8 )tmp___158;
#line 1205
    goto ldv_31793;
    case 4UL: 
#line 1205
    tmp___159 = __be32_to_cpup((__be32 const   *)__p___56);
#line 1205
    field = (u8 )tmp___159;
#line 1205
    goto ldv_31793;
    case 8UL: 
#line 1205
    tmp___160 = __be64_to_cpup((__be64 const   *)__p___56);
#line 1205
    field = (u8 )tmp___160;
#line 1205
    goto ldv_31793;
    default: 
#line 1205
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31793: 
#line 1206
    dev_lim->max_srq_sz = (1 << (int )field) + -1;
#line 1207
    __p___57 = (void *)outbox + 17U;
#line 1207
    switch (1UL) {
    case 1UL: 
#line 1207
    field = *((u8 *)__p___57);
#line 1207
    goto ldv_31800;
    case 2UL: 
#line 1207
    tmp___161 = __be16_to_cpup((__be16 const   *)__p___57);
#line 1207
    field = (u8 )tmp___161;
#line 1207
    goto ldv_31800;
    case 4UL: 
#line 1207
    tmp___162 = __be32_to_cpup((__be32 const   *)__p___57);
#line 1207
    field = (u8 )tmp___162;
#line 1207
    goto ldv_31800;
    case 8UL: 
#line 1207
    tmp___163 = __be64_to_cpup((__be64 const   *)__p___57);
#line 1207
    field = (u8 )tmp___163;
#line 1207
    goto ldv_31800;
    default: 
#line 1207
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31800: 
#line 1208
    dev_lim->max_qp_sz = (1 << (int )field) + -1;
#line 1209
    __p___58 = (void *)outbox + 39U;
#line 1209
    switch (1UL) {
    case 1UL: 
#line 1209
    field = *((u8 *)__p___58);
#line 1209
    goto ldv_31807;
    case 2UL: 
#line 1209
    tmp___164 = __be16_to_cpup((__be16 const   *)__p___58);
#line 1209
    field = (u8 )tmp___164;
#line 1209
    goto ldv_31807;
    case 4UL: 
#line 1209
    tmp___165 = __be32_to_cpup((__be32 const   *)__p___58);
#line 1209
    field = (u8 )tmp___165;
#line 1209
    goto ldv_31807;
    case 8UL: 
#line 1209
    tmp___166 = __be64_to_cpup((__be64 const   *)__p___58);
#line 1209
    field = (u8 )tmp___166;
#line 1209
    goto ldv_31807;
    default: 
#line 1209
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31807: 
#line 1210
    dev_lim->hca.tavor.max_avs = 1 << ((int )field & 63);
#line 1211
    dev_lim->mpt_entry_sz = 64;
  }
#line 1214
  if (mthca_debug_level != 0) {
#line 1214
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max QPs: %d, reserved QPs: %d, entry size: %d\n",
               dev_lim->max_qps, dev_lim->reserved_qps, dev_lim->qpc_entry_sz);
  } else {

  }
#line 1216
  if (mthca_debug_level != 0) {
#line 1216
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max SRQs: %d, reserved SRQs: %d, entry size: %d\n",
               dev_lim->max_srqs, dev_lim->reserved_srqs, dev_lim->srq_entry_sz);
  } else {

  }
#line 1218
  if (mthca_debug_level != 0) {
#line 1218
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max CQs: %d, reserved CQs: %d, entry size: %d\n",
               dev_lim->max_cqs, dev_lim->reserved_cqs, dev_lim->cqc_entry_sz);
  } else {

  }
#line 1220
  if (mthca_debug_level != 0) {
#line 1220
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max EQs: %d, reserved EQs: %d, entry size: %d\n",
               dev_lim->max_eqs, dev_lim->reserved_eqs, dev_lim->eqc_entry_sz);
  } else {

  }
#line 1222
  if (mthca_debug_level != 0) {
#line 1222
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "reserved MPTs: %d, reserved MTTs: %d\n",
               dev_lim->reserved_mrws, dev_lim->reserved_mtts);
  } else {

  }
#line 1224
  if (mthca_debug_level != 0) {
#line 1224
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max PDs: %d, reserved PDs: %d, reserved UARs: %d\n",
               dev_lim->max_pds, dev_lim->reserved_pds, dev_lim->reserved_uars);
  } else {

  }
#line 1226
  if (mthca_debug_level != 0) {
#line 1226
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max QP/MCG: %d, reserved MGMs: %d\n",
               dev_lim->max_pds, dev_lim->reserved_mgms);
  } else {

  }
#line 1228
  if (mthca_debug_level != 0) {
#line 1228
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max CQEs: %d, max WQEs: %d, max SRQ WQEs: %d\n",
               dev_lim->max_cq_sz, dev_lim->max_qp_sz, dev_lim->max_srq_sz);
  } else {

  }
#line 1231
  if (mthca_debug_level != 0) {
#line 1231
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Flags: %08x\n",
               dev_lim->flags);
  } else {

  }
  out: 
#line 1234
  mthca_free_mailbox(dev, mailbox);
#line 1235
  return (err);
}
}
#line 1238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
static void get_board_id(void *vsd , char *board_id ) 
{ 
  int i ;
  __u32 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;

  {
#line 1249
  memset((void *)board_id, 0, 64UL);
#line 1251
  tmp___0 = __be16_to_cpup((__be16 const   *)vsd);
#line 1251
  if ((unsigned int )tmp___0 == 1453U) {
#line 1251
    tmp___1 = __be16_to_cpup((__be16 const   *)vsd + 222U);
#line 1251
    if ((unsigned int )tmp___1 == 1453U) {
#line 1253
      strlcpy(board_id, (char const   *)vsd + 32U, 64UL);
    } else {
#line 1251
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1260
    i = 0;
#line 1260
    goto ldv_31818;
    ldv_31817: 
#line 1261
    tmp = __fswab32(*((u32 *)(vsd + ((unsigned long )(i * 4) + 208UL))));
#line 1261
    *((u32 *)board_id + (unsigned long )i) = tmp;
#line 1260
    i = i + 1;
    ldv_31818: ;
#line 1260
    if (i <= 3) {
#line 1262
      goto ldv_31817;
    } else {

    }

  }
#line 1268
  return;
}
}
#line 1266 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_QUERY_ADAPTER(struct mthca_dev *dev , struct mthca_adapter *adapter ) 
{ 
  struct mthca_mailbox *mailbox ;
  u32 *outbox ;
  int err ;
  long tmp ;
  bool tmp___0 ;
  void *__p ;
  __u16 tmp___1 ;
  __u64 tmp___2 ;
  void *__p___0 ;
  __u16 tmp___3 ;
  __u64 tmp___4 ;
  void *__p___1 ;
  __u16 tmp___5 ;
  __u64 tmp___6 ;
  int tmp___7 ;
  void *__p___2 ;
  __u16 tmp___8 ;
  __u32 tmp___9 ;
  __u64 tmp___10 ;

  {
#line 1280
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1281
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1281
  if ((int )tmp___0) {
#line 1282
    tmp = PTR_ERR((void const   *)mailbox);
#line 1282
    return ((int )tmp);
  } else {

  }
#line 1283
  outbox = (u32 *)mailbox->buf;
#line 1285
  err = mthca_cmd_box(dev, 0ULL, mailbox->dma, 0U, 0, 6, 15000UL);
#line 1288
  if (err != 0) {
#line 1289
    goto out;
  } else {

  }
#line 1291
  tmp___7 = mthca_is_memfree(dev);
#line 1291
  if (tmp___7 == 0) {
#line 1292
    __p = (void *)outbox;
#line 1292
    switch (4UL) {
    case 1UL: 
#line 1292
    adapter->vendor_id = (u32 )*((u8 *)__p);
#line 1292
    goto ldv_31830;
    case 2UL: 
#line 1292
    tmp___1 = __be16_to_cpup((__be16 const   *)__p);
#line 1292
    adapter->vendor_id = (u32 )tmp___1;
#line 1292
    goto ldv_31830;
    case 4UL: 
#line 1292
    adapter->vendor_id = __be32_to_cpup((__be32 const   *)__p);
#line 1292
    goto ldv_31830;
    case 8UL: 
#line 1292
    tmp___2 = __be64_to_cpup((__be64 const   *)__p);
#line 1292
    adapter->vendor_id = (u32 )tmp___2;
#line 1292
    goto ldv_31830;
    default: 
#line 1292
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31830: 
#line 1294
    __p___0 = (void *)outbox + 4U;
#line 1294
    switch (4UL) {
    case 1UL: 
#line 1294
    adapter->device_id = (u32 )*((u8 *)__p___0);
#line 1294
    goto ldv_31837;
    case 2UL: 
#line 1294
    tmp___3 = __be16_to_cpup((__be16 const   *)__p___0);
#line 1294
    adapter->device_id = (u32 )tmp___3;
#line 1294
    goto ldv_31837;
    case 4UL: 
#line 1294
    adapter->device_id = __be32_to_cpup((__be32 const   *)__p___0);
#line 1294
    goto ldv_31837;
    case 8UL: 
#line 1294
    tmp___4 = __be64_to_cpup((__be64 const   *)__p___0);
#line 1294
    adapter->device_id = (u32 )tmp___4;
#line 1294
    goto ldv_31837;
    default: 
#line 1294
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31837: 
#line 1296
    __p___1 = (void *)outbox + 8U;
#line 1296
    switch (4UL) {
    case 1UL: 
#line 1296
    adapter->revision_id = (u32 )*((u8 *)__p___1);
#line 1296
    goto ldv_31844;
    case 2UL: 
#line 1296
    tmp___5 = __be16_to_cpup((__be16 const   *)__p___1);
#line 1296
    adapter->revision_id = (u32 )tmp___5;
#line 1296
    goto ldv_31844;
    case 4UL: 
#line 1296
    adapter->revision_id = __be32_to_cpup((__be32 const   *)__p___1);
#line 1296
    goto ldv_31844;
    case 8UL: 
#line 1296
    tmp___6 = __be64_to_cpup((__be64 const   *)__p___1);
#line 1296
    adapter->revision_id = (u32 )tmp___6;
#line 1296
    goto ldv_31844;
    default: 
#line 1296
    __buggy_use_of_MTHCA_GET();
    }
    ldv_31844: ;
  } else {

  }
#line 1299
  __p___2 = (void *)outbox + 16U;
#line 1299
  switch (1UL) {
  case 1UL: 
#line 1299
  adapter->inta_pin = *((u8 *)__p___2);
#line 1299
  goto ldv_31851;
  case 2UL: 
#line 1299
  tmp___8 = __be16_to_cpup((__be16 const   *)__p___2);
#line 1299
  adapter->inta_pin = (u8 )tmp___8;
#line 1299
  goto ldv_31851;
  case 4UL: 
#line 1299
  tmp___9 = __be32_to_cpup((__be32 const   *)__p___2);
#line 1299
  adapter->inta_pin = (u8 )tmp___9;
#line 1299
  goto ldv_31851;
  case 8UL: 
#line 1299
  tmp___10 = __be64_to_cpup((__be64 const   *)__p___2);
#line 1299
  adapter->inta_pin = (u8 )tmp___10;
#line 1299
  goto ldv_31851;
  default: 
#line 1299
  __buggy_use_of_MTHCA_GET();
  }
  ldv_31851: 
#line 1301
  get_board_id((void *)outbox + 8U, (char *)(& adapter->board_id));
  out: 
#line 1305
  mthca_free_mailbox(dev, mailbox);
#line 1306
  return (err);
}
}
#line 1309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_INIT_HCA(struct mthca_dev *dev , struct mthca_init_hca_param *param ) 
{ 
  struct mthca_mailbox *mailbox ;
  __be32 *inbox ;
  int err ;
  long tmp ;
  bool tmp___0 ;
  void *__d ;
  void *__d___0 ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  __u64 tmp___3 ;
  void *__d___1 ;
  __u16 tmp___4 ;
  __u32 tmp___5 ;
  __u64 tmp___6 ;
  void *__d___2 ;
  __u16 tmp___7 ;
  __u32 tmp___8 ;
  __u64 tmp___9 ;
  void *__d___3 ;
  __u16 tmp___10 ;
  __u32 tmp___11 ;
  __u64 tmp___12 ;
  void *__d___4 ;
  __u16 tmp___13 ;
  __u32 tmp___14 ;
  __u64 tmp___15 ;
  void *__d___5 ;
  __u16 tmp___16 ;
  __u32 tmp___17 ;
  __u64 tmp___18 ;
  void *__d___6 ;
  __u16 tmp___19 ;
  __u32 tmp___20 ;
  __u64 tmp___21 ;
  void *__d___7 ;
  __u16 tmp___22 ;
  __u32 tmp___23 ;
  __u64 tmp___24 ;
  void *__d___8 ;
  __u16 tmp___25 ;
  __u32 tmp___26 ;
  __u64 tmp___27 ;
  void *__d___9 ;
  __u16 tmp___28 ;
  __u32 tmp___29 ;
  __u64 tmp___30 ;
  void *__d___10 ;
  __u16 tmp___31 ;
  __u32 tmp___32 ;
  __u64 tmp___33 ;
  void *__d___11 ;
  __u16 tmp___34 ;
  __u32 tmp___35 ;
  __u64 tmp___36 ;
  void *__d___12 ;
  __u16 tmp___37 ;
  __u32 tmp___38 ;
  __u64 tmp___39 ;
  void *__d___13 ;
  __u16 tmp___40 ;
  __u32 tmp___41 ;
  __u64 tmp___42 ;
  void *__d___14 ;
  __u16 tmp___43 ;
  __u32 tmp___44 ;
  __u64 tmp___45 ;
  void *__d___15 ;
  __u16 tmp___46 ;
  __u32 tmp___47 ;
  __u64 tmp___48 ;
  void *__d___16 ;
  __u16 tmp___49 ;
  __u32 tmp___50 ;
  __u64 tmp___51 ;
  void *__d___17 ;
  __u16 tmp___52 ;
  __u32 tmp___53 ;
  __u64 tmp___54 ;
  void *__d___18 ;
  __u16 tmp___55 ;
  __u32 tmp___56 ;
  __u64 tmp___57 ;
  int tmp___58 ;
  void *__d___19 ;
  __u16 tmp___59 ;
  __u32 tmp___60 ;
  __u64 tmp___61 ;
  void *__d___20 ;
  __u16 tmp___62 ;
  __u32 tmp___63 ;
  __u64 tmp___64 ;
  u8 uar_page_sz ;
  void *__d___21 ;
  __u16 tmp___65 ;
  __u32 tmp___66 ;
  __u64 tmp___67 ;
  void *__d___22 ;
  __u16 tmp___68 ;
  __u32 tmp___69 ;
  __u64 tmp___70 ;
  void *__d___23 ;
  __u16 tmp___71 ;
  __u32 tmp___72 ;
  __u64 tmp___73 ;
  void *__d___24 ;
  __u16 tmp___74 ;
  __u32 tmp___75 ;
  __u64 tmp___76 ;
  void *__d___25 ;
  __u16 tmp___77 ;
  __u32 tmp___78 ;
  __u64 tmp___79 ;
  int tmp___80 ;

  {
#line 1354
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1355
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1355
  if ((int )tmp___0) {
#line 1356
    tmp = PTR_ERR((void const   *)mailbox);
#line 1356
    return ((int )tmp);
  } else {

  }
#line 1357
  inbox = (__be32 *)mailbox->buf;
#line 1359
  memset((void *)inbox, 0, 512UL);
#line 1361
  if ((dev->mthca_flags & 256UL) != 0UL) {
#line 1362
    __d = (void *)inbox + 12U;
#line 1362
    switch (4UL) {
    case 1UL: 
#line 1362
    *((u8 *)__d) = 1U;
#line 1362
    goto ldv_31865;
    case 2UL: 
#line 1362
    *((__be16 *)__d) = 256U;
#line 1362
    goto ldv_31865;
    case 4UL: 
#line 1362
    *((__be32 *)__d) = 16777216U;
#line 1362
    goto ldv_31865;
    case 8UL: 
#line 1362
    *((__be64 *)__d) = 72057594037927936ULL;
#line 1362
    goto ldv_31865;
    default: 
#line 1362
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_31865: ;
  } else {

  }
#line 1365
  *(inbox + 5UL) = *(inbox + 5UL) & 4261412863U;
#line 1372
  *(inbox + 5UL) = *(inbox + 5UL) | 16777216U;
#line 1375
  if ((dev->device_cap_flags & 262144UL) != 0UL) {
#line 1376
    *(inbox + 5UL) = *(inbox + 5UL) | 939524096U;
  } else {

  }
#line 1382
  __d___0 = (void *)inbox + 48U;
#line 1382
  switch (8UL) {
  case 1UL: 
#line 1382
  *((u8 *)__d___0) = (u8 )param->qpc_base;
#line 1382
  goto ldv_31872;
  case 2UL: 
#line 1382
  tmp___1 = __fswab16((int )((__u16 )param->qpc_base));
#line 1382
  *((__be16 *)__d___0) = tmp___1;
#line 1382
  goto ldv_31872;
  case 4UL: 
#line 1382
  tmp___2 = __fswab32((__u32 )param->qpc_base);
#line 1382
  *((__be32 *)__d___0) = tmp___2;
#line 1382
  goto ldv_31872;
  case 8UL: 
#line 1382
  tmp___3 = __fswab64(param->qpc_base);
#line 1382
  *((__be64 *)__d___0) = tmp___3;
#line 1382
  goto ldv_31872;
  default: 
#line 1382
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31872: 
#line 1383
  __d___1 = (void *)inbox + 55U;
#line 1383
  switch (1UL) {
  case 1UL: 
#line 1383
  *((u8 *)__d___1) = param->log_num_qps;
#line 1383
  goto ldv_31879;
  case 2UL: 
#line 1383
  tmp___4 = __fswab16((int )param->log_num_qps);
#line 1383
  *((__be16 *)__d___1) = tmp___4;
#line 1383
  goto ldv_31879;
  case 4UL: 
#line 1383
  tmp___5 = __fswab32((__u32 )param->log_num_qps);
#line 1383
  *((__be32 *)__d___1) = tmp___5;
#line 1383
  goto ldv_31879;
  case 8UL: 
#line 1383
  tmp___6 = __fswab64((__u64 )param->log_num_qps);
#line 1383
  *((__be64 *)__d___1) = tmp___6;
#line 1383
  goto ldv_31879;
  default: 
#line 1383
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31879: 
#line 1384
  __d___2 = (void *)inbox + 64U;
#line 1384
  switch (8UL) {
  case 1UL: 
#line 1384
  *((u8 *)__d___2) = (u8 )param->eec_base;
#line 1384
  goto ldv_31886;
  case 2UL: 
#line 1384
  tmp___7 = __fswab16((int )((__u16 )param->eec_base));
#line 1384
  *((__be16 *)__d___2) = tmp___7;
#line 1384
  goto ldv_31886;
  case 4UL: 
#line 1384
  tmp___8 = __fswab32((__u32 )param->eec_base);
#line 1384
  *((__be32 *)__d___2) = tmp___8;
#line 1384
  goto ldv_31886;
  case 8UL: 
#line 1384
  tmp___9 = __fswab64(param->eec_base);
#line 1384
  *((__be64 *)__d___2) = tmp___9;
#line 1384
  goto ldv_31886;
  default: 
#line 1384
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31886: 
#line 1385
  __d___3 = (void *)inbox + 71U;
#line 1385
  switch (1UL) {
  case 1UL: 
#line 1385
  *((u8 *)__d___3) = param->log_num_eecs;
#line 1385
  goto ldv_31893;
  case 2UL: 
#line 1385
  tmp___10 = __fswab16((int )param->log_num_eecs);
#line 1385
  *((__be16 *)__d___3) = tmp___10;
#line 1385
  goto ldv_31893;
  case 4UL: 
#line 1385
  tmp___11 = __fswab32((__u32 )param->log_num_eecs);
#line 1385
  *((__be32 *)__d___3) = tmp___11;
#line 1385
  goto ldv_31893;
  case 8UL: 
#line 1385
  tmp___12 = __fswab64((__u64 )param->log_num_eecs);
#line 1385
  *((__be64 *)__d___3) = tmp___12;
#line 1385
  goto ldv_31893;
  default: 
#line 1385
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31893: 
#line 1386
  __d___4 = (void *)inbox + 72U;
#line 1386
  switch (8UL) {
  case 1UL: 
#line 1386
  *((u8 *)__d___4) = (u8 )param->srqc_base;
#line 1386
  goto ldv_31900;
  case 2UL: 
#line 1386
  tmp___13 = __fswab16((int )((__u16 )param->srqc_base));
#line 1386
  *((__be16 *)__d___4) = tmp___13;
#line 1386
  goto ldv_31900;
  case 4UL: 
#line 1386
  tmp___14 = __fswab32((__u32 )param->srqc_base);
#line 1386
  *((__be32 *)__d___4) = tmp___14;
#line 1386
  goto ldv_31900;
  case 8UL: 
#line 1386
  tmp___15 = __fswab64(param->srqc_base);
#line 1386
  *((__be64 *)__d___4) = tmp___15;
#line 1386
  goto ldv_31900;
  default: 
#line 1386
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31900: 
#line 1387
  __d___5 = (void *)inbox + 79U;
#line 1387
  switch (1UL) {
  case 1UL: 
#line 1387
  *((u8 *)__d___5) = param->log_num_srqs;
#line 1387
  goto ldv_31907;
  case 2UL: 
#line 1387
  tmp___16 = __fswab16((int )param->log_num_srqs);
#line 1387
  *((__be16 *)__d___5) = tmp___16;
#line 1387
  goto ldv_31907;
  case 4UL: 
#line 1387
  tmp___17 = __fswab32((__u32 )param->log_num_srqs);
#line 1387
  *((__be32 *)__d___5) = tmp___17;
#line 1387
  goto ldv_31907;
  case 8UL: 
#line 1387
  tmp___18 = __fswab64((__u64 )param->log_num_srqs);
#line 1387
  *((__be64 *)__d___5) = tmp___18;
#line 1387
  goto ldv_31907;
  default: 
#line 1387
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31907: 
#line 1388
  __d___6 = (void *)inbox + 80U;
#line 1388
  switch (8UL) {
  case 1UL: 
#line 1388
  *((u8 *)__d___6) = (u8 )param->cqc_base;
#line 1388
  goto ldv_31914;
  case 2UL: 
#line 1388
  tmp___19 = __fswab16((int )((__u16 )param->cqc_base));
#line 1388
  *((__be16 *)__d___6) = tmp___19;
#line 1388
  goto ldv_31914;
  case 4UL: 
#line 1388
  tmp___20 = __fswab32((__u32 )param->cqc_base);
#line 1388
  *((__be32 *)__d___6) = tmp___20;
#line 1388
  goto ldv_31914;
  case 8UL: 
#line 1388
  tmp___21 = __fswab64(param->cqc_base);
#line 1388
  *((__be64 *)__d___6) = tmp___21;
#line 1388
  goto ldv_31914;
  default: 
#line 1388
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31914: 
#line 1389
  __d___7 = (void *)inbox + 87U;
#line 1389
  switch (1UL) {
  case 1UL: 
#line 1389
  *((u8 *)__d___7) = param->log_num_cqs;
#line 1389
  goto ldv_31921;
  case 2UL: 
#line 1389
  tmp___22 = __fswab16((int )param->log_num_cqs);
#line 1389
  *((__be16 *)__d___7) = tmp___22;
#line 1389
  goto ldv_31921;
  case 4UL: 
#line 1389
  tmp___23 = __fswab32((__u32 )param->log_num_cqs);
#line 1389
  *((__be32 *)__d___7) = tmp___23;
#line 1389
  goto ldv_31921;
  case 8UL: 
#line 1389
  tmp___24 = __fswab64((__u64 )param->log_num_cqs);
#line 1389
  *((__be64 *)__d___7) = tmp___24;
#line 1389
  goto ldv_31921;
  default: 
#line 1389
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31921: 
#line 1390
  __d___8 = (void *)inbox + 96U;
#line 1390
  switch (8UL) {
  case 1UL: 
#line 1390
  *((u8 *)__d___8) = (u8 )param->eqpc_base;
#line 1390
  goto ldv_31928;
  case 2UL: 
#line 1390
  tmp___25 = __fswab16((int )((__u16 )param->eqpc_base));
#line 1390
  *((__be16 *)__d___8) = tmp___25;
#line 1390
  goto ldv_31928;
  case 4UL: 
#line 1390
  tmp___26 = __fswab32((__u32 )param->eqpc_base);
#line 1390
  *((__be32 *)__d___8) = tmp___26;
#line 1390
  goto ldv_31928;
  case 8UL: 
#line 1390
  tmp___27 = __fswab64(param->eqpc_base);
#line 1390
  *((__be64 *)__d___8) = tmp___27;
#line 1390
  goto ldv_31928;
  default: 
#line 1390
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31928: 
#line 1391
  __d___9 = (void *)inbox + 112U;
#line 1391
  switch (8UL) {
  case 1UL: 
#line 1391
  *((u8 *)__d___9) = (u8 )param->eeec_base;
#line 1391
  goto ldv_31935;
  case 2UL: 
#line 1391
  tmp___28 = __fswab16((int )((__u16 )param->eeec_base));
#line 1391
  *((__be16 *)__d___9) = tmp___28;
#line 1391
  goto ldv_31935;
  case 4UL: 
#line 1391
  tmp___29 = __fswab32((__u32 )param->eeec_base);
#line 1391
  *((__be32 *)__d___9) = tmp___29;
#line 1391
  goto ldv_31935;
  case 8UL: 
#line 1391
  tmp___30 = __fswab64(param->eeec_base);
#line 1391
  *((__be64 *)__d___9) = tmp___30;
#line 1391
  goto ldv_31935;
  default: 
#line 1391
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31935: 
#line 1392
  __d___10 = (void *)inbox + 128U;
#line 1392
  switch (8UL) {
  case 1UL: 
#line 1392
  *((u8 *)__d___10) = (u8 )param->eqc_base;
#line 1392
  goto ldv_31942;
  case 2UL: 
#line 1392
  tmp___31 = __fswab16((int )((__u16 )param->eqc_base));
#line 1392
  *((__be16 *)__d___10) = tmp___31;
#line 1392
  goto ldv_31942;
  case 4UL: 
#line 1392
  tmp___32 = __fswab32((__u32 )param->eqc_base);
#line 1392
  *((__be32 *)__d___10) = tmp___32;
#line 1392
  goto ldv_31942;
  case 8UL: 
#line 1392
  tmp___33 = __fswab64(param->eqc_base);
#line 1392
  *((__be64 *)__d___10) = tmp___33;
#line 1392
  goto ldv_31942;
  default: 
#line 1392
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31942: 
#line 1393
  __d___11 = (void *)inbox + 135U;
#line 1393
  switch (1UL) {
  case 1UL: 
#line 1393
  *((u8 *)__d___11) = param->log_num_eqs;
#line 1393
  goto ldv_31949;
  case 2UL: 
#line 1393
  tmp___34 = __fswab16((int )param->log_num_eqs);
#line 1393
  *((__be16 *)__d___11) = tmp___34;
#line 1393
  goto ldv_31949;
  case 4UL: 
#line 1393
  tmp___35 = __fswab32((__u32 )param->log_num_eqs);
#line 1393
  *((__be32 *)__d___11) = tmp___35;
#line 1393
  goto ldv_31949;
  case 8UL: 
#line 1393
  tmp___36 = __fswab64((__u64 )param->log_num_eqs);
#line 1393
  *((__be64 *)__d___11) = tmp___36;
#line 1393
  goto ldv_31949;
  default: 
#line 1393
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31949: 
#line 1394
  __d___12 = (void *)inbox + 144U;
#line 1394
  switch (8UL) {
  case 1UL: 
#line 1394
  *((u8 *)__d___12) = (u8 )param->rdb_base;
#line 1394
  goto ldv_31956;
  case 2UL: 
#line 1394
  tmp___37 = __fswab16((int )((__u16 )param->rdb_base));
#line 1394
  *((__be16 *)__d___12) = tmp___37;
#line 1394
  goto ldv_31956;
  case 4UL: 
#line 1394
  tmp___38 = __fswab32((__u32 )param->rdb_base);
#line 1394
  *((__be32 *)__d___12) = tmp___38;
#line 1394
  goto ldv_31956;
  case 8UL: 
#line 1394
  tmp___39 = __fswab64(param->rdb_base);
#line 1394
  *((__be64 *)__d___12) = tmp___39;
#line 1394
  goto ldv_31956;
  default: 
#line 1394
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31956: 
#line 1400
  __d___13 = (void *)inbox + 192U;
#line 1400
  switch (8UL) {
  case 1UL: 
#line 1400
  *((u8 *)__d___13) = (u8 )param->mc_base;
#line 1400
  goto ldv_31963;
  case 2UL: 
#line 1400
  tmp___40 = __fswab16((int )((__u16 )param->mc_base));
#line 1400
  *((__be16 *)__d___13) = tmp___40;
#line 1400
  goto ldv_31963;
  case 4UL: 
#line 1400
  tmp___41 = __fswab32((__u32 )param->mc_base);
#line 1400
  *((__be32 *)__d___13) = tmp___41;
#line 1400
  goto ldv_31963;
  case 8UL: 
#line 1400
  tmp___42 = __fswab64(param->mc_base);
#line 1400
  *((__be64 *)__d___13) = tmp___42;
#line 1400
  goto ldv_31963;
  default: 
#line 1400
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31963: 
#line 1401
  __d___14 = (void *)inbox + 210U;
#line 1401
  switch (2UL) {
  case 1UL: 
#line 1401
  *((u8 *)__d___14) = (u8 )param->log_mc_entry_sz;
#line 1401
  goto ldv_31970;
  case 2UL: 
#line 1401
  tmp___43 = __fswab16((int )param->log_mc_entry_sz);
#line 1401
  *((__be16 *)__d___14) = tmp___43;
#line 1401
  goto ldv_31970;
  case 4UL: 
#line 1401
  tmp___44 = __fswab32((__u32 )param->log_mc_entry_sz);
#line 1401
  *((__be32 *)__d___14) = tmp___44;
#line 1401
  goto ldv_31970;
  case 8UL: 
#line 1401
  tmp___45 = __fswab64((__u64 )param->log_mc_entry_sz);
#line 1401
  *((__be64 *)__d___14) = tmp___45;
#line 1401
  goto ldv_31970;
  default: 
#line 1401
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31970: 
#line 1402
  __d___15 = (void *)inbox + 214U;
#line 1402
  switch (2UL) {
  case 1UL: 
#line 1402
  *((u8 *)__d___15) = (u8 )param->mc_hash_sz;
#line 1402
  goto ldv_31977;
  case 2UL: 
#line 1402
  tmp___46 = __fswab16((int )param->mc_hash_sz);
#line 1402
  *((__be16 *)__d___15) = tmp___46;
#line 1402
  goto ldv_31977;
  case 4UL: 
#line 1402
  tmp___47 = __fswab32((__u32 )param->mc_hash_sz);
#line 1402
  *((__be32 *)__d___15) = tmp___47;
#line 1402
  goto ldv_31977;
  case 8UL: 
#line 1402
  tmp___48 = __fswab64((__u64 )param->mc_hash_sz);
#line 1402
  *((__be64 *)__d___15) = tmp___48;
#line 1402
  goto ldv_31977;
  default: 
#line 1402
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31977: 
#line 1403
  __d___16 = (void *)inbox + 219U;
#line 1403
  switch (1UL) {
  case 1UL: 
#line 1403
  *((u8 *)__d___16) = param->log_mc_table_sz;
#line 1403
  goto ldv_31984;
  case 2UL: 
#line 1403
  tmp___49 = __fswab16((int )param->log_mc_table_sz);
#line 1403
  *((__be16 *)__d___16) = tmp___49;
#line 1403
  goto ldv_31984;
  case 4UL: 
#line 1403
  tmp___50 = __fswab32((__u32 )param->log_mc_table_sz);
#line 1403
  *((__be32 *)__d___16) = tmp___50;
#line 1403
  goto ldv_31984;
  case 8UL: 
#line 1403
  tmp___51 = __fswab64((__u64 )param->log_mc_table_sz);
#line 1403
  *((__be64 *)__d___16) = tmp___51;
#line 1403
  goto ldv_31984;
  default: 
#line 1403
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31984: 
#line 1407
  __d___17 = (void *)inbox + 240U;
#line 1407
  switch (8UL) {
  case 1UL: 
#line 1407
  *((u8 *)__d___17) = (u8 )param->mpt_base;
#line 1407
  goto ldv_31991;
  case 2UL: 
#line 1407
  tmp___52 = __fswab16((int )((__u16 )param->mpt_base));
#line 1407
  *((__be16 *)__d___17) = tmp___52;
#line 1407
  goto ldv_31991;
  case 4UL: 
#line 1407
  tmp___53 = __fswab32((__u32 )param->mpt_base);
#line 1407
  *((__be32 *)__d___17) = tmp___53;
#line 1407
  goto ldv_31991;
  case 8UL: 
#line 1407
  tmp___54 = __fswab64(param->mpt_base);
#line 1407
  *((__be64 *)__d___17) = tmp___54;
#line 1407
  goto ldv_31991;
  default: 
#line 1407
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_31991: 
#line 1408
  tmp___58 = mthca_is_memfree(dev);
#line 1408
  if (tmp___58 == 0) {
#line 1409
    __d___18 = (void *)inbox + 249U;
#line 1409
    switch (1UL) {
    case 1UL: 
#line 1409
    *((u8 *)__d___18) = param->mtt_seg_sz;
#line 1409
    goto ldv_31998;
    case 2UL: 
#line 1409
    tmp___55 = __fswab16((int )param->mtt_seg_sz);
#line 1409
    *((__be16 *)__d___18) = tmp___55;
#line 1409
    goto ldv_31998;
    case 4UL: 
#line 1409
    tmp___56 = __fswab32((__u32 )param->mtt_seg_sz);
#line 1409
    *((__be32 *)__d___18) = tmp___56;
#line 1409
    goto ldv_31998;
    case 8UL: 
#line 1409
    tmp___57 = __fswab64((__u64 )param->mtt_seg_sz);
#line 1409
    *((__be64 *)__d___18) = tmp___57;
#line 1409
    goto ldv_31998;
    default: 
#line 1409
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_31998: ;
  } else {

  }
#line 1410
  __d___19 = (void *)inbox + 251U;
#line 1410
  switch (1UL) {
  case 1UL: 
#line 1410
  *((u8 *)__d___19) = param->log_mpt_sz;
#line 1410
  goto ldv_32005;
  case 2UL: 
#line 1410
  tmp___59 = __fswab16((int )param->log_mpt_sz);
#line 1410
  *((__be16 *)__d___19) = tmp___59;
#line 1410
  goto ldv_32005;
  case 4UL: 
#line 1410
  tmp___60 = __fswab32((__u32 )param->log_mpt_sz);
#line 1410
  *((__be32 *)__d___19) = tmp___60;
#line 1410
  goto ldv_32005;
  case 8UL: 
#line 1410
  tmp___61 = __fswab64((__u64 )param->log_mpt_sz);
#line 1410
  *((__be64 *)__d___19) = tmp___61;
#line 1410
  goto ldv_32005;
  default: 
#line 1410
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32005: 
#line 1411
  __d___20 = (void *)inbox + 256U;
#line 1411
  switch (8UL) {
  case 1UL: 
#line 1411
  *((u8 *)__d___20) = (u8 )param->mtt_base;
#line 1411
  goto ldv_32012;
  case 2UL: 
#line 1411
  tmp___62 = __fswab16((int )((__u16 )param->mtt_base));
#line 1411
  *((__be16 *)__d___20) = tmp___62;
#line 1411
  goto ldv_32012;
  case 4UL: 
#line 1411
  tmp___63 = __fswab32((__u32 )param->mtt_base);
#line 1411
  *((__be32 *)__d___20) = tmp___63;
#line 1411
  goto ldv_32012;
  case 8UL: 
#line 1411
  tmp___64 = __fswab64(param->mtt_base);
#line 1411
  *((__be64 *)__d___20) = tmp___64;
#line 1411
  goto ldv_32012;
  default: 
#line 1411
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32012: 
#line 1415
  uar_page_sz = 0U;
#line 1416
  __d___21 = (void *)inbox + 299U;
#line 1416
  switch (1UL) {
  case 1UL: 
#line 1416
  *((u8 *)__d___21) = uar_page_sz;
#line 1416
  goto ldv_32020;
  case 2UL: 
#line 1416
  tmp___65 = __fswab16((int )uar_page_sz);
#line 1416
  *((__be16 *)__d___21) = tmp___65;
#line 1416
  goto ldv_32020;
  case 4UL: 
#line 1416
  tmp___66 = __fswab32((__u32 )uar_page_sz);
#line 1416
  *((__be32 *)__d___21) = tmp___66;
#line 1416
  goto ldv_32020;
  case 8UL: 
#line 1416
  tmp___67 = __fswab64((__u64 )uar_page_sz);
#line 1416
  *((__be64 *)__d___21) = tmp___67;
#line 1416
  goto ldv_32020;
  default: 
#line 1416
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32020: 
#line 1419
  __d___22 = (void *)inbox + 304U;
#line 1419
  switch (8UL) {
  case 1UL: 
#line 1419
  *((u8 *)__d___22) = (u8 )param->uar_scratch_base;
#line 1419
  goto ldv_32027;
  case 2UL: 
#line 1419
  tmp___68 = __fswab16((int )((__u16 )param->uar_scratch_base));
#line 1419
  *((__be16 *)__d___22) = tmp___68;
#line 1419
  goto ldv_32027;
  case 4UL: 
#line 1419
  tmp___69 = __fswab32((__u32 )param->uar_scratch_base);
#line 1419
  *((__be32 *)__d___22) = tmp___69;
#line 1419
  goto ldv_32027;
  case 8UL: 
#line 1419
  tmp___70 = __fswab64(param->uar_scratch_base);
#line 1419
  *((__be64 *)__d___22) = tmp___70;
#line 1419
  goto ldv_32027;
  default: 
#line 1419
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32027: 
#line 1421
  tmp___80 = mthca_is_memfree(dev);
#line 1421
  if (tmp___80 != 0) {
#line 1422
    __d___23 = (void *)inbox + 297U;
#line 1422
    switch (1UL) {
    case 1UL: 
#line 1422
    *((u8 *)__d___23) = param->log_uarc_sz;
#line 1422
    goto ldv_32034;
    case 2UL: 
#line 1422
    tmp___71 = __fswab16((int )param->log_uarc_sz);
#line 1422
    *((__be16 *)__d___23) = tmp___71;
#line 1422
    goto ldv_32034;
    case 4UL: 
#line 1422
    tmp___72 = __fswab32((__u32 )param->log_uarc_sz);
#line 1422
    *((__be32 *)__d___23) = tmp___72;
#line 1422
    goto ldv_32034;
    case 8UL: 
#line 1422
    tmp___73 = __fswab64((__u64 )param->log_uarc_sz);
#line 1422
    *((__be64 *)__d___23) = tmp___73;
#line 1422
    goto ldv_32034;
    default: 
#line 1422
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_32034: 
#line 1423
    __d___24 = (void *)inbox + 298U;
#line 1423
    switch (1UL) {
    case 1UL: 
#line 1423
    *((u8 *)__d___24) = param->log_uar_sz;
#line 1423
    goto ldv_32041;
    case 2UL: 
#line 1423
    tmp___74 = __fswab16((int )param->log_uar_sz);
#line 1423
    *((__be16 *)__d___24) = tmp___74;
#line 1423
    goto ldv_32041;
    case 4UL: 
#line 1423
    tmp___75 = __fswab32((__u32 )param->log_uar_sz);
#line 1423
    *((__be32 *)__d___24) = tmp___75;
#line 1423
    goto ldv_32041;
    case 8UL: 
#line 1423
    tmp___76 = __fswab64((__u64 )param->log_uar_sz);
#line 1423
    *((__be64 *)__d___24) = tmp___76;
#line 1423
    goto ldv_32041;
    default: 
#line 1423
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_32041: 
#line 1424
    __d___25 = (void *)inbox + 312U;
#line 1424
    switch (8UL) {
    case 1UL: 
#line 1424
    *((u8 *)__d___25) = (u8 )param->uarc_base;
#line 1424
    goto ldv_32048;
    case 2UL: 
#line 1424
    tmp___77 = __fswab16((int )((__u16 )param->uarc_base));
#line 1424
    *((__be16 *)__d___25) = tmp___77;
#line 1424
    goto ldv_32048;
    case 4UL: 
#line 1424
    tmp___78 = __fswab32((__u32 )param->uarc_base);
#line 1424
    *((__be32 *)__d___25) = tmp___78;
#line 1424
    goto ldv_32048;
    case 8UL: 
#line 1424
    tmp___79 = __fswab64(param->uarc_base);
#line 1424
    *((__be64 *)__d___25) = tmp___79;
#line 1424
    goto ldv_32048;
    default: 
#line 1424
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_32048: ;
  } else {

  }
#line 1427
  err = mthca_cmd(dev, mailbox->dma, 0U, 0, 7, 15000UL);
#line 1430
  mthca_free_mailbox(dev, mailbox);
#line 1431
  return (err);
}
}
#line 1434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_INIT_IB(struct mthca_dev *dev , struct mthca_init_ib_param *param , int port ) 
{ 
  struct mthca_mailbox *mailbox ;
  u32 *inbox ;
  int err ;
  u32 flags ;
  long tmp ;
  bool tmp___0 ;
  void *__d ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  __u64 tmp___3 ;
  void *__d___0 ;
  __u16 tmp___4 ;
  __u32 tmp___5 ;
  __u64 tmp___6 ;
  void *__d___1 ;
  __u16 tmp___7 ;
  __u32 tmp___8 ;
  __u64 tmp___9 ;
  void *__d___2 ;
  __u16 tmp___10 ;
  __u32 tmp___11 ;
  __u64 tmp___12 ;
  void *__d___3 ;
  __u16 tmp___13 ;
  __u32 tmp___14 ;
  __u64 tmp___15 ;
  void *__d___4 ;
  __u16 tmp___16 ;
  __u32 tmp___17 ;
  __u64 tmp___18 ;

  {
#line 1457
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1458
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1458
  if ((int )tmp___0) {
#line 1459
    tmp = PTR_ERR((void const   *)mailbox);
#line 1459
    return ((int )tmp);
  } else {

  }
#line 1460
  inbox = (u32 *)mailbox->buf;
#line 1462
  memset((void *)inbox, 0, 56UL);
#line 1464
  flags = 0U;
#line 1465
  flags = (param->set_guid0 != 0 ? 65536U : 0U) | flags;
#line 1466
  flags = (param->set_node_guid != 0 ? 131072U : 0U) | flags;
#line 1467
  flags = (param->set_si_guid != 0 ? 262144U : 0U) | flags;
#line 1468
  flags = (u32 )(param->vl_cap << 4) | flags;
#line 1469
  flags = (u32 )(param->port_width << 8) | flags;
#line 1470
  flags = (u32 )(param->mtu_cap << 12) | flags;
#line 1471
  __d = (void *)inbox;
#line 1471
  switch (4UL) {
  case 1UL: 
#line 1471
  *((u8 *)__d) = (u8 )flags;
#line 1471
  goto ldv_32064;
  case 2UL: 
#line 1471
  tmp___1 = __fswab16((int )((__u16 )flags));
#line 1471
  *((__be16 *)__d) = tmp___1;
#line 1471
  goto ldv_32064;
  case 4UL: 
#line 1471
  tmp___2 = __fswab32(flags);
#line 1471
  *((__be32 *)__d) = tmp___2;
#line 1471
  goto ldv_32064;
  case 8UL: 
#line 1471
  tmp___3 = __fswab64((__u64 )flags);
#line 1471
  *((__be64 *)__d) = tmp___3;
#line 1471
  goto ldv_32064;
  default: 
#line 1471
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32064: 
#line 1473
  __d___0 = (void *)inbox + 6U;
#line 1473
  switch (2UL) {
  case 1UL: 
#line 1473
  *((u8 *)__d___0) = (u8 )param->gid_cap;
#line 1473
  goto ldv_32071;
  case 2UL: 
#line 1473
  tmp___4 = __fswab16((int )param->gid_cap);
#line 1473
  *((__be16 *)__d___0) = tmp___4;
#line 1473
  goto ldv_32071;
  case 4UL: 
#line 1473
  tmp___5 = __fswab32((__u32 )param->gid_cap);
#line 1473
  *((__be32 *)__d___0) = tmp___5;
#line 1473
  goto ldv_32071;
  case 8UL: 
#line 1473
  tmp___6 = __fswab64((__u64 )param->gid_cap);
#line 1473
  *((__be64 *)__d___0) = tmp___6;
#line 1473
  goto ldv_32071;
  default: 
#line 1473
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32071: 
#line 1474
  __d___1 = (void *)inbox + 10U;
#line 1474
  switch (2UL) {
  case 1UL: 
#line 1474
  *((u8 *)__d___1) = (u8 )param->pkey_cap;
#line 1474
  goto ldv_32078;
  case 2UL: 
#line 1474
  tmp___7 = __fswab16((int )param->pkey_cap);
#line 1474
  *((__be16 *)__d___1) = tmp___7;
#line 1474
  goto ldv_32078;
  case 4UL: 
#line 1474
  tmp___8 = __fswab32((__u32 )param->pkey_cap);
#line 1474
  *((__be32 *)__d___1) = tmp___8;
#line 1474
  goto ldv_32078;
  case 8UL: 
#line 1474
  tmp___9 = __fswab64((__u64 )param->pkey_cap);
#line 1474
  *((__be64 *)__d___1) = tmp___9;
#line 1474
  goto ldv_32078;
  default: 
#line 1474
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32078: 
#line 1475
  __d___2 = (void *)inbox + 16U;
#line 1475
  switch (8UL) {
  case 1UL: 
#line 1475
  *((u8 *)__d___2) = (u8 )param->guid0;
#line 1475
  goto ldv_32085;
  case 2UL: 
#line 1475
  tmp___10 = __fswab16((int )((__u16 )param->guid0));
#line 1475
  *((__be16 *)__d___2) = tmp___10;
#line 1475
  goto ldv_32085;
  case 4UL: 
#line 1475
  tmp___11 = __fswab32((__u32 )param->guid0);
#line 1475
  *((__be32 *)__d___2) = tmp___11;
#line 1475
  goto ldv_32085;
  case 8UL: 
#line 1475
  tmp___12 = __fswab64(param->guid0);
#line 1475
  *((__be64 *)__d___2) = tmp___12;
#line 1475
  goto ldv_32085;
  default: 
#line 1475
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32085: 
#line 1476
  __d___3 = (void *)inbox + 24U;
#line 1476
  switch (8UL) {
  case 1UL: 
#line 1476
  *((u8 *)__d___3) = (u8 )param->node_guid;
#line 1476
  goto ldv_32092;
  case 2UL: 
#line 1476
  tmp___13 = __fswab16((int )((__u16 )param->node_guid));
#line 1476
  *((__be16 *)__d___3) = tmp___13;
#line 1476
  goto ldv_32092;
  case 4UL: 
#line 1476
  tmp___14 = __fswab32((__u32 )param->node_guid);
#line 1476
  *((__be32 *)__d___3) = tmp___14;
#line 1476
  goto ldv_32092;
  case 8UL: 
#line 1476
  tmp___15 = __fswab64(param->node_guid);
#line 1476
  *((__be64 *)__d___3) = tmp___15;
#line 1476
  goto ldv_32092;
  default: 
#line 1476
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32092: 
#line 1477
  __d___4 = (void *)inbox + 32U;
#line 1477
  switch (8UL) {
  case 1UL: 
#line 1477
  *((u8 *)__d___4) = (u8 )param->si_guid;
#line 1477
  goto ldv_32099;
  case 2UL: 
#line 1477
  tmp___16 = __fswab16((int )((__u16 )param->si_guid));
#line 1477
  *((__be16 *)__d___4) = tmp___16;
#line 1477
  goto ldv_32099;
  case 4UL: 
#line 1477
  tmp___17 = __fswab32((__u32 )param->si_guid);
#line 1477
  *((__be32 *)__d___4) = tmp___17;
#line 1477
  goto ldv_32099;
  case 8UL: 
#line 1477
  tmp___18 = __fswab64(param->si_guid);
#line 1477
  *((__be64 *)__d___4) = tmp___18;
#line 1477
  goto ldv_32099;
  default: 
#line 1477
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32099: 
#line 1479
  err = mthca_cmd(dev, mailbox->dma, (u32 )port, 0, 9, 15000UL);
#line 1482
  mthca_free_mailbox(dev, mailbox);
#line 1483
  return (err);
}
}
#line 1486 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_CLOSE_IB(struct mthca_dev *dev , int port ) 
{ 
  int tmp ;

  {
#line 1488
  tmp = mthca_cmd(dev, 0ULL, (u32 )port, 0, 10, 15000UL);
#line 1488
  return (tmp);
}
}
#line 1491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_CLOSE_HCA(struct mthca_dev *dev , int panic___0 ) 
{ 
  int tmp ;

  {
#line 1493
  tmp = mthca_cmd(dev, 0ULL, 0U, (int )((u8 )panic___0), 8, 15000UL);
#line 1493
  return (tmp);
}
}
#line 1496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_SET_IB(struct mthca_dev *dev , struct mthca_set_ib_param *param , int port ) 
{ 
  struct mthca_mailbox *mailbox ;
  u32 *inbox ;
  int err ;
  u32 flags ;
  long tmp ;
  bool tmp___0 ;
  void *__d ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  __u64 tmp___3 ;
  void *__d___0 ;
  __u16 tmp___4 ;
  __u32 tmp___5 ;
  __u64 tmp___6 ;
  void *__d___1 ;
  __u16 tmp___7 ;
  __u32 tmp___8 ;
  __u64 tmp___9 ;

  {
#line 1502
  flags = 0U;
#line 1511
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1512
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1512
  if ((int )tmp___0) {
#line 1513
    tmp = PTR_ERR((void const   *)mailbox);
#line 1513
    return ((int )tmp);
  } else {

  }
#line 1514
  inbox = (u32 *)mailbox->buf;
#line 1516
  memset((void *)inbox, 0, 64UL);
#line 1518
  flags = (param->set_si_guid != 0 ? 262144U : 0U) | flags;
#line 1519
  flags = (param->reset_qkey_viol != 0 ? 1U : 0U) | flags;
#line 1520
  __d = (void *)inbox;
#line 1520
  switch (4UL) {
  case 1UL: 
#line 1520
  *((u8 *)__d) = (u8 )flags;
#line 1520
  goto ldv_32123;
  case 2UL: 
#line 1520
  tmp___1 = __fswab16((int )((__u16 )flags));
#line 1520
  *((__be16 *)__d) = tmp___1;
#line 1520
  goto ldv_32123;
  case 4UL: 
#line 1520
  tmp___2 = __fswab32(flags);
#line 1520
  *((__be32 *)__d) = tmp___2;
#line 1520
  goto ldv_32123;
  case 8UL: 
#line 1520
  tmp___3 = __fswab64((__u64 )flags);
#line 1520
  *((__be64 *)__d) = tmp___3;
#line 1520
  goto ldv_32123;
  default: 
#line 1520
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32123: 
#line 1522
  __d___0 = (void *)inbox + 4U;
#line 1522
  switch (4UL) {
  case 1UL: 
#line 1522
  *((u8 *)__d___0) = (u8 )param->cap_mask;
#line 1522
  goto ldv_32130;
  case 2UL: 
#line 1522
  tmp___4 = __fswab16((int )((__u16 )param->cap_mask));
#line 1522
  *((__be16 *)__d___0) = tmp___4;
#line 1522
  goto ldv_32130;
  case 4UL: 
#line 1522
  tmp___5 = __fswab32(param->cap_mask);
#line 1522
  *((__be32 *)__d___0) = tmp___5;
#line 1522
  goto ldv_32130;
  case 8UL: 
#line 1522
  tmp___6 = __fswab64((__u64 )param->cap_mask);
#line 1522
  *((__be64 *)__d___0) = tmp___6;
#line 1522
  goto ldv_32130;
  default: 
#line 1522
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32130: 
#line 1523
  __d___1 = (void *)inbox + 8U;
#line 1523
  switch (8UL) {
  case 1UL: 
#line 1523
  *((u8 *)__d___1) = (u8 )param->si_guid;
#line 1523
  goto ldv_32137;
  case 2UL: 
#line 1523
  tmp___7 = __fswab16((int )((__u16 )param->si_guid));
#line 1523
  *((__be16 *)__d___1) = tmp___7;
#line 1523
  goto ldv_32137;
  case 4UL: 
#line 1523
  tmp___8 = __fswab32((__u32 )param->si_guid);
#line 1523
  *((__be32 *)__d___1) = tmp___8;
#line 1523
  goto ldv_32137;
  case 8UL: 
#line 1523
  tmp___9 = __fswab64(param->si_guid);
#line 1523
  *((__be64 *)__d___1) = tmp___9;
#line 1523
  goto ldv_32137;
  default: 
#line 1523
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32137: 
#line 1525
  err = mthca_cmd(dev, mailbox->dma, (u32 )port, 0, 12, 15000UL);
#line 1528
  mthca_free_mailbox(dev, mailbox);
#line 1529
  return (err);
}
}
#line 1532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_MAP_ICM(struct mthca_dev *dev , struct mthca_icm *icm , u64 virt ) 
{ 
  int tmp ;

  {
#line 1534
  tmp = mthca_map_cmd(dev, 4090, icm, virt);
#line 1534
  return (tmp);
}
}
#line 1537 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_MAP_ICM_page(struct mthca_dev *dev , u64 dma_addr , u64 virt ) 
{ 
  struct mthca_mailbox *mailbox ;
  __be64 *inbox ;
  int err ;
  long tmp ;
  bool tmp___0 ;
  __u64 tmp___1 ;
  __u64 tmp___2 ;

  {
#line 1543
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1544
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1544
  if ((int )tmp___0) {
#line 1545
    tmp = PTR_ERR((void const   *)mailbox);
#line 1545
    return ((int )tmp);
  } else {

  }
#line 1546
  inbox = (__be64 *)mailbox->buf;
#line 1548
  tmp___1 = __fswab64(virt);
#line 1548
  *inbox = tmp___1;
#line 1549
  tmp___2 = __fswab64(dma_addr);
#line 1549
  *(inbox + 1UL) = tmp___2;
#line 1551
  err = mthca_cmd(dev, mailbox->dma, 1U, 0, 4090, 15000UL);
#line 1554
  mthca_free_mailbox(dev, mailbox);
#line 1556
  if (err == 0) {
#line 1557
    if (mthca_debug_level != 0) {
#line 1557
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Mapped page at %llx to %llx for ICM.\n",
                 dma_addr, virt);
    } else {

    }
  } else {

  }
#line 1560
  return (err);
}
}
#line 1563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_UNMAP_ICM(struct mthca_dev *dev , u64 virt , u32 page_count___0 ) 
{ 
  int tmp ;

  {
#line 1565
  if (mthca_debug_level != 0) {
#line 1565
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Unmapping %d pages at %llx from ICM.\n",
               page_count___0, virt);
  } else {

  }
#line 1568
  tmp = mthca_cmd(dev, virt, page_count___0, 0, 4089, 15000UL);
#line 1568
  return (tmp);
}
}
#line 1572 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_MAP_ICM_AUX(struct mthca_dev *dev , struct mthca_icm *icm ) 
{ 
  int tmp ;

  {
#line 1574
  tmp = mthca_map_cmd(dev, 4092, icm, 0xffffffffffffffffULL);
#line 1574
  return (tmp);
}
}
#line 1577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_UNMAP_ICM_AUX(struct mthca_dev *dev ) 
{ 
  int tmp ;

  {
#line 1579
  tmp = mthca_cmd(dev, 0ULL, 0U, 0, 4091, 15000UL);
#line 1579
  return (tmp);
}
}
#line 1582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_SET_ICM_SIZE(struct mthca_dev *dev , u64 icm_size , u64 *aux_pages ) 
{ 
  int ret ;
  int tmp ;

  {
#line 1584
  tmp = mthca_cmd_imm(dev, icm_size, aux_pages, 0U, 0, 4093, 15000UL);
#line 1584
  ret = tmp;
#line 1587
  if (ret != 0) {
#line 1588
    return (ret);
  } else {

  }
#line 1594
  *aux_pages = *aux_pages;
#line 1597
  return (0);
}
}
#line 1600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_SW2HW_MPT(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int mpt_index ) 
{ 
  int tmp ;

  {
#line 1603
  tmp = mthca_cmd(dev, mailbox->dma, (u32 )mpt_index, 0, 13, 15000UL);
#line 1603
  return (tmp);
}
}
#line 1607 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_HW2SW_MPT(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int mpt_index ) 
{ 
  int tmp ;

  {
#line 1610
  tmp = mthca_cmd_box(dev, 0ULL, (unsigned long )mailbox != (unsigned long )((struct mthca_mailbox *)0) ? mailbox->dma : 0ULL,
                      (u32 )mpt_index, (unsigned long )mailbox == (unsigned long )((struct mthca_mailbox *)0),
                      15, 15000UL);
#line 1610
  return (tmp);
}
}
#line 1615 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_WRITE_MTT(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int num_mtt ) 
{ 
  int tmp ;

  {
#line 1618
  tmp = mthca_cmd(dev, mailbox->dma, (u32 )num_mtt, 0, 17, 15000UL);
#line 1618
  return (tmp);
}
}
#line 1622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_SYNC_TPT(struct mthca_dev *dev ) 
{ 
  int tmp ;

  {
#line 1624
  tmp = mthca_cmd(dev, 0ULL, 0U, 0, 47, 15000UL);
#line 1624
  return (tmp);
}
}
#line 1627 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_MAP_EQ(struct mthca_dev *dev , u64 event_mask , int unmap , int eq_num ) 
{ 
  int tmp ;

  {
#line 1630
  if (mthca_debug_level != 0) {
#line 1630
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "%s mask %016llx for eqn %d\n",
               unmap != 0 ? (char *)"Clearing" : (char *)"Setting", event_mask, eq_num);
  } else {

  }
#line 1633
  tmp = mthca_cmd(dev, event_mask, (u32 )((unmap << 31) | eq_num), 0, 18, 15000UL);
#line 1633
  return (tmp);
}
}
#line 1637 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_SW2HW_EQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int eq_num ) 
{ 
  int tmp ;

  {
#line 1640
  tmp = mthca_cmd(dev, mailbox->dma, (u32 )eq_num, 0, 19, 15000UL);
#line 1640
  return (tmp);
}
}
#line 1644 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_HW2SW_EQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int eq_num ) 
{ 
  int tmp ;

  {
#line 1647
  tmp = mthca_cmd_box(dev, 0ULL, mailbox->dma, (u32 )eq_num, 0, 20, 15000UL);
#line 1647
  return (tmp);
}
}
#line 1652 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_SW2HW_CQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int cq_num ) 
{ 
  int tmp ;

  {
#line 1655
  tmp = mthca_cmd(dev, mailbox->dma, (u32 )cq_num, 0, 22, 15000UL);
#line 1655
  return (tmp);
}
}
#line 1659 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_HW2SW_CQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int cq_num ) 
{ 
  int tmp ;

  {
#line 1662
  tmp = mthca_cmd_box(dev, 0ULL, mailbox->dma, (u32 )cq_num, 0, 23, 15000UL);
#line 1662
  return (tmp);
}
}
#line 1667 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_RESIZE_CQ(struct mthca_dev *dev , int cq_num , u32 lkey , u8 log_size ) 
{ 
  struct mthca_mailbox *mailbox ;
  __be32 *inbox ;
  int err ;
  long tmp ;
  bool tmp___0 ;
  void *__d ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  __u64 tmp___3 ;
  void *__d___0 ;
  __u16 tmp___4 ;
  __u32 tmp___5 ;
  __u64 tmp___6 ;

  {
#line 1677
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1678
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1678
  if ((int )tmp___0) {
#line 1679
    tmp = PTR_ERR((void const   *)mailbox);
#line 1679
    return ((int )tmp);
  } else {

  }
#line 1680
  inbox = (__be32 *)mailbox->buf;
#line 1682
  memset((void *)inbox, 0, 64UL);
#line 1687
  __d = (void *)inbox + 12U;
#line 1687
  switch (1UL) {
  case 1UL: 
#line 1687
  *((u8 *)__d) = log_size;
#line 1687
  goto ldv_32228;
  case 2UL: 
#line 1687
  tmp___1 = __fswab16((int )log_size);
#line 1687
  *((__be16 *)__d) = tmp___1;
#line 1687
  goto ldv_32228;
  case 4UL: 
#line 1687
  tmp___2 = __fswab32((__u32 )log_size);
#line 1687
  *((__be32 *)__d) = tmp___2;
#line 1687
  goto ldv_32228;
  case 8UL: 
#line 1687
  tmp___3 = __fswab64((__u64 )log_size);
#line 1687
  *((__be64 *)__d) = tmp___3;
#line 1687
  goto ldv_32228;
  default: 
#line 1687
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32228: 
#line 1688
  __d___0 = (void *)inbox + 28U;
#line 1688
  switch (4UL) {
  case 1UL: 
#line 1688
  *((u8 *)__d___0) = (u8 )lkey;
#line 1688
  goto ldv_32235;
  case 2UL: 
#line 1688
  tmp___4 = __fswab16((int )((__u16 )lkey));
#line 1688
  *((__be16 *)__d___0) = tmp___4;
#line 1688
  goto ldv_32235;
  case 4UL: 
#line 1688
  tmp___5 = __fswab32(lkey);
#line 1688
  *((__be32 *)__d___0) = tmp___5;
#line 1688
  goto ldv_32235;
  case 8UL: 
#line 1688
  tmp___6 = __fswab64((__u64 )lkey);
#line 1688
  *((__be64 *)__d___0) = tmp___6;
#line 1688
  goto ldv_32235;
  default: 
#line 1688
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_32235: 
#line 1690
  err = mthca_cmd(dev, mailbox->dma, (u32 )cq_num, 1, 44, 15000UL);
#line 1693
  mthca_free_mailbox(dev, mailbox);
#line 1694
  return (err);
}
}
#line 1697 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_SW2HW_SRQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int srq_num ) 
{ 
  int tmp ;

  {
#line 1700
  tmp = mthca_cmd(dev, mailbox->dma, (u32 )srq_num, 0, 53, 15000UL);
#line 1700
  return (tmp);
}
}
#line 1704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_HW2SW_SRQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int srq_num ) 
{ 
  int tmp ;

  {
#line 1707
  tmp = mthca_cmd_box(dev, 0ULL, mailbox->dma, (u32 )srq_num, 0, 54, 15000UL);
#line 1707
  return (tmp);
}
}
#line 1712 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_QUERY_SRQ(struct mthca_dev *dev , u32 num , struct mthca_mailbox *mailbox ) 
{ 
  int tmp ;

  {
#line 1715
  tmp = mthca_cmd_box(dev, 0ULL, mailbox->dma, num, 0, 55, 15000UL);
#line 1715
  return (tmp);
}
}
#line 1719 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_ARM_SRQ(struct mthca_dev *dev , int srq_num , int limit ) 
{ 
  int tmp ;

  {
#line 1721
  tmp = mthca_cmd(dev, (u64 )limit, (u32 )srq_num, 0, 64, 15000UL);
#line 1721
  return (tmp);
}
}
#line 1725 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_MODIFY_QP(struct mthca_dev *dev , enum ib_qp_state cur , enum ib_qp_state next ,
                    u32 num , int is_ee , struct mthca_mailbox *mailbox , u32 optmask ) 
{ 
  u16 op[7U][7U] ;
  u8 op_mod ;
  int my_mailbox ;
  int err ;
  bool tmp ;
  int tmp___0 ;
  int i ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  int i___0 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;

  {
#line 1729
  op[0][0] = 33U;
#line 1729
  op[0][1] = 25U;
#line 1729
  op[0][2] = (unsigned short)0;
#line 1729
  op[0][3] = (unsigned short)0;
#line 1729
  op[0][4] = (unsigned short)0;
#line 1729
  op[0][5] = (unsigned short)0;
#line 1729
  op[0][6] = 30U;
#line 1729
  op[1][0] = 33U;
#line 1729
  op[1][1] = 45U;
#line 1729
  op[1][2] = 26U;
#line 1729
  op[1][3] = (unsigned short)0;
#line 1729
  op[1][4] = (unsigned short)0;
#line 1729
  op[1][5] = (unsigned short)0;
#line 1729
  op[1][6] = 30U;
#line 1729
  op[2][0] = 33U;
#line 1729
  op[2][1] = (unsigned short)0;
#line 1729
  op[2][2] = (unsigned short)0;
#line 1729
  op[2][3] = 27U;
#line 1729
  op[2][4] = (unsigned short)0;
#line 1729
  op[2][5] = (unsigned short)0;
#line 1729
  op[2][6] = 30U;
#line 1729
  op[3][0] = 33U;
#line 1729
  op[3][1] = (unsigned short)0;
#line 1729
  op[3][2] = (unsigned short)0;
#line 1729
  op[3][3] = 28U;
#line 1729
  op[3][4] = 31U;
#line 1729
  op[3][5] = (unsigned short)0;
#line 1729
  op[3][6] = 30U;
#line 1729
  op[4][0] = 33U;
#line 1729
  op[4][1] = (unsigned short)0;
#line 1729
  op[4][2] = (unsigned short)0;
#line 1729
  op[4][3] = 32U;
#line 1729
  op[4][4] = 56U;
#line 1729
  op[4][5] = (unsigned short)0;
#line 1729
  op[4][6] = 30U;
#line 1729
  op[5][0] = 33U;
#line 1729
  op[5][1] = (unsigned short)0;
#line 1729
  op[5][2] = (unsigned short)0;
#line 1729
  op[5][3] = 29U;
#line 1729
  op[5][4] = (unsigned short)0;
#line 1729
  op[5][5] = (unsigned short)0;
#line 1729
  op[5][6] = 30U;
#line 1729
  op[6][0] = 33U;
#line 1729
  op[6][1] = (unsigned short)0;
#line 1729
  op[6][2] = (unsigned short)0;
#line 1729
  op[6][3] = (unsigned short)0;
#line 1729
  op[6][4] = (unsigned short)0;
#line 1729
  op[6][5] = (unsigned short)0;
#line 1729
  op[6][6] = 30U;
#line 1769
  op_mod = 0U;
#line 1770
  my_mailbox = 0;
#line 1773
  if ((unsigned int )op[(unsigned int )cur][(unsigned int )next] == 33U) {
#line 1774
    op_mod = 3U;
#line 1777
    if ((unsigned long )mailbox == (unsigned long )((struct mthca_mailbox *)0)) {
#line 1778
      mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1779
      tmp = IS_ERR((void const   *)mailbox);
#line 1779
      if (tmp) {
#line 1779
        tmp___0 = 0;
      } else {
#line 1779
        tmp___0 = 1;
      }
#line 1779
      if (tmp___0) {
#line 1780
        my_mailbox = 1;
#line 1781
        op_mod = 2U;
      } else {
#line 1783
        mailbox = (struct mthca_mailbox *)0;
      }
    } else {

    }
#line 1786
    err = mthca_cmd_box(dev, 0ULL, (unsigned long )mailbox != (unsigned long )((struct mthca_mailbox *)0) ? mailbox->dma : 0ULL,
                        (is_ee != 0 ? 16777216U : 0U) | num, (int )op_mod, (int )op[(unsigned int )cur][(unsigned int )next],
                        15000UL);
#line 1790
    if (0) {
#line 1792
      if (mthca_debug_level != 0) {
#line 1792
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Dumping QP context:\n");
      } else {

      }
#line 1793
      tmp___1 = __be32_to_cpup((__be32 const   *)mailbox->buf);
#line 1793
      printk(" %08x\n", tmp___1);
#line 1794
      i = 0;
#line 1794
      goto ldv_32275;
      ldv_32274: ;
#line 1795
      if (((unsigned int )i & 7U) == 0U) {
#line 1796
        printk("[%02x] ", i * 4);
      } else {

      }
#line 1797
      tmp___2 = __fswab32(*((__be32 *)mailbox->buf + ((unsigned long )i + 2UL)));
#line 1797
      printk(" %08x", tmp___2);
#line 1799
      if (((unsigned int )(i + 1) & 7U) == 0U) {
#line 1800
        printk("\n");
      } else {

      }
#line 1794
      i = i + 1;
      ldv_32275: ;
#line 1794
      if (i <= 63) {
#line 1796
        goto ldv_32274;
      } else {

      }

    } else {

    }
#line 1804
    if (my_mailbox != 0) {
#line 1805
      mthca_free_mailbox(dev, mailbox);
    } else {

    }
  } else {
#line 1807
    if (0) {
#line 1809
      if (mthca_debug_level != 0) {
#line 1809
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Dumping QP context:\n");
      } else {

      }
#line 1810
      tmp___3 = __be32_to_cpup((__be32 const   *)mailbox->buf);
#line 1810
      printk("  opt param mask: %08x\n", tmp___3);
#line 1811
      i___0 = 0;
#line 1811
      goto ldv_32279;
      ldv_32278: ;
#line 1812
      if (((unsigned int )i___0 & 7U) == 0U) {
#line 1813
        printk("  [%02x] ", i___0 * 4);
      } else {

      }
#line 1814
      tmp___4 = __fswab32(*((__be32 *)mailbox->buf + ((unsigned long )i___0 + 2UL)));
#line 1814
      printk(" %08x", tmp___4);
#line 1816
      if (((unsigned int )(i___0 + 1) & 7U) == 0U) {
#line 1817
        printk("\n");
      } else {

      }
#line 1811
      i___0 = i___0 + 1;
      ldv_32279: ;
#line 1811
      if (i___0 <= 63) {
#line 1813
        goto ldv_32278;
      } else {

      }

    } else {

    }
#line 1821
    err = mthca_cmd(dev, mailbox->dma, ((is_ee != 0 ? 16777216U : 0U) | optmask) | num,
                    (int )op_mod, (int )op[(unsigned int )cur][(unsigned int )next],
                    15000UL);
  }
#line 1825
  return (err);
}
}
#line 1828 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_QUERY_QP(struct mthca_dev *dev , u32 num , int is_ee , struct mthca_mailbox *mailbox ) 
{ 
  int tmp ;

  {
#line 1831
  tmp = mthca_cmd_box(dev, 0ULL, mailbox->dma, (is_ee != 0 ? 16777216U : 0U) | num,
                      0, 34, 15000UL);
#line 1831
  return (tmp);
}
}
#line 1835 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_CONF_SPECIAL_QP(struct mthca_dev *dev , int type , u32 qpn ) 
{ 
  u8 op_mod ;
  int tmp ;

  {
#line 1839
  switch (type) {
  case 0: 
#line 1841
  op_mod = 0U;
#line 1842
  goto ldv_32294;
  case 1: 
#line 1844
  op_mod = 1U;
#line 1845
  goto ldv_32294;
  case 5: 
#line 1847
  op_mod = 2U;
#line 1848
  goto ldv_32294;
  case 6: 
#line 1850
  op_mod = 3U;
#line 1851
  goto ldv_32294;
  default: ;
#line 1853
  return (-22);
  }
  ldv_32294: 
#line 1856
  tmp = mthca_cmd(dev, 0ULL, qpn, (int )op_mod, 35, 15000UL);
#line 1856
  return (tmp);
}
}
#line 1860 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_MAD_IFC(struct mthca_dev *dev , int ignore_mkey , int ignore_bkey , int port ,
                  struct ib_wc  const  *in_wc , struct ib_grh  const  *in_grh , void const   *in_mad ,
                  void *response_mad ) 
{ 
  struct mthca_mailbox *inmailbox ;
  struct mthca_mailbox *outmailbox ;
  void *inbox ;
  int err ;
  u32 in_modifier ;
  u8 op_modifier ;
  long tmp ;
  bool tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  u8 val ;
  void *__d ;
  __u16 tmp___3 ;
  __u32 tmp___4 ;
  __u64 tmp___5 ;
  void *__d___0 ;
  __u16 tmp___6 ;
  __u32 tmp___7 ;
  __u64 tmp___8 ;
  void *__d___1 ;
  __u16 tmp___9 ;
  __u32 tmp___10 ;
  __u64 tmp___11 ;
  void *__d___2 ;
  __u16 tmp___12 ;
  __u32 tmp___13 ;
  __u64 tmp___14 ;
  void *__d___3 ;
  __u16 tmp___15 ;
  __u32 tmp___16 ;
  __u64 tmp___17 ;
  void *__d___4 ;
  __u16 tmp___18 ;
  __u32 tmp___19 ;
  __u64 tmp___20 ;

  {
#line 1867
  in_modifier = (u32 )port;
#line 1868
  op_modifier = 0U;
#line 1879
  inmailbox = mthca_alloc_mailbox(dev, 208U);
#line 1880
  tmp___0 = IS_ERR((void const   *)inmailbox);
#line 1880
  if ((int )tmp___0) {
#line 1881
    tmp = PTR_ERR((void const   *)inmailbox);
#line 1881
    return ((int )tmp);
  } else {

  }
#line 1882
  inbox = inmailbox->buf;
#line 1884
  outmailbox = mthca_alloc_mailbox(dev, 208U);
#line 1885
  tmp___2 = IS_ERR((void const   *)outmailbox);
#line 1885
  if ((int )tmp___2) {
#line 1886
    mthca_free_mailbox(dev, inmailbox);
#line 1887
    tmp___1 = PTR_ERR((void const   *)outmailbox);
#line 1887
    return ((int )tmp___1);
  } else {

  }
#line 1890
  memcpy(inbox, in_mad, 256UL);
#line 1896
  if (ignore_mkey != 0 || (unsigned long )in_wc == (unsigned long )((struct ib_wc  const  *)0)) {
#line 1897
    op_modifier = (u8 )((unsigned int )op_modifier | 1U);
  } else {

  }
#line 1898
  if (ignore_bkey != 0 || (unsigned long )in_wc == (unsigned long )((struct ib_wc  const  *)0)) {
#line 1899
    op_modifier = (u8 )((unsigned int )op_modifier | 2U);
  } else {

  }
#line 1901
  if ((unsigned long )in_wc != (unsigned long )((struct ib_wc  const  *)0)) {
#line 1904
    memset(inbox + 256UL, 0, 256UL);
#line 1906
    __d = inbox + 256U;
#line 1906
    switch (4UL) {
    case 1UL: 
#line 1906
    *((u8 *)__d) = (u8 )(in_wc->qp)->qp_num;
#line 1906
    goto ldv_32318;
    case 2UL: 
#line 1906
    tmp___3 = __fswab16((int )((__u16 )(in_wc->qp)->qp_num));
#line 1906
    *((__be16 *)__d) = tmp___3;
#line 1906
    goto ldv_32318;
    case 4UL: 
#line 1906
    tmp___4 = __fswab32((in_wc->qp)->qp_num);
#line 1906
    *((__be32 *)__d) = tmp___4;
#line 1906
    goto ldv_32318;
    case 8UL: 
#line 1906
    tmp___5 = __fswab64((__u64 )(in_wc->qp)->qp_num);
#line 1906
    *((__be64 *)__d) = tmp___5;
#line 1906
    goto ldv_32318;
    default: 
#line 1906
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_32318: 
#line 1907
    __d___0 = inbox + 264U;
#line 1907
    switch (4UL) {
    case 1UL: 
#line 1907
    *((u8 *)__d___0) = (u8 )in_wc->src_qp;
#line 1907
    goto ldv_32325;
    case 2UL: 
#line 1907
    tmp___6 = __fswab16((int )((__u16 )in_wc->src_qp));
#line 1907
    *((__be16 *)__d___0) = tmp___6;
#line 1907
    goto ldv_32325;
    case 4UL: 
#line 1907
    tmp___7 = __fswab32(in_wc->src_qp);
#line 1907
    *((__be32 *)__d___0) = tmp___7;
#line 1907
    goto ldv_32325;
    case 8UL: 
#line 1907
    tmp___8 = __fswab64((__u64 )in_wc->src_qp);
#line 1907
    *((__be64 *)__d___0) = tmp___8;
#line 1907
    goto ldv_32325;
    default: 
#line 1907
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_32325: 
#line 1909
    val = (int )((u8 )in_wc->sl) << 4U;
#line 1910
    __d___1 = inbox + 268U;
#line 1910
    switch (1UL) {
    case 1UL: 
#line 1910
    *((u8 *)__d___1) = val;
#line 1910
    goto ldv_32332;
    case 2UL: 
#line 1910
    tmp___9 = __fswab16((int )val);
#line 1910
    *((__be16 *)__d___1) = tmp___9;
#line 1910
    goto ldv_32332;
    case 4UL: 
#line 1910
    tmp___10 = __fswab32((__u32 )val);
#line 1910
    *((__be32 *)__d___1) = tmp___10;
#line 1910
    goto ldv_32332;
    case 8UL: 
#line 1910
    tmp___11 = __fswab64((__u64 )val);
#line 1910
    *((__be64 *)__d___1) = tmp___11;
#line 1910
    goto ldv_32332;
    default: 
#line 1910
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_32332: 
#line 1912
    val = (u8 )((int )((signed char )in_wc->dlid_path_bits) | ((int )in_wc->wc_flags & 1 ? -128 : 0));
#line 1914
    __d___2 = inbox + 269U;
#line 1914
    switch (1UL) {
    case 1UL: 
#line 1914
    *((u8 *)__d___2) = val;
#line 1914
    goto ldv_32339;
    case 2UL: 
#line 1914
    tmp___12 = __fswab16((int )val);
#line 1914
    *((__be16 *)__d___2) = tmp___12;
#line 1914
    goto ldv_32339;
    case 4UL: 
#line 1914
    tmp___13 = __fswab32((__u32 )val);
#line 1914
    *((__be32 *)__d___2) = tmp___13;
#line 1914
    goto ldv_32339;
    case 8UL: 
#line 1914
    tmp___14 = __fswab64((__u64 )val);
#line 1914
    *((__be64 *)__d___2) = tmp___14;
#line 1914
    goto ldv_32339;
    default: 
#line 1914
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_32339: 
#line 1916
    __d___3 = inbox + 270U;
#line 1916
    switch (2UL) {
    case 1UL: 
#line 1916
    *((u8 *)__d___3) = (u8 )in_wc->slid;
#line 1916
    goto ldv_32346;
    case 2UL: 
#line 1916
    tmp___15 = __fswab16((int )in_wc->slid);
#line 1916
    *((__be16 *)__d___3) = tmp___15;
#line 1916
    goto ldv_32346;
    case 4UL: 
#line 1916
    tmp___16 = __fswab32((__u32 )in_wc->slid);
#line 1916
    *((__be32 *)__d___3) = tmp___16;
#line 1916
    goto ldv_32346;
    case 8UL: 
#line 1916
    tmp___17 = __fswab64((__u64 )in_wc->slid);
#line 1916
    *((__be64 *)__d___3) = tmp___17;
#line 1916
    goto ldv_32346;
    default: 
#line 1916
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_32346: 
#line 1917
    __d___4 = inbox + 274U;
#line 1917
    switch (2UL) {
    case 1UL: 
#line 1917
    *((u8 *)__d___4) = (u8 )in_wc->pkey_index;
#line 1917
    goto ldv_32353;
    case 2UL: 
#line 1917
    tmp___18 = __fswab16((int )in_wc->pkey_index);
#line 1917
    *((__be16 *)__d___4) = tmp___18;
#line 1917
    goto ldv_32353;
    case 4UL: 
#line 1917
    tmp___19 = __fswab32((__u32 )in_wc->pkey_index);
#line 1917
    *((__be32 *)__d___4) = tmp___19;
#line 1917
    goto ldv_32353;
    case 8UL: 
#line 1917
    tmp___20 = __fswab64((__u64 )in_wc->pkey_index);
#line 1917
    *((__be64 *)__d___4) = tmp___20;
#line 1917
    goto ldv_32353;
    default: 
#line 1917
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_32353: ;
#line 1919
    if ((unsigned long )in_grh != (unsigned long )((struct ib_grh  const  *)0)) {
#line 1920
      memcpy(inbox + 320UL, (void const   *)in_grh, 40UL);
    } else {

    }
#line 1922
    op_modifier = (u8 )((unsigned int )op_modifier | 4U);
#line 1924
    in_modifier = (u32 )((int )in_wc->slid << 16) | in_modifier;
  } else {

  }
#line 1927
  err = mthca_cmd_box(dev, inmailbox->dma, outmailbox->dma, in_modifier, (int )op_modifier,
                      36, 15000UL);
#line 1931
  if (err == 0) {
#line 1932
    memcpy(response_mad, (void const   *)outmailbox->buf, 256UL);
  } else {

  }
#line 1934
  mthca_free_mailbox(dev, inmailbox);
#line 1935
  mthca_free_mailbox(dev, outmailbox);
#line 1936
  return (err);
}
}
#line 1939 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_READ_MGM(struct mthca_dev *dev , int index , struct mthca_mailbox *mailbox ) 
{ 
  int tmp ;

  {
#line 1942
  tmp = mthca_cmd_box(dev, 0ULL, mailbox->dma, (u32 )index, 0, 37, 15000UL);
#line 1942
  return (tmp);
}
}
#line 1946 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_WRITE_MGM(struct mthca_dev *dev , int index , struct mthca_mailbox *mailbox ) 
{ 
  int tmp ;

  {
#line 1949
  tmp = mthca_cmd(dev, mailbox->dma, (u32 )index, 0, 38, 15000UL);
#line 1949
  return (tmp);
}
}
#line 1953 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_MGID_HASH(struct mthca_dev *dev , struct mthca_mailbox *mailbox , u16 *hash ) 
{ 
  u64 imm ;
  int err ;

  {
#line 1959
  err = mthca_cmd_imm(dev, mailbox->dma, & imm, 0U, 0, 39, 15000UL);
#line 1962
  *hash = (u16 )imm;
#line 1963
  return (err);
}
}
#line 1966 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.c"
int mthca_NOP(struct mthca_dev *dev ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 1968
  tmp = msecs_to_jiffies(100U);
#line 1968
  tmp___0 = mthca_cmd(dev, 0ULL, 31U, 0, 49, tmp);
#line 1968
  return (tmp___0);
}
}
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.o.c.prepared"
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
#line 58
  tmp = ldv_err_ptr(error);
#line 58
  return (tmp);
}
}
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.o.c.prepared"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 64
  tmp = ldv_ptr_err(ptr);
#line 64
  return (tmp);
}
}
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.o.c.prepared"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 70
  tmp = ldv_is_err(ptr);
#line 70
  return (tmp);
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.o.c.prepared"
bool ldv_queue_work_on_23(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.o.c.prepared"
bool ldv_queue_delayed_work_on_24(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.o.c.prepared"
bool ldv_queue_work_on_25(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.o.c.prepared"
void ldv_flush_workqueue_26(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cmd.o.c.prepared"
bool ldv_queue_delayed_work_on_27(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_37(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_39(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_38(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_41(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_40(struct workqueue_struct *ldv_func_arg1 ) ;
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_profile.c"
s64 mthca_make_profile(struct mthca_dev *dev , struct mthca_profile *request , struct mthca_dev_lim *dev_lim ,
                       struct mthca_init_hca_param *init_hca ) 
{ 
  u64 mem_base ;
  u64 mem_avail ;
  s64 total_size ;
  struct mthca_resource *profile ;
  int i ;
  int j ;
  void *tmp ;
  int _max1 ;
  int tmp___0 ;
  int _max2 ;
  u64 _max1___0 ;
  unsigned long long _max2___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct mthca_resource __tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 78
  total_size = 0LL;
#line 82
  tmp = kzalloc(448UL, 208U);
#line 82
  profile = (struct mthca_resource *)tmp;
#line 83
  if ((unsigned long )profile == (unsigned long )((struct mthca_resource *)0)) {
#line 84
    return (-12LL);
  } else {

  }
#line 86
  profile->size = (u64 )dev_lim->qpc_entry_sz;
#line 87
  (profile + 1UL)->size = (u64 )dev_lim->eec_entry_sz;
#line 88
  (profile + 2UL)->size = (u64 )dev_lim->srq_entry_sz;
#line 89
  (profile + 3UL)->size = (u64 )dev_lim->cqc_entry_sz;
#line 90
  (profile + 4UL)->size = (u64 )dev_lim->eqpc_entry_sz;
#line 91
  (profile + 5UL)->size = (u64 )dev_lim->eeec_entry_sz;
#line 92
  (profile + 6UL)->size = (u64 )dev_lim->eqc_entry_sz;
#line 93
  (profile + 7UL)->size = 32ULL;
#line 94
  (profile + 8UL)->size = 256ULL;
#line 95
  (profile + 9UL)->size = (u64 )dev_lim->mpt_entry_sz;
#line 96
  (profile + 10UL)->size = (u64 )dev->limits.mtt_seg_size;
#line 97
  (profile + 11UL)->size = (u64 )dev_lim->uar_scratch_entry_sz;
#line 98
  (profile + 12UL)->size = 32ULL;
#line 99
  (profile + 13UL)->size = (u64 )request->uarc_size;
#line 101
  profile->num = request->num_qp;
#line 102
  (profile + 2UL)->num = request->num_srq;
#line 103
  (profile + 4UL)->num = request->num_qp;
#line 104
  (profile + 7UL)->num = request->num_qp * request->rdb_per_qp;
#line 105
  (profile + 3UL)->num = request->num_cq;
#line 106
  (profile + 6UL)->num = 32;
#line 107
  (profile + 8UL)->num = request->num_mcg;
#line 108
  (profile + 9UL)->num = request->num_mpt;
#line 109
  (profile + 10UL)->num = request->num_mtt;
#line 110
  (profile + 11UL)->num = request->num_uar;
#line 111
  (profile + 13UL)->num = request->num_uar;
#line 112
  (profile + 12UL)->num = request->num_udav;
#line 114
  i = 0;
#line 114
  goto ldv_30522;
  ldv_30521: 
#line 115
  (profile + (unsigned long )i)->type = i;
#line 116
  tmp___0 = ffs((profile + (unsigned long )i)->num);
#line 116
  _max1 = tmp___0 + -1;
#line 116
  _max2 = 0;
#line 116
  (profile + (unsigned long )i)->log_num = _max1 > _max2 ? _max1 : _max2;
#line 117
  (profile + (unsigned long )i)->size = (profile + (unsigned long )i)->size * (u64 )(profile + (unsigned long )i)->num;
#line 118
  tmp___1 = mthca_is_memfree(dev);
#line 118
  if (tmp___1 != 0) {
#line 119
    _max1___0 = (profile + (unsigned long )i)->size;
#line 119
    _max2___0 = 4096ULL;
#line 119
    (profile + (unsigned long )i)->size = _max1___0 > _max2___0 ? _max1___0 : _max2___0;
  } else {

  }
#line 114
  i = i + 1;
  ldv_30522: ;
#line 114
  if (i <= 13) {
#line 116
    goto ldv_30521;
  } else {

  }
#line 122
  tmp___2 = mthca_is_memfree(dev);
#line 122
  if (tmp___2 != 0) {
#line 123
    mem_base = 0ULL;
#line 124
    mem_avail = dev_lim->hca.arbel.max_icm_sz;
  } else {
#line 126
    mem_base = dev->ddr_start;
#line 127
    mem_avail = dev->fw.tavor.fw_start - dev->ddr_start;
  }
#line 136
  i = 14;
#line 136
  goto ldv_30529;
  ldv_30528: 
#line 137
  j = 1;
#line 137
  goto ldv_30526;
  ldv_30525: ;
#line 138
  if ((profile + (unsigned long )j)->size > (profile + ((unsigned long )j + 0xffffffffffffffffUL))->size) {
#line 139
    __tmp = *(profile + (unsigned long )j);
#line 139
    *(profile + (unsigned long )j) = *(profile + ((unsigned long )j + 0xffffffffffffffffUL));
#line 139
    *(profile + ((unsigned long )j + 0xffffffffffffffffUL)) = __tmp;
  } else {

  }
#line 137
  j = j + 1;
  ldv_30526: ;
#line 137
  if (j < i) {
#line 139
    goto ldv_30525;
  } else {

  }
#line 136
  i = i - 1;
  ldv_30529: ;
#line 136
  if (i > 0) {
#line 138
    goto ldv_30528;
  } else {

  }
#line 142
  i = 0;
#line 142
  goto ldv_30532;
  ldv_30531: ;
#line 143
  if ((profile + (unsigned long )i)->size != 0ULL) {
#line 144
    (profile + (unsigned long )i)->start = mem_base + (unsigned long long )total_size;
#line 145
    total_size = (s64 )((profile + (unsigned long )i)->size + (unsigned long long )total_size);
  } else {

  }
#line 147
  if ((unsigned long long )total_size > mem_avail) {
#line 148
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Profile requires 0x%llx bytes; won\'t fit in 0x%llx bytes of context memory.\n",
            (unsigned long long )total_size, mem_avail);
#line 152
    kfree((void const   *)profile);
#line 153
    return (-12LL);
  } else {

  }
#line 156
  if ((profile + (unsigned long )i)->size != 0ULL) {
#line 157
    if (mthca_debug_level != 0) {
#line 157
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "profile[%2d]--%2d/%2d @ 0x%16llx (size 0x%8llx)\n",
                 i, (profile + (unsigned long )i)->type, (profile + (unsigned long )i)->log_num,
                 (profile + (unsigned long )i)->start, (profile + (unsigned long )i)->size);
    } else {

    }
  } else {

  }
#line 142
  i = i + 1;
  ldv_30532: ;
#line 142
  if (i <= 13) {
#line 144
    goto ldv_30531;
  } else {

  }
#line 164
  tmp___3 = mthca_is_memfree(dev);
#line 164
  if (tmp___3 != 0) {
#line 165
    if (mthca_debug_level != 0) {
#line 165
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "HCA context memory: reserving %d KB\n",
                 (int )(total_size >> 10));
    } else {

    }
  } else
#line 168
  if (mthca_debug_level != 0) {
#line 168
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "HCA memory: allocated %d KB/%d KB (%d KB free)\n",
               (int )(total_size >> 10), (int )(mem_avail >> 10), (int )((mem_avail - (unsigned long long )total_size) >> 10));
  } else {

  }
#line 172
  i = 0;
#line 172
  goto ldv_30554;
  ldv_30553: ;
#line 173
  switch ((profile + (unsigned long )i)->type) {
  case 0: 
#line 175
  dev->limits.num_qps = (profile + (unsigned long )i)->num;
#line 176
  init_hca->qpc_base = (profile + (unsigned long )i)->start;
#line 177
  init_hca->log_num_qps = (u8 )(profile + (unsigned long )i)->log_num;
#line 178
  goto ldv_30535;
  case 1: 
#line 180
  dev->limits.num_eecs = (profile + (unsigned long )i)->num;
#line 181
  init_hca->eec_base = (profile + (unsigned long )i)->start;
#line 182
  init_hca->log_num_eecs = (u8 )(profile + (unsigned long )i)->log_num;
#line 183
  goto ldv_30535;
  case 2: 
#line 185
  dev->limits.num_srqs = (profile + (unsigned long )i)->num;
#line 186
  init_hca->srqc_base = (profile + (unsigned long )i)->start;
#line 187
  init_hca->log_num_srqs = (u8 )(profile + (unsigned long )i)->log_num;
#line 188
  goto ldv_30535;
  case 3: 
#line 190
  dev->limits.num_cqs = (profile + (unsigned long )i)->num;
#line 191
  init_hca->cqc_base = (profile + (unsigned long )i)->start;
#line 192
  init_hca->log_num_cqs = (u8 )(profile + (unsigned long )i)->log_num;
#line 193
  goto ldv_30535;
  case 4: 
#line 195
  init_hca->eqpc_base = (profile + (unsigned long )i)->start;
#line 196
  goto ldv_30535;
  case 5: 
#line 198
  init_hca->eeec_base = (profile + (unsigned long )i)->start;
#line 199
  goto ldv_30535;
  case 6: 
#line 201
  dev->limits.num_eqs = (profile + (unsigned long )i)->num;
#line 202
  init_hca->eqc_base = (profile + (unsigned long )i)->start;
#line 203
  init_hca->log_num_eqs = (u8 )(profile + (unsigned long )i)->log_num;
#line 204
  goto ldv_30535;
  case 7: 
#line 206
  dev->qp_table.rdb_shift = 0;
#line 206
  goto ldv_30544;
  ldv_30543: 
#line 208
  dev->qp_table.rdb_shift = dev->qp_table.rdb_shift + 1;
  ldv_30544: ;
#line 206
  if (request->num_qp << dev->qp_table.rdb_shift < (profile + (unsigned long )i)->num) {
#line 209
    goto ldv_30543;
  } else {

  }
#line 210
  dev->qp_table.rdb_base = (unsigned int )(profile + (unsigned long )i)->start;
#line 211
  init_hca->rdb_base = (profile + (unsigned long )i)->start;
#line 212
  goto ldv_30535;
  case 8: 
#line 214
  dev->limits.num_mgms = (profile + (unsigned long )i)->num >> 1;
#line 215
  dev->limits.num_amgms = (profile + (unsigned long )i)->num >> 1;
#line 216
  init_hca->mc_base = (profile + (unsigned long )i)->start;
#line 217
  tmp___4 = ffs(256);
#line 217
  init_hca->log_mc_entry_sz = (unsigned int )((u16 )tmp___4) + 65535U;
#line 218
  init_hca->log_mc_table_sz = (u8 )(profile + (unsigned long )i)->log_num;
#line 219
  init_hca->mc_hash_sz = (u16 )(1 << ((profile + (unsigned long )i)->log_num + -1));
#line 220
  goto ldv_30535;
  case 9: 
#line 222
  dev->limits.num_mpts = (profile + (unsigned long )i)->num;
#line 223
  dev->mr_table.mpt_base = (profile + (unsigned long )i)->start;
#line 224
  init_hca->mpt_base = (profile + (unsigned long )i)->start;
#line 225
  init_hca->log_mpt_sz = (u8 )(profile + (unsigned long )i)->log_num;
#line 226
  goto ldv_30535;
  case 10: 
#line 228
  dev->limits.num_mtt_segs = (profile + (unsigned long )i)->num;
#line 229
  dev->mr_table.mtt_base = (profile + (unsigned long )i)->start;
#line 230
  init_hca->mtt_base = (profile + (unsigned long )i)->start;
#line 231
  tmp___5 = ffs(dev->limits.mtt_seg_size);
#line 231
  init_hca->mtt_seg_sz = (unsigned int )((u8 )tmp___5) + 249U;
#line 232
  goto ldv_30535;
  case 11: 
#line 234
  dev->limits.num_uars = (profile + (unsigned long )i)->num;
#line 235
  init_hca->uar_scratch_base = (profile + (unsigned long )i)->start;
#line 236
  goto ldv_30535;
  case 12: 
#line 238
  dev->av_table.ddr_av_base = (profile + (unsigned long )i)->start;
#line 239
  dev->av_table.num_ddr_avs = (profile + (unsigned long )i)->num;
#line 240
  goto ldv_30535;
  case 13: 
#line 242
  dev->uar_table.uarc_size = request->uarc_size;
#line 243
  dev->uar_table.uarc_base = (profile + (unsigned long )i)->start;
#line 244
  init_hca->uarc_base = (profile + (unsigned long )i)->start;
#line 245
  tmp___6 = ffs(request->uarc_size);
#line 245
  init_hca->log_uarc_sz = (unsigned int )((u8 )tmp___6) + 243U;
#line 246
  tmp___7 = ffs(request->num_uar);
#line 246
  init_hca->log_uar_sz = (unsigned int )((u8 )tmp___7) + 255U;
#line 247
  goto ldv_30535;
  default: ;
#line 249
  goto ldv_30535;
  }
  ldv_30535: 
#line 172
  i = i + 1;
  ldv_30554: ;
#line 172
  if (i <= 13) {
#line 174
    goto ldv_30553;
  } else {

  }
#line 257
  dev->limits.num_pds = 32768;
#line 259
  if ((dev->mthca_flags & 256UL) != 0UL && (unsigned int )init_hca->log_mpt_sz > 23U) {
#line 261
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "MPT table too large (requested size 2^%d >= 2^24)\n",
             (int )init_hca->log_mpt_sz);
#line 263
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Disabling memory key throughput optimization.\n");
#line 264
    dev->mthca_flags = dev->mthca_flags & 0xfffffffffffffeffUL;
  } else {

  }
#line 274
  mthca_is_memfree(dev);
#line 275
  dev->limits.fmr_reserved_mtts = 0;
#line 279
  kfree((void const   *)profile);
#line 280
  return (total_size);
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_profile.o.c.prepared"
bool ldv_queue_work_on_37(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_profile.o.c.prepared"
bool ldv_queue_delayed_work_on_38(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_profile.o.c.prepared"
bool ldv_queue_work_on_39(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_profile.o.c.prepared"
void ldv_flush_workqueue_40(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_profile.o.c.prepared"
bool ldv_queue_delayed_work_on_41(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_53(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_52(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_55(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_54(struct workqueue_struct *ldv_func_arg1 ) ;
#line 66 "./arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 66
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 67
  return;
}
}
#line 812 "include/linux/pci.h"
extern void pci_dev_put(struct pci_dev * ) ;
#line 841
extern struct pci_dev *pci_get_device(unsigned int  , unsigned int  , struct pci_dev * ) ;
#line 861
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 867
extern int pci_bus_write_config_dword(struct pci_bus * , unsigned int  , int  , u32  ) ;
#line 889 "include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp ;

  {
#line 892
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
#line 892
  return (tmp);
}
}
#line 902 "include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val ) 
{ 
  int tmp ;

  {
#line 905
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
#line 905
  return (tmp);
}
}
#line 910
extern int pcie_capability_write_word(struct pci_dev * , int  , u16  ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_reset.c"
int mthca_reset(struct mthca_dev *mdev ) 
{ 
  int i ;
  int err ;
  u32 *hca_header ;
  u32 *bridge_header ;
  struct pci_dev *bridge ;
  int bridge_pcix_cap ;
  int hca_pcie_cap ;
  int hca_pcix_cap ;
  u16 devctl ;
  u16 linkctl ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *reset ;
  void *tmp___5 ;
  u32 v ;
  int c ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 44
  err = 0;
#line 45
  hca_header = (u32 *)0U;
#line 46
  bridge_header = (u32 *)0U;
#line 47
  bridge = (struct pci_dev *)0;
#line 48
  bridge_pcix_cap = 0;
#line 49
  hca_pcie_cap = 0;
#line 50
  hca_pcix_cap = 0;
#line 69
  if ((mdev->mthca_flags & 128UL) == 0UL) {
#line 72
    goto ldv_30504;
    ldv_30503: ;
#line 75
    if ((unsigned int )bridge->hdr_type == 1U && (unsigned long )bridge->subordinate == (unsigned long )(mdev->pdev)->bus) {
#line 77
      if (mthca_debug_level != 0) {
#line 77
        tmp = pci_name((struct pci_dev  const  *)bridge);
#line 77
        dev_printk("\017", (struct device  const  *)(& (mdev->pdev)->dev), "Found bridge: %s\n",
                   tmp);
      } else {

      }
#line 79
      goto ldv_30502;
    } else {

    }
    ldv_30504: 
#line 72
    bridge = pci_get_device((unsigned int )(mdev->pdev)->vendor, (unsigned int )((int )(mdev->pdev)->device + 2),
                            bridge);
#line 72
    if ((unsigned long )bridge != (unsigned long )((struct pci_dev *)0)) {
#line 76
      goto ldv_30503;
    } else {

    }
    ldv_30502: ;
#line 83
    if ((unsigned long )bridge == (unsigned long )((struct pci_dev *)0)) {
#line 89
      tmp___0 = pci_name((struct pci_dev  const  *)mdev->pdev);
#line 89
      dev_warn((struct device  const  *)(& (mdev->pdev)->dev), "No bridge found for %s\n",
               tmp___0);
    } else {

    }
  } else {

  }
#line 96
  tmp___1 = kmalloc(256UL, 208U);
#line 96
  hca_header = (u32 *)tmp___1;
#line 97
  if ((unsigned long )hca_header == (unsigned long )((u32 *)0U)) {
#line 98
    err = -12;
#line 99
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t allocate memory to save HCA PCI header, aborting.\n");
#line 101
    goto out;
  } else {

  }
#line 104
  i = 0;
#line 104
  goto ldv_30508;
  ldv_30507: ;
#line 105
  if (i == 22 || i == 23) {
#line 106
    goto ldv_30506;
  } else {

  }
#line 107
  tmp___2 = pci_read_config_dword((struct pci_dev  const  *)mdev->pdev, i * 4, hca_header + (unsigned long )i);
#line 107
  if (tmp___2 != 0) {
#line 108
    err = -19;
#line 109
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t save HCA PCI header, aborting.\n");
#line 111
    goto out;
  } else {

  }
  ldv_30506: 
#line 104
  i = i + 1;
  ldv_30508: ;
#line 104
  if (i <= 63) {
#line 106
    goto ldv_30507;
  } else {

  }
#line 115
  hca_pcix_cap = pci_find_capability(mdev->pdev, 7);
#line 116
  hca_pcie_cap = pci_pcie_cap(mdev->pdev);
#line 118
  if ((unsigned long )bridge != (unsigned long )((struct pci_dev *)0)) {
#line 119
    tmp___3 = kmalloc(256UL, 208U);
#line 119
    bridge_header = (u32 *)tmp___3;
#line 120
    if ((unsigned long )bridge_header == (unsigned long )((u32 *)0U)) {
#line 121
      err = -12;
#line 122
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t allocate memory to save HCA bridge PCI header, aborting.\n");
#line 124
      goto out;
    } else {

    }
#line 127
    i = 0;
#line 127
    goto ldv_30512;
    ldv_30511: ;
#line 128
    if (i == 22 || i == 23) {
#line 129
      goto ldv_30510;
    } else {

    }
#line 130
    tmp___4 = pci_read_config_dword((struct pci_dev  const  *)bridge, i * 4, bridge_header + (unsigned long )i);
#line 130
    if (tmp___4 != 0) {
#line 131
      err = -19;
#line 132
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t save HCA bridge PCI header, aborting.\n");
#line 134
      goto out;
    } else {

    }
    ldv_30510: 
#line 127
    i = i + 1;
    ldv_30512: ;
#line 127
    if (i <= 63) {
#line 129
      goto ldv_30511;
    } else {

    }
#line 137
    bridge_pcix_cap = pci_find_capability(bridge, 7);
#line 138
    if (bridge_pcix_cap == 0) {
#line 139
      err = -19;
#line 140
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t locate HCA bridge PCI-X capability, aborting.\n");
#line 142
      goto out;
    } else {

    }
  } else {

  }
#line 148
  tmp___5 = ioremap((mdev->pdev)->resource[0].start + 983056ULL, 4UL);
#line 148
  reset = tmp___5;
#line 151
  if ((unsigned long )reset == (unsigned long )((void *)0)) {
#line 152
    err = -12;
#line 153
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t map HCA reset register, aborting.\n");
#line 155
    goto out;
  } else {

  }
#line 158
  writel(16777216U, (void volatile   *)reset);
#line 159
  iounmap((void volatile   *)reset);
#line 163
  msleep(1000U);
#line 168
  c = 0;
#line 170
  c = 0;
#line 170
  goto ldv_30519;
  ldv_30518: 
#line 171
  tmp___6 = pci_read_config_dword((struct pci_dev  const  *)((unsigned long )bridge == (unsigned long )((struct pci_dev *)0) ? mdev->pdev : bridge),
                                  0, & v);
#line 171
  if (tmp___6 != 0) {
#line 172
    err = -19;
#line 173
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t access HCA after reset, aborting.\n");
#line 175
    goto out;
  } else {

  }
#line 178
  if (v != 4294967295U) {
#line 179
    goto good;
  } else {

  }
#line 181
  msleep(100U);
#line 170
  c = c + 1;
  ldv_30519: ;
#line 170
  if (c <= 99) {
#line 172
    goto ldv_30518;
  } else {

  }
#line 184
  err = -19;
#line 185
  dev_err((struct device  const  *)(& (mdev->pdev)->dev), "PCI device did not come back after reset, aborting.\n");
#line 187
  goto out;
  good: ;
#line 192
  if ((unsigned long )bridge != (unsigned long )((struct pci_dev *)0)) {
#line 193
    tmp___7 = pci_write_config_dword((struct pci_dev  const  *)bridge, bridge_pcix_cap + 8,
                                     *(bridge_header + (unsigned long )((bridge_pcix_cap + 8) / 4)));
#line 193
    if (tmp___7 != 0) {
#line 195
      err = -19;
#line 196
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA bridge Upstream split transaction control, aborting.\n");
#line 198
      goto out;
    } else {

    }
#line 200
    tmp___8 = pci_write_config_dword((struct pci_dev  const  *)bridge, bridge_pcix_cap + 12,
                                     *(bridge_header + (unsigned long )((bridge_pcix_cap + 12) / 4)));
#line 200
    if (tmp___8 != 0) {
#line 202
      err = -19;
#line 203
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA bridge Downstream split transaction control, aborting.\n");
#line 205
      goto out;
    } else {

    }
#line 211
    i = 0;
#line 211
    goto ldv_30523;
    ldv_30522: ;
#line 212
    if (i * 4 == 4) {
#line 213
      goto ldv_30521;
    } else {

    }
#line 215
    tmp___9 = pci_write_config_dword((struct pci_dev  const  *)bridge, i * 4, *(bridge_header + (unsigned long )i));
#line 215
    if (tmp___9 != 0) {
#line 216
      err = -19;
#line 217
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA bridge reg %x, aborting.\n",
              i);
#line 219
      goto out;
    } else {

    }
    ldv_30521: 
#line 211
    i = i + 1;
    ldv_30523: ;
#line 211
    if (i <= 15) {
#line 213
      goto ldv_30522;
    } else {

    }
#line 223
    tmp___10 = pci_write_config_dword((struct pci_dev  const  *)bridge, 4, *(bridge_header + 1UL));
#line 223
    if (tmp___10 != 0) {
#line 225
      err = -19;
#line 226
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA bridge COMMAND, aborting.\n");
#line 228
      goto out;
    } else {

    }
  } else {

  }
#line 232
  if (hca_pcix_cap != 0) {
#line 233
    tmp___11 = pci_write_config_dword((struct pci_dev  const  *)mdev->pdev, hca_pcix_cap,
                                      *(hca_header + (unsigned long )(hca_pcix_cap / 4)));
#line 233
    if (tmp___11 != 0) {
#line 235
      err = -19;
#line 236
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA PCI-X command register, aborting.\n");
#line 238
      goto out;
    } else {

    }
  } else {

  }
#line 242
  if (hca_pcie_cap != 0) {
#line 243
    devctl = (u16 )*(hca_header + (unsigned long )((hca_pcie_cap + 8) / 4));
#line 244
    tmp___12 = pcie_capability_write_word(mdev->pdev, 8, (int )devctl);
#line 244
    if (tmp___12 != 0) {
#line 246
      err = -19;
#line 247
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA PCI Express Device Control register, aborting.\n");
#line 249
      goto out;
    } else {

    }
#line 251
    linkctl = (u16 )*(hca_header + (unsigned long )((hca_pcie_cap + 16) / 4));
#line 252
    tmp___13 = pcie_capability_write_word(mdev->pdev, 16, (int )linkctl);
#line 252
    if (tmp___13 != 0) {
#line 254
      err = -19;
#line 255
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA PCI Express Link control register, aborting.\n");
#line 257
      goto out;
    } else {

    }
  } else {

  }
#line 261
  i = 0;
#line 261
  goto ldv_30527;
  ldv_30526: ;
#line 262
  if (i * 4 == 4) {
#line 263
    goto ldv_30525;
  } else {

  }
#line 265
  tmp___14 = pci_write_config_dword((struct pci_dev  const  *)mdev->pdev, i * 4, *(hca_header + (unsigned long )i));
#line 265
  if (tmp___14 != 0) {
#line 266
    err = -19;
#line 267
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA reg %x, aborting.\n",
            i);
#line 269
    goto out;
  } else {

  }
  ldv_30525: 
#line 261
  i = i + 1;
  ldv_30527: ;
#line 261
  if (i <= 15) {
#line 263
    goto ldv_30526;
  } else {

  }
#line 273
  tmp___15 = pci_write_config_dword((struct pci_dev  const  *)mdev->pdev, 4, *(hca_header + 1UL));
#line 273
  if (tmp___15 != 0) {
#line 275
    err = -19;
#line 276
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA COMMAND, aborting.\n");
#line 278
    goto out;
  } else {

  }
  out: ;
#line 282
  if ((unsigned long )bridge != (unsigned long )((struct pci_dev *)0)) {
#line 283
    pci_dev_put(bridge);
  } else {

  }
#line 284
  kfree((void const   *)bridge_header);
#line 285
  kfree((void const   *)hca_header);
#line 287
  return (err);
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_reset.o.c.prepared"
bool ldv_queue_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_reset.o.c.prepared"
bool ldv_queue_delayed_work_on_52(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_reset.o.c.prepared"
bool ldv_queue_work_on_53(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_reset.o.c.prepared"
void ldv_flush_workqueue_54(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_reset.o.c.prepared"
bool ldv_queue_delayed_work_on_55(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 28 "include/asm-generic/bitops/find.h"
extern unsigned long find_next_zero_bit(unsigned long const   * , unsigned long  ,
                                        unsigned long  ) ;
#line 53
extern unsigned long find_first_zero_bit(unsigned long const   * , unsigned long  ) ;
#line 45 "include/linux/dynamic_debug.h"
extern void __dynamic_pr_debug(struct _ddebug * , char const   *  , ...) ;
#line 37 "./arch/x86/include/asm/page_64.h"
extern void clear_page(void * ) ;
#line 13 "include/asm-generic/getorder.h"
__inline static int __get_order(unsigned long size ) 
{ 
  int order ;

  {
#line 17
  size = size - 1UL;
#line 18
  size = size >> 12;
#line 22
  order = fls64((__u64 )size);
#line 24
  return (order);
}
}
#line 181 "include/linux/bitmap.h"
__inline static void bitmap_zero(unsigned long *dst , unsigned int nbits ) 
{ 
  unsigned int len ;

  {
#line 186
  len = (unsigned int )(((unsigned long )nbits + 63UL) / 64UL) * 8U;
#line 187
  memset((void *)dst, 0, (size_t )len);
#line 189
  return;
}
}
#line 34 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 45
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 370 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 372
  _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
#line 373
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_67(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_66(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_69(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_68(struct workqueue_struct *ldv_func_arg1 ) ;
#line 353 "include/linux/gfp.h"
extern unsigned long get_zeroed_page(gfp_t  ) ;
#line 367
extern void free_pages(unsigned long  , unsigned int  ) ;
#line 131 "./arch/x86/include/asm/dma-mapping.h"
extern void *dma_alloc_attrs(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
#line 136
extern void dma_free_attrs(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
#line 414 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
u32 mthca_alloc(struct mthca_alloc *alloc ) ;
#line 415
void mthca_free(struct mthca_alloc *alloc , u32 obj ) ;
#line 416
int mthca_alloc_init(struct mthca_alloc *alloc , u32 num , u32 mask , u32 reserved ) ;
#line 418
void mthca_alloc_cleanup(struct mthca_alloc *alloc ) ;
#line 419
void *mthca_array_get(struct mthca_array *array , int index ) ;
#line 420
int mthca_array_set(struct mthca_array *array , int index , void *value ) ;
#line 421
void mthca_array_clear(struct mthca_array *array , int index ) ;
#line 422
int mthca_array_init(struct mthca_array *array , int nent ) ;
#line 423
void mthca_array_cleanup(struct mthca_array *array , int nent ) ;
#line 424
int mthca_buf_alloc(struct mthca_dev *dev , int size , int max_direct , union mthca_buf *buf ,
                    int *is_direct , struct mthca_pd *pd , int hca_write , struct mthca_mr *mr ) ;
#line 427
void mthca_buf_free(struct mthca_dev *dev , int size , union mthca_buf *buf , int is_direct ,
                    struct mthca_mr *mr ) ;
#line 475
int mthca_mr_alloc_phys(struct mthca_dev *dev , u32 pd , u64 *buffer_list , int buffer_size_shift ,
                        int list_len , u64 iova , u64 total_size , u32 access , struct mthca_mr *mr ) ;
#line 479
void mthca_free_mr(struct mthca_dev *dev , struct mthca_mr *mr ) ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.c"
u32 mthca_alloc(struct mthca_alloc *alloc ) 
{ 
  unsigned long flags ;
  u32 obj ;
  raw_spinlock_t *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 45
  tmp = spinlock_check(& alloc->lock);
#line 45
  flags = _raw_spin_lock_irqsave(tmp);
#line 47
  tmp___0 = find_next_zero_bit((unsigned long const   *)alloc->table, (unsigned long )alloc->max,
                               (unsigned long )alloc->last);
#line 47
  obj = (u32 )tmp___0;
#line 48
  if (alloc->max <= obj) {
#line 49
    alloc->top = (alloc->top + alloc->max) & alloc->mask;
#line 50
    tmp___1 = find_first_zero_bit((unsigned long const   *)alloc->table, (unsigned long )alloc->max);
#line 50
    obj = (u32 )tmp___1;
  } else {

  }
#line 53
  if (alloc->max > obj) {
#line 54
    set_bit((long )obj, (unsigned long volatile   *)alloc->table);
#line 55
    obj = alloc->top | obj;
  } else {
#line 57
    obj = 4294967295U;
  }
#line 59
  spin_unlock_irqrestore(& alloc->lock, flags);
#line 61
  return (obj);
}
}
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.c"
void mthca_free(struct mthca_alloc *alloc , u32 obj ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  u32 _min1 ;
  u32 _min2 ;

  {
#line 68
  obj = (alloc->max - 1U) & obj;
#line 70
  tmp = spinlock_check(& alloc->lock);
#line 70
  flags = _raw_spin_lock_irqsave(tmp);
#line 72
  clear_bit((long )obj, (unsigned long volatile   *)alloc->table);
#line 73
  _min1 = alloc->last;
#line 73
  _min2 = obj;
#line 73
  alloc->last = _min1 < _min2 ? _min1 : _min2;
#line 74
  alloc->top = (alloc->top + alloc->max) & alloc->mask;
#line 76
  spin_unlock_irqrestore(& alloc->lock, flags);
#line 77
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.c"
int mthca_alloc_init(struct mthca_alloc *alloc , u32 num , u32 mask , u32 reserved ) 
{ 
  int i ;
  int tmp ;
  struct lock_class_key __key ;
  void *tmp___0 ;

  {
#line 85
  tmp = ffs((int )num);
#line 85
  if ((u32 )(1 << (tmp + -1)) != num) {
#line 86
    return (-22);
  } else {

  }
#line 88
  alloc->last = 0U;
#line 89
  alloc->top = 0U;
#line 90
  alloc->max = num;
#line 91
  alloc->mask = mask;
#line 92
  spinlock_check(& alloc->lock);
#line 92
  __raw_spin_lock_init(& alloc->lock.__annonCompField18.rlock, "&(&alloc->lock)->rlock",
                       & __key);
#line 93
  tmp___0 = kmalloc((((unsigned long )num + 63UL) / 64UL) * 8UL, 208U);
#line 93
  alloc->table = (unsigned long *)tmp___0;
#line 95
  if ((unsigned long )alloc->table == (unsigned long )((unsigned long *)0UL)) {
#line 96
    return (-12);
  } else {

  }
#line 98
  bitmap_zero(alloc->table, num);
#line 99
  i = 0;
#line 99
  goto ldv_30145;
  ldv_30144: 
#line 100
  set_bit((long )i, (unsigned long volatile   *)alloc->table);
#line 99
  i = i + 1;
  ldv_30145: ;
#line 99
  if ((u32 )i < reserved) {
#line 101
    goto ldv_30144;
  } else {

  }

#line 102
  return (0);
}
}
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.c"
void mthca_alloc_cleanup(struct mthca_alloc *alloc ) 
{ 


  {
#line 107
  kfree((void const   *)alloc->table);
#line 108
  return;
}
}
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.c"
void *mthca_array_get(struct mthca_array *array , int index ) 
{ 
  int p ;

  {
#line 120
  p = (int )((unsigned long )index * 8UL >> 12);
#line 122
  if ((unsigned long )(array->page_list + (unsigned long )p)->page != (unsigned long )((void **)0)) {
#line 123
    return (*((array->page_list + (unsigned long )p)->page + ((unsigned long )index & 511UL)));
  } else {
#line 125
    return ((void *)0);
  }
}
}
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.c"
int mthca_array_set(struct mthca_array *array , int index , void *value ) 
{ 
  int p ;
  unsigned long tmp ;

  {
#line 130
  p = (int )((unsigned long )index * 8UL >> 12);
#line 133
  if ((unsigned long )(array->page_list + (unsigned long )p)->page == (unsigned long )((void **)0)) {
#line 134
    tmp = get_zeroed_page(32U);
#line 134
    (array->page_list + (unsigned long )p)->page = (void **)tmp;
  } else {

  }
#line 136
  if ((unsigned long )(array->page_list + (unsigned long )p)->page == (unsigned long )((void **)0)) {
#line 137
    return (-12);
  } else {

  }
#line 139
  *((array->page_list + (unsigned long )p)->page + ((unsigned long )index & 511UL)) = value;
#line 140
  (array->page_list + (unsigned long )p)->used = (array->page_list + (unsigned long )p)->used + 1;
#line 142
  return (0);
}
}
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.c"
void mthca_array_clear(struct mthca_array *array , int index ) 
{ 
  int p ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 147
  p = (int )((unsigned long )index * 8UL >> 12);
#line 149
  (array->page_list + (unsigned long )p)->used = (array->page_list + (unsigned long )p)->used - 1;
#line 149
  if ((array->page_list + (unsigned long )p)->used == 0) {
#line 150
    free_pages((unsigned long )(array->page_list + (unsigned long )p)->page, 0U);
#line 151
    (array->page_list + (unsigned long )p)->page = (void **)0;
  } else {
#line 153
    *((array->page_list + (unsigned long )p)->page + ((unsigned long )index & 511UL)) = (void *)0;
  }
#line 155
  if ((array->page_list + (unsigned long )p)->used < 0) {
#line 156
    descriptor.modname = "ib_mthca";
#line 156
    descriptor.function = "mthca_array_clear";
#line 156
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.c";
#line 156
    descriptor.format = "Array %p index %d page %d with ref count %d < 0\n";
#line 156
    descriptor.lineno = 157U;
#line 156
    descriptor.flags = 0U;
#line 156
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 156
    if (tmp != 0L) {
#line 156
      __dynamic_pr_debug(& descriptor, "Array %p index %d page %d with ref count %d < 0\n",
                         array, index, p, (array->page_list + (unsigned long )p)->used);
    } else {

    }
  } else {

  }
#line 158
  return;
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.c"
int mthca_array_init(struct mthca_array *array , int nent ) 
{ 
  int npage ;
  int i ;
  void *tmp ;

  {
#line 162
  npage = (int )((((unsigned long )nent + 512UL) * 8UL - 1UL) / 4096UL);
#line 165
  tmp = kmalloc((unsigned long )npage * 16UL, 208U);
#line 165
  array->page_list = (struct __anonstruct_251 *)tmp;
#line 166
  if ((unsigned long )array->page_list == (unsigned long )((struct __anonstruct_253 *)0)) {
#line 167
    return (-12);
  } else {

  }
#line 169
  i = 0;
#line 169
  goto ldv_30175;
  ldv_30174: 
#line 170
  (array->page_list + (unsigned long )i)->page = (void **)0;
#line 171
  (array->page_list + (unsigned long )i)->used = 0;
#line 169
  i = i + 1;
  ldv_30175: ;
#line 169
  if (i < npage) {
#line 171
    goto ldv_30174;
  } else {

  }

#line 174
  return (0);
}
}
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.c"
void mthca_array_cleanup(struct mthca_array *array , int nent ) 
{ 
  int i ;

  {
#line 181
  i = 0;
#line 181
  goto ldv_30183;
  ldv_30182: 
#line 182
  free_pages((unsigned long )(array->page_list + (unsigned long )i)->page, 0U);
#line 181
  i = i + 1;
  ldv_30183: ;
#line 181
  if ((unsigned long )i < (((unsigned long )nent + 512UL) * 8UL - 1UL) / 4096UL) {
#line 183
    goto ldv_30182;
  } else {

  }
#line 184
  kfree((void const   *)array->page_list);
#line 185
  return;
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.c"
int mthca_buf_alloc(struct mthca_dev *dev , int size , int max_direct , union mthca_buf *buf ,
                    int *is_direct , struct mthca_pd *pd , int hca_write , struct mthca_mr *mr ) 
{ 
  int err ;
  int npages ;
  int shift ;
  u64 *dma_list ;
  dma_addr_t t ;
  int i ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 198
  err = -12;
#line 200
  dma_list = (u64 *)0ULL;
#line 204
  if (size <= max_direct) {
#line 205
    *is_direct = 1;
#line 206
    npages = 1;
#line 207
    tmp = __get_order((unsigned long )size);
#line 207
    shift = tmp + 12;
#line 209
    buf->direct.buf = dma_alloc_attrs(& (dev->pdev)->dev, (size_t )size, & t, 208U,
                                      (struct dma_attrs *)0);
#line 211
    if ((unsigned long )buf->direct.buf == (unsigned long )((void *)0)) {
#line 212
      return (-12);
    } else {

    }
#line 214
    buf->direct.mapping = t;
#line 216
    memset(buf->direct.buf, 0, (size_t )size);
#line 218
    goto ldv_30202;
    ldv_30201: 
#line 219
    shift = shift - 1;
#line 220
    npages = npages * 2;
    ldv_30202: ;
#line 218
    if (((dma_addr_t )((1 << shift) + -1) & t) != 0ULL) {
#line 220
      goto ldv_30201;
    } else {

    }
#line 223
    tmp___0 = kmalloc((unsigned long )npages * 8UL, 208U);
#line 223
    dma_list = (u64 *)tmp___0;
#line 224
    if ((unsigned long )dma_list == (unsigned long )((u64 *)0ULL)) {
#line 225
      goto err_free;
    } else {

    }
#line 227
    i = 0;
#line 227
    goto ldv_30206;
    ldv_30205: 
#line 228
    *(dma_list + (unsigned long )i) = (dma_addr_t )(i << shift) + t;
#line 227
    i = i + 1;
    ldv_30206: ;
#line 227
    if (i < npages) {
#line 229
      goto ldv_30205;
    } else {

    }

  } else {
#line 230
    *is_direct = 0;
#line 231
    npages = (int )(((unsigned long )size + 4095UL) / 4096UL);
#line 232
    shift = 12;
#line 234
    tmp___1 = kmalloc((unsigned long )npages * 8UL, 208U);
#line 234
    dma_list = (u64 *)tmp___1;
#line 235
    if ((unsigned long )dma_list == (unsigned long )((u64 *)0ULL)) {
#line 236
      return (-12);
    } else {

    }
#line 238
    tmp___2 = kmalloc((unsigned long )npages * 16UL, 208U);
#line 238
    buf->page_list = (struct mthca_buf_list *)tmp___2;
#line 240
    if ((unsigned long )buf->page_list == (unsigned long )((struct mthca_buf_list *)0)) {
#line 241
      goto err_out;
    } else {

    }
#line 243
    i = 0;
#line 243
    goto ldv_30210;
    ldv_30209: 
#line 244
    (buf->page_list + (unsigned long )i)->buf = (void *)0;
#line 243
    i = i + 1;
    ldv_30210: ;
#line 243
    if (i < npages) {
#line 245
      goto ldv_30209;
    } else {

    }
#line 246
    i = 0;
#line 246
    goto ldv_30213;
    ldv_30212: 
#line 247
    (buf->page_list + (unsigned long )i)->buf = dma_alloc_attrs(& (dev->pdev)->dev,
                                                                4096UL, & t, 208U,
                                                                (struct dma_attrs *)0);
#line 250
    if ((unsigned long )(buf->page_list + (unsigned long )i)->buf == (unsigned long )((void *)0)) {
#line 251
      goto err_free;
    } else {

    }
#line 253
    *(dma_list + (unsigned long )i) = t;
#line 254
    (buf->page_list + (unsigned long )i)->mapping = t;
#line 256
    clear_page((buf->page_list + (unsigned long )i)->buf);
#line 246
    i = i + 1;
    ldv_30213: ;
#line 246
    if (i < npages) {
#line 248
      goto ldv_30212;
    } else {

    }

  }
#line 260
  err = mthca_mr_alloc_phys(dev, pd->pd_num, dma_list, shift, npages, 0ULL, (u64 )size,
                            hca_write != 0 ? 3072U : 1024U, mr);
#line 266
  if (err != 0) {
#line 267
    goto err_free;
  } else {

  }
#line 269
  kfree((void const   *)dma_list);
#line 271
  return (0);
  err_free: 
#line 274
  mthca_buf_free(dev, size, buf, *is_direct, (struct mthca_mr *)0);
  err_out: 
#line 277
  kfree((void const   *)dma_list);
#line 279
  return (err);
}
}
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.c"
void mthca_buf_free(struct mthca_dev *dev , int size , union mthca_buf *buf , int is_direct ,
                    struct mthca_mr *mr ) 
{ 
  int i ;

  {
#line 287
  if ((unsigned long )mr != (unsigned long )((struct mthca_mr *)0)) {
#line 288
    mthca_free_mr(dev, mr);
  } else {

  }
#line 290
  if (is_direct != 0) {
#line 291
    dma_free_attrs(& (dev->pdev)->dev, (size_t )size, buf->direct.buf, buf->direct.mapping,
                   (struct dma_attrs *)0);
  } else {
#line 294
    i = 0;
#line 294
    goto ldv_30224;
    ldv_30223: 
#line 295
    dma_free_attrs(& (dev->pdev)->dev, 4096UL, (buf->page_list + (unsigned long )i)->buf,
                   (buf->page_list + (unsigned long )i)->mapping, (struct dma_attrs *)0);
#line 294
    i = i + 1;
    ldv_30224: ;
#line 294
    if ((unsigned long )i < ((unsigned long )size + 4095UL) / 4096UL) {
#line 296
      goto ldv_30223;
    } else {

    }
#line 299
    kfree((void const   *)buf->page_list);
  }
#line 301
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.o.c.prepared"
bool ldv_queue_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.o.c.prepared"
bool ldv_queue_delayed_work_on_66(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.o.c.prepared"
bool ldv_queue_work_on_67(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.o.c.prepared"
void ldv_flush_workqueue_68(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_allocator.o.c.prepared"
bool ldv_queue_delayed_work_on_69(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 405 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 41 "include/linux/err.h"
__inline static bool IS_ERR(void const   *ptr ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_79(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_81(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_80(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_83(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_82(struct workqueue_struct *ldv_func_arg1 ) ;
#line 91 "./arch/x86/include/asm/io.h"
__inline static void writeq(unsigned long val , void volatile   *addr ) 
{ 


  {
#line 91
  __asm__  volatile   ("movq %0,%1": : "r" (val), "m" (*((unsigned long volatile   *)addr)): "memory");
#line 92
  return;
}
}
#line 322 "include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 325 "include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 327
  tmp = alloc_pages_current(gfp_mask, order);
#line 327
  return (tmp);
}
}
#line 366
extern void __free_pages(struct page * , unsigned int  ) ;
#line 127 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 132 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 135
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 135
  return (tmp);
}
}
#line 146
extern void free_irq(unsigned int  , void * ) ;
#line 924 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 926
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 73 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 75
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 42
extern void debug_dma_mapping_error(struct device * , dma_addr_t  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 30 "./arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops ;
#line 32 "./arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 76 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 80
  tmp = get_dma_ops(dev);
#line 80
  ops = tmp;
#line 83
  tmp___0 = lowmem_page_address((struct page  const  *)page);
#line 83
  kmemcheck_mark_initialized(tmp___0 + offset, (unsigned int )size);
#line 84
  tmp___1 = valid_dma_direction((int )dir);
#line 84
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 84
  if (tmp___2 != 0L) {
#line 84
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (84), "i" (12UL));
    ldv_28000: ;
#line 84
    goto ldv_28000;
  } else {

  }
#line 85
  addr = (*(ops->map_page))(dev, page, offset, size, dir, (struct dma_attrs *)0);
#line 86
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, 0);
#line 88
  return (addr);
}
}
#line 91 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 94
  tmp = get_dma_ops(dev);
#line 94
  ops = tmp;
#line 96
  tmp___0 = valid_dma_direction((int )dir);
#line 96
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 96
  if (tmp___1 != 0L) {
#line 96
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (96), "i" (12UL));
    ldv_28008: ;
#line 96
    goto ldv_28008;
  } else {

  }
#line 97
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 98
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)0);
  } else {

  }
#line 99
  debug_dma_unmap_page(dev, addr, size, (int )dir, 0);
#line 100
  return;
}
}
#line 47 "./arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;

  {
#line 49
  tmp = get_dma_ops(dev);
#line 49
  ops = tmp;
#line 50
  debug_dma_mapping_error(dev, dma_addr);
#line 51
  if ((unsigned long )ops->mapping_error != (unsigned long )((int (*)(struct device * ,
                                                                      dma_addr_t  ))0)) {
#line 52
    tmp___0 = (*(ops->mapping_error))(dev, dma_addr);
#line 52
    return (tmp___0);
  } else {

  }
#line 54
  return (dma_addr == 0ULL);
}
}
#line 31 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle ) 
{ 


  {
#line 34
  dma_free_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                 size, vaddr, dma_handle, (struct dma_attrs *)0);
#line 35
  return;
}
}
#line 51 "include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_page(struct pci_dev *hwdev , struct page *page ,
                                        unsigned long offset , size_t size , int direction ) 
{ 
  dma_addr_t tmp ;

  {
#line 54
  tmp = dma_map_page((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                     page, offset, size, (enum dma_data_direction )direction);
#line 54
  return (tmp);
}
}
#line 58 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_page(struct pci_dev *hwdev , dma_addr_t dma_address ,
                                    size_t size , int direction ) 
{ 


  {
#line 61
  dma_unmap_page((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                 dma_address, size, (enum dma_data_direction )direction);
#line 62
  return;
}
}
#line 107 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_dma_mapping_error(struct pci_dev *pdev , dma_addr_t dma_addr ) 
{ 
  int tmp ;

  {
#line 109
  tmp = dma_mapping_error(& pdev->dev, dma_addr);
#line 109
  return (tmp);
}
}
#line 1815 "include/rdma/ib_verbs.h"
extern void ib_dispatch_event(struct ib_event * ) ;
#line 59 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_doorbell.h"
__inline static void mthca_write64(u32 hi , u32 lo , void *dest , spinlock_t *doorbell_lock ) 
{ 
  __u64 tmp ;

  {
#line 62
  tmp = __fswab64(((unsigned long long )hi << 32) | (unsigned long long )lo);
#line 62
  writeq((unsigned long )tmp, (void volatile   *)dest);
#line 63
  return;
}
}
#line 503 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
void mthca_cq_completion(struct mthca_dev *dev , u32 cqn ) ;
#line 504
void mthca_cq_event(struct mthca_dev *dev , u32 cqn , enum ib_event_type event_type ) ;
#line 519
void mthca_srq_event(struct mthca_dev *dev , u32 srqn , enum ib_event_type event_type ) ;
#line 527
void mthca_qp_event(struct mthca_dev *dev , u32 qpn , enum ib_event_type event_type ) ;
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
__inline static u64 async_mask(struct mthca_dev *dev ) 
{ 


  {
#line 168
  return ((dev->mthca_flags & 4UL) != 0UL ? 2049022ULL : 214014ULL);
}
}
#line 173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
__inline static void tavor_set_eq_ci(struct mthca_dev *dev , struct mthca_eq *eq ,
                                     u32 ci ) 
{ 


  {
#line 183
  __asm__  volatile   ("sfence": : : "memory");
#line 184
  mthca_write64((u32 )(eq->eqn | 67108864), (u32 )(eq->nent + -1) & ci, dev->kar + 40UL,
                (spinlock_t *)0);
#line 186
  return;
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
__inline static void arbel_set_eq_ci(struct mthca_dev *dev , struct mthca_eq *eq ,
                                     u32 ci ) 
{ 
  __u32 tmp ;

  {
#line 192
  __asm__  volatile   ("sfence": : : "memory");
#line 193
  tmp = __fswab32(ci);
#line 193
  __writel(tmp, (void volatile   *)dev->eq_regs.arbel.eq_set_ci_base + (unsigned long )(eq->eqn * 8));
#line 196
  __asm__  volatile   ("mfence": : : "memory");
#line 197
  return;
}
}
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
__inline static void set_eq_ci(struct mthca_dev *dev , struct mthca_eq *eq , u32 ci ) 
{ 
  int tmp ;

  {
#line 201
  tmp = mthca_is_memfree(dev);
#line 201
  if (tmp != 0) {
#line 202
    arbel_set_eq_ci(dev, eq, ci);
  } else {
#line 204
    tavor_set_eq_ci(dev, eq, ci);
  }
#line 205
  return;
}
}
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
__inline static void tavor_eq_req_not(struct mthca_dev *dev , int eqn ) 
{ 


  {
#line 209
  mthca_write64((u32 )(eqn | 33554432), 0U, dev->kar + 40UL, (spinlock_t *)0);
#line 211
  return;
}
}
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
__inline static void arbel_eq_req_not(struct mthca_dev *dev , u32 eqn_mask ) 
{ 


  {
#line 216
  writel(eqn_mask, (void volatile   *)dev->eq_regs.arbel.eq_arm);
#line 217
  return;
}
}
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
__inline static void disarm_cq(struct mthca_dev *dev , int eqn , int cqn ) 
{ 
  int tmp ;

  {
#line 221
  tmp = mthca_is_memfree(dev);
#line 221
  if (tmp == 0) {
#line 222
    mthca_write64((u32 )(eqn | 50331648), (u32 )cqn, dev->kar + 40UL, (spinlock_t *)0);
  } else {

  }
#line 224
  return;
}
}
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
__inline static struct mthca_eqe *get_eqe(struct mthca_eq *eq , u32 entry ) 
{ 
  unsigned long off ;

  {
#line 230
  off = (unsigned long )(((u32 )(eq->nent + -1) & entry) * 32U);
#line 231
  return ((struct mthca_eqe *)((eq->page_list + off / 4096UL)->buf + (off & 4095UL)));
}
}
#line 234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
__inline static struct mthca_eqe *next_eqe_sw(struct mthca_eq *eq ) 
{ 
  struct mthca_eqe *eqe ;

  {
#line 237
  eqe = get_eqe(eq, eq->cons_index);
#line 238
  return ((int )((signed char )eqe->owner) >= 0 ? eqe : (struct mthca_eqe *)0);
}
}
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
__inline static void set_eqe_hw(struct mthca_eqe *eqe ) 
{ 


  {
#line 243
  eqe->owner = 128U;
#line 244
  return;
}
}
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
static void port_change(struct mthca_dev *dev , int port , int active ) 
{ 
  struct ib_event record ;

  {
#line 250
  if (mthca_debug_level != 0) {
#line 250
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Port change to %s for port %d\n",
               active != 0 ? (char *)"active" : (char *)"down", port);
  } else {

  }
#line 253
  record.device = & dev->ib_dev;
#line 254
  record.event = active != 0 ? 9 : 10;
#line 255
  record.element.port_num = (u8 )port;
#line 257
  ib_dispatch_event(& record);
#line 258
  return;
}
}
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
static int mthca_eq_int(struct mthca_dev *dev , struct mthca_eq *eq ) 
{ 
  struct mthca_eqe *eqe ;
  int disarm_cqn ;
  int eqes_found ;
  int set_ci ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u64 tmp___9 ;
  __u16 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;
  long tmp___14 ;

  {
#line 264
  eqes_found = 0;
#line 265
  set_ci = 0;
#line 267
  goto ldv_32078;
  ldv_32077: 
#line 272
  __asm__  volatile   ("lfence": : : "memory");
#line 274
  switch ((int )eqe->type) {
  case 0: 
#line 276
  tmp = __fswab32(eqe->event.comp.cqn);
#line 276
  disarm_cqn = (int )tmp & 16777215;
#line 277
  disarm_cq(dev, eq->eqn, disarm_cqn);
#line 278
  mthca_cq_completion(dev, (u32 )disarm_cqn);
#line 279
  goto ldv_32058;
  case 1: 
#line 282
  tmp___0 = __fswab32(eqe->event.qp.qpn);
#line 282
  mthca_qp_event(dev, tmp___0 & 16777215U, 6);
#line 284
  goto ldv_32058;
  case 2: 
#line 287
  tmp___1 = __fswab32(eqe->event.qp.qpn);
#line 287
  mthca_qp_event(dev, tmp___1 & 16777215U, 4);
#line 289
  goto ldv_32058;
  case 3: 
#line 292
  tmp___2 = __fswab32(eqe->event.qp.qpn);
#line 292
  mthca_qp_event(dev, tmp___2 & 16777215U, 5);
#line 294
  goto ldv_32058;
  case 19: 
#line 297
  tmp___3 = __fswab32(eqe->event.qp.qpn);
#line 297
  mthca_qp_event(dev, tmp___3 & 16777215U, 16);
#line 299
  goto ldv_32058;
  case 20: 
#line 302
  tmp___4 = __fswab32(eqe->event.srq.srqn);
#line 302
  mthca_srq_event(dev, tmp___4 & 16777215U, 15);
#line 304
  goto ldv_32058;
  case 5: 
#line 307
  tmp___5 = __fswab32(eqe->event.qp.qpn);
#line 307
  mthca_qp_event(dev, tmp___5 & 16777215U, 1);
#line 309
  goto ldv_32058;
  case 7: 
#line 312
  tmp___6 = __fswab32(eqe->event.qp.qpn);
#line 312
  mthca_qp_event(dev, tmp___6 & 16777215U, 7);
#line 314
  goto ldv_32058;
  case 16: 
#line 317
  tmp___7 = __fswab32(eqe->event.qp.qpn);
#line 317
  mthca_qp_event(dev, tmp___7 & 16777215U, 2);
#line 319
  goto ldv_32058;
  case 17: 
#line 322
  tmp___8 = __fswab32(eqe->event.qp.qpn);
#line 322
  mthca_qp_event(dev, tmp___8 & 16777215U, 3);
#line 324
  goto ldv_32058;
  case 10: 
#line 327
  tmp___9 = __fswab64(eqe->event.cmd.out_param);
#line 327
  tmp___10 = __fswab16((int )eqe->event.cmd.token);
#line 327
  mthca_cmd_event(dev, (int )tmp___10, (int )eqe->event.cmd.status, tmp___9);
#line 331
  goto ldv_32058;
  case 9: 
#line 334
  tmp___11 = __fswab32(eqe->event.port_change.port);
#line 334
  port_change(dev, (int )(tmp___11 >> 28) & 3, (unsigned int )eqe->subtype == 4U);
#line 337
  goto ldv_32058;
  case 4: 
#line 340
  tmp___12 = __fswab32(eqe->event.cq_err.cqn);
#line 340
  dev_warn((struct device  const  *)(& (dev->pdev)->dev), "CQ %s on CQN %06x\n", (unsigned int )eqe->event.cq_err.syndrome == 1U ? (char *)"overrun" : (char *)"access violation",
           tmp___12 & 16777215U);
#line 344
  tmp___13 = __fswab32(eqe->event.cq_err.cqn);
#line 344
  mthca_cq_event(dev, tmp___13, 0);
#line 346
  goto ldv_32058;
  case 15: 
#line 349
  dev_warn((struct device  const  *)(& (dev->pdev)->dev), "EQ overrun on EQN %d\n",
           eq->eqn);
#line 350
  goto ldv_32058;
  case 6: ;
  case 18: ;
  case 8: ;
  case 14: ;
  default: 
#line 357
  dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Unhandled event %02x(%02x) on EQ %d\n",
           (int )eqe->type, (int )eqe->subtype, eq->eqn);
#line 359
  goto ldv_32058;
  }
  ldv_32058: 
#line 362
  set_eqe_hw(eqe);
#line 363
  eq->cons_index = eq->cons_index + 1U;
#line 364
  eqes_found = 1;
#line 365
  set_ci = set_ci + 1;
#line 374
  tmp___14 = ldv__builtin_expect(set_ci > 127, 0L);
#line 374
  if (tmp___14 != 0L) {
#line 379
    set_eq_ci(dev, eq, eq->cons_index);
#line 380
    set_ci = 0;
  } else {

  }
  ldv_32078: 
#line 267
  eqe = next_eqe_sw(eq);
#line 267
  if ((unsigned long )eqe != (unsigned long )((struct mthca_eqe *)0)) {
#line 269
    goto ldv_32077;
  } else {

  }

#line 388
  return (eqes_found);
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
static irqreturn_t mthca_tavor_interrupt(int irq , void *dev_ptr ) 
{ 
  struct mthca_dev *dev ;
  u32 ecr ;
  int i ;
  int tmp ;

  {
#line 393
  dev = (struct mthca_dev *)dev_ptr;
#line 397
  if (dev->eq_table.clr_mask != 0U) {
#line 398
    writel(dev->eq_table.clr_mask, (void volatile   *)dev->eq_table.clr_int);
  } else {

  }
#line 400
  ecr = readl((void const volatile   *)dev->eq_regs.tavor.ecr_base + 4U);
#line 401
  if (ecr == 0U) {
#line 402
    return (0);
  } else {

  }
#line 404
  writel(ecr, (void volatile   *)dev->eq_regs.tavor.ecr_base + 12U);
#line 407
  i = 0;
#line 407
  goto ldv_32088;
  ldv_32087: ;
#line 408
  if ((dev->eq_table.eq[i].eqn_mask & ecr) != 0U) {
#line 409
    tmp = mthca_eq_int(dev, (struct mthca_eq *)(& dev->eq_table.eq) + (unsigned long )i);
#line 409
    if (tmp != 0) {
#line 410
      tavor_set_eq_ci(dev, (struct mthca_eq *)(& dev->eq_table.eq) + (unsigned long )i,
                      dev->eq_table.eq[i].cons_index);
    } else {

    }
#line 412
    tavor_eq_req_not(dev, dev->eq_table.eq[i].eqn);
  } else {

  }
#line 407
  i = i + 1;
  ldv_32088: ;
#line 407
  if (i <= 2) {
#line 409
    goto ldv_32087;
  } else {

  }

#line 415
  return (1);
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
static irqreturn_t mthca_tavor_msi_x_interrupt(int irq , void *eq_ptr ) 
{ 
  struct mthca_eq *eq ;
  struct mthca_dev *dev ;

  {
#line 420
  eq = (struct mthca_eq *)eq_ptr;
#line 421
  dev = eq->dev;
#line 423
  mthca_eq_int(dev, eq);
#line 424
  tavor_set_eq_ci(dev, eq, eq->cons_index);
#line 425
  tavor_eq_req_not(dev, eq->eqn);
#line 428
  return (1);
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
static irqreturn_t mthca_arbel_interrupt(int irq , void *dev_ptr ) 
{ 
  struct mthca_dev *dev ;
  int work ;
  int i ;
  int tmp ;

  {
#line 433
  dev = (struct mthca_dev *)dev_ptr;
#line 434
  work = 0;
#line 437
  if (dev->eq_table.clr_mask != 0U) {
#line 438
    writel(dev->eq_table.clr_mask, (void volatile   *)dev->eq_table.clr_int);
  } else {

  }
#line 440
  i = 0;
#line 440
  goto ldv_32104;
  ldv_32103: 
#line 441
  tmp = mthca_eq_int(dev, (struct mthca_eq *)(& dev->eq_table.eq) + (unsigned long )i);
#line 441
  if (tmp != 0) {
#line 442
    work = 1;
#line 443
    arbel_set_eq_ci(dev, (struct mthca_eq *)(& dev->eq_table.eq) + (unsigned long )i,
                    dev->eq_table.eq[i].cons_index);
  } else {

  }
#line 440
  i = i + 1;
  ldv_32104: ;
#line 440
  if (i <= 2) {
#line 442
    goto ldv_32103;
  } else {

  }
#line 447
  arbel_eq_req_not(dev, dev->eq_table.arm_mask);
#line 449
  return (work != 0);
}
}
#line 452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
static irqreturn_t mthca_arbel_msi_x_interrupt(int irq , void *eq_ptr ) 
{ 
  struct mthca_eq *eq ;
  struct mthca_dev *dev ;

  {
#line 454
  eq = (struct mthca_eq *)eq_ptr;
#line 455
  dev = eq->dev;
#line 457
  mthca_eq_int(dev, eq);
#line 458
  arbel_set_eq_ci(dev, eq, eq->cons_index);
#line 459
  arbel_eq_req_not(dev, eq->eqn_mask);
#line 462
  return (1);
}
}
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
static int mthca_create_eq(struct mthca_dev *dev , int nent , u8 intr , struct mthca_eq *eq ) 
{ 
  int npages ;
  u64 *dma_list ;
  dma_addr_t t ;
  struct mthca_mailbox *mailbox ;
  struct mthca_eq_context *eq_context ;
  int err ;
  int i ;
  int _max1 ;
  int _max2 ;
  unsigned long tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  bool tmp___2 ;
  struct mthca_eqe *tmp___3 ;
  u32 tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  int tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;

  {
#line 471
  dma_list = (u64 *)0ULL;
#line 475
  err = -12;
#line 478
  eq->dev = dev;
#line 479
  _max1 = nent;
#line 479
  _max2 = 2;
#line 479
  tmp = __roundup_pow_of_two((unsigned long )(_max1 > _max2 ? _max1 : _max2));
#line 479
  eq->nent = (int )tmp;
#line 480
  npages = (int )((unsigned long )((eq->nent * 32 + 4095) & -4096) / 4096UL);
#line 482
  tmp___0 = kmalloc((unsigned long )npages * 16UL, 208U);
#line 482
  eq->page_list = (struct mthca_buf_list *)tmp___0;
#line 484
  if ((unsigned long )eq->page_list == (unsigned long )((struct mthca_buf_list *)0)) {
#line 485
    goto err_out;
  } else {

  }
#line 487
  i = 0;
#line 487
  goto ldv_32343;
  ldv_32342: 
#line 488
  (eq->page_list + (unsigned long )i)->buf = (void *)0;
#line 487
  i = i + 1;
  ldv_32343: ;
#line 487
  if (i < npages) {
#line 489
    goto ldv_32342;
  } else {

  }
#line 490
  tmp___1 = kmalloc((unsigned long )npages * 8UL, 208U);
#line 490
  dma_list = (u64 *)tmp___1;
#line 491
  if ((unsigned long )dma_list == (unsigned long )((u64 *)0ULL)) {
#line 492
    goto err_out_free;
  } else {

  }
#line 494
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 495
  tmp___2 = IS_ERR((void const   *)mailbox);
#line 495
  if ((int )tmp___2) {
#line 496
    goto err_out_free;
  } else {

  }
#line 497
  eq_context = (struct mthca_eq_context *)mailbox->buf;
#line 499
  i = 0;
#line 499
  goto ldv_32348;
  ldv_32347: 
#line 500
  (eq->page_list + (unsigned long )i)->buf = dma_alloc_attrs(& (dev->pdev)->dev, 4096UL,
                                                             & t, 208U, (struct dma_attrs *)0);
#line 502
  if ((unsigned long )(eq->page_list + (unsigned long )i)->buf == (unsigned long )((void *)0)) {
#line 503
    goto err_out_free_pages;
  } else {

  }
#line 505
  *(dma_list + (unsigned long )i) = t;
#line 506
  (eq->page_list + (unsigned long )i)->mapping = t;
#line 508
  clear_page((eq->page_list + (unsigned long )i)->buf);
#line 499
  i = i + 1;
  ldv_32348: ;
#line 499
  if (i < npages) {
#line 501
    goto ldv_32347;
  } else {

  }
#line 511
  i = 0;
#line 511
  goto ldv_32351;
  ldv_32350: 
#line 512
  tmp___3 = get_eqe(eq, (u32 )i);
#line 512
  set_eqe_hw(tmp___3);
#line 511
  i = i + 1;
  ldv_32351: ;
#line 511
  if (eq->nent > i) {
#line 513
    goto ldv_32350;
  } else {

  }
#line 514
  tmp___4 = mthca_alloc(& dev->eq_table.alloc);
#line 514
  eq->eqn = (int )tmp___4;
#line 515
  if (eq->eqn == -1) {
#line 516
    goto err_out_free_pages;
  } else {

  }
#line 518
  err = mthca_mr_alloc_phys(dev, dev->driver_pd.pd_num, dma_list, 12, npages, 0ULL,
                            (u64 )((unsigned long )npages * 4096UL), 3072U, & eq->mr);
#line 524
  if (err != 0) {
#line 525
    goto err_out_free_eq;
  } else {

  }
#line 527
  memset((void *)eq_context, 0, 64UL);
#line 528
  eq_context->flags = 66561U;
#line 532
  tmp___5 = mthca_is_memfree(dev);
#line 532
  if (tmp___5 != 0) {
#line 533
    eq_context->flags = eq_context->flags | 524288U;
  } else {

  }
#line 535
  tmp___6 = ffs(eq->nent);
#line 535
  tmp___7 = __fswab32((__u32 )((tmp___6 + -1) << 24));
#line 535
  eq_context->logsize_usrpage = tmp___7;
#line 536
  tmp___11 = mthca_is_memfree(dev);
#line 536
  if (tmp___11 != 0) {
#line 537
    tmp___8 = __fswab32(dev->driver_pd.pd_num);
#line 537
    eq_context->arbel_pd = tmp___8;
  } else {
#line 539
    tmp___9 = __fswab32((__u32 )dev->driver_uar.index);
#line 539
    eq_context->logsize_usrpage = eq_context->logsize_usrpage | tmp___9;
#line 540
    tmp___10 = __fswab32(dev->driver_pd.pd_num);
#line 540
    eq_context->tavor_pd = tmp___10;
  }
#line 542
  eq_context->intr = intr;
#line 543
  tmp___12 = __fswab32(eq->mr.ibmr.lkey);
#line 543
  eq_context->lkey = tmp___12;
#line 545
  err = mthca_SW2HW_EQ(dev, mailbox, eq->eqn);
#line 546
  if (err != 0) {
#line 547
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "SW2HW_EQ returned %d\n",
             err);
#line 548
    goto err_out_free_mr;
  } else {

  }
#line 551
  kfree((void const   *)dma_list);
#line 552
  mthca_free_mailbox(dev, mailbox);
#line 554
  tmp___13 = __fswab32((__u32 )(1 << eq->eqn));
#line 554
  eq->eqn_mask = tmp___13;
#line 555
  eq->cons_index = 0U;
#line 557
  dev->eq_table.arm_mask = dev->eq_table.arm_mask | eq->eqn_mask;
#line 559
  if (mthca_debug_level != 0) {
#line 559
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Allocated EQ %d with %d entries\n",
               eq->eqn, eq->nent);
  } else {

  }
#line 562
  return (err);
  err_out_free_mr: 
#line 565
  mthca_free_mr(dev, & eq->mr);
  err_out_free_eq: 
#line 568
  mthca_free(& dev->eq_table.alloc, (u32 )eq->eqn);
  err_out_free_pages: 
#line 571
  i = 0;
#line 571
  goto ldv_32356;
  ldv_32355: ;
#line 572
  if ((unsigned long )(eq->page_list + (unsigned long )i)->buf != (unsigned long )((void *)0)) {
#line 573
    dma_free_attrs(& (dev->pdev)->dev, 4096UL, (eq->page_list + (unsigned long )i)->buf,
                   (eq->page_list + (unsigned long )i)->mapping, (struct dma_attrs *)0);
  } else {

  }
#line 571
  i = i + 1;
  ldv_32356: ;
#line 571
  if (i < npages) {
#line 573
    goto ldv_32355;
  } else {

  }
#line 578
  mthca_free_mailbox(dev, mailbox);
  err_out_free: 
#line 581
  kfree((void const   *)eq->page_list);
#line 582
  kfree((void const   *)dma_list);
  err_out: ;
#line 585
  return (err);
}
}
#line 588 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
static void mthca_free_eq(struct mthca_dev *dev , struct mthca_eq *eq ) 
{ 
  struct mthca_mailbox *mailbox ;
  int err ;
  int npages ;
  int i ;
  bool tmp ;
  __u32 tmp___0 ;

  {
#line 593
  npages = (int )(((unsigned long )(eq->nent * 32) + 4095UL) / 4096UL);
#line 597
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 598
  tmp = IS_ERR((void const   *)mailbox);
#line 598
  if ((int )tmp) {
#line 599
    return;
  } else {

  }
#line 601
  err = mthca_HW2SW_EQ(dev, mailbox, eq->eqn);
#line 602
  if (err != 0) {
#line 603
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "HW2SW_EQ returned %d\n",
             err);
  } else {

  }
#line 605
  dev->eq_table.arm_mask = dev->eq_table.arm_mask & ~ eq->eqn_mask;
#line 607
  if (0) {
#line 608
    if (mthca_debug_level != 0) {
#line 608
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Dumping EQ context %02x:\n",
                 eq->eqn);
    } else {

    }
#line 609
    i = 0;
#line 609
    goto ldv_32367;
    ldv_32366: ;
#line 610
    if (((unsigned int )i & 3U) == 0U) {
#line 611
      printk("[%02x] ", i * 4);
    } else {

    }
#line 612
    tmp___0 = __be32_to_cpup((__be32 const   *)mailbox->buf + (unsigned long )(i * 4));
#line 612
    printk(" %08x", tmp___0);
#line 613
    if (((unsigned int )(i + 1) & 3U) == 0U) {
#line 614
      printk("\n");
    } else {

    }
#line 609
    i = i + 1;
    ldv_32367: ;
#line 609
    if ((unsigned int )i <= 15U) {
#line 611
      goto ldv_32366;
    } else {

    }

  } else {

  }
#line 618
  mthca_free_mr(dev, & eq->mr);
#line 619
  i = 0;
#line 619
  goto ldv_32370;
  ldv_32369: 
#line 620
  pci_free_consistent(dev->pdev, 4096UL, (eq->page_list + (unsigned long )i)->buf,
                      (eq->page_list + (unsigned long )i)->mapping);
#line 619
  i = i + 1;
  ldv_32370: ;
#line 619
  if (i < npages) {
#line 621
    goto ldv_32369;
  } else {

  }
#line 624
  kfree((void const   *)eq->page_list);
#line 625
  mthca_free_mailbox(dev, mailbox);
#line 626
  return;
}
}
#line 628 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
static void mthca_free_irqs(struct mthca_dev *dev ) 
{ 
  int i ;

  {
#line 632
  if (dev->eq_table.have_irq != 0) {
#line 633
    free_irq((dev->pdev)->irq, (void *)dev);
  } else {

  }
#line 634
  i = 0;
#line 634
  goto ldv_32377;
  ldv_32376: ;
#line 635
  if (dev->eq_table.eq[i].have_irq != 0) {
#line 636
    free_irq((unsigned int )dev->eq_table.eq[i].msi_x_vector, (void *)(& dev->eq_table.eq) + (unsigned long )i);
#line 638
    dev->eq_table.eq[i].have_irq = 0;
  } else {

  }
#line 634
  i = i + 1;
  ldv_32377: ;
#line 634
  if (i <= 2) {
#line 636
    goto ldv_32376;
  } else {

  }

#line 641
  return;
}
}
#line 642 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
static int mthca_map_reg(struct mthca_dev *dev , unsigned long offset , unsigned long size ,
                         void **map ) 
{ 
  phys_addr_t base ;

  {
#line 646
  base = (dev->pdev)->resource[0].start;
#line 648
  *map = ioremap(base + (unsigned long long )offset, size);
#line 649
  if ((unsigned long )*map == (unsigned long )((void *)0)) {
#line 650
    return (-12);
  } else {

  }
#line 652
  return (0);
}
}
#line 655 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
static int mthca_map_eq_regs(struct mthca_dev *dev ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 657
  tmp___4 = mthca_is_memfree(dev);
#line 657
  if (tmp___4 != 0) {
#line 665
    tmp = mthca_map_reg(dev, (unsigned long )(((dev->pdev)->resource[0].start != 0ULL || (dev->pdev)->resource[0].end != (dev->pdev)->resource[0].start ? (dev->pdev)->resource[0].end - (dev->pdev)->resource[0].start : 0xffffffffffffffffULL) & dev->fw.arbel.clr_int_base),
                        8UL, & dev->clr_base);
#line 665
    if (tmp != 0) {
#line 668
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "Couldn\'t map interrupt clear register, aborting.\n");
#line 670
      return (-12);
    } else {

    }
#line 677
    tmp___0 = mthca_map_reg(dev, (unsigned long )((((dev->pdev)->resource[0].start != 0ULL || (dev->pdev)->resource[0].end != (dev->pdev)->resource[0].start ? (dev->pdev)->resource[0].end - (dev->pdev)->resource[0].start : 0xffffffffffffffffULL) & dev->fw.arbel.eq_arm_base) + 4ULL),
                            4UL, & dev->eq_regs.arbel.eq_arm);
#line 677
    if (tmp___0 != 0) {
#line 680
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "Couldn\'t map EQ arm register, aborting.\n");
#line 681
      iounmap((void volatile   *)dev->clr_base);
#line 682
      return (-12);
    } else {

    }
#line 685
    tmp___1 = mthca_map_reg(dev, (unsigned long )(((dev->pdev)->resource[0].start != 0ULL || (dev->pdev)->resource[0].end != (dev->pdev)->resource[0].start ? (dev->pdev)->resource[0].end - (dev->pdev)->resource[0].start : 0xffffffffffffffffULL) & dev->fw.arbel.eq_set_ci_base),
                            256UL, & dev->eq_regs.arbel.eq_set_ci_base);
#line 685
    if (tmp___1 != 0) {
#line 689
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "Couldn\'t map EQ CI register, aborting.\n");
#line 690
      iounmap((void volatile   *)dev->eq_regs.arbel.eq_arm);
#line 691
      iounmap((void volatile   *)dev->clr_base);
#line 692
      return (-12);
    } else {

    }
  } else {
#line 695
    tmp___2 = mthca_map_reg(dev, 983256UL, 8UL, & dev->clr_base);
#line 695
    if (tmp___2 != 0) {
#line 697
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "Couldn\'t map interrupt clear register, aborting.\n");
#line 699
      return (-12);
    } else {

    }
#line 702
    tmp___3 = mthca_map_reg(dev, 526080UL, 16UL, & dev->eq_regs.tavor.ecr_base);
#line 702
    if (tmp___3 != 0) {
#line 705
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "Couldn\'t map ecr register, aborting.\n");
#line 707
      iounmap((void volatile   *)dev->clr_base);
#line 708
      return (-12);
    } else {

    }
  }
#line 712
  return (0);
}
}
#line 716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
static void mthca_unmap_eq_regs(struct mthca_dev *dev ) 
{ 
  int tmp ;

  {
#line 718
  tmp = mthca_is_memfree(dev);
#line 718
  if (tmp != 0) {
#line 719
    iounmap((void volatile   *)dev->eq_regs.arbel.eq_set_ci_base);
#line 720
    iounmap((void volatile   *)dev->eq_regs.arbel.eq_arm);
#line 721
    iounmap((void volatile   *)dev->clr_base);
  } else {
#line 723
    iounmap((void volatile   *)dev->eq_regs.tavor.ecr_base);
#line 724
    iounmap((void volatile   *)dev->clr_base);
  }
#line 726
  return;
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
int mthca_map_eq_icm(struct mthca_dev *dev , u64 icm_virt ) 
{ 
  int ret ;
  int tmp ;

  {
#line 738
  dev->eq_table.icm_virt = icm_virt;
#line 739
  dev->eq_table.icm_page = alloc_pages(131282U, 0U);
#line 740
  if ((unsigned long )dev->eq_table.icm_page == (unsigned long )((struct page *)0)) {
#line 741
    return (-12);
  } else {

  }
#line 742
  dev->eq_table.icm_dma = pci_map_page(dev->pdev, dev->eq_table.icm_page, 0UL, 4096UL,
                                       0);
#line 744
  tmp = pci_dma_mapping_error(dev->pdev, dev->eq_table.icm_dma);
#line 744
  if (tmp != 0) {
#line 745
    __free_pages(dev->eq_table.icm_page, 0U);
#line 746
    return (-12);
  } else {

  }
#line 749
  ret = mthca_MAP_ICM_page(dev, dev->eq_table.icm_dma, icm_virt);
#line 750
  if (ret != 0) {
#line 751
    pci_unmap_page(dev->pdev, dev->eq_table.icm_dma, 4096UL, 0);
#line 753
    __free_pages(dev->eq_table.icm_page, 0U);
  } else {

  }
#line 756
  return (ret);
}
}
#line 759 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
void mthca_unmap_eq_icm(struct mthca_dev *dev ) 
{ 


  {
#line 761
  mthca_UNMAP_ICM(dev, dev->eq_table.icm_virt, 1U);
#line 762
  pci_unmap_page(dev->pdev, dev->eq_table.icm_dma, 4096UL, 0);
#line 764
  __free_pages(dev->eq_table.icm_page, 0U);
#line 765
  return;
}
}
#line 767 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
int mthca_init_eq_table(struct mthca_dev *dev ) 
{ 
  int err ;
  u8 intr ;
  int i ;
  __u32 tmp ;
  char const   *eq_name[3U] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  u64 tmp___4 ;
  int tmp___5 ;

  {
#line 773
  err = mthca_alloc_init(& dev->eq_table.alloc, (u32 )dev->limits.num_eqs, (u32 )(dev->limits.num_eqs + -1),
                         (u32 )dev->limits.reserved_eqs);
#line 777
  if (err != 0) {
#line 778
    return (err);
  } else {

  }
#line 780
  err = mthca_map_eq_regs(dev);
#line 781
  if (err != 0) {
#line 782
    goto err_out_free;
  } else {

  }
#line 784
  if ((dev->mthca_flags & 8UL) != 0UL) {
#line 785
    dev->eq_table.clr_mask = 0U;
  } else {
#line 787
    tmp = __fswab32((__u32 )(1 << ((int )dev->eq_table.inta_pin & 31)));
#line 787
    dev->eq_table.clr_mask = tmp;
#line 789
    dev->eq_table.clr_int = dev->clr_base + ((unsigned int )dev->eq_table.inta_pin <= 31U ? 4UL : 0UL);
  }
#line 793
  dev->eq_table.arm_mask = 0U;
#line 795
  intr = dev->eq_table.inta_pin;
#line 797
  err = mthca_create_eq(dev, dev->limits.num_cqs + 128, (dev->mthca_flags & 8UL) == 0UL ? (int )intr : 128,
                        (struct mthca_eq *)(& dev->eq_table.eq) + 2UL);
#line 800
  if (err != 0) {
#line 801
    goto err_out_unmap;
  } else {

  }
#line 803
  err = mthca_create_eq(dev, 256, (dev->mthca_flags & 8UL) == 0UL ? (int )intr : 129,
                        (struct mthca_eq *)(& dev->eq_table.eq) + 1UL);
#line 806
  if (err != 0) {
#line 807
    goto err_out_comp;
  } else {

  }
#line 809
  err = mthca_create_eq(dev, 256, (dev->mthca_flags & 8UL) == 0UL ? (int )intr : 130,
                        (struct mthca_eq *)(& dev->eq_table.eq));
#line 812
  if (err != 0) {
#line 813
    goto err_out_async;
  } else {

  }
#line 815
  if ((dev->mthca_flags & 8UL) != 0UL) {
#line 816
    eq_name[0] = "ib_mthca-cmd";
#line 816
    eq_name[1] = "ib_mthca-async";
#line 816
    eq_name[2] = "ib_mthca-comp";
#line 822
    i = 0;
#line 822
    goto ldv_32413;
    ldv_32412: 
#line 823
    tmp___0 = pci_name((struct pci_dev  const  *)dev->pdev);
#line 823
    snprintf((char *)(& dev->eq_table.eq[i].irq_name), 64UL, "%s@pci:%s", eq_name[i],
             tmp___0);
#line 827
    tmp___1 = mthca_is_memfree(dev);
#line 827
    err = request_irq((unsigned int )dev->eq_table.eq[i].msi_x_vector, tmp___1 != 0 ? & mthca_arbel_msi_x_interrupt : & mthca_tavor_msi_x_interrupt,
                      0UL, (char const   *)(& dev->eq_table.eq[i].irq_name), (void *)(& dev->eq_table.eq) + (unsigned long )i);
#line 833
    if (err != 0) {
#line 834
      goto err_out_cmd;
    } else {

    }
#line 835
    dev->eq_table.eq[i].have_irq = 1;
#line 822
    i = i + 1;
    ldv_32413: ;
#line 822
    if (i <= 2) {
#line 824
      goto ldv_32412;
    } else {

    }

  } else {
#line 838
    tmp___2 = pci_name((struct pci_dev  const  *)dev->pdev);
#line 838
    snprintf((char *)(& dev->eq_table.eq[0].irq_name), 64UL, "ib_mthca@pci:%s", tmp___2);
#line 840
    tmp___3 = mthca_is_memfree(dev);
#line 840
    err = request_irq((dev->pdev)->irq, tmp___3 != 0 ? & mthca_arbel_interrupt : & mthca_tavor_interrupt,
                      128UL, (char const   *)(& dev->eq_table.eq[0].irq_name), (void *)dev);
#line 845
    if (err != 0) {
#line 846
      goto err_out_cmd;
    } else {

    }
#line 847
    dev->eq_table.have_irq = 1;
  }
#line 850
  tmp___4 = async_mask(dev);
#line 850
  err = mthca_MAP_EQ(dev, tmp___4, 0, dev->eq_table.eq[1].eqn);
#line 852
  if (err != 0) {
#line 853
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "MAP_EQ for async EQ %d failed (%d)\n",
             dev->eq_table.eq[1].eqn, err);
  } else {

  }
#line 856
  err = mthca_MAP_EQ(dev, 1024ULL, 0, dev->eq_table.eq[0].eqn);
#line 858
  if (err != 0) {
#line 859
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "MAP_EQ for cmd EQ %d failed (%d)\n",
             dev->eq_table.eq[0].eqn, err);
  } else {

  }
#line 862
  i = 0;
#line 862
  goto ldv_32416;
  ldv_32415: 
#line 863
  tmp___5 = mthca_is_memfree(dev);
#line 863
  if (tmp___5 != 0) {
#line 864
    arbel_eq_req_not(dev, dev->eq_table.eq[i].eqn_mask);
  } else {
#line 866
    tavor_eq_req_not(dev, dev->eq_table.eq[i].eqn);
  }
#line 862
  i = i + 1;
  ldv_32416: ;
#line 862
  if (i <= 2) {
#line 864
    goto ldv_32415;
  } else {

  }

#line 868
  return (0);
  err_out_cmd: 
#line 871
  mthca_free_irqs(dev);
#line 872
  mthca_free_eq(dev, (struct mthca_eq *)(& dev->eq_table.eq));
  err_out_async: 
#line 875
  mthca_free_eq(dev, (struct mthca_eq *)(& dev->eq_table.eq) + 1UL);
  err_out_comp: 
#line 878
  mthca_free_eq(dev, (struct mthca_eq *)(& dev->eq_table.eq) + 2UL);
  err_out_unmap: 
#line 881
  mthca_unmap_eq_regs(dev);
  err_out_free: 
#line 884
  mthca_alloc_cleanup(& dev->eq_table.alloc);
#line 885
  return (err);
}
}
#line 888 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.c"
void mthca_cleanup_eq_table(struct mthca_dev *dev ) 
{ 
  int i ;
  u64 tmp ;

  {
#line 892
  mthca_free_irqs(dev);
#line 894
  tmp = async_mask(dev);
#line 894
  mthca_MAP_EQ(dev, tmp, 1, dev->eq_table.eq[1].eqn);
#line 896
  mthca_MAP_EQ(dev, 1024ULL, 1, dev->eq_table.eq[0].eqn);
#line 899
  i = 0;
#line 899
  goto ldv_32423;
  ldv_32422: 
#line 900
  mthca_free_eq(dev, (struct mthca_eq *)(& dev->eq_table.eq) + (unsigned long )i);
#line 899
  i = i + 1;
  ldv_32423: ;
#line 899
  if (i <= 2) {
#line 901
    goto ldv_32422;
  } else {

  }
#line 902
  mthca_unmap_eq_regs(dev);
#line 904
  mthca_alloc_cleanup(& dev->eq_table.alloc);
#line 905
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.o.c.prepared"
bool ldv_queue_work_on_79(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.o.c.prepared"
bool ldv_queue_delayed_work_on_80(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.o.c.prepared"
bool ldv_queue_work_on_81(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.o.c.prepared"
void ldv_flush_workqueue_82(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_eq.o.c.prepared"
bool ldv_queue_delayed_work_on_83(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_93(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_95(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_94(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_97(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_96(struct workqueue_struct *ldv_func_arg1 ) ;
#line 473 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
int mthca_mr_alloc_notrans(struct mthca_dev *dev , u32 pd , u32 access , struct mthca_mr *mr ) ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_pd.c"
int mthca_pd_alloc(struct mthca_dev *dev , int privileged , struct mthca_pd *pd ) 
{ 
  int err ;

  {
#line 41
  err = 0;
#line 43
  pd->privileged = privileged;
#line 45
  atomic_set(& pd->sqp_count, 0);
#line 46
  pd->pd_num = mthca_alloc(& dev->pd_table.alloc);
#line 47
  if (pd->pd_num == 4294967295U) {
#line 48
    return (-12);
  } else {

  }
#line 50
  if (privileged != 0) {
#line 51
    err = mthca_mr_alloc_notrans(dev, pd->pd_num, 3072U, & pd->ntmr);
#line 55
    if (err != 0) {
#line 56
      mthca_free(& dev->pd_table.alloc, pd->pd_num);
    } else {

    }
  } else {

  }
#line 59
  return (err);
}
}
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_pd.c"
void mthca_pd_free(struct mthca_dev *dev , struct mthca_pd *pd ) 
{ 


  {
#line 64
  if (pd->privileged != 0) {
#line 65
    mthca_free_mr(dev, & pd->ntmr);
  } else {

  }
#line 66
  mthca_free(& dev->pd_table.alloc, pd->pd_num);
#line 67
  return;
}
}
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_pd.c"
int mthca_init_pd_table(struct mthca_dev *dev ) 
{ 
  int tmp ;

  {
#line 71
  tmp = mthca_alloc_init(& dev->pd_table.alloc, (u32 )dev->limits.num_pds, 16777215U,
                         (u32 )dev->limits.reserved_pds);
#line 71
  return (tmp);
}
}
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_pd.c"
void mthca_cleanup_pd_table(struct mthca_dev *dev ) 
{ 


  {
#line 80
  mthca_alloc_cleanup(& dev->pd_table.alloc);
#line 81
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_pd.o.c.prepared"
bool ldv_queue_work_on_93(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_pd.o.c.prepared"
bool ldv_queue_delayed_work_on_94(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_pd.o.c.prepared"
bool ldv_queue_work_on_95(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_pd.o.c.prepared"
void ldv_flush_workqueue_96(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_pd.o.c.prepared"
bool ldv_queue_delayed_work_on_97(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 158 "include/linux/byteorder/generic.h"
__inline static void be16_add_cpu(__be16 *var , u16 val ) 
{ 
  __u16 tmp ;
  __u16 tmp___0 ;

  {
#line 160
  tmp = __fswab16((int )*var);
#line 160
  tmp___0 = __fswab16((int )tmp + (int )val);
#line 160
  *var = tmp___0;
#line 161
  return;
}
}
#line 178 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 41 "include/linux/err.h"
__inline static bool IS_ERR(void const   *ptr ) ;
#line 31 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
#line 340 "include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
#line 342
  _raw_spin_lock_irq(& lock->__annonCompField18.rlock);
#line 343
  return;
}
}
#line 365 "include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
#line 367
  _raw_spin_unlock_irq(& lock->__annonCompField18.rlock);
#line 368
  return;
}
}
#line 149 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 926
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 927
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_107(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_109(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_108(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_111(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_110(struct workqueue_struct *ldv_func_arg1 ) ;
#line 11 "include/linux/hardirq.h"
extern void synchronize_irq(unsigned int  ) ;
#line 324 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_cq *to_mcq(struct ib_cq *ibcq ) 
{ 
  struct ib_cq  const  *__mptr ;

  {
#line 326
  __mptr = (struct ib_cq  const  *)ibcq;
#line 326
  return ((struct mthca_cq *)__mptr);
}
}
#line 329 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_srq *to_msrq(struct ib_srq *ibsrq ) 
{ 
  struct ib_srq  const  *__mptr ;

  {
#line 331
  __mptr = (struct ib_srq  const  *)ibsrq;
#line 331
  return ((struct mthca_srq *)__mptr);
}
}
#line 65 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_doorbell.h"
__inline static void mthca_write_db_rec(__be32 *val , __be32 *db ) 
{ 


  {
#line 67
  *((u64 *)db) = *((u64 *)val);
#line 68
  return;
}
}
#line 494 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
int mthca_poll_cq(struct ib_cq *ibcq , int num_entries , struct ib_wc *entry ) ;
#line 496
int mthca_tavor_arm_cq(struct ib_cq *cq , enum ib_cq_notify_flags flags ) ;
#line 497
int mthca_arbel_arm_cq(struct ib_cq *ibcq , enum ib_cq_notify_flags flags ) ;
#line 498
int mthca_init_cq(struct mthca_dev *dev , int nent , struct mthca_ucontext *ctx ,
                  u32 pdn , struct mthca_cq *cq ) ;
#line 501
void mthca_free_cq(struct mthca_dev *dev , struct mthca_cq *cq ) ;
#line 506
void mthca_cq_clean(struct mthca_dev *dev , struct mthca_cq *cq , u32 qpn , struct mthca_srq *srq ) ;
#line 508
void mthca_cq_resize_copy_cqes(struct mthca_cq *cq ) ;
#line 509
int mthca_alloc_cq_buf(struct mthca_dev *dev , struct mthca_cq_buf *buf , int nent ) ;
#line 510
void mthca_free_cq_buf(struct mthca_dev *dev , struct mthca_cq_buf *buf , int cqe ) ;
#line 521
void mthca_free_srq_wqe(struct mthca_srq *srq , u32 wqe_addr ) ;
#line 541
void mthca_free_err_wqe(struct mthca_dev *dev , struct mthca_qp *qp , int is_send ,
                        int index , int *dbd , __be32 *new_wqe ) ;
#line 587 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
__inline static struct mthca_dev *to_mdev(struct ib_device *ibdev ) 
{ 
  struct ib_device  const  *__mptr ;

  {
#line 589
  __mptr = (struct ib_device  const  *)ibdev;
#line 589
  return ((struct mthca_dev *)__mptr);
}
}
#line 91 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
int mthca_table_get(struct mthca_dev *dev , struct mthca_icm_table *table , int obj ) ;
#line 92
void mthca_table_put(struct mthca_dev *dev , struct mthca_icm_table *table , int obj ) ;
#line 175
int mthca_alloc_db(struct mthca_dev *dev , enum mthca_db_type type , u32 qn , __be32 **db ) ;
#line 177
void mthca_free_db(struct mthca_dev *dev , int type , int db_index ) ;
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
__inline static struct mthca_cqe *get_cqe_from_buf(struct mthca_cq_buf *buf , int entry ) 
{ 


  {
#line 162
  if (buf->is_direct != 0) {
#line 163
    return ((struct mthca_cqe *)buf->queue.direct.buf + (unsigned long )(entry * 32));
  } else {
#line 165
    return ((struct mthca_cqe *)((buf->queue.page_list + (unsigned long )(entry * 32) / 4096UL)->buf + ((unsigned long )(entry * 32) & 4095UL)));
  }
}
}
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
__inline static struct mthca_cqe *get_cqe(struct mthca_cq *cq , int entry ) 
{ 
  struct mthca_cqe *tmp ;

  {
#line 171
  tmp = get_cqe_from_buf(& cq->buf, entry);
#line 171
  return (tmp);
}
}
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
__inline static struct mthca_cqe *cqe_sw(struct mthca_cqe *cqe ) 
{ 


  {
#line 176
  return ((int )((signed char )cqe->owner) >= 0 ? cqe : (struct mthca_cqe *)0);
}
}
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
__inline static struct mthca_cqe *next_cqe_sw(struct mthca_cq *cq ) 
{ 
  struct mthca_cqe *tmp ;
  struct mthca_cqe *tmp___0 ;

  {
#line 181
  tmp = get_cqe(cq, (int )(cq->cons_index & (u32 )cq->ibcq.cqe));
#line 181
  tmp___0 = cqe_sw(tmp);
#line 181
  return (tmp___0);
}
}
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
__inline static void set_cqe_hw(struct mthca_cqe *cqe ) 
{ 


  {
#line 186
  cqe->owner = 128U;
#line 187
  return;
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
static void dump_cqe(struct mthca_dev *dev , void *cqe_ptr ) 
{ 
  __be32 *cqe ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;

  {
#line 191
  cqe = (__be32 *)cqe_ptr;
#line 194
  if (mthca_debug_level != 0) {
#line 194
    tmp = __fswab32(*(cqe + 7UL));
#line 194
    tmp___0 = __fswab32(*(cqe + 6UL));
#line 194
    tmp___1 = __fswab32(*(cqe + 5UL));
#line 194
    tmp___2 = __fswab32(*(cqe + 4UL));
#line 194
    tmp___3 = __fswab32(*(cqe + 3UL));
#line 194
    tmp___4 = __fswab32(*(cqe + 2UL));
#line 194
    tmp___5 = __fswab32(*(cqe + 1UL));
#line 194
    tmp___6 = __fswab32(*cqe);
#line 194
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "CQE contents %08x %08x %08x %08x %08x %08x %08x %08x\n",
               tmp___6, tmp___5, tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, tmp);
  } else {

  }
#line 195
  return;
}
}
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
__inline static void update_cons_index(struct mthca_dev *dev , struct mthca_cq *cq ,
                                       int incr ) 
{ 
  __u32 tmp ;
  int tmp___0 ;

  {
#line 207
  tmp___0 = mthca_is_memfree(dev);
#line 207
  if (tmp___0 != 0) {
#line 208
    tmp = __fswab32(cq->cons_index);
#line 208
    *(cq->set_ci_db) = tmp;
#line 209
    __asm__  volatile   ("sfence": : : "memory");
  } else {
#line 211
    mthca_write64((u32 )(cq->cqn | 16777216), (u32 )(incr + -1), dev->kar + 32UL,
                  (spinlock_t *)0);
#line 218
    __asm__  volatile   ("": : : "memory");
  }
#line 220
  return;
}
}
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
void mthca_cq_completion(struct mthca_dev *dev , u32 cqn ) 
{ 
  struct mthca_cq *cq ;
  void *tmp ;

  {
#line 226
  tmp = mthca_array_get(& dev->cq_table.cq, (int )((u32 )(dev->limits.num_cqs + -1) & cqn));
#line 226
  cq = (struct mthca_cq *)tmp;
#line 228
  if ((unsigned long )cq == (unsigned long )((struct mthca_cq *)0)) {
#line 229
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Completion event for bogus CQ %08x\n",
             cqn);
#line 230
    return;
  } else {

  }
#line 233
  cq->arm_sn = cq->arm_sn + 1;
#line 235
  (*(cq->ibcq.comp_handler))(& cq->ibcq, cq->ibcq.cq_context);
#line 236
  return;
}
}
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
void mthca_cq_event(struct mthca_dev *dev , u32 cqn , enum ib_event_type event_type ) 
{ 
  struct mthca_cq *cq ;
  struct ib_event event ;
  void *tmp ;

  {
#line 244
  spin_lock(& dev->cq_table.lock);
#line 246
  tmp = mthca_array_get(& dev->cq_table.cq, (int )((u32 )(dev->limits.num_cqs + -1) & cqn));
#line 246
  cq = (struct mthca_cq *)tmp;
#line 247
  if ((unsigned long )cq != (unsigned long )((struct mthca_cq *)0)) {
#line 248
    cq->refcount = cq->refcount + 1;
  } else {

  }
#line 250
  spin_unlock(& dev->cq_table.lock);
#line 252
  if ((unsigned long )cq == (unsigned long )((struct mthca_cq *)0)) {
#line 253
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Async event for bogus CQ %08x\n",
             cqn);
#line 254
    return;
  } else {

  }
#line 257
  event.device = & dev->ib_dev;
#line 258
  event.event = event_type;
#line 259
  event.element.cq = & cq->ibcq;
#line 260
  if ((unsigned long )cq->ibcq.event_handler != (unsigned long )((void (*)(struct ib_event * ,
                                                                           void * ))0)) {
#line 261
    (*(cq->ibcq.event_handler))(& event, cq->ibcq.cq_context);
  } else {

  }
#line 263
  spin_lock(& dev->cq_table.lock);
#line 264
  cq->refcount = cq->refcount - 1;
#line 264
  if (cq->refcount == 0) {
#line 265
    __wake_up(& cq->wait, 3U, 1, (void *)0);
  } else {

  }
#line 266
  spin_unlock(& dev->cq_table.lock);
#line 267
  return;
}
}
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
__inline static int is_recv_cqe(struct mthca_cqe *cqe ) 
{ 


  {
#line 271
  if (((int )cqe->opcode & 254) == 254) {
#line 273
    return (((int )cqe->opcode & 1) == 0);
  } else {
#line 275
    return ((int )((signed char )cqe->is_send) >= 0);
  }
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
void mthca_cq_clean(struct mthca_dev *dev , struct mthca_cq *cq , u32 qpn , struct mthca_srq *srq ) 
{ 
  struct mthca_cqe *cqe ;
  u32 prod_index ;
  int i ;
  int nfreed ;
  struct mthca_cqe *tmp ;
  struct mthca_cqe *tmp___0 ;
  __u32 tmp___1 ;
  int tmp___2 ;
  struct mthca_cqe *tmp___3 ;
  __u32 tmp___4 ;
  struct mthca_cqe *tmp___5 ;

  {
#line 283
  nfreed = 0;
#line 285
  spin_lock_irq(& cq->lock);
#line 294
  prod_index = cq->cons_index;
#line 294
  goto ldv_31823;
  ldv_31822: ;
#line 297
  if (cq->cons_index + (u32 )cq->ibcq.cqe == prod_index) {
#line 298
    goto ldv_31821;
  } else {

  }
#line 296
  prod_index = prod_index + 1U;
  ldv_31823: 
#line 294
  tmp = get_cqe(cq, (int )((u32 )cq->ibcq.cqe & prod_index));
#line 294
  tmp___0 = cqe_sw(tmp);
#line 294
  if ((unsigned long )tmp___0 != (unsigned long )((struct mthca_cqe *)0)) {
#line 297
    goto ldv_31822;
  } else {

  }
  ldv_31821: ;
#line 308
  goto ldv_31825;
  ldv_31824: 
#line 309
  cqe = get_cqe(cq, (int )((u32 )cq->ibcq.cqe & prod_index));
#line 310
  tmp___4 = __fswab32(qpn);
#line 310
  if (cqe->my_qpn == tmp___4) {
#line 311
    if ((unsigned long )srq != (unsigned long )((struct mthca_srq *)0)) {
#line 311
      tmp___2 = is_recv_cqe(cqe);
#line 311
      if (tmp___2 != 0) {
#line 312
        tmp___1 = __fswab32(cqe->wqe);
#line 312
        mthca_free_srq_wqe(srq, tmp___1);
      } else {

      }
    } else {

    }
#line 313
    nfreed = nfreed + 1;
  } else
#line 314
  if (nfreed != 0) {
#line 315
    tmp___3 = get_cqe(cq, (int )((prod_index + (u32 )nfreed) & (u32 )cq->ibcq.cqe));
#line 315
    memcpy((void *)tmp___3, (void const   *)cqe, 32UL);
  } else {

  }
  ldv_31825: 
#line 308
  prod_index = prod_index - 1U;
#line 308
  if ((int )prod_index - (int )cq->cons_index >= 0) {
#line 310
    goto ldv_31824;
  } else {

  }

#line 319
  if (nfreed != 0) {
#line 320
    i = 0;
#line 320
    goto ldv_31828;
    ldv_31827: 
#line 321
    tmp___5 = get_cqe(cq, (int )((cq->cons_index + (u32 )i) & (u32 )cq->ibcq.cqe));
#line 321
    set_cqe_hw(tmp___5);
#line 320
    i = i + 1;
    ldv_31828: ;
#line 320
    if (i < nfreed) {
#line 322
      goto ldv_31827;
    } else {

    }
#line 322
    __asm__  volatile   ("sfence": : : "memory");
#line 323
    cq->cons_index = cq->cons_index + (u32 )nfreed;
#line 324
    update_cons_index(dev, cq, nfreed);
  } else {

  }
#line 327
  spin_unlock_irq(& cq->lock);
#line 328
  return;
}
}
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
void mthca_cq_resize_copy_cqes(struct mthca_cq *cq ) 
{ 
  int i ;
  struct mthca_cqe *tmp ;
  struct mthca_cqe *tmp___0 ;
  struct mthca_dev *tmp___1 ;
  int tmp___2 ;
  struct mthca_cqe *tmp___3 ;
  struct mthca_cqe *tmp___4 ;
  struct mthca_cqe *tmp___5 ;
  struct mthca_cqe *tmp___6 ;

  {
#line 340
  tmp___1 = to_mdev(cq->ibcq.device);
#line 340
  tmp___2 = mthca_is_memfree(tmp___1);
#line 340
  if (tmp___2 == 0 && cq->ibcq.cqe < (cq->resize_buf)->cqe) {
#line 342
    cq->cons_index = cq->cons_index & (u32 )cq->ibcq.cqe;
#line 343
    tmp = get_cqe(cq, cq->ibcq.cqe);
#line 343
    tmp___0 = cqe_sw(tmp);
#line 343
    if ((unsigned long )tmp___0 != (unsigned long )((struct mthca_cqe *)0)) {
#line 344
      cq->cons_index = cq->cons_index + (u32 )(~ cq->ibcq.cqe);
    } else {

    }
  } else {

  }
#line 347
  i = (int )cq->cons_index;
#line 347
  goto ldv_31835;
  ldv_31834: 
#line 348
  tmp___3 = get_cqe(cq, cq->ibcq.cqe & i);
#line 348
  tmp___4 = get_cqe_from_buf(& (cq->resize_buf)->buf, (cq->resize_buf)->cqe & i);
#line 348
  memcpy((void *)tmp___4, (void const   *)tmp___3, 32UL);
#line 347
  i = i + 1;
  ldv_31835: 
#line 347
  tmp___5 = get_cqe(cq, cq->ibcq.cqe & i);
#line 347
  tmp___6 = cqe_sw(tmp___5);
#line 347
  if ((unsigned long )tmp___6 != (unsigned long )((struct mthca_cqe *)0)) {
#line 349
    goto ldv_31834;
  } else {

  }

#line 354
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
int mthca_alloc_cq_buf(struct mthca_dev *dev , struct mthca_cq_buf *buf , int nent ) 
{ 
  int ret ;
  int i ;
  struct mthca_cqe *tmp ;

  {
#line 358
  ret = mthca_buf_alloc(dev, nent * 32, 16384, & buf->queue, & buf->is_direct, & dev->driver_pd,
                        1, & buf->mr);
#line 362
  if (ret != 0) {
#line 363
    return (ret);
  } else {

  }
#line 365
  i = 0;
#line 365
  goto ldv_31845;
  ldv_31844: 
#line 366
  tmp = get_cqe_from_buf(buf, i);
#line 366
  set_cqe_hw(tmp);
#line 365
  i = i + 1;
  ldv_31845: ;
#line 365
  if (i < nent) {
#line 367
    goto ldv_31844;
  } else {

  }

#line 368
  return (0);
}
}
#line 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
void mthca_free_cq_buf(struct mthca_dev *dev , struct mthca_cq_buf *buf , int cqe ) 
{ 


  {
#line 373
  mthca_buf_free(dev, (cqe + 1) * 32, & buf->queue, buf->is_direct, & buf->mr);
#line 375
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
static void handle_error_cqe(struct mthca_dev *dev , struct mthca_cq *cq , struct mthca_qp *qp ,
                             int wqe_index , int is_send , struct mthca_err_cqe *cqe ,
                             struct ib_wc *entry , int *free_cqe ) 
{ 
  int dbd ;
  __be32 new_wqe ;
  __u32 tmp ;
  __u32 tmp___0 ;
  int tmp___1 ;

  {
#line 385
  if ((unsigned int )cqe->syndrome == 2U) {
#line 386
    if (mthca_debug_level != 0) {
#line 386
      tmp = __fswab32(cqe->wqe);
#line 386
      tmp___0 = __fswab32(cqe->my_qpn);
#line 386
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "local QP operation err (QPN %06x, WQE @ %08x, CQN %06x, index %d)\n",
                 tmp___0, tmp, cq->cqn, cq->cons_index);
    } else {

    }
#line 390
    dump_cqe(dev, (void *)cqe);
  } else {

  }
#line 397
  switch ((int )cqe->syndrome) {
  case 1: 
#line 399
  entry->status = 1;
#line 400
  goto ldv_31865;
  case 2: 
#line 402
  entry->status = 2;
#line 403
  goto ldv_31865;
  case 3: 
#line 405
  entry->status = 3;
#line 406
  goto ldv_31865;
  case 4: 
#line 408
  entry->status = 4;
#line 409
  goto ldv_31865;
  case 5: 
#line 411
  entry->status = 5;
#line 412
  goto ldv_31865;
  case 6: 
#line 414
  entry->status = 6;
#line 415
  goto ldv_31865;
  case 16: 
#line 417
  entry->status = 7;
#line 418
  goto ldv_31865;
  case 17: 
#line 420
  entry->status = 8;
#line 421
  goto ldv_31865;
  case 18: 
#line 423
  entry->status = 9;
#line 424
  goto ldv_31865;
  case 19: 
#line 426
  entry->status = 10;
#line 427
  goto ldv_31865;
  case 20: 
#line 429
  entry->status = 11;
#line 430
  goto ldv_31865;
  case 21: 
#line 432
  entry->status = 12;
#line 433
  goto ldv_31865;
  case 22: 
#line 435
  entry->status = 13;
#line 436
  goto ldv_31865;
  case 32: 
#line 438
  entry->status = 14;
#line 439
  goto ldv_31865;
  case 33: 
#line 441
  entry->status = 15;
#line 442
  goto ldv_31865;
  case 34: 
#line 444
  entry->status = 16;
#line 445
  goto ldv_31865;
  case 35: 
#line 447
  entry->status = 17;
#line 448
  goto ldv_31865;
  case 36: 
#line 450
  entry->status = 18;
#line 451
  goto ldv_31865;
  default: 
#line 453
  entry->status = 21;
#line 454
  goto ldv_31865;
  }
  ldv_31865: 
#line 457
  entry->vendor_err = (u32 )cqe->vendor_err;
#line 463
  tmp___1 = mthca_is_memfree(dev);
#line 463
  if (tmp___1 != 0) {
#line 464
    return;
  } else {

  }
#line 466
  mthca_free_err_wqe(dev, qp, is_send, wqe_index, & dbd, & new_wqe);
#line 473
  if ((new_wqe & 1056964608U) == 0U || ((unsigned int )cqe->db_cnt == 0U && dbd != 0)) {
#line 474
    return;
  } else {

  }
#line 476
  be16_add_cpu(& cqe->db_cnt, - ((int )((u16 )dbd)));
#line 477
  cqe->wqe = new_wqe;
#line 478
  cqe->syndrome = 5U;
#line 480
  *free_cqe = 0;
#line 481
  return;
}
}
#line 483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
__inline static int mthca_poll_one(struct mthca_dev *dev , struct mthca_cq *cq , struct mthca_qp **cur_qp ,
                                   int *freed , struct ib_wc *entry ) 
{ 
  struct mthca_wq *wq ;
  struct mthca_cqe *cqe ;
  int wqe_index ;
  int is_error ;
  int is_send ;
  int free_cqe ;
  int err ;
  u16 checksum ;
  __u32 tmp___1 ;
  void *tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  struct mthca_srq *srq ;
  struct mthca_srq *tmp___6 ;
  u32 wqe ;
  __u32 tmp___7 ;
  s32 wqe___0 ;
  __u32 tmp___8 ;
  long tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u16 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;
  __u32 tmp___15 ;
  __u32 tmp___16 ;
  long tmp___17 ;

  {
#line 494
  free_cqe = 1;
#line 495
  err = 0;
#line 498
  cqe = next_cqe_sw(cq);
#line 499
  if ((unsigned long )cqe == (unsigned long )((struct mthca_cqe *)0)) {
#line 500
    return (-11);
  } else {

  }
#line 506
  __asm__  volatile   ("lfence": : : "memory");
#line 515
  is_error = ((int )cqe->opcode & 254) == 254;
#line 517
  is_send = is_error != 0 ? (int )cqe->opcode & 1 : (int )cqe->is_send & 128;
#line 519
  if ((unsigned long )*cur_qp == (unsigned long )((struct mthca_qp *)0)) {
#line 519
    goto _L;
  } else {
#line 519
    tmp___4 = __fswab32(cqe->my_qpn);
#line 519
    if (tmp___4 != (*cur_qp)->qpn) {
      _L: /* CIL Label */ 
#line 525
      tmp___1 = __fswab32(cqe->my_qpn);
#line 525
      tmp___2 = mthca_array_get(& dev->qp_table.qp, (int )(tmp___1 & (unsigned int )(dev->limits.num_qps + -1)));
#line 525
      *cur_qp = (struct mthca_qp *)tmp___2;
#line 528
      if ((unsigned long )*cur_qp == (unsigned long )((struct mthca_qp *)0)) {
#line 529
        tmp___3 = __fswab32(cqe->my_qpn);
#line 529
        dev_warn((struct device  const  *)(& (dev->pdev)->dev), "CQ entry for unknown QP %06x\n",
                 tmp___3 & 16777215U);
#line 531
        err = -22;
#line 532
        goto out;
      } else {

      }
    } else {

    }
  }
#line 536
  entry->qp = & (*cur_qp)->ibqp;
#line 538
  if (is_send != 0) {
#line 539
    wq = & (*cur_qp)->sq;
#line 540
    tmp___5 = __fswab32(cqe->wqe);
#line 540
    wqe_index = (int )((tmp___5 - (unsigned int )(*cur_qp)->send_wqe_offset) >> wq->wqe_shift);
#line 542
    entry->wr_id = *((*cur_qp)->wrid + (unsigned long )((*cur_qp)->rq.max + wqe_index));
  } else
#line 544
  if ((unsigned long )(*cur_qp)->ibqp.srq != (unsigned long )((struct ib_srq *)0)) {
#line 545
    tmp___6 = to_msrq((*cur_qp)->ibqp.srq);
#line 545
    srq = tmp___6;
#line 546
    tmp___7 = __fswab32(cqe->wqe);
#line 546
    wqe = tmp___7;
#line 547
    wq = (struct mthca_wq *)0;
#line 548
    wqe_index = (int )(wqe >> srq->wqe_shift);
#line 549
    entry->wr_id = *(srq->wrid + (unsigned long )wqe_index);
#line 550
    mthca_free_srq_wqe(srq, wqe);
  } else {
#line 553
    wq = & (*cur_qp)->rq;
#line 554
    tmp___8 = __fswab32(cqe->wqe);
#line 554
    wqe___0 = (s32 )tmp___8;
#line 555
    wqe_index = wqe___0 >> wq->wqe_shift;
#line 561
    tmp___9 = ldv__builtin_expect(wqe_index < 0, 0L);
#line 561
    if (tmp___9 != 0L) {
#line 562
      wqe_index = wq->max + -1;
    } else {

    }
#line 563
    entry->wr_id = *((*cur_qp)->wrid + (unsigned long )wqe_index);
  }
#line 566
  if ((unsigned long )wq != (unsigned long )((struct mthca_wq *)0)) {
#line 567
    if (wq->last_comp < (unsigned int )wqe_index) {
#line 568
      wq->tail = wq->tail + ((unsigned int )wqe_index - wq->last_comp);
    } else {
#line 570
      wq->tail = wq->tail + ((unsigned int )(wq->max + wqe_index) - wq->last_comp);
    }
#line 572
    wq->last_comp = (unsigned int )wqe_index;
  } else {

  }
#line 575
  if (is_error != 0) {
#line 576
    handle_error_cqe(dev, cq, *cur_qp, wqe_index, is_send, (struct mthca_err_cqe *)cqe,
                     entry, & free_cqe);
#line 579
    goto out;
  } else {

  }
#line 582
  if (is_send != 0) {
#line 583
    entry->wc_flags = 0;
#line 584
    switch ((int )cqe->opcode) {
    case 8: 
#line 586
    entry->opcode = 1;
#line 587
    goto ldv_31904;
    case 9: 
#line 589
    entry->opcode = 1;
#line 590
    entry->wc_flags = entry->wc_flags | 2;
#line 591
    goto ldv_31904;
    case 10: 
#line 593
    entry->opcode = 0;
#line 594
    goto ldv_31904;
    case 11: 
#line 596
    entry->opcode = 0;
#line 597
    entry->wc_flags = entry->wc_flags | 2;
#line 598
    goto ldv_31904;
    case 16: 
#line 600
    entry->opcode = 2;
#line 601
    tmp___10 = __fswab32(cqe->byte_cnt);
#line 601
    entry->byte_len = tmp___10;
#line 602
    goto ldv_31904;
    case 17: 
#line 604
    entry->opcode = 3;
#line 605
    entry->byte_len = 8U;
#line 606
    goto ldv_31904;
    case 18: 
#line 608
    entry->opcode = 4;
#line 609
    entry->byte_len = 8U;
#line 610
    goto ldv_31904;
    case 24: 
#line 612
    entry->opcode = 5;
#line 613
    goto ldv_31904;
    default: 
#line 615
    entry->opcode = 255;
#line 616
    goto ldv_31904;
    }
    ldv_31904: ;
  } else {
#line 619
    tmp___11 = __fswab32(cqe->byte_cnt);
#line 619
    entry->byte_len = tmp___11;
#line 620
    switch ((int )cqe->opcode & 31) {
    case 3: ;
    case 5: 
#line 623
    entry->wc_flags = 2;
#line 624
    entry->ex.imm_data = cqe->imm_etype_pkey_eec;
#line 625
    entry->opcode = 128;
#line 626
    goto ldv_31915;
    case 9: ;
    case 11: 
#line 629
    entry->wc_flags = 2;
#line 630
    entry->ex.imm_data = cqe->imm_etype_pkey_eec;
#line 631
    entry->opcode = 129;
#line 632
    goto ldv_31915;
    default: 
#line 634
    entry->wc_flags = 0;
#line 635
    entry->opcode = 128;
#line 636
    goto ldv_31915;
    }
    ldv_31915: 
#line 638
    tmp___12 = __fswab16((int )cqe->rlid);
#line 638
    entry->slid = tmp___12;
#line 639
    entry->sl = (u8 )((int )cqe->sl_ipok >> 4);
#line 640
    tmp___13 = __fswab32(cqe->rqpn);
#line 640
    entry->src_qp = tmp___13 & 16777215U;
#line 641
    entry->dlid_path_bits = (unsigned int )cqe->g_mlpath & 127U;
#line 642
    tmp___14 = __fswab32(cqe->imm_etype_pkey_eec);
#line 642
    entry->pkey_index = (u16 )(tmp___14 >> 16);
#line 643
    entry->wc_flags = entry->wc_flags | ((int )((signed char )cqe->g_mlpath) < 0);
#line 644
    tmp___15 = __fswab32(cqe->rqpn);
#line 644
    tmp___16 = __fswab32(cqe->my_ee);
#line 644
    checksum = (unsigned int )((u16 )(tmp___15 >> 24)) | ((unsigned int )((u16 )(tmp___16 >> 16)) & 65280U);
#line 646
    entry->wc_flags = entry->wc_flags | ((int )cqe->sl_ipok & 1 && (unsigned int )checksum == 65535U ? 8 : 0);
  }
#line 650
  entry->status = 0;
  out: 
#line 653
  tmp___17 = ldv__builtin_expect(free_cqe != 0, 1L);
#line 653
  if (tmp___17 != 0L) {
#line 654
    set_cqe_hw(cqe);
#line 655
    *freed = *freed + 1;
#line 656
    cq->cons_index = cq->cons_index + 1U;
  } else {

  }
#line 659
  return (err);
}
}
#line 662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
int mthca_poll_cq(struct ib_cq *ibcq , int num_entries , struct ib_wc *entry ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_cq *cq ;
  struct mthca_cq *tmp___0 ;
  struct mthca_qp *qp ;
  unsigned long flags ;
  int err ;
  int freed ;
  int npolled ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  struct mthca_cq_buf tbuf ;
  int tcqe ;
  struct mthca_cqe *tmp___3 ;
  struct mthca_cqe *tmp___4 ;
  long tmp___5 ;

  {
#line 665
  tmp = to_mdev(ibcq->device);
#line 665
  dev = tmp;
#line 666
  tmp___0 = to_mcq(ibcq);
#line 666
  cq = tmp___0;
#line 667
  qp = (struct mthca_qp *)0;
#line 669
  err = 0;
#line 670
  freed = 0;
#line 673
  tmp___1 = spinlock_check(& cq->lock);
#line 673
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 675
  npolled = 0;
  repoll: ;
#line 677
  goto ldv_31937;
  ldv_31936: 
#line 678
  err = mthca_poll_one(dev, cq, & qp, & freed, entry + (unsigned long )npolled);
#line 680
  if (err != 0) {
#line 681
    goto ldv_31935;
  } else {

  }
#line 682
  npolled = npolled + 1;
  ldv_31937: ;
#line 677
  if (npolled < num_entries) {
#line 679
    goto ldv_31936;
  } else {

  }
  ldv_31935: ;
#line 685
  if (freed != 0) {
#line 686
    __asm__  volatile   ("sfence": : : "memory");
#line 687
    update_cons_index(dev, cq, freed);
  } else {

  }
#line 696
  tmp___5 = ldv__builtin_expect((long )((err == -11 && (unsigned long )cq->resize_buf != (unsigned long )((struct mthca_cq_resize *)0)) && (unsigned int )(cq->resize_buf)->state == 1U),
                             0L);
#line 696
  if (tmp___5 != 0L) {
#line 705
    tmp___2 = mthca_is_memfree(dev);
#line 705
    if (tmp___2 == 0) {
#line 706
      cq->cons_index = cq->cons_index & (u32 )cq->ibcq.cqe;
    } else {

    }
#line 708
    tmp___3 = get_cqe_from_buf(& (cq->resize_buf)->buf, (int )(cq->cons_index & (u32 )(cq->resize_buf)->cqe));
#line 708
    tmp___4 = cqe_sw(tmp___3);
#line 708
    if ((unsigned long )tmp___4 != (unsigned long )((struct mthca_cqe *)0)) {
#line 713
      tbuf = cq->buf;
#line 714
      tcqe = cq->ibcq.cqe;
#line 715
      cq->buf = (cq->resize_buf)->buf;
#line 716
      cq->ibcq.cqe = (cq->resize_buf)->cqe;
#line 718
      (cq->resize_buf)->buf = tbuf;
#line 719
      (cq->resize_buf)->cqe = tcqe;
#line 720
      (cq->resize_buf)->state = 2;
#line 722
      goto repoll;
    } else {

    }
  } else {

  }
#line 726
  spin_unlock_irqrestore(& cq->lock, flags);
#line 728
  return (err == 0 || err == -11 ? npolled : err);
}
}
#line 731 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
int mthca_tavor_arm_cq(struct ib_cq *cq , enum ib_cq_notify_flags flags ) 
{ 
  u32 dbhi ;
  struct mthca_cq *tmp ;
  struct mthca_dev *tmp___0 ;

  {
#line 733
  tmp = to_mcq(cq);
#line 733
  dbhi = (u32 )((((unsigned int )flags & 3U) == 1U ? 50331648 : 33554432) | tmp->cqn);
#line 738
  tmp___0 = to_mdev(cq->device);
#line 738
  mthca_write64(dbhi, 4294967295U, tmp___0->kar + 32UL, (spinlock_t *)0);
#line 741
  return (0);
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
int mthca_arbel_arm_cq(struct ib_cq *ibcq , enum ib_cq_notify_flags flags ) 
{ 
  struct mthca_cq *cq ;
  struct mthca_cq *tmp ;
  __be32 db_rec[2U] ;
  u32 dbhi ;
  u32 sn ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  struct mthca_dev *tmp___2 ;

  {
#line 746
  tmp = to_mcq(ibcq);
#line 746
  cq = tmp;
#line 749
  sn = (u32 )cq->arm_sn & 3U;
#line 751
  tmp___0 = __fswab32(cq->cons_index);
#line 751
  db_rec[0] = tmp___0;
#line 752
  tmp___1 = __fswab32((((u32 )(cq->cqn << 8) | (sn << 3)) | (((unsigned int )flags & 3U) == 1U ? 1U : 2U)) | 64U);
#line 752
  db_rec[1] = tmp___1;
#line 756
  mthca_write_db_rec((__be32 *)(& db_rec), cq->arm_db);
#line 762
  __asm__  volatile   ("sfence": : : "memory");
#line 764
  dbhi = ((sn << 28) | (((unsigned int )flags & 3U) == 1U ? 16777216U : 33554432U)) | (u32 )cq->cqn;
#line 769
  tmp___2 = to_mdev(ibcq->device);
#line 769
  mthca_write64(dbhi, cq->cons_index, tmp___2->kar + 32UL, (spinlock_t *)0);
#line 773
  return (0);
}
}
#line 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
int mthca_init_cq(struct mthca_dev *dev , int nent , struct mthca_ucontext *ctx ,
                  u32 pdn , struct mthca_cq *cq ) 
{ 
  struct mthca_mailbox *mailbox ;
  struct mthca_cq_context *cq_context ;
  int err ;
  u32 tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  int tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 782
  err = -12;
#line 784
  cq->ibcq.cqe = nent + -1;
#line 785
  cq->is_kernel = (unsigned long )ctx == (unsigned long )((struct mthca_ucontext *)0);
#line 787
  tmp = mthca_alloc(& dev->cq_table.alloc);
#line 787
  cq->cqn = (int )tmp;
#line 788
  if (cq->cqn == -1) {
#line 789
    return (-12);
  } else {

  }
#line 791
  tmp___0 = mthca_is_memfree(dev);
#line 791
  if (tmp___0 != 0) {
#line 792
    err = mthca_table_get(dev, dev->cq_table.table, cq->cqn);
#line 793
    if (err != 0) {
#line 794
      goto err_out;
    } else {

    }
#line 796
    if (cq->is_kernel != 0) {
#line 797
      cq->arm_sn = 1;
#line 799
      err = -12;
#line 801
      cq->set_ci_db_index = mthca_alloc_db(dev, 1, (u32 )cq->cqn, & cq->set_ci_db);
#line 803
      if (cq->set_ci_db_index < 0) {
#line 804
        goto err_out_icm;
      } else {

      }
#line 806
      cq->arm_db_index = mthca_alloc_db(dev, 2, (u32 )cq->cqn, & cq->arm_db);
#line 808
      if (cq->arm_db_index < 0) {
#line 809
        goto err_out_ci;
      } else {

      }
    } else {

    }
  } else {

  }
#line 813
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 814
  tmp___1 = IS_ERR((void const   *)mailbox);
#line 814
  if ((int )tmp___1) {
#line 815
    goto err_out_arm;
  } else {

  }
#line 817
  cq_context = (struct mthca_cq_context *)mailbox->buf;
#line 819
  if (cq->is_kernel != 0) {
#line 820
    err = mthca_alloc_cq_buf(dev, & cq->buf, nent);
#line 821
    if (err != 0) {
#line 822
      goto err_out_mailbox;
    } else {

    }
  } else {

  }
#line 825
  spinlock_check(& cq->lock);
#line 825
  __raw_spin_lock_init(& cq->lock.__annonCompField18.rlock, "&(&cq->lock)->rlock",
                       & __key);
#line 826
  cq->refcount = 1;
#line 827
  __init_waitqueue_head(& cq->wait, "&cq->wait", & __key___0);
#line 828
  __mutex_init(& cq->mutex, "&cq->mutex", & __key___1);
#line 830
  memset((void *)cq_context, 0, 64UL);
#line 831
  cq_context->flags = 1024U;
#line 834
  tmp___2 = ffs(nent);
#line 834
  tmp___3 = __fswab32((__u32 )((tmp___2 + -1) << 24));
#line 834
  cq_context->logsize_usrpage = tmp___3;
#line 835
  if ((unsigned long )ctx != (unsigned long )((struct mthca_ucontext *)0)) {
#line 836
    tmp___4 = __fswab32((__u32 )ctx->uar.index);
#line 836
    cq_context->logsize_usrpage = cq_context->logsize_usrpage | tmp___4;
  } else {
#line 838
    tmp___5 = __fswab32((__u32 )dev->driver_uar.index);
#line 838
    cq_context->logsize_usrpage = cq_context->logsize_usrpage | tmp___5;
  }
#line 839
  tmp___6 = __fswab32((__u32 )dev->eq_table.eq[1].eqn);
#line 839
  cq_context->error_eqn = tmp___6;
#line 840
  tmp___7 = __fswab32((__u32 )dev->eq_table.eq[2].eqn);
#line 840
  cq_context->comp_eqn = tmp___7;
#line 841
  tmp___8 = __fswab32(pdn);
#line 841
  cq_context->pd = tmp___8;
#line 842
  tmp___9 = __fswab32(cq->buf.mr.ibmr.lkey);
#line 842
  cq_context->lkey = tmp___9;
#line 843
  tmp___10 = __fswab32((__u32 )cq->cqn);
#line 843
  cq_context->cqn = tmp___10;
#line 845
  tmp___13 = mthca_is_memfree(dev);
#line 845
  if (tmp___13 != 0) {
#line 846
    tmp___11 = __fswab32((__u32 )cq->set_ci_db_index);
#line 846
    cq_context->ci_db = tmp___11;
#line 847
    tmp___12 = __fswab32((__u32 )cq->arm_db_index);
#line 847
    cq_context->state_db = tmp___12;
  } else {

  }
#line 850
  err = mthca_SW2HW_CQ(dev, mailbox, cq->cqn);
#line 851
  if (err != 0) {
#line 852
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "SW2HW_CQ failed (%d)\n",
             err);
#line 853
    goto err_out_free_mr;
  } else {

  }
#line 856
  spin_lock_irq(& dev->cq_table.lock);
#line 857
  tmp___14 = mthca_array_set(& dev->cq_table.cq, cq->cqn & (dev->limits.num_cqs + -1),
                             (void *)cq);
#line 857
  if (tmp___14 != 0) {
#line 860
    spin_unlock_irq(& dev->cq_table.lock);
#line 861
    goto err_out_free_mr;
  } else {

  }
#line 863
  spin_unlock_irq(& dev->cq_table.lock);
#line 865
  cq->cons_index = 0U;
#line 867
  mthca_free_mailbox(dev, mailbox);
#line 869
  return (0);
  err_out_free_mr: ;
#line 872
  if (cq->is_kernel != 0) {
#line 873
    mthca_free_cq_buf(dev, & cq->buf, cq->ibcq.cqe);
  } else {

  }
  err_out_mailbox: 
#line 876
  mthca_free_mailbox(dev, mailbox);
  err_out_arm: ;
#line 879
  if (cq->is_kernel != 0) {
#line 879
    tmp___15 = mthca_is_memfree(dev);
#line 879
    if (tmp___15 != 0) {
#line 880
      mthca_free_db(dev, 2, cq->arm_db_index);
    } else {

    }
  } else {

  }
  err_out_ci: ;
#line 883
  if (cq->is_kernel != 0) {
#line 883
    tmp___16 = mthca_is_memfree(dev);
#line 883
    if (tmp___16 != 0) {
#line 884
      mthca_free_db(dev, 1, cq->set_ci_db_index);
    } else {

    }
  } else {

  }
  err_out_icm: 
#line 887
  mthca_table_put(dev, dev->cq_table.table, cq->cqn);
  err_out: 
#line 890
  mthca_free(& dev->cq_table.alloc, (u32 )cq->cqn);
#line 892
  return (err);
}
}
#line 895 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
__inline static int get_cq_refcount(struct mthca_dev *dev , struct mthca_cq *cq ) 
{ 
  int c ;

  {
#line 899
  spin_lock_irq(& dev->cq_table.lock);
#line 900
  c = cq->refcount;
#line 901
  spin_unlock_irq(& dev->cq_table.lock);
#line 903
  return (c);
}
}
#line 906 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
void mthca_free_cq(struct mthca_dev *dev , struct mthca_cq *cq ) 
{ 
  struct mthca_mailbox *mailbox ;
  int err ;
  bool tmp ;
  __be32 *ctx ;
  int j ;
  struct mthca_cqe *tmp___0 ;
  int tmp___1 ;
  __u32 tmp___2 ;
  int tmp___3 ;
  wait_queue_t __wait ;
  long __ret ;
  long __int ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 912
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 913
  tmp = IS_ERR((void const   *)mailbox);
#line 913
  if ((int )tmp) {
#line 914
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "No memory for mailbox to free CQ.\n");
#line 915
    return;
  } else {

  }
#line 918
  err = mthca_HW2SW_CQ(dev, mailbox, cq->cqn);
#line 919
  if (err != 0) {
#line 920
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "HW2SW_CQ failed (%d)\n",
             err);
  } else {

  }
#line 922
  if (0) {
#line 923
    ctx = (__be32 *)mailbox->buf;
#line 926
    if (cq->is_kernel != 0) {
#line 926
      tmp___0 = next_cqe_sw(cq);
#line 926
      if ((unsigned long )tmp___0 != (unsigned long )((struct mthca_cqe *)0)) {
#line 926
        tmp___1 = 1;
      } else {
#line 926
        tmp___1 = 0;
      }
    } else {
#line 926
      tmp___1 = 0;
    }
#line 926
    printk("\vcontext for CQN %x (cons index %x, next sw %d)\n", cq->cqn, cq->cons_index,
           tmp___1);
#line 929
    j = 0;
#line 929
    goto ldv_31986;
    ldv_31985: 
#line 930
    tmp___2 = __fswab32(*(ctx + (unsigned long )j));
#line 930
    printk("\v[%2x] %08x\n", j * 4, tmp___2);
#line 929
    j = j + 1;
    ldv_31986: ;
#line 929
    if (j <= 15) {
#line 931
      goto ldv_31985;
    } else {

    }

  } else {

  }
#line 933
  spin_lock_irq(& dev->cq_table.lock);
#line 934
  mthca_array_clear(& dev->cq_table.cq, cq->cqn & (dev->limits.num_cqs + -1));
#line 936
  cq->refcount = cq->refcount - 1;
#line 937
  spin_unlock_irq(& dev->cq_table.lock);
#line 939
  if ((dev->mthca_flags & 8UL) != 0UL) {
#line 940
    synchronize_irq((unsigned int )dev->eq_table.eq[2].msi_x_vector);
  } else {
#line 942
    synchronize_irq((dev->pdev)->irq);
  }
#line 944
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c",
                944, 0);
#line 944
  tmp___3 = get_cq_refcount(dev, cq);
#line 944
  if (tmp___3 == 0) {
#line 944
    goto ldv_31988;
  } else {

  }
#line 944
  __ret = 0L;
#line 944
  INIT_LIST_HEAD(& __wait.task_list);
#line 944
  __wait.flags = 0U;
  ldv_31994: 
#line 944
  tmp___4 = prepare_to_wait_event(& cq->wait, & __wait, 2);
#line 944
  __int = tmp___4;
#line 944
  tmp___5 = get_cq_refcount(dev, cq);
#line 944
  if (tmp___5 == 0) {
#line 944
    goto ldv_31993;
  } else {

  }
#line 944
  schedule();
#line 944
  goto ldv_31994;
  ldv_31993: 
#line 944
  finish_wait(& cq->wait, & __wait);

  ldv_31988: ;
#line 946
  if (cq->is_kernel != 0) {
#line 947
    mthca_free_cq_buf(dev, & cq->buf, cq->ibcq.cqe);
#line 948
    tmp___6 = mthca_is_memfree(dev);
#line 948
    if (tmp___6 != 0) {
#line 949
      mthca_free_db(dev, 2, cq->arm_db_index);
#line 950
      mthca_free_db(dev, 1, cq->set_ci_db_index);
    } else {

    }
  } else {

  }
#line 954
  mthca_table_put(dev, dev->cq_table.table, cq->cqn);
#line 955
  mthca_free(& dev->cq_table.alloc, (u32 )cq->cqn);
#line 956
  mthca_free_mailbox(dev, mailbox);
#line 957
  return;
}
}
#line 959 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
int mthca_init_cq_table(struct mthca_dev *dev ) 
{ 
  int err ;
  struct lock_class_key __key ;

  {
#line 963
  spinlock_check(& dev->cq_table.lock);
#line 963
  __raw_spin_lock_init(& dev->cq_table.lock.__annonCompField18.rlock, "&(&dev->cq_table.lock)->rlock",
                       & __key);
#line 965
  err = mthca_alloc_init(& dev->cq_table.alloc, (u32 )dev->limits.num_cqs, 16777215U,
                         (u32 )dev->limits.reserved_cqs);
#line 969
  if (err != 0) {
#line 970
    return (err);
  } else {

  }
#line 972
  err = mthca_array_init(& dev->cq_table.cq, dev->limits.num_cqs);
#line 974
  if (err != 0) {
#line 975
    mthca_alloc_cleanup(& dev->cq_table.alloc);
  } else {

  }
#line 977
  return (err);
}
}
#line 980 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.c"
void mthca_cleanup_cq_table(struct mthca_dev *dev ) 
{ 


  {
#line 982
  mthca_array_cleanup(& dev->cq_table.cq, dev->limits.num_cqs);
#line 983
  mthca_alloc_cleanup(& dev->cq_table.alloc);
#line 984
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.o.c.prepared"
bool ldv_queue_work_on_107(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.o.c.prepared"
bool ldv_queue_delayed_work_on_108(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.o.c.prepared"
bool ldv_queue_work_on_109(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.o.c.prepared"
void ldv_flush_workqueue_110(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_cq.o.c.prepared"
bool ldv_queue_delayed_work_on_111(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 314 "./arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 437 "./arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ 
  int r ;

  {
#line 451
  __asm__  ("bsrl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 464
  return (r + 1);
}
}
#line 42 "include/asm-generic/bitops/find.h"
extern unsigned long find_first_bit(unsigned long const   * , unsigned long  ) ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 32
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_121(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_123(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_122(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_125(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_124(struct workqueue_struct *ldv_func_arg1 ) ;
#line 64 "./arch/x86/include/asm/io.h"
__inline static void writeb(unsigned char val , void volatile   *addr ) 
{ 


  {
#line 64
  __asm__  volatile   ("movb %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)): "memory");
#line 65
  return;
}
}
#line 221 "./arch/x86/include/asm/io.h"
__inline static void memcpy_toio(void volatile   *dst , void const   *src , size_t count ) 
{ 


  {
#line 223
  memcpy((void *)dst, src, count);
#line 224
  return;
}
}
#line 525 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 527
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 528
    return ((void *)0);
  } else {

  }
#line 529
  tmp = __kmalloc(n * size, flags);
#line 529
  return (tmp);
}
}
#line 538 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 540
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 540
  return (tmp);
}
}
#line 59 "include/linux/dma-debug.h"
extern void debug_dma_sync_single_for_cpu(struct device * , dma_addr_t  , size_t  ,
                                          int  ) ;
#line 63
extern void debug_dma_sync_single_for_device(struct device * , dma_addr_t  , size_t  ,
                                             int  ) ;
#line 102 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev , dma_addr_t addr ,
                                             size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 106
  tmp = get_dma_ops(dev);
#line 106
  ops = tmp;
#line 108
  tmp___0 = valid_dma_direction((int )dir);
#line 108
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 108
  if (tmp___1 != 0L) {
#line 108
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (108), "i" (12UL));
    ldv_26361: ;
#line 108
    goto ldv_26361;
  } else {

  }
#line 109
  if ((unsigned long )ops->sync_single_for_cpu != (unsigned long )((void (*)(struct device * ,
                                                                             dma_addr_t  ,
                                                                             size_t  ,
                                                                             enum dma_data_direction  ))0)) {
#line 110
    (*(ops->sync_single_for_cpu))(dev, addr, size, dir);
  } else {

  }
#line 111
  debug_dma_sync_single_for_cpu(dev, addr, size, (int )dir);
#line 112
  return;
}
}
#line 114 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev , dma_addr_t addr ,
                                                size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 118
  tmp = get_dma_ops(dev);
#line 118
  ops = tmp;
#line 120
  tmp___0 = valid_dma_direction((int )dir);
#line 120
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 120
  if (tmp___1 != 0L) {
#line 120
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (120), "i" (12UL));
    ldv_26369: ;
#line 120
    goto ldv_26369;
  } else {

  }
#line 121
  if ((unsigned long )ops->sync_single_for_device != (unsigned long )((void (*)(struct device * ,
                                                                                dma_addr_t  ,
                                                                                size_t  ,
                                                                                enum dma_data_direction  ))0)) {
#line 122
    (*(ops->sync_single_for_device))(dev, addr, size, dir);
  } else {

  }
#line 123
  debug_dma_sync_single_for_device(dev, addr, size, (int )dir);
#line 124
  return;
}
}
#line 304 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_fmr *to_mfmr(struct ib_fmr *ibmr ) 
{ 
  struct ib_fmr  const  *__mptr ;

  {
#line 306
  __mptr = (struct ib_fmr  const  *)ibmr;
#line 306
  return ((struct mthca_fmr *)__mptr);
}
}
#line 54 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_doorbell.h"
__inline static void mthca_write64_raw(__be64 val , void *dest ) 
{ 


  {
#line 56
  writeq((unsigned long )val, (void volatile   *)dest);
#line 57
  return;
}
}
#line 465 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
int mthca_write_mtt_size(struct mthca_dev *dev ) ;
#line 467
struct mthca_mtt *mthca_alloc_mtt(struct mthca_dev *dev , int size ) ;
#line 468
void mthca_free_mtt(struct mthca_dev *dev , struct mthca_mtt *mtt ) ;
#line 469
int mthca_write_mtt(struct mthca_dev *dev , struct mthca_mtt *mtt , int start_index ,
                    u64 *buffer_list , int list_len ) ;
#line 471
int mthca_mr_alloc(struct mthca_dev *dev , u32 pd , int buffer_size_shift , u64 iova ,
                   u64 total_size , u32 access , struct mthca_mr *mr ) ;
#line 481
int mthca_fmr_alloc(struct mthca_dev *dev , u32 pd , u32 access , struct mthca_fmr *mr ) ;
#line 483
int mthca_tavor_map_phys_fmr(struct ib_fmr *ibfmr , u64 *page_list , int list_len ,
                             u64 iova ) ;
#line 485
void mthca_tavor_fmr_unmap(struct mthca_dev *dev , struct mthca_fmr *fmr ) ;
#line 486
int mthca_arbel_map_phys_fmr(struct ib_fmr *ibfmr , u64 *page_list , int list_len ,
                             u64 iova ) ;
#line 488
void mthca_arbel_fmr_unmap(struct mthca_dev *dev , struct mthca_fmr *fmr ) ;
#line 489
int mthca_free_fmr(struct mthca_dev *dev , struct mthca_fmr *fmr ) ;
#line 93 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
void *mthca_table_find(struct mthca_icm_table *table , int obj , dma_addr_t *dma_handle ) ;
#line 94
int mthca_table_get_range(struct mthca_dev *dev , struct mthca_icm_table *table ,
                          int start , int end ) ;
#line 96
void mthca_table_put_range(struct mthca_dev *dev , struct mthca_icm_table *table ,
                           int start , int end ) ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
static u32 mthca_buddy_alloc(struct mthca_buddy *buddy , int order ) 
{ 
  int o ;
  int m ;
  u32 seg ;
  unsigned long tmp ;

  {
#line 90
  spin_lock(& buddy->lock);
#line 92
  o = order;
#line 92
  goto ldv_30617;
  ldv_30616: ;
#line 93
  if (*(buddy->num_free + (unsigned long )o) != 0) {
#line 94
    m = 1 << (buddy->max_order - o);
#line 95
    tmp = find_first_bit((unsigned long const   *)*(buddy->bits + (unsigned long )o),
                         (unsigned long )m);
#line 95
    seg = (u32 )tmp;
#line 96
    if ((u32 )m > seg) {
#line 97
      goto found;
    } else {

    }
  } else {

  }
#line 92
  o = o + 1;
  ldv_30617: ;
#line 92
  if (buddy->max_order >= o) {
#line 94
    goto ldv_30616;
  } else {

  }
#line 100
  spin_unlock(& buddy->lock);
#line 101
  return (4294967295U);
  found: 
#line 104
  clear_bit((long )seg, (unsigned long volatile   *)*(buddy->bits + (unsigned long )o));
#line 105
  *(buddy->num_free + (unsigned long )o) = *(buddy->num_free + (unsigned long )o) - 1;
#line 107
  goto ldv_30620;
  ldv_30619: 
#line 108
  o = o - 1;
#line 109
  seg = seg << 1;
#line 110
  set_bit((long )(seg ^ 1U), (unsigned long volatile   *)*(buddy->bits + (unsigned long )o));
#line 111
  *(buddy->num_free + (unsigned long )o) = *(buddy->num_free + (unsigned long )o) + 1;
  ldv_30620: ;
#line 107
  if (o > order) {
#line 109
    goto ldv_30619;
  } else {

  }
#line 114
  spin_unlock(& buddy->lock);
#line 116
  seg = seg << order;
#line 118
  return (seg);
}
}
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
static void mthca_buddy_free(struct mthca_buddy *buddy , u32 seg , int order ) 
{ 
  int tmp ;

  {
#line 123
  seg = seg >> order;
#line 125
  spin_lock(& buddy->lock);
#line 127
  goto ldv_30628;
  ldv_30627: 
#line 128
  clear_bit((long )(seg ^ 1U), (unsigned long volatile   *)*(buddy->bits + (unsigned long )order));
#line 129
  *(buddy->num_free + (unsigned long )order) = *(buddy->num_free + (unsigned long )order) - 1;
#line 130
  seg = seg >> 1;
#line 131
  order = order + 1;
  ldv_30628: 
#line 127
  tmp = variable_test_bit((long )(seg ^ 1U), (unsigned long const volatile   *)*(buddy->bits + (unsigned long )order));
#line 127
  if (tmp != 0) {
#line 129
    goto ldv_30627;
  } else {

  }
#line 134
  set_bit((long )seg, (unsigned long volatile   *)*(buddy->bits + (unsigned long )order));
#line 135
  *(buddy->num_free + (unsigned long )order) = *(buddy->num_free + (unsigned long )order) + 1;
#line 137
  spin_unlock(& buddy->lock);
#line 138
  return;
}
}
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
static int mthca_buddy_init(struct mthca_buddy *buddy , int max_order ) 
{ 
  int i ;
  int s ;
  struct lock_class_key __key ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 144
  buddy->max_order = max_order;
#line 145
  spinlock_check(& buddy->lock);
#line 145
  __raw_spin_lock_init(& buddy->lock.__annonCompField18.rlock, "&(&buddy->lock)->rlock",
                       & __key);
#line 147
  tmp = kzalloc((unsigned long )(buddy->max_order + 1) * 8UL, 208U);
#line 147
  buddy->bits = (unsigned long **)tmp;
#line 149
  tmp___0 = kcalloc((size_t )(buddy->max_order + 1), 4UL, 208U);
#line 149
  buddy->num_free = (int *)tmp___0;
#line 151
  if ((unsigned long )buddy->bits == (unsigned long )((unsigned long **)0UL) || (unsigned long )buddy->num_free == (unsigned long )((int *)0)) {
#line 152
    goto err_out;
  } else {

  }
#line 154
  i = 0;
#line 154
  goto ldv_30640;
  ldv_30639: 
#line 155
  s = (int )(((unsigned long )(1 << (buddy->max_order - i)) + 63UL) / 64UL);
#line 156
  tmp___1 = kmalloc((unsigned long )s * 8UL, 208U);
#line 156
  *(buddy->bits + (unsigned long )i) = (unsigned long *)tmp___1;
#line 157
  if ((unsigned long )*(buddy->bits + (unsigned long )i) == (unsigned long )((unsigned long *)0UL)) {
#line 158
    goto err_out_free;
  } else {

  }
#line 159
  bitmap_zero(*(buddy->bits + (unsigned long )i), (unsigned int )(1 << (buddy->max_order - i)));
#line 154
  i = i + 1;
  ldv_30640: ;
#line 154
  if (buddy->max_order >= i) {
#line 156
    goto ldv_30639;
  } else {

  }
#line 163
  set_bit(0L, (unsigned long volatile   *)*(buddy->bits + (unsigned long )buddy->max_order));
#line 164
  *(buddy->num_free + (unsigned long )buddy->max_order) = 1;
#line 166
  return (0);
  err_out_free: 
#line 169
  i = 0;
#line 169
  goto ldv_30643;
  ldv_30642: 
#line 170
  kfree((void const   *)*(buddy->bits + (unsigned long )i));
#line 169
  i = i + 1;
  ldv_30643: ;
#line 169
  if (buddy->max_order >= i) {
#line 171
    goto ldv_30642;
  } else {

  }

  err_out: 
#line 173
  kfree((void const   *)buddy->bits);
#line 174
  kfree((void const   *)buddy->num_free);
#line 176
  return (-12);
}
}
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
static void mthca_buddy_cleanup(struct mthca_buddy *buddy ) 
{ 
  int i ;

  {
#line 183
  i = 0;
#line 183
  goto ldv_30650;
  ldv_30649: 
#line 184
  kfree((void const   *)*(buddy->bits + (unsigned long )i));
#line 183
  i = i + 1;
  ldv_30650: ;
#line 183
  if (buddy->max_order >= i) {
#line 185
    goto ldv_30649;
  } else {

  }
#line 186
  kfree((void const   *)buddy->bits);
#line 187
  kfree((void const   *)buddy->num_free);
#line 188
  return;
}
}
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
static u32 mthca_alloc_mtt_range(struct mthca_dev *dev , int order , struct mthca_buddy *buddy ) 
{ 
  u32 seg ;
  u32 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 193
  tmp = mthca_buddy_alloc(buddy, order);
#line 193
  seg = tmp;
#line 195
  if (seg == 4294967295U) {
#line 196
    return (4294967295U);
  } else {

  }
#line 198
  tmp___1 = mthca_is_memfree(dev);
#line 198
  if (tmp___1 != 0) {
#line 199
    tmp___0 = mthca_table_get_range(dev, dev->mr_table.mtt_table, (int )seg, (int )(((u32 )(1 << order) + seg) - 1U));
#line 199
    if (tmp___0 != 0) {
#line 201
      mthca_buddy_free(buddy, seg, order);
#line 202
      seg = 4294967295U;
    } else {

    }
  } else {

  }
#line 205
  return (seg);
}
}
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
static struct mthca_mtt *__mthca_alloc_mtt(struct mthca_dev *dev , int size , struct mthca_buddy *buddy ) 
{ 
  struct mthca_mtt *mtt ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 214
  if (size <= 0) {
#line 215
    tmp = ERR_PTR(-22L);
#line 215
    return ((struct mthca_mtt *)tmp);
  } else {

  }
#line 217
  tmp___0 = kmalloc(16UL, 208U);
#line 217
  mtt = (struct mthca_mtt *)tmp___0;
#line 218
  if ((unsigned long )mtt == (unsigned long )((struct mthca_mtt *)0)) {
#line 219
    tmp___1 = ERR_PTR(-12L);
#line 219
    return ((struct mthca_mtt *)tmp___1);
  } else {

  }
#line 221
  mtt->buddy = buddy;
#line 222
  mtt->order = 0;
#line 223
  i = dev->limits.mtt_seg_size / 8;
#line 223
  goto ldv_30666;
  ldv_30665: 
#line 224
  mtt->order = mtt->order + 1;
#line 223
  i = i << 1;
  ldv_30666: ;
#line 223
  if (i < size) {
#line 225
    goto ldv_30665;
  } else {

  }
#line 226
  mtt->first_seg = mthca_alloc_mtt_range(dev, mtt->order, buddy);
#line 227
  if (mtt->first_seg == 4294967295U) {
#line 228
    kfree((void const   *)mtt);
#line 229
    tmp___2 = ERR_PTR(-12L);
#line 229
    return ((struct mthca_mtt *)tmp___2);
  } else {

  }
#line 232
  return (mtt);
}
}
#line 235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
struct mthca_mtt *mthca_alloc_mtt(struct mthca_dev *dev , int size ) 
{ 
  struct mthca_mtt *tmp ;

  {
#line 237
  tmp = __mthca_alloc_mtt(dev, size, & dev->mr_table.mtt_buddy);
#line 237
  return (tmp);
}
}
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
void mthca_free_mtt(struct mthca_dev *dev , struct mthca_mtt *mtt ) 
{ 


  {
#line 242
  if ((unsigned long )mtt == (unsigned long )((struct mthca_mtt *)0)) {
#line 243
    return;
  } else {

  }
#line 245
  mthca_buddy_free(mtt->buddy, mtt->first_seg, mtt->order);
#line 247
  mthca_table_put_range(dev, dev->mr_table.mtt_table, (int )mtt->first_seg, (int )((mtt->first_seg + (u32 )(1 << mtt->order)) - 1U));
#line 251
  kfree((void const   *)mtt);
#line 252
  return;
}
}
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
static int __mthca_write_mtt(struct mthca_dev *dev , struct mthca_mtt *mtt , int start_index ,
                             u64 *buffer_list , int list_len ) 
{ 
  struct mthca_mailbox *mailbox ;
  __be64 *mtt_entry ;
  int err ;
  int i ;
  long tmp ;
  bool tmp___0 ;
  __u64 tmp___1 ;
  __u64 tmp___2 ;

  {
#line 259
  err = 0;
#line 262
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 263
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 263
  if ((int )tmp___0) {
#line 264
    tmp = PTR_ERR((void const   *)mailbox);
#line 264
    return ((int )tmp);
  } else {

  }
#line 265
  mtt_entry = (__be64 *)mailbox->buf;
#line 267
  goto ldv_30692;
  ldv_30691: 
#line 268
  tmp___1 = __fswab64((dev->mr_table.mtt_base + (u64 )(mtt->first_seg * (u32 )dev->limits.mtt_seg_size)) + (u64 )(start_index * 8));
#line 268
  *mtt_entry = tmp___1;
#line 271
  *(mtt_entry + 1UL) = 0ULL;
#line 272
  i = 0;
#line 272
  goto ldv_30688;
  ldv_30687: 
#line 273
  tmp___2 = __fswab64(*(buffer_list + (unsigned long )i) | 1ULL);
#line 273
  *(mtt_entry + ((unsigned long )i + 2UL)) = tmp___2;
#line 272
  i = i + 1;
  ldv_30688: ;
#line 272
  if (i < list_len && i <= 509) {
#line 274
    goto ldv_30687;
  } else {

  }

#line 280
  if (i & 1) {
#line 281
    *(mtt_entry + ((unsigned long )i + 2UL)) = 0ULL;
  } else {

  }
#line 283
  err = mthca_WRITE_MTT(dev, mailbox, (i + 1) & -2);
#line 284
  if (err != 0) {
#line 285
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "WRITE_MTT failed (%d)\n",
             err);
#line 286
    goto out;
  } else {

  }
#line 289
  list_len = list_len - i;
#line 290
  start_index = start_index + i;
#line 291
  buffer_list = buffer_list + (unsigned long )i;
  ldv_30692: ;
#line 267
  if (list_len > 0) {
#line 269
    goto ldv_30691;
  } else {

  }

  out: 
#line 295
  mthca_free_mailbox(dev, mailbox);
#line 296
  return (err);
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
int mthca_write_mtt_size(struct mthca_dev *dev ) 
{ 
  int tmp ;

  {
#line 301
  if ((unsigned long )dev->mr_table.fmr_mtt_buddy != (unsigned long )(& dev->mr_table.mtt_buddy) || (dev->mthca_flags & 32UL) == 0UL) {
#line 309
    return (510);
  } else {

  }
#line 312
  tmp = mthca_is_memfree(dev);
#line 312
  return (tmp != 0 ? 512 : 134217727);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
static void mthca_tavor_write_mtt_seg(struct mthca_dev *dev , struct mthca_mtt *mtt ,
                                      int start_index , u64 *buffer_list , int list_len ) 
{ 
  u64 *mtts ;
  int i ;
  __u64 tmp ;

  {
#line 322
  mtts = (u64 *)(dev->mr_table.tavor_fmr.mtt_base + ((unsigned long )(mtt->first_seg * (u32 )dev->limits.mtt_seg_size) + (unsigned long )start_index * 8UL));
#line 324
  i = 0;
#line 324
  goto ldv_30707;
  ldv_30706: 
#line 325
  tmp = __fswab64(*(buffer_list + (unsigned long )i) | 1ULL);
#line 325
  mthca_write64_raw(tmp, (void *)mtts + (unsigned long )i);
#line 324
  i = i + 1;
  ldv_30707: ;
#line 324
  if (i < list_len) {
#line 326
    goto ldv_30706;
  } else {

  }

#line 331
  return;
}
}
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
static void mthca_arbel_write_mtt_seg(struct mthca_dev *dev , struct mthca_mtt *mtt ,
                                      int start_index , u64 *buffer_list , int list_len ) 
{ 
  __be64 *mtts ;
  dma_addr_t dma_handle ;
  int i ;
  int s ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  __u64 tmp___3 ;

  {
#line 336
  s = (int )((unsigned int )start_index * 8U);
#line 339
  tmp = ldv__builtin_expect((unsigned long )s / 4096UL != (((unsigned long )s + (unsigned long )list_len * 8UL) - 1UL) / 4096UL,
                         0L);
#line 339
  if (tmp != 0L) {
#line 339
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"),
                         "i" (339), "i" (12UL));
    ldv_30720: ;
#line 339
    goto ldv_30720;
  } else {

  }
#line 341
  tmp___0 = ldv__builtin_expect(s % dev->limits.mtt_seg_size != 0, 0L);
#line 341
  if (tmp___0 != 0L) {
#line 341
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"),
                         "i" (341), "i" (12UL));
    ldv_30721: ;
#line 341
    goto ldv_30721;
  } else {

  }
#line 343
  tmp___1 = mthca_table_find(dev->mr_table.mtt_table, (int )(mtt->first_seg + (u32 )(s / dev->limits.mtt_seg_size)),
                             & dma_handle);
#line 343
  mtts = (__be64 *)tmp___1;
#line 346
  tmp___2 = ldv__builtin_expect((unsigned long )mtts == (unsigned long )((__be64 *)0ULL),
                             0L);
#line 346
  if (tmp___2 != 0L) {
#line 346
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"),
                         "i" (346), "i" (12UL));
    ldv_30722: ;
#line 346
    goto ldv_30722;
  } else {

  }
#line 348
  dma_sync_single_for_cpu(& (dev->pdev)->dev, dma_handle, (unsigned long )list_len * 8UL,
                          1);
#line 351
  i = 0;
#line 351
  goto ldv_30724;
  ldv_30723: 
#line 352
  tmp___3 = __fswab64(*(buffer_list + (unsigned long )i) | 1ULL);
#line 352
  *(mtts + (unsigned long )i) = tmp___3;
#line 351
  i = i + 1;
  ldv_30724: ;
#line 351
  if (i < list_len) {
#line 353
    goto ldv_30723;
  } else {

  }
#line 354
  dma_sync_single_for_device(& (dev->pdev)->dev, dma_handle, (unsigned long )list_len * 8UL,
                             1);
#line 356
  return;
}
}
#line 358 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
int mthca_write_mtt(struct mthca_dev *dev , struct mthca_mtt *mtt , int start_index ,
                    u64 *buffer_list , int list_len ) 
{ 
  int size ;
  int tmp ;
  int chunk ;
  int tmp___0 ;
  int _min1 ;
  int _min2 ;
  int tmp___1 ;

  {
#line 361
  tmp = mthca_write_mtt_size(dev);
#line 361
  size = tmp;
#line 364
  if ((unsigned long )dev->mr_table.fmr_mtt_buddy != (unsigned long )(& dev->mr_table.mtt_buddy) || (dev->mthca_flags & 32UL) == 0UL) {
#line 366
    tmp___0 = __mthca_write_mtt(dev, mtt, start_index, buffer_list, list_len);
#line 366
    return (tmp___0);
  } else {

  }
#line 368
  goto ldv_30739;
  ldv_30738: 
#line 369
  _min1 = size;
#line 369
  _min2 = list_len;
#line 369
  chunk = _min1 < _min2 ? _min1 : _min2;
#line 370
  tmp___1 = mthca_is_memfree(dev);
#line 370
  if (tmp___1 != 0) {
#line 371
    mthca_arbel_write_mtt_seg(dev, mtt, start_index, buffer_list, chunk);
  } else {
#line 374
    mthca_tavor_write_mtt_seg(dev, mtt, start_index, buffer_list, chunk);
  }
#line 377
  list_len = list_len - chunk;
#line 378
  start_index = start_index + chunk;
#line 379
  buffer_list = buffer_list + (unsigned long )chunk;
  ldv_30739: ;
#line 368
  if (list_len > 0) {
#line 370
    goto ldv_30738;
  } else {

  }

#line 382
  return (0);
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
__inline static u32 tavor_hw_index_to_key(u32 ind ) 
{ 


  {
#line 387
  return (ind);
}
}
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
__inline static u32 arbel_hw_index_to_key(u32 ind ) 
{ 


  {
#line 397
  return ((ind << 8) | (ind >> (8UL * sizeof(ind) - 8UL)));
}
}
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
__inline static u32 arbel_key_to_hw_index(u32 key ) 
{ 


  {
#line 402
  return ((key << 24) | (key >> (8UL * sizeof(key) - 24UL)));
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
__inline static u32 hw_index_to_key(struct mthca_dev *dev , u32 ind ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  int tmp___1 ;

  {
#line 407
  tmp___1 = mthca_is_memfree(dev);
#line 407
  if (tmp___1 != 0) {
#line 408
    tmp = arbel_hw_index_to_key(ind);
#line 408
    return (tmp);
  } else {
#line 410
    tmp___0 = tavor_hw_index_to_key(ind);
#line 410
    return (tmp___0);
  }
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
__inline static u32 key_to_hw_index(struct mthca_dev *dev , u32 key ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  int tmp___1 ;

  {
#line 415
  tmp___1 = mthca_is_memfree(dev);
#line 415
  if (tmp___1 != 0) {
#line 416
    tmp = arbel_key_to_hw_index(key);
#line 416
    return (tmp);
  } else {
#line 418
    tmp___0 = tavor_hw_index_to_key(key);
#line 418
    return (tmp___0);
  }
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
__inline static u32 adjust_key(struct mthca_dev *dev , u32 key ) 
{ 


  {
#line 423
  if ((dev->mthca_flags & 256UL) != 0UL) {
#line 424
    return (((key << 20) & 8388608U) | (key & 8388607U));
  } else {
#line 426
    return (key);
  }
}
}
#line 429 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
int mthca_mr_alloc(struct mthca_dev *dev , u32 pd , int buffer_size_shift , u64 iova ,
                   u64 total_size , u32 access , struct mthca_mr *mr ) 
{ 
  struct mthca_mailbox *mailbox ;
  struct mthca_mpt_entry *mpt_entry ;
  u32 key ;
  int i ;
  int err ;
  int __ret_warn_on ;
  long tmp ;
  u32 tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u64 tmp___8 ;
  __u64 tmp___9 ;
  __u64 tmp___10 ;
  __u32 tmp___11 ;

  {
#line 438
  __ret_warn_on = buffer_size_shift > 31;
#line 438
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 438
  if (tmp != 0L) {
#line 438
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c",
                       438);
  } else {

  }
#line 438
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 440
  key = mthca_alloc(& dev->mr_table.mpt_alloc);
#line 441
  if (key == 4294967295U) {
#line 442
    return (-12);
  } else {

  }
#line 443
  key = adjust_key(dev, key);
#line 444
  tmp___0 = hw_index_to_key(dev, key);
#line 444
  mr->ibmr.lkey = tmp___0;
#line 444
  mr->ibmr.rkey = tmp___0;
#line 446
  tmp___1 = mthca_is_memfree(dev);
#line 446
  if (tmp___1 != 0) {
#line 447
    err = mthca_table_get(dev, dev->mr_table.mpt_table, (int )key);
#line 448
    if (err != 0) {
#line 449
      goto err_out_mpt_free;
    } else {

    }
  } else {

  }
#line 452
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 453
  tmp___3 = IS_ERR((void const   *)mailbox);
#line 453
  if ((int )tmp___3) {
#line 454
    tmp___2 = PTR_ERR((void const   *)mailbox);
#line 454
    err = (int )tmp___2;
#line 455
    goto err_out_table;
  } else {

  }
#line 457
  mpt_entry = (struct mthca_mpt_entry *)mailbox->buf;
#line 459
  tmp___4 = __fswab32(access | 4026663168U);
#line 459
  mpt_entry->flags = tmp___4;
#line 463
  if ((unsigned long )mr->mtt == (unsigned long )((struct mthca_mtt *)0)) {
#line 464
    mpt_entry->flags = mpt_entry->flags | 131072U;
  } else {

  }
#line 466
  tmp___5 = __fswab32((__u32 )(buffer_size_shift + -12));
#line 466
  mpt_entry->page_size = tmp___5;
#line 467
  tmp___6 = __fswab32(key);
#line 467
  mpt_entry->key = tmp___6;
#line 468
  tmp___7 = __fswab32(pd);
#line 468
  mpt_entry->pd = tmp___7;
#line 469
  tmp___8 = __fswab64(iova);
#line 469
  mpt_entry->start = tmp___8;
#line 470
  tmp___9 = __fswab64(total_size);
#line 470
  mpt_entry->length = tmp___9;
#line 472
  memset((void *)(& mpt_entry->lkey), 0, 32UL);
#line 475
  if ((unsigned long )mr->mtt != (unsigned long )((struct mthca_mtt *)0)) {
#line 476
    tmp___10 = __fswab64(dev->mr_table.mtt_base + (u64 )((mr->mtt)->first_seg * (u32 )dev->limits.mtt_seg_size));
#line 476
    mpt_entry->mtt_seg = tmp___10;
  } else {

  }
#line 480
  if (0) {
#line 481
    if (mthca_debug_level != 0) {
#line 481
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Dumping MPT entry %08x:\n",
                 mr->ibmr.lkey);
    } else {

    }
#line 482
    i = 0;
#line 482
    goto ldv_30784;
    ldv_30783: ;
#line 483
    if (((unsigned int )i & 3U) == 0U) {
#line 484
      printk("[%02x] ", i * 4);
    } else {

    }
#line 485
    tmp___11 = __fswab32(*((__be32 *)mpt_entry + (unsigned long )i));
#line 485
    printk(" %08x", tmp___11);
#line 486
    if (((unsigned int )(i + 1) & 3U) == 0U) {
#line 487
      printk("\n");
    } else {

    }
#line 482
    i = i + 1;
    ldv_30784: ;
#line 482
    if ((unsigned int )i <= 15U) {
#line 484
      goto ldv_30783;
    } else {

    }

  } else {

  }
#line 491
  err = mthca_SW2HW_MPT(dev, mailbox, (int )((u32 )(dev->limits.num_mpts + -1) & key));
#line 493
  if (err != 0) {
#line 494
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "SW2HW_MPT failed (%d)\n",
             err);
#line 495
    goto err_out_mailbox;
  } else {

  }
#line 498
  mthca_free_mailbox(dev, mailbox);
#line 499
  return (err);
  err_out_mailbox: 
#line 502
  mthca_free_mailbox(dev, mailbox);
  err_out_table: 
#line 505
  mthca_table_put(dev, dev->mr_table.mpt_table, (int )key);
  err_out_mpt_free: 
#line 508
  mthca_free(& dev->mr_table.mpt_alloc, key);
#line 509
  return (err);
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
int mthca_mr_alloc_notrans(struct mthca_dev *dev , u32 pd , u32 access , struct mthca_mr *mr ) 
{ 
  int tmp ;

  {
#line 515
  mr->mtt = (struct mthca_mtt *)0;
#line 516
  tmp = mthca_mr_alloc(dev, pd, 12, 0ULL, 0xffffffffffffffffULL, access, mr);
#line 516
  return (tmp);
}
}
#line 519 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
int mthca_mr_alloc_phys(struct mthca_dev *dev , u32 pd , u64 *buffer_list , int buffer_size_shift ,
                        int list_len , u64 iova , u64 total_size , u32 access , struct mthca_mr *mr ) 
{ 
  int err ;
  long tmp ;
  bool tmp___0 ;

  {
#line 526
  mr->mtt = mthca_alloc_mtt(dev, list_len);
#line 527
  tmp___0 = IS_ERR((void const   *)mr->mtt);
#line 527
  if ((int )tmp___0) {
#line 528
    tmp = PTR_ERR((void const   *)mr->mtt);
#line 528
    return ((int )tmp);
  } else {

  }
#line 530
  err = mthca_write_mtt(dev, mr->mtt, 0, buffer_list, list_len);
#line 531
  if (err != 0) {
#line 532
    mthca_free_mtt(dev, mr->mtt);
#line 533
    return (err);
  } else {

  }
#line 536
  err = mthca_mr_alloc(dev, pd, buffer_size_shift, iova, total_size, access, mr);
#line 538
  if (err != 0) {
#line 539
    mthca_free_mtt(dev, mr->mtt);
  } else {

  }
#line 541
  return (err);
}
}
#line 545 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
static void mthca_free_region(struct mthca_dev *dev , u32 lkey ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 547
  tmp = key_to_hw_index(dev, lkey);
#line 547
  mthca_table_put(dev, dev->mr_table.mpt_table, (int )tmp);
#line 550
  tmp___0 = key_to_hw_index(dev, lkey);
#line 550
  mthca_free(& dev->mr_table.mpt_alloc, tmp___0);
#line 551
  return;
}
}
#line 553 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
void mthca_free_mr(struct mthca_dev *dev , struct mthca_mr *mr ) 
{ 
  int err ;
  u32 tmp ;

  {
#line 557
  tmp = key_to_hw_index(dev, mr->ibmr.lkey);
#line 557
  err = mthca_HW2SW_MPT(dev, (struct mthca_mailbox *)0, (int )(tmp & (u32 )(dev->limits.num_mpts + -1)));
#line 560
  if (err != 0) {
#line 561
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "HW2SW_MPT failed (%d)\n",
             err);
  } else {

  }
#line 563
  mthca_free_region(dev, mr->ibmr.lkey);
#line 564
  mthca_free_mtt(dev, mr->mtt);
#line 565
  return;
}
}
#line 567 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
int mthca_fmr_alloc(struct mthca_dev *dev , u32 pd , u32 access , struct mthca_fmr *mr ) 
{ 
  struct mthca_mpt_entry *mpt_entry ;
  struct mthca_mailbox *mailbox ;
  u64 mtt_seg ;
  u32 key ;
  u32 idx ;
  int list_len ;
  int err ;
  int i ;
  int tmp ;
  u32 tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  bool tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  bool tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;
  __u64 tmp___15 ;
  __u32 tmp___16 ;

  {
#line 574
  list_len = mr->attr.max_pages;
#line 575
  err = -12;
#line 578
  if ((unsigned int )mr->attr.page_shift <= 11U || (unsigned int )mr->attr.page_shift > 31U) {
#line 579
    return (-22);
  } else {

  }
#line 582
  tmp = mthca_is_memfree(dev);
#line 582
  if (tmp != 0 && (unsigned long )mr->attr.max_pages * 8UL > 4096UL) {
#line 584
    return (-22);
  } else {

  }
#line 586
  mr->maps = 0;
#line 588
  key = mthca_alloc(& dev->mr_table.mpt_alloc);
#line 589
  if (key == 4294967295U) {
#line 590
    return (-12);
  } else {

  }
#line 591
  key = adjust_key(dev, key);
#line 593
  idx = (u32 )(dev->limits.num_mpts + -1) & key;
#line 594
  tmp___0 = hw_index_to_key(dev, key);
#line 594
  mr->ibmr.lkey = tmp___0;
#line 594
  mr->ibmr.rkey = tmp___0;
#line 596
  tmp___3 = mthca_is_memfree(dev);
#line 596
  if (tmp___3 != 0) {
#line 597
    err = mthca_table_get(dev, dev->mr_table.mpt_table, (int )key);
#line 598
    if (err != 0) {
#line 599
      goto err_out_mpt_free;
    } else {

    }
#line 601
    tmp___1 = mthca_table_find(dev->mr_table.mpt_table, (int )key, (dma_addr_t *)0ULL);
#line 601
    mr->mem.arbel.mpt = (struct mthca_mpt_entry *)tmp___1;
#line 602
    tmp___2 = ldv__builtin_expect((unsigned long )mr->mem.arbel.mpt == (unsigned long )((struct mthca_mpt_entry *)0),
                               0L);
#line 602
    if (tmp___2 != 0L) {
#line 602
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"),
                           "i" (602), "i" (12UL));
      ldv_30829: ;
#line 602
      goto ldv_30829;
    } else {

    }
  } else {
#line 604
    mr->mem.tavor.mpt = (struct mthca_mpt_entry *)(dev->mr_table.tavor_fmr.mpt_base + (unsigned long )idx * 64UL);
  }
#line 607
  mr->mtt = __mthca_alloc_mtt(dev, list_len, dev->mr_table.fmr_mtt_buddy);
#line 608
  tmp___5 = IS_ERR((void const   *)mr->mtt);
#line 608
  if ((int )tmp___5) {
#line 609
    tmp___4 = PTR_ERR((void const   *)mr->mtt);
#line 609
    err = (int )tmp___4;
#line 610
    goto err_out_table;
  } else {

  }
#line 613
  mtt_seg = (u64 )((mr->mtt)->first_seg * (u32 )dev->limits.mtt_seg_size);
#line 615
  tmp___8 = mthca_is_memfree(dev);
#line 615
  if (tmp___8 != 0) {
#line 616
    tmp___6 = mthca_table_find(dev->mr_table.mtt_table, (int )(mr->mtt)->first_seg,
                               & mr->mem.arbel.dma_handle);
#line 616
    mr->mem.arbel.mtts = (__be64 *)tmp___6;
#line 619
    tmp___7 = ldv__builtin_expect((unsigned long )mr->mem.arbel.mtts == (unsigned long )((__be64 *)0ULL),
                               0L);
#line 619
    if (tmp___7 != 0L) {
#line 619
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"),
                           "i" (619), "i" (12UL));
      ldv_30831: ;
#line 619
      goto ldv_30831;
    } else {

    }
  } else {
#line 621
    mr->mem.tavor.mtts = (u64 *)(dev->mr_table.tavor_fmr.mtt_base + mtt_seg);
  }
#line 623
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 624
  tmp___10 = IS_ERR((void const   *)mailbox);
#line 624
  if ((int )tmp___10) {
#line 625
    tmp___9 = PTR_ERR((void const   *)mailbox);
#line 625
    err = (int )tmp___9;
#line 626
    goto err_out_free_mtt;
  } else {

  }
#line 629
  mpt_entry = (struct mthca_mpt_entry *)mailbox->buf;
#line 631
  tmp___11 = __fswab32(access | 4026663168U);
#line 631
  mpt_entry->flags = tmp___11;
#line 636
  tmp___12 = __fswab32((__u32 )((int )mr->attr.page_shift + -12));
#line 636
  mpt_entry->page_size = tmp___12;
#line 637
  tmp___13 = __fswab32(key);
#line 637
  mpt_entry->key = tmp___13;
#line 638
  tmp___14 = __fswab32(pd);
#line 638
  mpt_entry->pd = tmp___14;
#line 639
  memset((void *)(& mpt_entry->start), 0, 48UL);
#line 641
  tmp___15 = __fswab64(dev->mr_table.mtt_base + mtt_seg);
#line 641
  mpt_entry->mtt_seg = tmp___15;
#line 643
  if (0) {
#line 644
    if (mthca_debug_level != 0) {
#line 644
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Dumping MPT entry %08x:\n",
                 mr->ibmr.lkey);
    } else {

    }
#line 645
    i = 0;
#line 645
    goto ldv_30834;
    ldv_30833: ;
#line 646
    if (((unsigned int )i & 3U) == 0U) {
#line 647
      printk("[%02x] ", i * 4);
    } else {

    }
#line 648
    tmp___16 = __fswab32(*((__be32 *)mpt_entry + (unsigned long )i));
#line 648
    printk(" %08x", tmp___16);
#line 649
    if (((unsigned int )(i + 1) & 3U) == 0U) {
#line 650
      printk("\n");
    } else {

    }
#line 645
    i = i + 1;
    ldv_30834: ;
#line 645
    if ((unsigned int )i <= 15U) {
#line 647
      goto ldv_30833;
    } else {

    }

  } else {

  }
#line 654
  err = mthca_SW2HW_MPT(dev, mailbox, (int )((u32 )(dev->limits.num_mpts + -1) & key));
#line 656
  if (err != 0) {
#line 657
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "SW2HW_MPT failed (%d)\n",
             err);
#line 658
    goto err_out_mailbox_free;
  } else {

  }
#line 661
  mthca_free_mailbox(dev, mailbox);
#line 662
  return (0);
  err_out_mailbox_free: 
#line 665
  mthca_free_mailbox(dev, mailbox);
  err_out_free_mtt: 
#line 668
  mthca_free_mtt(dev, mr->mtt);
  err_out_table: 
#line 671
  mthca_table_put(dev, dev->mr_table.mpt_table, (int )key);
  err_out_mpt_free: 
#line 674
  mthca_free(& dev->mr_table.mpt_alloc, key);
#line 675
  return (err);
}
}
#line 678 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
int mthca_free_fmr(struct mthca_dev *dev , struct mthca_fmr *fmr ) 
{ 


  {
#line 680
  if (fmr->maps != 0) {
#line 681
    return (-16);
  } else {

  }
#line 683
  mthca_free_region(dev, fmr->ibmr.lkey);
#line 684
  mthca_free_mtt(dev, fmr->mtt);
#line 686
  return (0);
}
}
#line 689 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
__inline static int mthca_check_fmr(struct mthca_fmr *fmr , u64 *page_list , int list_len ,
                                    u64 iova ) 
{ 
  int i ;
  int page_mask ;

  {
#line 694
  if (fmr->attr.max_pages < list_len) {
#line 695
    return (-22);
  } else {

  }
#line 697
  page_mask = (1 << (int )fmr->attr.page_shift) + -1;
#line 700
  if (((u64 )page_mask & iova) != 0ULL) {
#line 701
    return (-22);
  } else {

  }
#line 704
  if (0) {
#line 705
    i = 0;
#line 705
    goto ldv_30850;
    ldv_30849: ;
#line 706
    if ((*(page_list + (unsigned long )i) & (u64 )(~ page_mask)) != 0ULL) {
#line 707
      return (-22);
    } else {

    }
#line 705
    i = i + 1;
    ldv_30850: ;
#line 705
    if (i < list_len) {
#line 707
      goto ldv_30849;
    } else {

    }

  } else {

  }
#line 710
  if (fmr->maps >= fmr->attr.max_maps) {
#line 711
    return (-22);
  } else {

  }
#line 713
  return (0);
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
int mthca_tavor_map_phys_fmr(struct ib_fmr *ibfmr , u64 *page_list , int list_len ,
                             u64 iova ) 
{ 
  struct mthca_fmr *fmr ;
  struct mthca_fmr *tmp ;
  struct mthca_dev *dev ;
  struct mthca_dev *tmp___0 ;
  struct mthca_mpt_entry mpt_entry ;
  u32 key ;
  int i ;
  int err ;
  u32 tmp___1 ;
  __be64 mtt_entry ;
  __u64 tmp___2 ;
  __u32 tmp___3 ;
  __u64 tmp___4 ;
  __u64 tmp___5 ;

  {
#line 720
  tmp = to_mfmr(ibfmr);
#line 720
  fmr = tmp;
#line 721
  tmp___0 = to_mdev(ibfmr->device);
#line 721
  dev = tmp___0;
#line 726
  err = mthca_check_fmr(fmr, page_list, list_len, iova);
#line 727
  if (err != 0) {
#line 728
    return (err);
  } else {

  }
#line 730
  fmr->maps = fmr->maps + 1;
#line 732
  key = tavor_hw_index_to_key(fmr->ibmr.lkey);
#line 733
  key = (u32 )dev->limits.num_mpts + key;
#line 734
  tmp___1 = tavor_hw_index_to_key(key);
#line 734
  fmr->ibmr.rkey = tmp___1;
#line 734
  fmr->ibmr.lkey = tmp___1;
#line 736
  writeb(240, (void volatile   *)fmr->mem.tavor.mpt);
#line 738
  i = 0;
#line 738
  goto ldv_30866;
  ldv_30865: 
#line 739
  tmp___2 = __fswab64(*(page_list + (unsigned long )i) | 1ULL);
#line 739
  mtt_entry = tmp___2;
#line 741
  mthca_write64_raw(mtt_entry, (void *)fmr->mem.tavor.mtts + (unsigned long )i);
#line 738
  i = i + 1;
  ldv_30866: ;
#line 738
  if (i < list_len) {
#line 740
    goto ldv_30865;
  } else {

  }
#line 744
  tmp___3 = __fswab32(key);
#line 744
  mpt_entry.lkey = tmp___3;
#line 745
  tmp___4 = __fswab64((unsigned long long )list_len << (int )fmr->attr.page_shift);
#line 745
  mpt_entry.length = tmp___4;
#line 746
  tmp___5 = __fswab64(iova);
#line 746
  mpt_entry.start = tmp___5;
#line 748
  __writel(mpt_entry.lkey, (void volatile   *)(& (fmr->mem.tavor.mpt)->key));
#line 749
  memcpy_toio((void volatile   *)(& (fmr->mem.tavor.mpt)->start), (void const   *)(& mpt_entry.start),
              20UL);
#line 753
  writeb(0, (void volatile   *)fmr->mem.tavor.mpt);
#line 755
  return (0);
}
}
#line 758 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
int mthca_arbel_map_phys_fmr(struct ib_fmr *ibfmr , u64 *page_list , int list_len ,
                             u64 iova ) 
{ 
  struct mthca_fmr *fmr ;
  struct mthca_fmr *tmp ;
  struct mthca_dev *dev ;
  struct mthca_dev *tmp___0 ;
  u32 key ;
  int i ;
  int err ;
  u32 tmp___1 ;
  __u64 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u64 tmp___5 ;
  __u64 tmp___6 ;

  {
#line 761
  tmp = to_mfmr(ibfmr);
#line 761
  fmr = tmp;
#line 762
  tmp___0 = to_mdev(ibfmr->device);
#line 762
  dev = tmp___0;
#line 766
  err = mthca_check_fmr(fmr, page_list, list_len, iova);
#line 767
  if (err != 0) {
#line 768
    return (err);
  } else {

  }
#line 770
  fmr->maps = fmr->maps + 1;
#line 772
  key = arbel_key_to_hw_index(fmr->ibmr.lkey);
#line 773
  if ((dev->mthca_flags & 256UL) != 0UL) {
#line 774
    key = key + 16777216U;
  } else {
#line 776
    key = (u32 )dev->limits.num_mpts + key;
  }
#line 777
  tmp___1 = arbel_hw_index_to_key(key);
#line 777
  fmr->ibmr.rkey = tmp___1;
#line 777
  fmr->ibmr.lkey = tmp___1;
#line 779
  *((u8 *)fmr->mem.arbel.mpt) = 240U;
#line 781
  __asm__  volatile   ("sfence": : : "memory");
#line 783
  dma_sync_single_for_cpu(& (dev->pdev)->dev, fmr->mem.arbel.dma_handle, (unsigned long )list_len * 8UL,
                          1);
#line 786
  i = 0;
#line 786
  goto ldv_30880;
  ldv_30879: 
#line 787
  tmp___2 = __fswab64(*(page_list + (unsigned long )i) | 1ULL);
#line 787
  *(fmr->mem.arbel.mtts + (unsigned long )i) = tmp___2;
#line 786
  i = i + 1;
  ldv_30880: ;
#line 786
  if (i < list_len) {
#line 788
    goto ldv_30879;
  } else {

  }
#line 790
  dma_sync_single_for_device(& (dev->pdev)->dev, fmr->mem.arbel.dma_handle, (unsigned long )list_len * 8UL,
                             1);
#line 793
  tmp___3 = __fswab32(key);
#line 793
  (fmr->mem.arbel.mpt)->key = tmp___3;
#line 794
  tmp___4 = __fswab32(key);
#line 794
  (fmr->mem.arbel.mpt)->lkey = tmp___4;
#line 795
  tmp___5 = __fswab64((unsigned long long )list_len << (int )fmr->attr.page_shift);
#line 795
  (fmr->mem.arbel.mpt)->length = tmp___5;
#line 796
  tmp___6 = __fswab64(iova);
#line 796
  (fmr->mem.arbel.mpt)->start = tmp___6;
#line 798
  __asm__  volatile   ("sfence": : : "memory");
#line 800
  *((u8 *)fmr->mem.arbel.mpt) = 0U;
#line 802
  __asm__  volatile   ("sfence": : : "memory");
#line 804
  return (0);
}
}
#line 807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
void mthca_tavor_fmr_unmap(struct mthca_dev *dev , struct mthca_fmr *fmr ) 
{ 


  {
#line 809
  if (fmr->maps == 0) {
#line 810
    return;
  } else {

  }
#line 812
  fmr->maps = 0;
#line 814
  writeb(240, (void volatile   *)fmr->mem.tavor.mpt);
#line 815
  return;
}
}
#line 817 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
void mthca_arbel_fmr_unmap(struct mthca_dev *dev , struct mthca_fmr *fmr ) 
{ 


  {
#line 819
  if (fmr->maps == 0) {
#line 820
    return;
  } else {

  }
#line 822
  fmr->maps = 0;
#line 824
  *((u8 *)fmr->mem.arbel.mpt) = 240U;
#line 825
  return;
}
}
#line 827 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
int mthca_init_mr_table(struct mthca_dev *dev ) 
{ 
  phys_addr_t addr ;
  int mpts ;
  int mtts ;
  int err ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;

  {
#line 832
  err = mthca_alloc_init(& dev->mr_table.mpt_alloc, (u32 )dev->limits.num_mpts, 4294967295U,
                         (u32 )dev->limits.reserved_mrws);
#line 835
  if (err != 0) {
#line 836
    return (err);
  } else {

  }
#line 838
  tmp = mthca_is_memfree(dev);
#line 838
  if (tmp == 0 && (dev->mthca_flags & 2UL) != 0UL) {
#line 840
    dev->limits.fmr_reserved_mtts = 0;
  } else {
#line 842
    dev->mthca_flags = dev->mthca_flags | 32UL;
  }
#line 844
  if ((dev->mthca_flags & 256UL) != 0UL) {
#line 845
    if (mthca_debug_level != 0) {
#line 845
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Memory key throughput optimization activated.\n");
    } else {

    }
  } else {

  }
#line 847
  tmp___0 = fls(dev->limits.num_mtt_segs + -1);
#line 847
  err = mthca_buddy_init(& dev->mr_table.mtt_buddy, tmp___0);
#line 850
  if (err != 0) {
#line 851
    goto err_mtt_buddy;
  } else {

  }
#line 853
  dev->mr_table.tavor_fmr.mpt_base = (void *)0;
#line 854
  dev->mr_table.tavor_fmr.mtt_base = (void *)0;
#line 856
  if (dev->limits.fmr_reserved_mtts != 0) {
#line 857
    i = fls(dev->limits.fmr_reserved_mtts + -1);
#line 859
    if (i > 30) {
#line 860
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Unable to reserve 2^31 FMR MTTs.\n");
#line 861
      err = -22;
#line 862
      goto err_fmr_mpt;
    } else {

    }
#line 864
    mtts = 1 << i;
#line 864
    mpts = mtts;
  } else {
#line 866
    mtts = dev->limits.num_mtt_segs;
#line 867
    mpts = dev->limits.num_mpts;
  }
#line 870
  tmp___1 = mthca_is_memfree(dev);
#line 870
  if (tmp___1 == 0 && (dev->mthca_flags & 32UL) != 0UL) {
#line 873
    addr = (dev->pdev)->resource[4].start + (((dev->pdev)->resource[4].start != 0ULL || (dev->pdev)->resource[4].end != (dev->pdev)->resource[4].start ? (dev->pdev)->resource[4].end - (dev->pdev)->resource[4].start : 0xffffffffffffffffULL) & dev->mr_table.mpt_base);
#line 877
    dev->mr_table.tavor_fmr.mpt_base = ioremap(addr, (unsigned long )mpts * 64UL);
#line 880
    if ((unsigned long )dev->mr_table.tavor_fmr.mpt_base == (unsigned long )((void *)0)) {
#line 881
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "MPT ioremap for FMR failed.\n");
#line 882
      err = -12;
#line 883
      goto err_fmr_mpt;
    } else {

    }
#line 886
    addr = (dev->pdev)->resource[4].start + (((dev->pdev)->resource[4].start != 0ULL || (dev->pdev)->resource[4].end != (dev->pdev)->resource[4].start ? (dev->pdev)->resource[4].end - (dev->pdev)->resource[4].start : 0xffffffffffffffffULL) & dev->mr_table.mtt_base);
#line 890
    dev->mr_table.tavor_fmr.mtt_base = ioremap(addr, (unsigned long )(dev->limits.mtt_seg_size * mtts));
#line 892
    if ((unsigned long )dev->mr_table.tavor_fmr.mtt_base == (unsigned long )((void *)0)) {
#line 893
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "MTT ioremap for FMR failed.\n");
#line 894
      err = -12;
#line 895
      goto err_fmr_mtt;
    } else {

    }
  } else {

  }
#line 899
  if (dev->limits.fmr_reserved_mtts != 0) {
#line 900
    tmp___2 = fls(mtts + -1);
#line 900
    err = mthca_buddy_init(& dev->mr_table.tavor_fmr.mtt_buddy, tmp___2);
#line 901
    if (err != 0) {
#line 902
      goto err_fmr_mtt_buddy;
    } else {

    }
#line 905
    tmp___3 = fls(mtts + -1);
#line 905
    tmp___4 = mthca_buddy_alloc(& dev->mr_table.mtt_buddy, tmp___3);
#line 905
    err = (int )tmp___4;
#line 906
    if (err != 0) {
#line 907
      goto err_reserve_fmr;
    } else {

    }
#line 909
    dev->mr_table.fmr_mtt_buddy = & dev->mr_table.tavor_fmr.mtt_buddy;
  } else {
#line 912
    dev->mr_table.fmr_mtt_buddy = & dev->mr_table.mtt_buddy;
  }
#line 915
  if (dev->limits.reserved_mtts != 0) {
#line 916
    i = fls(dev->limits.reserved_mtts + -1);
#line 918
    tmp___5 = mthca_alloc_mtt_range(dev, i, dev->mr_table.fmr_mtt_buddy);
#line 918
    if (tmp___5 == 4294967295U) {
#line 920
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "MTT table of order %d is too small.\n",
               (dev->mr_table.fmr_mtt_buddy)->max_order);
#line 922
      err = -12;
#line 923
      goto err_reserve_mtts;
    } else {

    }
  } else {

  }
#line 927
  return (0);
  err_reserve_mtts: ;
  err_reserve_fmr: ;
#line 931
  if (dev->limits.fmr_reserved_mtts != 0) {
#line 932
    mthca_buddy_cleanup(& dev->mr_table.tavor_fmr.mtt_buddy);
  } else {

  }
  err_fmr_mtt_buddy: ;
#line 935
  if ((unsigned long )dev->mr_table.tavor_fmr.mtt_base != (unsigned long )((void *)0)) {
#line 936
    iounmap((void volatile   *)dev->mr_table.tavor_fmr.mtt_base);
  } else {

  }
  err_fmr_mtt: ;
#line 939
  if ((unsigned long )dev->mr_table.tavor_fmr.mpt_base != (unsigned long )((void *)0)) {
#line 940
    iounmap((void volatile   *)dev->mr_table.tavor_fmr.mpt_base);
  } else {

  }
  err_fmr_mpt: 
#line 943
  mthca_buddy_cleanup(& dev->mr_table.mtt_buddy);
  err_mtt_buddy: 
#line 946
  mthca_alloc_cleanup(& dev->mr_table.mpt_alloc);
#line 948
  return (err);
}
}
#line 951 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.c"
void mthca_cleanup_mr_table(struct mthca_dev *dev ) 
{ 


  {
#line 954
  if (dev->limits.fmr_reserved_mtts != 0) {
#line 955
    mthca_buddy_cleanup(& dev->mr_table.tavor_fmr.mtt_buddy);
  } else {

  }
#line 957
  mthca_buddy_cleanup(& dev->mr_table.mtt_buddy);
#line 959
  if ((unsigned long )dev->mr_table.tavor_fmr.mtt_base != (unsigned long )((void *)0)) {
#line 960
    iounmap((void volatile   *)dev->mr_table.tavor_fmr.mtt_base);
  } else {

  }
#line 961
  if ((unsigned long )dev->mr_table.tavor_fmr.mpt_base != (unsigned long )((void *)0)) {
#line 962
    iounmap((void volatile   *)dev->mr_table.tavor_fmr.mpt_base);
  } else {

  }
#line 964
  mthca_alloc_cleanup(& dev->mr_table.mpt_alloc);
#line 965
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.o.c.prepared"
bool ldv_queue_work_on_121(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.o.c.prepared"
bool ldv_queue_delayed_work_on_122(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.o.c.prepared"
bool ldv_queue_work_on_123(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.o.c.prepared"
void ldv_flush_workqueue_124(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mr.o.c.prepared"
bool ldv_queue_delayed_work_on_125(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 32 "include/linux/log2.h"
__inline static int __ilog2_u32(u32 n ) 
{ 
  int tmp ;

  {
#line 34
  tmp = fls((int )n);
#line 34
  return (tmp + -1);
}
}
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 102 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 104
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 106
  return;
}
}
#line 23 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_nested(raw_spinlock_t * , int  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_137(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_136(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_139(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_138(struct workqueue_struct *ldv_func_arg1 ) ;
#line 1809 "include/rdma/ib_verbs.h"
extern int ib_modify_qp_is_ok(enum ib_qp_state  , enum ib_qp_state  , enum ib_qp_type  ,
                              enum ib_qp_attr_mask  , enum rdma_link_layer  ) ;
#line 82 "include/rdma/ib_cache.h"
extern int ib_get_cached_pkey(struct ib_device * , u8  , int  , u16 * ) ;
#line 254 "include/rdma/ib_pack.h"
extern void ib_ud_header_init(int  , int  , int  , int  , int  , int  , struct ib_ud_header * ) ;
#line 262
extern int ib_ud_header_pack(struct ib_ud_header * , void * ) ;
#line 299 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_ucontext *to_mucontext(struct ib_ucontext *ibucontext ) 
{ 
  struct ib_ucontext  const  *__mptr ;

  {
#line 301
  __mptr = (struct ib_ucontext  const  *)ibucontext;
#line 301
  return ((struct mthca_ucontext *)__mptr);
}
}
#line 314 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_pd *to_mpd(struct ib_pd *ibpd ) 
{ 
  struct ib_pd  const  *__mptr ;

  {
#line 316
  __mptr = (struct ib_pd  const  *)ibpd;
#line 316
  return ((struct mthca_pd *)__mptr);
}
}
#line 319 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_ah *to_mah(struct ib_ah *ibah ) 
{ 
  struct ib_ah  const  *__mptr ;

  {
#line 321
  __mptr = (struct ib_ah  const  *)ibah;
#line 321
  return ((struct mthca_ah *)__mptr);
}
}
#line 334 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_qp *to_mqp(struct ib_qp *ibqp ) 
{ 
  struct ib_qp  const  *__mptr ;

  {
#line 336
  __mptr = (struct ib_qp  const  *)ibqp;
#line 336
  return ((struct mthca_qp *)__mptr);
}
}
#line 339 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_sqp *to_msqp(struct mthca_qp *qp ) 
{ 
  struct mthca_qp  const  *__mptr ;

  {
#line 341
  __mptr = (struct mthca_qp  const  *)qp;
#line 341
  return ((struct mthca_sqp *)__mptr);
}
}
#line 529 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
int mthca_query_qp(struct ib_qp *ibqp , struct ib_qp_attr *qp_attr , int qp_attr_mask ,
                   struct ib_qp_init_attr *qp_init_attr ) ;
#line 531
int mthca_modify_qp(struct ib_qp *ibqp , struct ib_qp_attr *attr , int attr_mask ,
                    struct ib_udata *udata ) ;
#line 533
int mthca_tavor_post_send(struct ib_qp *ibqp , struct ib_send_wr *wr , struct ib_send_wr **bad_wr ) ;
#line 535
int mthca_tavor_post_receive(struct ib_qp *ibqp , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) ;
#line 537
int mthca_arbel_post_send(struct ib_qp *ibqp , struct ib_send_wr *wr , struct ib_send_wr **bad_wr ) ;
#line 539
int mthca_arbel_post_receive(struct ib_qp *ibqp , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) ;
#line 543
int mthca_alloc_qp(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_cq *send_cq ,
                   struct mthca_cq *recv_cq , enum ib_qp_type type , enum ib_sig_type send_policy ,
                   struct ib_qp_cap *cap , struct mthca_qp *qp ) ;
#line 551
int mthca_alloc_sqp(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_cq *send_cq ,
                    struct mthca_cq *recv_cq , enum ib_sig_type send_policy , struct ib_qp_cap *cap ,
                    int qpn , int port , struct mthca_sqp *sqp ) ;
#line 560
void mthca_free_qp(struct mthca_dev *dev , struct mthca_qp *qp ) ;
#line 566
int mthca_read_ah(struct mthca_dev *dev , struct mthca_ah *ah , struct ib_ud_header *header ) ;
#line 569
int mthca_ah_grh_present(struct mthca_ah *ah ) ;
#line 570
u8 mthca_get_rate(struct mthca_dev *dev , int static_rate , u8 port ) ;
#line 571
enum ib_rate mthca_rate_to_ib(struct mthca_dev *dev , u8 mthca_rate , u8 port ) ;
#line 116 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
__inline static void mthca_set_data_seg(struct mthca_data_seg *dseg , struct ib_sge *sg ) 
{ 
  __u32 tmp ;
  __u32 tmp___0 ;
  __u64 tmp___1 ;

  {
#line 119
  tmp = __fswab32(sg->length);
#line 119
  dseg->byte_count = tmp;
#line 120
  tmp___0 = __fswab32(sg->lkey);
#line 120
  dseg->lkey = tmp___0;
#line 121
  tmp___1 = __fswab64(sg->addr);
#line 121
  dseg->addr = tmp___1;
#line 122
  return;
}
}
#line 124 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
__inline static void mthca_set_data_seg_inval(struct mthca_data_seg *dseg ) 
{ 


  {
#line 126
  dseg->byte_count = 0U;
#line 127
  dseg->lkey = 65536U;
#line 128
  dseg->addr = 0ULL;
#line 129
  return;
}
}
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static u8 const   mthca_opcode[7U]  = {      8U,      9U,      10U,      11U, 
        16U,      17U,      18U};
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static int is_sqp(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ 


  {
#line 197
  return (qp->qpn >= (u32 )dev->qp_table.sqp_start && qp->qpn <= (u32 )(dev->qp_table.sqp_start + 3));
}
}
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static int is_qp0(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ 


  {
#line 203
  return (qp->qpn >= (u32 )dev->qp_table.sqp_start && qp->qpn <= (u32 )(dev->qp_table.sqp_start + 1));
}
}
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static void *get_recv_wqe(struct mthca_qp *qp , int n ) 
{ 


  {
#line 209
  if (qp->is_direct != 0) {
#line 210
    return (qp->queue.direct.buf + (unsigned long )(n << qp->rq.wqe_shift));
  } else {
#line 212
    return ((qp->queue.page_list + (unsigned long )((n << qp->rq.wqe_shift) >> 12))->buf + ((unsigned long )(n << qp->rq.wqe_shift) & 4095UL));
  }
}
}
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static void *get_send_wqe(struct mthca_qp *qp , int n ) 
{ 


  {
#line 218
  if (qp->is_direct != 0) {
#line 219
    return (qp->queue.direct.buf + ((unsigned long )qp->send_wqe_offset + (unsigned long )(n << qp->sq.wqe_shift)));
  } else {
#line 222
    return ((qp->queue.page_list + (unsigned long )((qp->send_wqe_offset + (n << qp->sq.wqe_shift)) >> 12))->buf + ((unsigned long )(qp->send_wqe_offset + (n << qp->sq.wqe_shift)) & 4095UL));
  }
}
}
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static void mthca_wq_reset(struct mthca_wq *wq ) 
{ 


  {
#line 231
  wq->next_ind = 0U;
#line 232
  wq->last_comp = (unsigned int )(wq->max + -1);
#line 233
  wq->head = 0U;
#line 234
  wq->tail = 0U;
#line 235
  return;
}
}
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
void mthca_qp_event(struct mthca_dev *dev , u32 qpn , enum ib_event_type event_type ) 
{ 
  struct mthca_qp *qp ;
  struct ib_event event ;
  void *tmp ;

  {
#line 243
  spin_lock(& dev->qp_table.lock);
#line 244
  tmp = mthca_array_get(& dev->qp_table.qp, (int )((u32 )(dev->limits.num_qps + -1) & qpn));
#line 244
  qp = (struct mthca_qp *)tmp;
#line 245
  if ((unsigned long )qp != (unsigned long )((struct mthca_qp *)0)) {
#line 246
    qp->refcount = qp->refcount + 1;
  } else {

  }
#line 247
  spin_unlock(& dev->qp_table.lock);
#line 249
  if ((unsigned long )qp == (unsigned long )((struct mthca_qp *)0)) {
#line 250
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Async event %d for bogus QP %08x\n",
             (unsigned int )event_type, qpn);
#line 252
    return;
  } else {

  }
#line 255
  if ((unsigned int )event_type == 6U) {
#line 256
    qp->port = qp->alt_port;
  } else {

  }
#line 258
  event.device = & dev->ib_dev;
#line 259
  event.event = event_type;
#line 260
  event.element.qp = & qp->ibqp;
#line 261
  if ((unsigned long )qp->ibqp.event_handler != (unsigned long )((void (*)(struct ib_event * ,
                                                                           void * ))0)) {
#line 262
    (*(qp->ibqp.event_handler))(& event, qp->ibqp.qp_context);
  } else {

  }
#line 264
  spin_lock(& dev->qp_table.lock);
#line 265
  qp->refcount = qp->refcount - 1;
#line 265
  if (qp->refcount == 0) {
#line 266
    __wake_up(& qp->wait, 3U, 1, (void *)0);
  } else {

  }
#line 267
  spin_unlock(& dev->qp_table.lock);
#line 268
  return;
}
}
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static int to_mthca_state(enum ib_qp_state ib_state ) 
{ 


  {
#line 272
  switch ((unsigned int )ib_state) {
  case 0U: ;
#line 273
  return (0);
  case 1U: ;
#line 274
  return (1);
  case 2U: ;
#line 275
  return (2);
  case 3U: ;
#line 276
  return (3);
  case 4U: ;
#line 277
  return (5);
  case 5U: ;
#line 278
  return (4);
  case 6U: ;
#line 279
  return (6);
  default: ;
#line 280
  return (-1);
  }
}
}
#line 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static int to_mthca_st(int transport ) 
{ 


  {
#line 288
  switch (transport) {
  case 0: ;
#line 289
  return (0);
  case 1: ;
#line 290
  return (1);
  case 2: ;
#line 291
  return (3);
  case 3: ;
#line 292
  return (2);
  case 5: ;
#line 293
  return (7);
  default: ;
#line 294
  return (-1);
  }
}
}
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static void store_attrs(struct mthca_sqp *sqp , struct ib_qp_attr  const  *attr ,
                        int attr_mask ) 
{ 


  {
#line 301
  if ((attr_mask & 16) != 0) {
#line 302
    sqp->pkey_index = (int )attr->pkey_index;
  } else {

  }
#line 303
  if ((attr_mask & 64) != 0) {
#line 304
    sqp->qkey = attr->qkey;
  } else {

  }
#line 305
  if ((attr_mask & 65536) != 0) {
#line 306
    sqp->send_psn = attr->sq_psn;
  } else {

  }
#line 307
  return;
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static void init_port(struct mthca_dev *dev , int port ) 
{ 
  int err ;
  struct mthca_init_ib_param param ;

  {
#line 314
  memset((void *)(& param), 0, 64UL);
#line 316
  param.port_width = (int )dev->limits.port_width_cap;
#line 317
  param.vl_cap = dev->limits.vl_cap;
#line 318
  param.mtu_cap = dev->limits.mtu_cap;
#line 319
  param.gid_cap = (u16 )dev->limits.gid_table_len;
#line 320
  param.pkey_cap = (u16 )dev->limits.pkey_table_len;
#line 322
  err = mthca_INIT_IB(dev, & param, port);
#line 323
  if (err != 0) {
#line 324
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "INIT_IB failed, return code %d.\n",
             err);
  } else {

  }
#line 325
  return;
}
}
#line 327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static __be32 get_hw_access_flags(struct mthca_qp *qp , struct ib_qp_attr  const  *attr ,
                                  int attr_mask ) 
{ 
  u8 dest_rd_atomic ;
  u32 access_flags ;
  u32 hw_access_flags ;
  __u32 tmp ;

  {
#line 332
  hw_access_flags = 0U;
#line 334
  if ((attr_mask & 131072) != 0) {
#line 335
    dest_rd_atomic = attr->max_dest_rd_atomic;
  } else {
#line 337
    dest_rd_atomic = qp->resp_depth;
  }
#line 339
  if ((attr_mask & 8) != 0) {
#line 340
    access_flags = (u32 )attr->qp_access_flags;
  } else {
#line 342
    access_flags = (u32 )qp->atomic_rd_en;
  }
#line 344
  if ((unsigned int )dest_rd_atomic == 0U) {
#line 345
    access_flags = access_flags & 2U;
  } else {

  }
#line 347
  if ((access_flags & 4U) != 0U) {
#line 348
    hw_access_flags = hw_access_flags | 32768U;
  } else {

  }
#line 349
  if ((access_flags & 8U) != 0U) {
#line 350
    hw_access_flags = hw_access_flags | 8192U;
  } else {

  }
#line 351
  if ((access_flags & 2U) != 0U) {
#line 352
    hw_access_flags = hw_access_flags | 16384U;
  } else {

  }
#line 354
  tmp = __fswab32(hw_access_flags);
#line 354
  return (tmp);
}
}
#line 357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
__inline static enum ib_qp_state to_ib_qp_state(int mthca_state ) 
{ 


  {
#line 359
  switch (mthca_state) {
  case 0: ;
#line 360
  return (0);
  case 1: ;
#line 361
  return (1);
  case 2: ;
#line 362
  return (2);
  case 3: ;
#line 363
  return (3);
  case 7: ;
  case 5: ;
#line 365
  return (4);
  case 4: ;
#line 366
  return (5);
  case 6: ;
#line 367
  return (6);
  default: ;
#line 368
  return (4294967295L);
  }
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
__inline static enum ib_mig_state to_ib_mig_state(int mthca_mig_state ) 
{ 


  {
#line 374
  switch (mthca_mig_state) {
  case 0: ;
#line 375
  return (2);
  case 1: ;
#line 376
  return (1);
  case 3: ;
#line 377
  return (0);
  default: ;
#line 378
  return (4294967295L);
  }
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static int to_ib_qp_access_flags(int mthca_flags ) 
{ 
  int ib_flags ;

  {
#line 384
  ib_flags = 0;
#line 386
  if ((mthca_flags & 32768) != 0) {
#line 387
    ib_flags = ib_flags | 4;
  } else {

  }
#line 388
  if ((mthca_flags & 16384) != 0) {
#line 389
    ib_flags = ib_flags | 2;
  } else {

  }
#line 390
  if ((mthca_flags & 8192) != 0) {
#line 391
    ib_flags = ib_flags | 8;
  } else {

  }
#line 393
  return (ib_flags);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static void to_ib_ah_attr(struct mthca_dev *dev , struct ib_ah_attr *ib_ah_attr ,
                          struct mthca_qp_path *path ) 
{ 
  __u32 tmp ;
  __u16 tmp___0 ;
  __u32 tmp___1 ;
  enum ib_rate tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;

  {
#line 399
  memset((void *)ib_ah_attr, 0, 40UL);
#line 400
  tmp = __fswab32(path->port_pkey);
#line 400
  ib_ah_attr->port_num = (unsigned int )((u8 )(tmp >> 24)) & 3U;
#line 402
  if ((unsigned int )ib_ah_attr->port_num == 0U || (int )ib_ah_attr->port_num > dev->limits.num_ports) {
#line 403
    return;
  } else {

  }
#line 405
  tmp___0 = __fswab16((int )path->rlid);
#line 405
  ib_ah_attr->dlid = tmp___0;
#line 406
  tmp___1 = __fswab32(path->sl_tclass_flowlabel);
#line 406
  ib_ah_attr->sl = (u8 )(tmp___1 >> 28);
#line 407
  ib_ah_attr->src_path_bits = (unsigned int )path->g_mylmc & 127U;
#line 408
  tmp___2 = mthca_rate_to_ib(dev, (int )path->static_rate & 15, (int )ib_ah_attr->port_num);
#line 408
  ib_ah_attr->static_rate = (u8 )tmp___2;
#line 411
  ib_ah_attr->ah_flags = (int )((signed char )path->g_mylmc) < 0;
#line 412
  if ((unsigned int )ib_ah_attr->ah_flags != 0U) {
#line 413
    ib_ah_attr->grh.sgid_index = (u8 )((int )((signed char )path->mgid_index) & (int )((signed char )((unsigned int )((unsigned char )dev->limits.gid_table_len) + 255U)));
#line 414
    ib_ah_attr->grh.hop_limit = path->hop_limit;
#line 415
    tmp___3 = __fswab32(path->sl_tclass_flowlabel);
#line 415
    ib_ah_attr->grh.traffic_class = (u8 )(tmp___3 >> 20);
#line 417
    tmp___4 = __fswab32(path->sl_tclass_flowlabel);
#line 417
    ib_ah_attr->grh.flow_label = tmp___4 & 1048575U;
#line 419
    memcpy((void *)(& ib_ah_attr->grh.dgid.raw), (void const   *)(& path->rgid),
             16UL);
  } else {

  }
#line 421
  return;
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
int mthca_query_qp(struct ib_qp *ibqp , struct ib_qp_attr *qp_attr , int qp_attr_mask ,
                   struct ib_qp_init_attr *qp_init_attr ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_qp *qp ;
  struct mthca_qp *tmp___0 ;
  int err ;
  struct mthca_mailbox *mailbox ;
  struct mthca_qp_param *qp_param ;
  struct mthca_qp_context *context ;
  int mthca_state ;
  long tmp___1 ;
  bool tmp___2 ;
  __u32 tmp___3 ;
  enum ib_qp_state tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;
  __u32 tmp___15 ;
  __u32 tmp___16 ;
  __u32 tmp___17 ;

  {
#line 427
  tmp = to_mdev(ibqp->device);
#line 427
  dev = tmp;
#line 428
  tmp___0 = to_mqp(ibqp);
#line 428
  qp = tmp___0;
#line 429
  err = 0;
#line 430
  mailbox = (struct mthca_mailbox *)0;
#line 435
  mutex_lock_nested(& qp->mutex, 0U);
#line 437
  if ((unsigned int )qp->state == 0U) {
#line 438
    qp_attr->qp_state = 0;
#line 439
    goto done;
  } else {

  }
#line 442
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 443
  tmp___2 = IS_ERR((void const   *)mailbox);
#line 443
  if ((int )tmp___2) {
#line 444
    tmp___1 = PTR_ERR((void const   *)mailbox);
#line 444
    err = (int )tmp___1;
#line 445
    goto out;
  } else {

  }
#line 448
  err = mthca_QUERY_QP(dev, qp->qpn, 0, mailbox);
#line 449
  if (err != 0) {
#line 450
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "QUERY_QP failed (%d)\n",
             err);
#line 451
    goto out_mailbox;
  } else {

  }
#line 454
  qp_param = (struct mthca_qp_param *)mailbox->buf;
#line 455
  context = & qp_param->context;
#line 456
  tmp___3 = __fswab32(context->flags);
#line 456
  mthca_state = (int )(tmp___3 >> 28);
#line 458
  tmp___4 = to_ib_qp_state(mthca_state);
#line 458
  qp->state = (u8 )tmp___4;
#line 459
  qp_attr->qp_state = (enum ib_qp_state )qp->state;
#line 460
  qp_attr->path_mtu = (enum ib_mtu )((int )context->mtu_msgmax >> 5);
#line 461
  tmp___5 = __fswab32(context->flags);
#line 461
  qp_attr->path_mig_state = to_ib_mig_state((int )(tmp___5 >> 11) & 3);
#line 463
  tmp___6 = __fswab32(context->qkey);
#line 463
  qp_attr->qkey = tmp___6;
#line 464
  tmp___7 = __fswab32(context->rnr_nextrecvpsn);
#line 464
  qp_attr->rq_psn = tmp___7 & 16777215U;
#line 465
  tmp___8 = __fswab32(context->next_send_psn);
#line 465
  qp_attr->sq_psn = tmp___8 & 16777215U;
#line 466
  tmp___9 = __fswab32(context->remote_qpn);
#line 466
  qp_attr->dest_qp_num = tmp___9 & 16777215U;
#line 467
  tmp___10 = __fswab32(context->params2);
#line 467
  qp_attr->qp_access_flags = to_ib_qp_access_flags((int )tmp___10);
#line 470
  if ((unsigned int )qp->transport == 0U || (unsigned int )qp->transport == 1U) {
#line 471
    to_ib_ah_attr(dev, & qp_attr->ah_attr, & context->pri_path);
#line 472
    to_ib_ah_attr(dev, & qp_attr->alt_ah_attr, & context->alt_path);
#line 473
    tmp___11 = __fswab32(context->alt_path.port_pkey);
#line 473
    qp_attr->alt_pkey_index = (unsigned int )((u16 )tmp___11) & 127U;
#line 475
    qp_attr->alt_port_num = qp_attr->alt_ah_attr.port_num;
  } else {

  }
#line 478
  tmp___12 = __fswab32(context->pri_path.port_pkey);
#line 478
  qp_attr->pkey_index = (unsigned int )((u16 )tmp___12) & 127U;
#line 479
  tmp___13 = __fswab32(context->pri_path.port_pkey);
#line 479
  qp_attr->port_num = (unsigned int )((u8 )(tmp___13 >> 24)) & 3U;
#line 483
  qp_attr->sq_draining = mthca_state == 7;
#line 485
  tmp___14 = __fswab32(context->params1);
#line 485
  qp_attr->max_rd_atomic = (u8 )(1 << ((int )(tmp___14 >> 21) & 7));
#line 487
  tmp___15 = __fswab32(context->params2);
#line 487
  qp_attr->max_dest_rd_atomic = (u8 )(1 << ((int )(tmp___15 >> 21) & 7));
#line 489
  tmp___16 = __fswab32(context->rnr_nextrecvpsn);
#line 489
  qp_attr->min_rnr_timer = (unsigned int )((u8 )(tmp___16 >> 24)) & 31U;
#line 491
  qp_attr->timeout = (u8 )((int )context->pri_path.ackto >> 3);
#line 492
  tmp___17 = __fswab32(context->params1);
#line 492
  qp_attr->retry_cnt = (unsigned int )((u8 )(tmp___17 >> 16)) & 7U;
#line 493
  qp_attr->rnr_retry = (u8 )((int )context->pri_path.rnr_retry >> 5);
#line 494
  qp_attr->alt_timeout = (u8 )((int )context->alt_path.ackto >> 3);
  done: 
#line 497
  qp_attr->cur_qp_state = qp_attr->qp_state;
#line 498
  qp_attr->cap.max_send_wr = (u32 )qp->sq.max;
#line 499
  qp_attr->cap.max_recv_wr = (u32 )qp->rq.max;
#line 500
  qp_attr->cap.max_send_sge = (u32 )qp->sq.max_gs;
#line 501
  qp_attr->cap.max_recv_sge = (u32 )qp->rq.max_gs;
#line 502
  qp_attr->cap.max_inline_data = (u32 )qp->max_inline_data;
#line 504
  qp_init_attr->cap = qp_attr->cap;
#line 505
  qp_init_attr->sq_sig_type = qp->sq_policy;
  out_mailbox: 
#line 508
  mthca_free_mailbox(dev, mailbox);
  out: 
#line 511
  mutex_unlock(& qp->mutex);
#line 512
  return (err);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static int mthca_path_set(struct mthca_dev *dev , struct ib_ah_attr  const  *ah ,
                          struct mthca_qp_path *path , u8 port ) 
{ 
  __u16 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
#line 518
  path->g_mylmc = (unsigned int )((u8 )ah->src_path_bits) & 127U;
#line 519
  tmp = __fswab16((int )ah->dlid);
#line 519
  path->rlid = tmp;
#line 520
  path->static_rate = mthca_get_rate(dev, (int )ah->static_rate, (int )port);
#line 522
  if ((int )ah->ah_flags & 1) {
#line 523
    if ((int )ah->grh.sgid_index >= dev->limits.gid_table_len) {
#line 524
      if (mthca_debug_level != 0) {
#line 524
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "sgid_index (%u) too large. max is %d\n",
                   (int )ah->grh.sgid_index, dev->limits.gid_table_len + -1);
      } else {

      }
#line 526
      return (-1);
    } else {

    }
#line 529
    path->g_mylmc = (u8 )((unsigned int )path->g_mylmc | 128U);
#line 530
    path->mgid_index = ah->grh.sgid_index;
#line 531
    path->hop_limit = ah->grh.hop_limit;
#line 532
    tmp___0 = __fswab32((unsigned int )(((int )ah->sl << 28) | ((int )ah->grh.traffic_class << 20)) | (unsigned int )ah->grh.flow_label);
#line 532
    path->sl_tclass_flowlabel = tmp___0;
#line 536
    memcpy((void *)(& path->rgid), (void const   *)(& ah->grh.dgid.raw), 16UL);
  } else {
#line 538
    tmp___1 = __fswab32((__u32 )((int )ah->sl << 28));
#line 538
    path->sl_tclass_flowlabel = tmp___1;
  }
#line 540
  return (0);
}
}
#line 543 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static int __mthca_modify_qp(struct ib_qp *ibqp , struct ib_qp_attr  const  *attr ,
                             int attr_mask , enum ib_qp_state cur_state , enum ib_qp_state new_state ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_qp *qp ;
  struct mthca_qp *tmp___0 ;
  struct mthca_mailbox *mailbox ;
  struct mthca_qp_param *qp_param ;
  struct mthca_qp_context *qp_context ;
  u32 sqd_event ;
  int err ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __u32 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  struct mthca_ucontext *tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;
  __u32 tmp___15 ;
  __u32 tmp___16 ;
  u8 tmp___17 ;
  int tmp___18 ;
  u8 sched_queue ;
  __u32 tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  __u32 tmp___22 ;
  struct mthca_pd *tmp___23 ;
  __u32 tmp___24 ;
  __u32 tmp___25 ;
  __u32 tmp___26 ;
  int tmp___27 ;
  __u32 tmp___28 ;
  __u32 tmp___29 ;
  struct mthca_cq *tmp___30 ;
  __u32 tmp___31 ;
  __u32 tmp___32 ;
  __u32 tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  __u32 tmp___36 ;
  __be32 tmp___37 ;
  __u32 tmp___38 ;
  __u32 tmp___39 ;
  __u32 tmp___40 ;
  struct mthca_cq *tmp___41 ;
  __u32 tmp___42 ;
  __u32 tmp___43 ;
  int tmp___44 ;
  __u32 tmp___45 ;
  struct mthca_srq *tmp___46 ;
  __u32 tmp___47 ;
  struct mthca_sqp *tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  struct mthca_srq *tmp___51 ;
  struct mthca_srq *tmp___52 ;
  struct mthca_cq *tmp___53 ;
  struct mthca_cq *tmp___54 ;
  int tmp___55 ;

  {
#line 547
  tmp = to_mdev(ibqp->device);
#line 547
  dev = tmp;
#line 548
  tmp___0 = to_mqp(ibqp);
#line 548
  qp = tmp___0;
#line 552
  sqd_event = 0U;
#line 553
  err = -22;
#line 555
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 556
  tmp___2 = IS_ERR((void const   *)mailbox);
#line 556
  if ((int )tmp___2) {
#line 557
    tmp___1 = PTR_ERR((void const   *)mailbox);
#line 557
    err = (int )tmp___1;
#line 558
    goto out;
  } else {

  }
#line 560
  qp_param = (struct mthca_qp_param *)mailbox->buf;
#line 561
  qp_context = & qp_param->context;
#line 562
  memset((void *)qp_param, 0, 512UL);
#line 564
  tmp___3 = to_mthca_state(new_state);
#line 564
  tmp___4 = to_mthca_st((int )qp->transport);
#line 564
  tmp___5 = __fswab32((__u32 )((tmp___3 << 28) | (tmp___4 << 16)));
#line 564
  qp_context->flags = tmp___5;
#line 566
  qp_context->flags = qp_context->flags | 65536U;
#line 567
  if ((attr_mask & 262144) == 0) {
#line 568
    qp_context->flags = qp_context->flags | 1572864U;
  } else {
#line 570
    qp_param->opt_param_mask = qp_param->opt_param_mask | 262144U;
#line 571
    switch ((unsigned int )attr->path_mig_state) {
    case 0U: 
#line 573
    qp_context->flags = qp_context->flags | 1572864U;
#line 574
    goto ldv_30936;
    case 1U: 
#line 576
    qp_context->flags = qp_context->flags | 524288U;
#line 577
    goto ldv_30936;
    case 2U: 
#line 579
    qp_context->flags = qp_context->flags;
#line 580
    goto ldv_30936;
    }
    ldv_30936: ;
  }
#line 586
  if ((unsigned int )qp->transport == 5U || (unsigned int )qp->transport == 2U) {
#line 587
    qp_context->mtu_msgmax = 139U;
  } else
#line 588
  if ((attr_mask & 256) != 0) {
#line 589
    if ((unsigned int )attr->path_mtu == 0U || (unsigned int )attr->path_mtu > 4U) {
#line 590
      if (mthca_debug_level != 0) {
#line 590
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "path MTU (%u) is invalid\n",
                   (unsigned int )attr->path_mtu);
      } else {

      }
#line 592
      goto out_mailbox;
    } else {

    }
#line 594
    qp_context->mtu_msgmax = (unsigned int )((int )((u8 )attr->path_mtu) << 5U) | 31U;
  } else {

  }
#line 597
  tmp___8 = mthca_is_memfree(dev);
#line 597
  if (tmp___8 != 0) {
#line 598
    if (qp->rq.max != 0) {
#line 599
      tmp___6 = __ilog2_u32((u32 )qp->rq.max);
#line 599
      qp_context->rq_size_stride = (int )((u8 )tmp___6) << 3U;
    } else {

    }
#line 600
    qp_context->rq_size_stride = (u8 )((int )((signed char )qp_context->rq_size_stride) | (int )((signed char )((unsigned int )((unsigned char )qp->rq.wqe_shift) + 252U)));
#line 602
    if (qp->sq.max != 0) {
#line 603
      tmp___7 = __ilog2_u32((u32 )qp->sq.max);
#line 603
      qp_context->sq_size_stride = (int )((u8 )tmp___7) << 3U;
    } else {

    }
#line 604
    qp_context->sq_size_stride = (u8 )((int )((signed char )qp_context->sq_size_stride) | (int )((signed char )((unsigned int )((unsigned char )qp->sq.wqe_shift) + 252U)));
  } else {

  }
#line 609
  if ((unsigned long )qp->ibqp.uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 610
    tmp___9 = to_mucontext((qp->ibqp.uobject)->context);
#line 610
    tmp___10 = __fswab32((__u32 )tmp___9->uar.index);
#line 610
    qp_context->usr_page = tmp___10;
  } else {
#line 613
    tmp___11 = __fswab32((__u32 )dev->driver_uar.index);
#line 613
    qp_context->usr_page = tmp___11;
  }
#line 614
  tmp___12 = __fswab32(qp->qpn);
#line 614
  qp_context->local_qpn = tmp___12;
#line 615
  if ((attr_mask & 1048576) != 0) {
#line 616
    tmp___13 = __fswab32(attr->dest_qp_num);
#line 616
    qp_context->remote_qpn = tmp___13;
  } else {

  }
#line 619
  if ((unsigned int )qp->transport == 5U) {
#line 620
    tmp___14 = __fswab32((__u32 )((int )qp->port << 24));
#line 620
    qp_context->pri_path.port_pkey = qp_context->pri_path.port_pkey | tmp___14;
  } else
#line 623
  if ((attr_mask & 32) != 0) {
#line 624
    tmp___15 = __fswab32((__u32 )((int )attr->port_num << 24));
#line 624
    qp_context->pri_path.port_pkey = qp_context->pri_path.port_pkey | tmp___15;
#line 626
    qp_param->opt_param_mask = qp_param->opt_param_mask | 524288U;
  } else {

  }
#line 630
  if ((attr_mask & 16) != 0) {
#line 631
    tmp___16 = __fswab32((__u32 )attr->pkey_index);
#line 631
    qp_context->pri_path.port_pkey = qp_context->pri_path.port_pkey | tmp___16;
#line 633
    qp_param->opt_param_mask = qp_param->opt_param_mask | 268435456U;
  } else {

  }
#line 636
  if ((attr_mask & 2048) != 0) {
#line 637
    tmp___17 = (int )((u8 )attr->rnr_retry) << 5U;
#line 637
    qp_context->pri_path.rnr_retry = tmp___17;
#line 637
    qp_context->alt_path.rnr_retry = tmp___17;
#line 639
    qp_param->opt_param_mask = qp_param->opt_param_mask | 10485760U;
  } else {

  }
#line 643
  if ((attr_mask & 128) != 0) {
#line 644
    tmp___18 = mthca_path_set(dev, & attr->ah_attr, & qp_context->pri_path, (attr_mask & 32) != 0 ? (int )attr->port_num : (int )qp->port);
#line 644
    if (tmp___18 != 0) {
#line 646
      goto out_mailbox;
    } else {

    }
#line 648
    qp_param->opt_param_mask = qp_param->opt_param_mask | 2147483648U;
  } else {

  }
#line 651
  if (((unsigned int )ibqp->qp_type == 2U && (unsigned int )cur_state == 1U) && (unsigned int )new_state == 2U) {
#line 653
    sched_queue = (unsigned long )ibqp->uobject != (unsigned long )((struct ib_uobject *)0) ? 2U : 1U;
#line 655
    tmp___20 = mthca_is_memfree(dev);
#line 655
    if (tmp___20 != 0) {
#line 656
      qp_context->rlkey_arbel_sched_queue = (u8 )((int )qp_context->rlkey_arbel_sched_queue | (int )sched_queue);
    } else {
#line 658
      tmp___19 = __fswab32((__u32 )sched_queue);
#line 658
      qp_context->tavor_sched_queue = qp_context->tavor_sched_queue | tmp___19;
    }
#line 660
    qp_param->opt_param_mask = qp_param->opt_param_mask | 256U;
  } else {

  }
#line 664
  if ((attr_mask & 512) != 0) {
#line 665
    qp_context->pri_path.ackto = (int )((u8 )attr->timeout) << 3U;
#line 666
    qp_param->opt_param_mask = qp_param->opt_param_mask | 4194304U;
  } else {

  }
#line 669
  if ((attr_mask & 16384) != 0) {
#line 670
    if ((int )attr->alt_pkey_index >= dev->limits.pkey_table_len) {
#line 671
      if (mthca_debug_level != 0) {
#line 671
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Alternate P_Key index (%u) too large. max is %d\n",
                   (int )attr->alt_pkey_index, dev->limits.pkey_table_len + -1);
      } else {

      }
#line 673
      goto out_mailbox;
    } else {

    }
#line 676
    if ((unsigned int )((unsigned char )attr->alt_port_num) == 0U || (int )attr->alt_port_num > dev->limits.num_ports) {
#line 677
      if (mthca_debug_level != 0) {
#line 677
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Alternate port number (%u) is invalid\n",
                   (int )attr->alt_port_num);
      } else {

      }
#line 679
      goto out_mailbox;
    } else {

    }
#line 682
    tmp___21 = mthca_path_set(dev, & attr->alt_ah_attr, & qp_context->alt_path, (int )attr->alt_ah_attr.port_num);
#line 682
    if (tmp___21 != 0) {
#line 684
      goto out_mailbox;
    } else {

    }
#line 686
    tmp___22 = __fswab32((__u32 )((int )attr->alt_pkey_index | ((int )attr->alt_port_num << 24)));
#line 686
    qp_context->alt_path.port_pkey = qp_context->alt_path.port_pkey | tmp___22;
#line 688
    qp_context->alt_path.ackto = (int )((u8 )attr->alt_timeout) << 3U;
#line 689
    qp_param->opt_param_mask = qp_param->opt_param_mask | 16777216U;
  } else {

  }
#line 693
  tmp___23 = to_mpd(ibqp->pd);
#line 693
  tmp___24 = __fswab32(tmp___23->pd_num);
#line 693
  qp_context->pd = tmp___24;
#line 695
  tmp___25 = __fswab32(qp->mr.ibmr.lkey);
#line 695
  qp_context->wqe_lkey = tmp___25;
#line 696
  qp_context->params1 = 4194473U;
#line 699
  if ((unsigned int )qp->sq_policy == 0U) {
#line 700
    qp_context->params1 = qp_context->params1 | 134217728U;
  } else {

  }
#line 701
  if ((attr_mask & 1024) != 0) {
#line 702
    tmp___26 = __fswab32((__u32 )((int )attr->retry_cnt << 16));
#line 702
    qp_context->params1 = qp_context->params1 | tmp___26;
#line 703
    qp_param->opt_param_mask = qp_param->opt_param_mask | 1048576U;
  } else {

  }
#line 706
  if ((attr_mask & 8192) != 0) {
#line 707
    if ((unsigned int )((unsigned char )attr->max_rd_atomic) != 0U) {
#line 708
      qp_context->params1 = qp_context->params1 | 10485760U;
#line 711
      tmp___27 = fls((int )attr->max_rd_atomic + -1);
#line 711
      tmp___28 = __fswab32((__u32 )(tmp___27 << 21));
#line 711
      qp_context->params1 = qp_context->params1 | tmp___28;
    } else {

    }
#line 714
    qp_param->opt_param_mask = qp_param->opt_param_mask | 65536U;
  } else {

  }
#line 717
  if ((attr_mask & 65536) != 0) {
#line 718
    tmp___29 = __fswab32(attr->sq_psn);
#line 718
    qp_context->next_send_psn = tmp___29;
  } else {

  }
#line 719
  tmp___30 = to_mcq(ibqp->send_cq);
#line 719
  tmp___31 = __fswab32((__u32 )tmp___30->cqn);
#line 719
  qp_context->cqn_snd = tmp___31;
#line 721
  tmp___34 = mthca_is_memfree(dev);
#line 721
  if (tmp___34 != 0) {
#line 722
    tmp___32 = __fswab32((__u32 )qp->send_wqe_offset);
#line 722
    qp_context->snd_wqe_base_l = tmp___32;
#line 723
    tmp___33 = __fswab32((__u32 )qp->sq.db_index);
#line 723
    qp_context->snd_db_index = tmp___33;
  } else {

  }
#line 726
  if ((attr_mask & 131072) != 0) {
#line 727
    if ((unsigned int )((unsigned char )attr->max_dest_rd_atomic) != 0U) {
#line 728
      tmp___35 = fls((int )attr->max_dest_rd_atomic + -1);
#line 728
      tmp___36 = __fswab32((__u32 )(tmp___35 << 21));
#line 728
      qp_context->params2 = qp_context->params2 | tmp___36;
    } else {

    }
#line 731
    qp_param->opt_param_mask = qp_param->opt_param_mask | 131072U;
  } else {

  }
#line 734
  if ((attr_mask & 131080) != 0) {
#line 735
    tmp___37 = get_hw_access_flags(qp, attr, attr_mask);
#line 735
    qp_context->params2 = qp_context->params2 | tmp___37;
#line 736
    qp_param->opt_param_mask = qp_param->opt_param_mask | 234881024U;
  } else {

  }
#line 741
  qp_context->params2 = qp_context->params2 | 134217728U;
#line 743
  if ((unsigned long )ibqp->srq != (unsigned long )((struct ib_srq *)0)) {
#line 744
    qp_context->params2 = qp_context->params2 | 268435456U;
  } else {

  }
#line 746
  if ((attr_mask & 32768) != 0) {
#line 747
    tmp___38 = __fswab32((__u32 )((int )attr->min_rnr_timer << 24));
#line 747
    qp_context->rnr_nextrecvpsn = qp_context->rnr_nextrecvpsn | tmp___38;
#line 748
    qp_param->opt_param_mask = qp_param->opt_param_mask | 1073741824U;
  } else {

  }
#line 750
  if ((attr_mask & 4096) != 0) {
#line 751
    tmp___39 = __fswab32(attr->rq_psn);
#line 751
    qp_context->rnr_nextrecvpsn = qp_context->rnr_nextrecvpsn | tmp___39;
  } else {

  }
#line 753
  tmp___40 = __fswab32(dev->qp_table.rdb_base + ((qp->qpn & (u32 )(dev->limits.num_qps + -1)) * 32U << dev->qp_table.rdb_shift));
#line 753
  qp_context->ra_buff_indx = tmp___40;
#line 758
  tmp___41 = to_mcq(ibqp->recv_cq);
#line 758
  tmp___42 = __fswab32((__u32 )tmp___41->cqn);
#line 758
  qp_context->cqn_rcv = tmp___42;
#line 760
  tmp___44 = mthca_is_memfree(dev);
#line 760
  if (tmp___44 != 0) {
#line 761
    tmp___43 = __fswab32((__u32 )qp->rq.db_index);
#line 761
    qp_context->rcv_db_index = tmp___43;
  } else {

  }
#line 763
  if ((attr_mask & 64) != 0) {
#line 764
    tmp___45 = __fswab32(attr->qkey);
#line 764
    qp_context->qkey = tmp___45;
#line 765
    qp_param->opt_param_mask = qp_param->opt_param_mask | 536870912U;
  } else {

  }
#line 768
  if ((unsigned long )ibqp->srq != (unsigned long )((struct ib_srq *)0)) {
#line 769
    tmp___46 = to_msrq(ibqp->srq);
#line 769
    tmp___47 = __fswab32((__u32 )(tmp___46->srqn | 16777216));
#line 769
    qp_context->srqn = tmp___47;
  } else {

  }
#line 772
  if ((((unsigned int )cur_state == 3U && (unsigned int )new_state == 4U) && (attr_mask & 4) != 0) && (unsigned int )((unsigned char )attr->en_sqd_async_notify) != 0U) {
#line 775
    sqd_event = 2147483648U;
  } else {

  }
#line 777
  err = mthca_MODIFY_QP(dev, cur_state, new_state, qp->qpn, 0, mailbox, sqd_event);
#line 779
  if (err != 0) {
#line 780
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "modify QP %d->%d returned %d.\n",
             (unsigned int )cur_state, (unsigned int )new_state, err);
#line 782
    goto out_mailbox;
  } else {

  }
#line 785
  qp->state = (u8 )new_state;
#line 786
  if ((attr_mask & 8) != 0) {
#line 787
    qp->atomic_rd_en = (u8 )attr->qp_access_flags;
  } else {

  }
#line 788
  if ((attr_mask & 131072) != 0) {
#line 789
    qp->resp_depth = attr->max_dest_rd_atomic;
  } else {

  }
#line 790
  if ((attr_mask & 32) != 0) {
#line 791
    qp->port = attr->port_num;
  } else {

  }
#line 792
  if ((attr_mask & 16384) != 0) {
#line 793
    qp->alt_port = attr->alt_port_num;
  } else {

  }
#line 795
  tmp___49 = is_sqp(dev, qp);
#line 795
  if (tmp___49 != 0) {
#line 796
    tmp___48 = to_msqp(qp);
#line 796
    store_attrs(tmp___48, attr, attr_mask);
  } else {

  }
#line 802
  tmp___50 = is_qp0(dev, qp);
#line 802
  if (tmp___50 != 0) {
#line 803
    if ((unsigned int )cur_state != 2U && (unsigned int )new_state == 2U) {
#line 805
      init_port(dev, (int )qp->port);
    } else {

    }
#line 807
    if (((unsigned int )cur_state != 0U && (unsigned int )cur_state != 6U) && ((unsigned int )new_state == 0U || (unsigned int )new_state == 6U)) {
#line 811
      mthca_CLOSE_IB(dev, (int )qp->port);
    } else {

    }
  } else {

  }
#line 818
  if ((unsigned int )new_state == 0U && (unsigned long )qp->ibqp.uobject == (unsigned long )((struct ib_uobject *)0)) {
#line 819
    if ((unsigned long )qp->ibqp.srq != (unsigned long )((struct ib_srq *)0)) {
#line 819
      tmp___51 = to_msrq(qp->ibqp.srq);
#line 819
      tmp___52 = tmp___51;
    } else {
#line 819
      tmp___52 = (struct mthca_srq *)0;
    }
#line 819
    tmp___53 = to_mcq(qp->ibqp.recv_cq);
#line 819
    mthca_cq_clean(dev, tmp___53, qp->qpn, tmp___52);
#line 821
    if ((unsigned long )qp->ibqp.send_cq != (unsigned long )qp->ibqp.recv_cq) {
#line 822
      tmp___54 = to_mcq(qp->ibqp.send_cq);
#line 822
      mthca_cq_clean(dev, tmp___54, qp->qpn, (struct mthca_srq *)0);
    } else {

    }
#line 824
    mthca_wq_reset(& qp->sq);
#line 825
    qp->sq.last = get_send_wqe(qp, qp->sq.max + -1);
#line 827
    mthca_wq_reset(& qp->rq);
#line 828
    qp->rq.last = get_recv_wqe(qp, qp->rq.max + -1);
#line 830
    tmp___55 = mthca_is_memfree(dev);
#line 830
    if (tmp___55 != 0) {
#line 831
      *(qp->sq.db) = 0U;
#line 832
      *(qp->rq.db) = 0U;
    } else {

    }
  } else {

  }
  out_mailbox: 
#line 837
  mthca_free_mailbox(dev, mailbox);
  out: ;
#line 839
  return (err);
}
}
#line 842 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
int mthca_modify_qp(struct ib_qp *ibqp , struct ib_qp_attr *attr , int attr_mask ,
                    struct ib_udata *udata ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_qp *qp ;
  struct mthca_qp *tmp___0 ;
  enum ib_qp_state cur_state ;
  enum ib_qp_state new_state ;
  int err ;
  int tmp___1 ;

  {
#line 845
  tmp = to_mdev(ibqp->device);
#line 845
  dev = tmp;
#line 846
  tmp___0 = to_mqp(ibqp);
#line 846
  qp = tmp___0;
#line 848
  err = -22;
#line 850
  mutex_lock_nested(& qp->mutex, 0U);
#line 851
  if ((attr_mask & 2) != 0) {
#line 852
    cur_state = attr->cur_qp_state;
  } else {
#line 854
    spin_lock_irq(& qp->sq.lock);
#line 855
    spin_lock(& qp->rq.lock);
#line 856
    cur_state = (enum ib_qp_state )qp->state;
#line 857
    spin_unlock(& qp->rq.lock);
#line 858
    spin_unlock_irq(& qp->sq.lock);
  }
#line 861
  new_state = attr_mask & 1 ? attr->qp_state : cur_state;
#line 863
  tmp___1 = ib_modify_qp_is_ok(cur_state, new_state, ibqp->qp_type, (enum ib_qp_attr_mask )attr_mask,
                               0);
#line 863
  if (tmp___1 == 0) {
#line 865
    if (mthca_debug_level != 0) {
#line 865
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Bad QP transition (transport %d) %d->%d with attr 0x%08x\n",
                 (int )qp->transport, (unsigned int )cur_state, (unsigned int )new_state,
                 attr_mask);
    } else {

    }
#line 869
    goto out;
  } else {

  }
#line 872
  if ((attr_mask & 16) != 0 && (int )attr->pkey_index >= dev->limits.pkey_table_len) {
#line 874
    if (mthca_debug_level != 0) {
#line 874
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "P_Key index (%u) too large. max is %d\n",
                 (int )attr->pkey_index, dev->limits.pkey_table_len + -1);
    } else {

    }
#line 876
    goto out;
  } else {

  }
#line 879
  if ((attr_mask & 32) != 0 && ((unsigned int )attr->port_num == 0U || (int )attr->port_num > dev->limits.num_ports)) {
#line 881
    if (mthca_debug_level != 0) {
#line 881
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Port number (%u) is invalid\n",
                 (int )attr->port_num);
    } else {

    }
#line 882
    goto out;
  } else {

  }
#line 885
  if ((attr_mask & 8192) != 0 && (int )attr->max_rd_atomic > dev->limits.max_qp_init_rdma) {
#line 887
    if (mthca_debug_level != 0) {
#line 887
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max rdma_atomic as initiator %u too large (max is %d)\n",
                 (int )attr->max_rd_atomic, dev->limits.max_qp_init_rdma);
    } else {

    }
#line 889
    goto out;
  } else {

  }
#line 892
  if ((attr_mask & 131072) != 0 && (int )attr->max_dest_rd_atomic > 1 << dev->qp_table.rdb_shift) {
#line 894
    if (mthca_debug_level != 0) {
#line 894
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max rdma_atomic as responder %u too large (max %d)\n",
                 (int )attr->max_dest_rd_atomic, 1 << dev->qp_table.rdb_shift);
    } else {

    }
#line 896
    goto out;
  } else {

  }
#line 899
  if ((unsigned int )cur_state == (unsigned int )new_state && (unsigned int )cur_state == 0U) {
#line 900
    err = 0;
#line 901
    goto out;
  } else {

  }
#line 904
  err = __mthca_modify_qp(ibqp, (struct ib_qp_attr  const  *)attr, attr_mask, cur_state,
                          new_state);
  out: 
#line 907
  mutex_unlock(& qp->mutex);
#line 908
  return (err);
}
}
#line 911 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static int mthca_max_data_size(struct mthca_dev *dev , struct mthca_qp *qp , int desc_sz ) 
{ 
  int max_data_size ;
  int tmp ;

  {
#line 917
  max_data_size = (int )((unsigned int )desc_sz - 16U);
#line 919
  switch ((int )qp->transport) {
  case 5: 
#line 921
  max_data_size = (int )((unsigned int )max_data_size - 32U);
#line 922
  goto ldv_30960;
  case 2: 
#line 925
  tmp = mthca_is_memfree(dev);
#line 925
  if (tmp != 0) {
#line 926
    max_data_size = (int )((unsigned int )max_data_size - 48U);
  } else {
#line 928
    max_data_size = (int )((unsigned int )max_data_size - 48U);
  }
#line 929
  goto ldv_30960;
  default: 
#line 932
  max_data_size = (int )((unsigned int )max_data_size - 16U);
#line 933
  goto ldv_30960;
  }
  ldv_30960: ;
#line 936
  return (max_data_size);
}
}
#line 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
__inline static int mthca_max_inline_data(struct mthca_pd *pd , int max_data_size ) 
{ 


  {
#line 942
  return ((unsigned long )pd->ibpd.uobject != (unsigned long )((struct ib_uobject *)0) ? max_data_size + -4 : 0);
}
}
#line 945 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static void mthca_adjust_qp_caps(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_qp *qp ) 
{ 
  int max_data_size ;
  int _min1 ;
  int _min2 ;
  int tmp ;
  int __min1 ;
  int __min2 ;
  int __min1___0 ;
  int __min2___0 ;
  int _min1___0 ;
  int _min2___0 ;

  {
#line 950
  _min1 = dev->limits.max_desc_sz;
#line 950
  _min2 = 1 << qp->sq.wqe_shift;
#line 950
  tmp = mthca_max_data_size(dev, qp, _min1 < _min2 ? _min1 : _min2);
#line 950
  max_data_size = tmp;
#line 953
  qp->max_inline_data = mthca_max_inline_data(pd, max_data_size);
#line 955
  __min1 = dev->limits.max_sg;
#line 955
  __min2 = (int )((unsigned long )max_data_size / 16UL);
#line 955
  qp->sq.max_gs = __min1 < __min2 ? __min1 : __min2;
#line 957
  __min1___0 = dev->limits.max_sg;
#line 957
  _min1___0 = dev->limits.max_desc_sz;
#line 957
  _min2___0 = 1 << qp->rq.wqe_shift;
#line 957
  __min2___0 = (int )(((unsigned long )(_min1___0 < _min2___0 ? _min1___0 : _min2___0) - 16UL) / 16UL);
#line 957
  qp->rq.max_gs = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
#line 959
  return;
}
}
#line 970 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static int mthca_alloc_wqe_buf(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_qp *qp ) 
{ 
  int size ;
  int err ;
  int __max1 ;
  int __max2 ;
  int __max1___0 ;
  int __max2___0 ;
  void *tmp ;

  {
#line 975
  err = -12;
#line 977
  size = (int )((unsigned int )((unsigned long )qp->rq.max_gs + 1UL) * 16U);
#line 980
  if (dev->limits.max_desc_sz < size) {
#line 981
    return (-22);
  } else {

  }
#line 983
  qp->rq.wqe_shift = 6;
#line 983
  goto ldv_30993;
  ldv_30992: 
#line 984
  qp->rq.wqe_shift = qp->rq.wqe_shift + 1;
  ldv_30993: ;
#line 983
  if (1 << qp->rq.wqe_shift < size) {
#line 985
    goto ldv_30992;
  } else {

  }
#line 987
  size = (int )((unsigned int )qp->sq.max_gs * 16U);
#line 988
  switch ((int )qp->transport) {
  case 5: 
#line 990
  size = (int )((unsigned int )size + 32U);
#line 991
  goto ldv_30996;
  case 2: 
#line 994
  mthca_is_memfree(dev);
#line 994
  size = (int )((unsigned long )size + 48UL);
#line 997
  goto ldv_30996;
  case 1: 
#line 1000
  size = (int )((unsigned int )size + 16U);
#line 1001
  goto ldv_30996;
  case 0: 
#line 1004
  size = (int )((unsigned int )size + 16U);
#line 1009
  __max1 = size;
#line 1009
  __max2 = 48;
#line 1009
  size = __max1 > __max2 ? __max1 : __max2;
#line 1013
  goto ldv_30996;
  default: ;
#line 1016
  goto ldv_30996;
  }
  ldv_30996: 
#line 1020
  __max1___0 = size;
#line 1020
  __max2___0 = 32;
#line 1020
  size = __max1___0 > __max2___0 ? __max1___0 : __max2___0;
#line 1022
  size = (int )((unsigned int )size + 16U);
#line 1024
  if (dev->limits.max_desc_sz < size) {
#line 1025
    return (-22);
  } else {

  }
#line 1027
  qp->sq.wqe_shift = 6;
#line 1027
  goto ldv_31008;
  ldv_31007: 
#line 1028
  qp->sq.wqe_shift = qp->sq.wqe_shift + 1;
  ldv_31008: ;
#line 1027
  if (1 << qp->sq.wqe_shift < size) {
#line 1029
    goto ldv_31007;
  } else {

  }
#line 1031
  qp->send_wqe_offset = ((qp->rq.max << qp->rq.wqe_shift) + ((1 << qp->sq.wqe_shift) + -1)) & - (1 << qp->sq.wqe_shift);
#line 1039
  if ((unsigned long )pd->ibpd.uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 1040
    return (0);
  } else {

  }
#line 1042
  size = ((qp->send_wqe_offset + (qp->sq.max << qp->sq.wqe_shift)) + 4095) & -4096;
#line 1045
  tmp = kmalloc((unsigned long )(qp->rq.max + qp->sq.max) * 8UL, 208U);
#line 1045
  qp->wrid = (u64 *)tmp;
#line 1047
  if ((unsigned long )qp->wrid == (unsigned long )((u64 *)0ULL)) {
#line 1048
    goto err_out;
  } else {

  }
#line 1050
  err = mthca_buf_alloc(dev, size, 16384, & qp->queue, & qp->is_direct, pd, 0, & qp->mr);
#line 1052
  if (err != 0) {
#line 1053
    goto err_out;
  } else {

  }
#line 1055
  return (0);
  err_out: 
#line 1058
  kfree((void const   *)qp->wrid);
#line 1059
  return (err);
}
}
#line 1062 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static void mthca_free_wqe_buf(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ 


  {
#line 1065
  mthca_buf_free(dev, ((qp->send_wqe_offset + (qp->sq.max << qp->sq.wqe_shift)) + 4095) & -4096,
                 & qp->queue, qp->is_direct, & qp->mr);
#line 1068
  kfree((void const   *)qp->wrid);
#line 1069
  return;
}
}
#line 1071 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static int mthca_map_memfree(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ 
  int ret ;
  int tmp ;

  {
#line 1076
  tmp = mthca_is_memfree(dev);
#line 1076
  if (tmp != 0) {
#line 1077
    ret = mthca_table_get(dev, dev->qp_table.qp_table, (int )qp->qpn);
#line 1078
    if (ret != 0) {
#line 1079
      return (ret);
    } else {

    }
#line 1081
    ret = mthca_table_get(dev, dev->qp_table.eqp_table, (int )qp->qpn);
#line 1082
    if (ret != 0) {
#line 1083
      goto err_qpc;
    } else {

    }
#line 1085
    ret = mthca_table_get(dev, dev->qp_table.rdb_table, (int )(qp->qpn << dev->qp_table.rdb_shift));
#line 1087
    if (ret != 0) {
#line 1088
      goto err_eqpc;
    } else {

    }
  } else {

  }
#line 1092
  return (0);
  err_eqpc: 
#line 1095
  mthca_table_put(dev, dev->qp_table.eqp_table, (int )qp->qpn);
  err_qpc: 
#line 1098
  mthca_table_put(dev, dev->qp_table.qp_table, (int )qp->qpn);
#line 1100
  return (ret);
}
}
#line 1103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static void mthca_unmap_memfree(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ 


  {
#line 1106
  mthca_table_put(dev, dev->qp_table.rdb_table, (int )(qp->qpn << dev->qp_table.rdb_shift));
#line 1108
  mthca_table_put(dev, dev->qp_table.eqp_table, (int )qp->qpn);
#line 1109
  mthca_table_put(dev, dev->qp_table.qp_table, (int )qp->qpn);
#line 1110
  return;
}
}
#line 1112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static int mthca_alloc_memfree(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ 
  int tmp ;

  {
#line 1115
  tmp = mthca_is_memfree(dev);
#line 1115
  if (tmp != 0) {
#line 1116
    qp->rq.db_index = mthca_alloc_db(dev, 4, qp->qpn, & qp->rq.db);
#line 1118
    if (qp->rq.db_index < 0) {
#line 1119
      return (-12);
    } else {

    }
#line 1121
    qp->sq.db_index = mthca_alloc_db(dev, 3, qp->qpn, & qp->sq.db);
#line 1123
    if (qp->sq.db_index < 0) {
#line 1124
      mthca_free_db(dev, 4, qp->rq.db_index);
#line 1125
      return (-12);
    } else {

    }
  } else {

  }
#line 1129
  return (0);
}
}
#line 1132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static void mthca_free_memfree(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ 
  int tmp ;

  {
#line 1135
  tmp = mthca_is_memfree(dev);
#line 1135
  if (tmp != 0) {
#line 1136
    mthca_free_db(dev, 3, qp->sq.db_index);
#line 1137
    mthca_free_db(dev, 4, qp->rq.db_index);
  } else {

  }
#line 1139
  return;
}
}
#line 1141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static int mthca_alloc_qp_common(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_cq *send_cq ,
                                 struct mthca_cq *recv_cq , enum ib_sig_type send_policy ,
                                 struct mthca_qp *qp ) 
{ 
  int ret ;
  int i ;
  struct mthca_next_seg *next ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct mthca_data_seg *scatter ;
  int size ;
  void *tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  void *tmp___2 ;
  __u32 tmp___3 ;
  void *tmp___4 ;
  __u32 tmp___5 ;
  int tmp___6 ;

  {
#line 1152
  qp->refcount = 1;
#line 1153
  __init_waitqueue_head(& qp->wait, "&qp->wait", & __key);
#line 1154
  __mutex_init(& qp->mutex, "&qp->mutex", & __key___0);
#line 1155
  qp->state = 0U;
#line 1156
  qp->atomic_rd_en = 0U;
#line 1157
  qp->resp_depth = 0U;
#line 1158
  qp->sq_policy = send_policy;
#line 1159
  mthca_wq_reset(& qp->sq);
#line 1160
  mthca_wq_reset(& qp->rq);
#line 1162
  spinlock_check(& qp->sq.lock);
#line 1162
  __raw_spin_lock_init(& qp->sq.lock.__annonCompField18.rlock, "&(&qp->sq.lock)->rlock",
                       & __key___1);
#line 1163
  spinlock_check(& qp->rq.lock);
#line 1163
  __raw_spin_lock_init(& qp->rq.lock.__annonCompField18.rlock, "&(&qp->rq.lock)->rlock",
                       & __key___2);
#line 1165
  ret = mthca_map_memfree(dev, qp);
#line 1166
  if (ret != 0) {
#line 1167
    return (ret);
  } else {

  }
#line 1169
  ret = mthca_alloc_wqe_buf(dev, pd, qp);
#line 1170
  if (ret != 0) {
#line 1171
    mthca_unmap_memfree(dev, qp);
#line 1172
    return (ret);
  } else {

  }
#line 1175
  mthca_adjust_qp_caps(dev, pd, qp);
#line 1182
  if ((unsigned long )pd->ibpd.uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 1183
    return (0);
  } else {

  }
#line 1185
  ret = mthca_alloc_memfree(dev, qp);
#line 1186
  if (ret != 0) {
#line 1187
    mthca_free_wqe_buf(dev, qp);
#line 1188
    mthca_unmap_memfree(dev, qp);
#line 1189
    return (ret);
  } else {

  }
#line 1192
  tmp___6 = mthca_is_memfree(dev);
#line 1192
  if (tmp___6 != 0) {
#line 1194
    size = (int )((((unsigned long )qp->rq.max_gs + 1UL) * 16UL) / 16UL);
#line 1197
    i = 0;
#line 1197
    goto ldv_31055;
    ldv_31054: 
#line 1198
    tmp = get_recv_wqe(qp, i);
#line 1198
    next = (struct mthca_next_seg *)tmp;
#line 1199
    tmp___0 = __fswab32((__u32 )(((i + 1) & (qp->rq.max + -1)) << qp->rq.wqe_shift));
#line 1199
    next->nda_op = tmp___0;
#line 1201
    tmp___1 = __fswab32((__u32 )size);
#line 1201
    next->ee_nds = tmp___1;
#line 1203
    scatter = (struct mthca_data_seg *)next + 1U;
#line 1203
    goto ldv_31052;
    ldv_31051: 
#line 1206
    scatter->lkey = 65536U;
#line 1205
    scatter = scatter + 1;
    ldv_31052: ;
#line 1203
    if ((unsigned long )((void *)next + (unsigned long )(1 << qp->rq.wqe_shift)) > (unsigned long )((void *)scatter)) {
#line 1206
      goto ldv_31051;
    } else {

    }
#line 1197
    i = i + 1;
    ldv_31055: ;
#line 1197
    if (qp->rq.max > i) {
#line 1199
      goto ldv_31054;
    } else {

    }
#line 1209
    i = 0;
#line 1209
    goto ldv_31058;
    ldv_31057: 
#line 1210
    tmp___2 = get_send_wqe(qp, i);
#line 1210
    next = (struct mthca_next_seg *)tmp___2;
#line 1211
    tmp___3 = __fswab32((__u32 )((((i + 1) & (qp->sq.max + -1)) << qp->sq.wqe_shift) + qp->send_wqe_offset));
#line 1211
    next->nda_op = tmp___3;
#line 1209
    i = i + 1;
    ldv_31058: ;
#line 1209
    if (qp->sq.max > i) {
#line 1211
      goto ldv_31057;
    } else {

    }

  } else {
#line 1216
    i = 0;
#line 1216
    goto ldv_31061;
    ldv_31060: 
#line 1217
    tmp___4 = get_recv_wqe(qp, i);
#line 1217
    next = (struct mthca_next_seg *)tmp___4;
#line 1218
    tmp___5 = __fswab32((__u32 )(((i + 1) % qp->rq.max << qp->rq.wqe_shift) | 1));
#line 1218
    next->nda_op = tmp___5;
#line 1216
    i = i + 1;
    ldv_31061: ;
#line 1216
    if (qp->rq.max > i) {
#line 1218
      goto ldv_31060;
    } else {

    }

  }
#line 1224
  qp->sq.last = get_send_wqe(qp, qp->sq.max + -1);
#line 1225
  qp->rq.last = get_recv_wqe(qp, qp->rq.max + -1);
#line 1227
  return (0);
}
}
#line 1230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static int mthca_set_qp_size(struct mthca_dev *dev , struct ib_qp_cap *cap , struct mthca_pd *pd ,
                             struct mthca_qp *qp ) 
{ 
  int max_data_size ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  int __max1 ;
  int __max2 ;

  {
#line 1233
  tmp = mthca_max_data_size(dev, qp, dev->limits.max_desc_sz);
#line 1233
  max_data_size = tmp;
#line 1236
  if (((cap->max_send_wr > (u32 )dev->limits.max_wqes || cap->max_recv_wr > (u32 )dev->limits.max_wqes) || cap->max_send_sge > (u32 )dev->limits.max_sg) || cap->max_recv_sge > (u32 )dev->limits.max_sg) {
#line 1241
    return (-22);
  } else {
#line 1236
    tmp___0 = mthca_max_inline_data(pd, max_data_size);
#line 1236
    if (cap->max_inline_data > (u32 )tmp___0) {
#line 1241
      return (-22);
    } else {

    }
  }
#line 1247
  if ((unsigned int )qp->transport == 5U && cap->max_send_sge + 2U > (u32 )dev->limits.max_sg) {
#line 1248
    return (-22);
  } else {

  }
#line 1250
  tmp___3 = mthca_is_memfree(dev);
#line 1250
  if (tmp___3 != 0) {
#line 1251
    if (cap->max_recv_wr != 0U) {
#line 1251
      tmp___1 = __roundup_pow_of_two((unsigned long )cap->max_recv_wr);
#line 1251
      qp->rq.max = (int )tmp___1;
    } else {
#line 1251
      qp->rq.max = 0;
    }
#line 1253
    if (cap->max_send_wr != 0U) {
#line 1253
      tmp___2 = __roundup_pow_of_two((unsigned long )cap->max_send_wr);
#line 1253
      qp->sq.max = (int )tmp___2;
    } else {
#line 1253
      qp->sq.max = 0;
    }
  } else {
#line 1256
    qp->rq.max = (int )cap->max_recv_wr;
#line 1257
    qp->sq.max = (int )cap->max_send_wr;
  }
#line 1260
  qp->rq.max_gs = (int )cap->max_recv_sge;
#line 1261
  __max1 = (int )cap->max_send_sge;
#line 1261
  __max2 = (int )(((unsigned long )(cap->max_inline_data + 19U) & 4294967280UL) / 16UL);
#line 1261
  qp->sq.max_gs = __max1 > __max2 ? __max1 : __max2;
#line 1266
  return (0);
}
}
#line 1269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
int mthca_alloc_qp(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_cq *send_cq ,
                   struct mthca_cq *recv_cq , enum ib_qp_type type , enum ib_sig_type send_policy ,
                   struct ib_qp_cap *cap , struct mthca_qp *qp ) 
{ 
  int err ;

  {
#line 1280
  switch ((unsigned int )type) {
  case 2U: 
#line 1281
  qp->transport = 0U;
#line 1281
  goto ldv_31085;
  case 3U: 
#line 1282
  qp->transport = 1U;
#line 1282
  goto ldv_31085;
  case 4U: 
#line 1283
  qp->transport = 2U;
#line 1283
  goto ldv_31085;
  default: ;
#line 1284
  return (-22);
  }
  ldv_31085: 
#line 1287
  err = mthca_set_qp_size(dev, cap, pd, qp);
#line 1288
  if (err != 0) {
#line 1289
    return (err);
  } else {

  }
#line 1291
  qp->qpn = mthca_alloc(& dev->qp_table.alloc);
#line 1292
  if (qp->qpn == 4294967295U) {
#line 1293
    return (-12);
  } else {

  }
#line 1296
  qp->port = 0U;
#line 1298
  err = mthca_alloc_qp_common(dev, pd, send_cq, recv_cq, send_policy, qp);
#line 1300
  if (err != 0) {
#line 1301
    mthca_free(& dev->qp_table.alloc, qp->qpn);
#line 1302
    return (err);
  } else {

  }
#line 1305
  spin_lock_irq(& dev->qp_table.lock);
#line 1306
  mthca_array_set(& dev->qp_table.qp, (int )(qp->qpn & (u32 )(dev->limits.num_qps + -1)),
                  (void *)qp);
#line 1308
  spin_unlock_irq(& dev->qp_table.lock);
#line 1310
  return (0);
}
}
#line 1313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static void mthca_lock_cqs(struct mthca_cq *send_cq , struct mthca_cq *recv_cq ) 
{ 
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1316
  if ((unsigned long )send_cq == (unsigned long )recv_cq) {
#line 1317
    spin_lock_irq(& send_cq->lock);
  } else
#line 1319
  if (send_cq->cqn < recv_cq->cqn) {
#line 1320
    spin_lock_irq(& send_cq->lock);
#line 1321
    tmp = spinlock_check(& recv_cq->lock);
#line 1321
    _raw_spin_lock_nested(tmp, 1);
  } else {
#line 1323
    spin_lock_irq(& recv_cq->lock);
#line 1324
    tmp___0 = spinlock_check(& send_cq->lock);
#line 1324
    _raw_spin_lock_nested(tmp___0, 1);
  }
#line 1326
  return;
}
}
#line 1328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static void mthca_unlock_cqs(struct mthca_cq *send_cq , struct mthca_cq *recv_cq ) 
{ 


  {
#line 1331
  if ((unsigned long )send_cq == (unsigned long )recv_cq) {
#line 1333
    spin_unlock_irq(& send_cq->lock);
  } else
#line 1334
  if (send_cq->cqn < recv_cq->cqn) {
#line 1335
    spin_unlock(& recv_cq->lock);
#line 1336
    spin_unlock_irq(& send_cq->lock);
  } else {
#line 1338
    spin_unlock(& send_cq->lock);
#line 1339
    spin_unlock_irq(& recv_cq->lock);
  }
#line 1341
  return;
}
}
#line 1343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
int mthca_alloc_sqp(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_cq *send_cq ,
                    struct mthca_cq *recv_cq , enum ib_sig_type send_policy , struct ib_qp_cap *cap ,
                    int qpn , int port , struct mthca_sqp *sqp ) 
{ 
  u32 mqpn ;
  int err ;
  void *tmp ;

  {
#line 1353
  mqpn = (u32 )(((qpn * 2 + dev->qp_table.sqp_start) + port) + -1);
#line 1356
  sqp->qp.transport = 5U;
#line 1357
  err = mthca_set_qp_size(dev, cap, pd, & sqp->qp);
#line 1358
  if (err != 0) {
#line 1359
    return (err);
  } else {

  }
#line 1361
  sqp->header_buf_size = sqp->qp.sq.max * 72;
#line 1362
  sqp->header_buf = dma_alloc_attrs(& (dev->pdev)->dev, (size_t )sqp->header_buf_size,
                                    & sqp->header_dma, 208U, (struct dma_attrs *)0);
#line 1364
  if ((unsigned long )sqp->header_buf == (unsigned long )((void *)0)) {
#line 1365
    return (-12);
  } else {

  }
#line 1367
  spin_lock_irq(& dev->qp_table.lock);
#line 1368
  tmp = mthca_array_get(& dev->qp_table.qp, (int )mqpn);
#line 1368
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1369
    err = -16;
  } else {
#line 1371
    mthca_array_set(& dev->qp_table.qp, (int )mqpn, (void *)sqp);
  }
#line 1372
  spin_unlock_irq(& dev->qp_table.lock);
#line 1374
  if (err != 0) {
#line 1375
    goto err_out;
  } else {

  }
#line 1377
  sqp->qp.port = (u8 )port;
#line 1378
  sqp->qp.qpn = mqpn;
#line 1379
  sqp->qp.transport = 5U;
#line 1381
  err = mthca_alloc_qp_common(dev, pd, send_cq, recv_cq, send_policy, & sqp->qp);
#line 1383
  if (err != 0) {
#line 1384
    goto err_out_free;
  } else {

  }
#line 1386
  atomic_inc(& pd->sqp_count);
#line 1388
  return (0);
  err_out_free: 
#line 1395
  mthca_lock_cqs(send_cq, recv_cq);
#line 1397
  spin_lock(& dev->qp_table.lock);
#line 1398
  mthca_array_clear(& dev->qp_table.qp, (int )mqpn);
#line 1399
  spin_unlock(& dev->qp_table.lock);
#line 1401
  mthca_unlock_cqs(send_cq, recv_cq);
  err_out: 
#line 1404
  dma_free_attrs(& (dev->pdev)->dev, (size_t )sqp->header_buf_size, sqp->header_buf,
                 sqp->header_dma, (struct dma_attrs *)0);
#line 1407
  return (err);
}
}
#line 1410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
__inline static int get_qp_refcount(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ 
  int c ;

  {
#line 1414
  spin_lock_irq(& dev->qp_table.lock);
#line 1415
  c = qp->refcount;
#line 1416
  spin_unlock_irq(& dev->qp_table.lock);
#line 1418
  return (c);
}
}
#line 1421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
void mthca_free_qp(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ 
  struct mthca_cq *send_cq ;
  struct mthca_cq *recv_cq ;
  int tmp ;
  wait_queue_t __wait ;
  long __ret ;
  long __int ;
  long tmp___0 ;
  int tmp___1 ;
  struct mthca_srq *tmp___2 ;
  struct mthca_srq *tmp___3 ;
  struct mthca_pd *tmp___4 ;
  struct mthca_sqp *tmp___5 ;
  struct mthca_sqp *tmp___6 ;
  struct mthca_sqp *tmp___7 ;
  int tmp___8 ;

  {
#line 1427
  send_cq = to_mcq(qp->ibqp.send_cq);
#line 1428
  recv_cq = to_mcq(qp->ibqp.recv_cq);
#line 1434
  mthca_lock_cqs(send_cq, recv_cq);
#line 1436
  spin_lock(& dev->qp_table.lock);
#line 1437
  mthca_array_clear(& dev->qp_table.qp, (int )(qp->qpn & (u32 )(dev->limits.num_qps + -1)));
#line 1439
  qp->refcount = qp->refcount - 1;
#line 1440
  spin_unlock(& dev->qp_table.lock);
#line 1442
  mthca_unlock_cqs(send_cq, recv_cq);
#line 1444
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c",
                1444, 0);
#line 1444
  tmp = get_qp_refcount(dev, qp);
#line 1444
  if (tmp == 0) {
#line 1444
    goto ldv_31123;
  } else {

  }
#line 1444
  __ret = 0L;
#line 1444
  INIT_LIST_HEAD(& __wait.task_list);
#line 1444
  __wait.flags = 0U;
  ldv_31129: 
#line 1444
  tmp___0 = prepare_to_wait_event(& qp->wait, & __wait, 2);
#line 1444
  __int = tmp___0;
#line 1444
  tmp___1 = get_qp_refcount(dev, qp);
#line 1444
  if (tmp___1 == 0) {
#line 1444
    goto ldv_31128;
  } else {

  }
#line 1444
  schedule();
#line 1444
  goto ldv_31129;
  ldv_31128: 
#line 1444
  finish_wait(& qp->wait, & __wait);

  ldv_31123: ;
#line 1446
  if ((unsigned int )qp->state != 0U) {
#line 1447
    mthca_MODIFY_QP(dev, (enum ib_qp_state )qp->state, 0, qp->qpn, 0, (struct mthca_mailbox *)0,
                    0U);
  } else {

  }
#line 1455
  if ((unsigned long )qp->ibqp.uobject == (unsigned long )((struct ib_uobject *)0)) {
#line 1456
    if ((unsigned long )qp->ibqp.srq != (unsigned long )((struct ib_srq *)0)) {
#line 1456
      tmp___2 = to_msrq(qp->ibqp.srq);
#line 1456
      tmp___3 = tmp___2;
    } else {
#line 1456
      tmp___3 = (struct mthca_srq *)0;
    }
#line 1456
    mthca_cq_clean(dev, recv_cq, qp->qpn, tmp___3);
#line 1458
    if ((unsigned long )send_cq != (unsigned long )recv_cq) {
#line 1459
      mthca_cq_clean(dev, send_cq, qp->qpn, (struct mthca_srq *)0);
    } else {

    }
#line 1461
    mthca_free_memfree(dev, qp);
#line 1462
    mthca_free_wqe_buf(dev, qp);
  } else {

  }
#line 1465
  mthca_unmap_memfree(dev, qp);
#line 1467
  tmp___8 = is_sqp(dev, qp);
#line 1467
  if (tmp___8 != 0) {
#line 1468
    tmp___4 = to_mpd(qp->ibqp.pd);
#line 1468
    atomic_dec(& tmp___4->sqp_count);
#line 1469
    tmp___5 = to_msqp(qp);
#line 1469
    tmp___6 = to_msqp(qp);
#line 1469
    tmp___7 = to_msqp(qp);
#line 1469
    dma_free_attrs(& (dev->pdev)->dev, (size_t )tmp___7->header_buf_size, tmp___6->header_buf,
                   tmp___5->header_dma, (struct dma_attrs *)0);
  } else {
#line 1474
    mthca_free(& dev->qp_table.alloc, qp->qpn);
  }
#line 1475
  return;
}
}
#line 1478 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static int build_mlx_header(struct mthca_dev *dev , struct mthca_sqp *sqp , int ind ,
                            struct ib_send_wr *wr , struct mthca_mlx_seg *mlx , struct mthca_data_seg *data ) 
{ 
  int header_size ;
  int err ;
  u16 pkey ;
  struct mthca_ah *tmp ;
  int tmp___0 ;
  struct mthca_ah *tmp___1 ;
  __u32 tmp___2 ;
  __u16 tmp___3 ;
  __u32 tmp___4 ;
  u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  struct mthca_pd *tmp___10 ;
  __u32 tmp___11 ;
  __u64 tmp___12 ;

  {
#line 1487
  tmp = to_mah(wr->wr.ud.ah);
#line 1487
  tmp___0 = mthca_ah_grh_present(tmp);
#line 1487
  ib_ud_header_init(256, 1, 0, 0, tmp___0, 0, & sqp->ud_header);
#line 1491
  tmp___1 = to_mah(wr->wr.ud.ah);
#line 1491
  err = mthca_read_ah(dev, tmp___1, & sqp->ud_header);
#line 1492
  if (err != 0) {
#line 1493
    return (err);
  } else {

  }
#line 1494
  mlx->flags = mlx->flags & 4244635647U;
#line 1495
  tmp___2 = __fswab32((__u32 )(((sqp->qp.ibqp.qp_num == 0U ? 131072 : 0) | ((unsigned int )sqp->ud_header.lrh.destination_lid == 65535U ? 65536 : 0)) | ((int )sqp->ud_header.lrh.service_level << 8)));
#line 1495
  mlx->flags = mlx->flags | tmp___2;
#line 1499
  mlx->rlid = sqp->ud_header.lrh.destination_lid;
#line 1500
  mlx->vcrc = 0U;
#line 1502
  switch ((unsigned int )wr->opcode) {
  case 2U: 
#line 1504
  sqp->ud_header.bth.opcode = 100U;
#line 1505
  sqp->ud_header.immediate_present = 0;
#line 1506
  goto ldv_31143;
  case 3U: 
#line 1508
  sqp->ud_header.bth.opcode = 101U;
#line 1509
  sqp->ud_header.immediate_present = 1;
#line 1510
  sqp->ud_header.immediate_data = wr->ex.imm_data;
#line 1511
  goto ldv_31143;
  default: ;
#line 1513
  return (-22);
  }
  ldv_31143: 
#line 1516
  sqp->ud_header.lrh.virtual_lane = sqp->qp.ibqp.qp_num == 0U ? 15U : 0U;
#line 1517
  if ((unsigned int )sqp->ud_header.lrh.destination_lid == 65535U) {
#line 1518
    sqp->ud_header.lrh.source_lid = 65535U;
  } else {

  }
#line 1519
  sqp->ud_header.bth.solicited_event = (wr->send_flags & 4) != 0;
#line 1520
  if (sqp->qp.ibqp.qp_num == 0U) {
#line 1521
    ib_get_cached_pkey(& dev->ib_dev, (int )sqp->qp.port, sqp->pkey_index, & pkey);
  } else {
#line 1524
    ib_get_cached_pkey(& dev->ib_dev, (int )sqp->qp.port, (int )wr->wr.ud.pkey_index,
                       & pkey);
  }
#line 1526
  tmp___3 = __fswab16((int )pkey);
#line 1526
  sqp->ud_header.bth.pkey = tmp___3;
#line 1527
  tmp___4 = __fswab32(wr->wr.ud.remote_qpn);
#line 1527
  sqp->ud_header.bth.destination_qpn = tmp___4;
#line 1528
  tmp___5 = sqp->send_psn;
#line 1528
  sqp->send_psn = sqp->send_psn + 1U;
#line 1528
  tmp___6 = __fswab32(tmp___5 & 16777215U);
#line 1528
  sqp->ud_header.bth.psn = tmp___6;
#line 1529
  tmp___7 = __fswab32((int )wr->wr.ud.remote_qkey < 0 ? sqp->qkey : wr->wr.ud.remote_qkey);
#line 1529
  sqp->ud_header.deth.qkey = tmp___7;
#line 1531
  tmp___8 = __fswab32(sqp->qp.ibqp.qp_num);
#line 1531
  sqp->ud_header.deth.source_qpn = tmp___8;
#line 1533
  header_size = ib_ud_header_pack(& sqp->ud_header, sqp->header_buf + (unsigned long )(ind * 72));
#line 1537
  tmp___9 = __fswab32((__u32 )header_size);
#line 1537
  data->byte_count = tmp___9;
#line 1538
  tmp___10 = to_mpd(sqp->qp.ibqp.pd);
#line 1538
  tmp___11 = __fswab32(tmp___10->ntmr.ibmr.lkey);
#line 1538
  data->lkey = tmp___11;
#line 1539
  tmp___12 = __fswab64(sqp->header_dma + (dma_addr_t )(ind * 72));
#line 1539
  data->addr = tmp___12;
#line 1542
  return (0);
}
}
#line 1545 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
__inline static int mthca_wq_overflow(struct mthca_wq *wq , int nreq , struct ib_cq *ib_cq ) 
{ 
  unsigned int cur ;
  struct mthca_cq *cq ;
  long tmp ;

  {
#line 1551
  cur = wq->head - wq->tail;
#line 1552
  tmp = ldv__builtin_expect(cur + (unsigned int )nreq < (unsigned int )wq->max, 1L);
#line 1552
  if (tmp != 0L) {
#line 1553
    return (0);
  } else {

  }
#line 1555
  cq = to_mcq(ib_cq);
#line 1556
  spin_lock(& cq->lock);
#line 1557
  cur = wq->head - wq->tail;
#line 1558
  spin_unlock(& cq->lock);
#line 1560
  return (cur + (unsigned int )nreq >= (unsigned int )wq->max);
}
}
#line 1563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
__inline static void set_raddr_seg(struct mthca_raddr_seg *rseg , u64 remote_addr ,
                                   u32 rkey ) 
{ 
  __u64 tmp ;
  __u32 tmp___0 ;

  {
#line 1566
  tmp = __fswab64(remote_addr);
#line 1566
  rseg->raddr = tmp;
#line 1567
  tmp___0 = __fswab32(rkey);
#line 1567
  rseg->rkey = tmp___0;
#line 1568
  rseg->reserved = 0U;
#line 1569
  return;
}
}
#line 1571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
__inline static void set_atomic_seg(struct mthca_atomic_seg *aseg , struct ib_send_wr *wr ) 
{ 
  __u64 tmp ;
  __u64 tmp___0 ;
  __u64 tmp___1 ;

  {
#line 1574
  if ((unsigned int )wr->opcode == 5U) {
#line 1575
    tmp = __fswab64(wr->wr.atomic.swap);
#line 1575
    aseg->swap_add = tmp;
#line 1576
    tmp___0 = __fswab64(wr->wr.atomic.compare_add);
#line 1576
    aseg->compare = tmp___0;
  } else {
#line 1578
    tmp___1 = __fswab64(wr->wr.atomic.compare_add);
#line 1578
    aseg->swap_add = tmp___1;
#line 1579
    aseg->compare = 0ULL;
  }
#line 1581
  return;
}
}
#line 1584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static void set_tavor_ud_seg(struct mthca_tavor_ud_seg *useg , struct ib_send_wr *wr ) 
{ 
  struct mthca_ah *tmp ;
  __u32 tmp___0 ;
  struct mthca_ah *tmp___1 ;
  __u64 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;

  {
#line 1587
  tmp = to_mah(wr->wr.ud.ah);
#line 1587
  tmp___0 = __fswab32(tmp->key);
#line 1587
  useg->lkey = tmp___0;
#line 1588
  tmp___1 = to_mah(wr->wr.ud.ah);
#line 1588
  tmp___2 = __fswab64(tmp___1->avdma);
#line 1588
  useg->av_addr = tmp___2;
#line 1589
  tmp___3 = __fswab32(wr->wr.ud.remote_qpn);
#line 1589
  useg->dqpn = tmp___3;
#line 1590
  tmp___4 = __fswab32(wr->wr.ud.remote_qkey);
#line 1590
  useg->qkey = tmp___4;
#line 1591
  return;
}
}
#line 1594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
static void set_arbel_ud_seg(struct mthca_arbel_ud_seg *useg , struct ib_send_wr *wr ) 
{ 
  struct mthca_ah *tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
#line 1597
  tmp = to_mah(wr->wr.ud.ah);
#line 1597
  memcpy((void *)(& useg->av), (void const   *)tmp->av, 32UL);
#line 1598
  tmp___0 = __fswab32(wr->wr.ud.remote_qpn);
#line 1598
  useg->dqpn = tmp___0;
#line 1599
  tmp___1 = __fswab32(wr->wr.ud.remote_qkey);
#line 1599
  useg->qkey = tmp___1;
#line 1600
  return;
}
}
#line 1602 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
int mthca_tavor_post_send(struct ib_qp *ibqp , struct ib_send_wr *wr , struct ib_send_wr **bad_wr ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_qp *qp ;
  struct mthca_qp *tmp___0 ;
  void *wqe ;
  void *prev_wqe ;
  unsigned long flags ;
  int err ;
  int nreq ;
  int i ;
  int size ;
  int size0 ;
  u32 f0 ;
  int ind ;
  u8 op0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  struct mthca_sqp *tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
#line 1605
  tmp = to_mdev(ibqp->device);
#line 1605
  dev = tmp;
#line 1606
  tmp___0 = to_mqp(ibqp);
#line 1606
  qp = tmp___0;
#line 1610
  err = 0;
#line 1621
  size0 = size0;
#line 1622
  f0 = f0;
#line 1624
  op0 = 0U;
#line 1626
  tmp___1 = spinlock_check(& qp->sq.lock);
#line 1626
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 1630
  ind = (int )qp->sq.next_ind;
#line 1632
  nreq = 0;
#line 1632
  goto ldv_31214;
  ldv_31213: 
#line 1633
  tmp___2 = mthca_wq_overflow(& qp->sq, nreq, qp->ibqp.send_cq);
#line 1633
  if (tmp___2 != 0) {
#line 1634
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "SQ %06x full (%u head, %u tail, %d max, %d nreq)\n",
            qp->qpn, qp->sq.head, qp->sq.tail, qp->sq.max, nreq);
#line 1638
    err = -12;
#line 1639
    *bad_wr = wr;
#line 1640
    goto out;
  } else {

  }
#line 1643
  wqe = get_send_wqe(qp, ind);
#line 1644
  prev_wqe = qp->sq.last;
#line 1645
  qp->sq.last = wqe;
#line 1647
  ((struct mthca_next_seg *)wqe)->nda_op = 0U;
#line 1648
  ((struct mthca_next_seg *)wqe)->ee_nds = 0U;
#line 1649
  ((struct mthca_next_seg *)wqe)->flags = (((wr->send_flags & 2) != 0 ? 134217728U : 0U) | ((wr->send_flags & 4) != 0 ? 33554432U : 0U)) | 16777216U;
#line 1655
  if ((unsigned int )wr->opcode == 3U || (unsigned int )wr->opcode == 1U) {
#line 1657
    ((struct mthca_next_seg *)wqe)->imm = wr->ex.imm_data;
  } else {

  }
#line 1659
  wqe = wqe + 16UL;
#line 1660
  size = 1;
#line 1662
  switch ((int )qp->transport) {
  case 0: ;
#line 1664
  switch ((unsigned int )wr->opcode) {
  case 5U: ;
  case 6U: 
#line 1667
  set_raddr_seg((struct mthca_raddr_seg *)wqe, wr->wr.atomic.remote_addr, wr->wr.atomic.rkey);
#line 1669
  wqe = wqe + 16UL;
#line 1671
  set_atomic_seg((struct mthca_atomic_seg *)wqe, wr);
#line 1672
  wqe = wqe + 16UL;
#line 1673
  size = (int )((unsigned int )size + 2U);
#line 1675
  goto ldv_31195;
  case 0U: ;
  case 1U: ;
  case 4U: 
#line 1680
  set_raddr_seg((struct mthca_raddr_seg *)wqe, wr->wr.rdma.remote_addr, wr->wr.rdma.rkey);
#line 1682
  wqe = wqe + 16UL;
#line 1683
  size = (int )((unsigned int )size + 1U);
#line 1684
  goto ldv_31195;
  default: ;
#line 1688
  goto ldv_31195;
  }
  ldv_31195: ;
#line 1691
  goto ldv_31200;
  case 1: ;
#line 1694
  switch ((unsigned int )wr->opcode) {
  case 0U: ;
  case 1U: 
#line 1697
  set_raddr_seg((struct mthca_raddr_seg *)wqe, wr->wr.rdma.remote_addr, wr->wr.rdma.rkey);
#line 1699
  wqe = wqe + 16UL;
#line 1700
  size = (int )((unsigned int )size + 1U);
#line 1701
  goto ldv_31204;
  default: ;
#line 1705
  goto ldv_31204;
  }
  ldv_31204: ;
#line 1708
  goto ldv_31200;
  case 2: 
#line 1711
  set_tavor_ud_seg((struct mthca_tavor_ud_seg *)wqe, wr);
#line 1712
  wqe = wqe + 48UL;
#line 1713
  size = (int )((unsigned int )size + 3U);
#line 1714
  goto ldv_31200;
  case 5: 
#line 1717
  tmp___3 = to_msqp(qp);
#line 1717
  err = build_mlx_header(dev, tmp___3, ind, wr, (struct mthca_mlx_seg *)wqe + 0xfffffffffffffff0UL,
                         (struct mthca_data_seg *)wqe);
#line 1720
  if (err != 0) {
#line 1721
    *bad_wr = wr;
#line 1722
    goto out;
  } else {

  }
#line 1724
  wqe = wqe + 16UL;
#line 1725
  size = (int )((unsigned int )size + 1U);
#line 1726
  goto ldv_31200;
  }
  ldv_31200: ;
#line 1729
  if (wr->num_sge > qp->sq.max_gs) {
#line 1730
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "too many gathers\n");
#line 1731
    err = -22;
#line 1732
    *bad_wr = wr;
#line 1733
    goto out;
  } else {

  }
#line 1736
  i = 0;
#line 1736
  goto ldv_31209;
  ldv_31208: 
#line 1737
  mthca_set_data_seg((struct mthca_data_seg *)wqe, wr->sg_list + (unsigned long )i);
#line 1738
  wqe = wqe + 16UL;
#line 1739
  size = (int )((unsigned int )size + 1U);
#line 1736
  i = i + 1;
  ldv_31209: ;
#line 1736
  if (wr->num_sge > i) {
#line 1738
    goto ldv_31208;
  } else {

  }

#line 1743
  if ((unsigned int )qp->transport == 5U) {
#line 1744
    ((struct mthca_data_seg *)wqe)->byte_count = 67108992U;
#line 1746
    *((u32 *)wqe + 1UL) = 0U;
#line 1747
    wqe = wqe + 16UL;
#line 1748
    size = (int )((unsigned int )size + 1U);
  } else {

  }
#line 1751
  *(qp->wrid + (unsigned long )(qp->rq.max + ind)) = wr->wr_id;
#line 1753
  if ((unsigned int )wr->opcode > 6U) {
#line 1754
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "opcode invalid\n");
#line 1755
    err = -22;
#line 1756
    *bad_wr = wr;
#line 1757
    goto out;
  } else {

  }
#line 1760
  tmp___4 = __fswab32((__u32 )(((ind << qp->sq.wqe_shift) + qp->send_wqe_offset) | (int )mthca_opcode[(unsigned int )wr->opcode]));
#line 1760
  ((struct mthca_next_seg *)prev_wqe)->nda_op = tmp___4;
#line 1764
  __asm__  volatile   ("sfence": : : "memory");
#line 1765
  tmp___5 = __fswab32((__u32 )(((nreq != 0 ? 0 : 128) | size) | (wr->send_flags & 1 ? 64 : 0)));
#line 1765
  ((struct mthca_next_seg *)prev_wqe)->ee_nds = tmp___5;
#line 1770
  if (nreq == 0) {
#line 1771
    size0 = size;
#line 1772
    op0 = mthca_opcode[(unsigned int )wr->opcode];
#line 1773
    f0 = wr->send_flags & 1 ? 32U : 0U;
  } else {

  }
#line 1777
  ind = ind + 1;
#line 1778
  tmp___6 = ldv__builtin_expect(qp->sq.max <= ind, 0L);
#line 1778
  if (tmp___6 != 0L) {
#line 1779
    ind = ind - qp->sq.max;
  } else {

  }
#line 1632
  nreq = nreq + 1;
#line 1632
  wr = wr->next;
  ldv_31214: ;
#line 1632
  if ((unsigned long )wr != (unsigned long )((struct ib_send_wr *)0)) {
#line 1634
    goto ldv_31213;
  } else {

  }

  out: 
#line 1783
  tmp___7 = ldv__builtin_expect(nreq != 0, 1L);
#line 1783
  if (tmp___7 != 0L) {
#line 1784
    __asm__  volatile   ("sfence": : : "memory");
#line 1786
    mthca_write64((((qp->sq.next_ind << qp->sq.wqe_shift) + (unsigned int )qp->send_wqe_offset) | f0) | (unsigned int )op0,
                  (qp->qpn << 8) | (u32 )size0, dev->kar + 16UL, (spinlock_t *)0);
#line 1795
    __asm__  volatile   ("": : : "memory");
  } else {

  }
#line 1798
  qp->sq.next_ind = (unsigned int )ind;
#line 1799
  qp->sq.head = qp->sq.head + (unsigned int )nreq;
#line 1801
  spin_unlock_irqrestore(& qp->sq.lock, flags);
#line 1802
  return (err);
}
}
#line 1805 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
int mthca_tavor_post_receive(struct ib_qp *ibqp , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_qp *qp ;
  struct mthca_qp *tmp___0 ;
  unsigned long flags ;
  int err ;
  int nreq ;
  int i ;
  int size ;
  int size0 ;
  int ind ;
  void *wqe ;
  void *prev_wqe ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  __u32 tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
#line 1808
  tmp = to_mdev(ibqp->device);
#line 1808
  dev = tmp;
#line 1809
  tmp___0 = to_mqp(ibqp);
#line 1809
  qp = tmp___0;
#line 1811
  err = 0;
#line 1822
  size0 = size0;
#line 1827
  tmp___1 = spinlock_check(& qp->rq.lock);
#line 1827
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 1831
  ind = (int )qp->rq.next_ind;
#line 1833
  nreq = 0;
#line 1833
  goto ldv_31240;
  ldv_31239: 
#line 1834
  tmp___2 = mthca_wq_overflow(& qp->rq, nreq, qp->ibqp.recv_cq);
#line 1834
  if (tmp___2 != 0) {
#line 1835
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "RQ %06x full (%u head, %u tail, %d max, %d nreq)\n",
            qp->qpn, qp->rq.head, qp->rq.tail, qp->rq.max, nreq);
#line 1839
    err = -12;
#line 1840
    *bad_wr = wr;
#line 1841
    goto out;
  } else {

  }
#line 1844
  wqe = get_recv_wqe(qp, ind);
#line 1845
  prev_wqe = qp->rq.last;
#line 1846
  qp->rq.last = wqe;
#line 1848
  ((struct mthca_next_seg *)wqe)->ee_nds = 2147483648U;
#line 1850
  ((struct mthca_next_seg *)wqe)->flags = 0U;
#line 1852
  wqe = wqe + 16UL;
#line 1853
  size = 1;
#line 1855
  tmp___3 = ldv__builtin_expect(wr->num_sge > qp->rq.max_gs, 0L);
#line 1855
  if (tmp___3 != 0L) {
#line 1856
    err = -22;
#line 1857
    *bad_wr = wr;
#line 1858
    goto out;
  } else {

  }
#line 1861
  i = 0;
#line 1861
  goto ldv_31237;
  ldv_31236: 
#line 1862
  mthca_set_data_seg((struct mthca_data_seg *)wqe, wr->sg_list + (unsigned long )i);
#line 1863
  wqe = wqe + 16UL;
#line 1864
  size = (int )((unsigned int )size + 1U);
#line 1861
  i = i + 1;
  ldv_31237: ;
#line 1861
  if (wr->num_sge > i) {
#line 1863
    goto ldv_31236;
  } else {

  }
#line 1867
  *(qp->wrid + (unsigned long )ind) = wr->wr_id;
#line 1869
  tmp___4 = __fswab32((__u32 )(size | 128));
#line 1869
  ((struct mthca_next_seg *)prev_wqe)->ee_nds = tmp___4;
#line 1872
  if (nreq == 0) {
#line 1873
    size0 = size;
  } else {

  }
#line 1875
  ind = ind + 1;
#line 1876
  tmp___5 = ldv__builtin_expect(qp->rq.max <= ind, 0L);
#line 1876
  if (tmp___5 != 0L) {
#line 1877
    ind = ind - qp->rq.max;
  } else {

  }
#line 1879
  nreq = nreq + 1;
#line 1880
  tmp___6 = ldv__builtin_expect(nreq == 256, 0L);
#line 1880
  if (tmp___6 != 0L) {
#line 1881
    nreq = 0;
#line 1883
    __asm__  volatile   ("sfence": : : "memory");
#line 1885
    mthca_write64((qp->rq.next_ind << qp->rq.wqe_shift) | (unsigned int )size0, qp->qpn << 8,
                  dev->kar + 24UL, (spinlock_t *)0);
#line 1889
    qp->rq.next_ind = (unsigned int )ind;
#line 1890
    qp->rq.head = qp->rq.head + 256U;
  } else {

  }
#line 1833
  wr = wr->next;
  ldv_31240: ;
#line 1833
  if ((unsigned long )wr != (unsigned long )((struct ib_recv_wr *)0)) {
#line 1835
    goto ldv_31239;
  } else {

  }

  out: 
#line 1895
  tmp___7 = ldv__builtin_expect(nreq != 0, 1L);
#line 1895
  if (tmp___7 != 0L) {
#line 1896
    __asm__  volatile   ("sfence": : : "memory");
#line 1898
    mthca_write64((qp->rq.next_ind << qp->rq.wqe_shift) | (unsigned int )size0, (qp->qpn << 8) | (u32 )nreq,
                  dev->kar + 24UL, (spinlock_t *)0);
  } else {

  }
#line 1903
  qp->rq.next_ind = (unsigned int )ind;
#line 1904
  qp->rq.head = qp->rq.head + (unsigned int )nreq;
#line 1910
  __asm__  volatile   ("": : : "memory");
#line 1912
  spin_unlock_irqrestore(& qp->rq.lock, flags);
#line 1913
  return (err);
}
}
#line 1916 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
int mthca_arbel_post_send(struct ib_qp *ibqp , struct ib_send_wr *wr , struct ib_send_wr **bad_wr ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_qp *qp ;
  struct mthca_qp *tmp___0 ;
  u32 dbhi ;
  void *wqe ;
  void *prev_wqe ;
  unsigned long flags ;
  int err ;
  int nreq ;
  int i ;
  int size ;
  int size0 ;
  u32 f0 ;
  int ind ;
  u8 op0 ;
  raw_spinlock_t *tmp___1 ;
  __u32 tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  struct mthca_sqp *tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  long tmp___8 ;
  __u32 tmp___9 ;
  long tmp___10 ;

  {
#line 1919
  tmp = to_mdev(ibqp->device);
#line 1919
  dev = tmp;
#line 1920
  tmp___0 = to_mqp(ibqp);
#line 1920
  qp = tmp___0;
#line 1925
  err = 0;
#line 1936
  size0 = size0;
#line 1937
  f0 = f0;
#line 1939
  op0 = 0U;
#line 1941
  tmp___1 = spinlock_check(& qp->sq.lock);
#line 1941
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 1945
  ind = (int )(qp->sq.head & (unsigned int )(qp->sq.max + -1));
#line 1947
  nreq = 0;
#line 1947
  goto ldv_31287;
  ldv_31286: 
#line 1948
  tmp___3 = ldv__builtin_expect(nreq == 255, 0L);
#line 1948
  if (tmp___3 != 0L) {
#line 1949
    nreq = 0;
#line 1951
    dbhi = ((((qp->sq.head & 65535U) << 8) | f0) | (unsigned int )op0) | 4278190080U;
#line 1954
    qp->sq.head = qp->sq.head + 255U;
#line 1960
    __asm__  volatile   ("sfence": : : "memory");
#line 1961
    tmp___2 = __fswab32(qp->sq.head & 65535U);
#line 1961
    *(qp->sq.db) = tmp___2;
#line 1967
    __asm__  volatile   ("sfence": : : "memory");
#line 1969
    mthca_write64(dbhi, (qp->qpn << 8) | (u32 )size0, dev->kar + 16UL, (spinlock_t *)0);
  } else {

  }
#line 1974
  tmp___4 = mthca_wq_overflow(& qp->sq, nreq, qp->ibqp.send_cq);
#line 1974
  if (tmp___4 != 0) {
#line 1975
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "SQ %06x full (%u head, %u tail, %d max, %d nreq)\n",
            qp->qpn, qp->sq.head, qp->sq.tail, qp->sq.max, nreq);
#line 1979
    err = -12;
#line 1980
    *bad_wr = wr;
#line 1981
    goto out;
  } else {

  }
#line 1984
  wqe = get_send_wqe(qp, ind);
#line 1985
  prev_wqe = qp->sq.last;
#line 1986
  qp->sq.last = wqe;
#line 1988
  ((struct mthca_next_seg *)wqe)->flags = ((((wr->send_flags & 2) != 0 ? 134217728U : 0U) | ((wr->send_flags & 4) != 0 ? 33554432U : 0U)) | ((wr->send_flags & 16) != 0 ? 805306368U : 0U)) | 16777216U;
#line 1996
  if ((unsigned int )wr->opcode == 3U || (unsigned int )wr->opcode == 1U) {
#line 1998
    ((struct mthca_next_seg *)wqe)->imm = wr->ex.imm_data;
  } else {

  }
#line 2000
  wqe = wqe + 16UL;
#line 2001
  size = 1;
#line 2003
  switch ((int )qp->transport) {
  case 0: ;
#line 2005
  switch ((unsigned int )wr->opcode) {
  case 5U: ;
  case 6U: 
#line 2008
  set_raddr_seg((struct mthca_raddr_seg *)wqe, wr->wr.atomic.remote_addr, wr->wr.atomic.rkey);
#line 2010
  wqe = wqe + 16UL;
#line 2012
  set_atomic_seg((struct mthca_atomic_seg *)wqe, wr);
#line 2013
  wqe = wqe + 16UL;
#line 2014
  size = (int )((unsigned int )size + 2U);
#line 2016
  goto ldv_31268;
  case 4U: ;
  case 0U: ;
  case 1U: 
#line 2021
  set_raddr_seg((struct mthca_raddr_seg *)wqe, wr->wr.rdma.remote_addr, wr->wr.rdma.rkey);
#line 2023
  wqe = wqe + 16UL;
#line 2024
  size = (int )((unsigned int )size + 1U);
#line 2025
  goto ldv_31268;
  default: ;
#line 2029
  goto ldv_31268;
  }
  ldv_31268: ;
#line 2032
  goto ldv_31273;
  case 1: ;
#line 2035
  switch ((unsigned int )wr->opcode) {
  case 0U: ;
  case 1U: 
#line 2038
  set_raddr_seg((struct mthca_raddr_seg *)wqe, wr->wr.rdma.remote_addr, wr->wr.rdma.rkey);
#line 2040
  wqe = wqe + 16UL;
#line 2041
  size = (int )((unsigned int )size + 1U);
#line 2042
  goto ldv_31277;
  default: ;
#line 2046
  goto ldv_31277;
  }
  ldv_31277: ;
#line 2049
  goto ldv_31273;
  case 2: 
#line 2052
  set_arbel_ud_seg((struct mthca_arbel_ud_seg *)wqe, wr);
#line 2053
  wqe = wqe + 48UL;
#line 2054
  size = (int )((unsigned int )size + 3U);
#line 2055
  goto ldv_31273;
  case 5: 
#line 2058
  tmp___5 = to_msqp(qp);
#line 2058
  err = build_mlx_header(dev, tmp___5, ind, wr, (struct mthca_mlx_seg *)wqe + 0xfffffffffffffff0UL,
                         (struct mthca_data_seg *)wqe);
#line 2061
  if (err != 0) {
#line 2062
    *bad_wr = wr;
#line 2063
    goto out;
  } else {

  }
#line 2065
  wqe = wqe + 16UL;
#line 2066
  size = (int )((unsigned int )size + 1U);
#line 2067
  goto ldv_31273;
  }
  ldv_31273: ;
#line 2070
  if (wr->num_sge > qp->sq.max_gs) {
#line 2071
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "too many gathers\n");
#line 2072
    err = -22;
#line 2073
    *bad_wr = wr;
#line 2074
    goto out;
  } else {

  }
#line 2077
  i = 0;
#line 2077
  goto ldv_31282;
  ldv_31281: 
#line 2078
  mthca_set_data_seg((struct mthca_data_seg *)wqe, wr->sg_list + (unsigned long )i);
#line 2079
  wqe = wqe + 16UL;
#line 2080
  size = (int )((unsigned int )size + 1U);
#line 2077
  i = i + 1;
  ldv_31282: ;
#line 2077
  if (wr->num_sge > i) {
#line 2079
    goto ldv_31281;
  } else {

  }

#line 2084
  if ((unsigned int )qp->transport == 5U) {
#line 2085
    ((struct mthca_data_seg *)wqe)->byte_count = 67108992U;
#line 2087
    *((u32 *)wqe + 1UL) = 0U;
#line 2088
    wqe = wqe + 16UL;
#line 2089
    size = (int )((unsigned int )size + 1U);
  } else {

  }
#line 2092
  *(qp->wrid + (unsigned long )(qp->rq.max + ind)) = wr->wr_id;
#line 2094
  if ((unsigned int )wr->opcode > 6U) {
#line 2095
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "opcode invalid\n");
#line 2096
    err = -22;
#line 2097
    *bad_wr = wr;
#line 2098
    goto out;
  } else {

  }
#line 2101
  tmp___6 = __fswab32((__u32 )(((ind << qp->sq.wqe_shift) + qp->send_wqe_offset) | (int )mthca_opcode[(unsigned int )wr->opcode]));
#line 2101
  ((struct mthca_next_seg *)prev_wqe)->nda_op = tmp___6;
#line 2105
  __asm__  volatile   ("sfence": : : "memory");
#line 2106
  tmp___7 = __fswab32((__u32 )((size | 128) | (wr->send_flags & 1 ? 64 : 0)));
#line 2106
  ((struct mthca_next_seg *)prev_wqe)->ee_nds = tmp___7;
#line 2111
  if (nreq == 0) {
#line 2112
    size0 = size;
#line 2113
    op0 = mthca_opcode[(unsigned int )wr->opcode];
#line 2114
    f0 = wr->send_flags & 1 ? 32U : 0U;
  } else {

  }
#line 2118
  ind = ind + 1;
#line 2119
  tmp___8 = ldv__builtin_expect(qp->sq.max <= ind, 0L);
#line 2119
  if (tmp___8 != 0L) {
#line 2120
    ind = ind - qp->sq.max;
  } else {

  }
#line 1947
  nreq = nreq + 1;
#line 1947
  wr = wr->next;
  ldv_31287: ;
#line 1947
  if ((unsigned long )wr != (unsigned long )((struct ib_send_wr *)0)) {
#line 1949
    goto ldv_31286;
  } else {

  }

  out: 
#line 2124
  tmp___10 = ldv__builtin_expect(nreq != 0, 1L);
#line 2124
  if (tmp___10 != 0L) {
#line 2125
    dbhi = (((unsigned int )(nreq << 24) | ((qp->sq.head & 65535U) << 8)) | f0) | (unsigned int )op0;
#line 2127
    qp->sq.head = qp->sq.head + (unsigned int )nreq;
#line 2133
    __asm__  volatile   ("sfence": : : "memory");
#line 2134
    tmp___9 = __fswab32(qp->sq.head & 65535U);
#line 2134
    *(qp->sq.db) = tmp___9;
#line 2140
    __asm__  volatile   ("sfence": : : "memory");
#line 2142
    mthca_write64(dbhi, (qp->qpn << 8) | (u32 )size0, dev->kar + 16UL, (spinlock_t *)0);
  } else {

  }
#line 2150
  __asm__  volatile   ("": : : "memory");
#line 2152
  spin_unlock_irqrestore(& qp->sq.lock, flags);
#line 2153
  return (err);
}
}
#line 2156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
int mthca_arbel_post_receive(struct ib_qp *ibqp , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_qp *qp ;
  struct mthca_qp *tmp___0 ;
  unsigned long flags ;
  int err ;
  int nreq ;
  int ind ;
  int i ;
  void *wqe ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  __u32 tmp___5 ;
  long tmp___6 ;

  {
#line 2159
  tmp = to_mdev(ibqp->device);
#line 2159
  dev = tmp;
#line 2160
  tmp___0 = to_mqp(ibqp);
#line 2160
  qp = tmp___0;
#line 2162
  err = 0;
#line 2168
  tmp___1 = spinlock_check(& qp->rq.lock);
#line 2168
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 2172
  ind = (int )(qp->rq.head & (unsigned int )(qp->rq.max + -1));
#line 2174
  nreq = 0;
#line 2174
  goto ldv_31310;
  ldv_31309: 
#line 2175
  tmp___2 = mthca_wq_overflow(& qp->rq, nreq, qp->ibqp.recv_cq);
#line 2175
  if (tmp___2 != 0) {
#line 2176
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "RQ %06x full (%u head, %u tail, %d max, %d nreq)\n",
            qp->qpn, qp->rq.head, qp->rq.tail, qp->rq.max, nreq);
#line 2180
    err = -12;
#line 2181
    *bad_wr = wr;
#line 2182
    goto out;
  } else {

  }
#line 2185
  wqe = get_recv_wqe(qp, ind);
#line 2187
  ((struct mthca_next_seg *)wqe)->flags = 0U;
#line 2189
  wqe = wqe + 16UL;
#line 2191
  tmp___3 = ldv__builtin_expect(wr->num_sge > qp->rq.max_gs, 0L);
#line 2191
  if (tmp___3 != 0L) {
#line 2192
    err = -22;
#line 2193
    *bad_wr = wr;
#line 2194
    goto out;
  } else {

  }
#line 2197
  i = 0;
#line 2197
  goto ldv_31307;
  ldv_31306: 
#line 2198
  mthca_set_data_seg((struct mthca_data_seg *)wqe, wr->sg_list + (unsigned long )i);
#line 2199
  wqe = wqe + 16UL;
#line 2197
  i = i + 1;
  ldv_31307: ;
#line 2197
  if (wr->num_sge > i) {
#line 2199
    goto ldv_31306;
  } else {

  }

#line 2202
  if (qp->rq.max_gs > i) {
#line 2203
    mthca_set_data_seg_inval((struct mthca_data_seg *)wqe);
  } else {

  }
#line 2205
  *(qp->wrid + (unsigned long )ind) = wr->wr_id;
#line 2207
  ind = ind + 1;
#line 2208
  tmp___4 = ldv__builtin_expect(qp->rq.max <= ind, 0L);
#line 2208
  if (tmp___4 != 0L) {
#line 2209
    ind = ind - qp->rq.max;
  } else {

  }
#line 2174
  nreq = nreq + 1;
#line 2174
  wr = wr->next;
  ldv_31310: ;
#line 2174
  if ((unsigned long )wr != (unsigned long )((struct ib_recv_wr *)0)) {
#line 2176
    goto ldv_31309;
  } else {

  }

  out: 
#line 2212
  tmp___6 = ldv__builtin_expect(nreq != 0, 1L);
#line 2212
  if (tmp___6 != 0L) {
#line 2213
    qp->rq.head = qp->rq.head + (unsigned int )nreq;
#line 2219
    __asm__  volatile   ("sfence": : : "memory");
#line 2220
    tmp___5 = __fswab32(qp->rq.head & 65535U);
#line 2220
    *(qp->rq.db) = tmp___5;
  } else {

  }
#line 2223
  spin_unlock_irqrestore(& qp->rq.lock, flags);
#line 2224
  return (err);
}
}
#line 2227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
void mthca_free_err_wqe(struct mthca_dev *dev , struct mthca_qp *qp , int is_send ,
                        int index , int *dbd , __be32 *new_wqe ) 
{ 
  struct mthca_next_seg *next ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2236
  if ((unsigned long )qp->ibqp.srq != (unsigned long )((struct ib_srq *)0) && is_send == 0) {
#line 2237
    *new_wqe = 0U;
#line 2238
    return;
  } else {

  }
#line 2241
  if (is_send != 0) {
#line 2242
    tmp = get_send_wqe(qp, index);
#line 2242
    next = (struct mthca_next_seg *)tmp;
  } else {
#line 2244
    tmp___0 = get_recv_wqe(qp, index);
#line 2244
    next = (struct mthca_next_seg *)tmp___0;
  }
#line 2246
  *dbd = (int )next->ee_nds < 0;
#line 2247
  if ((next->ee_nds & 1056964608U) != 0U) {
#line 2248
    *new_wqe = (next->nda_op & 3238002687U) | (next->ee_nds & 1056964608U);
  } else {
#line 2251
    *new_wqe = 0U;
  }
#line 2252
  return;
}
}
#line 2254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
int mthca_init_qp_table(struct mthca_dev *dev ) 
{ 
  int err ;
  int i ;
  struct lock_class_key __key ;

  {
#line 2259
  spinlock_check(& dev->qp_table.lock);
#line 2259
  __raw_spin_lock_init(& dev->qp_table.lock.__annonCompField18.rlock, "&(&dev->qp_table.lock)->rlock",
                       & __key);
#line 2265
  dev->qp_table.sqp_start = (dev->limits.reserved_qps + 1) & -2;
#line 2266
  err = mthca_alloc_init(& dev->qp_table.alloc, (u32 )dev->limits.num_qps, 16777215U,
                         (u32 )(dev->qp_table.sqp_start + 4));
#line 2271
  if (err != 0) {
#line 2272
    return (err);
  } else {

  }
#line 2274
  err = mthca_array_init(& dev->qp_table.qp, dev->limits.num_qps);
#line 2276
  if (err != 0) {
#line 2277
    mthca_alloc_cleanup(& dev->qp_table.alloc);
#line 2278
    return (err);
  } else {

  }
#line 2281
  i = 0;
#line 2281
  goto ldv_31329;
  ldv_31328: 
#line 2282
  err = mthca_CONF_SPECIAL_QP(dev, i != 0, (u32 )(dev->qp_table.sqp_start + i * 2));
#line 2284
  if (err != 0) {
#line 2285
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "CONF_SPECIAL_QP returned %d, aborting.\n",
             err);
#line 2287
    goto err_out;
  } else {

  }
#line 2281
  i = i + 1;
  ldv_31329: ;
#line 2281
  if (i <= 1) {
#line 2283
    goto ldv_31328;
  } else {

  }

#line 2290
  return (0);
  err_out: 
#line 2293
  i = 0;
#line 2293
  goto ldv_31332;
  ldv_31331: 
#line 2294
  mthca_CONF_SPECIAL_QP(dev, i, 0U);
#line 2293
  i = i + 1;
  ldv_31332: ;
#line 2293
  if (i <= 1) {
#line 2295
    goto ldv_31331;
  } else {

  }
#line 2296
  mthca_array_cleanup(& dev->qp_table.qp, dev->limits.num_qps);
#line 2297
  mthca_alloc_cleanup(& dev->qp_table.alloc);
#line 2299
  return (err);
}
}
#line 2302 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.c"
void mthca_cleanup_qp_table(struct mthca_dev *dev ) 
{ 
  int i ;

  {
#line 2306
  i = 0;
#line 2306
  goto ldv_31339;
  ldv_31338: 
#line 2307
  mthca_CONF_SPECIAL_QP(dev, i, 0U);
#line 2306
  i = i + 1;
  ldv_31339: ;
#line 2306
  if (i <= 1) {
#line 2308
    goto ldv_31338;
  } else {

  }
#line 2309
  mthca_array_cleanup(& dev->qp_table.qp, dev->limits.num_qps);
#line 2310
  mthca_alloc_cleanup(& dev->qp_table.alloc);
#line 2311
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.o.c.prepared"
bool ldv_queue_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.o.c.prepared"
bool ldv_queue_delayed_work_on_136(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.o.c.prepared"
bool ldv_queue_work_on_137(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.o.c.prepared"
void ldv_flush_workqueue_138(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_qp.o.c.prepared"
bool ldv_queue_delayed_work_on_139(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_149(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_151(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_150(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_153(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_152(struct workqueue_struct *ldv_func_arg1 ) ;
#line 550 "include/rdma/ib_verbs.h"
extern int ib_rate_to_mult(enum ib_rate  ) ;
#line 684
extern enum ib_rate mult_to_ib_rate(int  ) ;
#line 50 "include/rdma/ib_cache.h"
extern int ib_get_cached_gid(struct ib_device * , u8  , int  , union ib_gid * ) ;
#line 561 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
int mthca_create_ah(struct mthca_dev *dev , struct mthca_pd *pd , struct ib_ah_attr *ah_attr ,
                    struct mthca_ah *ah ) ;
#line 565
int mthca_destroy_ah(struct mthca_dev *dev , struct mthca_ah *ah ) ;
#line 568
int mthca_ah_query(struct ib_ah *ibah , struct ib_ah_attr *attr ) ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.c"
static enum ib_rate memfree_rate_to_ib(u8 mthca_rate , u8 port_rate ) 
{ 
  enum ib_rate tmp ;
  enum ib_rate tmp___0 ;
  enum ib_rate tmp___1 ;
  enum ib_rate tmp___2 ;

  {
#line 71
  switch ((int )mthca_rate) {
  case 2: 
#line 73
  tmp = mult_to_ib_rate((int )port_rate >> 3);
#line 73
  return (tmp);
  case 1: 
#line 75
  tmp___0 = mult_to_ib_rate((int )port_rate >> 2);
#line 75
  return (tmp___0);
  case 3: 
#line 77
  tmp___1 = mult_to_ib_rate((int )port_rate >> 1);
#line 77
  return (tmp___1);
  case 0: ;
  default: 
#line 80
  tmp___2 = mult_to_ib_rate((int )port_rate);
#line 80
  return (tmp___2);
  }
}
}
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.c"
static enum ib_rate tavor_rate_to_ib(u8 mthca_rate , u8 port_rate ) 
{ 
  enum ib_rate tmp ;

  {
#line 86
  switch ((int )mthca_rate) {
  case 1: ;
#line 87
  return (2);
  case 3: ;
#line 88
  return (5);
  case 2: ;
#line 89
  return (3);
  default: 
#line 90
  tmp = mult_to_ib_rate((int )port_rate);
#line 90
  return (tmp);
  }
}
}
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.c"
enum ib_rate mthca_rate_to_ib(struct mthca_dev *dev , u8 mthca_rate , u8 port ) 
{ 
  enum ib_rate tmp ;
  enum ib_rate tmp___0 ;
  int tmp___1 ;

  {
#line 96
  tmp___1 = mthca_is_memfree(dev);
#line 96
  if (tmp___1 != 0) {
#line 98
    if ((unsigned int )dev->limits.stat_rate_support == 3U && (unsigned int )mthca_rate != 0U) {
#line 99
      return (2);
    } else {

    }
#line 101
    tmp = memfree_rate_to_ib((int )mthca_rate, (int )dev->rate[(int )port + -1]);
#line 101
    return (tmp);
  } else {
#line 103
    tmp___0 = tavor_rate_to_ib((int )mthca_rate, (int )dev->rate[(int )port + -1]);
#line 103
    return (tmp___0);
  }
}
}
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.c"
static u8 ib_rate_to_memfree(u8 req_rate , u8 cur_rate ) 
{ 


  {
#line 108
  if ((int )cur_rate <= (int )req_rate) {
#line 109
    return (0U);
  } else {

  }
#line 115
  switch (((int )cur_rate + -1) / (int )req_rate) {
  case 0: ;
#line 116
  return (0U);
  case 1: ;
#line 117
  return (3U);
  case 2: ;
  case 3: ;
#line 119
  return (1U);
  default: ;
#line 120
  return (2U);
  }
}
}
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.c"
static u8 ib_rate_to_tavor(u8 static_rate ) 
{ 


  {
#line 126
  switch ((int )static_rate) {
  case 2: ;
#line 127
  return (1U);
  case 5: ;
#line 128
  return (3U);
  case 3: ;
#line 129
  return (2U);
  default: ;
#line 130
  return (0U);
  }
}
}
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.c"
u8 mthca_get_rate(struct mthca_dev *dev , int static_rate , u8 port ) 
{ 
  u8 rate ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 138
  if (static_rate == 0) {
#line 139
    return (0U);
  } else {
#line 138
    tmp = ib_rate_to_mult((enum ib_rate )static_rate);
#line 138
    if (tmp >= (int )dev->rate[(int )port + -1]) {
#line 139
      return (0U);
    } else {

    }
  }
#line 141
  tmp___1 = mthca_is_memfree(dev);
#line 141
  if (tmp___1 != 0) {
#line 142
    tmp___0 = ib_rate_to_mult((enum ib_rate )static_rate);
#line 142
    rate = ib_rate_to_memfree((int )((u8 )tmp___0), (int )dev->rate[(int )port + -1]);
  } else {
#line 145
    rate = ib_rate_to_tavor((int )((u8 )static_rate));
  }
#line 147
  if ((((int )dev->limits.stat_rate_support >> (int )rate) & 1) == 0) {
#line 148
    rate = 1U;
  } else {

  }
#line 150
  return (rate);
}
}
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.c"
int mthca_create_ah(struct mthca_dev *dev , struct mthca_pd *pd , struct ib_ah_attr *ah_attr ,
                    struct mthca_ah *ah ) 
{ 
  u32 index ;
  struct mthca_av *av ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  __u32 tmp___4 ;
  __u16 tmp___5 ;
  u8 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  int j ;
  __u32 tmp___9 ;

  {
#line 158
  index = 4294967295U;
#line 159
  av = (struct mthca_av *)0;
#line 161
  ah->type = 1;
#line 163
  tmp___2 = mthca_is_memfree(dev);
#line 163
  if (tmp___2 != 0) {
#line 164
    tmp = kmalloc(32UL, 32U);
#line 164
    ah->av = (struct mthca_av *)tmp;
#line 165
    if ((unsigned long )ah->av == (unsigned long )((struct mthca_av *)0)) {
#line 166
      return (-12);
    } else {

    }
#line 168
    ah->type = 2;
#line 169
    av = ah->av;
  } else {
#line 170
    tmp___1 = atomic_read((atomic_t const   *)(& pd->sqp_count));
#line 170
    if (tmp___1 == 0 && (dev->mthca_flags & 2UL) == 0UL) {
#line 172
      index = mthca_alloc(& dev->av_table.alloc);
#line 175
      if (index == 4294967295U) {
#line 176
        goto on_hca_fail;
      } else {

      }
#line 178
      tmp___0 = kmalloc(32UL, 32U);
#line 178
      av = (struct mthca_av *)tmp___0;
#line 179
      if ((unsigned long )av == (unsigned long )((struct mthca_av *)0)) {
#line 180
        goto on_hca_fail;
      } else {

      }
#line 182
      ah->type = 0;
#line 183
      ah->avdma = dev->av_table.ddr_av_base + (u64 )(index * 32U);
    } else {

    }
  }
  on_hca_fail: ;
#line 188
  if ((unsigned int )ah->type == 1U) {
#line 189
    tmp___3 = dma_pool_alloc(dev->av_table.pool, 32U, & ah->avdma);
#line 189
    ah->av = (struct mthca_av *)tmp___3;
#line 191
    if ((unsigned long )ah->av == (unsigned long )((struct mthca_av *)0)) {
#line 192
      return (-12);
    } else {

    }
#line 194
    av = ah->av;
  } else {

  }
#line 197
  ah->key = pd->ntmr.ibmr.lkey;
#line 199
  memset((void *)av, 0, 32UL);
#line 201
  tmp___4 = __fswab32(pd->pd_num | (u32 )((int )ah_attr->port_num << 24));
#line 201
  av->port_pd = tmp___4;
#line 202
  av->g_slid = ah_attr->src_path_bits;
#line 203
  tmp___5 = __fswab16((int )ah_attr->dlid);
#line 203
  av->dlid = tmp___5;
#line 204
  tmp___6 = mthca_get_rate(dev, (int )ah_attr->static_rate, (int )ah_attr->port_num);
#line 204
  av->msg_sr = (u8 )((unsigned int )tmp___6 | 48U);
#line 206
  tmp___7 = __fswab32((__u32 )((int )ah_attr->sl << 28));
#line 206
  av->sl_tclass_flowlabel = tmp___7;
#line 207
  if ((int )ah_attr->ah_flags & 1) {
#line 208
    av->g_slid = (u8 )((unsigned int )av->g_slid | 128U);
#line 209
    av->gid_index = (int )((u8 )((int )ah_attr->port_num + -1)) * (int )((u8 )dev->limits.gid_table_len) + (int )ah_attr->grh.sgid_index;
#line 211
    av->hop_limit = ah_attr->grh.hop_limit;
#line 212
    tmp___8 = __fswab32((u32 )((int )ah_attr->grh.traffic_class << 20) | ah_attr->grh.flow_label);
#line 212
    av->sl_tclass_flowlabel = av->sl_tclass_flowlabel | tmp___8;
#line 215
    memcpy((void *)(& av->dgid), (void const   *)(& ah_attr->grh.dgid.raw), 16UL);
  } else {
#line 218
    av->dgid[3] = 33554432U;
  }
#line 221
  if (0) {
#line 224
    if (mthca_debug_level != 0) {
#line 224
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Created UDAV at %p/%08lx:\n",
                 av, (unsigned long )ah->avdma);
    } else {

    }
#line 226
    j = 0;
#line 226
    goto ldv_30221;
    ldv_30220: 
#line 227
    tmp___9 = __fswab32(*((__be32 *)av + (unsigned long )j));
#line 227
    printk("\017  [%2x] %08x\n", j * 4, tmp___9);
#line 226
    j = j + 1;
    ldv_30221: ;
#line 226
    if (j <= 7) {
#line 228
      goto ldv_30220;
    } else {

    }

  } else {

  }
#line 231
  if ((unsigned int )ah->type == 0U) {
#line 232
    memcpy_toio((void volatile   *)dev->av_table.av_map + (unsigned long )(index * 32U),
                (void const   *)av, 32UL);
#line 234
    kfree((void const   *)av);
  } else {

  }
#line 237
  return (0);
}
}
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.c"
int mthca_destroy_ah(struct mthca_dev *dev , struct mthca_ah *ah ) 
{ 


  {
#line 242
  switch ((unsigned int )ah->type) {
  case 0U: 
#line 244
  mthca_free(& dev->av_table.alloc, (u32 )((ah->avdma - dev->av_table.ddr_av_base) / 32ULL));
#line 247
  goto ldv_30228;
  case 1U: 
#line 250
  dma_pool_free(dev->av_table.pool, (void *)ah->av, ah->avdma);
#line 251
  goto ldv_30228;
  case 2U: 
#line 254
  kfree((void const   *)ah->av);
#line 255
  goto ldv_30228;
  }
  ldv_30228: ;
#line 258
  return (0);
}
}
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.c"
int mthca_ah_grh_present(struct mthca_ah *ah ) 
{ 


  {
#line 263
  return ((int )((signed char )(ah->av)->g_slid) < 0);
}
}
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.c"
int mthca_read_ah(struct mthca_dev *dev , struct mthca_ah *ah , struct ib_ud_header *header ) 
{ 
  __u32 tmp ;
  __u16 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  int tmp___3 ;

  {
#line 269
  if ((unsigned int )ah->type == 0U) {
#line 270
    return (-22);
  } else {

  }
#line 272
  tmp = __fswab32((ah->av)->sl_tclass_flowlabel);
#line 272
  header->lrh.service_level = (u8 )(tmp >> 28);
#line 273
  header->lrh.destination_lid = (ah->av)->dlid;
#line 274
  tmp___0 = __fswab16((int )(ah->av)->g_slid & 127);
#line 274
  header->lrh.source_lid = tmp___0;
#line 275
  tmp___3 = mthca_ah_grh_present(ah);
#line 275
  if (tmp___3 != 0) {
#line 276
    tmp___1 = __fswab32((ah->av)->sl_tclass_flowlabel);
#line 276
    header->grh.traffic_class = (u8 )(tmp___1 >> 20);
#line 278
    header->grh.flow_label = (ah->av)->sl_tclass_flowlabel & 4294905600U;
#line 280
    header->grh.hop_limit = (ah->av)->hop_limit;
#line 281
    tmp___2 = __fswab32((ah->av)->port_pd);
#line 281
    ib_get_cached_gid(& dev->ib_dev, (int )((u8 )(tmp___2 >> 24)), (int )(ah->av)->gid_index % dev->limits.gid_table_len,
                      & header->grh.source_gid);
#line 285
    memcpy((void *)(& header->grh.destination_gid.raw), (void const   *)(& (ah->av)->dgid),
             16UL);
  } else {

  }
#line 289
  return (0);
}
}
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.c"
int mthca_ah_query(struct ib_ah *ibah , struct ib_ah_attr *attr ) 
{ 
  struct mthca_ah *ah ;
  struct mthca_ah *tmp ;
  struct mthca_dev *dev ;
  struct mthca_dev *tmp___0 ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  enum ib_rate tmp___4 ;
  int tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;

  {
#line 294
  tmp = to_mah(ibah);
#line 294
  ah = tmp;
#line 295
  tmp___0 = to_mdev(ibah->device);
#line 295
  dev = tmp___0;
#line 298
  if ((unsigned int )ah->type == 0U) {
#line 299
    return (-38);
  } else {

  }
#line 301
  memset((void *)attr, 0, 40UL);
#line 302
  tmp___1 = __fswab16((int )(ah->av)->dlid);
#line 302
  attr->dlid = tmp___1;
#line 303
  tmp___2 = __fswab32((ah->av)->sl_tclass_flowlabel);
#line 303
  attr->sl = (u8 )(tmp___2 >> 28);
#line 304
  tmp___3 = __fswab32((ah->av)->port_pd);
#line 304
  attr->port_num = (u8 )(tmp___3 >> 24);
#line 305
  tmp___4 = mthca_rate_to_ib(dev, (int )(ah->av)->msg_sr & 7, (int )attr->port_num);
#line 305
  attr->static_rate = (u8 )tmp___4;
#line 307
  attr->src_path_bits = (unsigned int )(ah->av)->g_slid & 127U;
#line 308
  tmp___5 = mthca_ah_grh_present(ah);
#line 308
  attr->ah_flags = tmp___5 != 0;
#line 310
  if ((unsigned int )attr->ah_flags != 0U) {
#line 311
    tmp___6 = __fswab32((ah->av)->sl_tclass_flowlabel);
#line 311
    attr->grh.traffic_class = (u8 )(tmp___6 >> 20);
#line 313
    tmp___7 = __fswab32((ah->av)->sl_tclass_flowlabel);
#line 313
    attr->grh.flow_label = tmp___7 & 1048575U;
#line 315
    attr->grh.hop_limit = (ah->av)->hop_limit;
#line 316
    attr->grh.sgid_index = (u8 )((int )((signed char )(ah->av)->gid_index) & (int )((signed char )((unsigned int )((unsigned char )dev->limits.gid_table_len) + 255U)));
#line 318
    memcpy((void *)(& attr->grh.dgid.raw), (void const   *)(& (ah->av)->dgid), 16UL);
  } else {

  }
#line 321
  return (0);
}
}
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.c"
int mthca_init_av_table(struct mthca_dev *dev ) 
{ 
  int err ;
  int tmp ;

  {
#line 328
  tmp = mthca_is_memfree(dev);
#line 328
  if (tmp != 0) {
#line 329
    return (0);
  } else {

  }
#line 331
  err = mthca_alloc_init(& dev->av_table.alloc, (u32 )dev->av_table.num_ddr_avs, (u32 )(dev->av_table.num_ddr_avs + -1),
                         0U);
#line 335
  if (err != 0) {
#line 336
    return (err);
  } else {

  }
#line 338
  dev->av_table.pool = dma_pool_create("mthca_av", & (dev->pdev)->dev, 32UL, 32UL,
                                       0UL);
#line 341
  if ((unsigned long )dev->av_table.pool == (unsigned long )((struct dma_pool *)0)) {
#line 342
    goto out_free_alloc;
  } else {

  }
#line 344
  if ((dev->mthca_flags & 2UL) == 0UL) {
#line 345
    dev->av_table.av_map = ioremap(((dev->pdev)->resource[4].start + dev->av_table.ddr_av_base) - dev->ddr_start,
                                   (unsigned long )(dev->av_table.num_ddr_avs * 32));
#line 350
    if ((unsigned long )dev->av_table.av_map == (unsigned long )((void *)0)) {
#line 351
      goto out_free_pool;
    } else {

    }
  } else {
#line 353
    dev->av_table.av_map = (void *)0;
  }
#line 355
  return (0);
  out_free_pool: 
#line 358
  dma_pool_destroy(dev->av_table.pool);
  out_free_alloc: 
#line 361
  mthca_alloc_cleanup(& dev->av_table.alloc);
#line 362
  return (-12);
}
}
#line 365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.c"
void mthca_cleanup_av_table(struct mthca_dev *dev ) 
{ 
  int tmp ;

  {
#line 367
  tmp = mthca_is_memfree(dev);
#line 367
  if (tmp != 0) {
#line 368
    return;
  } else {

  }
#line 370
  if ((unsigned long )dev->av_table.av_map != (unsigned long )((void *)0)) {
#line 371
    iounmap((void volatile   *)dev->av_table.av_map);
  } else {

  }
#line 372
  dma_pool_destroy(dev->av_table.pool);
#line 373
  mthca_alloc_cleanup(& dev->av_table.alloc);
#line 374
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.o.c.prepared"
bool ldv_queue_work_on_149(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.o.c.prepared"
bool ldv_queue_delayed_work_on_150(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.o.c.prepared"
bool ldv_queue_work_on_151(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.o.c.prepared"
void ldv_flush_workqueue_152(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_av.o.c.prepared"
bool ldv_queue_delayed_work_on_153(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 63 "./arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_163(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_164(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_167(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_166(struct workqueue_struct *ldv_func_arg1 ) ;
#line 573 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
int mthca_multicast_attach(struct ib_qp *ibqp , union ib_gid *gid , u16 lid ) ;
#line 574
int mthca_multicast_detach(struct ib_qp *ibqp , union ib_gid *gid , u16 lid ) ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mcg.c"
static u8 const   zero_gid[16U]  ;
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mcg.c"
static int find_mgm(struct mthca_dev *dev , u8 *gid , struct mthca_mailbox *mgm_mailbox ,
                    u16 *hash , int *prev , int *index ) 
{ 
  struct mthca_mailbox *mailbox ;
  struct mthca_mgm *mgm ;
  u8 *mgid ;
  int err ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __u32 tmp___2 ;

  {
#line 68
  mgm = (struct mthca_mgm *)mgm_mailbox->buf;
#line 72
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 73
  tmp = IS_ERR((void const   *)mailbox);
#line 73
  if ((int )tmp) {
#line 74
    return (-12);
  } else {

  }
#line 75
  mgid = (u8 *)mailbox->buf;
#line 77
  memcpy((void *)mgid, (void const   *)gid, 16UL);
#line 79
  err = mthca_MGID_HASH(dev, mailbox, hash);
#line 80
  if (err != 0) {
#line 81
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "MGID_HASH failed (%d)\n",
            err);
#line 82
    goto out;
  } else {

  }
#line 88
  *index = (int )*hash;
#line 89
  *prev = -1;
  ldv_30480: 
#line 92
  err = mthca_READ_MGM(dev, *index, mgm_mailbox);
#line 93
  if (err != 0) {
#line 94
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "READ_MGM failed (%d)\n",
            err);
#line 95
    goto out;
  } else {

  }
#line 98
  tmp___0 = memcmp((void const   *)(& mgm->gid), (void const   *)(& zero_gid), 16UL);
#line 98
  if (tmp___0 == 0) {
#line 99
    if (*index != (int )*hash) {
#line 100
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "Found zero MGID in AMGM.\n");
#line 101
      err = -22;
    } else {

    }
#line 103
    goto out;
  } else {

  }
#line 106
  tmp___1 = memcmp((void const   *)(& mgm->gid), (void const   *)gid, 16UL);
#line 106
  if (tmp___1 == 0) {
#line 107
    goto out;
  } else {

  }
#line 109
  *prev = *index;
#line 110
  tmp___2 = __fswab32(mgm->next_gid_index);
#line 110
  *index = (int )(tmp___2 >> 6);
#line 111
  if (*index != 0) {
#line 113
    goto ldv_30480;
  } else {

  }
#line 113
  *index = -1;
  out: 
#line 116
  mthca_free_mailbox(dev, mailbox);
#line 117
  return (err);
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mcg.c"
int mthca_multicast_attach(struct ib_qp *ibqp , union ib_gid *gid , u16 lid ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_mailbox *mailbox ;
  struct mthca_mgm *mgm ;
  u16 hash ;
  int index ;
  int prev ;
  int link ;
  int i ;
  int err ;
  long tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  long tmp___7 ;

  {
#line 122
  tmp = to_mdev(ibqp->device);
#line 122
  dev = tmp;
#line 127
  link = 0;
#line 131
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 132
  tmp___1 = IS_ERR((void const   *)mailbox);
#line 132
  if ((int )tmp___1) {
#line 133
    tmp___0 = PTR_ERR((void const   *)mailbox);
#line 133
    return ((int )tmp___0);
  } else {

  }
#line 134
  mgm = (struct mthca_mgm *)mailbox->buf;
#line 136
  mutex_lock_nested(& dev->mcg_table.mutex, 0U);
#line 138
  err = find_mgm(dev, (u8 *)(& gid->raw), mailbox, & hash, & prev, & index);
#line 139
  if (err != 0) {
#line 140
    goto out;
  } else {

  }
#line 142
  if (index != -1) {
#line 143
    tmp___2 = memcmp((void const   *)(& mgm->gid), (void const   *)(& zero_gid), 16UL);
#line 143
    if (tmp___2 == 0) {
#line 144
      memcpy((void *)(& mgm->gid), (void const   *)(& gid->raw), 16UL);
    } else {

    }
  } else {
#line 146
    link = 1;
#line 148
    tmp___3 = mthca_alloc(& dev->mcg_table.alloc);
#line 148
    index = (int )tmp___3;
#line 149
    if (index == -1) {
#line 150
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "No AMGM entries left\n");
#line 151
      err = -12;
#line 152
      goto out;
    } else {

    }
#line 155
    err = mthca_READ_MGM(dev, index, mailbox);
#line 156
    if (err != 0) {
#line 157
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "READ_MGM failed (%d)\n",
              err);
#line 158
      goto out;
    } else {

    }
#line 160
    memset((void *)mgm, 0, 256UL);
#line 161
    memcpy((void *)(& mgm->gid), (void const   *)(& gid->raw), 16UL);
  }
#line 164
  i = 0;
#line 164
  goto ldv_30499;
  ldv_30498: 
#line 165
  tmp___5 = __fswab32(ibqp->qp_num | 2147483648U);
#line 165
  if (mgm->qp[i] == tmp___5) {
#line 166
    if (mthca_debug_level != 0) {
#line 166
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "QP %06x already a member of MGM\n",
                 ibqp->qp_num);
    } else {

    }
#line 168
    err = 0;
#line 169
    goto out;
  } else
#line 170
  if ((mgm->qp[i] & 128U) == 0U) {
#line 171
    tmp___4 = __fswab32(ibqp->qp_num | 2147483648U);
#line 171
    mgm->qp[i] = tmp___4;
#line 172
    goto ldv_30497;
  } else {

  }
#line 164
  i = i + 1;
  ldv_30499: ;
#line 164
  if (i <= 55) {
#line 166
    goto ldv_30498;
  } else {

  }
  ldv_30497: ;
#line 175
  if (i == 56) {
#line 176
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "MGM at index %x is full.\n",
            index);
#line 177
    err = -12;
#line 178
    goto out;
  } else {

  }
#line 181
  err = mthca_WRITE_MGM(dev, index, mailbox);
#line 182
  if (err != 0) {
#line 183
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "WRITE_MGM failed %d\n",
            err);
#line 184
    err = -22;
#line 185
    goto out;
  } else {

  }
#line 188
  if (link == 0) {
#line 189
    goto out;
  } else {

  }
#line 191
  err = mthca_READ_MGM(dev, prev, mailbox);
#line 192
  if (err != 0) {
#line 193
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "READ_MGM failed %d\n",
            err);
#line 194
    goto out;
  } else {

  }
#line 197
  tmp___6 = __fswab32((__u32 )(index << 6));
#line 197
  mgm->next_gid_index = tmp___6;
#line 199
  err = mthca_WRITE_MGM(dev, prev, mailbox);
#line 200
  if (err != 0) {
#line 201
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "WRITE_MGM returned %d\n",
            err);
  } else {

  }
  out: ;
#line 204
  if ((err != 0 && link != 0) && index != -1) {
#line 205
    tmp___7 = ldv__builtin_expect(dev->limits.num_mgms > index, 0L);
#line 205
    if (tmp___7 != 0L) {
#line 205
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mcg.c"),
                           "i" (205), "i" (12UL));
      ldv_30500: ;
#line 205
      goto ldv_30500;
    } else {

    }
#line 206
    mthca_free(& dev->mcg_table.alloc, (u32 )index);
  } else {

  }
#line 208
  mutex_unlock(& dev->mcg_table.mutex);
#line 210
  mthca_free_mailbox(dev, mailbox);
#line 211
  return (err);
}
}
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mcg.c"
int mthca_multicast_detach(struct ib_qp *ibqp , union ib_gid *gid , u16 lid ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_mailbox *mailbox ;
  struct mthca_mgm *mgm ;
  u16 hash ;
  int prev ;
  int index ;
  int i ;
  int loc ;
  int err ;
  long tmp___0 ;
  bool tmp___1 ;
  __u32 tmp___2 ;
  int amgm_index_to_free ;
  __u32 tmp___3 ;
  long tmp___4 ;
  int curr_next_index ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  long tmp___7 ;

  {
#line 216
  tmp = to_mdev(ibqp->device);
#line 216
  dev = tmp;
#line 224
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 225
  tmp___1 = IS_ERR((void const   *)mailbox);
#line 225
  if ((int )tmp___1) {
#line 226
    tmp___0 = PTR_ERR((void const   *)mailbox);
#line 226
    return ((int )tmp___0);
  } else {

  }
#line 227
  mgm = (struct mthca_mgm *)mailbox->buf;
#line 229
  mutex_lock_nested(& dev->mcg_table.mutex, 0U);
#line 231
  err = find_mgm(dev, (u8 *)(& gid->raw), mailbox, & hash, & prev, & index);
#line 232
  if (err != 0) {
#line 233
    goto out;
  } else {

  }
#line 235
  if (index == -1) {
#line 236
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "MGID %pI6 not found\n",
            (u8 *)(& gid->raw));
#line 237
    err = -22;
#line 238
    goto out;
  } else {

  }
#line 241
  loc = -1;
#line 241
  i = 0;
#line 241
  goto ldv_30518;
  ldv_30517: 
#line 242
  tmp___2 = __fswab32(ibqp->qp_num | 2147483648U);
#line 242
  if (mgm->qp[i] == tmp___2) {
#line 243
    loc = i;
  } else {

  }
#line 244
  if ((mgm->qp[i] & 128U) == 0U) {
#line 245
    goto ldv_30516;
  } else {

  }
#line 241
  i = i + 1;
  ldv_30518: ;
#line 241
  if (i <= 55) {
#line 243
    goto ldv_30517;
  } else {

  }
  ldv_30516: ;
#line 248
  if (loc == -1) {
#line 249
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "QP %06x not found in MGM\n",
            ibqp->qp_num);
#line 250
    err = -22;
#line 251
    goto out;
  } else {

  }
#line 254
  mgm->qp[loc] = mgm->qp[i + -1];
#line 255
  mgm->qp[i + -1] = 0U;
#line 257
  err = mthca_WRITE_MGM(dev, index, mailbox);
#line 258
  if (err != 0) {
#line 259
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "WRITE_MGM returned %d\n",
            err);
#line 260
    goto out;
  } else {

  }
#line 263
  if (i != 1) {
#line 264
    goto out;
  } else {

  }
#line 266
  if (prev == -1) {
#line 268
    tmp___3 = __fswab32(mgm->next_gid_index);
#line 268
    amgm_index_to_free = (int )(tmp___3 >> 6);
#line 269
    if (amgm_index_to_free != 0) {
#line 270
      err = mthca_READ_MGM(dev, amgm_index_to_free, mailbox);
#line 272
      if (err != 0) {
#line 273
        dev_err((struct device  const  *)(& (dev->pdev)->dev), "READ_MGM returned %d\n",
                err);
#line 274
        goto out;
      } else {

      }
    } else {
#line 277
      memset((void *)(& mgm->gid), 0, 16UL);
    }
#line 279
    err = mthca_WRITE_MGM(dev, index, mailbox);
#line 280
    if (err != 0) {
#line 281
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "WRITE_MGM returned %d\n",
              err);
#line 282
      goto out;
    } else {

    }
#line 284
    if (amgm_index_to_free != 0) {
#line 285
      tmp___4 = ldv__builtin_expect(dev->limits.num_mgms > amgm_index_to_free, 0L);
#line 285
      if (tmp___4 != 0L) {
#line 285
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mcg.c"),
                             "i" (285), "i" (12UL));
        ldv_30520: ;
#line 285
        goto ldv_30520;
      } else {

      }
#line 286
      mthca_free(& dev->mcg_table.alloc, (u32 )amgm_index_to_free);
    } else {

    }
  } else {
#line 290
    tmp___5 = __fswab32(mgm->next_gid_index);
#line 290
    curr_next_index = (int )(tmp___5 >> 6);
#line 291
    err = mthca_READ_MGM(dev, prev, mailbox);
#line 292
    if (err != 0) {
#line 293
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "READ_MGM returned %d\n",
              err);
#line 294
      goto out;
    } else {

    }
#line 297
    tmp___6 = __fswab32((__u32 )(curr_next_index << 6));
#line 297
    mgm->next_gid_index = tmp___6;
#line 299
    err = mthca_WRITE_MGM(dev, prev, mailbox);
#line 300
    if (err != 0) {
#line 301
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "WRITE_MGM returned %d\n",
              err);
#line 302
      goto out;
    } else {

    }
#line 304
    tmp___7 = ldv__builtin_expect(dev->limits.num_mgms > index, 0L);
#line 304
    if (tmp___7 != 0L) {
#line 304
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mcg.c"),
                           "i" (304), "i" (12UL));
      ldv_30522: ;
#line 304
      goto ldv_30522;
    } else {

    }
#line 305
    mthca_free(& dev->mcg_table.alloc, (u32 )index);
  }
  out: 
#line 309
  mutex_unlock(& dev->mcg_table.mutex);
#line 311
  mthca_free_mailbox(dev, mailbox);
#line 312
  return (err);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mcg.c"
int mthca_init_mcg_table(struct mthca_dev *dev ) 
{ 
  int err ;
  int table_size ;
  struct lock_class_key __key ;

  {
#line 318
  table_size = dev->limits.num_mgms + dev->limits.num_amgms;
#line 320
  err = mthca_alloc_init(& dev->mcg_table.alloc, (u32 )table_size, (u32 )(table_size + -1),
                         (u32 )dev->limits.num_mgms);
#line 324
  if (err != 0) {
#line 325
    return (err);
  } else {

  }
#line 327
  __mutex_init(& dev->mcg_table.mutex, "&dev->mcg_table.mutex", & __key);
#line 329
  return (0);
}
}
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mcg.c"
void mthca_cleanup_mcg_table(struct mthca_dev *dev ) 
{ 


  {
#line 334
  mthca_alloc_cleanup(& dev->mcg_table.alloc);
#line 335
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mcg.o.c.prepared"
bool ldv_queue_work_on_163(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mcg.o.c.prepared"
bool ldv_queue_delayed_work_on_164(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mcg.o.c.prepared"
bool ldv_queue_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mcg.o.c.prepared"
void ldv_flush_workqueue_166(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mcg.o.c.prepared"
bool ldv_queue_delayed_work_on_167(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_177(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_179(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_178(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_181(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_180(struct workqueue_struct *ldv_func_arg1 ) ;
#line 297 "include/rdma/ib_verbs.h"
__inline static int ib_width_enum_to_int(enum ib_port_width width ) 
{ 


  {
#line 299
  switch ((unsigned int )width) {
  case 1U: ;
#line 300
  return (1);
  case 2U: ;
#line 301
  return (4);
  case 4U: ;
#line 302
  return (8);
  case 8U: ;
#line 303
  return (12);
  default: ;
#line 304
  return (-1);
  }
}
}
#line 1820
extern int ib_query_port(struct ib_device * , u8  , struct ib_port_attr * ) ;
#line 2147
extern struct ib_ah *ib_create_ah(struct ib_pd * , struct ib_ah_attr * ) ;
#line 2201
extern int ib_destroy_ah(struct ib_ah * ) ;
#line 490 "include/rdma/ib_mad.h"
extern struct ib_mad_agent *ib_register_mad_agent(struct ib_device * , u8  , enum ib_qp_type  ,
                                                  struct ib_mad_reg_req * , u8  ,
                                                  void (*)(struct ib_mad_agent * ,
                                                           struct ib_mad_send_wc * ) ,
                                                  void (*)(struct ib_mad_agent * ,
                                                           struct ib_mad_recv_wc * ) ,
                                                  void * , u32  ) ;
#line 536
extern int ib_unregister_mad_agent(struct ib_mad_agent * ) ;
#line 557
extern int ib_post_send_mad(struct ib_mad_send_buf * , struct ib_mad_send_buf ** ) ;
#line 660
extern struct ib_mad_send_buf *ib_create_send_mad(struct ib_mad_agent * , u32  , u16  ,
                                                  int  , int  , int  , gfp_t  , u8  ) ;
#line 700
extern void ib_free_send_mad(struct ib_mad_send_buf * ) ;
#line 576 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
int mthca_process_mad(struct ib_device *ibdev , int mad_flags , u8 port_num , struct ib_wc  const  *in_wc ,
                      struct ib_grh  const  *in_grh , struct ib_mad_hdr  const  *in ,
                      size_t in_mad_size , struct ib_mad_hdr *out , size_t *out_mad_size ,
                      u16 *out_mad_pkey_index ) ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.c"
static int mthca_update_rate(struct mthca_dev *dev , u8 port_num ) 
{ 
  struct ib_port_attr *tprops ;
  int ret ;
  void *tmp ;
  int tmp___0 ;

  {
#line 52
  tprops = (struct ib_port_attr *)0;
#line 55
  tmp = kmalloc(48UL, 208U);
#line 55
  tprops = (struct ib_port_attr *)tmp;
#line 56
  if ((unsigned long )tprops == (unsigned long )((struct ib_port_attr *)0)) {
#line 57
    return (-12);
  } else {

  }
#line 59
  ret = ib_query_port(& dev->ib_dev, (int )port_num, tprops);
#line 60
  if (ret != 0) {
#line 61
    printk("\fib_query_port failed (%d) for %s port %d\n", ret, (char *)(& dev->ib_dev.name),
           (int )port_num);
#line 63
    goto out;
  } else {

  }
#line 66
  tmp___0 = ib_width_enum_to_int((enum ib_port_width )tprops->active_width);
#line 66
  dev->rate[(int )port_num + -1] = (int )tprops->active_speed * (int )((u8 )tmp___0);
  out: 
#line 70
  kfree((void const   *)tprops);
#line 71
  return (ret);
}
}
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.c"
static void update_sm_ah(struct mthca_dev *dev , u8 port_num , u16 lid , u8 sl ) 
{ 
  struct ib_ah *new_ah ;
  struct ib_ah_attr ah_attr ;
  unsigned long flags ;
  bool tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 81
  if ((unsigned long )dev->send_agent[(int )port_num + -1][0] == (unsigned long )((struct ib_mad_agent *)0)) {
#line 82
    return;
  } else {

  }
#line 84
  memset((void *)(& ah_attr), 0, 40UL);
#line 85
  ah_attr.dlid = lid;
#line 86
  ah_attr.sl = sl;
#line 87
  ah_attr.port_num = port_num;
#line 89
  new_ah = ib_create_ah(((dev->send_agent[(int )port_num + -1][0])->qp)->pd, & ah_attr);
#line 91
  tmp = IS_ERR((void const   *)new_ah);
#line 91
  if ((int )tmp) {
#line 92
    return;
  } else {

  }
#line 94
  tmp___0 = spinlock_check(& dev->sm_lock);
#line 94
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 95
  if ((unsigned long )dev->sm_ah[(int )port_num + -1] != (unsigned long )((struct ib_ah *)0)) {
#line 96
    ib_destroy_ah(dev->sm_ah[(int )port_num + -1]);
  } else {

  }
#line 97
  dev->sm_ah[(int )port_num + -1] = new_ah;
#line 98
  spin_unlock_irqrestore(& dev->sm_lock, flags);
#line 99
  return;
}
}
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.c"
static void smp_snoop(struct ib_device *ibdev , u8 port_num , struct ib_mad  const  *mad ,
                      u16 prev_lid ) 
{ 
  struct ib_event event ;
  struct ib_port_info *pinfo ;
  u16 lid ;
  __u16 tmp ;
  struct mthca_dev *tmp___0 ;
  __u16 tmp___1 ;
  struct mthca_dev *tmp___2 ;

  {
#line 112
  if (((unsigned int )((unsigned char )mad->mad_hdr.mgmt_class) == 1U || (unsigned int )((unsigned char )mad->mad_hdr.mgmt_class) == 129U) && (unsigned int )((unsigned char )mad->mad_hdr.method) == 2U) {
#line 115
    if ((unsigned int )((unsigned short )mad->mad_hdr.attr_id) == 5376U) {
#line 116
      pinfo = (struct ib_port_info *)(& ((struct ib_smp *)mad)->data);
#line 118
      tmp = __fswab16((int )pinfo->lid);
#line 118
      lid = tmp;
#line 120
      tmp___0 = to_mdev(ibdev);
#line 120
      mthca_update_rate(tmp___0, (int )port_num);
#line 121
      tmp___1 = __fswab16((int )pinfo->sm_lid);
#line 121
      tmp___2 = to_mdev(ibdev);
#line 121
      update_sm_ah(tmp___2, (int )port_num, (int )tmp___1, (int )pinfo->neighbormtu_mastersmsl & 15);
#line 125
      event.device = ibdev;
#line 126
      event.element.port_num = port_num;
#line 128
      if ((int )((signed char )pinfo->clientrereg_resv_subnetto) < 0) {
#line 129
        event.event = 17;
#line 130
        ib_dispatch_event(& event);
      } else {

      }
#line 133
      if ((int )prev_lid != (int )lid) {
#line 134
        event.event = 11;
#line 135
        ib_dispatch_event(& event);
      } else {

      }
    } else {

    }
#line 139
    if ((unsigned int )((unsigned short )mad->mad_hdr.attr_id) == 5632U) {
#line 140
      event.device = ibdev;
#line 141
      event.event = 12;
#line 142
      event.element.port_num = port_num;
#line 143
      ib_dispatch_event(& event);
    } else {

    }
  } else {

  }
#line 146
  return;
}
}
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.c"
static void node_desc_override(struct ib_device *dev , struct ib_mad *mad ) 
{ 
  struct mthca_dev *tmp ;
  struct mthca_dev *tmp___0 ;

  {
#line 151
  if ((((unsigned int )mad->mad_hdr.mgmt_class == 1U || (unsigned int )mad->mad_hdr.mgmt_class == 129U) && (unsigned int )mad->mad_hdr.method == 129U) && (unsigned int )mad->mad_hdr.attr_id == 4096U) {
#line 155
    tmp = to_mdev(dev);
#line 155
    mutex_lock_nested(& tmp->cap_mask_mutex, 0U);
#line 156
    memcpy((void *)(& ((struct ib_smp *)mad)->data), (void const   *)(& dev->node_desc),
             64UL);
#line 157
    tmp___0 = to_mdev(dev);
#line 157
    mutex_unlock(& tmp___0->cap_mask_mutex);
  } else {

  }
#line 159
  return;
}
}
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.c"
static void forward_trap(struct mthca_dev *dev , u8 port_num , struct ib_mad  const  *mad ) 
{ 
  int qpn ;
  struct ib_mad_send_buf *send_buf ;
  struct ib_mad_agent *agent ;
  int ret ;
  unsigned long flags ;
  bool tmp ;
  raw_spinlock_t *tmp___0 ;
  struct ib_ah *tmp___1 ;

  {
#line 165
  qpn = (unsigned int )((unsigned char )mad->mad_hdr.mgmt_class) != 1U;
#line 167
  agent = dev->send_agent[(int )port_num + -1][qpn];
#line 171
  if ((unsigned long )agent != (unsigned long )((struct ib_mad_agent *)0)) {
#line 172
    send_buf = ib_create_send_mad(agent, (u32 )qpn, 0, 0, 24, 232, 32U, 1);
#line 175
    tmp = IS_ERR((void const   *)send_buf);
#line 175
    if ((int )tmp) {
#line 176
      return;
    } else {

    }
#line 183
    tmp___0 = spinlock_check(& dev->sm_lock);
#line 183
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 184
    memcpy(send_buf->mad, (void const   *)mad, 256UL);
#line 185
    tmp___1 = dev->sm_ah[(int )port_num + -1];
#line 185
    send_buf->ah = tmp___1;
#line 185
    if ((unsigned long )tmp___1 != (unsigned long )((struct ib_ah *)0)) {
#line 186
      ret = ib_post_send_mad(send_buf, (struct ib_mad_send_buf **)0);
    } else {
#line 188
      ret = -22;
    }
#line 189
    spin_unlock_irqrestore(& dev->sm_lock, flags);
#line 191
    if (ret != 0) {
#line 192
      ib_free_send_mad(send_buf);
    } else {

    }
  } else {

  }
#line 194
  return;
}
}
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.c"
int mthca_process_mad(struct ib_device *ibdev , int mad_flags , u8 port_num , struct ib_wc  const  *in_wc ,
                      struct ib_grh  const  *in_grh , struct ib_mad_hdr  const  *in ,
                      size_t in_mad_size , struct ib_mad_hdr *out , size_t *out_mad_size ,
                      u16 *out_mad_pkey_index ) 
{ 
  int err ;
  u16 slid ;
  u16 prev_lid ;
  struct ib_port_attr pattr ;
  struct ib_mad  const  *in_mad ;
  struct ib_mad *out_mad ;
  long tmp ;
  struct mthca_dev *tmp___0 ;
  int tmp___1 ;
  struct mthca_dev *tmp___2 ;
  struct mthca_dev *tmp___3 ;

  {
#line 206
  slid = (unsigned long )in_wc != (unsigned long )((struct ib_wc  const  *)0) ? (u16 )in_wc->slid : 65535U;
#line 207
  prev_lid = 0U;
#line 209
  in_mad = (struct ib_mad  const  *)in;
#line 210
  out_mad = (struct ib_mad *)out;
#line 212
  tmp = ldv__builtin_expect((long )(in_mad_size != 256UL || *out_mad_size != 256UL),
                         0L);
#line 212
  if (tmp != 0L) {
#line 212
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.c"),
                         "i" (213), "i" (12UL));
    ldv_30863: ;
#line 212
    goto ldv_30863;
  } else {

  }
#line 216
  if ((unsigned int )((unsigned char )in_mad->mad_hdr.method) == 5U && (unsigned int )slid == 0U) {
#line 218
    tmp___0 = to_mdev(ibdev);
#line 218
    forward_trap(tmp___0, (int )port_num, in_mad);
#line 219
    return (5);
  } else {

  }
#line 228
  if ((unsigned int )((unsigned char )in_mad->mad_hdr.mgmt_class) == 1U || (unsigned int )((unsigned char )in_mad->mad_hdr.mgmt_class) == 129U) {
#line 230
    if (((unsigned int )((unsigned char )in_mad->mad_hdr.method) != 1U && (unsigned int )((unsigned char )in_mad->mad_hdr.method) != 2U) && (unsigned int )((unsigned char )in_mad->mad_hdr.method) != 7U) {
#line 233
      return (1);
    } else {

    }
#line 239
    if ((unsigned int )((unsigned short )in_mad->mad_hdr.attr_id) == 8192U || ((int )in_mad->mad_hdr.attr_id & 255) == 255) {
#line 242
      return (1);
    } else {

    }
  } else
#line 243
  if (((unsigned int )((unsigned char )in_mad->mad_hdr.mgmt_class) == 4U || (unsigned int )((unsigned char )in_mad->mad_hdr.mgmt_class) == 9U) || (unsigned int )((unsigned char )in_mad->mad_hdr.mgmt_class) == 10U) {
#line 246
    if ((unsigned int )((unsigned char )in_mad->mad_hdr.method) != 1U && (unsigned int )((unsigned char )in_mad->mad_hdr.method) != 2U) {
#line 248
      return (1);
    } else {

    }
  } else {
#line 250
    return (1);
  }
#line 251
  if ((((unsigned int )((unsigned char )in_mad->mad_hdr.mgmt_class) == 1U || (unsigned int )((unsigned char )in_mad->mad_hdr.mgmt_class) == 129U) && (unsigned int )((unsigned char )in_mad->mad_hdr.method) == 2U) && (unsigned int )((unsigned short )in_mad->mad_hdr.attr_id) == 5376U) {
#line 251
    tmp___1 = ib_query_port(ibdev, (int )port_num, & pattr);
#line 251
    if (tmp___1 == 0) {
#line 256
      prev_lid = pattr.lid;
    } else {

    }
  } else {

  }
#line 258
  tmp___2 = to_mdev(ibdev);
#line 258
  err = mthca_MAD_IFC(tmp___2, mad_flags & 1, mad_flags & 2, (int )port_num, in_wc,
                      in_grh, (void const   *)in_mad, (void *)out_mad);
#line 262
  if (err == -74) {
#line 263
    return (1);
  } else
#line 264
  if (err != 0) {
#line 265
    tmp___3 = to_mdev(ibdev);
#line 265
    dev_err((struct device  const  *)(& (tmp___3->pdev)->dev), "MAD_IFC returned %d\n",
            err);
#line 266
    return (0);
  } else {

  }
#line 269
  if ((unsigned int )out_mad->mad_hdr.status == 0U) {
#line 270
    smp_snoop(ibdev, (int )port_num, in_mad, (int )prev_lid);
#line 271
    node_desc_override(ibdev, out_mad);
  } else {

  }
#line 275
  if ((unsigned int )((unsigned char )in_mad->mad_hdr.mgmt_class) == 129U) {
#line 276
    out_mad->mad_hdr.status = (__be16 )((unsigned int )out_mad->mad_hdr.status | 128U);
  } else {

  }
#line 278
  if ((unsigned int )((unsigned char )in_mad->mad_hdr.method) == 7U) {
#line 280
    return (5);
  } else {

  }
#line 282
  return (3);
}
}
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.c"
static void send_handler(struct ib_mad_agent *agent , struct ib_mad_send_wc *mad_send_wc ) 
{ 


  {
#line 288
  ib_free_send_mad(mad_send_wc->send_buf);
#line 289
  return;
}
}
#line 291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.c"
int mthca_create_agents(struct mthca_dev *dev ) 
{ 
  struct ib_mad_agent *agent ;
  int p ;
  int q ;
  int ret ;
  struct lock_class_key __key ;
  long tmp ;
  bool tmp___0 ;

  {
#line 297
  spinlock_check(& dev->sm_lock);
#line 297
  __raw_spin_lock_init(& dev->sm_lock.__annonCompField18.rlock, "&(&dev->sm_lock)->rlock",
                       & __key);
#line 299
  p = 0;
#line 299
  goto ldv_30881;
  ldv_30880: 
#line 300
  q = 0;
#line 300
  goto ldv_30878;
  ldv_30877: 
#line 301
  agent = ib_register_mad_agent(& dev->ib_dev, (int )((unsigned int )((u8 )p) + 1U),
                                q != 0, (struct ib_mad_reg_req *)0, 0, & send_handler,
                                (void (*)(struct ib_mad_agent * , struct ib_mad_recv_wc * ))0,
                                (void *)0, 0U);
#line 305
  tmp___0 = IS_ERR((void const   *)agent);
#line 305
  if ((int )tmp___0) {
#line 306
    tmp = PTR_ERR((void const   *)agent);
#line 306
    ret = (int )tmp;
#line 307
    goto err;
  } else {

  }
#line 309
  dev->send_agent[p][q] = agent;
#line 300
  q = q + 1;
  ldv_30878: ;
#line 300
  if (q <= 1) {
#line 302
    goto ldv_30877;
  } else {

  }
#line 299
  p = p + 1;
  ldv_30881: ;
#line 299
  if (dev->limits.num_ports > p) {
#line 301
    goto ldv_30880;
  } else {

  }
#line 313
  p = 1;
#line 313
  goto ldv_30884;
  ldv_30883: 
#line 314
  ret = mthca_update_rate(dev, (int )((u8 )p));
#line 315
  if (ret != 0) {
#line 316
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to obtain port %d rate. aborting.\n",
            p);
#line 318
    goto err;
  } else {

  }
#line 313
  p = p + 1;
  ldv_30884: ;
#line 313
  if (dev->limits.num_ports >= p) {
#line 315
    goto ldv_30883;
  } else {

  }

#line 322
  return (0);
  err: 
#line 325
  p = 0;
#line 325
  goto ldv_30890;
  ldv_30889: 
#line 326
  q = 0;
#line 326
  goto ldv_30887;
  ldv_30886: ;
#line 327
  if ((unsigned long )dev->send_agent[p][q] != (unsigned long )((struct ib_mad_agent *)0)) {
#line 328
    ib_unregister_mad_agent(dev->send_agent[p][q]);
  } else {

  }
#line 326
  q = q + 1;
  ldv_30887: ;
#line 326
  if (q <= 1) {
#line 328
    goto ldv_30886;
  } else {

  }
#line 325
  p = p + 1;
  ldv_30890: ;
#line 325
  if (dev->limits.num_ports > p) {
#line 327
    goto ldv_30889;
  } else {

  }

#line 330
  return (ret);
}
}
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.c"
void mthca_free_agents(struct mthca_dev *dev ) 
{ 
  struct ib_mad_agent *agent ;
  int p ;
  int q ;

  {
#line 338
  p = 0;
#line 338
  goto ldv_30902;
  ldv_30901: 
#line 339
  q = 0;
#line 339
  goto ldv_30899;
  ldv_30898: 
#line 340
  agent = dev->send_agent[p][q];
#line 341
  dev->send_agent[p][q] = (struct ib_mad_agent *)0;
#line 342
  ib_unregister_mad_agent(agent);
#line 339
  q = q + 1;
  ldv_30899: ;
#line 339
  if (q <= 1) {
#line 341
    goto ldv_30898;
  } else {

  }

#line 345
  if ((unsigned long )dev->sm_ah[p] != (unsigned long )((struct ib_ah *)0)) {
#line 346
    ib_destroy_ah(dev->sm_ah[p]);
  } else {

  }
#line 338
  p = p + 1;
  ldv_30902: ;
#line 338
  if (dev->limits.num_ports > p) {
#line 340
    goto ldv_30901;
  } else {

  }

#line 345
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.o.c.prepared"
bool ldv_queue_work_on_177(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.o.c.prepared"
bool ldv_queue_delayed_work_on_178(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.o.c.prepared"
bool ldv_queue_work_on_179(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.o.c.prepared"
void ldv_flush_workqueue_180(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_mad.o.c.prepared"
bool ldv_queue_delayed_work_on_181(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 307 "./arch/x86/include/asm/pgtable_types.h"
extern uint16_t __cachemode2pte_tbl[8U] ;
#line 319 "./arch/x86/include/asm/pgtable_types.h"
__inline static unsigned long cachemode2protval(enum page_cache_mode pcm ) 
{ 
  long tmp ;

  {
#line 321
  tmp = ldv__builtin_expect((unsigned int )pcm == 0U, 1L);
#line 321
  if (tmp != 0L) {
#line 322
    return (0UL);
  } else {

  }
#line 323
  return ((unsigned long )__cachemode2pte_tbl[(unsigned int )pcm]);
}
}
#line 346 "./arch/x86/include/asm/bitops.h"
__inline static unsigned long __ffs(unsigned long word ) 
{ 


  {
#line 348
  __asm__  ("rep; bsf %1,%0": "=r" (word): "rm" (word));
#line 351
  return (word);
}
}
#line 248 "include/linux/kernel.h"
extern void __might_fault(char const   * , int  ) ;
#line 402
extern int sprintf(char * , char const   *  , ...) ;
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 32
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 155 "./arch/x86/include/asm/processor.h"
extern struct cpuinfo_x86 boot_cpu_data ;
#line 141 "include/linux/mutex.h"
extern int mutex_lock_interruptible_nested(struct mutex * , unsigned int  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_191(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_193(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_192(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_195(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_194(struct workqueue_struct *ldv_func_arg1 ) ;
#line 352 "include/linux/gfp.h"
extern unsigned long __get_free_pages(gfp_t  , unsigned int  ) ;
#line 591 "include/linux/device.h"
extern int device_create_file(struct device * , struct device_attribute  const  * ) ;
#line 2012 "include/linux/mm.h"
extern int remap_pfn_range(struct vm_area_struct * , unsigned long  , unsigned long  ,
                           unsigned long  , pgprot_t  ) ;
#line 250 "include/linux/scatterlist.h"
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 650 "./arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 652
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 672
extern void __copy_from_user_overflow(void) ;
#line 677
extern void __copy_to_user_overflow(void) ;
#line 693 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 695
  tmp = __builtin_object_size((void const   *)to, 0);
#line 695
  sz = (int )tmp;
#line 697
  __might_fault("./arch/x86/include/asm/uaccess.h", 697);
#line 717
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
#line 717
  if (tmp___0 != 0L) {
#line 718
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
#line 722
    __copy_from_user_overflow();
  }
#line 724
  return (n);
}
}
#line 728 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 730
  tmp = __builtin_object_size(from, 0);
#line 730
  sz = (int )tmp;
#line 732
  __might_fault("./arch/x86/include/asm/uaccess.h", 732);
#line 735
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
#line 735
  if (tmp___0 != 0L) {
#line 736
    n = _copy_to_user(to, from, (unsigned int )n);
  } else {
#line 740
    __copy_to_user_overflow();
  }
#line 742
  return (n);
}
}
#line 1771 "include/rdma/ib_verbs.h"
extern int ib_register_device(struct ib_device * , int (*)(struct ib_device * , u8  ,
                                                           struct kobject * ) ) ;
#line 1774
extern void ib_unregister_device(struct ib_device * ) ;
#line 1783 "include/rdma/ib_verbs.h"
__inline static int ib_copy_from_udata(void *dest , struct ib_udata *udata , size_t len ) 
{ 
  unsigned long tmp ;

  {
#line 1785
  tmp = copy_from_user(dest, udata->inbuf, len);
#line 1785
  return (tmp != 0UL ? -14 : 0);
}
}
#line 1788 "include/rdma/ib_verbs.h"
__inline static int ib_copy_to_udata(struct ib_udata *udata , void *src , size_t len ) 
{ 
  unsigned long tmp ;

  {
#line 1790
  tmp = copy_to_user(udata->outbuf, (void const   *)src, len);
#line 1790
  return (tmp != 0UL ? -14 : 0);
}
}
#line 85 "include/rdma/ib_umem.h"
extern struct ib_umem *ib_umem_get(struct ib_ucontext * , unsigned long  , size_t  ,
                                   int  , int  ) ;
#line 87
extern void ib_umem_release(struct ib_umem * ) ;
#line 309 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_mr *to_mmr(struct ib_mr *ibmr ) 
{ 
  struct ib_mr  const  *__mptr ;

  {
#line 311
  __mptr = (struct ib_mr  const  *)ibmr;
#line 311
  return ((struct mthca_mr *)__mptr);
}
}
#line 453 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
void mthca_start_catas_poll(struct mthca_dev *dev ) ;
#line 454
void mthca_stop_catas_poll(struct mthca_dev *dev ) ;
#line 512
int mthca_alloc_srq(struct mthca_dev *dev , struct mthca_pd *pd , struct ib_srq_attr *attr ,
                    struct mthca_srq *srq ) ;
#line 514
void mthca_free_srq(struct mthca_dev *dev , struct mthca_srq *srq ) ;
#line 515
int mthca_modify_srq(struct ib_srq *ibsrq , struct ib_srq_attr *attr , enum ib_srq_attr_mask attr_mask ,
                     struct ib_udata *udata ) ;
#line 517
int mthca_query_srq(struct ib_srq *ibsrq , struct ib_srq_attr *srq_attr ) ;
#line 522
int mthca_tavor_post_srq_recv(struct ib_srq *ibsrq , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) ;
#line 524
int mthca_arbel_post_srq_recv(struct ib_srq *ibsrq , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) ;
#line 165 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
int mthca_map_user_db(struct mthca_dev *dev , struct mthca_uar *uar , struct mthca_user_db_table *db_tab ,
                      int index , u64 uaddr ) ;
#line 167
void mthca_unmap_user_db(struct mthca_dev *dev , struct mthca_uar *uar , struct mthca_user_db_table *db_tab ,
                         int index ) ;
#line 169
struct mthca_user_db_table *mthca_init_user_db_tab(struct mthca_dev *dev ) ;
#line 170
void mthca_cleanup_user_db_tab(struct mthca_dev *dev , struct mthca_uar *uar , struct mthca_user_db_table *db_tab ) ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static void init_query_mad(struct ib_smp *mad ) 
{ 


  {
#line 54
  mad->base_version = 1U;
#line 55
  mad->mgmt_class = 1U;
#line 56
  mad->class_version = 1U;
#line 57
  mad->method = 1U;
#line 58
  return;
}
}
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_query_device(struct ib_device *ibdev , struct ib_device_attr *props ,
                              struct ib_udata *uhw ) 
{ 
  struct ib_smp *in_mad ;
  struct ib_smp *out_mad ;
  int err ;
  struct mthca_dev *mdev ;
  struct mthca_dev *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  __u32 tmp___2 ;
  __u16 tmp___3 ;
  int tmp___4 ;

  {
#line 63
  in_mad = (struct ib_smp *)0;
#line 64
  out_mad = (struct ib_smp *)0;
#line 65
  err = -12;
#line 66
  tmp = to_mdev(ibdev);
#line 66
  mdev = tmp;
#line 68
  if (uhw->inlen != 0UL || uhw->outlen != 0UL) {
#line 69
    return (-22);
  } else {

  }
#line 71
  tmp___0 = kzalloc(256UL, 208U);
#line 71
  in_mad = (struct ib_smp *)tmp___0;
#line 72
  tmp___1 = kmalloc(256UL, 208U);
#line 72
  out_mad = (struct ib_smp *)tmp___1;
#line 73
  if ((unsigned long )in_mad == (unsigned long )((struct ib_smp *)0) || (unsigned long )out_mad == (unsigned long )((struct ib_smp *)0)) {
#line 74
    goto out;
  } else {

  }
#line 76
  memset((void *)props, 0, 224UL);
#line 78
  props->fw_ver = mdev->fw_ver;
#line 80
  init_query_mad(in_mad);
#line 81
  in_mad->attr_id = 4352U;
#line 83
  err = mthca_MAD_IFC(mdev, 1, 1, 1, (struct ib_wc  const  *)0, (struct ib_grh  const  *)0,
                      (void const   *)in_mad, (void *)out_mad);
#line 85
  if (err != 0) {
#line 86
    goto out;
  } else {

  }
#line 88
  props->device_cap_flags = (int )mdev->device_cap_flags;
#line 89
  tmp___2 = __be32_to_cpup((__be32 const   *)(& out_mad->data) + 36U);
#line 89
  props->vendor_id = tmp___2 & 16777215U;
#line 91
  tmp___3 = __be16_to_cpup((__be16 const   *)(& out_mad->data) + 30U);
#line 91
  props->vendor_part_id = (u32 )tmp___3;
#line 92
  props->hw_ver = __be32_to_cpup((__be32 const   *)(& out_mad->data) + 32U);
#line 93
  memcpy((void *)(& props->sys_image_guid), (void const   *)(& out_mad->data) + 4U,
           8UL);
#line 95
  props->max_mr_size = 0xffffffffffffffffULL;
#line 96
  props->page_size_cap = (u64 )mdev->limits.page_size_cap;
#line 97
  props->max_qp = mdev->limits.num_qps - mdev->limits.reserved_qps;
#line 98
  props->max_qp_wr = mdev->limits.max_wqes;
#line 99
  props->max_sge = mdev->limits.max_sg;
#line 100
  props->max_cq = mdev->limits.num_cqs - mdev->limits.reserved_cqs;
#line 101
  props->max_cqe = mdev->limits.max_cqes;
#line 102
  props->max_mr = mdev->limits.num_mpts - mdev->limits.reserved_mrws;
#line 103
  props->max_pd = mdev->limits.num_pds - mdev->limits.reserved_pds;
#line 104
  props->max_qp_rd_atom = 1 << mdev->qp_table.rdb_shift;
#line 105
  props->max_qp_init_rd_atom = mdev->limits.max_qp_init_rdma;
#line 106
  props->max_res_rd_atom = props->max_qp_rd_atom * props->max_qp;
#line 107
  props->max_srq = mdev->limits.num_srqs - mdev->limits.reserved_srqs;
#line 108
  props->max_srq_wr = mdev->limits.max_srq_wqes;
#line 109
  props->max_srq_sge = mdev->limits.max_srq_sge;
#line 110
  props->local_ca_ack_delay = (u8 )mdev->limits.local_ca_ack_delay;
#line 111
  props->atomic_cap = (mdev->limits.flags & 262144U) != 0U;
#line 113
  props->max_pkeys = (u16 )mdev->limits.pkey_table_len;
#line 114
  props->max_mcast_grp = mdev->limits.num_mgms + mdev->limits.num_amgms;
#line 115
  props->max_mcast_qp_attach = 56;
#line 116
  props->max_total_mcast_qp_attach = props->max_mcast_qp_attach * props->max_mcast_grp;
#line 123
  if ((mdev->mthca_flags & 256UL) != 0UL) {
#line 124
    props->max_map_per_fmr = 255;
  } else {
#line 126
    tmp___4 = __ilog2_u32((u32 )mdev->limits.num_mpts);
#line 126
    props->max_map_per_fmr = (1 << (32 - tmp___4)) + -1;
  }
#line 129
  err = 0;
  out: 
#line 131
  kfree((void const   *)in_mad);
#line 132
  kfree((void const   *)out_mad);
#line 133
  return (err);
}
}
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_query_port(struct ib_device *ibdev , u8 port , struct ib_port_attr *props ) 
{ 
  struct ib_smp *in_mad ;
  struct ib_smp *out_mad ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  __u32 tmp___1 ;
  struct mthca_dev *tmp___2 ;
  struct mthca_dev *tmp___3 ;
  struct mthca_dev *tmp___4 ;
  __u16 tmp___5 ;
  __u16 tmp___6 ;

  {
#line 139
  in_mad = (struct ib_smp *)0;
#line 140
  out_mad = (struct ib_smp *)0;
#line 141
  err = -12;
#line 143
  tmp = kzalloc(256UL, 208U);
#line 143
  in_mad = (struct ib_smp *)tmp;
#line 144
  tmp___0 = kmalloc(256UL, 208U);
#line 144
  out_mad = (struct ib_smp *)tmp___0;
#line 145
  if ((unsigned long )in_mad == (unsigned long )((struct ib_smp *)0) || (unsigned long )out_mad == (unsigned long )((struct ib_smp *)0)) {
#line 146
    goto out;
  } else {

  }
#line 148
  memset((void *)props, 0, 48UL);
#line 150
  init_query_mad(in_mad);
#line 151
  in_mad->attr_id = 5376U;
#line 152
  tmp___1 = __fswab32((__u32 )port);
#line 152
  in_mad->attr_mod = tmp___1;
#line 154
  tmp___2 = to_mdev(ibdev);
#line 154
  err = mthca_MAD_IFC(tmp___2, 1, 1, (int )port, (struct ib_wc  const  *)0, (struct ib_grh  const  *)0,
                      (void const   *)in_mad, (void *)out_mad);
#line 156
  if (err != 0) {
#line 157
    goto out;
  } else {

  }
#line 159
  props->lid = __be16_to_cpup((__be16 const   *)(& out_mad->data) + 16U);
#line 160
  props->lmc = (unsigned int )out_mad->data[34] & 7U;
#line 161
  props->sm_lid = __be16_to_cpup((__be16 const   *)(& out_mad->data) + 18U);
#line 162
  props->sm_sl = (unsigned int )out_mad->data[36] & 15U;
#line 163
  props->state = (enum ib_port_state )((int )out_mad->data[32] & 15);
#line 164
  props->phys_state = (u8 )((int )out_mad->data[33] >> 4);
#line 165
  props->port_cap_flags = __be32_to_cpup((__be32 const   *)(& out_mad->data) + 20U);
#line 166
  tmp___3 = to_mdev(ibdev);
#line 166
  props->gid_tbl_len = tmp___3->limits.gid_table_len;
#line 167
  props->max_msg_sz = 2147483648U;
#line 168
  tmp___4 = to_mdev(ibdev);
#line 168
  props->pkey_tbl_len = (u16 )tmp___4->limits.pkey_table_len;
#line 169
  tmp___5 = __be16_to_cpup((__be16 const   *)(& out_mad->data) + 46U);
#line 169
  props->bad_pkey_cntr = (u32 )tmp___5;
#line 170
  tmp___6 = __be16_to_cpup((__be16 const   *)(& out_mad->data) + 48U);
#line 170
  props->qkey_viol_cntr = (u32 )tmp___6;
#line 171
  props->active_width = (unsigned int )out_mad->data[31] & 15U;
#line 172
  props->active_speed = (u8 )((int )out_mad->data[35] >> 4);
#line 173
  props->max_mtu = (enum ib_mtu )((int )out_mad->data[41] & 15);
#line 174
  props->active_mtu = (enum ib_mtu )((int )out_mad->data[36] >> 4);
#line 175
  props->subnet_timeout = (unsigned int )out_mad->data[51] & 31U;
#line 176
  props->max_vl_num = (u8 )((int )out_mad->data[37] >> 4);
#line 177
  props->init_type_reply = (u8 )((int )out_mad->data[41] >> 4);
  out: 
#line 180
  kfree((void const   *)in_mad);
#line 181
  kfree((void const   *)out_mad);
#line 182
  return (err);
}
}
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_modify_device(struct ib_device *ibdev , int mask , struct ib_device_modify *props ) 
{ 
  struct mthca_dev *tmp ;
  int tmp___0 ;
  struct mthca_dev *tmp___1 ;

  {
#line 189
  if ((mask & -3) != 0) {
#line 190
    return (-95);
  } else {

  }
#line 192
  if ((mask & 2) != 0) {
#line 193
    tmp = to_mdev(ibdev);
#line 193
    tmp___0 = mutex_lock_interruptible_nested(& tmp->cap_mask_mutex, 0U);
#line 193
    if (tmp___0 != 0) {
#line 194
      return (-512);
    } else {

    }
#line 195
    memcpy((void *)(& ibdev->node_desc), (void const   *)(& props->node_desc), 64UL);
#line 196
    tmp___1 = to_mdev(ibdev);
#line 196
    mutex_unlock(& tmp___1->cap_mask_mutex);
  } else {

  }
#line 199
  return (0);
}
}
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_modify_port(struct ib_device *ibdev , u8 port , int port_modify_mask ,
                             struct ib_port_modify *props ) 
{ 
  struct mthca_set_ib_param set_ib ;
  struct ib_port_attr attr ;
  int err ;
  struct mthca_dev *tmp ;
  int tmp___0 ;
  struct mthca_dev *tmp___1 ;
  struct mthca_dev *tmp___2 ;

  {
#line 210
  tmp = to_mdev(ibdev);
#line 210
  tmp___0 = mutex_lock_interruptible_nested(& tmp->cap_mask_mutex, 0U);
#line 210
  if (tmp___0 != 0) {
#line 211
    return (-512);
  } else {

  }
#line 213
  err = mthca_query_port(ibdev, (int )port, & attr);
#line 214
  if (err != 0) {
#line 215
    goto out;
  } else {

  }
#line 217
  set_ib.set_si_guid = 0;
#line 218
  set_ib.reset_qkey_viol = (port_modify_mask & 8) != 0;
#line 220
  set_ib.cap_mask = (attr.port_cap_flags | props->set_port_cap_mask) & ~ props->clr_port_cap_mask;
#line 223
  tmp___1 = to_mdev(ibdev);
#line 223
  err = mthca_SET_IB(tmp___1, & set_ib, (int )port);
#line 224
  if (err != 0) {

  } else {

  }
  out: 
#line 227
  tmp___2 = to_mdev(ibdev);
#line 227
  mutex_unlock(& tmp___2->cap_mask_mutex);
#line 228
  return (err);
}
}
#line 231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_query_pkey(struct ib_device *ibdev , u8 port , u16 index , u16 *pkey ) 
{ 
  struct ib_smp *in_mad ;
  struct ib_smp *out_mad ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  __u32 tmp___1 ;
  struct mthca_dev *tmp___2 ;
  __u16 tmp___3 ;

  {
#line 234
  in_mad = (struct ib_smp *)0;
#line 235
  out_mad = (struct ib_smp *)0;
#line 236
  err = -12;
#line 238
  tmp = kzalloc(256UL, 208U);
#line 238
  in_mad = (struct ib_smp *)tmp;
#line 239
  tmp___0 = kmalloc(256UL, 208U);
#line 239
  out_mad = (struct ib_smp *)tmp___0;
#line 240
  if ((unsigned long )in_mad == (unsigned long )((struct ib_smp *)0) || (unsigned long )out_mad == (unsigned long )((struct ib_smp *)0)) {
#line 241
    goto out;
  } else {

  }
#line 243
  init_query_mad(in_mad);
#line 244
  in_mad->attr_id = 5632U;
#line 245
  tmp___1 = __fswab32((unsigned int )index / 32U);
#line 245
  in_mad->attr_mod = tmp___1;
#line 247
  tmp___2 = to_mdev(ibdev);
#line 247
  err = mthca_MAD_IFC(tmp___2, 1, 1, (int )port, (struct ib_wc  const  *)0, (struct ib_grh  const  *)0,
                      (void const   *)in_mad, (void *)out_mad);
#line 249
  if (err != 0) {
#line 250
    goto out;
  } else {

  }
#line 252
  tmp___3 = __fswab16((int )*((__be16 *)(& out_mad->data) + ((unsigned long )index & 31UL)));
#line 252
  *pkey = tmp___3;
  out: 
#line 255
  kfree((void const   *)in_mad);
#line 256
  kfree((void const   *)out_mad);
#line 257
  return (err);
}
}
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_query_gid(struct ib_device *ibdev , u8 port , int index , union ib_gid *gid ) 
{ 
  struct ib_smp *in_mad ;
  struct ib_smp *out_mad ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  __u32 tmp___1 ;
  struct mthca_dev *tmp___2 ;
  __u32 tmp___3 ;
  struct mthca_dev *tmp___4 ;

  {
#line 263
  in_mad = (struct ib_smp *)0;
#line 264
  out_mad = (struct ib_smp *)0;
#line 265
  err = -12;
#line 267
  tmp = kzalloc(256UL, 208U);
#line 267
  in_mad = (struct ib_smp *)tmp;
#line 268
  tmp___0 = kmalloc(256UL, 208U);
#line 268
  out_mad = (struct ib_smp *)tmp___0;
#line 269
  if ((unsigned long )in_mad == (unsigned long )((struct ib_smp *)0) || (unsigned long )out_mad == (unsigned long )((struct ib_smp *)0)) {
#line 270
    goto out;
  } else {

  }
#line 272
  init_query_mad(in_mad);
#line 273
  in_mad->attr_id = 5376U;
#line 274
  tmp___1 = __fswab32((__u32 )port);
#line 274
  in_mad->attr_mod = tmp___1;
#line 276
  tmp___2 = to_mdev(ibdev);
#line 276
  err = mthca_MAD_IFC(tmp___2, 1, 1, (int )port, (struct ib_wc  const  *)0, (struct ib_grh  const  *)0,
                      (void const   *)in_mad, (void *)out_mad);
#line 278
  if (err != 0) {
#line 279
    goto out;
  } else {

  }
#line 281
  memcpy((void *)(& gid->raw), (void const   *)(& out_mad->data) + 8U, 8UL);
#line 283
  init_query_mad(in_mad);
#line 284
  in_mad->attr_id = 5120U;
#line 285
  tmp___3 = __fswab32((__u32 )(index / 8));
#line 285
  in_mad->attr_mod = tmp___3;
#line 287
  tmp___4 = to_mdev(ibdev);
#line 287
  err = mthca_MAD_IFC(tmp___4, 1, 1, (int )port, (struct ib_wc  const  *)0, (struct ib_grh  const  *)0,
                      (void const   *)in_mad, (void *)out_mad);
#line 289
  if (err != 0) {
#line 290
    goto out;
  } else {

  }
#line 292
  memcpy((void *)(& gid->raw) + 8U, (void const   *)(& out_mad->data) + (unsigned long )((index % 8) * 8),
           8UL);
  out: 
#line 295
  kfree((void const   *)in_mad);
#line 296
  kfree((void const   *)out_mad);
#line 297
  return (err);
}
}
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct ib_ucontext *mthca_alloc_ucontext(struct ib_device *ibdev , struct ib_udata *udata ) 
{ 
  struct mthca_alloc_ucontext_resp uresp ;
  struct mthca_ucontext *context ;
  int err ;
  void *tmp ;
  struct mthca_dev *tmp___0 ;
  int tmp___1 ;
  struct mthca_dev *tmp___2 ;
  struct mthca_dev *tmp___3 ;
  struct mthca_dev *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  struct mthca_dev *tmp___8 ;
  void *tmp___9 ;
  struct mthca_dev *tmp___10 ;
  long tmp___11 ;
  struct mthca_dev *tmp___12 ;
  void *tmp___13 ;
  bool tmp___14 ;
  struct mthca_dev *tmp___15 ;
  struct mthca_dev *tmp___16 ;
  void *tmp___17 ;
  int tmp___18 ;

  {
#line 307
  tmp___0 = to_mdev(ibdev);
#line 307
  if (tmp___0->active) {
#line 307
    tmp___1 = 0;
  } else {
#line 307
    tmp___1 = 1;
  }
#line 307
  if (tmp___1) {
#line 308
    tmp = ERR_PTR(-11L);
#line 308
    return ((struct ib_ucontext *)tmp);
  } else {

  }
#line 310
  memset((void *)(& uresp), 0, 8UL);
#line 312
  tmp___2 = to_mdev(ibdev);
#line 312
  uresp.qp_tab_size = (__u32 )tmp___2->limits.num_qps;
#line 313
  tmp___4 = to_mdev(ibdev);
#line 313
  tmp___5 = mthca_is_memfree(tmp___4);
#line 313
  if (tmp___5 != 0) {
#line 314
    tmp___3 = to_mdev(ibdev);
#line 314
    uresp.uarc_size = (__u32 )tmp___3->uar_table.uarc_size;
  } else {
#line 316
    uresp.uarc_size = 0U;
  }
#line 318
  tmp___6 = kmalloc(432UL, 208U);
#line 318
  context = (struct mthca_ucontext *)tmp___6;
#line 319
  if ((unsigned long )context == (unsigned long )((struct mthca_ucontext *)0)) {
#line 320
    tmp___7 = ERR_PTR(-12L);
#line 320
    return ((struct ib_ucontext *)tmp___7);
  } else {

  }
#line 322
  tmp___8 = to_mdev(ibdev);
#line 322
  err = mthca_uar_alloc(tmp___8, & context->uar);
#line 323
  if (err != 0) {
#line 324
    kfree((void const   *)context);
#line 325
    tmp___9 = ERR_PTR((long )err);
#line 325
    return ((struct ib_ucontext *)tmp___9);
  } else {

  }
#line 328
  tmp___10 = to_mdev(ibdev);
#line 328
  context->db_tab = mthca_init_user_db_tab(tmp___10);
#line 329
  tmp___14 = IS_ERR((void const   *)context->db_tab);
#line 329
  if ((int )tmp___14) {
#line 330
    tmp___11 = PTR_ERR((void const   *)context->db_tab);
#line 330
    err = (int )tmp___11;
#line 331
    tmp___12 = to_mdev(ibdev);
#line 331
    mthca_uar_free(tmp___12, & context->uar);
#line 332
    kfree((void const   *)context);
#line 333
    tmp___13 = ERR_PTR((long )err);
#line 333
    return ((struct ib_ucontext *)tmp___13);
  } else {

  }
#line 336
  tmp___18 = ib_copy_to_udata(udata, (void *)(& uresp), 8UL);
#line 336
  if (tmp___18 != 0) {
#line 337
    tmp___15 = to_mdev(ibdev);
#line 337
    mthca_cleanup_user_db_tab(tmp___15, & context->uar, context->db_tab);
#line 338
    tmp___16 = to_mdev(ibdev);
#line 338
    mthca_uar_free(tmp___16, & context->uar);
#line 339
    kfree((void const   *)context);
#line 340
    tmp___17 = ERR_PTR(-14L);
#line 340
    return ((struct ib_ucontext *)tmp___17);
  } else {

  }
#line 343
  context->reg_mr_warned = 0;
#line 345
  return (& context->ibucontext);
}
}
#line 348 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_dealloc_ucontext(struct ib_ucontext *context ) 
{ 
  struct mthca_ucontext *tmp ;
  struct mthca_ucontext *tmp___0 ;
  struct mthca_dev *tmp___1 ;
  struct mthca_ucontext *tmp___2 ;
  struct mthca_dev *tmp___3 ;
  struct mthca_ucontext *tmp___4 ;

  {
#line 350
  tmp = to_mucontext(context);
#line 350
  tmp___0 = to_mucontext(context);
#line 350
  tmp___1 = to_mdev(context->device);
#line 350
  mthca_cleanup_user_db_tab(tmp___1, & tmp___0->uar, tmp->db_tab);
#line 352
  tmp___2 = to_mucontext(context);
#line 352
  tmp___3 = to_mdev(context->device);
#line 352
  mthca_uar_free(tmp___3, & tmp___2->uar);
#line 353
  tmp___4 = to_mucontext(context);
#line 353
  kfree((void const   *)tmp___4);
#line 355
  return (0);
}
}
#line 358 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_mmap_uar(struct ib_ucontext *context , struct vm_area_struct *vma ) 
{ 
  pgprot_t __constr_expr_0 ;
  unsigned long tmp ;
  struct mthca_ucontext *tmp___0 ;
  int tmp___1 ;

  {
#line 361
  if (vma->vm_end - vma->vm_start != 4096UL) {
#line 362
    return (-22);
  } else {

  }
#line 364
  if ((unsigned int )boot_cpu_data.x86 > 3U) {
#line 364
    tmp = cachemode2protval(2);
#line 364
    __constr_expr_0.pgprot = vma->vm_page_prot.pgprot | tmp;
#line 364
    vma->vm_page_prot = __constr_expr_0;
  } else {
#line 364
    vma->vm_page_prot = vma->vm_page_prot;
  }
#line 366
  tmp___0 = to_mucontext(context);
#line 366
  tmp___1 = remap_pfn_range(vma, vma->vm_start, tmp___0->uar.pfn, 4096UL, vma->vm_page_prot);
#line 366
  if (tmp___1 != 0) {
#line 369
    return (-11);
  } else {

  }
#line 371
  return (0);
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct ib_pd *mthca_alloc_pd(struct ib_device *ibdev , struct ib_ucontext *context ,
                                    struct ib_udata *udata ) 
{ 
  struct mthca_pd *pd ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  struct mthca_dev *tmp___1 ;
  void *tmp___2 ;
  struct mthca_dev *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 381
  tmp = kmalloc(96UL, 208U);
#line 381
  pd = (struct mthca_pd *)tmp;
#line 382
  if ((unsigned long )pd == (unsigned long )((struct mthca_pd *)0)) {
#line 383
    tmp___0 = ERR_PTR(-12L);
#line 383
    return ((struct ib_pd *)tmp___0);
  } else {

  }
#line 385
  tmp___1 = to_mdev(ibdev);
#line 385
  err = mthca_pd_alloc(tmp___1, (unsigned long )context == (unsigned long )((struct ib_ucontext *)0),
                       pd);
#line 386
  if (err != 0) {
#line 387
    kfree((void const   *)pd);
#line 388
    tmp___2 = ERR_PTR((long )err);
#line 388
    return ((struct ib_pd *)tmp___2);
  } else {

  }
#line 391
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 392
    tmp___5 = ib_copy_to_udata(udata, (void *)(& pd->pd_num), 4UL);
#line 392
    if (tmp___5 != 0) {
#line 393
      tmp___3 = to_mdev(ibdev);
#line 393
      mthca_pd_free(tmp___3, pd);
#line 394
      kfree((void const   *)pd);
#line 395
      tmp___4 = ERR_PTR(-14L);
#line 395
      return ((struct ib_pd *)tmp___4);
    } else {

    }
  } else {

  }
#line 399
  return (& pd->ibpd);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_dealloc_pd(struct ib_pd *pd ) 
{ 
  struct mthca_pd *tmp ;
  struct mthca_dev *tmp___0 ;

  {
#line 404
  tmp = to_mpd(pd);
#line 404
  tmp___0 = to_mdev(pd->device);
#line 404
  mthca_pd_free(tmp___0, tmp);
#line 405
  kfree((void const   *)pd);
#line 407
  return (0);
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct ib_ah *mthca_ah_create(struct ib_pd *pd , struct ib_ah_attr *ah_attr ) 
{ 
  int err ;
  struct mthca_ah *ah ;
  void *tmp ;
  void *tmp___0 ;
  struct mthca_pd *tmp___1 ;
  struct mthca_dev *tmp___2 ;
  void *tmp___3 ;

  {
#line 416
  tmp = kmalloc(48UL, 32U);
#line 416
  ah = (struct mthca_ah *)tmp;
#line 417
  if ((unsigned long )ah == (unsigned long )((struct mthca_ah *)0)) {
#line 418
    tmp___0 = ERR_PTR(-12L);
#line 418
    return ((struct ib_ah *)tmp___0);
  } else {

  }
#line 420
  tmp___1 = to_mpd(pd);
#line 420
  tmp___2 = to_mdev(pd->device);
#line 420
  err = mthca_create_ah(tmp___2, tmp___1, ah_attr, ah);
#line 421
  if (err != 0) {
#line 422
    kfree((void const   *)ah);
#line 423
    tmp___3 = ERR_PTR((long )err);
#line 423
    return ((struct ib_ah *)tmp___3);
  } else {

  }
#line 426
  return (& ah->ibah);
}
}
#line 429 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_ah_destroy(struct ib_ah *ah ) 
{ 
  struct mthca_ah *tmp ;
  struct mthca_dev *tmp___0 ;

  {
#line 431
  tmp = to_mah(ah);
#line 431
  tmp___0 = to_mdev(ah->device);
#line 431
  mthca_destroy_ah(tmp___0, tmp);
#line 432
  kfree((void const   *)ah);
#line 434
  return (0);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct ib_srq *mthca_create_srq(struct ib_pd *pd , struct ib_srq_init_attr *init_attr ,
                                       struct ib_udata *udata ) 
{ 
  struct mthca_create_srq ucmd ;
  struct mthca_ucontext *context ;
  struct mthca_srq *srq ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  struct mthca_dev *tmp___3 ;
  struct mthca_pd *tmp___4 ;
  struct mthca_dev *tmp___5 ;
  struct mthca_dev *tmp___6 ;
  struct mthca_dev *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;

  {
#line 442
  context = (struct mthca_ucontext *)0;
#line 446
  if ((unsigned int )init_attr->srq_type != 0U) {
#line 447
    tmp = ERR_PTR(-38L);
#line 447
    return ((struct ib_srq *)tmp);
  } else {

  }
#line 449
  tmp___0 = kmalloc(536UL, 208U);
#line 449
  srq = (struct mthca_srq *)tmp___0;
#line 450
  if ((unsigned long )srq == (unsigned long )((struct mthca_srq *)0)) {
#line 451
    tmp___1 = ERR_PTR(-12L);
#line 451
    return ((struct ib_srq *)tmp___1);
  } else {

  }
#line 453
  if ((unsigned long )pd->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 454
    context = to_mucontext((pd->uobject)->context);
#line 456
    tmp___2 = ib_copy_from_udata((void *)(& ucmd), udata, 16UL);
#line 456
    if (tmp___2 != 0) {
#line 457
      err = -14;
#line 458
      goto err_free;
    } else {

    }
#line 461
    tmp___3 = to_mdev(pd->device);
#line 461
    err = mthca_map_user_db(tmp___3, & context->uar, context->db_tab, (int )ucmd.db_index,
                            ucmd.db_page);
#line 465
    if (err != 0) {
#line 466
      goto err_free;
    } else {

    }
#line 468
    srq->mr.ibmr.lkey = ucmd.lkey;
#line 469
    srq->db_index = (int )ucmd.db_index;
  } else {

  }
#line 472
  tmp___4 = to_mpd(pd);
#line 472
  tmp___5 = to_mdev(pd->device);
#line 472
  err = mthca_alloc_srq(tmp___5, tmp___4, & init_attr->attr, srq);
#line 475
  if (err != 0 && (unsigned long )pd->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 476
    tmp___6 = to_mdev(pd->device);
#line 476
    mthca_unmap_user_db(tmp___6, & context->uar, context->db_tab, (int )ucmd.db_index);
  } else {

  }
#line 479
  if (err != 0) {
#line 480
    goto err_free;
  } else {

  }
#line 482
  if ((unsigned long )context != (unsigned long )((struct mthca_ucontext *)0)) {
#line 482
    tmp___8 = ib_copy_to_udata(udata, (void *)(& srq->srqn), 4UL);
#line 482
    if (tmp___8 != 0) {
#line 483
      tmp___7 = to_mdev(pd->device);
#line 483
      mthca_free_srq(tmp___7, srq);
#line 484
      err = -14;
#line 485
      goto err_free;
    } else {

    }
  } else {

  }
#line 488
  return (& srq->ibsrq);
  err_free: 
#line 491
  kfree((void const   *)srq);
#line 493
  tmp___9 = ERR_PTR((long )err);
#line 493
  return ((struct ib_srq *)tmp___9);
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_destroy_srq(struct ib_srq *srq ) 
{ 
  struct mthca_ucontext *context ;
  struct mthca_srq *tmp ;
  struct mthca_dev *tmp___0 ;
  struct mthca_srq *tmp___1 ;
  struct mthca_dev *tmp___2 ;

  {
#line 500
  if ((unsigned long )srq->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 501
    context = to_mucontext((srq->uobject)->context);
#line 503
    tmp = to_msrq(srq);
#line 503
    tmp___0 = to_mdev(srq->device);
#line 503
    mthca_unmap_user_db(tmp___0, & context->uar, context->db_tab, tmp->db_index);
  } else {

  }
#line 507
  tmp___1 = to_msrq(srq);
#line 507
  tmp___2 = to_mdev(srq->device);
#line 507
  mthca_free_srq(tmp___2, tmp___1);
#line 508
  kfree((void const   *)srq);
#line 510
  return (0);
}
}
#line 513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct ib_qp *mthca_create_qp(struct ib_pd *pd , struct ib_qp_init_attr *init_attr ,
                                     struct ib_udata *udata ) 
{ 
  struct mthca_create_qp ucmd ;
  struct mthca_qp *qp ;
  int err ;
  void *tmp ;
  struct mthca_ucontext *context ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  struct mthca_dev *tmp___4 ;
  void *tmp___5 ;
  struct mthca_dev *tmp___6 ;
  struct mthca_dev *tmp___7 ;
  void *tmp___8 ;
  struct mthca_cq *tmp___9 ;
  struct mthca_cq *tmp___10 ;
  struct mthca_pd *tmp___11 ;
  struct mthca_dev *tmp___12 ;
  struct mthca_dev *tmp___13 ;
  struct mthca_dev *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  struct mthca_sqp *tmp___18 ;
  struct mthca_cq *tmp___19 ;
  struct mthca_cq *tmp___20 ;
  struct mthca_pd *tmp___21 ;
  struct mthca_dev *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;

  {
#line 521
  if ((int )init_attr->create_flags != 0) {
#line 522
    tmp = ERR_PTR(-22L);
#line 522
    return ((struct ib_qp *)tmp);
  } else {

  }
#line 524
  switch ((unsigned int )init_attr->qp_type) {
  case 2U: ;
  case 3U: ;
  case 4U: 
#line 531
  tmp___0 = kmalloc(752UL, 208U);
#line 531
  qp = (struct mthca_qp *)tmp___0;
#line 532
  if ((unsigned long )qp == (unsigned long )((struct mthca_qp *)0)) {
#line 533
    tmp___1 = ERR_PTR(-12L);
#line 533
    return ((struct ib_qp *)tmp___1);
  } else {

  }
#line 535
  if ((unsigned long )pd->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 536
    context = to_mucontext((pd->uobject)->context);
#line 538
    tmp___3 = ib_copy_from_udata((void *)(& ucmd), udata, 32UL);
#line 538
    if (tmp___3 != 0) {
#line 539
      kfree((void const   *)qp);
#line 540
      tmp___2 = ERR_PTR(-14L);
#line 540
      return ((struct ib_qp *)tmp___2);
    } else {

    }
#line 543
    tmp___4 = to_mdev(pd->device);
#line 543
    err = mthca_map_user_db(tmp___4, & context->uar, context->db_tab, (int )ucmd.sq_db_index,
                            ucmd.sq_db_page);
#line 546
    if (err != 0) {
#line 547
      kfree((void const   *)qp);
#line 548
      tmp___5 = ERR_PTR((long )err);
#line 548
      return ((struct ib_qp *)tmp___5);
    } else {

    }
#line 551
    tmp___6 = to_mdev(pd->device);
#line 551
    err = mthca_map_user_db(tmp___6, & context->uar, context->db_tab, (int )ucmd.rq_db_index,
                            ucmd.rq_db_page);
#line 554
    if (err != 0) {
#line 555
      tmp___7 = to_mdev(pd->device);
#line 555
      mthca_unmap_user_db(tmp___7, & context->uar, context->db_tab, (int )ucmd.sq_db_index);
#line 559
      kfree((void const   *)qp);
#line 560
      tmp___8 = ERR_PTR((long )err);
#line 560
      return ((struct ib_qp *)tmp___8);
    } else {

    }
#line 563
    qp->mr.ibmr.lkey = ucmd.lkey;
#line 564
    qp->sq.db_index = (int )ucmd.sq_db_index;
#line 565
    qp->rq.db_index = (int )ucmd.rq_db_index;
  } else {

  }
#line 568
  tmp___9 = to_mcq(init_attr->recv_cq);
#line 568
  tmp___10 = to_mcq(init_attr->send_cq);
#line 568
  tmp___11 = to_mpd(pd);
#line 568
  tmp___12 = to_mdev(pd->device);
#line 568
  err = mthca_alloc_qp(tmp___12, tmp___11, tmp___10, tmp___9, init_attr->qp_type,
                       init_attr->sq_sig_type, & init_attr->cap, qp);
#line 574
  if (err != 0 && (unsigned long )pd->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 575
    context = to_mucontext((pd->uobject)->context);
#line 577
    tmp___13 = to_mdev(pd->device);
#line 577
    mthca_unmap_user_db(tmp___13, & context->uar, context->db_tab, (int )ucmd.sq_db_index);
#line 581
    tmp___14 = to_mdev(pd->device);
#line 581
    mthca_unmap_user_db(tmp___14, & context->uar, context->db_tab, (int )ucmd.rq_db_index);
  } else {

  }
#line 587
  qp->ibqp.qp_num = qp->qpn;
#line 588
  goto ldv_31775;
  case 0U: ;
  case 1U: ;
#line 594
  if ((unsigned long )pd->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 595
    tmp___15 = ERR_PTR(-22L);
#line 595
    return ((struct ib_qp *)tmp___15);
  } else {

  }
#line 597
  tmp___16 = kmalloc(928UL, 208U);
#line 597
  qp = (struct mthca_qp *)tmp___16;
#line 598
  if ((unsigned long )qp == (unsigned long )((struct mthca_qp *)0)) {
#line 599
    tmp___17 = ERR_PTR(-12L);
#line 599
    return ((struct ib_qp *)tmp___17);
  } else {

  }
#line 601
  qp->ibqp.qp_num = (unsigned int )init_attr->qp_type != 0U;
#line 603
  tmp___18 = to_msqp(qp);
#line 603
  tmp___19 = to_mcq(init_attr->recv_cq);
#line 603
  tmp___20 = to_mcq(init_attr->send_cq);
#line 603
  tmp___21 = to_mpd(pd);
#line 603
  tmp___22 = to_mdev(pd->device);
#line 603
  err = mthca_alloc_sqp(tmp___22, tmp___21, tmp___20, tmp___19, init_attr->sq_sig_type,
                        & init_attr->cap, (int )qp->ibqp.qp_num, (int )init_attr->port_num,
                        tmp___18);
#line 609
  goto ldv_31775;
  default: 
#line 613
  tmp___23 = ERR_PTR(-38L);
#line 613
  return ((struct ib_qp *)tmp___23);
  }
  ldv_31775: ;
#line 616
  if (err != 0) {
#line 617
    kfree((void const   *)qp);
#line 618
    tmp___24 = ERR_PTR((long )err);
#line 618
    return ((struct ib_qp *)tmp___24);
  } else {

  }
#line 621
  init_attr->cap.max_send_wr = (u32 )qp->sq.max;
#line 622
  init_attr->cap.max_recv_wr = (u32 )qp->rq.max;
#line 623
  init_attr->cap.max_send_sge = (u32 )qp->sq.max_gs;
#line 624
  init_attr->cap.max_recv_sge = (u32 )qp->rq.max_gs;
#line 625
  init_attr->cap.max_inline_data = (u32 )qp->max_inline_data;
#line 627
  return (& qp->ibqp);
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_destroy_qp(struct ib_qp *qp ) 
{ 
  struct mthca_qp *tmp ;
  struct mthca_ucontext *tmp___0 ;
  struct mthca_ucontext *tmp___1 ;
  struct mthca_dev *tmp___2 ;
  struct mthca_qp *tmp___3 ;
  struct mthca_ucontext *tmp___4 ;
  struct mthca_ucontext *tmp___5 ;
  struct mthca_dev *tmp___6 ;
  struct mthca_qp *tmp___7 ;
  struct mthca_dev *tmp___8 ;

  {
#line 632
  if ((unsigned long )qp->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 633
    tmp = to_mqp(qp);
#line 633
    tmp___0 = to_mucontext((qp->uobject)->context);
#line 633
    tmp___1 = to_mucontext((qp->uobject)->context);
#line 633
    tmp___2 = to_mdev(qp->device);
#line 633
    mthca_unmap_user_db(tmp___2, & tmp___1->uar, tmp___0->db_tab, tmp->sq.db_index);
#line 637
    tmp___3 = to_mqp(qp);
#line 637
    tmp___4 = to_mucontext((qp->uobject)->context);
#line 637
    tmp___5 = to_mucontext((qp->uobject)->context);
#line 637
    tmp___6 = to_mdev(qp->device);
#line 637
    mthca_unmap_user_db(tmp___6, & tmp___5->uar, tmp___4->db_tab, tmp___3->rq.db_index);
  } else {

  }
#line 642
  tmp___7 = to_mqp(qp);
#line 642
  tmp___8 = to_mdev(qp->device);
#line 642
  mthca_free_qp(tmp___8, tmp___7);
#line 643
  kfree((void const   *)qp);
#line 644
  return (0);
}
}
#line 647 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct ib_cq *mthca_create_cq(struct ib_device *ibdev , struct ib_cq_init_attr  const  *attr ,
                                     struct ib_ucontext *context , struct ib_udata *udata ) 
{ 
  int entries ;
  struct mthca_create_cq ucmd ;
  struct mthca_cq *cq ;
  int nent ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  struct mthca_dev *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  struct mthca_ucontext *tmp___4 ;
  struct mthca_ucontext *tmp___5 ;
  struct mthca_dev *tmp___6 ;
  void *tmp___7 ;
  struct mthca_ucontext *tmp___8 ;
  struct mthca_ucontext *tmp___9 ;
  struct mthca_dev *tmp___10 ;
  void *tmp___11 ;
  struct mthca_dev *tmp___12 ;
  unsigned int tmp___13 ;
  struct mthca_ucontext *tmp___14 ;
  struct mthca_ucontext *tmp___15 ;
  struct mthca_dev *tmp___16 ;
  struct mthca_dev *tmp___17 ;
  int tmp___18 ;
  struct mthca_ucontext *tmp___19 ;
  struct mthca_ucontext *tmp___20 ;
  struct mthca_dev *tmp___21 ;
  struct mthca_ucontext *tmp___22 ;
  struct mthca_ucontext *tmp___23 ;
  struct mthca_dev *tmp___24 ;
  void *tmp___25 ;

  {
#line 652
  entries = (int )attr->cqe;
#line 658
  if ((unsigned int )attr->flags != 0U) {
#line 659
    tmp = ERR_PTR(-22L);
#line 659
    return ((struct ib_cq *)tmp);
  } else {

  }
#line 661
  if (entries <= 0) {
#line 662
    tmp___0 = ERR_PTR(-22L);
#line 662
    return ((struct ib_cq *)tmp___0);
  } else {
#line 661
    tmp___1 = to_mdev(ibdev);
#line 661
    if (tmp___1->limits.max_cqes < entries) {
#line 662
      tmp___0 = ERR_PTR(-22L);
#line 662
      return ((struct ib_cq *)tmp___0);
    } else {

    }
  }
#line 664
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 665
    tmp___3 = ib_copy_from_udata((void *)(& ucmd), udata, 32UL);
#line 665
    if (tmp___3 != 0) {
#line 666
      tmp___2 = ERR_PTR(-14L);
#line 666
      return ((struct ib_cq *)tmp___2);
    } else {

    }
#line 668
    tmp___4 = to_mucontext(context);
#line 668
    tmp___5 = to_mucontext(context);
#line 668
    tmp___6 = to_mdev(ibdev);
#line 668
    err = mthca_map_user_db(tmp___6, & tmp___5->uar, tmp___4->db_tab, (int )ucmd.set_db_index,
                            ucmd.set_db_page);
#line 671
    if (err != 0) {
#line 672
      tmp___7 = ERR_PTR((long )err);
#line 672
      return ((struct ib_cq *)tmp___7);
    } else {

    }
#line 674
    tmp___8 = to_mucontext(context);
#line 674
    tmp___9 = to_mucontext(context);
#line 674
    tmp___10 = to_mdev(ibdev);
#line 674
    err = mthca_map_user_db(tmp___10, & tmp___9->uar, tmp___8->db_tab, (int )ucmd.arm_db_index,
                            ucmd.arm_db_page);
#line 677
    if (err != 0) {
#line 678
      goto err_unmap_set;
    } else {

    }
  } else {

  }
#line 681
  tmp___11 = kmalloc(512UL, 208U);
#line 681
  cq = (struct mthca_cq *)tmp___11;
#line 682
  if ((unsigned long )cq == (unsigned long )((struct mthca_cq *)0)) {
#line 683
    err = -12;
#line 684
    goto err_unmap_arm;
  } else {

  }
#line 687
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 688
    cq->buf.mr.ibmr.lkey = ucmd.lkey;
#line 689
    cq->set_ci_db_index = (int )ucmd.set_db_index;
#line 690
    cq->arm_db_index = (int )ucmd.arm_db_index;
  } else {

  }
#line 693
  nent = 1;
#line 693
  goto ldv_31796;
  ldv_31795: 
#line 693
  nent = nent << 1;
  ldv_31796: ;
#line 693
  if (nent <= entries) {
#line 695
    goto ldv_31795;
  } else {

  }

#line 696
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 696
    tmp___13 = ucmd.pdn;
  } else {
#line 696
    tmp___12 = to_mdev(ibdev);
#line 696
    tmp___13 = tmp___12->driver_pd.pd_num;
  }
#line 696
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 696
    tmp___14 = to_mucontext(context);
#line 696
    tmp___15 = tmp___14;
  } else {
#line 696
    tmp___15 = (struct mthca_ucontext *)0;
  }
#line 696
  tmp___16 = to_mdev(ibdev);
#line 696
  err = mthca_init_cq(tmp___16, nent, tmp___15, tmp___13, cq);
#line 700
  if (err != 0) {
#line 701
    goto err_free;
  } else {

  }
#line 703
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 703
    tmp___18 = ib_copy_to_udata(udata, (void *)(& cq->cqn), 4UL);
#line 703
    if (tmp___18 != 0) {
#line 704
      tmp___17 = to_mdev(ibdev);
#line 704
      mthca_free_cq(tmp___17, cq);
#line 705
      err = -14;
#line 706
      goto err_free;
    } else {

    }
  } else {

  }
#line 709
  cq->resize_buf = (struct mthca_cq_resize *)0;
#line 711
  return (& cq->ibcq);
  err_free: 
#line 714
  kfree((void const   *)cq);
  err_unmap_arm: ;
#line 717
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 718
    tmp___19 = to_mucontext(context);
#line 718
    tmp___20 = to_mucontext(context);
#line 718
    tmp___21 = to_mdev(ibdev);
#line 718
    mthca_unmap_user_db(tmp___21, & tmp___20->uar, tmp___19->db_tab, (int )ucmd.arm_db_index);
  } else {

  }
  err_unmap_set: ;
#line 722
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 723
    tmp___22 = to_mucontext(context);
#line 723
    tmp___23 = to_mucontext(context);
#line 723
    tmp___24 = to_mdev(ibdev);
#line 723
    mthca_unmap_user_db(tmp___24, & tmp___23->uar, tmp___22->db_tab, (int )ucmd.set_db_index);
  } else {

  }
#line 726
  tmp___25 = ERR_PTR((long )err);
#line 726
  return ((struct ib_cq *)tmp___25);
}
}
#line 729 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_alloc_resize_buf(struct mthca_dev *dev , struct mthca_cq *cq , int entries ) 
{ 
  int ret ;
  void *tmp ;

  {
#line 734
  spin_lock_irq(& cq->lock);
#line 735
  if ((unsigned long )cq->resize_buf != (unsigned long )((struct mthca_cq_resize *)0)) {
#line 736
    ret = -16;
#line 737
    goto unlock;
  } else {

  }
#line 740
  tmp = kmalloc(88UL, 32U);
#line 740
  cq->resize_buf = (struct mthca_cq_resize *)tmp;
#line 741
  if ((unsigned long )cq->resize_buf == (unsigned long )((struct mthca_cq_resize *)0)) {
#line 742
    ret = -12;
#line 743
    goto unlock;
  } else {

  }
#line 746
  (cq->resize_buf)->state = 0;
#line 748
  ret = 0;
  unlock: 
#line 751
  spin_unlock_irq(& cq->lock);
#line 753
  if (ret != 0) {
#line 754
    return (ret);
  } else {

  }
#line 756
  ret = mthca_alloc_cq_buf(dev, & (cq->resize_buf)->buf, entries);
#line 757
  if (ret != 0) {
#line 758
    spin_lock_irq(& cq->lock);
#line 759
    kfree((void const   *)cq->resize_buf);
#line 760
    cq->resize_buf = (struct mthca_cq_resize *)0;
#line 761
    spin_unlock_irq(& cq->lock);
#line 762
    return (ret);
  } else {

  }
#line 765
  (cq->resize_buf)->cqe = entries + -1;
#line 767
  spin_lock_irq(& cq->lock);
#line 768
  (cq->resize_buf)->state = 1;
#line 769
  spin_unlock_irq(& cq->lock);
#line 771
  return (0);
}
}
#line 774 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_resize_cq(struct ib_cq *ibcq , int entries , struct ib_udata *udata ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_cq *cq ;
  struct mthca_cq *tmp___0 ;
  struct mthca_resize_cq ucmd ;
  u32 lkey ;
  int ret ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct mthca_cq_buf tbuf ;
  int tcqe ;

  {
#line 776
  tmp = to_mdev(ibcq->device);
#line 776
  dev = tmp;
#line 777
  tmp___0 = to_mcq(ibcq);
#line 777
  cq = tmp___0;
#line 782
  if (entries <= 0 || dev->limits.max_cqes < entries) {
#line 783
    return (-22);
  } else {

  }
#line 785
  mutex_lock_nested(& cq->mutex, 0U);
#line 787
  tmp___1 = __roundup_pow_of_two((unsigned long )(entries + 1));
#line 787
  entries = (int )tmp___1;
#line 788
  if (ibcq->cqe + 1 == entries) {
#line 789
    ret = 0;
#line 790
    goto out;
  } else {

  }
#line 793
  if (cq->is_kernel != 0) {
#line 794
    ret = mthca_alloc_resize_buf(dev, cq, entries);
#line 795
    if (ret != 0) {
#line 796
      goto out;
    } else {

    }
#line 797
    lkey = (cq->resize_buf)->buf.mr.ibmr.lkey;
  } else {
#line 799
    tmp___2 = ib_copy_from_udata((void *)(& ucmd), udata, 8UL);
#line 799
    if (tmp___2 != 0) {
#line 800
      ret = -14;
#line 801
      goto out;
    } else {

    }
#line 803
    lkey = ucmd.lkey;
  }
#line 806
  tmp___3 = __ilog2_u32((u32 )entries);
#line 806
  ret = mthca_RESIZE_CQ(dev, cq->cqn, lkey, (int )((u8 )tmp___3));
#line 808
  if (ret != 0) {
#line 809
    if ((unsigned long )cq->resize_buf != (unsigned long )((struct mthca_cq_resize *)0)) {
#line 810
      mthca_free_cq_buf(dev, & (cq->resize_buf)->buf, (cq->resize_buf)->cqe);
#line 812
      kfree((void const   *)cq->resize_buf);
#line 813
      spin_lock_irq(& cq->lock);
#line 814
      cq->resize_buf = (struct mthca_cq_resize *)0;
#line 815
      spin_unlock_irq(& cq->lock);
    } else {

    }
#line 817
    goto out;
  } else {

  }
#line 820
  if (cq->is_kernel != 0) {
#line 824
    spin_lock_irq(& cq->lock);
#line 825
    if ((unsigned int )(cq->resize_buf)->state == 1U) {
#line 826
      mthca_cq_resize_copy_cqes(cq);
#line 827
      tbuf = cq->buf;
#line 828
      tcqe = cq->ibcq.cqe;
#line 829
      cq->buf = (cq->resize_buf)->buf;
#line 830
      cq->ibcq.cqe = (cq->resize_buf)->cqe;
    } else {
#line 832
      tbuf = (cq->resize_buf)->buf;
#line 833
      tcqe = (cq->resize_buf)->cqe;
    }
#line 836
    kfree((void const   *)cq->resize_buf);
#line 837
    cq->resize_buf = (struct mthca_cq_resize *)0;
#line 838
    spin_unlock_irq(& cq->lock);
#line 840
    mthca_free_cq_buf(dev, & tbuf, tcqe);
  } else {
#line 842
    ibcq->cqe = entries + -1;
  }
  out: 
#line 845
  mutex_unlock(& cq->mutex);
#line 847
  return (ret);
}
}
#line 850 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_destroy_cq(struct ib_cq *cq ) 
{ 
  struct mthca_cq *tmp ;
  struct mthca_ucontext *tmp___0 ;
  struct mthca_ucontext *tmp___1 ;
  struct mthca_dev *tmp___2 ;
  struct mthca_cq *tmp___3 ;
  struct mthca_ucontext *tmp___4 ;
  struct mthca_ucontext *tmp___5 ;
  struct mthca_dev *tmp___6 ;
  struct mthca_cq *tmp___7 ;
  struct mthca_dev *tmp___8 ;

  {
#line 852
  if ((unsigned long )cq->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 853
    tmp = to_mcq(cq);
#line 853
    tmp___0 = to_mucontext((cq->uobject)->context);
#line 853
    tmp___1 = to_mucontext((cq->uobject)->context);
#line 853
    tmp___2 = to_mdev(cq->device);
#line 853
    mthca_unmap_user_db(tmp___2, & tmp___1->uar, tmp___0->db_tab, tmp->arm_db_index);
#line 857
    tmp___3 = to_mcq(cq);
#line 857
    tmp___4 = to_mucontext((cq->uobject)->context);
#line 857
    tmp___5 = to_mucontext((cq->uobject)->context);
#line 857
    tmp___6 = to_mdev(cq->device);
#line 857
    mthca_unmap_user_db(tmp___6, & tmp___5->uar, tmp___4->db_tab, tmp___3->set_ci_db_index);
  } else {

  }
#line 862
  tmp___7 = to_mcq(cq);
#line 862
  tmp___8 = to_mdev(cq->device);
#line 862
  mthca_free_cq(tmp___8, tmp___7);
#line 863
  kfree((void const   *)cq);
#line 865
  return (0);
}
}
#line 868 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
__inline static u32 convert_access(int acc ) 
{ 


  {
#line 870
  return ((u32 )((((((acc & 8) != 0 ? 16384 : 0) | ((acc & 2) != 0 ? 8192 : 0)) | ((acc & 4) != 0 ? 4096 : 0)) | (acc & 1 ? 2048 : 0)) | 1024));
}
}
#line 877 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct ib_mr *mthca_get_dma_mr(struct ib_pd *pd , int acc ) 
{ 
  struct mthca_mr *mr ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  struct mthca_pd *tmp___2 ;
  struct mthca_dev *tmp___3 ;
  void *tmp___4 ;

  {
#line 882
  tmp = kmalloc(56UL, 208U);
#line 882
  mr = (struct mthca_mr *)tmp;
#line 883
  if ((unsigned long )mr == (unsigned long )((struct mthca_mr *)0)) {
#line 884
    tmp___0 = ERR_PTR(-12L);
#line 884
    return ((struct ib_mr *)tmp___0);
  } else {

  }
#line 886
  tmp___1 = convert_access(acc);
#line 886
  tmp___2 = to_mpd(pd);
#line 886
  tmp___3 = to_mdev(pd->device);
#line 886
  err = mthca_mr_alloc_notrans(tmp___3, tmp___2->pd_num, tmp___1, mr);
#line 890
  if (err != 0) {
#line 891
    kfree((void const   *)mr);
#line 892
    tmp___4 = ERR_PTR((long )err);
#line 892
    return ((struct ib_mr *)tmp___4);
  } else {

  }
#line 895
  mr->umem = (struct ib_umem *)0;
#line 897
  return (& mr->ibmr);
}
}
#line 900 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct ib_mr *mthca_reg_phys_mr(struct ib_pd *pd , struct ib_phys_buf *buffer_list ,
                                       int num_phys_buf , int acc , u64 *iova_start ) 
{ 
  struct mthca_mr *mr ;
  u64 *page_list ;
  u64 total_size ;
  unsigned long mask ;
  int shift ;
  int npages ;
  int err ;
  int i ;
  int j ;
  int n ;
  void *tmp ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  struct mthca_pd *tmp___6 ;
  struct mthca_dev *tmp___7 ;
  u32 tmp___8 ;
  struct mthca_pd *tmp___9 ;
  struct mthca_dev *tmp___10 ;
  void *tmp___11 ;

  {
#line 915
  mask = (unsigned long )(buffer_list->addr ^ *iova_start);
#line 916
  total_size = 0ULL;
#line 917
  i = 0;
#line 917
  goto ldv_31849;
  ldv_31848: ;
#line 918
  if (i != 0) {
#line 919
    mask = (unsigned long )((buffer_list + (unsigned long )i)->addr | (unsigned long long )mask);
  } else {

  }
#line 920
  if (num_phys_buf + -1 != i) {
#line 921
    mask = (unsigned long )(((buffer_list + (unsigned long )i)->addr + (buffer_list + (unsigned long )i)->size) | (unsigned long long )mask);
  } else {

  }
#line 923
  total_size = (buffer_list + (unsigned long )i)->size + total_size;
#line 917
  i = i + 1;
  ldv_31849: ;
#line 917
  if (i < num_phys_buf) {
#line 919
    goto ldv_31848;
  } else {

  }

#line 926
  if ((mask & 4095UL) != 0UL) {
#line 927
    tmp = ERR_PTR(-22L);
#line 927
    return ((struct ib_mr *)tmp);
  } else {

  }
#line 929
  tmp___0 = __ffs(mask | 0xffffffff80000000UL);
#line 929
  shift = (int )tmp___0;
#line 931
  buffer_list->size = buffer_list->size + (buffer_list->addr & ((1ULL << shift) - 1ULL));
#line 932
  buffer_list->addr = buffer_list->addr & (0xffffffffffffffffULL << shift);
#line 934
  tmp___1 = kmalloc(56UL, 208U);
#line 934
  mr = (struct mthca_mr *)tmp___1;
#line 935
  if ((unsigned long )mr == (unsigned long )((struct mthca_mr *)0)) {
#line 936
    tmp___2 = ERR_PTR(-12L);
#line 936
    return ((struct ib_mr *)tmp___2);
  } else {

  }
#line 938
  npages = 0;
#line 939
  i = 0;
#line 939
  goto ldv_31852;
  ldv_31851: 
#line 940
  npages = (int )((unsigned int )((((buffer_list + (unsigned long )i)->size + (1ULL << shift)) - 1ULL) >> shift) + (unsigned int )npages);
#line 939
  i = i + 1;
  ldv_31852: ;
#line 939
  if (i < num_phys_buf) {
#line 941
    goto ldv_31851;
  } else {

  }

#line 942
  if (npages == 0) {
#line 943
    return (& mr->ibmr);
  } else {

  }
#line 945
  tmp___3 = kmalloc((unsigned long )npages * 8UL, 208U);
#line 945
  page_list = (u64 *)tmp___3;
#line 946
  if ((unsigned long )page_list == (unsigned long )((u64 *)0ULL)) {
#line 947
    kfree((void const   *)mr);
#line 948
    tmp___4 = ERR_PTR(-12L);
#line 948
    return ((struct ib_mr *)tmp___4);
  } else {

  }
#line 951
  n = 0;
#line 952
  i = 0;
#line 952
  goto ldv_31858;
  ldv_31857: 
#line 953
  j = 0;
#line 953
  goto ldv_31855;
  ldv_31854: 
#line 956
  tmp___5 = n;
#line 956
  n = n + 1;
#line 956
  *(page_list + (unsigned long )tmp___5) = (buffer_list + (unsigned long )i)->addr + ((unsigned long long )j << shift);
#line 955
  j = j + 1;
  ldv_31855: ;
#line 953
  if ((unsigned long long )j < (((buffer_list + (unsigned long )i)->size + (1ULL << shift)) - 1ULL) >> shift) {
#line 956
    goto ldv_31854;
  } else {

  }
#line 952
  i = i + 1;
  ldv_31858: ;
#line 952
  if (i < num_phys_buf) {
#line 954
    goto ldv_31857;
  } else {

  }

#line 958
  if (mthca_debug_level != 0) {
#line 958
    tmp___6 = to_mpd(pd);
#line 958
    tmp___7 = to_mdev(pd->device);
#line 958
    dev_printk("\017", (struct device  const  *)(& (tmp___7->pdev)->dev), "Registering memory at %llx (iova %llx) in PD %x; shift %d, npages %d.\n",
               buffer_list->addr, *iova_start, tmp___6->pd_num, shift, npages);
  } else {

  }
#line 965
  tmp___8 = convert_access(acc);
#line 965
  tmp___9 = to_mpd(pd);
#line 965
  tmp___10 = to_mdev(pd->device);
#line 965
  err = mthca_mr_alloc_phys(tmp___10, tmp___9->pd_num, page_list, shift, npages, *iova_start,
                            total_size, tmp___8, mr);
#line 971
  if (err != 0) {
#line 972
    kfree((void const   *)page_list);
#line 973
    kfree((void const   *)mr);
#line 974
    tmp___11 = ERR_PTR((long )err);
#line 974
    return ((struct ib_mr *)tmp___11);
  } else {

  }
#line 977
  kfree((void const   *)page_list);
#line 978
  mr->umem = (struct ib_umem *)0;
#line 980
  return (& mr->ibmr);
}
}
#line 983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct ib_mr *mthca_reg_user_mr(struct ib_pd *pd , u64 start , u64 length ,
                                       u64 virt , int acc , struct ib_udata *udata ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct scatterlist *sg ;
  struct mthca_mr *mr ;
  struct mthca_reg_mr ucmd ;
  u64 *pages ;
  int shift ;
  int n ;
  int len ;
  int i ;
  int k ;
  int entry ;
  int err ;
  int write_mtt_size ;
  struct task_struct *tmp___0 ;
  struct mthca_ucontext *tmp___1 ;
  struct mthca_ucontext *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  bool tmp___11 ;
  unsigned long tmp___12 ;
  int _min1 ;
  int tmp___13 ;
  int _min2 ;
  int tmp___14 ;
  u32 tmp___15 ;
  struct mthca_pd *tmp___16 ;
  void *tmp___17 ;

  {
#line 986
  tmp = to_mdev(pd->device);
#line 986
  dev = tmp;
#line 993
  err = 0;
#line 996
  if (udata->inlen - 8UL <= 7UL) {
#line 997
    tmp___1 = to_mucontext((pd->uobject)->context);
#line 997
    if (tmp___1->reg_mr_warned == 0) {
#line 998
      tmp___0 = get_current();
#line 998
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Process \'%s\' did not pass in MR attrs.\n",
               (char *)(& tmp___0->comm));
#line 1000
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "  Update libmthca to fix this.\n");
    } else {

    }
#line 1002
    tmp___2 = to_mucontext((pd->uobject)->context);
#line 1002
    tmp___2->reg_mr_warned = tmp___2->reg_mr_warned + 1;
#line 1003
    ucmd.mr_attrs = 0U;
  } else {
#line 1004
    tmp___4 = ib_copy_from_udata((void *)(& ucmd), udata, 8UL);
#line 1004
    if (tmp___4 != 0) {
#line 1005
      tmp___3 = ERR_PTR(-14L);
#line 1005
      return ((struct ib_mr *)tmp___3);
    } else {

    }
  }
#line 1007
  tmp___5 = kmalloc(56UL, 208U);
#line 1007
  mr = (struct mthca_mr *)tmp___5;
#line 1008
  if ((unsigned long )mr == (unsigned long )((struct mthca_mr *)0)) {
#line 1009
    tmp___6 = ERR_PTR(-12L);
#line 1009
    return ((struct ib_mr *)tmp___6);
  } else {

  }
#line 1011
  mr->umem = ib_umem_get((pd->uobject)->context, (unsigned long )start, (size_t )length,
                         acc, (int )ucmd.mr_attrs & 1);
#line 1014
  tmp___8 = IS_ERR((void const   *)mr->umem);
#line 1014
  if ((int )tmp___8) {
#line 1015
    tmp___7 = PTR_ERR((void const   *)mr->umem);
#line 1015
    err = (int )tmp___7;
#line 1016
    goto err;
  } else {

  }
#line 1019
  tmp___9 = ffs((mr->umem)->page_size);
#line 1019
  shift = tmp___9 + -1;
#line 1020
  n = (mr->umem)->nmap;
#line 1022
  mr->mtt = mthca_alloc_mtt(dev, n);
#line 1023
  tmp___11 = IS_ERR((void const   *)mr->mtt);
#line 1023
  if ((int )tmp___11) {
#line 1024
    tmp___10 = PTR_ERR((void const   *)mr->mtt);
#line 1024
    err = (int )tmp___10;
#line 1025
    goto err_umem;
  } else {

  }
#line 1028
  tmp___12 = __get_free_pages(208U, 0U);
#line 1028
  pages = (u64 *)tmp___12;
#line 1029
  if ((unsigned long )pages == (unsigned long )((u64 *)0ULL)) {
#line 1030
    err = -12;
#line 1031
    goto err_mtt;
  } else {

  }
#line 1034
  n = 0;
#line 1034
  i = n;
#line 1036
  tmp___13 = mthca_write_mtt_size(dev);
#line 1036
  _min1 = tmp___13;
#line 1036
  _min2 = 512;
#line 1036
  write_mtt_size = _min1 < _min2 ? _min1 : _min2;
#line 1038
  entry = 0;
#line 1038
  sg = (mr->umem)->sg_head.sgl;
#line 1038
  goto ldv_31892;
  ldv_31891: 
#line 1039
  len = (int )(sg->dma_length >> shift);
#line 1040
  k = 0;
#line 1040
  goto ldv_31889;
  ldv_31888: 
#line 1041
  tmp___14 = i;
#line 1041
  i = i + 1;
#line 1041
  *(pages + (unsigned long )tmp___14) = sg->dma_address + (dma_addr_t )((mr->umem)->page_size * k);
#line 1047
  if (i == write_mtt_size) {
#line 1048
    err = mthca_write_mtt(dev, mr->mtt, n, pages, i);
#line 1049
    if (err != 0) {
#line 1050
      goto mtt_done;
    } else {

    }
#line 1051
    n = n + i;
#line 1052
    i = 0;
  } else {

  }
#line 1040
  k = k + 1;
  ldv_31889: ;
#line 1040
  if (k < len) {
#line 1042
    goto ldv_31888;
  } else {

  }
#line 1038
  entry = entry + 1;
#line 1038
  sg = sg_next(sg);
  ldv_31892: ;
#line 1038
  if ((mr->umem)->nmap > entry) {
#line 1040
    goto ldv_31891;
  } else {

  }

#line 1057
  if (i != 0) {
#line 1058
    err = mthca_write_mtt(dev, mr->mtt, n, pages, i);
  } else {

  }
  mtt_done: 
#line 1060
  free_pages((unsigned long )pages, 0U);
#line 1061
  if (err != 0) {
#line 1062
    goto err_mtt;
  } else {

  }
#line 1064
  tmp___15 = convert_access(acc);
#line 1064
  tmp___16 = to_mpd(pd);
#line 1064
  err = mthca_mr_alloc(dev, tmp___16->pd_num, shift, virt, length, tmp___15, mr);
#line 1067
  if (err != 0) {
#line 1068
    goto err_mtt;
  } else {

  }
#line 1070
  return (& mr->ibmr);
  err_mtt: 
#line 1073
  mthca_free_mtt(dev, mr->mtt);
  err_umem: 
#line 1076
  ib_umem_release(mr->umem);
  err: 
#line 1079
  kfree((void const   *)mr);
#line 1080
  tmp___17 = ERR_PTR((long )err);
#line 1080
  return ((struct ib_mr *)tmp___17);
}
}
#line 1083 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_dereg_mr(struct ib_mr *mr ) 
{ 
  struct mthca_mr *mmr ;
  struct mthca_mr *tmp ;
  struct mthca_dev *tmp___0 ;

  {
#line 1085
  tmp = to_mmr(mr);
#line 1085
  mmr = tmp;
#line 1087
  tmp___0 = to_mdev(mr->device);
#line 1087
  mthca_free_mr(tmp___0, mmr);
#line 1088
  if ((unsigned long )mmr->umem != (unsigned long )((struct ib_umem *)0)) {
#line 1089
    ib_umem_release(mmr->umem);
  } else {

  }
#line 1090
  kfree((void const   *)mmr);
#line 1092
  return (0);
}
}
#line 1095 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct ib_fmr *mthca_alloc_fmr(struct ib_pd *pd , int mr_access_flags , struct ib_fmr_attr *fmr_attr ) 
{ 
  struct mthca_fmr *fmr ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  struct mthca_pd *tmp___2 ;
  struct mthca_dev *tmp___3 ;
  void *tmp___4 ;

  {
#line 1101
  tmp = kmalloc(96UL, 208U);
#line 1101
  fmr = (struct mthca_fmr *)tmp;
#line 1102
  if ((unsigned long )fmr == (unsigned long )((struct mthca_fmr *)0)) {
#line 1103
    tmp___0 = ERR_PTR(-12L);
#line 1103
    return ((struct ib_fmr *)tmp___0);
  } else {

  }
#line 1105
  memcpy((void *)(& fmr->attr), (void const   *)fmr_attr, 12UL);
#line 1106
  tmp___1 = convert_access(mr_access_flags);
#line 1106
  tmp___2 = to_mpd(pd);
#line 1106
  tmp___3 = to_mdev(pd->device);
#line 1106
  err = mthca_fmr_alloc(tmp___3, tmp___2->pd_num, tmp___1, fmr);
#line 1109
  if (err != 0) {
#line 1110
    kfree((void const   *)fmr);
#line 1111
    tmp___4 = ERR_PTR((long )err);
#line 1111
    return ((struct ib_fmr *)tmp___4);
  } else {

  }
#line 1114
  return (& fmr->ibmr);
}
}
#line 1117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_dealloc_fmr(struct ib_fmr *fmr ) 
{ 
  struct mthca_fmr *mfmr ;
  struct mthca_fmr *tmp ;
  int err ;
  struct mthca_dev *tmp___0 ;

  {
#line 1119
  tmp = to_mfmr(fmr);
#line 1119
  mfmr = tmp;
#line 1122
  tmp___0 = to_mdev(fmr->device);
#line 1122
  err = mthca_free_fmr(tmp___0, mfmr);
#line 1123
  if (err != 0) {
#line 1124
    return (err);
  } else {

  }
#line 1126
  kfree((void const   *)mfmr);
#line 1127
  return (0);
}
}
#line 1130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_unmap_fmr(struct list_head *fmr_list ) 
{ 
  struct ib_fmr *fmr ;
  int err ;
  struct mthca_dev *mdev ;
  struct list_head  const  *__mptr ;
  struct mthca_dev *tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct mthca_fmr *tmp___0 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct mthca_fmr *tmp___1 ;
  struct list_head  const  *__mptr___4 ;
  int tmp___2 ;

  {
#line 1134
  mdev = (struct mthca_dev *)0;
#line 1136
  __mptr = (struct list_head  const  *)fmr_list->next;
#line 1136
  fmr = (struct ib_fmr *)__mptr + 0xfffffffffffffff0UL;
#line 1136
  goto ldv_31921;
  ldv_31920: ;
#line 1137
  if ((unsigned long )mdev != (unsigned long )((struct mthca_dev *)0)) {
#line 1137
    tmp = to_mdev(fmr->device);
#line 1137
    if ((unsigned long )tmp != (unsigned long )mdev) {
#line 1138
      return (-22);
    } else {

    }
  } else {

  }
#line 1139
  mdev = to_mdev(fmr->device);
#line 1136
  __mptr___0 = (struct list_head  const  *)fmr->list.next;
#line 1136
  fmr = (struct ib_fmr *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_31921: ;
#line 1136
  if ((unsigned long )(& fmr->list) != (unsigned long )fmr_list) {
#line 1138
    goto ldv_31920;
  } else {

  }

#line 1142
  if ((unsigned long )mdev == (unsigned long )((struct mthca_dev *)0)) {
#line 1143
    return (0);
  } else {

  }
#line 1145
  tmp___2 = mthca_is_memfree(mdev);
#line 1145
  if (tmp___2 != 0) {
#line 1146
    __mptr___1 = (struct list_head  const  *)fmr_list->next;
#line 1146
    fmr = (struct ib_fmr *)__mptr___1 + 0xfffffffffffffff0UL;
#line 1146
    goto ldv_31928;
    ldv_31927: 
#line 1147
    tmp___0 = to_mfmr(fmr);
#line 1147
    mthca_arbel_fmr_unmap(mdev, tmp___0);
#line 1146
    __mptr___2 = (struct list_head  const  *)fmr->list.next;
#line 1146
    fmr = (struct ib_fmr *)__mptr___2 + 0xfffffffffffffff0UL;
    ldv_31928: ;
#line 1146
    if ((unsigned long )(& fmr->list) != (unsigned long )fmr_list) {
#line 1148
      goto ldv_31927;
    } else {

    }
#line 1149
    __asm__  volatile   ("sfence": : : "memory");
  } else {
#line 1151
    __mptr___3 = (struct list_head  const  *)fmr_list->next;
#line 1151
    fmr = (struct ib_fmr *)__mptr___3 + 0xfffffffffffffff0UL;
#line 1151
    goto ldv_31935;
    ldv_31934: 
#line 1152
    tmp___1 = to_mfmr(fmr);
#line 1152
    mthca_tavor_fmr_unmap(mdev, tmp___1);
#line 1151
    __mptr___4 = (struct list_head  const  *)fmr->list.next;
#line 1151
    fmr = (struct ib_fmr *)__mptr___4 + 0xfffffffffffffff0UL;
    ldv_31935: ;
#line 1151
    if ((unsigned long )(& fmr->list) != (unsigned long )fmr_list) {
#line 1153
      goto ldv_31934;
    } else {

    }

  }
#line 1154
  err = mthca_SYNC_TPT(mdev);
#line 1155
  return (err);
}
}
#line 1158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static ssize_t show_rev(struct device *device , struct device_attribute *attr , char *buf ) 
{ 
  struct mthca_dev *dev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
#line 1162
  __mptr = (struct device  const  *)device;
#line 1162
  dev = (struct mthca_dev *)__mptr + 0xfffffffffffffc58UL;
#line 1163
  tmp = sprintf(buf, "%x\n", dev->rev_id);
#line 1163
  return ((ssize_t )tmp);
}
}
#line 1166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static ssize_t show_fw_ver(struct device *device , struct device_attribute *attr ,
                           char *buf ) 
{ 
  struct mthca_dev *dev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
#line 1170
  __mptr = (struct device  const  *)device;
#line 1170
  dev = (struct mthca_dev *)__mptr + 0xfffffffffffffc58UL;
#line 1171
  tmp = sprintf(buf, "%d.%d.%d\n", (int )(dev->fw_ver >> 32), (int )(dev->fw_ver >> 16) & 65535,
                (int )dev->fw_ver & 65535);
#line 1171
  return ((ssize_t )tmp);
}
}
#line 1176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static ssize_t show_hca(struct device *device , struct device_attribute *attr , char *buf ) 
{ 
  struct mthca_dev *dev ;
  struct device  const  *__mptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1180
  __mptr = (struct device  const  *)device;
#line 1180
  dev = (struct mthca_dev *)__mptr + 0xfffffffffffffc58UL;
#line 1181
  switch ((int )(dev->pdev)->device) {
  case 23108: 
#line 1183
  tmp = sprintf(buf, "MT23108\n");
#line 1183
  return ((ssize_t )tmp);
  case 25208: 
#line 1185
  tmp___0 = sprintf(buf, "MT25208 (MT23108 compat mode)\n");
#line 1185
  return ((ssize_t )tmp___0);
  case 25218: 
#line 1187
  tmp___1 = sprintf(buf, "MT25208\n");
#line 1187
  return ((ssize_t )tmp___1);
  case 25204: ;
  case 24204: 
#line 1190
  tmp___2 = sprintf(buf, "MT25204\n");
#line 1190
  return ((ssize_t )tmp___2);
  default: 
#line 1192
  tmp___3 = sprintf(buf, "unknown\n");
#line 1192
  return ((ssize_t )tmp___3);
  }
}
}
#line 1196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static ssize_t show_board(struct device *device , struct device_attribute *attr ,
                          char *buf ) 
{ 
  struct mthca_dev *dev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
#line 1200
  __mptr = (struct device  const  *)device;
#line 1200
  dev = (struct mthca_dev *)__mptr + 0xfffffffffffffc58UL;
#line 1201
  tmp = sprintf(buf, "%.*s\n", 64, (char *)(& dev->board_id));
#line 1201
  return ((ssize_t )tmp);
}
}
#line 1204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct device_attribute dev_attr_hw_rev  =    {{"hw_rev", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & show_rev,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct device_attribute dev_attr_fw_ver  =    {{"fw_ver", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & show_fw_ver,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct device_attribute dev_attr_hca_type  =    {{"hca_type", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & show_hca, (ssize_t (*)(struct device * , struct device_attribute * , char const   * ,
                             size_t  ))0};
#line 1207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct device_attribute dev_attr_board_id  =    {{"board_id", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & show_board, (ssize_t (*)(struct device * , struct device_attribute * , char const   * ,
                               size_t  ))0};
#line 1209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static struct device_attribute *mthca_dev_attributes[4U]  = {      & dev_attr_hw_rev,      & dev_attr_fw_ver,      & dev_attr_hca_type,      & dev_attr_board_id};
#line 1216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_init_node_data(struct mthca_dev *dev ) 
{ 
  struct ib_smp *in_mad ;
  struct ib_smp *out_mad ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1218
  in_mad = (struct ib_smp *)0;
#line 1219
  out_mad = (struct ib_smp *)0;
#line 1220
  err = -12;
#line 1222
  tmp = kzalloc(256UL, 208U);
#line 1222
  in_mad = (struct ib_smp *)tmp;
#line 1223
  tmp___0 = kmalloc(256UL, 208U);
#line 1223
  out_mad = (struct ib_smp *)tmp___0;
#line 1224
  if ((unsigned long )in_mad == (unsigned long )((struct ib_smp *)0) || (unsigned long )out_mad == (unsigned long )((struct ib_smp *)0)) {
#line 1225
    goto out;
  } else {

  }
#line 1227
  init_query_mad(in_mad);
#line 1228
  in_mad->attr_id = 4096U;
#line 1230
  err = mthca_MAD_IFC(dev, 1, 1, 1, (struct ib_wc  const  *)0, (struct ib_grh  const  *)0,
                      (void const   *)in_mad, (void *)out_mad);
#line 1232
  if (err != 0) {
#line 1233
    goto out;
  } else {

  }
#line 1235
  memcpy((void *)(& dev->ib_dev.node_desc), (void const   *)(& out_mad->data), 64UL);
#line 1237
  in_mad->attr_id = 4352U;
#line 1239
  err = mthca_MAD_IFC(dev, 1, 1, 1, (struct ib_wc  const  *)0, (struct ib_grh  const  *)0,
                      (void const   *)in_mad, (void *)out_mad);
#line 1241
  if (err != 0) {
#line 1242
    goto out;
  } else {

  }
#line 1244
  tmp___1 = mthca_is_memfree(dev);
#line 1244
  if (tmp___1 != 0) {
#line 1245
    dev->rev_id = __be32_to_cpup((__be32 const   *)(& out_mad->data) + 32U);
  } else {

  }
#line 1246
  memcpy((void *)(& dev->ib_dev.node_guid), (void const   *)(& out_mad->data) + 12U,
           8UL);
  out: 
#line 1249
  kfree((void const   *)in_mad);
#line 1250
  kfree((void const   *)out_mad);
#line 1251
  return (err);
}
}
#line 1254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
static int mthca_port_immutable(struct ib_device *ibdev , u8 port_num , struct ib_port_immutable *immutable ) 
{ 
  struct ib_port_attr attr ;
  int err ;

  {
#line 1260
  err = mthca_query_port(ibdev, (int )port_num, & attr);
#line 1261
  if (err != 0) {
#line 1262
    return (err);
  } else {

  }
#line 1264
  immutable->pkey_tbl_len = (int )attr.pkey_tbl_len;
#line 1265
  immutable->gid_tbl_len = attr.gid_tbl_len;
#line 1266
  immutable->core_cap_flags = 1052695U;
#line 1267
  immutable->max_mad_size = 256U;
#line 1269
  return (0);
}
}
#line 1272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
int mthca_register_device(struct mthca_dev *dev ) 
{ 
  int ret ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct lock_class_key __key ;

  {
#line 1277
  ret = mthca_init_node_data(dev);
#line 1278
  if (ret != 0) {
#line 1279
    return (ret);
  } else {

  }
#line 1281
  strlcpy((char *)(& dev->ib_dev.name), "mthca%d", 64UL);
#line 1282
  dev->ib_dev.owner = & __this_module;
#line 1284
  dev->ib_dev.uverbs_abi_ver = 1;
#line 1285
  dev->ib_dev.uverbs_cmd_mask = 3474858527ULL;
#line 1303
  dev->ib_dev.node_type = 1U;
#line 1304
  dev->ib_dev.phys_port_cnt = (u8 )dev->limits.num_ports;
#line 1305
  dev->ib_dev.num_comp_vectors = 1;
#line 1306
  dev->ib_dev.dma_device = & (dev->pdev)->dev;
#line 1307
  dev->ib_dev.query_device = & mthca_query_device;
#line 1308
  dev->ib_dev.query_port = & mthca_query_port;
#line 1309
  dev->ib_dev.modify_device = & mthca_modify_device;
#line 1310
  dev->ib_dev.modify_port = & mthca_modify_port;
#line 1311
  dev->ib_dev.query_pkey = & mthca_query_pkey;
#line 1312
  dev->ib_dev.query_gid = & mthca_query_gid;
#line 1313
  dev->ib_dev.alloc_ucontext = & mthca_alloc_ucontext;
#line 1314
  dev->ib_dev.dealloc_ucontext = & mthca_dealloc_ucontext;
#line 1315
  dev->ib_dev.mmap = & mthca_mmap_uar;
#line 1316
  dev->ib_dev.alloc_pd = & mthca_alloc_pd;
#line 1317
  dev->ib_dev.dealloc_pd = & mthca_dealloc_pd;
#line 1318
  dev->ib_dev.create_ah = & mthca_ah_create;
#line 1319
  dev->ib_dev.query_ah = & mthca_ah_query;
#line 1320
  dev->ib_dev.destroy_ah = & mthca_ah_destroy;
#line 1322
  if ((dev->mthca_flags & 4UL) != 0UL) {
#line 1323
    dev->ib_dev.create_srq = & mthca_create_srq;
#line 1324
    dev->ib_dev.modify_srq = & mthca_modify_srq;
#line 1325
    dev->ib_dev.query_srq = & mthca_query_srq;
#line 1326
    dev->ib_dev.destroy_srq = & mthca_destroy_srq;
#line 1327
    dev->ib_dev.uverbs_cmd_mask = dev->ib_dev.uverbs_cmd_mask | 64424509440ULL;
#line 1333
    tmp = mthca_is_memfree(dev);
#line 1333
    if (tmp != 0) {
#line 1334
      dev->ib_dev.post_srq_recv = & mthca_arbel_post_srq_recv;
    } else {
#line 1336
      dev->ib_dev.post_srq_recv = & mthca_tavor_post_srq_recv;
    }
  } else {

  }
#line 1339
  dev->ib_dev.create_qp = & mthca_create_qp;
#line 1340
  dev->ib_dev.modify_qp = & mthca_modify_qp;
#line 1341
  dev->ib_dev.query_qp = & mthca_query_qp;
#line 1342
  dev->ib_dev.destroy_qp = & mthca_destroy_qp;
#line 1343
  dev->ib_dev.create_cq = & mthca_create_cq;
#line 1344
  dev->ib_dev.resize_cq = & mthca_resize_cq;
#line 1345
  dev->ib_dev.destroy_cq = & mthca_destroy_cq;
#line 1346
  dev->ib_dev.poll_cq = & mthca_poll_cq;
#line 1347
  dev->ib_dev.get_dma_mr = & mthca_get_dma_mr;
#line 1348
  dev->ib_dev.reg_phys_mr = & mthca_reg_phys_mr;
#line 1349
  dev->ib_dev.reg_user_mr = & mthca_reg_user_mr;
#line 1350
  dev->ib_dev.dereg_mr = & mthca_dereg_mr;
#line 1351
  dev->ib_dev.get_port_immutable = & mthca_port_immutable;
#line 1353
  if ((dev->mthca_flags & 32UL) != 0UL) {
#line 1354
    dev->ib_dev.alloc_fmr = & mthca_alloc_fmr;
#line 1355
    dev->ib_dev.unmap_fmr = & mthca_unmap_fmr;
#line 1356
    dev->ib_dev.dealloc_fmr = & mthca_dealloc_fmr;
#line 1357
    tmp___0 = mthca_is_memfree(dev);
#line 1357
    if (tmp___0 != 0) {
#line 1358
      dev->ib_dev.map_phys_fmr = & mthca_arbel_map_phys_fmr;
    } else {
#line 1360
      dev->ib_dev.map_phys_fmr = & mthca_tavor_map_phys_fmr;
    }
  } else {

  }
#line 1363
  dev->ib_dev.attach_mcast = & mthca_multicast_attach;
#line 1364
  dev->ib_dev.detach_mcast = & mthca_multicast_detach;
#line 1365
  dev->ib_dev.process_mad = & mthca_process_mad;
#line 1367
  tmp___1 = mthca_is_memfree(dev);
#line 1367
  if (tmp___1 != 0) {
#line 1368
    dev->ib_dev.req_notify_cq = & mthca_arbel_arm_cq;
#line 1369
    dev->ib_dev.post_send = & mthca_arbel_post_send;
#line 1370
    dev->ib_dev.post_recv = & mthca_arbel_post_receive;
  } else {
#line 1372
    dev->ib_dev.req_notify_cq = & mthca_tavor_arm_cq;
#line 1373
    dev->ib_dev.post_send = & mthca_tavor_post_send;
#line 1374
    dev->ib_dev.post_recv = & mthca_tavor_post_receive;
  }
#line 1377
  __mutex_init(& dev->cap_mask_mutex, "&dev->cap_mask_mutex", & __key);
#line 1379
  ret = ib_register_device(& dev->ib_dev, (int (*)(struct ib_device * , u8  , struct kobject * ))0);
#line 1380
  if (ret != 0) {
#line 1381
    return (ret);
  } else {

  }
#line 1383
  i = 0;
#line 1383
  goto ldv_32051;
  ldv_32050: 
#line 1384
  ret = device_create_file(& dev->ib_dev.dev, (struct device_attribute  const  *)mthca_dev_attributes[i]);
#line 1386
  if (ret != 0) {
#line 1387
    ib_unregister_device(& dev->ib_dev);
#line 1388
    return (ret);
  } else {

  }
#line 1383
  i = i + 1;
  ldv_32051: ;
#line 1383
  if ((unsigned int )i <= 3U) {
#line 1385
    goto ldv_32050;
  } else {

  }
#line 1392
  mthca_start_catas_poll(dev);
#line 1394
  return (0);
}
}
#line 1397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.c"
void mthca_unregister_device(struct mthca_dev *dev ) 
{ 


  {
#line 1399
  mthca_stop_catas_poll(dev);
#line 1400
  ib_unregister_device(& dev->ib_dev);
#line 1401
  return;
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.o.c.prepared"
void ldv_main_exported_6(void) 
{ 
  struct device_attribute *ldvarg2 ;
  void *tmp ;
  struct device *ldvarg0 ;
  void *tmp___0 ;
  char *ldvarg1 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 57
  tmp = ldv_init_zalloc(48UL);
#line 57
  ldvarg2 = (struct device_attribute *)tmp;
#line 58
  tmp___0 = ldv_init_zalloc(1416UL);
#line 58
  ldvarg0 = (struct device *)tmp___0;
#line 59
  tmp___1 = ldv_init_zalloc(1UL);
#line 59
  ldvarg1 = (char *)tmp___1;
#line 61
  tmp___2 = __VERIFIER_nondet_int();
#line 61
  switch (tmp___2) {
  case 0: ;
#line 64
  if (ldv_state_variable_6 == 1) {
#line 66
    show_rev(ldvarg0, ldvarg2, ldvarg1);
#line 68
    ldv_state_variable_6 = 1;
  } else {

  }
#line 71
  goto ldv_32063;
  default: 
#line 72
  ldv_stop();
  }
  ldv_32063: ;
#line 76
  return;
}
}
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.o.c.prepared"
void ldv_main_exported_4(void) 
{ 
  struct device_attribute *ldvarg9 ;
  void *tmp ;
  struct device *ldvarg7 ;
  void *tmp___0 ;
  char *ldvarg8 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 79
  tmp = ldv_init_zalloc(48UL);
#line 79
  ldvarg9 = (struct device_attribute *)tmp;
#line 80
  tmp___0 = ldv_init_zalloc(1416UL);
#line 80
  ldvarg7 = (struct device *)tmp___0;
#line 81
  tmp___1 = ldv_init_zalloc(1UL);
#line 81
  ldvarg8 = (char *)tmp___1;
#line 83
  tmp___2 = __VERIFIER_nondet_int();
#line 83
  switch (tmp___2) {
  case 0: ;
#line 86
  if (ldv_state_variable_4 == 1) {
#line 88
    show_hca(ldvarg7, ldvarg9, ldvarg8);
#line 90
    ldv_state_variable_4 = 1;
  } else {

  }
#line 93
  goto ldv_32072;
  default: 
#line 94
  ldv_stop();
  }
  ldv_32072: ;
#line 98
  return;
}
}
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.o.c.prepared"
void ldv_main_exported_3(void) 
{ 
  struct device_attribute *ldvarg5 ;
  void *tmp ;
  struct device *ldvarg3 ;
  void *tmp___0 ;
  char *ldvarg4 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 101
  tmp = ldv_init_zalloc(48UL);
#line 101
  ldvarg5 = (struct device_attribute *)tmp;
#line 102
  tmp___0 = ldv_init_zalloc(1416UL);
#line 102
  ldvarg3 = (struct device *)tmp___0;
#line 103
  tmp___1 = ldv_init_zalloc(1UL);
#line 103
  ldvarg4 = (char *)tmp___1;
#line 105
  tmp___2 = __VERIFIER_nondet_int();
#line 105
  switch (tmp___2) {
  case 0: ;
#line 108
  if (ldv_state_variable_3 == 1) {
#line 110
    show_board(ldvarg3, ldvarg5, ldvarg4);
#line 112
    ldv_state_variable_3 = 1;
  } else {

  }
#line 115
  goto ldv_32081;
  default: 
#line 116
  ldv_stop();
  }
  ldv_32081: ;
#line 120
  return;
}
}
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.o.c.prepared"
void ldv_main_exported_5(void) 
{ 
  struct device_attribute *ldvarg12 ;
  void *tmp ;
  struct device *ldvarg10 ;
  void *tmp___0 ;
  char *ldvarg11 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 123
  tmp = ldv_init_zalloc(48UL);
#line 123
  ldvarg12 = (struct device_attribute *)tmp;
#line 124
  tmp___0 = ldv_init_zalloc(1416UL);
#line 124
  ldvarg10 = (struct device *)tmp___0;
#line 125
  tmp___1 = ldv_init_zalloc(1UL);
#line 125
  ldvarg11 = (char *)tmp___1;
#line 127
  tmp___2 = __VERIFIER_nondet_int();
#line 127
  switch (tmp___2) {
  case 0: ;
#line 130
  if (ldv_state_variable_5 == 1) {
#line 132
    show_fw_ver(ldvarg10, ldvarg12, ldvarg11);
#line 134
    ldv_state_variable_5 = 1;
  } else {

  }
#line 137
  goto ldv_32090;
  default: 
#line 138
  ldv_stop();
  }
  ldv_32090: ;
#line 142
  return;
}
}
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.o.c.prepared"
bool ldv_queue_work_on_191(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 171
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 171
  ldv_func_res = tmp;
#line 173
  activate_work_1(ldv_func_arg3, 2);
#line 175
  return (ldv_func_res);
}
}
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.o.c.prepared"
bool ldv_queue_delayed_work_on_192(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 182
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 182
  ldv_func_res = tmp;
#line 184
  activate_work_1(& ldv_func_arg3->work, 2);
#line 186
  return (ldv_func_res);
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.o.c.prepared"
bool ldv_queue_work_on_193(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 193
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 193
  ldv_func_res = tmp;
#line 195
  activate_work_1(ldv_func_arg3, 2);
#line 197
  return (ldv_func_res);
}
}
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.o.c.prepared"
void ldv_flush_workqueue_194(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 203
  flush_workqueue(ldv_func_arg1);
#line 205
  call_and_disable_all_1(2);
#line 206
  return;
}
}
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_provider.o.c.prepared"
bool ldv_queue_delayed_work_on_195(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 212
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 212
  ldv_func_res = tmp;
#line 214
  activate_work_1(& ldv_func_arg3->work, 2);
#line 216
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 48 "include/linux/list.h"
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 75 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 77
  __list_add(new, head->prev, head);
#line 78
  return;
}
}
#line 23 "./arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 65 "./arch/x86/include/asm/page.h"
extern bool __virt_addr_valid(unsigned long  ) ;
#line 282 "include/linux/bitmap.h"
__inline static int bitmap_empty(unsigned long const   *src , unsigned int nbits ) 
{ 
  unsigned long tmp ;

  {
#line 287
  tmp = find_first_bit(src, (unsigned long )nbits);
#line 287
  return (tmp == (unsigned long )nbits);
}
}
#line 290 "include/linux/bitmap.h"
__inline static int bitmap_full(unsigned long const   *src , unsigned int nbits ) 
{ 
  unsigned long tmp ;

  {
#line 295
  tmp = find_first_zero_bit(src, (unsigned long )nbits);
#line 295
  return (tmp == (unsigned long )nbits);
}
}
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_205(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_207(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_206(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_209(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_208(struct workqueue_struct *ldv_func_arg1 ) ;
#line 569 "include/linux/mm.h"
extern void put_page(struct page * ) ;
#line 1184
extern long get_user_pages(struct task_struct * , struct mm_struct * , unsigned long  ,
                           unsigned long  , int  , int  , struct page ** , struct vm_area_struct ** ) ;
#line 82 "include/linux/scatterlist.h"
__inline static void sg_assign_page(struct scatterlist *sg , struct page *page ) 
{ 
  unsigned long page_link ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 84
  page_link = sg->page_link & 3UL;
#line 90
  tmp = ldv__builtin_expect(((unsigned long )page & 3UL) != 0UL, 0L);
#line 90
  if (tmp != 0L) {
#line 90
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (90), "i" (12UL));
    ldv_22927: ;
#line 90
    goto ldv_22927;
  } else {

  }
#line 92
  tmp___0 = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 92
  if (tmp___0 != 0L) {
#line 92
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (92), "i" (12UL));
    ldv_22928: ;
#line 92
    goto ldv_22928;
  } else {

  }
#line 93
  tmp___1 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 93
  if (tmp___1 != 0L) {
#line 93
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (93), "i" (12UL));
    ldv_22929: ;
#line 93
    goto ldv_22929;
  } else {

  }
#line 95
  sg->page_link = page_link | (unsigned long )page;
#line 96
  return;
}
}
#line 112 "include/linux/scatterlist.h"
__inline static void sg_set_page(struct scatterlist *sg , struct page *page , unsigned int len ,
                                 unsigned int offset ) 
{ 


  {
#line 115
  sg_assign_page(sg, page);
#line 116
  sg->offset = offset;
#line 117
  sg->length = len;
#line 118
  return;
}
}
#line 120 "include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 123
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 123
  if (tmp != 0L) {
#line 123
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (123), "i" (12UL));
    ldv_22939: ;
#line 123
    goto ldv_22939;
  } else {

  }
#line 124
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 124
  if (tmp___0 != 0L) {
#line 124
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (124), "i" (12UL));
    ldv_22940: ;
#line 124
    goto ldv_22940;
  } else {

  }
#line 126
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 136 "include/linux/scatterlist.h"
__inline static void sg_set_buf(struct scatterlist *sg , void const   *buf , unsigned int buflen ) 
{ 
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 140
  tmp = __virt_addr_valid((unsigned long )buf);
#line 140
  if (tmp) {
#line 140
    tmp___0 = 0;
  } else {
#line 140
    tmp___0 = 1;
  }
#line 140
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 140
  if (tmp___1 != 0L) {
#line 140
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (140), "i" (12UL));
    ldv_22946: ;
#line 140
    goto ldv_22946;
  } else {

  }
#line 142
  tmp___2 = __phys_addr((unsigned long )buf);
#line 142
  sg_set_page(sg, (struct page *)-24189255811072L + (tmp___2 >> 12), buflen, (unsigned int )((long )buf) & 4095U);
#line 143
  return;
}
}
#line 243 "include/linux/scatterlist.h"
__inline static void *sg_virt(struct scatterlist *sg ) 
{ 
  struct page *tmp ;
  void *tmp___0 ;

  {
#line 245
  tmp = sg_page(sg);
#line 245
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
#line 245
  return (tmp___0 + (unsigned long )sg->offset);
}
}
#line 252
extern void sg_init_table(struct scatterlist * , unsigned int  ) ;
#line 173 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
int mthca_init_db_tab(struct mthca_dev *dev ) ;
#line 174
void mthca_cleanup_db_tab(struct mthca_dev *dev ) ;
#line 47 "include/linux/dma-debug.h"
extern void debug_dma_map_sg(struct device * , struct scatterlist * , int  , int  ,
                             int  ) ;
#line 50
extern void debug_dma_unmap_sg(struct device * , struct scatterlist * , int  , int  ) ;
#line 46 "include/asm-generic/dma-mapping-common.h"
__inline static int dma_map_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                     int nents , enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int i ;
  int ents ;
  struct scatterlist *s ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 50
  tmp = get_dma_ops(dev);
#line 50
  ops = tmp;
#line 54
  i = 0;
#line 54
  s = sg;
#line 54
  goto ldv_26461;
  ldv_26460: 
#line 55
  tmp___0 = sg_virt(s);
#line 55
  kmemcheck_mark_initialized(tmp___0, s->length);
#line 54
  i = i + 1;
#line 54
  s = sg_next(s);
  ldv_26461: ;
#line 54
  if (i < nents) {
#line 56
    goto ldv_26460;
  } else {

  }
#line 56
  tmp___1 = valid_dma_direction((int )dir);
#line 56
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 56
  if (tmp___2 != 0L) {
#line 56
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (56), "i" (12UL));
    ldv_26463: ;
#line 56
    goto ldv_26463;
  } else {

  }
#line 57
  ents = (*(ops->map_sg))(dev, sg, nents, dir, attrs);
#line 58
  tmp___3 = ldv__builtin_expect(ents < 0, 0L);
#line 58
  if (tmp___3 != 0L) {
#line 58
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (58), "i" (12UL));
    ldv_26464: ;
#line 58
    goto ldv_26464;
  } else {

  }
#line 59
  debug_dma_map_sg(dev, sg, nents, ents, (int )dir);
#line 61
  return (ents);
}
}
#line 64 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                        int nents , enum dma_data_direction dir ,
                                        struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 68
  tmp = get_dma_ops(dev);
#line 68
  ops = tmp;
#line 70
  tmp___0 = valid_dma_direction((int )dir);
#line 70
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 70
  if (tmp___1 != 0L) {
#line 70
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (70), "i" (12UL));
    ldv_26473: ;
#line 70
    goto ldv_26473;
  } else {

  }
#line 71
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
#line 72
  if ((unsigned long )ops->unmap_sg != (unsigned long )((void (*)(struct device * ,
                                                                  struct scatterlist * ,
                                                                  int  , enum dma_data_direction  ,
                                                                  struct dma_attrs * ))0)) {
#line 73
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
  } else {

  }
#line 74
  return;
}
}
#line 65 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_map_sg(struct pci_dev *hwdev , struct scatterlist *sg , int nents ,
                               int direction ) 
{ 
  int tmp ;

  {
#line 68
  tmp = dma_map_sg_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                         sg, nents, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 68
  return (tmp);
}
}
#line 72 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_sg(struct pci_dev *hwdev , struct scatterlist *sg ,
                                  int nents , int direction ) 
{ 


  {
#line 75
  dma_unmap_sg_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                     sg, nents, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 76
  return;
}
}
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
static void mthca_free_icm_pages(struct mthca_dev *dev , struct mthca_icm_chunk *chunk ) 
{ 
  int i ;
  int tmp ;
  struct page *tmp___0 ;

  {
#line 68
  if (chunk->nsg > 0) {
#line 69
    pci_unmap_sg(dev->pdev, (struct scatterlist *)(& chunk->mem), chunk->npages, 0);
  } else {

  }
#line 72
  i = 0;
#line 72
  goto ldv_30608;
  ldv_30607: 
#line 73
  tmp = __get_order((unsigned long )chunk->mem[i].length);
#line 73
  tmp___0 = sg_page((struct scatterlist *)(& chunk->mem) + (unsigned long )i);
#line 73
  __free_pages(tmp___0, (unsigned int )tmp);
#line 72
  i = i + 1;
  ldv_30608: ;
#line 72
  if (chunk->npages > i) {
#line 74
    goto ldv_30607;
  } else {

  }

#line 79
  return;
}
}
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
static void mthca_free_icm_coherent(struct mthca_dev *dev , struct mthca_icm_chunk *chunk ) 
{ 
  int i ;
  struct page *tmp ;
  void *tmp___0 ;

  {
#line 81
  i = 0;
#line 81
  goto ldv_30616;
  ldv_30615: 
#line 82
  tmp = sg_page((struct scatterlist *)(& chunk->mem) + (unsigned long )i);
#line 82
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
#line 82
  dma_free_attrs(& (dev->pdev)->dev, (size_t )chunk->mem[i].length, tmp___0, ((struct scatterlist *)(& chunk->mem) + (unsigned long )i)->dma_address,
                 (struct dma_attrs *)0);
#line 81
  i = i + 1;
  ldv_30616: ;
#line 81
  if (chunk->npages > i) {
#line 83
    goto ldv_30615;
  } else {

  }

#line 88
  return;
}
}
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
void mthca_free_icm(struct mthca_dev *dev , struct mthca_icm *icm , int coherent ) 
{ 
  struct mthca_icm_chunk *chunk ;
  struct mthca_icm_chunk *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 92
  if ((unsigned long )icm == (unsigned long )((struct mthca_icm *)0)) {
#line 93
    return;
  } else {

  }
#line 95
  __mptr = (struct list_head  const  *)icm->chunk_list.next;
#line 95
  chunk = (struct mthca_icm_chunk *)__mptr;
#line 95
  __mptr___0 = (struct list_head  const  *)chunk->list.next;
#line 95
  tmp = (struct mthca_icm_chunk *)__mptr___0;
#line 95
  goto ldv_30632;
  ldv_30631: ;
#line 96
  if (coherent != 0) {
#line 97
    mthca_free_icm_coherent(dev, chunk);
  } else {
#line 99
    mthca_free_icm_pages(dev, chunk);
  }
#line 101
  kfree((void const   *)chunk);
#line 95
  chunk = tmp;
#line 95
  __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 95
  tmp = (struct mthca_icm_chunk *)__mptr___1;
  ldv_30632: ;
#line 95
  if ((unsigned long )chunk != (unsigned long )icm) {
#line 97
    goto ldv_30631;
  } else {

  }
#line 104
  kfree((void const   *)icm);
#line 105
  return;
}
}
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
static int mthca_alloc_icm_pages(struct scatterlist *mem , int order , gfp_t gfp_mask ) 
{ 
  struct page *page ;

  {
#line 115
  page = alloc_pages(gfp_mask | 32768U, (unsigned int )order);
#line 116
  if ((unsigned long )page == (unsigned long )((struct page *)0)) {
#line 117
    return (-12);
  } else {

  }
#line 119
  sg_set_page(mem, page, (unsigned int )(4096UL << order), 0U);
#line 120
  return (0);
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
static int mthca_alloc_icm_coherent(struct device *dev , struct scatterlist *mem ,
                                    int order , gfp_t gfp_mask ) 
{ 
  void *buf ;
  void *tmp ;
  long tmp___0 ;

  {
#line 126
  tmp = dma_alloc_attrs(dev, 4096UL << order, & mem->dma_address, gfp_mask, (struct dma_attrs *)0);
#line 126
  buf = tmp;
#line 128
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 129
    return (-12);
  } else {

  }
#line 131
  sg_set_buf(mem, (void const   *)buf, (unsigned int )(4096UL << order));
#line 132
  tmp___0 = ldv__builtin_expect(mem->offset != 0U, 0L);
#line 132
  if (tmp___0 != 0L) {
#line 132
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"),
                         "i" (132), "i" (12UL));
    ldv_30647: ;
#line 132
    goto ldv_30647;
  } else {

  }
#line 133
  mem->dma_length = (unsigned int )(4096UL << order);
#line 134
  return (0);
}
}
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
struct mthca_icm *mthca_alloc_icm(struct mthca_dev *dev , int npages , gfp_t gfp_mask ,
                                  int coherent ) 
{ 
  struct mthca_icm *icm ;
  struct mthca_icm_chunk *chunk ;
  int cur_order ;
  int ret ;
  long tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 141
  chunk = (struct mthca_icm_chunk *)0;
#line 146
  tmp = ldv__builtin_expect((long )(coherent != 0 && (gfp_mask & 2U) != 0U), 0L);
#line 146
  if (tmp != 0L) {
#line 146
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"),
                         "i" (146), "i" (12UL));
    ldv_30658: ;
#line 146
    goto ldv_30658;
  } else {

  }
#line 148
  tmp___0 = kmalloc(24UL, gfp_mask & 4294966781U);
#line 148
  icm = (struct mthca_icm *)tmp___0;
#line 149
  if ((unsigned long )icm == (unsigned long )((struct mthca_icm *)0)) {
#line 150
    return (icm);
  } else {

  }
#line 152
  icm->refcount = 0;
#line 153
  INIT_LIST_HEAD(& icm->chunk_list);
#line 155
  cur_order = 6;
#line 157
  goto ldv_30664;
  ldv_30663: ;
#line 158
  if ((unsigned long )chunk == (unsigned long )((struct mthca_icm_chunk *)0)) {
#line 159
    tmp___1 = kmalloc(224UL, gfp_mask & 4294966781U);
#line 159
    chunk = (struct mthca_icm_chunk *)tmp___1;
#line 161
    if ((unsigned long )chunk == (unsigned long )((struct mthca_icm_chunk *)0)) {
#line 162
      goto fail;
    } else {

    }
#line 164
    sg_init_table((struct scatterlist *)(& chunk->mem), 5U);
#line 165
    chunk->npages = 0;
#line 166
    chunk->nsg = 0;
#line 167
    list_add_tail(& chunk->list, & icm->chunk_list);
  } else {

  }
#line 170
  goto ldv_30661;
  ldv_30660: 
#line 171
  cur_order = cur_order - 1;
  ldv_30661: ;
#line 170
  if (1 << cur_order > npages) {
#line 172
    goto ldv_30660;
  } else {

  }

#line 173
  if (coherent != 0) {
#line 174
    ret = mthca_alloc_icm_coherent(& (dev->pdev)->dev, (struct scatterlist *)(& chunk->mem) + (unsigned long )chunk->npages,
                                   cur_order, gfp_mask);
  } else {
#line 178
    ret = mthca_alloc_icm_pages((struct scatterlist *)(& chunk->mem) + (unsigned long )chunk->npages,
                                cur_order, gfp_mask);
  }
#line 181
  if (ret == 0) {
#line 182
    chunk->npages = chunk->npages + 1;
#line 184
    if (coherent != 0) {
#line 185
      chunk->nsg = chunk->nsg + 1;
    } else
#line 186
    if (chunk->npages == 5) {
#line 187
      chunk->nsg = pci_map_sg(dev->pdev, (struct scatterlist *)(& chunk->mem), chunk->npages,
                              0);
#line 191
      if (chunk->nsg <= 0) {
#line 192
        goto fail;
      } else {

      }
    } else {

    }
#line 195
    if (chunk->npages == 5) {
#line 196
      chunk = (struct mthca_icm_chunk *)0;
    } else {

    }
#line 198
    npages = npages - (1 << cur_order);
  } else {
#line 200
    cur_order = cur_order - 1;
#line 201
    if (cur_order < 0) {
#line 202
      goto fail;
    } else {

    }
  }
  ldv_30664: ;
#line 157
  if (npages > 0) {
#line 159
    goto ldv_30663;
  } else {

  }

#line 206
  if (coherent == 0 && (unsigned long )chunk != (unsigned long )((struct mthca_icm_chunk *)0)) {
#line 207
    chunk->nsg = pci_map_sg(dev->pdev, (struct scatterlist *)(& chunk->mem), chunk->npages,
                            0);
#line 211
    if (chunk->nsg <= 0) {
#line 212
      goto fail;
    } else {

    }
  } else {

  }
#line 215
  return (icm);
  fail: 
#line 218
  mthca_free_icm(dev, icm, coherent);
#line 219
  return ((struct mthca_icm *)0);
}
}
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
int mthca_table_get(struct mthca_dev *dev , struct mthca_icm_table *table , int obj ) 
{ 
  int i ;
  int ret ;
  int tmp ;

  {
#line 224
  i = (((table->num_obj + -1) & obj) * table->obj_size) / 262144;
#line 225
  ret = 0;
#line 227
  mutex_lock_nested(& table->mutex, 0U);
#line 229
  if ((unsigned long )table->icm[i] != (unsigned long )((struct mthca_icm *)0)) {
#line 230
    (table->icm[i])->refcount = (table->icm[i])->refcount + 1;
#line 231
    goto out;
  } else {

  }
#line 234
  table->icm[i] = mthca_alloc_icm(dev, 64, table->lowmem != 0 ? 720U : 131794U, table->coherent);
#line 237
  if ((unsigned long )table->icm[i] == (unsigned long )((struct mthca_icm *)0)) {
#line 238
    ret = -12;
#line 239
    goto out;
  } else {

  }
#line 242
  tmp = mthca_MAP_ICM(dev, table->icm[i], table->virt + (u64 )(i * 262144));
#line 242
  if (tmp != 0) {
#line 244
    mthca_free_icm(dev, table->icm[i], table->coherent);
#line 245
    table->icm[i] = (struct mthca_icm *)0;
#line 246
    ret = -12;
#line 247
    goto out;
  } else {

  }
#line 250
  (table->icm[i])->refcount = (table->icm[i])->refcount + 1;
  out: 
#line 253
  mutex_unlock(& table->mutex);
#line 254
  return (ret);
}
}
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
void mthca_table_put(struct mthca_dev *dev , struct mthca_icm_table *table , int obj ) 
{ 
  int i ;
  int tmp ;

  {
#line 261
  tmp = mthca_is_memfree(dev);
#line 261
  if (tmp == 0) {
#line 262
    return;
  } else {

  }
#line 264
  i = (((table->num_obj + -1) & obj) * table->obj_size) / 262144;
#line 266
  mutex_lock_nested(& table->mutex, 0U);
#line 268
  (table->icm[i])->refcount = (table->icm[i])->refcount - 1;
#line 268
  if ((table->icm[i])->refcount == 0) {
#line 269
    mthca_UNMAP_ICM(dev, table->virt + (u64 )(i * 262144), 64U);
#line 271
    mthca_free_icm(dev, table->icm[i], table->coherent);
#line 272
    table->icm[i] = (struct mthca_icm *)0;
  } else {

  }
#line 275
  mutex_unlock(& table->mutex);
#line 276
  return;
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
void *mthca_table_find(struct mthca_icm_table *table , int obj , dma_addr_t *dma_handle ) 
{ 
  int idx ;
  int offset ;
  int dma_offset ;
  int i ;
  struct mthca_icm_chunk *chunk ;
  struct mthca_icm *icm ;
  struct page *page ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 283
  page = (struct page *)0;
#line 285
  if (table->lowmem == 0) {
#line 286
    return ((void *)0);
  } else {

  }
#line 288
  mutex_lock_nested(& table->mutex, 0U);
#line 290
  idx = ((table->num_obj + -1) & obj) * table->obj_size;
#line 291
  icm = table->icm[idx / 262144];
#line 292
  offset = idx % 262144;
#line 292
  dma_offset = offset;
#line 294
  if ((unsigned long )icm == (unsigned long )((struct mthca_icm *)0)) {
#line 295
    goto out;
  } else {

  }
#line 297
  __mptr = (struct list_head  const  *)icm->chunk_list.next;
#line 297
  chunk = (struct mthca_icm_chunk *)__mptr;
#line 297
  goto ldv_30701;
  ldv_30700: 
#line 298
  i = 0;
#line 298
  goto ldv_30698;
  ldv_30697: ;
#line 299
  if ((unsigned long )dma_handle != (unsigned long )((dma_addr_t *)0ULL) && dma_offset >= 0) {
#line 300
    if (((struct scatterlist *)(& chunk->mem) + (unsigned long )i)->dma_length > (unsigned int )dma_offset) {
#line 301
      *dma_handle = ((struct scatterlist *)(& chunk->mem) + (unsigned long )i)->dma_address + (dma_addr_t )dma_offset;
    } else {

    }
#line 303
    dma_offset = (int )((unsigned int )dma_offset - ((struct scatterlist *)(& chunk->mem) + (unsigned long )i)->dma_length);
  } else {

  }
#line 308
  if (chunk->mem[i].length > (unsigned int )offset) {
#line 309
    page = sg_page((struct scatterlist *)(& chunk->mem) + (unsigned long )i);
#line 310
    goto out;
  } else {

  }
#line 312
  offset = (int )((unsigned int )offset - chunk->mem[i].length);
#line 298
  i = i + 1;
  ldv_30698: ;
#line 298
  if (chunk->npages > i) {
#line 300
    goto ldv_30697;
  } else {

  }
#line 297
  __mptr___0 = (struct list_head  const  *)chunk->list.next;
#line 297
  chunk = (struct mthca_icm_chunk *)__mptr___0;
  ldv_30701: ;
#line 297
  if ((unsigned long )chunk != (unsigned long )icm) {
#line 299
    goto ldv_30700;
  } else {

  }

  out: 
#line 317
  mutex_unlock(& table->mutex);
#line 318
  if ((unsigned long )page != (unsigned long )((struct page *)0)) {
#line 318
    tmp = lowmem_page_address((struct page  const  *)page);
#line 318
    tmp___0 = tmp + (unsigned long )offset;
  } else {
#line 318
    tmp___0 = (void *)0;
  }
#line 318
  return (tmp___0);
}
}
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
int mthca_table_get_range(struct mthca_dev *dev , struct mthca_icm_table *table ,
                          int start , int end ) 
{ 
  int inc ;
  int i ;
  int err ;

  {
#line 324
  inc = 262144 / table->obj_size;
#line 327
  i = start;
#line 327
  goto ldv_30714;
  ldv_30713: 
#line 328
  err = mthca_table_get(dev, table, i);
#line 329
  if (err != 0) {
#line 330
    goto fail;
  } else {

  }
#line 327
  i = i + inc;
  ldv_30714: ;
#line 327
  if (i <= end) {
#line 329
    goto ldv_30713;
  } else {

  }

#line 333
  return (0);
  fail: ;
#line 336
  goto ldv_30717;
  ldv_30716: 
#line 337
  i = i - inc;
#line 338
  mthca_table_put(dev, table, i);
  ldv_30717: ;
#line 336
  if (i > start) {
#line 338
    goto ldv_30716;
  } else {

  }

#line 341
  return (err);
}
}
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
void mthca_table_put_range(struct mthca_dev *dev , struct mthca_icm_table *table ,
                           int start , int end ) 
{ 
  int i ;
  int tmp ;

  {
#line 349
  tmp = mthca_is_memfree(dev);
#line 349
  if (tmp == 0) {
#line 350
    return;
  } else {

  }
#line 352
  i = start;
#line 352
  goto ldv_30727;
  ldv_30726: 
#line 353
  mthca_table_put(dev, table, i);
#line 352
  i = 262144 / table->obj_size + i;
  ldv_30727: ;
#line 352
  if (i <= end) {
#line 354
    goto ldv_30726;
  } else {

  }

#line 359
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
struct mthca_icm_table *mthca_alloc_icm_table(struct mthca_dev *dev , u64 virt , int obj_size ,
                                              int nobj , int reserved , int use_lowmem ,
                                              int use_coherent ) 
{ 
  struct mthca_icm_table *table ;
  int obj_per_chunk ;
  int num_icm ;
  unsigned int chunk_size ;
  int i ;
  void *tmp ;
  struct lock_class_key __key ;
  int tmp___0 ;

  {
#line 367
  obj_per_chunk = 262144 / obj_size;
#line 368
  num_icm = ((nobj + obj_per_chunk) + -1) / obj_per_chunk;
#line 370
  tmp = kmalloc(((unsigned long )num_icm + 24UL) * 8UL, 208U);
#line 370
  table = (struct mthca_icm_table *)tmp;
#line 371
  if ((unsigned long )table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 372
    return ((struct mthca_icm_table *)0);
  } else {

  }
#line 374
  table->virt = virt;
#line 375
  table->num_icm = num_icm;
#line 376
  table->num_obj = nobj;
#line 377
  table->obj_size = obj_size;
#line 378
  table->lowmem = use_lowmem;
#line 379
  table->coherent = use_coherent;
#line 380
  __mutex_init(& table->mutex, "&table->mutex", & __key);
#line 382
  i = 0;
#line 382
  goto ldv_30745;
  ldv_30744: 
#line 383
  table->icm[i] = (struct mthca_icm *)0;
#line 382
  i = i + 1;
  ldv_30745: ;
#line 382
  if (i < num_icm) {
#line 384
    goto ldv_30744;
  } else {

  }
#line 385
  i = 0;
#line 385
  goto ldv_30749;
  ldv_30748: 
#line 386
  chunk_size = 262144U;
#line 387
  if ((i + 1) * 262144 > nobj * obj_size) {
#line 388
    chunk_size = (unsigned int )(nobj * obj_size + i * -262144);
  } else {

  }
#line 390
  table->icm[i] = mthca_alloc_icm(dev, (int )(chunk_size >> 12), use_lowmem != 0 ? 720U : 131794U,
                                  use_coherent);
#line 393
  if ((unsigned long )table->icm[i] == (unsigned long )((struct mthca_icm *)0)) {
#line 394
    goto err;
  } else {

  }
#line 395
  tmp___0 = mthca_MAP_ICM(dev, table->icm[i], (u64 )(i * 262144) + virt);
#line 395
  if (tmp___0 != 0) {
#line 397
    mthca_free_icm(dev, table->icm[i], table->coherent);
#line 398
    table->icm[i] = (struct mthca_icm *)0;
#line 399
    goto err;
  } else {

  }
#line 406
  (table->icm[i])->refcount = (table->icm[i])->refcount + 1;
#line 385
  i = i + 1;
  ldv_30749: ;
#line 385
  if (i * 262144 < reserved * obj_size) {
#line 387
    goto ldv_30748;
  } else {

  }

#line 409
  return (table);
  err: 
#line 412
  i = 0;
#line 412
  goto ldv_30752;
  ldv_30751: ;
#line 413
  if ((unsigned long )table->icm[i] != (unsigned long )((struct mthca_icm *)0)) {
#line 414
    mthca_UNMAP_ICM(dev, (u64 )(i * 262144) + virt, 64U);
#line 416
    mthca_free_icm(dev, table->icm[i], table->coherent);
  } else {

  }
#line 412
  i = i + 1;
  ldv_30752: ;
#line 412
  if (i < num_icm) {
#line 414
    goto ldv_30751;
  } else {

  }
#line 419
  kfree((void const   *)table);
#line 421
  return ((struct mthca_icm_table *)0);
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
void mthca_free_icm_table(struct mthca_dev *dev , struct mthca_icm_table *table ) 
{ 
  int i ;

  {
#line 428
  i = 0;
#line 428
  goto ldv_30760;
  ldv_30759: ;
#line 429
  if ((unsigned long )table->icm[i] != (unsigned long )((struct mthca_icm *)0)) {
#line 430
    mthca_UNMAP_ICM(dev, table->virt + (u64 )(i * 262144), 64U);
#line 433
    mthca_free_icm(dev, table->icm[i], table->coherent);
  } else {

  }
#line 428
  i = i + 1;
  ldv_30760: ;
#line 428
  if (table->num_icm > i) {
#line 430
    goto ldv_30759;
  } else {

  }
#line 436
  kfree((void const   *)table);
#line 437
  return;
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
static u64 mthca_uarc_virt(struct mthca_dev *dev , struct mthca_uar *uar , int page ) 
{ 


  {
#line 441
  return ((dev->uar_table.uarc_base + (u64 )(uar->index * dev->uar_table.uarc_size)) + (u64 )(page * 4096));
}
}
#line 446 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
int mthca_map_user_db(struct mthca_dev *dev , struct mthca_uar *uar , struct mthca_user_db_table *db_tab ,
                      int index , u64 uaddr ) 
{ 
  struct page *pages[1U] ;
  int ret ;
  int i ;
  int tmp ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  long tmp___2 ;
  u64 tmp___3 ;
  struct page *tmp___4 ;

  {
#line 450
  ret = 0;
#line 453
  tmp = mthca_is_memfree(dev);
#line 453
  if (tmp == 0) {
#line 454
    return (0);
  } else {

  }
#line 456
  if (index < 0 || dev->uar_table.uarc_size / 8 < index) {
#line 457
    return (-22);
  } else {

  }
#line 459
  mutex_lock_nested(& db_tab->mutex, 0U);
#line 461
  i = index / 512;
#line 463
  if ((db_tab->page[i].refcount > 511 || (db_tab->page[i].uvirt != 0ULL && db_tab->page[i].uvirt != uaddr)) || (uaddr & 4095ULL) != 0ULL) {
#line 466
    ret = -22;
#line 467
    goto out;
  } else {

  }
#line 470
  if (db_tab->page[i].refcount != 0) {
#line 471
    db_tab->page[i].refcount = db_tab->page[i].refcount + 1;
#line 472
    goto out;
  } else {

  }
#line 475
  tmp___0 = get_current();
#line 475
  tmp___1 = get_current();
#line 475
  tmp___2 = get_user_pages(tmp___1, tmp___0->mm, (unsigned long )uaddr & 0xfffffffffffff000UL,
                           1UL, 1, 0, (struct page **)(& pages), (struct vm_area_struct **)0);
#line 475
  ret = (int )tmp___2;
#line 477
  if (ret < 0) {
#line 478
    goto out;
  } else {

  }
#line 480
  sg_set_page(& db_tab->page[i].mem, pages[0], 4096U, (unsigned int )uaddr & 4095U);
#line 483
  ret = pci_map_sg(dev->pdev, & db_tab->page[i].mem, 1, 1);
#line 484
  if (ret < 0) {
#line 485
    put_page(pages[0]);
#line 486
    goto out;
  } else {

  }
#line 489
  tmp___3 = mthca_uarc_virt(dev, uar, i);
#line 489
  ret = mthca_MAP_ICM_page(dev, db_tab->page[i].mem.dma_address, tmp___3);
#line 491
  if (ret != 0) {
#line 492
    pci_unmap_sg(dev->pdev, & db_tab->page[i].mem, 1, 1);
#line 493
    tmp___4 = sg_page(& db_tab->page[i].mem);
#line 493
    put_page(tmp___4);
#line 494
    goto out;
  } else {

  }
#line 497
  db_tab->page[i].uvirt = uaddr;
#line 498
  db_tab->page[i].refcount = 1;
  out: 
#line 501
  mutex_unlock(& db_tab->mutex);
#line 502
  return (ret);
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
void mthca_unmap_user_db(struct mthca_dev *dev , struct mthca_uar *uar , struct mthca_user_db_table *db_tab ,
                         int index ) 
{ 
  int tmp ;

  {
#line 508
  tmp = mthca_is_memfree(dev);
#line 508
  if (tmp == 0) {
#line 509
    return;
  } else {

  }
#line 516
  mutex_lock_nested(& db_tab->mutex, 0U);
#line 518
  db_tab->page[index / 512].refcount = db_tab->page[index / 512].refcount - 1;
#line 520
  mutex_unlock(& db_tab->mutex);
#line 521
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
struct mthca_user_db_table *mthca_init_user_db_tab(struct mthca_dev *dev ) 
{ 
  struct mthca_user_db_table *db_tab ;
  int npages ;
  int i ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct lock_class_key __key ;

  {
#line 529
  tmp = mthca_is_memfree(dev);
#line 529
  if (tmp == 0) {
#line 530
    return ((struct mthca_user_db_table *)0);
  } else {

  }
#line 532
  npages = dev->uar_table.uarc_size / 4096;
#line 533
  tmp___0 = kmalloc((unsigned long )npages * 56UL + 160UL, 208U);
#line 533
  db_tab = (struct mthca_user_db_table *)tmp___0;
#line 534
  if ((unsigned long )db_tab == (unsigned long )((struct mthca_user_db_table *)0)) {
#line 535
    tmp___1 = ERR_PTR(-12L);
#line 535
    return ((struct mthca_user_db_table *)tmp___1);
  } else {

  }
#line 537
  __mutex_init(& db_tab->mutex, "&db_tab->mutex", & __key);
#line 538
  i = 0;
#line 538
  goto ldv_30792;
  ldv_30791: 
#line 539
  db_tab->page[i].refcount = 0;
#line 540
  db_tab->page[i].uvirt = 0ULL;
#line 541
  sg_init_table(& db_tab->page[i].mem, 1U);
#line 538
  i = i + 1;
  ldv_30792: ;
#line 538
  if (i < npages) {
#line 540
    goto ldv_30791;
  } else {

  }

#line 544
  return (db_tab);
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
void mthca_cleanup_user_db_tab(struct mthca_dev *dev , struct mthca_uar *uar , struct mthca_user_db_table *db_tab ) 
{ 
  int i ;
  int tmp ;
  u64 tmp___0 ;
  struct page *tmp___1 ;

  {
#line 552
  tmp = mthca_is_memfree(dev);
#line 552
  if (tmp == 0) {
#line 553
    return;
  } else {

  }
#line 555
  i = 0;
#line 555
  goto ldv_30801;
  ldv_30800: ;
#line 556
  if (db_tab->page[i].uvirt != 0ULL) {
#line 557
    tmp___0 = mthca_uarc_virt(dev, uar, i);
#line 557
    mthca_UNMAP_ICM(dev, tmp___0, 1U);
#line 558
    pci_unmap_sg(dev->pdev, & db_tab->page[i].mem, 1, 1);
#line 559
    tmp___1 = sg_page(& db_tab->page[i].mem);
#line 559
    put_page(tmp___1);
  } else {

  }
#line 555
  i = i + 1;
  ldv_30801: ;
#line 555
  if (dev->uar_table.uarc_size / 4096 > i) {
#line 557
    goto ldv_30800;
  } else {

  }
#line 563
  kfree((void const   *)db_tab);
#line 564
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
int mthca_alloc_db(struct mthca_dev *dev , enum mthca_db_type type , u32 qn , __be32 **db ) 
{ 
  int group ;
  int start ;
  int end ;
  int dir ;
  int i ;
  int j ;
  struct mthca_db_page *page ;
  int ret ;
  int tmp ;
  void *tmp___0 ;
  u64 tmp___1 ;
  unsigned long tmp___2 ;
  __u64 tmp___3 ;

  {
#line 573
  ret = 0;
#line 575
  mutex_lock_nested(& (dev->db_tab)->mutex, 0U);
#line 577
  switch ((unsigned int )type) {
  case 2U: ;
  case 3U: 
#line 580
  group = 0;
#line 581
  start = 0;
#line 582
  end = (dev->db_tab)->max_group1;
#line 583
  dir = 1;
#line 584
  goto ldv_30819;
  case 1U: ;
  case 4U: ;
  case 5U: 
#line 589
  group = 1;
#line 590
  start = (dev->db_tab)->npages + -1;
#line 591
  end = (dev->db_tab)->min_group2;
#line 592
  dir = -1;
#line 593
  goto ldv_30819;
  default: 
#line 596
  ret = -22;
#line 597
  goto out;
  }
  ldv_30819: 
#line 600
  i = start;
#line 600
  goto ldv_30827;
  ldv_30826: ;
#line 601
  if ((unsigned long )((dev->db_tab)->page + (unsigned long )i)->db_rec != (unsigned long )((__be64 *)0ULL)) {
#line 601
    tmp = bitmap_full((unsigned long const   *)(& ((dev->db_tab)->page + (unsigned long )i)->used),
                      512U);
#line 601
    if (tmp == 0) {
#line 604
      page = (dev->db_tab)->page + (unsigned long )i;
#line 605
      goto found;
    } else {

    }
  } else {

  }
#line 600
  i = i + dir;
  ldv_30827: ;
#line 600
  if (i != end) {
#line 602
    goto ldv_30826;
  } else {

  }
#line 608
  i = start;
#line 608
  goto ldv_30831;
  ldv_30830: ;
#line 609
  if ((unsigned long )((dev->db_tab)->page + (unsigned long )i)->db_rec == (unsigned long )((__be64 *)0ULL)) {
#line 610
    page = (dev->db_tab)->page + (unsigned long )i;
#line 611
    goto alloc;
  } else {

  }
#line 608
  i = i + dir;
  ldv_30831: ;
#line 608
  if (i != end) {
#line 610
    goto ldv_30830;
  } else {

  }

#line 614
  if ((dev->db_tab)->max_group1 >= (dev->db_tab)->min_group2 + -1) {
#line 615
    ret = -12;
#line 616
    goto out;
  } else {

  }
#line 619
  if (group == 0) {
#line 620
    (dev->db_tab)->max_group1 = (dev->db_tab)->max_group1 + 1;
  } else {
#line 622
    (dev->db_tab)->min_group2 = (dev->db_tab)->min_group2 - 1;
  }
#line 624
  page = (dev->db_tab)->page + (unsigned long )end;
  alloc: 
#line 627
  tmp___0 = dma_alloc_attrs(& (dev->pdev)->dev, 4096UL, & page->mapping, 208U, (struct dma_attrs *)0);
#line 627
  page->db_rec = (__be64 *)tmp___0;
#line 629
  if ((unsigned long )page->db_rec == (unsigned long )((__be64 *)0ULL)) {
#line 630
    ret = -12;
#line 631
    goto out;
  } else {

  }
#line 633
  memset((void *)page->db_rec, 0, 4096UL);
#line 635
  tmp___1 = mthca_uarc_virt(dev, & dev->driver_uar, i);
#line 635
  ret = mthca_MAP_ICM_page(dev, page->mapping, tmp___1);
#line 637
  if (ret != 0) {
#line 638
    dma_free_attrs(& (dev->pdev)->dev, 4096UL, (void *)page->db_rec, page->mapping,
                   (struct dma_attrs *)0);
#line 640
    goto out;
  } else {

  }
#line 643
  bitmap_zero((unsigned long *)(& page->used), 512U);
  found: 
#line 646
  tmp___2 = find_first_zero_bit((unsigned long const   *)(& page->used), 512UL);
#line 646
  j = (int )tmp___2;
#line 647
  set_bit((long )j, (unsigned long volatile   *)(& page->used));
#line 649
  if (group == 1) {
#line 650
    j = 511 - j;
  } else {

  }
#line 652
  ret = i * 512 + j;
#line 654
  tmp___3 = __fswab64((__u64 )((qn << 8) | ((unsigned int )type << 5)));
#line 654
  *(page->db_rec + (unsigned long )j) = tmp___3;
#line 656
  *db = (__be32 *)page->db_rec + (unsigned long )j;
  out: 
#line 659
  mutex_unlock(& (dev->db_tab)->mutex);
#line 661
  return (ret);
}
}
#line 664 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
void mthca_free_db(struct mthca_dev *dev , int type , int db_index ) 
{ 
  int i ;
  int j ;
  struct mthca_db_page *page ;
  u64 tmp ;
  int tmp___0 ;

  {
#line 669
  i = db_index / 512;
#line 670
  j = db_index % 512;
#line 672
  page = (dev->db_tab)->page + (unsigned long )i;
#line 674
  mutex_lock_nested(& (dev->db_tab)->mutex, 0U);
#line 676
  *(page->db_rec + (unsigned long )j) = 0ULL;
#line 677
  if ((dev->db_tab)->min_group2 <= i) {
#line 678
    j = 511 - j;
  } else {

  }
#line 679
  clear_bit((long )j, (unsigned long volatile   *)(& page->used));
#line 681
  tmp___0 = bitmap_empty((unsigned long const   *)(& page->used), 512U);
#line 681
  if (tmp___0 != 0 && (dev->db_tab)->max_group1 + -1 <= i) {
#line 683
    tmp = mthca_uarc_virt(dev, & dev->driver_uar, i);
#line 683
    mthca_UNMAP_ICM(dev, tmp, 1U);
#line 685
    dma_free_attrs(& (dev->pdev)->dev, 4096UL, (void *)page->db_rec, page->mapping,
                   (struct dma_attrs *)0);
#line 687
    page->db_rec = (__be64 *)0ULL;
#line 689
    if ((dev->db_tab)->max_group1 == i) {
#line 690
      (dev->db_tab)->max_group1 = (dev->db_tab)->max_group1 - 1;
    } else {

    }
#line 693
    if ((dev->db_tab)->min_group2 == i) {
#line 694
      (dev->db_tab)->min_group2 = (dev->db_tab)->min_group2 + 1;
    } else {

    }
  } else {

  }
#line 697
  mutex_unlock(& (dev->db_tab)->mutex);
#line 698
  return;
}
}
#line 700 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
int mthca_init_db_tab(struct mthca_dev *dev ) 
{ 
  int i ;
  int tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  void *tmp___1 ;

  {
#line 704
  tmp = mthca_is_memfree(dev);
#line 704
  if (tmp == 0) {
#line 705
    return (0);
  } else {

  }
#line 707
  tmp___0 = kmalloc(184UL, 208U);
#line 707
  dev->db_tab = (struct mthca_db_table *)tmp___0;
#line 708
  if ((unsigned long )dev->db_tab == (unsigned long )((struct mthca_db_table *)0)) {
#line 709
    return (-12);
  } else {

  }
#line 711
  __mutex_init(& (dev->db_tab)->mutex, "&dev->db_tab->mutex", & __key);
#line 713
  (dev->db_tab)->npages = dev->uar_table.uarc_size / 4096;
#line 714
  (dev->db_tab)->max_group1 = 0;
#line 715
  (dev->db_tab)->min_group2 = (dev->db_tab)->npages + -1;
#line 717
  tmp___1 = kmalloc((unsigned long )(dev->db_tab)->npages * 80UL, 208U);
#line 717
  (dev->db_tab)->page = (struct mthca_db_page *)tmp___1;
#line 720
  if ((unsigned long )(dev->db_tab)->page == (unsigned long )((struct mthca_db_page *)0)) {
#line 721
    kfree((void const   *)dev->db_tab);
#line 722
    return (-12);
  } else {

  }
#line 725
  i = 0;
#line 725
  goto ldv_30847;
  ldv_30846: 
#line 726
  ((dev->db_tab)->page + (unsigned long )i)->db_rec = (__be64 *)0ULL;
#line 725
  i = i + 1;
  ldv_30847: ;
#line 725
  if ((dev->db_tab)->npages > i) {
#line 727
    goto ldv_30846;
  } else {

  }

#line 728
  return (0);
}
}
#line 731 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.c"
void mthca_cleanup_db_tab(struct mthca_dev *dev ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  u64 tmp___1 ;

  {
#line 735
  tmp = mthca_is_memfree(dev);
#line 735
  if (tmp == 0) {
#line 736
    return;
  } else {

  }
#line 744
  i = 0;
#line 744
  goto ldv_30855;
  ldv_30854: ;
#line 745
  if ((unsigned long )((dev->db_tab)->page + (unsigned long )i)->db_rec == (unsigned long )((__be64 *)0ULL)) {
#line 746
    goto ldv_30853;
  } else {

  }
#line 748
  tmp___0 = bitmap_empty((unsigned long const   *)(& ((dev->db_tab)->page + (unsigned long )i)->used),
                         512U);
#line 748
  if (tmp___0 == 0) {
#line 749
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Kernel UARC page %d not empty\n",
             i);
  } else {

  }
#line 751
  tmp___1 = mthca_uarc_virt(dev, & dev->driver_uar, i);
#line 751
  mthca_UNMAP_ICM(dev, tmp___1, 1U);
#line 753
  dma_free_attrs(& (dev->pdev)->dev, 4096UL, (void *)((dev->db_tab)->page + (unsigned long )i)->db_rec,
                 ((dev->db_tab)->page + (unsigned long )i)->mapping, (struct dma_attrs *)0);
  ldv_30853: 
#line 744
  i = i + 1;
  ldv_30855: ;
#line 744
  if ((dev->db_tab)->npages > i) {
#line 746
    goto ldv_30854;
  } else {

  }
#line 758
  kfree((void const   *)(dev->db_tab)->page);
#line 759
  kfree((void const   *)dev->db_tab);
#line 760
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.o.c.prepared"
bool ldv_queue_work_on_205(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.o.c.prepared"
bool ldv_queue_delayed_work_on_206(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.o.c.prepared"
bool ldv_queue_work_on_207(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.o.c.prepared"
void ldv_flush_workqueue_208(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_memfree.o.c.prepared"
bool ldv_queue_delayed_work_on_209(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_219(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_221(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_220(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_223(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_222(struct workqueue_struct *ldv_func_arg1 ) ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_uar.c"
int mthca_uar_alloc(struct mthca_dev *dev , struct mthca_uar *uar ) 
{ 
  u32 tmp ;

  {
#line 40
  tmp = mthca_alloc(& dev->uar_table.alloc);
#line 40
  uar->index = (int )tmp;
#line 41
  if (uar->index == -1) {
#line 42
    return (-12);
  } else {

  }
#line 44
  uar->pfn = (unsigned long )(((dev->pdev)->resource[2].start >> 12) + (resource_size_t )uar->index);
#line 46
  return (0);
}
}
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_uar.c"
void mthca_uar_free(struct mthca_dev *dev , struct mthca_uar *uar ) 
{ 


  {
#line 51
  mthca_free(& dev->uar_table.alloc, (u32 )uar->index);
#line 52
  return;
}
}
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_uar.c"
int mthca_init_uar_table(struct mthca_dev *dev ) 
{ 
  int ret ;

  {
#line 58
  ret = mthca_alloc_init(& dev->uar_table.alloc, (u32 )dev->limits.num_uars, (u32 )(dev->limits.num_uars + -1),
                         (u32 )(dev->limits.reserved_uars + 1));
#line 62
  if (ret != 0) {
#line 63
    return (ret);
  } else {

  }
#line 65
  ret = mthca_init_db_tab(dev);
#line 66
  if (ret != 0) {
#line 67
    mthca_alloc_cleanup(& dev->uar_table.alloc);
  } else {

  }
#line 69
  return (ret);
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_uar.c"
void mthca_cleanup_uar_table(struct mthca_dev *dev ) 
{ 


  {
#line 74
  mthca_cleanup_db_tab(dev);
#line 77
  mthca_alloc_cleanup(& dev->uar_table.alloc);
#line 78
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_uar.o.c.prepared"
bool ldv_queue_work_on_219(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_uar.o.c.prepared"
bool ldv_queue_delayed_work_on_220(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_uar.o.c.prepared"
bool ldv_queue_work_on_221(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_uar.o.c.prepared"
void ldv_flush_workqueue_222(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_uar.o.c.prepared"
bool ldv_queue_delayed_work_on_223(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_233(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_235(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_234(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_237(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_236(struct workqueue_struct *ldv_func_arg1 ) ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
static void *get_wqe(struct mthca_srq *srq , int n ) 
{ 


  {
#line 74
  if (srq->is_direct != 0) {
#line 75
    return (srq->queue.direct.buf + (unsigned long )(n << srq->wqe_shift));
  } else {
#line 77
    return ((srq->queue.page_list + (unsigned long )((n << srq->wqe_shift) >> 12))->buf + ((unsigned long )(n << srq->wqe_shift) & 4095UL));
  }
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
__inline static int *wqe_to_link(void *wqe ) 
{ 


  {
#line 92
  return ((int *)wqe + 12U);
}
}
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
static void mthca_tavor_init_srq_context(struct mthca_dev *dev , struct mthca_pd *pd ,
                                         struct mthca_srq *srq , struct mthca_tavor_srq_context *context ) 
{ 
  __u64 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  struct mthca_ucontext *tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;

  {
#line 100
  memset((void *)context, 0, 32UL);
#line 102
  tmp = __fswab64((__u64 )(1 << (srq->wqe_shift + -4)));
#line 102
  context->wqe_base_ds = tmp;
#line 103
  tmp___0 = __fswab32(pd->pd_num);
#line 103
  context->state_pd = tmp___0;
#line 104
  tmp___1 = __fswab32(srq->mr.ibmr.lkey);
#line 104
  context->lkey = tmp___1;
#line 106
  if ((unsigned long )pd->ibpd.uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 107
    tmp___2 = to_mucontext((pd->ibpd.uobject)->context);
#line 107
    tmp___3 = __fswab32((__u32 )tmp___2->uar.index);
#line 107
    context->uar = tmp___3;
  } else {
#line 110
    tmp___4 = __fswab32((__u32 )dev->driver_uar.index);
#line 110
    context->uar = tmp___4;
  }
#line 111
  return;
}
}
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
static void mthca_arbel_init_srq_context(struct mthca_dev *dev , struct mthca_pd *pd ,
                                         struct mthca_srq *srq , struct mthca_arbel_srq_context *context ) 
{ 
  int logsize ;
  int max ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  struct mthca_ucontext *tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;

  {
#line 120
  memset((void *)context, 0, 48UL);
#line 126
  max = srq->max;
#line 127
  logsize = __ilog2_u32((u32 )max);
#line 128
  tmp = __fswab32((__u32 )((logsize << 24) | srq->srqn));
#line 128
  context->state_logsize_srqn = tmp;
#line 129
  tmp___0 = __fswab32(srq->mr.ibmr.lkey);
#line 129
  context->lkey = tmp___0;
#line 130
  tmp___1 = __fswab32((__u32 )srq->db_index);
#line 130
  context->db_index = tmp___1;
#line 131
  tmp___2 = __fswab32((__u32 )((srq->wqe_shift + -4) << 29));
#line 131
  context->logstride_usrpage = tmp___2;
#line 132
  if ((unsigned long )pd->ibpd.uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 133
    tmp___3 = to_mucontext((pd->ibpd.uobject)->context);
#line 133
    tmp___4 = __fswab32((__u32 )tmp___3->uar.index);
#line 133
    context->logstride_usrpage = context->logstride_usrpage | tmp___4;
  } else {
#line 136
    tmp___5 = __fswab32((__u32 )dev->driver_uar.index);
#line 136
    context->logstride_usrpage = context->logstride_usrpage | tmp___5;
  }
#line 137
  tmp___6 = __fswab32(pd->pd_num | 16777216U);
#line 137
  context->eq_pd = tmp___6;
#line 138
  return;
}
}
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
static void mthca_free_srq_buf(struct mthca_dev *dev , struct mthca_srq *srq ) 
{ 


  {
#line 142
  mthca_buf_free(dev, srq->max << srq->wqe_shift, & srq->queue, srq->is_direct, & srq->mr);
#line 144
  kfree((void const   *)srq->wrid);
#line 145
  return;
}
}
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
static int mthca_alloc_srq_buf(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_srq *srq ) 
{ 
  struct mthca_data_seg *scatter ;
  void *wqe ;
  int err ;
  int i ;
  void *tmp ;
  struct mthca_next_seg *next ;
  int *tmp___0 ;
  __u32 tmp___1 ;
  int *tmp___2 ;

  {
#line 155
  if ((unsigned long )pd->ibpd.uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 156
    return (0);
  } else {

  }
#line 158
  tmp = kmalloc((unsigned long )srq->max * 8UL, 208U);
#line 158
  srq->wrid = (u64 *)tmp;
#line 159
  if ((unsigned long )srq->wrid == (unsigned long )((u64 *)0ULL)) {
#line 160
    return (-12);
  } else {

  }
#line 162
  err = mthca_buf_alloc(dev, srq->max << srq->wqe_shift, 16384, & srq->queue, & srq->is_direct,
                        pd, 1, & srq->mr);
#line 165
  if (err != 0) {
#line 166
    kfree((void const   *)srq->wrid);
#line 167
    return (err);
  } else {

  }
#line 175
  i = 0;
#line 175
  goto ldv_30717;
  ldv_30716: 
#line 178
  wqe = get_wqe(srq, i);
#line 178
  next = (struct mthca_next_seg *)wqe;
#line 180
  if (srq->max + -1 > i) {
#line 181
    tmp___0 = wqe_to_link(wqe);
#line 181
    *tmp___0 = i + 1;
#line 182
    tmp___1 = __fswab32((__u32 )(((i + 1) << srq->wqe_shift) | 1));
#line 182
    next->nda_op = tmp___1;
  } else {
#line 184
    tmp___2 = wqe_to_link(wqe);
#line 184
    *tmp___2 = -1;
#line 185
    next->nda_op = 0U;
  }
#line 188
  scatter = (struct mthca_data_seg *)wqe + 16U;
#line 188
  goto ldv_30714;
  ldv_30713: 
#line 191
  scatter->lkey = 65536U;
#line 190
  scatter = scatter + 1;
  ldv_30714: ;
#line 188
  if ((unsigned long )(wqe + (unsigned long )(1 << srq->wqe_shift)) > (unsigned long )((void *)scatter)) {
#line 191
    goto ldv_30713;
  } else {

  }
#line 175
  i = i + 1;
  ldv_30717: ;
#line 175
  if (srq->max > i) {
#line 177
    goto ldv_30716;
  } else {

  }
#line 194
  srq->last = get_wqe(srq, srq->max + -1);
#line 196
  return (0);
}
}
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
int mthca_alloc_srq(struct mthca_dev *dev , struct mthca_pd *pd , struct ib_srq_attr *attr ,
                    struct mthca_srq *srq ) 
{ 
  struct mthca_mailbox *mailbox ;
  int ds ;
  int err ;
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long _max1 ;
  unsigned long _max2 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  u32 tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  bool tmp___6 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 207
  if (attr->max_wr > (u32 )dev->limits.max_srq_wqes || attr->max_sge > (u32 )dev->limits.max_srq_sge) {
#line 209
    return (-22);
  } else {

  }
#line 211
  srq->max = (int )attr->max_wr;
#line 212
  srq->max_gs = (int )attr->max_sge;
#line 213
  srq->counter = 0U;
#line 215
  tmp___0 = mthca_is_memfree(dev);
#line 215
  if (tmp___0 != 0) {
#line 216
    tmp = __roundup_pow_of_two((unsigned long )(srq->max + 1));
#line 216
    srq->max = (int )tmp;
  } else {
#line 218
    srq->max = srq->max + 1;
  }
#line 220
  _max1 = 64UL;
#line 220
  tmp___1 = __roundup_pow_of_two(((unsigned long )srq->max_gs + 1UL) * 16UL);
#line 220
  _max2 = tmp___1;
#line 220
  ds = (int )(_max1 > _max2 ? _max1 : _max2);
#line 224
  tmp___2 = mthca_is_memfree(dev);
#line 224
  if (tmp___2 == 0 && dev->limits.max_desc_sz < ds) {
#line 225
    return (-22);
  } else {

  }
#line 227
  srq->wqe_shift = __ilog2_u32((u32 )ds);
#line 229
  tmp___3 = mthca_alloc(& dev->srq_table.alloc);
#line 229
  srq->srqn = (int )tmp___3;
#line 230
  if (srq->srqn == -1) {
#line 231
    return (-12);
  } else {

  }
#line 233
  tmp___4 = mthca_is_memfree(dev);
#line 233
  if (tmp___4 != 0) {
#line 234
    err = mthca_table_get(dev, dev->srq_table.table, srq->srqn);
#line 235
    if (err != 0) {
#line 236
      goto err_out;
    } else {

    }
#line 238
    if ((unsigned long )pd->ibpd.uobject == (unsigned long )((struct ib_uobject *)0)) {
#line 239
      srq->db_index = mthca_alloc_db(dev, 5, (u32 )srq->srqn, & srq->db);
#line 241
      if (srq->db_index < 0) {
#line 242
        err = -12;
#line 243
        goto err_out_icm;
      } else {

      }
    } else {

    }
  } else {

  }
#line 248
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 249
  tmp___6 = IS_ERR((void const   *)mailbox);
#line 249
  if ((int )tmp___6) {
#line 250
    tmp___5 = PTR_ERR((void const   *)mailbox);
#line 250
    err = (int )tmp___5;
#line 251
    goto err_out_db;
  } else {

  }
#line 254
  err = mthca_alloc_srq_buf(dev, pd, srq);
#line 255
  if (err != 0) {
#line 256
    goto err_out_mailbox;
  } else {

  }
#line 258
  spinlock_check(& srq->lock);
#line 258
  __raw_spin_lock_init(& srq->lock.__annonCompField18.rlock, "&(&srq->lock)->rlock",
                       & __key);
#line 259
  srq->refcount = 1;
#line 260
  __init_waitqueue_head(& srq->wait, "&srq->wait", & __key___0);
#line 261
  __mutex_init(& srq->mutex, "&srq->mutex", & __key___1);
#line 263
  tmp___7 = mthca_is_memfree(dev);
#line 263
  if (tmp___7 != 0) {
#line 264
    mthca_arbel_init_srq_context(dev, pd, srq, (struct mthca_arbel_srq_context *)mailbox->buf);
  } else {
#line 266
    mthca_tavor_init_srq_context(dev, pd, srq, (struct mthca_tavor_srq_context *)mailbox->buf);
  }
#line 268
  err = mthca_SW2HW_SRQ(dev, mailbox, srq->srqn);
#line 270
  if (err != 0) {
#line 271
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "SW2HW_SRQ failed (%d)\n",
             err);
#line 272
    goto err_out_free_buf;
  } else {

  }
#line 275
  spin_lock_irq(& dev->srq_table.lock);
#line 276
  tmp___8 = mthca_array_set(& dev->srq_table.srq, srq->srqn & (dev->limits.num_srqs + -1),
                            (void *)srq);
#line 276
  if (tmp___8 != 0) {
#line 279
    spin_unlock_irq(& dev->srq_table.lock);
#line 280
    goto err_out_free_srq;
  } else {

  }
#line 282
  spin_unlock_irq(& dev->srq_table.lock);
#line 284
  mthca_free_mailbox(dev, mailbox);
#line 286
  srq->first_free = 0;
#line 287
  srq->last_free = srq->max + -1;
#line 289
  attr->max_wr = (u32 )(srq->max + -1);
#line 290
  attr->max_sge = (u32 )srq->max_gs;
#line 292
  return (0);
  err_out_free_srq: 
#line 295
  err = mthca_HW2SW_SRQ(dev, mailbox, srq->srqn);
#line 296
  if (err != 0) {
#line 297
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "HW2SW_SRQ failed (%d)\n",
             err);
  } else {

  }
  err_out_free_buf: ;
#line 300
  if ((unsigned long )pd->ibpd.uobject == (unsigned long )((struct ib_uobject *)0)) {
#line 301
    mthca_free_srq_buf(dev, srq);
  } else {

  }
  err_out_mailbox: 
#line 304
  mthca_free_mailbox(dev, mailbox);
  err_out_db: ;
#line 307
  if ((unsigned long )pd->ibpd.uobject == (unsigned long )((struct ib_uobject *)0)) {
#line 307
    tmp___9 = mthca_is_memfree(dev);
#line 307
    if (tmp___9 != 0) {
#line 308
      mthca_free_db(dev, 5, srq->db_index);
    } else {

    }
  } else {

  }
  err_out_icm: 
#line 311
  mthca_table_put(dev, dev->srq_table.table, srq->srqn);
  err_out: 
#line 314
  mthca_free(& dev->srq_table.alloc, (u32 )srq->srqn);
#line 316
  return (err);
}
}
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
__inline static int get_srq_refcount(struct mthca_dev *dev , struct mthca_srq *srq ) 
{ 
  int c ;

  {
#line 323
  spin_lock_irq(& dev->srq_table.lock);
#line 324
  c = srq->refcount;
#line 325
  spin_unlock_irq(& dev->srq_table.lock);
#line 327
  return (c);
}
}
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
void mthca_free_srq(struct mthca_dev *dev , struct mthca_srq *srq ) 
{ 
  struct mthca_mailbox *mailbox ;
  int err ;
  bool tmp ;
  int tmp___0 ;
  wait_queue_t __wait ;
  long __ret ;
  long __int ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 335
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 336
  tmp = IS_ERR((void const   *)mailbox);
#line 336
  if ((int )tmp) {
#line 337
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "No memory for mailbox to free SRQ.\n");
#line 338
    return;
  } else {

  }
#line 341
  err = mthca_HW2SW_SRQ(dev, mailbox, srq->srqn);
#line 342
  if (err != 0) {
#line 343
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "HW2SW_SRQ failed (%d)\n",
             err);
  } else {

  }
#line 345
  spin_lock_irq(& dev->srq_table.lock);
#line 346
  mthca_array_clear(& dev->srq_table.srq, srq->srqn & (dev->limits.num_srqs + -1));
#line 348
  srq->refcount = srq->refcount - 1;
#line 349
  spin_unlock_irq(& dev->srq_table.lock);
#line 351
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c",
                351, 0);
#line 351
  tmp___0 = get_srq_refcount(dev, srq);
#line 351
  if (tmp___0 == 0) {
#line 351
    goto ldv_30751;
  } else {

  }
#line 351
  __ret = 0L;
#line 351
  INIT_LIST_HEAD(& __wait.task_list);
#line 351
  __wait.flags = 0U;
  ldv_30757: 
#line 351
  tmp___1 = prepare_to_wait_event(& srq->wait, & __wait, 2);
#line 351
  __int = tmp___1;
#line 351
  tmp___2 = get_srq_refcount(dev, srq);
#line 351
  if (tmp___2 == 0) {
#line 351
    goto ldv_30756;
  } else {

  }
#line 351
  schedule();
#line 351
  goto ldv_30757;
  ldv_30756: 
#line 351
  finish_wait(& srq->wait, & __wait);

  ldv_30751: ;
#line 353
  if ((unsigned long )srq->ibsrq.uobject == (unsigned long )((struct ib_uobject *)0)) {
#line 354
    mthca_free_srq_buf(dev, srq);
#line 355
    tmp___3 = mthca_is_memfree(dev);
#line 355
    if (tmp___3 != 0) {
#line 356
      mthca_free_db(dev, 5, srq->db_index);
    } else {

    }
  } else {

  }
#line 359
  mthca_table_put(dev, dev->srq_table.table, srq->srqn);
#line 360
  mthca_free(& dev->srq_table.alloc, (u32 )srq->srqn);
#line 361
  mthca_free_mailbox(dev, mailbox);
#line 362
  return;
}
}
#line 364 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
int mthca_modify_srq(struct ib_srq *ibsrq , struct ib_srq_attr *attr , enum ib_srq_attr_mask attr_mask ,
                     struct ib_udata *udata ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_srq *srq ;
  struct mthca_srq *tmp___0 ;
  int ret ;
  u32 max_wr ;
  int tmp___1 ;

  {
#line 367
  tmp = to_mdev(ibsrq->device);
#line 367
  dev = tmp;
#line 368
  tmp___0 = to_msrq(ibsrq);
#line 368
  srq = tmp___0;
#line 369
  ret = 0;
#line 372
  if ((int )attr_mask & 1) {
#line 373
    return (-22);
  } else {

  }
#line 375
  if (((unsigned int )attr_mask & 2U) != 0U) {
#line 376
    tmp___1 = mthca_is_memfree(dev);
#line 376
    max_wr = (u32 )(tmp___1 != 0 ? srq->max + -1 : srq->max);
#line 377
    if (attr->srq_limit > max_wr) {
#line 378
      return (-22);
    } else {

    }
#line 380
    mutex_lock_nested(& srq->mutex, 0U);
#line 381
    ret = mthca_ARM_SRQ(dev, srq->srqn, (int )attr->srq_limit);
#line 382
    mutex_unlock(& srq->mutex);
  } else {

  }
#line 385
  return (ret);
}
}
#line 388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
int mthca_query_srq(struct ib_srq *ibsrq , struct ib_srq_attr *srq_attr ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_srq *srq ;
  struct mthca_srq *tmp___0 ;
  struct mthca_mailbox *mailbox ;
  struct mthca_arbel_srq_context *arbel_ctx ;
  struct mthca_tavor_srq_context *tavor_ctx ;
  int err ;
  long tmp___1 ;
  bool tmp___2 ;
  __u16 tmp___3 ;
  __u16 tmp___4 ;
  int tmp___5 ;

  {
#line 390
  tmp = to_mdev(ibsrq->device);
#line 390
  dev = tmp;
#line 391
  tmp___0 = to_msrq(ibsrq);
#line 391
  srq = tmp___0;
#line 397
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 398
  tmp___2 = IS_ERR((void const   *)mailbox);
#line 398
  if ((int )tmp___2) {
#line 399
    tmp___1 = PTR_ERR((void const   *)mailbox);
#line 399
    return ((int )tmp___1);
  } else {

  }
#line 401
  err = mthca_QUERY_SRQ(dev, (u32 )srq->srqn, mailbox);
#line 402
  if (err != 0) {
#line 403
    goto out;
  } else {

  }
#line 405
  tmp___5 = mthca_is_memfree(dev);
#line 405
  if (tmp___5 != 0) {
#line 406
    arbel_ctx = (struct mthca_arbel_srq_context *)mailbox->buf;
#line 407
    tmp___3 = __fswab16((int )arbel_ctx->limit_watermark);
#line 407
    srq_attr->srq_limit = (u32 )tmp___3;
  } else {
#line 409
    tavor_ctx = (struct mthca_tavor_srq_context *)mailbox->buf;
#line 410
    tmp___4 = __fswab16((int )tavor_ctx->limit_watermark);
#line 410
    srq_attr->srq_limit = (u32 )tmp___4;
  }
#line 413
  srq_attr->max_wr = (u32 )(srq->max + -1);
#line 414
  srq_attr->max_sge = (u32 )srq->max_gs;
  out: 
#line 417
  mthca_free_mailbox(dev, mailbox);
#line 419
  return (err);
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
void mthca_srq_event(struct mthca_dev *dev , u32 srqn , enum ib_event_type event_type ) 
{ 
  struct mthca_srq *srq ;
  struct ib_event event ;
  void *tmp ;

  {
#line 428
  spin_lock(& dev->srq_table.lock);
#line 429
  tmp = mthca_array_get(& dev->srq_table.srq, (int )((u32 )(dev->limits.num_srqs + -1) & srqn));
#line 429
  srq = (struct mthca_srq *)tmp;
#line 430
  if ((unsigned long )srq != (unsigned long )((struct mthca_srq *)0)) {
#line 431
    srq->refcount = srq->refcount + 1;
  } else {

  }
#line 432
  spin_unlock(& dev->srq_table.lock);
#line 434
  if ((unsigned long )srq == (unsigned long )((struct mthca_srq *)0)) {
#line 435
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Async event for bogus SRQ %08x\n",
             srqn);
#line 436
    return;
  } else {

  }
#line 439
  if ((unsigned long )srq->ibsrq.event_handler == (unsigned long )((void (*)(struct ib_event * ,
                                                                             void * ))0)) {
#line 440
    goto out;
  } else {

  }
#line 442
  event.device = & dev->ib_dev;
#line 443
  event.event = event_type;
#line 444
  event.element.srq = & srq->ibsrq;
#line 445
  (*(srq->ibsrq.event_handler))(& event, srq->ibsrq.srq_context);
  out: 
#line 448
  spin_lock(& dev->srq_table.lock);
#line 449
  srq->refcount = srq->refcount - 1;
#line 449
  if (srq->refcount == 0) {
#line 450
    __wake_up(& srq->wait, 3U, 1, (void *)0);
  } else {

  }
#line 451
  spin_unlock(& dev->srq_table.lock);
#line 452
  return;
}
}
#line 457 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
void mthca_free_srq_wqe(struct mthca_srq *srq , u32 wqe_addr ) 
{ 
  int ind ;
  struct mthca_next_seg *last_free ;
  void *tmp ;
  int *tmp___0 ;
  __u32 tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;

  {
#line 462
  ind = (int )(wqe_addr >> srq->wqe_shift);
#line 464
  spin_lock(& srq->lock);
#line 466
  tmp = get_wqe(srq, srq->last_free);
#line 466
  last_free = (struct mthca_next_seg *)tmp;
#line 467
  tmp___0 = wqe_to_link((void *)last_free);
#line 467
  *tmp___0 = ind;
#line 468
  tmp___1 = __fswab32((__u32 )((ind << srq->wqe_shift) | 1));
#line 468
  last_free->nda_op = tmp___1;
#line 469
  tmp___2 = get_wqe(srq, ind);
#line 469
  tmp___3 = wqe_to_link(tmp___2);
#line 469
  *tmp___3 = -1;
#line 470
  srq->last_free = ind;
#line 472
  spin_unlock(& srq->lock);
#line 473
  return;
}
}
#line 475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
int mthca_tavor_post_srq_recv(struct ib_srq *ibsrq , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_srq *srq ;
  struct mthca_srq *tmp___0 ;
  unsigned long flags ;
  int err ;
  int first_ind ;
  int ind ;
  int next_ind ;
  int nreq ;
  int i ;
  void *wqe ;
  void *prev_wqe ;
  raw_spinlock_t *tmp___1 ;
  int *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 478
  tmp = to_mdev(ibsrq->device);
#line 478
  dev = tmp;
#line 479
  tmp___0 = to_msrq(ibsrq);
#line 479
  srq = tmp___0;
#line 481
  err = 0;
#line 490
  tmp___1 = spinlock_check(& srq->lock);
#line 490
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 492
  first_ind = srq->first_free;
#line 494
  nreq = 0;
#line 494
  goto ldv_30818;
  ldv_30817: 
#line 495
  ind = srq->first_free;
#line 496
  wqe = get_wqe(srq, ind);
#line 497
  tmp___2 = wqe_to_link(wqe);
#line 497
  next_ind = *tmp___2;
#line 499
  tmp___3 = ldv__builtin_expect(next_ind < 0, 0L);
#line 499
  if (tmp___3 != 0L) {
#line 500
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "SRQ %06x full\n", srq->srqn);
#line 501
    err = -12;
#line 502
    *bad_wr = wr;
#line 503
    goto ldv_30813;
  } else {

  }
#line 506
  prev_wqe = srq->last;
#line 507
  srq->last = wqe;
#line 509
  ((struct mthca_next_seg *)wqe)->ee_nds = 0U;
#line 512
  wqe = wqe + 16UL;
#line 514
  tmp___4 = ldv__builtin_expect(wr->num_sge > srq->max_gs, 0L);
#line 514
  if (tmp___4 != 0L) {
#line 515
    err = -22;
#line 516
    *bad_wr = wr;
#line 517
    srq->last = prev_wqe;
#line 518
    goto ldv_30813;
  } else {

  }
#line 521
  i = 0;
#line 521
  goto ldv_30815;
  ldv_30814: 
#line 522
  mthca_set_data_seg((struct mthca_data_seg *)wqe, wr->sg_list + (unsigned long )i);
#line 523
  wqe = wqe + 16UL;
#line 521
  i = i + 1;
  ldv_30815: ;
#line 521
  if (wr->num_sge > i) {
#line 523
    goto ldv_30814;
  } else {

  }

#line 526
  if (srq->max_gs > i) {
#line 527
    mthca_set_data_seg_inval((struct mthca_data_seg *)wqe);
  } else {

  }
#line 529
  ((struct mthca_next_seg *)prev_wqe)->ee_nds = 2147483648U;
#line 532
  *(srq->wrid + (unsigned long )ind) = wr->wr_id;
#line 533
  srq->first_free = next_ind;
#line 535
  nreq = nreq + 1;
#line 536
  tmp___5 = ldv__builtin_expect(nreq == 256, 0L);
#line 536
  if (tmp___5 != 0L) {
#line 537
    nreq = 0;
#line 543
    __asm__  volatile   ("sfence": : : "memory");
#line 545
    mthca_write64((u32 )(first_ind << srq->wqe_shift), (u32 )(srq->srqn << 8), dev->kar + 24UL,
                  (spinlock_t *)0);
#line 549
    first_ind = srq->first_free;
  } else {

  }
#line 494
  wr = wr->next;
  ldv_30818: ;
#line 494
  if ((unsigned long )wr != (unsigned long )((struct ib_recv_wr *)0)) {
#line 496
    goto ldv_30817;
  } else {

  }
  ldv_30813: 
#line 553
  tmp___6 = ldv__builtin_expect(nreq != 0, 1L);
#line 553
  if (tmp___6 != 0L) {
#line 558
    __asm__  volatile   ("sfence": : : "memory");
#line 560
    mthca_write64((u32 )(first_ind << srq->wqe_shift), (u32 )((srq->srqn << 8) | nreq),
                  dev->kar + 24UL, (spinlock_t *)0);
  } else {

  }
#line 569
  __asm__  volatile   ("": : : "memory");
#line 571
  spin_unlock_irqrestore(& srq->lock, flags);
#line 572
  return (err);
}
}
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
int mthca_arbel_post_srq_recv(struct ib_srq *ibsrq , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_srq *srq ;
  struct mthca_srq *tmp___0 ;
  unsigned long flags ;
  int err ;
  int ind ;
  int next_ind ;
  int nreq ;
  int i ;
  void *wqe ;
  raw_spinlock_t *tmp___1 ;
  int *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  __u32 tmp___5 ;
  long tmp___6 ;

  {
#line 578
  tmp = to_mdev(ibsrq->device);
#line 578
  dev = tmp;
#line 579
  tmp___0 = to_msrq(ibsrq);
#line 579
  srq = tmp___0;
#line 581
  err = 0;
#line 588
  tmp___1 = spinlock_check(& srq->lock);
#line 588
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 590
  nreq = 0;
#line 590
  goto ldv_30841;
  ldv_30840: 
#line 591
  ind = srq->first_free;
#line 592
  wqe = get_wqe(srq, ind);
#line 593
  tmp___2 = wqe_to_link(wqe);
#line 593
  next_ind = *tmp___2;
#line 595
  tmp___3 = ldv__builtin_expect(next_ind < 0, 0L);
#line 595
  if (tmp___3 != 0L) {
#line 596
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "SRQ %06x full\n", srq->srqn);
#line 597
    err = -12;
#line 598
    *bad_wr = wr;
#line 599
    goto ldv_30836;
  } else {

  }
#line 602
  ((struct mthca_next_seg *)wqe)->ee_nds = 0U;
#line 605
  wqe = wqe + 16UL;
#line 607
  tmp___4 = ldv__builtin_expect(wr->num_sge > srq->max_gs, 0L);
#line 607
  if (tmp___4 != 0L) {
#line 608
    err = -22;
#line 609
    *bad_wr = wr;
#line 610
    goto ldv_30836;
  } else {

  }
#line 613
  i = 0;
#line 613
  goto ldv_30838;
  ldv_30837: 
#line 614
  mthca_set_data_seg((struct mthca_data_seg *)wqe, wr->sg_list + (unsigned long )i);
#line 615
  wqe = wqe + 16UL;
#line 613
  i = i + 1;
  ldv_30838: ;
#line 613
  if (wr->num_sge > i) {
#line 615
    goto ldv_30837;
  } else {

  }

#line 618
  if (srq->max_gs > i) {
#line 619
    mthca_set_data_seg_inval((struct mthca_data_seg *)wqe);
  } else {

  }
#line 621
  *(srq->wrid + (unsigned long )ind) = wr->wr_id;
#line 622
  srq->first_free = next_ind;
#line 590
  nreq = nreq + 1;
#line 590
  wr = wr->next;
  ldv_30841: ;
#line 590
  if ((unsigned long )wr != (unsigned long )((struct ib_recv_wr *)0)) {
#line 592
    goto ldv_30840;
  } else {

  }
  ldv_30836: 
#line 625
  tmp___6 = ldv__builtin_expect(nreq != 0, 1L);
#line 625
  if (tmp___6 != 0L) {
#line 626
    srq->counter = (int )srq->counter + (int )((u16 )nreq);
#line 632
    __asm__  volatile   ("sfence": : : "memory");
#line 633
    tmp___5 = __fswab32((__u32 )srq->counter);
#line 633
    *(srq->db) = tmp___5;
  } else {

  }
#line 636
  spin_unlock_irqrestore(& srq->lock, flags);
#line 637
  return (err);
}
}
#line 640 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
int mthca_max_srq_sge(struct mthca_dev *dev ) 
{ 
  int tmp ;
  int __min1 ;
  int __min2 ;
  int tmp___0 ;

  {
#line 642
  tmp = mthca_is_memfree(dev);
#line 642
  if (tmp != 0) {
#line 643
    return (dev->limits.max_sg);
  } else {

  }
#line 659
  __min1 = dev->limits.max_sg;
#line 659
  tmp___0 = fls(dev->limits.max_desc_sz);
#line 659
  __min2 = (int )(((unsigned long )(1 << (tmp___0 + -1)) - 16UL) / 16UL);
#line 659
  return (__min1 < __min2 ? __min1 : __min2);
}
}
#line 665 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
int mthca_init_srq_table(struct mthca_dev *dev ) 
{ 
  int err ;
  struct lock_class_key __key ;

  {
#line 669
  if ((dev->mthca_flags & 4UL) == 0UL) {
#line 670
    return (0);
  } else {

  }
#line 672
  spinlock_check(& dev->srq_table.lock);
#line 672
  __raw_spin_lock_init(& dev->srq_table.lock.__annonCompField18.rlock, "&(&dev->srq_table.lock)->rlock",
                       & __key);
#line 674
  err = mthca_alloc_init(& dev->srq_table.alloc, (u32 )dev->limits.num_srqs, (u32 )(dev->limits.num_srqs + -1),
                         (u32 )dev->limits.reserved_srqs);
#line 678
  if (err != 0) {
#line 679
    return (err);
  } else {

  }
#line 681
  err = mthca_array_init(& dev->srq_table.srq, dev->limits.num_srqs);
#line 683
  if (err != 0) {
#line 684
    mthca_alloc_cleanup(& dev->srq_table.alloc);
  } else {

  }
#line 686
  return (err);
}
}
#line 689 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.c"
void mthca_cleanup_srq_table(struct mthca_dev *dev ) 
{ 


  {
#line 691
  if ((dev->mthca_flags & 4UL) == 0UL) {
#line 692
    return;
  } else {

  }
#line 694
  mthca_array_cleanup(& dev->srq_table.srq, dev->limits.num_srqs);
#line 695
  mthca_alloc_cleanup(& dev->srq_table.alloc);
#line 696
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.o.c.prepared"
bool ldv_queue_work_on_233(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 83
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 83
  ldv_func_res = tmp;
#line 85
  activate_work_1(ldv_func_arg3, 2);
#line 87
  return (ldv_func_res);
}
}
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.o.c.prepared"
bool ldv_queue_delayed_work_on_234(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 94
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 94
  ldv_func_res = tmp;
#line 96
  activate_work_1(& ldv_func_arg3->work, 2);
#line 98
  return (ldv_func_res);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.o.c.prepared"
bool ldv_queue_work_on_235(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 105
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 105
  ldv_func_res = tmp;
#line 107
  activate_work_1(ldv_func_arg3, 2);
#line 109
  return (ldv_func_res);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.o.c.prepared"
void ldv_flush_workqueue_236(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 115
  flush_workqueue(ldv_func_arg1);
#line 117
  call_and_disable_all_1(2);
#line 118
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_srq.o.c.prepared"
bool ldv_queue_delayed_work_on_237(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 124
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 124
  ldv_func_res = tmp;
#line 126
  activate_work_1(& ldv_func_arg3->work, 2);
#line 128
  return (ldv_func_res);
}
}
#line 61 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 63
  __list_add(new, head, head->next);
#line 64
  return;
}
}
#line 113
extern void list_del(struct list_head * ) ;
#line 274 "include/linux/list.h"
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ 
  struct list_head *first ;
  struct list_head *last ;

  {
#line 278
  first = list->next;
#line 279
  last = list->prev;
#line 281
  first->prev = prev;
#line 282
  prev->next = first;
#line 284
  last->next = next;
#line 285
  next->prev = last;
#line 286
  return;
}
}
#line 319 "include/linux/list.h"
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ 
  int tmp ;

  {
#line 322
  tmp = list_empty((struct list_head  const  *)list);
#line 322
  if (tmp == 0) {
#line 323
    __list_splice((struct list_head  const  *)list, head, head->next);
#line 324
    INIT_LIST_HEAD(list);
  } else {

  }
#line 326
  return;
}
}
#line 170 "include/linux/timer.h"
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 173
int ldv_mod_timer_252(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 224
extern void add_timer(struct timer_list * ) ;
#line 229
extern int del_timer_sync(struct timer_list * ) ;
#line 232
int ldv_del_timer_sync_253(struct timer_list *ldv_func_arg1 ) ;
#line 252
extern unsigned long round_jiffies(unsigned long  ) ;
#line 181 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 361
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 421
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 424
void ldv_destroy_workqueue_254(struct workqueue_struct *ldv_func_arg1 ) ;
#line 437
bool ldv_queue_work_on_247(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 441
bool ldv_queue_work_on_249(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 447
bool ldv_queue_delayed_work_on_248(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 451
bool ldv_queue_delayed_work_on_251(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 459
void ldv_flush_workqueue_250(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_247(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
void call_and_disable_work_1(struct work_struct *work ) ;
#line 43
void choose_timer_2(struct timer_list *timer ) ;
#line 44
int reg_timer_2(struct timer_list *timer ) ;
#line 45
void disable_work_1(struct work_struct *work ) ;
#line 46
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 48
void disable_suitable_timer_2(struct timer_list *timer ) ;
#line 50
void invoke_work_1(void) ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.c"
static spinlock_t catas_lock  =    {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "catas_lock", 0, 0UL}}}};
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.c"
static struct list_head catas_list  =    {& catas_list, & catas_list};
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.c"
static struct workqueue_struct *catas_wq  ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.c"
static struct work_struct catas_work  ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.c"
static int catas_reset_disable  ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.c"
static void catas_reset(struct work_struct *work ) 
{ 
  struct mthca_dev *dev ;
  struct mthca_dev *tmpdev ;
  struct list_head tlist ;
  int ret ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct pci_dev *pdev ;
  char const   *tmp ;
  struct mthca_dev *d ;
  void *tmp___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 62
  tlist.next = & tlist;
#line 62
  tlist.prev = & tlist;
#line 65
  mutex_lock_nested(& mthca_device_mutex, 0U);
#line 67
  spin_lock_irq(& catas_lock);
#line 68
  list_splice_init(& catas_list, & tlist);
#line 69
  spin_unlock_irq(& catas_lock);
#line 71
  __mptr = (struct list_head  const  *)tlist.next;
#line 71
  dev = (struct mthca_dev *)__mptr + 0xffffffffffffe948UL;
#line 71
  __mptr___0 = (struct list_head  const  *)dev->catas_err.list.next;
#line 71
  tmpdev = (struct mthca_dev *)__mptr___0 + 0xffffffffffffe948UL;
#line 71
  goto ldv_30178;
  ldv_30177: 
#line 72
  pdev = dev->pdev;
#line 73
  ret = __mthca_restart_one(dev->pdev);
#line 75
  if (ret != 0) {
#line 76
    tmp = pci_name((struct pci_dev  const  *)pdev);
#line 76
    printk("\vmthca %s: Reset failed (%d)\n", tmp, ret);
  } else {
#line 79
    tmp___0 = pci_get_drvdata(pdev);
#line 79
    d = (struct mthca_dev *)tmp___0;
#line 80
    if (mthca_debug_level != 0) {
#line 80
      dev_printk("\017", (struct device  const  *)(& (d->pdev)->dev), "Reset succeeded\n");
    } else {

    }
  }
#line 71
  dev = tmpdev;
#line 71
  __mptr___1 = (struct list_head  const  *)tmpdev->catas_err.list.next;
#line 71
  tmpdev = (struct mthca_dev *)__mptr___1 + 0xffffffffffffe948UL;
  ldv_30178: ;
#line 71
  if ((unsigned long )(& dev->catas_err.list) != (unsigned long )(& tlist)) {
#line 73
    goto ldv_30177;
  } else {

  }
#line 84
  mutex_unlock(& mthca_device_mutex);
#line 85
  return;
}
}
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.c"
static void handle_catas(struct mthca_dev *dev ) 
{ 
  struct ib_event event ;
  unsigned long flags ;
  char const   *type ;
  int i ;
  unsigned int tmp ;
  __u32 tmp___0 ;
  unsigned int tmp___1 ;
  __u32 tmp___2 ;
  raw_spinlock_t *tmp___3 ;

  {
#line 94
  event.device = & dev->ib_dev;
#line 95
  event.event = 8;
#line 96
  event.element.port_num = 0U;
#line 97
  dev->active = 0;
#line 99
  ib_dispatch_event(& event);
#line 101
  tmp = readl((void const volatile   *)dev->catas_err.map);
#line 101
  tmp___0 = __fswab32(tmp);
#line 101
  switch (tmp___0 >> 24) {
  case 0U: 
#line 103
  type = "internal error";
#line 104
  goto ldv_30188;
  case 3U: 
#line 106
  type = "uplink bus error";
#line 107
  goto ldv_30188;
  case 4U: 
#line 109
  type = "DDR data error";
#line 110
  goto ldv_30188;
  case 5U: 
#line 112
  type = "internal parity error";
#line 113
  goto ldv_30188;
  default: 
#line 115
  type = "unknown error";
#line 116
  goto ldv_30188;
  }
  ldv_30188: 
#line 119
  dev_err((struct device  const  *)(& (dev->pdev)->dev), "Catastrophic error detected: %s\n",
          type);
#line 120
  i = 0;
#line 120
  goto ldv_30194;
  ldv_30193: 
#line 121
  tmp___1 = readl((void const volatile   *)dev->catas_err.map + (unsigned long )i);
#line 121
  tmp___2 = __fswab32(tmp___1);
#line 121
  dev_err((struct device  const  *)(& (dev->pdev)->dev), "  buf[%02x]: %08x\n", i,
          tmp___2);
#line 120
  i = i + 1;
  ldv_30194: ;
#line 120
  if ((u32 )i < dev->catas_err.size) {
#line 122
    goto ldv_30193;
  } else {

  }

#line 124
  if (catas_reset_disable != 0) {
#line 125
    return;
  } else {

  }
#line 127
  tmp___3 = spinlock_check(& catas_lock);
#line 127
  flags = _raw_spin_lock_irqsave(tmp___3);
#line 128
  list_add(& dev->catas_err.list, & catas_list);
#line 129
  queue_work(catas_wq, & catas_work);
#line 130
  spin_unlock_irqrestore(& catas_lock, flags);
#line 131
  return;
}
}
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.c"
static void poll_catas(unsigned long dev_ptr ) 
{ 
  struct mthca_dev *dev ;
  int i ;
  unsigned int tmp ;
  unsigned long tmp___0 ;

  {
#line 135
  dev = (struct mthca_dev *)dev_ptr;
#line 138
  i = 0;
#line 138
  goto ldv_30205;
  ldv_30204: 
#line 139
  tmp = readl((void const volatile   *)dev->catas_err.map + (unsigned long )i);
#line 139
  if (tmp != 0U) {
#line 140
    handle_catas(dev);
#line 141
    return;
  } else {

  }
#line 138
  i = i + 1;
  ldv_30205: ;
#line 138
  if ((u32 )i < dev->catas_err.size) {
#line 140
    goto ldv_30204;
  } else {

  }
#line 144
  tmp___0 = round_jiffies((unsigned long )jiffies + 1250UL);
#line 144
  ldv_mod_timer_252(& dev->catas_err.timer, tmp___0);
#line 146
  return;
}
}
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.c"
void mthca_start_catas_poll(struct mthca_dev *dev ) 
{ 
  phys_addr_t addr ;
  void *tmp ;

  {
#line 152
  reg_timer_2(& dev->catas_err.timer);
#line 153
  dev->catas_err.map = (u32 *)0U;
#line 155
  addr = (dev->pdev)->resource[0].start + (((dev->pdev)->resource[0].start != 0ULL || (dev->pdev)->resource[0].end != (dev->pdev)->resource[0].start ? (dev->pdev)->resource[0].end - (dev->pdev)->resource[0].start : 0xffffffffffffffffULL) & dev->catas_err.addr);
#line 159
  tmp = ioremap(addr, (unsigned long )(dev->catas_err.size * 4U));
#line 159
  dev->catas_err.map = (u32 *)tmp;
#line 160
  if ((unsigned long )dev->catas_err.map == (unsigned long )((u32 *)0U)) {
#line 161
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "couldn\'t map catastrophic error region at 0x%llx/0x%x\n",
             addr, dev->catas_err.size * 4U);
#line 164
    return;
  } else {

  }
#line 167
  dev->catas_err.timer.data = (unsigned long )dev;
#line 168
  dev->catas_err.timer.function = & poll_catas;
#line 169
  dev->catas_err.timer.expires = (unsigned long )jiffies + 1250UL;
#line 170
  INIT_LIST_HEAD(& dev->catas_err.list);
#line 171
  add_timer(& dev->catas_err.timer);
#line 172
  return;
}
}
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.c"
void mthca_stop_catas_poll(struct mthca_dev *dev ) 
{ 


  {
#line 176
  ldv_del_timer_sync_253(& dev->catas_err.timer);
#line 178
  if ((unsigned long )dev->catas_err.map != (unsigned long )((u32 *)0U)) {
#line 179
    iounmap((void volatile   *)dev->catas_err.map);
  } else {

  }
#line 181
  spin_lock_irq(& catas_lock);
#line 182
  list_del(& dev->catas_err.list);
#line 183
  spin_unlock_irq(& catas_lock);
#line 184
  return;
}
}
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.c"
int mthca_catas_init(void) 
{ 
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;

  {
#line 188
  __init_work(& catas_work, 0);
#line 188
  __constr_expr_0.counter = 137438953408L;
#line 188
  catas_work.data = __constr_expr_0;
#line 188
  lockdep_init_map(& catas_work.lockdep_map, "(&catas_work)", & __key, 0);
#line 188
  INIT_LIST_HEAD(& catas_work.entry);
#line 188
  catas_work.func = & catas_reset;
#line 190
  __lock_name = "\"%s\"\"mthca_catas\"";
#line 190
  tmp = __alloc_workqueue_key("%s", 131082U, 1, & __key___0, __lock_name, (char *)"mthca_catas");
#line 190
  catas_wq = tmp;
#line 191
  if ((unsigned long )catas_wq == (unsigned long )((struct workqueue_struct *)0)) {
#line 192
    return (-12);
  } else {

  }
#line 194
  return (0);
}
}
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.c"
void mthca_catas_cleanup(void) 
{ 


  {
#line 199
  ldv_destroy_workqueue_254(catas_wq);
#line 200
  return;
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
void call_and_disable_work_1(struct work_struct *work ) 
{ 


  {
#line 59
  if ((ldv_work_1_0 == 2 || ldv_work_1_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_0) {
#line 61
    catas_reset(work);
#line 62
    ldv_work_1_0 = 1;
#line 63
    return;
  } else {

  }
#line 65
  if ((ldv_work_1_1 == 2 || ldv_work_1_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_1) {
#line 67
    catas_reset(work);
#line 68
    ldv_work_1_1 = 1;
#line 69
    return;
  } else {

  }
#line 71
  if ((ldv_work_1_2 == 2 || ldv_work_1_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_2) {
#line 73
    catas_reset(work);
#line 74
    ldv_work_1_2 = 1;
#line 75
    return;
  } else {

  }
#line 77
  if ((ldv_work_1_3 == 2 || ldv_work_1_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_3) {
#line 79
    catas_reset(work);
#line 80
    ldv_work_1_3 = 1;
#line 81
    return;
  } else {

  }
#line 83
  return;
}
}
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
void choose_timer_2(struct timer_list *timer ) 
{ 


  {
#line 87
  LDV_IN_INTERRUPT = 2;
#line 88
  (*(timer->function))(timer->data);
#line 89
  LDV_IN_INTERRUPT = 1;
#line 90
  ldv_timer_state_2 = 2;
#line 91
  return;
}
}
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
int reg_timer_2(struct timer_list *timer ) 
{ 


  {
#line 95
  ldv_timer_list_2 = timer;
#line 96
  ldv_timer_state_2 = 1;
#line 97
  return (0);
}
}
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
void disable_work_1(struct work_struct *work ) 
{ 


  {
#line 102
  if ((ldv_work_1_0 == 3 || ldv_work_1_0 == 2) && (unsigned long )ldv_work_struct_1_0 == (unsigned long )work) {
#line 104
    ldv_work_1_0 = 1;
  } else {

  }
#line 106
  if ((ldv_work_1_1 == 3 || ldv_work_1_1 == 2) && (unsigned long )ldv_work_struct_1_1 == (unsigned long )work) {
#line 108
    ldv_work_1_1 = 1;
  } else {

  }
#line 110
  if ((ldv_work_1_2 == 3 || ldv_work_1_2 == 2) && (unsigned long )ldv_work_struct_1_2 == (unsigned long )work) {
#line 112
    ldv_work_1_2 = 1;
  } else {

  }
#line 114
  if ((ldv_work_1_3 == 3 || ldv_work_1_3 == 2) && (unsigned long )ldv_work_struct_1_3 == (unsigned long )work) {
#line 116
    ldv_work_1_3 = 1;
  } else {

  }
#line 117
  return;
}
}
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 121
  if ((unsigned long )ldv_timer_list_2 == (unsigned long )timer) {
#line 122
    if (ldv_timer_state_2 == 2 || pending_flag != 0) {
#line 123
      ldv_timer_list_2 = timer;
#line 124
      ldv_timer_list_2->data = data;
#line 125
      ldv_timer_state_2 = 1;
    } else {

    }
#line 127
    return;
  } else {

  }
#line 129
  reg_timer_2(timer);
#line 130
  ldv_timer_list_2->data = data;
#line 131
  return;
}
}
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
void work_init_1(void) 
{ 


  {
#line 135
  ldv_work_1_0 = 0;
#line 136
  ldv_work_1_1 = 0;
#line 137
  ldv_work_1_2 = 0;
#line 138
  ldv_work_1_3 = 0;
#line 139
  return;
}
}
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
void disable_suitable_timer_2(struct timer_list *timer ) 
{ 


  {
#line 143
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_2) {
#line 144
    ldv_timer_state_2 = 0;
#line 145
    return;
  } else {

  }
#line 147
  return;
}
}
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
void call_and_disable_all_1(int state ) 
{ 


  {
#line 152
  if (ldv_work_1_0 == state) {
#line 153
    call_and_disable_work_1(ldv_work_struct_1_0);
  } else {

  }
#line 154
  if (ldv_work_1_1 == state) {
#line 155
    call_and_disable_work_1(ldv_work_struct_1_1);
  } else {

  }
#line 156
  if (ldv_work_1_2 == state) {
#line 157
    call_and_disable_work_1(ldv_work_struct_1_2);
  } else {

  }
#line 158
  if (ldv_work_1_3 == state) {
#line 159
    call_and_disable_work_1(ldv_work_struct_1_3);
  } else {

  }
#line 160
  return;
}
}
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
void invoke_work_1(void) 
{ 
  int tmp ;

  {
#line 165
  tmp = __VERIFIER_nondet_int();
#line 165
  switch (tmp) {
  case 0: ;
#line 167
  if (ldv_work_1_0 == 2 || ldv_work_1_0 == 3) {
#line 168
    ldv_work_1_0 = 4;
#line 169
    catas_reset(ldv_work_struct_1_0);
#line 170
    ldv_work_1_0 = 1;
  } else {

  }
#line 173
  goto ldv_30259;
  case 1: ;
#line 175
  if (ldv_work_1_1 == 2 || ldv_work_1_1 == 3) {
#line 176
    ldv_work_1_1 = 4;
#line 177
    catas_reset(ldv_work_struct_1_0);
#line 178
    ldv_work_1_1 = 1;
  } else {

  }
#line 181
  goto ldv_30259;
  case 2: ;
#line 183
  if (ldv_work_1_2 == 2 || ldv_work_1_2 == 3) {
#line 184
    ldv_work_1_2 = 4;
#line 185
    catas_reset(ldv_work_struct_1_0);
#line 186
    ldv_work_1_2 = 1;
  } else {

  }
#line 189
  goto ldv_30259;
  case 3: ;
#line 191
  if (ldv_work_1_3 == 2 || ldv_work_1_3 == 3) {
#line 192
    ldv_work_1_3 = 4;
#line 193
    catas_reset(ldv_work_struct_1_0);
#line 194
    ldv_work_1_3 = 1;
  } else {

  }
#line 197
  goto ldv_30259;
  default: 
#line 198
  ldv_stop();
  }
  ldv_30259: ;
#line 200
  return;
}
}
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
void activate_work_1(struct work_struct *work , int state ) 
{ 


  {
#line 205
  if (ldv_work_1_0 == 0) {
#line 206
    ldv_work_struct_1_0 = work;
#line 207
    ldv_work_1_0 = state;
#line 208
    return;
  } else {

  }
#line 211
  if (ldv_work_1_1 == 0) {
#line 212
    ldv_work_struct_1_1 = work;
#line 213
    ldv_work_1_1 = state;
#line 214
    return;
  } else {

  }
#line 217
  if (ldv_work_1_2 == 0) {
#line 218
    ldv_work_struct_1_2 = work;
#line 219
    ldv_work_1_2 = state;
#line 220
    return;
  } else {

  }
#line 223
  if (ldv_work_1_3 == 0) {
#line 224
    ldv_work_struct_1_3 = work;
#line 225
    ldv_work_1_3 = state;
#line 226
    return;
  } else {

  }
#line 228
  return;
}
}
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
bool ldv_queue_work_on_247(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 258
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 258
  ldv_func_res = tmp;
#line 260
  activate_work_1(ldv_func_arg3, 2);
#line 262
  return (ldv_func_res);
}
}
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
bool ldv_queue_delayed_work_on_248(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 269
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 269
  ldv_func_res = tmp;
#line 271
  activate_work_1(& ldv_func_arg3->work, 2);
#line 273
  return (ldv_func_res);
}
}
#line 276 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
bool ldv_queue_work_on_249(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 280
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 280
  ldv_func_res = tmp;
#line 282
  activate_work_1(ldv_func_arg3, 2);
#line 284
  return (ldv_func_res);
}
}
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
void ldv_flush_workqueue_250(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 290
  flush_workqueue(ldv_func_arg1);
#line 292
  call_and_disable_all_1(2);
#line 293
  return;
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
bool ldv_queue_delayed_work_on_251(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 299
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 299
  ldv_func_res = tmp;
#line 301
  activate_work_1(& ldv_func_arg3->work, 2);
#line 303
  return (ldv_func_res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
int ldv_mod_timer_252(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 310
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 310
  ldv_func_res = tmp;
#line 312
  activate_pending_timer_2(ldv_func_arg1, ldv_func_arg2, 1);
#line 314
  return (ldv_func_res);
}
}
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
int ldv_del_timer_sync_253(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 321
  tmp = del_timer_sync(ldv_func_arg1);
#line 321
  ldv_func_res = tmp;
#line 323
  disable_suitable_timer_2(ldv_func_arg1);
#line 325
  return (ldv_func_res);
}
}
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/hw/mthca/mthca_catas.o.c.prepared"
void ldv_destroy_workqueue_254(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 331
  destroy_workqueue(ldv_func_arg1);
#line 333
  call_and_disable_all_1(2);
#line 334
  return;
}
}
#line 8 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *memset(void * , int  , size_t  ) ;
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 7 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_module_refcounter  =    1;
#line 10 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_get(struct module *module ) 
{ 


  {
#line 13
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 15
    ldv_module_refcounter = ldv_module_refcounter + 1;
  } else {

  }
#line 16
  return;
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_try_module_get(struct module *module ) 
{ 
  int module_get_succeeded ;

  {
#line 25
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 28
    module_get_succeeded = ldv_undef_int();
#line 30
    if (module_get_succeeded == 1) {
#line 32
      ldv_module_refcounter = ldv_module_refcounter + 1;
#line 34
      return (1);
    } else {
#line 39
      return (0);
    }
  } else {

  }
#line 41
  return (0);
}
}
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put(struct module *module ) 
{ 


  {
#line 48
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 50
    if (ldv_module_refcounter <= 1) {
#line 50
      ldv_error();
    } else {

    }
#line 52
    ldv_module_refcounter = ldv_module_refcounter - 1;
  } else {

  }
#line 54
  return;
}
}
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put_and_exit(void) 
{ 


  {
#line 59
  ldv_module_put((struct module *)1);
  LDV_STOP: ;
#line 61
  goto LDV_STOP;
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
unsigned int ldv_module_refcount(void) 
{ 


  {
#line 68
  return ((unsigned int )(ldv_module_refcounter + -1));
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4925/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 75
  if (ldv_module_refcounter != 1) {
#line 75
    ldv_error();
  } else {

  }
#line 79
  return;
}
}
