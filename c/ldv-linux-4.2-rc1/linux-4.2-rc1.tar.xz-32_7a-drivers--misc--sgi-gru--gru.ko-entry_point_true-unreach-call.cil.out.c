extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 687 "include/linux/list.h"
struct lockdep_map;
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_15 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 328 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_25 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_24 {
   struct __anonstruct____missing_field_name_25 __annonCompField11 ;
   struct __anonstruct____missing_field_name_26 __annonCompField12 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_24 __annonCompField13 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_27 __annonCompField14 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_31 __annonCompField16 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_30 __annonCompField17 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct vm_area_struct;
#line 15 "include/linux/mmdebug.h"
struct timespec;
#line 16
struct compat_timespec;
#line 17 "include/linux/mmdebug.h"
struct __anonstruct_futex_34 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 17 "include/linux/mmdebug.h"
struct __anonstruct_nanosleep_35 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 17
struct pollfd;
#line 17 "include/linux/mmdebug.h"
struct __anonstruct_poll_36 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 17 "include/linux/mmdebug.h"
union __anonunion____missing_field_name_33 {
   struct __anonstruct_futex_34 futex ;
   struct __anonstruct_nanosleep_35 nanosleep ;
   struct __anonstruct_poll_36 poll ;
};
#line 17 "include/linux/mmdebug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_33 __annonCompField18 ;
};
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 1170 "include/linux/wait.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_46 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_46 nodemask_t;
#line 357
enum node_states {
    N_POSSIBLE = 0,
    N_ONLINE = 1,
    N_NORMAL_MEMORY = 2,
    N_HIGH_MEMORY = 2,
    N_MEMORY = 3,
    N_CPU = 4,
    NR_NODE_STATES = 5
} ;
#line 90 "include/linux/mmzone.h"
struct free_area {
   struct list_head free_list[6U] ;
   unsigned long nr_free ;
};
#line 96
struct pglist_data;
#line 97 "include/linux/mmzone.h"
struct zone_padding {
   char x[0U] ;
};
#line 202 "include/linux/mmzone.h"
struct zone_reclaim_stat {
   unsigned long recent_rotated[2U] ;
   unsigned long recent_scanned[2U] ;
};
#line 215
struct zone;
#line 215 "include/linux/mmzone.h"
struct lruvec {
   struct list_head lists[5U] ;
   struct zone_reclaim_stat reclaim_stat ;
   struct zone *zone ;
};
#line 247 "include/linux/mmzone.h"
struct per_cpu_pages {
   int count ;
   int high ;
   int batch ;
   struct list_head lists[3U] ;
};
#line 260 "include/linux/mmzone.h"
struct per_cpu_pageset {
   struct per_cpu_pages pcp ;
   s8 expire ;
   s8 stat_threshold ;
   s8 vm_stat_diff[39U] ;
};
#line 270
enum zone_type {
    ZONE_DMA = 0,
    ZONE_DMA32 = 1,
    ZONE_NORMAL = 2,
    ZONE_MOVABLE = 3,
    __MAX_NR_ZONES = 4
} ;
#line 278 "include/linux/mmzone.h"
struct zone {
   unsigned long watermark[3U] ;
   long lowmem_reserve[4U] ;
   int node ;
   unsigned int inactive_ratio ;
   struct pglist_data *zone_pgdat ;
   struct per_cpu_pageset *pageset ;
   unsigned long dirty_balance_reserve ;
   unsigned long min_unmapped_pages ;
   unsigned long min_slab_pages ;
   unsigned long zone_start_pfn ;
   unsigned long managed_pages ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   char const   *name ;
   int nr_migrate_reserve_block ;
   unsigned long nr_isolate_pageblock ;
   seqlock_t span_seqlock ;
   wait_queue_head_t *wait_table ;
   unsigned long wait_table_hash_nr_entries ;
   unsigned long wait_table_bits ;
   struct zone_padding _pad1_ ;
   struct free_area free_area[11U] ;
   unsigned long flags ;
   spinlock_t lock ;
   struct zone_padding _pad2_ ;
   spinlock_t lru_lock ;
   struct lruvec lruvec ;
   atomic_long_t inactive_age ;
   unsigned long percpu_drift_mark ;
   unsigned long compact_cached_free_pfn ;
   unsigned long compact_cached_migrate_pfn[2U] ;
   unsigned int compact_considered ;
   unsigned int compact_defer_shift ;
   int compact_order_failed ;
   bool compact_blockskip_flush ;
   struct zone_padding _pad3_ ;
   atomic_long_t vm_stat[39U] ;
};
#line 567 "include/linux/mmzone.h"
struct zonelist_cache {
   unsigned short z_to_n[4096U] ;
   unsigned long fullzones[64U] ;
   unsigned long last_full_zap ;
};
#line 654 "include/linux/mmzone.h"
struct zoneref {
   struct zone *zone ;
   int zone_idx ;
};
#line 667 "include/linux/mmzone.h"
struct zonelist {
   struct zonelist_cache *zlcache_ptr ;
   struct zoneref _zonerefs[4097U] ;
   struct zonelist_cache zlcache ;
};
#line 705 "include/linux/mmzone.h"
struct pglist_data {
   struct zone node_zones[4U] ;
   struct zonelist node_zonelists[2U] ;
   int nr_zones ;
   spinlock_t node_size_lock ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   wait_queue_head_t kswapd_wait ;
   wait_queue_head_t pfmemalloc_wait ;
   struct task_struct *kswapd ;
   int kswapd_max_order ;
   enum zone_type classzone_idx ;
   spinlock_t numabalancing_migrate_lock ;
   unsigned long numabalancing_migrate_next_window ;
   unsigned long numabalancing_migrate_nr_pages ;
   unsigned long first_deferred_pfn ;
};
#line 773 "include/linux/mmzone.h"
typedef struct pglist_data pg_data_t;
#line 796
struct rw_semaphore;
#line 797 "include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 172 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 105 "include/linux/debugobjects.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 1121 "include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 238 "include/linux/timer.h"
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 240 "include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 838 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_113 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_113 mm_context_t;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 60 "include/linux/kmemleak.h"
struct kmem_cache;
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 33
struct inode;
#line 34
struct dentry;
#line 35
struct user_namespace;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_146 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_147 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_145 {
   struct __anonstruct____missing_field_name_146 __annonCompField33 ;
   struct __anonstruct____missing_field_name_147 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_145 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_148 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_154 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_152 {
   union __anonunion____missing_field_name_153 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_151 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_152 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_149 {
   union __anonunion____missing_field_name_150 __annonCompField37 ;
   union __anonunion____missing_field_name_151 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_157 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_156 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_157 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_158 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_148 __annonCompField36 ;
   struct __anonstruct____missing_field_name_149 __annonCompField42 ;
   union __anonunion____missing_field_name_155 __annonCompField45 ;
   union __anonunion____missing_field_name_158 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_159 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_159 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_161 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_161 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_162 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_162 kgid_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_163 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_163 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_165 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_166 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_167 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_170 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_169 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_170 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_171 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_172 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_164 {
   int _pad[28U] ;
   struct __anonstruct__kill_165 _kill ;
   struct __anonstruct__timer_166 _timer ;
   struct __anonstruct__rt_167 _rt ;
   struct __anonstruct__sigchld_168 _sigchld ;
   struct __anonstruct__sigfault_169 _sigfault ;
   struct __anonstruct__sigpoll_171 _sigpoll ;
   struct __anonstruct__sigsys_172 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_164 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct cred;
#line 38
struct key_type;
#line 42 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_179 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_180 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_182 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_181 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_182 __annonCompField49 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_183 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_185 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_184 {
   union __anonunion_payload_185 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_179 __annonCompField47 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_180 __annonCompField48 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_181 __annonCompField50 ;
   union __anonunion_type_data_183 type_data ;
   union __anonunion____missing_field_name_184 __annonCompField51 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369 "include/linux/cred.h"
union __anonunion____missing_field_name_186 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 369 "include/linux/cred.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_186 __annonCompField52 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 31
struct kernfs_node;
#line 32
struct kernfs_ops;
#line 33
struct kernfs_open_file;
#line 75 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270
struct kernfs_root;
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct mmu_notifier;
#line 135 "./arch/x86/include/uapi/asm/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
struct iattr;
#line 54
struct super_block;
#line 55
struct file_system_type;
#line 56
struct kernfs_open_node;
#line 57
struct kernfs_iattrs;
#line 80 "include/linux/elf.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_209 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_209 __annonCompField56 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_210 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_210 __annonCompField57 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 66
struct bdi_writeback;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 82 "include/linux/io.h"
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203
struct of_device_id;
#line 203
struct acpi_device_id;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 1273 "include/linux/device.h"
struct miscdevice {
   int minor ;
   char const   *name ;
   struct file_operations  const  *fops ;
   struct list_head list ;
   struct device *parent ;
   struct device *this_device ;
   struct attribute_group  const  **groups ;
   char const   *nodename ;
   umode_t mode ;
};
#line 82 "include/linux/miscdevice.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_228 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_227 {
   struct __anonstruct____missing_field_name_228 __annonCompField65 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_227 __annonCompField66 ;
};
#line 50 "include/linux/lockref.h"
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_230 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion____missing_field_name_229 {
   struct __anonstruct____missing_field_name_230 __annonCompField67 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_229 __annonCompField68 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_231 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_231 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_235 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_234 {
   struct __anonstruct____missing_field_name_235 __annonCompField69 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_234 __annonCompField70 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 47
struct block_device;
#line 60 "include/uapi/linux/fs.h"
struct export_operations;
#line 63
struct kiocb;
#line 64
struct poll_table_struct;
#line 65
struct kstatfs;
#line 66
struct swap_info_struct;
#line 67
struct iov_iter;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_239 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_239 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_240 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_240 __annonCompField72 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_243 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_244 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_245 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_243 __annonCompField73 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_244 __annonCompField74 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_245 __annonCompField75 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_246 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_246 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_248 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_247 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_248 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_247 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 55 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru.h"
struct gru_gseg_statistics {
   unsigned long fmm_tlbmiss ;
   unsigned long upm_tlbmiss ;
   unsigned long tlbdropin ;
   unsigned long context_stolen ;
   unsigned long reserved[10U] ;
};
#line 70 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grulib.h"
struct gru_create_context_req {
   unsigned long gseg ;
   unsigned int data_segment_bytes ;
   unsigned int control_blocks ;
   unsigned int maximum_thread_count ;
   unsigned int options ;
   unsigned char tlb_preload_count ;
};
#line 141 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grulib.h"
struct gru_config_info {
   int cpus ;
   int blades ;
   int nodes ;
   int chiplets ;
   int fill[16U] ;
};
#line 152 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grulib.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 580 "include/linux/memcontrol.h"
struct anon_vma {
   struct anon_vma *root ;
   struct rw_semaphore rwsem ;
   atomic_t refcount ;
   unsigned int degree ;
   struct anon_vma *parent ;
   struct rb_root rb_root ;
};
#line 254 "include/linux/rmap.h"
struct mmu_notifier_ops;
#line 255 "include/linux/rmap.h"
struct mmu_notifier_mm {
   struct hlist_head list ;
   spinlock_t lock ;
};
#line 26 "include/linux/mmu_notifier.h"
struct mmu_notifier_ops {
   void (*release)(struct mmu_notifier * , struct mm_struct * ) ;
   int (*clear_flush_young)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                            unsigned long  ) ;
   int (*test_young)(struct mmu_notifier * , struct mm_struct * , unsigned long  ) ;
   void (*change_pte)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                      pte_t  ) ;
   void (*invalidate_page)(struct mmu_notifier * , struct mm_struct * , unsigned long  ) ;
   void (*invalidate_range_start)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                                  unsigned long  ) ;
   void (*invalidate_range_end)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                                unsigned long  ) ;
   void (*invalidate_range)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                            unsigned long  ) ;
};
#line 170 "include/linux/mmu_notifier.h"
struct mmu_notifier {
   struct hlist_node hlist ;
   struct mmu_notifier_ops  const  *ops ;
};
#line 154 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
struct gru_stats_s;
#line 155
struct gru_blade_state;
#line 159 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
struct gru_stats_s {
   atomic_long_t vdata_alloc ;
   atomic_long_t vdata_free ;
   atomic_long_t gts_alloc ;
   atomic_long_t gts_free ;
   atomic_long_t gms_alloc ;
   atomic_long_t gms_free ;
   atomic_long_t gts_double_allocate ;
   atomic_long_t assign_context ;
   atomic_long_t assign_context_failed ;
   atomic_long_t free_context ;
   atomic_long_t load_user_context ;
   atomic_long_t load_kernel_context ;
   atomic_long_t lock_kernel_context ;
   atomic_long_t unlock_kernel_context ;
   atomic_long_t steal_user_context ;
   atomic_long_t steal_kernel_context ;
   atomic_long_t steal_context_failed ;
   atomic_long_t nopfn ;
   atomic_long_t asid_new ;
   atomic_long_t asid_next ;
   atomic_long_t asid_wrap ;
   atomic_long_t asid_reuse ;
   atomic_long_t intr ;
   atomic_long_t intr_cbr ;
   atomic_long_t intr_tfh ;
   atomic_long_t intr_spurious ;
   atomic_long_t intr_mm_lock_failed ;
   atomic_long_t call_os ;
   atomic_long_t call_os_wait_queue ;
   atomic_long_t user_flush_tlb ;
   atomic_long_t user_unload_context ;
   atomic_long_t user_exception ;
   atomic_long_t set_context_option ;
   atomic_long_t check_context_retarget_intr ;
   atomic_long_t check_context_unload ;
   atomic_long_t tlb_dropin ;
   atomic_long_t tlb_preload_page ;
   atomic_long_t tlb_dropin_fail_no_asid ;
   atomic_long_t tlb_dropin_fail_upm ;
   atomic_long_t tlb_dropin_fail_invalid ;
   atomic_long_t tlb_dropin_fail_range_active ;
   atomic_long_t tlb_dropin_fail_idle ;
   atomic_long_t tlb_dropin_fail_fmm ;
   atomic_long_t tlb_dropin_fail_no_exception ;
   atomic_long_t tfh_stale_on_fault ;
   atomic_long_t mmu_invalidate_range ;
   atomic_long_t mmu_invalidate_page ;
   atomic_long_t flush_tlb ;
   atomic_long_t flush_tlb_gru ;
   atomic_long_t flush_tlb_gru_tgh ;
   atomic_long_t flush_tlb_gru_zero_asid ;
   atomic_long_t copy_gpa ;
   atomic_long_t read_gpa ;
   atomic_long_t mesq_receive ;
   atomic_long_t mesq_receive_none ;
   atomic_long_t mesq_send ;
   atomic_long_t mesq_send_failed ;
   atomic_long_t mesq_noop ;
   atomic_long_t mesq_send_unexpected_error ;
   atomic_long_t mesq_send_lb_overflow ;
   atomic_long_t mesq_send_qlimit_reached ;
   atomic_long_t mesq_send_amo_nacked ;
   atomic_long_t mesq_send_put_nacked ;
   atomic_long_t mesq_page_overflow ;
   atomic_long_t mesq_qf_locked ;
   atomic_long_t mesq_qf_noop_not_full ;
   atomic_long_t mesq_qf_switch_head_failed ;
   atomic_long_t mesq_qf_unexpected_error ;
   atomic_long_t mesq_noop_unexpected_error ;
   atomic_long_t mesq_noop_lb_overflow ;
   atomic_long_t mesq_noop_qlimit_reached ;
   atomic_long_t mesq_noop_amo_nacked ;
   atomic_long_t mesq_noop_put_nacked ;
   atomic_long_t mesq_noop_page_overflow ;
};
#line 260
struct gru_state;
#line 261 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
struct gru_mm_tracker {
   unsigned int mt_asid_gen : 24 ;
   unsigned int mt_asid : 24 ;
   unsigned short mt_ctxbitmap ;
};
#line 318 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
struct gru_mm_struct {
   struct mmu_notifier ms_notifier ;
   atomic_t ms_refcnt ;
   spinlock_t ms_asid_lock ;
   atomic_t ms_range_active ;
   char ms_released ;
   wait_queue_head_t ms_wait_queue ;
   unsigned long ms_asidmap[32U] ;
   struct gru_mm_tracker ms_asids[2048U] ;
};
#line 330 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
struct gru_vma_data {
   spinlock_t vd_lock ;
   struct list_head vd_head ;
   long vd_user_options ;
   int vd_cbr_au_count ;
   int vd_dsr_au_count ;
   unsigned char vd_tlb_preload_count ;
};
#line 343 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
struct gru_thread_state {
   struct list_head ts_next ;
   struct mutex ts_ctxlock ;
   struct mm_struct *ts_mm ;
   struct vm_area_struct *ts_vma ;
   struct gru_state *ts_gru ;
   struct gru_mm_struct *ts_gms ;
   unsigned char ts_tlb_preload_count ;
   unsigned long ts_cbr_map ;
   unsigned long ts_dsr_map ;
   unsigned long ts_steal_jiffies ;
   long ts_user_options ;
   pid_t ts_tgid_owner ;
   short ts_user_blade_id ;
   char ts_user_chiplet_id ;
   unsigned short ts_sizeavail ;
   int ts_tsid ;
   int ts_tlb_int_select ;
   int ts_ctxnum ;
   atomic_t ts_refcnt ;
   unsigned char ts_dsr_au_count ;
   unsigned char ts_cbr_au_count ;
   char ts_cch_req_slice ;
   char ts_blade ;
   char ts_force_cch_reload ;
   char ts_cbr_idx[64U] ;
   int ts_data_valid ;
   struct gru_gseg_statistics ustats ;
   unsigned long ts_gdata[0U] ;
};
#line 391 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
struct gru_state {
   struct gru_blade_state *gs_blade ;
   unsigned long gs_gru_base_paddr ;
   void *gs_gru_base_vaddr ;
   unsigned short gs_gid ;
   unsigned short gs_blade_id ;
   unsigned char gs_chiplet_id ;
   unsigned char gs_tgh_local_shift ;
   unsigned char gs_tgh_first_remote ;
   spinlock_t gs_asid_lock ;
   spinlock_t gs_lock ;
   unsigned int gs_asid ;
   unsigned int gs_asid_limit ;
   unsigned int gs_asid_gen ;
   unsigned long gs_context_map ;
   unsigned long gs_cbr_map ;
   unsigned long gs_dsr_map ;
   unsigned int gs_reserved_cbrs ;
   unsigned int gs_reserved_dsr_bytes ;
   unsigned short gs_active_contexts ;
   struct gru_thread_state *gs_gts[16U] ;
   int gs_irq[16U] ;
};
#line 454 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
struct gru_blade_state {
   void *kernel_cb ;
   void *kernel_dsr ;
   struct rw_semaphore bs_kgts_sema ;
   struct gru_thread_state *bs_kgts ;
   int bs_async_dsr_bytes ;
   int bs_async_cbrs ;
   struct completion *bs_async_wq ;
   spinlock_t bs_lock ;
   int bs_lru_ctxnum ;
   struct gru_state *bs_lru_gru ;
   struct gru_state bs_grus[2U] ;
};
#line 2926 "./arch/x86/include/asm/uv/uv_mmrs.h"
struct uv_scir_s {
   struct timer_list timer ;
   unsigned long offset ;
   unsigned long last ;
   unsigned long idle_on ;
   unsigned long idle_off ;
   unsigned char state ;
   unsigned char enabled ;
};
#line 139 "./arch/x86/include/asm/uv/uv_hub.h"
struct uv_hub_info_s {
   unsigned long global_mmr_base ;
   unsigned long gpa_mask ;
   unsigned int gnode_extra ;
   unsigned char hub_revision ;
   unsigned char apic_pnode_shift ;
   unsigned char m_shift ;
   unsigned char n_lshift ;
   unsigned long gnode_upper ;
   unsigned long lowmem_remap_top ;
   unsigned long lowmem_remap_base ;
   unsigned short pnode ;
   unsigned short pnode_mask ;
   unsigned short coherency_domain_number ;
   unsigned short numa_blade_id ;
   unsigned char blade_processor_id ;
   unsigned char m_val ;
   unsigned char n_val ;
   struct uv_scir_s scir ;
};
#line 485 "./arch/x86/include/asm/uv/uv_hub.h"
struct uv_blade_info {
   unsigned short nr_possible_cpus ;
   unsigned short nr_online_cpus ;
   unsigned short pnode ;
   short memory_nid ;
   spinlock_t nmi_lock ;
   unsigned long nmi_count ;
};
#line 456 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
typedef int ldv_func_ret_type;
#line 507 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
typedef int ldv_func_ret_type___0;
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
typedef int ldv_func_ret_type___1;
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
typedef int ldv_func_ret_type___2;
#line 72 "./arch/x86/include/asm/preempt.h"
typedef int pao_T__;
#line 77 "./arch/x86/include/asm/preempt.h"
typedef int pao_T_____0;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 142 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
struct gru_context_configuration_handle;
#line 348 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
struct gru_context_configuration_handle {
   unsigned char cmd : 1 ;
   unsigned char delresp : 1 ;
   unsigned char opc : 3 ;
   unsigned char unmap_enable : 1 ;
   unsigned char req_slice_set_enable : 1 ;
   unsigned char req_slice : 2 ;
   unsigned char cb_int_enable : 1 ;
   unsigned char tlb_int_enable : 1 ;
   unsigned char tfm_fault_bit_enable : 1 ;
   unsigned char tlb_int_select : 4 ;
   unsigned char status : 2 ;
   unsigned char state : 2 ;
   unsigned char reserved2 : 4 ;
   unsigned char cause : 4 ;
   unsigned char tfm_done_bit_enable : 1 ;
   unsigned char unused : 3 ;
   unsigned int dsr_allocation_map ;
   unsigned long cbr_allocation_map ;
   unsigned int asid[8U] ;
   unsigned short sizeavail[8U] ;
};
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 13 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pmdval_t;
#line 14 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pudval_t;
#line 238 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pud_t_13 {
   pudval_t pud ;
};
#line 238 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pud_t_13 pud_t;
#line 259 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pmd_t_14 {
   pmdval_t pmd ;
};
#line 259 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pmd_t_14 pmd_t;
#line 428 "./arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 87 "./arch/x86/include/asm/paravirt_types.h"
struct pv_lazy_ops {
   void (*enter)(void) ;
   void (*leave)(void) ;
   void (*flush)(void) ;
};
#line 225 "./arch/x86/include/asm/paravirt_types.h"
struct pv_mmu_ops {
   unsigned long (*read_cr2)(void) ;
   void (*write_cr2)(unsigned long  ) ;
   unsigned long (*read_cr3)(void) ;
   void (*write_cr3)(unsigned long  ) ;
   void (*activate_mm)(struct mm_struct * , struct mm_struct * ) ;
   void (*dup_mmap)(struct mm_struct * , struct mm_struct * ) ;
   void (*exit_mmap)(struct mm_struct * ) ;
   void (*flush_tlb_user)(void) ;
   void (*flush_tlb_kernel)(void) ;
   void (*flush_tlb_single)(unsigned long  ) ;
   void (*flush_tlb_others)(struct cpumask  const  * , struct mm_struct * , unsigned long  ,
                            unsigned long  ) ;
   int (*pgd_alloc)(struct mm_struct * ) ;
   void (*pgd_free)(struct mm_struct * , pgd_t * ) ;
   void (*alloc_pte)(struct mm_struct * , unsigned long  ) ;
   void (*alloc_pmd)(struct mm_struct * , unsigned long  ) ;
   void (*alloc_pud)(struct mm_struct * , unsigned long  ) ;
   void (*release_pte)(unsigned long  ) ;
   void (*release_pmd)(unsigned long  ) ;
   void (*release_pud)(unsigned long  ) ;
   void (*set_pte)(pte_t * , pte_t  ) ;
   void (*set_pte_at)(struct mm_struct * , unsigned long  , pte_t * , pte_t  ) ;
   void (*set_pmd)(pmd_t * , pmd_t  ) ;
   void (*set_pmd_at)(struct mm_struct * , unsigned long  , pmd_t * , pmd_t  ) ;
   void (*pte_update)(struct mm_struct * , unsigned long  , pte_t * ) ;
   void (*pte_update_defer)(struct mm_struct * , unsigned long  , pte_t * ) ;
   void (*pmd_update)(struct mm_struct * , unsigned long  , pmd_t * ) ;
   void (*pmd_update_defer)(struct mm_struct * , unsigned long  , pmd_t * ) ;
   pte_t (*ptep_modify_prot_start)(struct mm_struct * , unsigned long  , pte_t * ) ;
   void (*ptep_modify_prot_commit)(struct mm_struct * , unsigned long  , pte_t * ,
                                   pte_t  ) ;
   struct paravirt_callee_save pte_val ;
   struct paravirt_callee_save make_pte ;
   struct paravirt_callee_save pgd_val ;
   struct paravirt_callee_save make_pgd ;
   void (*set_pud)(pud_t * , pud_t  ) ;
   struct paravirt_callee_save pmd_val ;
   struct paravirt_callee_save make_pmd ;
   struct paravirt_callee_save pud_val ;
   struct paravirt_callee_save make_pud ;
   void (*set_pgd)(pgd_t * , pgd_t  ) ;
   struct pv_lazy_ops lazy_mode ;
   void (*set_fixmap)(unsigned int  , phys_addr_t  , pgprot_t  ) ;
};
#line 12 "include/linux/wait.h"
struct __wait_queue;
#line 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 694 "include/linux/pagemap.h"
union __anonunion_v_244 {
   short preferred_node ;
   nodemask_t nodes ;
};
#line 694 "include/linux/pagemap.h"
union __anonunion_w_245 {
   nodemask_t cpuset_mems_allowed ;
   nodemask_t user_nodemask ;
};
#line 694 "include/linux/pagemap.h"
struct mempolicy {
   atomic_t refcnt ;
   unsigned short mode ;
   unsigned short flags ;
   union __anonunion_v_244 v ;
   union __anonunion_w_245 w ;
};
#line 375 "include/linux/mmu_notifier.h"
struct gru_get_gseg_statistics_req {
   unsigned long gseg ;
   struct gru_gseg_statistics stats ;
};
#line 82 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grulib.h"
struct gru_unload_context_req {
   unsigned long gseg ;
};
#line 95 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grulib.h"
struct gru_set_context_option_req {
   unsigned long gseg ;
   int op ;
   int val0 ;
   long val1 ;
};
#line 100 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grulib.h"
struct gru_flush_tlb_req {
   unsigned long gseg ;
   unsigned long vaddr ;
   size_t len ;
};
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
struct control_block_extended_exc_detail {
   unsigned long cb ;
   int opc ;
   int ecause ;
   int exopc ;
   long exceptdet0 ;
   int exceptdet1 ;
   int cbrstate ;
   int cbrexecstatus ;
};
#line 88 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
struct gru_instruction_bits {
   unsigned char icmd : 1 ;
   unsigned char ima : 3 ;
   unsigned char reserved0 : 4 ;
   unsigned char xtype : 3 ;
   unsigned char iaa0 : 2 ;
   unsigned char iaa1 : 2 ;
   unsigned char reserved1 : 1 ;
   unsigned char opc ;
   unsigned char exopc ;
   unsigned int idef2 : 22 ;
   unsigned char reserved2 : 2 ;
   unsigned char istatus : 2 ;
   unsigned char isubstatus : 4 ;
   unsigned char reserved3 : 1 ;
   unsigned char tlb_fault_color : 1 ;
   unsigned long idef4 ;
   unsigned long idef1 ;
   unsigned long idef5 ;
   unsigned long idef6 ;
   unsigned long idef3 ;
   unsigned long reserved4 ;
   unsigned long avalue ;
};
#line 118 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
struct gru_tlb_fault_map;
#line 130
struct gru_control_block_extended;
#line 136
struct gru_tlb_fault_handle;
#line 175 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
struct gru_tlb_fault_map {
   unsigned long fault_bits[2U] ;
   unsigned long fill0[2U] ;
   unsigned long done_bits[2U] ;
   unsigned long fill1[2U] ;
};
#line 264 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
struct gru_tlb_fault_handle {
   unsigned char cmd : 1 ;
   unsigned char delresp : 1 ;
   unsigned char fill0 : 2 ;
   unsigned char opc : 3 ;
   unsigned short fill1 : 9 ;
   unsigned char status : 2 ;
   unsigned char fill2 : 2 ;
   unsigned char state : 3 ;
   unsigned char fill3 : 1 ;
   unsigned char cause : 6 ;
   unsigned char cb_int : 1 ;
   unsigned char fill4 : 1 ;
   unsigned short indexway : 12 ;
   unsigned char fill5 : 4 ;
   unsigned char ctxnum : 4 ;
   unsigned short fill6 : 12 ;
   unsigned long missvaddr ;
   unsigned int missasid : 24 ;
   unsigned char fill7 ;
   unsigned int fillasid : 24 ;
   unsigned char dirty : 1 ;
   unsigned char gaa : 2 ;
   unsigned char fill8 : 5 ;
   unsigned long pfn : 41 ;
   unsigned char fill9 : 7 ;
   unsigned char pagesize : 5 ;
   unsigned short fill10 : 11 ;
   unsigned long fillvaddr ;
   unsigned long fill11[3U] ;
};
#line 427 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
struct gru_control_block_extended {
   unsigned char reserved0 : 1 ;
   unsigned char imacpy : 3 ;
   unsigned char reserved1 : 4 ;
   unsigned char xtypecpy : 3 ;
   unsigned char iaa0cpy : 2 ;
   unsigned char iaa1cpy : 2 ;
   unsigned char reserved2 : 1 ;
   unsigned char opccpy ;
   unsigned char exopccpy ;
   unsigned int idef2cpy : 22 ;
   unsigned short reserved3 : 10 ;
   unsigned int idef4cpy : 22 ;
   unsigned short reserved4 : 10 ;
   unsigned int idef4upd : 22 ;
   unsigned short reserved5 : 10 ;
   unsigned long idef1upd ;
   unsigned long idef5cpy ;
   unsigned long idef6cpy ;
   unsigned long idef3upd ;
   unsigned long idef5upd ;
   unsigned int idef2upd : 22 ;
   unsigned short reserved6 : 10 ;
   unsigned int ecause : 20 ;
   unsigned char cbrstate : 4 ;
   unsigned char cbrexecstatus ;
};
#line 43 "./arch/x86/include/asm/desc_defs.h"
struct gate_struct64 {
   u16 offset_low ;
   u16 segment ;
   unsigned char ist : 3 ;
   unsigned char zero0 : 5 ;
   unsigned char type : 5 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   u16 offset_middle ;
   u32 offset_high ;
   u32 zero1 ;
};
#line 81 "./arch/x86/include/asm/desc_defs.h"
typedef struct gate_struct64 gate_desc;
#line 84 "./arch/x86/include/asm/desc_defs.h"
struct desc_ptr {
   unsigned short size ;
   unsigned long address ;
};
#line 424 "./arch/x86/include/asm/pgtable_types.h"
struct tss_struct;
#line 102 "./arch/x86/include/asm/paravirt_types.h"
struct pv_cpu_ops {
   unsigned long (*get_debugreg)(int  ) ;
   void (*set_debugreg)(int  , unsigned long  ) ;
   void (*clts)(void) ;
   unsigned long (*read_cr0)(void) ;
   void (*write_cr0)(unsigned long  ) ;
   unsigned long (*read_cr4_safe)(void) ;
   unsigned long (*read_cr4)(void) ;
   void (*write_cr4)(unsigned long  ) ;
   unsigned long (*read_cr8)(void) ;
   void (*write_cr8)(unsigned long  ) ;
   void (*load_tr_desc)(void) ;
   void (*load_gdt)(struct desc_ptr  const  * ) ;
   void (*load_idt)(struct desc_ptr  const  * ) ;
   void (*store_idt)(struct desc_ptr * ) ;
   void (*set_ldt)(void const   * , unsigned int  ) ;
   unsigned long (*store_tr)(void) ;
   void (*load_tls)(struct thread_struct * , unsigned int  ) ;
   void (*load_gs_index)(unsigned int  ) ;
   void (*write_ldt_entry)(struct desc_struct * , int  , void const   * ) ;
   void (*write_gdt_entry)(struct desc_struct * , int  , void const   * , int  ) ;
   void (*write_idt_entry)(gate_desc * , int  , gate_desc const   * ) ;
   void (*alloc_ldt)(struct desc_struct * , unsigned int  ) ;
   void (*free_ldt)(struct desc_struct * , unsigned int  ) ;
   void (*load_sp0)(struct tss_struct * , struct thread_struct * ) ;
   void (*set_iopl_mask)(unsigned int  ) ;
   void (*wbinvd)(void) ;
   void (*io_delay)(void) ;
   void (*cpuid)(unsigned int * , unsigned int * , unsigned int * , unsigned int * ) ;
   u64 (*read_msr)(unsigned int  , int * ) ;
   int (*write_msr)(unsigned int  , unsigned int  , unsigned int  ) ;
   u64 (*read_tsc)(void) ;
   u64 (*read_pmc)(int  ) ;
   unsigned long long (*read_tscp)(unsigned int * ) ;
   void (*usergs_sysret64)(void) ;
   void (*usergs_sysret32)(void) ;
   void (*iret)(void) ;
   void (*swapgs)(void) ;
   void (*start_context_switch)(struct task_struct * ) ;
   void (*end_context_switch)(struct task_struct * ) ;
};
#line 213 "./arch/x86/include/asm/processor.h"
struct x86_hw_tss {
   u32 reserved1 ;
   u64 sp0 ;
   u64 sp1 ;
   u64 sp2 ;
   u64 reserved2 ;
   u64 ist[7U] ;
   u32 reserved3 ;
   u32 reserved4 ;
   u16 reserved5 ;
   u16 io_bitmap_base ;
};
#line 275 "./arch/x86/include/asm/processor.h"
struct tss_struct {
   struct x86_hw_tss x86_tss ;
   unsigned long io_bitmap[1025U] ;
   unsigned long SYSENTER_stack[64U] ;
};
#line 15 "./arch/x86/include/asm/tsc.h"
typedef unsigned long long cycles_t;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 124 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
struct gru_tlb_global_handle;
#line 190 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
struct gru_tlb_global_handle {
   unsigned char cmd : 1 ;
   unsigned char delresp : 1 ;
   unsigned char opc : 1 ;
   unsigned char fill1 : 5 ;
   unsigned char fill2 ;
   unsigned char status : 2 ;
   unsigned char fill3 : 2 ;
   unsigned char state : 3 ;
   unsigned char fill4 : 1 ;
   unsigned char cause : 3 ;
   unsigned long fill5 : 37 ;
   unsigned long vaddr ;
   unsigned int asid : 24 ;
   unsigned char fill6 ;
   unsigned char pagesize : 5 ;
   unsigned short fill7 : 11 ;
   unsigned char global : 1 ;
   unsigned short fill8 : 15 ;
   unsigned long vaddrmask : 39 ;
   unsigned short fill9 : 9 ;
   unsigned short n : 10 ;
   unsigned char fill10 : 6 ;
   unsigned short ctxbitmap ;
   unsigned long fill11[3U] ;
};
#line 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
union __anonunion___u_253 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
union __anonunion___u_255 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 3032 "include/linux/fs.h"
struct proc_dir_entry;
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
struct mcs_op_statistic {
   atomic_long_t count ;
   atomic_long_t total ;
   unsigned long max ;
};
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
struct proc_entry {
   char *name ;
   umode_t mode ;
   struct file_operations  const  *fops ;
   struct proc_dir_entry *entry ;
};
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 126 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
struct __anonstruct____missing_field_name_247 {
   unsigned int op32 ;
   unsigned int tri0 ;
};
#line 126 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
union __anonunion____missing_field_name_246 {
   unsigned long op64 ;
   struct __anonstruct____missing_field_name_247 __annonCompField75 ;
};
#line 126 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
struct gru_instruction {
   union __anonunion____missing_field_name_246 __annonCompField76 ;
   unsigned long tri1_bufsize ;
   unsigned long baddr0 ;
   unsigned long nelem ;
   unsigned long op1_stride ;
   unsigned long op2_value_baddr1 ;
   unsigned long reserved0 ;
   unsigned long avalue ;
};
#line 148 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
struct __anonstruct____missing_field_name_248 {
   unsigned int head ;
   unsigned int limit ;
};
#line 148 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
union gru_mesqhead {
   unsigned long val ;
   struct __anonstruct____missing_field_name_248 __annonCompField77 ;
};
#line 616 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
struct gru_control_block_status {
   unsigned char icmd : 1 ;
   unsigned char ima : 3 ;
   unsigned char reserved0 : 4 ;
   unsigned int unused1 : 24 ;
   unsigned int unused2 : 24 ;
   unsigned char istatus : 2 ;
   unsigned char isubstatus : 4 ;
   unsigned char unused3 : 2 ;
};
#line 677 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
struct gru_message_queue_desc {
   void *mq ;
   unsigned long mq_gpa ;
   int qlines ;
   int interrupt_vector ;
   int interrupt_pnode ;
   int interrupt_apicid ;
};
#line 678 "./arch/x86/include/asm/uv/uv_hub.h"
struct message_queue {
   union gru_mesqhead head ;
   int qlines ;
   long hstatus[2U] ;
   void *next ;
   void *limit ;
   void *start ;
   void *start2 ;
   char data ;
};
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
struct message_header {
   char present ;
   char present2 ;
   char lines ;
   char fill ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 247 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
enum mcs_op {
    cchop_allocate = 0,
    cchop_start = 1,
    cchop_interrupt = 2,
    cchop_interrupt_sync = 3,
    cchop_deallocate = 4,
    tfhop_write_only = 5,
    tfhop_write_restart = 6,
    tghop_invalidate = 7,
    mcsop_last = 8
} ;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 114 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grulib.h"
struct gru_dump_chiplet_state_req {
   unsigned int op ;
   unsigned int gid ;
   int ctxnum ;
   char data_opt ;
   char lock_cch ;
   char flush_cbrs ;
   char fill[10U] ;
   pid_t pid ;
   void *buf ;
   size_t buflen ;
   unsigned int num_contexts ;
};
#line 128 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grulib.h"
struct gru_dump_context_header {
   unsigned int magic ;
   unsigned int gid ;
   unsigned char ctxnum ;
   unsigned char cbrcnt ;
   unsigned char dsrcnt ;
   pid_t pid ;
   unsigned long vaddr ;
   int cch_locked ;
   unsigned long data[0U] ;
};
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 14 "include/asm-generic/bitops/find.h"
extern unsigned long find_next_bit(unsigned long const   * , unsigned long  , unsigned long  ) ;
#line 45 "./arch/x86/include/asm/arch_hweight.h"
__inline static unsigned long __arch_hweight64(__u64 w ) 
{ 
  unsigned long res ;

  {
#line 47
  res = 0UL;
#line 53
  __asm__  ("661:\n\tcall __sw_hweight64\n662:\n.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\n663:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6641f - .\n .word ( 4*32+23)\n .byte 663b-661b\n .byte 6651f-6641f\n .byte 663b-662b\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6641:\n\t.byte 0xf3,0x48,0x0f,0xb8,0xc7\n6651:\n\t.popsection": "=a" (res): "D" (w));
#line 58
  return (res);
}
}
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 248 "include/linux/kernel.h"
extern void __might_fault(char const   * , int  ) ;
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 295 "include/linux/percpu-defs.h"
extern void __bad_size_call_parameter(void) ;
#line 18 "include/asm-generic/percpu.h"
extern unsigned long __per_cpu_offset[8192U] ;
#line 554 "./arch/x86/include/asm/percpu.h"
extern unsigned long this_cpu_off ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_2696: ;
#line 14
  return (pfo_ret__);
}
}
#line 113 "include/linux/list.h"
extern void list_del(struct list_head * ) ;
#line 57 "./arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 112 "include/linux/bitmap.h"
extern int __bitmap_weight(unsigned long const   * , unsigned int  ) ;
#line 298 "include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , unsigned int nbits ) 
{ 
  int tmp___0 ;

  {
#line 302
  tmp___0 = __bitmap_weight(src, nbits);
#line 302
  return (tmp___0);
}
}
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 37 "include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 89
extern struct cpumask  const  * const  cpu_online_mask ;
#line 114 "include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 117
  __ret_warn_once = (unsigned int )nr_cpu_ids <= cpu;
#line 117
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 117
  if (tmp___1 != 0L) {
#line 117
    __ret_warn_on = ! __warned;
#line 117
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp != 0L) {
#line 117
      warn_slowpath_null("include/linux/cpumask.h", 117);
    } else {

    }
#line 117
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp___0 != 0L) {
#line 117
      __warned = 1;
    } else {

    }
  } else {

  }
#line 117
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 119
  return (cpu);
}
}
#line 184 "include/linux/cpumask.h"
__inline static unsigned int cpumask_next(int n , struct cpumask  const  *srcp ) 
{ 
  unsigned long tmp ;

  {
#line 187
  if (n != -1) {
#line 188
    cpumask_check((unsigned int )n);
  } else {

  }
#line 189
  tmp = find_next_bit((unsigned long const   *)(& srcp->bits), (unsigned long )nr_cpu_ids,
                      (unsigned long )(n + 1));
#line 189
  return ((unsigned int )tmp);
}
}
#line 474 "include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
#line 476
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), (unsigned int )nr_cpu_ids);
#line 476
  return ((unsigned int )tmp);
}
}
#line 84 "./arch/x86/include/asm/atomic64_64.h"
__inline static void atomic64_inc(atomic64_t *v ) 
{ 


  {
#line 86
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incq %0": "=m" (v->counter): "m" (v->counter));
#line 89
  return;
}
}
#line 41 "include/asm-generic/atomic-long.h"
__inline static void atomic_long_inc(atomic_long_t *l ) 
{ 
  atomic64_t *v ;

  {
#line 43
  v = l;
#line 45
  atomic64_inc(v);
#line 46
  return;
}
}
#line 173 "include/linux/mutex.h"
extern int mutex_trylock(struct mutex * ) ;
#line 176
int ldv_mutex_trylock_8(struct mutex *ldv_func_arg1 ) ;
#line 178
extern void mutex_unlock(struct mutex * ) ;
#line 181
void ldv_mutex_unlock_6(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_9(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_13(struct mutex *ldv_func_arg1 ) ;
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 18 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
extern void mutex_lock(struct mutex * ) ;
#line 21
void ldv_mutex_lock_5(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_7(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) ;
#line 42
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) ;
#line 51
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 55
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 64
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
#line 65
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
#line 68
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
#line 77
void ldv_mutex_lock_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) ;
#line 81
void ldv_mutex_unlock_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField17.rlock);
}
}
#line 226 "include/linux/nodemask.h"
__inline static int __nodes_weight(nodemask_t const   *srcp , unsigned int nbits ) 
{ 
  int tmp ;

  {
#line 228
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), nbits);
#line 228
  return (tmp);
}
}
#line 395
extern nodemask_t node_states[5U] ;
#line 413 "include/linux/nodemask.h"
__inline static int num_node_state(enum node_states state ) 
{ 
  int tmp ;

  {
#line 415
  tmp = __nodes_weight((nodemask_t const   *)(& node_states) + (unsigned long )state,
                       1024U);
#line 415
  return (tmp);
}
}
#line 84 "include/linux/rwsem.h"
extern void __init_rwsem(struct rw_semaphore * , char const   * , struct lock_class_key * ) ;
#line 118
extern void down_write(struct rw_semaphore * ) ;
#line 133
extern void up_write(struct rw_semaphore * ) ;
#line 158 "include/linux/memory_hotplug.h"
extern pg_data_t *node_data[] ;
#line 90 "./arch/x86/include/asm/io.h"
__inline static unsigned long readq(void const volatile   *addr ) 
{ 
  unsigned long ret ;

  {
#line 90
  __asm__  volatile   ("movq %1,%0": "=r" (ret): "m" (*((unsigned long volatile   *)addr)): "memory");
#line 90
  return (ret);
}
}
#line 38 "./arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 45
extern u16 x86_cpu_to_apicid ;
#line 71 "include/linux/topology.h"
extern int numa_node ;
#line 75 "include/linux/topology.h"
__inline static int numa_node_id(void) 
{ 
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 77
  __vpp_verify = (void const   *)0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  switch (4UL) {
  case 1UL: 
#line 77
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (numa_node));
#line 77
  goto ldv_13575;
  case 2UL: 
#line 77
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (numa_node));
#line 77
  goto ldv_13575;
  case 4UL: 
#line 77
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (numa_node));
#line 77
  goto ldv_13575;
  case 8UL: 
#line 77
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (numa_node));
#line 77
  goto ldv_13575;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_13575: 
#line 77
  pscr_ret__ = pfo_ret__;
#line 77
  goto ldv_13581;
  case 2UL: ;
#line 77
  switch (4UL) {
  case 1UL: 
#line 77
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (numa_node));
#line 77
  goto ldv_13585;
  case 2UL: 
#line 77
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (numa_node));
#line 77
  goto ldv_13585;
  case 4UL: 
#line 77
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (numa_node));
#line 77
  goto ldv_13585;
  case 8UL: 
#line 77
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (numa_node));
#line 77
  goto ldv_13585;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_13585: 
#line 77
  pscr_ret__ = pfo_ret_____0;
#line 77
  goto ldv_13581;
  case 4UL: ;
#line 77
  switch (4UL) {
  case 1UL: 
#line 77
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (numa_node));
#line 77
  goto ldv_13594;
  case 2UL: 
#line 77
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (numa_node));
#line 77
  goto ldv_13594;
  case 4UL: 
#line 77
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (numa_node));
#line 77
  goto ldv_13594;
  case 8UL: 
#line 77
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (numa_node));
#line 77
  goto ldv_13594;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_13594: 
#line 77
  pscr_ret__ = pfo_ret_____1;
#line 77
  goto ldv_13581;
  case 8UL: ;
#line 77
  switch (4UL) {
  case 1UL: 
#line 77
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (numa_node));
#line 77
  goto ldv_13603;
  case 2UL: 
#line 77
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (numa_node));
#line 77
  goto ldv_13603;
  case 4UL: 
#line 77
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (numa_node));
#line 77
  goto ldv_13603;
  case 8UL: 
#line 77
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (numa_node));
#line 77
  goto ldv_13603;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_13603: 
#line 77
  pscr_ret__ = pfo_ret_____2;
#line 77
  goto ldv_13581;
  default: 
#line 77
  __bad_size_call_parameter();
#line 77
  goto ldv_13581;
  }
  ldv_13581: ;
#line 77
  return (pscr_ret__);
}
}
#line 263 "include/linux/gfp.h"
__inline static int gfp_zonelist(gfp_t flags ) 
{ 
  long tmp ;

  {
#line 265
  tmp = ldv__builtin_expect((flags & 262144U) != 0U, 0L);
#line 265
  if (tmp != 0L) {
#line 266
    return (1);
  } else {

  }
#line 268
  return (0);
}
}
#line 280 "include/linux/gfp.h"
__inline static struct zonelist *node_zonelist(int nid , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 282
  tmp = gfp_zonelist(flags);
#line 282
  return ((struct zonelist *)(& (node_data[nid])->node_zonelists) + (unsigned long )tmp);
}
}
#line 293
extern struct page *__alloc_pages_nodemask(gfp_t  , unsigned int  , struct zonelist * ,
                                           nodemask_t * ) ;
#line 297 "include/linux/gfp.h"
__inline static struct page *__alloc_pages(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ) 
{ 
  struct page *tmp ;

  {
#line 300
  tmp = __alloc_pages_nodemask(gfp_mask, order, zonelist, (nodemask_t *)0);
#line 300
  return (tmp);
}
}
#line 303 "include/linux/gfp.h"
__inline static struct page *alloc_pages_node(int nid , gfp_t gfp_mask , unsigned int order ) 
{ 
  struct zonelist *tmp ;
  struct page *tmp___0 ;

  {
#line 307
  if (nid < 0) {
#line 308
    nid = numa_node_id();
  } else {

  }
#line 310
  tmp = node_zonelist(nid, gfp_mask);
#line 310
  tmp___0 = __alloc_pages(gfp_mask, order, tmp);
#line 310
  return (tmp___0);
}
}
#line 367
extern void free_pages(unsigned long  , unsigned int  ) ;
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_state_variable_8  ;
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_state_variable_10  ;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct inode *gru_fops_group1  ;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct file *mcs_statistics_fops_group2  ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
void *gru_seq_ops_group2  ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct mm_struct *gru_mmuops_group1  ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct file *cch_fops_group2  ;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_state_variable_6  ;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_state_variable_0  ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_state_variable_5  ;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
void *cch_seq_ops_group2  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct inode *cch_fops_group1  ;
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_state_variable_2  ;
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct inode *mcs_statistics_fops_group1  ;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct file *gru_fops_group2  ;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct inode *statistics_fops_group1  ;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct vm_area_struct *gru_vm_ops_group0  ;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct file *options_fops_group2  ;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct seq_file *gru_seq_ops_group1  ;
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
loff_t *cch_seq_ops_group3  ;
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_state_variable_9  ;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct seq_file *cch_seq_ops_group1  ;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
loff_t *gru_seq_ops_group3  ;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_state_variable_3  ;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct inode *options_fops_group1  ;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct file *statistics_fops_group2  ;
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ref_cnt  ;
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_state_variable_1  ;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_state_variable_7  ;
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_state_variable_4  ;
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
struct mmu_notifier *gru_mmuops_group0  ;
#line 108
void ldv_file_operations_3(void) ;
#line 109
void ldv_initialize_mmu_notifier_ops_8(void) ;
#line 114
void ldv_file_operations_10(void) ;
#line 117
void ldv_initialize_vm_operations_struct_9(void) ;
#line 924 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 926
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 69 "include/linux/miscdevice.h"
extern int misc_register(struct miscdevice * ) ;
#line 72
int ldv_misc_register_14(struct miscdevice *misc ) ;
#line 74
extern int misc_deregister(struct miscdevice * ) ;
#line 77
int ldv_misc_deregister_15(struct miscdevice *misc ) ;
#line 81
int ldv_misc_deregister_16(struct miscdevice *misc ) ;
#line 650 "./arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 652
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 672
extern void __copy_from_user_overflow(void) ;
#line 677
extern void __copy_to_user_overflow(void) ;
#line 693 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 695
  tmp = __builtin_object_size((void const   *)to, 0);
#line 695
  sz = (int )tmp;
#line 697
  __might_fault("./arch/x86/include/asm/uaccess.h", 697);
#line 717
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
#line 717
  if (tmp___0 != 0L) {
#line 718
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
#line 722
    __copy_from_user_overflow();
  }
#line 724
  return (n);
}
}
#line 728 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 730
  tmp = __builtin_object_size(from, 0);
#line 730
  sz = (int )tmp;
#line 732
  __might_fault("./arch/x86/include/asm/uaccess.h", 732);
#line 735
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
#line 735
  if (tmp___0 != 0L) {
#line 736
    n = _copy_to_user(to, from, (unsigned int )n);
  } else {
#line 740
    __copy_to_user_overflow();
  }
#line 742
  return (n);
}
}
#line 127 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 132 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 135
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 135
  return (tmp);
}
}
#line 146
extern void free_irq(unsigned int  , void * ) ;
#line 2648 "include/linux/fs.h"
extern loff_t noop_llseek(struct file * , loff_t  , int  ) ;
#line 35 "./arch/x86/include/asm/uv/uv_irq.h"
extern int uv_setup_irq(char * , int  , int  , unsigned long  , int  ) ;
#line 36
extern void uv_teardown_irq(unsigned int  ) ;
#line 12 "./arch/x86/include/asm/uv/uv.h"
extern int is_uv_system(void) ;
#line 156 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
__inline static unsigned long gru_chiplet_paddr(unsigned long paddr , int pnode ,
                                                int chiplet ) 
{ 


  {
#line 159
  return ((unsigned long )(pnode * 2 + chiplet) * 134217728UL + paddr);
}
}
#line 162 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
__inline static void *gru_chiplet_vaddr(void *vaddr , int pnode , int chiplet ) 
{ 


  {
#line 164
  return (vaddr + (unsigned long )(pnode * 2 + chiplet) * 134217728UL);
}
}
#line 154 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
struct gru_stats_s gru_stats  ;
#line 155 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
struct gru_blade_state *gru_base[1024U]  ;
#line 156 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
unsigned long gru_start_paddr  ;
#line 156 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
unsigned long gru_end_paddr  ;
#line 157 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
void *gru_start_vaddr  ;
#line 158 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
unsigned int gru_max_gids  ;
#line 626
struct vm_operations_struct  const  gru_vm_ops ;
#line 629
struct gru_vma_data *gru_alloc_vma_data(struct vm_area_struct *vma , int tsid ) ;
#line 638
void gru_unload_context(struct gru_thread_state *gts , int savestate ) ;
#line 640
void gts_drop(struct gru_thread_state *gts ) ;
#line 641
void gru_tgh_flush_init(struct gru_state *gru ) ;
#line 642
int gru_kservices_init(void) ;
#line 643
void gru_kservices_exit(void) ;
#line 644
irqreturn_t gru0_intr(int irq , void *dev_id ) ;
#line 645
irqreturn_t gru1_intr(int irq , void *dev_id ) ;
#line 646
irqreturn_t gru_intr_mblade(int irq , void *dev_id ) ;
#line 647
int gru_dump_chiplet_request(unsigned long arg ) ;
#line 648
long gru_get_gseg_statistics(unsigned long arg ) ;
#line 649
int gru_handle_user_call_os(unsigned long cb ) ;
#line 650
int gru_user_flush_tlb(unsigned long arg ) ;
#line 651
int gru_user_unload_context(unsigned long arg ) ;
#line 652
int gru_get_exception_detail(unsigned long arg ) ;
#line 653
int gru_set_context_option(unsigned long arg ) ;
#line 656
struct vm_area_struct *gru_find_vma(unsigned long vaddr ) ;
#line 658
int gru_proc_init(void) ;
#line 659
void gru_proc_exit(void) ;
#line 668
int gru_fault(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
#line 672
int gru_ktest(unsigned long arg ) ;
#line 676
unsigned long gru_options ;
#line 166 "./arch/x86/include/asm/uv/uv_hub.h"
extern struct uv_hub_info_s __uv_hub_info ;
#line 180 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static int is_uv1_hub(void) 
{ 
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;

  {
#line 182
  __vpp_verify = (void const   *)0;
#line 182
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off), "0" (& __uv_hub_info));
#line 182
  return ((unsigned int )((struct uv_hub_info_s *)tcp_ptr__)->hub_revision <= 2U);
}
}
#line 185 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static int is_uv2_hub(void) 
{ 
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;
  void const   *__vpp_verify___0 ;
  unsigned long tcp_ptr_____0 ;
  int tmp ;

  {
#line 187
  __vpp_verify = (void const   *)0;
#line 187
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off), "0" (& __uv_hub_info));
#line 188
  if ((unsigned int )((struct uv_hub_info_s *)tcp_ptr__)->hub_revision > 2U) {
#line 188
    __vpp_verify___0 = (void const   *)0;
#line 188
    __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____0): "m" (this_cpu_off),
                         "0" (& __uv_hub_info));
#line 188
    if ((unsigned int )((struct uv_hub_info_s *)tcp_ptr_____0)->hub_revision <= 4U) {
#line 188
      tmp = 1;
    } else {
#line 188
      tmp = 0;
    }
  } else {
#line 188
    tmp = 0;
  }
#line 187
  return (tmp);
}
}
#line 461 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static unsigned long *uv_local_mmr_address(unsigned long offset ) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 463
  tmp___1 = is_uv1_hub();
#line 463
  if (tmp___1 == 0) {
#line 463
    is_uv2_hub();
#line 463
    tmp___0 = 4194304000UL;
  } else {
#line 463
    tmp___0 = 4093640704UL;
  }
#line 463
  return ((unsigned long *)((tmp___0 | offset) + 0xffff880000000000UL));
}
}
#line 466 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static unsigned long uv_read_local_mmr(unsigned long offset ) 
{ 
  unsigned long *tmp ;
  unsigned long tmp___0 ;

  {
#line 468
  tmp = uv_local_mmr_address(offset);
#line 468
  tmp___0 = readq((void const volatile   *)tmp);
#line 468
  return (tmp___0);
}
}
#line 498
extern struct uv_blade_info *uv_blade_info ;
#line 499
extern short *uv_node_to_blade ;
#line 500
extern short *uv_cpu_to_blade ;
#line 501
extern short uv_possible_blades ;
#line 516 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_cpu_to_blade_id(int cpu ) 
{ 


  {
#line 518
  return ((int )*(uv_cpu_to_blade + (unsigned long )cpu));
}
}
#line 522 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_node_to_blade_id(int nid ) 
{ 


  {
#line 524
  return ((int )*(uv_node_to_blade + (unsigned long )nid));
}
}
#line 528 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_blade_to_pnode(int bid ) 
{ 


  {
#line 530
  return ((int )(uv_blade_info + (unsigned long )bid)->pnode);
}
}
#line 534 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_blade_to_memory_nid(int bid ) 
{ 


  {
#line 536
  return ((int )(uv_blade_info + (unsigned long )bid)->memory_nid);
}
}
#line 540 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_blade_nr_possible_cpus(int bid ) 
{ 


  {
#line 542
  return ((int )(uv_blade_info + (unsigned long )bid)->nr_possible_cpus);
}
}
#line 564 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_num_possible_blades(void) 
{ 


  {
#line 566
  return ((int )uv_possible_blades);
}
}
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static int max_user_cbrs  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static int max_user_dsr_bytes  ;
#line 59
static struct miscdevice gru_miscdev ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static int gru_supported(void) 
{ 
  int tmp ;
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;
  int tmp___0 ;

  {
#line 63
  tmp = is_uv_system();
#line 64
  if (tmp != 0) {
#line 64
    __vpp_verify = (void const   *)0;
#line 64
    __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off),
                         "0" (& __uv_hub_info));
#line 64
    if ((unsigned int )((struct uv_hub_info_s *)tcp_ptr__)->hub_revision <= 4U) {
#line 64
      tmp___0 = 1;
    } else {
#line 64
      tmp___0 = 0;
    }
  } else {
#line 64
    tmp___0 = 0;
  }
#line 63
  return (tmp___0);
}
}
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static void gru_vma_close(struct vm_area_struct *vma ) 
{ 
  struct gru_vma_data *vdata ;
  struct gru_thread_state *gts ;
  struct list_head *entry ;
  struct list_head *next ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct list_head  const  *__mptr ;

  {
#line 79
  if ((unsigned long )vma->vm_private_data == (unsigned long )((void *)0)) {
#line 80
    return;
  } else {

  }
#line 82
  vdata = (struct gru_vma_data *)vma->vm_private_data;
#line 83
  vma->vm_private_data = (void *)0;
#line 84
  if ((int )gru_options & 1) {
#line 84
    __vpp_verify = (void const   *)0;
#line 84
    switch (4UL) {
    case 1UL: ;
#line 85
    switch (4UL) {
    case 1UL: 
#line 85
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 85
    goto ldv_33196;
    case 2UL: 
#line 85
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 85
    goto ldv_33196;
    case 4UL: 
#line 85
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 85
    goto ldv_33196;
    case 8UL: 
#line 85
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 85
    goto ldv_33196;
    default: 
#line 85
    __bad_percpu_size();
    }
    ldv_33196: 
#line 85
    pscr_ret__ = pfo_ret__;
#line 85
    goto ldv_33202;
    case 2UL: ;
#line 85
    switch (4UL) {
    case 1UL: 
#line 85
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 85
    goto ldv_33206;
    case 2UL: 
#line 85
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 85
    goto ldv_33206;
    case 4UL: 
#line 85
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 85
    goto ldv_33206;
    case 8UL: 
#line 85
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 85
    goto ldv_33206;
    default: 
#line 85
    __bad_percpu_size();
    }
    ldv_33206: 
#line 85
    pscr_ret__ = pfo_ret_____0;
#line 85
    goto ldv_33202;
    case 4UL: ;
#line 85
    switch (4UL) {
    case 1UL: 
#line 85
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 85
    goto ldv_33215;
    case 2UL: 
#line 85
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 85
    goto ldv_33215;
    case 4UL: 
#line 85
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 85
    goto ldv_33215;
    case 8UL: 
#line 85
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 85
    goto ldv_33215;
    default: 
#line 85
    __bad_percpu_size();
    }
    ldv_33215: 
#line 85
    pscr_ret__ = pfo_ret_____1;
#line 85
    goto ldv_33202;
    case 8UL: ;
#line 85
    switch (4UL) {
    case 1UL: 
#line 85
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 85
    goto ldv_33224;
    case 2UL: 
#line 85
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 85
    goto ldv_33224;
    case 4UL: 
#line 85
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 85
    goto ldv_33224;
    case 8UL: 
#line 85
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 85
    goto ldv_33224;
    default: 
#line 85
    __bad_percpu_size();
    }
    ldv_33224: 
#line 85
    pscr_ret__ = pfo_ret_____2;
#line 85
    goto ldv_33202;
    default: 
#line 85
    __bad_size_call_parameter();
#line 85
    goto ldv_33202;
    }
    ldv_33202: 
#line 85
    printk("\017GRU:%d %s: vma %p, file %p, vdata %p\n", pscr_ret__, "gru_vma_close",
           vma, vma->vm_file, vdata);
  } else {

  }
#line 86
  entry = vdata->vd_head.next;
#line 86
  next = entry->next;
#line 86
  goto ldv_33236;
  ldv_33235: 
#line 88
  __mptr = (struct list_head  const  *)entry;
#line 88
  gts = (struct gru_thread_state *)__mptr;
#line 89
  list_del(& gts->ts_next);
#line 90
  ldv_mutex_lock_12(& gts->ts_ctxlock);
#line 91
  if ((unsigned long )gts->ts_gru != (unsigned long )((struct gru_state *)0)) {
#line 92
    gru_unload_context(gts, 0);
  } else {

  }
#line 93
  ldv_mutex_unlock_13(& gts->ts_ctxlock);
#line 94
  gts_drop(gts);
#line 86
  entry = next;
#line 86
  next = entry->next;
  ldv_33236: ;
#line 86
  if ((unsigned long )(& vdata->vd_head) != (unsigned long )entry) {
#line 88
    goto ldv_33235;
  } else {

  }
#line 96
  kfree((void const   *)vdata);
#line 97
  if ((gru_options & 2UL) != 0UL) {
#line 97
    atomic_long_inc(& gru_stats.vdata_free);
  } else {

  }
#line 98
  return;
}
}
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static int gru_file_mmap(struct file *file , struct vm_area_struct *vma ) 
{ 
  pgprot_t __constr_expr_0 ;
  struct gru_vma_data *tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 109
  if ((vma->vm_flags & 10UL) != 10UL) {
#line 110
    return (-1);
  } else {

  }
#line 112
  if ((vma->vm_start & 262143UL) != 0UL || (vma->vm_end & 262143UL) != 0UL) {
#line 114
    return (-22);
  } else {

  }
#line 116
  vma->vm_flags = vma->vm_flags | 67527680UL;
#line 118
  __constr_expr_0.pgprot = 0x8000000000000027UL;
#line 118
  vma->vm_page_prot = __constr_expr_0;
#line 119
  vma->vm_ops = & gru_vm_ops;
#line 121
  tmp = gru_alloc_vma_data(vma, 0);
#line 121
  vma->vm_private_data = (void *)tmp;
#line 122
  if ((unsigned long )vma->vm_private_data == (unsigned long )((void *)0)) {
#line 123
    return (-12);
  } else {

  }
#line 125
  if ((int )gru_options & 1) {
#line 125
    __vpp_verify = (void const   *)0;
#line 125
    switch (4UL) {
    case 1UL: ;
#line 126
    switch (4UL) {
    case 1UL: 
#line 126
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 126
    goto ldv_33248;
    case 2UL: 
#line 126
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 126
    goto ldv_33248;
    case 4UL: 
#line 126
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 126
    goto ldv_33248;
    case 8UL: 
#line 126
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 126
    goto ldv_33248;
    default: 
#line 126
    __bad_percpu_size();
    }
    ldv_33248: 
#line 126
    pscr_ret__ = pfo_ret__;
#line 126
    goto ldv_33254;
    case 2UL: ;
#line 126
    switch (4UL) {
    case 1UL: 
#line 126
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 126
    goto ldv_33258;
    case 2UL: 
#line 126
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 126
    goto ldv_33258;
    case 4UL: 
#line 126
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 126
    goto ldv_33258;
    case 8UL: 
#line 126
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 126
    goto ldv_33258;
    default: 
#line 126
    __bad_percpu_size();
    }
    ldv_33258: 
#line 126
    pscr_ret__ = pfo_ret_____0;
#line 126
    goto ldv_33254;
    case 4UL: ;
#line 126
    switch (4UL) {
    case 1UL: 
#line 126
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 126
    goto ldv_33267;
    case 2UL: 
#line 126
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 126
    goto ldv_33267;
    case 4UL: 
#line 126
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 126
    goto ldv_33267;
    case 8UL: 
#line 126
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 126
    goto ldv_33267;
    default: 
#line 126
    __bad_percpu_size();
    }
    ldv_33267: 
#line 126
    pscr_ret__ = pfo_ret_____1;
#line 126
    goto ldv_33254;
    case 8UL: ;
#line 126
    switch (4UL) {
    case 1UL: 
#line 126
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 126
    goto ldv_33276;
    case 2UL: 
#line 126
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 126
    goto ldv_33276;
    case 4UL: 
#line 126
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 126
    goto ldv_33276;
    case 8UL: 
#line 126
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 126
    goto ldv_33276;
    default: 
#line 126
    __bad_percpu_size();
    }
    ldv_33276: 
#line 126
    pscr_ret__ = pfo_ret_____2;
#line 126
    goto ldv_33254;
    default: 
#line 126
    __bad_size_call_parameter();
#line 126
    goto ldv_33254;
    }
    ldv_33254: 
#line 126
    printk("\017GRU:%d %s: file %p, vaddr 0x%lx, vma %p, vdata %p\n", pscr_ret__,
           "gru_file_mmap", file, vma->vm_start, vma, vma->vm_private_data);
  } else {

  }
#line 127
  return (0);
}
}
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static int gru_create_new_context(unsigned long arg ) 
{ 
  struct gru_create_context_req req ;
  struct vm_area_struct *vma ;
  struct gru_vma_data *vdata ;
  int ret ;
  unsigned long tmp ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;

  {
#line 138
  ret = -22;
#line 140
  tmp = copy_from_user((void *)(& req), (void const   *)arg, 32UL);
#line 140
  if (tmp != 0UL) {
#line 141
    return (-14);
  } else {

  }
#line 143
  if (req.data_segment_bytes > (unsigned int )max_user_dsr_bytes) {
#line 144
    return (-22);
  } else {

  }
#line 145
  if (req.control_blocks > (unsigned int )max_user_cbrs || req.maximum_thread_count == 0U) {
#line 146
    return (-22);
  } else {

  }
#line 148
  if ((req.options & 3U) == 0U) {
#line 149
    req.options = req.options | 2U;
  } else {

  }
#line 151
  tmp___0 = get_current();
#line 151
  down_write(& (tmp___0->mm)->mmap_sem);
#line 152
  vma = gru_find_vma(req.gseg);
#line 153
  if ((unsigned long )vma != (unsigned long )((struct vm_area_struct *)0)) {
#line 154
    vdata = (struct gru_vma_data *)vma->vm_private_data;
#line 155
    vdata->vd_user_options = (long )req.options;
#line 156
    vdata->vd_dsr_au_count = (int )((req.data_segment_bytes + 1023U) / 1024U);
#line 158
    vdata->vd_cbr_au_count = (int )((req.control_blocks + 1U) / 2U);
#line 159
    vdata->vd_tlb_preload_count = req.tlb_preload_count;
#line 160
    ret = 0;
  } else {

  }
#line 162
  tmp___1 = get_current();
#line 162
  up_write(& (tmp___1->mm)->mmap_sem);
#line 164
  return (ret);
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static long gru_get_config_info(unsigned long arg ) 
{ 
  struct gru_config_info info ;
  int nodesperblade ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 175
  tmp = num_node_state(1);
#line 175
  if (tmp > 1) {
#line 175
    tmp___0 = uv_node_to_blade_id(1);
#line 175
    tmp___1 = uv_node_to_blade_id(0);
#line 175
    if (tmp___0 == tmp___1) {
#line 177
      nodesperblade = 2;
    } else {
#line 179
      nodesperblade = 1;
    }
  } else {
#line 179
    nodesperblade = 1;
  }
#line 180
  memset((void *)(& info), 0, 80UL);
#line 181
  tmp___2 = cpumask_weight(cpu_online_mask);
#line 181
  info.cpus = (int )tmp___2;
#line 182
  info.nodes = num_node_state(1);
#line 183
  info.blades = info.nodes / nodesperblade;
#line 184
  info.chiplets = info.blades * 2;
#line 186
  tmp___3 = copy_to_user((void *)arg, (void const   *)(& info), 80UL);
#line 186
  if (tmp___3 != 0UL) {
#line 187
    return (-14L);
  } else {

  }
#line 188
  return (0L);
}
}
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static long gru_file_unlocked_ioctl(struct file *file , unsigned int req , unsigned long arg ) 
{ 
  int err ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  long tmp ;
  long tmp___0 ;

  {
#line 199
  err = -56;
#line 201
  if ((int )gru_options & 1) {
#line 201
    __vpp_verify = (void const   *)0;
#line 201
    switch (4UL) {
    case 1UL: ;
#line 201
    switch (4UL) {
    case 1UL: 
#line 201
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 201
    goto ldv_33308;
    case 2UL: 
#line 201
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 201
    goto ldv_33308;
    case 4UL: 
#line 201
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 201
    goto ldv_33308;
    case 8UL: 
#line 201
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 201
    goto ldv_33308;
    default: 
#line 201
    __bad_percpu_size();
    }
    ldv_33308: 
#line 201
    pscr_ret__ = pfo_ret__;
#line 201
    goto ldv_33314;
    case 2UL: ;
#line 201
    switch (4UL) {
    case 1UL: 
#line 201
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 201
    goto ldv_33318;
    case 2UL: 
#line 201
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 201
    goto ldv_33318;
    case 4UL: 
#line 201
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 201
    goto ldv_33318;
    case 8UL: 
#line 201
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 201
    goto ldv_33318;
    default: 
#line 201
    __bad_percpu_size();
    }
    ldv_33318: 
#line 201
    pscr_ret__ = pfo_ret_____0;
#line 201
    goto ldv_33314;
    case 4UL: ;
#line 201
    switch (4UL) {
    case 1UL: 
#line 201
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 201
    goto ldv_33327;
    case 2UL: 
#line 201
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 201
    goto ldv_33327;
    case 4UL: 
#line 201
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 201
    goto ldv_33327;
    case 8UL: 
#line 201
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 201
    goto ldv_33327;
    default: 
#line 201
    __bad_percpu_size();
    }
    ldv_33327: 
#line 201
    pscr_ret__ = pfo_ret_____1;
#line 201
    goto ldv_33314;
    case 8UL: ;
#line 201
    switch (4UL) {
    case 1UL: 
#line 201
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 201
    goto ldv_33336;
    case 2UL: 
#line 201
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 201
    goto ldv_33336;
    case 4UL: 
#line 201
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 201
    goto ldv_33336;
    case 8UL: 
#line 201
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 201
    goto ldv_33336;
    default: 
#line 201
    __bad_percpu_size();
    }
    ldv_33336: 
#line 201
    pscr_ret__ = pfo_ret_____2;
#line 201
    goto ldv_33314;
    default: 
#line 201
    __bad_size_call_parameter();
#line 201
    goto ldv_33314;
    }
    ldv_33314: 
#line 201
    printk("\017GRU:%d %s: file %p, req 0x%x, 0x%lx\n", pscr_ret__, "gru_file_unlocked_ioctl",
           file, req, arg);
  } else {

  }
#line 203
  switch (req) {
  case 3221767937U: 
#line 205
  err = gru_create_new_context(arg);
#line 206
  goto ldv_33346;
  case 3221767940U: 
#line 208
  err = gru_set_context_option(arg);
#line 209
  goto ldv_33346;
  case 3221767942U: 
#line 211
  err = gru_get_exception_detail(arg);
#line 212
  goto ldv_33346;
  case 3221767945U: 
#line 214
  err = gru_user_unload_context(arg);
#line 215
  goto ldv_33346;
  case 3221767986U: 
#line 217
  err = gru_user_flush_tlb(arg);
#line 218
  goto ldv_33346;
  case 3221767944U: 
#line 220
  err = gru_handle_user_call_os(arg);
#line 221
  goto ldv_33346;
  case 3221767948U: 
#line 223
  tmp = gru_get_gseg_statistics(arg);
#line 223
  err = (int )tmp;
#line 224
  goto ldv_33346;
  case 3221767988U: 
#line 226
  err = gru_ktest(arg);
#line 227
  goto ldv_33346;
  case 3221767987U: 
#line 229
  tmp___0 = gru_get_config_info(arg);
#line 229
  err = (int )tmp___0;
#line 230
  goto ldv_33346;
  case 3221767947U: 
#line 232
  err = gru_dump_chiplet_request(arg);
#line 233
  goto ldv_33346;
  }
  ldv_33346: ;
#line 235
  return ((long )err);
}
}
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static void gru_init_chiplet(struct gru_state *gru , unsigned long paddr , void *vaddr ,
                             int blade_id , int chiplet_id ) 
{ 
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 245
  spinlock_check(& gru->gs_lock);
#line 245
  __raw_spin_lock_init(& gru->gs_lock.__annonCompField17.rlock, "&(&gru->gs_lock)->rlock",
                       & __key);
#line 246
  spinlock_check(& gru->gs_asid_lock);
#line 246
  __raw_spin_lock_init(& gru->gs_asid_lock.__annonCompField17.rlock, "&(&gru->gs_asid_lock)->rlock",
                       & __key___0);
#line 247
  gru->gs_gru_base_paddr = paddr;
#line 248
  gru->gs_gru_base_vaddr = vaddr;
#line 249
  gru->gs_gid = (unsigned int )((unsigned short )blade_id) * 2U + (unsigned int )((unsigned short )chiplet_id);
#line 250
  gru->gs_blade = gru_base[blade_id];
#line 251
  gru->gs_blade_id = (unsigned short )blade_id;
#line 252
  gru->gs_chiplet_id = (unsigned char )chiplet_id;
#line 253
  gru->gs_cbr_map = 0xffffffffffffffffUL;
#line 254
  gru->gs_dsr_map = 4294967295UL;
#line 255
  gru->gs_asid_limit = 16777200U;
#line 256
  gru_tgh_flush_init(gru);
#line 257
  if ((unsigned int )gru->gs_gid >= gru_max_gids) {
#line 258
    gru_max_gids = (unsigned int )((int )gru->gs_gid + 1);
  } else {

  }
#line 259
  if ((int )gru_options & 1) {
#line 259
    __vpp_verify = (void const   *)0;
#line 259
    switch (4UL) {
    case 1UL: ;
#line 261
    switch (4UL) {
    case 1UL: 
#line 261
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 261
    goto ldv_33370;
    case 2UL: 
#line 261
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 261
    goto ldv_33370;
    case 4UL: 
#line 261
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 261
    goto ldv_33370;
    case 8UL: 
#line 261
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 261
    goto ldv_33370;
    default: 
#line 261
    __bad_percpu_size();
    }
    ldv_33370: 
#line 261
    pscr_ret__ = pfo_ret__;
#line 261
    goto ldv_33376;
    case 2UL: ;
#line 261
    switch (4UL) {
    case 1UL: 
#line 261
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 261
    goto ldv_33380;
    case 2UL: 
#line 261
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 261
    goto ldv_33380;
    case 4UL: 
#line 261
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 261
    goto ldv_33380;
    case 8UL: 
#line 261
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 261
    goto ldv_33380;
    default: 
#line 261
    __bad_percpu_size();
    }
    ldv_33380: 
#line 261
    pscr_ret__ = pfo_ret_____0;
#line 261
    goto ldv_33376;
    case 4UL: ;
#line 261
    switch (4UL) {
    case 1UL: 
#line 261
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 261
    goto ldv_33389;
    case 2UL: 
#line 261
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 261
    goto ldv_33389;
    case 4UL: 
#line 261
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 261
    goto ldv_33389;
    case 8UL: 
#line 261
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 261
    goto ldv_33389;
    default: 
#line 261
    __bad_percpu_size();
    }
    ldv_33389: 
#line 261
    pscr_ret__ = pfo_ret_____1;
#line 261
    goto ldv_33376;
    case 8UL: ;
#line 261
    switch (4UL) {
    case 1UL: 
#line 261
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 261
    goto ldv_33398;
    case 2UL: 
#line 261
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 261
    goto ldv_33398;
    case 4UL: 
#line 261
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 261
    goto ldv_33398;
    case 8UL: 
#line 261
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 261
    goto ldv_33398;
    default: 
#line 261
    __bad_percpu_size();
    }
    ldv_33398: 
#line 261
    pscr_ret__ = pfo_ret_____2;
#line 261
    goto ldv_33376;
    default: 
#line 261
    __bad_size_call_parameter();
#line 261
    goto ldv_33376;
    }
    ldv_33376: 
#line 261
    printk("\017GRU:%d %s: bid %d, gid %d, vaddr %p (0x%lx)\n", pscr_ret__, "gru_init_chiplet",
           blade_id, (int )gru->gs_gid, gru->gs_gru_base_vaddr, gru->gs_gru_base_paddr);
  } else {

  }
#line 262
  return;
}
}
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static int gru_init_tables(unsigned long gru_base_paddr , void *gru_base_vaddr ) 
{ 
  int pnode ;
  int nid ;
  int bid ;
  int chip ;
  int cbrs ;
  int dsrbytes ;
  int n ;
  int order ;
  struct page *page ;
  struct gru_state *gru ;
  unsigned long paddr ;
  void *vaddr ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  unsigned long tmp___0 ;
  int _max1 ;
  int _max2 ;
  unsigned long tmp___1 ;
  int _max1___0 ;
  int _max2___0 ;
  int _min1 ;
  int _min2 ;
  int _min1___0 ;
  int _min2___0 ;
  int tmp___2 ;

  {
#line 268
  order = 0;
#line 274
  max_user_cbrs = 128;
#line 275
  max_user_dsr_bytes = 32768;
#line 276
  bid = 0;
#line 276
  goto ldv_33442;
  ldv_33441: 
#line 277
  pnode = uv_blade_to_pnode(bid);
#line 278
  nid = uv_blade_to_memory_nid(bid);
#line 279
  page = alloc_pages_node(nid, 208U, (unsigned int )order);
#line 280
  if ((unsigned long )page == (unsigned long )((struct page *)0)) {
#line 281
    goto fail;
  } else {

  }
#line 282
  tmp = lowmem_page_address((struct page  const  *)page);
#line 282
  gru_base[bid] = (struct gru_blade_state *)tmp;
#line 283
  memset((void *)gru_base[bid], 0, 1136UL);
#line 284
  (gru_base[bid])->bs_lru_gru = (struct gru_state *)(& (gru_base[bid])->bs_grus);
#line 285
  spinlock_check(& (gru_base[bid])->bs_lock);
#line 285
  __raw_spin_lock_init(& (gru_base[bid])->bs_lock.__annonCompField17.rlock, "&(&gru_base[bid]->bs_lock)->rlock",
                       & __key);
#line 286
  __init_rwsem(& (gru_base[bid])->bs_kgts_sema, "&gru_base[bid]->bs_kgts_sema", & __key___0);
#line 288
  dsrbytes = 0;
#line 289
  cbrs = 0;
#line 290
  gru = (struct gru_state *)(& (gru_base[bid])->bs_grus);
#line 290
  chip = 0;
#line 290
  goto ldv_33433;
  ldv_33432: 
#line 293
  paddr = gru_chiplet_paddr(gru_base_paddr, pnode, chip);
#line 294
  vaddr = gru_chiplet_vaddr(gru_base_vaddr, pnode, chip);
#line 295
  gru_init_chiplet(gru, paddr, vaddr, bid, chip);
#line 296
  tmp___0 = __arch_hweight64((__u64 )gru->gs_cbr_map);
#line 296
  n = (int )((unsigned int )tmp___0 * 2U);
#line 297
  _max1 = cbrs;
#line 297
  _max2 = n;
#line 297
  cbrs = _max1 > _max2 ? _max1 : _max2;
#line 298
  tmp___1 = __arch_hweight64((__u64 )gru->gs_dsr_map);
#line 298
  n = (int )((unsigned int )tmp___1 * 1024U);
#line 299
  _max1___0 = dsrbytes;
#line 299
  _max2___0 = n;
#line 299
  dsrbytes = _max1___0 > _max2___0 ? _max1___0 : _max2___0;
#line 292
  chip = chip + 1;
#line 292
  gru = gru + 1;
  ldv_33433: ;
#line 290
  if (chip <= 1) {
#line 293
    goto ldv_33432;
  } else {

  }
#line 301
  _min1 = max_user_cbrs;
#line 301
  _min2 = cbrs;
#line 301
  max_user_cbrs = _min1 < _min2 ? _min1 : _min2;
#line 302
  _min1___0 = max_user_dsr_bytes;
#line 302
  _min2___0 = dsrbytes;
#line 302
  max_user_dsr_bytes = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 276
  bid = bid + 1;
  ldv_33442: 
#line 276
  tmp___2 = uv_num_possible_blades();
#line 276
  if (tmp___2 > bid) {
#line 278
    goto ldv_33441;
  } else {

  }

#line 305
  return (0);
  fail: 
#line 308
  bid = bid - 1;
#line 308
  goto ldv_33445;
  ldv_33444: 
#line 309
  free_pages((unsigned long )gru_base[bid], (unsigned int )order);
#line 308
  bid = bid - 1;
  ldv_33445: ;
#line 308
  if (bid >= 0) {
#line 310
    goto ldv_33444;
  } else {

  }

#line 310
  return (-12);
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static void gru_free_tables(void) 
{ 
  int bid ;
  int order ;

  {
#line 316
  order = 0;
#line 319
  bid = 0;
#line 319
  goto ldv_33453;
  ldv_33452: 
#line 320
  free_pages((unsigned long )gru_base[bid], (unsigned int )order);
#line 319
  bid = bid + 1;
  ldv_33453: ;
#line 319
  if (bid <= 1023) {
#line 321
    goto ldv_33452;
  } else {

  }

#line 326
  return;
}
}
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static unsigned long gru_chiplet_cpu_to_mmr(int chiplet , int cpu , int *corep ) 
{ 
  unsigned long mmr ;
  int core ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  void const   *__vpp_verify___0 ;
  unsigned long __ptr___0 ;
  void const   *__vpp_verify___1 ;
  unsigned long __ptr___1 ;
  void const   *__vpp_verify___2 ;
  unsigned long __ptr___2 ;

  {
#line 325
  mmr = 0UL;
#line 334
  __vpp_verify = (void const   *)0;
#line 334
  __asm__  ("": "=r" (__ptr): "0" (& x86_cpu_to_apicid));
#line 334
  __vpp_verify___0 = (void const   *)0;
#line 334
  __asm__  ("": "=r" (__ptr___0): "0" (& x86_cpu_to_apicid));
#line 334
  __vpp_verify___1 = (void const   *)0;
#line 334
  __asm__  ("": "=r" (__ptr___1): "0" (& x86_cpu_to_apicid));
#line 334
  core = ((((int )*((u16 *)(__per_cpu_offset[cpu] + __ptr)) >> 2) & 4) | (((int )*((u16 *)(__per_cpu_offset[cpu] + __ptr___0)) >> 1) & 3)) + (((int )*((u16 *)(__per_cpu_offset[cpu] + __ptr___1)) >> 5) & 1) * 8;
#line 335
  if (core > 15) {
#line 336
    return (0UL);
  } else {
#line 335
    __vpp_verify___2 = (void const   *)0;
#line 335
    __asm__  ("": "=r" (__ptr___2): "0" (& x86_cpu_to_apicid));
#line 335
    if ((int )*((u16 *)(__per_cpu_offset[cpu] + __ptr___2)) & 1) {
#line 336
      return (0UL);
    } else {

    }
  }
#line 338
  if (chiplet == 0) {
#line 339
    mmr = ((unsigned long )core + 6252UL) * 64UL;
  } else
#line 341
  if (chiplet == 1) {
#line 342
    mmr = ((unsigned long )core + 6268UL) * 64UL;
  } else {
#line 345
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"),
                         "i" (345), "i" (12UL));
    ldv_33478: ;
#line 345
    goto ldv_33478;
  }
#line 348
  *corep = core;
#line 349
  return (mmr);
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static int gru_chiplet_setup_tlb_irq(int chiplet , char *irq_name , irqreturn_t (*irq_handler)(int  ,
                                                                                               void * ) ,
                                     int cpu , int blade ) 
{ 
  unsigned long mmr ;
  int irq ;
  int core ;
  int ret ;

  {
#line 425
  mmr = gru_chiplet_cpu_to_mmr(chiplet, cpu, & core);
#line 426
  if (mmr == 0UL) {
#line 427
    return (0);
  } else {

  }
#line 429
  irq = uv_setup_irq(irq_name, cpu, blade, mmr, 2);
#line 430
  if (irq < 0) {
#line 431
    printk("\v%s: uv_setup_irq failed, errno=%d\n", (char *)"SGI GRU Device Driver",
           - irq);
#line 433
    return (irq);
  } else {

  }
#line 436
  ret = request_irq((unsigned int )irq, irq_handler, 0UL, (char const   *)irq_name,
                    (void *)0);
#line 437
  if (ret != 0) {
#line 438
    uv_teardown_irq((unsigned int )irq);
#line 439
    printk("\v%s: request_irq failed, errno=%d\n", (char *)"SGI GRU Device Driver",
           - ret);
#line 441
    return (ret);
  } else {

  }
#line 443
  (gru_base[blade])->bs_grus[chiplet].gs_irq[core] = irq;
#line 444
  return (0);
}
}
#line 447 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static void gru_chiplet_teardown_tlb_irq(int chiplet , int cpu , int blade ) 
{ 
  int irq ;
  int core ;
  unsigned long mmr ;

  {
#line 452
  mmr = gru_chiplet_cpu_to_mmr(chiplet, cpu, & core);
#line 453
  if (mmr != 0UL) {
#line 454
    irq = (gru_base[blade])->bs_grus[chiplet].gs_irq[core];
#line 455
    if (irq != 0) {
#line 456
      free_irq((unsigned int )irq, (void *)0);
#line 457
      uv_teardown_irq((unsigned int )irq);
    } else {

    }
  } else {

  }
#line 460
  return;
}
}
#line 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static void gru_teardown_tlb_irqs(void) 
{ 
  int blade ;
  int cpu ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 469
  cpu = -1;
#line 469
  goto ldv_33504;
  ldv_33503: 
#line 470
  blade = uv_cpu_to_blade_id(cpu);
#line 471
  gru_chiplet_teardown_tlb_irq(0, cpu, blade);
#line 472
  gru_chiplet_teardown_tlb_irq(1, cpu, blade);
  ldv_33504: 
#line 469
  tmp = cpumask_next(cpu, cpu_online_mask);
#line 469
  cpu = (int )tmp;
#line 469
  if (cpu < nr_cpu_ids) {
#line 471
    goto ldv_33503;
  } else {

  }
#line 474
  blade = 0;
#line 474
  goto ldv_33508;
  ldv_33507: 
#line 475
  tmp___0 = uv_blade_nr_possible_cpus(blade);
#line 475
  if (tmp___0 != 0) {
#line 476
    goto ldv_33506;
  } else {

  }
#line 477
  gru_chiplet_teardown_tlb_irq(0, 0, blade);
#line 478
  gru_chiplet_teardown_tlb_irq(1, 0, blade);
  ldv_33506: 
#line 474
  blade = blade + 1;
  ldv_33508: 
#line 474
  tmp___1 = uv_num_possible_blades();
#line 474
  if (tmp___1 > blade) {
#line 476
    goto ldv_33507;
  } else {

  }

#line 481
  return;
}
}
#line 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static int gru_setup_tlb_irqs(void) 
{ 
  int blade ;
  int cpu ;
  int ret ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 488
  cpu = -1;
#line 488
  goto ldv_33518;
  ldv_33517: 
#line 489
  blade = uv_cpu_to_blade_id(cpu);
#line 490
  ret = gru_chiplet_setup_tlb_irq(0, (char *)"GRU0_TLB", & gru0_intr, cpu, blade);
#line 491
  if (ret != 0) {
#line 492
    goto exit1;
  } else {

  }
#line 494
  ret = gru_chiplet_setup_tlb_irq(1, (char *)"GRU1_TLB", & gru1_intr, cpu, blade);
#line 495
  if (ret != 0) {
#line 496
    goto exit1;
  } else {

  }
  ldv_33518: 
#line 488
  tmp = cpumask_next(cpu, cpu_online_mask);
#line 488
  cpu = (int )tmp;
#line 488
  if (cpu < nr_cpu_ids) {
#line 490
    goto ldv_33517;
  } else {

  }
#line 498
  blade = 0;
#line 498
  goto ldv_33522;
  ldv_33521: 
#line 499
  tmp___0 = uv_blade_nr_possible_cpus(blade);
#line 499
  if (tmp___0 != 0) {
#line 500
    goto ldv_33520;
  } else {

  }
#line 501
  ret = gru_chiplet_setup_tlb_irq(0, (char *)"GRU0_TLB", & gru_intr_mblade, 0, blade);
#line 502
  if (ret != 0) {
#line 503
    goto exit1;
  } else {

  }
#line 505
  ret = gru_chiplet_setup_tlb_irq(1, (char *)"GRU1_TLB", & gru_intr_mblade, 0, blade);
#line 506
  if (ret != 0) {
#line 507
    goto exit1;
  } else {

  }
  ldv_33520: 
#line 498
  blade = blade + 1;
  ldv_33522: 
#line 498
  tmp___1 = uv_num_possible_blades();
#line 498
  if (tmp___1 > blade) {
#line 500
    goto ldv_33521;
  } else {

  }

#line 510
  return (0);
  exit1: 
#line 513
  gru_teardown_tlb_irqs();
#line 514
  return (ret);
}
}
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static int gru_init(void) 
{ 
  int ret ;
  int tmp ;
  unsigned long tmp___0 ;

  {
#line 526
  tmp = gru_supported();
#line 526
  if (tmp == 0) {
#line 527
    return (0);
  } else {

  }
#line 532
  tmp___0 = uv_read_local_mmr(23068688UL);
#line 532
  gru_start_paddr = tmp___0 & 140737488355327UL;
#line 535
  gru_start_vaddr = (void *)(gru_start_paddr + 0xffff880000000000UL);
#line 536
  gru_end_paddr = gru_start_paddr + 137438953472UL;
#line 537
  printk("\016GRU space: 0x%lx - 0x%lx\n", gru_start_paddr, gru_end_paddr);
#line 539
  ret = ldv_misc_register_14(& gru_miscdev);
#line 540
  if (ret != 0) {
#line 541
    printk("\v%s: misc_register failed\n", (char *)"SGI GRU Device Driver");
#line 543
    goto exit0;
  } else {

  }
#line 546
  ret = gru_proc_init();
#line 547
  if (ret != 0) {
#line 548
    printk("\v%s: proc init failed\n", (char *)"SGI GRU Device Driver");
#line 549
    goto exit1;
  } else {

  }
#line 552
  ret = gru_init_tables(gru_start_paddr, gru_start_vaddr);
#line 553
  if (ret != 0) {
#line 554
    printk("\v%s: init tables failed\n", (char *)"SGI GRU Device Driver");
#line 555
    goto exit2;
  } else {

  }
#line 558
  ret = gru_setup_tlb_irqs();
#line 559
  if (ret != 0) {
#line 560
    goto exit3;
  } else {

  }
#line 562
  gru_kservices_init();
#line 564
  printk("\016%s: v%s\n", (char *)"SGI GRU Device Driver", (char *)"0.85");
#line 566
  return (0);
  exit3: 
#line 569
  gru_free_tables();
  exit2: 
#line 571
  gru_proc_exit();
  exit1: 
#line 573
  ldv_misc_deregister_15(& gru_miscdev);
  exit0: ;
#line 575
  return (ret);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static void gru_exit(void) 
{ 
  int tmp ;

  {
#line 581
  tmp = gru_supported();
#line 581
  if (tmp == 0) {
#line 582
    return;
  } else {

  }
#line 584
  gru_teardown_tlb_irqs();
#line 585
  gru_kservices_exit();
#line 586
  gru_free_tables();
#line 587
  ldv_misc_deregister_16(& gru_miscdev);
#line 588
  gru_proc_exit();
#line 589
  return;
}
}
#line 591 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static struct file_operations  const  gru_fops  = 
#line 591
     {& __this_module, & noop_llseek, 0, 0, 0, 0, 0, 0, & gru_file_unlocked_ioctl, 0,
    & gru_file_mmap, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
static struct miscdevice gru_miscdev  = 
#line 598
     {255, "gru", & gru_fops, {0, 0}, 0, 0, 0, 0, (unsigned short)0};
#line 604 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.c"
struct vm_operations_struct  const  gru_vm_ops  = 
#line 604
     {0, & gru_vma_close, & gru_fault, 0, 0, 0, 0, 0, 0, 0, 0};
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
extern void ldv_initialize(void) ;
#line 121
void ldv_check_final_state(void) ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_retval_8  ;
#line 123
extern int ldv_open_10(void) ;
#line 124
extern int ldv_open_9(void) ;
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_retval_9  ;
#line 126
extern int ldv_release_10(void) ;
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
void ldv_file_operations_10(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 131
  tmp = ldv_init_zalloc(1000UL);
#line 131
  gru_fops_group1 = (struct inode *)tmp;
#line 132
  tmp___0 = ldv_init_zalloc(504UL);
#line 132
  gru_fops_group2 = (struct file *)tmp___0;
#line 133
  return;
}
}
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
void ldv_initialize_vm_operations_struct_9(void) 
{ 
  void *tmp ;

  {
#line 137
  tmp = ldv_init_zalloc(184UL);
#line 137
  gru_vm_ops_group0 = (struct vm_area_struct *)tmp;
#line 138
  return;
}
}
#line 141
void ldv_main_exported_6(void) ;
#line 142
void ldv_main_exported_4(void) ;
#line 143
void ldv_main_exported_1(void) ;
#line 144
void ldv_main_exported_3(void) ;
#line 145
void ldv_main_exported_7(void) ;
#line 146
void ldv_main_exported_2(void) ;
#line 147
void ldv_main_exported_5(void) ;
#line 151
void ldv_main_exported_8(void) ;
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
void main(void) 
{ 
  struct vm_fault *ldvarg8 ;
  void *tmp ;
  loff_t ldvarg35 ;
  unsigned long ldvarg32 ;
  struct vm_area_struct *ldvarg36 ;
  void *tmp___0 ;
  int ldvarg34 ;
  unsigned int ldvarg33 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 158
  tmp = ldv_init_zalloc(56UL);
#line 158
  ldvarg8 = (struct vm_fault *)tmp;
#line 161
  tmp___0 = ldv_init_zalloc(184UL);
#line 161
  ldvarg36 = (struct vm_area_struct *)tmp___0;
#line 156
  ldv_initialize();
#line 159
  ldv_memset((void *)(& ldvarg35), 0, 8UL);
#line 160
  ldv_memset((void *)(& ldvarg32), 0, 8UL);
#line 162
  ldv_memset((void *)(& ldvarg34), 0, 4UL);
#line 163
  ldv_memset((void *)(& ldvarg33), 0, 4UL);
#line 165
  ldv_state_variable_6 = 0;
#line 166
  ldv_state_variable_3 = 0;
#line 167
  ldv_state_variable_7 = 0;
#line 168
  ldv_state_variable_9 = 0;
#line 169
  ldv_state_variable_2 = 0;
#line 170
  ldv_state_variable_8 = 0;
#line 171
  ldv_state_variable_1 = 0;
#line 172
  ldv_state_variable_4 = 0;
#line 173
  ref_cnt = 0;
#line 174
  ldv_state_variable_0 = 1;
#line 175
  ldv_state_variable_10 = 0;
#line 176
  ldv_state_variable_5 = 0;
  ldv_33652: 
#line 178
  tmp___1 = __VERIFIER_nondet_int();
#line 178
  switch (tmp___1) {
  case 0: ;
#line 182
  if (ldv_state_variable_6 != 0) {
#line 183
    ldv_main_exported_6();
  } else {

  }
#line 186
  goto ldv_33623;
  case 1: ;
#line 190
  if (ldv_state_variable_3 != 0) {
#line 191
    ldv_main_exported_3();
  } else {

  }
#line 194
  goto ldv_33623;
  case 2: ;
#line 198
  if (ldv_state_variable_7 != 0) {
#line 199
    ldv_main_exported_7();
  } else {

  }
#line 202
  goto ldv_33623;
  case 3: ;
#line 206
  if (ldv_state_variable_9 != 0) {
#line 207
    tmp___2 = __VERIFIER_nondet_int();
#line 207
    switch (tmp___2) {
    case 0: ;
#line 210
    if (ldv_state_variable_9 == 1) {
#line 212
      gru_fault(gru_vm_ops_group0, ldvarg8);
#line 214
      ldv_state_variable_9 = 1;
    } else {

    }
#line 217
    if (ldv_state_variable_9 == 2) {
#line 219
      gru_fault(gru_vm_ops_group0, ldvarg8);
#line 221
      ldv_state_variable_9 = 2;
    } else {

    }
#line 224
    goto ldv_33628;
    case 1: ;
#line 227
    if (ldv_state_variable_9 == 2) {
#line 229
      gru_vma_close(gru_vm_ops_group0);
#line 230
      ldv_state_variable_9 = 1;
    } else {

    }
#line 233
    goto ldv_33628;
    case 2: ;
#line 236
    if (ldv_state_variable_9 == 1) {
#line 238
      ldv_open_9();
#line 239
      ldv_state_variable_9 = 2;
#line 240
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 243
    goto ldv_33628;
    default: 
#line 244
    ldv_stop();
    }
    ldv_33628: ;
  } else {

  }
#line 248
  goto ldv_33623;
  case 4: ;
#line 252
  if (ldv_state_variable_2 != 0) {
#line 253
    ldv_main_exported_2();
  } else {

  }
#line 256
  goto ldv_33623;
  case 5: ;
#line 260
  if (ldv_state_variable_8 != 0) {
#line 261
    ldv_main_exported_8();
  } else {

  }
#line 264
  goto ldv_33623;
  case 6: ;
#line 268
  if (ldv_state_variable_1 != 0) {
#line 269
    ldv_main_exported_1();
  } else {

  }
#line 272
  goto ldv_33623;
  case 7: ;
#line 276
  if (ldv_state_variable_4 != 0) {
#line 277
    ldv_main_exported_4();
  } else {

  }
#line 280
  goto ldv_33623;
  case 8: ;
#line 284
  if (ldv_state_variable_0 != 0) {
#line 285
    tmp___3 = __VERIFIER_nondet_int();
#line 285
    switch (tmp___3) {
    case 0: ;
#line 288
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
#line 290
      gru_exit();
#line 291
      ldv_state_variable_0 = 3;
#line 292
      goto ldv_final;
    } else {

    }
#line 295
    goto ldv_33639;
    case 1: ;
#line 298
    if (ldv_state_variable_0 == 1) {
#line 300
      ldv_retval_8 = gru_init();
#line 301
      if (ldv_retval_8 != 0) {
#line 302
        ldv_state_variable_0 = 3;
#line 303
        goto ldv_final;
      } else {

      }
#line 306
      if (ldv_retval_8 == 0) {
#line 307
        ldv_state_variable_0 = 2;
#line 308
        ldv_state_variable_9 = 1;
#line 309
        ldv_initialize_vm_operations_struct_9();
#line 310
        ldv_state_variable_8 = 1;
#line 311
        ldv_initialize_mmu_notifier_ops_8();
      } else {

      }
    } else {

    }
#line 315
    goto ldv_33639;
    default: 
#line 316
    ldv_stop();
    }
    ldv_33639: ;
  } else {

  }
#line 320
  goto ldv_33623;
  case 9: ;
#line 324
  if (ldv_state_variable_10 != 0) {
#line 325
    tmp___4 = __VERIFIER_nondet_int();
#line 325
    switch (tmp___4) {
    case 0: ;
#line 328
    if (ldv_state_variable_10 == 1) {
#line 330
      gru_file_mmap(gru_fops_group2, ldvarg36);
#line 332
      ldv_state_variable_10 = 1;
    } else {

    }
#line 335
    if (ldv_state_variable_10 == 2) {
#line 337
      gru_file_mmap(gru_fops_group2, ldvarg36);
#line 339
      ldv_state_variable_10 = 2;
    } else {

    }
#line 342
    goto ldv_33644;
    case 1: ;
#line 345
    if (ldv_state_variable_10 == 2) {
#line 347
      noop_llseek(gru_fops_group2, ldvarg35, ldvarg34);
#line 349
      ldv_state_variable_10 = 2;
    } else {

    }
#line 352
    goto ldv_33644;
    case 2: ;
#line 355
    if (ldv_state_variable_10 == 2) {
#line 357
      gru_file_unlocked_ioctl(gru_fops_group2, ldvarg33, ldvarg32);
#line 359
      ldv_state_variable_10 = 2;
    } else {

    }
#line 362
    goto ldv_33644;
    case 3: ;
#line 365
    if (ldv_state_variable_10 == 1) {
#line 367
      ldv_retval_9 = ldv_open_10();
#line 368
      if (ldv_retval_9 == 0) {
#line 369
        ldv_state_variable_10 = 2;
#line 370
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 374
    goto ldv_33644;
    case 4: ;
#line 377
    if (ldv_state_variable_10 == 2) {
#line 379
      ldv_release_10();
#line 380
      ldv_state_variable_10 = 1;
#line 381
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 384
    goto ldv_33644;
    default: 
#line 385
    ldv_stop();
    }
    ldv_33644: ;
  } else {

  }
#line 389
  goto ldv_33623;
  case 10: ;
#line 393
  if (ldv_state_variable_5 != 0) {
#line 394
    ldv_main_exported_5();
  } else {

  }
#line 397
  goto ldv_33623;
  default: 
#line 398
  ldv_stop();
  }
  ldv_33623: ;
#line 400
  goto ldv_33652;
  ldv_final: 
#line 402
  ldv_check_final_state();
#line 403
  return;
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
void ldv_mutex_lock_5(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 433
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 435
  mutex_lock(ldv_func_arg1);
#line 436
  return;
}
}
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
void ldv_mutex_unlock_6(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 441
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 443
  mutex_unlock(ldv_func_arg1);
#line 444
  return;
}
}
#line 446 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
void ldv_mutex_lock_7(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 449
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 451
  mutex_lock(ldv_func_arg1);
#line 452
  return;
}
}
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_mutex_trylock_8(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 458
  tmp = mutex_trylock(ldv_func_arg1);
#line 458
  ldv_func_res = tmp;
#line 460
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 460
  return (tmp___0);
#line 462
  return (ldv_func_res);
}
}
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
void ldv_mutex_unlock_9(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 468
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 470
  mutex_unlock(ldv_func_arg1);
#line 471
  return;
}
}
#line 473 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 476
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 478
  mutex_unlock(ldv_func_arg1);
#line 479
  return;
}
}
#line 481 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 484
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 486
  mutex_lock(ldv_func_arg1);
#line 487
  return;
}
}
#line 489 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 492
  ldv_mutex_lock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
#line 494
  mutex_lock(ldv_func_arg1);
#line 495
  return;
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
void ldv_mutex_unlock_13(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 500
  ldv_mutex_unlock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
#line 502
  mutex_unlock(ldv_func_arg1);
#line 503
  return;
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_misc_register_14(struct miscdevice *misc ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 509
  tmp = misc_register(misc);
#line 509
  ldv_func_res = tmp;
#line 511
  ldv_state_variable_3 = 1;
#line 512
  ldv_file_operations_3();
#line 515
  return (ldv_func_res);
}
}
#line 518 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_misc_deregister_15(struct miscdevice *misc ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;

  {
#line 522
  tmp = misc_deregister(misc);
#line 522
  ldv_func_res = tmp;
#line 524
  ldv_state_variable_3 = 0;
#line 526
  return (ldv_func_res);
}
}
#line 529 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufile.o.c.prepared"
int ldv_misc_deregister_16(struct miscdevice *misc ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 533
  tmp = misc_deregister(misc);
#line 533
  ldv_func_res = tmp;
#line 535
  ldv_state_variable_3 = 0;
#line 537
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 94 "./arch/x86/include/asm/bitops.h"
__inline static void __set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 96
  __asm__  volatile   ("bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 97
  return;
}
}
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 137 "./arch/x86/include/asm/bitops.h"
__inline static void __clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 139
  __asm__  volatile   ("btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 140
  return;
}
}
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 314 "./arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 42 "include/asm-generic/bitops/find.h"
extern unsigned long find_first_bit(unsigned long const   * , unsigned long  ) ;
#line 53
extern unsigned long find_first_zero_bit(unsigned long const   * , unsigned long  ) ;
#line 3 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
bool ldv_is_err(void const   *ptr ) ;
#line 5
void *ldv_err_ptr(long error ) ;
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 48
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 61 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 63
  __list_add(new, head, head->next);
#line 64
  return;
}
}
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 191 "./arch/x86/include/asm/special_insns.h"
__inline static void clflush(void volatile   *__p ) 
{ 


  {
#line 193
  __asm__  volatile   ("clflush %0": "+m" (*((char volatile   *)__p)));
#line 194
  return;
}
}
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 54 "include/linux/err.h"
__inline static void *ERR_CAST(void const   *ptr ) 
{ 


  {
#line 57
  return ((void *)ptr);
}
}
#line 561 "./arch/x86/include/asm/processor.h"
__inline static void rep_nop(void) 
{ 


  {
#line 563
  __asm__  volatile   ("rep; nop": : : "memory");
#line 564
  return;
}
}
#line 566 "./arch/x86/include/asm/processor.h"
__inline static void cpu_relax(void) 
{ 


  {
#line 568
  rep_nop();
#line 569
  return;
}
}
#line 693 "./arch/x86/include/asm/processor.h"
__inline static void prefetchw(void const   *x ) 
{ 


  {
#line 695
  __asm__  volatile   ("661:\n\tprefetcht0 %P1\n662:\n.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\n663:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6641f - .\n .word ( 6*32+ 8)\n .byte 663b-661b\n .byte 6651f-6641f\n .byte 663b-662b\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6641:\n\tprefetchw %P1\n6651:\n\t.popsection": : "i" (0),
                       "m" (*((char const   *)x)));
#line 696
  return;
}
}
#line 11 "./arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 15
extern void __xadd_wrong_size(void) ;
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 155 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 157
  __ret = i;
#line 157
  switch (4UL) {
  case 1UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  case 2UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  case 4UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  case 8UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  default: 
#line 157
  __xadd_wrong_size();
  }
  ldv_5596: ;
#line 157
  return (__ret + i);
}
}
#line 167 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_return(int i , atomic_t *v ) 
{ 
  int tmp ;

  {
#line 169
  tmp = atomic_add_return(- i, v);
#line 169
  return (tmp);
}
}
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 176
int ldv_mutex_trylock_36(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_40(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_34(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_37(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_38(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_41(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_43(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_44(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
void ldv_mutex_lock_33(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_35(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_39(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_42(struct mutex *ldv_func_arg1 ) ;
#line 78
int ldv_mutex_trylock_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) ;
#line 8 "./arch/x86/include/asm/preempt.h"
extern int __preempt_count ;
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6589;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6589;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6589;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6589;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6589: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6601;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6601;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6601;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6601;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6601: ;
#line 79
  return;
}
}
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField17.rlock);
#line 313
  return;
}
}
#line 355 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 357
  _raw_spin_unlock(& lock->__annonCompField17.rlock);
#line 358
  return;
}
}
#line 123 "include/linux/rwsem.h"
extern int down_write_trylock(struct rw_semaphore * ) ;
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 421 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 289 "include/linux/slab.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 1078 "include/linux/mm.h"
extern int zap_vma_ptes(struct vm_area_struct * , unsigned long  , unsigned long  ) ;
#line 2012
extern int remap_pfn_range(struct vm_area_struct * , unsigned long  , unsigned long  ,
                           unsigned long  , pgprot_t  ) ;
#line 510 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_numa_blade_id(void) 
{ 
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;

  {
#line 512
  __vpp_verify = (void const   *)0;
#line 512
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off), "0" (& __uv_hub_info));
#line 512
  return ((int )((struct uv_hub_info_s *)tcp_ptr__)->numa_blade_id);
}
}
#line 331 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_flush_cache(void *p ) 
{ 


  {
#line 333
  clflush((void volatile   *)p);
#line 334
  return;
}
}
#line 142 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
__inline static struct gru_context_configuration_handle *get_cch(void *base , int ctxnum ) 
{ 


  {
#line 145
  return ((struct gru_context_configuration_handle *)(base + ((unsigned long )(ctxnum * 256) + 67239936UL)));
}
}
#line 515
int cch_allocate(struct gru_context_configuration_handle *cch ) ;
#line 516
int cch_start(struct gru_context_configuration_handle *cch ) ;
#line 517
int cch_interrupt(struct gru_context_configuration_handle *cch ) ;
#line 518
int cch_deallocate(struct gru_context_configuration_handle *cch ) ;
#line 519
int cch_interrupt_sync(struct gru_context_configuration_handle *cch ) ;
#line 570 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
__inline static void __lock_handle(void *h ) 
{ 
  int tmp ;

  {
#line 572
  goto ldv_32008;
  ldv_32007: 
#line 573
  cpu_relax();
  ldv_32008: 
#line 572
  tmp = test_and_set_bit(1L, (unsigned long volatile   *)h);
#line 572
  if (tmp != 0) {
#line 574
    goto ldv_32007;
  } else {

  }

#line 579
  return;
}
}
#line 576 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
__inline static void __unlock_handle(void *h ) 
{ 


  {
#line 578
  clear_bit(1L, (unsigned long volatile   *)h);
#line 579
  return;
}
}
#line 586 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
__inline static void lock_cch_handle(struct gru_context_configuration_handle *cch ) 
{ 


  {
#line 588
  __lock_handle((void *)cch);
#line 589
  return;
}
}
#line 591 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
__inline static void unlock_cch_handle(struct gru_context_configuration_handle *cch ) 
{ 


  {
#line 594
  __unlock_handle((void *)cch);
#line 595
  return;
}
}
#line 607 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
__inline static int is_kernel_context(struct gru_thread_state *gts ) 
{ 


  {
#line 609
  return ((unsigned long )gts->ts_mm == (unsigned long )((struct mm_struct *)0));
}
}
#line 627
struct device *grudev ;
#line 631
struct gru_thread_state *gru_find_thread_state(struct vm_area_struct *vma , int tsid ) ;
#line 633
struct gru_thread_state *gru_alloc_thread_state(struct vm_area_struct *vma , int tsid ) ;
#line 635
struct gru_state *gru_assign_gru_context(struct gru_thread_state *gts ) ;
#line 636
void gru_load_context(struct gru_thread_state *gts ) ;
#line 637
void gru_steal_context(struct gru_thread_state *gts ) ;
#line 639
int gru_update_cch(struct gru_thread_state *gts ) ;
#line 654
void gru_check_context_placement(struct gru_thread_state *gts ) ;
#line 655
int gru_cpu_fault_map_id(void) ;
#line 657
void gru_flush_all_tlb(struct gru_state *gru ) ;
#line 661
struct gru_thread_state *gru_alloc_gts(struct vm_area_struct *vma , int cbr_au_count ,
                                       int dsr_au_count , unsigned char tlb_preload_count ,
                                       int options , int tsid ) ;
#line 664
unsigned long gru_reserve_cb_resources(struct gru_state *gru , int cbr_au_count ,
                                       char *cbmap ) ;
#line 666
unsigned long gru_reserve_ds_resources(struct gru_state *gru , int dsr_au_count ,
                                       char *dsmap ) ;
#line 669
struct gru_mm_struct *gru_register_mmu_notifier(void) ;
#line 670
void gru_drop_mmu_notifier(struct gru_mm_struct *gms ) ;
#line 676 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
unsigned long gru_options  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static struct device_driver gru_driver  = 
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
     {"gru", 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static struct device gru_device  = 
#line 43
     {0, 0, {0, {0, 0}, 0, 0, 0, 0, {{0}}, {{{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}},
                                          {{0, 0}, 0UL, 0, 0UL, 0U, 0, 0, 0, {(char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0},
                                           {0, {0, 0}, 0, 0, 0UL}}, 0, 0}, (unsigned char)0,
           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
    "", 0, {{0}, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}},
    0, & gru_driver, 0, 0, {{0}, (unsigned char)0, (unsigned char)0, (_Bool)0, (_Bool)0,
                            (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, {{{{{0}},
                                                                                 0U,
                                                                                 0U,
                                                                                 0,
                                                                                 {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                            {0, 0}, {0U, {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}},
                                          {0, 0}}}, 0, (_Bool)0, (_Bool)0, {{0, 0},
                                                                            0UL, 0,
                                                                            0UL, 0U,
                                                                            0, 0,
                                                                            0, {(char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0},
                                                                            {0, {0,
                                                                                 0},
                                                                             0, 0,
                                                                             0UL}},
                            0UL, {{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}}, {{{{{{0}},
                                                                                0U,
                                                                                0U,
                                                                                0,
                                                                                {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                                             {0, 0}},
                            0, {0}, {0}, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, 0, 0, 0, 0, 0UL, 0UL,
                            0UL, 0UL, 0, 0, 0}, 0, 0, 0, 0, 0ULL, 0UL, 0, {0, 0},
    0, 0, {0, 0}, 0, 0, 0U, 0U, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0,
                                                                                 0},
    {0, {0, 0}, {{0}}}, 0, 0, 0, 0, (_Bool)0, (_Bool)0};
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
struct device *grudev  =    & gru_device;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
int gru_cpu_fault_map_id(void) 
{ 
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int id ;
  int core ;
  void const   *__vpp_verify___0 ;
  unsigned long __ptr ;
  void const   *__vpp_verify___1 ;
  unsigned long __ptr___0 ;
  void const   *__vpp_verify___2 ;
  unsigned long __ptr___1 ;

  {
#line 60
  __vpp_verify = (void const   *)0;
#line 60
  switch (4UL) {
  case 1UL: ;
#line 60
  switch (4UL) {
  case 1UL: 
#line 60
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 60
  goto ldv_32138;
  case 2UL: 
#line 60
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 60
  goto ldv_32138;
  case 4UL: 
#line 60
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 60
  goto ldv_32138;
  case 8UL: 
#line 60
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 60
  goto ldv_32138;
  default: 
#line 60
  __bad_percpu_size();
  }
  ldv_32138: 
#line 60
  pscr_ret__ = pfo_ret__;
#line 60
  goto ldv_32144;
  case 2UL: ;
#line 60
  switch (4UL) {
  case 1UL: 
#line 60
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 60
  goto ldv_32148;
  case 2UL: 
#line 60
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 60
  goto ldv_32148;
  case 4UL: 
#line 60
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 60
  goto ldv_32148;
  case 8UL: 
#line 60
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 60
  goto ldv_32148;
  default: 
#line 60
  __bad_percpu_size();
  }
  ldv_32148: 
#line 60
  pscr_ret__ = pfo_ret_____0;
#line 60
  goto ldv_32144;
  case 4UL: ;
#line 60
  switch (4UL) {
  case 1UL: 
#line 60
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 60
  goto ldv_32157;
  case 2UL: 
#line 60
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 60
  goto ldv_32157;
  case 4UL: 
#line 60
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 60
  goto ldv_32157;
  case 8UL: 
#line 60
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 60
  goto ldv_32157;
  default: 
#line 60
  __bad_percpu_size();
  }
  ldv_32157: 
#line 60
  pscr_ret__ = pfo_ret_____1;
#line 60
  goto ldv_32144;
  case 8UL: ;
#line 60
  switch (4UL) {
  case 1UL: 
#line 60
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 60
  goto ldv_32166;
  case 2UL: 
#line 60
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 60
  goto ldv_32166;
  case 4UL: 
#line 60
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 60
  goto ldv_32166;
  case 8UL: 
#line 60
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 60
  goto ldv_32166;
  default: 
#line 60
  __bad_percpu_size();
  }
  ldv_32166: 
#line 60
  pscr_ret__ = pfo_ret_____2;
#line 60
  goto ldv_32144;
  default: 
#line 60
  __bad_size_call_parameter();
#line 60
  goto ldv_32144;
  }
  ldv_32144: 
#line 60
  cpu = pscr_ret__;
#line 63
  __vpp_verify___0 = (void const   *)0;
#line 63
  __asm__  ("": "=r" (__ptr): "0" (& x86_cpu_to_apicid));
#line 63
  __vpp_verify___1 = (void const   *)0;
#line 63
  __asm__  ("": "=r" (__ptr___0): "0" (& x86_cpu_to_apicid));
#line 63
  core = (((int )*((u16 *)(__per_cpu_offset[cpu] + __ptr)) >> 2) & 4) | (((int )*((u16 *)(__per_cpu_offset[cpu] + __ptr___0)) >> 1) & 3);
#line 64
  __vpp_verify___2 = (void const   *)0;
#line 64
  __asm__  ("": "=r" (__ptr___1): "0" (& x86_cpu_to_apicid));
#line 64
  id = (((int )*((u16 *)(__per_cpu_offset[cpu] + __ptr___1)) >> 5) & 1) * 8 + core;
#line 65
  return (id);
}
}
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static int gru_wrap_asid(struct gru_state *gru ) 
{ 
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 99
  if ((int )gru_options & 1) {
#line 99
    __vpp_verify = (void const   *)0;
#line 99
    switch (4UL) {
    case 1UL: ;
#line 99
    switch (4UL) {
    case 1UL: 
#line 99
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 99
    goto ldv_32196;
    case 2UL: 
#line 99
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 99
    goto ldv_32196;
    case 4UL: 
#line 99
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 99
    goto ldv_32196;
    case 8UL: 
#line 99
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 99
    goto ldv_32196;
    default: 
#line 99
    __bad_percpu_size();
    }
    ldv_32196: 
#line 99
    pscr_ret__ = pfo_ret__;
#line 99
    goto ldv_32202;
    case 2UL: ;
#line 99
    switch (4UL) {
    case 1UL: 
#line 99
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 99
    goto ldv_32206;
    case 2UL: 
#line 99
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 99
    goto ldv_32206;
    case 4UL: 
#line 99
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 99
    goto ldv_32206;
    case 8UL: 
#line 99
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 99
    goto ldv_32206;
    default: 
#line 99
    __bad_percpu_size();
    }
    ldv_32206: 
#line 99
    pscr_ret__ = pfo_ret_____0;
#line 99
    goto ldv_32202;
    case 4UL: ;
#line 99
    switch (4UL) {
    case 1UL: 
#line 99
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 99
    goto ldv_32215;
    case 2UL: 
#line 99
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 99
    goto ldv_32215;
    case 4UL: 
#line 99
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 99
    goto ldv_32215;
    case 8UL: 
#line 99
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 99
    goto ldv_32215;
    default: 
#line 99
    __bad_percpu_size();
    }
    ldv_32215: 
#line 99
    pscr_ret__ = pfo_ret_____1;
#line 99
    goto ldv_32202;
    case 8UL: ;
#line 99
    switch (4UL) {
    case 1UL: 
#line 99
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 99
    goto ldv_32224;
    case 2UL: 
#line 99
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 99
    goto ldv_32224;
    case 4UL: 
#line 99
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 99
    goto ldv_32224;
    case 8UL: 
#line 99
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 99
    goto ldv_32224;
    default: 
#line 99
    __bad_percpu_size();
    }
    ldv_32224: 
#line 99
    pscr_ret__ = pfo_ret_____2;
#line 99
    goto ldv_32202;
    default: 
#line 99
    __bad_size_call_parameter();
#line 99
    goto ldv_32202;
    }
    ldv_32202: 
#line 99
    printk("\017GRU:%d %s: gid %d\n", pscr_ret__, "gru_wrap_asid", (int )gru->gs_gid);
  } else {

  }
#line 100
  if ((gru_options & 2UL) != 0UL) {
#line 100
    atomic_long_inc(& gru_stats.asid_wrap);
  } else {

  }
#line 101
  gru->gs_asid_gen = gru->gs_asid_gen + 1U;
#line 102
  return (8);
}
}
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static int gru_reset_asid_limit(struct gru_state *gru , int asid ) 
{ 
  int i ;
  int gid ;
  int inuse_asid ;
  int limit ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int pscr_ret_____1 ;
  void const   *__vpp_verify___1 ;
  int pfo_ret_____7 ;
  int pfo_ret_____8 ;
  int pfo_ret_____9 ;
  int pfo_ret_____10 ;

  {
#line 110
  if ((int )gru_options & 1) {
#line 110
    __vpp_verify = (void const   *)0;
#line 110
    switch (4UL) {
    case 1UL: ;
#line 110
    switch (4UL) {
    case 1UL: 
#line 110
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 110
    goto ldv_32246;
    case 2UL: 
#line 110
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 110
    goto ldv_32246;
    case 4UL: 
#line 110
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 110
    goto ldv_32246;
    case 8UL: 
#line 110
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 110
    goto ldv_32246;
    default: 
#line 110
    __bad_percpu_size();
    }
    ldv_32246: 
#line 110
    pscr_ret__ = pfo_ret__;
#line 110
    goto ldv_32252;
    case 2UL: ;
#line 110
    switch (4UL) {
    case 1UL: 
#line 110
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 110
    goto ldv_32256;
    case 2UL: 
#line 110
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 110
    goto ldv_32256;
    case 4UL: 
#line 110
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 110
    goto ldv_32256;
    case 8UL: 
#line 110
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 110
    goto ldv_32256;
    default: 
#line 110
    __bad_percpu_size();
    }
    ldv_32256: 
#line 110
    pscr_ret__ = pfo_ret_____0;
#line 110
    goto ldv_32252;
    case 4UL: ;
#line 110
    switch (4UL) {
    case 1UL: 
#line 110
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 110
    goto ldv_32265;
    case 2UL: 
#line 110
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 110
    goto ldv_32265;
    case 4UL: 
#line 110
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 110
    goto ldv_32265;
    case 8UL: 
#line 110
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 110
    goto ldv_32265;
    default: 
#line 110
    __bad_percpu_size();
    }
    ldv_32265: 
#line 110
    pscr_ret__ = pfo_ret_____1;
#line 110
    goto ldv_32252;
    case 8UL: ;
#line 110
    switch (4UL) {
    case 1UL: 
#line 110
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 110
    goto ldv_32274;
    case 2UL: 
#line 110
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 110
    goto ldv_32274;
    case 4UL: 
#line 110
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 110
    goto ldv_32274;
    case 8UL: 
#line 110
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 110
    goto ldv_32274;
    default: 
#line 110
    __bad_percpu_size();
    }
    ldv_32274: 
#line 110
    pscr_ret__ = pfo_ret_____2;
#line 110
    goto ldv_32252;
    default: 
#line 110
    __bad_size_call_parameter();
#line 110
    goto ldv_32252;
    }
    ldv_32252: 
#line 110
    printk("\017GRU:%d %s: gid %d, asid 0x%x\n", pscr_ret__, "gru_reset_asid_limit",
           (int )gru->gs_gid, asid);
  } else {

  }
#line 111
  if ((gru_options & 2UL) != 0UL) {
#line 111
    atomic_long_inc(& gru_stats.asid_next);
  } else {

  }
#line 112
  limit = 16777200;
#line 113
  if (asid >= limit) {
#line 114
    asid = gru_wrap_asid(gru);
  } else {

  }
#line 115
  gru_flush_all_tlb(gru);
#line 116
  gid = (int )gru->gs_gid;
  again: 
#line 118
  i = 0;
#line 118
  goto ldv_32327;
  ldv_32326: ;
#line 119
  if ((unsigned long )gru->gs_gts[i] == (unsigned long )((struct gru_thread_state *)0)) {
#line 120
    goto ldv_32284;
  } else {
#line 119
    tmp = is_kernel_context(gru->gs_gts[i]);
#line 119
    if (tmp != 0) {
#line 120
      goto ldv_32284;
    } else {

    }
  }
#line 121
  inuse_asid = (int )((gru->gs_gts[i])->ts_gms)->ms_asids[gid].mt_asid;
#line 122
  if ((int )gru_options & 1) {
#line 122
    __vpp_verify___0 = (void const   *)0;
#line 122
    switch (4UL) {
    case 1UL: ;
#line 124
    switch (4UL) {
    case 1UL: 
#line 124
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 124
    goto ldv_32290;
    case 2UL: 
#line 124
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 124
    goto ldv_32290;
    case 4UL: 
#line 124
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 124
    goto ldv_32290;
    case 8UL: 
#line 124
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 124
    goto ldv_32290;
    default: 
#line 124
    __bad_percpu_size();
    }
    ldv_32290: 
#line 124
    pscr_ret_____0 = pfo_ret_____3;
#line 124
    goto ldv_32296;
    case 2UL: ;
#line 124
    switch (4UL) {
    case 1UL: 
#line 124
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 124
    goto ldv_32300;
    case 2UL: 
#line 124
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 124
    goto ldv_32300;
    case 4UL: 
#line 124
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 124
    goto ldv_32300;
    case 8UL: 
#line 124
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 124
    goto ldv_32300;
    default: 
#line 124
    __bad_percpu_size();
    }
    ldv_32300: 
#line 124
    pscr_ret_____0 = pfo_ret_____4;
#line 124
    goto ldv_32296;
    case 4UL: ;
#line 124
    switch (4UL) {
    case 1UL: 
#line 124
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 124
    goto ldv_32309;
    case 2UL: 
#line 124
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 124
    goto ldv_32309;
    case 4UL: 
#line 124
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 124
    goto ldv_32309;
    case 8UL: 
#line 124
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 124
    goto ldv_32309;
    default: 
#line 124
    __bad_percpu_size();
    }
    ldv_32309: 
#line 124
    pscr_ret_____0 = pfo_ret_____5;
#line 124
    goto ldv_32296;
    case 8UL: ;
#line 124
    switch (4UL) {
    case 1UL: 
#line 124
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 124
    goto ldv_32318;
    case 2UL: 
#line 124
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 124
    goto ldv_32318;
    case 4UL: 
#line 124
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 124
    goto ldv_32318;
    case 8UL: 
#line 124
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 124
    goto ldv_32318;
    default: 
#line 124
    __bad_percpu_size();
    }
    ldv_32318: 
#line 124
    pscr_ret_____0 = pfo_ret_____6;
#line 124
    goto ldv_32296;
    default: 
#line 124
    __bad_size_call_parameter();
#line 124
    goto ldv_32296;
    }
    ldv_32296: 
#line 124
    printk("\017GRU:%d %s: gid %d, gts %p, gms %p, inuse 0x%x, cxt %d\n", pscr_ret_____0,
           "gru_reset_asid_limit", (int )gru->gs_gid, gru->gs_gts[i], (gru->gs_gts[i])->ts_gms,
           inuse_asid, i);
  } else {

  }
#line 125
  if (inuse_asid == asid) {
#line 126
    asid = asid + 8;
#line 127
    if (asid >= limit) {
#line 132
      limit = 16777200;
#line 133
      if (asid > 16777199) {
#line 134
        asid = gru_wrap_asid(gru);
      } else {

      }
#line 135
      goto again;
    } else {

    }
  } else {

  }
#line 139
  if (inuse_asid > asid && inuse_asid < limit) {
#line 140
    limit = inuse_asid;
  } else {

  }
  ldv_32284: 
#line 118
  i = i + 1;
  ldv_32327: ;
#line 118
  if (i <= 15) {
#line 120
    goto ldv_32326;
  } else {

  }
#line 142
  gru->gs_asid_limit = (unsigned int )limit;
#line 143
  gru->gs_asid = (unsigned int )asid;
#line 144
  if ((int )gru_options & 1) {
#line 144
    __vpp_verify___1 = (void const   *)0;
#line 144
    switch (4UL) {
    case 1UL: ;
#line 145
    switch (4UL) {
    case 1UL: 
#line 145
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____7): "m" (cpu_number));
#line 145
    goto ldv_32334;
    case 2UL: 
#line 145
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 145
    goto ldv_32334;
    case 4UL: 
#line 145
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 145
    goto ldv_32334;
    case 8UL: 
#line 145
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 145
    goto ldv_32334;
    default: 
#line 145
    __bad_percpu_size();
    }
    ldv_32334: 
#line 145
    pscr_ret_____1 = pfo_ret_____7;
#line 145
    goto ldv_32340;
    case 2UL: ;
#line 145
    switch (4UL) {
    case 1UL: 
#line 145
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____8): "m" (cpu_number));
#line 145
    goto ldv_32344;
    case 2UL: 
#line 145
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 145
    goto ldv_32344;
    case 4UL: 
#line 145
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 145
    goto ldv_32344;
    case 8UL: 
#line 145
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 145
    goto ldv_32344;
    default: 
#line 145
    __bad_percpu_size();
    }
    ldv_32344: 
#line 145
    pscr_ret_____1 = pfo_ret_____8;
#line 145
    goto ldv_32340;
    case 4UL: ;
#line 145
    switch (4UL) {
    case 1UL: 
#line 145
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____9): "m" (cpu_number));
#line 145
    goto ldv_32353;
    case 2UL: 
#line 145
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 145
    goto ldv_32353;
    case 4UL: 
#line 145
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 145
    goto ldv_32353;
    case 8UL: 
#line 145
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 145
    goto ldv_32353;
    default: 
#line 145
    __bad_percpu_size();
    }
    ldv_32353: 
#line 145
    pscr_ret_____1 = pfo_ret_____9;
#line 145
    goto ldv_32340;
    case 8UL: ;
#line 145
    switch (4UL) {
    case 1UL: 
#line 145
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____10): "m" (cpu_number));
#line 145
    goto ldv_32362;
    case 2UL: 
#line 145
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 145
    goto ldv_32362;
    case 4UL: 
#line 145
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 145
    goto ldv_32362;
    case 8UL: 
#line 145
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 145
    goto ldv_32362;
    default: 
#line 145
    __bad_percpu_size();
    }
    ldv_32362: 
#line 145
    pscr_ret_____1 = pfo_ret_____10;
#line 145
    goto ldv_32340;
    default: 
#line 145
    __bad_size_call_parameter();
#line 145
    goto ldv_32340;
    }
    ldv_32340: 
#line 145
    printk("\017GRU:%d %s: gid %d, new asid 0x%x, new_limit 0x%x\n", pscr_ret_____1,
           "gru_reset_asid_limit", (int )gru->gs_gid, asid, limit);
  } else {

  }
#line 146
  return (asid);
}
}
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static int gru_assign_asid(struct gru_state *gru ) 
{ 
  int asid ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 154
  gru->gs_asid = gru->gs_asid + 8U;
#line 155
  asid = (int )gru->gs_asid;
#line 156
  if ((unsigned int )asid >= gru->gs_asid_limit) {
#line 157
    asid = gru_reset_asid_limit(gru, asid);
  } else {

  }
#line 159
  if ((int )gru_options & 1) {
#line 159
    __vpp_verify = (void const   *)0;
#line 159
    switch (4UL) {
    case 1UL: ;
#line 159
    switch (4UL) {
    case 1UL: 
#line 159
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 159
    goto ldv_32379;
    case 2UL: 
#line 159
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 159
    goto ldv_32379;
    case 4UL: 
#line 159
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 159
    goto ldv_32379;
    case 8UL: 
#line 159
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 159
    goto ldv_32379;
    default: 
#line 159
    __bad_percpu_size();
    }
    ldv_32379: 
#line 159
    pscr_ret__ = pfo_ret__;
#line 159
    goto ldv_32385;
    case 2UL: ;
#line 159
    switch (4UL) {
    case 1UL: 
#line 159
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 159
    goto ldv_32389;
    case 2UL: 
#line 159
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 159
    goto ldv_32389;
    case 4UL: 
#line 159
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 159
    goto ldv_32389;
    case 8UL: 
#line 159
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 159
    goto ldv_32389;
    default: 
#line 159
    __bad_percpu_size();
    }
    ldv_32389: 
#line 159
    pscr_ret__ = pfo_ret_____0;
#line 159
    goto ldv_32385;
    case 4UL: ;
#line 159
    switch (4UL) {
    case 1UL: 
#line 159
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 159
    goto ldv_32398;
    case 2UL: 
#line 159
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 159
    goto ldv_32398;
    case 4UL: 
#line 159
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 159
    goto ldv_32398;
    case 8UL: 
#line 159
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 159
    goto ldv_32398;
    default: 
#line 159
    __bad_percpu_size();
    }
    ldv_32398: 
#line 159
    pscr_ret__ = pfo_ret_____1;
#line 159
    goto ldv_32385;
    case 8UL: ;
#line 159
    switch (4UL) {
    case 1UL: 
#line 159
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 159
    goto ldv_32407;
    case 2UL: 
#line 159
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 159
    goto ldv_32407;
    case 4UL: 
#line 159
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 159
    goto ldv_32407;
    case 8UL: 
#line 159
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 159
    goto ldv_32407;
    default: 
#line 159
    __bad_percpu_size();
    }
    ldv_32407: 
#line 159
    pscr_ret__ = pfo_ret_____2;
#line 159
    goto ldv_32385;
    default: 
#line 159
    __bad_size_call_parameter();
#line 159
    goto ldv_32385;
    }
    ldv_32385: 
#line 159
    printk("\017GRU:%d %s: gid %d, asid 0x%x\n", pscr_ret__, "gru_assign_asid", (int )gru->gs_gid,
           asid);
  } else {

  }
#line 160
  return (asid);
}
}
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static unsigned long reserve_resources(unsigned long *p , int n , int mmax , char *idx ) 
{ 
  unsigned long bits ;
  int i ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 170
  bits = 0UL;
#line 173
  goto ldv_32426;
  ldv_32425: 
#line 174
  tmp = find_first_bit((unsigned long const   *)p, (unsigned long )mmax);
#line 174
  i = (int )tmp;
#line 175
  if (i == mmax) {
#line 176
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"),
                         "i" (176), "i" (12UL));
    ldv_32424: ;
#line 176
    goto ldv_32424;
  } else {

  }
#line 177
  __clear_bit((long )i, (unsigned long volatile   *)p);
#line 178
  __set_bit((long )i, (unsigned long volatile   *)(& bits));
#line 179
  if ((unsigned long )idx != (unsigned long )((char *)0)) {
#line 180
    tmp___0 = idx;
#line 180
    idx = idx + 1;
#line 180
    *tmp___0 = (char )i;
  } else {

  }
  ldv_32426: 
#line 173
  tmp___1 = n;
#line 173
  n = n - 1;
#line 173
  if (tmp___1 != 0) {
#line 175
    goto ldv_32425;
  } else {

  }

#line 182
  return (bits);
}
}
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
unsigned long gru_reserve_cb_resources(struct gru_state *gru , int cbr_au_count ,
                                       char *cbmap ) 
{ 
  unsigned long tmp ;

  {
#line 188
  tmp = reserve_resources(& gru->gs_cbr_map, cbr_au_count, 64, cbmap);
#line 188
  return (tmp);
}
}
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
unsigned long gru_reserve_ds_resources(struct gru_state *gru , int dsr_au_count ,
                                       char *dsmap ) 
{ 
  unsigned long tmp ;

  {
#line 195
  tmp = reserve_resources(& gru->gs_dsr_map, dsr_au_count, 32, dsmap);
#line 195
  return (tmp);
}
}
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static void reserve_gru_resources(struct gru_state *gru , struct gru_thread_state *gts ) 
{ 


  {
#line 202
  gru->gs_active_contexts = (unsigned short )((int )gru->gs_active_contexts + 1);
#line 203
  gts->ts_cbr_map = gru_reserve_cb_resources(gru, (int )gts->ts_cbr_au_count, (char *)(& gts->ts_cbr_idx));
#line 206
  gts->ts_dsr_map = gru_reserve_ds_resources(gru, (int )gts->ts_dsr_au_count, (char *)0);
#line 208
  return;
}
}
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static void free_gru_resources(struct gru_state *gru , struct gru_thread_state *gts ) 
{ 


  {
#line 213
  gru->gs_active_contexts = (unsigned short )((int )gru->gs_active_contexts - 1);
#line 214
  gru->gs_cbr_map = gru->gs_cbr_map | gts->ts_cbr_map;
#line 215
  gru->gs_dsr_map = gru->gs_dsr_map | gts->ts_dsr_map;
#line 216
  return;
}
}
#line 225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static int check_gru_resources(struct gru_state *gru , int cbr_au_count , int dsr_au_count ,
                               int max_active_contexts ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 228
  tmp = __arch_hweight64((__u64 )gru->gs_cbr_map);
#line 228
  if (tmp >= (unsigned long )cbr_au_count) {
#line 228
    tmp___0 = __arch_hweight64((__u64 )gru->gs_dsr_map);
#line 228
    if (tmp___0 >= (unsigned long )dsr_au_count) {
#line 228
      if ((int )gru->gs_active_contexts < max_active_contexts) {
#line 228
        tmp___1 = 1;
      } else {
#line 228
        tmp___1 = 0;
      }
    } else {
#line 228
      tmp___1 = 0;
    }
  } else {
#line 228
    tmp___1 = 0;
  }
#line 228
  return (tmp___1);
}
}
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static int gru_load_mm_tracker(struct gru_state *gru , struct gru_thread_state *gts ) 
{ 
  struct gru_mm_struct *gms ;
  struct gru_mm_tracker *asids ;
  unsigned short ctxbitmap ;
  int asid ;
  long tmp ;
  int tmp___0 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 240
  gms = gts->ts_gms;
#line 241
  asids = (struct gru_mm_tracker *)(& gms->ms_asids) + (unsigned long )gru->gs_gid;
#line 242
  ctxbitmap = (unsigned short )(1 << gts->ts_ctxnum);
#line 245
  spin_lock(& gms->ms_asid_lock);
#line 246
  asid = (int )asids->mt_asid;
#line 248
  spin_lock(& gru->gs_asid_lock);
#line 249
  if (asid == 0 || ((unsigned int )asids->mt_ctxbitmap == 0U && asids->mt_asid_gen != gru->gs_asid_gen)) {
#line 251
    asid = gru_assign_asid(gru);
#line 252
    asids->mt_asid = (unsigned int )asid;
#line 253
    asids->mt_asid_gen = gru->gs_asid_gen;
#line 254
    if ((gru_options & 2UL) != 0UL) {
#line 254
      atomic_long_inc(& gru_stats.asid_new);
    } else {

    }
  } else
#line 256
  if ((gru_options & 2UL) != 0UL) {
#line 256
    atomic_long_inc(& gru_stats.asid_reuse);
  } else {

  }
#line 258
  spin_unlock(& gru->gs_asid_lock);
#line 260
  tmp = ldv__builtin_expect((unsigned int )((int )asids->mt_ctxbitmap & (int )ctxbitmap) != 0U,
                         0L);
#line 260
  if (tmp != 0L) {
#line 260
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"),
                         "i" (260), "i" (12UL));
    ldv_32460: ;
#line 260
    goto ldv_32460;
  } else {

  }
#line 261
  asids->mt_ctxbitmap = (int )asids->mt_ctxbitmap | (int )ctxbitmap;
#line 262
  tmp___0 = variable_test_bit((long )gru->gs_gid, (unsigned long const volatile   *)(& gms->ms_asidmap));
#line 262
  if (tmp___0 == 0) {
#line 263
    __set_bit((long )gru->gs_gid, (unsigned long volatile   *)(& gms->ms_asidmap));
  } else {

  }
#line 264
  spin_unlock(& gms->ms_asid_lock);
#line 266
  if ((int )gru_options & 1) {
#line 266
    __vpp_verify = (void const   *)0;
#line 266
    switch (4UL) {
    case 1UL: ;
#line 269
    switch (4UL) {
    case 1UL: 
#line 269
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 269
    goto ldv_32466;
    case 2UL: 
#line 269
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 269
    goto ldv_32466;
    case 4UL: 
#line 269
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 269
    goto ldv_32466;
    case 8UL: 
#line 269
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 269
    goto ldv_32466;
    default: 
#line 269
    __bad_percpu_size();
    }
    ldv_32466: 
#line 269
    pscr_ret__ = pfo_ret__;
#line 269
    goto ldv_32472;
    case 2UL: ;
#line 269
    switch (4UL) {
    case 1UL: 
#line 269
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 269
    goto ldv_32476;
    case 2UL: 
#line 269
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 269
    goto ldv_32476;
    case 4UL: 
#line 269
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 269
    goto ldv_32476;
    case 8UL: 
#line 269
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 269
    goto ldv_32476;
    default: 
#line 269
    __bad_percpu_size();
    }
    ldv_32476: 
#line 269
    pscr_ret__ = pfo_ret_____0;
#line 269
    goto ldv_32472;
    case 4UL: ;
#line 269
    switch (4UL) {
    case 1UL: 
#line 269
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 269
    goto ldv_32485;
    case 2UL: 
#line 269
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 269
    goto ldv_32485;
    case 4UL: 
#line 269
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 269
    goto ldv_32485;
    case 8UL: 
#line 269
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 269
    goto ldv_32485;
    default: 
#line 269
    __bad_percpu_size();
    }
    ldv_32485: 
#line 269
    pscr_ret__ = pfo_ret_____1;
#line 269
    goto ldv_32472;
    case 8UL: ;
#line 269
    switch (4UL) {
    case 1UL: 
#line 269
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 269
    goto ldv_32494;
    case 2UL: 
#line 269
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 269
    goto ldv_32494;
    case 4UL: 
#line 269
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 269
    goto ldv_32494;
    case 8UL: 
#line 269
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 269
    goto ldv_32494;
    default: 
#line 269
    __bad_percpu_size();
    }
    ldv_32494: 
#line 269
    pscr_ret__ = pfo_ret_____2;
#line 269
    goto ldv_32472;
    default: 
#line 269
    __bad_size_call_parameter();
#line 269
    goto ldv_32472;
    }
    ldv_32472: 
#line 269
    printk("\017GRU:%d %s: gid %d, gts %p, gms %p, ctxnum %d, asid 0x%x, asidmap 0x%lx\n",
           pscr_ret__, "gru_load_mm_tracker", (int )gru->gs_gid, gts, gms, gts->ts_ctxnum,
           asid, gms->ms_asidmap[0]);
  } else {

  }
#line 270
  return (asid);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static void gru_unload_mm_tracker(struct gru_state *gru , struct gru_thread_state *gts ) 
{ 
  struct gru_mm_struct *gms ;
  struct gru_mm_tracker *asids ;
  unsigned short ctxbitmap ;
  long tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 276
  gms = gts->ts_gms;
#line 280
  asids = (struct gru_mm_tracker *)(& gms->ms_asids) + (unsigned long )gru->gs_gid;
#line 281
  ctxbitmap = (unsigned short )(1 << gts->ts_ctxnum);
#line 282
  spin_lock(& gms->ms_asid_lock);
#line 283
  spin_lock(& gru->gs_asid_lock);
#line 284
  tmp = ldv__builtin_expect(((int )asids->mt_ctxbitmap & (int )ctxbitmap) != (int )ctxbitmap,
                         0L);
#line 284
  if (tmp != 0L) {
#line 284
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"),
                         "i" (284), "i" (12UL));
    ldv_32510: ;
#line 284
    goto ldv_32510;
  } else {

  }
#line 285
  asids->mt_ctxbitmap = (int )asids->mt_ctxbitmap ^ (int )ctxbitmap;
#line 286
  if ((int )gru_options & 1) {
#line 286
    __vpp_verify = (void const   *)0;
#line 286
    switch (4UL) {
    case 1UL: ;
#line 287
    switch (4UL) {
    case 1UL: 
#line 287
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 287
    goto ldv_32516;
    case 2UL: 
#line 287
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 287
    goto ldv_32516;
    case 4UL: 
#line 287
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 287
    goto ldv_32516;
    case 8UL: 
#line 287
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 287
    goto ldv_32516;
    default: 
#line 287
    __bad_percpu_size();
    }
    ldv_32516: 
#line 287
    pscr_ret__ = pfo_ret__;
#line 287
    goto ldv_32522;
    case 2UL: ;
#line 287
    switch (4UL) {
    case 1UL: 
#line 287
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 287
    goto ldv_32526;
    case 2UL: 
#line 287
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 287
    goto ldv_32526;
    case 4UL: 
#line 287
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 287
    goto ldv_32526;
    case 8UL: 
#line 287
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 287
    goto ldv_32526;
    default: 
#line 287
    __bad_percpu_size();
    }
    ldv_32526: 
#line 287
    pscr_ret__ = pfo_ret_____0;
#line 287
    goto ldv_32522;
    case 4UL: ;
#line 287
    switch (4UL) {
    case 1UL: 
#line 287
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 287
    goto ldv_32535;
    case 2UL: 
#line 287
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 287
    goto ldv_32535;
    case 4UL: 
#line 287
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 287
    goto ldv_32535;
    case 8UL: 
#line 287
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 287
    goto ldv_32535;
    default: 
#line 287
    __bad_percpu_size();
    }
    ldv_32535: 
#line 287
    pscr_ret__ = pfo_ret_____1;
#line 287
    goto ldv_32522;
    case 8UL: ;
#line 287
    switch (4UL) {
    case 1UL: 
#line 287
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 287
    goto ldv_32544;
    case 2UL: 
#line 287
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 287
    goto ldv_32544;
    case 4UL: 
#line 287
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 287
    goto ldv_32544;
    case 8UL: 
#line 287
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 287
    goto ldv_32544;
    default: 
#line 287
    __bad_percpu_size();
    }
    ldv_32544: 
#line 287
    pscr_ret__ = pfo_ret_____2;
#line 287
    goto ldv_32522;
    default: 
#line 287
    __bad_size_call_parameter();
#line 287
    goto ldv_32522;
    }
    ldv_32522: 
#line 287
    printk("\017GRU:%d %s: gid %d, gts %p, gms %p, ctxnum 0x%d, asidmap 0x%lx\n",
           pscr_ret__, "gru_unload_mm_tracker", (int )gru->gs_gid, gts, gms, gts->ts_ctxnum,
           gms->ms_asidmap[0]);
  } else {

  }
#line 288
  spin_unlock(& gru->gs_asid_lock);
#line 289
  spin_unlock(& gms->ms_asid_lock);
#line 290
  return;
}
}
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
void gts_drop(struct gru_thread_state *gts ) 
{ 
  int tmp ;

  {
#line 298
  if ((unsigned long )gts != (unsigned long )((struct gru_thread_state *)0)) {
#line 298
    tmp = atomic_sub_return(1, & gts->ts_refcnt);
#line 298
    if (tmp == 0) {
#line 299
      if ((unsigned long )gts->ts_gms != (unsigned long )((struct gru_mm_struct *)0)) {
#line 300
        gru_drop_mmu_notifier(gts->ts_gms);
      } else {

      }
#line 301
      kfree((void const   *)gts);
#line 302
      if ((gru_options & 2UL) != 0UL) {
#line 302
        atomic_long_inc(& gru_stats.gts_free);
      } else {

      }
    } else {

    }
  } else {

  }
#line 304
  return;
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static struct gru_thread_state *gru_find_current_gts_nolock(struct gru_vma_data *vdata ,
                                                            int tsid ) 
{ 
  struct gru_thread_state *gts ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 314
  __mptr = (struct list_head  const  *)vdata->vd_head.next;
#line 314
  gts = (struct gru_thread_state *)__mptr;
#line 314
  goto ldv_32566;
  ldv_32565: ;
#line 315
  if (gts->ts_tsid == tsid) {
#line 316
    return (gts);
  } else {

  }
#line 314
  __mptr___0 = (struct list_head  const  *)gts->ts_next.next;
#line 314
  gts = (struct gru_thread_state *)__mptr___0;
  ldv_32566: ;
#line 314
  if ((unsigned long )(& gts->ts_next) != (unsigned long )(& vdata->vd_head)) {
#line 316
    goto ldv_32565;
  } else {

  }

#line 317
  return ((struct gru_thread_state *)0);
}
}
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
struct gru_thread_state *gru_alloc_gts(struct vm_area_struct *vma , int cbr_au_count ,
                                       int dsr_au_count , unsigned char tlb_preload_count ,
                                       int options , int tsid ) 
{ 
  struct gru_thread_state *gts ;
  struct gru_mm_struct *gms ;
  int bytes ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  struct task_struct *tmp___1 ;
  bool tmp___2 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  void *tmp___3 ;

  {
#line 331
  bytes = (dsr_au_count * 4 + cbr_au_count) * 256;
#line 332
  bytes = (int )((unsigned int )bytes + 464U);
#line 333
  tmp = kmalloc((size_t )bytes, 208U);
#line 333
  gts = (struct gru_thread_state *)tmp;
#line 334
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
#line 335
    tmp___0 = ERR_PTR(-12L);
#line 335
    return ((struct gru_thread_state *)tmp___0);
  } else {

  }
#line 337
  if ((gru_options & 2UL) != 0UL) {
#line 337
    atomic_long_inc(& gru_stats.gts_alloc);
  } else {

  }
#line 338
  memset((void *)gts, 0, 464UL);
#line 339
  atomic_set(& gts->ts_refcnt, 1);
#line 340
  __mutex_init(& gts->ts_ctxlock, "&gts->ts_ctxlock", & __key);
#line 341
  gts->ts_cbr_au_count = (unsigned char )cbr_au_count;
#line 342
  gts->ts_dsr_au_count = (unsigned char )dsr_au_count;
#line 343
  gts->ts_tlb_preload_count = tlb_preload_count;
#line 344
  gts->ts_user_options = (long )options;
#line 345
  gts->ts_user_blade_id = -1;
#line 346
  gts->ts_user_chiplet_id = -1;
#line 347
  gts->ts_tsid = tsid;
#line 348
  gts->ts_ctxnum = -1;
#line 349
  gts->ts_tlb_int_select = -1;
#line 350
  gts->ts_cch_req_slice = -1;
#line 351
  gts->ts_sizeavail = 1U;
#line 352
  if ((unsigned long )vma != (unsigned long )((struct vm_area_struct *)0)) {
#line 353
    tmp___1 = get_current();
#line 353
    gts->ts_mm = tmp___1->mm;
#line 354
    gts->ts_vma = vma;
#line 355
    gms = gru_register_mmu_notifier();
#line 356
    tmp___2 = IS_ERR((void const   *)gms);
#line 356
    if ((int )tmp___2) {
#line 357
      goto err;
    } else {

    }
#line 358
    gts->ts_gms = gms;
  } else {

  }
#line 361
  if ((int )gru_options & 1) {
#line 361
    __vpp_verify = (void const   *)0;
#line 361
    switch (4UL) {
    case 1UL: ;
#line 361
    switch (4UL) {
    case 1UL: 
#line 361
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 361
    goto ldv_32586;
    case 2UL: 
#line 361
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 361
    goto ldv_32586;
    case 4UL: 
#line 361
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 361
    goto ldv_32586;
    case 8UL: 
#line 361
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 361
    goto ldv_32586;
    default: 
#line 361
    __bad_percpu_size();
    }
    ldv_32586: 
#line 361
    pscr_ret__ = pfo_ret__;
#line 361
    goto ldv_32592;
    case 2UL: ;
#line 361
    switch (4UL) {
    case 1UL: 
#line 361
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 361
    goto ldv_32596;
    case 2UL: 
#line 361
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 361
    goto ldv_32596;
    case 4UL: 
#line 361
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 361
    goto ldv_32596;
    case 8UL: 
#line 361
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 361
    goto ldv_32596;
    default: 
#line 361
    __bad_percpu_size();
    }
    ldv_32596: 
#line 361
    pscr_ret__ = pfo_ret_____0;
#line 361
    goto ldv_32592;
    case 4UL: ;
#line 361
    switch (4UL) {
    case 1UL: 
#line 361
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 361
    goto ldv_32605;
    case 2UL: 
#line 361
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 361
    goto ldv_32605;
    case 4UL: 
#line 361
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 361
    goto ldv_32605;
    case 8UL: 
#line 361
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 361
    goto ldv_32605;
    default: 
#line 361
    __bad_percpu_size();
    }
    ldv_32605: 
#line 361
    pscr_ret__ = pfo_ret_____1;
#line 361
    goto ldv_32592;
    case 8UL: ;
#line 361
    switch (4UL) {
    case 1UL: 
#line 361
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 361
    goto ldv_32614;
    case 2UL: 
#line 361
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 361
    goto ldv_32614;
    case 4UL: 
#line 361
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 361
    goto ldv_32614;
    case 8UL: 
#line 361
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 361
    goto ldv_32614;
    default: 
#line 361
    __bad_percpu_size();
    }
    ldv_32614: 
#line 361
    pscr_ret__ = pfo_ret_____2;
#line 361
    goto ldv_32592;
    default: 
#line 361
    __bad_size_call_parameter();
#line 361
    goto ldv_32592;
    }
    ldv_32592: 
#line 361
    printk("\017GRU:%d %s: alloc gts %p\n", pscr_ret__, "gru_alloc_gts", gts);
  } else {

  }
#line 362
  return (gts);
  err: 
#line 365
  gts_drop(gts);
#line 366
  tmp___3 = ERR_CAST((void const   *)gms);
#line 366
  return ((struct gru_thread_state *)tmp___3);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
struct gru_vma_data *gru_alloc_vma_data(struct vm_area_struct *vma , int tsid ) 
{ 
  struct gru_vma_data *vdata ;
  void *tmp ;
  struct lock_class_key __key ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 374
  vdata = (struct gru_vma_data *)0;
#line 376
  tmp = kmalloc(112UL, 208U);
#line 376
  vdata = (struct gru_vma_data *)tmp;
#line 377
  if ((unsigned long )vdata == (unsigned long )((struct gru_vma_data *)0)) {
#line 378
    return ((struct gru_vma_data *)0);
  } else {

  }
#line 380
  if ((gru_options & 2UL) != 0UL) {
#line 380
    atomic_long_inc(& gru_stats.vdata_alloc);
  } else {

  }
#line 381
  INIT_LIST_HEAD(& vdata->vd_head);
#line 382
  spinlock_check(& vdata->vd_lock);
#line 382
  __raw_spin_lock_init(& vdata->vd_lock.__annonCompField17.rlock, "&(&vdata->vd_lock)->rlock",
                       & __key);
#line 383
  if ((int )gru_options & 1) {
#line 383
    __vpp_verify = (void const   *)0;
#line 383
    switch (4UL) {
    case 1UL: ;
#line 383
    switch (4UL) {
    case 1UL: 
#line 383
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 383
    goto ldv_32634;
    case 2UL: 
#line 383
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 383
    goto ldv_32634;
    case 4UL: 
#line 383
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 383
    goto ldv_32634;
    case 8UL: 
#line 383
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 383
    goto ldv_32634;
    default: 
#line 383
    __bad_percpu_size();
    }
    ldv_32634: 
#line 383
    pscr_ret__ = pfo_ret__;
#line 383
    goto ldv_32640;
    case 2UL: ;
#line 383
    switch (4UL) {
    case 1UL: 
#line 383
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 383
    goto ldv_32644;
    case 2UL: 
#line 383
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 383
    goto ldv_32644;
    case 4UL: 
#line 383
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 383
    goto ldv_32644;
    case 8UL: 
#line 383
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 383
    goto ldv_32644;
    default: 
#line 383
    __bad_percpu_size();
    }
    ldv_32644: 
#line 383
    pscr_ret__ = pfo_ret_____0;
#line 383
    goto ldv_32640;
    case 4UL: ;
#line 383
    switch (4UL) {
    case 1UL: 
#line 383
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 383
    goto ldv_32653;
    case 2UL: 
#line 383
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 383
    goto ldv_32653;
    case 4UL: 
#line 383
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 383
    goto ldv_32653;
    case 8UL: 
#line 383
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 383
    goto ldv_32653;
    default: 
#line 383
    __bad_percpu_size();
    }
    ldv_32653: 
#line 383
    pscr_ret__ = pfo_ret_____1;
#line 383
    goto ldv_32640;
    case 8UL: ;
#line 383
    switch (4UL) {
    case 1UL: 
#line 383
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 383
    goto ldv_32662;
    case 2UL: 
#line 383
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 383
    goto ldv_32662;
    case 4UL: 
#line 383
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 383
    goto ldv_32662;
    case 8UL: 
#line 383
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 383
    goto ldv_32662;
    default: 
#line 383
    __bad_percpu_size();
    }
    ldv_32662: 
#line 383
    pscr_ret__ = pfo_ret_____2;
#line 383
    goto ldv_32640;
    default: 
#line 383
    __bad_size_call_parameter();
#line 383
    goto ldv_32640;
    }
    ldv_32640: 
#line 383
    printk("\017GRU:%d %s: alloc vdata %p\n", pscr_ret__, "gru_alloc_vma_data", vdata);
  } else {

  }
#line 384
  return (vdata);
}
}
#line 390 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
struct gru_thread_state *gru_find_thread_state(struct vm_area_struct *vma , int tsid ) 
{ 
  struct gru_vma_data *vdata ;
  struct gru_thread_state *gts ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 393
  vdata = (struct gru_vma_data *)vma->vm_private_data;
#line 396
  spin_lock(& vdata->vd_lock);
#line 397
  gts = gru_find_current_gts_nolock(vdata, tsid);
#line 398
  spin_unlock(& vdata->vd_lock);
#line 399
  if ((int )gru_options & 1) {
#line 399
    __vpp_verify = (void const   *)0;
#line 399
    switch (4UL) {
    case 1UL: ;
#line 399
    switch (4UL) {
    case 1UL: 
#line 399
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 399
    goto ldv_32682;
    case 2UL: 
#line 399
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 399
    goto ldv_32682;
    case 4UL: 
#line 399
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 399
    goto ldv_32682;
    case 8UL: 
#line 399
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 399
    goto ldv_32682;
    default: 
#line 399
    __bad_percpu_size();
    }
    ldv_32682: 
#line 399
    pscr_ret__ = pfo_ret__;
#line 399
    goto ldv_32688;
    case 2UL: ;
#line 399
    switch (4UL) {
    case 1UL: 
#line 399
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 399
    goto ldv_32692;
    case 2UL: 
#line 399
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 399
    goto ldv_32692;
    case 4UL: 
#line 399
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 399
    goto ldv_32692;
    case 8UL: 
#line 399
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 399
    goto ldv_32692;
    default: 
#line 399
    __bad_percpu_size();
    }
    ldv_32692: 
#line 399
    pscr_ret__ = pfo_ret_____0;
#line 399
    goto ldv_32688;
    case 4UL: ;
#line 399
    switch (4UL) {
    case 1UL: 
#line 399
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 399
    goto ldv_32701;
    case 2UL: 
#line 399
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 399
    goto ldv_32701;
    case 4UL: 
#line 399
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 399
    goto ldv_32701;
    case 8UL: 
#line 399
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 399
    goto ldv_32701;
    default: 
#line 399
    __bad_percpu_size();
    }
    ldv_32701: 
#line 399
    pscr_ret__ = pfo_ret_____1;
#line 399
    goto ldv_32688;
    case 8UL: ;
#line 399
    switch (4UL) {
    case 1UL: 
#line 399
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 399
    goto ldv_32710;
    case 2UL: 
#line 399
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 399
    goto ldv_32710;
    case 4UL: 
#line 399
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 399
    goto ldv_32710;
    case 8UL: 
#line 399
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 399
    goto ldv_32710;
    default: 
#line 399
    __bad_percpu_size();
    }
    ldv_32710: 
#line 399
    pscr_ret__ = pfo_ret_____2;
#line 399
    goto ldv_32688;
    default: 
#line 399
    __bad_size_call_parameter();
#line 399
    goto ldv_32688;
    }
    ldv_32688: 
#line 399
    printk("\017GRU:%d %s: vma %p, gts %p\n", pscr_ret__, "gru_find_thread_state",
           vma, gts);
  } else {

  }
#line 400
  return (gts);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
struct gru_thread_state *gru_alloc_thread_state(struct vm_area_struct *vma , int tsid ) 
{ 
  struct gru_vma_data *vdata ;
  struct gru_thread_state *gts ;
  struct gru_thread_state *ngts ;
  bool tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 410
  vdata = (struct gru_vma_data *)vma->vm_private_data;
#line 413
  gts = gru_alloc_gts(vma, vdata->vd_cbr_au_count, vdata->vd_dsr_au_count, (int )vdata->vd_tlb_preload_count,
                      (int )vdata->vd_user_options, tsid);
#line 417
  tmp = IS_ERR((void const   *)gts);
#line 417
  if ((int )tmp) {
#line 418
    return (gts);
  } else {

  }
#line 420
  spin_lock(& vdata->vd_lock);
#line 421
  ngts = gru_find_current_gts_nolock(vdata, tsid);
#line 422
  if ((unsigned long )ngts != (unsigned long )((struct gru_thread_state *)0)) {
#line 423
    gts_drop(gts);
#line 424
    gts = ngts;
#line 425
    if ((gru_options & 2UL) != 0UL) {
#line 425
      atomic_long_inc(& gru_stats.gts_double_allocate);
    } else {

    }
  } else {
#line 427
    list_add(& gts->ts_next, & vdata->vd_head);
  }
#line 429
  spin_unlock(& vdata->vd_lock);
#line 430
  if ((int )gru_options & 1) {
#line 430
    __vpp_verify = (void const   *)0;
#line 430
    switch (4UL) {
    case 1UL: ;
#line 430
    switch (4UL) {
    case 1UL: 
#line 430
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 430
    goto ldv_32731;
    case 2UL: 
#line 430
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 430
    goto ldv_32731;
    case 4UL: 
#line 430
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 430
    goto ldv_32731;
    case 8UL: 
#line 430
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 430
    goto ldv_32731;
    default: 
#line 430
    __bad_percpu_size();
    }
    ldv_32731: 
#line 430
    pscr_ret__ = pfo_ret__;
#line 430
    goto ldv_32737;
    case 2UL: ;
#line 430
    switch (4UL) {
    case 1UL: 
#line 430
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 430
    goto ldv_32741;
    case 2UL: 
#line 430
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 430
    goto ldv_32741;
    case 4UL: 
#line 430
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 430
    goto ldv_32741;
    case 8UL: 
#line 430
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 430
    goto ldv_32741;
    default: 
#line 430
    __bad_percpu_size();
    }
    ldv_32741: 
#line 430
    pscr_ret__ = pfo_ret_____0;
#line 430
    goto ldv_32737;
    case 4UL: ;
#line 430
    switch (4UL) {
    case 1UL: 
#line 430
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 430
    goto ldv_32750;
    case 2UL: 
#line 430
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 430
    goto ldv_32750;
    case 4UL: 
#line 430
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 430
    goto ldv_32750;
    case 8UL: 
#line 430
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 430
    goto ldv_32750;
    default: 
#line 430
    __bad_percpu_size();
    }
    ldv_32750: 
#line 430
    pscr_ret__ = pfo_ret_____1;
#line 430
    goto ldv_32737;
    case 8UL: ;
#line 430
    switch (4UL) {
    case 1UL: 
#line 430
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 430
    goto ldv_32759;
    case 2UL: 
#line 430
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 430
    goto ldv_32759;
    case 4UL: 
#line 430
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 430
    goto ldv_32759;
    case 8UL: 
#line 430
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 430
    goto ldv_32759;
    default: 
#line 430
    __bad_percpu_size();
    }
    ldv_32759: 
#line 430
    pscr_ret__ = pfo_ret_____2;
#line 430
    goto ldv_32737;
    default: 
#line 430
    __bad_size_call_parameter();
#line 430
    goto ldv_32737;
    }
    ldv_32737: 
#line 430
    printk("\017GRU:%d %s: vma %p, gts %p\n", pscr_ret__, "gru_alloc_thread_state",
           vma, gts);
  } else {

  }
#line 431
  return (gts);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static void gru_free_gru_context(struct gru_thread_state *gts ) 
{ 
  struct gru_state *gru ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp ;
  long tmp___0 ;

  {
#line 441
  gru = gts->ts_gru;
#line 442
  if ((int )gru_options & 1) {
#line 442
    __vpp_verify = (void const   *)0;
#line 442
    switch (4UL) {
    case 1UL: ;
#line 442
    switch (4UL) {
    case 1UL: 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_32777;
    case 2UL: 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_32777;
    case 4UL: 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_32777;
    case 8UL: 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_32777;
    default: 
#line 442
    __bad_percpu_size();
    }
    ldv_32777: 
#line 442
    pscr_ret__ = pfo_ret__;
#line 442
    goto ldv_32783;
    case 2UL: ;
#line 442
    switch (4UL) {
    case 1UL: 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_32787;
    case 2UL: 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_32787;
    case 4UL: 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_32787;
    case 8UL: 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_32787;
    default: 
#line 442
    __bad_percpu_size();
    }
    ldv_32787: 
#line 442
    pscr_ret__ = pfo_ret_____0;
#line 442
    goto ldv_32783;
    case 4UL: ;
#line 442
    switch (4UL) {
    case 1UL: 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_32796;
    case 2UL: 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_32796;
    case 4UL: 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_32796;
    case 8UL: 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_32796;
    default: 
#line 442
    __bad_percpu_size();
    }
    ldv_32796: 
#line 442
    pscr_ret__ = pfo_ret_____1;
#line 442
    goto ldv_32783;
    case 8UL: ;
#line 442
    switch (4UL) {
    case 1UL: 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_32805;
    case 2UL: 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_32805;
    case 4UL: 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_32805;
    case 8UL: 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_32805;
    default: 
#line 442
    __bad_percpu_size();
    }
    ldv_32805: 
#line 442
    pscr_ret__ = pfo_ret_____2;
#line 442
    goto ldv_32783;
    default: 
#line 442
    __bad_size_call_parameter();
#line 442
    goto ldv_32783;
    }
    ldv_32783: 
#line 442
    printk("\017GRU:%d %s: gts %p, gid %d\n", pscr_ret__, "gru_free_gru_context",
           gts, (int )gru->gs_gid);
  } else {

  }
#line 444
  spin_lock(& gru->gs_lock);
#line 445
  gru->gs_gts[gts->ts_ctxnum] = (struct gru_thread_state *)0;
#line 446
  free_gru_resources(gru, gts);
#line 447
  tmp = variable_test_bit((long )gts->ts_ctxnum, (unsigned long const volatile   *)(& gru->gs_context_map));
#line 447
  tmp___0 = ldv__builtin_expect(tmp == 0, 0L);
#line 447
  if (tmp___0 != 0L) {
#line 447
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"),
                         "i" (447), "i" (12UL));
    ldv_32814: ;
#line 447
    goto ldv_32814;
  } else {

  }
#line 448
  __clear_bit((long )gts->ts_ctxnum, (unsigned long volatile   *)(& gru->gs_context_map));
#line 449
  gts->ts_ctxnum = -1;
#line 450
  gts->ts_gru = (struct gru_state *)0;
#line 451
  gts->ts_blade = -1;
#line 452
  spin_unlock(& gru->gs_lock);
#line 454
  gts_drop(gts);
#line 455
  if ((gru_options & 2UL) != 0UL) {
#line 455
    atomic_long_inc(& gru_stats.free_context);
  } else {

  }
#line 456
  return;
}
}
#line 462 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static void prefetch_data(void *p , int num , int stride ) 
{ 
  int tmp ;

  {
#line 464
  goto ldv_32821;
  ldv_32820: 
#line 465
  prefetchw((void const   *)p);
#line 466
  p = p + (unsigned long )stride;
  ldv_32821: 
#line 464
  tmp = num;
#line 464
  num = num - 1;
#line 464
  if (tmp > 0) {
#line 466
    goto ldv_32820;
  } else {

  }

#line 471
  return;
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
__inline static long gru_copy_handle(void *d , void *s ) 
{ 


  {
#line 472
  memcpy(d, (void const   *)s, 64UL);
#line 473
  return (64L);
}
}
#line 476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static void gru_prefetch_context(void *gseg , void *cb , void *cbe , unsigned long cbrmap ,
                                 unsigned long length ) 
{ 
  int i ;
  int scr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 481
  prefetch_data(gseg + 131072UL, (int )(length / 64UL), 64);
#line 484
  tmp = find_first_bit((unsigned long const   *)(& cbrmap), 64UL);
#line 484
  scr = (int )tmp;
#line 484
  goto ldv_32840;
  ldv_32839: 
#line 484
  i = scr * 2;
#line 484
  goto ldv_32837;
  ldv_32836: 
#line 485
  prefetch_data(cb, 1, 64);
#line 486
  prefetch_data(cbe + (unsigned long )(i * 256), 1, 64);
#line 488
  cb = cb + 256UL;
#line 484
  i = i + 1;
  ldv_32837: ;
#line 484
  if ((scr + 1) * 2 > i) {
#line 486
    goto ldv_32836;
  } else {

  }
#line 484
  tmp___0 = find_next_bit((unsigned long const   *)(& cbrmap), 64UL, (unsigned long )(scr + 1));
#line 484
  scr = (int )tmp___0;
  ldv_32840: ;
#line 484
  if (scr <= 63) {
#line 486
    goto ldv_32839;
  } else {

  }

#line 491
  return;
}
}
#line 492 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static void gru_load_context_data(void *save , void *grubase , int ctxnum , unsigned long cbrmap ,
                                  unsigned long dsrmap , int data_valid ) 
{ 
  void *gseg ;
  void *cb ;
  void *cbe ;
  unsigned long length ;
  int i ;
  int scr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 500
  gseg = grubase + (unsigned long )(ctxnum * 4194304);
#line 501
  cb = gseg;
#line 502
  cbe = grubase + 67174400UL;
#line 503
  tmp = __arch_hweight64((__u64 )dsrmap);
#line 503
  length = tmp * 1024UL;
#line 504
  gru_prefetch_context(gseg, cb, cbe, cbrmap, length);
#line 506
  tmp___0 = find_first_bit((unsigned long const   *)(& cbrmap), 64UL);
#line 506
  scr = (int )tmp___0;
#line 506
  goto ldv_32860;
  ldv_32859: 
#line 506
  i = scr * 2;
#line 506
  goto ldv_32857;
  ldv_32856: ;
#line 507
  if (data_valid != 0) {
#line 508
    tmp___1 = gru_copy_handle(cb, save);
#line 508
    save = save + (unsigned long )tmp___1;
#line 509
    tmp___2 = gru_copy_handle(cbe + (unsigned long )(i * 256), save);
#line 509
    save = save + (unsigned long )tmp___2;
  } else {
#line 512
    memset(cb, 0, 64UL);
#line 513
    memset(cbe + (unsigned long )(i * 256), 0, 64UL);
  }
#line 517
  __asm__  volatile   ("mfence": : : "memory");
#line 518
  gru_flush_cache(cbe + (unsigned long )(i * 256));
#line 519
  cb = cb + 256UL;
#line 506
  i = i + 1;
  ldv_32857: ;
#line 506
  if ((scr + 1) * 2 > i) {
#line 508
    goto ldv_32856;
  } else {

  }
#line 506
  tmp___3 = find_next_bit((unsigned long const   *)(& cbrmap), 64UL, (unsigned long )(scr + 1));
#line 506
  scr = (int )tmp___3;
  ldv_32860: ;
#line 506
  if (scr <= 63) {
#line 508
    goto ldv_32859;
  } else {

  }

#line 522
  if (data_valid != 0) {
#line 523
    memcpy(gseg + 131072UL, (void const   *)save, length);
  } else {
#line 525
    memset(gseg + 131072UL, 0, length);
  }
#line 526
  return;
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static void gru_unload_context_data(void *save , void *grubase , int ctxnum , unsigned long cbrmap ,
                                    unsigned long dsrmap ) 
{ 
  void *gseg ;
  void *cb ;
  void *cbe ;
  unsigned long length ;
  int i ;
  int scr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 535
  gseg = grubase + (unsigned long )(ctxnum * 4194304);
#line 536
  cb = gseg;
#line 537
  cbe = grubase + 67174400UL;
#line 538
  tmp = __arch_hweight64((__u64 )dsrmap);
#line 538
  length = tmp * 1024UL;
#line 541
  tmp___0 = find_first_bit((unsigned long const   *)(& cbrmap), 64UL);
#line 541
  scr = (int )tmp___0;
#line 541
  goto ldv_32879;
  ldv_32878: 
#line 541
  i = scr * 2;
#line 541
  goto ldv_32876;
  ldv_32875: 
#line 542
  gru_flush_cache(cbe + (unsigned long )(i * 256));
#line 541
  i = i + 1;
  ldv_32876: ;
#line 541
  if ((scr + 1) * 2 > i) {
#line 543
    goto ldv_32875;
  } else {

  }
#line 541
  tmp___1 = find_next_bit((unsigned long const   *)(& cbrmap), 64UL, (unsigned long )(scr + 1));
#line 541
  scr = (int )tmp___1;
  ldv_32879: ;
#line 541
  if (scr <= 63) {
#line 543
    goto ldv_32878;
  } else {

  }
#line 543
  __asm__  volatile   ("mfence": : : "memory");
#line 545
  gru_prefetch_context(gseg, cb, cbe, cbrmap, length);
#line 547
  tmp___2 = find_first_bit((unsigned long const   *)(& cbrmap), 64UL);
#line 547
  scr = (int )tmp___2;
#line 547
  goto ldv_32885;
  ldv_32884: 
#line 547
  i = scr * 2;
#line 547
  goto ldv_32882;
  ldv_32881: 
#line 548
  tmp___3 = gru_copy_handle(save, cb);
#line 548
  save = save + (unsigned long )tmp___3;
#line 549
  tmp___4 = gru_copy_handle(save, cbe + (unsigned long )(i * 256));
#line 549
  save = save + (unsigned long )tmp___4;
#line 550
  cb = cb + 256UL;
#line 547
  i = i + 1;
  ldv_32882: ;
#line 547
  if ((scr + 1) * 2 > i) {
#line 549
    goto ldv_32881;
  } else {

  }
#line 547
  tmp___5 = find_next_bit((unsigned long const   *)(& cbrmap), 64UL, (unsigned long )(scr + 1));
#line 547
  scr = (int )tmp___5;
  ldv_32885: ;
#line 547
  if (scr <= 63) {
#line 549
    goto ldv_32884;
  } else {

  }
#line 552
  memcpy(save, (void const   *)gseg + 131072U, length);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
void gru_unload_context(struct gru_thread_state *gts , int savestate ) 
{ 
  struct gru_state *gru ;
  struct gru_context_configuration_handle *cch ;
  int ctxnum ;
  int tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 557
  gru = gts->ts_gru;
#line 559
  ctxnum = gts->ts_ctxnum;
#line 561
  tmp = is_kernel_context(gts);
#line 561
  if (tmp == 0) {
#line 562
    zap_vma_ptes(gts->ts_vma, (gts->ts_vma)->vm_start + (unsigned long )gts->ts_tsid * 262144UL,
                 262144UL);
  } else {

  }
#line 563
  cch = get_cch(gru->gs_gru_base_vaddr, ctxnum);
#line 565
  if ((int )gru_options & 1) {
#line 565
    __vpp_verify = (void const   *)0;
#line 565
    switch (4UL) {
    case 1UL: ;
#line 566
    switch (4UL) {
    case 1UL: 
#line 566
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 566
    goto ldv_32899;
    case 2UL: 
#line 566
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 566
    goto ldv_32899;
    case 4UL: 
#line 566
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 566
    goto ldv_32899;
    case 8UL: 
#line 566
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 566
    goto ldv_32899;
    default: 
#line 566
    __bad_percpu_size();
    }
    ldv_32899: 
#line 566
    pscr_ret__ = pfo_ret__;
#line 566
    goto ldv_32905;
    case 2UL: ;
#line 566
    switch (4UL) {
    case 1UL: 
#line 566
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 566
    goto ldv_32909;
    case 2UL: 
#line 566
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 566
    goto ldv_32909;
    case 4UL: 
#line 566
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 566
    goto ldv_32909;
    case 8UL: 
#line 566
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 566
    goto ldv_32909;
    default: 
#line 566
    __bad_percpu_size();
    }
    ldv_32909: 
#line 566
    pscr_ret__ = pfo_ret_____0;
#line 566
    goto ldv_32905;
    case 4UL: ;
#line 566
    switch (4UL) {
    case 1UL: 
#line 566
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 566
    goto ldv_32918;
    case 2UL: 
#line 566
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 566
    goto ldv_32918;
    case 4UL: 
#line 566
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 566
    goto ldv_32918;
    case 8UL: 
#line 566
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 566
    goto ldv_32918;
    default: 
#line 566
    __bad_percpu_size();
    }
    ldv_32918: 
#line 566
    pscr_ret__ = pfo_ret_____1;
#line 566
    goto ldv_32905;
    case 8UL: ;
#line 566
    switch (4UL) {
    case 1UL: 
#line 566
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 566
    goto ldv_32927;
    case 2UL: 
#line 566
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 566
    goto ldv_32927;
    case 4UL: 
#line 566
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 566
    goto ldv_32927;
    case 8UL: 
#line 566
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 566
    goto ldv_32927;
    default: 
#line 566
    __bad_percpu_size();
    }
    ldv_32927: 
#line 566
    pscr_ret__ = pfo_ret_____2;
#line 566
    goto ldv_32905;
    default: 
#line 566
    __bad_size_call_parameter();
#line 566
    goto ldv_32905;
    }
    ldv_32905: 
#line 566
    printk("\017GRU:%d %s: gts %p, cbrmap 0x%lx, dsrmap 0x%lx\n", pscr_ret__, "gru_unload_context",
           gts, gts->ts_cbr_map, gts->ts_dsr_map);
  } else {

  }
#line 567
  lock_cch_handle(cch);
#line 568
  tmp___0 = cch_interrupt_sync(cch);
#line 568
  if (tmp___0 != 0) {
#line 569
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"),
                         "i" (569), "i" (12UL));
    ldv_32936: ;
#line 569
    goto ldv_32936;
  } else {

  }
#line 571
  tmp___1 = is_kernel_context(gts);
#line 571
  if (tmp___1 == 0) {
#line 572
    gru_unload_mm_tracker(gru, gts);
  } else {

  }
#line 573
  if (savestate != 0) {
#line 574
    gru_unload_context_data((void *)(& gts->ts_gdata), gru->gs_gru_base_vaddr, ctxnum,
                            gts->ts_cbr_map, gts->ts_dsr_map);
#line 577
    gts->ts_data_valid = 1;
  } else {

  }
#line 580
  tmp___2 = cch_deallocate(cch);
#line 580
  if (tmp___2 != 0) {
#line 581
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"),
                         "i" (581), "i" (12UL));
    ldv_32937: ;
#line 581
    goto ldv_32937;
  } else {

  }
#line 582
  unlock_cch_handle(cch);
#line 584
  gru_free_gru_context(gts);
#line 585
  return;
}
}
#line 591 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
void gru_load_context(struct gru_thread_state *gts ) 
{ 
  struct gru_state *gru ;
  struct gru_context_configuration_handle *cch ;
  int i ;
  int err ;
  int asid ;
  int ctxnum ;
  int tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___0 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;

  {
#line 593
  gru = gts->ts_gru;
#line 595
  ctxnum = gts->ts_ctxnum;
#line 597
  cch = get_cch(gru->gs_gru_base_vaddr, ctxnum);
#line 598
  lock_cch_handle(cch);
#line 599
  cch->tfm_fault_bit_enable = (unsigned char )(gts->ts_user_options == 3L || gts->ts_user_options == 2L);
#line 602
  cch->tlb_int_enable = gts->ts_user_options == 2L;
#line 603
  if ((unsigned int )*((unsigned char *)cch + 1UL) != 0U) {
#line 604
    gts->ts_tlb_int_select = gru_cpu_fault_map_id();
#line 605
    cch->tlb_int_select = (unsigned char )gts->ts_tlb_int_select;
  } else {

  }
#line 607
  if ((int )((signed char )gts->ts_cch_req_slice) >= 0) {
#line 608
    cch->req_slice_set_enable = 1U;
#line 609
    cch->req_slice = (unsigned char )gts->ts_cch_req_slice;
  } else {
#line 611
    cch->req_slice_set_enable = 0U;
  }
#line 613
  cch->tfm_done_bit_enable = 0U;
#line 614
  cch->dsr_allocation_map = (unsigned int )gts->ts_dsr_map;
#line 615
  cch->cbr_allocation_map = gts->ts_cbr_map;
#line 617
  tmp = is_kernel_context(gts);
#line 617
  if (tmp != 0) {
#line 618
    cch->unmap_enable = 1U;
#line 619
    cch->tfm_done_bit_enable = 1U;
#line 620
    cch->cb_int_enable = 1U;
#line 621
    cch->tlb_int_select = 0U;
  } else {
#line 623
    cch->unmap_enable = 0U;
#line 624
    cch->tfm_done_bit_enable = 0U;
#line 625
    cch->cb_int_enable = 0U;
#line 626
    asid = gru_load_mm_tracker(gru, gts);
#line 627
    i = 0;
#line 627
    goto ldv_32948;
    ldv_32947: 
#line 628
    cch->asid[i] = (unsigned int )(asid + i);
#line 629
    cch->sizeavail[i] = gts->ts_sizeavail;
#line 627
    i = i + 1;
    ldv_32948: ;
#line 627
    if (i <= 7) {
#line 629
      goto ldv_32947;
    } else {

    }

  }
#line 633
  err = cch_allocate(cch);
#line 634
  if (err != 0) {
#line 635
    if ((int )gru_options & 1) {
#line 635
      __vpp_verify = (void const   *)0;
#line 635
      switch (4UL) {
      case 1UL: ;
#line 637
      switch (4UL) {
      case 1UL: 
#line 637
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 637
      goto ldv_32955;
      case 2UL: 
#line 637
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 637
      goto ldv_32955;
      case 4UL: 
#line 637
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 637
      goto ldv_32955;
      case 8UL: 
#line 637
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 637
      goto ldv_32955;
      default: 
#line 637
      __bad_percpu_size();
      }
      ldv_32955: 
#line 637
      pscr_ret__ = pfo_ret__;
#line 637
      goto ldv_32961;
      case 2UL: ;
#line 637
      switch (4UL) {
      case 1UL: 
#line 637
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 637
      goto ldv_32965;
      case 2UL: 
#line 637
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 637
      goto ldv_32965;
      case 4UL: 
#line 637
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 637
      goto ldv_32965;
      case 8UL: 
#line 637
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 637
      goto ldv_32965;
      default: 
#line 637
      __bad_percpu_size();
      }
      ldv_32965: 
#line 637
      pscr_ret__ = pfo_ret_____0;
#line 637
      goto ldv_32961;
      case 4UL: ;
#line 637
      switch (4UL) {
      case 1UL: 
#line 637
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 637
      goto ldv_32974;
      case 2UL: 
#line 637
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 637
      goto ldv_32974;
      case 4UL: 
#line 637
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 637
      goto ldv_32974;
      case 8UL: 
#line 637
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 637
      goto ldv_32974;
      default: 
#line 637
      __bad_percpu_size();
      }
      ldv_32974: 
#line 637
      pscr_ret__ = pfo_ret_____1;
#line 637
      goto ldv_32961;
      case 8UL: ;
#line 637
      switch (4UL) {
      case 1UL: 
#line 637
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 637
      goto ldv_32983;
      case 2UL: 
#line 637
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 637
      goto ldv_32983;
      case 4UL: 
#line 637
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 637
      goto ldv_32983;
      case 8UL: 
#line 637
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 637
      goto ldv_32983;
      default: 
#line 637
      __bad_percpu_size();
      }
      ldv_32983: 
#line 637
      pscr_ret__ = pfo_ret_____2;
#line 637
      goto ldv_32961;
      default: 
#line 637
      __bad_size_call_parameter();
#line 637
      goto ldv_32961;
      }
      ldv_32961: 
#line 637
      printk("\017GRU:%d %s: err %d: cch %p, gts %p, cbr 0x%lx, dsr 0x%lx\n", pscr_ret__,
             "gru_load_context", err, cch, gts, gts->ts_cbr_map, gts->ts_dsr_map);
    } else {

    }
#line 638
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"),
                         "i" (638), "i" (12UL));
    ldv_32992: ;
#line 638
    goto ldv_32992;
  } else {

  }
#line 641
  gru_load_context_data((void *)(& gts->ts_gdata), gru->gs_gru_base_vaddr, ctxnum,
                        gts->ts_cbr_map, gts->ts_dsr_map, gts->ts_data_valid);
#line 644
  tmp___0 = cch_start(cch);
#line 644
  if (tmp___0 != 0) {
#line 645
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"),
                         "i" (645), "i" (12UL));
    ldv_32993: ;
#line 645
    goto ldv_32993;
  } else {

  }
#line 646
  unlock_cch_handle(cch);
#line 648
  if ((int )gru_options & 1) {
#line 648
    __vpp_verify___0 = (void const   *)0;
#line 648
    switch (4UL) {
    case 1UL: ;
#line 650
    switch (4UL) {
    case 1UL: 
#line 650
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 650
    goto ldv_32999;
    case 2UL: 
#line 650
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 650
    goto ldv_32999;
    case 4UL: 
#line 650
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 650
    goto ldv_32999;
    case 8UL: 
#line 650
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 650
    goto ldv_32999;
    default: 
#line 650
    __bad_percpu_size();
    }
    ldv_32999: 
#line 650
    pscr_ret_____0 = pfo_ret_____3;
#line 650
    goto ldv_33005;
    case 2UL: ;
#line 650
    switch (4UL) {
    case 1UL: 
#line 650
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 650
    goto ldv_33009;
    case 2UL: 
#line 650
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 650
    goto ldv_33009;
    case 4UL: 
#line 650
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 650
    goto ldv_33009;
    case 8UL: 
#line 650
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 650
    goto ldv_33009;
    default: 
#line 650
    __bad_percpu_size();
    }
    ldv_33009: 
#line 650
    pscr_ret_____0 = pfo_ret_____4;
#line 650
    goto ldv_33005;
    case 4UL: ;
#line 650
    switch (4UL) {
    case 1UL: 
#line 650
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 650
    goto ldv_33018;
    case 2UL: 
#line 650
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 650
    goto ldv_33018;
    case 4UL: 
#line 650
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 650
    goto ldv_33018;
    case 8UL: 
#line 650
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 650
    goto ldv_33018;
    default: 
#line 650
    __bad_percpu_size();
    }
    ldv_33018: 
#line 650
    pscr_ret_____0 = pfo_ret_____5;
#line 650
    goto ldv_33005;
    case 8UL: ;
#line 650
    switch (4UL) {
    case 1UL: 
#line 650
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 650
    goto ldv_33027;
    case 2UL: 
#line 650
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 650
    goto ldv_33027;
    case 4UL: 
#line 650
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 650
    goto ldv_33027;
    case 8UL: 
#line 650
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 650
    goto ldv_33027;
    default: 
#line 650
    __bad_percpu_size();
    }
    ldv_33027: 
#line 650
    pscr_ret_____0 = pfo_ret_____6;
#line 650
    goto ldv_33005;
    default: 
#line 650
    __bad_size_call_parameter();
#line 650
    goto ldv_33005;
    }
    ldv_33005: 
#line 650
    printk("\017GRU:%d %s: gid %d, gts %p, cbrmap 0x%lx, dsrmap 0x%lx, tie %d, tis %d\n",
           pscr_ret_____0, "gru_load_context", (int )(gts->ts_gru)->gs_gid, gts, gts->ts_cbr_map,
           gts->ts_dsr_map, gts->ts_user_options == 2L, gts->ts_tlb_int_select);
  } else {

  }
#line 651
  return;
}
}
#line 658 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
int gru_update_cch(struct gru_thread_state *gts ) 
{ 
  struct gru_context_configuration_handle *cch ;
  struct gru_state *gru ;
  int i ;
  int ctxnum ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 661
  gru = gts->ts_gru;
#line 662
  ctxnum = gts->ts_ctxnum;
#line 662
  ret = 0;
#line 664
  cch = get_cch(gru->gs_gru_base_vaddr, ctxnum);
#line 666
  lock_cch_handle(cch);
#line 667
  if ((unsigned int )*((unsigned char *)cch + 2UL) == 8U) {
#line 668
    if ((unsigned long )gru->gs_gts[gts->ts_ctxnum] != (unsigned long )gts) {
#line 669
      goto exit;
    } else {

    }
#line 670
    tmp = cch_interrupt(cch);
#line 670
    if (tmp != 0) {
#line 671
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"),
                           "i" (671), "i" (12UL));
      ldv_33044: ;
#line 671
      goto ldv_33044;
    } else {

    }
#line 672
    i = 0;
#line 672
    goto ldv_33046;
    ldv_33045: 
#line 673
    cch->sizeavail[i] = gts->ts_sizeavail;
#line 672
    i = i + 1;
    ldv_33046: ;
#line 672
    if (i <= 7) {
#line 674
      goto ldv_33045;
    } else {

    }
#line 674
    gts->ts_tlb_int_select = gru_cpu_fault_map_id();
#line 675
    tmp___0 = gru_cpu_fault_map_id();
#line 675
    cch->tlb_int_select = (unsigned char )tmp___0;
#line 676
    cch->tfm_fault_bit_enable = (unsigned char )(gts->ts_user_options == 3L || gts->ts_user_options == 2L);
#line 679
    tmp___1 = cch_start(cch);
#line 679
    if (tmp___1 != 0) {
#line 680
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"),
                           "i" (680), "i" (12UL));
      ldv_33048: ;
#line 680
      goto ldv_33048;
    } else {

    }
#line 681
    ret = 1;
  } else {

  }
  exit: 
#line 684
  unlock_cch_handle(cch);
#line 685
  return (ret);
}
}
#line 695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static int gru_retarget_intr(struct gru_thread_state *gts ) 
{ 
  int tmp ;
  int tmp___0 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___1 ;

  {
#line 697
  if (gts->ts_tlb_int_select < 0) {
#line 699
    return (0);
  } else {
#line 697
    tmp = gru_cpu_fault_map_id();
#line 697
    if (gts->ts_tlb_int_select == tmp) {
#line 699
      return (0);
    } else {

    }
  }
#line 701
  if ((int )gru_options & 1) {
#line 701
    tmp___0 = gru_cpu_fault_map_id();
#line 701
    __vpp_verify = (void const   *)0;
#line 701
    switch (4UL) {
    case 1UL: ;
#line 702
    switch (4UL) {
    case 1UL: 
#line 702
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 702
    goto ldv_33057;
    case 2UL: 
#line 702
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 702
    goto ldv_33057;
    case 4UL: 
#line 702
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 702
    goto ldv_33057;
    case 8UL: 
#line 702
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 702
    goto ldv_33057;
    default: 
#line 702
    __bad_percpu_size();
    }
    ldv_33057: 
#line 702
    pscr_ret__ = pfo_ret__;
#line 702
    goto ldv_33063;
    case 2UL: ;
#line 702
    switch (4UL) {
    case 1UL: 
#line 702
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 702
    goto ldv_33067;
    case 2UL: 
#line 702
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 702
    goto ldv_33067;
    case 4UL: 
#line 702
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 702
    goto ldv_33067;
    case 8UL: 
#line 702
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 702
    goto ldv_33067;
    default: 
#line 702
    __bad_percpu_size();
    }
    ldv_33067: 
#line 702
    pscr_ret__ = pfo_ret_____0;
#line 702
    goto ldv_33063;
    case 4UL: ;
#line 702
    switch (4UL) {
    case 1UL: 
#line 702
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 702
    goto ldv_33076;
    case 2UL: 
#line 702
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 702
    goto ldv_33076;
    case 4UL: 
#line 702
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 702
    goto ldv_33076;
    case 8UL: 
#line 702
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 702
    goto ldv_33076;
    default: 
#line 702
    __bad_percpu_size();
    }
    ldv_33076: 
#line 702
    pscr_ret__ = pfo_ret_____1;
#line 702
    goto ldv_33063;
    case 8UL: ;
#line 702
    switch (4UL) {
    case 1UL: 
#line 702
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 702
    goto ldv_33085;
    case 2UL: 
#line 702
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 702
    goto ldv_33085;
    case 4UL: 
#line 702
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 702
    goto ldv_33085;
    case 8UL: 
#line 702
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 702
    goto ldv_33085;
    default: 
#line 702
    __bad_percpu_size();
    }
    ldv_33085: 
#line 702
    pscr_ret__ = pfo_ret_____2;
#line 702
    goto ldv_33063;
    default: 
#line 702
    __bad_size_call_parameter();
#line 702
    goto ldv_33063;
    }
    ldv_33063: 
#line 702
    printk("\017GRU:%d %s: retarget from %d to %d\n", pscr_ret__, "gru_retarget_intr",
           gts->ts_tlb_int_select, tmp___0);
  } else {

  }
#line 703
  tmp___1 = gru_update_cch(gts);
#line 703
  return (tmp___1);
}
}
#line 712 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static int gru_check_chiplet_assignment(struct gru_state *gru , struct gru_thread_state *gts ) 
{ 
  int blade_id ;
  int chiplet_id ;

  {
#line 718
  blade_id = (int )gts->ts_user_blade_id;
#line 719
  if (blade_id < 0) {
#line 720
    blade_id = uv_numa_blade_id();
  } else {

  }
#line 722
  chiplet_id = (int )gts->ts_user_chiplet_id;
#line 723
  return ((int )gru->gs_blade_id == blade_id && (chiplet_id < 0 || (int )gru->gs_chiplet_id == chiplet_id));
}
}
#line 732 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
void gru_check_context_placement(struct gru_thread_state *gts ) 
{ 
  struct gru_state *gru ;
  struct task_struct *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 741
  gru = gts->ts_gru;
#line 742
  if ((unsigned long )gru == (unsigned long )((struct gru_state *)0)) {
#line 743
    return;
  } else {
#line 742
    tmp = get_current();
#line 742
    if (gts->ts_tgid_owner != tmp->tgid) {
#line 743
      return;
    } else {

    }
  }
#line 745
  tmp___1 = gru_check_chiplet_assignment(gru, gts);
#line 745
  if (tmp___1 == 0) {
#line 746
    if ((gru_options & 2UL) != 0UL) {
#line 746
      atomic_long_inc(& gru_stats.check_context_unload);
    } else {

    }
#line 747
    gru_unload_context(gts, 1);
  } else {
#line 748
    tmp___0 = gru_retarget_intr(gts);
#line 748
    if (tmp___0 != 0) {
#line 749
      if ((gru_options & 2UL) != 0UL) {
#line 749
        atomic_long_inc(& gru_stats.check_context_retarget_intr);
      } else {

      }
    } else {

    }
  }
#line 750
  return;
}
}
#line 762 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static int is_gts_stealable(struct gru_thread_state *gts , struct gru_blade_state *bs ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 765
  tmp___1 = is_kernel_context(gts);
#line 765
  if (tmp___1 != 0) {
#line 766
    tmp = down_write_trylock(& bs->bs_kgts_sema);
#line 766
    return (tmp);
  } else {
#line 768
    tmp___0 = ldv_mutex_trylock_40(& gts->ts_ctxlock);
#line 768
    return (tmp___0);
  }
}
}
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static void gts_stolen(struct gru_thread_state *gts , struct gru_blade_state *bs ) 
{ 
  int tmp ;

  {
#line 774
  tmp = is_kernel_context(gts);
#line 774
  if (tmp != 0) {
#line 775
    up_write(& bs->bs_kgts_sema);
#line 776
    if ((gru_options & 2UL) != 0UL) {
#line 776
      atomic_long_inc(& gru_stats.steal_kernel_context);
    } else {

    }
  } else {
#line 778
    ldv_mutex_unlock_41(& gts->ts_ctxlock);
#line 779
    if ((gru_options & 2UL) != 0UL) {
#line 779
      atomic_long_inc(& gru_stats.steal_user_context);
    } else {

    }
  }
#line 781
  return;
}
}
#line 783 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
void gru_steal_context(struct gru_thread_state *gts ) 
{ 
  struct gru_blade_state *blade ;
  struct gru_state *gru ;
  struct gru_state *gru0 ;
  struct gru_thread_state *ngts ;
  int ctxnum ;
  int ctxnum0 ;
  int flag ;
  int cbr ;
  int dsr ;
  int blade_id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 787
  ngts = (struct gru_thread_state *)0;
#line 788
  flag = 0;
#line 791
  blade_id = (int )gts->ts_user_blade_id;
#line 792
  if (blade_id < 0) {
#line 793
    blade_id = uv_numa_blade_id();
  } else {

  }
#line 794
  cbr = (int )gts->ts_cbr_au_count;
#line 795
  dsr = (int )gts->ts_dsr_au_count;
#line 797
  blade = gru_base[blade_id];
#line 798
  spin_lock(& blade->bs_lock);
#line 800
  ctxnum = blade->bs_lru_ctxnum <= 13 ? blade->bs_lru_ctxnum + 1 : 0;
#line 801
  gru = blade->bs_lru_gru;
#line 802
  if (ctxnum == 0) {
#line 803
    gru = (unsigned long )((struct gru_state *)(& blade->bs_grus) + 1UL) > (unsigned long )gru ? gru + 1UL : (struct gru_state *)(& blade->bs_grus);
  } else {

  }
#line 804
  blade->bs_lru_gru = gru;
#line 805
  blade->bs_lru_ctxnum = ctxnum;
#line 806
  ctxnum0 = ctxnum;
#line 807
  gru0 = gru;
  ldv_33129: 
#line 809
  tmp___1 = gru_check_chiplet_assignment(gru, gts);
#line 809
  if (tmp___1 != 0) {
#line 810
    tmp = check_gru_resources(gru, cbr, dsr, 16);
#line 810
    if (tmp != 0) {
#line 811
      goto ldv_33125;
    } else {

    }
#line 812
    spin_lock(& gru->gs_lock);
#line 813
    goto ldv_33128;
    ldv_33127: ;
#line 814
    if ((flag != 0 && (unsigned long )gru == (unsigned long )gru0) && ctxnum == ctxnum0) {
#line 815
      goto ldv_33126;
    } else {

    }
#line 816
    ngts = gru->gs_gts[ctxnum];
#line 823
    if ((unsigned long )ngts != (unsigned long )((struct gru_thread_state *)0)) {
#line 823
      tmp___0 = is_gts_stealable(ngts, blade);
#line 823
      if (tmp___0 != 0) {
#line 824
        goto ldv_33126;
      } else {

      }
    } else {

    }
#line 825
    ngts = (struct gru_thread_state *)0;
#line 813
    ctxnum = ctxnum + 1;
    ldv_33128: ;
#line 813
    if (ctxnum <= 15) {
#line 815
      goto ldv_33127;
    } else {

    }
    ldv_33126: 
#line 827
    spin_unlock(& gru->gs_lock);
#line 828
    if ((unsigned long )ngts != (unsigned long )((struct gru_thread_state *)0) || ((flag != 0 && (unsigned long )gru == (unsigned long )gru0) && ctxnum == ctxnum0)) {
#line 829
      goto ldv_33125;
    } else {

    }
  } else {

  }
#line 831
  if (flag != 0 && (unsigned long )gru == (unsigned long )gru0) {
#line 832
    goto ldv_33125;
  } else {

  }
#line 833
  flag = 1;
#line 834
  ctxnum = 0;
#line 835
  gru = (unsigned long )((struct gru_state *)(& blade->bs_grus) + 1UL) > (unsigned long )gru ? gru + 1UL : (struct gru_state *)(& blade->bs_grus);
#line 836
  goto ldv_33129;
  ldv_33125: 
#line 837
  spin_unlock(& blade->bs_lock);
#line 839
  if ((unsigned long )ngts != (unsigned long )((struct gru_thread_state *)0)) {
#line 840
    gts->ustats.context_stolen = gts->ustats.context_stolen + 1UL;
#line 841
    ngts->ts_steal_jiffies = jiffies;
#line 842
    tmp___2 = is_kernel_context(ngts);
#line 842
    gru_unload_context(ngts, tmp___2 == 0);
#line 843
    gts_stolen(ngts, blade);
  } else
#line 845
  if ((gru_options & 2UL) != 0UL) {
#line 845
    atomic_long_inc(& gru_stats.steal_context_failed);
  } else {

  }
#line 847
  if ((int )gru_options & 1) {
#line 847
    tmp___3 = __arch_hweight64((__u64 )gru->gs_dsr_map);
#line 847
    tmp___4 = __arch_hweight64((__u64 )gru->gs_cbr_map);
#line 847
    __vpp_verify = (void const   *)0;
#line 847
    switch (4UL) {
    case 1UL: ;
#line 851
    switch (4UL) {
    case 1UL: 
#line 851
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 851
    goto ldv_33135;
    case 2UL: 
#line 851
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 851
    goto ldv_33135;
    case 4UL: 
#line 851
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 851
    goto ldv_33135;
    case 8UL: 
#line 851
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 851
    goto ldv_33135;
    default: 
#line 851
    __bad_percpu_size();
    }
    ldv_33135: 
#line 851
    pscr_ret__ = pfo_ret__;
#line 851
    goto ldv_33141;
    case 2UL: ;
#line 851
    switch (4UL) {
    case 1UL: 
#line 851
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 851
    goto ldv_33145;
    case 2UL: 
#line 851
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 851
    goto ldv_33145;
    case 4UL: 
#line 851
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 851
    goto ldv_33145;
    case 8UL: 
#line 851
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 851
    goto ldv_33145;
    default: 
#line 851
    __bad_percpu_size();
    }
    ldv_33145: 
#line 851
    pscr_ret__ = pfo_ret_____0;
#line 851
    goto ldv_33141;
    case 4UL: ;
#line 851
    switch (4UL) {
    case 1UL: 
#line 851
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 851
    goto ldv_33154;
    case 2UL: 
#line 851
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 851
    goto ldv_33154;
    case 4UL: 
#line 851
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 851
    goto ldv_33154;
    case 8UL: 
#line 851
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 851
    goto ldv_33154;
    default: 
#line 851
    __bad_percpu_size();
    }
    ldv_33154: 
#line 851
    pscr_ret__ = pfo_ret_____1;
#line 851
    goto ldv_33141;
    case 8UL: ;
#line 851
    switch (4UL) {
    case 1UL: 
#line 851
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 851
    goto ldv_33163;
    case 2UL: 
#line 851
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 851
    goto ldv_33163;
    case 4UL: 
#line 851
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 851
    goto ldv_33163;
    case 8UL: 
#line 851
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 851
    goto ldv_33163;
    default: 
#line 851
    __bad_percpu_size();
    }
    ldv_33163: 
#line 851
    pscr_ret__ = pfo_ret_____2;
#line 851
    goto ldv_33141;
    default: 
#line 851
    __bad_size_call_parameter();
#line 851
    goto ldv_33141;
    }
    ldv_33141: 
#line 851
    printk("\017GRU:%d %s: stole gid %d, ctxnum %d from gts %p. Need cb %d, ds %d; avail cb %ld, ds %ld\n",
           pscr_ret__, "gru_steal_context", (int )gru->gs_gid, ctxnum, ngts, cbr,
           dsr, tmp___4, tmp___3);
  } else {

  }
#line 852
  return;
}
}
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
static int gru_assign_context_number(struct gru_state *gru ) 
{ 
  int ctxnum ;
  unsigned long tmp ;

  {
#line 861
  tmp = find_first_zero_bit((unsigned long const   *)(& gru->gs_context_map), 16UL);
#line 861
  ctxnum = (int )tmp;
#line 862
  __set_bit((long )ctxnum, (unsigned long volatile   *)(& gru->gs_context_map));
#line 863
  return (ctxnum);
}
}
#line 869 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
struct gru_state *gru_assign_gru_context(struct gru_thread_state *gts ) 
{ 
  struct gru_state *gru ;
  struct gru_state *grux ;
  int i ;
  int max_active_contexts ;
  int blade_id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;

  {
#line 873
  blade_id = (int )gts->ts_user_blade_id;
#line 875
  if (blade_id < 0) {
#line 876
    blade_id = uv_numa_blade_id();
  } else {

  }
  again: 
#line 878
  gru = (struct gru_state *)0;
#line 879
  max_active_contexts = 16;
#line 880
  grux = (struct gru_state *)(& (gru_base[blade_id])->bs_grus);
#line 880
  i = 0;
#line 880
  goto ldv_33188;
  ldv_33187: 
#line 881
  tmp = gru_check_chiplet_assignment(grux, gts);
#line 881
  if (tmp == 0) {
#line 882
    goto ldv_33185;
  } else {

  }
#line 883
  tmp___0 = check_gru_resources(grux, (int )gts->ts_cbr_au_count, (int )gts->ts_dsr_au_count,
                                max_active_contexts);
#line 883
  if (tmp___0 != 0) {
#line 886
    gru = grux;
#line 887
    max_active_contexts = (int )grux->gs_active_contexts;
#line 888
    if (max_active_contexts == 0) {
#line 889
      goto ldv_33186;
    } else {

    }
  } else {

  }
  ldv_33185: 
#line 880
  i = i + 1;
#line 880
  grux = grux + 1;
  ldv_33188: ;
#line 880
  if (i <= 1) {
#line 882
    goto ldv_33187;
  } else {

  }
  ldv_33186: ;
#line 893
  if ((unsigned long )gru != (unsigned long )((struct gru_state *)0)) {
#line 894
    spin_lock(& gru->gs_lock);
#line 895
    tmp___1 = check_gru_resources(gru, (int )gts->ts_cbr_au_count, (int )gts->ts_dsr_au_count,
                                  16);
#line 895
    if (tmp___1 == 0) {
#line 897
      spin_unlock(& gru->gs_lock);
#line 898
      goto again;
    } else {

    }
#line 900
    reserve_gru_resources(gru, gts);
#line 901
    gts->ts_gru = gru;
#line 902
    gts->ts_blade = (char )gru->gs_blade_id;
#line 903
    gts->ts_ctxnum = gru_assign_context_number(gru);
#line 904
    atomic_inc(& gts->ts_refcnt);
#line 905
    gru->gs_gts[gts->ts_ctxnum] = gts;
#line 906
    spin_unlock(& gru->gs_lock);
#line 908
    if ((gru_options & 2UL) != 0UL) {
#line 908
      atomic_long_inc(& gru_stats.assign_context);
    } else {

    }
#line 909
    if ((int )gru_options & 1) {
#line 909
      __vpp_verify = (void const   *)0;
#line 909
      switch (4UL) {
      case 1UL: ;
#line 913
      switch (4UL) {
      case 1UL: 
#line 913
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 913
      goto ldv_33194;
      case 2UL: 
#line 913
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 913
      goto ldv_33194;
      case 4UL: 
#line 913
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 913
      goto ldv_33194;
      case 8UL: 
#line 913
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 913
      goto ldv_33194;
      default: 
#line 913
      __bad_percpu_size();
      }
      ldv_33194: 
#line 913
      pscr_ret__ = pfo_ret__;
#line 913
      goto ldv_33200;
      case 2UL: ;
#line 913
      switch (4UL) {
      case 1UL: 
#line 913
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 913
      goto ldv_33204;
      case 2UL: 
#line 913
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 913
      goto ldv_33204;
      case 4UL: 
#line 913
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 913
      goto ldv_33204;
      case 8UL: 
#line 913
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 913
      goto ldv_33204;
      default: 
#line 913
      __bad_percpu_size();
      }
      ldv_33204: 
#line 913
      pscr_ret__ = pfo_ret_____0;
#line 913
      goto ldv_33200;
      case 4UL: ;
#line 913
      switch (4UL) {
      case 1UL: 
#line 913
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 913
      goto ldv_33213;
      case 2UL: 
#line 913
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 913
      goto ldv_33213;
      case 4UL: 
#line 913
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 913
      goto ldv_33213;
      case 8UL: 
#line 913
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 913
      goto ldv_33213;
      default: 
#line 913
      __bad_percpu_size();
      }
      ldv_33213: 
#line 913
      pscr_ret__ = pfo_ret_____1;
#line 913
      goto ldv_33200;
      case 8UL: ;
#line 913
      switch (4UL) {
      case 1UL: 
#line 913
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 913
      goto ldv_33222;
      case 2UL: 
#line 913
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 913
      goto ldv_33222;
      case 4UL: 
#line 913
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 913
      goto ldv_33222;
      case 8UL: 
#line 913
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 913
      goto ldv_33222;
      default: 
#line 913
      __bad_percpu_size();
      }
      ldv_33222: 
#line 913
      pscr_ret__ = pfo_ret_____2;
#line 913
      goto ldv_33200;
      default: 
#line 913
      __bad_size_call_parameter();
#line 913
      goto ldv_33200;
      }
      ldv_33200: 
#line 913
      printk("\017GRU:%d %s: gseg %p, gts %p, gid %d, ctx %d, cbr %d, dsr %d\n", pscr_ret__,
             "gru_assign_gru_context", (gts->ts_gru)->gs_gru_base_vaddr + (unsigned long )(gts->ts_ctxnum * 4194304),
             gts, (int )(gts->ts_gru)->gs_gid, gts->ts_ctxnum, (int )gts->ts_cbr_au_count,
             (int )gts->ts_dsr_au_count);
    } else {

    }
  } else {
#line 915
    if ((int )gru_options & 1) {
#line 915
      __vpp_verify___0 = (void const   *)0;
#line 915
      switch (4UL) {
      case 1UL: ;
#line 915
      switch (4UL) {
      case 1UL: 
#line 915
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 915
      goto ldv_33236;
      case 2UL: 
#line 915
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 915
      goto ldv_33236;
      case 4UL: 
#line 915
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 915
      goto ldv_33236;
      case 8UL: 
#line 915
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 915
      goto ldv_33236;
      default: 
#line 915
      __bad_percpu_size();
      }
      ldv_33236: 
#line 915
      pscr_ret_____0 = pfo_ret_____3;
#line 915
      goto ldv_33242;
      case 2UL: ;
#line 915
      switch (4UL) {
      case 1UL: 
#line 915
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 915
      goto ldv_33246;
      case 2UL: 
#line 915
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 915
      goto ldv_33246;
      case 4UL: 
#line 915
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 915
      goto ldv_33246;
      case 8UL: 
#line 915
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 915
      goto ldv_33246;
      default: 
#line 915
      __bad_percpu_size();
      }
      ldv_33246: 
#line 915
      pscr_ret_____0 = pfo_ret_____4;
#line 915
      goto ldv_33242;
      case 4UL: ;
#line 915
      switch (4UL) {
      case 1UL: 
#line 915
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 915
      goto ldv_33255;
      case 2UL: 
#line 915
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 915
      goto ldv_33255;
      case 4UL: 
#line 915
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 915
      goto ldv_33255;
      case 8UL: 
#line 915
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 915
      goto ldv_33255;
      default: 
#line 915
      __bad_percpu_size();
      }
      ldv_33255: 
#line 915
      pscr_ret_____0 = pfo_ret_____5;
#line 915
      goto ldv_33242;
      case 8UL: ;
#line 915
      switch (4UL) {
      case 1UL: 
#line 915
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 915
      goto ldv_33264;
      case 2UL: 
#line 915
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 915
      goto ldv_33264;
      case 4UL: 
#line 915
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 915
      goto ldv_33264;
      case 8UL: 
#line 915
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 915
      goto ldv_33264;
      default: 
#line 915
      __bad_percpu_size();
      }
      ldv_33264: 
#line 915
      pscr_ret_____0 = pfo_ret_____6;
#line 915
      goto ldv_33242;
      default: 
#line 915
      __bad_size_call_parameter();
#line 915
      goto ldv_33242;
      }
      ldv_33242: 
#line 915
      printk("\017GRU:%d %s: failed to allocate a GTS %s\n", pscr_ret_____0, "gru_assign_gru_context",
             (char *)"");
    } else {

    }
#line 916
    if ((gru_options & 2UL) != 0UL) {
#line 916
      atomic_long_inc(& gru_stats.assign_context_failed);
    } else {

    }
  }
#line 919
  return (gru);
}
}
#line 929 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.c"
int gru_fault(struct vm_area_struct *vma , struct vm_fault *vmf ) 
{ 
  struct gru_thread_state *gts ;
  unsigned long paddr ;
  unsigned long vaddr ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct gru_state *tmp___4 ;

  {
#line 934
  vaddr = (unsigned long )vmf->virtual_address;
#line 935
  if ((int )gru_options & 1) {
#line 935
    __vpp_verify = (void const   *)0;
#line 935
    switch (4UL) {
    case 1UL: ;
#line 936
    switch (4UL) {
    case 1UL: 
#line 936
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 936
    goto ldv_33284;
    case 2UL: 
#line 936
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 936
    goto ldv_33284;
    case 4UL: 
#line 936
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 936
    goto ldv_33284;
    case 8UL: 
#line 936
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 936
    goto ldv_33284;
    default: 
#line 936
    __bad_percpu_size();
    }
    ldv_33284: 
#line 936
    pscr_ret__ = pfo_ret__;
#line 936
    goto ldv_33290;
    case 2UL: ;
#line 936
    switch (4UL) {
    case 1UL: 
#line 936
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 936
    goto ldv_33294;
    case 2UL: 
#line 936
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 936
    goto ldv_33294;
    case 4UL: 
#line 936
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 936
    goto ldv_33294;
    case 8UL: 
#line 936
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 936
    goto ldv_33294;
    default: 
#line 936
    __bad_percpu_size();
    }
    ldv_33294: 
#line 936
    pscr_ret__ = pfo_ret_____0;
#line 936
    goto ldv_33290;
    case 4UL: ;
#line 936
    switch (4UL) {
    case 1UL: 
#line 936
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 936
    goto ldv_33303;
    case 2UL: 
#line 936
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 936
    goto ldv_33303;
    case 4UL: 
#line 936
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 936
    goto ldv_33303;
    case 8UL: 
#line 936
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 936
    goto ldv_33303;
    default: 
#line 936
    __bad_percpu_size();
    }
    ldv_33303: 
#line 936
    pscr_ret__ = pfo_ret_____1;
#line 936
    goto ldv_33290;
    case 8UL: ;
#line 936
    switch (4UL) {
    case 1UL: 
#line 936
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 936
    goto ldv_33312;
    case 2UL: 
#line 936
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 936
    goto ldv_33312;
    case 4UL: 
#line 936
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 936
    goto ldv_33312;
    case 8UL: 
#line 936
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 936
    goto ldv_33312;
    default: 
#line 936
    __bad_percpu_size();
    }
    ldv_33312: 
#line 936
    pscr_ret__ = pfo_ret_____2;
#line 936
    goto ldv_33290;
    default: 
#line 936
    __bad_size_call_parameter();
#line 936
    goto ldv_33290;
    }
    ldv_33290: 
#line 936
    printk("\017GRU:%d %s: vma %p, vaddr 0x%lx (0x%lx)\n", pscr_ret__, "gru_fault",
           vma, vaddr, vaddr & 0xfffffffffffc0000UL);
  } else {

  }
#line 937
  if ((gru_options & 2UL) != 0UL) {
#line 937
    atomic_long_inc(& gru_stats.nopfn);
  } else {

  }
#line 940
  gts = gru_find_thread_state(vma, (int )((vaddr - vma->vm_start) / 262144UL));
#line 941
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
#line 942
    return (2);
  } else {

  }
  again: 
#line 945
  ldv_mutex_lock_42(& gts->ts_ctxlock);
#line 946
  __preempt_count_add(1);
#line 946
  __asm__  volatile   ("": : : "memory");
#line 948
  gru_check_context_placement(gts);
#line 950
  if ((unsigned long )gts->ts_gru == (unsigned long )((struct gru_state *)0)) {
#line 951
    if ((gru_options & 2UL) != 0UL) {
#line 951
      atomic_long_inc(& gru_stats.load_user_context);
    } else {

    }
#line 952
    tmp___4 = gru_assign_gru_context(gts);
#line 952
    if ((unsigned long )tmp___4 == (unsigned long )((struct gru_state *)0)) {
#line 953
      __asm__  volatile   ("": : : "memory");
#line 953
      __preempt_count_sub(1);
#line 954
      ldv_mutex_unlock_43(& gts->ts_ctxlock);
#line 955
      tmp = get_current();
#line 955
      tmp->task_state_change = 0UL;
#line 955
      __ret = 1L;
#line 955
      switch (8UL) {
      case 1UL: 
#line 955
      tmp___0 = get_current();
#line 955
      __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                           "cc");
#line 955
      goto ldv_33324;
      case 2UL: 
#line 955
      tmp___1 = get_current();
#line 955
      __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                           "cc");
#line 955
      goto ldv_33324;
      case 4UL: 
#line 955
      tmp___2 = get_current();
#line 955
      __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                           "cc");
#line 955
      goto ldv_33324;
      case 8UL: 
#line 955
      tmp___3 = get_current();
#line 955
      __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                           "cc");
#line 955
      goto ldv_33324;
      default: 
#line 955
      __xchg_wrong_size();
      }
      ldv_33324: 
#line 956
      schedule_timeout(5L);
#line 957
      if (gts->ts_steal_jiffies + 50UL < (unsigned long )jiffies) {
#line 958
        gru_steal_context(gts);
      } else {

      }
#line 959
      goto again;
    } else {

    }
#line 961
    gru_load_context(gts);
#line 962
    paddr = (gts->ts_gru)->gs_gru_base_paddr + (unsigned long )(gts->ts_ctxnum * 4194304);
#line 963
    remap_pfn_range(vma, vaddr & 0xfffffffffffc0000UL, paddr >> 12, 262144UL, vma->vm_page_prot);
  } else {

  }
#line 968
  __asm__  volatile   ("": : : "memory");
#line 968
  __preempt_count_sub(1);
#line 969
  ldv_mutex_unlock_44(& gts->ts_ctxlock);
#line 971
  return (256);
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
#line 122
  tmp = ldv_err_ptr(error);
#line 122
  return (tmp);
}
}
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 134
  tmp = ldv_is_err(ptr);
#line 134
  return (tmp);
}
}
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
void ldv_mutex_lock_33(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 146
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 148
  mutex_lock(ldv_func_arg1);
#line 149
  return;
}
}
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
void ldv_mutex_unlock_34(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 154
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 156
  mutex_unlock(ldv_func_arg1);
#line 157
  return;
}
}
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
void ldv_mutex_lock_35(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 162
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 164
  mutex_lock(ldv_func_arg1);
#line 165
  return;
}
}
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
int ldv_mutex_trylock_36(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 171
  tmp = mutex_trylock(ldv_func_arg1);
#line 171
  ldv_func_res = tmp;
#line 173
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 173
  return (tmp___0);
#line 175
  return (ldv_func_res);
}
}
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
void ldv_mutex_unlock_37(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 181
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 183
  mutex_unlock(ldv_func_arg1);
#line 184
  return;
}
}
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
void ldv_mutex_unlock_38(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 189
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 191
  mutex_unlock(ldv_func_arg1);
#line 192
  return;
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
void ldv_mutex_lock_39(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 197
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 199
  mutex_lock(ldv_func_arg1);
#line 200
  return;
}
}
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
int ldv_mutex_trylock_40(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 206
  tmp = mutex_trylock(ldv_func_arg1);
#line 206
  ldv_func_res = tmp;
#line 208
  tmp___0 = ldv_mutex_trylock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
#line 208
  return (tmp___0);
#line 210
  return (ldv_func_res);
}
}
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
void ldv_mutex_unlock_41(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 216
  ldv_mutex_unlock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
#line 218
  mutex_unlock(ldv_func_arg1);
#line 219
  return;
}
}
#line 221 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
void ldv_mutex_lock_42(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 224
  ldv_mutex_lock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
#line 226
  mutex_lock(ldv_func_arg1);
#line 227
  return;
}
}
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
void ldv_mutex_unlock_43(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 232
  ldv_mutex_unlock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
#line 234
  mutex_unlock(ldv_func_arg1);
#line 235
  return;
}
}
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grumain.o.c.prepared"
void ldv_mutex_unlock_44(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 240
  ldv_mutex_unlock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
#line 242
  mutex_unlock(ldv_func_arg1);
#line 243
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 227 "./arch/x86/include/asm/pgtable_types.h"
__inline static pgdval_t native_pgd_val(pgd_t pgd ) 
{ 


  {
#line 229
  return (pgd.pgd);
}
}
#line 245 "./arch/x86/include/asm/pgtable_types.h"
__inline static pudval_t native_pud_val(pud_t pud ) 
{ 


  {
#line 247
  return (pud.pud);
}
}
#line 266 "./arch/x86/include/asm/pgtable_types.h"
__inline static pmdval_t native_pmd_val(pmd_t pmd ) 
{ 


  {
#line 268
  return (pmd.pmd);
}
}
#line 284 "./arch/x86/include/asm/pgtable_types.h"
__inline static pmdval_t pmd_flags(pmd_t pmd ) 
{ 
  pmdval_t tmp ;

  {
#line 286
  tmp = native_pmd_val(pmd);
#line 286
  return (tmp & 0xffffc00000000fffUL);
}
}
#line 294 "./arch/x86/include/asm/pgtable_types.h"
__inline static pteval_t native_pte_val(pte_t pte ) 
{ 


  {
#line 296
  return (pte.pte);
}
}
#line 299 "./arch/x86/include/asm/pgtable_types.h"
__inline static pteval_t pte_flags(pte_t pte ) 
{ 
  pteval_t tmp ;

  {
#line 301
  tmp = native_pte_val(pte);
#line 301
  return (tmp & 0xffffc00000000fffUL);
}
}
#line 371 "./arch/x86/include/asm/paravirt_types.h"
extern struct pv_mmu_ops pv_mmu_ops ;
#line 178 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
long ldv_ptr_err(void const   *ptr ) ;
#line 442 "./arch/x86/include/asm/paravirt.h"
__inline static pteval_t pte_val(pte_t pte ) 
{ 
  pteval_t ret ;
  pteval_t __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;
  pteval_t __ret___0 ;
  unsigned long __edi___0 ;
  unsigned long __esi___0 ;
  unsigned long __edx___0 ;
  unsigned long __ecx___0 ;
  unsigned long __eax___0 ;
  long tmp___0 ;

  {
#line 446
  if (0) {
#line 447
    __edi = __edi;
#line 447
    __esi = __esi;
#line 447
    __edx = __edx;
#line 447
    __ecx = __ecx;
#line 447
    __eax = __eax;
#line 447
    tmp = ldv__builtin_expect((unsigned long )pv_mmu_ops.pte_val.func == (unsigned long )((void *)0),
                           0L);
#line 447
    if (tmp != 0L) {
#line 447
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                           "i" (448), "i" (12UL));
      ldv_4435: ;
#line 447
      goto ldv_4435;
    } else {

    }
#line 447
    __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (80UL),
                         [paravirt_opptr] "i" (& pv_mmu_ops.pte_val.func), [paravirt_clobber] "i" (1),
                         "D" (pte.pte), "S" ((unsigned long )((unsigned long long )pte.pte >> 32)): "memory",
                         "cc");
#line 447
    __ret = __eax;
#line 447
    ret = __ret;
  } else {
#line 450
    __edi___0 = __edi___0;
#line 450
    __esi___0 = __esi___0;
#line 450
    __edx___0 = __edx___0;
#line 450
    __ecx___0 = __ecx___0;
#line 450
    __eax___0 = __eax___0;
#line 450
    tmp___0 = ldv__builtin_expect((unsigned long )pv_mmu_ops.pte_val.func == (unsigned long )((void *)0),
                               0L);
#line 450
    if (tmp___0 != 0L) {
#line 450
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                           "i" (451), "i" (12UL));
      ldv_4443: ;
#line 450
      goto ldv_4443;
    } else {

    }
#line 450
    __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax___0): [paravirt_typenum] "i" (80UL),
                         [paravirt_opptr] "i" (& pv_mmu_ops.pte_val.func), [paravirt_clobber] "i" (1),
                         "D" (pte.pte): "memory", "cc");
#line 450
    __ret___0 = __eax___0;
#line 450
    ret = __ret___0;
  }
#line 453
  return (ret);
}
}
#line 470 "./arch/x86/include/asm/paravirt.h"
__inline static pgdval_t pgd_val(pgd_t pgd ) 
{ 
  pgdval_t ret ;
  pgdval_t __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;
  pgdval_t __ret___0 ;
  unsigned long __edi___0 ;
  unsigned long __esi___0 ;
  unsigned long __edx___0 ;
  unsigned long __ecx___0 ;
  unsigned long __eax___0 ;
  long tmp___0 ;

  {
#line 474
  if (0) {
#line 475
    __edi = __edi;
#line 475
    __esi = __esi;
#line 475
    __edx = __edx;
#line 475
    __ecx = __ecx;
#line 475
    __eax = __eax;
#line 475
    tmp = ldv__builtin_expect((unsigned long )pv_mmu_ops.pgd_val.func == (unsigned long )((void *)0),
                           0L);
#line 475
    if (tmp != 0L) {
#line 475
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                           "i" (476), "i" (12UL));
      ldv_4476: ;
#line 475
      goto ldv_4476;
    } else {

    }
#line 475
    __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (82UL),
                         [paravirt_opptr] "i" (& pv_mmu_ops.pgd_val.func), [paravirt_clobber] "i" (1),
                         "D" (pgd.pgd), "S" ((unsigned long )((unsigned long long )pgd.pgd >> 32)): "memory",
                         "cc");
#line 475
    __ret = __eax;
#line 475
    ret = __ret;
  } else {
#line 478
    __edi___0 = __edi___0;
#line 478
    __esi___0 = __esi___0;
#line 478
    __edx___0 = __edx___0;
#line 478
    __ecx___0 = __ecx___0;
#line 478
    __eax___0 = __eax___0;
#line 478
    tmp___0 = ldv__builtin_expect((unsigned long )pv_mmu_ops.pgd_val.func == (unsigned long )((void *)0),
                               0L);
#line 478
    if (tmp___0 != 0L) {
#line 478
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                           "i" (479), "i" (12UL));
      ldv_4484: ;
#line 478
      goto ldv_4484;
    } else {

    }
#line 478
    __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax___0): [paravirt_typenum] "i" (82UL),
                         [paravirt_opptr] "i" (& pv_mmu_ops.pgd_val.func), [paravirt_clobber] "i" (1),
                         "D" (pgd.pgd): "memory", "cc");
#line 478
    __ret___0 = __eax___0;
#line 478
    ret = __ret___0;
  }
#line 481
  return (ret);
}
}
#line 563 "./arch/x86/include/asm/paravirt.h"
__inline static pmdval_t pmd_val(pmd_t pmd ) 
{ 
  pmdval_t ret ;
  pmdval_t __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;
  pmdval_t __ret___0 ;
  unsigned long __edi___0 ;
  unsigned long __esi___0 ;
  unsigned long __edx___0 ;
  unsigned long __ecx___0 ;
  unsigned long __eax___0 ;
  long tmp___0 ;

  {
#line 567
  if (0) {
#line 568
    __edi = __edi;
#line 568
    __esi = __esi;
#line 568
    __edx = __edx;
#line 568
    __ecx = __ecx;
#line 568
    __eax = __eax;
#line 568
    tmp = ldv__builtin_expect((unsigned long )pv_mmu_ops.pmd_val.func == (unsigned long )((void *)0),
                           0L);
#line 568
    if (tmp != 0L) {
#line 568
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                           "i" (569), "i" (12UL));
      ldv_4601: ;
#line 568
      goto ldv_4601;
    } else {

    }
#line 568
    __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (85UL),
                         [paravirt_opptr] "i" (& pv_mmu_ops.pmd_val.func), [paravirt_clobber] "i" (1),
                         "D" (pmd.pmd), "S" ((unsigned long )((unsigned long long )pmd.pmd >> 32)): "memory",
                         "cc");
#line 568
    __ret = __eax;
#line 568
    ret = __ret;
  } else {
#line 571
    __edi___0 = __edi___0;
#line 571
    __esi___0 = __esi___0;
#line 571
    __edx___0 = __edx___0;
#line 571
    __ecx___0 = __ecx___0;
#line 571
    __eax___0 = __eax___0;
#line 571
    tmp___0 = ldv__builtin_expect((unsigned long )pv_mmu_ops.pmd_val.func == (unsigned long )((void *)0),
                               0L);
#line 571
    if (tmp___0 != 0L) {
#line 571
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                           "i" (572), "i" (12UL));
      ldv_4609: ;
#line 571
      goto ldv_4609;
    } else {

    }
#line 571
    __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax___0): [paravirt_typenum] "i" (85UL),
                         [paravirt_opptr] "i" (& pv_mmu_ops.pmd_val.func), [paravirt_clobber] "i" (1),
                         "D" (pmd.pmd): "memory", "cc");
#line 571
    __ret___0 = __eax___0;
#line 571
    ret = __ret___0;
  }
#line 574
  return (ret);
}
}
#line 603 "./arch/x86/include/asm/paravirt.h"
__inline static pudval_t pud_val(pud_t pud ) 
{ 
  pudval_t ret ;
  pudval_t __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;
  pudval_t __ret___0 ;
  unsigned long __edi___0 ;
  unsigned long __esi___0 ;
  unsigned long __edx___0 ;
  unsigned long __ecx___0 ;
  unsigned long __eax___0 ;
  long tmp___0 ;

  {
#line 607
  if (0) {
#line 608
    __edi = __edi;
#line 608
    __esi = __esi;
#line 608
    __edx = __edx;
#line 608
    __ecx = __ecx;
#line 608
    __eax = __eax;
#line 608
    tmp = ldv__builtin_expect((unsigned long )pv_mmu_ops.pud_val.func == (unsigned long )((void *)0),
                           0L);
#line 608
    if (tmp != 0L) {
#line 608
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                           "i" (609), "i" (12UL));
      ldv_4659: ;
#line 608
      goto ldv_4659;
    } else {

    }
#line 608
    __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (87UL),
                         [paravirt_opptr] "i" (& pv_mmu_ops.pud_val.func), [paravirt_clobber] "i" (1),
                         "D" (pud.pud), "S" ((unsigned long )((unsigned long long )pud.pud >> 32)): "memory",
                         "cc");
#line 608
    __ret = __eax;
#line 608
    ret = __ret;
  } else {
#line 611
    __edi___0 = __edi___0;
#line 611
    __esi___0 = __esi___0;
#line 611
    __edx___0 = __edx___0;
#line 611
    __ecx___0 = __ecx___0;
#line 611
    __eax___0 = __eax___0;
#line 611
    tmp___0 = ldv__builtin_expect((unsigned long )pv_mmu_ops.pud_val.func == (unsigned long )((void *)0),
                               0L);
#line 611
    if (tmp___0 != 0L) {
#line 611
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                           "i" (612), "i" (12UL));
      ldv_4667: ;
#line 611
      goto ldv_4667;
    } else {

    }
#line 611
    __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax___0): [paravirt_typenum] "i" (87UL),
                         [paravirt_opptr] "i" (& pv_mmu_ops.pud_val.func), [paravirt_clobber] "i" (1),
                         "D" (pud.pud): "memory", "cc");
#line 611
    __ret___0 = __eax___0;
#line 611
    ret = __ret___0;
  }
#line 614
  return (ret);
}
}
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 32
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 574 "./arch/x86/include/asm/processor.h"
__inline static void sync_core(void) 
{ 
  int tmp ;

  {
#line 596
  __asm__  volatile   ("cpuid": "=a" (tmp): "0" (1): "ebx", "ecx", "edx", "memory");
#line 597
  return;
}
}
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_66(struct mutex *ldv_func_arg1 ) ;
#line 180
int ldv_mutex_trylock_71(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_61(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_64(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_67(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_70(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_72(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
void ldv_mutex_lock_62(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_63(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_65(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_68(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_69(struct mutex *ldv_func_arg1 ) ;
#line 926 "include/linux/wait.h"
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 927
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 108 "include/linux/rwsem.h"
extern void down_read(struct rw_semaphore * ) ;
#line 113
extern int down_read_trylock(struct rw_semaphore * ) ;
#line 128
extern void up_read(struct rw_semaphore * ) ;
#line 138
extern void downgrade_write(struct rw_semaphore * ) ;
#line 106 "include/linux/completion.h"
extern void complete(struct completion * ) ;
#line 215 "include/linux/capability.h"
extern bool capable(int  ) ;
#line 425 "include/linux/sched.h"
extern void schedule(void) ;
#line 93 "./arch/x86/include/asm/pgtable.h"
__inline static int pte_dirty(pte_t pte ) 
{ 
  pteval_t tmp ;

  {
#line 95
  tmp = pte_flags(pte);
#line 95
  return ((int )tmp & 64);
}
}
#line 113 "./arch/x86/include/asm/pgtable.h"
__inline static int pte_write(pte_t pte ) 
{ 
  pteval_t tmp ;

  {
#line 115
  tmp = pte_flags(pte);
#line 115
  return ((int )tmp & 2);
}
}
#line 138 "./arch/x86/include/asm/pgtable.h"
__inline static unsigned long pte_pfn(pte_t pte ) 
{ 
  pteval_t tmp ;

  {
#line 140
  tmp = pte_val(pte);
#line 140
  return ((tmp & 70368744173568UL) >> 12);
}
}
#line 155 "./arch/x86/include/asm/pgtable.h"
__inline static int pmd_large(pmd_t pte ) 
{ 
  pmdval_t tmp ;

  {
#line 157
  tmp = pmd_flags(pte);
#line 157
  return ((int )tmp & 128);
}
}
#line 444 "./arch/x86/include/asm/pgtable.h"
__inline static int pte_present(pte_t a ) 
{ 
  pteval_t tmp ;

  {
#line 446
  tmp = pte_flags(a);
#line 446
  return ((int )tmp & 257);
}
}
#line 496 "./arch/x86/include/asm/pgtable.h"
__inline static int pmd_none(pmd_t pmd ) 
{ 
  pmdval_t tmp ;

  {
#line 500
  tmp = native_pmd_val(pmd);
#line 500
  return (tmp == 0UL);
}
}
#line 503 "./arch/x86/include/asm/pgtable.h"
__inline static unsigned long pmd_page_vaddr(pmd_t pmd ) 
{ 
  pmdval_t tmp ;

  {
#line 505
  tmp = pmd_val(pmd);
#line 505
  return ((tmp & 70368744173568UL) + 0xffff880000000000UL);
}
}
#line 520 "./arch/x86/include/asm/pgtable.h"
__inline static unsigned long pmd_index(unsigned long address ) 
{ 


  {
#line 522
  return ((address >> 21) & 511UL);
}
}
#line 540 "./arch/x86/include/asm/pgtable.h"
__inline static unsigned long pte_index(unsigned long address ) 
{ 


  {
#line 542
  return ((address >> 12) & 511UL);
}
}
#line 545 "./arch/x86/include/asm/pgtable.h"
__inline static pte_t *pte_offset_kernel(pmd_t *pmd , unsigned long address ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 547
  tmp = pte_index(address);
#line 547
  tmp___0 = pmd_page_vaddr(*pmd);
#line 547
  return ((pte_t *)(tmp + tmp___0));
}
}
#line 561 "./arch/x86/include/asm/pgtable.h"
__inline static int pud_none(pud_t pud ) 
{ 
  pudval_t tmp ;

  {
#line 563
  tmp = native_pud_val(pud);
#line 563
  return (tmp == 0UL);
}
}
#line 571 "./arch/x86/include/asm/pgtable.h"
__inline static unsigned long pud_page_vaddr(pud_t pud ) 
{ 
  pudval_t tmp ;

  {
#line 573
  tmp = pud_val(pud);
#line 573
  return ((tmp & 70368744173568UL) + 0xffff880000000000UL);
}
}
#line 583 "./arch/x86/include/asm/pgtable.h"
__inline static pmd_t *pmd_offset(pud_t *pud , unsigned long address ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 585
  tmp = pmd_index(address);
#line 585
  tmp___0 = pud_page_vaddr(*pud);
#line 585
  return ((pmd_t *)(tmp + tmp___0));
}
}
#line 611 "./arch/x86/include/asm/pgtable.h"
__inline static unsigned long pgd_page_vaddr(pgd_t pgd ) 
{ 
  pgdval_t tmp ;

  {
#line 613
  tmp = pgd_val(pgd);
#line 613
  return ((tmp & 70368744173568UL) + 0xffff880000000000UL);
}
}
#line 623 "./arch/x86/include/asm/pgtable.h"
__inline static unsigned long pud_index(unsigned long address ) 
{ 


  {
#line 625
  return ((address >> 30) & 511UL);
}
}
#line 628 "./arch/x86/include/asm/pgtable.h"
__inline static pud_t *pud_offset(pgd_t *pgd , unsigned long address ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 630
  tmp = pud_index(address);
#line 630
  tmp___0 = pgd_page_vaddr(*pgd);
#line 630
  return ((pud_t *)(tmp + tmp___0));
}
}
#line 638 "./arch/x86/include/asm/pgtable.h"
__inline static int pgd_none(pgd_t pgd ) 
{ 
  pgdval_t tmp ;

  {
#line 640
  tmp = native_pgd_val(pgd);
#line 640
  return (tmp == 0UL);
}
}
#line 569 "include/linux/mm.h"
extern void put_page(struct page * ) ;
#line 1184
extern long get_user_pages(struct task_struct * , struct mm_struct * , unsigned long  ,
                           unsigned long  , int  , int  , struct page ** , struct vm_area_struct ** ) ;
#line 1960
extern struct vm_area_struct *find_vma(struct mm_struct * , unsigned long  ) ;
#line 8 "include/linux/hugetlb_inline.h"
__inline static int is_vm_hugetlb_page(struct vm_area_struct *vma ) 
{ 


  {
#line 10
  return ((vma->vm_flags & 4194304UL) != 0UL);
}
}
#line 1084 "include/linux/device.h"
extern void dev_err(struct device  const  * , char const   *  , ...) ;
#line 101 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
__inline static void *get_gseg_base_address(void *base , int ctxnum ) 
{ 


  {
#line 103
  return (base + (unsigned long )(ctxnum * 4194304));
}
}
#line 106 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
__inline static void *get_gseg_base_address_cb(void *base , int ctxnum , int line ) 
{ 
  void *tmp ;

  {
#line 108
  tmp = get_gseg_base_address(base, ctxnum);
#line 108
  return (tmp + (unsigned long )(line * 256));
}
}
#line 118 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
__inline static struct gru_tlb_fault_map *get_tfm(void *base , int ctxnum ) 
{ 


  {
#line 120
  return ((struct gru_tlb_fault_map *)(base + ((unsigned long )(ctxnum * 256) + 67108864UL)));
}
}
#line 130 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
__inline static struct gru_control_block_extended *get_cbe(void *base , int ctxnum ) 
{ 


  {
#line 132
  return ((struct gru_control_block_extended *)(base + ((unsigned long )(ctxnum * 256) + 67174400UL)));
}
}
#line 136 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
__inline static struct gru_tlb_fault_handle *get_tfh(void *base , int ctxnum ) 
{ 


  {
#line 138
  return ((struct gru_tlb_fault_handle *)(base + ((unsigned long )(ctxnum * 256) + 67207168UL)));
}
}
#line 149 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
__inline static unsigned long get_cb_number(void *cb ) 
{ 


  {
#line 151
  return (((unsigned long )cb & 262143UL) / 256UL);
}
}
#line 167 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
__inline static struct gru_control_block_extended *gru_tfh_to_cbe(struct gru_tlb_fault_handle *tfh ) 
{ 
  unsigned long cbe ;

  {
#line 172
  cbe = (unsigned long )tfh - 32768UL;
#line 173
  return ((struct gru_control_block_extended *)cbe);
}
}
#line 523
int tfh_write_only(struct gru_tlb_fault_handle *tfh , unsigned long paddr , int gaa ,
                   unsigned long vaddr , int asid , int dirty , int pagesize ) ;
#line 525
void tfh_write_restart(struct gru_tlb_fault_handle *tfh , unsigned long paddr , int gaa ,
                       unsigned long vaddr , int asid , int dirty , int pagesize ) ;
#line 528
void tfh_user_polling_mode(struct gru_tlb_fault_handle *tfh ) ;
#line 529
void tfh_exception(struct gru_tlb_fault_handle *tfh ) ;
#line 673 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
void gru_flush_tlb_range(struct gru_mm_struct *gms , unsigned long start , unsigned long len ) ;
#line 311 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static unsigned long uv_soc_phys_ram_to_gpa(unsigned long paddr ) 
{ 
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;
  void const   *__vpp_verify___0 ;
  unsigned long tcp_ptr_____0 ;
  void const   *__vpp_verify___1 ;
  unsigned long tcp_ptr_____1 ;
  void const   *__vpp_verify___2 ;
  unsigned long tcp_ptr_____2 ;
  void const   *__vpp_verify___3 ;
  unsigned long tcp_ptr_____3 ;
  void const   *__vpp_verify___4 ;
  unsigned long tcp_ptr_____4 ;
  void const   *__vpp_verify___5 ;
  unsigned long tcp_ptr_____5 ;

  {
#line 313
  __vpp_verify___0 = (void const   *)0;
#line 313
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____0): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 313
  if (((struct uv_hub_info_s *)tcp_ptr_____0)->lowmem_remap_top > paddr) {
#line 314
    __vpp_verify = (void const   *)0;
#line 314
    __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off),
                         "0" (& __uv_hub_info));
#line 314
    paddr = ((struct uv_hub_info_s *)tcp_ptr__)->lowmem_remap_base | paddr;
  } else {

  }
#line 315
  __vpp_verify___1 = (void const   *)0;
#line 315
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____1): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 315
  paddr = ((struct uv_hub_info_s *)tcp_ptr_____1)->gnode_upper | paddr;
#line 316
  __vpp_verify___2 = (void const   *)0;
#line 316
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____2): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 316
  __vpp_verify___3 = (void const   *)0;
#line 316
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____3): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 317
  __vpp_verify___4 = (void const   *)0;
#line 317
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____4): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 317
  __vpp_verify___5 = (void const   *)0;
#line 317
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____5): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 317
  paddr = ((paddr << (int )((struct uv_hub_info_s *)tcp_ptr_____2)->m_shift) >> (int )((struct uv_hub_info_s *)tcp_ptr_____3)->m_shift) | ((paddr >> (int )((struct uv_hub_info_s *)tcp_ptr_____4)->m_val) << (int )((struct uv_hub_info_s *)tcp_ptr_____5)->n_lshift);
#line 318
  return (paddr);
}
}
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
__inline static int is_gru_paddr(unsigned long paddr ) 
{ 


  {
#line 55
  return (paddr >= gru_start_paddr && paddr < gru_end_paddr);
}
}
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
struct vm_area_struct *gru_find_vma(unsigned long vaddr ) 
{ 
  struct vm_area_struct *vma ;
  struct task_struct *tmp ;

  {
#line 65
  tmp = get_current();
#line 65
  vma = find_vma(tmp->mm, vaddr);
#line 66
  if (((unsigned long )vma != (unsigned long )((struct vm_area_struct *)0) && vma->vm_start <= vaddr) && (unsigned long )vma->vm_ops == (unsigned long )(& gru_vm_ops)) {
#line 67
    return (vma);
  } else {

  }
#line 68
  return ((struct vm_area_struct *)0);
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
static struct gru_thread_state *gru_find_lock_gts(unsigned long vaddr ) 
{ 
  struct mm_struct *mm ;
  struct task_struct *tmp ;
  struct vm_area_struct *vma ;
  struct gru_thread_state *gts ;

  {
#line 81
  tmp = get_current();
#line 81
  mm = tmp->mm;
#line 83
  gts = (struct gru_thread_state *)0;
#line 85
  down_read(& mm->mmap_sem);
#line 86
  vma = gru_find_vma(vaddr);
#line 87
  if ((unsigned long )vma != (unsigned long )((struct vm_area_struct *)0)) {
#line 88
    gts = gru_find_thread_state(vma, (int )((vaddr - vma->vm_start) / 262144UL));
  } else {

  }
#line 89
  if ((unsigned long )gts != (unsigned long )((struct gru_thread_state *)0)) {
#line 90
    ldv_mutex_lock_68(& gts->ts_ctxlock);
  } else {
#line 92
    up_read(& mm->mmap_sem);
  }
#line 93
  return (gts);
}
}
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
static struct gru_thread_state *gru_alloc_locked_gts(unsigned long vaddr ) 
{ 
  struct mm_struct *mm ;
  struct task_struct *tmp ;
  struct vm_area_struct *vma ;
  struct gru_thread_state *gts ;
  void *tmp___0 ;
  bool tmp___1 ;

  {
#line 98
  tmp = get_current();
#line 98
  mm = tmp->mm;
#line 100
  tmp___0 = ERR_PTR(-22L);
#line 100
  gts = (struct gru_thread_state *)tmp___0;
#line 102
  down_write(& mm->mmap_sem);
#line 103
  vma = gru_find_vma(vaddr);
#line 104
  if ((unsigned long )vma == (unsigned long )((struct vm_area_struct *)0)) {
#line 105
    goto err;
  } else {

  }
#line 107
  gts = gru_alloc_thread_state(vma, (int )((vaddr - vma->vm_start) / 262144UL));
#line 108
  tmp___1 = IS_ERR((void const   *)gts);
#line 108
  if ((int )tmp___1) {
#line 109
    goto err;
  } else {

  }
#line 110
  ldv_mutex_lock_69(& gts->ts_ctxlock);
#line 111
  downgrade_write(& mm->mmap_sem);
#line 112
  return (gts);
  err: 
#line 115
  up_write(& mm->mmap_sem);
#line 116
  return (gts);
}
}
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
static void gru_unlock_gts(struct gru_thread_state *gts ) 
{ 
  struct task_struct *tmp ;

  {
#line 124
  ldv_mutex_unlock_70(& gts->ts_ctxlock);
#line 125
  tmp = get_current();
#line 125
  up_read(& (tmp->mm)->mmap_sem);
#line 126
  return;
}
}
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
static void gru_cb_set_istatus_active(struct gru_instruction_bits *cbk ) 
{ 


  {
#line 138
  if ((unsigned long )cbk != (unsigned long )((struct gru_instruction_bits *)0)) {
#line 139
    cbk->istatus = 2U;
  } else {

  }
#line 140
  return;
}
}
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
static void get_clear_fault_map(struct gru_state *gru , struct gru_tlb_fault_map *imap ,
                                struct gru_tlb_fault_map *dmap ) 
{ 
  unsigned long i ;
  unsigned long k ;
  struct gru_tlb_fault_map *tfm ;
  int tmp ;
  unsigned long __ret ;
  unsigned long __ret___0 ;

  {
#line 161
  tmp = gru_cpu_fault_map_id();
#line 161
  tfm = get_tfm(gru->gs_gru_base_vaddr, tmp);
#line 162
  prefetchw((void const   *)tfm);
#line 163
  i = 0UL;
#line 163
  goto ldv_34407;
  ldv_34406: 
#line 164
  k = tfm->fault_bits[i];
#line 165
  if (k != 0UL) {
#line 166
    __ret = 0UL;
#line 166
    switch (8UL) {
    case 1UL: 
#line 166
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (*((unsigned long *)(& tfm->fault_bits) + i)): : "memory",
                         "cc");
#line 166
    goto ldv_34392;
    case 2UL: 
#line 166
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (*((unsigned long *)(& tfm->fault_bits) + i)): : "memory",
                         "cc");
#line 166
    goto ldv_34392;
    case 4UL: 
#line 166
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (*((unsigned long *)(& tfm->fault_bits) + i)): : "memory",
                         "cc");
#line 166
    goto ldv_34392;
    case 8UL: 
#line 166
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (*((unsigned long *)(& tfm->fault_bits) + i)): : "memory",
                         "cc");
#line 166
    goto ldv_34392;
    default: 
#line 166
    __xchg_wrong_size();
    }
    ldv_34392: 
#line 166
    k = __ret;
  } else {

  }
#line 167
  imap->fault_bits[i] = k;
#line 168
  k = tfm->done_bits[i];
#line 169
  if (k != 0UL) {
#line 170
    __ret___0 = 0UL;
#line 170
    switch (8UL) {
    case 1UL: 
#line 170
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (*((unsigned long *)(& tfm->done_bits) + i)): : "memory",
                         "cc");
#line 170
    goto ldv_34400;
    case 2UL: 
#line 170
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (*((unsigned long *)(& tfm->done_bits) + i)): : "memory",
                         "cc");
#line 170
    goto ldv_34400;
    case 4UL: 
#line 170
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (*((unsigned long *)(& tfm->done_bits) + i)): : "memory",
                         "cc");
#line 170
    goto ldv_34400;
    case 8UL: 
#line 170
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (*((unsigned long *)(& tfm->done_bits) + i)): : "memory",
                         "cc");
#line 170
    goto ldv_34400;
    default: 
#line 170
    __xchg_wrong_size();
    }
    ldv_34400: 
#line 170
    k = __ret___0;
  } else {

  }
#line 171
  dmap->fault_bits[i] = k;
#line 163
  i = i + 1UL;
  ldv_34407: ;
#line 163
  if (i <= 1UL) {
#line 165
    goto ldv_34406;
  } else {

  }
#line 178
  gru_flush_cache((void *)tfm);
#line 179
  return;
}
}
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
static int non_atomic_pte_lookup(struct vm_area_struct *vma , unsigned long vaddr ,
                                 int write , unsigned long *paddr , int *pageshift ) 
{ 
  struct page *page ;
  int tmp ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  long tmp___2 ;

  {
#line 197
  tmp = is_vm_hugetlb_page(vma);
#line 197
  *pageshift = tmp != 0 ? 21 : 12;
#line 201
  tmp___0 = get_current();
#line 201
  tmp___1 = get_current();
#line 201
  tmp___2 = get_user_pages(tmp___1, tmp___0->mm, vaddr, 1UL, write, 0, & page, (struct vm_area_struct **)0);
#line 201
  if (tmp___2 <= 0L) {
#line 203
    return (-14);
  } else {

  }
#line 204
  *paddr = (unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12);
#line 205
  put_page(page);
#line 206
  return (0);
}
}
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
static int atomic_pte_lookup(struct vm_area_struct *vma , unsigned long vaddr , int write ,
                             unsigned long *paddr , int *pageshift ) 
{ 
  pgd_t *pgdp ;
  pmd_t *pmdp ;
  pud_t *pudp ;
  pte_t pte ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  pte_t *tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  unsigned long tmp___13 ;
  int tmp___14 ;

  {
#line 227
  pgdp = (vma->vm_mm)->pgd + ((vaddr >> 39) & 511UL);
#line 228
  tmp = pgd_none(*pgdp);
#line 228
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 228
  if (tmp___0 != 0L) {
#line 229
    goto err;
  } else {

  }
#line 231
  pudp = pud_offset(pgdp, vaddr);
#line 232
  tmp___1 = pud_none(*pudp);
#line 232
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 232
  if (tmp___2 != 0L) {
#line 233
    goto err;
  } else {

  }
#line 235
  pmdp = pmd_offset(pudp, vaddr);
#line 236
  tmp___3 = pmd_none(*pmdp);
#line 236
  tmp___4 = ldv__builtin_expect(tmp___3 != 0, 0L);
#line 236
  if (tmp___4 != 0L) {
#line 237
    goto err;
  } else {

  }
#line 239
  tmp___6 = pmd_large(*pmdp);
#line 239
  tmp___7 = ldv__builtin_expect(tmp___6 != 0, 0L);
#line 239
  if (tmp___7 != 0L) {
#line 240
    pte = *((pte_t *)pmdp);
  } else {
#line 243
    tmp___5 = pte_offset_kernel(pmdp, vaddr);
#line 243
    pte = *tmp___5;
  }
#line 245
  tmp___8 = pte_present(pte);
#line 245
  if (tmp___8 == 0) {
#line 245
    tmp___11 = 1;
  } else
#line 245
  if (write != 0) {
#line 245
    tmp___9 = pte_write(pte);
#line 245
    if (tmp___9 == 0) {
#line 245
      tmp___11 = 1;
    } else {
#line 245
      tmp___10 = pte_dirty(pte);
#line 245
      if (tmp___10 == 0) {
#line 245
        tmp___11 = 1;
      } else {
#line 245
        tmp___11 = 0;
      }
    }
  } else {
#line 245
    tmp___11 = 0;
  }
#line 245
  tmp___12 = ldv__builtin_expect((long )tmp___11, 0L);
#line 245
  if (tmp___12 != 0L) {
#line 247
    return (1);
  } else {

  }
#line 249
  tmp___13 = pte_pfn(pte);
#line 249
  *paddr = tmp___13 << 12;
#line 251
  tmp___14 = is_vm_hugetlb_page(vma);
#line 251
  *pageshift = tmp___14 != 0 ? 21 : 12;
#line 255
  return (0);
  err: ;
#line 258
  return (1);
}
}
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
static int gru_vtop(struct gru_thread_state *gts , unsigned long vaddr , int write ,
                    int atomic , unsigned long *gpa , int *pageshift ) 
{ 
  struct mm_struct *mm ;
  struct vm_area_struct *vma ;
  unsigned long paddr ;
  int ret ;
  int ps ;
  int tmp ;
  int tmp___0 ;

  {
#line 264
  mm = gts->ts_mm;
#line 269
  vma = find_vma(mm, vaddr);
#line 270
  if ((unsigned long )vma == (unsigned long )((struct vm_area_struct *)0)) {
#line 271
    goto inval;
  } else {

  }
#line 277
  __asm__  volatile   ("lfence": : : "memory");
#line 278
  ret = atomic_pte_lookup(vma, vaddr, write, & paddr, & ps);
#line 279
  if (ret != 0) {
#line 280
    if (atomic != 0) {
#line 281
      goto upm;
    } else {

    }
#line 282
    tmp = non_atomic_pte_lookup(vma, vaddr, write, & paddr, & ps);
#line 282
    if (tmp != 0) {
#line 283
      goto inval;
    } else {

    }
  } else {

  }
#line 285
  tmp___0 = is_gru_paddr(paddr);
#line 285
  if (tmp___0 != 0) {
#line 286
    goto inval;
  } else {

  }
#line 287
  paddr = - (1UL << ps) & paddr;
#line 288
  *gpa = uv_soc_phys_ram_to_gpa(paddr);
#line 289
  *pageshift = ps;
#line 290
  return (0);
  inval: ;
#line 293
  return (-1);
  upm: ;
#line 295
  return (-2);
}
}
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
static void gru_flush_cache_cbe(struct gru_control_block_extended *cbe ) 
{ 
  long tmp ;

  {
#line 307
  tmp = ldv__builtin_expect((unsigned long )cbe != (unsigned long )((struct gru_control_block_extended *)0),
                         0L);
#line 307
  if (tmp != 0L) {
#line 308
    cbe->cbrexecstatus = 0U;
#line 309
    gru_flush_cache((void *)cbe);
  } else {

  }
#line 311
  return;
}
}
#line 318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
static void gru_preload_tlb(struct gru_state *gru , struct gru_thread_state *gts ,
                            int atomic , unsigned long fault_vaddr , int asid , int write ,
                            unsigned char tlb_preload_count , struct gru_tlb_fault_handle *tfh ,
                            struct gru_control_block_extended *cbe ) 
{ 
  unsigned long vaddr ;
  unsigned long gpa ;
  int ret ;
  int pageshift ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  int tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 325
  vaddr = 0UL;
#line 328
  if ((unsigned int )cbe->opccpy != 1U) {
#line 329
    return;
  } else {

  }
#line 331
  if (cbe->idef1upd == fault_vaddr) {
#line 332
    vaddr = (cbe->idef6cpy * 64UL + fault_vaddr) - 1UL;
  } else
#line 333
  if (cbe->idef3upd == fault_vaddr) {
#line 334
    vaddr = ((unsigned long )(1 << (int )cbe->xtypecpy) * cbe->idef5upd + fault_vaddr) - 1UL;
  } else {

  }
#line 336
  fault_vaddr = fault_vaddr & 0xfffffffffffff000UL;
#line 337
  vaddr = vaddr & 0xfffffffffffff000UL;
#line 338
  _min1 = vaddr;
#line 338
  _min2 = (unsigned long )tlb_preload_count * 4096UL + fault_vaddr;
#line 338
  vaddr = _min1 < _min2 ? _min1 : _min2;
#line 340
  goto ldv_34508;
  ldv_34507: 
#line 341
  ret = gru_vtop(gts, vaddr, write, atomic, & gpa, & pageshift);
#line 342
  if (ret != 0) {
#line 344
    return;
  } else {
#line 342
    tmp = tfh_write_only(tfh, gpa, 0, vaddr, asid, write, pageshift > 20 ? ((pageshift + 2) >> 1) + -6 : (pageshift >> 1) + -6);
#line 342
    if (tmp != 0) {
#line 344
      return;
    } else {

    }
  }
#line 345
  if ((int )gru_options & 1) {
#line 345
    __vpp_verify = (void const   *)0;
#line 345
    switch (4UL) {
    case 1UL: ;
#line 348
    switch (4UL) {
    case 1UL: 
#line 348
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 348
    goto ldv_34470;
    case 2UL: 
#line 348
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 348
    goto ldv_34470;
    case 4UL: 
#line 348
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 348
    goto ldv_34470;
    case 8UL: 
#line 348
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 348
    goto ldv_34470;
    default: 
#line 348
    __bad_percpu_size();
    }
    ldv_34470: 
#line 348
    pscr_ret__ = pfo_ret__;
#line 348
    goto ldv_34476;
    case 2UL: ;
#line 348
    switch (4UL) {
    case 1UL: 
#line 348
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 348
    goto ldv_34480;
    case 2UL: 
#line 348
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 348
    goto ldv_34480;
    case 4UL: 
#line 348
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 348
    goto ldv_34480;
    case 8UL: 
#line 348
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 348
    goto ldv_34480;
    default: 
#line 348
    __bad_percpu_size();
    }
    ldv_34480: 
#line 348
    pscr_ret__ = pfo_ret_____0;
#line 348
    goto ldv_34476;
    case 4UL: ;
#line 348
    switch (4UL) {
    case 1UL: 
#line 348
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 348
    goto ldv_34489;
    case 2UL: 
#line 348
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 348
    goto ldv_34489;
    case 4UL: 
#line 348
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 348
    goto ldv_34489;
    case 8UL: 
#line 348
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 348
    goto ldv_34489;
    default: 
#line 348
    __bad_percpu_size();
    }
    ldv_34489: 
#line 348
    pscr_ret__ = pfo_ret_____1;
#line 348
    goto ldv_34476;
    case 8UL: ;
#line 348
    switch (4UL) {
    case 1UL: 
#line 348
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 348
    goto ldv_34498;
    case 2UL: 
#line 348
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 348
    goto ldv_34498;
    case 4UL: 
#line 348
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 348
    goto ldv_34498;
    case 8UL: 
#line 348
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 348
    goto ldv_34498;
    default: 
#line 348
    __bad_percpu_size();
    }
    ldv_34498: 
#line 348
    pscr_ret__ = pfo_ret_____2;
#line 348
    goto ldv_34476;
    default: 
#line 348
    __bad_size_call_parameter();
#line 348
    goto ldv_34476;
    }
    ldv_34476: 
#line 348
    printk("\017GRU:%d %s: %s: gid %d, gts 0x%p, tfh 0x%p, vaddr 0x%lx, asid 0x%x, rw %d, ps %d, gpa 0x%lx\n",
           pscr_ret__, "gru_preload_tlb", atomic != 0 ? (char *)"atomic" : (char *)"non-atomic",
           (int )gru->gs_gid, gts, tfh, vaddr, asid, write, pageshift, gpa);
  } else {

  }
#line 349
  vaddr = vaddr - 4096UL;
#line 350
  if ((gru_options & 2UL) != 0UL) {
#line 350
    atomic_long_inc(& gru_stats.tlb_preload_page);
  } else {

  }
  ldv_34508: ;
#line 340
  if (vaddr > fault_vaddr) {
#line 342
    goto ldv_34507;
  } else {

  }

#line 347
  return;
}
}
#line 364 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
static int gru_try_dropin(struct gru_state *gru , struct gru_thread_state *gts , struct gru_tlb_fault_handle *tfh ,
                          struct gru_instruction_bits *cbk ) 
{ 
  struct gru_control_block_extended *cbe ;
  unsigned char tlb_preload_count ;
  int pageshift ;
  int asid ;
  int write ;
  int ret ;
  int atomic ;
  int indexway ;
  unsigned long gpa ;
  unsigned long vaddr ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int pscr_ret_____1 ;
  void const   *__vpp_verify___1 ;
  int pfo_ret_____7 ;
  int pfo_ret_____8 ;
  int pfo_ret_____9 ;
  int pfo_ret_____10 ;
  int pscr_ret_____2 ;
  void const   *__vpp_verify___2 ;
  int pfo_ret_____11 ;
  int pfo_ret_____12 ;
  int pfo_ret_____13 ;
  int pfo_ret_____14 ;
  int pscr_ret_____3 ;
  void const   *__vpp_verify___3 ;
  int pfo_ret_____15 ;
  int pfo_ret_____16 ;
  int pfo_ret_____17 ;
  int pfo_ret_____18 ;
  int pscr_ret_____4 ;
  void const   *__vpp_verify___4 ;
  int pfo_ret_____19 ;
  int pfo_ret_____20 ;
  int pfo_ret_____21 ;
  int pfo_ret_____22 ;
  int pscr_ret_____5 ;
  void const   *__vpp_verify___5 ;
  int pfo_ret_____23 ;
  int pfo_ret_____24 ;
  int pfo_ret_____25 ;
  int pfo_ret_____26 ;
  int pscr_ret_____6 ;
  void const   *__vpp_verify___6 ;
  int pfo_ret_____27 ;
  int pfo_ret_____28 ;
  int pfo_ret_____29 ;
  int pfo_ret_____30 ;

  {
#line 369
  cbe = (struct gru_control_block_extended *)0;
#line 370
  tlb_preload_count = gts->ts_tlb_preload_count;
#line 371
  pageshift = 0;
#line 371
  atomic = (unsigned long )cbk == (unsigned long )((struct gru_instruction_bits *)0);
#line 372
  gpa = 0UL;
#line 372
  vaddr = 0UL;
#line 384
  tmp = ldv__builtin_expect((unsigned int )tlb_preload_count != 0U, 0L);
#line 384
  if (tmp != 0L) {
#line 385
    cbe = gru_tfh_to_cbe(tfh);
#line 386
    prefetchw((void const   *)cbe);
  } else {

  }
#line 394
  if ((unsigned int )*((unsigned char *)tfh + 2UL) != 1U) {
#line 395
    gru_flush_cache((void *)tfh);
#line 396
    sync_core();
#line 397
    if ((unsigned int )*((unsigned char *)tfh + 2UL) != 1U) {
#line 398
      goto failnoexception;
    } else {

    }
#line 399
    if ((gru_options & 2UL) != 0UL) {
#line 399
      atomic_long_inc(& gru_stats.tfh_stale_on_fault);
    } else {

    }
  } else {

  }
#line 401
  if ((unsigned int )*((unsigned char *)tfh + 2UL) == 16U) {
#line 402
    goto failidle;
  } else {

  }
#line 403
  if ((unsigned int )*((unsigned char *)tfh + 2UL) == 48U && (unsigned long )cbk != (unsigned long )((struct gru_instruction_bits *)0)) {
#line 404
    goto failfmm;
  } else {

  }
#line 406
  write = ((int )tfh->cause & 2) != 0;
#line 407
  vaddr = tfh->missvaddr;
#line 408
  asid = (int )tfh->missasid;
#line 409
  indexway = (int )tfh->indexway;
#line 410
  if (asid == 0) {
#line 411
    goto failnoasid;
  } else {

  }
#line 413
  __asm__  volatile   ("lfence": : : "memory");
#line 419
  tmp___0 = atomic_read((atomic_t const   *)(& (gts->ts_gms)->ms_range_active));
#line 419
  if (tmp___0 != 0) {
#line 420
    goto failactive;
  } else {

  }
#line 422
  ret = gru_vtop(gts, vaddr, write, atomic, & gpa, & pageshift);
#line 423
  if (ret == -1) {
#line 424
    goto failinval;
  } else {

  }
#line 425
  if (ret == -2) {
#line 426
    goto failupm;
  } else {

  }
#line 428
  if (((unsigned long )gts->ts_sizeavail & (pageshift > 20 ? 1UL << (((pageshift + 2) >> 1) + -6) : 1UL << ((pageshift >> 1) + -6))) == 0UL) {
#line 429
    gts->ts_sizeavail = (int )gts->ts_sizeavail | (pageshift > 20 ? (unsigned short )(1UL << (((pageshift + 2) >> 1) + -6)) : (unsigned short )(1UL << ((pageshift >> 1) + -6)));
#line 430
    if (atomic != 0) {
#line 431
      gts->ts_force_cch_reload = 1;
#line 432
      goto failupm;
    } else {
#line 430
      tmp___1 = gru_update_cch(gts);
#line 430
      if (tmp___1 == 0) {
#line 431
        gts->ts_force_cch_reload = 1;
#line 432
        goto failupm;
      } else {

      }
    }
  } else {

  }
#line 436
  tmp___2 = ldv__builtin_expect((unsigned long )cbe != (unsigned long )((struct gru_control_block_extended *)0),
                             0L);
#line 436
  if (tmp___2 != 0L && pageshift == 12) {
#line 437
    gru_preload_tlb(gru, gts, atomic, vaddr, asid, write, (int )tlb_preload_count,
                    tfh, cbe);
#line 438
    gru_flush_cache_cbe(cbe);
  } else {

  }
#line 441
  gru_cb_set_istatus_active(cbk);
#line 442
  gts->ustats.tlbdropin = gts->ustats.tlbdropin + 1UL;
#line 443
  tfh_write_restart(tfh, gpa, 0, vaddr, asid, write, pageshift > 20 ? ((pageshift + 2) >> 1) + -6 : (pageshift >> 1) + -6);
#line 445
  if ((int )gru_options & 1) {
#line 445
    __vpp_verify = (void const   *)0;
#line 445
    switch (4UL) {
    case 1UL: ;
#line 449
    switch (4UL) {
    case 1UL: 
#line 449
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 449
    goto ldv_34538;
    case 2UL: 
#line 449
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 449
    goto ldv_34538;
    case 4UL: 
#line 449
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 449
    goto ldv_34538;
    case 8UL: 
#line 449
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 449
    goto ldv_34538;
    default: 
#line 449
    __bad_percpu_size();
    }
    ldv_34538: 
#line 449
    pscr_ret__ = pfo_ret__;
#line 449
    goto ldv_34544;
    case 2UL: ;
#line 449
    switch (4UL) {
    case 1UL: 
#line 449
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 449
    goto ldv_34548;
    case 2UL: 
#line 449
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 449
    goto ldv_34548;
    case 4UL: 
#line 449
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 449
    goto ldv_34548;
    case 8UL: 
#line 449
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 449
    goto ldv_34548;
    default: 
#line 449
    __bad_percpu_size();
    }
    ldv_34548: 
#line 449
    pscr_ret__ = pfo_ret_____0;
#line 449
    goto ldv_34544;
    case 4UL: ;
#line 449
    switch (4UL) {
    case 1UL: 
#line 449
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 449
    goto ldv_34557;
    case 2UL: 
#line 449
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 449
    goto ldv_34557;
    case 4UL: 
#line 449
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 449
    goto ldv_34557;
    case 8UL: 
#line 449
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 449
    goto ldv_34557;
    default: 
#line 449
    __bad_percpu_size();
    }
    ldv_34557: 
#line 449
    pscr_ret__ = pfo_ret_____1;
#line 449
    goto ldv_34544;
    case 8UL: ;
#line 449
    switch (4UL) {
    case 1UL: 
#line 449
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 449
    goto ldv_34566;
    case 2UL: 
#line 449
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 449
    goto ldv_34566;
    case 4UL: 
#line 449
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 449
    goto ldv_34566;
    case 8UL: 
#line 449
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 449
    goto ldv_34566;
    default: 
#line 449
    __bad_percpu_size();
    }
    ldv_34566: 
#line 449
    pscr_ret__ = pfo_ret_____2;
#line 449
    goto ldv_34544;
    default: 
#line 449
    __bad_size_call_parameter();
#line 449
    goto ldv_34544;
    }
    ldv_34544: 
#line 449
    printk("\017GRU:%d %s: %s: gid %d, gts 0x%p, tfh 0x%p, vaddr 0x%lx, asid 0x%x, indexway 0x%x, rw %d, ps %d, gpa 0x%lx\n",
           pscr_ret__, "gru_try_dropin", atomic != 0 ? (char *)"atomic" : (char *)"non-atomic",
           (int )gru->gs_gid, gts, tfh, vaddr, asid, indexway, write, pageshift, gpa);
  } else {

  }
#line 450
  if ((gru_options & 2UL) != 0UL) {
#line 450
    atomic_long_inc(& gru_stats.tlb_dropin);
  } else {

  }
#line 451
  return (0);
  failnoasid: ;
#line 455
  if ((gru_options & 2UL) != 0UL) {
#line 455
    atomic_long_inc(& gru_stats.tlb_dropin_fail_no_asid);
  } else {

  }
#line 456
  if ((int )gru_options & 1) {
#line 456
    __vpp_verify___0 = (void const   *)0;
#line 456
    switch (4UL) {
    case 1UL: ;
#line 456
    switch (4UL) {
    case 1UL: 
#line 456
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 456
    goto ldv_34580;
    case 2UL: 
#line 456
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 456
    goto ldv_34580;
    case 4UL: 
#line 456
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 456
    goto ldv_34580;
    case 8UL: 
#line 456
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 456
    goto ldv_34580;
    default: 
#line 456
    __bad_percpu_size();
    }
    ldv_34580: 
#line 456
    pscr_ret_____0 = pfo_ret_____3;
#line 456
    goto ldv_34586;
    case 2UL: ;
#line 456
    switch (4UL) {
    case 1UL: 
#line 456
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 456
    goto ldv_34590;
    case 2UL: 
#line 456
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 456
    goto ldv_34590;
    case 4UL: 
#line 456
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 456
    goto ldv_34590;
    case 8UL: 
#line 456
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 456
    goto ldv_34590;
    default: 
#line 456
    __bad_percpu_size();
    }
    ldv_34590: 
#line 456
    pscr_ret_____0 = pfo_ret_____4;
#line 456
    goto ldv_34586;
    case 4UL: ;
#line 456
    switch (4UL) {
    case 1UL: 
#line 456
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 456
    goto ldv_34599;
    case 2UL: 
#line 456
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 456
    goto ldv_34599;
    case 4UL: 
#line 456
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 456
    goto ldv_34599;
    case 8UL: 
#line 456
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 456
    goto ldv_34599;
    default: 
#line 456
    __bad_percpu_size();
    }
    ldv_34599: 
#line 456
    pscr_ret_____0 = pfo_ret_____5;
#line 456
    goto ldv_34586;
    case 8UL: ;
#line 456
    switch (4UL) {
    case 1UL: 
#line 456
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 456
    goto ldv_34608;
    case 2UL: 
#line 456
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 456
    goto ldv_34608;
    case 4UL: 
#line 456
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 456
    goto ldv_34608;
    case 8UL: 
#line 456
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 456
    goto ldv_34608;
    default: 
#line 456
    __bad_percpu_size();
    }
    ldv_34608: 
#line 456
    pscr_ret_____0 = pfo_ret_____6;
#line 456
    goto ldv_34586;
    default: 
#line 456
    __bad_size_call_parameter();
#line 456
    goto ldv_34586;
    }
    ldv_34586: 
#line 456
    printk("\017GRU:%d %s: FAILED no_asid tfh: 0x%p, vaddr 0x%lx\n", pscr_ret_____0,
           "gru_try_dropin", tfh, vaddr);
  } else {

  }
#line 457
  if ((unsigned long )cbk == (unsigned long )((struct gru_instruction_bits *)0)) {
#line 458
    tfh_user_polling_mode(tfh);
  } else {
#line 460
    gru_flush_cache((void *)tfh);
  }
#line 461
  gru_flush_cache_cbe(cbe);
#line 462
  return (-11);
  failupm: 
#line 466
  tfh_user_polling_mode(tfh);
#line 467
  gru_flush_cache_cbe(cbe);
#line 468
  if ((gru_options & 2UL) != 0UL) {
#line 468
    atomic_long_inc(& gru_stats.tlb_dropin_fail_upm);
  } else {

  }
#line 469
  if ((int )gru_options & 1) {
#line 469
    __vpp_verify___1 = (void const   *)0;
#line 469
    switch (4UL) {
    case 1UL: ;
#line 469
    switch (4UL) {
    case 1UL: 
#line 469
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____7): "m" (cpu_number));
#line 469
    goto ldv_34621;
    case 2UL: 
#line 469
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 469
    goto ldv_34621;
    case 4UL: 
#line 469
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 469
    goto ldv_34621;
    case 8UL: 
#line 469
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 469
    goto ldv_34621;
    default: 
#line 469
    __bad_percpu_size();
    }
    ldv_34621: 
#line 469
    pscr_ret_____1 = pfo_ret_____7;
#line 469
    goto ldv_34627;
    case 2UL: ;
#line 469
    switch (4UL) {
    case 1UL: 
#line 469
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____8): "m" (cpu_number));
#line 469
    goto ldv_34631;
    case 2UL: 
#line 469
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 469
    goto ldv_34631;
    case 4UL: 
#line 469
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 469
    goto ldv_34631;
    case 8UL: 
#line 469
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 469
    goto ldv_34631;
    default: 
#line 469
    __bad_percpu_size();
    }
    ldv_34631: 
#line 469
    pscr_ret_____1 = pfo_ret_____8;
#line 469
    goto ldv_34627;
    case 4UL: ;
#line 469
    switch (4UL) {
    case 1UL: 
#line 469
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____9): "m" (cpu_number));
#line 469
    goto ldv_34640;
    case 2UL: 
#line 469
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 469
    goto ldv_34640;
    case 4UL: 
#line 469
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 469
    goto ldv_34640;
    case 8UL: 
#line 469
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 469
    goto ldv_34640;
    default: 
#line 469
    __bad_percpu_size();
    }
    ldv_34640: 
#line 469
    pscr_ret_____1 = pfo_ret_____9;
#line 469
    goto ldv_34627;
    case 8UL: ;
#line 469
    switch (4UL) {
    case 1UL: 
#line 469
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____10): "m" (cpu_number));
#line 469
    goto ldv_34649;
    case 2UL: 
#line 469
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 469
    goto ldv_34649;
    case 4UL: 
#line 469
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 469
    goto ldv_34649;
    case 8UL: 
#line 469
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 469
    goto ldv_34649;
    default: 
#line 469
    __bad_percpu_size();
    }
    ldv_34649: 
#line 469
    pscr_ret_____1 = pfo_ret_____10;
#line 469
    goto ldv_34627;
    default: 
#line 469
    __bad_size_call_parameter();
#line 469
    goto ldv_34627;
    }
    ldv_34627: 
#line 469
    printk("\017GRU:%d %s: FAILED upm tfh: 0x%p, vaddr 0x%lx\n", pscr_ret_____1, "gru_try_dropin",
           tfh, vaddr);
  } else {

  }
#line 470
  return (1);
  failfmm: 
#line 474
  gru_flush_cache((void *)tfh);
#line 475
  gru_flush_cache_cbe(cbe);
#line 476
  if ((gru_options & 2UL) != 0UL) {
#line 476
    atomic_long_inc(& gru_stats.tlb_dropin_fail_fmm);
  } else {

  }
#line 477
  if ((int )gru_options & 1) {
#line 477
    __vpp_verify___2 = (void const   *)0;
#line 477
    switch (4UL) {
    case 1UL: ;
#line 477
    switch (4UL) {
    case 1UL: 
#line 477
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____11): "m" (cpu_number));
#line 477
    goto ldv_34662;
    case 2UL: 
#line 477
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 477
    goto ldv_34662;
    case 4UL: 
#line 477
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 477
    goto ldv_34662;
    case 8UL: 
#line 477
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 477
    goto ldv_34662;
    default: 
#line 477
    __bad_percpu_size();
    }
    ldv_34662: 
#line 477
    pscr_ret_____2 = pfo_ret_____11;
#line 477
    goto ldv_34668;
    case 2UL: ;
#line 477
    switch (4UL) {
    case 1UL: 
#line 477
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____12): "m" (cpu_number));
#line 477
    goto ldv_34672;
    case 2UL: 
#line 477
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 477
    goto ldv_34672;
    case 4UL: 
#line 477
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 477
    goto ldv_34672;
    case 8UL: 
#line 477
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 477
    goto ldv_34672;
    default: 
#line 477
    __bad_percpu_size();
    }
    ldv_34672: 
#line 477
    pscr_ret_____2 = pfo_ret_____12;
#line 477
    goto ldv_34668;
    case 4UL: ;
#line 477
    switch (4UL) {
    case 1UL: 
#line 477
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____13): "m" (cpu_number));
#line 477
    goto ldv_34681;
    case 2UL: 
#line 477
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 477
    goto ldv_34681;
    case 4UL: 
#line 477
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 477
    goto ldv_34681;
    case 8UL: 
#line 477
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 477
    goto ldv_34681;
    default: 
#line 477
    __bad_percpu_size();
    }
    ldv_34681: 
#line 477
    pscr_ret_____2 = pfo_ret_____13;
#line 477
    goto ldv_34668;
    case 8UL: ;
#line 477
    switch (4UL) {
    case 1UL: 
#line 477
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____14): "m" (cpu_number));
#line 477
    goto ldv_34690;
    case 2UL: 
#line 477
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 477
    goto ldv_34690;
    case 4UL: 
#line 477
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 477
    goto ldv_34690;
    case 8UL: 
#line 477
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 477
    goto ldv_34690;
    default: 
#line 477
    __bad_percpu_size();
    }
    ldv_34690: 
#line 477
    pscr_ret_____2 = pfo_ret_____14;
#line 477
    goto ldv_34668;
    default: 
#line 477
    __bad_size_call_parameter();
#line 477
    goto ldv_34668;
    }
    ldv_34668: 
#line 477
    printk("\017GRU:%d %s: FAILED fmm tfh: 0x%p, state %d\n", pscr_ret_____2, "gru_try_dropin",
           tfh, (int )tfh->state);
  } else {

  }
#line 478
  return (0);
  failnoexception: 
#line 482
  gru_flush_cache((void *)tfh);
#line 483
  gru_flush_cache_cbe(cbe);
#line 484
  if ((unsigned long )cbk != (unsigned long )((struct gru_instruction_bits *)0)) {
#line 485
    gru_flush_cache((void *)cbk);
  } else {

  }
#line 486
  if ((gru_options & 2UL) != 0UL) {
#line 486
    atomic_long_inc(& gru_stats.tlb_dropin_fail_no_exception);
  } else {

  }
#line 487
  if ((int )gru_options & 1) {
#line 487
    __vpp_verify___3 = (void const   *)0;
#line 487
    switch (4UL) {
    case 1UL: ;
#line 488
    switch (4UL) {
    case 1UL: 
#line 488
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____15): "m" (cpu_number));
#line 488
    goto ldv_34703;
    case 2UL: 
#line 488
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____15): "m" (cpu_number));
#line 488
    goto ldv_34703;
    case 4UL: 
#line 488
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____15): "m" (cpu_number));
#line 488
    goto ldv_34703;
    case 8UL: 
#line 488
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____15): "m" (cpu_number));
#line 488
    goto ldv_34703;
    default: 
#line 488
    __bad_percpu_size();
    }
    ldv_34703: 
#line 488
    pscr_ret_____3 = pfo_ret_____15;
#line 488
    goto ldv_34709;
    case 2UL: ;
#line 488
    switch (4UL) {
    case 1UL: 
#line 488
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____16): "m" (cpu_number));
#line 488
    goto ldv_34713;
    case 2UL: 
#line 488
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____16): "m" (cpu_number));
#line 488
    goto ldv_34713;
    case 4UL: 
#line 488
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____16): "m" (cpu_number));
#line 488
    goto ldv_34713;
    case 8UL: 
#line 488
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____16): "m" (cpu_number));
#line 488
    goto ldv_34713;
    default: 
#line 488
    __bad_percpu_size();
    }
    ldv_34713: 
#line 488
    pscr_ret_____3 = pfo_ret_____16;
#line 488
    goto ldv_34709;
    case 4UL: ;
#line 488
    switch (4UL) {
    case 1UL: 
#line 488
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____17): "m" (cpu_number));
#line 488
    goto ldv_34722;
    case 2UL: 
#line 488
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____17): "m" (cpu_number));
#line 488
    goto ldv_34722;
    case 4UL: 
#line 488
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____17): "m" (cpu_number));
#line 488
    goto ldv_34722;
    case 8UL: 
#line 488
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____17): "m" (cpu_number));
#line 488
    goto ldv_34722;
    default: 
#line 488
    __bad_percpu_size();
    }
    ldv_34722: 
#line 488
    pscr_ret_____3 = pfo_ret_____17;
#line 488
    goto ldv_34709;
    case 8UL: ;
#line 488
    switch (4UL) {
    case 1UL: 
#line 488
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____18): "m" (cpu_number));
#line 488
    goto ldv_34731;
    case 2UL: 
#line 488
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____18): "m" (cpu_number));
#line 488
    goto ldv_34731;
    case 4UL: 
#line 488
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____18): "m" (cpu_number));
#line 488
    goto ldv_34731;
    case 8UL: 
#line 488
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____18): "m" (cpu_number));
#line 488
    goto ldv_34731;
    default: 
#line 488
    __bad_percpu_size();
    }
    ldv_34731: 
#line 488
    pscr_ret_____3 = pfo_ret_____18;
#line 488
    goto ldv_34709;
    default: 
#line 488
    __bad_size_call_parameter();
#line 488
    goto ldv_34709;
    }
    ldv_34709: 
#line 488
    printk("\017GRU:%d %s: FAILED non-exception tfh: 0x%p, status %d, state %d\n",
           pscr_ret_____3, "gru_try_dropin", tfh, (int )tfh->status, (int )tfh->state);
  } else {

  }
#line 489
  return (0);
  failidle: 
#line 493
  gru_flush_cache((void *)tfh);
#line 494
  gru_flush_cache_cbe(cbe);
#line 495
  if ((unsigned long )cbk != (unsigned long )((struct gru_instruction_bits *)0)) {
#line 496
    gru_flush_cache((void *)cbk);
  } else {

  }
#line 497
  if ((gru_options & 2UL) != 0UL) {
#line 497
    atomic_long_inc(& gru_stats.tlb_dropin_fail_idle);
  } else {

  }
#line 498
  if ((int )gru_options & 1) {
#line 498
    __vpp_verify___4 = (void const   *)0;
#line 498
    switch (4UL) {
    case 1UL: ;
#line 498
    switch (4UL) {
    case 1UL: 
#line 498
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____19): "m" (cpu_number));
#line 498
    goto ldv_34744;
    case 2UL: 
#line 498
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____19): "m" (cpu_number));
#line 498
    goto ldv_34744;
    case 4UL: 
#line 498
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____19): "m" (cpu_number));
#line 498
    goto ldv_34744;
    case 8UL: 
#line 498
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____19): "m" (cpu_number));
#line 498
    goto ldv_34744;
    default: 
#line 498
    __bad_percpu_size();
    }
    ldv_34744: 
#line 498
    pscr_ret_____4 = pfo_ret_____19;
#line 498
    goto ldv_34750;
    case 2UL: ;
#line 498
    switch (4UL) {
    case 1UL: 
#line 498
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____20): "m" (cpu_number));
#line 498
    goto ldv_34754;
    case 2UL: 
#line 498
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____20): "m" (cpu_number));
#line 498
    goto ldv_34754;
    case 4UL: 
#line 498
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____20): "m" (cpu_number));
#line 498
    goto ldv_34754;
    case 8UL: 
#line 498
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____20): "m" (cpu_number));
#line 498
    goto ldv_34754;
    default: 
#line 498
    __bad_percpu_size();
    }
    ldv_34754: 
#line 498
    pscr_ret_____4 = pfo_ret_____20;
#line 498
    goto ldv_34750;
    case 4UL: ;
#line 498
    switch (4UL) {
    case 1UL: 
#line 498
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____21): "m" (cpu_number));
#line 498
    goto ldv_34763;
    case 2UL: 
#line 498
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____21): "m" (cpu_number));
#line 498
    goto ldv_34763;
    case 4UL: 
#line 498
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____21): "m" (cpu_number));
#line 498
    goto ldv_34763;
    case 8UL: 
#line 498
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____21): "m" (cpu_number));
#line 498
    goto ldv_34763;
    default: 
#line 498
    __bad_percpu_size();
    }
    ldv_34763: 
#line 498
    pscr_ret_____4 = pfo_ret_____21;
#line 498
    goto ldv_34750;
    case 8UL: ;
#line 498
    switch (4UL) {
    case 1UL: 
#line 498
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____22): "m" (cpu_number));
#line 498
    goto ldv_34772;
    case 2UL: 
#line 498
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____22): "m" (cpu_number));
#line 498
    goto ldv_34772;
    case 4UL: 
#line 498
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____22): "m" (cpu_number));
#line 498
    goto ldv_34772;
    case 8UL: 
#line 498
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____22): "m" (cpu_number));
#line 498
    goto ldv_34772;
    default: 
#line 498
    __bad_percpu_size();
    }
    ldv_34772: 
#line 498
    pscr_ret_____4 = pfo_ret_____22;
#line 498
    goto ldv_34750;
    default: 
#line 498
    __bad_size_call_parameter();
#line 498
    goto ldv_34750;
    }
    ldv_34750: 
#line 498
    printk("\017GRU:%d %s: FAILED idle tfh: 0x%p, state %d\n", pscr_ret_____4, "gru_try_dropin",
           tfh, (int )tfh->state);
  } else {

  }
#line 499
  return (0);
  failinval: 
#line 503
  tfh_exception(tfh);
#line 504
  gru_flush_cache_cbe(cbe);
#line 505
  if ((gru_options & 2UL) != 0UL) {
#line 505
    atomic_long_inc(& gru_stats.tlb_dropin_fail_invalid);
  } else {

  }
#line 506
  if ((int )gru_options & 1) {
#line 506
    __vpp_verify___5 = (void const   *)0;
#line 506
    switch (4UL) {
    case 1UL: ;
#line 506
    switch (4UL) {
    case 1UL: 
#line 506
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____23): "m" (cpu_number));
#line 506
    goto ldv_34785;
    case 2UL: 
#line 506
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____23): "m" (cpu_number));
#line 506
    goto ldv_34785;
    case 4UL: 
#line 506
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____23): "m" (cpu_number));
#line 506
    goto ldv_34785;
    case 8UL: 
#line 506
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____23): "m" (cpu_number));
#line 506
    goto ldv_34785;
    default: 
#line 506
    __bad_percpu_size();
    }
    ldv_34785: 
#line 506
    pscr_ret_____5 = pfo_ret_____23;
#line 506
    goto ldv_34791;
    case 2UL: ;
#line 506
    switch (4UL) {
    case 1UL: 
#line 506
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____24): "m" (cpu_number));
#line 506
    goto ldv_34795;
    case 2UL: 
#line 506
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____24): "m" (cpu_number));
#line 506
    goto ldv_34795;
    case 4UL: 
#line 506
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____24): "m" (cpu_number));
#line 506
    goto ldv_34795;
    case 8UL: 
#line 506
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____24): "m" (cpu_number));
#line 506
    goto ldv_34795;
    default: 
#line 506
    __bad_percpu_size();
    }
    ldv_34795: 
#line 506
    pscr_ret_____5 = pfo_ret_____24;
#line 506
    goto ldv_34791;
    case 4UL: ;
#line 506
    switch (4UL) {
    case 1UL: 
#line 506
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____25): "m" (cpu_number));
#line 506
    goto ldv_34804;
    case 2UL: 
#line 506
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____25): "m" (cpu_number));
#line 506
    goto ldv_34804;
    case 4UL: 
#line 506
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____25): "m" (cpu_number));
#line 506
    goto ldv_34804;
    case 8UL: 
#line 506
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____25): "m" (cpu_number));
#line 506
    goto ldv_34804;
    default: 
#line 506
    __bad_percpu_size();
    }
    ldv_34804: 
#line 506
    pscr_ret_____5 = pfo_ret_____25;
#line 506
    goto ldv_34791;
    case 8UL: ;
#line 506
    switch (4UL) {
    case 1UL: 
#line 506
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____26): "m" (cpu_number));
#line 506
    goto ldv_34813;
    case 2UL: 
#line 506
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____26): "m" (cpu_number));
#line 506
    goto ldv_34813;
    case 4UL: 
#line 506
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____26): "m" (cpu_number));
#line 506
    goto ldv_34813;
    case 8UL: 
#line 506
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____26): "m" (cpu_number));
#line 506
    goto ldv_34813;
    default: 
#line 506
    __bad_percpu_size();
    }
    ldv_34813: 
#line 506
    pscr_ret_____5 = pfo_ret_____26;
#line 506
    goto ldv_34791;
    default: 
#line 506
    __bad_size_call_parameter();
#line 506
    goto ldv_34791;
    }
    ldv_34791: 
#line 506
    printk("\017GRU:%d %s: FAILED inval tfh: 0x%p, vaddr 0x%lx\n", pscr_ret_____5,
           "gru_try_dropin", tfh, vaddr);
  } else {

  }
#line 507
  return (-14);
  failactive: ;
#line 511
  if ((unsigned long )cbk == (unsigned long )((struct gru_instruction_bits *)0)) {
#line 512
    tfh_user_polling_mode(tfh);
  } else {
#line 514
    gru_flush_cache((void *)tfh);
  }
#line 515
  gru_flush_cache_cbe(cbe);
#line 516
  if ((gru_options & 2UL) != 0UL) {
#line 516
    atomic_long_inc(& gru_stats.tlb_dropin_fail_range_active);
  } else {

  }
#line 517
  if ((int )gru_options & 1) {
#line 517
    __vpp_verify___6 = (void const   *)0;
#line 517
    switch (4UL) {
    case 1UL: ;
#line 518
    switch (4UL) {
    case 1UL: 
#line 518
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____27): "m" (cpu_number));
#line 518
    goto ldv_34826;
    case 2UL: 
#line 518
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____27): "m" (cpu_number));
#line 518
    goto ldv_34826;
    case 4UL: 
#line 518
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____27): "m" (cpu_number));
#line 518
    goto ldv_34826;
    case 8UL: 
#line 518
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____27): "m" (cpu_number));
#line 518
    goto ldv_34826;
    default: 
#line 518
    __bad_percpu_size();
    }
    ldv_34826: 
#line 518
    pscr_ret_____6 = pfo_ret_____27;
#line 518
    goto ldv_34832;
    case 2UL: ;
#line 518
    switch (4UL) {
    case 1UL: 
#line 518
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____28): "m" (cpu_number));
#line 518
    goto ldv_34836;
    case 2UL: 
#line 518
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____28): "m" (cpu_number));
#line 518
    goto ldv_34836;
    case 4UL: 
#line 518
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____28): "m" (cpu_number));
#line 518
    goto ldv_34836;
    case 8UL: 
#line 518
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____28): "m" (cpu_number));
#line 518
    goto ldv_34836;
    default: 
#line 518
    __bad_percpu_size();
    }
    ldv_34836: 
#line 518
    pscr_ret_____6 = pfo_ret_____28;
#line 518
    goto ldv_34832;
    case 4UL: ;
#line 518
    switch (4UL) {
    case 1UL: 
#line 518
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____29): "m" (cpu_number));
#line 518
    goto ldv_34845;
    case 2UL: 
#line 518
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____29): "m" (cpu_number));
#line 518
    goto ldv_34845;
    case 4UL: 
#line 518
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____29): "m" (cpu_number));
#line 518
    goto ldv_34845;
    case 8UL: 
#line 518
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____29): "m" (cpu_number));
#line 518
    goto ldv_34845;
    default: 
#line 518
    __bad_percpu_size();
    }
    ldv_34845: 
#line 518
    pscr_ret_____6 = pfo_ret_____29;
#line 518
    goto ldv_34832;
    case 8UL: ;
#line 518
    switch (4UL) {
    case 1UL: 
#line 518
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____30): "m" (cpu_number));
#line 518
    goto ldv_34854;
    case 2UL: 
#line 518
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____30): "m" (cpu_number));
#line 518
    goto ldv_34854;
    case 4UL: 
#line 518
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____30): "m" (cpu_number));
#line 518
    goto ldv_34854;
    case 8UL: 
#line 518
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____30): "m" (cpu_number));
#line 518
    goto ldv_34854;
    default: 
#line 518
    __bad_percpu_size();
    }
    ldv_34854: 
#line 518
    pscr_ret_____6 = pfo_ret_____30;
#line 518
    goto ldv_34832;
    default: 
#line 518
    __bad_size_call_parameter();
#line 518
    goto ldv_34832;
    }
    ldv_34832: 
#line 518
    printk("\017GRU:%d %s: FAILED range active: tfh 0x%p, vaddr 0x%lx\n", pscr_ret_____6,
           "gru_try_dropin", tfh, vaddr);
  } else {

  }
#line 519
  return (1);
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
static irqreturn_t gru_intr(int chiplet , int blade ) 
{ 
  struct gru_state *gru ;
  struct gru_tlb_fault_map imap ;
  struct gru_tlb_fault_map dmap ;
  struct gru_thread_state *gts ;
  struct gru_tlb_fault_handle *tfh ;
  struct completion *cmp ;
  int cbrnum ;
  int ctxnum ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int pscr_ret_____1 ;
  void const   *__vpp_verify___1 ;
  int pfo_ret_____7 ;
  int pfo_ret_____8 ;
  int pfo_ret_____9 ;
  int pfo_ret_____10 ;
  unsigned long tmp ;
  int pscr_ret_____2 ;
  void const   *__vpp_verify___2 ;
  int pfo_ret_____11 ;
  int pfo_ret_____12 ;
  int pfo_ret_____13 ;
  int pfo_ret_____14 ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 533
  tfh = (struct gru_tlb_fault_handle *)0;
#line 537
  if ((gru_options & 2UL) != 0UL) {
#line 537
    atomic_long_inc(& gru_stats.intr);
  } else {

  }
#line 539
  gru = (struct gru_state *)(& (gru_base[blade])->bs_grus) + (unsigned long )chiplet;
#line 540
  if ((unsigned long )gru == (unsigned long )((struct gru_state *)0)) {
#line 542
    __vpp_verify = (void const   *)0;
#line 542
    switch (4UL) {
    case 1UL: ;
#line 542
    switch (4UL) {
    case 1UL: 
#line 542
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 542
    goto ldv_34879;
    case 2UL: 
#line 542
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 542
    goto ldv_34879;
    case 4UL: 
#line 542
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 542
    goto ldv_34879;
    case 8UL: 
#line 542
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 542
    goto ldv_34879;
    default: 
#line 542
    __bad_percpu_size();
    }
    ldv_34879: 
#line 542
    pscr_ret__ = pfo_ret__;
#line 542
    goto ldv_34885;
    case 2UL: ;
#line 542
    switch (4UL) {
    case 1UL: 
#line 542
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 542
    goto ldv_34889;
    case 2UL: 
#line 542
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 542
    goto ldv_34889;
    case 4UL: 
#line 542
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 542
    goto ldv_34889;
    case 8UL: 
#line 542
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 542
    goto ldv_34889;
    default: 
#line 542
    __bad_percpu_size();
    }
    ldv_34889: 
#line 542
    pscr_ret__ = pfo_ret_____0;
#line 542
    goto ldv_34885;
    case 4UL: ;
#line 542
    switch (4UL) {
    case 1UL: 
#line 542
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 542
    goto ldv_34898;
    case 2UL: 
#line 542
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 542
    goto ldv_34898;
    case 4UL: 
#line 542
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 542
    goto ldv_34898;
    case 8UL: 
#line 542
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 542
    goto ldv_34898;
    default: 
#line 542
    __bad_percpu_size();
    }
    ldv_34898: 
#line 542
    pscr_ret__ = pfo_ret_____1;
#line 542
    goto ldv_34885;
    case 8UL: ;
#line 542
    switch (4UL) {
    case 1UL: 
#line 542
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 542
    goto ldv_34907;
    case 2UL: 
#line 542
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 542
    goto ldv_34907;
    case 4UL: 
#line 542
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 542
    goto ldv_34907;
    case 8UL: 
#line 542
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 542
    goto ldv_34907;
    default: 
#line 542
    __bad_percpu_size();
    }
    ldv_34907: 
#line 542
    pscr_ret__ = pfo_ret_____2;
#line 542
    goto ldv_34885;
    default: 
#line 542
    __bad_size_call_parameter();
#line 542
    goto ldv_34885;
    }
    ldv_34885: 
#line 542
    dev_err((struct device  const  *)grudev, "GRU: invalid interrupt: cpu %d, chiplet %d\n",
            pscr_ret__, chiplet);
#line 543
    return (0);
  } else {

  }
#line 545
  get_clear_fault_map(gru, & imap, & dmap);
#line 546
  if ((int )gru_options & 1) {
#line 550
    __vpp_verify___0 = (void const   *)0;
#line 550
    switch (4UL) {
    case 1UL: ;
#line 550
    switch (4UL) {
    case 1UL: 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 550
    goto ldv_34962;
    case 2UL: 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 550
    goto ldv_34962;
    case 4UL: 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 550
    goto ldv_34962;
    case 8UL: 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 550
    goto ldv_34962;
    default: 
#line 550
    __bad_percpu_size();
    }
    ldv_34962: 
#line 550
    pscr_ret_____0 = pfo_ret_____3;
#line 550
    goto ldv_34968;
    case 2UL: ;
#line 550
    switch (4UL) {
    case 1UL: 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 550
    goto ldv_34972;
    case 2UL: 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 550
    goto ldv_34972;
    case 4UL: 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 550
    goto ldv_34972;
    case 8UL: 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 550
    goto ldv_34972;
    default: 
#line 550
    __bad_percpu_size();
    }
    ldv_34972: 
#line 550
    pscr_ret_____0 = pfo_ret_____4;
#line 550
    goto ldv_34968;
    case 4UL: ;
#line 550
    switch (4UL) {
    case 1UL: 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 550
    goto ldv_34981;
    case 2UL: 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 550
    goto ldv_34981;
    case 4UL: 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 550
    goto ldv_34981;
    case 8UL: 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 550
    goto ldv_34981;
    default: 
#line 550
    __bad_percpu_size();
    }
    ldv_34981: 
#line 550
    pscr_ret_____0 = pfo_ret_____5;
#line 550
    goto ldv_34968;
    case 8UL: ;
#line 550
    switch (4UL) {
    case 1UL: 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 550
    goto ldv_34990;
    case 2UL: 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 550
    goto ldv_34990;
    case 4UL: 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 550
    goto ldv_34990;
    case 8UL: 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 550
    goto ldv_34990;
    default: 
#line 550
    __bad_percpu_size();
    }
    ldv_34990: 
#line 550
    pscr_ret_____0 = pfo_ret_____6;
#line 550
    goto ldv_34968;
    default: 
#line 550
    __bad_size_call_parameter();
#line 550
    goto ldv_34968;
    }
    ldv_34968: 
#line 546
    __vpp_verify___1 = (void const   *)0;
#line 546
    switch (4UL) {
    case 1UL: ;
#line 550
    switch (4UL) {
    case 1UL: 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____7): "m" (cpu_number));
#line 550
    goto ldv_34920;
    case 2UL: 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 550
    goto ldv_34920;
    case 4UL: 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 550
    goto ldv_34920;
    case 8UL: 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 550
    goto ldv_34920;
    default: 
#line 550
    __bad_percpu_size();
    }
    ldv_34920: 
#line 550
    pscr_ret_____1 = pfo_ret_____7;
#line 550
    goto ldv_34926;
    case 2UL: ;
#line 550
    switch (4UL) {
    case 1UL: 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____8): "m" (cpu_number));
#line 550
    goto ldv_34930;
    case 2UL: 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 550
    goto ldv_34930;
    case 4UL: 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 550
    goto ldv_34930;
    case 8UL: 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 550
    goto ldv_34930;
    default: 
#line 550
    __bad_percpu_size();
    }
    ldv_34930: 
#line 550
    pscr_ret_____1 = pfo_ret_____8;
#line 550
    goto ldv_34926;
    case 4UL: ;
#line 550
    switch (4UL) {
    case 1UL: 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____9): "m" (cpu_number));
#line 550
    goto ldv_34939;
    case 2UL: 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 550
    goto ldv_34939;
    case 4UL: 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 550
    goto ldv_34939;
    case 8UL: 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 550
    goto ldv_34939;
    default: 
#line 550
    __bad_percpu_size();
    }
    ldv_34939: 
#line 550
    pscr_ret_____1 = pfo_ret_____9;
#line 550
    goto ldv_34926;
    case 8UL: ;
#line 550
    switch (4UL) {
    case 1UL: 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____10): "m" (cpu_number));
#line 550
    goto ldv_34948;
    case 2UL: 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 550
    goto ldv_34948;
    case 4UL: 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 550
    goto ldv_34948;
    case 8UL: 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 550
    goto ldv_34948;
    default: 
#line 550
    __bad_percpu_size();
    }
    ldv_34948: 
#line 550
    pscr_ret_____1 = pfo_ret_____10;
#line 550
    goto ldv_34926;
    default: 
#line 550
    __bad_size_call_parameter();
#line 550
    goto ldv_34926;
    }
    ldv_34926: 
#line 550
    printk("\017GRU:%d %s: cpu %d, chiplet %d, gid %d, imap %016lx %016lx, dmap %016lx %016lx\n",
           pscr_ret_____1, "gru_intr", pscr_ret_____0, chiplet, (int )gru->gs_gid,
           imap.fault_bits[0], imap.fault_bits[1], dmap.fault_bits[0], dmap.fault_bits[1]);
  } else {

  }
#line 552
  tmp = find_first_bit((unsigned long const   *)(& dmap.fault_bits), 128UL);
#line 552
  cbrnum = (int )tmp;
#line 552
  goto ldv_35040;
  ldv_35039: ;
#line 553
  if ((gru_options & 2UL) != 0UL) {
#line 553
    atomic_long_inc(& gru_stats.intr_cbr);
  } else {

  }
#line 554
  cmp = (gru->gs_blade)->bs_async_wq;
#line 555
  if ((unsigned long )cmp != (unsigned long )((struct completion *)0)) {
#line 556
    complete(cmp);
  } else {

  }
#line 557
  if ((int )gru_options & 1) {
#line 557
    __vpp_verify___2 = (void const   *)0;
#line 557
    switch (4UL) {
    case 1UL: ;
#line 558
    switch (4UL) {
    case 1UL: 
#line 558
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____11): "m" (cpu_number));
#line 558
    goto ldv_35003;
    case 2UL: 
#line 558
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 558
    goto ldv_35003;
    case 4UL: 
#line 558
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 558
    goto ldv_35003;
    case 8UL: 
#line 558
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 558
    goto ldv_35003;
    default: 
#line 558
    __bad_percpu_size();
    }
    ldv_35003: 
#line 558
    pscr_ret_____2 = pfo_ret_____11;
#line 558
    goto ldv_35009;
    case 2UL: ;
#line 558
    switch (4UL) {
    case 1UL: 
#line 558
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____12): "m" (cpu_number));
#line 558
    goto ldv_35013;
    case 2UL: 
#line 558
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 558
    goto ldv_35013;
    case 4UL: 
#line 558
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 558
    goto ldv_35013;
    case 8UL: 
#line 558
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 558
    goto ldv_35013;
    default: 
#line 558
    __bad_percpu_size();
    }
    ldv_35013: 
#line 558
    pscr_ret_____2 = pfo_ret_____12;
#line 558
    goto ldv_35009;
    case 4UL: ;
#line 558
    switch (4UL) {
    case 1UL: 
#line 558
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____13): "m" (cpu_number));
#line 558
    goto ldv_35022;
    case 2UL: 
#line 558
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 558
    goto ldv_35022;
    case 4UL: 
#line 558
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 558
    goto ldv_35022;
    case 8UL: 
#line 558
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 558
    goto ldv_35022;
    default: 
#line 558
    __bad_percpu_size();
    }
    ldv_35022: 
#line 558
    pscr_ret_____2 = pfo_ret_____13;
#line 558
    goto ldv_35009;
    case 8UL: ;
#line 558
    switch (4UL) {
    case 1UL: 
#line 558
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____14): "m" (cpu_number));
#line 558
    goto ldv_35031;
    case 2UL: 
#line 558
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 558
    goto ldv_35031;
    case 4UL: 
#line 558
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 558
    goto ldv_35031;
    case 8UL: 
#line 558
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 558
    goto ldv_35031;
    default: 
#line 558
    __bad_percpu_size();
    }
    ldv_35031: 
#line 558
    pscr_ret_____2 = pfo_ret_____14;
#line 558
    goto ldv_35009;
    default: 
#line 558
    __bad_size_call_parameter();
#line 558
    goto ldv_35009;
    }
    ldv_35009: 
#line 558
    printk("\017GRU:%d %s: gid %d, cbr_done %d, done %d\n", pscr_ret_____2, "gru_intr",
           (int )gru->gs_gid, cbrnum, (unsigned long )cmp != (unsigned long )((struct completion *)0) ? cmp->done : 4294967295U);
  } else {

  }
#line 552
  tmp___0 = find_next_bit((unsigned long const   *)(& dmap.fault_bits), 128UL, (unsigned long )(cbrnum + 1));
#line 552
  cbrnum = (int )tmp___0;
  ldv_35040: ;
#line 552
  if (cbrnum <= 127) {
#line 554
    goto ldv_35039;
  } else {

  }
#line 561
  tmp___1 = find_first_bit((unsigned long const   *)(& imap.fault_bits), 128UL);
#line 561
  cbrnum = (int )tmp___1;
#line 561
  goto ldv_35044;
  ldv_35043: ;
#line 562
  if ((gru_options & 2UL) != 0UL) {
#line 562
    atomic_long_inc(& gru_stats.intr_tfh);
  } else {

  }
#line 563
  tfh = get_tfh(gru->gs_gru_base_vaddr, cbrnum);
#line 564
  prefetchw((void const   *)tfh);
#line 572
  ctxnum = (int )tfh->ctxnum;
#line 573
  gts = gru->gs_gts[ctxnum];
#line 576
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
#line 577
    if ((gru_options & 2UL) != 0UL) {
#line 577
      atomic_long_inc(& gru_stats.intr_spurious);
    } else {

    }
#line 578
    goto ldv_35042;
  } else {

  }
#line 585
  gts->ustats.fmm_tlbmiss = gts->ustats.fmm_tlbmiss + 1UL;
#line 586
  if ((int )((signed char )gts->ts_force_cch_reload) == 0) {
#line 586
    tmp___2 = down_read_trylock(& (gts->ts_mm)->mmap_sem);
#line 586
    if (tmp___2 != 0) {
#line 588
      gru_try_dropin(gru, gts, tfh, (struct gru_instruction_bits *)0);
#line 589
      up_read(& (gts->ts_mm)->mmap_sem);
    } else {
#line 586
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 591
    tfh_user_polling_mode(tfh);
#line 592
    if ((gru_options & 2UL) != 0UL) {
#line 592
      atomic_long_inc(& gru_stats.intr_mm_lock_failed);
    } else {

    }
  }
  ldv_35042: 
#line 561
  tmp___3 = find_next_bit((unsigned long const   *)(& imap.fault_bits), 128UL, (unsigned long )(cbrnum + 1));
#line 561
  cbrnum = (int )tmp___3;
  ldv_35044: ;
#line 561
  if (cbrnum <= 127) {
#line 563
    goto ldv_35043;
  } else {

  }

#line 595
  return (1);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
irqreturn_t gru0_intr(int irq , void *dev_id ) 
{ 
  int tmp ;
  irqreturn_t tmp___0 ;

  {
#line 600
  tmp = uv_numa_blade_id();
#line 600
  tmp___0 = gru_intr(0, tmp);
#line 600
  return (tmp___0);
}
}
#line 603 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
irqreturn_t gru1_intr(int irq , void *dev_id ) 
{ 
  int tmp ;
  irqreturn_t tmp___0 ;

  {
#line 605
  tmp = uv_numa_blade_id();
#line 605
  tmp___0 = gru_intr(1, tmp);
#line 605
  return (tmp___0);
}
}
#line 608 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
irqreturn_t gru_intr_mblade(int irq , void *dev_id ) 
{ 
  int blade ;
  int tmp ;
  int tmp___0 ;

  {
#line 612
  blade = 0;
#line 612
  goto ldv_35061;
  ldv_35060: 
#line 613
  tmp = uv_blade_nr_possible_cpus(blade);
#line 613
  if (tmp != 0) {
#line 614
    goto ldv_35059;
  } else {

  }
#line 615
  gru_intr(0, blade);
#line 616
  gru_intr(1, blade);
  ldv_35059: 
#line 612
  blade = blade + 1;
  ldv_35061: 
#line 612
  tmp___0 = uv_num_possible_blades();
#line 612
  if (tmp___0 > blade) {
#line 614
    goto ldv_35060;
  } else {

  }

#line 618
  return (1);
}
}
#line 622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
static int gru_user_dropin(struct gru_thread_state *gts , struct gru_tlb_fault_handle *tfh ,
                           void *cb ) 
{ 
  struct gru_mm_struct *gms ;
  int ret ;
  int tmp ;
  wait_queue_t __wait ;
  long __ret ;
  long __int ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 626
  gms = gts->ts_gms;
#line 629
  gts->ustats.upm_tlbmiss = gts->ustats.upm_tlbmiss + 1UL;
  ldv_35078: 
#line 631
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c",
                632, 0);
#line 631
  tmp = atomic_read((atomic_t const   *)(& gms->ms_range_active));
#line 631
  if (tmp == 0) {
#line 631
    goto ldv_35070;
  } else {

  }
#line 631
  __ret = 0L;
#line 631
  INIT_LIST_HEAD(& __wait.task_list);
#line 631
  __wait.flags = 0U;
  ldv_35076: 
#line 631
  tmp___0 = prepare_to_wait_event(& gms->ms_wait_queue, & __wait, 2);
#line 631
  __int = tmp___0;
#line 631
  tmp___1 = atomic_read((atomic_t const   *)(& gms->ms_range_active));
#line 631
  if (tmp___1 == 0) {
#line 631
    goto ldv_35075;
  } else {

  }
#line 631
  schedule();
#line 631
  goto ldv_35076;
  ldv_35075: 
#line 631
  finish_wait(& gms->ms_wait_queue, & __wait);

  ldv_35070: 
#line 633
  prefetchw((void const   *)tfh);
#line 634
  ret = gru_try_dropin(gts->ts_gru, gts, tfh, (struct gru_instruction_bits *)cb);
#line 635
  if (ret <= 0) {
#line 636
    return (ret);
  } else {

  }
#line 637
  if ((gru_options & 2UL) != 0UL) {
#line 637
    atomic_long_inc(& gru_stats.call_os_wait_queue);
  } else {

  }
#line 638
  goto ldv_35078;
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
int gru_handle_user_call_os(unsigned long cb ) 
{ 
  struct gru_tlb_fault_handle *tfh ;
  struct gru_thread_state *gts ;
  void *cbk ;
  int ucbnum ;
  int cbrnum ;
  int ret ;
  unsigned long tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 651
  ret = -22;
#line 653
  if ((gru_options & 2UL) != 0UL) {
#line 653
    atomic_long_inc(& gru_stats.call_os);
  } else {

  }
#line 656
  tmp = get_cb_number((void *)cb);
#line 656
  ucbnum = (int )tmp;
#line 657
  if ((cb & 255UL) != 0UL || ucbnum > 127) {
#line 658
    return (-22);
  } else {

  }
#line 660
  gts = gru_find_lock_gts(cb);
#line 661
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
#line 662
    return (-22);
  } else {

  }
#line 663
  if ((int )gru_options & 1) {
#line 663
    __vpp_verify = (void const   *)0;
#line 663
    switch (4UL) {
    case 1UL: ;
#line 663
    switch (4UL) {
    case 1UL: 
#line 663
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 663
    goto ldv_35093;
    case 2UL: 
#line 663
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 663
    goto ldv_35093;
    case 4UL: 
#line 663
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 663
    goto ldv_35093;
    case 8UL: 
#line 663
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 663
    goto ldv_35093;
    default: 
#line 663
    __bad_percpu_size();
    }
    ldv_35093: 
#line 663
    pscr_ret__ = pfo_ret__;
#line 663
    goto ldv_35099;
    case 2UL: ;
#line 663
    switch (4UL) {
    case 1UL: 
#line 663
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 663
    goto ldv_35103;
    case 2UL: 
#line 663
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 663
    goto ldv_35103;
    case 4UL: 
#line 663
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 663
    goto ldv_35103;
    case 8UL: 
#line 663
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 663
    goto ldv_35103;
    default: 
#line 663
    __bad_percpu_size();
    }
    ldv_35103: 
#line 663
    pscr_ret__ = pfo_ret_____0;
#line 663
    goto ldv_35099;
    case 4UL: ;
#line 663
    switch (4UL) {
    case 1UL: 
#line 663
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 663
    goto ldv_35112;
    case 2UL: 
#line 663
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 663
    goto ldv_35112;
    case 4UL: 
#line 663
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 663
    goto ldv_35112;
    case 8UL: 
#line 663
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 663
    goto ldv_35112;
    default: 
#line 663
    __bad_percpu_size();
    }
    ldv_35112: 
#line 663
    pscr_ret__ = pfo_ret_____1;
#line 663
    goto ldv_35099;
    case 8UL: ;
#line 663
    switch (4UL) {
    case 1UL: 
#line 663
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 663
    goto ldv_35121;
    case 2UL: 
#line 663
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 663
    goto ldv_35121;
    case 4UL: 
#line 663
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 663
    goto ldv_35121;
    case 8UL: 
#line 663
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 663
    goto ldv_35121;
    default: 
#line 663
    __bad_percpu_size();
    }
    ldv_35121: 
#line 663
    pscr_ret__ = pfo_ret_____2;
#line 663
    goto ldv_35099;
    default: 
#line 663
    __bad_size_call_parameter();
#line 663
    goto ldv_35099;
    }
    ldv_35099: 
#line 663
    printk("\017GRU:%d %s: address 0x%lx, gid %d, gts 0x%p\n", pscr_ret__, "gru_handle_user_call_os",
           cb, (unsigned long )gts->ts_gru != (unsigned long )((struct gru_state *)0) ? (int )(gts->ts_gru)->gs_gid : -1,
           gts);
  } else {

  }
#line 665
  if ((int )gts->ts_cbr_au_count * 2 <= ucbnum) {
#line 666
    goto exit;
  } else {

  }
#line 668
  gru_check_context_placement(gts);
#line 673
  if ((unsigned long )gts->ts_gru != (unsigned long )((struct gru_state *)0) && (int )((signed char )gts->ts_force_cch_reload) != 0) {
#line 674
    gts->ts_force_cch_reload = 0;
#line 675
    gru_update_cch(gts);
  } else {

  }
#line 678
  ret = -11;
#line 679
  cbrnum = (int )gts->ts_cbr_idx[ucbnum / 2] * 2 + ucbnum % 2;
#line 680
  if ((unsigned long )gts->ts_gru != (unsigned long )((struct gru_state *)0)) {
#line 681
    tfh = get_tfh((gts->ts_gru)->gs_gru_base_vaddr, cbrnum);
#line 682
    cbk = get_gseg_base_address_cb((gts->ts_gru)->gs_gru_base_vaddr, gts->ts_ctxnum,
                                   ucbnum);
#line 684
    ret = gru_user_dropin(gts, tfh, cbk);
  } else {

  }
  exit: 
#line 687
  gru_unlock_gts(gts);
#line 688
  return (ret);
}
}
#line 695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
int gru_get_exception_detail(unsigned long arg ) 
{ 
  struct control_block_extended_exc_detail excdet ;
  struct gru_control_block_extended *cbe ;
  struct gru_thread_state *gts ;
  int ucbnum ;
  int cbrnum ;
  int ret ;
  unsigned long tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  unsigned long tmp___0 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  unsigned long tmp___1 ;

  {
#line 702
  if ((gru_options & 2UL) != 0UL) {
#line 702
    atomic_long_inc(& gru_stats.user_exception);
  } else {

  }
#line 703
  tmp = copy_from_user((void *)(& excdet), (void const   *)arg, 48UL);
#line 703
  if (tmp != 0UL) {
#line 704
    return (-14);
  } else {

  }
#line 706
  gts = gru_find_lock_gts(excdet.cb);
#line 707
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
#line 708
    return (-22);
  } else {

  }
#line 710
  if ((int )gru_options & 1) {
#line 710
    __vpp_verify = (void const   *)0;
#line 710
    switch (4UL) {
    case 1UL: ;
#line 710
    switch (4UL) {
    case 1UL: 
#line 710
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 710
    goto ldv_35145;
    case 2UL: 
#line 710
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 710
    goto ldv_35145;
    case 4UL: 
#line 710
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 710
    goto ldv_35145;
    case 8UL: 
#line 710
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 710
    goto ldv_35145;
    default: 
#line 710
    __bad_percpu_size();
    }
    ldv_35145: 
#line 710
    pscr_ret__ = pfo_ret__;
#line 710
    goto ldv_35151;
    case 2UL: ;
#line 710
    switch (4UL) {
    case 1UL: 
#line 710
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 710
    goto ldv_35155;
    case 2UL: 
#line 710
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 710
    goto ldv_35155;
    case 4UL: 
#line 710
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 710
    goto ldv_35155;
    case 8UL: 
#line 710
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 710
    goto ldv_35155;
    default: 
#line 710
    __bad_percpu_size();
    }
    ldv_35155: 
#line 710
    pscr_ret__ = pfo_ret_____0;
#line 710
    goto ldv_35151;
    case 4UL: ;
#line 710
    switch (4UL) {
    case 1UL: 
#line 710
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 710
    goto ldv_35164;
    case 2UL: 
#line 710
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 710
    goto ldv_35164;
    case 4UL: 
#line 710
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 710
    goto ldv_35164;
    case 8UL: 
#line 710
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 710
    goto ldv_35164;
    default: 
#line 710
    __bad_percpu_size();
    }
    ldv_35164: 
#line 710
    pscr_ret__ = pfo_ret_____1;
#line 710
    goto ldv_35151;
    case 8UL: ;
#line 710
    switch (4UL) {
    case 1UL: 
#line 710
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 710
    goto ldv_35173;
    case 2UL: 
#line 710
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 710
    goto ldv_35173;
    case 4UL: 
#line 710
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 710
    goto ldv_35173;
    case 8UL: 
#line 710
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 710
    goto ldv_35173;
    default: 
#line 710
    __bad_percpu_size();
    }
    ldv_35173: 
#line 710
    pscr_ret__ = pfo_ret_____2;
#line 710
    goto ldv_35151;
    default: 
#line 710
    __bad_size_call_parameter();
#line 710
    goto ldv_35151;
    }
    ldv_35151: 
#line 710
    printk("\017GRU:%d %s: address 0x%lx, gid %d, gts 0x%p\n", pscr_ret__, "gru_get_exception_detail",
           excdet.cb, (unsigned long )gts->ts_gru != (unsigned long )((struct gru_state *)0) ? (int )(gts->ts_gru)->gs_gid : -1,
           gts);
  } else {

  }
#line 711
  tmp___0 = get_cb_number((void *)excdet.cb);
#line 711
  ucbnum = (int )tmp___0;
#line 712
  if ((int )gts->ts_cbr_au_count * 2 <= ucbnum) {
#line 713
    ret = -22;
  } else
#line 714
  if ((unsigned long )gts->ts_gru != (unsigned long )((struct gru_state *)0)) {
#line 715
    cbrnum = (int )gts->ts_cbr_idx[ucbnum / 2] * 2 + ucbnum % 2;
#line 716
    cbe = get_cbe((gts->ts_gru)->gs_gru_base_vaddr, cbrnum);
#line 717
    gru_flush_cache((void *)cbe);
#line 718
    sync_core();
#line 719
    excdet.opc = (int )cbe->opccpy;
#line 720
    excdet.exopc = (int )cbe->exopccpy;
#line 721
    excdet.ecause = (int )cbe->ecause;
#line 722
    excdet.exceptdet0 = (long )cbe->idef1upd;
#line 723
    excdet.exceptdet1 = (int )cbe->idef3upd;
#line 724
    excdet.cbrstate = (int )cbe->cbrstate;
#line 725
    excdet.cbrexecstatus = (int )cbe->cbrexecstatus;
#line 726
    gru_flush_cache_cbe(cbe);
#line 727
    ret = 0;
  } else {
#line 729
    ret = -11;
  }
#line 731
  gru_unlock_gts(gts);
#line 733
  if ((int )gru_options & 1) {
#line 733
    __vpp_verify___0 = (void const   *)0;
#line 733
    switch (4UL) {
    case 1UL: ;
#line 737
    switch (4UL) {
    case 1UL: 
#line 737
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 737
    goto ldv_35187;
    case 2UL: 
#line 737
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 737
    goto ldv_35187;
    case 4UL: 
#line 737
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 737
    goto ldv_35187;
    case 8UL: 
#line 737
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 737
    goto ldv_35187;
    default: 
#line 737
    __bad_percpu_size();
    }
    ldv_35187: 
#line 737
    pscr_ret_____0 = pfo_ret_____3;
#line 737
    goto ldv_35193;
    case 2UL: ;
#line 737
    switch (4UL) {
    case 1UL: 
#line 737
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 737
    goto ldv_35197;
    case 2UL: 
#line 737
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 737
    goto ldv_35197;
    case 4UL: 
#line 737
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 737
    goto ldv_35197;
    case 8UL: 
#line 737
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 737
    goto ldv_35197;
    default: 
#line 737
    __bad_percpu_size();
    }
    ldv_35197: 
#line 737
    pscr_ret_____0 = pfo_ret_____4;
#line 737
    goto ldv_35193;
    case 4UL: ;
#line 737
    switch (4UL) {
    case 1UL: 
#line 737
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 737
    goto ldv_35206;
    case 2UL: 
#line 737
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 737
    goto ldv_35206;
    case 4UL: 
#line 737
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 737
    goto ldv_35206;
    case 8UL: 
#line 737
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 737
    goto ldv_35206;
    default: 
#line 737
    __bad_percpu_size();
    }
    ldv_35206: 
#line 737
    pscr_ret_____0 = pfo_ret_____5;
#line 737
    goto ldv_35193;
    case 8UL: ;
#line 737
    switch (4UL) {
    case 1UL: 
#line 737
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 737
    goto ldv_35215;
    case 2UL: 
#line 737
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 737
    goto ldv_35215;
    case 4UL: 
#line 737
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 737
    goto ldv_35215;
    case 8UL: 
#line 737
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 737
    goto ldv_35215;
    default: 
#line 737
    __bad_percpu_size();
    }
    ldv_35215: 
#line 737
    pscr_ret_____0 = pfo_ret_____6;
#line 737
    goto ldv_35193;
    default: 
#line 737
    __bad_size_call_parameter();
#line 737
    goto ldv_35193;
    }
    ldv_35193: 
#line 737
    printk("\017GRU:%d %s: cb 0x%lx, op %d, exopc %d, cbrstate %d, cbrexecstatus 0x%x, ecause 0x%x, exdet0 0x%lx, exdet1 0x%x\n",
           pscr_ret_____0, "gru_get_exception_detail", excdet.cb, excdet.opc, excdet.exopc,
           excdet.cbrstate, excdet.cbrexecstatus, excdet.ecause, excdet.exceptdet0,
           excdet.exceptdet1);
  } else {

  }
#line 738
  if (ret == 0) {
#line 738
    tmp___1 = copy_to_user((void *)arg, (void const   *)(& excdet), 48UL);
#line 738
    if (tmp___1 != 0UL) {
#line 739
      ret = -14;
    } else {

    }
  } else {

  }
#line 740
  return (ret);
}
}
#line 746 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
static int gru_unload_all_contexts(void) 
{ 
  struct gru_thread_state *gts ;
  struct gru_state *gru ;
  int gid ;
  int ctxnum ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 752
  tmp = capable(21);
#line 752
  if (tmp) {
#line 752
    tmp___0 = 0;
  } else {
#line 752
    tmp___0 = 1;
  }
#line 752
  if (tmp___0) {
#line 753
    return (-1);
  } else {

  }
#line 754
  gid = 0;
#line 754
  goto ldv_35234;
  ldv_35233: 
#line 755
  gru = (unsigned long )gru_base[gid / 2] != (unsigned long )((struct gru_blade_state *)0) ? (struct gru_state *)(& (gru_base[gid / 2])->bs_grus) + (unsigned long )(gid % 2) : (struct gru_state *)0;
#line 756
  spin_lock(& gru->gs_lock);
#line 757
  ctxnum = 0;
#line 757
  goto ldv_35231;
  ldv_35230: 
#line 758
  gts = gru->gs_gts[ctxnum];
#line 759
  if ((unsigned long )gts != (unsigned long )((struct gru_thread_state *)0)) {
#line 759
    tmp___1 = ldv_mutex_trylock_71(& gts->ts_ctxlock);
#line 759
    if (tmp___1 != 0) {
#line 760
      spin_unlock(& gru->gs_lock);
#line 761
      gru_unload_context(gts, 1);
#line 762
      ldv_mutex_unlock_72(& gts->ts_ctxlock);
#line 763
      spin_lock(& gru->gs_lock);
    } else {

    }
  } else {

  }
#line 757
  ctxnum = ctxnum + 1;
  ldv_35231: ;
#line 757
  if (ctxnum <= 15) {
#line 759
    goto ldv_35230;
  } else {

  }
#line 766
  spin_unlock(& gru->gs_lock);
#line 754
  gid = gid + 1;
  ldv_35234: ;
#line 754
  if ((unsigned int )gid < gru_max_gids) {
#line 756
    goto ldv_35233;
  } else {

  }

#line 768
  return (0);
}
}
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
int gru_user_unload_context(unsigned long arg ) 
{ 
  struct gru_thread_state *gts ;
  struct gru_unload_context_req req ;
  unsigned long tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___0 ;

  {
#line 776
  if ((gru_options & 2UL) != 0UL) {
#line 776
    atomic_long_inc(& gru_stats.user_unload_context);
  } else {

  }
#line 777
  tmp = copy_from_user((void *)(& req), (void const   *)arg, 8UL);
#line 777
  if (tmp != 0UL) {
#line 778
    return (-14);
  } else {

  }
#line 780
  if ((int )gru_options & 1) {
#line 780
    __vpp_verify = (void const   *)0;
#line 780
    switch (4UL) {
    case 1UL: ;
#line 780
    switch (4UL) {
    case 1UL: 
#line 780
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 780
    goto ldv_35246;
    case 2UL: 
#line 780
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 780
    goto ldv_35246;
    case 4UL: 
#line 780
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 780
    goto ldv_35246;
    case 8UL: 
#line 780
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 780
    goto ldv_35246;
    default: 
#line 780
    __bad_percpu_size();
    }
    ldv_35246: 
#line 780
    pscr_ret__ = pfo_ret__;
#line 780
    goto ldv_35252;
    case 2UL: ;
#line 780
    switch (4UL) {
    case 1UL: 
#line 780
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 780
    goto ldv_35256;
    case 2UL: 
#line 780
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 780
    goto ldv_35256;
    case 4UL: 
#line 780
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 780
    goto ldv_35256;
    case 8UL: 
#line 780
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 780
    goto ldv_35256;
    default: 
#line 780
    __bad_percpu_size();
    }
    ldv_35256: 
#line 780
    pscr_ret__ = pfo_ret_____0;
#line 780
    goto ldv_35252;
    case 4UL: ;
#line 780
    switch (4UL) {
    case 1UL: 
#line 780
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 780
    goto ldv_35265;
    case 2UL: 
#line 780
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 780
    goto ldv_35265;
    case 4UL: 
#line 780
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 780
    goto ldv_35265;
    case 8UL: 
#line 780
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 780
    goto ldv_35265;
    default: 
#line 780
    __bad_percpu_size();
    }
    ldv_35265: 
#line 780
    pscr_ret__ = pfo_ret_____1;
#line 780
    goto ldv_35252;
    case 8UL: ;
#line 780
    switch (4UL) {
    case 1UL: 
#line 780
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 780
    goto ldv_35274;
    case 2UL: 
#line 780
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 780
    goto ldv_35274;
    case 4UL: 
#line 780
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 780
    goto ldv_35274;
    case 8UL: 
#line 780
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 780
    goto ldv_35274;
    default: 
#line 780
    __bad_percpu_size();
    }
    ldv_35274: 
#line 780
    pscr_ret__ = pfo_ret_____2;
#line 780
    goto ldv_35252;
    default: 
#line 780
    __bad_size_call_parameter();
#line 780
    goto ldv_35252;
    }
    ldv_35252: 
#line 780
    printk("\017GRU:%d %s: gseg 0x%lx\n", pscr_ret__, "gru_user_unload_context", req.gseg);
  } else {

  }
#line 782
  if (req.gseg == 0UL) {
#line 783
    tmp___0 = gru_unload_all_contexts();
#line 783
    return (tmp___0);
  } else {

  }
#line 785
  gts = gru_find_lock_gts(req.gseg);
#line 786
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
#line 787
    return (-22);
  } else {

  }
#line 789
  if ((unsigned long )gts->ts_gru != (unsigned long )((struct gru_state *)0)) {
#line 790
    gru_unload_context(gts, 1);
  } else {

  }
#line 791
  gru_unlock_gts(gts);
#line 793
  return (0);
}
}
#line 800 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
int gru_user_flush_tlb(unsigned long arg ) 
{ 
  struct gru_thread_state *gts ;
  struct gru_flush_tlb_req req ;
  struct gru_mm_struct *gms ;
  unsigned long tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 806
  if ((gru_options & 2UL) != 0UL) {
#line 806
    atomic_long_inc(& gru_stats.user_flush_tlb);
  } else {

  }
#line 807
  tmp = copy_from_user((void *)(& req), (void const   *)arg, 24UL);
#line 807
  if (tmp != 0UL) {
#line 808
    return (-14);
  } else {

  }
#line 810
  if ((int )gru_options & 1) {
#line 810
    __vpp_verify = (void const   *)0;
#line 810
    switch (4UL) {
    case 1UL: ;
#line 811
    switch (4UL) {
    case 1UL: 
#line 811
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 811
    goto ldv_35294;
    case 2UL: 
#line 811
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 811
    goto ldv_35294;
    case 4UL: 
#line 811
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 811
    goto ldv_35294;
    case 8UL: 
#line 811
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 811
    goto ldv_35294;
    default: 
#line 811
    __bad_percpu_size();
    }
    ldv_35294: 
#line 811
    pscr_ret__ = pfo_ret__;
#line 811
    goto ldv_35300;
    case 2UL: ;
#line 811
    switch (4UL) {
    case 1UL: 
#line 811
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 811
    goto ldv_35304;
    case 2UL: 
#line 811
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 811
    goto ldv_35304;
    case 4UL: 
#line 811
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 811
    goto ldv_35304;
    case 8UL: 
#line 811
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 811
    goto ldv_35304;
    default: 
#line 811
    __bad_percpu_size();
    }
    ldv_35304: 
#line 811
    pscr_ret__ = pfo_ret_____0;
#line 811
    goto ldv_35300;
    case 4UL: ;
#line 811
    switch (4UL) {
    case 1UL: 
#line 811
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 811
    goto ldv_35313;
    case 2UL: 
#line 811
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 811
    goto ldv_35313;
    case 4UL: 
#line 811
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 811
    goto ldv_35313;
    case 8UL: 
#line 811
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 811
    goto ldv_35313;
    default: 
#line 811
    __bad_percpu_size();
    }
    ldv_35313: 
#line 811
    pscr_ret__ = pfo_ret_____1;
#line 811
    goto ldv_35300;
    case 8UL: ;
#line 811
    switch (4UL) {
    case 1UL: 
#line 811
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 811
    goto ldv_35322;
    case 2UL: 
#line 811
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 811
    goto ldv_35322;
    case 4UL: 
#line 811
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 811
    goto ldv_35322;
    case 8UL: 
#line 811
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 811
    goto ldv_35322;
    default: 
#line 811
    __bad_percpu_size();
    }
    ldv_35322: 
#line 811
    pscr_ret__ = pfo_ret_____2;
#line 811
    goto ldv_35300;
    default: 
#line 811
    __bad_size_call_parameter();
#line 811
    goto ldv_35300;
    }
    ldv_35300: 
#line 811
    printk("\017GRU:%d %s: gseg 0x%lx, vaddr 0x%lx, len 0x%lx\n", pscr_ret__, "gru_user_flush_tlb",
           req.gseg, req.vaddr, req.len);
  } else {

  }
#line 813
  gts = gru_find_lock_gts(req.gseg);
#line 814
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
#line 815
    return (-22);
  } else {

  }
#line 817
  gms = gts->ts_gms;
#line 818
  gru_unlock_gts(gts);
#line 819
  gru_flush_tlb_range(gms, req.vaddr, req.len);
#line 821
  return (0);
}
}
#line 827 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
long gru_get_gseg_statistics(unsigned long arg ) 
{ 
  struct gru_thread_state *gts ;
  struct gru_get_gseg_statistics_req req ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 832
  tmp = copy_from_user((void *)(& req), (void const   *)arg, 120UL);
#line 832
  if (tmp != 0UL) {
#line 833
    return (-14L);
  } else {

  }
#line 840
  gts = gru_find_lock_gts(req.gseg);
#line 841
  if ((unsigned long )gts != (unsigned long )((struct gru_thread_state *)0)) {
#line 842
    memcpy((void *)(& req.stats), (void const   *)(& gts->ustats), 112UL);
#line 843
    gru_unlock_gts(gts);
  } else {
#line 845
    memset((void *)(& req.stats), 0, 112UL);
  }
#line 848
  tmp___0 = copy_to_user((void *)arg, (void const   *)(& req), 120UL);
#line 848
  if (tmp___0 != 0UL) {
#line 849
    return (-14L);
  } else {

  }
#line 851
  return (0L);
}
}
#line 858 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.c"
int gru_set_context_option(unsigned long arg ) 
{ 
  struct gru_thread_state *gts ;
  struct gru_set_context_option_req req ;
  int ret ;
  unsigned long tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  long tmp___0 ;
  bool tmp___1 ;
  struct task_struct *tmp___2 ;

  {
#line 862
  ret = 0;
#line 864
  if ((gru_options & 2UL) != 0UL) {
#line 864
    atomic_long_inc(& gru_stats.set_context_option);
  } else {

  }
#line 865
  tmp = copy_from_user((void *)(& req), (void const   *)arg, 24UL);
#line 865
  if (tmp != 0UL) {
#line 866
    return (-14);
  } else {

  }
#line 867
  if ((int )gru_options & 1) {
#line 867
    __vpp_verify = (void const   *)0;
#line 867
    switch (4UL) {
    case 1UL: ;
#line 867
    switch (4UL) {
    case 1UL: 
#line 867
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 867
    goto ldv_35347;
    case 2UL: 
#line 867
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 867
    goto ldv_35347;
    case 4UL: 
#line 867
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 867
    goto ldv_35347;
    case 8UL: 
#line 867
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 867
    goto ldv_35347;
    default: 
#line 867
    __bad_percpu_size();
    }
    ldv_35347: 
#line 867
    pscr_ret__ = pfo_ret__;
#line 867
    goto ldv_35353;
    case 2UL: ;
#line 867
    switch (4UL) {
    case 1UL: 
#line 867
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 867
    goto ldv_35357;
    case 2UL: 
#line 867
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 867
    goto ldv_35357;
    case 4UL: 
#line 867
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 867
    goto ldv_35357;
    case 8UL: 
#line 867
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 867
    goto ldv_35357;
    default: 
#line 867
    __bad_percpu_size();
    }
    ldv_35357: 
#line 867
    pscr_ret__ = pfo_ret_____0;
#line 867
    goto ldv_35353;
    case 4UL: ;
#line 867
    switch (4UL) {
    case 1UL: 
#line 867
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 867
    goto ldv_35366;
    case 2UL: 
#line 867
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 867
    goto ldv_35366;
    case 4UL: 
#line 867
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 867
    goto ldv_35366;
    case 8UL: 
#line 867
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 867
    goto ldv_35366;
    default: 
#line 867
    __bad_percpu_size();
    }
    ldv_35366: 
#line 867
    pscr_ret__ = pfo_ret_____1;
#line 867
    goto ldv_35353;
    case 8UL: ;
#line 867
    switch (4UL) {
    case 1UL: 
#line 867
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 867
    goto ldv_35375;
    case 2UL: 
#line 867
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 867
    goto ldv_35375;
    case 4UL: 
#line 867
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 867
    goto ldv_35375;
    case 8UL: 
#line 867
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 867
    goto ldv_35375;
    default: 
#line 867
    __bad_percpu_size();
    }
    ldv_35375: 
#line 867
    pscr_ret__ = pfo_ret_____2;
#line 867
    goto ldv_35353;
    default: 
#line 867
    __bad_size_call_parameter();
#line 867
    goto ldv_35353;
    }
    ldv_35353: 
#line 867
    printk("\017GRU:%d %s: op %d, gseg 0x%lx, value1 0x%lx\n", pscr_ret__, "gru_set_context_option",
           req.op, req.gseg, req.val1);
  } else {

  }
#line 869
  gts = gru_find_lock_gts(req.gseg);
#line 870
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
#line 871
    gts = gru_alloc_locked_gts(req.gseg);
#line 872
    tmp___1 = IS_ERR((void const   *)gts);
#line 872
    if ((int )tmp___1) {
#line 873
      tmp___0 = PTR_ERR((void const   *)gts);
#line 873
      return ((int )tmp___0);
    } else {

    }
  } else {

  }
#line 876
  switch (req.op) {
  case 2: ;
#line 879
  if ((((req.val0 < -1 || req.val0 > 1) || req.val1 < -1L) || req.val1 > 1023L) || (req.val1 >= 0L && (unsigned long )gru_base[req.val1] == (unsigned long )((struct gru_blade_state *)0))) {
#line 882
    ret = -22;
  } else {
#line 884
    gts->ts_user_blade_id = (short )req.val1;
#line 885
    gts->ts_user_chiplet_id = (char )req.val0;
#line 886
    gru_check_context_placement(gts);
  }
#line 888
  goto ldv_35385;
  case 0: 
#line 891
  tmp___2 = get_current();
#line 891
  gts->ts_tgid_owner = tmp___2->tgid;
#line 892
  goto ldv_35385;
  case 1: 
#line 895
  gts->ts_cch_req_slice = (int )((char )req.val1) & 3;
#line 896
  goto ldv_35385;
  default: 
#line 898
  ret = -22;
  }
  ldv_35385: 
#line 900
  gru_unlock_gts(gts);
#line 902
  return (ret);
}
}
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 128
  tmp = ldv_ptr_err(ptr);
#line 128
  return (tmp);
}
}
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
void ldv_mutex_unlock_61(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 146
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 148
  mutex_unlock(ldv_func_arg1);
#line 149
  return;
}
}
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
void ldv_mutex_lock_62(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 154
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 156
  mutex_lock(ldv_func_arg1);
#line 157
  return;
}
}
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
void ldv_mutex_lock_63(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 162
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 164
  mutex_lock(ldv_func_arg1);
#line 165
  return;
}
}
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
void ldv_mutex_unlock_64(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 170
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 172
  mutex_unlock(ldv_func_arg1);
#line 173
  return;
}
}
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
void ldv_mutex_lock_65(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 178
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 180
  mutex_lock(ldv_func_arg1);
#line 181
  return;
}
}
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
int ldv_mutex_trylock_66(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 187
  tmp = mutex_trylock(ldv_func_arg1);
#line 187
  ldv_func_res = tmp;
#line 189
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 189
  return (tmp___0);
#line 191
  return (ldv_func_res);
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
void ldv_mutex_unlock_67(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 197
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 199
  mutex_unlock(ldv_func_arg1);
#line 200
  return;
}
}
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
void ldv_mutex_lock_68(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 205
  ldv_mutex_lock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
#line 207
  mutex_lock(ldv_func_arg1);
#line 208
  return;
}
}
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
void ldv_mutex_lock_69(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 213
  ldv_mutex_lock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
#line 215
  mutex_lock(ldv_func_arg1);
#line 216
  return;
}
}
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
void ldv_mutex_unlock_70(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 221
  ldv_mutex_unlock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
#line 223
  mutex_unlock(ldv_func_arg1);
#line 224
  return;
}
}
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
int ldv_mutex_trylock_71(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 230
  tmp = mutex_trylock(ldv_func_arg1);
#line 230
  ldv_func_res = tmp;
#line 232
  tmp___0 = ldv_mutex_trylock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
#line 232
  return (tmp___0);
#line 234
  return (ldv_func_res);
}
}
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grufault.o.c.prepared"
void ldv_mutex_unlock_72(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 240
  ldv_mutex_unlock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
#line 242
  mutex_unlock(ldv_func_arg1);
#line 243
  return;
}
}
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 201 "include/linux/compiler.h"
__inline static void __read_once_size(void const volatile   *p , void *res , int size ) 
{ 


  {
#line 203
  switch (size) {
  case 1: 
#line 204
  *((__u8 *)res) = *((__u8 volatile   *)p);
#line 204
  goto ldv_880;
  case 2: 
#line 205
  *((__u16 *)res) = *((__u16 volatile   *)p);
#line 205
  goto ldv_880;
  case 4: 
#line 206
  *((__u32 *)res) = *((__u32 volatile   *)p);
#line 206
  goto ldv_880;
  case 8: 
#line 207
  *((__u64 *)res) = *((__u64 volatile   *)p);
#line 207
  goto ldv_880;
  default: 
#line 209
  __asm__  volatile   ("": : : "memory");
#line 210
  __builtin_memcpy(res, (void const   *)p, (unsigned long )size);
#line 211
  __asm__  volatile   ("": : : "memory");
  }
  ldv_880: ;
#line 214
  return;
}
}
#line 368 "./arch/x86/include/asm/paravirt_types.h"
extern struct pv_cpu_ops pv_cpu_ops ;
#line 437 "./arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ 
  int r ;

  {
#line 451
  __asm__  ("bsrl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 464
  return (r + 1);
}
}
#line 177 "./arch/x86/include/asm/paravirt.h"
__inline static u64 paravirt_read_tsc(void) 
{ 
  u64 __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 179
  __edi = __edi;
#line 179
  __esi = __esi;
#line 179
  __edx = __edx;
#line 179
  __ecx = __ecx;
#line 179
  __eax = __eax;
#line 179
  tmp = ldv__builtin_expect((unsigned long )pv_cpu_ops.read_tsc == (unsigned long )((u64 (*)(void))0),
                         0L);
#line 179
  if (tmp != 0L) {
#line 179
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (179), "i" (12UL));
    ldv_4012: ;
#line 179
    goto ldv_4012;
  } else {

  }
#line 179
  __asm__  volatile   ("771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n": "=D" (__edi),
                       "=S" (__esi), "=d" (__edx), "=c" (__ecx), "=a" (__eax): [paravirt_typenum] "i" (34UL),
                       [paravirt_opptr] "i" (& pv_cpu_ops.read_tsc), [paravirt_clobber] "i" (511): "memory",
                       "cc", "r8", "r9", "r10", "r11");
#line 179
  __ret = (unsigned long long )__eax;
#line 179
  return (__ret);
}
}
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 116 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ 
  char c ;

  {
#line 118
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0; sete %1": "+m" (v->counter),
                       "=qm" (c): : "memory");
#line 118
  return ((int )((signed char )c) != 0);
}
}
#line 333 "include/linux/lockdep.h"
extern void lock_acquire(struct lockdep_map * , unsigned int  , int  , int  , int  ,
                         struct lockdep_map * , unsigned long  ) ;
#line 337
extern void lock_release(struct lockdep_map * , int  , unsigned long  ) ;
#line 545
extern void lockdep_rcu_suspicious(char const   * , int const    , char const   * ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_92(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_93(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.o.c.prepared"
void ldv_mutex_lock_89(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_91(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) ;
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add___0(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6569;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6569;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6569;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6569;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6569: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub___0(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6581;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6581;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6581;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6581;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6581: ;
#line 79
  return;
}
}
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 149
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 22 "./arch/x86/include/asm/tsc.h"
__inline static cycles_t get_cycles(void) 
{ 
  unsigned long long ret ;

  {
#line 24
  ret = 0ULL;
#line 30
  ret = paravirt_read_tsc();
#line 32
  return (ret);
}
}
#line 268 "include/linux/rcupdate.h"
__inline static void __rcu_read_lock(void) 
{ 


  {
#line 270
  __preempt_count_add___0(1);
#line 270
  __asm__  volatile   ("": : : "memory");
#line 271
  return;
}
}
#line 273 "include/linux/rcupdate.h"
__inline static void __rcu_read_unlock(void) 
{ 


  {
#line 275
  __asm__  volatile   ("": : : "memory");
#line 275
  __preempt_count_sub___0(1);
#line 276
  return;
}
}
#line 104 "include/linux/rcutree.h"
extern bool rcu_is_watching(void) ;
#line 447 "include/linux/rcupdate.h"
__inline static void rcu_lock_acquire(struct lockdep_map *map ) 
{ 


  {
#line 449
  lock_acquire(map, 0U, 0, 2, 0, (struct lockdep_map *)0, 0UL);
#line 450
  return;
}
}
#line 452 "include/linux/rcupdate.h"
__inline static void rcu_lock_release(struct lockdep_map *map ) 
{ 


  {
#line 454
  lock_release(map, 1, 0UL);
#line 455
  return;
}
}
#line 457
extern struct lockdep_map rcu_lock_map ;
#line 461
extern int debug_lockdep_rcu_enabled(void) ;
#line 843 "include/linux/rcupdate.h"
__inline static void rcu_read_lock(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 845
  __rcu_read_lock();
#line 847
  rcu_lock_acquire(& rcu_lock_map);
#line 848
  tmp = debug_lockdep_rcu_enabled();
#line 848
  if (tmp != 0 && ! __warned) {
#line 848
    tmp___0 = rcu_is_watching();
#line 848
    if (tmp___0) {
#line 848
      tmp___1 = 0;
    } else {
#line 848
      tmp___1 = 1;
    }
#line 848
    if (tmp___1) {
#line 848
      __warned = 1;
#line 848
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 849, "rcu_read_lock() used illegally while idle");
    } else {

    }
  } else {

  }
#line 851
  return;
}
}
#line 897 "include/linux/rcupdate.h"
__inline static void rcu_read_unlock(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 899
  tmp = debug_lockdep_rcu_enabled();
#line 899
  if (tmp != 0 && ! __warned) {
#line 899
    tmp___0 = rcu_is_watching();
#line 899
    if (tmp___0) {
#line 899
      tmp___1 = 0;
    } else {
#line 899
      tmp___1 = 1;
    }
#line 899
    if (tmp___1) {
#line 899
      __warned = 1;
#line 899
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 900, "rcu_read_unlock() used illegally while idle");
    } else {

    }
  } else {

  }
#line 902
  __rcu_read_unlock();
#line 903
  rcu_lock_release(& rcu_lock_map);
#line 904
  return;
}
}
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 195 "include/linux/mmu_notifier.h"
extern int __mmu_notifier_register(struct mmu_notifier * , struct mm_struct * ) ;
#line 197
extern void mmu_notifier_unregister(struct mmu_notifier * , struct mm_struct * ) ;
#line 124 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
__inline static struct gru_tlb_global_handle *get_tgh(void *base , int ctxnum ) 
{ 


  {
#line 126
  return ((struct gru_tlb_global_handle *)(base + ((unsigned long )(ctxnum * 256) + 67141632UL)));
}
}
#line 520
int tgh_invalidate(struct gru_tlb_global_handle *tgh , unsigned long vaddr , unsigned long vaddrmask ,
                   int asid , int pagesize , int global , int n , unsigned short ctxbitmap ) ;
#line 570 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
__inline static void __lock_handle___0(void *h ) 
{ 
  int tmp ;

  {
#line 572
  goto ldv_32028;
  ldv_32027: 
#line 573
  cpu_relax();
  ldv_32028: 
#line 572
  tmp = test_and_set_bit(1L, (unsigned long volatile   *)h);
#line 572
  if (tmp != 0) {
#line 574
    goto ldv_32027;
  } else {

  }

#line 579
  return;
}
}
#line 597 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
__inline static void lock_tgh_handle(struct gru_tlb_global_handle *tgh ) 
{ 


  {
#line 599
  __lock_handle___0((void *)tgh);
#line 600
  return;
}
}
#line 602 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
__inline static void unlock_tgh_handle(struct gru_tlb_global_handle *tgh ) 
{ 


  {
#line 604
  __unlock_handle((void *)tgh);
#line 605
  return;
}
}
#line 504 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_blade_processor_id(void) 
{ 
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;

  {
#line 506
  __vpp_verify = (void const   *)0;
#line 506
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off), "0" (& __uv_hub_info));
#line 506
  return ((int )((struct uv_hub_info_s *)tcp_ptr__)->blade_processor_id);
}
}
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
__inline static int get_off_blade_tgh(struct gru_state *gru ) 
{ 
  int n ;
  cycles_t tmp ;

  {
#line 64
  n = 24 - (int )gru->gs_tgh_first_remote;
#line 65
  tmp = get_cycles();
#line 65
  n = (int )(tmp % (cycles_t )n);
#line 66
  n = (int )gru->gs_tgh_first_remote + n;
#line 67
  return (n);
}
}
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
__inline static int get_on_blade_tgh(struct gru_state *gru ) 
{ 
  int tmp ;

  {
#line 72
  tmp = uv_blade_processor_id();
#line 72
  return (tmp >> (int )gru->gs_tgh_local_shift);
}
}
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
static struct gru_tlb_global_handle *get_lock_tgh_handle(struct gru_state *gru ) 
{ 
  struct gru_tlb_global_handle *tgh ;
  int n ;
  int tmp ;

  {
#line 81
  __preempt_count_add___0(1);
#line 81
  __asm__  volatile   ("": : : "memory");
#line 82
  tmp = uv_numa_blade_id();
#line 82
  if (tmp == (int )gru->gs_blade_id) {
#line 83
    n = get_on_blade_tgh(gru);
  } else {
#line 85
    n = get_off_blade_tgh(gru);
  }
#line 86
  tgh = get_tgh(gru->gs_gru_base_vaddr, n);
#line 87
  lock_tgh_handle(tgh);
#line 89
  return (tgh);
}
}
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
static void get_unlock_tgh_handle(struct gru_tlb_global_handle *tgh ) 
{ 


  {
#line 94
  unlock_tgh_handle(tgh);
#line 95
  __asm__  volatile   ("": : : "memory");
#line 95
  __preempt_count_sub___0(1);
#line 96
  return;
}
}
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
void gru_flush_tlb_range(struct gru_mm_struct *gms , unsigned long start , unsigned long len ) 
{ 
  struct gru_state *gru ;
  struct gru_mm_tracker *asids ;
  struct gru_tlb_global_handle *tgh ;
  unsigned long num ;
  int grupagesize ;
  int pagesize ;
  int pageshift ;
  int gid ;
  int asid ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  unsigned long tmp ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int pscr_ret_____1 ;
  void const   *__vpp_verify___1 ;
  int pfo_ret_____7 ;
  int pfo_ret_____8 ;
  int pfo_ret_____9 ;
  int pfo_ret_____10 ;
  unsigned long tmp___0 ;

  {
#line 168
  pageshift = 12;
#line 169
  pagesize = (int )(1UL << pageshift);
#line 170
  grupagesize = pageshift > 20 ? ((pageshift + 2) >> 1) + -6 : (pageshift >> 1) + -6;
#line 171
  _min1 = (((unsigned long )pagesize + len) - 1UL) >> pageshift;
#line 171
  _min2 = 1024UL;
#line 171
  num = _min1 < _min2 ? _min1 : _min2;
#line 173
  if ((gru_options & 2UL) != 0UL) {
#line 173
    atomic_long_inc(& gru_stats.flush_tlb);
  } else {

  }
#line 174
  if ((int )gru_options & 1) {
#line 174
    __vpp_verify = (void const   *)0;
#line 174
    switch (4UL) {
    case 1UL: ;
#line 175
    switch (4UL) {
    case 1UL: 
#line 175
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 175
    goto ldv_33616;
    case 2UL: 
#line 175
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 175
    goto ldv_33616;
    case 4UL: 
#line 175
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 175
    goto ldv_33616;
    case 8UL: 
#line 175
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 175
    goto ldv_33616;
    default: 
#line 175
    __bad_percpu_size();
    }
    ldv_33616: 
#line 175
    pscr_ret__ = pfo_ret__;
#line 175
    goto ldv_33622;
    case 2UL: ;
#line 175
    switch (4UL) {
    case 1UL: 
#line 175
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 175
    goto ldv_33626;
    case 2UL: 
#line 175
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 175
    goto ldv_33626;
    case 4UL: 
#line 175
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 175
    goto ldv_33626;
    case 8UL: 
#line 175
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 175
    goto ldv_33626;
    default: 
#line 175
    __bad_percpu_size();
    }
    ldv_33626: 
#line 175
    pscr_ret__ = pfo_ret_____0;
#line 175
    goto ldv_33622;
    case 4UL: ;
#line 175
    switch (4UL) {
    case 1UL: 
#line 175
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 175
    goto ldv_33635;
    case 2UL: 
#line 175
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 175
    goto ldv_33635;
    case 4UL: 
#line 175
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 175
    goto ldv_33635;
    case 8UL: 
#line 175
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 175
    goto ldv_33635;
    default: 
#line 175
    __bad_percpu_size();
    }
    ldv_33635: 
#line 175
    pscr_ret__ = pfo_ret_____1;
#line 175
    goto ldv_33622;
    case 8UL: ;
#line 175
    switch (4UL) {
    case 1UL: 
#line 175
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 175
    goto ldv_33644;
    case 2UL: 
#line 175
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 175
    goto ldv_33644;
    case 4UL: 
#line 175
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 175
    goto ldv_33644;
    case 8UL: 
#line 175
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 175
    goto ldv_33644;
    default: 
#line 175
    __bad_percpu_size();
    }
    ldv_33644: 
#line 175
    pscr_ret__ = pfo_ret_____2;
#line 175
    goto ldv_33622;
    default: 
#line 175
    __bad_size_call_parameter();
#line 175
    goto ldv_33622;
    }
    ldv_33622: 
#line 175
    printk("\017GRU:%d %s: gms %p, start 0x%lx, len 0x%lx, asidmap 0x%lx\n", pscr_ret__,
           "gru_flush_tlb_range", gms, start, len, gms->ms_asidmap[0]);
  } else {

  }
#line 177
  spin_lock(& gms->ms_asid_lock);
#line 178
  tmp = find_first_bit((unsigned long const   *)(& gms->ms_asidmap), 2048UL);
#line 178
  gid = (int )tmp;
#line 178
  goto ldv_33736;
  ldv_33735: ;
#line 179
  if ((gru_options & 2UL) != 0UL) {
#line 179
    atomic_long_inc(& gru_stats.flush_tlb_gru);
  } else {

  }
#line 180
  gru = (unsigned long )gru_base[gid / 2] != (unsigned long )((struct gru_blade_state *)0) ? (struct gru_state *)(& (gru_base[gid / 2])->bs_grus) + (unsigned long )(gid % 2) : (struct gru_state *)0;
#line 181
  asids = (struct gru_mm_tracker *)(& gms->ms_asids) + (unsigned long )gid;
#line 182
  asid = (int )asids->mt_asid;
#line 183
  if ((unsigned int )asids->mt_ctxbitmap != 0U && asid != 0) {
#line 184
    if ((gru_options & 2UL) != 0UL) {
#line 184
      atomic_long_inc(& gru_stats.flush_tlb_gru_tgh);
    } else {

    }
#line 185
    asid = (int )(((unsigned int )(start >> 61) & 3U) + (unsigned int )asid);
#line 186
    if ((int )gru_options & 1) {
#line 186
      __vpp_verify___0 = (void const   *)0;
#line 186
      switch (4UL) {
      case 1UL: ;
#line 188
      switch (4UL) {
      case 1UL: 
#line 188
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 188
      goto ldv_33658;
      case 2UL: 
#line 188
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 188
      goto ldv_33658;
      case 4UL: 
#line 188
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 188
      goto ldv_33658;
      case 8UL: 
#line 188
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 188
      goto ldv_33658;
      default: 
#line 188
      __bad_percpu_size();
      }
      ldv_33658: 
#line 188
      pscr_ret_____0 = pfo_ret_____3;
#line 188
      goto ldv_33664;
      case 2UL: ;
#line 188
      switch (4UL) {
      case 1UL: 
#line 188
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 188
      goto ldv_33668;
      case 2UL: 
#line 188
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 188
      goto ldv_33668;
      case 4UL: 
#line 188
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 188
      goto ldv_33668;
      case 8UL: 
#line 188
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 188
      goto ldv_33668;
      default: 
#line 188
      __bad_percpu_size();
      }
      ldv_33668: 
#line 188
      pscr_ret_____0 = pfo_ret_____4;
#line 188
      goto ldv_33664;
      case 4UL: ;
#line 188
      switch (4UL) {
      case 1UL: 
#line 188
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 188
      goto ldv_33677;
      case 2UL: 
#line 188
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 188
      goto ldv_33677;
      case 4UL: 
#line 188
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 188
      goto ldv_33677;
      case 8UL: 
#line 188
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 188
      goto ldv_33677;
      default: 
#line 188
      __bad_percpu_size();
      }
      ldv_33677: 
#line 188
      pscr_ret_____0 = pfo_ret_____5;
#line 188
      goto ldv_33664;
      case 8UL: ;
#line 188
      switch (4UL) {
      case 1UL: 
#line 188
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 188
      goto ldv_33686;
      case 2UL: 
#line 188
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 188
      goto ldv_33686;
      case 4UL: 
#line 188
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 188
      goto ldv_33686;
      case 8UL: 
#line 188
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 188
      goto ldv_33686;
      default: 
#line 188
      __bad_percpu_size();
      }
      ldv_33686: 
#line 188
      pscr_ret_____0 = pfo_ret_____6;
#line 188
      goto ldv_33664;
      default: 
#line 188
      __bad_size_call_parameter();
#line 188
      goto ldv_33664;
      }
      ldv_33664: 
#line 188
      printk("\017GRU:%d %s:   FLUSH gruid %d, asid 0x%x, vaddr 0x%lx, vamask 0x%x, num %ld, cbmap 0x%x\n",
             pscr_ret_____0, "gru_flush_tlb_range", gid, asid, start, grupagesize,
             num, (int )asids->mt_ctxbitmap);
    } else {

    }
#line 189
    tgh = get_lock_tgh_handle(gru);
#line 190
    tgh_invalidate(tgh, start, 0xffffffffffffffffUL, asid, grupagesize, 0, (int )((unsigned int )num - 1U),
                   (int )asids->mt_ctxbitmap);
#line 192
    get_unlock_tgh_handle(tgh);
  } else {
#line 194
    if ((gru_options & 2UL) != 0UL) {
#line 194
      atomic_long_inc(& gru_stats.flush_tlb_gru_zero_asid);
    } else {

    }
#line 195
    asids->mt_asid = 0U;
#line 196
    __clear_bit((long )gru->gs_gid, (unsigned long volatile   *)(& gms->ms_asidmap));
#line 197
    if ((int )gru_options & 1) {
#line 197
      __vpp_verify___1 = (void const   *)0;
#line 197
      switch (4UL) {
      case 1UL: ;
#line 200
      switch (4UL) {
      case 1UL: 
#line 200
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____7): "m" (cpu_number));
#line 200
      goto ldv_33699;
      case 2UL: 
#line 200
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 200
      goto ldv_33699;
      case 4UL: 
#line 200
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 200
      goto ldv_33699;
      case 8UL: 
#line 200
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 200
      goto ldv_33699;
      default: 
#line 200
      __bad_percpu_size();
      }
      ldv_33699: 
#line 200
      pscr_ret_____1 = pfo_ret_____7;
#line 200
      goto ldv_33705;
      case 2UL: ;
#line 200
      switch (4UL) {
      case 1UL: 
#line 200
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____8): "m" (cpu_number));
#line 200
      goto ldv_33709;
      case 2UL: 
#line 200
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 200
      goto ldv_33709;
      case 4UL: 
#line 200
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 200
      goto ldv_33709;
      case 8UL: 
#line 200
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 200
      goto ldv_33709;
      default: 
#line 200
      __bad_percpu_size();
      }
      ldv_33709: 
#line 200
      pscr_ret_____1 = pfo_ret_____8;
#line 200
      goto ldv_33705;
      case 4UL: ;
#line 200
      switch (4UL) {
      case 1UL: 
#line 200
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____9): "m" (cpu_number));
#line 200
      goto ldv_33718;
      case 2UL: 
#line 200
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 200
      goto ldv_33718;
      case 4UL: 
#line 200
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 200
      goto ldv_33718;
      case 8UL: 
#line 200
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 200
      goto ldv_33718;
      default: 
#line 200
      __bad_percpu_size();
      }
      ldv_33718: 
#line 200
      pscr_ret_____1 = pfo_ret_____9;
#line 200
      goto ldv_33705;
      case 8UL: ;
#line 200
      switch (4UL) {
      case 1UL: 
#line 200
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____10): "m" (cpu_number));
#line 200
      goto ldv_33727;
      case 2UL: 
#line 200
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 200
      goto ldv_33727;
      case 4UL: 
#line 200
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 200
      goto ldv_33727;
      case 8UL: 
#line 200
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 200
      goto ldv_33727;
      default: 
#line 200
      __bad_percpu_size();
      }
      ldv_33727: 
#line 200
      pscr_ret_____1 = pfo_ret_____10;
#line 200
      goto ldv_33705;
      default: 
#line 200
      __bad_size_call_parameter();
#line 200
      goto ldv_33705;
      }
      ldv_33705: 
#line 200
      printk("\017GRU:%d %s:   CLEARASID gruid %d, asid 0x%x, cbtmap 0x%x, asidmap 0x%lx\n",
             pscr_ret_____1, "gru_flush_tlb_range", gid, asid, (int )asids->mt_ctxbitmap,
             gms->ms_asidmap[0]);
    } else {

    }
  }
#line 178
  tmp___0 = find_next_bit((unsigned long const   *)(& gms->ms_asidmap), 2048UL, (unsigned long )(gid + 1));
#line 178
  gid = (int )tmp___0;
  ldv_33736: ;
#line 178
  if (gid <= 2047) {
#line 180
    goto ldv_33735;
  } else {

  }
#line 203
  spin_unlock(& gms->ms_asid_lock);
#line 204
  return;
}
}
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
void gru_flush_all_tlb(struct gru_state *gru ) 
{ 
  struct gru_tlb_global_handle *tgh ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 213
  if ((int )gru_options & 1) {
#line 213
    __vpp_verify = (void const   *)0;
#line 213
    switch (4UL) {
    case 1UL: ;
#line 213
    switch (4UL) {
    case 1UL: 
#line 213
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 213
    goto ldv_33747;
    case 2UL: 
#line 213
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 213
    goto ldv_33747;
    case 4UL: 
#line 213
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 213
    goto ldv_33747;
    case 8UL: 
#line 213
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 213
    goto ldv_33747;
    default: 
#line 213
    __bad_percpu_size();
    }
    ldv_33747: 
#line 213
    pscr_ret__ = pfo_ret__;
#line 213
    goto ldv_33753;
    case 2UL: ;
#line 213
    switch (4UL) {
    case 1UL: 
#line 213
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 213
    goto ldv_33757;
    case 2UL: 
#line 213
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 213
    goto ldv_33757;
    case 4UL: 
#line 213
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 213
    goto ldv_33757;
    case 8UL: 
#line 213
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 213
    goto ldv_33757;
    default: 
#line 213
    __bad_percpu_size();
    }
    ldv_33757: 
#line 213
    pscr_ret__ = pfo_ret_____0;
#line 213
    goto ldv_33753;
    case 4UL: ;
#line 213
    switch (4UL) {
    case 1UL: 
#line 213
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 213
    goto ldv_33766;
    case 2UL: 
#line 213
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 213
    goto ldv_33766;
    case 4UL: 
#line 213
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 213
    goto ldv_33766;
    case 8UL: 
#line 213
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 213
    goto ldv_33766;
    default: 
#line 213
    __bad_percpu_size();
    }
    ldv_33766: 
#line 213
    pscr_ret__ = pfo_ret_____1;
#line 213
    goto ldv_33753;
    case 8UL: ;
#line 213
    switch (4UL) {
    case 1UL: 
#line 213
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 213
    goto ldv_33775;
    case 2UL: 
#line 213
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 213
    goto ldv_33775;
    case 4UL: 
#line 213
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 213
    goto ldv_33775;
    case 8UL: 
#line 213
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 213
    goto ldv_33775;
    default: 
#line 213
    __bad_percpu_size();
    }
    ldv_33775: 
#line 213
    pscr_ret__ = pfo_ret_____2;
#line 213
    goto ldv_33753;
    default: 
#line 213
    __bad_size_call_parameter();
#line 213
    goto ldv_33753;
    }
    ldv_33753: 
#line 213
    printk("\017GRU:%d %s: gid %d\n", pscr_ret__, "gru_flush_all_tlb", (int )gru->gs_gid);
  } else {

  }
#line 214
  tgh = get_lock_tgh_handle(gru);
#line 215
  tgh_invalidate(tgh, 0UL, 0xffffffffffffffffUL, 0, 1, 1, 1023, 65535);
#line 216
  get_unlock_tgh_handle(tgh);
#line 217
  return;
}
}
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
static void gru_invalidate_range_start(struct mmu_notifier *mn , struct mm_struct *mm ,
                                       unsigned long start , unsigned long end ) 
{ 
  struct gru_mm_struct *gms ;
  struct mmu_notifier  const  *__mptr ;
  int tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 226
  __mptr = (struct mmu_notifier  const  *)mn;
#line 226
  gms = (struct gru_mm_struct *)__mptr;
#line 229
  if ((gru_options & 2UL) != 0UL) {
#line 229
    atomic_long_inc(& gru_stats.mmu_invalidate_range);
  } else {

  }
#line 230
  atomic_inc(& gms->ms_range_active);
#line 231
  if ((int )gru_options & 1) {
#line 231
    tmp = atomic_read((atomic_t const   *)(& gms->ms_range_active));
#line 231
    __vpp_verify = (void const   *)0;
#line 231
    switch (4UL) {
    case 1UL: ;
#line 232
    switch (4UL) {
    case 1UL: 
#line 232
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 232
    goto ldv_33798;
    case 2UL: 
#line 232
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 232
    goto ldv_33798;
    case 4UL: 
#line 232
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 232
    goto ldv_33798;
    case 8UL: 
#line 232
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 232
    goto ldv_33798;
    default: 
#line 232
    __bad_percpu_size();
    }
    ldv_33798: 
#line 232
    pscr_ret__ = pfo_ret__;
#line 232
    goto ldv_33804;
    case 2UL: ;
#line 232
    switch (4UL) {
    case 1UL: 
#line 232
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 232
    goto ldv_33808;
    case 2UL: 
#line 232
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 232
    goto ldv_33808;
    case 4UL: 
#line 232
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 232
    goto ldv_33808;
    case 8UL: 
#line 232
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 232
    goto ldv_33808;
    default: 
#line 232
    __bad_percpu_size();
    }
    ldv_33808: 
#line 232
    pscr_ret__ = pfo_ret_____0;
#line 232
    goto ldv_33804;
    case 4UL: ;
#line 232
    switch (4UL) {
    case 1UL: 
#line 232
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 232
    goto ldv_33817;
    case 2UL: 
#line 232
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 232
    goto ldv_33817;
    case 4UL: 
#line 232
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 232
    goto ldv_33817;
    case 8UL: 
#line 232
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 232
    goto ldv_33817;
    default: 
#line 232
    __bad_percpu_size();
    }
    ldv_33817: 
#line 232
    pscr_ret__ = pfo_ret_____1;
#line 232
    goto ldv_33804;
    case 8UL: ;
#line 232
    switch (4UL) {
    case 1UL: 
#line 232
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 232
    goto ldv_33826;
    case 2UL: 
#line 232
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 232
    goto ldv_33826;
    case 4UL: 
#line 232
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 232
    goto ldv_33826;
    case 8UL: 
#line 232
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 232
    goto ldv_33826;
    default: 
#line 232
    __bad_percpu_size();
    }
    ldv_33826: 
#line 232
    pscr_ret__ = pfo_ret_____2;
#line 232
    goto ldv_33804;
    default: 
#line 232
    __bad_size_call_parameter();
#line 232
    goto ldv_33804;
    }
    ldv_33804: 
#line 232
    printk("\017GRU:%d %s: gms %p, start 0x%lx, end 0x%lx, act %d\n", pscr_ret__,
           "gru_invalidate_range_start", gms, start, end, tmp);
  } else {

  }
#line 233
  gru_flush_tlb_range(gms, start, end - start);
#line 234
  return;
}
}
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
static void gru_invalidate_range_end(struct mmu_notifier *mn , struct mm_struct *mm ,
                                     unsigned long start , unsigned long end ) 
{ 
  struct gru_mm_struct *gms ;
  struct mmu_notifier  const  *__mptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 240
  __mptr = (struct mmu_notifier  const  *)mn;
#line 240
  gms = (struct gru_mm_struct *)__mptr;
#line 244
  atomic_dec_and_test(& gms->ms_range_active);
#line 246
  __wake_up(& gms->ms_wait_queue, 3U, 0, (void *)0);
#line 247
  if ((int )gru_options & 1) {
#line 247
    __vpp_verify = (void const   *)0;
#line 247
    switch (4UL) {
    case 1UL: ;
#line 247
    switch (4UL) {
    case 1UL: 
#line 247
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 247
    goto ldv_33849;
    case 2UL: 
#line 247
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 247
    goto ldv_33849;
    case 4UL: 
#line 247
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 247
    goto ldv_33849;
    case 8UL: 
#line 247
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 247
    goto ldv_33849;
    default: 
#line 247
    __bad_percpu_size();
    }
    ldv_33849: 
#line 247
    pscr_ret__ = pfo_ret__;
#line 247
    goto ldv_33855;
    case 2UL: ;
#line 247
    switch (4UL) {
    case 1UL: 
#line 247
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 247
    goto ldv_33859;
    case 2UL: 
#line 247
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 247
    goto ldv_33859;
    case 4UL: 
#line 247
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 247
    goto ldv_33859;
    case 8UL: 
#line 247
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 247
    goto ldv_33859;
    default: 
#line 247
    __bad_percpu_size();
    }
    ldv_33859: 
#line 247
    pscr_ret__ = pfo_ret_____0;
#line 247
    goto ldv_33855;
    case 4UL: ;
#line 247
    switch (4UL) {
    case 1UL: 
#line 247
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 247
    goto ldv_33868;
    case 2UL: 
#line 247
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 247
    goto ldv_33868;
    case 4UL: 
#line 247
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 247
    goto ldv_33868;
    case 8UL: 
#line 247
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 247
    goto ldv_33868;
    default: 
#line 247
    __bad_percpu_size();
    }
    ldv_33868: 
#line 247
    pscr_ret__ = pfo_ret_____1;
#line 247
    goto ldv_33855;
    case 8UL: ;
#line 247
    switch (4UL) {
    case 1UL: 
#line 247
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 247
    goto ldv_33877;
    case 2UL: 
#line 247
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 247
    goto ldv_33877;
    case 4UL: 
#line 247
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 247
    goto ldv_33877;
    case 8UL: 
#line 247
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 247
    goto ldv_33877;
    default: 
#line 247
    __bad_percpu_size();
    }
    ldv_33877: 
#line 247
    pscr_ret__ = pfo_ret_____2;
#line 247
    goto ldv_33855;
    default: 
#line 247
    __bad_size_call_parameter();
#line 247
    goto ldv_33855;
    }
    ldv_33855: 
#line 247
    printk("\017GRU:%d %s: gms %p, start 0x%lx, end 0x%lx\n", pscr_ret__, "gru_invalidate_range_end",
           gms, start, end);
  } else {

  }
#line 248
  return;
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
static void gru_invalidate_page(struct mmu_notifier *mn , struct mm_struct *mm , unsigned long address ) 
{ 
  struct gru_mm_struct *gms ;
  struct mmu_notifier  const  *__mptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 253
  __mptr = (struct mmu_notifier  const  *)mn;
#line 253
  gms = (struct gru_mm_struct *)__mptr;
#line 256
  if ((gru_options & 2UL) != 0UL) {
#line 256
    atomic_long_inc(& gru_stats.mmu_invalidate_page);
  } else {

  }
#line 257
  gru_flush_tlb_range(gms, address, 4096UL);
#line 258
  if ((int )gru_options & 1) {
#line 258
    __vpp_verify = (void const   *)0;
#line 258
    switch (4UL) {
    case 1UL: ;
#line 258
    switch (4UL) {
    case 1UL: 
#line 258
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 258
    goto ldv_33899;
    case 2UL: 
#line 258
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 258
    goto ldv_33899;
    case 4UL: 
#line 258
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 258
    goto ldv_33899;
    case 8UL: 
#line 258
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 258
    goto ldv_33899;
    default: 
#line 258
    __bad_percpu_size();
    }
    ldv_33899: 
#line 258
    pscr_ret__ = pfo_ret__;
#line 258
    goto ldv_33905;
    case 2UL: ;
#line 258
    switch (4UL) {
    case 1UL: 
#line 258
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 258
    goto ldv_33909;
    case 2UL: 
#line 258
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 258
    goto ldv_33909;
    case 4UL: 
#line 258
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 258
    goto ldv_33909;
    case 8UL: 
#line 258
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 258
    goto ldv_33909;
    default: 
#line 258
    __bad_percpu_size();
    }
    ldv_33909: 
#line 258
    pscr_ret__ = pfo_ret_____0;
#line 258
    goto ldv_33905;
    case 4UL: ;
#line 258
    switch (4UL) {
    case 1UL: 
#line 258
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 258
    goto ldv_33918;
    case 2UL: 
#line 258
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 258
    goto ldv_33918;
    case 4UL: 
#line 258
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 258
    goto ldv_33918;
    case 8UL: 
#line 258
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 258
    goto ldv_33918;
    default: 
#line 258
    __bad_percpu_size();
    }
    ldv_33918: 
#line 258
    pscr_ret__ = pfo_ret_____1;
#line 258
    goto ldv_33905;
    case 8UL: ;
#line 258
    switch (4UL) {
    case 1UL: 
#line 258
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 258
    goto ldv_33927;
    case 2UL: 
#line 258
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 258
    goto ldv_33927;
    case 4UL: 
#line 258
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 258
    goto ldv_33927;
    case 8UL: 
#line 258
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 258
    goto ldv_33927;
    default: 
#line 258
    __bad_percpu_size();
    }
    ldv_33927: 
#line 258
    pscr_ret__ = pfo_ret_____2;
#line 258
    goto ldv_33905;
    default: 
#line 258
    __bad_size_call_parameter();
#line 258
    goto ldv_33905;
    }
    ldv_33905: 
#line 258
    printk("\017GRU:%d %s: gms %p, address 0x%lx\n", pscr_ret__, "gru_invalidate_page",
           gms, address);
  } else {

  }
#line 259
  return;
}
}
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
static void gru_release(struct mmu_notifier *mn , struct mm_struct *mm ) 
{ 
  struct gru_mm_struct *gms ;
  struct mmu_notifier  const  *__mptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 263
  __mptr = (struct mmu_notifier  const  *)mn;
#line 263
  gms = (struct gru_mm_struct *)__mptr;
#line 266
  gms->ms_released = 1;
#line 267
  if ((int )gru_options & 1) {
#line 267
    __vpp_verify = (void const   *)0;
#line 267
    switch (4UL) {
    case 1UL: ;
#line 267
    switch (4UL) {
    case 1UL: 
#line 267
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 267
    goto ldv_33948;
    case 2UL: 
#line 267
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 267
    goto ldv_33948;
    case 4UL: 
#line 267
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 267
    goto ldv_33948;
    case 8UL: 
#line 267
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 267
    goto ldv_33948;
    default: 
#line 267
    __bad_percpu_size();
    }
    ldv_33948: 
#line 267
    pscr_ret__ = pfo_ret__;
#line 267
    goto ldv_33954;
    case 2UL: ;
#line 267
    switch (4UL) {
    case 1UL: 
#line 267
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 267
    goto ldv_33958;
    case 2UL: 
#line 267
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 267
    goto ldv_33958;
    case 4UL: 
#line 267
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 267
    goto ldv_33958;
    case 8UL: 
#line 267
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 267
    goto ldv_33958;
    default: 
#line 267
    __bad_percpu_size();
    }
    ldv_33958: 
#line 267
    pscr_ret__ = pfo_ret_____0;
#line 267
    goto ldv_33954;
    case 4UL: ;
#line 267
    switch (4UL) {
    case 1UL: 
#line 267
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 267
    goto ldv_33967;
    case 2UL: 
#line 267
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 267
    goto ldv_33967;
    case 4UL: 
#line 267
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 267
    goto ldv_33967;
    case 8UL: 
#line 267
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 267
    goto ldv_33967;
    default: 
#line 267
    __bad_percpu_size();
    }
    ldv_33967: 
#line 267
    pscr_ret__ = pfo_ret_____1;
#line 267
    goto ldv_33954;
    case 8UL: ;
#line 267
    switch (4UL) {
    case 1UL: 
#line 267
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 267
    goto ldv_33976;
    case 2UL: 
#line 267
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 267
    goto ldv_33976;
    case 4UL: 
#line 267
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 267
    goto ldv_33976;
    case 8UL: 
#line 267
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 267
    goto ldv_33976;
    default: 
#line 267
    __bad_percpu_size();
    }
    ldv_33976: 
#line 267
    pscr_ret__ = pfo_ret_____2;
#line 267
    goto ldv_33954;
    default: 
#line 267
    __bad_size_call_parameter();
#line 267
    goto ldv_33954;
    }
    ldv_33954: 
#line 267
    printk("\017GRU:%d %s: gms %p\n", pscr_ret__, "gru_release", gms);
  } else {

  }
#line 268
  return;
}
}
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
static struct mmu_notifier_ops  const  gru_mmuops  = 
#line 271
     {& gru_release, 0, 0, 0, & gru_invalidate_page, & gru_invalidate_range_start, & gru_invalidate_range_end,
    0};
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
static struct mmu_notifier *mmu_find_ops(struct mm_struct *mm , struct mmu_notifier_ops  const  *ops ) 
{ 
  struct mmu_notifier *mn ;
  struct mmu_notifier *gru_mn ;
  struct hlist_node *____ptr ;
  struct hlist_node *________p1 ;
  struct hlist_node *_________p1 ;
  union __anonunion___u_253 __u ;
  int tmp ;
  struct hlist_node  const  *__mptr ;
  struct mmu_notifier *tmp___0 ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node *________p1___0 ;
  struct hlist_node *_________p1___0 ;
  union __anonunion___u_255 __u___0 ;
  int tmp___1 ;
  struct hlist_node  const  *__mptr___0 ;
  struct mmu_notifier *tmp___2 ;

  {
#line 282
  gru_mn = (struct mmu_notifier *)0;
#line 284
  if ((unsigned long )mm->mmu_notifier_mm != (unsigned long )((struct mmu_notifier_mm *)0)) {
#line 285
    rcu_read_lock();
#line 286
    __read_once_size((void const volatile   *)(& (mm->mmu_notifier_mm)->list.first),
                     (void *)(& __u.__c), 8);
#line 286
    _________p1 = __u.__val;
#line 286
    ________p1 = _________p1;
#line 286
    tmp = debug_lockdep_rcu_enabled();
#line 286
    ____ptr = ________p1;
#line 286
    if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
#line 286
      __mptr = (struct hlist_node  const  *)____ptr;
#line 286
      tmp___0 = (struct mmu_notifier *)__mptr;
    } else {
#line 286
      tmp___0 = (struct mmu_notifier *)0;
    }
#line 286
    mn = tmp___0;
#line 286
    goto ldv_34042;
    ldv_34041: ;
#line 288
    if ((unsigned long )mn->ops == (unsigned long )ops) {
#line 289
      gru_mn = mn;
#line 290
      goto ldv_34040;
    } else {

    }
#line 286
    __read_once_size((void const volatile   *)(& mn->hlist.next), (void *)(& __u___0.__c),
                     8);
#line 286
    _________p1___0 = __u___0.__val;
#line 286
    ________p1___0 = _________p1___0;
#line 286
    tmp___1 = debug_lockdep_rcu_enabled();
#line 286
    ____ptr___0 = ________p1___0;
#line 286
    if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
#line 286
      __mptr___0 = (struct hlist_node  const  *)____ptr___0;
#line 286
      tmp___2 = (struct mmu_notifier *)__mptr___0;
    } else {
#line 286
      tmp___2 = (struct mmu_notifier *)0;
    }
#line 286
    mn = tmp___2;
    ldv_34042: ;
#line 286
    if ((unsigned long )mn != (unsigned long )((struct mmu_notifier *)0)) {
#line 288
      goto ldv_34041;
    } else {

    }
    ldv_34040: 
#line 292
    rcu_read_unlock();
  } else {

  }
#line 294
  return (gru_mn);
}
}
#line 297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
struct gru_mm_struct *gru_register_mmu_notifier(void) 
{ 
  struct gru_mm_struct *gms ;
  struct mmu_notifier *mn ;
  int err ;
  struct task_struct *tmp ;
  struct mmu_notifier  const  *__mptr ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  void *tmp___3 ;

  {
#line 303
  tmp = get_current();
#line 303
  mn = mmu_find_ops(tmp->mm, & gru_mmuops);
#line 304
  if ((unsigned long )mn != (unsigned long )((struct mmu_notifier *)0)) {
#line 305
    __mptr = (struct mmu_notifier  const  *)mn;
#line 305
    gms = (struct gru_mm_struct *)__mptr;
#line 306
    atomic_inc(& gms->ms_refcnt);
  } else {
#line 308
    tmp___0 = kzalloc(16840UL, 208U);
#line 308
    gms = (struct gru_mm_struct *)tmp___0;
#line 309
    if ((unsigned long )gms != (unsigned long )((struct gru_mm_struct *)0)) {
#line 310
      if ((gru_options & 2UL) != 0UL) {
#line 310
        atomic_long_inc(& gru_stats.gms_alloc);
      } else {

      }
#line 311
      spinlock_check(& gms->ms_asid_lock);
#line 311
      __raw_spin_lock_init(& gms->ms_asid_lock.__annonCompField17.rlock, "&(&gms->ms_asid_lock)->rlock",
                           & __key);
#line 312
      gms->ms_notifier.ops = & gru_mmuops;
#line 313
      atomic_set(& gms->ms_refcnt, 1);
#line 314
      __init_waitqueue_head(& gms->ms_wait_queue, "&gms->ms_wait_queue", & __key___0);
#line 315
      tmp___1 = get_current();
#line 315
      err = __mmu_notifier_register(& gms->ms_notifier, tmp___1->mm);
#line 316
      if (err != 0) {
#line 317
        goto error;
      } else {

      }
    } else {

    }
  }
#line 320
  if ((int )gru_options & 1) {
#line 320
    tmp___2 = atomic_read((atomic_t const   *)(& gms->ms_refcnt));
#line 320
    __vpp_verify = (void const   *)0;
#line 320
    switch (4UL) {
    case 1UL: ;
#line 321
    switch (4UL) {
    case 1UL: 
#line 321
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 321
    goto ldv_34059;
    case 2UL: 
#line 321
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 321
    goto ldv_34059;
    case 4UL: 
#line 321
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 321
    goto ldv_34059;
    case 8UL: 
#line 321
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 321
    goto ldv_34059;
    default: 
#line 321
    __bad_percpu_size();
    }
    ldv_34059: 
#line 321
    pscr_ret__ = pfo_ret__;
#line 321
    goto ldv_34065;
    case 2UL: ;
#line 321
    switch (4UL) {
    case 1UL: 
#line 321
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 321
    goto ldv_34069;
    case 2UL: 
#line 321
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 321
    goto ldv_34069;
    case 4UL: 
#line 321
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 321
    goto ldv_34069;
    case 8UL: 
#line 321
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 321
    goto ldv_34069;
    default: 
#line 321
    __bad_percpu_size();
    }
    ldv_34069: 
#line 321
    pscr_ret__ = pfo_ret_____0;
#line 321
    goto ldv_34065;
    case 4UL: ;
#line 321
    switch (4UL) {
    case 1UL: 
#line 321
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 321
    goto ldv_34078;
    case 2UL: 
#line 321
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 321
    goto ldv_34078;
    case 4UL: 
#line 321
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 321
    goto ldv_34078;
    case 8UL: 
#line 321
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 321
    goto ldv_34078;
    default: 
#line 321
    __bad_percpu_size();
    }
    ldv_34078: 
#line 321
    pscr_ret__ = pfo_ret_____1;
#line 321
    goto ldv_34065;
    case 8UL: ;
#line 321
    switch (4UL) {
    case 1UL: 
#line 321
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 321
    goto ldv_34087;
    case 2UL: 
#line 321
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 321
    goto ldv_34087;
    case 4UL: 
#line 321
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 321
    goto ldv_34087;
    case 8UL: 
#line 321
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 321
    goto ldv_34087;
    default: 
#line 321
    __bad_percpu_size();
    }
    ldv_34087: 
#line 321
    pscr_ret__ = pfo_ret_____2;
#line 321
    goto ldv_34065;
    default: 
#line 321
    __bad_size_call_parameter();
#line 321
    goto ldv_34065;
    }
    ldv_34065: 
#line 321
    printk("\017GRU:%d %s: gms %p, refcnt %d\n", pscr_ret__, "gru_register_mmu_notifier",
           gms, tmp___2);
  } else {

  }
#line 322
  return (gms);
  error: 
#line 324
  kfree((void const   *)gms);
#line 325
  tmp___3 = ERR_PTR((long )err);
#line 325
  return ((struct gru_mm_struct *)tmp___3);
}
}
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
void gru_drop_mmu_notifier(struct gru_mm_struct *gms ) 
{ 
  int tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;

  {
#line 330
  if ((int )gru_options & 1) {
#line 330
    tmp = atomic_read((atomic_t const   *)(& gms->ms_refcnt));
#line 330
    __vpp_verify = (void const   *)0;
#line 330
    switch (4UL) {
    case 1UL: ;
#line 331
    switch (4UL) {
    case 1UL: 
#line 331
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 331
    goto ldv_34104;
    case 2UL: 
#line 331
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 331
    goto ldv_34104;
    case 4UL: 
#line 331
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 331
    goto ldv_34104;
    case 8UL: 
#line 331
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 331
    goto ldv_34104;
    default: 
#line 331
    __bad_percpu_size();
    }
    ldv_34104: 
#line 331
    pscr_ret__ = pfo_ret__;
#line 331
    goto ldv_34110;
    case 2UL: ;
#line 331
    switch (4UL) {
    case 1UL: 
#line 331
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 331
    goto ldv_34114;
    case 2UL: 
#line 331
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 331
    goto ldv_34114;
    case 4UL: 
#line 331
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 331
    goto ldv_34114;
    case 8UL: 
#line 331
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 331
    goto ldv_34114;
    default: 
#line 331
    __bad_percpu_size();
    }
    ldv_34114: 
#line 331
    pscr_ret__ = pfo_ret_____0;
#line 331
    goto ldv_34110;
    case 4UL: ;
#line 331
    switch (4UL) {
    case 1UL: 
#line 331
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 331
    goto ldv_34123;
    case 2UL: 
#line 331
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 331
    goto ldv_34123;
    case 4UL: 
#line 331
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 331
    goto ldv_34123;
    case 8UL: 
#line 331
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 331
    goto ldv_34123;
    default: 
#line 331
    __bad_percpu_size();
    }
    ldv_34123: 
#line 331
    pscr_ret__ = pfo_ret_____1;
#line 331
    goto ldv_34110;
    case 8UL: ;
#line 331
    switch (4UL) {
    case 1UL: 
#line 331
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 331
    goto ldv_34132;
    case 2UL: 
#line 331
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 331
    goto ldv_34132;
    case 4UL: 
#line 331
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 331
    goto ldv_34132;
    case 8UL: 
#line 331
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 331
    goto ldv_34132;
    default: 
#line 331
    __bad_percpu_size();
    }
    ldv_34132: 
#line 331
    pscr_ret__ = pfo_ret_____2;
#line 331
    goto ldv_34110;
    default: 
#line 331
    __bad_size_call_parameter();
#line 331
    goto ldv_34110;
    }
    ldv_34110: 
#line 331
    printk("\017GRU:%d %s: gms %p, refcnt %d, released %d\n", pscr_ret__, "gru_drop_mmu_notifier",
           gms, tmp, (int )gms->ms_released);
  } else {

  }
#line 332
  tmp___1 = atomic_sub_return(1, & gms->ms_refcnt);
#line 332
  if (tmp___1 == 0) {
#line 333
    if ((int )((signed char )gms->ms_released) == 0) {
#line 334
      tmp___0 = get_current();
#line 334
      mmu_notifier_unregister(& gms->ms_notifier, tmp___0->mm);
    } else {

    }
#line 335
    kfree((void const   *)gms);
#line 336
    if ((gru_options & 2UL) != 0UL) {
#line 336
      atomic_long_inc(& gru_stats.gms_free);
    } else {

    }
  } else {

  }
#line 338
  return;
}
}
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.c"
void gru_tgh_flush_init(struct gru_state *gru ) 
{ 
  int cpus ;
  int shift ;
  int n ;
  int tmp ;
  int _max1 ;
  int _max2 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 356
  shift = 0;
#line 358
  cpus = uv_blade_nr_possible_cpus((int )gru->gs_blade_id);
#line 361
  if (cpus != 0) {
#line 362
    tmp = fls(cpus + -1);
#line 362
    n = 1 << tmp;
#line 370
    _max1 = 0;
#line 370
    tmp___0 = fls(n + -1);
#line 370
    tmp___1 = fls(15);
#line 370
    _max2 = tmp___0 - tmp___1;
#line 370
    shift = _max1 > _max2 ? _max1 : _max2;
  } else {

  }
#line 372
  gru->gs_tgh_local_shift = (unsigned char )shift;
#line 375
  gru->gs_tgh_first_remote = (unsigned char )((((1 << shift) + cpus) + -1) >> shift);
#line 376
  return;
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.o.c.prepared"
extern int ldv_probe_8(void) ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.o.c.prepared"
void ldv_initialize_mmu_notifier_ops_8(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 123
  tmp = ldv_init_zalloc(24UL);
#line 123
  gru_mmuops_group0 = (struct mmu_notifier *)tmp;
#line 124
  tmp___0 = ldv_init_zalloc(2296UL);
#line 124
  gru_mmuops_group1 = (struct mm_struct *)tmp___0;
#line 125
  return;
}
}
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.o.c.prepared"
void ldv_main_exported_8(void) 
{ 
  unsigned long ldvarg15 ;
  unsigned long ldvarg16 ;
  unsigned long ldvarg14 ;
  unsigned long ldvarg17 ;
  unsigned long ldvarg18 ;
  int tmp ;

  {
#line 128
  ldv_memset((void *)(& ldvarg15), 0, 8UL);
#line 129
  ldv_memset((void *)(& ldvarg16), 0, 8UL);
#line 130
  ldv_memset((void *)(& ldvarg14), 0, 8UL);
#line 131
  ldv_memset((void *)(& ldvarg17), 0, 8UL);
#line 132
  ldv_memset((void *)(& ldvarg18), 0, 8UL);
#line 134
  tmp = __VERIFIER_nondet_int();
#line 134
  switch (tmp) {
  case 0: ;
#line 137
  if (ldv_state_variable_8 == 2) {
#line 139
    gru_release(gru_mmuops_group0, gru_mmuops_group1);
#line 141
    ldv_state_variable_8 = 1;
#line 142
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 145
  goto ldv_34164;
  case 1: ;
#line 148
  if (ldv_state_variable_8 == 1) {
#line 150
    gru_invalidate_range_start(gru_mmuops_group0, gru_mmuops_group1, ldvarg18, ldvarg17);
#line 152
    ldv_state_variable_8 = 1;
  } else {

  }
#line 155
  if (ldv_state_variable_8 == 2) {
#line 157
    gru_invalidate_range_start(gru_mmuops_group0, gru_mmuops_group1, ldvarg18, ldvarg17);
#line 159
    ldv_state_variable_8 = 2;
  } else {

  }
#line 162
  goto ldv_34164;
  case 2: ;
#line 165
  if (ldv_state_variable_8 == 1) {
#line 167
    gru_invalidate_range_end(gru_mmuops_group0, gru_mmuops_group1, ldvarg16, ldvarg15);
#line 169
    ldv_state_variable_8 = 1;
  } else {

  }
#line 172
  if (ldv_state_variable_8 == 2) {
#line 174
    gru_invalidate_range_end(gru_mmuops_group0, gru_mmuops_group1, ldvarg16, ldvarg15);
#line 176
    ldv_state_variable_8 = 2;
  } else {

  }
#line 179
  goto ldv_34164;
  case 3: ;
#line 182
  if (ldv_state_variable_8 == 1) {
#line 184
    gru_invalidate_page(gru_mmuops_group0, gru_mmuops_group1, ldvarg14);
#line 186
    ldv_state_variable_8 = 1;
  } else {

  }
#line 189
  if (ldv_state_variable_8 == 2) {
#line 191
    gru_invalidate_page(gru_mmuops_group0, gru_mmuops_group1, ldvarg14);
#line 193
    ldv_state_variable_8 = 2;
  } else {

  }
#line 196
  goto ldv_34164;
  case 4: ;
#line 199
  if (ldv_state_variable_8 == 1) {
#line 201
    ldv_probe_8();
#line 203
    ldv_state_variable_8 = 2;
#line 204
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 207
  goto ldv_34164;
  default: 
#line 208
  ldv_stop();
  }
  ldv_34164: ;
#line 212
  return;
}
}
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.o.c.prepared"
void ldv_mutex_lock_89(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 240
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 242
  mutex_lock(ldv_func_arg1);
#line 243
  return;
}
}
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.o.c.prepared"
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 248
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 250
  mutex_unlock(ldv_func_arg1);
#line 251
  return;
}
}
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.o.c.prepared"
void ldv_mutex_lock_91(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 256
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 258
  mutex_lock(ldv_func_arg1);
#line 259
  return;
}
}
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.o.c.prepared"
int ldv_mutex_trylock_92(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 265
  tmp = mutex_trylock(ldv_func_arg1);
#line 265
  ldv_func_res = tmp;
#line 267
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 267
  return (tmp___0);
#line 269
  return (ldv_func_res);
}
}
#line 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.o.c.prepared"
void ldv_mutex_unlock_93(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 275
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 277
  mutex_unlock(ldv_func_arg1);
#line 278
  return;
}
}
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.o.c.prepared"
void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 283
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 285
  mutex_unlock(ldv_func_arg1);
#line 286
  return;
}
}
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grutlbpurge.o.c.prepared"
void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 291
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 293
  mutex_lock(ldv_func_arg1);
#line 294
  return;
}
}
#line 362 "include/linux/kernel.h"
extern int kstrtoul_from_user(char const   * , size_t  , unsigned int  , unsigned long * ) ;
#line 19 "./arch/x86/include/asm/atomic64_64.h"
__inline static long atomic64_read(atomic64_t const   *v ) 
{ 
  long __var ;

  {
#line 21
  __var = 0L;
#line 21
  return ((long )*((long const volatile   *)(& v->counter)));
}
}
#line 27 "include/asm-generic/atomic-long.h"
__inline static long atomic_long_read(atomic_long_t *l ) 
{ 
  atomic64_t *v ;
  long tmp ;

  {
#line 29
  v = l;
#line 31
  tmp = atomic64_read((atomic64_t const   *)v);
#line 31
  return (tmp);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_112(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_107(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_110(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_113(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_mutex_lock_108(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_109(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_111(struct mutex *ldv_func_arg1 ) ;
#line 109
void ldv_seq_operations_6(void) ;
#line 111
void ldv_file_operations_1(void) ;
#line 112
void ldv_file_operations_2(void) ;
#line 114
void ldv_file_operations_5(void) ;
#line 115
void ldv_seq_operations_7(void) ;
#line 117
void ldv_file_operations_4(void) ;
#line 19 "include/linux/proc_fs.h"
extern struct proc_dir_entry *proc_mkdir(char const   * , struct proc_dir_entry * ) ;
#line 25
extern struct proc_dir_entry *proc_create_data(char const   * , umode_t  , struct proc_dir_entry * ,
                                               struct file_operations  const  * ,
                                               void * ) ;
#line 30 "include/linux/proc_fs.h"
__inline static struct proc_dir_entry *proc_create(char const   *name , umode_t mode ,
                                                   struct proc_dir_entry *parent ,
                                                   struct file_operations  const  *proc_fops ) 
{ 
  struct proc_dir_entry *tmp ;

  {
#line 34
  tmp = proc_create_data(name, (int )mode, parent, proc_fops, (void *)0);
#line 34
  return (tmp);
}
}
#line 41
extern void proc_remove(struct proc_dir_entry * ) ;
#line 42
extern void remove_proc_entry(char const   * , struct proc_dir_entry * ) ;
#line 113 "include/linux/seq_file.h"
extern int seq_open(struct file * , struct seq_operations  const  * ) ;
#line 116
int ldv_seq_open_114(struct file *ldv_func_arg1 , struct seq_operations  const  *ldv_func_arg2 ) ;
#line 120
int ldv_seq_open_115(struct file *ldv_func_arg1 , struct seq_operations  const  *ldv_func_arg2 ) ;
#line 122
extern ssize_t seq_read(struct file * , char * , size_t  , loff_t * ) ;
#line 123
extern loff_t seq_lseek(struct file * , loff_t  , int  ) ;
#line 124
extern int seq_release(struct inode * , struct file * ) ;
#line 127
int ldv_seq_release_116(struct inode *ldv_func_arg1 , struct file *ldv_func_arg2 ) ;
#line 131
int ldv_seq_release_117(struct inode *ldv_func_arg1 , struct file *ldv_func_arg2 ) ;
#line 138
extern int seq_printf(struct seq_file * , char const   *  , ...) ;
#line 147
extern int single_open(struct file * , int (*)(struct seq_file * , void * ) , void * ) ;
#line 149
extern int single_release(struct inode * , struct file * ) ;
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
struct mcs_op_statistic mcs_op_statistics[8U] ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static void printstat_val(struct seq_file *s , atomic_long_t *v , char *id ) 
{ 
  unsigned long val ;
  long tmp ;

  {
#line 37
  tmp = atomic_long_read(v);
#line 37
  val = (unsigned long )tmp;
#line 39
  seq_printf(s, "%16lu %s\n", val, id);
#line 40
  return;
}
}
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static int statistics_show(struct seq_file *s , void *p ) 
{ 


  {
#line 44
  printstat_val(s, & gru_stats.vdata_alloc, (char *)"vdata_alloc");
#line 45
  printstat_val(s, & gru_stats.vdata_free, (char *)"vdata_free");
#line 46
  printstat_val(s, & gru_stats.gts_alloc, (char *)"gts_alloc");
#line 47
  printstat_val(s, & gru_stats.gts_free, (char *)"gts_free");
#line 48
  printstat_val(s, & gru_stats.gms_alloc, (char *)"gms_alloc");
#line 49
  printstat_val(s, & gru_stats.gms_free, (char *)"gms_free");
#line 50
  printstat_val(s, & gru_stats.gts_double_allocate, (char *)"gts_double_allocate");
#line 51
  printstat_val(s, & gru_stats.assign_context, (char *)"assign_context");
#line 52
  printstat_val(s, & gru_stats.assign_context_failed, (char *)"assign_context_failed");
#line 53
  printstat_val(s, & gru_stats.free_context, (char *)"free_context");
#line 54
  printstat_val(s, & gru_stats.load_user_context, (char *)"load_user_context");
#line 55
  printstat_val(s, & gru_stats.load_kernel_context, (char *)"load_kernel_context");
#line 56
  printstat_val(s, & gru_stats.lock_kernel_context, (char *)"lock_kernel_context");
#line 57
  printstat_val(s, & gru_stats.unlock_kernel_context, (char *)"unlock_kernel_context");
#line 58
  printstat_val(s, & gru_stats.steal_user_context, (char *)"steal_user_context");
#line 59
  printstat_val(s, & gru_stats.steal_kernel_context, (char *)"steal_kernel_context");
#line 60
  printstat_val(s, & gru_stats.steal_context_failed, (char *)"steal_context_failed");
#line 61
  printstat_val(s, & gru_stats.nopfn, (char *)"nopfn");
#line 62
  printstat_val(s, & gru_stats.asid_new, (char *)"asid_new");
#line 63
  printstat_val(s, & gru_stats.asid_next, (char *)"asid_next");
#line 64
  printstat_val(s, & gru_stats.asid_wrap, (char *)"asid_wrap");
#line 65
  printstat_val(s, & gru_stats.asid_reuse, (char *)"asid_reuse");
#line 66
  printstat_val(s, & gru_stats.intr, (char *)"intr");
#line 67
  printstat_val(s, & gru_stats.intr_cbr, (char *)"intr_cbr");
#line 68
  printstat_val(s, & gru_stats.intr_tfh, (char *)"intr_tfh");
#line 69
  printstat_val(s, & gru_stats.intr_spurious, (char *)"intr_spurious");
#line 70
  printstat_val(s, & gru_stats.intr_mm_lock_failed, (char *)"intr_mm_lock_failed");
#line 71
  printstat_val(s, & gru_stats.call_os, (char *)"call_os");
#line 72
  printstat_val(s, & gru_stats.call_os_wait_queue, (char *)"call_os_wait_queue");
#line 73
  printstat_val(s, & gru_stats.user_flush_tlb, (char *)"user_flush_tlb");
#line 74
  printstat_val(s, & gru_stats.user_unload_context, (char *)"user_unload_context");
#line 75
  printstat_val(s, & gru_stats.user_exception, (char *)"user_exception");
#line 76
  printstat_val(s, & gru_stats.set_context_option, (char *)"set_context_option");
#line 77
  printstat_val(s, & gru_stats.check_context_retarget_intr, (char *)"check_context_retarget_intr");
#line 78
  printstat_val(s, & gru_stats.check_context_unload, (char *)"check_context_unload");
#line 79
  printstat_val(s, & gru_stats.tlb_dropin, (char *)"tlb_dropin");
#line 80
  printstat_val(s, & gru_stats.tlb_preload_page, (char *)"tlb_preload_page");
#line 81
  printstat_val(s, & gru_stats.tlb_dropin_fail_no_asid, (char *)"tlb_dropin_fail_no_asid");
#line 82
  printstat_val(s, & gru_stats.tlb_dropin_fail_upm, (char *)"tlb_dropin_fail_upm");
#line 83
  printstat_val(s, & gru_stats.tlb_dropin_fail_invalid, (char *)"tlb_dropin_fail_invalid");
#line 84
  printstat_val(s, & gru_stats.tlb_dropin_fail_range_active, (char *)"tlb_dropin_fail_range_active");
#line 85
  printstat_val(s, & gru_stats.tlb_dropin_fail_idle, (char *)"tlb_dropin_fail_idle");
#line 86
  printstat_val(s, & gru_stats.tlb_dropin_fail_fmm, (char *)"tlb_dropin_fail_fmm");
#line 87
  printstat_val(s, & gru_stats.tlb_dropin_fail_no_exception, (char *)"tlb_dropin_fail_no_exception");
#line 88
  printstat_val(s, & gru_stats.tfh_stale_on_fault, (char *)"tfh_stale_on_fault");
#line 89
  printstat_val(s, & gru_stats.mmu_invalidate_range, (char *)"mmu_invalidate_range");
#line 90
  printstat_val(s, & gru_stats.mmu_invalidate_page, (char *)"mmu_invalidate_page");
#line 91
  printstat_val(s, & gru_stats.flush_tlb, (char *)"flush_tlb");
#line 92
  printstat_val(s, & gru_stats.flush_tlb_gru, (char *)"flush_tlb_gru");
#line 93
  printstat_val(s, & gru_stats.flush_tlb_gru_tgh, (char *)"flush_tlb_gru_tgh");
#line 94
  printstat_val(s, & gru_stats.flush_tlb_gru_zero_asid, (char *)"flush_tlb_gru_zero_asid");
#line 95
  printstat_val(s, & gru_stats.copy_gpa, (char *)"copy_gpa");
#line 96
  printstat_val(s, & gru_stats.read_gpa, (char *)"read_gpa");
#line 97
  printstat_val(s, & gru_stats.mesq_receive, (char *)"mesq_receive");
#line 98
  printstat_val(s, & gru_stats.mesq_receive_none, (char *)"mesq_receive_none");
#line 99
  printstat_val(s, & gru_stats.mesq_send, (char *)"mesq_send");
#line 100
  printstat_val(s, & gru_stats.mesq_send_failed, (char *)"mesq_send_failed");
#line 101
  printstat_val(s, & gru_stats.mesq_noop, (char *)"mesq_noop");
#line 102
  printstat_val(s, & gru_stats.mesq_send_unexpected_error, (char *)"mesq_send_unexpected_error");
#line 103
  printstat_val(s, & gru_stats.mesq_send_lb_overflow, (char *)"mesq_send_lb_overflow");
#line 104
  printstat_val(s, & gru_stats.mesq_send_qlimit_reached, (char *)"mesq_send_qlimit_reached");
#line 105
  printstat_val(s, & gru_stats.mesq_send_amo_nacked, (char *)"mesq_send_amo_nacked");
#line 106
  printstat_val(s, & gru_stats.mesq_send_put_nacked, (char *)"mesq_send_put_nacked");
#line 107
  printstat_val(s, & gru_stats.mesq_qf_locked, (char *)"mesq_qf_locked");
#line 108
  printstat_val(s, & gru_stats.mesq_qf_noop_not_full, (char *)"mesq_qf_noop_not_full");
#line 109
  printstat_val(s, & gru_stats.mesq_qf_switch_head_failed, (char *)"mesq_qf_switch_head_failed");
#line 110
  printstat_val(s, & gru_stats.mesq_qf_unexpected_error, (char *)"mesq_qf_unexpected_error");
#line 111
  printstat_val(s, & gru_stats.mesq_noop_unexpected_error, (char *)"mesq_noop_unexpected_error");
#line 112
  printstat_val(s, & gru_stats.mesq_noop_lb_overflow, (char *)"mesq_noop_lb_overflow");
#line 113
  printstat_val(s, & gru_stats.mesq_noop_qlimit_reached, (char *)"mesq_noop_qlimit_reached");
#line 114
  printstat_val(s, & gru_stats.mesq_noop_amo_nacked, (char *)"mesq_noop_amo_nacked");
#line 115
  printstat_val(s, & gru_stats.mesq_noop_put_nacked, (char *)"mesq_noop_put_nacked");
#line 116
  printstat_val(s, & gru_stats.mesq_noop_page_overflow, (char *)"mesq_noop_page_overflow");
#line 117
  return (0);
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static ssize_t statistics_write(struct file *file , char const   *userbuf , size_t count ,
                                loff_t *data ) 
{ 


  {
#line 123
  memset((void *)(& gru_stats), 0, 592UL);
#line 124
  return ((ssize_t )count);
}
}
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static int mcs_statistics_show(struct seq_file *s , void *p ) 
{ 
  int op ;
  unsigned long total ;
  unsigned long count ;
  unsigned long max ;
  char *id[8U] ;
  long tmp ;
  long tmp___0 ;

  {
#line 131
  id[0] = (char *)"cch_allocate";
#line 131
  id[1] = (char *)"cch_start";
#line 131
  id[2] = (char *)"cch_interrupt";
#line 131
  id[3] = (char *)"cch_interrupt_sync";
#line 131
  id[4] = (char *)"cch_deallocate";
#line 131
  id[5] = (char *)"tfh_write_only";
#line 131
  id[6] = (char *)"tfh_write_restart";
#line 131
  id[7] = (char *)"tgh_invalidate";
#line 135
  seq_printf(s, "%-20s%12s%12s%12s\n", (char *)"#id", (char *)"count", (char *)"aver-clks",
             (char *)"max-clks");
#line 136
  op = 0;
#line 136
  goto ldv_30803;
  ldv_30802: 
#line 137
  tmp = atomic_long_read(& mcs_op_statistics[op].count);
#line 137
  count = (unsigned long )tmp;
#line 138
  tmp___0 = atomic_long_read(& mcs_op_statistics[op].total);
#line 138
  total = (unsigned long )tmp___0;
#line 139
  max = mcs_op_statistics[op].max;
#line 140
  seq_printf(s, "%-20s%12ld%12ld%12ld\n", id[op], count, count != 0UL ? total / count : 0UL,
             max);
#line 136
  op = op + 1;
  ldv_30803: ;
#line 136
  if (op <= 7) {
#line 138
    goto ldv_30802;
  } else {

  }

#line 143
  return (0);
}
}
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static ssize_t mcs_statistics_write(struct file *file , char const   *userbuf , size_t count ,
                                    loff_t *data ) 
{ 


  {
#line 149
  memset((void *)(& mcs_op_statistics), 0, 192UL);
#line 150
  return ((ssize_t )count);
}
}
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static int options_show(struct seq_file *s , void *p ) 
{ 


  {
#line 155
  seq_printf(s, "#bitmask: 1=trace, 2=statistics\n");
#line 156
  seq_printf(s, "0x%lx\n", gru_options);
#line 157
  return (0);
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static ssize_t options_write(struct file *file , char const   *userbuf , size_t count ,
                             loff_t *data ) 
{ 
  int ret ;

  {
#line 165
  ret = kstrtoul_from_user(userbuf, count, 0U, & gru_options);
#line 166
  if (ret != 0) {
#line 167
    return ((ssize_t )ret);
  } else {

  }
#line 169
  return ((ssize_t )count);
}
}
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static int cch_seq_show(struct seq_file *file , void *data ) 
{ 
  long gid ;
  int i ;
  struct gru_state *gru ;
  struct gru_thread_state *ts ;
  char const   *mode[4U] ;
  int tmp ;
  int tmp___0 ;

  {
#line 174
  gid = *((long *)data);
#line 176
  gru = (unsigned long )gru_base[gid / 2L] != (unsigned long )((struct gru_blade_state *)0) ? (struct gru_state *)(& (gru_base[gid / 2L])->bs_grus) + (unsigned long )(gid % 2L) : (struct gru_state *)0;
#line 178
  mode[0] = "??";
#line 178
  mode[1] = "UPM";
#line 178
  mode[2] = "INTR";
#line 178
  mode[3] = "OS_POLL";
#line 180
  if (gid == 0L) {
#line 181
    seq_printf(file, "#%5s%5s%6s%7s%9s%6s%8s%8s\n", (char *)"gid", (char *)"bid",
               (char *)"ctx#", (char *)"asid", (char *)"pid", (char *)"cbrs", (char *)"dsbytes",
               (char *)"mode");
  } else {

  }
#line 183
  if ((unsigned long )gru != (unsigned long )((struct gru_state *)0)) {
#line 184
    i = 0;
#line 184
    goto ldv_30833;
    ldv_30832: 
#line 185
    ts = gru->gs_gts[i];
#line 186
    if ((unsigned long )ts == (unsigned long )((struct gru_thread_state *)0)) {
#line 187
      goto ldv_30831;
    } else {

    }
#line 188
    tmp = is_kernel_context(ts);
#line 188
    tmp___0 = is_kernel_context(ts);
#line 188
    seq_printf(file, " %5d%5d%6d%7d%9d%6d%8d%8s\n", (int )gru->gs_gid, (int )gru->gs_blade_id,
               i, tmp___0 == 0 ? (int )(ts->ts_gms)->ms_asids[gid].mt_asid : 0, tmp == 0 ? ts->ts_tgid_owner : 0,
               (int )ts->ts_cbr_au_count * 2, (int )ts->ts_cbr_au_count * 1024, mode[ts->ts_user_options & 3L]);
    ldv_30831: 
#line 184
    i = i + 1;
    ldv_30833: ;
#line 184
    if (i <= 15) {
#line 186
      goto ldv_30832;
    } else {

    }

  } else {

  }
#line 198
  return (0);
}
}
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static int gru_seq_show(struct seq_file *file , void *data ) 
{ 
  long gid ;
  long ctxfree ;
  long cbrfree ;
  long dsrfree ;
  struct gru_state *gru ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 203
  gid = *((long *)data);
#line 204
  gru = (unsigned long )gru_base[gid / 2L] != (unsigned long )((struct gru_blade_state *)0) ? (struct gru_state *)(& (gru_base[gid / 2L])->bs_grus) + (unsigned long )(gid % 2L) : (struct gru_state *)0;
#line 206
  if (gid == 0L) {
#line 207
    seq_printf(file, "#%5s%5s%7s%6s%6s%8s%6s%6s\n", (char *)"gid", (char *)"nid",
               (char *)"ctx", (char *)"cbr", (char *)"dsr", (char *)"ctx", (char *)"cbr",
               (char *)"dsr");
#line 209
    seq_printf(file, "#%5s%5s%7s%6s%6s%8s%6s%6s\n", (char *)"", (char *)"", (char *)"busy",
               (char *)"busy", (char *)"busy", (char *)"free", (char *)"free", (char *)"free");
  } else {

  }
#line 212
  if ((unsigned long )gru != (unsigned long )((struct gru_state *)0)) {
#line 213
    ctxfree = (long )(16 - (int )gru->gs_active_contexts);
#line 214
    tmp = __arch_hweight64((__u64 )gru->gs_cbr_map);
#line 214
    cbrfree = (long )(tmp * 2UL);
#line 215
    tmp___0 = __arch_hweight64((__u64 )gru->gs_dsr_map);
#line 215
    dsrfree = (long )(tmp___0 * 1024UL);
#line 216
    seq_printf(file, " %5d%5d%7ld%6ld%6ld%8ld%6ld%6ld\n", (int )gru->gs_gid, (int )gru->gs_blade_id,
               16L - ctxfree, 128L - cbrfree, 32768L - dsrfree, ctxfree, cbrfree,
               dsrfree);
  } else {

  }
#line 222
  return (0);
}
}
#line 225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static void seq_stop(struct seq_file *file , void *data ) 
{ 


  {
#line 227
  return;
}
}
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static void *seq_start(struct seq_file *file , loff_t *gid ) 
{ 


  {
#line 231
  if (*gid < (loff_t )gru_max_gids) {
#line 232
    return ((void *)gid);
  } else {

  }
#line 233
  return ((void *)0);
}
}
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static void *seq_next(struct seq_file *file , void *data , loff_t *gid ) 
{ 


  {
#line 238
  *gid = *gid + 1LL;
#line 239
  if (*gid < (loff_t )gru_max_gids) {
#line 240
    return ((void *)gid);
  } else {

  }
#line 241
  return ((void *)0);
}
}
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static struct seq_operations  const  cch_seq_ops  =    {& seq_start, & seq_stop, & seq_next, & cch_seq_show};
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static struct seq_operations  const  gru_seq_ops  =    {& seq_start, & seq_stop, & seq_next, & gru_seq_show};
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static int statistics_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
#line 260
  tmp = single_open(file, & statistics_show, (void *)0);
#line 260
  return (tmp);
}
}
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static int mcs_statistics_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
#line 265
  tmp = single_open(file, & mcs_statistics_show, (void *)0);
#line 265
  return (tmp);
}
}
#line 268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static int options_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
#line 270
  tmp = single_open(file, & options_show, (void *)0);
#line 270
  return (tmp);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static int cch_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
#line 275
  tmp = ldv_seq_open_114(file, & cch_seq_ops);
#line 275
  return (tmp);
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static int gru_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
#line 280
  tmp = ldv_seq_open_115(file, & gru_seq_ops);
#line 280
  return (tmp);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static struct file_operations  const  statistics_fops  = 
#line 284
     {0, & seq_lseek, & seq_read, & statistics_write, 0, 0, 0, 0, 0, 0, 0, 0, & statistics_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static struct file_operations  const  mcs_statistics_fops  = 
#line 292
     {0, & seq_lseek, & seq_read, & mcs_statistics_write, 0, 0, 0, 0, 0, 0, 0, 0, & mcs_statistics_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static struct file_operations  const  options_fops  = 
#line 300
     {0, & seq_lseek, & seq_read, & options_write, 0, 0, 0, 0, 0, 0, 0, 0, & options_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 308 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static struct file_operations  const  cch_fops  = 
#line 308
     {0, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, & cch_open, 0, & seq_release,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static struct file_operations  const  gru_fops___0  = 
#line 314
     {0, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, & gru_open, 0, & seq_release,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static struct proc_entry proc_files[6U]  = {      {(char *)"statistics", 420U, & statistics_fops, 0}, 
        {(char *)"mcs_statistics", 420U, & mcs_statistics_fops, 0}, 
        {(char *)"debug_options", 420U, & options_fops, 0}, 
        {(char *)"cch_status", 292U, & cch_fops, 0}, 
        {(char *)"gru_status", 292U, & gru_fops___0, 0}, 
        {(char *)0, (unsigned short)0, 0, 0}};
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static struct proc_dir_entry *proc_gru  ;
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static int create_proc_file(struct proc_entry *p ) 
{ 


  {
#line 340
  p->entry = proc_create((char const   *)p->name, (int )p->mode, proc_gru, p->fops);
#line 341
  if ((unsigned long )p->entry == (unsigned long )((struct proc_dir_entry *)0)) {
#line 342
    return (-1);
  } else {

  }
#line 343
  return (0);
}
}
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
static void delete_proc_files(void) 
{ 
  struct proc_entry *p ;

  {
#line 350
  if ((unsigned long )proc_gru != (unsigned long )((struct proc_dir_entry *)0)) {
#line 351
    p = (struct proc_entry *)(& proc_files);
#line 351
    goto ldv_30899;
    ldv_30898: ;
#line 352
    if ((unsigned long )p->entry != (unsigned long )((struct proc_dir_entry *)0)) {
#line 353
      remove_proc_entry((char const   *)p->name, proc_gru);
    } else {

    }
#line 351
    p = p + 1;
    ldv_30899: ;
#line 351
    if ((unsigned long )p->name != (unsigned long )((char *)0)) {
#line 353
      goto ldv_30898;
    } else {

    }
#line 354
    proc_remove(proc_gru);
  } else {

  }
#line 356
  return;
}
}
#line 358 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
int gru_proc_init(void) 
{ 
  struct proc_entry *p ;
  int tmp ;

  {
#line 362
  proc_gru = proc_mkdir("sgi_uv/gru", (struct proc_dir_entry *)0);
#line 364
  p = (struct proc_entry *)(& proc_files);
#line 364
  goto ldv_30907;
  ldv_30906: 
#line 365
  tmp = create_proc_file(p);
#line 365
  if (tmp != 0) {
#line 366
    goto err;
  } else {

  }
#line 364
  p = p + 1;
  ldv_30907: ;
#line 364
  if ((unsigned long )p->name != (unsigned long )((char *)0)) {
#line 366
    goto ldv_30906;
  } else {

  }

#line 367
  return (0);
  err: 
#line 370
  delete_proc_files();
#line 371
  return (-1);
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.c"
void gru_proc_exit(void) 
{ 


  {
#line 376
  delete_proc_files();
#line 377
  return;
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
int ldv_retval_10  ;
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
int ldv_retval_2  ;
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void *ldv_retval_0  ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
int ldv_retval_5  ;
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void *ldv_retval_4  ;
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void *ldv_retval_1  ;
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
int ldv_retval_6  ;
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void *ldv_retval_3  ;
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
int ldv_retval_7  ;
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_file_operations_3(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 131
  tmp = ldv_init_zalloc(1000UL);
#line 131
  options_fops_group1 = (struct inode *)tmp;
#line 132
  tmp___0 = ldv_init_zalloc(504UL);
#line 132
  options_fops_group2 = (struct file *)tmp___0;
#line 133
  return;
}
}
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_seq_operations_6(void) 
{ 
  void *tmp ;

  {
#line 137
  tmp = ldv_init_zalloc(256UL);
#line 137
  gru_seq_ops_group1 = (struct seq_file *)tmp;
#line 138
  return;
}
}
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_file_operations_1(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 142
  tmp = ldv_init_zalloc(1000UL);
#line 142
  gru_fops_group1 = (struct inode *)tmp;
#line 143
  tmp___0 = ldv_init_zalloc(504UL);
#line 143
  gru_fops_group2 = (struct file *)tmp___0;
#line 144
  return;
}
}
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_file_operations_2(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 148
  tmp = ldv_init_zalloc(1000UL);
#line 148
  cch_fops_group1 = (struct inode *)tmp;
#line 149
  tmp___0 = ldv_init_zalloc(504UL);
#line 149
  cch_fops_group2 = (struct file *)tmp___0;
#line 150
  return;
}
}
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_file_operations_5(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 154
  tmp = ldv_init_zalloc(1000UL);
#line 154
  statistics_fops_group1 = (struct inode *)tmp;
#line 155
  tmp___0 = ldv_init_zalloc(504UL);
#line 155
  statistics_fops_group2 = (struct file *)tmp___0;
#line 156
  return;
}
}
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_seq_operations_7(void) 
{ 
  void *tmp ;

  {
#line 160
  tmp = ldv_init_zalloc(256UL);
#line 160
  cch_seq_ops_group1 = (struct seq_file *)tmp;
#line 161
  return;
}
}
#line 164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_file_operations_4(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 165
  tmp = ldv_init_zalloc(1000UL);
#line 165
  mcs_statistics_fops_group1 = (struct inode *)tmp;
#line 166
  tmp___0 = ldv_init_zalloc(504UL);
#line 166
  mcs_statistics_fops_group2 = (struct file *)tmp___0;
#line 167
  return;
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_main_exported_6(void) 
{ 
  int tmp ;

  {
#line 172
  tmp = __VERIFIER_nondet_int();
#line 172
  switch (tmp) {
  case 0: ;
#line 175
  if (ldv_state_variable_6 == 1) {
#line 177
    ldv_retval_1 = seq_start(gru_seq_ops_group1, gru_seq_ops_group3);
#line 178
    if ((unsigned long )ldv_retval_1 == (unsigned long )((void *)0)) {
#line 179
      ldv_state_variable_6 = 3;
#line 180
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 182
    if ((unsigned long )ldv_retval_1 != (unsigned long )((void *)0)) {
#line 183
      ldv_state_variable_6 = 2;
#line 184
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 188
  goto ldv_30946;
  case 1: ;
#line 191
  if (ldv_state_variable_6 == 3) {
#line 193
    seq_stop(gru_seq_ops_group1, gru_seq_ops_group2);
#line 194
    ldv_state_variable_6 = 1;
#line 195
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 198
  if (ldv_state_variable_6 == 2) {
#line 200
    seq_stop(gru_seq_ops_group1, gru_seq_ops_group2);
#line 201
    ldv_state_variable_6 = 1;
#line 202
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 205
  goto ldv_30946;
  case 2: ;
#line 208
  if (ldv_state_variable_6 == 3) {
#line 210
    gru_seq_show(gru_seq_ops_group1, (void *)gru_seq_ops_group3);
#line 212
    ldv_state_variable_6 = 3;
  } else {

  }
#line 215
  goto ldv_30946;
  case 3: ;
#line 218
  if (ldv_state_variable_6 == 3) {
#line 220
    ldv_retval_0 = seq_next(gru_seq_ops_group1, gru_seq_ops_group2, gru_seq_ops_group3);
#line 221
    if ((unsigned long )ldv_retval_0 == (unsigned long )((void *)0)) {
#line 222
      ldv_state_variable_6 = 3;
#line 223
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 225
    if ((unsigned long )ldv_retval_0 != (unsigned long )((void *)0)) {
#line 226
      ldv_state_variable_6 = 2;
#line 227
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 231
  goto ldv_30946;
  default: 
#line 232
  ldv_stop();
  }
  ldv_30946: ;
#line 236
  return;
}
}
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_main_exported_4(void) 
{ 
  char *ldvarg28 ;
  void *tmp ;
  loff_t *ldvarg29 ;
  void *tmp___0 ;
  loff_t ldvarg25 ;
  size_t ldvarg30 ;
  char *ldvarg31 ;
  void *tmp___1 ;
  loff_t *ldvarg26 ;
  void *tmp___2 ;
  size_t ldvarg27 ;
  int ldvarg24 ;
  int tmp___3 ;

  {
#line 239
  tmp = ldv_init_zalloc(1UL);
#line 239
  ldvarg28 = (char *)tmp;
#line 240
  tmp___0 = ldv_init_zalloc(8UL);
#line 240
  ldvarg29 = (loff_t *)tmp___0;
#line 243
  tmp___1 = ldv_init_zalloc(1UL);
#line 243
  ldvarg31 = (char *)tmp___1;
#line 244
  tmp___2 = ldv_init_zalloc(8UL);
#line 244
  ldvarg26 = (loff_t *)tmp___2;
#line 241
  ldv_memset((void *)(& ldvarg25), 0, 8UL);
#line 242
  ldv_memset((void *)(& ldvarg30), 0, 8UL);
#line 245
  ldv_memset((void *)(& ldvarg27), 0, 8UL);
#line 246
  ldv_memset((void *)(& ldvarg24), 0, 4UL);
#line 248
  tmp___3 = __VERIFIER_nondet_int();
#line 248
  switch (tmp___3) {
  case 0: ;
#line 251
  if (ldv_state_variable_4 == 1) {
#line 253
    mcs_statistics_write(mcs_statistics_fops_group2, (char const   *)ldvarg31, ldvarg30,
                         ldvarg29);
#line 255
    ldv_state_variable_4 = 1;
  } else {

  }
#line 258
  if (ldv_state_variable_4 == 2) {
#line 260
    mcs_statistics_write(mcs_statistics_fops_group2, (char const   *)ldvarg31, ldvarg30,
                         ldvarg29);
#line 262
    ldv_state_variable_4 = 2;
  } else {

  }
#line 265
  goto ldv_30963;
  case 1: ;
#line 268
  if (ldv_state_variable_4 == 2) {
#line 270
    single_release(mcs_statistics_fops_group1, mcs_statistics_fops_group2);
#line 271
    ldv_state_variable_4 = 1;
#line 272
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 275
  goto ldv_30963;
  case 2: ;
#line 278
  if (ldv_state_variable_4 == 2) {
#line 280
    seq_read(mcs_statistics_fops_group2, ldvarg28, ldvarg27, ldvarg26);
#line 282
    ldv_state_variable_4 = 2;
  } else {

  }
#line 285
  goto ldv_30963;
  case 3: ;
#line 288
  if (ldv_state_variable_4 == 2) {
#line 290
    seq_lseek(mcs_statistics_fops_group2, ldvarg25, ldvarg24);
#line 292
    ldv_state_variable_4 = 2;
  } else {

  }
#line 295
  goto ldv_30963;
  case 4: ;
#line 298
  if (ldv_state_variable_4 == 1) {
#line 300
    ldv_retval_7 = mcs_statistics_open(mcs_statistics_fops_group1, mcs_statistics_fops_group2);
#line 301
    if (ldv_retval_7 == 0) {
#line 302
      ldv_state_variable_4 = 2;
#line 303
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 307
  goto ldv_30963;
  default: 
#line 308
  ldv_stop();
  }
  ldv_30963: ;
#line 312
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_main_exported_1(void) 
{ 
  int ldvarg19 ;
  size_t ldvarg22 ;
  char *ldvarg23 ;
  void *tmp ;
  loff_t ldvarg20 ;
  loff_t *ldvarg21 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 317
  tmp = ldv_init_zalloc(1UL);
#line 317
  ldvarg23 = (char *)tmp;
#line 319
  tmp___0 = ldv_init_zalloc(8UL);
#line 319
  ldvarg21 = (loff_t *)tmp___0;
#line 315
  ldv_memset((void *)(& ldvarg19), 0, 4UL);
#line 316
  ldv_memset((void *)(& ldvarg22), 0, 8UL);
#line 318
  ldv_memset((void *)(& ldvarg20), 0, 8UL);
#line 321
  tmp___1 = __VERIFIER_nondet_int();
#line 321
  switch (tmp___1) {
  case 0: ;
#line 324
  if (ldv_state_variable_1 == 2) {
#line 326
    ldv_seq_release_116(gru_fops_group1, gru_fops_group2);
#line 327
    ldv_state_variable_1 = 1;
#line 328
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 331
  goto ldv_30978;
  case 1: ;
#line 334
  if (ldv_state_variable_1 == 2) {
#line 336
    seq_read(gru_fops_group2, ldvarg23, ldvarg22, ldvarg21);
#line 338
    ldv_state_variable_1 = 2;
  } else {

  }
#line 341
  goto ldv_30978;
  case 2: ;
#line 344
  if (ldv_state_variable_1 == 2) {
#line 346
    seq_lseek(gru_fops_group2, ldvarg20, ldvarg19);
#line 348
    ldv_state_variable_1 = 2;
  } else {

  }
#line 351
  goto ldv_30978;
  case 3: ;
#line 354
  if (ldv_state_variable_1 == 1) {
#line 356
    ldv_retval_6 = gru_open(gru_fops_group1, gru_fops_group2);
#line 357
    if (ldv_retval_6 == 0) {
#line 358
      ldv_state_variable_1 = 2;
#line 359
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 363
  goto ldv_30978;
  default: 
#line 364
  ldv_stop();
  }
  ldv_30978: ;
#line 368
  return;
}
}
#line 370 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_main_exported_3(void) 
{ 
  loff_t *ldvarg2 ;
  void *tmp ;
  char *ldvarg4 ;
  void *tmp___0 ;
  loff_t ldvarg1 ;
  size_t ldvarg6 ;
  loff_t *ldvarg5 ;
  void *tmp___1 ;
  int ldvarg0 ;
  size_t ldvarg3 ;
  char *ldvarg7 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 371
  tmp = ldv_init_zalloc(8UL);
#line 371
  ldvarg2 = (loff_t *)tmp;
#line 372
  tmp___0 = ldv_init_zalloc(1UL);
#line 372
  ldvarg4 = (char *)tmp___0;
#line 375
  tmp___1 = ldv_init_zalloc(8UL);
#line 375
  ldvarg5 = (loff_t *)tmp___1;
#line 378
  tmp___2 = ldv_init_zalloc(1UL);
#line 378
  ldvarg7 = (char *)tmp___2;
#line 373
  ldv_memset((void *)(& ldvarg1), 0, 8UL);
#line 374
  ldv_memset((void *)(& ldvarg6), 0, 8UL);
#line 376
  ldv_memset((void *)(& ldvarg0), 0, 4UL);
#line 377
  ldv_memset((void *)(& ldvarg3), 0, 8UL);
#line 380
  tmp___3 = __VERIFIER_nondet_int();
#line 380
  switch (tmp___3) {
  case 0: ;
#line 383
  if (ldv_state_variable_3 == 1) {
#line 385
    options_write(options_fops_group2, (char const   *)ldvarg7, ldvarg6, ldvarg5);
#line 387
    ldv_state_variable_3 = 1;
  } else {

  }
#line 390
  if (ldv_state_variable_3 == 2) {
#line 392
    options_write(options_fops_group2, (char const   *)ldvarg7, ldvarg6, ldvarg5);
#line 394
    ldv_state_variable_3 = 2;
  } else {

  }
#line 397
  goto ldv_30995;
  case 1: ;
#line 400
  if (ldv_state_variable_3 == 2) {
#line 402
    single_release(options_fops_group1, options_fops_group2);
#line 403
    ldv_state_variable_3 = 1;
#line 404
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 407
  goto ldv_30995;
  case 2: ;
#line 410
  if (ldv_state_variable_3 == 2) {
#line 412
    seq_read(options_fops_group2, ldvarg4, ldvarg3, ldvarg2);
#line 414
    ldv_state_variable_3 = 2;
  } else {

  }
#line 417
  goto ldv_30995;
  case 3: ;
#line 420
  if (ldv_state_variable_3 == 2) {
#line 422
    seq_lseek(options_fops_group2, ldvarg1, ldvarg0);
#line 424
    ldv_state_variable_3 = 2;
  } else {

  }
#line 427
  goto ldv_30995;
  case 4: ;
#line 430
  if (ldv_state_variable_3 == 1) {
#line 432
    ldv_retval_2 = options_open(options_fops_group1, options_fops_group2);
#line 433
    if (ldv_retval_2 == 0) {
#line 434
      ldv_state_variable_3 = 2;
#line 435
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 439
  goto ldv_30995;
  default: 
#line 440
  ldv_stop();
  }
  ldv_30995: ;
#line 444
  return;
}
}
#line 446 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_main_exported_7(void) 
{ 
  int tmp ;

  {
#line 448
  tmp = __VERIFIER_nondet_int();
#line 448
  switch (tmp) {
  case 0: ;
#line 451
  if (ldv_state_variable_7 == 1) {
#line 453
    ldv_retval_4 = seq_start(cch_seq_ops_group1, cch_seq_ops_group3);
#line 454
    if ((unsigned long )ldv_retval_4 == (unsigned long )((void *)0)) {
#line 455
      ldv_state_variable_7 = 3;
#line 456
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 458
    if ((unsigned long )ldv_retval_4 != (unsigned long )((void *)0)) {
#line 459
      ldv_state_variable_7 = 2;
#line 460
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 464
  goto ldv_31005;
  case 1: ;
#line 467
  if (ldv_state_variable_7 == 3) {
#line 469
    seq_stop(cch_seq_ops_group1, cch_seq_ops_group2);
#line 470
    ldv_state_variable_7 = 1;
#line 471
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 474
  if (ldv_state_variable_7 == 2) {
#line 476
    seq_stop(cch_seq_ops_group1, cch_seq_ops_group2);
#line 477
    ldv_state_variable_7 = 1;
#line 478
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 481
  goto ldv_31005;
  case 2: ;
#line 484
  if (ldv_state_variable_7 == 3) {
#line 486
    cch_seq_show(cch_seq_ops_group1, (void *)cch_seq_ops_group3);
#line 488
    ldv_state_variable_7 = 3;
  } else {

  }
#line 491
  goto ldv_31005;
  case 3: ;
#line 494
  if (ldv_state_variable_7 == 3) {
#line 496
    ldv_retval_3 = seq_next(cch_seq_ops_group1, cch_seq_ops_group2, cch_seq_ops_group3);
#line 497
    if ((unsigned long )ldv_retval_3 == (unsigned long )((void *)0)) {
#line 498
      ldv_state_variable_7 = 3;
#line 499
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 501
    if ((unsigned long )ldv_retval_3 != (unsigned long )((void *)0)) {
#line 502
      ldv_state_variable_7 = 2;
#line 503
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 507
  goto ldv_31005;
  default: 
#line 508
  ldv_stop();
  }
  ldv_31005: ;
#line 512
  return;
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_main_exported_2(void) 
{ 
  int ldvarg9 ;
  size_t ldvarg12 ;
  loff_t ldvarg10 ;
  char *ldvarg13 ;
  void *tmp ;
  loff_t *ldvarg11 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 518
  tmp = ldv_init_zalloc(1UL);
#line 518
  ldvarg13 = (char *)tmp;
#line 519
  tmp___0 = ldv_init_zalloc(8UL);
#line 519
  ldvarg11 = (loff_t *)tmp___0;
#line 515
  ldv_memset((void *)(& ldvarg9), 0, 4UL);
#line 516
  ldv_memset((void *)(& ldvarg12), 0, 8UL);
#line 517
  ldv_memset((void *)(& ldvarg10), 0, 8UL);
#line 521
  tmp___1 = __VERIFIER_nondet_int();
#line 521
  switch (tmp___1) {
  case 0: ;
#line 524
  if (ldv_state_variable_2 == 2) {
#line 526
    ldv_seq_release_117(cch_fops_group1, cch_fops_group2);
#line 527
    ldv_state_variable_2 = 1;
#line 528
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 531
  goto ldv_31019;
  case 1: ;
#line 534
  if (ldv_state_variable_2 == 2) {
#line 536
    seq_read(cch_fops_group2, ldvarg13, ldvarg12, ldvarg11);
#line 538
    ldv_state_variable_2 = 2;
  } else {

  }
#line 541
  goto ldv_31019;
  case 2: ;
#line 544
  if (ldv_state_variable_2 == 2) {
#line 546
    seq_lseek(cch_fops_group2, ldvarg10, ldvarg9);
#line 548
    ldv_state_variable_2 = 2;
  } else {

  }
#line 551
  goto ldv_31019;
  case 3: ;
#line 554
  if (ldv_state_variable_2 == 1) {
#line 556
    ldv_retval_5 = cch_open(cch_fops_group1, cch_fops_group2);
#line 557
    if (ldv_retval_5 == 0) {
#line 558
      ldv_state_variable_2 = 2;
#line 559
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 563
  goto ldv_31019;
  default: 
#line 564
  ldv_stop();
  }
  ldv_31019: ;
#line 568
  return;
}
}
#line 570 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_main_exported_5(void) 
{ 
  char *ldvarg44 ;
  void *tmp ;
  size_t ldvarg40 ;
  int ldvarg37 ;
  loff_t ldvarg38 ;
  loff_t *ldvarg42 ;
  void *tmp___0 ;
  size_t ldvarg43 ;
  char *ldvarg41 ;
  void *tmp___1 ;
  loff_t *ldvarg39 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 571
  tmp = ldv_init_zalloc(1UL);
#line 571
  ldvarg44 = (char *)tmp;
#line 575
  tmp___0 = ldv_init_zalloc(8UL);
#line 575
  ldvarg42 = (loff_t *)tmp___0;
#line 577
  tmp___1 = ldv_init_zalloc(1UL);
#line 577
  ldvarg41 = (char *)tmp___1;
#line 578
  tmp___2 = ldv_init_zalloc(8UL);
#line 578
  ldvarg39 = (loff_t *)tmp___2;
#line 572
  ldv_memset((void *)(& ldvarg40), 0, 8UL);
#line 573
  ldv_memset((void *)(& ldvarg37), 0, 4UL);
#line 574
  ldv_memset((void *)(& ldvarg38), 0, 8UL);
#line 576
  ldv_memset((void *)(& ldvarg43), 0, 8UL);
#line 580
  tmp___3 = __VERIFIER_nondet_int();
#line 580
  switch (tmp___3) {
  case 0: ;
#line 583
  if (ldv_state_variable_5 == 1) {
#line 585
    statistics_write(statistics_fops_group2, (char const   *)ldvarg44, ldvarg43, ldvarg42);
#line 587
    ldv_state_variable_5 = 1;
  } else {

  }
#line 590
  if (ldv_state_variable_5 == 2) {
#line 592
    statistics_write(statistics_fops_group2, (char const   *)ldvarg44, ldvarg43, ldvarg42);
#line 594
    ldv_state_variable_5 = 2;
  } else {

  }
#line 597
  goto ldv_31036;
  case 1: ;
#line 600
  if (ldv_state_variable_5 == 2) {
#line 602
    single_release(statistics_fops_group1, statistics_fops_group2);
#line 603
    ldv_state_variable_5 = 1;
#line 604
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 607
  goto ldv_31036;
  case 2: ;
#line 610
  if (ldv_state_variable_5 == 2) {
#line 612
    seq_read(statistics_fops_group2, ldvarg41, ldvarg40, ldvarg39);
#line 614
    ldv_state_variable_5 = 2;
  } else {

  }
#line 617
  goto ldv_31036;
  case 3: ;
#line 620
  if (ldv_state_variable_5 == 2) {
#line 622
    seq_lseek(statistics_fops_group2, ldvarg38, ldvarg37);
#line 624
    ldv_state_variable_5 = 2;
  } else {

  }
#line 627
  goto ldv_31036;
  case 4: ;
#line 630
  if (ldv_state_variable_5 == 1) {
#line 632
    ldv_retval_10 = statistics_open(statistics_fops_group1, statistics_fops_group2);
#line 633
    if (ldv_retval_10 == 0) {
#line 634
      ldv_state_variable_5 = 2;
#line 635
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 639
  goto ldv_31036;
  default: 
#line 640
  ldv_stop();
  }
  ldv_31036: ;
#line 644
  return;
}
}
#line 669 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_mutex_unlock_107(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 672
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 674
  mutex_unlock(ldv_func_arg1);
#line 675
  return;
}
}
#line 677 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_mutex_lock_108(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 680
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 682
  mutex_lock(ldv_func_arg1);
#line 683
  return;
}
}
#line 685 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_mutex_lock_109(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 688
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 690
  mutex_lock(ldv_func_arg1);
#line 691
  return;
}
}
#line 693 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_mutex_unlock_110(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 696
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 698
  mutex_unlock(ldv_func_arg1);
#line 699
  return;
}
}
#line 701 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_mutex_lock_111(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 704
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 706
  mutex_lock(ldv_func_arg1);
#line 707
  return;
}
}
#line 709 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
int ldv_mutex_trylock_112(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 713
  tmp = mutex_trylock(ldv_func_arg1);
#line 713
  ldv_func_res = tmp;
#line 715
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 715
  return (tmp___0);
#line 717
  return (ldv_func_res);
}
}
#line 720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
void ldv_mutex_unlock_113(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 723
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 725
  mutex_unlock(ldv_func_arg1);
#line 726
  return;
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
int ldv_seq_open_114(struct file *ldv_func_arg1 , struct seq_operations  const  *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 732
  tmp = seq_open(ldv_func_arg1, ldv_func_arg2);
#line 732
  ldv_func_res = tmp;
#line 734
  if (ldv_func_res == 0) {
#line 735
    ldv_state_variable_6 = 1;
#line 736
    ldv_seq_operations_6();
  } else {

  }
#line 740
  return (ldv_func_res);
}
}
#line 743 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
int ldv_seq_open_115(struct file *ldv_func_arg1 , struct seq_operations  const  *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;

  {
#line 747
  tmp = seq_open(ldv_func_arg1, ldv_func_arg2);
#line 747
  ldv_func_res = tmp;
#line 749
  if (ldv_func_res == 0) {
#line 750
    ldv_state_variable_6 = 1;
#line 751
    ldv_seq_operations_6();
  } else {

  }
#line 755
  return (ldv_func_res);
}
}
#line 758 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
int ldv_seq_release_116(struct inode *ldv_func_arg1 , struct file *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 762
  tmp = seq_release(ldv_func_arg1, ldv_func_arg2);
#line 762
  ldv_func_res = tmp;
#line 764
  ldv_state_variable_6 = 0;
#line 766
  return (ldv_func_res);
}
}
#line 769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruprocfs.o.c.prepared"
int ldv_seq_release_117(struct inode *ldv_func_arg1 , struct file *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 773
  tmp = seq_release(ldv_func_arg1, ldv_func_arg2);
#line 773
  ldv_func_res = tmp;
#line 775
  ldv_state_variable_6 = 0;
#line 777
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 256 "include/linux/kernel.h"
extern void panic(char const   *  , ...) ;
#line 405
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 23 "./arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 63 "./arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 177 "./arch/x86/include/asm/paravirt.h"
__inline static u64 paravirt_read_tsc___0(void) 
{ 
  u64 __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 179
  __edi = __edi;
#line 179
  __esi = __esi;
#line 179
  __edx = __edx;
#line 179
  __ecx = __ecx;
#line 179
  __eax = __eax;
#line 179
  tmp = ldv__builtin_expect((unsigned long )pv_cpu_ops.read_tsc == (unsigned long )((u64 (*)(void))0),
                         0L);
#line 179
  if (tmp != 0L) {
#line 179
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (179), "i" (12UL));
    ldv_4012: ;
#line 179
    goto ldv_4012;
  } else {

  }
#line 179
  __asm__  volatile   ("771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n": "=D" (__edi),
                       "=S" (__esi), "=d" (__edx), "=c" (__ecx), "=a" (__eax): [paravirt_typenum] "i" (34UL),
                       [paravirt_opptr] "i" (& pv_cpu_ops.read_tsc), [paravirt_clobber] "i" (511): "memory",
                       "cc", "r8", "r9", "r10", "r11");
#line 179
  __ret = (unsigned long long )__eax;
#line 179
  return (__ret);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_136(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_134(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_137(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.o.c.prepared"
void ldv_mutex_lock_133(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_135(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_139(struct mutex *ldv_func_arg1 ) ;
#line 91 "include/linux/completion.h"
extern void wait_for_completion(struct completion * ) ;
#line 22 "./arch/x86/include/asm/tsc.h"
__inline static cycles_t get_cycles___0(void) 
{ 
  unsigned long long ret ;

  {
#line 24
  ret = 0ULL;
#line 30
  ret = paravirt_read_tsc___0();
#line 32
  return (ret);
}
}
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 22 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
int gru_check_status_proc(void *cb ) ;
#line 23
int gru_wait_proc(void *cb ) ;
#line 24
void gru_wait_abort_proc(void *cb ) ;
#line 313 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static unsigned long __opdword(unsigned char opcode , unsigned char exopc ,
                                        unsigned char xtype , unsigned char iaa0 ,
                                        unsigned char iaa1 , unsigned long idef2 ,
                                        unsigned char ima ) 
{ 


  {
#line 317
  return ((((((((idef2 << 32) | (unsigned long )((int )iaa0 << 11)) | (unsigned long )((int )iaa1 << 13)) | (unsigned long )((int )ima << 1)) | (unsigned long )((int )xtype << 8)) | (unsigned long )((int )opcode << 16)) | (unsigned long )((int )exopc << 24)) | 144115188075855873UL);
}
}
#line 340 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_start_instruction(struct gru_instruction *ins , unsigned long op64 ) 
{ 


  {
#line 342
  __asm__  volatile   ("": : : "memory");
#line 342
  *((unsigned long *)ins) = op64;
#line 343
  __asm__  volatile   ("mfence": : : "memory");
#line 344
  gru_flush_cache((void *)ins);
#line 345
  return;
}
}
#line 359 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_vload_phys(void *cb , unsigned long gpa , unsigned int tri0 ,
                                    int iaa , unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
#line 362
  ins = (struct gru_instruction *)cb;
#line 364
  ins->baddr0 = ((unsigned long )iaa << 62) | gpa;
#line 365
  ins->nelem = 1UL;
#line 366
  ins->op1_stride = 1UL;
#line 367
  tmp = __opdword(2, 0, 3, (int )((unsigned char )iaa), 0, (unsigned long )tri0, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 367
  gru_start_instruction(ins, tmp);
#line 369
  return;
}
}
#line 371 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_vstore_phys(void *cb , unsigned long gpa , unsigned int tri0 ,
                                     int iaa , unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
#line 374
  ins = (struct gru_instruction *)cb;
#line 376
  ins->baddr0 = ((unsigned long )iaa << 62) | gpa;
#line 377
  ins->nelem = 1UL;
#line 378
  ins->op1_stride = 1UL;
#line 379
  tmp = __opdword(4, 0, 3, (int )((unsigned char )iaa), 0, (unsigned long )tri0, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 379
  gru_start_instruction(ins, tmp);
#line 381
  return;
}
}
#line 383 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_vload(void *cb , unsigned long mem_addr , unsigned int tri0 ,
                               unsigned char xtype , unsigned long nelem , unsigned long stride ,
                               unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
#line 387
  ins = (struct gru_instruction *)cb;
#line 389
  ins->baddr0 = mem_addr;
#line 390
  ins->nelem = nelem;
#line 391
  ins->op1_stride = stride;
#line 392
  tmp = __opdword(2, 0, (int )xtype, 0, 0, (unsigned long )tri0, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 392
  gru_start_instruction(ins, tmp);
#line 394
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_vstore(void *cb , unsigned long mem_addr , unsigned int tri0 ,
                                unsigned char xtype , unsigned long nelem , unsigned long stride ,
                                unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
#line 400
  ins = (struct gru_instruction *)cb;
#line 402
  ins->baddr0 = mem_addr;
#line 403
  ins->nelem = nelem;
#line 404
  ins->op1_stride = stride;
#line 405
  tmp = __opdword(4, 0, (int )xtype, 0, 0, (unsigned long )tri0, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 405
  gru_start_instruction(ins, tmp);
#line 406
  return;
}
}
#line 435 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_vset(void *cb , unsigned long mem_addr , unsigned long value ,
                              unsigned char xtype , unsigned long nelem , unsigned long stride ,
                              unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
#line 439
  ins = (struct gru_instruction *)cb;
#line 441
  ins->baddr0 = mem_addr;
#line 442
  ins->op2_value_baddr1 = value;
#line 443
  ins->nelem = nelem;
#line 444
  ins->op1_stride = stride;
#line 445
  tmp = __opdword(6, 0, (int )xtype, 0, 0, 0UL, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 445
  gru_start_instruction(ins, tmp);
#line 446
  return;
}
}
#line 484 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_bcopy(void *cb , unsigned long const   src , unsigned long dest ,
                               unsigned int tri0 , unsigned int xtype , unsigned long nelem ,
                               unsigned int bufsize , unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
#line 489
  ins = (struct gru_instruction *)cb;
#line 491
  ins->baddr0 = (unsigned long )src;
#line 492
  ins->op2_value_baddr1 = dest;
#line 493
  ins->nelem = nelem;
#line 494
  ins->tri1_bufsize = (unsigned long )bufsize;
#line 495
  tmp = __opdword(1, 0, (int )((unsigned char )xtype), 0, 0, (unsigned long )tri0,
                  (int )((unsigned int )((unsigned char )hints) | 2U));
#line 495
  gru_start_instruction(ins, tmp);
#line 496
  return;
}
}
#line 512 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_gamir(void *cb , int exopc , unsigned long src , unsigned int xtype ,
                               unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
#line 515
  ins = (struct gru_instruction *)cb;
#line 517
  ins->baddr0 = src;
#line 518
  tmp = __opdword(10, (int )((unsigned char )exopc), (int )((unsigned char )xtype),
                  0, 0, 0UL, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 518
  gru_start_instruction(ins, tmp);
#line 519
  return;
}
}
#line 532 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_gamer(void *cb , int exopc , unsigned long src , unsigned int xtype ,
                               unsigned long operand1 , unsigned long operand2 , unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
#line 537
  ins = (struct gru_instruction *)cb;
#line 539
  ins->baddr0 = src;
#line 540
  ins->op1_stride = operand1;
#line 541
  ins->op2_value_baddr1 = operand2;
#line 542
  tmp = __opdword(12, (int )((unsigned char )exopc), (int )((unsigned char )xtype),
                  0, 0, 0UL, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 542
  gru_start_instruction(ins, tmp);
#line 543
  return;
}
}
#line 570 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_mesq(void *cb , unsigned long queue , unsigned long tri0 ,
                              unsigned long nelem , unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
#line 574
  ins = (struct gru_instruction *)cb;
#line 576
  ins->baddr0 = queue;
#line 577
  ins->nelem = nelem;
#line 578
  tmp = __opdword(8, 0, 6, 0, 0, tri0, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 578
  gru_start_instruction(ins, tmp);
#line 579
  return;
}
}
#line 582 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static unsigned long gru_get_amo_value(void *cb ) 
{ 
  struct gru_instruction *ins ;

  {
#line 584
  ins = (struct gru_instruction *)cb;
#line 586
  return (ins->avalue);
}
}
#line 589 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static int gru_get_amo_value_head(void *cb ) 
{ 
  struct gru_instruction *ins ;

  {
#line 591
  ins = (struct gru_instruction *)cb;
#line 593
  return ((int )ins->avalue);
}
}
#line 596 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static int gru_get_amo_value_limit(void *cb ) 
{ 
  struct gru_instruction *ins ;

  {
#line 598
  ins = (struct gru_instruction *)cb;
#line 600
  return ((int )(ins->avalue >> 32));
}
}
#line 603 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static union gru_mesqhead gru_mesq_head(int head , int limit ) 
{ 
  union gru_mesqhead mqh ;

  {
#line 607
  mqh.__annonCompField77.head = (unsigned int )head;
#line 608
  mqh.__annonCompField77.limit = (unsigned int )limit;
#line 609
  return (mqh);
}
}
#line 615
int gru_get_cb_exception_detail(void *cb , struct control_block_extended_exc_detail *excdet ) ;
#line 644 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static int gru_get_cb_message_queue_substatus(void *cb ) 
{ 
  struct gru_control_block_status *cbs ;

  {
#line 646
  cbs = (struct gru_control_block_status *)cb;
#line 648
  return ((int )cbs->isubstatus & 7);
}
}
#line 665 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static int gru_check_status(void *cb ) 
{ 
  struct gru_control_block_status *cbs ;
  int ret ;

  {
#line 667
  cbs = (struct gru_control_block_status *)cb;
#line 670
  ret = (int )cbs->istatus;
#line 671
  if (ret != 2) {
#line 672
    ret = gru_check_status_proc(cb);
  } else {

  }
#line 673
  return (ret);
}
}
#line 683 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static int gru_wait(void *cb ) 
{ 
  int tmp ;

  {
#line 685
  tmp = gru_wait_proc(cb);
#line 685
  return (tmp);
}
}
#line 732 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gru_instructions.h"
__inline static int gru_get_tri(void *vaddr ) 
{ 


  {
#line 734
  return ((int )(((unsigned int )((long )vaddr) & 262143U) - 131072U));
}
}
#line 112 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
__inline static void *get_gseg_base_address_ds(void *base , int ctxnum , int line ) 
{ 
  void *tmp ;

  {
#line 114
  tmp = get_gseg_base_address(base, ctxnum);
#line 114
  return (tmp + ((unsigned long )(line * 64) + 131072UL));
}
}
#line 74 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grukservices.h"
int gru_create_message_queue(struct gru_message_queue_desc *mqd , void *p , unsigned int bytes ,
                             int nasid , int vector , int apicid ) ;
#line 94
int gru_send_message_gpa(struct gru_message_queue_desc *mqd , void *mesg , unsigned int bytes ) ;
#line 114
void gru_free_message(struct gru_message_queue_desc *mqd , void *mesg ) ;
#line 130
void *gru_get_next_message(struct gru_message_queue_desc *mqd ) ;
#line 144
int gru_read_gpa(unsigned long *value , unsigned long gpa ) ;
#line 160
int gru_copy_gpa(unsigned long dest_gpa , unsigned long src_gpa , unsigned int bytes ) ;
#line 176
unsigned long gru_reserve_async_resources(int blade_id , int cbrs , int dsr_bytes ,
                                          struct completion *cmp ) ;
#line 185
void gru_release_async_resources(unsigned long han ) ;
#line 193
void gru_wait_async_cbr(unsigned long han ) ;
#line 204
void gru_lock_async_resource(unsigned long han , void **cb , void **dsr ) ;
#line 212
void gru_unlock_async_resource(unsigned long han ) ;
#line 323 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static unsigned long uv_gpa(void *v ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 325
  tmp = __phys_addr((unsigned long )v);
#line 325
  tmp___0 = uv_soc_phys_ram_to_gpa(tmp);
#line 325
  return (tmp___0);
}
}
#line 441 "./arch/x86/include/asm/uv/uv_hub.h"
__inline static unsigned long uv_global_gru_mmr_address(int pnode , unsigned long offset ) 
{ 
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;

  {
#line 444
  __vpp_verify = (void const   *)0;
#line 444
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off), "0" (& __uv_hub_info));
#line 443
  return ((((unsigned long )pnode << (int )((struct uv_hub_info_s *)tcp_ptr__)->m_val) | offset) | 67108864UL);
}
}
#line 645
extern unsigned int uv_apicid_hibits ;
#line 646 "./arch/x86/include/asm/uv/uv_hub.h"
static unsigned long uv_hub_ipi_value(int apicid , int vector , int mode ) 
{ 


  {
#line 648
  apicid = (int )((unsigned int )apicid | uv_apicid_hibits);
#line 649
  return ((((unsigned long )(apicid << 16) | (unsigned long )(mode << 8)) | (unsigned long )vector) | 0x8000000000000000UL);
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static void gru_load_kernel_context(struct gru_blade_state *bs , int blade_id ) 
{ 
  struct gru_state *gru ;
  struct gru_thread_state *kgts ;
  void *vaddr ;
  int ctxnum ;
  int ncpus ;
  struct gru_state *tmp ;

  {
#line 159
  up_read(& bs->bs_kgts_sema);
#line 160
  down_write(& bs->bs_kgts_sema);
#line 162
  if ((unsigned long )bs->bs_kgts == (unsigned long )((struct gru_thread_state *)0)) {
#line 163
    bs->bs_kgts = gru_alloc_gts((struct vm_area_struct *)0, 0, 0, 0, 0, 0);
#line 164
    (bs->bs_kgts)->ts_user_blade_id = (short )blade_id;
  } else {

  }
#line 166
  kgts = bs->bs_kgts;
#line 168
  if ((unsigned long )kgts->ts_gru == (unsigned long )((struct gru_state *)0)) {
#line 169
    if ((gru_options & 2UL) != 0UL) {
#line 169
      atomic_long_inc(& gru_stats.load_kernel_context);
    } else {

    }
#line 170
    ncpus = uv_blade_nr_possible_cpus(blade_id);
#line 171
    kgts->ts_cbr_au_count = (unsigned char )(((bs->bs_async_cbrs + ncpus) + 1) / 2);
#line 173
    kgts->ts_dsr_au_count = (unsigned char )(((ncpus * 256 + bs->bs_async_dsr_bytes) + 1023) / 1024);
#line 176
    goto ldv_32298;
    ldv_32297: 
#line 177
    msleep(1U);
#line 178
    gru_steal_context(kgts);
    ldv_32298: 
#line 176
    tmp = gru_assign_gru_context(kgts);
#line 176
    if ((unsigned long )tmp == (unsigned long )((struct gru_state *)0)) {
#line 178
      goto ldv_32297;
    } else {

    }
#line 180
    gru_load_context(kgts);
#line 181
    gru = (bs->bs_kgts)->ts_gru;
#line 182
    vaddr = gru->gs_gru_base_vaddr;
#line 183
    ctxnum = kgts->ts_ctxnum;
#line 184
    bs->kernel_cb = get_gseg_base_address_cb(vaddr, ctxnum, 0);
#line 185
    bs->kernel_dsr = get_gseg_base_address_ds(vaddr, ctxnum, 0);
  } else {

  }
#line 187
  downgrade_write(& bs->bs_kgts_sema);
#line 188
  return;
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static int gru_free_kernel_contexts(void) 
{ 
  struct gru_blade_state *bs ;
  struct gru_thread_state *kgts ;
  int bid ;
  int ret ;
  int tmp ;

  {
#line 198
  ret = 0;
#line 200
  bid = 0;
#line 200
  goto ldv_32309;
  ldv_32308: 
#line 201
  bs = gru_base[bid];
#line 202
  if ((unsigned long )bs == (unsigned long )((struct gru_blade_state *)0)) {
#line 203
    goto ldv_32307;
  } else {

  }
#line 206
  tmp = down_write_trylock(& bs->bs_kgts_sema);
#line 206
  if (tmp != 0) {
#line 207
    kgts = bs->bs_kgts;
#line 208
    if ((unsigned long )kgts != (unsigned long )((struct gru_thread_state *)0) && (unsigned long )kgts->ts_gru != (unsigned long )((struct gru_state *)0)) {
#line 209
      gru_unload_context(kgts, 0);
    } else {

    }
#line 210
    bs->bs_kgts = (struct gru_thread_state *)0;
#line 211
    up_write(& bs->bs_kgts_sema);
#line 212
    kfree((void const   *)kgts);
  } else {
#line 214
    ret = ret + 1;
  }
  ldv_32307: 
#line 200
  bid = bid + 1;
  ldv_32309: ;
#line 200
  if (bid <= 1023) {
#line 202
    goto ldv_32308;
  } else {

  }

#line 217
  return (ret);
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static struct gru_blade_state *gru_lock_kernel_context(int blade_id ) 
{ 
  struct gru_blade_state *bs ;
  int bid ;
  int tmp ;
  int tmp___0 ;

  {
#line 228
  if ((gru_options & 2UL) != 0UL) {
#line 228
    atomic_long_inc(& gru_stats.lock_kernel_context);
  } else {

  }
  again: ;
#line 230
  if (blade_id < 0) {
#line 230
    tmp = uv_numa_blade_id();
#line 230
    bid = tmp;
  } else {
#line 230
    bid = blade_id;
  }
#line 231
  bs = gru_base[bid];
#line 234
  down_read(& bs->bs_kgts_sema);
#line 235
  if (blade_id < 0) {
#line 235
    tmp___0 = uv_numa_blade_id();
#line 235
    if (tmp___0 != bid) {
#line 236
      up_read(& bs->bs_kgts_sema);
#line 237
      goto again;
    } else {

    }
  } else {

  }
#line 239
  if ((unsigned long )bs->bs_kgts == (unsigned long )((struct gru_thread_state *)0) || (unsigned long )(bs->bs_kgts)->ts_gru == (unsigned long )((struct gru_state *)0)) {
#line 240
    gru_load_kernel_context(bs, bid);
  } else {

  }
#line 241
  return (bs);
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static void gru_unlock_kernel_context(int blade_id ) 
{ 
  struct gru_blade_state *bs ;

  {
#line 253
  bs = gru_base[blade_id];
#line 254
  up_read(& bs->bs_kgts_sema);
#line 255
  if ((gru_options & 2UL) != 0UL) {
#line 255
    atomic_long_inc(& gru_stats.unlock_kernel_context);
  } else {

  }
#line 256
  return;
}
}
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static int gru_get_cpu_resources(int dsr_bytes , void **cb , void **dsr ) 
{ 
  struct gru_blade_state *bs ;
  int lcpu ;
  long tmp ;

  {
#line 267
  tmp = ldv__builtin_expect(dsr_bytes > 256, 0L);
#line 267
  if (tmp != 0L) {
#line 267
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"),
                         "i" (267), "i" (12UL));
    ldv_32328: ;
#line 267
    goto ldv_32328;
  } else {

  }
#line 268
  __preempt_count_add___0(1);
#line 268
  __asm__  volatile   ("": : : "memory");
#line 269
  bs = gru_lock_kernel_context(-1);
#line 270
  lcpu = uv_blade_processor_id();
#line 271
  *cb = bs->kernel_cb + (unsigned long )(lcpu * 256);
#line 272
  *dsr = bs->kernel_dsr + (unsigned long )(lcpu * 256);
#line 273
  return (0);
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static void gru_free_cpu_resources(void *cb , void *dsr ) 
{ 
  int tmp ;

  {
#line 281
  tmp = uv_numa_blade_id();
#line 281
  gru_unlock_kernel_context(tmp);
#line 282
  __asm__  volatile   ("": : : "memory");
#line 282
  __preempt_count_sub___0(1);
#line 283
  return;
}
}
#line 297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
unsigned long gru_reserve_async_resources(int blade_id , int cbrs , int dsr_bytes ,
                                          struct completion *cmp ) 
{ 
  struct gru_blade_state *bs ;
  struct gru_thread_state *kgts ;
  int ret ;

  {
#line 302
  ret = 0;
#line 304
  bs = gru_base[blade_id];
#line 306
  down_write(& bs->bs_kgts_sema);
#line 309
  if (bs->bs_async_dsr_bytes + bs->bs_async_cbrs != 0) {
#line 310
    goto done;
  } else {

  }
#line 311
  bs->bs_async_dsr_bytes = dsr_bytes;
#line 312
  bs->bs_async_cbrs = cbrs;
#line 313
  bs->bs_async_wq = cmp;
#line 314
  kgts = bs->bs_kgts;
#line 317
  if ((unsigned long )kgts != (unsigned long )((struct gru_thread_state *)0) && (unsigned long )kgts->ts_gru != (unsigned long )((struct gru_state *)0)) {
#line 318
    gru_unload_context(kgts, 0);
  } else {

  }
#line 319
  ret = blade_id + 1;
  done: 
#line 322
  up_write(& bs->bs_kgts_sema);
#line 323
  return ((unsigned long )ret);
}
}
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
void gru_release_async_resources(unsigned long han ) 
{ 
  struct gru_blade_state *bs ;

  {
#line 334
  bs = gru_base[han - 1UL];
#line 336
  down_write(& bs->bs_kgts_sema);
#line 337
  bs->bs_async_dsr_bytes = 0;
#line 338
  bs->bs_async_cbrs = 0;
#line 339
  bs->bs_async_wq = (struct completion *)0;
#line 340
  up_write(& bs->bs_kgts_sema);
#line 341
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
void gru_wait_async_cbr(unsigned long han ) 
{ 
  struct gru_blade_state *bs ;

  {
#line 351
  bs = gru_base[han - 1UL];
#line 353
  wait_for_completion(bs->bs_async_wq);
#line 354
  __asm__  volatile   ("mfence": : : "memory");
#line 355
  return;
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
void gru_lock_async_resource(unsigned long han , void **cb , void **dsr ) 
{ 
  struct gru_blade_state *bs ;
  int blade_id ;
  int ncpus ;

  {
#line 368
  bs = gru_base[han - 1UL];
#line 369
  blade_id = (int )((unsigned int )han - 1U);
#line 372
  gru_lock_kernel_context(blade_id);
#line 373
  ncpus = uv_blade_nr_possible_cpus(blade_id);
#line 374
  if ((unsigned long )cb != (unsigned long )((void **)0)) {
#line 375
    *cb = bs->kernel_cb + (unsigned long )(ncpus * 256);
  } else {

  }
#line 376
  if ((unsigned long )dsr != (unsigned long )((void **)0)) {
#line 377
    *dsr = bs->kernel_dsr + (unsigned long )(ncpus * 256);
  } else {

  }
#line 378
  return;
}
}
#line 386 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
void gru_unlock_async_resource(unsigned long han ) 
{ 
  int blade_id ;

  {
#line 388
  blade_id = (int )((unsigned int )han - 1U);
#line 390
  gru_unlock_kernel_context(blade_id);
#line 391
  return;
}
}
#line 394 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
int gru_get_cb_exception_detail(void *cb , struct control_block_extended_exc_detail *excdet ) 
{ 
  struct gru_control_block_extended *cbe ;
  struct gru_thread_state *kgts ;
  unsigned long off ;
  int cbrnum ;
  int bid ;
  int tmp ;
  long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 398
  kgts = (struct gru_thread_state *)0;
#line 407
  bid = 0;
#line 407
  goto ldv_32375;
  ldv_32374: ;
#line 408
  if ((unsigned long )gru_base[bid] == (unsigned long )((struct gru_blade_state *)0)) {
#line 409
    goto ldv_32372;
  } else {

  }
#line 410
  kgts = (gru_base[bid])->bs_kgts;
#line 411
  if ((unsigned long )kgts == (unsigned long )((struct gru_thread_state *)0) || (unsigned long )kgts->ts_gru == (unsigned long )((struct gru_state *)0)) {
#line 412
    goto ldv_32373;
  } else {

  }
#line 413
  off = (unsigned long )((long )cb - (long )(kgts->ts_gru)->gs_gru_base_vaddr);
#line 414
  if (off <= 134217727UL) {
#line 415
    goto ldv_32372;
  } else {

  }
#line 416
  kgts = (struct gru_thread_state *)0;
  ldv_32373: 
#line 407
  bid = bid + 1;
  ldv_32375: 
#line 407
  tmp = uv_num_possible_blades();
#line 407
  if (tmp > bid) {
#line 409
    goto ldv_32374;
  } else {

  }
  ldv_32372: 
#line 418
  tmp___0 = ldv__builtin_expect((unsigned long )kgts == (unsigned long )((struct gru_thread_state *)0),
                             0L);
#line 418
  if (tmp___0 != 0L) {
#line 418
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"),
                         "i" (418), "i" (12UL));
    ldv_32376: ;
#line 418
    goto ldv_32376;
  } else {

  }
#line 419
  tmp___1 = get_cb_number(cb);
#line 419
  tmp___2 = get_cb_number(cb);
#line 419
  cbrnum = (int )((unsigned int )((int )kgts->ts_cbr_idx[tmp___1 / 2UL] * 2) + ((unsigned int )tmp___2 & 1U));
#line 420
  cbe = get_cbe((void *)((unsigned long )cb & 0xfffffffff8000000UL), cbrnum);
#line 421
  gru_flush_cache((void *)cbe);
#line 422
  sync_core();
#line 423
  excdet->opc = (int )cbe->opccpy;
#line 424
  excdet->exopc = (int )cbe->exopccpy;
#line 425
  excdet->ecause = (int )cbe->ecause;
#line 426
  excdet->exceptdet0 = (long )cbe->idef1upd;
#line 427
  excdet->exceptdet1 = (int )cbe->idef3upd;
#line 428
  gru_flush_cache((void *)cbe);
#line 429
  return (0);
}
}
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
char *gru_get_cb_exception_detail_str(int ret , void *cb , char *buf , int size ) 
{ 
  struct gru_control_block_status *gen ;
  struct control_block_extended_exc_detail excdet ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 435
  gen = (struct gru_control_block_status *)cb;
#line 438
  if (ret > 0 && (unsigned int )*((unsigned char *)gen + 7UL) == 1U) {
#line 439
    gru_get_cb_exception_detail(cb, & excdet);
#line 442
    __vpp_verify = (void const   *)0;
#line 442
    switch (4UL) {
    case 1UL: ;
#line 442
    switch (4UL) {
    case 1UL: 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_32390;
    case 2UL: 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_32390;
    case 4UL: 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_32390;
    case 8UL: 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_32390;
    default: 
#line 442
    __bad_percpu_size();
    }
    ldv_32390: 
#line 442
    pscr_ret__ = pfo_ret__;
#line 442
    goto ldv_32396;
    case 2UL: ;
#line 442
    switch (4UL) {
    case 1UL: 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_32400;
    case 2UL: 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_32400;
    case 4UL: 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_32400;
    case 8UL: 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_32400;
    default: 
#line 442
    __bad_percpu_size();
    }
    ldv_32400: 
#line 442
    pscr_ret__ = pfo_ret_____0;
#line 442
    goto ldv_32396;
    case 4UL: ;
#line 442
    switch (4UL) {
    case 1UL: 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_32409;
    case 2UL: 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_32409;
    case 4UL: 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_32409;
    case 8UL: 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_32409;
    default: 
#line 442
    __bad_percpu_size();
    }
    ldv_32409: 
#line 442
    pscr_ret__ = pfo_ret_____1;
#line 442
    goto ldv_32396;
    case 8UL: ;
#line 442
    switch (4UL) {
    case 1UL: 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_32418;
    case 2UL: 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_32418;
    case 4UL: 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_32418;
    case 8UL: 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_32418;
    default: 
#line 442
    __bad_percpu_size();
    }
    ldv_32418: 
#line 442
    pscr_ret__ = pfo_ret_____2;
#line 442
    goto ldv_32396;
    default: 
#line 442
    __bad_size_call_parameter();
#line 442
    goto ldv_32396;
    }
    ldv_32396: 
#line 442
    snprintf(buf, (size_t )size, "GRU:%d exception: cb %p, opc %d, exopc %d, ecause 0x%x,excdet0 0x%lx, excdet1 0x%x",
             pscr_ret__, gen, excdet.opc, excdet.exopc, excdet.ecause, excdet.exceptdet0,
             excdet.exceptdet1);
  } else {
#line 446
    snprintf(buf, (size_t )size, "No exception");
  }
#line 448
  return (buf);
}
}
#line 451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static int gru_wait_idle_or_exception(struct gru_control_block_status *gen ) 
{ 


  {
#line 453
  goto ldv_32430;
  ldv_32429: 
#line 454
  cpu_relax();
#line 455
  __asm__  volatile   ("": : : "memory");
  ldv_32430: ;
#line 453
  if ((int )gen->istatus > 1) {
#line 455
    goto ldv_32429;
  } else {

  }

#line 457
  return ((int )gen->istatus);
}
}
#line 460 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static int gru_retry_exception(void *cb ) 
{ 
  struct gru_control_block_status *gen ;
  struct control_block_extended_exc_detail excdet ;
  int retry ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 462
  gen = (struct gru_control_block_status *)cb;
#line 464
  retry = 3;
  ldv_32439: 
#line 467
  tmp = gru_wait_idle_or_exception(gen);
#line 467
  if (tmp == 0) {
#line 468
    return (0);
  } else {

  }
#line 469
  tmp___0 = gru_get_cb_message_queue_substatus(cb);
#line 469
  if (tmp___0 != 0) {
#line 470
    return (1);
  } else {

  }
#line 471
  gru_get_cb_exception_detail(cb, & excdet);
#line 472
  if ((excdet.ecause & -414593) != 0 || excdet.cbrexecstatus & 1) {
#line 474
    goto ldv_32438;
  } else {

  }
#line 475
  tmp___1 = retry;
#line 475
  retry = retry - 1;
#line 475
  if (tmp___1 == 0) {
#line 476
    goto ldv_32438;
  } else {

  }
#line 477
  gen->icmd = 1U;
#line 478
  gru_flush_cache((void *)gen);
#line 479
  goto ldv_32439;
  ldv_32438: ;
#line 480
  return (1);
}
}
#line 483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
int gru_check_status_proc(void *cb ) 
{ 
  struct gru_control_block_status *gen ;
  int ret ;

  {
#line 485
  gen = (struct gru_control_block_status *)cb;
#line 488
  ret = (int )gen->istatus;
#line 489
  if (ret == 1) {
#line 490
    ret = gru_retry_exception(cb);
  } else {

  }
#line 491
  __asm__  volatile   ("lfence": : : "memory");
#line 492
  return (ret);
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
int gru_wait_proc(void *cb ) 
{ 
  struct gru_control_block_status *gen ;
  int ret ;

  {
#line 498
  gen = (struct gru_control_block_status *)cb;
#line 501
  ret = gru_wait_idle_or_exception(gen);
#line 502
  if (ret == 1) {
#line 503
    ret = gru_retry_exception(cb);
  } else {

  }
#line 504
  __asm__  volatile   ("lfence": : : "memory");
#line 505
  return (ret);
}
}
#line 508 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
void gru_abort(int ret , void *cb , char *str ) 
{ 
  char buf[256U] ;
  char *tmp ;

  {
#line 512
  tmp = gru_get_cb_exception_detail_str(ret, cb, (char *)(& buf), 256);
#line 512
  panic("GRU FATAL OLD_ERROR: %s - %s\n", str, tmp);
#line 514
  return;
}
}
#line 516 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
void gru_wait_abort_proc(void *cb ) 
{ 
  int ret ;

  {
#line 520
  ret = gru_wait_proc(cb);
#line 521
  if (ret != 0) {
#line 522
    gru_abort(ret, cb, (char *)"gru_wait_abort");
  } else {

  }
#line 523
  return;
}
}
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
__inline static int get_present2(void *p ) 
{ 
  struct message_header *mhdr ;

  {
#line 538
  mhdr = (struct message_header *)p + 64U;
#line 539
  return ((int )mhdr->present);
}
}
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
__inline static void restore_present2(void *p , int val ) 
{ 
  struct message_header *mhdr ;

  {
#line 544
  mhdr = (struct message_header *)p + 64U;
#line 545
  mhdr->present = (char )val;
#line 546
  return;
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
int gru_create_message_queue(struct gru_message_queue_desc *mqd , void *p , unsigned int bytes ,
                             int nasid , int vector , int apicid ) 
{ 
  struct message_queue *mq ;
  unsigned int qlines ;

  {
#line 555
  mq = (struct message_queue *)p;
#line 558
  qlines = bytes / 64U - 2U;
#line 559
  memset((void *)mq, 0, (size_t )bytes);
#line 560
  mq->start = (void *)(& mq->data);
#line 561
  mq->start2 = (void *)(& mq->data) + (unsigned long )((qlines / 2U + 67108863U) * 64U);
#line 562
  mq->next = (void *)(& mq->data);
#line 563
  mq->limit = (void *)(& mq->data) + (unsigned long )((qlines + 67108862U) * 64U);
#line 564
  mq->qlines = (int )qlines;
#line 565
  mq->hstatus[0] = 0L;
#line 566
  mq->hstatus[1] = 1L;
#line 567
  mq->head = gru_mesq_head(2, (int )(qlines / 2U + 1U));
#line 568
  mqd->mq = (void *)mq;
#line 569
  mqd->mq_gpa = uv_gpa((void *)mq);
#line 570
  mqd->qlines = (int )qlines;
#line 571
  mqd->interrupt_pnode = nasid >> 1;
#line 572
  mqd->interrupt_vector = vector;
#line 573
  mqd->interrupt_apicid = apicid;
#line 574
  return (0);
}
}
#line 576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static char const   __kstrtab_gru_create_message_queue[25U]  = 
#line 576
  {      'g',      'r',      'u',      '_', 
        'c',      'r',      'e',      'a', 
        't',      'e',      '_',      'm', 
        'e',      's',      's',      'a', 
        'g',      'e',      '_',      'q', 
        'u',      'e',      'u',      'e', 
        '\000'};
#line 576
struct kernel_symbol  const  __ksymtab_gru_create_message_queue ;
#line 576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
struct kernel_symbol  const  __ksymtab_gru_create_message_queue  =    {(unsigned long )(& gru_create_message_queue), (char const   *)(& __kstrtab_gru_create_message_queue)};
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static int send_noop_message(void *cb , struct gru_message_queue_desc *mqd , void *mesg ) 
{ 
  struct message_header noop_header ;
  unsigned long m ;
  int substatus ;
  int ret ;
  struct message_header save_mhdr ;
  struct message_header *mhdr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 589
  noop_header.present = 2;
#line 589
  noop_header.present2 = (char)0;
#line 589
  noop_header.lines = 1;
#line 589
  noop_header.fill = (char)0;
#line 593
  mhdr = (struct message_header *)mesg;
#line 595
  if ((gru_options & 2UL) != 0UL) {
#line 595
    atomic_long_inc(& gru_stats.mesq_noop);
  } else {

  }
#line 596
  save_mhdr = *mhdr;
#line 597
  *mhdr = noop_header;
#line 598
  tmp = gru_get_tri((void *)mhdr);
#line 598
  gru_mesq(cb, mqd->mq_gpa, (unsigned long )tmp, 1UL, 1UL);
#line 599
  ret = gru_wait(cb);
#line 601
  if (ret != 0) {
#line 602
    substatus = gru_get_cb_message_queue_substatus(cb);
#line 603
    switch (substatus) {
    case 0: ;
#line 605
    if ((gru_options & 2UL) != 0UL) {
#line 605
      atomic_long_inc(& gru_stats.mesq_noop_unexpected_error);
    } else {

    }
#line 606
    ret = 3;
#line 607
    goto ldv_32503;
    case 1: ;
#line 609
    if ((gru_options & 2UL) != 0UL) {
#line 609
      atomic_long_inc(& gru_stats.mesq_noop_lb_overflow);
    } else {

    }
#line 610
    ret = 1;
#line 611
    goto ldv_32503;
    case 2: ;
#line 613
    if ((gru_options & 2UL) != 0UL) {
#line 613
      atomic_long_inc(& gru_stats.mesq_noop_qlimit_reached);
    } else {

    }
#line 614
    ret = 0;
#line 615
    goto ldv_32503;
    case 4: ;
#line 617
    if ((gru_options & 2UL) != 0UL) {
#line 617
      atomic_long_inc(& gru_stats.mesq_noop_amo_nacked);
    } else {

    }
#line 618
    ret = 1;
#line 619
    goto ldv_32503;
    case 5: ;
#line 621
    if ((gru_options & 2UL) != 0UL) {
#line 621
      atomic_long_inc(& gru_stats.mesq_noop_put_nacked);
    } else {

    }
#line 622
    tmp___0 = gru_get_amo_value_head(cb);
#line 622
    m = mqd->mq_gpa + (unsigned long )(tmp___0 << 6);
#line 623
    tmp___1 = gru_get_tri(mesg);
#line 623
    gru_vstore(cb, m, (unsigned int )tmp___1, 6, 1UL, 1UL, 1UL);
#line 625
    tmp___2 = gru_wait(cb);
#line 625
    if (tmp___2 == 0) {
#line 626
      ret = -1;
    } else {
#line 628
      ret = 3;
    }
#line 629
    goto ldv_32503;
    case 3: ;
#line 631
    if ((gru_options & 2UL) != 0UL) {
#line 631
      atomic_long_inc(& gru_stats.mesq_noop_page_overflow);
    } else {

    }
    default: 
#line 634
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"),
                         "i" (634), "i" (12UL));
    ldv_32510: ;
#line 634
    goto ldv_32510;
    }
    ldv_32503: ;
  } else {

  }
#line 637
  *mhdr = save_mhdr;
#line 638
  return (ret);
}
}
#line 644 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static int send_message_queue_full(void *cb , struct gru_message_queue_desc *mqd ,
                                   void *mesg , int lines ) 
{ 
  union gru_mesqhead mqh ;
  unsigned int limit ;
  unsigned int head ;
  unsigned long avalue ;
  int half ;
  int qlines ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;

  {
#line 653
  avalue = gru_get_amo_value(cb);
#line 654
  tmp = gru_get_amo_value_head(cb);
#line 654
  head = (unsigned int )tmp;
#line 655
  tmp___0 = gru_get_amo_value_limit(cb);
#line 655
  limit = (unsigned int )tmp___0;
#line 657
  qlines = mqd->qlines;
#line 658
  half = (unsigned int )qlines != limit;
#line 660
  if (half != 0) {
#line 661
    mqh = gru_mesq_head(qlines / 2 + 1, qlines);
  } else {
#line 663
    mqh = gru_mesq_head(2, qlines / 2 + 1);
  }
#line 666
  gru_gamir(cb, 2, mqd->mq_gpa + ((unsigned long )half + 2UL) * 8UL, 3U, 1UL);
#line 667
  tmp___1 = gru_wait(cb);
#line 667
  if (tmp___1 != 0) {
#line 668
    goto cberr;
  } else {

  }
#line 669
  tmp___2 = gru_get_amo_value(cb);
#line 669
  if (tmp___2 == 0UL) {
#line 670
    if ((gru_options & 2UL) != 0UL) {
#line 670
      atomic_long_inc(& gru_stats.mesq_qf_locked);
    } else {

    }
#line 671
    return (2);
  } else {

  }
#line 675
  if (head != limit) {
#line 676
    tmp___4 = send_noop_message(cb, mqd, mesg);
#line 676
    if (tmp___4 != 0) {
#line 677
      gru_gamir(cb, 5, mqd->mq_gpa + ((unsigned long )half + 2UL) * 8UL, 3U, 1UL);
#line 679
      tmp___3 = gru_wait(cb);
#line 679
      if (tmp___3 != 0) {
#line 680
        goto cberr;
      } else {

      }
#line 681
      if ((gru_options & 2UL) != 0UL) {
#line 681
        atomic_long_inc(& gru_stats.mesq_qf_noop_not_full);
      } else {

      }
#line 682
      return (-1);
    } else {

    }
#line 684
    avalue = avalue + 1UL;
  } else {

  }
#line 688
  gru_gamer(cb, 8, mqd->mq_gpa, 3U, mqh.val, avalue, 1UL);
#line 690
  tmp___5 = gru_wait(cb);
#line 690
  if (tmp___5 != 0) {
#line 691
    goto cberr;
  } else {

  }
#line 694
  tmp___7 = gru_get_amo_value(cb);
#line 694
  if (tmp___7 != avalue) {
#line 695
    if ((gru_options & 2UL) != 0UL) {
#line 695
      atomic_long_inc(& gru_stats.mesq_qf_switch_head_failed);
    } else {

    }
#line 696
    gru_gamir(cb, 5, mqd->mq_gpa + ((unsigned long )half + 2UL) * 8UL, 3U, 1UL);
#line 698
    tmp___6 = gru_wait(cb);
#line 698
    if (tmp___6 != 0) {
#line 699
      goto cberr;
    } else {

    }
  } else {

  }
#line 701
  return (-1);
  cberr: ;
#line 703
  if ((gru_options & 2UL) != 0UL) {
#line 703
    atomic_long_inc(& gru_stats.mesq_qf_unexpected_error);
  } else {

  }
#line 704
  return (3);
}
}
#line 713 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static int send_message_put_nacked(void *cb , struct gru_message_queue_desc *mqd ,
                                   void *mesg , int lines ) 
{ 
  unsigned long m ;
  unsigned long *val ;
  unsigned long gpa ;
  unsigned long save ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 716
  val = (unsigned long *)mesg;
#line 719
  tmp = gru_get_amo_value_head(cb);
#line 719
  m = mqd->mq_gpa + (unsigned long )(tmp << 6);
#line 720
  if (lines == 2) {
#line 721
    gru_vset(cb, m, 0UL, 6, (unsigned long )lines, 1UL, 1UL);
#line 722
    tmp___0 = gru_wait(cb);
#line 722
    if (tmp___0 != 0) {
#line 723
      return (3);
    } else {

    }
  } else {

  }
#line 725
  tmp___1 = gru_get_tri(mesg);
#line 725
  gru_vstore(cb, m, (unsigned int )tmp___1, 6, (unsigned long )lines, 1UL, 1UL);
#line 726
  tmp___2 = gru_wait(cb);
#line 726
  if (tmp___2 != 0) {
#line 727
    return (3);
  } else {

  }
#line 729
  if (mqd->interrupt_vector == 0) {
#line 730
    return (0);
  } else {

  }
#line 739
  gpa = uv_global_gru_mmr_address(mqd->interrupt_pnode, 394496UL);
#line 740
  save = *val;
#line 741
  *val = uv_hub_ipi_value(mqd->interrupt_apicid, mqd->interrupt_vector, 0);
#line 743
  tmp___3 = gru_get_tri(mesg);
#line 743
  gru_vstore_phys(cb, gpa, (unsigned int )tmp___3, 3, 1UL);
#line 744
  ret = gru_wait(cb);
#line 745
  *val = save;
#line 746
  if (ret != 0) {
#line 747
    return (3);
  } else {

  }
#line 748
  return (0);
}
}
#line 755 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static int send_message_failure(void *cb , struct gru_message_queue_desc *mqd , void *mesg ,
                                int lines ) 
{ 
  int substatus ;
  int ret ;

  {
#line 758
  ret = 0;
#line 760
  substatus = gru_get_cb_message_queue_substatus(cb);
#line 761
  switch (substatus) {
  case 0: ;
#line 763
  if ((gru_options & 2UL) != 0UL) {
#line 763
    atomic_long_inc(& gru_stats.mesq_send_unexpected_error);
  } else {

  }
#line 764
  ret = 3;
#line 765
  goto ldv_32544;
  case 1: ;
#line 767
  if ((gru_options & 2UL) != 0UL) {
#line 767
    atomic_long_inc(& gru_stats.mesq_send_lb_overflow);
  } else {

  }
#line 768
  ret = 1;
#line 769
  goto ldv_32544;
  case 2: ;
#line 771
  if ((gru_options & 2UL) != 0UL) {
#line 771
    atomic_long_inc(& gru_stats.mesq_send_qlimit_reached);
  } else {

  }
#line 772
  ret = send_message_queue_full(cb, mqd, mesg, lines);
#line 773
  goto ldv_32544;
  case 4: ;
#line 775
  if ((gru_options & 2UL) != 0UL) {
#line 775
    atomic_long_inc(& gru_stats.mesq_send_amo_nacked);
  } else {

  }
#line 776
  ret = 1;
#line 777
  goto ldv_32544;
  case 5: ;
#line 779
  if ((gru_options & 2UL) != 0UL) {
#line 779
    atomic_long_inc(& gru_stats.mesq_send_put_nacked);
  } else {

  }
#line 780
  ret = send_message_put_nacked(cb, mqd, mesg, lines);
#line 781
  goto ldv_32544;
  case 3: ;
#line 783
  if ((gru_options & 2UL) != 0UL) {
#line 783
    atomic_long_inc(& gru_stats.mesq_page_overflow);
  } else {

  }
  default: 
#line 786
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"),
                       "i" (786), "i" (12UL));
  ldv_32551: ;
#line 786
  goto ldv_32551;
  }
  ldv_32544: ;
#line 788
  return (ret);
}
}
#line 797 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
int gru_send_message_gpa(struct gru_message_queue_desc *mqd , void *mesg , unsigned int bytes ) 
{ 
  struct message_header *mhdr ;
  void *cb ;
  void *dsr ;
  int istatus ;
  int clines ;
  int ret ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 805
  if ((gru_options & 2UL) != 0UL) {
#line 805
    atomic_long_inc(& gru_stats.mesq_send);
  } else {

  }
#line 806
  tmp = ldv__builtin_expect((long )(bytes <= 3U || bytes > 128U), 0L);
#line 806
  if (tmp != 0L) {
#line 806
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"),
                         "i" (806), "i" (12UL));
    ldv_32563: ;
#line 806
    goto ldv_32563;
  } else {

  }
#line 808
  clines = (int )((bytes + 63U) / 64U);
#line 809
  tmp___0 = gru_get_cpu_resources((int )bytes, & cb, & dsr);
#line 809
  if (tmp___0 != 0) {
#line 810
    return (11);
  } else {

  }
#line 811
  memcpy(dsr, (void const   *)mesg, (size_t )bytes);
#line 812
  mhdr = (struct message_header *)dsr;
#line 813
  mhdr->present = 1;
#line 814
  mhdr->lines = (char )clines;
#line 815
  if (clines == 2) {
#line 816
    tmp___1 = get_present2((void *)mhdr);
#line 816
    mhdr->present2 = (char )tmp___1;
#line 817
    restore_present2((void *)mhdr, 1);
  } else {

  }
  ldv_32564: 
#line 821
  ret = 0;
#line 822
  tmp___2 = gru_get_tri((void *)mhdr);
#line 822
  gru_mesq(cb, mqd->mq_gpa, (unsigned long )tmp___2, (unsigned long )clines, 1UL);
#line 823
  istatus = gru_wait(cb);
#line 824
  if (istatus != 0) {
#line 825
    ret = send_message_failure(cb, mqd, dsr, clines);
  } else {

  }
#line 826
  if (ret == -1) {
#line 828
    goto ldv_32564;
  } else {

  }
#line 827
  gru_free_cpu_resources(cb, dsr);
#line 829
  if (ret != 0) {
#line 830
    if ((gru_options & 2UL) != 0UL) {
#line 830
      atomic_long_inc(& gru_stats.mesq_send_failed);
    } else {

    }
  } else {

  }
#line 831
  return (ret);
}
}
#line 833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static char const   __kstrtab_gru_send_message_gpa[21U]  = 
#line 833
  {      'g',      'r',      'u',      '_', 
        's',      'e',      'n',      'd', 
        '_',      'm',      'e',      's', 
        's',      'a',      'g',      'e', 
        '_',      'g',      'p',      'a', 
        '\000'};
#line 833
struct kernel_symbol  const  __ksymtab_gru_send_message_gpa ;
#line 833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
struct kernel_symbol  const  __ksymtab_gru_send_message_gpa  =    {(unsigned long )(& gru_send_message_gpa), (char const   *)(& __kstrtab_gru_send_message_gpa)};
#line 838 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
void gru_free_message(struct gru_message_queue_desc *mqd , void *mesg ) 
{ 
  struct message_queue *mq ;
  struct message_header *mhdr ;
  void *next ;
  void *pnext ;
  int half ;
  int lines ;

  {
#line 840
  mq = (struct message_queue *)mqd->mq;
#line 841
  mhdr = (struct message_header *)mq->next;
#line 843
  half = -1;
#line 844
  lines = (int )mhdr->lines;
#line 846
  if (lines == 2) {
#line 847
    restore_present2((void *)mhdr, 0);
  } else {

  }
#line 848
  mhdr->present = 0;
#line 850
  pnext = mq->next;
#line 851
  next = pnext + (unsigned long )(lines * 64);
#line 852
  if ((unsigned long )mq->limit == (unsigned long )next) {
#line 853
    next = mq->start;
#line 854
    half = 1;
  } else
#line 855
  if ((unsigned long )mq->start2 > (unsigned long )pnext && (unsigned long )mq->start2 <= (unsigned long )next) {
#line 856
    half = 0;
  } else {

  }
#line 859
  if (half >= 0) {
#line 860
    mq->hstatus[half] = 1L;
  } else {

  }
#line 861
  mq->next = next;
#line 862
  return;
}
}
#line 863 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static char const   __kstrtab_gru_free_message[17U]  = 
#line 863
  {      'g',      'r',      'u',      '_', 
        'f',      'r',      'e',      'e', 
        '_',      'm',      'e',      's', 
        's',      'a',      'g',      'e', 
        '\000'};
#line 863
struct kernel_symbol  const  __ksymtab_gru_free_message ;
#line 863 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
struct kernel_symbol  const  __ksymtab_gru_free_message  =    {(unsigned long )(& gru_free_message), (char const   *)(& __kstrtab_gru_free_message)};
#line 870 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
void *gru_get_next_message(struct gru_message_queue_desc *mqd ) 
{ 
  struct message_queue *mq ;
  struct message_header *mhdr ;
  int present ;
  int tmp ;

  {
#line 872
  mq = (struct message_queue *)mqd->mq;
#line 873
  mhdr = (struct message_header *)mq->next;
#line 874
  present = (int )mhdr->present;
#line 877
  goto ldv_32600;
  ldv_32599: 
#line 878
  gru_free_message(mqd, (void *)mhdr);
#line 879
  mhdr = (struct message_header *)mq->next;
#line 880
  present = (int )mhdr->present;
  ldv_32600: ;
#line 877
  if (present == 2) {
#line 879
    goto ldv_32599;
  } else {

  }

#line 884
  if (present == 1 && (int )((signed char )mhdr->lines) == 2) {
#line 884
    tmp = get_present2((void *)mhdr);
#line 884
    if (tmp == 0) {
#line 886
      present = 0;
    } else {

    }
  } else {

  }
#line 888
  if (present == 0) {
#line 889
    if ((gru_options & 2UL) != 0UL) {
#line 889
      atomic_long_inc(& gru_stats.mesq_receive_none);
    } else {

    }
#line 890
    return ((void *)0);
  } else {

  }
#line 893
  if ((int )((signed char )mhdr->lines) == 2) {
#line 894
    restore_present2((void *)mhdr, (int )mhdr->present2);
  } else {

  }
#line 896
  if ((gru_options & 2UL) != 0UL) {
#line 896
    atomic_long_inc(& gru_stats.mesq_receive);
  } else {

  }
#line 897
  return ((void *)mhdr);
}
}
#line 899 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static char const   __kstrtab_gru_get_next_message[21U]  = 
#line 899
  {      'g',      'r',      'u',      '_', 
        'g',      'e',      't',      '_', 
        'n',      'e',      'x',      't', 
        '_',      'm',      'e',      's', 
        's',      'a',      'g',      'e', 
        '\000'};
#line 899
struct kernel_symbol  const  __ksymtab_gru_get_next_message ;
#line 899 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
struct kernel_symbol  const  __ksymtab_gru_get_next_message  =    {(unsigned long )(& gru_get_next_message), (char const   *)(& __kstrtab_gru_get_next_message)};
#line 906 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
int gru_read_gpa(unsigned long *value , unsigned long gpa ) 
{ 
  void *cb ;
  void *dsr ;
  int ret ;
  int iaa ;
  int tmp ;
  int tmp___0 ;

  {
#line 912
  if ((gru_options & 2UL) != 0UL) {
#line 912
    atomic_long_inc(& gru_stats.read_gpa);
  } else {

  }
#line 913
  tmp = gru_get_cpu_resources(256, & cb, & dsr);
#line 913
  if (tmp != 0) {
#line 914
    return (11);
  } else {

  }
#line 915
  iaa = (int )(gpa >> 62);
#line 916
  tmp___0 = gru_get_tri(dsr);
#line 916
  gru_vload_phys(cb, gpa, (unsigned int )tmp___0, iaa, 1UL);
#line 917
  ret = gru_wait(cb);
#line 918
  if (ret == 0) {
#line 919
    *value = *((unsigned long *)dsr);
  } else {

  }
#line 920
  gru_free_cpu_resources(cb, dsr);
#line 921
  return (ret);
}
}
#line 923 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static char const   __kstrtab_gru_read_gpa[13U]  = 
#line 923
  {      'g',      'r',      'u',      '_', 
        'r',      'e',      'a',      'd', 
        '_',      'g',      'p',      'a', 
        '\000'};
#line 923
struct kernel_symbol  const  __ksymtab_gru_read_gpa ;
#line 923 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
struct kernel_symbol  const  __ksymtab_gru_read_gpa  =    {(unsigned long )(& gru_read_gpa), (char const   *)(& __kstrtab_gru_read_gpa)};
#line 929 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
int gru_copy_gpa(unsigned long dest_gpa , unsigned long src_gpa , unsigned int bytes ) 
{ 
  void *cb ;
  void *dsr ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 936
  if ((gru_options & 2UL) != 0UL) {
#line 936
    atomic_long_inc(& gru_stats.copy_gpa);
  } else {

  }
#line 937
  tmp = gru_get_cpu_resources(256, & cb, & dsr);
#line 937
  if (tmp != 0) {
#line 938
    return (11);
  } else {

  }
#line 939
  tmp___0 = gru_get_tri(dsr);
#line 939
  gru_bcopy(cb, src_gpa, dest_gpa, (unsigned int )tmp___0, 0U, (unsigned long )bytes,
            4U, 1UL);
#line 941
  ret = gru_wait(cb);
#line 942
  gru_free_cpu_resources(cb, dsr);
#line 943
  return (ret);
}
}
#line 945 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static char const   __kstrtab_gru_copy_gpa[13U]  = 
#line 945
  {      'g',      'r',      'u',      '_', 
        'c',      'o',      'p',      'y', 
        '_',      'g',      'p',      'a', 
        '\000'};
#line 945
struct kernel_symbol  const  __ksymtab_gru_copy_gpa ;
#line 945 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
struct kernel_symbol  const  __ksymtab_gru_copy_gpa  =    {(unsigned long )(& gru_copy_gpa), (char const   *)(& __kstrtab_gru_copy_gpa)};
#line 950 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static int quicktest0(unsigned long arg ) 
{ 
  unsigned long word0 ;
  unsigned long word1 ;
  void *cb ;
  void *dsr ;
  unsigned long *p ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___2 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  int pscr_ret_____1 ;
  void const   *__vpp_verify___1 ;
  int pfo_ret_____7 ;
  int pfo_ret_____8 ;
  int pfo_ret_____9 ;
  int pfo_ret_____10 ;
  int tmp___5 ;
  int pscr_ret_____2 ;
  void const   *__vpp_verify___2 ;
  int pfo_ret_____11 ;
  int pfo_ret_____12 ;
  int pfo_ret_____13 ;
  int pfo_ret_____14 ;

  {
#line 957
  ret = -5;
#line 959
  tmp = gru_get_cpu_resources(64, & cb, & dsr);
#line 959
  if (tmp != 0) {
#line 960
    return (11);
  } else {

  }
#line 961
  p = (unsigned long *)dsr;
#line 962
  word0 = 1311768467139281697UL;
#line 963
  word1 = 0UL;
#line 965
  tmp___0 = gru_get_tri(dsr);
#line 965
  tmp___1 = uv_gpa((void *)(& word0));
#line 965
  gru_vload(cb, tmp___1, (unsigned int )tmp___0, 3, 1UL, 1UL, 1UL);
#line 966
  tmp___2 = gru_wait(cb);
#line 966
  if (tmp___2 != 0) {
#line 967
    __vpp_verify = (void const   *)0;
#line 967
    switch (4UL) {
    case 1UL: ;
#line 967
    switch (4UL) {
    case 1UL: 
#line 967
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 967
    goto ldv_32656;
    case 2UL: 
#line 967
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 967
    goto ldv_32656;
    case 4UL: 
#line 967
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 967
    goto ldv_32656;
    case 8UL: 
#line 967
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 967
    goto ldv_32656;
    default: 
#line 967
    __bad_percpu_size();
    }
    ldv_32656: 
#line 967
    pscr_ret__ = pfo_ret__;
#line 967
    goto ldv_32662;
    case 2UL: ;
#line 967
    switch (4UL) {
    case 1UL: 
#line 967
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 967
    goto ldv_32666;
    case 2UL: 
#line 967
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 967
    goto ldv_32666;
    case 4UL: 
#line 967
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 967
    goto ldv_32666;
    case 8UL: 
#line 967
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 967
    goto ldv_32666;
    default: 
#line 967
    __bad_percpu_size();
    }
    ldv_32666: 
#line 967
    pscr_ret__ = pfo_ret_____0;
#line 967
    goto ldv_32662;
    case 4UL: ;
#line 967
    switch (4UL) {
    case 1UL: 
#line 967
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 967
    goto ldv_32675;
    case 2UL: 
#line 967
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 967
    goto ldv_32675;
    case 4UL: 
#line 967
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 967
    goto ldv_32675;
    case 8UL: 
#line 967
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 967
    goto ldv_32675;
    default: 
#line 967
    __bad_percpu_size();
    }
    ldv_32675: 
#line 967
    pscr_ret__ = pfo_ret_____1;
#line 967
    goto ldv_32662;
    case 8UL: ;
#line 967
    switch (4UL) {
    case 1UL: 
#line 967
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 967
    goto ldv_32684;
    case 2UL: 
#line 967
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 967
    goto ldv_32684;
    case 4UL: 
#line 967
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 967
    goto ldv_32684;
    case 8UL: 
#line 967
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 967
    goto ldv_32684;
    default: 
#line 967
    __bad_percpu_size();
    }
    ldv_32684: 
#line 967
    pscr_ret__ = pfo_ret_____2;
#line 967
    goto ldv_32662;
    default: 
#line 967
    __bad_size_call_parameter();
#line 967
    goto ldv_32662;
    }
    ldv_32662: 
#line 967
    printk("\017GRU:%d quicktest0: CBR failure 1\n", pscr_ret__);
#line 968
    goto done;
  } else {

  }
#line 971
  if (*p != 1311768467139281697UL) {
#line 972
    __vpp_verify___0 = (void const   *)0;
#line 972
    switch (4UL) {
    case 1UL: ;
#line 972
    switch (4UL) {
    case 1UL: 
#line 972
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 972
    goto ldv_32698;
    case 2UL: 
#line 972
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 972
    goto ldv_32698;
    case 4UL: 
#line 972
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 972
    goto ldv_32698;
    case 8UL: 
#line 972
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 972
    goto ldv_32698;
    default: 
#line 972
    __bad_percpu_size();
    }
    ldv_32698: 
#line 972
    pscr_ret_____0 = pfo_ret_____3;
#line 972
    goto ldv_32704;
    case 2UL: ;
#line 972
    switch (4UL) {
    case 1UL: 
#line 972
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 972
    goto ldv_32708;
    case 2UL: 
#line 972
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 972
    goto ldv_32708;
    case 4UL: 
#line 972
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 972
    goto ldv_32708;
    case 8UL: 
#line 972
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 972
    goto ldv_32708;
    default: 
#line 972
    __bad_percpu_size();
    }
    ldv_32708: 
#line 972
    pscr_ret_____0 = pfo_ret_____4;
#line 972
    goto ldv_32704;
    case 4UL: ;
#line 972
    switch (4UL) {
    case 1UL: 
#line 972
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 972
    goto ldv_32717;
    case 2UL: 
#line 972
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 972
    goto ldv_32717;
    case 4UL: 
#line 972
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 972
    goto ldv_32717;
    case 8UL: 
#line 972
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 972
    goto ldv_32717;
    default: 
#line 972
    __bad_percpu_size();
    }
    ldv_32717: 
#line 972
    pscr_ret_____0 = pfo_ret_____5;
#line 972
    goto ldv_32704;
    case 8UL: ;
#line 972
    switch (4UL) {
    case 1UL: 
#line 972
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 972
    goto ldv_32726;
    case 2UL: 
#line 972
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 972
    goto ldv_32726;
    case 4UL: 
#line 972
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 972
    goto ldv_32726;
    case 8UL: 
#line 972
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 972
    goto ldv_32726;
    default: 
#line 972
    __bad_percpu_size();
    }
    ldv_32726: 
#line 972
    pscr_ret_____0 = pfo_ret_____6;
#line 972
    goto ldv_32704;
    default: 
#line 972
    __bad_size_call_parameter();
#line 972
    goto ldv_32704;
    }
    ldv_32704: 
#line 972
    printk("\017GRU:%d quicktest0 bad magic 0x%lx\n", pscr_ret_____0, *p);
#line 973
    goto done;
  } else {

  }
#line 975
  tmp___3 = gru_get_tri(dsr);
#line 975
  tmp___4 = uv_gpa((void *)(& word1));
#line 975
  gru_vstore(cb, tmp___4, (unsigned int )tmp___3, 3, 1UL, 1UL, 1UL);
#line 976
  tmp___5 = gru_wait(cb);
#line 976
  if (tmp___5 != 0) {
#line 977
    __vpp_verify___1 = (void const   *)0;
#line 977
    switch (4UL) {
    case 1UL: ;
#line 977
    switch (4UL) {
    case 1UL: 
#line 977
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____7): "m" (cpu_number));
#line 977
    goto ldv_32739;
    case 2UL: 
#line 977
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 977
    goto ldv_32739;
    case 4UL: 
#line 977
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 977
    goto ldv_32739;
    case 8UL: 
#line 977
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 977
    goto ldv_32739;
    default: 
#line 977
    __bad_percpu_size();
    }
    ldv_32739: 
#line 977
    pscr_ret_____1 = pfo_ret_____7;
#line 977
    goto ldv_32745;
    case 2UL: ;
#line 977
    switch (4UL) {
    case 1UL: 
#line 977
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____8): "m" (cpu_number));
#line 977
    goto ldv_32749;
    case 2UL: 
#line 977
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 977
    goto ldv_32749;
    case 4UL: 
#line 977
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 977
    goto ldv_32749;
    case 8UL: 
#line 977
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 977
    goto ldv_32749;
    default: 
#line 977
    __bad_percpu_size();
    }
    ldv_32749: 
#line 977
    pscr_ret_____1 = pfo_ret_____8;
#line 977
    goto ldv_32745;
    case 4UL: ;
#line 977
    switch (4UL) {
    case 1UL: 
#line 977
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____9): "m" (cpu_number));
#line 977
    goto ldv_32758;
    case 2UL: 
#line 977
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 977
    goto ldv_32758;
    case 4UL: 
#line 977
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 977
    goto ldv_32758;
    case 8UL: 
#line 977
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 977
    goto ldv_32758;
    default: 
#line 977
    __bad_percpu_size();
    }
    ldv_32758: 
#line 977
    pscr_ret_____1 = pfo_ret_____9;
#line 977
    goto ldv_32745;
    case 8UL: ;
#line 977
    switch (4UL) {
    case 1UL: 
#line 977
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____10): "m" (cpu_number));
#line 977
    goto ldv_32767;
    case 2UL: 
#line 977
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 977
    goto ldv_32767;
    case 4UL: 
#line 977
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 977
    goto ldv_32767;
    case 8UL: 
#line 977
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 977
    goto ldv_32767;
    default: 
#line 977
    __bad_percpu_size();
    }
    ldv_32767: 
#line 977
    pscr_ret_____1 = pfo_ret_____10;
#line 977
    goto ldv_32745;
    default: 
#line 977
    __bad_size_call_parameter();
#line 977
    goto ldv_32745;
    }
    ldv_32745: 
#line 977
    printk("\017GRU:%d quicktest0: CBR failure 2\n", pscr_ret_____1);
#line 978
    goto done;
  } else {

  }
#line 981
  if (word0 != word1 || word1 != 1311768467139281697UL) {
#line 984
    __vpp_verify___2 = (void const   *)0;
#line 984
    switch (4UL) {
    case 1UL: ;
#line 984
    switch (4UL) {
    case 1UL: 
#line 984
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____11): "m" (cpu_number));
#line 984
    goto ldv_32780;
    case 2UL: 
#line 984
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 984
    goto ldv_32780;
    case 4UL: 
#line 984
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 984
    goto ldv_32780;
    case 8UL: 
#line 984
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 984
    goto ldv_32780;
    default: 
#line 984
    __bad_percpu_size();
    }
    ldv_32780: 
#line 984
    pscr_ret_____2 = pfo_ret_____11;
#line 984
    goto ldv_32786;
    case 2UL: ;
#line 984
    switch (4UL) {
    case 1UL: 
#line 984
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____12): "m" (cpu_number));
#line 984
    goto ldv_32790;
    case 2UL: 
#line 984
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 984
    goto ldv_32790;
    case 4UL: 
#line 984
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 984
    goto ldv_32790;
    case 8UL: 
#line 984
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 984
    goto ldv_32790;
    default: 
#line 984
    __bad_percpu_size();
    }
    ldv_32790: 
#line 984
    pscr_ret_____2 = pfo_ret_____12;
#line 984
    goto ldv_32786;
    case 4UL: ;
#line 984
    switch (4UL) {
    case 1UL: 
#line 984
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____13): "m" (cpu_number));
#line 984
    goto ldv_32799;
    case 2UL: 
#line 984
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 984
    goto ldv_32799;
    case 4UL: 
#line 984
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 984
    goto ldv_32799;
    case 8UL: 
#line 984
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 984
    goto ldv_32799;
    default: 
#line 984
    __bad_percpu_size();
    }
    ldv_32799: 
#line 984
    pscr_ret_____2 = pfo_ret_____13;
#line 984
    goto ldv_32786;
    case 8UL: ;
#line 984
    switch (4UL) {
    case 1UL: 
#line 984
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____14): "m" (cpu_number));
#line 984
    goto ldv_32808;
    case 2UL: 
#line 984
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 984
    goto ldv_32808;
    case 4UL: 
#line 984
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 984
    goto ldv_32808;
    case 8UL: 
#line 984
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 984
    goto ldv_32808;
    default: 
#line 984
    __bad_percpu_size();
    }
    ldv_32808: 
#line 984
    pscr_ret_____2 = pfo_ret_____14;
#line 984
    goto ldv_32786;
    default: 
#line 984
    __bad_size_call_parameter();
#line 984
    goto ldv_32786;
    }
    ldv_32786: 
#line 984
    printk("\017GRU:%d quicktest0 err: found 0x%lx, expected 0x%lx\n", pscr_ret_____2,
           word1, 1311768467139281697UL);
#line 985
    goto done;
  } else {

  }
#line 987
  ret = 0;
  done: 
#line 990
  gru_free_cpu_resources(cb, dsr);
#line 991
  return (ret);
}
}
#line 996 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static int quicktest1(unsigned long arg ) 
{ 
  struct gru_message_queue_desc mqd ;
  void *p ;
  void *mq ;
  unsigned long *dw ;
  int i ;
  int ret ;
  char mes[64U] ;
  char *m ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  void *tmp ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;

  {
#line 1001
  ret = -5;
#line 1005
  p = kmalloc(4096UL, 0U);
#line 1006
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1007
    return (-12);
  } else {

  }
#line 1008
  mq = (void *)(((unsigned long )p + 1023UL) & 0xfffffffffffffc00UL);
#line 1009
  memset((void *)(& mes), 238, 64UL);
#line 1010
  dw = (unsigned long *)mq;
#line 1012
  gru_create_message_queue(& mqd, mq, 512U, 0, 0, 0);
#line 1013
  i = 0;
#line 1013
  goto ldv_32831;
  ldv_32830: 
#line 1014
  mes[8] = (char )i;
  ldv_32827: 
#line 1016
  ret = gru_send_message_gpa(& mqd, (void *)(& mes), 64U);
#line 1017
  if (ret == 1) {
#line 1019
    goto ldv_32827;
  } else {

  }

#line 1018
  if (ret != 0) {
#line 1019
    goto ldv_32829;
  } else {

  }
#line 1013
  i = i + 1;
  ldv_32831: ;
#line 1013
  if (i <= 5) {
#line 1015
    goto ldv_32830;
  } else {

  }
  ldv_32829: ;
#line 1021
  if (ret != 2 || i != 4) {
#line 1023
    __vpp_verify = (void const   *)0;
#line 1023
    switch (4UL) {
    case 1UL: ;
#line 1023
    switch (4UL) {
    case 1UL: 
#line 1023
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 1023
    goto ldv_32837;
    case 2UL: 
#line 1023
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1023
    goto ldv_32837;
    case 4UL: 
#line 1023
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1023
    goto ldv_32837;
    case 8UL: 
#line 1023
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1023
    goto ldv_32837;
    default: 
#line 1023
    __bad_percpu_size();
    }
    ldv_32837: 
#line 1023
    pscr_ret__ = pfo_ret__;
#line 1023
    goto ldv_32843;
    case 2UL: ;
#line 1023
    switch (4UL) {
    case 1UL: 
#line 1023
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 1023
    goto ldv_32847;
    case 2UL: 
#line 1023
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1023
    goto ldv_32847;
    case 4UL: 
#line 1023
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1023
    goto ldv_32847;
    case 8UL: 
#line 1023
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1023
    goto ldv_32847;
    default: 
#line 1023
    __bad_percpu_size();
    }
    ldv_32847: 
#line 1023
    pscr_ret__ = pfo_ret_____0;
#line 1023
    goto ldv_32843;
    case 4UL: ;
#line 1023
    switch (4UL) {
    case 1UL: 
#line 1023
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 1023
    goto ldv_32856;
    case 2UL: 
#line 1023
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1023
    goto ldv_32856;
    case 4UL: 
#line 1023
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1023
    goto ldv_32856;
    case 8UL: 
#line 1023
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1023
    goto ldv_32856;
    default: 
#line 1023
    __bad_percpu_size();
    }
    ldv_32856: 
#line 1023
    pscr_ret__ = pfo_ret_____1;
#line 1023
    goto ldv_32843;
    case 8UL: ;
#line 1023
    switch (4UL) {
    case 1UL: 
#line 1023
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 1023
    goto ldv_32865;
    case 2UL: 
#line 1023
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1023
    goto ldv_32865;
    case 4UL: 
#line 1023
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1023
    goto ldv_32865;
    case 8UL: 
#line 1023
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1023
    goto ldv_32865;
    default: 
#line 1023
    __bad_percpu_size();
    }
    ldv_32865: 
#line 1023
    pscr_ret__ = pfo_ret_____2;
#line 1023
    goto ldv_32843;
    default: 
#line 1023
    __bad_size_call_parameter();
#line 1023
    goto ldv_32843;
    }
    ldv_32843: 
#line 1023
    printk("\017GRU:%d quicktest1: unexpect status %d, i %d\n", pscr_ret__, ret, i);
#line 1024
    goto done;
  } else {

  }
#line 1027
  i = 0;
#line 1027
  goto ldv_32876;
  ldv_32875: 
#line 1028
  tmp = gru_get_next_message(& mqd);
#line 1028
  m = (char *)tmp;
#line 1029
  if ((unsigned long )m == (unsigned long )((char *)0) || (int )*(m + 8UL) != i) {
#line 1030
    goto ldv_32874;
  } else {

  }
#line 1031
  gru_free_message(& mqd, (void *)m);
#line 1027
  i = i + 1;
  ldv_32876: ;
#line 1027
  if (i <= 5) {
#line 1029
    goto ldv_32875;
  } else {

  }
  ldv_32874: ;
#line 1033
  if (i != 4) {
#line 1035
    __vpp_verify___0 = (void const   *)0;
#line 1035
    switch (4UL) {
    case 1UL: ;
#line 1035
    switch (4UL) {
    case 1UL: 
#line 1035
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 1035
    goto ldv_32882;
    case 2UL: 
#line 1035
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 1035
    goto ldv_32882;
    case 4UL: 
#line 1035
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 1035
    goto ldv_32882;
    case 8UL: 
#line 1035
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 1035
    goto ldv_32882;
    default: 
#line 1035
    __bad_percpu_size();
    }
    ldv_32882: 
#line 1035
    pscr_ret_____0 = pfo_ret_____3;
#line 1035
    goto ldv_32888;
    case 2UL: ;
#line 1035
    switch (4UL) {
    case 1UL: 
#line 1035
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 1035
    goto ldv_32892;
    case 2UL: 
#line 1035
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 1035
    goto ldv_32892;
    case 4UL: 
#line 1035
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 1035
    goto ldv_32892;
    case 8UL: 
#line 1035
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 1035
    goto ldv_32892;
    default: 
#line 1035
    __bad_percpu_size();
    }
    ldv_32892: 
#line 1035
    pscr_ret_____0 = pfo_ret_____4;
#line 1035
    goto ldv_32888;
    case 4UL: ;
#line 1035
    switch (4UL) {
    case 1UL: 
#line 1035
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 1035
    goto ldv_32901;
    case 2UL: 
#line 1035
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 1035
    goto ldv_32901;
    case 4UL: 
#line 1035
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 1035
    goto ldv_32901;
    case 8UL: 
#line 1035
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 1035
    goto ldv_32901;
    default: 
#line 1035
    __bad_percpu_size();
    }
    ldv_32901: 
#line 1035
    pscr_ret_____0 = pfo_ret_____5;
#line 1035
    goto ldv_32888;
    case 8UL: ;
#line 1035
    switch (4UL) {
    case 1UL: 
#line 1035
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 1035
    goto ldv_32910;
    case 2UL: 
#line 1035
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 1035
    goto ldv_32910;
    case 4UL: 
#line 1035
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 1035
    goto ldv_32910;
    case 8UL: 
#line 1035
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 1035
    goto ldv_32910;
    default: 
#line 1035
    __bad_percpu_size();
    }
    ldv_32910: 
#line 1035
    pscr_ret_____0 = pfo_ret_____6;
#line 1035
    goto ldv_32888;
    default: 
#line 1035
    __bad_size_call_parameter();
#line 1035
    goto ldv_32888;
    }
    ldv_32888: 
#line 1035
    printk("\017GRU:%d quicktest2: bad message, i %d, m %p, m8 %d\n", pscr_ret_____0,
           i, m, (unsigned long )m != (unsigned long )((char *)0) ? (int )*(m + 8UL) : -1);
#line 1036
    goto done;
  } else {

  }
#line 1038
  ret = 0;
  done: 
#line 1041
  kfree((void const   *)p);
#line 1042
  return (ret);
}
}
#line 1045 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static int quicktest2(unsigned long arg ) 
{ 
  struct completion cmp ;
  unsigned long han ;
  int blade_id ;
  int numcb ;
  int ret ;
  unsigned long *buf ;
  void *cb0 ;
  void *cb ;
  struct gru_control_block_status *gen ;
  int i ;
  int k ;
  int istatus ;
  int bytes ;
  void *tmp ;
  unsigned long tmp___0 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  long tmp___1 ;

  {
#line 1047
  cmp.done = 0U;
#line 1047
  cmp.wait.lock.__annonCompField17.rlock.raw_lock.val.counter = 0;
#line 1047
  cmp.wait.lock.__annonCompField17.rlock.magic = 3735899821U;
#line 1047
  cmp.wait.lock.__annonCompField17.rlock.owner_cpu = 4294967295U;
#line 1047
  cmp.wait.lock.__annonCompField17.rlock.owner = (void *)-1;
#line 1047
  cmp.wait.lock.__annonCompField17.rlock.dep_map.key = 0;
#line 1047
  cmp.wait.lock.__annonCompField17.rlock.dep_map.class_cache[0] = 0;
#line 1047
  cmp.wait.lock.__annonCompField17.rlock.dep_map.class_cache[1] = 0;
#line 1047
  cmp.wait.lock.__annonCompField17.rlock.dep_map.name = "(cmp).wait.lock";
#line 1047
  cmp.wait.lock.__annonCompField17.rlock.dep_map.cpu = 0;
#line 1047
  cmp.wait.lock.__annonCompField17.rlock.dep_map.ip = 0UL;
#line 1047
  cmp.wait.task_list.next = & cmp.wait.task_list;
#line 1047
  cmp.wait.task_list.prev = & cmp.wait.task_list;
#line 1049
  blade_id = 0;
#line 1050
  numcb = 4;
#line 1051
  ret = 0;
#line 1057
  bytes = numcb * 32;
#line 1058
  tmp = kmalloc((size_t )bytes, 208U);
#line 1058
  buf = (unsigned long *)tmp;
#line 1059
  if ((unsigned long )buf == (unsigned long )((unsigned long *)0UL)) {
#line 1060
    return (-12);
  } else {

  }
#line 1062
  ret = -16;
#line 1063
  han = gru_reserve_async_resources(blade_id, numcb, 0, & cmp);
#line 1064
  if (han == 0UL) {
#line 1065
    goto done;
  } else {

  }
#line 1067
  gru_lock_async_resource(han, & cb0, (void **)0);
#line 1068
  memset((void *)buf, 238, (size_t )bytes);
#line 1069
  i = 0;
#line 1069
  goto ldv_32937;
  ldv_32936: 
#line 1070
  tmp___0 = uv_gpa((void *)buf + (unsigned long )(i * 4));
#line 1070
  gru_vset(cb0 + (unsigned long )(i * 256), tmp___0, 0UL, 3, 4UL, 1UL, 4UL);
#line 1069
  i = i + 1;
  ldv_32937: ;
#line 1069
  if (i < numcb) {
#line 1071
    goto ldv_32936;
  } else {

  }
#line 1073
  ret = 0;
#line 1074
  k = numcb;
  ldv_33025: 
#line 1076
  gru_wait_async_cbr(han);
#line 1077
  i = 0;
#line 1077
  goto ldv_32941;
  ldv_32940: 
#line 1078
  cb = cb0 + (unsigned long )(i * 256);
#line 1079
  istatus = gru_check_status(cb);
#line 1080
  if (istatus != 2 && istatus != 3) {
#line 1081
    goto ldv_32939;
  } else {

  }
#line 1077
  i = i + 1;
  ldv_32941: ;
#line 1077
  if (i < numcb) {
#line 1079
    goto ldv_32940;
  } else {

  }
  ldv_32939: ;
#line 1083
  if (i == numcb) {
#line 1084
    goto ldv_32942;
  } else {

  }
#line 1085
  if (istatus != 0) {
#line 1086
    __vpp_verify = (void const   *)0;
#line 1086
    switch (4UL) {
    case 1UL: ;
#line 1086
    switch (4UL) {
    case 1UL: 
#line 1086
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 1086
    goto ldv_32948;
    case 2UL: 
#line 1086
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1086
    goto ldv_32948;
    case 4UL: 
#line 1086
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1086
    goto ldv_32948;
    case 8UL: 
#line 1086
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1086
    goto ldv_32948;
    default: 
#line 1086
    __bad_percpu_size();
    }
    ldv_32948: 
#line 1086
    pscr_ret__ = pfo_ret__;
#line 1086
    goto ldv_32954;
    case 2UL: ;
#line 1086
    switch (4UL) {
    case 1UL: 
#line 1086
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 1086
    goto ldv_32958;
    case 2UL: 
#line 1086
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1086
    goto ldv_32958;
    case 4UL: 
#line 1086
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1086
    goto ldv_32958;
    case 8UL: 
#line 1086
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1086
    goto ldv_32958;
    default: 
#line 1086
    __bad_percpu_size();
    }
    ldv_32958: 
#line 1086
    pscr_ret__ = pfo_ret_____0;
#line 1086
    goto ldv_32954;
    case 4UL: ;
#line 1086
    switch (4UL) {
    case 1UL: 
#line 1086
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 1086
    goto ldv_32967;
    case 2UL: 
#line 1086
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1086
    goto ldv_32967;
    case 4UL: 
#line 1086
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1086
    goto ldv_32967;
    case 8UL: 
#line 1086
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1086
    goto ldv_32967;
    default: 
#line 1086
    __bad_percpu_size();
    }
    ldv_32967: 
#line 1086
    pscr_ret__ = pfo_ret_____1;
#line 1086
    goto ldv_32954;
    case 8UL: ;
#line 1086
    switch (4UL) {
    case 1UL: 
#line 1086
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 1086
    goto ldv_32976;
    case 2UL: 
#line 1086
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1086
    goto ldv_32976;
    case 4UL: 
#line 1086
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1086
    goto ldv_32976;
    case 8UL: 
#line 1086
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1086
    goto ldv_32976;
    default: 
#line 1086
    __bad_percpu_size();
    }
    ldv_32976: 
#line 1086
    pscr_ret__ = pfo_ret_____2;
#line 1086
    goto ldv_32954;
    default: 
#line 1086
    __bad_size_call_parameter();
#line 1086
    goto ldv_32954;
    }
    ldv_32954: 
#line 1086
    printk("\017GRU:%d quicktest2: cb %d, exception\n", pscr_ret__, i);
#line 1087
    ret = -14;
  } else
#line 1088
  if (((*(buf + (unsigned long )(i * 4)) != 0UL || *(buf + ((unsigned long )(i * 4) + 1UL)) != 0UL) || *(buf + ((unsigned long )(i * 4) + 2UL)) != 0UL) || *(buf + ((unsigned long )(i * 4) + 3UL)) != 0UL) {
#line 1091
    __vpp_verify___0 = (void const   *)0;
#line 1091
    switch (4UL) {
    case 1UL: ;
#line 1091
    switch (4UL) {
    case 1UL: 
#line 1091
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 1091
    goto ldv_32989;
    case 2UL: 
#line 1091
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 1091
    goto ldv_32989;
    case 4UL: 
#line 1091
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 1091
    goto ldv_32989;
    case 8UL: 
#line 1091
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 1091
    goto ldv_32989;
    default: 
#line 1091
    __bad_percpu_size();
    }
    ldv_32989: 
#line 1091
    pscr_ret_____0 = pfo_ret_____3;
#line 1091
    goto ldv_32995;
    case 2UL: ;
#line 1091
    switch (4UL) {
    case 1UL: 
#line 1091
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 1091
    goto ldv_32999;
    case 2UL: 
#line 1091
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 1091
    goto ldv_32999;
    case 4UL: 
#line 1091
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 1091
    goto ldv_32999;
    case 8UL: 
#line 1091
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 1091
    goto ldv_32999;
    default: 
#line 1091
    __bad_percpu_size();
    }
    ldv_32999: 
#line 1091
    pscr_ret_____0 = pfo_ret_____4;
#line 1091
    goto ldv_32995;
    case 4UL: ;
#line 1091
    switch (4UL) {
    case 1UL: 
#line 1091
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 1091
    goto ldv_33008;
    case 2UL: 
#line 1091
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 1091
    goto ldv_33008;
    case 4UL: 
#line 1091
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 1091
    goto ldv_33008;
    case 8UL: 
#line 1091
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 1091
    goto ldv_33008;
    default: 
#line 1091
    __bad_percpu_size();
    }
    ldv_33008: 
#line 1091
    pscr_ret_____0 = pfo_ret_____5;
#line 1091
    goto ldv_32995;
    case 8UL: ;
#line 1091
    switch (4UL) {
    case 1UL: 
#line 1091
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 1091
    goto ldv_33017;
    case 2UL: 
#line 1091
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 1091
    goto ldv_33017;
    case 4UL: 
#line 1091
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 1091
    goto ldv_33017;
    case 8UL: 
#line 1091
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 1091
    goto ldv_33017;
    default: 
#line 1091
    __bad_percpu_size();
    }
    ldv_33017: 
#line 1091
    pscr_ret_____0 = pfo_ret_____6;
#line 1091
    goto ldv_32995;
    default: 
#line 1091
    __bad_size_call_parameter();
#line 1091
    goto ldv_32995;
    }
    ldv_32995: 
#line 1091
    printk("\017GRU:%d quicktest2:cb %d,  buf 0x%lx, 0x%lx, 0x%lx, 0x%lx\n", pscr_ret_____0,
           i, *(buf + (unsigned long )(i * 4)), *(buf + ((unsigned long )(i * 4) + 1UL)),
           *(buf + ((unsigned long )(i * 4) + 2UL)), *(buf + ((unsigned long )(i * 4) + 3UL)));
#line 1092
    ret = -5;
  } else {

  }
#line 1094
  k = k - 1;
#line 1095
  gen = (struct gru_control_block_status *)cb;
#line 1096
  gen->istatus = 3U;
  ldv_32942: ;
#line 1097
  if (k != 0) {
#line 1099
    goto ldv_33025;
  } else {

  }
#line 1098
  tmp___1 = ldv__builtin_expect(cmp.done != 0U, 0L);
#line 1098
  if (tmp___1 != 0L) {
#line 1098
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"),
                         "i" (1098), "i" (12UL));
    ldv_33027: ;
#line 1098
    goto ldv_33027;
  } else {

  }
#line 1100
  gru_unlock_async_resource(han);
#line 1101
  gru_release_async_resources(han);
  done: 
#line 1103
  kfree((void const   *)buf);
#line 1104
  return (ret);
}
}
#line 1108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
static int quicktest3(unsigned long arg ) 
{ 
  char buf1[200U] ;
  char buf2[200U] ;
  int ret ;
  cycles_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___2 ;

  {
#line 1111
  ret = 0;
#line 1113
  memset((void *)(& buf2), 0, 200UL);
#line 1114
  tmp = get_cycles___0();
#line 1114
  memset((void *)(& buf1), (int )tmp & 255, 200UL);
#line 1115
  tmp___0 = uv_gpa((void *)(& buf1));
#line 1115
  tmp___1 = uv_gpa((void *)(& buf2));
#line 1115
  gru_copy_gpa(tmp___1, tmp___0, 200U);
#line 1116
  tmp___2 = memcmp((void const   *)(& buf1), (void const   *)(& buf2), 200UL);
#line 1116
  if (tmp___2 != 0) {
#line 1117
    __vpp_verify = (void const   *)0;
#line 1117
    switch (4UL) {
    case 1UL: ;
#line 1117
    switch (4UL) {
    case 1UL: 
#line 1117
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 1117
    goto ldv_33039;
    case 2UL: 
#line 1117
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1117
    goto ldv_33039;
    case 4UL: 
#line 1117
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1117
    goto ldv_33039;
    case 8UL: 
#line 1117
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1117
    goto ldv_33039;
    default: 
#line 1117
    __bad_percpu_size();
    }
    ldv_33039: 
#line 1117
    pscr_ret__ = pfo_ret__;
#line 1117
    goto ldv_33045;
    case 2UL: ;
#line 1117
    switch (4UL) {
    case 1UL: 
#line 1117
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 1117
    goto ldv_33049;
    case 2UL: 
#line 1117
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1117
    goto ldv_33049;
    case 4UL: 
#line 1117
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1117
    goto ldv_33049;
    case 8UL: 
#line 1117
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1117
    goto ldv_33049;
    default: 
#line 1117
    __bad_percpu_size();
    }
    ldv_33049: 
#line 1117
    pscr_ret__ = pfo_ret_____0;
#line 1117
    goto ldv_33045;
    case 4UL: ;
#line 1117
    switch (4UL) {
    case 1UL: 
#line 1117
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 1117
    goto ldv_33058;
    case 2UL: 
#line 1117
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1117
    goto ldv_33058;
    case 4UL: 
#line 1117
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1117
    goto ldv_33058;
    case 8UL: 
#line 1117
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1117
    goto ldv_33058;
    default: 
#line 1117
    __bad_percpu_size();
    }
    ldv_33058: 
#line 1117
    pscr_ret__ = pfo_ret_____1;
#line 1117
    goto ldv_33045;
    case 8UL: ;
#line 1117
    switch (4UL) {
    case 1UL: 
#line 1117
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 1117
    goto ldv_33067;
    case 2UL: 
#line 1117
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1117
    goto ldv_33067;
    case 4UL: 
#line 1117
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1117
    goto ldv_33067;
    case 8UL: 
#line 1117
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1117
    goto ldv_33067;
    default: 
#line 1117
    __bad_percpu_size();
    }
    ldv_33067: 
#line 1117
    pscr_ret__ = pfo_ret_____2;
#line 1117
    goto ldv_33045;
    default: 
#line 1117
    __bad_size_call_parameter();
#line 1117
    goto ldv_33045;
    }
    ldv_33045: 
#line 1117
    printk("\017GRU:%d quicktest3 error\n", pscr_ret__);
#line 1118
    ret = -5;
  } else {

  }
#line 1120
  return (ret);
}
}
#line 1127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
int gru_ktest(unsigned long arg ) 
{ 
  int ret ;

  {
#line 1129
  ret = -22;
#line 1131
  switch (arg & 255UL) {
  case 0UL: 
#line 1133
  ret = quicktest0(arg);
#line 1134
  goto ldv_33080;
  case 1UL: 
#line 1136
  ret = quicktest1(arg);
#line 1137
  goto ldv_33080;
  case 2UL: 
#line 1139
  ret = quicktest2(arg);
#line 1140
  goto ldv_33080;
  case 3UL: 
#line 1142
  ret = quicktest3(arg);
#line 1143
  goto ldv_33080;
  case 99UL: 
#line 1145
  ret = gru_free_kernel_contexts();
#line 1146
  goto ldv_33080;
  }
  ldv_33080: ;
#line 1148
  return (ret);
}
}
#line 1152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
int gru_kservices_init(void) 
{ 


  {
#line 1154
  return (0);
}
}
#line 1157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"
void gru_kservices_exit(void) 
{ 
  int tmp ;

  {
#line 1159
  tmp = gru_free_kernel_contexts();
#line 1159
  if (tmp != 0) {
#line 1160
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.c"),
                         "i" (1160), "i" (12UL));
    ldv_33091: ;
#line 1160
    goto ldv_33091;
  } else {

  }
#line 1162
  return;
}
}
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.o.c.prepared"
void ldv_mutex_lock_133(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 146
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 148
  mutex_lock(ldv_func_arg1);
#line 149
  return;
}
}
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.o.c.prepared"
void ldv_mutex_unlock_134(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 154
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 156
  mutex_unlock(ldv_func_arg1);
#line 157
  return;
}
}
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.o.c.prepared"
void ldv_mutex_lock_135(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 162
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 164
  mutex_lock(ldv_func_arg1);
#line 165
  return;
}
}
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.o.c.prepared"
int ldv_mutex_trylock_136(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 171
  tmp = mutex_trylock(ldv_func_arg1);
#line 171
  ldv_func_res = tmp;
#line 173
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 173
  return (tmp___0);
#line 175
  return (ldv_func_res);
}
}
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.o.c.prepared"
void ldv_mutex_unlock_137(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 181
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 183
  mutex_unlock(ldv_func_arg1);
#line 184
  return;
}
}
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.o.c.prepared"
void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 189
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 191
  mutex_unlock(ldv_func_arg1);
#line 192
  return;
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukservices.o.c.prepared"
void ldv_mutex_lock_139(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 197
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 199
  mutex_lock(ldv_func_arg1);
#line 200
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 177 "./arch/x86/include/asm/paravirt.h"
__inline static u64 paravirt_read_tsc___1(void) 
{ 
  u64 __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 179
  __edi = __edi;
#line 179
  __esi = __esi;
#line 179
  __edx = __edx;
#line 179
  __ecx = __ecx;
#line 179
  __eax = __eax;
#line 179
  tmp = ldv__builtin_expect((unsigned long )pv_cpu_ops.read_tsc == (unsigned long )((u64 (*)(void))0),
                         0L);
#line 179
  if (tmp != 0L) {
#line 179
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (179), "i" (12UL));
    ldv_4012: ;
#line 179
    goto ldv_4012;
  } else {

  }
#line 179
  __asm__  volatile   ("771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n": "=D" (__edi),
                       "=S" (__esi), "=d" (__edx), "=c" (__ecx), "=a" (__eax): [paravirt_typenum] "i" (34UL),
                       [paravirt_opptr] "i" (& pv_cpu_ops.read_tsc), [paravirt_clobber] "i" (511): "memory",
                       "cc", "r8", "r9", "r10", "r11");
#line 179
  __ret = (unsigned long long )__eax;
#line 179
  return (__ret);
}
}
#line 43 "./arch/x86/include/asm/atomic64_64.h"
__inline static void atomic64_add(long i , atomic64_t *v ) 
{ 


  {
#line 45
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addq %1,%0": "=m" (v->counter): "er" (i),
                       "m" (v->counter));
#line 48
  return;
}
}
#line 55 "include/asm-generic/atomic-long.h"
__inline static void atomic_long_add(long i , atomic_long_t *l ) 
{ 
  atomic64_t *v ;

  {
#line 57
  v = l;
#line 59
  atomic64_add(i, v);
#line 60
  return;
}
}
#line 177 "include/linux/mutex.h"
void ldv_mutex_unlock_151(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_154(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.o.c.prepared"
void ldv_mutex_lock_152(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_153(struct mutex *ldv_func_arg1 ) ;
#line 18 "./arch/x86/include/asm/tsc.h"
extern unsigned int tsc_khz ;
#line 22 "./arch/x86/include/asm/tsc.h"
__inline static cycles_t get_cycles___1(void) 
{ 
  unsigned long long ret ;

  {
#line 24
  ret = 0ULL;
#line 30
  ret = paravirt_read_tsc___1();
#line 32
  return (ret);
}
}
#line 527 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/gruhandles.h"
void tfh_restart(struct gru_tlb_fault_handle *tfh ) ;
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
struct mcs_op_statistic mcs_op_statistics[8U]  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
static void update_mcs_stats(enum mcs_op op , unsigned long clks ) 
{ 
  unsigned long nsec ;

  {
#line 46
  nsec = (clks * 1000000UL) / (unsigned long )tsc_khz;
#line 47
  atomic_long_inc(& mcs_op_statistics[(unsigned int )op].count);
#line 48
  atomic_long_add((long )nsec, & mcs_op_statistics[(unsigned int )op].total);
#line 49
  if (mcs_op_statistics[(unsigned int )op].max < nsec) {
#line 50
    mcs_op_statistics[(unsigned int )op].max = nsec;
  } else {

  }
#line 51
  return;
}
}
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
static void start_instruction(void *h ) 
{ 
  unsigned long *w0 ;

  {
#line 55
  w0 = (unsigned long *)h;
#line 57
  __asm__  volatile   ("sfence": : : "memory");
#line 58
  *w0 = *w0 | 131073UL;
#line 59
  gru_flush_cache(h);
#line 60
  return;
}
}
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
static void report_instruction_timeout(void *h ) 
{ 
  unsigned long goff ;
  char *id ;

  {
#line 64
  goff = (unsigned long )h & 134217727UL;
#line 65
  id = (char *)"???";
#line 67
  if ((goff > 67239935UL && goff <= 67244031UL) && (goff & 255UL) == 0UL) {
#line 68
    id = (char *)"CCH";
  } else
#line 69
  if ((goff > 67141631UL && goff <= 67147775UL) && (goff & 255UL) == 0UL) {
#line 70
    id = (char *)"TGH";
  } else
#line 71
  if ((goff > 67207167UL && goff <= 67239935UL) && (goff & 255UL) == 0UL) {
#line 72
    id = (char *)"TFH";
  } else {

  }
#line 74
  panic("\tGRU %p (%s) is malfunctioning\n", h, id);
#line 75
  return;
}
}
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
static int wait_instruction_complete(void *h , enum mcs_op opc ) 
{ 
  int status ;
  unsigned long start_time ;
  cycles_t tmp ;
  cycles_t tmp___0 ;
  cycles_t tmp___1 ;
  cycles_t tmp___2 ;

  {
#line 80
  tmp = get_cycles___1();
#line 80
  start_time = (unsigned long )tmp;
  ldv_29301: 
#line 83
  cpu_relax();
#line 84
  status = (int )(*((unsigned long *)h) >> 16) & 3;
#line 85
  if (status != 2) {
#line 86
    goto ldv_29300;
  } else {

  }
#line 87
  tmp___1 = get_cycles___1();
#line 87
  if ((unsigned long long )tsc_khz * 10000ULL < tmp___1 - (unsigned long long )start_time) {
#line 88
    report_instruction_timeout(h);
#line 89
    tmp___0 = get_cycles___1();
#line 89
    start_time = (unsigned long )tmp___0;
  } else {

  }
#line 91
  goto ldv_29301;
  ldv_29300: ;
#line 92
  if ((gru_options & 2UL) != 0UL) {
#line 93
    tmp___2 = get_cycles___1();
#line 93
    update_mcs_stats(opc, (unsigned long )(tmp___2 - (unsigned long long )start_time));
  } else {

  }
#line 94
  return (status);
}
}
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
int cch_allocate(struct gru_context_configuration_handle *cch ) 
{ 
  int ret ;

  {
#line 101
  cch->opc = 2U;
#line 102
  start_instruction((void *)cch);
#line 103
  ret = wait_instruction_complete((void *)cch, 0);
#line 109
  sync_core();
#line 110
  return (ret);
}
}
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
int cch_start(struct gru_context_configuration_handle *cch ) 
{ 
  int tmp ;

  {
#line 115
  cch->opc = 1U;
#line 116
  start_instruction((void *)cch);
#line 117
  tmp = wait_instruction_complete((void *)cch, 1);
#line 117
  return (tmp);
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
int cch_interrupt(struct gru_context_configuration_handle *cch ) 
{ 
  int tmp ;

  {
#line 122
  cch->opc = 3U;
#line 123
  start_instruction((void *)cch);
#line 124
  tmp = wait_instruction_complete((void *)cch, 2);
#line 124
  return (tmp);
}
}
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
int cch_deallocate(struct gru_context_configuration_handle *cch ) 
{ 
  int ret ;

  {
#line 131
  cch->opc = 4U;
#line 132
  start_instruction((void *)cch);
#line 133
  ret = wait_instruction_complete((void *)cch, 4);
#line 139
  sync_core();
#line 140
  return (ret);
}
}
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
int cch_interrupt_sync(struct gru_context_configuration_handle *cch ) 
{ 
  int tmp ;

  {
#line 146
  cch->opc = 5U;
#line 147
  start_instruction((void *)cch);
#line 148
  tmp = wait_instruction_complete((void *)cch, 3);
#line 148
  return (tmp);
}
}
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
int tgh_invalidate(struct gru_tlb_global_handle *tgh , unsigned long vaddr , unsigned long vaddrmask ,
                   int asid , int pagesize , int global , int n , unsigned short ctxbitmap ) 
{ 
  int tmp ;

  {
#line 156
  tgh->vaddr = vaddr;
#line 157
  tgh->asid = (unsigned int )asid;
#line 158
  tgh->pagesize = (unsigned char )pagesize;
#line 159
  tgh->n = (unsigned short )n;
#line 160
  tgh->global = (unsigned char )global;
#line 161
  tgh->vaddrmask = vaddrmask;
#line 162
  tgh->ctxbitmap = ctxbitmap;
#line 163
  tgh->opc = 1U;
#line 164
  start_instruction((void *)tgh);
#line 165
  tmp = wait_instruction_complete((void *)tgh, 7);
#line 165
  return (tmp);
}
}
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
int tfh_write_only(struct gru_tlb_fault_handle *tfh , unsigned long paddr , int gaa ,
                   unsigned long vaddr , int asid , int dirty , int pagesize ) 
{ 
  int tmp ;

  {
#line 173
  tfh->fillasid = (unsigned int )asid;
#line 174
  tfh->fillvaddr = vaddr;
#line 175
  tfh->pfn = paddr >> 12;
#line 176
  tfh->gaa = (unsigned char )gaa;
#line 177
  tfh->dirty = (unsigned char )dirty;
#line 178
  tfh->pagesize = (unsigned char )pagesize;
#line 179
  tfh->opc = 2U;
#line 180
  start_instruction((void *)tfh);
#line 181
  tmp = wait_instruction_complete((void *)tfh, 5);
#line 181
  return (tmp);
}
}
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
void tfh_write_restart(struct gru_tlb_fault_handle *tfh , unsigned long paddr , int gaa ,
                       unsigned long vaddr , int asid , int dirty , int pagesize ) 
{ 


  {
#line 189
  tfh->fillasid = (unsigned int )asid;
#line 190
  tfh->fillvaddr = vaddr;
#line 191
  tfh->pfn = paddr >> 12;
#line 192
  tfh->gaa = (unsigned char )gaa;
#line 193
  tfh->dirty = (unsigned char )dirty;
#line 194
  tfh->pagesize = (unsigned char )pagesize;
#line 195
  tfh->opc = 3U;
#line 196
  start_instruction((void *)tfh);
#line 197
  return;
}
}
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
void tfh_restart(struct gru_tlb_fault_handle *tfh ) 
{ 


  {
#line 201
  tfh->opc = 1U;
#line 202
  start_instruction((void *)tfh);
#line 203
  return;
}
}
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
void tfh_user_polling_mode(struct gru_tlb_fault_handle *tfh ) 
{ 


  {
#line 207
  tfh->opc = 7U;
#line 208
  start_instruction((void *)tfh);
#line 209
  return;
}
}
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.c"
void tfh_exception(struct gru_tlb_fault_handle *tfh ) 
{ 


  {
#line 213
  tfh->opc = 4U;
#line 214
  start_instruction((void *)tfh);
#line 215
  return;
}
}
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.o.c.prepared"
void ldv_mutex_unlock_151(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 146
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 148
  mutex_unlock(ldv_func_arg1);
#line 149
  return;
}
}
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.o.c.prepared"
void ldv_mutex_lock_152(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 154
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 156
  mutex_lock(ldv_func_arg1);
#line 157
  return;
}
}
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.o.c.prepared"
void ldv_mutex_lock_153(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 162
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 164
  mutex_lock(ldv_func_arg1);
#line 165
  return;
}
}
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/gruhandles.o.c.prepared"
void ldv_mutex_unlock_154(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 170
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 172
  mutex_unlock(ldv_func_arg1);
#line 173
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 24 "./arch/x86/include/asm/arch_hweight.h"
__inline static unsigned int __arch_hweight32(unsigned int w ) 
{ 
  unsigned int res ;

  {
#line 26
  res = 0U;
#line 28
  __asm__  ("661:\n\tcall __sw_hweight32\n662:\n.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\n663:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6641f - .\n .word ( 4*32+23)\n .byte 663b-661b\n .byte 6651f-6641f\n .byte 663b-662b\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6641:\n\t.byte 0xf3,0x40,0x0f,0xb8,0xc7\n6651:\n\t.popsection": "=a" (res): "D" (w));
#line 32
  return (res);
}
}
#line 177 "include/linux/mutex.h"
void ldv_mutex_unlock_163(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_166(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukdump.o.c.prepared"
void ldv_mutex_lock_164(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_165(struct mutex *ldv_func_arg1 ) ;
#line 565 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
__inline static int __trylock_handle(void *h ) 
{ 
  int tmp ;

  {
#line 567
  tmp = test_and_set_bit(1L, (unsigned long volatile   *)h);
#line 567
  return (tmp == 0);
}
}
#line 581 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/misc/sgi-gru/grutables.h"
__inline static int trylock_cch_handle(struct gru_context_configuration_handle *cch ) 
{ 
  int tmp ;

  {
#line 583
  tmp = __trylock_handle((void *)cch);
#line 583
  return (tmp);
}
}
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukdump.c"
static int gru_user_copy_handle(void **dp , void *s ) 
{ 
  unsigned long tmp ;

  {
#line 39
  tmp = copy_to_user(*dp, (void const   *)s, 64UL);
#line 39
  if (tmp != 0UL) {
#line 40
    return (-1);
  } else {

  }
#line 41
  *dp = *dp + 64UL;
#line 42
  return (0);
}
}
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukdump.c"
static int gru_dump_context_data(void *grubase , struct gru_context_configuration_handle *cch ,
                                 void *ubuf , int ctxnum , int dsrcnt , int flush_cbrs ) 
{ 
  void *cb ;
  void *cbe ;
  void *tfh ;
  void *gseg ;
  int i ;
  int scr ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 53
  gseg = grubase + (unsigned long )(ctxnum * 4194304);
#line 54
  cb = gseg;
#line 55
  cbe = grubase + 67174400UL;
#line 56
  tfh = grubase + 67207168UL;
#line 58
  tmp = find_first_bit((unsigned long const   *)(& cch->cbr_allocation_map), 64UL);
#line 58
  scr = (int )tmp;
#line 58
  goto ldv_30794;
  ldv_30793: 
#line 58
  i = scr * 2;
#line 58
  goto ldv_30791;
  ldv_30790: ;
#line 59
  if (flush_cbrs != 0) {
#line 60
    gru_flush_cache(cb);
  } else {

  }
#line 61
  tmp___0 = gru_user_copy_handle(& ubuf, cb);
#line 61
  if (tmp___0 != 0) {
#line 62
    goto fail;
  } else {

  }
#line 63
  tmp___1 = gru_user_copy_handle(& ubuf, tfh + (unsigned long )(i * 256));
#line 63
  if (tmp___1 != 0) {
#line 64
    goto fail;
  } else {

  }
#line 65
  tmp___2 = gru_user_copy_handle(& ubuf, cbe + (unsigned long )(i * 256));
#line 65
  if (tmp___2 != 0) {
#line 66
    goto fail;
  } else {

  }
#line 67
  cb = cb + 256UL;
#line 58
  i = i + 1;
  ldv_30791: ;
#line 58
  if ((scr + 1) * 2 > i) {
#line 60
    goto ldv_30790;
  } else {

  }
#line 58
  tmp___3 = find_next_bit((unsigned long const   *)(& cch->cbr_allocation_map), 64UL,
                          (unsigned long )(scr + 1));
#line 58
  scr = (int )tmp___3;
  ldv_30794: ;
#line 58
  if (scr <= 63) {
#line 60
    goto ldv_30793;
  } else {

  }

#line 69
  if (dsrcnt != 0) {
#line 70
    memcpy(ubuf, (void const   *)gseg + 131072U, (size_t )(dsrcnt * 256));
  } else {

  }
#line 71
  return (0);
  fail: ;
#line 74
  return (-14);
}
}
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukdump.c"
static int gru_dump_tfm(struct gru_state *gru , void *ubuf , void *ubufend ) 
{ 
  struct gru_tlb_fault_map *tfm ;
  int i ;
  int ret ;
  int bytes ;
  int tmp ;

  {
#line 83
  bytes = 1024;
#line 84
  if ((long )bytes > (long )ubufend - (long )ubuf) {
#line 85
    ret = -27;
  } else {

  }
#line 87
  i = 0;
#line 87
  goto ldv_30807;
  ldv_30806: 
#line 88
  tfm = get_tfm(gru->gs_gru_base_vaddr, i);
#line 89
  tmp = gru_user_copy_handle(& ubuf, (void *)tfm);
#line 89
  if (tmp != 0) {
#line 90
    goto fail;
  } else {

  }
#line 87
  i = i + 1;
  ldv_30807: ;
#line 87
  if (i <= 15) {
#line 89
    goto ldv_30806;
  } else {

  }

#line 92
  return (1024);
  fail: ;
#line 95
  return (-14);
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukdump.c"
static int gru_dump_tgh(struct gru_state *gru , void *ubuf , void *ubufend ) 
{ 
  struct gru_tlb_global_handle *tgh ;
  int i ;
  int ret ;
  int bytes ;
  int tmp ;

  {
#line 104
  bytes = 1536;
#line 105
  if ((long )bytes > (long )ubufend - (long )ubuf) {
#line 106
    ret = -27;
  } else {

  }
#line 108
  i = 0;
#line 108
  goto ldv_30820;
  ldv_30819: 
#line 109
  tgh = get_tgh(gru->gs_gru_base_vaddr, i);
#line 110
  tmp = gru_user_copy_handle(& ubuf, (void *)tgh);
#line 110
  if (tmp != 0) {
#line 111
    goto fail;
  } else {

  }
#line 108
  i = i + 1;
  ldv_30820: ;
#line 108
  if (i <= 23) {
#line 110
    goto ldv_30819;
  } else {

  }

#line 113
  return (1536);
  fail: ;
#line 116
  return (-14);
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukdump.c"
static int gru_dump_context(struct gru_state *gru , int ctxnum , void *ubuf , void *ubufend ,
                            char data_opt , char lock_cch , char flush_cbrs ) 
{ 
  struct gru_dump_context_header hdr ;
  struct gru_dump_context_header *uhdr ;
  struct gru_context_configuration_handle *cch ;
  struct gru_context_configuration_handle *ubufcch ;
  struct gru_thread_state *gts ;
  int try ;
  int cch_locked ;
  int cbrcnt ;
  int dsrcnt ;
  int bytes ;
  int ret ;
  void *grubase ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned int tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 124
  uhdr = (struct gru_dump_context_header *)ubuf;
#line 127
  cbrcnt = 0;
#line 127
  dsrcnt = 0;
#line 127
  bytes = 0;
#line 127
  ret = 0;
#line 130
  memset((void *)(& hdr), 0, 32UL);
#line 131
  grubase = gru->gs_gru_base_vaddr;
#line 132
  cch = get_cch(grubase, ctxnum);
#line 133
  try = 0;
#line 133
  goto ldv_30845;
  ldv_30844: 
#line 134
  cch_locked = trylock_cch_handle(cch);
#line 135
  if (cch_locked != 0) {
#line 136
    goto ldv_30843;
  } else {

  }
#line 137
  msleep(1U);
#line 133
  try = try + 1;
  ldv_30845: ;
#line 133
  if (try <= 9) {
#line 135
    goto ldv_30844;
  } else {

  }
  ldv_30843: 
#line 140
  ubuf = ubuf + 32UL;
#line 141
  ubufcch = (struct gru_context_configuration_handle *)ubuf;
#line 142
  tmp = gru_user_copy_handle(& ubuf, (void *)cch);
#line 142
  if (tmp != 0) {
#line 143
    if (cch_locked != 0) {
#line 144
      unlock_cch_handle(cch);
    } else {

    }
#line 145
    return (-14);
  } else {

  }
#line 147
  if (cch_locked != 0) {
#line 148
    ubufcch->delresp = 0U;
  } else {

  }
#line 149
  bytes = 96;
#line 151
  if (cch_locked != 0 || (int )((signed char )lock_cch) == 0) {
#line 152
    gts = gru->gs_gts[ctxnum];
#line 153
    if ((unsigned long )gts != (unsigned long )((struct gru_thread_state *)0) && (unsigned long )gts->ts_vma != (unsigned long )((struct vm_area_struct *)0)) {
#line 154
      hdr.pid = gts->ts_tgid_owner;
#line 155
      hdr.vaddr = (gts->ts_vma)->vm_start;
    } else {

    }
#line 157
    if ((unsigned int )*((unsigned char *)cch + 2UL) != 0U) {
#line 158
      tmp___0 = __arch_hweight64((__u64 )cch->cbr_allocation_map);
#line 158
      cbrcnt = (int )((unsigned int )tmp___0 * 2U);
#line 160
      if ((int )((signed char )data_opt) != 0) {
#line 160
        tmp___1 = __arch_hweight32(cch->dsr_allocation_map);
#line 160
        dsrcnt = (int )(tmp___1 * 16U);
      } else {
#line 160
        dsrcnt = 0;
      }
    } else {

    }
#line 163
    bytes = (cbrcnt * 3 + dsrcnt) * 64 + bytes;
#line 164
    if ((long )bytes > (long )ubufend - (long )ubuf) {
#line 165
      ret = -27;
    } else {
#line 167
      ret = gru_dump_context_data(grubase, cch, ubuf, ctxnum, dsrcnt, (int )flush_cbrs);
    }
  } else {

  }
#line 170
  if (cch_locked != 0) {
#line 171
    unlock_cch_handle(cch);
  } else {

  }
#line 172
  if (ret != 0) {
#line 173
    return (ret);
  } else {

  }
#line 175
  hdr.magic = 880061292U;
#line 176
  hdr.gid = (unsigned int )gru->gs_gid;
#line 177
  hdr.ctxnum = (unsigned char )ctxnum;
#line 178
  hdr.cbrcnt = (unsigned char )cbrcnt;
#line 179
  hdr.dsrcnt = (unsigned char )dsrcnt;
#line 180
  hdr.cch_locked = cch_locked;
#line 181
  tmp___2 = copy_to_user((void *)uhdr, (void const   *)(& hdr), 32UL);
#line 181
  if (tmp___2 != 0UL) {
#line 182
    return (-14);
  } else {

  }
#line 184
  return (bytes);
}
}
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukdump.c"
int gru_dump_chiplet_request(unsigned long arg ) 
{ 
  struct gru_state *gru ;
  struct gru_dump_chiplet_state_req req ;
  void *ubuf ;
  void *ubufend ;
  int ctxnum ;
  int ret ;
  int cnt ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 193
  cnt = 0;
#line 195
  tmp = copy_from_user((void *)(& req), (void const   *)arg, 56UL);
#line 195
  if (tmp != 0UL) {
#line 196
    return (-14);
  } else {

  }
#line 199
  if (req.gid >= gru_max_gids) {
#line 200
    return (-22);
  } else {

  }
#line 202
  gru = (unsigned long )gru_base[req.gid / 2U] != (unsigned long )((struct gru_blade_state *)0) ? (struct gru_state *)(& (gru_base[req.gid / 2U])->bs_grus) + ((unsigned long )req.gid & 1UL) : (struct gru_state *)0;
#line 203
  ubuf = req.buf;
#line 204
  ubufend = req.buf + req.buflen;
#line 206
  ret = gru_dump_tfm(gru, ubuf, ubufend);
#line 207
  if (ret < 0) {
#line 208
    goto fail;
  } else {

  }
#line 209
  ubuf = ubuf + (unsigned long )ret;
#line 211
  ret = gru_dump_tgh(gru, ubuf, ubufend);
#line 212
  if (ret < 0) {
#line 213
    goto fail;
  } else {

  }
#line 214
  ubuf = ubuf + (unsigned long )ret;
#line 216
  ctxnum = 0;
#line 216
  goto ldv_30858;
  ldv_30857: ;
#line 217
  if (req.ctxnum == ctxnum || req.ctxnum < 0) {
#line 218
    ret = gru_dump_context(gru, ctxnum, ubuf, ubufend, (int )req.data_opt, (int )req.lock_cch,
                           (int )req.flush_cbrs);
#line 221
    if (ret < 0) {
#line 222
      goto fail;
    } else {

    }
#line 223
    ubuf = ubuf + (unsigned long )ret;
#line 224
    cnt = cnt + 1;
  } else {

  }
#line 216
  ctxnum = ctxnum + 1;
  ldv_30858: ;
#line 216
  if (ctxnum <= 15) {
#line 218
    goto ldv_30857;
  } else {

  }
#line 228
  tmp___0 = copy_to_user((void *)arg, (void const   *)(& req), 56UL);
#line 228
  if (tmp___0 != 0UL) {
#line 229
    return (-14);
  } else {

  }
#line 230
  return (cnt);
  fail: ;
#line 233
  return (ret);
}
}
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukdump.o.c.prepared"
void ldv_mutex_unlock_163(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 146
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 148
  mutex_unlock(ldv_func_arg1);
#line 149
  return;
}
}
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukdump.o.c.prepared"
void ldv_mutex_lock_164(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 154
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 156
  mutex_lock(ldv_func_arg1);
#line 157
  return;
}
}
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukdump.o.c.prepared"
void ldv_mutex_lock_165(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 162
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 164
  mutex_lock(ldv_func_arg1);
#line 165
  return;
}
}
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/dscv/ri/32_7a/drivers/misc/sgi-gru/grukdump.o.c.prepared"
void ldv_mutex_unlock_166(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 170
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 172
  mutex_unlock(ldv_func_arg1);
#line 173
  return;
}
}
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
#line 34
  tmp = ldv_undef_int();
#line 34
  ret = tmp;
#line 36
  if (ret >= 0) {
#line 36
    ldv_stop();
  } else {

  }
#line 38
  return (ret);
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 8 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_i_mutex_of_inode  =    1;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 16
    ldv_error();
  } else {

  }
#line 19
  nondetermined = ldv_undef_int();
#line 22
  if (nondetermined != 0) {
#line 25
    ldv_mutex_i_mutex_of_inode = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 42
    ldv_error();
  } else {

  }
#line 45
  nondetermined = ldv_undef_int();
#line 48
  if (nondetermined != 0) {
#line 51
    ldv_mutex_i_mutex_of_inode = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 66
    ldv_error();
  } else {

  }
#line 68
  ldv_mutex_i_mutex_of_inode = 2;
#line 69
  return;
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 77
    ldv_error();
  } else {

  }
#line 80
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 83
  if (is_mutex_held_by_another_thread != 0) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_i_mutex_of_inode = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 103
    ldv_error();
  } else {

  }
#line 106
  atomic_value_after_dec = ldv_undef_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_i_mutex_of_inode = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_i_mutex_of_inode == 1) {
#line 130
    nondetermined = ldv_undef_int();
#line 133
    if (nondetermined != 0) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_i_mutex_of_inode != 2) {
#line 155
    ldv_error();
  } else {

  }
#line 157
  ldv_mutex_i_mutex_of_inode = 1;
#line 158
  return;
}
}
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_i_mutex_of_inode(void) 
{ 


  {
#line 166
  ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 167
  return;
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_i_mutex_of_inode(void) 
{ 
  int tmp ;

  {
#line 172
  tmp = ldv_mutex_trylock_i_mutex_of_inode((struct mutex *)0);
#line 172
  return (tmp);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_i_mutex_of_inode(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 178
  tmp___0 = ldv_undef_int();
#line 178
  if (tmp___0 != 0) {
#line 180
    ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 182
    return (0);
  } else {
#line 185
    tmp = ldv_undef_int_negative();
#line 185
    return (tmp);
  }
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_i_mutex_of_inode(void) 
{ 


  {
#line 191
  ldv_mutex_unlock_i_mutex_of_inode((struct mutex *)0);
#line 192
  return;
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  =    1;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 202
  if (ldv_mutex_lock != 1) {
#line 202
    ldv_error();
  } else {

  }
#line 205
  nondetermined = ldv_undef_int();
#line 208
  if (nondetermined != 0) {
#line 211
    ldv_mutex_lock = 2;
#line 213
    return (0);
  } else {
#line 218
    return (-4);
  }
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 228
  if (ldv_mutex_lock != 1) {
#line 228
    ldv_error();
  } else {

  }
#line 231
  nondetermined = ldv_undef_int();
#line 234
  if (nondetermined != 0) {
#line 237
    ldv_mutex_lock = 2;
#line 239
    return (0);
  } else {
#line 244
    return (-4);
  }
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 252
  if (ldv_mutex_lock != 1) {
#line 252
    ldv_error();
  } else {

  }
#line 254
  ldv_mutex_lock = 2;
#line 255
  return;
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 263
  if (ldv_mutex_lock != 1) {
#line 263
    ldv_error();
  } else {

  }
#line 266
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 269
  if (is_mutex_held_by_another_thread != 0) {
#line 272
    return (0);
  } else {
#line 277
    ldv_mutex_lock = 2;
#line 279
    return (1);
  }
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 289
  if (ldv_mutex_lock != 1) {
#line 289
    ldv_error();
  } else {

  }
#line 292
  atomic_value_after_dec = ldv_undef_int();
#line 295
  if (atomic_value_after_dec == 0) {
#line 298
    ldv_mutex_lock = 2;
#line 300
    return (1);
  } else {

  }
#line 304
  return (0);
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 313
  if (ldv_mutex_lock == 1) {
#line 316
    nondetermined = ldv_undef_int();
#line 319
    if (nondetermined != 0) {
#line 322
      return (0);
    } else {
#line 327
      return (1);
    }
  } else {
#line 333
    return (1);
  }
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 341
  if (ldv_mutex_lock != 2) {
#line 341
    ldv_error();
  } else {

  }
#line 343
  ldv_mutex_lock = 1;
#line 344
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_lock(void) 
{ 


  {
#line 352
  ldv_mutex_lock_lock((struct mutex *)0);
#line 353
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_lock(void) 
{ 
  int tmp ;

  {
#line 358
  tmp = ldv_mutex_trylock_lock((struct mutex *)0);
#line 358
  return (tmp);
}
}
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_lock(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 364
  tmp___0 = ldv_undef_int();
#line 364
  if (tmp___0 != 0) {
#line 366
    ldv_mutex_lock_lock((struct mutex *)0);
#line 368
    return (0);
  } else {
#line 371
    tmp = ldv_undef_int_negative();
#line 371
    return (tmp);
  }
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_lock(void) 
{ 


  {
#line 377
  ldv_mutex_unlock_lock((struct mutex *)0);
#line 378
  return;
}
}
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_device  =    1;
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 388
  if (ldv_mutex_mutex_of_device != 1) {
#line 388
    ldv_error();
  } else {

  }
#line 391
  nondetermined = ldv_undef_int();
#line 394
  if (nondetermined != 0) {
#line 397
    ldv_mutex_mutex_of_device = 2;
#line 399
    return (0);
  } else {
#line 404
    return (-4);
  }
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 414
  if (ldv_mutex_mutex_of_device != 1) {
#line 414
    ldv_error();
  } else {

  }
#line 417
  nondetermined = ldv_undef_int();
#line 420
  if (nondetermined != 0) {
#line 423
    ldv_mutex_mutex_of_device = 2;
#line 425
    return (0);
  } else {
#line 430
    return (-4);
  }
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 438
  if (ldv_mutex_mutex_of_device != 1) {
#line 438
    ldv_error();
  } else {

  }
#line 440
  ldv_mutex_mutex_of_device = 2;
#line 441
  return;
}
}
#line 444 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 449
  if (ldv_mutex_mutex_of_device != 1) {
#line 449
    ldv_error();
  } else {

  }
#line 452
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 455
  if (is_mutex_held_by_another_thread != 0) {
#line 458
    return (0);
  } else {
#line 463
    ldv_mutex_mutex_of_device = 2;
#line 465
    return (1);
  }
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 475
  if (ldv_mutex_mutex_of_device != 1) {
#line 475
    ldv_error();
  } else {

  }
#line 478
  atomic_value_after_dec = ldv_undef_int();
#line 481
  if (atomic_value_after_dec == 0) {
#line 484
    ldv_mutex_mutex_of_device = 2;
#line 486
    return (1);
  } else {

  }
#line 490
  return (0);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 499
  if (ldv_mutex_mutex_of_device == 1) {
#line 502
    nondetermined = ldv_undef_int();
#line 505
    if (nondetermined != 0) {
#line 508
      return (0);
    } else {
#line 513
      return (1);
    }
  } else {
#line 519
    return (1);
  }
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 527
  if (ldv_mutex_mutex_of_device != 2) {
#line 527
    ldv_error();
  } else {

  }
#line 529
  ldv_mutex_mutex_of_device = 1;
#line 530
  return;
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_mutex_of_device(void) 
{ 


  {
#line 538
  ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 539
  return;
}
}
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_mutex_of_device(void) 
{ 
  int tmp ;

  {
#line 544
  tmp = ldv_mutex_trylock_mutex_of_device((struct mutex *)0);
#line 544
  return (tmp);
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_mutex_of_device(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 550
  tmp___0 = ldv_undef_int();
#line 550
  if (tmp___0 != 0) {
#line 552
    ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 554
    return (0);
  } else {
#line 557
    tmp = ldv_undef_int_negative();
#line 557
    return (tmp);
  }
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_mutex_of_device(void) 
{ 


  {
#line 563
  ldv_mutex_unlock_mutex_of_device((struct mutex *)0);
#line 564
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_ts_ctxlock_of_gru_thread_state  =    1;
#line 569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 574
  if (ldv_mutex_ts_ctxlock_of_gru_thread_state != 1) {
#line 574
    ldv_error();
  } else {

  }
#line 577
  nondetermined = ldv_undef_int();
#line 580
  if (nondetermined != 0) {
#line 583
    ldv_mutex_ts_ctxlock_of_gru_thread_state = 2;
#line 585
    return (0);
  } else {
#line 590
    return (-4);
  }
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 600
  if (ldv_mutex_ts_ctxlock_of_gru_thread_state != 1) {
#line 600
    ldv_error();
  } else {

  }
#line 603
  nondetermined = ldv_undef_int();
#line 606
  if (nondetermined != 0) {
#line 609
    ldv_mutex_ts_ctxlock_of_gru_thread_state = 2;
#line 611
    return (0);
  } else {
#line 616
    return (-4);
  }
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) 
{ 


  {
#line 624
  if (ldv_mutex_ts_ctxlock_of_gru_thread_state != 1) {
#line 624
    ldv_error();
  } else {

  }
#line 626
  ldv_mutex_ts_ctxlock_of_gru_thread_state = 2;
#line 627
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 635
  if (ldv_mutex_ts_ctxlock_of_gru_thread_state != 1) {
#line 635
    ldv_error();
  } else {

  }
#line 638
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 641
  if (is_mutex_held_by_another_thread != 0) {
#line 644
    return (0);
  } else {
#line 649
    ldv_mutex_ts_ctxlock_of_gru_thread_state = 2;
#line 651
    return (1);
  }
}
}
#line 656 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_ts_ctxlock_of_gru_thread_state(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 661
  if (ldv_mutex_ts_ctxlock_of_gru_thread_state != 1) {
#line 661
    ldv_error();
  } else {

  }
#line 664
  atomic_value_after_dec = ldv_undef_int();
#line 667
  if (atomic_value_after_dec == 0) {
#line 670
    ldv_mutex_ts_ctxlock_of_gru_thread_state = 2;
#line 672
    return (1);
  } else {

  }
#line 676
  return (0);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 685
  if (ldv_mutex_ts_ctxlock_of_gru_thread_state == 1) {
#line 688
    nondetermined = ldv_undef_int();
#line 691
    if (nondetermined != 0) {
#line 694
      return (0);
    } else {
#line 699
      return (1);
    }
  } else {
#line 705
    return (1);
  }
}
}
#line 710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) 
{ 


  {
#line 713
  if (ldv_mutex_ts_ctxlock_of_gru_thread_state != 2) {
#line 713
    ldv_error();
  } else {

  }
#line 715
  ldv_mutex_ts_ctxlock_of_gru_thread_state = 1;
#line 716
  return;
}
}
#line 721 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_ts_ctxlock_of_gru_thread_state(void) 
{ 


  {
#line 724
  ldv_mutex_lock_ts_ctxlock_of_gru_thread_state((struct mutex *)0);
#line 725
  return;
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_ts_ctxlock_of_gru_thread_state(void) 
{ 
  int tmp ;

  {
#line 730
  tmp = ldv_mutex_trylock_ts_ctxlock_of_gru_thread_state((struct mutex *)0);
#line 730
  return (tmp);
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_ts_ctxlock_of_gru_thread_state(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 736
  tmp___0 = ldv_undef_int();
#line 736
  if (tmp___0 != 0) {
#line 738
    ldv_mutex_lock_ts_ctxlock_of_gru_thread_state((struct mutex *)0);
#line 740
    return (0);
  } else {
#line 743
    tmp = ldv_undef_int_negative();
#line 743
    return (tmp);
  }
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_ts_ctxlock_of_gru_thread_state(void) 
{ 


  {
#line 749
  ldv_mutex_unlock_ts_ctxlock_of_gru_thread_state((struct mutex *)0);
#line 750
  return;
}
}
#line 754 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/1565/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 757
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 757
    ldv_error();
  } else {

  }
#line 759
  if (ldv_mutex_lock != 1) {
#line 759
    ldv_error();
  } else {

  }
#line 761
  if (ldv_mutex_mutex_of_device != 1) {
#line 761
    ldv_error();
  } else {

  }
#line 763
  if (ldv_mutex_ts_ctxlock_of_gru_thread_state != 1) {
#line 763
    ldv_error();
  } else {

  }
#line 767
  return;
}
}
